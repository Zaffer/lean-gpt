{"path": "Mathlib/GroupTheory/GroupAction/Group.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Units.lean", "Mathlib/Algebra/Hom/Aut.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RightCancelMonoid.faithfulSMul", "code": "@[to_additive \" `AddMonoid.toAddAction` is faithful on additive cancellative monoids. \"]\ninstance RightCancelMonoid.faithfulSMul [RightCancelMonoid \u03b1] : FaithfulSMul \u03b1 \u03b1 :=\n  \u27e8fun h => mul_right_cancel (h 1)\u27e9", "start": [24, 1], "end": [27, 36], "kind": "commanddeclaration"}, {"full_name": "inv_smul_smul", "code": "@[to_additive (attr := simp)]\ntheorem inv_smul_smul (c : \u03b1) (x : \u03b2) : c\u207b\u00b9 \u2022 c \u2022 x = x", "start": [35, 1], "end": [36, 101], "kind": "commanddeclaration"}, {"full_name": "smul_inv_smul", "code": "@[to_additive (attr := simp)]\ntheorem smul_inv_smul (c : \u03b1) (x : \u03b2) : c \u2022 c\u207b\u00b9 \u2022 x = x", "start": [40, 1], "end": [42, 42], "kind": "commanddeclaration"}, {"full_name": "MulAction.toPerm", "code": "@[to_additive (attr := simps)]\ndef MulAction.toPerm (a : \u03b1) : Equiv.Perm \u03b2 :=\n  \u27e8fun x => a \u2022 x, fun x => a\u207b\u00b9 \u2022 x, inv_smul_smul a, smul_inv_smul a\u27e9", "start": [46, 1], "end": [49, 71], "kind": "commanddeclaration"}, {"full_name": "MulAction.toPerm_injective", "code": "@[to_additive \"`AddAction.toPerm` is injective on faithful actions.\"]\ntheorem MulAction.toPerm_injective [FaithfulSMul \u03b1 \u03b2] :\n    Function.Injective (MulAction.toPerm : \u03b1 \u2192 Equiv.Perm \u03b2)", "start": [60, 1], "end": [64, 95], "kind": "commanddeclaration"}, {"full_name": "MulAction.toPermHom", "code": "@[simps]\ndef MulAction.toPermHom : \u03b1 \u2192* Equiv.Perm \u03b2 where\n  toFun := MulAction.toPerm\n  map_one' := Equiv.ext <| one_smul \u03b1\n  map_mul' u\u2081 u\u2082 := Equiv.ext <| mul_smul (u\u2081 : \u03b1) u\u2082", "start": [70, 1], "end": [75, 54], "kind": "commanddeclaration"}, {"full_name": "AddAction.toPermHom", "code": "@[simps!]\ndef AddAction.toPermHom (\u03b1 : Type*) [AddGroup \u03b1] [AddAction \u03b1 \u03b2] :\n    \u03b1 \u2192+ Additive (Equiv.Perm \u03b2) :=\n  MonoidHom.toAdditive'' <| MulAction.toPermHom (Multiplicative \u03b1) \u03b2", "start": [79, 1], "end": [84, 69], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.applyMulAction", "code": "instance Equiv.Perm.applyMulAction (\u03b1 : Type*) : MulAction (Equiv.Perm \u03b1) \u03b1 where\n  smul f a := f a\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [87, 1], "end": [93, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.smul_def", "code": "@[simp]\nprotected theorem Equiv.Perm.smul_def {\u03b1 : Type*} (f : Equiv.Perm \u03b1) (a : \u03b1) : f \u2022 a = f a", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.applyFaithfulSMul", "code": "instance Equiv.Perm.applyFaithfulSMul (\u03b1 : Type*) : FaithfulSMul (Equiv.Perm \u03b1) \u03b1 :=\n  \u27e8Equiv.ext\u27e9", "start": [101, 1], "end": [103, 14], "kind": "commanddeclaration"}, {"full_name": "inv_smul_eq_iff", "code": "@[to_additive]\ntheorem inv_smul_eq_iff {a : \u03b1} {x y : \u03b2} : a\u207b\u00b9 \u2022 x = y \u2194 x = a \u2022 y", "start": [108, 1], "end": [110, 37], "kind": "commanddeclaration"}, {"full_name": "eq_inv_smul_iff", "code": "@[to_additive]\ntheorem eq_inv_smul_iff {a : \u03b1} {x y : \u03b2} : x = a\u207b\u00b9 \u2022 y \u2194 a \u2022 x = y", "start": [114, 1], "end": [116, 37], "kind": "commanddeclaration"}, {"full_name": "smul_inv", "code": "theorem smul_inv [Group \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (c : \u03b1) (x : \u03b2) :\n    (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9", "start": [120, 1], "end": [122, 84], "kind": "commanddeclaration"}, {"full_name": "smul_zpow", "code": "theorem smul_zpow [Group \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (c : \u03b1) (x : \u03b2) (p : \u2124) :\n    (c \u2022 x) ^ p = c ^ p \u2022 x ^ p", "start": [125, 1], "end": [128, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_right_iff", "code": "@[simp]\ntheorem Commute.smul_right_iff [Mul \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] {a b : \u03b2}\n    (r : \u03b1) : Commute a (r \u2022 b) \u2194 Commute a b", "start": [131, 1], "end": [134, 75], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_left_iff", "code": "@[simp]\ntheorem Commute.smul_left_iff [Mul \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] {a b : \u03b2}\n    (r : \u03b1) : Commute (r \u2022 a) b \u2194 Commute a b", "start": [137, 1], "end": [140, 66], "kind": "commanddeclaration"}, {"full_name": "MulAction.bijective", "code": "@[to_additive]\nprotected theorem MulAction.bijective (g : \u03b1) : Function.Bijective ((\u00b7 \u2022 \u00b7) g : \u03b2 \u2192 \u03b2)", "start": [143, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "MulAction.injective", "code": "@[to_additive]\nprotected theorem MulAction.injective (g : \u03b1) : Function.Injective ((\u00b7 \u2022 \u00b7) g : \u03b2 \u2192 \u03b2)", "start": [149, 1], "end": [151, 36], "kind": "commanddeclaration"}, {"full_name": "MulAction.surjective", "code": "@[to_additive]\nprotected theorem MulAction.surjective (g : \u03b1) : Function.Surjective ((\u00b7 \u2022 \u00b7) g : \u03b2 \u2192 \u03b2)", "start": [155, 1], "end": [157, 37], "kind": "commanddeclaration"}, {"full_name": "smul_left_cancel", "code": "@[to_additive]\ntheorem smul_left_cancel (g : \u03b1) {x y : \u03b2} (h : g \u2022 x = g \u2022 y) : x = y", "start": [161, 1], "end": [163, 26], "kind": "commanddeclaration"}, {"full_name": "smul_left_cancel_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_left_cancel_iff (g : \u03b1) {x y : \u03b2} : g \u2022 x = g \u2022 y \u2194 x = y", "start": [167, 1], "end": [169, 33], "kind": "commanddeclaration"}, {"full_name": "smul_eq_iff_eq_inv_smul", "code": "@[to_additive]\ntheorem smul_eq_iff_eq_inv_smul (g : \u03b1) {x y : \u03b2} : g \u2022 x = y \u2194 x = g\u207b\u00b9 \u2022 y", "start": [173, 1], "end": [175, 50], "kind": "commanddeclaration"}, {"full_name": "CancelMonoidWithZero.faithfulSMul", "code": "instance CancelMonoidWithZero.faithfulSMul [CancelMonoidWithZero \u03b1] [Nontrivial \u03b1] :\n    FaithfulSMul \u03b1 \u03b1 :=\n  \u27e8fun h => mul_left_injective\u2080 one_ne_zero (h 1)\u27e9", "start": [181, 1], "end": [184, 51], "kind": "commanddeclaration"}, {"full_name": "inv_smul_smul\u2080", "code": "@[simp]\ntheorem inv_smul_smul\u2080 {c : \u03b1} (hc : c \u2260 0) (x : \u03b2) : c\u207b\u00b9 \u2022 c \u2022 x = x", "start": [191, 1], "end": [193, 35], "kind": "commanddeclaration"}, {"full_name": "smul_inv_smul\u2080", "code": "@[simp]\ntheorem smul_inv_smul\u2080 {c : \u03b1} (hc : c \u2260 0) (x : \u03b2) : c \u2022 c\u207b\u00b9 \u2022 x = x", "start": [196, 1], "end": [198, 35], "kind": "commanddeclaration"}, {"full_name": "inv_smul_eq_iff\u2080", "code": "theorem inv_smul_eq_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {x y : \u03b2} : a\u207b\u00b9 \u2022 x = y \u2194 x = a \u2022 y", "start": [201, 1], "end": [202, 83], "kind": "commanddeclaration"}, {"full_name": "eq_inv_smul_iff\u2080", "code": "theorem eq_inv_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {x y : \u03b2} : x = a\u207b\u00b9 \u2022 y \u2194 a \u2022 x = y", "start": [205, 1], "end": [206, 52], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_right_iff\u2080", "code": "@[simp]\ntheorem Commute.smul_right_iff\u2080 [Mul \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] {a b : \u03b2}\n    {c : \u03b1} (hc : c \u2260 0) : Commute a (c \u2022 b) \u2194 Commute a b", "start": [209, 1], "end": [212, 42], "kind": "commanddeclaration"}, {"full_name": "Commute.smul_left_iff\u2080", "code": "@[simp]\ntheorem Commute.smul_left_iff\u2080 [Mul \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] {a b : \u03b2} {c : \u03b1}\n    (hc : c \u2260 0) : Commute (c \u2022 a) b \u2194 Commute a b", "start": [215, 1], "end": [218, 41], "kind": "commanddeclaration"}, {"full_name": "MulAction.bijective\u2080", "code": "protected theorem MulAction.bijective\u2080 (ha : a \u2260 0) : Function.Bijective ((\u00b7 \u2022 \u00b7) a : \u03b2 \u2192 \u03b2)", "start": [221, 1], "end": [222, 40], "kind": "commanddeclaration"}, {"full_name": "MulAction.injective\u2080", "code": "protected theorem MulAction.injective\u2080 (ha : a \u2260 0) : Function.Injective ((\u00b7 \u2022 \u00b7) a : \u03b2 \u2192 \u03b2)", "start": [225, 1], "end": [226, 38], "kind": "commanddeclaration"}, {"full_name": "MulAction.surjective\u2080", "code": "protected theorem MulAction.surjective\u2080 (ha : a \u2260 0) : Function.Surjective ((\u00b7 \u2022 \u00b7) a : \u03b2 \u2192 \u03b2)", "start": [229, 1], "end": [230, 39], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toAddEquiv", "code": "@[simps (config := { simpRhs := true })]\ndef DistribMulAction.toAddEquiv (x : \u03b1) : \u03b2 \u2243+ \u03b2 :=\n  { DistribMulAction.toAddMonoidHom \u03b2 x, MulAction.toPermHom \u03b1 \u03b2 x with }", "start": [245, 1], "end": [250, 74], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toAddAut", "code": "@[simps]\ndef DistribMulAction.toAddAut : \u03b1 \u2192* AddAut \u03b2 where\n  toFun := DistribMulAction.toAddEquiv \u03b2\n  map_one' := AddEquiv.ext (one_smul _)\n  map_mul' _ _ := AddEquiv.ext (mul_smul _ _)", "start": [257, 1], "end": [264, 46], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toAddEquiv\u2080", "code": "def DistribMulAction.toAddEquiv\u2080 {\u03b1 : Type*} (\u03b2 : Type*) [GroupWithZero \u03b1] [AddMonoid \u03b2]\n    [DistribMulAction \u03b1 \u03b2] (x : \u03b1) (hx : x \u2260 0) : \u03b2 \u2243+ \u03b2 :=\n  { DistribMulAction.toAddMonoidHom \u03b2 x with\n    invFun := fun b \u21a6 x\u207b\u00b9 \u2022 b\n    left_inv := fun b \u21a6 inv_smul_smul\u2080 hx b\n    right_inv := fun b \u21a6 smul_inv_smul\u2080 hx b }", "start": [268, 1], "end": [276, 47], "kind": "commanddeclaration"}, {"full_name": "smul_eq_zero_iff_eq", "code": "theorem smul_eq_zero_iff_eq (a : \u03b1) {x : \u03b2} : a \u2022 x = 0 \u2194 x = 0", "start": [280, 1], "end": [281, 86], "kind": "commanddeclaration"}, {"full_name": "smul_ne_zero_iff_ne", "code": "theorem smul_ne_zero_iff_ne (a : \u03b1) {x : \u03b2} : a \u2022 x \u2260 0 \u2194 x \u2260 0", "start": [284, 1], "end": [285, 37], "kind": "commanddeclaration"}, {"full_name": "smul_eq_zero_iff_eq'", "code": "theorem smul_eq_zero_iff_eq' {a : \u03b1} (ha : a \u2260 0) {x : \u03b2} : a \u2022 x = 0 \u2194 x = 0", "start": [294, 1], "end": [295, 65], "kind": "commanddeclaration"}, {"full_name": "smul_ne_zero_iff_ne'", "code": "theorem smul_ne_zero_iff_ne' {a : \u03b1} (ha : a \u2260 0) {x : \u03b2} : a \u2022 x \u2260 0 \u2194 x \u2260 0", "start": [298, 1], "end": [299, 65], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.toMulEquiv", "code": "@[simps (config := { simpRhs := true })]\ndef MulDistribMulAction.toMulEquiv (x : \u03b1) : \u03b2 \u2243* \u03b2 :=\n  { MulDistribMulAction.toMonoidHom \u03b2 x, MulAction.toPermHom \u03b1 \u03b2 x with }", "start": [312, 1], "end": [317, 74], "kind": "commanddeclaration"}, {"full_name": "MulDistribMulAction.toMulAut", "code": "@[simps]\ndef MulDistribMulAction.toMulAut : \u03b1 \u2192* MulAut \u03b2 where\n  toFun := MulDistribMulAction.toMulEquiv \u03b2\n  map_one' := MulEquiv.ext (one_smul _)\n  map_mul' _ _ := MulEquiv.ext (mul_smul _ _)", "start": [324, 1], "end": [331, 46], "kind": "commanddeclaration"}, {"full_name": "arrowAction", "code": "@[to_additive (attr := simps) arrowAddAction\n      \"If `G` acts on `A`, then it acts also on `A \u2192 B`, by `(g +\u1d65 F) a = F (g\u207b\u00b9 +\u1d65 a)`\"]\ndef arrowAction {G A B : Type*} [DivisionMonoid G] [MulAction G A] : MulAction G (A \u2192 B) where\n  smul g F a := F (g\u207b\u00b9 \u2022 a)\n  one_smul := by\n    intro f\n    show (fun x => f ((1 : G)\u207b\u00b9 \u2022 x)) = f\n    simp only [inv_one, one_smul]\n  mul_smul := by\n    intros x y f\n    show (fun a => f ((x*y)\u207b\u00b9 \u2022 a)) = (fun a => f (y\u207b\u00b9 \u2022 x\u207b\u00b9 \u2022 a))\n    simp only [mul_smul, mul_inv_rev]", "start": [341, 1], "end": [353, 38], "kind": "commanddeclaration"}, {"full_name": "arrowMulDistribMulAction", "code": "def arrowMulDistribMulAction {G A B : Type*} [Group G] [MulAction G A] [Monoid B] :\n    MulDistribMulAction G (A \u2192 B) where\n  smul_one _ := rfl\n  smul_mul _ _ _ := rfl", "start": [359, 1], "end": [363, 24], "kind": "commanddeclaration"}, {"full_name": "mulAutArrow", "code": "@[simps!]\ndef mulAutArrow {G A H} [Group G] [MulAction G A] [Monoid H] : G \u2192* MulAut (A \u2192 H) :=\n  MulDistribMulAction.toMulAut _ _", "start": [368, 1], "end": [372, 35], "kind": "commanddeclaration"}, {"full_name": "IsUnit.smul_left_cancel", "code": "@[to_additive]\ntheorem smul_left_cancel {a : \u03b1} (ha : IsUnit a) {x y : \u03b2} : a \u2022 x = a \u2022 y \u2194 x = y", "start": [385, 1], "end": [388, 30], "kind": "commanddeclaration"}, {"full_name": "IsUnit.smul_eq_zero", "code": "@[simp]\ntheorem smul_eq_zero {u : \u03b1} (hu : IsUnit u) {x : \u03b2} : u \u2022 x = 0 \u2194 x = 0", "start": [398, 1], "end": [400, 86], "kind": "commanddeclaration"}, {"full_name": "isUnit_smul_iff", "code": "@[simp]\ntheorem isUnit_smul_iff [MulAction \u03b1 \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (g : \u03b1)\n    (m : \u03b2) : IsUnit (g \u2022 m) \u2194 IsUnit m", "start": [411, 1], "end": [414, 59], "kind": "commanddeclaration"}, {"full_name": "IsUnit.smul_sub_iff_sub_inv_smul", "code": "theorem IsUnit.smul_sub_iff_sub_inv_smul [AddGroup \u03b2] [DistribMulAction \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2]\n    [SMulCommClass \u03b1 \u03b2 \u03b2] (r : \u03b1) (a : \u03b2) : IsUnit (r \u2022 (1 : \u03b2) - a) \u2194 IsUnit (1 - r\u207b\u00b9 \u2022 a)", "start": [417, 1], "end": [419, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/SMulWithZero.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Prod.lean", "Mathlib/GroupTheory/GroupAction/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Algebra/Ring/Opposite.lean"], "premises": [{"full_name": "SMulWithZero", "code": "class SMulWithZero [Zero R] [Zero M] extends SMulZeroClass R M where\n  \n  zero_smul : \u2200 m : M, (0 : R) \u2022 m = 0", "start": [46, 1], "end": [51, 39], "kind": "commanddeclaration"}, {"full_name": "MulZeroClass.toSMulWithZero", "code": "instance MulZeroClass.toSMulWithZero [MulZeroClass R] : SMulWithZero R R where\n  smul := (\u00b7 * \u00b7)\n  smul_zero := mul_zero\n  zero_smul := zero_mul", "start": [54, 1], "end": [57, 24], "kind": "commanddeclaration"}, {"full_name": "MulZeroClass.toOppositeSMulWithZero", "code": "instance MulZeroClass.toOppositeSMulWithZero [MulZeroClass R] : SMulWithZero R\u1d50\u1d52\u1d56 R where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_zero _ := zero_mul _\n  zero_smul := mul_zero", "start": [60, 1], "end": [64, 24], "kind": "commanddeclaration"}, {"full_name": "zero_smul", "code": "@[simp]\ntheorem zero_smul (m : M) : (0 : R) \u2022 m = 0", "start": [69, 1], "end": [71, 27], "kind": "commanddeclaration"}, {"full_name": "smul_eq_zero_of_left", "code": "lemma smul_eq_zero_of_left (h : a = 0) (b : M) : a \u2022 b = 0 := h.symm \u25b8 zero_smul _ b", "start": [76, 1], "end": [76, 85], "kind": "mathlibtacticlemma"}, {"full_name": "smul_eq_zero_of_right", "code": "lemma smul_eq_zero_of_right (a : R) (h : b = 0) : a \u2022 b = 0 := h.symm \u25b8 smul_zero a", "start": [78, 1], "end": [78, 84], "kind": "mathlibtacticlemma"}, {"full_name": "left_ne_zero_of_smul", "code": "lemma left_ne_zero_of_smul : a \u2022 b \u2260 0 \u2192 a \u2260 0 := mt $ fun h \u21a6 smul_eq_zero_of_left h b", "start": [80, 1], "end": [80, 88], "kind": "mathlibtacticlemma"}, {"full_name": "right_ne_zero_of_smul", "code": "lemma right_ne_zero_of_smul : a \u2022 b \u2260 0 \u2192 b \u2260 0 := mt $ smul_eq_zero_of_right a", "start": [82, 1], "end": [82, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.smulWithZero", "code": "@[reducible]\nprotected def Function.Injective.smulWithZero (f : ZeroHom M' M) (hf : Function.Injective f)\n    (smul : \u2200 (a : R) (b), f (a \u2022 b) = a \u2022 f b) :\n    SMulWithZero R M' where\n  smul := (\u00b7 \u2022 \u00b7)\n  zero_smul a := hf <| by simp [smul]\n  smul_zero a := hf <| by simp [smul]", "start": [87, 1], "end": [95, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.smulWithZero", "code": "@[reducible]\nprotected def Function.Surjective.smulWithZero (f : ZeroHom M M') (hf : Function.Surjective f)\n    (smul : \u2200 (a : R) (b), f (a \u2022 b) = a \u2022 f b) :\n    SMulWithZero R M' where\n  smul := (\u00b7 \u2022 \u00b7)\n  zero_smul m := by\n    rcases hf m with \u27e8x, rfl\u27e9\n    simp [\u2190 smul]\n  smul_zero c := by rw [\u2190f.map_zero, \u2190smul, smul_zero]", "start": [98, 1], "end": [108, 55], "kind": "commanddeclaration"}, {"full_name": "SMulWithZero.compHom", "code": "def SMulWithZero.compHom (f : ZeroHom R' R) : SMulWithZero R' M where\n  smul := (\u00b7 \u2022 \u00b7) \u2218 f\n  smul_zero m := smul_zero (f m)\n  zero_smul m := by show (f 0) \u2022 m = 0; rw [map_zero, zero_smul]", "start": [113, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.natSMulWithZero", "code": "instance AddMonoid.natSMulWithZero [AddMonoid M] : SMulWithZero \u2115 M where\n  smul_zero := _root_.nsmul_zero\n  zero_smul := zero_nsmul", "start": [122, 1], "end": [124, 26], "kind": "commanddeclaration"}, {"full_name": "AddGroup.intSMulWithZero", "code": "instance AddGroup.intSMulWithZero [AddGroup M] : SMulWithZero \u2124 M where\n  smul_zero := zsmul_zero\n  zero_smul := zero_zsmul", "start": [127, 1], "end": [129, 26], "kind": "commanddeclaration"}, {"full_name": "MulActionWithZero", "code": "class MulActionWithZero extends MulAction R M where\n  \n  smul_zero : \u2200 r : R, r \u2022 (0 : M) = 0\n  \n  zero_smul : \u2200 m : M, (0 : R) \u2022 m = 0", "start": [138, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "MulActionWithZero.toSMulWithZero", "code": "instance (priority := 100) MulActionWithZero.toSMulWithZero [m : MulActionWithZero R M] :\n    SMulWithZero R M :=\n  { m with }", "start": [150, 1], "end": [152, 13], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero.toMulActionWithZero", "code": "instance MonoidWithZero.toMulActionWithZero : MulActionWithZero R R :=\n  { MulZeroClass.toSMulWithZero R, Monoid.toMulAction R with }", "start": [155, 1], "end": [157, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZero.toOppositeMulActionWithZero", "code": "instance MonoidWithZero.toOppositeMulActionWithZero : MulActionWithZero R\u1d50\u1d52\u1d56 R :=\n  { MulZeroClass.toOppositeSMulWithZero R, Monoid.toOppositeMulAction R with }", "start": [160, 1], "end": [163, 79], "kind": "commanddeclaration"}, {"full_name": "MulActionWithZero.subsingleton", "code": "protected lemma MulActionWithZero.subsingleton\n    [MulActionWithZero R M] [Subsingleton R] : Subsingleton M :=\n  \u27e8\u03bb x y => by rw [\u2190one_smul R x, \u2190one_smul R y, Subsingleton.elim (1 : R) 0, zero_smul, zero_smul]\u27e9", "start": [166, 1], "end": [168, 101], "kind": "mathlibtacticlemma"}, {"full_name": "MulActionWithZero.nontrivial", "code": "protected lemma MulActionWithZero.nontrivial\n    [MulActionWithZero R M] [Nontrivial M] : Nontrivial R :=\n  (subsingleton_or_nontrivial R).resolve_left fun _ =>\n    not_subsingleton M <| MulActionWithZero.subsingleton R M", "start": [171, 1], "end": [174, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Function.Injective.mulActionWithZero", "code": "@[reducible]\nprotected def Function.Injective.mulActionWithZero (f : ZeroHom M' M) (hf : Function.Injective f)\n    (smul : \u2200 (a : R) (b), f (a \u2022 b) = a \u2022 f b) : MulActionWithZero R M' :=\n  { hf.mulAction f smul, hf.smulWithZero f smul with }", "start": [180, 1], "end": [185, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.mulActionWithZero", "code": "@[reducible]\nprotected def Function.Surjective.mulActionWithZero (f : ZeroHom M M') (hf : Function.Surjective f)\n    (smul : \u2200 (a : R) (b), f (a \u2022 b) = a \u2022 f b) : MulActionWithZero R M' :=\n  { hf.mulAction f smul, hf.smulWithZero f smul with }", "start": [188, 1], "end": [193, 55], "kind": "commanddeclaration"}, {"full_name": "MulActionWithZero.compHom", "code": "def MulActionWithZero.compHom (f : R' \u2192*\u2080 R) : MulActionWithZero R' M :=\n  { SMulWithZero.compHom M f.toZeroHom with\n    mul_smul := fun r s m => by show f (r * s) \u2022 m = (f r) \u2022 (f s) \u2022 m; simp [mul_smul]\n    one_smul := fun m => by show (f 1) \u2022 m = m; simp }", "start": [198, 1], "end": [202, 55], "kind": "commanddeclaration"}, {"full_name": "smul_inv\u2080", "code": "theorem smul_inv\u2080 [SMulCommClass \u03b1 \u03b2 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] (c : \u03b1) (x : \u03b2) :\n    (c \u2022 x)\u207b\u00b9 = c\u207b\u00b9 \u2022 x\u207b\u00b9", "start": [211, 1], "end": [218, 71], "kind": "commanddeclaration"}, {"full_name": "smulMonoidWithZeroHom", "code": "@[simps]\ndef smulMonoidWithZeroHom {\u03b1 \u03b2 : Type*} [MonoidWithZero \u03b1] [MulZeroOneClass \u03b2]\n    [MulActionWithZero \u03b1 \u03b2] [IsScalarTower \u03b1 \u03b2 \u03b2] [SMulCommClass \u03b1 \u03b2 \u03b2] : \u03b1 \u00d7 \u03b2 \u2192*\u2080 \u03b2 :=\n  { smulMonoidHom with map_zero' := smul_zero _ }", "start": [223, 1], "end": [227, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Abel.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Util/AtomM.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Abel.Context", "code": "structure Context where\n  \n  \u03b1       : Expr\n  \n  univ    : Level\n  \n  \u03b10      : Expr\n  \n  isGroup : Bool\n  \n  inst    : Expr", "start": [25, 1], "end": [40, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.mkContext", "code": "def mkContext (e : Expr) : MetaM Context := do\n  let \u03b1 \u2190 inferType e\n  let c \u2190 synthInstance (\u2190 mkAppM ``AddCommMonoid #[\u03b1])\n  let cg \u2190 synthInstance? (\u2190 mkAppM ``AddCommGroup #[\u03b1])\n  let u \u2190 mkFreshLevelMVar\n  _ \u2190 isDefEq (.sort (.succ u)) (\u2190 inferType \u03b1)\n  let \u03b10 \u2190 Expr.ofNat \u03b1 0\n  match cg with\n  | some cg => return \u27e8\u03b1, u, \u03b10, true, cg\u27e9\n  | _ => return \u27e8\u03b1, u, \u03b10, false, c\u27e9", "start": [42, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.M", "code": "abbrev M := ReaderT Context AtomM", "start": [54, 1], "end": [57, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.Context.app", "code": "def Context.app (c : Context) (n : Name) (inst : Expr) : Array Expr \u2192 Expr :=\n  mkAppN (((@Expr.const n [c.univ]).app c.\u03b1).app inst)", "start": [59, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.Context.mkApp", "code": "def Context.mkApp (c : Context) (n inst : Name) (l : Array Expr) : MetaM Expr := do\n  return c.app n (\u2190 synthInstance ((Expr.const inst [c.univ]).app c.\u03b1)) l", "start": [64, 1], "end": [71, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.addG", "code": "def addG : Name \u2192 Name\n  | .str p s => .str p (s ++ \"g\")\n  | n => n", "start": [73, 1], "end": [80, 11], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.iapp", "code": "def iapp (n : Name) (xs : Array Expr) : M Expr := do\n  let c \u2190 read\n  return c.app (if c.isGroup then addG n else n) c.inst xs", "start": [82, 1], "end": [88, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term", "code": "def term {\u03b1} [AddCommMonoid \u03b1] (n : \u2115) (x a : \u03b1) : \u03b1 := n \u2022 x + a", "start": [90, 1], "end": [91, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.termg", "code": "def termg {\u03b1} [AddCommGroup \u03b1] (n : \u2124) (x a : \u03b1) : \u03b1 := n \u2022 x + a", "start": [92, 1], "end": [93, 66], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.mkTerm", "code": "def mkTerm (n x a : Expr) : M Expr := iapp ``term #[n, x, a]", "start": [95, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.intToExpr", "code": "def intToExpr (n : \u2124) : M Expr := do\n  Expr.ofInt (mkConst (if (\u2190 read).isGroup then ``Int else ``Nat) []) n", "start": [98, 1], "end": [100, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.NormalExpr", "code": "inductive NormalExpr : Type\n  | zero (e : Expr) : NormalExpr\n  | nterm (e : Expr) (n : Expr \u00d7 \u2124) (x : \u2115 \u00d7 Expr) (a : NormalExpr) : NormalExpr\n  deriving Inhabited", "start": [102, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.NormalExpr.e", "code": "def NormalExpr.e : NormalExpr \u2192 Expr\n  | .zero e => e\n  | .nterm e .. => e", "start": [112, 1], "end": [115, 21], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.NormalExpr.term'", "code": "def NormalExpr.term' (n : Expr \u00d7 \u2124) (x : \u2115 \u00d7 Expr) (a : NormalExpr) : M NormalExpr :=\n  return .nterm (\u2190 mkTerm n.1 x.2 a) n x a", "start": [119, 1], "end": [121, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.NormalExpr.zero'", "code": "def NormalExpr.zero' : M NormalExpr := return NormalExpr.zero (\u2190 read).\u03b10", "start": [123, 1], "end": [124, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.const_add_term", "code": "theorem const_add_term {\u03b1} [AddCommMonoid \u03b1] (k n x a a') (h : k + a = a') :\n    k + @term \u03b1 _ n x a = term n x a'", "start": [128, 1], "end": [130, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.const_add_termg", "code": "theorem const_add_termg {\u03b1} [AddCommGroup \u03b1] (k n x a a') (h : k + a = a') :\n    k + @termg \u03b1 _ n x a = termg n x a'", "start": [132, 1], "end": [134, 44], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_add_const", "code": "theorem term_add_const {\u03b1} [AddCommMonoid \u03b1] (n x a k a') (h : a + k = a') :\n    @term \u03b1 _ n x a + k = term n x a'", "start": [136, 1], "end": [138, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_add_constg", "code": "theorem term_add_constg {\u03b1} [AddCommGroup \u03b1] (n x a k a') (h : a + k = a') :\n    @termg \u03b1 _ n x a + k = termg n x a'", "start": [140, 1], "end": [142, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_add_term", "code": "theorem term_add_term {\u03b1} [AddCommMonoid \u03b1] (n\u2081 x a\u2081 n\u2082 a\u2082 n' a') (h\u2081 : n\u2081 + n\u2082 = n')\n    (h\u2082 : a\u2081 + a\u2082 = a') : @term \u03b1 _ n\u2081 x a\u2081 + @term \u03b1 _ n\u2082 x a\u2082 = term n' x a'", "start": [144, 1], "end": [146, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_add_termg", "code": "theorem term_add_termg {\u03b1} [AddCommGroup \u03b1] (n\u2081 x a\u2081 n\u2082 a\u2082 n' a')\n    (h\u2081 : n\u2081 + n\u2082 = n') (h\u2082 : a\u2081 + a\u2082 = a') :\n    @termg \u03b1 _ n\u2081 x a\u2081 + @termg \u03b1 _ n\u2082 x a\u2082 = termg n' x a'", "start": [148, 1], "end": [152, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.zero_term", "code": "theorem zero_term {\u03b1} [AddCommMonoid \u03b1] (x a) : @term \u03b1 _ 0 x a = a", "start": [154, 1], "end": [155, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.zero_termg", "code": "theorem zero_termg {\u03b1} [AddCommGroup \u03b1] (x a) : @termg \u03b1 _ 0 x a = a", "start": [157, 1], "end": [158, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.evalAdd", "code": "partial def evalAdd : NormalExpr \u2192 NormalExpr \u2192 M (NormalExpr \u00d7 Expr)\n  | zero _, e\u2082 => do\n    let p \u2190 mkAppM ``zero_add #[e\u2082]\n    return (e\u2082, p)\n  | e\u2081, zero _ => do\n    let p \u2190 mkAppM ``add_zero #[e\u2081]\n    return (e\u2081, p)\n  | he\u2081@(nterm e\u2081 n\u2081 x\u2081 a\u2081), he\u2082@(nterm e\u2082 n\u2082 x\u2082 a\u2082) => do\n    if x\u2081.1 = x\u2082.1 then\n      let n' \u2190 Mathlib.Meta.NormNum.eval (\u2190 mkAppM ``HAdd.hAdd #[n\u2081.1, n\u2082.1])\n      let (a', h\u2082) \u2190 evalAdd a\u2081 a\u2082\n      let k := n\u2081.2 + n\u2082.2\n      let p\u2081 \u2190 iapp ``term_add_term\n        #[n\u2081.1, x\u2081.2, a\u2081, n\u2082.1, a\u2082, n'.expr, a', \u2190 n'.getProof, h\u2082]\n      if k = 0 then do\n        let p \u2190 mkEqTrans p\u2081 (\u2190 iapp ``zero_term #[x\u2081.2, a'])\n        return (a', p)\n      else return (\u2190 term' (n'.expr, k) x\u2081 a', p\u2081)\n    else if x\u2081.1 < x\u2082.1 then do\n      let (a', h) \u2190 evalAdd a\u2081 he\u2082\n      return (\u2190 term' n\u2081 x\u2081 a', \u2190 iapp ``term_add_const #[n\u2081.1, x\u2081.2, a\u2081, e\u2082, a', h])\n    else do\n      let (a', h) \u2190 evalAdd he\u2081 a\u2082\n      return (\u2190 term' n\u2082 x\u2082 a', \u2190 iapp ``const_add_term #[e\u2081, n\u2082.1, x\u2082.2, a\u2082, a', h])", "start": [160, 1], "end": [186, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_neg", "code": "theorem term_neg {\u03b1} [AddCommGroup \u03b1] (n x a n' a')\n    (h\u2081 : -n = n') (h\u2082 : -a = a') : -@termg \u03b1 _ n x a = termg n' x a'", "start": [188, 1], "end": [190, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.evalNeg", "code": "def evalNeg : NormalExpr \u2192 M (NormalExpr \u00d7 Expr)\n  | (zero _) => do\n    let p \u2190 (\u2190 read).mkApp ``neg_zero ``NegZeroClass #[]\n    return (\u2190 zero', p)\n  | (nterm _ n x a) => do\n    let n' \u2190 Mathlib.Meta.NormNum.eval (\u2190 mkAppM ``Neg.neg #[n.1])\n    let (a', h\u2082) \u2190 evalNeg a\n    return (\u2190 term' (n'.expr, -n.2) x a',\n      (\u2190 read).app ``term_neg (\u2190 read).inst #[n.1, x.2, a, n'.expr, a', \u2190 n'.getProof, h\u2082])", "start": [192, 1], "end": [203, 92], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.smul", "code": "def smul {\u03b1} [AddCommMonoid \u03b1] (n : \u2115) (x : \u03b1) : \u03b1 := n \u2022 x", "start": [205, 1], "end": [206, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.smulg", "code": "def smulg {\u03b1} [AddCommGroup \u03b1] (n : \u2124) (x : \u03b1) : \u03b1 := n \u2022 x", "start": [207, 1], "end": [208, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.zero_smul", "code": "theorem zero_smul {\u03b1} [AddCommMonoid \u03b1] (c) : smul c (0 : \u03b1) = 0", "start": [210, 1], "end": [211, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.zero_smulg", "code": "theorem zero_smulg {\u03b1} [AddCommGroup \u03b1] (c) : smulg c (0 : \u03b1) = 0", "start": [213, 1], "end": [214, 27], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_smul", "code": "theorem term_smul {\u03b1} [AddCommMonoid \u03b1] (c n x a n' a')\n    (h\u2081 : c * n = n') (h\u2082 : smul c a = a') :\n    smul c (@term \u03b1 _ n x a) = term n' x a'", "start": [216, 1], "end": [219, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_smulg", "code": "theorem term_smulg {\u03b1} [AddCommGroup \u03b1] (c n x a n' a')\n    (h\u2081 : c * n = n') (h\u2082 : smulg c a = a') :\n    smulg c (@termg \u03b1 _ n x a) = termg n' x a'", "start": [221, 1], "end": [224, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.evalSMul", "code": "def evalSMul (k : Expr \u00d7 \u2124) : NormalExpr \u2192 M (NormalExpr \u00d7 Expr)\n  | zero _ => return (\u2190 zero', \u2190 iapp ``zero_smul #[k.1])\n  | nterm _ n x a => do\n    let n' \u2190 Mathlib.Meta.NormNum.eval (\u2190 mkAppM ``HMul.hMul #[k.1, n.1])\n    let (a', h\u2082) \u2190 evalSMul k a\n    return (\u2190 term' (n'.expr, k.2 * n.2) x a',\n      \u2190 iapp ``term_smul #[k.1, n.1, x.2, a, n'.expr, a', \u2190 n'.getProof, h\u2082])", "start": [226, 1], "end": [235, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_atom", "code": "theorem term_atom {\u03b1} [AddCommMonoid \u03b1] (x : \u03b1) : x = term 1 x 0", "start": [237, 1], "end": [237, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_atomg", "code": "theorem term_atomg {\u03b1} [AddCommGroup \u03b1] (x : \u03b1) : x = termg 1 x 0", "start": [238, 1], "end": [238, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_atom_pf", "code": "theorem term_atom_pf {\u03b1} [AddCommMonoid \u03b1] (x x' : \u03b1) (h : x = x') : x = term 1 x' 0", "start": [239, 1], "end": [240, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_atom_pfg", "code": "theorem term_atom_pfg {\u03b1} [AddCommGroup \u03b1] (x x' : \u03b1) (h : x = x') : x = termg 1 x' 0", "start": [241, 1], "end": [242, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.evalAtom", "code": "def evalAtom (e : Expr) : M (NormalExpr \u00d7 Expr) := do\n  let { expr := e', proof?, .. } \u2190 (\u2190 readThe AtomM.Context).evalAtom e\n  let i \u2190 AtomM.addAtom e'\n  let p \u2190 match proof? with\n  | none => iapp ``term_atom #[e]\n  | some p => iapp ``term_atom_pf #[e, e', p]\n  return (\u2190 term' (\u2190 intToExpr 1, 1) (i, e') (\u2190 zero'), p)", "start": [244, 1], "end": [251, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.unfold_sub", "code": "theorem unfold_sub {\u03b1} [SubtractionMonoid \u03b1] (a b c : \u03b1) (h : a + -b = c) : a - b = c", "start": [253, 1], "end": [254, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.unfold_smul", "code": "theorem unfold_smul {\u03b1} [AddCommMonoid \u03b1] (n) (x y : \u03b1)\n    (h : smul n x = y) : n \u2022 x = y", "start": [256, 1], "end": [257, 40], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.unfold_smulg", "code": "theorem unfold_smulg {\u03b1} [AddCommGroup \u03b1] (n : \u2115) (x y : \u03b1)\n    (h : smulg (Int.ofNat n) x = y) : (n : \u2124) \u2022 x = y", "start": [259, 1], "end": [260, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.unfold_zsmul", "code": "theorem unfold_zsmul {\u03b1} [AddCommGroup \u03b1] (n : \u2124) (x y : \u03b1)\n    (h : smulg n x = y) : n \u2022 x = y", "start": [262, 1], "end": [263, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_smul", "code": "lemma subst_into_smul {\u03b1} [AddCommMonoid \u03b1]\n    (l r tl tr t) (prl : l = tl) (prr : r = tr)\n    (prt : @smul \u03b1 _ tl tr = t) : smul l r = t := by simp [prl, prr, prt]", "start": [265, 1], "end": [267, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_smulg", "code": "lemma subst_into_smulg {\u03b1} [AddCommGroup \u03b1]\n    (l r tl tr t) (prl : l = tl) (prr : r = tr)\n    (prt : @smulg \u03b1 _ tl tr = t) : smulg l r = t := by simp [prl, prr, prt]", "start": [269, 1], "end": [271, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_smul_upcast", "code": "lemma subst_into_smul_upcast {\u03b1} [AddCommGroup \u03b1]\n    (l r tl zl tr t) (prl\u2081 : l = tl) (prl\u2082 : \u2191tl = zl) (prr : r = tr)\n    (prt : @smulg \u03b1 _ zl tr = t) : smul l r = t := by\n  simp [\u2190 prt, prl\u2081, \u2190 prl\u2082, prr, smul, smulg, coe_nat_zsmul]", "start": [273, 1], "end": [276, 62], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_add", "code": "lemma subst_into_add {\u03b1} [AddCommMonoid \u03b1] (l r tl tr t)\n    (prl : (l : \u03b1) = tl) (prr : r = tr) (prt : tl + tr = t) : l + r = t := by\n  rw [prl, prr, prt]", "start": [278, 1], "end": [280, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_addg", "code": "lemma subst_into_addg {\u03b1} [AddCommGroup \u03b1] (l r tl tr t)\n    (prl : (l : \u03b1) = tl) (prr : r = tr) (prt : tl + tr = t) : l + r = t := by\n  rw [prl, prr, prt]", "start": [282, 1], "end": [284, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.subst_into_negg", "code": "lemma subst_into_negg {\u03b1} [AddCommGroup \u03b1] (a ta t : \u03b1)\n    (pra : a = ta) (prt : -ta = t) : -a = t := by\n  simp [pra, prt]", "start": [286, 1], "end": [288, 18], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Abel.evalSMul'", "code": "def evalSMul' (eval : Expr \u2192 M (NormalExpr \u00d7 Expr))\n    (is_smulg : Bool) (orig e\u2081 e\u2082 : Expr) : M (NormalExpr \u00d7 Expr) := do\n  trace[abel] \"Calling NormNum on {e\u2081}\"\n  let \u27e8e\u2081', p\u2081, _\u27e9 \u2190 try Meta.NormNum.eval e\u2081 catch _ => pure { expr := e\u2081 }\n  let p\u2081 \u2190 p\u2081.getDM (mkEqRefl e\u2081')\n  match e\u2081'.int? with\n  | some n => do\n    let c \u2190 read\n    let (e\u2082', p\u2082) \u2190 eval e\u2082\n    if c.isGroup = is_smulg then do\n      let (e', p) \u2190 evalSMul (e\u2081', n) e\u2082'\n      return (e', \u2190 iapp ``subst_into_smul #[e\u2081, e\u2082, e\u2081', e\u2082', e', p\u2081, p\u2082, p])\n    else do\n      if \u00ac c.isGroup then throwError \"Doesn't make sense to us `smulg` in a monoid. \"\n      let zl \u2190 Expr.ofInt q(\u2124) n\n      let p\u2081' \u2190 mkEqRefl zl\n      let (e', p) \u2190 evalSMul (zl, n) e\u2082'\n      return (e', c.app ``subst_into_smul_upcast c.inst #[e\u2081, e\u2082, e\u2081', zl, e\u2082', e', p\u2081, p\u2081', p\u2082, p])\n  | none => evalAtom orig", "start": [290, 1], "end": [318, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.eval", "code": "partial def eval (e : Expr) : M (NormalExpr \u00d7 Expr) := do\n  trace[abel.detail] \"running eval on {e}\"\n  trace[abel.detail] \"getAppFnArgs: {e.getAppFnArgs}\"\n  match e.getAppFnArgs with\n  | (``HAdd.hAdd, #[_, _, _, _, e\u2081, e\u2082]) => do\n    let (e\u2081', p\u2081) \u2190 eval e\u2081\n    let (e\u2082', p\u2082) \u2190 eval e\u2082\n    let (e', p') \u2190 evalAdd e\u2081' e\u2082'\n    return (e', \u2190 iapp ``subst_into_add #[e\u2081, e\u2082, e\u2081', e\u2082', e', p\u2081, p\u2082, p'])\n  | (``HSub.hSub, #[_, _, _ ,_, e\u2081, e\u2082]) => do\n    let e\u2082' \u2190 mkAppM ``Neg.neg #[e\u2082]\n    let e \u2190 mkAppM ``HAdd.hAdd #[e\u2081, e\u2082']\n    let (e', p) \u2190 eval e\n    let p' \u2190 (\u2190 read).mkApp ``unfold_sub ``SubtractionMonoid #[e\u2081, e\u2082, e', p]\n    return (e', p')\n  | (``Neg.neg, #[_, _, e]) => do\n    let (e\u2081, p\u2081) \u2190 eval e\n    let (e\u2082, p\u2082) \u2190 evalNeg e\u2081\n    return (e\u2082, \u2190 iapp `Mathlib.Tactic.Abel.subst_into_neg #[e, e\u2081, e\u2082, p\u2081, p\u2082])\n  | (`AddMonoid.nsmul, #[_, _, e\u2081, e\u2082]) => do\n    let n \u2190 if (\u2190 read).isGroup then mkAppM ``Int.ofNat #[e\u2081] else pure e\u2081\n    let (e', p) \u2190 eval <| \u2190 iapp ``smul #[n, e\u2082]\n    return (e', \u2190 iapp ``unfold_smul #[e\u2081, e\u2082, e', p])\n  | (``SubNegMonoid.zsmul, #[_, _, e\u2081, e\u2082]) => do\n      if \u00ac (\u2190 read).isGroup then failure\n      let (e', p) \u2190 eval <| \u2190 iapp ``smul #[e\u2081, e\u2082]\n      return (e', (\u2190 read).app ``unfold_zsmul (\u2190 read).inst #[e\u2081, e\u2082, e', p])\n  | (``SMul.smul, #[.const ``Int _, _, _, e\u2081, e\u2082]) =>\n    evalSMul' eval true e e\u2081 e\u2082\n  | (``SMul.smul, #[.const ``Nat _, _, _, e\u2081, e\u2082]) =>\n    evalSMul' eval false e e\u2081 e\u2082\n  | (``HSMul.hSMul, #[.const ``Int _, _, _, _, e\u2081, e\u2082]) =>\n    evalSMul' eval true e e\u2081 e\u2082\n  | (``HSMul.hSMul, #[.const ``Nat _, _, _, _, e\u2081, e\u2082]) =>\n    evalSMul' eval false e e\u2081 e\u2082\n  | (``smul, #[_, _, e\u2081, e\u2082]) => evalSMul' eval false e e\u2081 e\u2082\n  | (``smulg, #[_, _, e\u2081, e\u2082]) => evalSMul' eval true e e\u2081 e\u2082\n  | (``OfNat.ofNat, #[_, .lit (.natVal 0), _])\n  | (``Zero.zero, #[_, _]) =>\n    if \u2190 isDefEq e (\u2190 read).\u03b10 then\n      pure (\u2190 zero', \u2190 mkEqRefl (\u2190 read).\u03b10)\n    else\n      evalAtom e\n  | _ => evalAtom e", "start": [320, 1], "end": [364, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.term_eq", "code": "theorem term_eq [AddCommMonoid \u03b1] (n : \u2115) (x a : \u03b1) : term n x a = n \u2022 x + a", "start": [398, 1], "end": [398, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.termg_eq", "code": "theorem termg_eq [AddCommGroup \u03b1] (n : \u2124) (x a : \u03b1) : termg n x a = n \u2022 x + a", "start": [399, 1], "end": [400, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.NormalExpr.isAtom", "code": "def NormalExpr.isAtom : NormalExpr \u2192 Bool\n  | .nterm _ (_, 1) _ (.zero _) => true\n  | _ => false", "start": [402, 1], "end": [405, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.AbelMode", "code": "inductive AbelMode where\n  \n  | term\n  \n  | raw", "start": [407, 1], "end": [412, 8], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.AbelNF.Config", "code": "structure AbelNF.Config where\n  \n  red := TransparencyMode.reducible\n  \n  recursive := true\n  \n  mode := AbelMode.term", "start": [414, 1], "end": [421, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.abelNFCore", "code": "partial def abelNFCore\n    (s : IO.Ref AtomM.State) (cfg : AbelNF.Config) (e : Expr) : MetaM Simp.Result := do\n  let ctx := {\n    simpTheorems := #[\u2190 Elab.Tactic.simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) {}]\n    congrTheorems := \u2190 getSimpCongrTheorems }\n  let simp \u2190 match cfg.mode with\n  | .raw => pure pure\n  | .term =>\n    let thms := [``term_eq, ``termg_eq, ``add_zero, ``one_nsmul, ``one_zsmul, ``zsmul_zero]\n    let ctx' := { ctx with simpTheorems := #[\u2190 thms.foldlM (\u00b7.addConst \u00b7) {:_}] }\n    pure fun r' : Simp.Result \u21a6 do\n      Simp.mkEqTrans r' (\u2190 Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  let rec\n    \n    go root parent :=\n      let pre e :=\n        try\n          guard <| root || parent != e let e \u2190 withReducible <| whnf e\n          guard e.isApp let (a, pa) \u2190 eval e (\u2190 mkContext e) { red := cfg.red, evalAtom } s\n          guard !a.isAtom\n          let r \u2190 simp { expr := a, proof? := pa }\n          if \u2190 withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n          pure (.done r)\n        catch _ => pure <| .visit { expr := e }\n      let post := (Simp.postDefault \u00b7 fun _ \u21a6 none)\n      (\u00b7.1) <$> Simp.main parent ctx (methods := { pre, post }),\n    \n    evalAtom := if cfg.recursive then go false else fun e \u21a6 pure { expr := e }\n  go true e", "start": [426, 1], "end": [471, 12], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.abelNFTarget", "code": "def abelNFTarget (s : IO.Ref AtomM.State) (cfg : AbelNF.Config) : TacticM Unit := withMainContext do\n  let goal \u2190 getMainGoal\n  let tgt \u2190 instantiateMVars (\u2190 goal.getType)\n  let r \u2190 abelNFCore s cfg tgt\n  if r.expr.isConstOf ``True then\n    goal.assign (\u2190 mkOfEqTrue (\u2190 r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [\u2190 applySimpResultToTarget goal tgt r]", "start": [474, 1], "end": [483, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.abelNFLocalDecl", "code": "def abelNFLocalDecl (s : IO.Ref AtomM.State) (cfg : AbelNF.Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt \u2190 instantiateMVars (\u2190 fvarId.getType)\n  let goal \u2190 getMainGoal\n  let myres \u2190 abelNFCore s cfg tgt\n  match \u2190 applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]", "start": [485, 1], "end": [493, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Abel.elabAbelNFConv", "code": "@[tactic abelNFConv] def elabAbelNFConv : Tactic := fun stx \u21a6 match stx with\n  | `(conv| abel_nf $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg \u2190 elabAbelNFConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    Conv.applySimpResult (\u2190 abelNFCore (\u2190 IO.mkRef {}) cfg (\u2190 instantiateMVars (\u2190 Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax", "start": [523, 1], "end": [529, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Pi.lean", "imports": ["Mathlib/Order/Filter/Bases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.pi", "code": "def pi (f : \u2200 i, Filter (\u03b1 i)) : Filter (\u2200 i, \u03b1 i) :=\n  \u2a05 i, comap (eval i) (f i)", "start": [35, 1], "end": [37, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.pi.isCountablyGenerated", "code": "instance pi.isCountablyGenerated [Countable \u03b9] [\u2200 i, IsCountablyGenerated (f i)] :\n    IsCountablyGenerated (pi f) :=\n  iInf.isCountablyGenerated _", "start": [40, 1], "end": [42, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_eval_pi", "code": "theorem tendsto_eval_pi (f : \u2200 i, Filter (\u03b1 i)) (i : \u03b9) : Tendsto (eval i) (pi f) (f i)", "start": [45, 1], "end": [46, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pi", "code": "theorem tendsto_pi {\u03b2 : Type*} {m : \u03b2 \u2192 \u2200 i, \u03b1 i} {l : Filter \u03b2} :\n    Tendsto m l (pi f) \u2194 \u2200 i, Tendsto (fun x => m x i) l (f i)", "start": [49, 1], "end": [51, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.le_pi", "code": "theorem le_pi {g : Filter (\u2200 i, \u03b1 i)} : g \u2264 pi f \u2194 \u2200 i, Tendsto (eval i) g (f i)", "start": [54, 1], "end": [55, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_mono", "code": "@[mono]\ntheorem pi_mono (h : \u2200 i, f\u2081 i \u2264 f\u2082 i) : pi f\u2081 \u2264 pi f\u2082", "start": [58, 1], "end": [60, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_pi_of_mem", "code": "theorem mem_pi_of_mem (i : \u03b9) {s : Set (\u03b1 i)} (hs : s \u2208 f i) : eval i \u207b\u00b9' s \u2208 pi f", "start": [63, 1], "end": [64, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_mem_pi", "code": "theorem pi_mem_pi {I : Set \u03b9} (hI : I.Finite) (h : \u2200 i \u2208 I, s i \u2208 f i) : I.pi s \u2208 pi f", "start": [67, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_pi", "code": "theorem mem_pi {s : Set (\u2200 i, \u03b1 i)} :\n    s \u2208 pi f \u2194 \u2203 I : Set \u03b9, I.Finite \u2227 \u2203 t : \u2200 i, Set (\u03b1 i), (\u2200 i, t i \u2208 f i) \u2227 I.pi t \u2286 s", "start": [73, 1], "end": [81, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_pi'", "code": "theorem mem_pi' {s : Set (\u2200 i, \u03b1 i)} :\n    s \u2208 pi f \u2194 \u2203 I : Finset \u03b9, \u2203 t : \u2200 i, Set (\u03b1 i), (\u2200 i, t i \u2208 f i) \u2227 Set.pi (\u2191I) t \u2286 s", "start": [84, 1], "end": [86, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_of_pi_mem_pi", "code": "theorem mem_of_pi_mem_pi [\u2200 i, NeBot (f i)] {I : Set \u03b9} (h : I.pi s \u2208 pi f) {i : \u03b9} (hi : i \u2208 I) :\n    s i \u2208 f i", "start": [89, 1], "end": [97, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_mem_pi_iff", "code": "@[simp]\ntheorem pi_mem_pi_iff [\u2200 i, NeBot (f i)] {I : Set \u03b9} (hI : I.Finite) :\n    I.pi s \u2208 pi f \u2194 \u2200 i \u2208 I, s i \u2208 f i", "start": [100, 1], "end": [103, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_pi", "code": "theorem hasBasis_pi {\u03b9' : \u03b9 \u2192 Type} {s : \u2200 i, \u03b9' i \u2192 Set (\u03b1 i)} {p : \u2200 i, \u03b9' i \u2192 Prop}\n    (h : \u2200 i, (f i).HasBasis (p i) (s i)) :\n    (pi f).HasBasis (fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => If.1.Finite \u2227 \u2200 i \u2208 If.1, p i (If.2 i))\n      fun If : Set \u03b9 \u00d7 \u2200 i, \u03b9' i => If.1.pi fun i => s i <| If.2 i", "start": [106, 1], "end": [110, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_inf_principal_univ_pi_eq_bot", "code": "@[simp]\ntheorem pi_inf_principal_univ_pi_eq_bot :\n    pi f \u2293 \ud835\udcdf (Set.pi univ s) = \u22a5 \u2194 \u2203 i, f i \u2293 \ud835\udcdf (s i) = \u22a5", "start": [113, 1], "end": [125, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_inf_principal_pi_eq_bot", "code": "@[simp]\ntheorem pi_inf_principal_pi_eq_bot [\u2200 i, NeBot (f i)] {I : Set \u03b9} :\n    pi f \u2293 \ud835\udcdf (Set.pi I s) = \u22a5 \u2194 \u2203 i \u2208 I, f i \u2293 \ud835\udcdf (s i) = \u22a5", "start": [128, 1], "end": [133, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_inf_principal_univ_pi_neBot", "code": "@[simp]\ntheorem pi_inf_principal_univ_pi_neBot :\n    NeBot (pi f \u2293 \ud835\udcdf (Set.pi univ s)) \u2194 \u2200 i, NeBot (f i \u2293 \ud835\udcdf (s i))", "start": [136, 1], "end": [138, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_inf_principal_pi_neBot", "code": "@[simp]\ntheorem pi_inf_principal_pi_neBot [\u2200 i, NeBot (f i)] {I : Set \u03b9} :\n    NeBot (pi f \u2293 \ud835\udcdf (I.pi s)) \u2194 \u2200 i \u2208 I, NeBot (f i \u2293 \ud835\udcdf (s i))", "start": [141, 1], "end": [143, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.PiInfPrincipalPi.neBot", "code": "instance PiInfPrincipalPi.neBot [h : \u2200 i, NeBot (f i \u2293 \ud835\udcdf (s i))] {I : Set \u03b9} :\n    NeBot (pi f \u2293 \ud835\udcdf (I.pi s)) :=\n  (pi_inf_principal_univ_pi_neBot.2 \u2039_\u203a).mono <|\n    inf_le_inf_left _ <| principal_mono.2 fun x hx i _ => hx i trivial", "start": [146, 1], "end": [149, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_eq_bot", "code": "@[simp]\ntheorem pi_eq_bot : pi f = \u22a5 \u2194 \u2203 i, f i = \u22a5", "start": [152, 1], "end": [154, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_neBot", "code": "@[simp]\ntheorem pi_neBot : NeBot (pi f) \u2194 \u2200 i, NeBot (f i)", "start": [157, 1], "end": [158, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.map_eval_pi", "code": "@[simp]\ntheorem map_eval_pi (f : \u2200 i, Filter (\u03b1 i)) [\u2200 i, NeBot (f i)] (i : \u03b9) :\n    map (eval i) (pi f) = f i", "start": [164, 1], "end": [171, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_le_pi", "code": "@[simp]\ntheorem pi_le_pi [\u2200 i, NeBot (f\u2081 i)] : pi f\u2081 \u2264 pi f\u2082 \u2194 \u2200 i, f\u2081 i \u2264 f\u2082 i", "start": [174, 1], "end": [176, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.pi_inj", "code": "@[simp]\ntheorem pi_inj [\u2200 i, NeBot (f\u2081 i)] : pi f\u2081 = pi f\u2082 \u2194 f\u2081 = f\u2082", "start": [179, 1], "end": [184, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62", "code": "protected def coprod\u1d62 (f : \u2200 i, Filter (\u03b1 i)) : Filter (\u2200 i, \u03b1 i) :=\n  \u2a06 i : \u03b9, comap (eval i) (f i)", "start": [196, 1], "end": [198, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_coprod\u1d62_iff", "code": "theorem mem_coprod\u1d62_iff {s : Set (\u2200 i, \u03b1 i)} :\n    s \u2208 Filter.coprod\u1d62 f \u2194 \u2200 i : \u03b9, \u2203 t\u2081 \u2208 f i, eval i \u207b\u00b9' t\u2081 \u2286 s", "start": [201, 1], "end": [202, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.compl_mem_coprod\u1d62", "code": "theorem compl_mem_coprod\u1d62 {s : Set (\u2200 i, \u03b1 i)} :\n    s\u1d9c \u2208 Filter.coprod\u1d62 f \u2194 \u2200 i, (eval i '' s)\u1d9c \u2208 f i", "start": [205, 1], "end": [207, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_neBot_iff'", "code": "theorem coprod\u1d62_neBot_iff' :\n    NeBot (Filter.coprod\u1d62 f) \u2194 (\u2200 i, Nonempty (\u03b1 i)) \u2227 \u2203 d, NeBot (f d)", "start": [210, 1], "end": [212, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_neBot_iff", "code": "@[simp]\ntheorem coprod\u1d62_neBot_iff [\u2200 i, Nonempty (\u03b1 i)] : NeBot (Filter.coprod\u1d62 f) \u2194 \u2203 d, NeBot (f d)", "start": [215, 1], "end": [217, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_eq_bot_iff'", "code": "theorem coprod\u1d62_eq_bot_iff' : Filter.coprod\u1d62 f = \u22a5 \u2194 (\u2203 i, IsEmpty (\u03b1 i)) \u2228 f = \u22a5", "start": [220, 1], "end": [222, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_eq_bot_iff", "code": "@[simp]\ntheorem coprod\u1d62_eq_bot_iff [\u2200 i, Nonempty (\u03b1 i)] : Filter.coprod\u1d62 f = \u22a5 \u2194 f = \u22a5", "start": [225, 1], "end": [227, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_bot'", "code": "@[simp] theorem coprod\u1d62_bot' : Filter.coprod\u1d62 (\u22a5 : \u2200 i, Filter (\u03b1 i)) = \u22a5", "start": [230, 1], "end": [231, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_bot", "code": "@[simp]\ntheorem coprod\u1d62_bot : Filter.coprod\u1d62 (fun _ => \u22a5 : \u2200 i, Filter (\u03b1 i)) = \u22a5", "start": [234, 1], "end": [236, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.coprod\u1d62", "code": "theorem NeBot.coprod\u1d62 [\u2200 i, Nonempty (\u03b1 i)] {i : \u03b9} (h : NeBot (f i)) : NeBot (Filter.coprod\u1d62 f)", "start": [239, 1], "end": [240, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_neBot", "code": "@[instance]\ntheorem coprod\u1d62_neBot [\u2200 i, Nonempty (\u03b1 i)] [Nonempty \u03b9] (f : \u2200 i, Filter (\u03b1 i))\n    [H : \u2200 i, NeBot (f i)] : NeBot (Filter.coprod\u1d62 f)", "start": [243, 1], "end": [246, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_mono", "code": "@[mono]\ntheorem coprod\u1d62_mono (hf : \u2200 i, f\u2081 i \u2264 f\u2082 i) : Filter.coprod\u1d62 f\u2081 \u2264 Filter.coprod\u1d62 f\u2082", "start": [249, 1], "end": [251, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.map_pi_map_coprod\u1d62_le", "code": "theorem map_pi_map_coprod\u1d62_le :\n    map (fun k : \u2200 i, \u03b1 i => fun i => m i (k i)) (Filter.coprod\u1d62 f) \u2264\n      Filter.coprod\u1d62 fun i => map (m i) (f i)", "start": [256, 1], "end": [262, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.pi_map_coprod\u1d62", "code": "theorem Tendsto.pi_map_coprod\u1d62 {g : \u2200 i, Filter (\u03b2 i)} (h : \u2200 i, Tendsto (m i) (f i) (g i)) :\n    Tendsto (fun k : \u2200 i, \u03b1 i => fun i => m i (k i)) (Filter.coprod\u1d62 f) (Filter.coprod\u1d62 g)", "start": [265, 1], "end": [267, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/AtTopBot.lean", "imports": ["Mathlib/Algebra/Order/Group/MinMax.lean", "Mathlib/Data/Set/Intervals/OrderIso.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Data/Finset/Preimage.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/Disjoint.lean", "Mathlib/Order/Filter/Bases.lean"], "premises": [{"full_name": "Filter.atTop", "code": "def atTop [Preorder \u03b1] : Filter \u03b1 :=\n  \u2a05 a, \ud835\udcdf (Ici a)", "start": [37, 1], "end": [42, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot", "code": "def atBot [Preorder \u03b1] : Filter \u03b1 :=\n  \u2a05 a, \ud835\udcdf (Iic a)", "start": [45, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_atTop", "code": "theorem mem_atTop [Preorder \u03b1] (a : \u03b1) : { b : \u03b1 | a \u2264 b } \u2208 @atTop \u03b1 _", "start": [53, 1], "end": [54, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.Ici_mem_atTop", "code": "theorem Ici_mem_atTop [Preorder \u03b1] (a : \u03b1) : Ici a \u2208 (atTop : Filter \u03b1)", "start": [57, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.Ioi_mem_atTop", "code": "theorem Ioi_mem_atTop [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) : Ioi x \u2208 (atTop : Filter \u03b1)", "start": [61, 1], "end": [63, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_atBot", "code": "theorem mem_atBot [Preorder \u03b1] (a : \u03b1) : { b : \u03b1 | b \u2264 a } \u2208 @atBot \u03b1 _", "start": [66, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.Iic_mem_atBot", "code": "theorem Iic_mem_atBot [Preorder \u03b1] (a : \u03b1) : Iic a \u2208 (atBot : Filter \u03b1)", "start": [70, 1], "end": [71, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.Iio_mem_atBot", "code": "theorem Iio_mem_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) : Iio x \u2208 (atBot : Filter \u03b1)", "start": [74, 1], "end": [76, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atBot_principal_Ioi", "code": "theorem disjoint_atBot_principal_Ioi [Preorder \u03b1] (x : \u03b1) : Disjoint atBot (\ud835\udcdf (Ioi x))", "start": [79, 1], "end": [80, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atTop_principal_Iio", "code": "theorem disjoint_atTop_principal_Iio [Preorder \u03b1] (x : \u03b1) : Disjoint atTop (\ud835\udcdf (Iio x))", "start": [83, 1], "end": [84, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atTop_principal_Iic", "code": "theorem disjoint_atTop_principal_Iic [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) :\n    Disjoint atTop (\ud835\udcdf (Iic x))", "start": [87, 1], "end": [90, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atBot_principal_Ici", "code": "theorem disjoint_atBot_principal_Ici [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) :\n    Disjoint atBot (\ud835\udcdf (Ici x))", "start": [93, 1], "end": [95, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_pure_atTop", "code": "theorem disjoint_pure_atTop [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) : Disjoint (pure x) atTop", "start": [98, 1], "end": [100, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_pure_atBot", "code": "theorem disjoint_pure_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) : Disjoint (pure x) atBot", "start": [103, 1], "end": [104, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.not_tendsto_const_atTop", "code": "theorem not_tendsto_const_atTop [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) (l : Filter \u03b2) [l.NeBot] :\n    \u00acTendsto (fun _ => x) l atTop", "start": [107, 1], "end": [109, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.not_tendsto_const_atBot", "code": "theorem not_tendsto_const_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) (l : Filter \u03b2) [l.NeBot] :\n    \u00acTendsto (fun _ => x) l atBot", "start": [112, 1], "end": [114, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atBot_atTop", "code": "theorem disjoint_atBot_atTop [PartialOrder \u03b1] [Nontrivial \u03b1] :\n    Disjoint (atBot : Filter \u03b1) atTop", "start": [117, 1], "end": [124, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_atTop_atBot", "code": "theorem disjoint_atTop_atBot [PartialOrder \u03b1] [Nontrivial \u03b1] : Disjoint (atTop : Filter \u03b1) atBot", "start": [127, 1], "end": [128, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_basis", "code": "theorem atTop_basis [Nonempty \u03b1] [SemilatticeSup \u03b1] : (@atTop \u03b1 _).HasBasis (fun _ => True) Ici", "start": [131, 1], "end": [132, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_eq_generate_Ici", "code": "theorem atTop_eq_generate_Ici [SemilatticeSup \u03b1] : atTop = generate (range (Ici (\u03b1 := \u03b1)))", "start": [135, 1], "end": [138, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_basis'", "code": "theorem atTop_basis' [SemilatticeSup \u03b1] (a : \u03b1) : (@atTop \u03b1 _).HasBasis (fun x => a \u2264 x) Ici", "start": [140, 1], "end": [144, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_basis", "code": "theorem atBot_basis [Nonempty \u03b1] [SemilatticeInf \u03b1] : (@atBot \u03b1 _).HasBasis (fun _ => True) Iic", "start": [147, 1], "end": [148, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_basis'", "code": "theorem atBot_basis' [SemilatticeInf \u03b1] (a : \u03b1) : (@atBot \u03b1 _).HasBasis (fun x => x \u2264 a) Iic", "start": [151, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_neBot", "code": "@[instance]\ntheorem atTop_neBot [Nonempty \u03b1] [SemilatticeSup \u03b1] : NeBot (atTop : Filter \u03b1)", "start": [155, 1], "end": [157, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_neBot", "code": "@[instance]\ntheorem atBot_neBot [Nonempty \u03b1] [SemilatticeInf \u03b1] : NeBot (atBot : Filter \u03b1)", "start": [160, 1], "end": [162, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_atTop_sets", "code": "@[simp]\ntheorem mem_atTop_sets [Nonempty \u03b1] [SemilatticeSup \u03b1] {s : Set \u03b1} :\n    s \u2208 (atTop : Filter \u03b1) \u2194 \u2203 a : \u03b1, \u2200 b \u2265 a, b \u2208 s", "start": [165, 1], "end": [168, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_atBot_sets", "code": "@[simp]\ntheorem mem_atBot_sets [Nonempty \u03b1] [SemilatticeInf \u03b1] {s : Set \u03b1} :\n    s \u2208 (atBot : Filter \u03b1) \u2194 \u2203 a : \u03b1, \u2200 b \u2264 a, b \u2208 s", "start": [171, 1], "end": [174, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atTop", "code": "@[simp]\ntheorem eventually_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atTop, p x) \u2194 \u2203 a, \u2200 b \u2265 a, p b", "start": [177, 1], "end": [180, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atBot", "code": "@[simp]\ntheorem eventually_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atBot, p x) \u2194 \u2203 a, \u2200 b \u2264 a, p b", "start": [183, 1], "end": [186, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_ge_atTop", "code": "theorem eventually_ge_atTop [Preorder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atTop, a \u2264 x", "start": [189, 1], "end": [190, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_le_atBot", "code": "theorem eventually_le_atBot [Preorder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atBot, x \u2264 a", "start": [193, 1], "end": [194, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_gt_atTop", "code": "theorem eventually_gt_atTop [Preorder \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atTop, a < x", "start": [197, 1], "end": [198, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_ne_atTop", "code": "theorem eventually_ne_atTop [Preorder \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atTop, x \u2260 a", "start": [201, 1], "end": [202, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_gt_atTop", "code": "protected theorem Tendsto.eventually_gt_atTop [Preorder \u03b2] [NoMaxOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atTop) (c : \u03b2) : \u2200\u1da0 x in l, c < f x", "start": [205, 1], "end": [207, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_ge_atTop", "code": "protected theorem Tendsto.eventually_ge_atTop [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atTop) (c : \u03b2) : \u2200\u1da0 x in l, c \u2264 f x", "start": [210, 1], "end": [212, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_ne_atTop", "code": "protected theorem Tendsto.eventually_ne_atTop [Preorder \u03b2] [NoMaxOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atTop) (c : \u03b2) : \u2200\u1da0 x in l, f x \u2260 c", "start": [215, 1], "end": [217, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_ne_atTop'", "code": "protected theorem Tendsto.eventually_ne_atTop' [Preorder \u03b2] [NoMaxOrder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {l : Filter \u03b1} (hf : Tendsto f l atTop) (c : \u03b1) : \u2200\u1da0 x in l, x \u2260 c", "start": [220, 1], "end": [222, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_lt_atBot", "code": "theorem eventually_lt_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atBot, x < a", "start": [225, 1], "end": [226, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_ne_atBot", "code": "theorem eventually_ne_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) : \u2200\u1da0 x in atBot, x \u2260 a", "start": [229, 1], "end": [230, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_lt_atBot", "code": "protected theorem Tendsto.eventually_lt_atBot [Preorder \u03b2] [NoMinOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atBot) (c : \u03b2) : \u2200\u1da0 x in l, f x < c", "start": [233, 1], "end": [235, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_le_atBot", "code": "protected theorem Tendsto.eventually_le_atBot [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atBot) (c : \u03b2) : \u2200\u1da0 x in l, f x \u2264 c", "start": [238, 1], "end": [240, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_ne_atBot", "code": "protected theorem Tendsto.eventually_ne_atBot [Preorder \u03b2] [NoMinOrder \u03b2] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1}\n    (hf : Tendsto f l atBot) (c : \u03b2) : \u2200\u1da0 x in l, f x \u2260 c", "start": [243, 1], "end": [245, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_forall_ge_atTop", "code": "theorem eventually_forall_ge_atTop [Preorder \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atTop, \u2200 y, x \u2264 y \u2192 p y) \u2194 \u2200\u1da0 x in atTop, p x", "start": [248, 1], "end": [254, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_forall_le_atBot", "code": "theorem eventually_forall_le_atBot [Preorder \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atBot, \u2200 y, y \u2264 x \u2192 p y) \u2194 \u2200\u1da0 x in atBot, p x", "start": [256, 1], "end": [258, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_forall_ge_atTop", "code": "theorem Tendsto.eventually_forall_ge_atTop {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {l : Filter \u03b1}\n    {p : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Tendsto f l atTop) (h_evtl : \u2200\u1da0 x in atTop, p x) :\n    \u2200\u1da0 x in l, \u2200 y, f x \u2264 y \u2192 p y", "start": [260, 1], "end": [263, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_forall_le_atBot", "code": "theorem Tendsto.eventually_forall_le_atBot {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {l : Filter \u03b1}\n    {p : \u03b2 \u2192 Prop} {f : \u03b1 \u2192 \u03b2} (hf : Tendsto f l atBot) (h_evtl : \u2200\u1da0 x in atBot, p x) :\n    \u2200\u1da0 x in l, \u2200 y, y \u2264 f x \u2192 p y", "start": [265, 1], "end": [268, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_basis_Ioi", "code": "theorem atTop_basis_Ioi [Nonempty \u03b1] [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] :\n    (@atTop \u03b1 _).HasBasis (fun _ => True) Ioi", "start": [270, 1], "end": [273, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_countable_basis", "code": "theorem atTop_countable_basis [Nonempty \u03b1] [SemilatticeSup \u03b1] [Countable \u03b1] :\n    HasCountableBasis (atTop : Filter \u03b1) (fun _ => True) Ici", "start": [276, 1], "end": [278, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_countable_basis", "code": "theorem atBot_countable_basis [Nonempty \u03b1] [SemilatticeInf \u03b1] [Countable \u03b1] :\n    HasCountableBasis (atBot : Filter \u03b1) (fun _ => True) Iic", "start": [281, 1], "end": [283, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop.isCountablyGenerated", "code": "instance (priority := 200) atTop.isCountablyGenerated [Preorder \u03b1] [Countable \u03b1] :\n    (atTop : Filter <| \u03b1).IsCountablyGenerated :=\n  isCountablyGenerated_seq _", "start": [286, 1], "end": [288, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot.isCountablyGenerated", "code": "instance (priority := 200) atBot.isCountablyGenerated [Preorder \u03b1] [Countable \u03b1] :\n    (atBot : Filter <| \u03b1).IsCountablyGenerated :=\n  isCountablyGenerated_seq _", "start": [291, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.OrderTop.atTop_eq", "code": "theorem OrderTop.atTop_eq (\u03b1) [PartialOrder \u03b1] [OrderTop \u03b1] : (atTop : Filter \u03b1) = pure \u22a4", "start": [296, 1], "end": [298, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.OrderBot.atBot_eq", "code": "theorem OrderBot.atBot_eq (\u03b1) [PartialOrder \u03b1] [OrderBot \u03b1] : (atBot : Filter \u03b1) = pure \u22a5", "start": [301, 1], "end": [302, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.atTop_eq", "code": "@[nontriviality]\ntheorem Subsingleton.atTop_eq (\u03b1) [Subsingleton \u03b1] [Preorder \u03b1] : (atTop : Filter \u03b1) = \u22a4", "start": [305, 1], "end": [309, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.atBot_eq", "code": "@[nontriviality]\ntheorem Subsingleton.atBot_eq (\u03b1) [Subsingleton \u03b1] [Preorder \u03b1] : (atBot : Filter \u03b1) = \u22a4", "start": [312, 1], "end": [314, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_pure", "code": "theorem tendsto_atTop_pure [PartialOrder \u03b1] [OrderTop \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f atTop (pure <| f \u22a4)", "start": [317, 1], "end": [319, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_pure", "code": "theorem tendsto_atBot_pure [PartialOrder \u03b1] [OrderBot \u03b1] (f : \u03b1 \u2192 \u03b2) :\n    Tendsto f atBot (pure <| f \u22a5)", "start": [322, 1], "end": [324, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_forall_of_atTop", "code": "theorem Eventually.exists_forall_of_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2200\u1da0 x in atTop, p x) : \u2203 a, \u2200 b \u2265 a, p b", "start": [327, 1], "end": [329, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_forall_of_atBot", "code": "theorem Eventually.exists_forall_of_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2200\u1da0 x in atBot, p x) : \u2203 a, \u2200 b \u2264 a, p b", "start": [332, 1], "end": [334, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_eventually_atTop", "code": "lemma exists_eventually_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] {r : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    (\u2203 b, \u2200\u1da0 a in atTop, r a b) \u2194 \u2200\u1da0 a\u2080 in atTop, \u2203 b, \u2200 a \u2265 a\u2080, r a b := by\n  simp_rw [eventually_atTop, \u2190 exists_swap (\u03b1 := \u03b1)]\n  exact exists_congr fun a \u21a6 .symm <| forall_ge_iff <| Monotone.exists fun _ _ _ hb H n hn \u21a6\n    H n (hb.trans hn)", "start": [337, 1], "end": [341, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.exists_eventually_atBot", "code": "lemma exists_eventually_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {r : \u03b1 \u2192 \u03b2 \u2192 Prop} :\n    (\u2203 b, \u2200\u1da0 a in atBot, r a b) \u2194 \u2200\u1da0 a\u2080 in atBot, \u2203 b, \u2200 a \u2264 a\u2080, r a b := by\n  simp_rw [eventually_atBot, \u2190 exists_swap (\u03b1 := \u03b1)]\n  exact exists_congr fun a \u21a6 .symm <| forall_le_iff <| Antitone.exists fun _ _ _ hb H n hn \u21a6\n    H n (hn.trans hb)", "start": [343, 1], "end": [347, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.frequently_atTop", "code": "theorem frequently_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in atTop, p x) \u2194 \u2200 a, \u2203 b \u2265 a, p b", "start": [349, 1], "end": [351, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_atBot", "code": "theorem frequently_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in atBot, p x) \u2194 \u2200 a, \u2203 b \u2264 a, p b", "start": [354, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_atTop'", "code": "theorem frequently_atTop' [SemilatticeSup \u03b1] [Nonempty \u03b1] [NoMaxOrder \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in atTop, p x) \u2194 \u2200 a, \u2203 b > a, p b", "start": [359, 1], "end": [361, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_atBot'", "code": "theorem frequently_atBot' [SemilatticeInf \u03b1] [Nonempty \u03b1] [NoMinOrder \u03b1] {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in atBot, p x) \u2194 \u2200 a, \u2203 b < a, p b", "start": [364, 1], "end": [366, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.forall_exists_of_atTop", "code": "theorem Frequently.forall_exists_of_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2203\u1da0 x in atTop, p x) : \u2200 a, \u2203 b \u2265 a, p b", "start": [369, 1], "end": [371, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.forall_exists_of_atBot", "code": "theorem Frequently.forall_exists_of_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n    (h : \u2203\u1da0 x in atBot, p x) : \u2200 a, \u2203 b \u2264 a, p b", "start": [374, 1], "end": [376, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.map_atTop_eq", "code": "theorem map_atTop_eq [Nonempty \u03b1] [SemilatticeSup \u03b1] {f : \u03b1 \u2192 \u03b2} :\n    atTop.map f = \u2a05 a, \ud835\udcdf (f '' { a' | a \u2264 a' })", "start": [379, 1], "end": [381, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.map_atBot_eq", "code": "theorem map_atBot_eq [Nonempty \u03b1] [SemilatticeInf \u03b1] {f : \u03b1 \u2192 \u03b2} :\n    atBot.map f = \u2a05 a, \ud835\udcdf (f '' { a' | a' \u2264 a })", "start": [384, 1], "end": [386, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop", "code": "theorem tendsto_atTop [Preorder \u03b2] {m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} :\n    Tendsto m f atTop \u2194 \u2200 b, \u2200\u1da0 a in f, b \u2264 m a", "start": [389, 1], "end": [391, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot", "code": "theorem tendsto_atBot [Preorder \u03b2] {m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} :\n    Tendsto m f atBot \u2194 \u2200 b, \u2200\u1da0 a in f, m a \u2264 b", "start": [394, 1], "end": [396, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_mono'", "code": "theorem tendsto_atTop_mono' [Preorder \u03b2] (l : Filter \u03b1) \u2983f\u2081 f\u2082 : \u03b1 \u2192 \u03b2\u2984 (h : f\u2081 \u2264\u1da0[l] f\u2082)\n    (h\u2081 : Tendsto f\u2081 l atTop) : Tendsto f\u2082 l atTop", "start": [399, 1], "end": [401, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_mono'", "code": "theorem tendsto_atBot_mono' [Preorder \u03b2] (l : Filter \u03b1) \u2983f\u2081 f\u2082 : \u03b1 \u2192 \u03b2\u2984 (h : f\u2081 \u2264\u1da0[l] f\u2082) :\n    Tendsto f\u2082 l atBot \u2192 Tendsto f\u2081 l atBot", "start": [404, 1], "end": [406, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_mono", "code": "theorem tendsto_atTop_mono [Preorder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : \u2200 n, f n \u2264 g n) :\n    Tendsto f l atTop \u2192 Tendsto g l atTop", "start": [409, 1], "end": [411, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_mono", "code": "theorem tendsto_atBot_mono [Preorder \u03b2] {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (h : \u2200 n, f n \u2264 g n) :\n    Tendsto g l atBot \u2192 Tendsto f l atBot", "start": [414, 1], "end": [416, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_eq_generate_of_forall_exists_le", "code": "lemma atTop_eq_generate_of_forall_exists_le [LinearOrder \u03b1] {s : Set \u03b1} (hs : \u2200 x, \u2203 y \u2208 s, x \u2264 y) :\n    (atTop : Filter \u03b1) = generate (Ici '' s) := by\n  rw [atTop_eq_generate_Ici]\n  apply le_antisymm\n  \u00b7 rw [le_generate_iff]\n    rintro - \u27e8y, -, rfl\u27e9\n    exact mem_generate_of_mem \u27e8y, rfl\u27e9\n  \u00b7 rw [le_generate_iff]\n    rintro - \u27e8x, -, -, rfl\u27e9\n    rcases hs x with \u27e8y, ys, hy\u27e9\n    have A : Ici y \u2208 generate (Ici '' s) := mem_generate_of_mem (mem_image_of_mem _ ys)\n    have B : Ici y \u2286 Ici x := Ici_subset_Ici.2 hy\n    exact sets_of_superset (generate (Ici '' s)) A B", "start": [419, 1], "end": [431, 53], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.atTop_eq_generate_of_not_bddAbove", "code": "lemma atTop_eq_generate_of_not_bddAbove [LinearOrder \u03b1] {s : Set \u03b1} (hs : \u00ac BddAbove s) :\n    (atTop : Filter \u03b1) = generate (Ici '' s) := by\n  refine' atTop_eq_generate_of_forall_exists_le fun x \u21a6 _\n  obtain \u27e8y, hy, hy'\u27e9 := not_bddAbove_iff.mp hs x\n  exact \u27e8y, hy, hy'.le\u27e9", "start": [433, 1], "end": [437, 24], "kind": "mathlibtacticlemma"}, {"full_name": "OrderIso.comap_atTop", "code": "@[simp]\ntheorem comap_atTop (e : \u03b1 \u2243o \u03b2) : comap e atTop = atTop", "start": [447, 1], "end": [449, 41], "kind": "commanddeclaration"}, {"full_name": "OrderIso.comap_atBot", "code": "@[simp]\ntheorem comap_atBot (e : \u03b1 \u2243o \u03b2) : comap e atBot = atBot", "start": [452, 1], "end": [454, 21], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_atTop", "code": "@[simp]\ntheorem map_atTop (e : \u03b1 \u2243o \u03b2) : map (e : \u03b1 \u2192 \u03b2) atTop = atTop", "start": [457, 1], "end": [459, 61], "kind": "commanddeclaration"}, {"full_name": "OrderIso.map_atBot", "code": "@[simp]\ntheorem map_atBot (e : \u03b1 \u2243o \u03b2) : map (e : \u03b1 \u2192 \u03b2) atBot = atBot", "start": [462, 1], "end": [464, 19], "kind": "commanddeclaration"}, {"full_name": "OrderIso.tendsto_atTop", "code": "theorem tendsto_atTop (e : \u03b1 \u2243o \u03b2) : Tendsto e atTop atTop", "start": [467, 1], "end": [468, 17], "kind": "commanddeclaration"}, {"full_name": "OrderIso.tendsto_atBot", "code": "theorem tendsto_atBot (e : \u03b1 \u2243o \u03b2) : Tendsto e atBot atBot", "start": [471, 1], "end": [472, 17], "kind": "commanddeclaration"}, {"full_name": "OrderIso.tendsto_atTop_iff", "code": "@[simp]\ntheorem tendsto_atTop_iff {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} (e : \u03b1 \u2243o \u03b2) :\n    Tendsto (fun x => e (f x)) l atTop \u2194 Tendsto f l atTop", "start": [475, 1], "end": [478, 47], "kind": "commanddeclaration"}, {"full_name": "OrderIso.tendsto_atBot_iff", "code": "@[simp]\ntheorem tendsto_atBot_iff {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} (e : \u03b1 \u2243o \u03b2) :\n    Tendsto (fun x => e (f x)) l atBot \u2194 Tendsto f l atBot", "start": [481, 1], "end": [484, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_map_atTop_neBot_iff", "code": "theorem inf_map_atTop_neBot_iff [SemilatticeSup \u03b1] [Nonempty \u03b1] {F : Filter \u03b2} {u : \u03b1 \u2192 \u03b2} :\n    NeBot (F \u2293 map u atTop) \u2194 \u2200 U \u2208 F, \u2200 N, \u2203 n \u2265 N, u n \u2208 U", "start": [495, 1], "end": [497, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.inf_map_atBot_neBot_iff", "code": "theorem inf_map_atBot_neBot_iff [SemilatticeInf \u03b1] [Nonempty \u03b1] {F : Filter \u03b2} {u : \u03b1 \u2192 \u03b2} :\n    NeBot (F \u2293 map u atBot) \u2194 \u2200 U \u2208 F, \u2200 N, \u2203 n \u2264 N, u n \u2208 U", "start": [500, 1], "end": [502, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_of_frequently_atTop'", "code": "theorem extraction_of_frequently_atTop' {P : \u2115 \u2192 Prop} (h : \u2200 N, \u2203 n > N, P n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P (\u03c6 n)", "start": [505, 1], "end": [510, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_of_frequently_atTop", "code": "theorem extraction_of_frequently_atTop {P : \u2115 \u2192 Prop} (h : \u2203\u1da0 n in atTop, P n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P (\u03c6 n)", "start": [513, 1], "end": [516, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_of_eventually_atTop", "code": "theorem extraction_of_eventually_atTop {P : \u2115 \u2192 Prop} (h : \u2200\u1da0 n in atTop, P n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P (\u03c6 n)", "start": [519, 1], "end": [521, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_forall_of_frequently", "code": "theorem extraction_forall_of_frequently {P : \u2115 \u2192 \u2115 \u2192 Prop} (h : \u2200 n, \u2203\u1da0 k in atTop, P n k) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P n (\u03c6 n)", "start": [524, 1], "end": [534, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_forall_of_eventually", "code": "theorem extraction_forall_of_eventually {P : \u2115 \u2192 \u2115 \u2192 Prop} (h : \u2200 n, \u2200\u1da0 k in atTop, P n k) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P n (\u03c6 n)", "start": [537, 1], "end": [539, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.extraction_forall_of_eventually'", "code": "theorem extraction_forall_of_eventually' {P : \u2115 \u2192 \u2115 \u2192 Prop} (h : \u2200 n, \u2203 N, \u2200 k \u2265 N, P n k) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, P n (\u03c6 n)", "start": [542, 1], "end": [544, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.atTop_of_arithmetic", "code": "theorem Eventually.atTop_of_arithmetic {p : \u2115 \u2192 Prop} {n : \u2115} (hn : n \u2260 0)\n    (hp : \u2200 k < n, \u2200\u1da0 a in atTop, p (n * a + k)) : \u2200\u1da0 a in atTop, p a", "start": [547, 1], "end": [556, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_le_of_tendsto_atTop", "code": "theorem exists_le_of_tendsto_atTop [SemilatticeSup \u03b1] [Preorder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    (h : Tendsto u atTop atTop) (a : \u03b1) (b : \u03b2) : \u2203 a' \u2265 a, b \u2264 u a'", "start": [558, 1], "end": [563, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_le_of_tendsto_atBot", "code": "theorem exists_le_of_tendsto_atBot [SemilatticeSup \u03b1] [Preorder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    (h : Tendsto u atTop atBot) : \u2200 a b, \u2203 a' \u2265 a, u a' \u2264 b", "start": [567, 1], "end": [569, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_lt_of_tendsto_atTop", "code": "theorem exists_lt_of_tendsto_atTop [SemilatticeSup \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    (h : Tendsto u atTop atTop) (a : \u03b1) (b : \u03b2) : \u2203 a' \u2265 a, b < u a'", "start": [572, 1], "end": [576, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_lt_of_tendsto_atBot", "code": "theorem exists_lt_of_tendsto_atBot [SemilatticeSup \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2] {u : \u03b1 \u2192 \u03b2}\n    (h : Tendsto u atTop atBot) : \u2200 a b, \u2203 a' \u2265 a, u a' < b", "start": [580, 1], "end": [582, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.high_scores", "code": "theorem high_scores [LinearOrder \u03b2] [NoMaxOrder \u03b2] {u : \u2115 \u2192 \u03b2} (hu : Tendsto u atTop atTop) :\n    \u2200 N, \u2203 n \u2265 N, \u2200 k < n, u k < u n", "start": [585, 1], "end": [607, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.low_scores", "code": "theorem low_scores [LinearOrder \u03b2] [NoMinOrder \u03b2] {u : \u2115 \u2192 \u03b2} (hu : Tendsto u atTop atBot) :\n    \u2200 N, \u2203 n \u2265 N, \u2200 k < n, u n < u k", "start": [611, 1], "end": [617, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_high_scores", "code": "theorem frequently_high_scores [LinearOrder \u03b2] [NoMaxOrder \u03b2] {u : \u2115 \u2192 \u03b2}\n    (hu : Tendsto u atTop atTop) : \u2203\u1da0 n in atTop, \u2200 k < n, u k < u n", "start": [620, 1], "end": [625, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_low_scores", "code": "theorem frequently_low_scores [LinearOrder \u03b2] [NoMinOrder \u03b2] {u : \u2115 \u2192 \u03b2}\n    (hu : Tendsto u atTop atBot) : \u2203\u1da0 n in atTop, \u2200 k < n, u n < u k", "start": [628, 1], "end": [633, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.strictMono_subseq_of_tendsto_atTop", "code": "theorem strictMono_subseq_of_tendsto_atTop {\u03b2 : Type*} [LinearOrder \u03b2] [NoMaxOrder \u03b2] {u : \u2115 \u2192 \u03b2}\n    (hu : Tendsto u atTop atTop) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 StrictMono (u \u2218 \u03c6)", "start": [636, 1], "end": [639, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.strictMono_subseq_of_id_le", "code": "theorem strictMono_subseq_of_id_le {u : \u2115 \u2192 \u2115} (hu : \u2200 n, n \u2264 u n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 StrictMono (u \u2218 \u03c6)", "start": [642, 1], "end": [644, 72], "kind": "commanddeclaration"}, {"full_name": "StrictMono.tendsto_atTop", "code": "theorem _root_.StrictMono.tendsto_atTop {\u03c6 : \u2115 \u2192 \u2115} (h : StrictMono \u03c6) : Tendsto \u03c6 atTop atTop", "start": [647, 1], "end": [648, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_nonneg_left'", "code": "theorem tendsto_atTop_add_nonneg_left' (hf : \u2200\u1da0 x in l, 0 \u2264 f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [655, 1], "end": [657, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_nonpos_left'", "code": "theorem tendsto_atBot_add_nonpos_left' (hf : \u2200\u1da0 x in l, f x \u2264 0) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [660, 1], "end": [662, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_nonneg_left", "code": "theorem tendsto_atTop_add_nonneg_left (hf : \u2200 x, 0 \u2264 f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [665, 1], "end": [667, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_nonpos_left", "code": "theorem tendsto_atBot_add_nonpos_left (hf : \u2200 x, f x \u2264 0) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [670, 1], "end": [672, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_nonneg_right'", "code": "theorem tendsto_atTop_add_nonneg_right' (hf : Tendsto f l atTop) (hg : \u2200\u1da0 x in l, 0 \u2264 g x) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [675, 1], "end": [677, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_nonpos_right'", "code": "theorem tendsto_atBot_add_nonpos_right' (hf : Tendsto f l atBot) (hg : \u2200\u1da0 x in l, g x \u2264 0) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [680, 1], "end": [682, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_nonneg_right", "code": "theorem tendsto_atTop_add_nonneg_right (hf : Tendsto f l atTop) (hg : \u2200 x, 0 \u2264 g x) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [685, 1], "end": [687, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_nonpos_right", "code": "theorem tendsto_atBot_add_nonpos_right (hf : Tendsto f l atBot) (hg : \u2200 x, g x \u2264 0) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [690, 1], "end": [692, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add", "code": "theorem tendsto_atTop_add (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [695, 1], "end": [697, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add", "code": "theorem tendsto_atBot_add (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [700, 1], "end": [702, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nsmul_atTop", "code": "theorem Tendsto.nsmul_atTop (hf : Tendsto f l atTop) {n : \u2115} (hn : 0 < n) :\n    Tendsto (fun x => n \u2022 f x) l atTop", "start": [705, 1], "end": [713, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nsmul_atBot", "code": "theorem Tendsto.nsmul_atBot (hf : Tendsto f l atBot) {n : \u2115} (hn : 0 < n) :\n    Tendsto (fun x => n \u2022 f x) l atBot", "start": [716, 1], "end": [718, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_bit0_atTop", "code": "@[deprecated] theorem tendsto_bit0_atTop : Tendsto bit0 (atTop : Filter \u03b2) atTop", "start": [722, 1], "end": [723, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_bit0_atBot", "code": "@[deprecated] theorem tendsto_bit0_atBot : Tendsto bit0 (atBot : Filter \u03b2) atBot", "start": [727, 1], "end": [728, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_const_left", "code": "theorem tendsto_atTop_of_add_const_left (C : \u03b2) (hf : Tendsto (fun x => C + f x) l atTop) :\n    Tendsto f l atTop", "start": [737, 1], "end": [739, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_const_left", "code": "theorem tendsto_atBot_of_add_const_left (C : \u03b2) (hf : Tendsto (fun x => C + f x) l atBot) :\n    Tendsto f l atBot", "start": [743, 1], "end": [745, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_const_right", "code": "theorem tendsto_atTop_of_add_const_right (C : \u03b2) (hf : Tendsto (fun x => f x + C) l atTop) :\n    Tendsto f l atTop", "start": [748, 1], "end": [750, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_const_right", "code": "theorem tendsto_atBot_of_add_const_right (C : \u03b2) (hf : Tendsto (fun x => f x + C) l atBot) :\n    Tendsto f l atBot", "start": [754, 1], "end": [756, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_bdd_above_left'", "code": "theorem tendsto_atTop_of_add_bdd_above_left' (C) (hC : \u2200\u1da0 x in l, f x \u2264 C)\n    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto g l atTop", "start": [759, 1], "end": [762, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_bdd_below_left'", "code": "theorem tendsto_atBot_of_add_bdd_below_left' (C) (hC : \u2200\u1da0 x in l, C \u2264 f x)\n    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto g l atBot", "start": [766, 1], "end": [769, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_bdd_above_left", "code": "theorem tendsto_atTop_of_add_bdd_above_left (C) (hC : \u2200 x, f x \u2264 C) :\n    Tendsto (fun x => f x + g x) l atTop \u2192 Tendsto g l atTop", "start": [772, 1], "end": [774, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_bdd_below_left", "code": "theorem tendsto_atBot_of_add_bdd_below_left (C) (hC : \u2200 x, C \u2264 f x) :\n    Tendsto (fun x => f x + g x) l atBot \u2192 Tendsto g l atBot", "start": [778, 1], "end": [780, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_bdd_above_right'", "code": "theorem tendsto_atTop_of_add_bdd_above_right' (C) (hC : \u2200\u1da0 x in l, g x \u2264 C)\n    (h : Tendsto (fun x => f x + g x) l atTop) : Tendsto f l atTop", "start": [783, 1], "end": [786, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_bdd_below_right'", "code": "theorem tendsto_atBot_of_add_bdd_below_right' (C) (hC : \u2200\u1da0 x in l, C \u2264 g x)\n    (h : Tendsto (fun x => f x + g x) l atBot) : Tendsto f l atBot", "start": [790, 1], "end": [793, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_add_bdd_above_right", "code": "theorem tendsto_atTop_of_add_bdd_above_right (C) (hC : \u2200 x, g x \u2264 C) :\n    Tendsto (fun x => f x + g x) l atTop \u2192 Tendsto f l atTop", "start": [796, 1], "end": [798, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_add_bdd_below_right", "code": "theorem tendsto_atBot_of_add_bdd_below_right (C) (hC : \u2200 x, C \u2264 g x) :\n    Tendsto (fun x => f x + g x) l atBot \u2192 Tendsto f l atBot", "start": [802, 1], "end": [804, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_left_of_le'", "code": "theorem tendsto_atTop_add_left_of_le' (C : \u03b2) (hf : \u2200\u1da0 x in l, C \u2264 f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [813, 1], "end": [816, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_left_of_ge'", "code": "theorem tendsto_atBot_add_left_of_ge' (C : \u03b2) (hf : \u2200\u1da0 x in l, f x \u2264 C) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [819, 1], "end": [821, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_left_of_le", "code": "theorem tendsto_atTop_add_left_of_le (C : \u03b2) (hf : \u2200 x, C \u2264 f x) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [824, 1], "end": [826, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_left_of_ge", "code": "theorem tendsto_atBot_add_left_of_ge (C : \u03b2) (hf : \u2200 x, f x \u2264 C) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [829, 1], "end": [831, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_right_of_le'", "code": "theorem tendsto_atTop_add_right_of_le' (C : \u03b2) (hf : Tendsto f l atTop) (hg : \u2200\u1da0 x in l, C \u2264 g x) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [834, 1], "end": [837, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_right_of_ge'", "code": "theorem tendsto_atBot_add_right_of_ge' (C : \u03b2) (hf : Tendsto f l atBot) (hg : \u2200\u1da0 x in l, g x \u2264 C) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [840, 1], "end": [842, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_right_of_le", "code": "theorem tendsto_atTop_add_right_of_le (C : \u03b2) (hf : Tendsto f l atTop) (hg : \u2200 x, C \u2264 g x) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [845, 1], "end": [847, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_right_of_ge", "code": "theorem tendsto_atBot_add_right_of_ge (C : \u03b2) (hf : Tendsto f l atBot) (hg : \u2200 x, g x \u2264 C) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [850, 1], "end": [852, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_const_left", "code": "theorem tendsto_atTop_add_const_left (C : \u03b2) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => C + f x) l atTop", "start": [855, 1], "end": [857, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_const_left", "code": "theorem tendsto_atBot_add_const_left (C : \u03b2) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => C + f x) l atBot", "start": [860, 1], "end": [862, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_add_const_right", "code": "theorem tendsto_atTop_add_const_right (C : \u03b2) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x + C) l atTop", "start": [865, 1], "end": [867, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_add_const_right", "code": "theorem tendsto_atBot_add_const_right (C : \u03b2) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x + C) l atBot", "start": [870, 1], "end": [872, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.map_neg_atBot", "code": "theorem map_neg_atBot : map (Neg.neg : \u03b2 \u2192 \u03b2) atBot = atTop", "start": [875, 1], "end": [876, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map_neg_atTop", "code": "theorem map_neg_atTop : map (Neg.neg : \u03b2 \u2192 \u03b2) atTop = atBot", "start": [879, 1], "end": [880, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neg_atBot", "code": "@[simp]\ntheorem comap_neg_atBot : comap (Neg.neg : \u03b2 \u2192 \u03b2) atBot = atTop", "start": [883, 1], "end": [885, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_neg_atTop", "code": "@[simp]\ntheorem comap_neg_atTop : comap (Neg.neg : \u03b2 \u2192 \u03b2) atTop = atBot", "start": [888, 1], "end": [890, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_neg_atTop_atBot", "code": "theorem tendsto_neg_atTop_atBot : Tendsto (Neg.neg : \u03b2 \u2192 \u03b2) atTop atBot", "start": [893, 1], "end": [894, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_neg_atBot_atTop", "code": "theorem tendsto_neg_atBot_atTop : Tendsto (Neg.neg : \u03b2 \u2192 \u03b2) atBot atTop", "start": [897, 1], "end": [898, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_neg_atTop_iff", "code": "@[simp]\ntheorem tendsto_neg_atTop_iff : Tendsto (fun x => -f x) l atTop \u2194 Tendsto f l atBot", "start": [903, 1], "end": [905, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_neg_atBot_iff", "code": "@[simp]\ntheorem tendsto_neg_atBot_iff : Tendsto (fun x => -f x) l atBot \u2194 Tendsto f l atTop", "start": [908, 1], "end": [910, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_bit1_atTop", "code": "@[deprecated] theorem tendsto_bit1_atTop : Tendsto bit1 (atTop : Filter \u03b1) atTop", "start": [920, 1], "end": [921, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_atTop", "code": "theorem Tendsto.atTop_mul_atTop (hf : Tendsto f l atTop) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atTop", "start": [924, 1], "end": [928, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_self_atTop", "code": "theorem tendsto_mul_self_atTop : Tendsto (fun x : \u03b1 => x * x) atTop atTop", "start": [931, 1], "end": [932, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pow_atTop", "code": "theorem tendsto_pow_atTop {n : \u2115} (hn : n \u2260 0) : Tendsto (fun x : \u03b1 => x ^ n) atTop atTop", "start": [935, 1], "end": [938, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.zero_pow_eventuallyEq", "code": "theorem zero_pow_eventuallyEq [MonoidWithZero \u03b1] :\n    (fun n : \u2115 => (0 : \u03b1) ^ n) =\u1da0[atTop] fun _ => 0", "start": [943, 1], "end": [945, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_atBot", "code": "theorem Tendsto.atTop_mul_atBot (hf : Tendsto f l atTop) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atBot", "start": [952, 1], "end": [955, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_atTop", "code": "theorem Tendsto.atBot_mul_atTop (hf : Tendsto f l atBot) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x * g x) l atBot", "start": [958, 1], "end": [962, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_atBot", "code": "theorem Tendsto.atBot_mul_atBot (hf : Tendsto f l atBot) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x * g x) l atTop", "start": [965, 1], "end": [969, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_abs_atTop_atTop", "code": "theorem tendsto_abs_atTop_atTop : Tendsto (abs : \u03b1 \u2192 \u03b1) atTop atTop", "start": [978, 1], "end": [980, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_abs_atBot_atTop", "code": "theorem tendsto_abs_atBot_atTop : Tendsto (abs : \u03b1 \u2192 \u03b1) atBot atTop", "start": [983, 1], "end": [985, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_abs_atTop", "code": "@[simp]\ntheorem comap_abs_atTop : comap (abs : \u03b1 \u2192 \u03b1) atTop = atBot \u2294 atTop", "start": [988, 1], "end": [996, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_of_const_mul", "code": "theorem Tendsto.atTop_of_const_mul {c : \u03b1} (hc : 0 < c) (hf : Tendsto (fun x => c * f x) l atTop) :\n    Tendsto f l atTop", "start": [1005, 1], "end": [1008, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_of_mul_const", "code": "theorem Tendsto.atTop_of_mul_const {c : \u03b1} (hc : 0 < c) (hf : Tendsto (fun x => f x * c) l atTop) :\n    Tendsto f l atTop", "start": [1011, 1], "end": [1014, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_pow_atTop_iff", "code": "@[simp]\ntheorem tendsto_pow_atTop_iff {n : \u2115} : Tendsto (fun x : \u03b1 => x ^ n) atTop atTop \u2194 n \u2260 0", "start": [1017, 1], "end": [1019, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.nonneg_of_eventually_pow_nonneg", "code": "theorem nonneg_of_eventually_pow_nonneg [LinearOrderedRing \u03b1] {a : \u03b1}\n    (h : \u2200\u1da0 n in atTop, 0 \u2264 a ^ (n : \u2115)) : 0 \u2264 a", "start": [1026, 1], "end": [1029, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.not_tendsto_pow_atTop_atBot", "code": "theorem not_tendsto_pow_atTop_atBot [LinearOrderedRing \u03b1] :\n    \u2200 {n : \u2115}, \u00acTendsto (fun x : \u03b1 => x ^ n) atTop atBot", "start": [1032, 1], "end": [1035, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atTop_of_pos", "code": "theorem tendsto_const_mul_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x => r * f x) l atTop \u2194 Tendsto f l atTop", "start": [1047, 1], "end": [1052, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atTop_of_pos", "code": "theorem tendsto_mul_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atTop \u2194 Tendsto f l atTop", "start": [1055, 1], "end": [1059, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_div_const_atTop_of_pos", "code": "lemma tendsto_div_const_atTop_of_pos (hr : 0 < r) :\n    Tendsto (\u03bb x \u21a6 f x / r) l atTop \u2194 Tendsto f l atTop := by\n  simpa only [div_eq_mul_inv] using tendsto_mul_const_atTop_of_pos (inv_pos.2 hr)", "start": [1062, 1], "end": [1066, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.tendsto_const_mul_atTop_iff_pos", "code": "theorem tendsto_const_mul_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop \u2194 0 < r", "start": [1068, 1], "end": [1074, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atTop_iff_pos", "code": "theorem tendsto_mul_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop \u2194 0 < r", "start": [1077, 1], "end": [1081, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_div_const_atTop_iff_pos", "code": "lemma tendsto_div_const_atTop_iff_pos [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (\u03bb x \u21a6 f x / r) l atTop \u2194 0 < r := by\n  simp only [div_eq_mul_inv, tendsto_mul_const_atTop_iff_pos h, inv_pos]", "start": [1084, 1], "end": [1088, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.Tendsto.const_mul_atTop", "code": "theorem Tendsto.const_mul_atTop (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop", "start": [1090, 1], "end": [1095, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_const", "code": "theorem Tendsto.atTop_mul_const (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop", "start": [1098, 1], "end": [1103, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_div_const", "code": "theorem Tendsto.atTop_div_const (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x / r) l atTop", "start": [1106, 1], "end": [1110, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_pow_atTop", "code": "theorem tendsto_const_mul_pow_atTop (hn : n \u2260 0) (hc : 0 < c) :\n    Tendsto (fun x => c * x ^ n) atTop atTop", "start": [1113, 1], "end": [1115, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_pow_atTop_iff", "code": "theorem tendsto_const_mul_pow_atTop_iff :\n    Tendsto (fun x => c * x ^ n) atTop atTop \u2194 n \u2260 0 \u2227 0 < c", "start": [1118, 1], "end": [1124, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atBot_of_pos", "code": "theorem tendsto_const_mul_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => r * f x) l atBot \u2194 Tendsto f l atBot", "start": [1133, 1], "end": [1137, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atBot_of_pos", "code": "theorem tendsto_mul_const_atBot_of_pos (hr : 0 < r) :\n    Tendsto (fun x => f x * r) l atBot \u2194 Tendsto f l atBot", "start": [1140, 1], "end": [1144, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atTop_of_neg", "code": "theorem tendsto_const_mul_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atTop \u2194 Tendsto f l atBot", "start": [1147, 1], "end": [1151, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atTop_of_neg", "code": "theorem tendsto_mul_const_atTop_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atTop \u2194 Tendsto f l atBot", "start": [1154, 1], "end": [1158, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atBot_of_neg", "code": "theorem tendsto_const_mul_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => r * f x) l atBot \u2194 Tendsto f l atTop", "start": [1161, 1], "end": [1165, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atBot_of_neg", "code": "theorem tendsto_mul_const_atBot_of_neg (hr : r < 0) :\n    Tendsto (fun x => f x * r) l atBot \u2194 Tendsto f l atTop", "start": [1168, 1], "end": [1172, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atTop_iff", "code": "theorem tendsto_const_mul_atTop_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atTop \u2194 0 < r \u2227 Tendsto f l atTop \u2228 r < 0 \u2227 Tendsto f l atBot", "start": [1175, 1], "end": [1182, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atTop_iff", "code": "theorem tendsto_mul_const_atTop_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atTop \u2194 0 < r \u2227 Tendsto f l atTop \u2228 r < 0 \u2227 Tendsto f l atBot", "start": [1185, 1], "end": [1189, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atBot_iff", "code": "theorem tendsto_const_mul_atBot_iff [NeBot l] :\n    Tendsto (fun x => r * f x) l atBot \u2194 0 < r \u2227 Tendsto f l atBot \u2228 r < 0 \u2227 Tendsto f l atTop", "start": [1192, 1], "end": [1196, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atBot_iff", "code": "theorem tendsto_mul_const_atBot_iff [NeBot l] :\n    Tendsto (fun x => f x * r) l atBot \u2194 0 < r \u2227 Tendsto f l atBot \u2228 r < 0 \u2227 Tendsto f l atTop", "start": [1199, 1], "end": [1203, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atTop_iff_neg", "code": "theorem tendsto_const_mul_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atTop \u2194 r < 0", "start": [1206, 1], "end": [1210, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atTop_iff_neg", "code": "theorem tendsto_mul_const_atTop_iff_neg [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop \u2194 r < 0", "start": [1213, 1], "end": [1217, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atBot_iff_pos", "code": "theorem tendsto_const_mul_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atBot \u2194 0 < r", "start": [1220, 1], "end": [1224, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atBot_iff_pos", "code": "theorem tendsto_mul_const_atBot_iff_pos [NeBot l] (h : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot \u2194 0 < r", "start": [1227, 1], "end": [1231, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_atBot_iff_neg", "code": "theorem tendsto_const_mul_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atBot \u2194 r < 0", "start": [1234, 1], "end": [1238, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_const_atBot_iff_neg", "code": "theorem tendsto_mul_const_atBot_iff_neg [NeBot l] (h : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot \u2194 r < 0", "start": [1241, 1], "end": [1245, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.neg_const_mul_atTop", "code": "theorem Tendsto.neg_const_mul_atTop (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atBot", "start": [1248, 1], "end": [1252, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_neg_const", "code": "theorem Tendsto.atTop_mul_neg_const (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot", "start": [1255, 1], "end": [1259, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_mul_atBot", "code": "theorem Tendsto.const_mul_atBot (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atBot", "start": [1262, 1], "end": [1266, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_const", "code": "theorem Tendsto.atBot_mul_const (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot", "start": [1269, 1], "end": [1273, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_div_const", "code": "theorem Tendsto.atBot_div_const (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x / r) l atBot", "start": [1276, 1], "end": [1280, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.neg_const_mul_atBot", "code": "theorem Tendsto.neg_const_mul_atBot (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => r * f x) l atTop", "start": [1283, 1], "end": [1287, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_neg_const", "code": "theorem Tendsto.atBot_mul_neg_const (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop", "start": [1290, 1], "end": [1294, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_neg_const_mul_pow_atTop", "code": "theorem tendsto_neg_const_mul_pow_atTop {c : \u03b1} {n : \u2115} (hn : n \u2260 0) (hc : c < 0) :\n    Tendsto (fun x => c * x ^ n) atTop atBot", "start": [1297, 1], "end": [1299, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_const_mul_pow_atBot_iff", "code": "theorem tendsto_const_mul_pow_atBot_iff {c : \u03b1} {n : \u2115} :\n    Tendsto (fun x => c * x ^ n) atTop atBot \u2194 n \u2260 0 \u2227 c < 0", "start": [1302, 1], "end": [1304, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop'", "code": "theorem tendsto_atTop' [Nonempty \u03b1] [SemilatticeSup \u03b1] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} :\n    Tendsto f atTop l \u2194 \u2200 s \u2208 l, \u2203 a, \u2200 b \u2265 a, f b \u2208 s", "start": [1311, 1], "end": [1313, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot'", "code": "theorem tendsto_atBot' [Nonempty \u03b1] [SemilatticeInf \u03b1] {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} :\n    Tendsto f atBot l \u2194 \u2200 s \u2208 l, \u2203 a, \u2200 b \u2264 a, f b \u2208 s", "start": [1316, 1], "end": [1318, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_principal", "code": "theorem tendsto_atTop_principal [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b1} :\n    Tendsto f atTop (\ud835\udcdf s) \u2194 \u2203 N, \u2200 n \u2265 N, f n \u2208 s", "start": [1321, 1], "end": [1323, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_principal", "code": "theorem tendsto_atBot_principal [Nonempty \u03b2] [SemilatticeInf \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b1} :\n    Tendsto f atBot (\ud835\udcdf s) \u2194 \u2203 N, \u2200 n \u2264 N, f n \u2208 s", "start": [1326, 1], "end": [1328, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_atTop", "code": "theorem tendsto_atTop_atTop [Nonempty \u03b1] [SemilatticeSup \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Tendsto f atTop atTop \u2194 \u2200 b : \u03b2, \u2203 i : \u03b1, \u2200 a : \u03b1, i \u2264 a \u2192 b \u2264 f a", "start": [1331, 1], "end": [1334, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_atBot", "code": "theorem tendsto_atTop_atBot [Nonempty \u03b1] [SemilatticeSup \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Tendsto f atTop atBot \u2194 \u2200 b : \u03b2, \u2203 i : \u03b1, \u2200 a : \u03b1, i \u2264 a \u2192 f a \u2264 b", "start": [1337, 1], "end": [1339, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_atTop", "code": "theorem tendsto_atBot_atTop [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Tendsto f atBot atTop \u2194 \u2200 b : \u03b2, \u2203 i : \u03b1, \u2200 a : \u03b1, a \u2264 i \u2192 b \u2264 f a", "start": [1342, 1], "end": [1344, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_atBot", "code": "theorem tendsto_atBot_atBot [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Tendsto f atBot atBot \u2194 \u2200 b : \u03b2, \u2203 i : \u03b1, \u2200 a : \u03b1, a \u2264 i \u2192 f a \u2264 b", "start": [1347, 1], "end": [1349, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_atTop_of_monotone", "code": "theorem tendsto_atTop_atTop_of_monotone [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (h : \u2200 b, \u2203 a, b \u2264 f a) : Tendsto f atTop atTop", "start": [1352, 1], "end": [1357, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_atBot_of_monotone", "code": "theorem tendsto_atBot_atBot_of_monotone [Preorder \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Monotone f)\n    (h : \u2200 b, \u2203 a, f a \u2264 b) : Tendsto f atBot atBot", "start": [1360, 1], "end": [1363, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_atTop_iff_of_monotone", "code": "theorem tendsto_atTop_atTop_iff_of_monotone [Nonempty \u03b1] [SemilatticeSup \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Monotone f) : Tendsto f atTop atTop \u2194 \u2200 b : \u03b2, \u2203 a : \u03b1, b \u2264 f a", "start": [1366, 1], "end": [1369, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_atBot_iff_of_monotone", "code": "theorem tendsto_atBot_atBot_iff_of_monotone [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Monotone f) : Tendsto f atBot atBot \u2194 \u2200 b : \u03b2, \u2203 a : \u03b1, f a \u2264 b", "start": [1372, 1], "end": [1375, 69], "kind": "commanddeclaration"}, {"full_name": "Monotone.tendsto_atTop_atTop", "code": "alias _root_.Monotone.tendsto_atTop_atTop := tendsto_atTop_atTop_of_monotone", "start": [1378, 1], "end": [1378, 77], "kind": "stdtacticaliasalias"}, {"full_name": "Monotone.tendsto_atBot_atBot", "code": "alias _root_.Monotone.tendsto_atBot_atBot := tendsto_atBot_atBot_of_monotone", "start": [1381, 1], "end": [1381, 77], "kind": "stdtacticaliasalias"}, {"full_name": "Monotone.tendsto_atTop_atTop_iff", "code": "alias _root_.Monotone.tendsto_atTop_atTop_iff := tendsto_atTop_atTop_iff_of_monotone", "start": [1384, 1], "end": [1384, 85], "kind": "stdtacticaliasalias"}, {"full_name": "Monotone.tendsto_atBot_atBot_iff", "code": "alias _root_.Monotone.tendsto_atBot_atBot_iff := tendsto_atBot_atBot_iff_of_monotone", "start": [1387, 1], "end": [1387, 85], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.comap_embedding_atTop", "code": "theorem comap_embedding_atTop [Preorder \u03b2] [Preorder \u03b3] {e : \u03b2 \u2192 \u03b3}\n    (hm : \u2200 b\u2081 b\u2082, e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) (hu : \u2200 c, \u2203 b, c \u2264 e b) : comap e atTop = atTop", "start": [1390, 1], "end": [1395, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_embedding_atBot", "code": "theorem comap_embedding_atBot [Preorder \u03b2] [Preorder \u03b3] {e : \u03b2 \u2192 \u03b3}\n    (hm : \u2200 b\u2081 b\u2082, e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) (hu : \u2200 c, \u2203 b, e b \u2264 c) : comap e atBot = atBot", "start": [1398, 1], "end": [1400, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_embedding", "code": "theorem tendsto_atTop_embedding [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {e : \u03b2 \u2192 \u03b3} {l : Filter \u03b1}\n    (hm : \u2200 b\u2081 b\u2082, e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) (hu : \u2200 c, \u2203 b, c \u2264 e b) :\n    Tendsto (e \u2218 f) l atTop \u2194 Tendsto f l atTop", "start": [1403, 1], "end": [1406, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_embedding", "code": "theorem tendsto_atBot_embedding [Preorder \u03b2] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2} {e : \u03b2 \u2192 \u03b3} {l : Filter \u03b1}\n    (hm : \u2200 b\u2081 b\u2082, e b\u2081 \u2264 e b\u2082 \u2194 b\u2081 \u2264 b\u2082) (hu : \u2200 c, \u2203 b, e b \u2264 c) :\n    Tendsto (e \u2218 f) l atBot \u2194 Tendsto f l atBot", "start": [1409, 1], "end": [1413, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_finset_range", "code": "theorem tendsto_finset_range : Tendsto Finset.range atTop atTop", "start": [1416, 1], "end": [1417, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_finset_eq_iInf", "code": "theorem atTop_finset_eq_iInf : (atTop : Filter (Finset \u03b1)) = \u2a05 x : \u03b1, \ud835\udcdf (Ici {x})", "start": [1420, 1], "end": [1427, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_finset_of_monotone", "code": "theorem tendsto_atTop_finset_of_monotone [Preorder \u03b2] {f : \u03b2 \u2192 Finset \u03b1} (h : Monotone f)\n    (h' : \u2200 x : \u03b1, \u2203 n, x \u2208 f n) : Tendsto f atTop atTop", "start": [1430, 1], "end": [1437, 100], "kind": "commanddeclaration"}, {"full_name": "Monotone.tendsto_atTop_finset", "code": "alias _root_.Monotone.tendsto_atTop_finset := tendsto_atTop_finset_of_monotone", "start": [1440, 1], "end": [1440, 79], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.tendsto_finset_image_atTop_atTop", "code": "theorem tendsto_finset_image_atTop_atTop [DecidableEq \u03b2] {i : \u03b2 \u2192 \u03b3} {j : \u03b3 \u2192 \u03b2}\n    (h : Function.LeftInverse j i) : Tendsto (Finset.image j) atTop atTop", "start": [1444, 1], "end": [1447, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_finset_preimage_atTop_atTop", "code": "theorem tendsto_finset_preimage_atTop_atTop {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) :\n    Tendsto (fun s : Finset \u03b2 => s.preimage f (hf.injOn _)) atTop atTop", "start": [1450, 1], "end": [1453, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_atTop_atTop_eq", "code": "theorem prod_atTop_atTop_eq [Preorder \u03b1] [Preorder \u03b2] :\n    (atTop : Filter \u03b1) \u00d7\u02e2 (atTop : Filter \u03b2) = (atTop : Filter (\u03b1 \u00d7 \u03b2))", "start": [1457, 1], "end": [1461, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_atBot_atBot_eq", "code": "theorem prod_atBot_atBot_eq [Preorder \u03b2\u2081] [Preorder \u03b2\u2082] :\n    (atBot : Filter \u03b2\u2081) \u00d7\u02e2 (atBot : Filter \u03b2\u2082) = (atBot : Filter (\u03b2\u2081 \u00d7 \u03b2\u2082))", "start": [1465, 1], "end": [1467, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_atTop_eq", "code": "theorem prod_map_atTop_eq {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} [Preorder \u03b2\u2081] [Preorder \u03b2\u2082]\n    (u\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081) (u\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082) : map u\u2081 atTop \u00d7\u02e2 map u\u2082 atTop = map (Prod.map u\u2081 u\u2082) atTop", "start": [1471, 1], "end": [1473, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_map_atBot_eq", "code": "theorem prod_map_atBot_eq {\u03b1\u2081 \u03b1\u2082 \u03b2\u2081 \u03b2\u2082 : Type*} [Preorder \u03b2\u2081] [Preorder \u03b2\u2082]\n    (u\u2081 : \u03b2\u2081 \u2192 \u03b1\u2081) (u\u2082 : \u03b2\u2082 \u2192 \u03b1\u2082) : map u\u2081 atBot \u00d7\u02e2 map u\u2082 atBot = map (Prod.map u\u2081 u\u2082) atBot", "start": [1477, 1], "end": [1479, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.subseq_mem", "code": "theorem Tendsto.subseq_mem {F : Filter \u03b1} {V : \u2115 \u2192 Set \u03b1} (h : \u2200 n, V n \u2208 F) {u : \u2115 \u2192 \u03b1}\n    (hu : Tendsto u atTop F) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, u (\u03c6 n) \u2208 V n", "start": [1482, 1], "end": [1485, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_diagonal", "code": "theorem tendsto_atBot_diagonal [SemilatticeInf \u03b1] : Tendsto (fun a : \u03b1 => (a, a)) atBot atBot", "start": [1488, 1], "end": [1490, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_diagonal", "code": "theorem tendsto_atTop_diagonal [SemilatticeSup \u03b1] : Tendsto (fun a : \u03b1 => (a, a)) atTop atTop", "start": [1493, 1], "end": [1495, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_map_prod_atBot", "code": "theorem Tendsto.prod_map_prod_atBot [SemilatticeInf \u03b3] {F : Filter \u03b1} {G : Filter \u03b2} {f : \u03b1 \u2192 \u03b3}\n    {g : \u03b2 \u2192 \u03b3} (hf : Tendsto f F atBot) (hg : Tendsto g G atBot) :\n    Tendsto (Prod.map f g) (F \u00d7\u02e2 G) atBot", "start": [1498, 1], "end": [1502, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_map_prod_atTop", "code": "theorem Tendsto.prod_map_prod_atTop [SemilatticeSup \u03b3] {F : Filter \u03b1} {G : Filter \u03b2} {f : \u03b1 \u2192 \u03b3}\n    {g : \u03b2 \u2192 \u03b3} (hf : Tendsto f F atTop) (hg : Tendsto g G atTop) :\n    Tendsto (Prod.map f g) (F \u00d7\u02e2 G) atTop", "start": [1505, 1], "end": [1509, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_atBot", "code": "theorem Tendsto.prod_atBot [SemilatticeInf \u03b1] [SemilatticeInf \u03b3] {f g : \u03b1 \u2192 \u03b3}\n    (hf : Tendsto f atBot atBot) (hg : Tendsto g atBot atBot) :\n    Tendsto (Prod.map f g) atBot atBot", "start": [1512, 1], "end": [1516, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_atTop", "code": "theorem Tendsto.prod_atTop [SemilatticeSup \u03b1] [SemilatticeSup \u03b3] {f g : \u03b1 \u2192 \u03b3}\n    (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    Tendsto (Prod.map f g) atTop atTop", "start": [1519, 1], "end": [1523, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atBot_prod_self", "code": "theorem eventually_atBot_prod_self [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atBot, p x) \u2194 \u2203 a, \u2200 k l, k \u2264 a \u2192 l \u2264 a \u2192 p (k, l)", "start": [1526, 1], "end": [1528, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atTop_prod_self", "code": "theorem eventually_atTop_prod_self [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atTop, p x) \u2194 \u2203 a, \u2200 k l, a \u2264 k \u2192 a \u2264 l \u2192 p (k, l)", "start": [1531, 1], "end": [1533, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atBot_prod_self'", "code": "theorem eventually_atBot_prod_self' [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atBot, p x) \u2194 \u2203 a, \u2200 k \u2264 a, \u2200 l \u2264 a, p (k, l)", "start": [1536, 1], "end": [1538, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atTop_prod_self'", "code": "theorem eventually_atTop_prod_self' [SemilatticeSup \u03b1] [Nonempty \u03b1] {p : \u03b1 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in atTop, p x) \u2194 \u2203 a, \u2200 k \u2265 a, \u2200 l \u2265 a, p (k, l)", "start": [1541, 1], "end": [1543, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atTop_curry", "code": "theorem eventually_atTop_curry [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] {p : \u03b1 \u00d7 \u03b2 \u2192 Prop}\n    (hp : \u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in Filter.atTop, p x) : \u2200\u1da0 k in atTop, \u2200\u1da0 l in atTop, p (k, l)", "start": [1546, 1], "end": [1549, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_atBot_curry", "code": "theorem eventually_atBot_curry [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] {p : \u03b1 \u00d7 \u03b2 \u2192 Prop}\n    (hp : \u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in Filter.atBot, p x) : \u2200\u1da0 k in atBot, \u2200\u1da0 l in atBot, p (k, l)", "start": [1552, 1], "end": [1554, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.map_atTop_eq_of_gc", "code": "theorem map_atTop_eq_of_gc [SemilatticeSup \u03b1] [SemilatticeSup \u03b2] {f : \u03b1 \u2192 \u03b2} (g : \u03b2 \u2192 \u03b1) (b' : \u03b2)\n    (hf : Monotone f) (gc : \u2200 a, \u2200 b \u2265 b', f a \u2264 b \u2194 a \u2264 g b) (hgi : \u2200 b \u2265 b', b \u2264 f (g b)) :\n    map f atTop = atTop", "start": [1557, 1], "end": [1569, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.map_atBot_eq_of_gc", "code": "theorem map_atBot_eq_of_gc [SemilatticeInf \u03b1] [SemilatticeInf \u03b2] {f : \u03b1 \u2192 \u03b2} (g : \u03b2 \u2192 \u03b1) (b' : \u03b2)\n    (hf : Monotone f) (gc : \u2200 a, \u2200 b \u2264 b', b \u2264 f a \u2194 g b \u2264 a) (hgi : \u2200 b \u2264 b', f (g b) \u2264 b) :\n    map f atBot = atBot", "start": [1572, 1], "end": [1575, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.map_val_atTop_of_Ici_subset", "code": "theorem map_val_atTop_of_Ici_subset [SemilatticeSup \u03b1] {a : \u03b1} {s : Set \u03b1} (h : Ici a \u2286 s) :\n    map ((\u2191) : s \u2192 \u03b1) atTop = atTop", "start": [1578, 1], "end": [1595, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.map_val_Ici_atTop", "code": "@[simp]\ntheorem map_val_Ici_atTop [SemilatticeSup \u03b1] (a : \u03b1) : map ((\u2191) : Ici a \u2192 \u03b1) atTop = atTop", "start": [1598, 1], "end": [1601, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.map_val_Ioi_atTop", "code": "@[simp]\ntheorem map_val_Ioi_atTop [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    map ((\u2191) : Ioi a \u2192 \u03b1) atTop = atTop", "start": [1604, 1], "end": [1609, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_Ioi_eq", "code": "theorem atTop_Ioi_eq [SemilatticeSup \u03b1] (a : \u03b1) : atTop = comap ((\u2191) : Ioi a \u2192 \u03b1) atTop", "start": [1612, 1], "end": [1617, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_Ici_eq", "code": "theorem atTop_Ici_eq [SemilatticeSup \u03b1] (a : \u03b1) : atTop = comap ((\u2191) : Ici a \u2192 \u03b1) atTop", "start": [1620, 1], "end": [1623, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.map_val_Iio_atBot", "code": "@[simp]\ntheorem map_val_Iio_atBot [SemilatticeInf \u03b1] [NoMinOrder \u03b1] (a : \u03b1) :\n    map ((\u2191) : Iio a \u2192 \u03b1) atBot = atBot", "start": [1626, 1], "end": [1631, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_Iio_eq", "code": "theorem atBot_Iio_eq [SemilatticeInf \u03b1] (a : \u03b1) : atBot = comap ((\u2191) : Iio a \u2192 \u03b1) atBot", "start": [1634, 1], "end": [1637, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.map_val_Iic_atBot", "code": "@[simp]\ntheorem map_val_Iic_atBot [SemilatticeInf \u03b1] (a : \u03b1) : map ((\u2191) : Iic a \u2192 \u03b1) atBot = atBot", "start": [1640, 1], "end": [1644, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.atBot_Iic_eq", "code": "theorem atBot_Iic_eq [SemilatticeInf \u03b1] (a : \u03b1) : atBot = comap ((\u2191) : Iic a \u2192 \u03b1) atBot", "start": [1647, 1], "end": [1650, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioi_atTop", "code": "theorem tendsto_Ioi_atTop [SemilatticeSup \u03b1] {a : \u03b1} {f : \u03b2 \u2192 Ioi a} {l : Filter \u03b2} :\n    Tendsto f l atTop \u2194 Tendsto (fun x => (f x : \u03b1)) l atTop", "start": [1653, 1], "end": [1655, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Iio_atBot", "code": "theorem tendsto_Iio_atBot [SemilatticeInf \u03b1] {a : \u03b1} {f : \u03b2 \u2192 Iio a} {l : Filter \u03b2} :\n    Tendsto f l atBot \u2194 Tendsto (fun x => (f x : \u03b1)) l atBot", "start": [1658, 1], "end": [1660, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ici_atTop", "code": "theorem tendsto_Ici_atTop [SemilatticeSup \u03b1] {a : \u03b1} {f : \u03b2 \u2192 Ici a} {l : Filter \u03b2} :\n    Tendsto f l atTop \u2194 Tendsto (fun x => (f x : \u03b1)) l atTop", "start": [1663, 1], "end": [1665, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Iic_atBot", "code": "theorem tendsto_Iic_atBot [SemilatticeInf \u03b1] {a : \u03b1} {f : \u03b2 \u2192 Iic a} {l : Filter \u03b2} :\n    Tendsto f l atBot \u2194 Tendsto (fun x => (f x : \u03b1)) l atBot", "start": [1668, 1], "end": [1670, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comp_val_Ioi_atTop", "code": "@[simp, nolint simpNF] theorem tendsto_comp_val_Ioi_atTop [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2}\n    {l : Filter \u03b2} : Tendsto (fun x : Ioi a => f x) atTop l \u2194 Tendsto f atTop l", "start": [1673, 1], "end": [1676, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comp_val_Ici_atTop", "code": "@[simp, nolint simpNF] theorem tendsto_comp_val_Ici_atTop [SemilatticeSup \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} :\n    Tendsto (fun x : Ici a => f x) atTop l \u2194 Tendsto f atTop l", "start": [1679, 1], "end": [1682, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comp_val_Iio_atBot", "code": "@[simp, nolint simpNF] theorem tendsto_comp_val_Iio_atBot [SemilatticeInf \u03b1] [NoMinOrder \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2}\n    {l : Filter \u03b2} : Tendsto (fun x : Iio a => f x) atBot l \u2194 Tendsto f atBot l", "start": [1685, 1], "end": [1688, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_comp_val_Iic_atBot", "code": "@[simp, nolint simpNF] theorem tendsto_comp_val_Iic_atBot [SemilatticeInf \u03b1] {a : \u03b1} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b2} :\n    Tendsto (fun x : Iic a => f x) atBot l \u2194 Tendsto f atBot l", "start": [1691, 1], "end": [1694, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.map_add_atTop_eq_nat", "code": "theorem map_add_atTop_eq_nat (k : \u2115) : map (fun a => a + k) atTop = atTop", "start": [1697, 1], "end": [1699, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.map_sub_atTop_eq_nat", "code": "theorem map_sub_atTop_eq_nat (k : \u2115) : map (fun a => a - k) atTop = atTop", "start": [1702, 1], "end": [1704, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_add_atTop_nat", "code": "theorem tendsto_add_atTop_nat (k : \u2115) : Tendsto (fun a => a + k) atTop atTop", "start": [1707, 1], "end": [1708, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_sub_atTop_nat", "code": "theorem tendsto_sub_atTop_nat (k : \u2115) : Tendsto (fun a => a - k) atTop atTop", "start": [1711, 1], "end": [1712, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_add_atTop_iff_nat", "code": "theorem tendsto_add_atTop_iff_nat {f : \u2115 \u2192 \u03b1} {l : Filter \u03b1} (k : \u2115) :\n    Tendsto (fun n => f (n + k)) atTop l \u2194 Tendsto f atTop l", "start": [1715, 1], "end": [1718, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.map_div_atTop_eq_nat", "code": "theorem map_div_atTop_eq_nat (k : \u2115) (hk : 0 < k) : map (fun a => a / k) atTop = atTop", "start": [1721, 1], "end": [1729, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_atTop_of_monotone'", "code": "theorem tendsto_atTop_atTop_of_monotone' [Preorder \u03b9] [LinearOrder \u03b1] {u : \u03b9 \u2192 \u03b1} (h : Monotone u)\n    (H : \u00acBddAbove (range u)) : Tendsto u atTop atTop", "start": [1732, 1], "end": [1739, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_atBot_of_monotone'", "code": "theorem tendsto_atBot_atBot_of_monotone' [Preorder \u03b9] [LinearOrder \u03b1] {u : \u03b9 \u2192 \u03b1} (h : Monotone u)\n    (H : \u00acBddBelow (range u)) : Tendsto u atBot atBot", "start": [1742, 1], "end": [1746, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.unbounded_of_tendsto_atTop", "code": "theorem unbounded_of_tendsto_atTop [Nonempty \u03b1] [SemilatticeSup \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : Tendsto f atTop atTop) : \u00acBddAbove (range f)", "start": [1749, 1], "end": [1756, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.unbounded_of_tendsto_atBot", "code": "theorem unbounded_of_tendsto_atBot [Nonempty \u03b1] [SemilatticeSup \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : Tendsto f atTop atBot) : \u00acBddBelow (range f)", "start": [1759, 1], "end": [1761, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.unbounded_of_tendsto_atTop'", "code": "theorem unbounded_of_tendsto_atTop' [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : Tendsto f atBot atTop) : \u00acBddAbove (range f)", "start": [1764, 1], "end": [1766, 48], "kind": "commanddeclaration"}, {"full_name": "Filter.unbounded_of_tendsto_atBot'", "code": "theorem unbounded_of_tendsto_atBot' [Nonempty \u03b1] [SemilatticeInf \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : Tendsto f atBot atBot) : \u00acBddBelow (range f)", "start": [1769, 1], "end": [1771, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_monotone_of_filter", "code": "theorem tendsto_atTop_of_monotone_of_filter [Preorder \u03b9] [Preorder \u03b1] {l : Filter \u03b9} {u : \u03b9 \u2192 \u03b1}\n    (h : Monotone u) [NeBot l] (hu : Tendsto u l atTop) : Tendsto u atTop atTop", "start": [1774, 1], "end": [1778, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_monotone_of_filter", "code": "theorem tendsto_atBot_of_monotone_of_filter [Preorder \u03b9] [Preorder \u03b1] {l : Filter \u03b9} {u : \u03b9 \u2192 \u03b1}\n    (h : Monotone u) [NeBot l] (hu : Tendsto u l atBot) : Tendsto u atBot atBot", "start": [1781, 1], "end": [1785, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atTop_of_monotone_of_subseq", "code": "theorem tendsto_atTop_of_monotone_of_subseq [Preorder \u03b9] [Preorder \u03b1] {u : \u03b9 \u2192 \u03b1} {\u03c6 : \u03b9' \u2192 \u03b9}\n    (h : Monotone u) {l : Filter \u03b9'} [NeBot l] (H : Tendsto (u \u2218 \u03c6) l atTop) :\n    Tendsto u atTop atTop", "start": [1788, 1], "end": [1791, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_atBot_of_monotone_of_subseq", "code": "theorem tendsto_atBot_of_monotone_of_subseq [Preorder \u03b9] [Preorder \u03b1] {u : \u03b9 \u2192 \u03b1} {\u03c6 : \u03b9' \u2192 \u03b9}\n    (h : Monotone u) {l : Filter \u03b9'} [NeBot l] (H : Tendsto (u \u2218 \u03c6) l atBot) :\n    Tendsto u atBot atBot", "start": [1794, 1], "end": [1797, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.map_atTop_finset_prod_le_of_prod_eq", "code": "@[to_additive \"Let `f` and `g` be two maps to the same commutative additive monoid. This lemma gives\na sufficient condition for comparison of the filter `atTop.map (fun s \u21a6 \u2211 b in s, f b)` with\n`atTop.map (fun s \u21a6 \u2211 b in s, g b)`. This is useful to compare the set of limit points of\n`\u2211 b in s, f b` as `s \u2192 atTop` with the similar set for `g`.\"]\ntheorem map_atTop_finset_prod_le_of_prod_eq [CommMonoid \u03b1] {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1}\n    (h_eq : \u2200 u : Finset \u03b3,\n      \u2203 v : Finset \u03b2, \u2200 v', v \u2286 v' \u2192 \u2203 u', u \u2286 u' \u2227 \u220f x in u', g x = \u220f b in v', f b) :\n    (atTop.map fun s : Finset \u03b2 => \u220f b in s, f b) \u2264\n      atTop.map fun s : Finset \u03b3 => \u220f x in s, g x", "start": [1800, 1], "end": [1817, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.eventually_subset", "code": "theorem HasAntitoneBasis.eventually_subset [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n    (hl : l.HasAntitoneBasis s) {t : Set \u03b1} (ht : t \u2208 l) : \u2200\u1da0 i in atTop, s i \u2286 t", "start": [1821, 1], "end": [1824, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.tendsto", "code": "protected theorem HasAntitoneBasis.tendsto [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n    (hl : l.HasAntitoneBasis s) {\u03c6 : \u03b9 \u2192 \u03b1} (h : \u2200 i : \u03b9, \u03c6 i \u2208 s i) : Tendsto \u03c6 atTop l", "start": [1827, 1], "end": [1829, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.comp_mono", "code": "theorem HasAntitoneBasis.comp_mono [SemilatticeSup \u03b9] [Nonempty \u03b9] [Preorder \u03b9'] {l : Filter \u03b1}\n    {s : \u03b9' \u2192 Set \u03b1} (hs : l.HasAntitoneBasis s) {\u03c6 : \u03b9 \u2192 \u03b9'} (\u03c6_mono : Monotone \u03c6)\n    (h\u03c6 : Tendsto \u03c6 atTop atTop) : l.HasAntitoneBasis (s \u2218 \u03c6)", "start": [1832, 1], "end": [1838, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.comp_strictMono", "code": "theorem HasAntitoneBasis.comp_strictMono {l : Filter \u03b1} {s : \u2115 \u2192 Set \u03b1} (hs : l.HasAntitoneBasis s)\n    {\u03c6 : \u2115 \u2192 \u2115} (h\u03c6 : StrictMono \u03c6) : l.HasAntitoneBasis (s \u2218 \u03c6)", "start": [1841, 1], "end": [1843, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.subbasis_with_rel", "code": "theorem HasAntitoneBasis.subbasis_with_rel {f : Filter \u03b1} {s : \u2115 \u2192 Set \u03b1}\n    (hs : f.HasAntitoneBasis s) {r : \u2115 \u2192 \u2115 \u2192 Prop} (hr : \u2200 m, \u2200\u1da0 n in atTop, r m n) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 (\u2200 \u2983m n\u2984, m < n \u2192 r (\u03c6 m) (\u03c6 n)) \u2227 f.HasAntitoneBasis (s \u2218 \u03c6)", "start": [1846, 1], "end": [1860, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_seq_tendsto", "code": "theorem exists_seq_tendsto (f : Filter \u03b1) [IsCountablyGenerated f] [NeBot f] :\n    \u2203 x : \u2115 \u2192 \u03b1, Tendsto x atTop f", "start": [1863, 1], "end": [1869, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_seq_monotone_tendsto_atTop_atTop", "code": "theorem exists_seq_monotone_tendsto_atTop_atTop (\u03b1 : Type*) [SemilatticeSup \u03b1] [Nonempty \u03b1]\n    [(atTop : Filter \u03b1).IsCountablyGenerated] :\n    \u2203 xs : \u2115 \u2192 \u03b1, Monotone xs \u2227 Tendsto xs atTop atTop", "start": [1872, 1], "end": [1896, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_seq_antitone_tendsto_atTop_atBot", "code": "theorem exists_seq_antitone_tendsto_atTop_atBot (\u03b1 : Type*) [SemilatticeInf \u03b1] [Nonempty \u03b1]\n    [h2 : (atBot : Filter \u03b1).IsCountablyGenerated] :\n    \u2203 xs : \u2115 \u2192 \u03b1, Antitone xs \u2227 Tendsto xs atTop atBot", "start": [1899, 1], "end": [1902, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_seq_tendsto", "code": "theorem tendsto_iff_seq_tendsto {f : \u03b1 \u2192 \u03b2} {k : Filter \u03b1} {l : Filter \u03b2} [k.IsCountablyGenerated] :\n    Tendsto f k l \u2194 \u2200 x : \u2115 \u2192 \u03b1, Tendsto x atTop k \u2192 Tendsto (f \u2218 x) atTop l", "start": [1905, 1], "end": [1917, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_of_seq_tendsto", "code": "theorem tendsto_of_seq_tendsto {f : \u03b1 \u2192 \u03b2} {k : Filter \u03b1} {l : Filter \u03b2} [k.IsCountablyGenerated] :\n    (\u2200 x : \u2115 \u2192 \u03b1, Tendsto x atTop k \u2192 Tendsto (f \u2218 x) atTop l) \u2192 Tendsto f k l", "start": [1920, 1], "end": [1922, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_forall_eventually_mem", "code": "theorem tendsto_iff_forall_eventually_mem {x : \u03b9 \u2192 \u03b1} {f : Filter \u03b1} {l : Filter \u03b9} :\n    Tendsto x l f \u2194 \u2200 s \u2208 f, \u2200\u1da0 n in l, x n \u2208 s", "start": [1926, 1], "end": [1928, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.not_tendsto_iff_exists_frequently_nmem", "code": "theorem not_tendsto_iff_exists_frequently_nmem {x : \u03b9 \u2192 \u03b1} {f : Filter \u03b1} {l : Filter \u03b9} :\n    \u00acTendsto x l f \u2194 \u2203 s \u2208 f, \u2203\u1da0 n in l, x n \u2209 s", "start": [1932, 1], "end": [1934, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_iff_seq_frequently", "code": "theorem frequently_iff_seq_frequently {\u03b9 : Type*} {l : Filter \u03b9} {p : \u03b9 \u2192 Prop}\n    [hl : l.IsCountablyGenerated] :\n    (\u2203\u1da0 n in l, p n) \u2194 \u2203 x : \u2115 \u2192 \u03b9, Tendsto x atTop l \u2227 \u2203\u1da0 n : \u2115 in atTop, p (x n)", "start": [1937, 1], "end": [1952, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_iff_seq_eventually", "code": "theorem eventually_iff_seq_eventually {\u03b9 : Type*} {l : Filter \u03b9} {p : \u03b9 \u2192 Prop}\n    [hl : l.IsCountablyGenerated] :\n    (\u2200\u1da0 n in l, p n) \u2194 \u2200 x : \u2115 \u2192 \u03b9, Tendsto x atTop l \u2192 \u2200\u1da0 n : \u2115 in atTop, p (x n)", "start": [1955, 1], "end": [1963, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.subseq_forall_of_frequently", "code": "theorem subseq_forall_of_frequently {\u03b9 : Type*} {x : \u2115 \u2192 \u03b9} {p : \u03b9 \u2192 Prop} {l : Filter \u03b9}\n    (h_tendsto : Tendsto x atTop l) (h : \u2203\u1da0 n in atTop, p (x n)) :\n    \u2203 ns : \u2115 \u2192 \u2115, Tendsto (fun n => x (ns n)) atTop l \u2227 \u2200 n, p (x (ns n))", "start": [1966, 1], "end": [1971, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_seq_forall_of_frequently", "code": "theorem exists_seq_forall_of_frequently {\u03b9 : Type*} {l : Filter \u03b9} {p : \u03b9 \u2192 Prop}\n    [hl : l.IsCountablyGenerated] (h : \u2203\u1da0 n in l, p n) :\n    \u2203 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop l \u2227 \u2200 n, p (ns n)", "start": [1974, 1], "end": [1980, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_of_subseq_tendsto", "code": "theorem tendsto_of_subseq_tendsto {\u03b1 \u03b9 : Type*} {x : \u03b9 \u2192 \u03b1} {f : Filter \u03b1} {l : Filter \u03b9}\n    [l.IsCountablyGenerated]\n    (hxy :\n      \u2200 ns : \u2115 \u2192 \u03b9, Tendsto ns atTop l \u2192 \u2203 ms : \u2115 \u2192 \u2115, Tendsto (fun n => x (ns <| ms n)) atTop f) :\n    Tendsto x l f", "start": [1983, 1], "end": [2003, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.subseq_tendsto_of_neBot", "code": "theorem subseq_tendsto_of_neBot {f : Filter \u03b1} [IsCountablyGenerated f] {u : \u2115 \u2192 \u03b1}\n    (hx : NeBot (f \u2293 map u atTop)) : \u2203 \u03b8 : \u2115 \u2192 \u2115, StrictMono \u03b8 \u2227 Tendsto (u \u2218 \u03b8) atTop f", "start": [2006, 1], "end": [2017, 51], "kind": "commanddeclaration"}, {"full_name": "exists_lt_mul_self", "code": "theorem exists_lt_mul_self (a : R) : \u2203 x \u2265 0, a < x * x", "start": [2028, 1], "end": [2031, 16], "kind": "commanddeclaration"}, {"full_name": "exists_le_mul_self", "code": "theorem exists_le_mul_self (a : R) : \u2203 x \u2265 0, a \u2264 x * x", "start": [2034, 1], "end": [2036, 19], "kind": "commanddeclaration"}, {"full_name": "Monotone.piecewise_eventually_eq_iUnion", "code": "theorem Monotone.piecewise_eventually_eq_iUnion {\u03b2 : \u03b1 \u2192 Type*} [Preorder \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    [\u2200 i, DecidablePred (\u00b7 \u2208 s i)] [DecidablePred (\u00b7 \u2208 \u22c3 i, s i)]\n    (hs : Monotone s) (f g : (a : \u03b1) \u2192 \u03b2 a) (a : \u03b1) :\n    \u2200\u1da0 i in atTop, (s i).piecewise f g a = (\u22c3 i, s i).piecewise f g a", "start": [2041, 1], "end": [2049, 83], "kind": "commanddeclaration"}, {"full_name": "Antitone.piecewise_eventually_eq_iInter", "code": "theorem Antitone.piecewise_eventually_eq_iInter {\u03b2 : \u03b1 \u2192 Type*} [Preorder \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    [\u2200 i, DecidablePred (\u00b7 \u2208 s i)] [DecidablePred (\u00b7 \u2208 \u22c2 i, s i)]\n    (hs : Antitone s) (f g : (a : \u03b1) \u2192 \u03b2 a) (a : \u03b1) :\n    \u2200\u1da0 i in atTop, (s i).piecewise f g a = (\u22c2 i, s i).piecewise f g a", "start": [2051, 1], "end": [2058, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.map_atTop_finset_prod_eq", "code": "@[to_additive]\ntheorem Function.Injective.map_atTop_finset_prod_eq [CommMonoid \u03b1] {g : \u03b3 \u2192 \u03b2}\n    (hg : Function.Injective g) {f : \u03b2 \u2192 \u03b1} (hf : \u2200 x, x \u2209 Set.range g \u2192 f x = 1) :\n    map (fun s => \u220f i in s, f (g i)) atTop = map (fun s => \u220f i in s, f i) atTop", "start": [2060, 1], "end": [2082, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Zorn.lean", "imports": ["Mathlib/Order/Chain.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "exists_maximal_of_chains_bounded", "code": "theorem exists_maximal_of_chains_bounded (h : \u2200 c, IsChain r c \u2192 \u2203 ub, \u2200 a \u2208 c, a \u227a ub)\n    (trans : \u2200 {a b c}, a \u227a b \u2192 b \u227a c \u2192 a \u227a c) : \u2203 m, \u2200 a, m \u227a a \u2192 a \u227a m", "start": [73, 1], "end": [85, 28], "kind": "commanddeclaration"}, {"full_name": "exists_maximal_of_nonempty_chains_bounded", "code": "theorem exists_maximal_of_nonempty_chains_bounded [Nonempty \u03b1]\n    (h : \u2200 c, IsChain r c \u2192 c.Nonempty \u2192 \u2203 ub, \u2200 a \u2208 c, a \u227a ub)\n    (trans : \u2200 {a b c}, a \u227a b \u2192 b \u227a c \u2192 a \u227a c) : \u2203 m, \u2200 a, m \u227a a \u2192 a \u227a m", "start": [88, 1], "end": [98, 10], "kind": "commanddeclaration"}, {"full_name": "zorn_preorder", "code": "theorem zorn_preorder (h : \u2200 c : Set \u03b1, IsChain (\u00b7 \u2264 \u00b7) c \u2192 BddAbove c) :\n    \u2203 m : \u03b1, \u2200 a, m \u2264 a \u2192 a \u2264 m", "start": [105, 1], "end": [107, 46], "kind": "commanddeclaration"}, {"full_name": "zorn_nonempty_preorder", "code": "theorem zorn_nonempty_preorder [Nonempty \u03b1]\n    (h : \u2200 c : Set \u03b1, IsChain (\u00b7 \u2264 \u00b7) c \u2192 c.Nonempty \u2192 BddAbove c) : \u2203 m : \u03b1, \u2200 a, m \u2264 a \u2192 a \u2264 m", "start": [110, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "zorn_preorder\u2080", "code": "theorem zorn_preorder\u2080 (s : Set \u03b1)\n    (ih : \u2200 (c) (_ : c \u2286 s), IsChain (\u00b7 \u2264 \u00b7) c \u2192 \u2203 ub \u2208 s, \u2200 z \u2208 c, z \u2264 ub) :\n    \u2203 m \u2208 s, \u2200 z \u2208 s, m \u2264 z \u2192 z \u2264 m", "start": [115, 1], "end": [126, 44], "kind": "commanddeclaration"}, {"full_name": "zorn_nonempty_preorder\u2080", "code": "theorem zorn_nonempty_preorder\u2080 (s : Set \u03b1)\n    (ih : \u2200 (c) (_ : c \u2286 s), IsChain (\u00b7 \u2264 \u00b7) c \u2192 \u2200 y \u2208 c, \u2203 ub \u2208 s, \u2200 z \u2208 c, z \u2264 ub) (x : \u03b1)\n    (hxs : x \u2208 s) : \u2203 m \u2208 s, x \u2264 m \u2227 \u2200 z \u2208 s, m \u2264 z \u2192 z \u2264 m", "start": [129, 1], "end": [142, 56], "kind": "commanddeclaration"}, {"full_name": "zorn_nonempty_Ici\u2080", "code": "theorem zorn_nonempty_Ici\u2080 (a : \u03b1)\n    (ih : \u2200 (c) (_ : c \u2286 Ici a), IsChain (\u00b7 \u2264 \u00b7) c \u2192 \u2200 y \u2208 c, \u2203 ub, a \u2264 ub \u2227 \u2200 z \u2208 c, z \u2264 ub)\n    (x : \u03b1) (hax : a \u2264 x) : \u2203 m, x \u2264 m \u2227 \u2200 z, m \u2264 z \u2192 z \u2264 m", "start": [145, 1], "end": [149, 63], "kind": "commanddeclaration"}, {"full_name": "zorn_partialOrder", "code": "theorem zorn_partialOrder (h : \u2200 c : Set \u03b1, IsChain (\u00b7 \u2264 \u00b7) c \u2192 BddAbove c) :\n    \u2203 m : \u03b1, \u2200 a, m \u2264 a \u2192 a = m", "start": [158, 1], "end": [161, 44], "kind": "commanddeclaration"}, {"full_name": "zorn_nonempty_partialOrder", "code": "theorem zorn_nonempty_partialOrder [Nonempty \u03b1]\n    (h : \u2200 c : Set \u03b1, IsChain (\u00b7 \u2264 \u00b7) c \u2192 c.Nonempty \u2192 BddAbove c) : \u2203 m : \u03b1, \u2200 a, m \u2264 a \u2192 a = m", "start": [164, 1], "end": [167, 44], "kind": "commanddeclaration"}, {"full_name": "zorn_partialOrder\u2080", "code": "theorem zorn_partialOrder\u2080 (s : Set \u03b1)\n    (ih : \u2200 (c) (_ : c \u2286 s), IsChain (\u00b7 \u2264 \u00b7) c \u2192 \u2203 ub \u2208 s, \u2200 z \u2208 c, z \u2264 ub) :\n    \u2203 m \u2208 s, \u2200 z \u2208 s, m \u2264 z \u2192 z = m", "start": [170, 1], "end": [174, 57], "kind": "commanddeclaration"}, {"full_name": "zorn_nonempty_partialOrder\u2080", "code": "theorem zorn_nonempty_partialOrder\u2080 (s : Set \u03b1)\n    (ih : \u2200 (c) (_ : c \u2286 s), IsChain (\u00b7 \u2264 \u00b7) c \u2192 \u2200 y \u2208 c, \u2203 ub \u2208 s, \u2200 z \u2208 c, z \u2264 ub) (x : \u03b1)\n    (hxs : x \u2208 s) : \u2203 m \u2208 s, x \u2264 m \u2227 \u2200 z \u2208 s, m \u2264 z \u2192 z = m", "start": [177, 1], "end": [181, 62], "kind": "commanddeclaration"}, {"full_name": "zorn_subset", "code": "theorem zorn_subset (S : Set (Set \u03b1))\n    (h : \u2200 (c) (_ : c \u2286 S), IsChain (\u00b7 \u2286 \u00b7) c \u2192 \u2203 ub \u2208 S, \u2200 s \u2208 c, s \u2286 ub) :\n    \u2203 m \u2208 S, \u2200 a \u2208 S, m \u2286 a \u2192 a = m", "start": [186, 1], "end": [189, 25], "kind": "commanddeclaration"}, {"full_name": "zorn_subset_nonempty", "code": "theorem zorn_subset_nonempty (S : Set (Set \u03b1))\n    (H : \u2200 (c) (_ : c \u2286 S), IsChain (\u00b7 \u2286 \u00b7) c \u2192 c.Nonempty \u2192 \u2203 ub \u2208 S, \u2200 s \u2208 c, s \u2286 ub) (x)\n    (hx : x \u2208 S) : \u2203 m \u2208 S, x \u2286 m \u2227 \u2200 a \u2208 S, m \u2286 a \u2192 a = m", "start": [192, 1], "end": [195, 77], "kind": "commanddeclaration"}, {"full_name": "zorn_superset", "code": "theorem zorn_superset (S : Set (Set \u03b1))\n    (h : \u2200 (c) (_ : c \u2286 S), IsChain (\u00b7 \u2286 \u00b7) c \u2192 \u2203 lb \u2208 S, \u2200 s \u2208 c, lb \u2286 s) :\n    \u2203 m \u2208 S, \u2200 a \u2208 S, a \u2286 m \u2192 a = m", "start": [198, 1], "end": [201, 68], "kind": "commanddeclaration"}, {"full_name": "zorn_superset_nonempty", "code": "theorem zorn_superset_nonempty (S : Set (Set \u03b1))\n    (H : \u2200 (c) (_ : c \u2286 S), IsChain (\u00b7 \u2286 \u00b7) c \u2192 c.Nonempty \u2192 \u2203 lb \u2208 S, \u2200 s \u2208 c, lb \u2286 s) (x)\n    (hx : x \u2208 S) : \u2203 m \u2208 S, m \u2286 x \u2227 \u2200 a \u2208 S, a \u2286 m \u2192 a = m", "start": [204, 1], "end": [207, 95], "kind": "commanddeclaration"}, {"full_name": "IsChain.exists_maxChain", "code": "theorem IsChain.exists_maxChain (hc : IsChain r c) : \u2203 M, @IsMaxChain _ r M \u2227 c \u2286 M", "start": [210, 1], "end": [229, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Atoms.lean", "imports": ["Mathlib/Order/WellFounded.lean", "Mathlib/Tactic/Nontriviality.lean", "Mathlib/Order/ModularLattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsAtom", "code": "def IsAtom (a : \u03b1) : Prop :=\n  a \u2260 \u22a5 \u2227 \u2200 b, b < a \u2192 b = \u22a5", "start": [64, 1], "end": [67, 29], "kind": "commanddeclaration"}, {"full_name": "IsAtom.Iic", "code": "theorem IsAtom.Iic (ha : IsAtom a) (hax : a \u2264 x) : IsAtom (\u27e8a, hax\u27e9 : Set.Iic x)", "start": [70, 1], "end": [71, 96], "kind": "commanddeclaration"}, {"full_name": "IsAtom.of_isAtom_coe_Iic", "code": "theorem IsAtom.of_isAtom_coe_Iic {a : Set.Iic x} (ha : IsAtom a) : IsAtom (a : \u03b1)", "start": [74, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "isAtom_iff", "code": "theorem isAtom_iff {a : \u03b1} : IsAtom a \u2194 a \u2260 \u22a5 \u2227 \u2200 (b) (_ : b \u2260 \u22a5), b \u2264 a \u2192 a \u2264 b", "start": [79, 1], "end": [81, 99], "kind": "commanddeclaration"}, {"full_name": "IsAtom.lt_iff", "code": "theorem IsAtom.lt_iff (h : IsAtom a) : x < a \u2194 x = \u22a5", "start": [90, 1], "end": [91, 42], "kind": "commanddeclaration"}, {"full_name": "IsAtom.le_iff", "code": "theorem IsAtom.le_iff (h : IsAtom a) : x \u2264 a \u2194 x = \u22a5 \u2228 x = a", "start": [94, 1], "end": [94, 98], "kind": "commanddeclaration"}, {"full_name": "IsAtom.Iic_eq", "code": "theorem IsAtom.Iic_eq (h : IsAtom a) : Set.Iic a = {\u22a5, a}", "start": [97, 1], "end": [98, 28], "kind": "commanddeclaration"}, {"full_name": "bot_covby_iff", "code": "@[simp]\ntheorem bot_covby_iff : \u22a5 \u22d6 a \u2194 IsAtom a", "start": [101, 1], "end": [103, 60], "kind": "commanddeclaration"}, {"full_name": "Covby.is_atom", "code": "alias \u27e8Covby.is_atom, IsAtom.bot_covby\u27e9 := bot_covby_iff", "start": [106, 1], "end": [106, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsAtom.bot_covby", "code": "alias \u27e8Covby.is_atom, IsAtom.bot_covby\u27e9 := bot_covby_iff", "start": [106, 1], "end": [106, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "atom_le_iSup", "code": "theorem atom_le_iSup [Order.Frame \u03b1] (ha : IsAtom a) {f : \u03b9 \u2192 \u03b1} :\n    a \u2264 iSup f \u2194 \u2203 i, a \u2264 f i", "start": [112, 1], "end": [123, 17], "kind": "commanddeclaration"}, {"full_name": "IsCoatom", "code": "def IsCoatom [OrderTop \u03b1] (a : \u03b1) : Prop :=\n  a \u2260 \u22a4 \u2227 \u2200 b, a < b \u2192 b = \u22a4", "start": [133, 1], "end": [136, 29], "kind": "commanddeclaration"}, {"full_name": "isCoatom_dual_iff_isAtom", "code": "@[simp]\ntheorem isCoatom_dual_iff_isAtom [OrderBot \u03b1] {a : \u03b1} :\n    IsCoatom (OrderDual.toDual a) \u2194 IsAtom a", "start": [139, 1], "end": [142, 10], "kind": "commanddeclaration"}, {"full_name": "isAtom_dual_iff_isCoatom", "code": "@[simp]\ntheorem isAtom_dual_iff_isCoatom [OrderTop \u03b1] {a : \u03b1} :\n    IsAtom (OrderDual.toDual a) \u2194 IsCoatom a", "start": [145, 1], "end": [148, 10], "kind": "commanddeclaration"}, {"full_name": "IsAtom.dual", "code": "alias \u27e8_, IsAtom.dual\u27e9 := isCoatom_dual_iff_isAtom", "start": [151, 1], "end": [151, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsCoatom.dual", "code": "alias \u27e8_, IsCoatom.dual\u27e9 := isAtom_dual_iff_isCoatom", "start": [154, 1], "end": [154, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsCoatom.Ici", "code": "theorem IsCoatom.Ici (ha : IsCoatom a) (hax : x \u2264 a) : IsCoatom (\u27e8a, hax\u27e9 : Set.Ici x)", "start": [159, 1], "end": [160, 18], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.of_isCoatom_coe_Ici", "code": "theorem IsCoatom.of_isCoatom_coe_Ici {a : Set.Ici x} (ha : IsCoatom a) : IsCoatom (a : \u03b1)", "start": [163, 1], "end": [164, 43], "kind": "commanddeclaration"}, {"full_name": "isCoatom_iff", "code": "theorem isCoatom_iff {a : \u03b1} : IsCoatom a \u2194 a \u2260 \u22a4 \u2227 \u2200 (b) (_ : b \u2260 \u22a4), a \u2264 b \u2192 b \u2264 a", "start": [167, 1], "end": [168, 24], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.lt_iff", "code": "theorem IsCoatom.lt_iff (h : IsCoatom a) : a < x \u2194 x = \u22a4", "start": [177, 1], "end": [178, 16], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.le_iff", "code": "theorem IsCoatom.le_iff (h : IsCoatom a) : a \u2264 x \u2194 x = \u22a4 \u2228 x = a", "start": [181, 1], "end": [182, 16], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.Ici_eq", "code": "theorem IsCoatom.Ici_eq (h : IsCoatom a) : Set.Ici a = {\u22a4, a}", "start": [185, 1], "end": [186, 16], "kind": "commanddeclaration"}, {"full_name": "covby_top_iff", "code": "@[simp]\ntheorem covby_top_iff : a \u22d6 \u22a4 \u2194 IsCoatom a", "start": [189, 1], "end": [191, 51], "kind": "commanddeclaration"}, {"full_name": "Covby.is_coatom", "code": "alias \u27e8Covby.is_coatom, IsCoatom.covby_top\u27e9 := covby_top_iff", "start": [194, 1], "end": [194, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsCoatom.covby_top", "code": "alias \u27e8Covby.is_coatom, IsCoatom.covby_top\u27e9 := covby_top_iff", "start": [194, 1], "end": [194, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "iInf_le_coatom", "code": "theorem iInf_le_coatom [Order.Coframe \u03b1] (ha : IsCoatom a) {f : \u03b9 \u2192 \u03b1} :\n    iInf f \u2264 a \u2194 \u2203 i, f i \u2264 a", "start": [200, 1], "end": [202, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Ici.isAtom_iff", "code": "@[simp]\ntheorem Set.Ici.isAtom_iff {b : Set.Ici a} : IsAtom b \u2194 a \u22d6 b", "start": [210, 1], "end": [214, 98], "kind": "commanddeclaration"}, {"full_name": "Set.Iic.isCoatom_iff", "code": "@[simp]\ntheorem Set.Iic.isCoatom_iff {a : Set.Iic b} : IsCoatom a \u2194 \u2191a \u22d6 b", "start": [217, 1], "end": [221, 98], "kind": "commanddeclaration"}, {"full_name": "covby_iff_atom_Ici", "code": "theorem covby_iff_atom_Ici (h : a \u2264 b) : a \u22d6 b \u2194 IsAtom (\u27e8b, h\u27e9 : Set.Ici a)", "start": [224, 1], "end": [224, 88], "kind": "commanddeclaration"}, {"full_name": "covby_iff_coatom_Iic", "code": "theorem covby_iff_coatom_Iic (h : a \u2264 b) : a \u22d6 b \u2194 IsCoatom (\u27e8a, h\u27e9 : Set.Iic b)", "start": [227, 1], "end": [227, 92], "kind": "commanddeclaration"}, {"full_name": "IsAtom.inf_eq_bot_of_ne", "code": "theorem IsAtom.inf_eq_bot_of_ne [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1} (ha : IsAtom a)\n    (hb : IsAtom b) (hab : a \u2260 b) : a \u2293 b = \u22a5", "start": [234, 1], "end": [236, 89], "kind": "commanddeclaration"}, {"full_name": "IsAtom.disjoint_of_ne", "code": "theorem IsAtom.disjoint_of_ne [SemilatticeInf \u03b1] [OrderBot \u03b1] {a b : \u03b1} (ha : IsAtom a)\n    (hb : IsAtom b) (hab : a \u2260 b) : Disjoint a b", "start": [239, 1], "end": [241, 55], "kind": "commanddeclaration"}, {"full_name": "IsCoatom.sup_eq_top_of_ne", "code": "theorem IsCoatom.sup_eq_top_of_ne [SemilatticeSup \u03b1] [OrderTop \u03b1] {a b : \u03b1} (ha : IsCoatom a)\n    (hb : IsCoatom b) (hab : a \u2260 b) : a \u2294 b = \u22a4", "start": [244, 1], "end": [246, 39], "kind": "commanddeclaration"}, {"full_name": "IsAtomic", "code": "@[mk_iff]\nclass IsAtomic [OrderBot \u03b1] : Prop where\n  \n  eq_bot_or_exists_atom_le : \u2200 b : \u03b1, b = \u22a5 \u2228 \u2203 a : \u03b1, IsAtom a \u2227 a \u2264 b", "start": [257, 1], "end": [261, 72], "kind": "commanddeclaration"}, {"full_name": "IsCoatomic", "code": "@[mk_iff]\nclass IsCoatomic [OrderTop \u03b1] : Prop where\n  \n  eq_top_or_exists_le_coatom : \u2200 b : \u03b1, b = \u22a4 \u2228 \u2203 a : \u03b1, IsCoatom a \u2227 b \u2264 a", "start": [265, 1], "end": [269, 76], "kind": "commanddeclaration"}, {"full_name": "isCoatomic_dual_iff_isAtomic", "code": "@[simp]\ntheorem isCoatomic_dual_iff_isAtomic [OrderBot \u03b1] : IsCoatomic \u03b1\u1d52\u1d48 \u2194 IsAtomic \u03b1", "start": [279, 1], "end": [282, 52], "kind": "commanddeclaration"}, {"full_name": "isAtomic_dual_iff_isCoatomic", "code": "@[simp]\ntheorem isAtomic_dual_iff_isCoatomic [OrderTop \u03b1] : IsAtomic \u03b1\u1d52\u1d48 \u2194 IsCoatomic \u03b1", "start": [285, 1], "end": [288, 54], "kind": "commanddeclaration"}, {"full_name": "IsAtomic.isCoatomic_dual", "code": "instance isCoatomic_dual : IsCoatomic \u03b1\u1d52\u1d48 :=\n  isCoatomic_dual_iff_isAtomic.2 \u2039IsAtomic \u03b1\u203a", "start": [295, 1], "end": [296, 46], "kind": "commanddeclaration"}, {"full_name": "IsAtomic.Set.Iic.isAtomic", "code": "instance Set.Iic.isAtomic {x : \u03b1} : IsAtomic (Set.Iic x) :=\n  \u27e8fun \u27e8y, hy\u27e9 =>\n    (eq_bot_or_exists_atom_le y).imp Subtype.mk_eq_mk.2 fun \u27e8a, ha, hay\u27e9 =>\n      \u27e8\u27e8a, hay.trans hy\u27e9, ha.Iic (hay.trans hy), hay\u27e9\u27e9", "start": [299, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "IsCoatomic.isCoatomic", "code": "instance isCoatomic : IsAtomic \u03b1\u1d52\u1d48 :=\n  isAtomic_dual_iff_isCoatomic.2 \u2039IsCoatomic \u03b1\u203a", "start": [311, 1], "end": [312, 48], "kind": "commanddeclaration"}, {"full_name": "IsCoatomic.Set.Ici.isCoatomic", "code": "instance Set.Ici.isCoatomic {x : \u03b1} : IsCoatomic (Set.Ici x) :=\n  \u27e8fun \u27e8y, hy\u27e9 =>\n    (eq_top_or_exists_le_coatom y).imp Subtype.mk_eq_mk.2 fun \u27e8a, ha, hay\u27e9 =>\n      \u27e8\u27e8a, le_trans hy hay\u27e9, ha.Ici (le_trans hy hay), hay\u27e9\u27e9", "start": [315, 1], "end": [318, 61], "kind": "commanddeclaration"}, {"full_name": "isAtomic_iff_forall_isAtomic_Iic", "code": "theorem isAtomic_iff_forall_isAtomic_Iic [OrderBot \u03b1] :\n    IsAtomic \u03b1 \u2194 \u2200 x : \u03b1, IsAtomic (Set.Iic x)", "start": [323, 1], "end": [328, 80], "kind": "commanddeclaration"}, {"full_name": "isCoatomic_iff_forall_isCoatomic_Ici", "code": "theorem isCoatomic_iff_forall_isCoatomic_Ici [OrderTop \u03b1] :\n    IsCoatomic \u03b1 \u2194 \u2200 x : \u03b1, IsCoatomic (Set.Ici x)", "start": [331, 1], "end": [335, 77], "kind": "commanddeclaration"}, {"full_name": "isAtomic_of_orderBot_wellFounded_lt", "code": "theorem isAtomic_of_orderBot_wellFounded_lt [OrderBot \u03b1]\n    (h : WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) : IsAtomic \u03b1", "start": [340, 1], "end": [345, 93], "kind": "commanddeclaration"}, {"full_name": "isCoatomic_of_orderTop_gt_wellFounded", "code": "theorem isCoatomic_of_orderTop_gt_wellFounded [OrderTop \u03b1]\n    (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) : IsCoatomic \u03b1", "start": [348, 1], "end": [350, 82], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.le_iff_atom_le_imp", "code": "theorem le_iff_atom_le_imp {\u03b1} [BooleanAlgebra \u03b1] [IsAtomic \u03b1] {x y : \u03b1} :\n    x \u2264 y \u2194 \u2200 a, IsAtom a \u2192 a \u2264 x \u2192 a \u2264 y", "start": [357, 1], "end": [366, 71], "kind": "commanddeclaration"}, {"full_name": "BooleanAlgebra.eq_iff_atom_le_iff", "code": "theorem eq_iff_atom_le_iff {\u03b1} [BooleanAlgebra \u03b1] [IsAtomic \u03b1] {x y : \u03b1} :\n    x = y \u2194 \u2200 a, IsAtom a \u2192 (a \u2264 x \u2194 a \u2264 y)", "start": [368, 1], "end": [372, 56], "kind": "commanddeclaration"}, {"full_name": "CompleteBooleanAlgebra.toCompleteAtomicBooleanAlgebra", "code": "abbrev toCompleteAtomicBooleanAlgebra {\u03b1} [CompleteBooleanAlgebra \u03b1] [IsAtomic \u03b1] :\n    CompleteAtomicBooleanAlgebra \u03b1 where\n  __ := \u2039CompleteBooleanAlgebra \u03b1\u203a\n  iInf_iSup_eq f := BooleanAlgebra.eq_iff_atom_le_iff.2 fun a ha => by\n    simp only [le_iInf_iff, atom_le_iSup ha]\n    rw [Classical.skolem]", "start": [379, 1], "end": [384, 26], "kind": "commanddeclaration"}, {"full_name": "IsAtomistic", "code": "class IsAtomistic : Prop where\n  \n  eq_sSup_atoms : \u2200 b : \u03b1, \u2203 s : Set \u03b1, b = sSup s \u2227 \u2200 a, a \u2208 s \u2192 IsAtom a", "start": [394, 1], "end": [397, 75], "kind": "commanddeclaration"}, {"full_name": "IsCoatomistic", "code": "class IsCoatomistic : Prop where\n  \n  eq_sInf_coatoms : \u2200 b : \u03b1, \u2203 s : Set \u03b1, b = sInf s \u2227 \u2200 a, a \u2208 s \u2192 IsCoatom a", "start": [401, 1], "end": [404, 79], "kind": "commanddeclaration"}, {"full_name": "isCoatomistic_dual_iff_isAtomistic", "code": "@[simp]\ntheorem isCoatomistic_dual_iff_isAtomistic : IsCoatomistic \u03b1\u1d52\u1d48 \u2194 IsAtomistic \u03b1", "start": [414, 1], "end": [416, 97], "kind": "commanddeclaration"}, {"full_name": "isAtomistic_dual_iff_isCoatomistic", "code": "@[simp]\ntheorem isAtomistic_dual_iff_isCoatomistic : IsAtomistic \u03b1\u1d52\u1d48 \u2194 IsCoatomistic \u03b1", "start": [419, 1], "end": [421, 97], "kind": "commanddeclaration"}, {"full_name": "IsAtomistic.isCoatomistic_dual", "code": "instance isCoatomistic_dual [h : IsAtomistic \u03b1] : IsCoatomistic \u03b1\u1d52\u1d48 :=\n  isCoatomistic_dual_iff_isAtomistic.2 h", "start": [426, 1], "end": [427, 41], "kind": "commanddeclaration"}, {"full_name": "sSup_atoms_le_eq", "code": "@[simp]\ntheorem sSup_atoms_le_eq (b : \u03b1) : sSup { a : \u03b1 | IsAtom a \u2227 a \u2264 b } = b", "start": [445, 1], "end": [448, 98], "kind": "commanddeclaration"}, {"full_name": "sSup_atoms_eq_top", "code": "@[simp]\ntheorem sSup_atoms_eq_top : sSup { a : \u03b1 | IsAtom a } = \u22a4", "start": [451, 1], "end": [454, 35], "kind": "commanddeclaration"}, {"full_name": "le_iff_atom_le_imp", "code": "theorem le_iff_atom_le_imp {a b : \u03b1} : a \u2264 b \u2194 \u2200 c : \u03b1, IsAtom c \u2192 c \u2264 a \u2192 c \u2264 b", "start": [457, 1], "end": [460, 58], "kind": "commanddeclaration"}, {"full_name": "eq_iff_atom_le_iff", "code": "theorem eq_iff_atom_le_iff {a b : \u03b1} : a = b \u2194 \u2200 c, IsAtom c \u2192 (c \u2264 a \u2194 c \u2264 b)", "start": [463, 1], "end": [466, 56], "kind": "commanddeclaration"}, {"full_name": "IsCoatomistic.isAtomistic_dual", "code": "instance isAtomistic_dual [h : IsCoatomistic \u03b1] : IsAtomistic \u03b1\u1d52\u1d48 :=\n  isAtomistic_dual_iff_isCoatomistic.2 h", "start": [472, 1], "end": [473, 41], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder", "code": "class IsSimpleOrder (\u03b1 : Type*) [LE \u03b1] [BoundedOrder \u03b1] extends Nontrivial \u03b1 : Prop where\n  \n  eq_bot_or_eq_top : \u2200 a : \u03b1, a = \u22a5 \u2228 a = \u22a4", "start": [511, 1], "end": [514, 44], "kind": "commanddeclaration"}, {"full_name": "isSimpleOrder_iff_isSimpleOrder_orderDual", "code": "theorem isSimpleOrder_iff_isSimpleOrder_orderDual [LE \u03b1] [BoundedOrder \u03b1] :\n    IsSimpleOrder \u03b1 \u2194 IsSimpleOrder \u03b1\u1d52\u1d48", "start": [519, 1], "end": [527, 87], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.bot_ne_top", "code": "theorem IsSimpleOrder.bot_ne_top [LE \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] : (\u22a5 : \u03b1) \u2260 (\u22a4 : \u03b1)", "start": [530, 1], "end": [533, 36], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.preorder", "code": "protected def IsSimpleOrder.preorder {\u03b1} [LE \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] : Preorder \u03b1\n    where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl a := by rcases eq_bot_or_eq_top a with (rfl | rfl) <;> simp\n  le_trans a b c := by\n    rcases eq_bot_or_eq_top a with (rfl | rfl)\n    \u00b7 simp\n    \u00b7 rcases eq_bot_or_eq_top b with (rfl | rfl)\n      \u00b7 rcases eq_bot_or_eq_top c with (rfl | rfl) <;> simp\n      \u00b7 simp", "start": [543, 1], "end": [553, 13], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.linearOrder", "code": "protected def IsSimpleOrder.linearOrder [DecidableEq \u03b1] : LinearOrder \u03b1 :=\n  { (inferInstance : PartialOrder \u03b1) with\n    le_total := fun a b => by rcases eq_bot_or_eq_top a with (rfl | rfl) <;> simp\n    decidableLE := fun a b =>\n      if ha : a = \u22a5 then isTrue (ha.le.trans bot_le)\n      else\n        if hb : b = \u22a4 then isTrue (le_top.trans hb.ge)\n        else\n          isFalse fun H =>\n            hb (top_unique (le_trans (top_le_iff.mpr (Or.resolve_left\n              (eq_bot_or_eq_top a) ha)) H)) }", "start": [556, 1], "end": [568, 46], "kind": "commanddeclaration"}, {"full_name": "isAtom_top", "code": "@[simp]\ntheorem isAtom_top : IsAtom (\u22a4 : \u03b1)", "start": [571, 1], "end": [573, 80], "kind": "commanddeclaration"}, {"full_name": "isCoatom_bot", "code": "@[simp]\ntheorem isCoatom_bot : IsCoatom (\u22a5 : \u03b1)", "start": [576, 1], "end": [578, 40], "kind": "commanddeclaration"}, {"full_name": "bot_covby_top", "code": "theorem bot_covby_top : (\u22a5 : \u03b1) \u22d6 \u22a4", "start": [581, 1], "end": [582, 23], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.eq_bot_of_lt", "code": "theorem eq_bot_of_lt : a = \u22a5", "start": [593, 1], "end": [594, 60], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.eq_top_of_lt", "code": "theorem eq_top_of_lt : b = \u22a4", "start": [597, 1], "end": [598, 59], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.LT.lt.eq_bot", "code": "alias LT.lt.eq_bot := eq_bot_of_lt", "start": [601, 1], "end": [601, 35], "kind": "stdtacticaliasalias"}, {"full_name": "IsSimpleOrder.LT.lt.eq_top", "code": "alias LT.lt.eq_top := eq_top_of_lt", "start": [603, 1], "end": [603, 35], "kind": "stdtacticaliasalias"}, {"full_name": "IsSimpleOrder.lattice", "code": "protected def lattice {\u03b1} [DecidableEq \u03b1] [PartialOrder \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] :\n    Lattice \u03b1 :=\n  @LinearOrder.toLattice \u03b1 IsSimpleOrder.linearOrder", "start": [611, 1], "end": [615, 53], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.distribLattice", "code": "protected def distribLattice : DistribLattice \u03b1 :=\n  { (inferInstance : Lattice \u03b1) with\n    le_sup_inf := fun x y z => by rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp }", "start": [618, 1], "end": [622, 88], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.equivBool", "code": "@[simps]\ndef equivBool {\u03b1} [DecidableEq \u03b1] [LE \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] : \u03b1 \u2243 Bool\n    where\n  toFun x := x = \u22a4\n  invFun x := x.casesOn \u22a5 \u22a4\n  left_inv x := by rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp [bot_ne_top]\n  right_inv x := by cases x <;> simp [bot_ne_top]", "start": [640, 1], "end": [647, 50], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.orderIsoBool", "code": "def orderIsoBool : \u03b1 \u2243o Bool :=\n  { equivBool with\n    map_rel_iff' := @fun a b => by\n      rcases eq_bot_or_eq_top a with (rfl | rfl)\n      \u00b7 simp [bot_ne_top]\n      \u00b7 rcases eq_bot_or_eq_top b with (rfl | rfl)\n        \u00b7 simp [bot_ne_top.symm, bot_ne_top, Bool.false_lt_true]\n        \u00b7 simp [bot_ne_top] }", "start": [652, 1], "end": [660, 30], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.booleanAlgebra", "code": "protected def booleanAlgebra {\u03b1} [DecidableEq \u03b1] [Lattice \u03b1] [BoundedOrder \u03b1] [IsSimpleOrder \u03b1] :\n    BooleanAlgebra \u03b1 :=\n  { inferInstanceAs (BoundedOrder \u03b1), IsSimpleOrder.distribLattice with\n    compl := fun x => if x = \u22a5 then \u22a4 else \u22a5\n    sdiff := fun x y => if x = \u22a4 \u2227 y = \u22a5 then \u22a4 else \u22a5\n    sdiff_eq := fun x y => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp [bot_ne_top, SDiff.sdiff, compl]\n    inf_compl_le_bot := fun x => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 simp\n      \u00b7 simp\n    top_le_sup_compl := fun x => by rcases eq_bot_or_eq_top x with (rfl | rfl) <;> simp }", "start": [663, 1], "end": [675, 90], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.completeLattice", "code": "protected noncomputable def completeLattice : CompleteLattice \u03b1 :=\n  { (inferInstance : Lattice \u03b1),\n    (inferInstance : BoundedOrder \u03b1) with\n    sSup := fun s => if \u22a4 \u2208 s then \u22a4 else \u22a5\n    sInf := fun s => if \u22a5 \u2208 s then \u22a5 else \u22a4\n    le_sSup := fun s x h => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 exact bot_le\n      \u00b7 dsimp; rw [if_pos h]\n    sSup_le := fun s x h => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 dsimp; rw [if_neg]\n        intro con\n        exact bot_ne_top (eq_top_iff.2 (h \u22a4 con))\n      \u00b7 exact le_top\n    sInf_le := fun s x h => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 dsimp; rw [if_pos h]\n      \u00b7 exact le_top\n    le_sInf := fun s x h => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 exact bot_le\n      \u00b7 dsimp; rw [if_neg]\n        intro con\n        exact top_ne_bot (eq_bot_iff.2 (h \u22a5 con)) }", "start": [684, 1], "end": [709, 52], "kind": "commanddeclaration"}, {"full_name": "IsSimpleOrder.completeBooleanAlgebra", "code": "protected noncomputable def completeBooleanAlgebra : CompleteBooleanAlgebra \u03b1 :=\n  { IsSimpleOrder.completeLattice,\n    IsSimpleOrder.booleanAlgebra with\n    iInf_sup_le_sup_sInf := fun x s => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 simp only [bot_sup_eq, \u2190 sInf_eq_iInf]\n        exact le_rfl\n      \u00b7 simp only [top_le_iff, top_sup_eq, iInf_top, le_sInf_iff, le_refl]\n    inf_sSup_le_iSup_inf := fun x s => by\n      rcases eq_bot_or_eq_top x with (rfl | rfl)\n      \u00b7 simp only [le_bot_iff, sSup_eq_bot, bot_inf_eq, iSup_bot, le_refl]\n      \u00b7 simp only [top_inf_eq, \u2190 sSup_eq_iSup]\n        exact le_rfl }", "start": [712, 1], "end": [725, 23], "kind": "commanddeclaration"}, {"full_name": "isSimpleOrder_iff_isAtom_top", "code": "theorem isSimpleOrder_iff_isAtom_top [PartialOrder \u03b1] [BoundedOrder \u03b1] :\n    IsSimpleOrder \u03b1 \u2194 IsAtom (\u22a4 : \u03b1)", "start": [749, 1], "end": [753, 87], "kind": "commanddeclaration"}, {"full_name": "isSimpleOrder_iff_isCoatom_bot", "code": "theorem isSimpleOrder_iff_isCoatom_bot [PartialOrder \u03b1] [BoundedOrder \u03b1] :\n    IsSimpleOrder \u03b1 \u2194 IsCoatom (\u22a5 : \u03b1)", "start": [756, 1], "end": [758, 79], "kind": "commanddeclaration"}, {"full_name": "Set.isSimpleOrder_Iic_iff_isAtom", "code": "theorem isSimpleOrder_Iic_iff_isAtom [PartialOrder \u03b1] [OrderBot \u03b1] {a : \u03b1} :\n    IsSimpleOrder (Iic a) \u2194 IsAtom a", "start": [763, 1], "end": [768, 61], "kind": "commanddeclaration"}, {"full_name": "Set.isSimpleOrder_Ici_iff_isCoatom", "code": "theorem isSimpleOrder_Ici_iff_isCoatom [PartialOrder \u03b1] [OrderTop \u03b1] {a : \u03b1} :\n    IsSimpleOrder (Ici a) \u2194 IsCoatom a", "start": [771, 1], "end": [776, 61], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.isAtom_of_map_bot_of_image", "code": "theorem isAtom_of_map_bot_of_image [OrderBot \u03b1] [OrderBot \u03b2] (f : \u03b2 \u21aao \u03b1) (hbot : f \u22a5 = \u22a5) {b : \u03b2}\n    (hb : IsAtom (f b)) : IsAtom b", "start": [785, 1], "end": [788, 42], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.isCoatom_of_map_top_of_image", "code": "theorem isCoatom_of_map_top_of_image [OrderTop \u03b1] [OrderTop \u03b2] (f : \u03b2 \u21aao \u03b1) (htop : f \u22a4 = \u22a4)\n    {b : \u03b2} (hb : IsCoatom (f b)) : IsCoatom b", "start": [791, 1], "end": [793, 44], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isAtom_of_u_bot", "code": "theorem isAtom_of_u_bot [OrderBot \u03b1] [OrderBot \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisInsertion l u) (hbot : u \u22a5 = \u22a5) {b : \u03b2} (hb : IsAtom (u b)) : IsAtom b", "start": [802, 1], "end": [805, 78], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isAtom_iff", "code": "theorem isAtom_iff [OrderBot \u03b1] [IsAtomic \u03b1] [OrderBot \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisInsertion l u) (hbot : u \u22a5 = \u22a5) (h_atom : \u2200 a, IsAtom a \u2192 u (l a) = a) (a : \u03b1) :\n    IsAtom (l a) \u2194 IsAtom a", "start": [808, 1], "end": [821, 24], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isAtom_iff'", "code": "theorem isAtom_iff' [OrderBot \u03b1] [IsAtomic \u03b1] [OrderBot \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisInsertion l u) (hbot : u \u22a5 = \u22a5) (h_atom : \u2200 a, IsAtom a \u2192 u (l a) = a) (b : \u03b2) :\n    IsAtom (u b) \u2194 IsAtom b", "start": [824, 1], "end": [826, 78], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isCoatom_of_image", "code": "theorem isCoatom_of_image [OrderTop \u03b1] [OrderTop \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisInsertion l u) {b : \u03b2} (hb : IsCoatom (u b)) : IsCoatom b", "start": [829, 1], "end": [832, 85], "kind": "commanddeclaration"}, {"full_name": "GaloisInsertion.isCoatom_iff", "code": "theorem isCoatom_iff [OrderTop \u03b1] [IsCoatomic \u03b1] [OrderTop \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisInsertion l u) (h_coatom : \u2200 a : \u03b1, IsCoatom a \u2192 u (l a) = a) (b : \u03b2) :\n    IsCoatom (u b) \u2194 IsCoatom b", "start": [835, 1], "end": [845, 41], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isCoatom_of_l_top", "code": "theorem isCoatom_of_l_top [OrderTop \u03b1] [OrderTop \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisCoinsertion l u) (hbot : l \u22a4 = \u22a4) {a : \u03b1} (hb : IsCoatom (l a)) : IsCoatom a", "start": [854, 1], "end": [856, 39], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isCoatom_iff", "code": "theorem isCoatom_iff [OrderTop \u03b1] [OrderTop \u03b2] [IsCoatomic \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisCoinsertion l u) (htop : l \u22a4 = \u22a4) (h_coatom : \u2200 b, IsCoatom b \u2192 l (u b) = b)\n    (b : \u03b2) : IsCoatom (u b) \u2194 IsCoatom b", "start": [859, 1], "end": [862, 37], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isCoatom_iff'", "code": "theorem isCoatom_iff' [OrderTop \u03b1] [OrderTop \u03b2] [IsCoatomic \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisCoinsertion l u) (htop : l \u22a4 = \u22a4) (h_coatom : \u2200 b, IsCoatom b \u2192 l (u b) = b)\n    (a : \u03b1) : IsCoatom (l a) \u2194 IsCoatom a", "start": [865, 1], "end": [868, 38], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isAtom_of_image", "code": "theorem isAtom_of_image [OrderBot \u03b1] [OrderBot \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisCoinsertion l u) {a : \u03b1} (hb : IsAtom (l a)) : IsAtom a", "start": [871, 1], "end": [873, 36], "kind": "commanddeclaration"}, {"full_name": "GaloisCoinsertion.isAtom_iff", "code": "theorem isAtom_iff [OrderBot \u03b1] [OrderBot \u03b2] [IsAtomic \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gi : GaloisCoinsertion l u) (h_atom : \u2200 b, IsAtom b \u2192 l (u b) = b) (a : \u03b1) :\n    IsAtom (l a) \u2194 IsAtom a", "start": [876, 1], "end": [879, 32], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isAtom_iff", "code": "@[simp]\ntheorem isAtom_iff [OrderBot \u03b1] [OrderBot \u03b2] (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : IsAtom (f a) \u2194 IsAtom a", "start": [888, 1], "end": [891, 94], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isCoatom_iff", "code": "@[simp]\ntheorem isCoatom_iff [OrderTop \u03b1] [OrderTop \u03b2] (f : \u03b1 \u2243o \u03b2) (a : \u03b1) :\n    IsCoatom (f a) \u2194 IsCoatom a", "start": [894, 1], "end": [897, 22], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isSimpleOrder_iff", "code": "theorem isSimpleOrder_iff [BoundedOrder \u03b1] [BoundedOrder \u03b2] (f : \u03b1 \u2243o \u03b2) :\n    IsSimpleOrder \u03b1 \u2194 IsSimpleOrder \u03b2", "start": [900, 1], "end": [903, 15], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isSimpleOrder", "code": "theorem isSimpleOrder [BoundedOrder \u03b1] [BoundedOrder \u03b2] [h : IsSimpleOrder \u03b2] (f : \u03b1 \u2243o \u03b2) :\n    IsSimpleOrder \u03b1", "start": [906, 1], "end": [908, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isAtomic_iff", "code": "protected theorem isAtomic_iff [OrderBot \u03b1] [OrderBot \u03b2] (f : \u03b1 \u2243o \u03b2) :\n    IsAtomic \u03b1 \u2194 IsAtomic \u03b2", "start": [911, 1], "end": [914, 31], "kind": "commanddeclaration"}, {"full_name": "OrderIso.isCoatomic_iff", "code": "protected theorem isCoatomic_iff [OrderTop \u03b1] [OrderTop \u03b2] (f : \u03b1 \u2243o \u03b2) :\n    IsCoatomic \u03b1 \u2194 IsCoatomic \u03b2", "start": [917, 1], "end": [919, 66], "kind": "commanddeclaration"}, {"full_name": "IsCompl.isAtom_iff_isCoatom", "code": "theorem isAtom_iff_isCoatom : IsAtom a \u2194 IsCoatom b", "start": [932, 1], "end": [934, 81], "kind": "commanddeclaration"}, {"full_name": "IsCompl.isCoatom_iff_isAtom", "code": "theorem isCoatom_iff_isAtom : IsCoatom a \u2194 IsAtom b", "start": [937, 1], "end": [938, 35], "kind": "commanddeclaration"}, {"full_name": "isCoatomic_of_isAtomic_of_complementedLattice_of_isModular", "code": "theorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic \u03b1] :\n    IsCoatomic \u03b1", "start": [945, 1], "end": [956, 20], "kind": "commanddeclaration"}, {"full_name": "isAtomic_of_isCoatomic_of_complementedLattice_of_isModular", "code": "theorem isAtomic_of_isCoatomic_of_complementedLattice_of_isModular [IsCoatomic \u03b1] :\n    IsAtomic \u03b1", "start": [959, 1], "end": [961, 92], "kind": "commanddeclaration"}, {"full_name": "isAtomic_iff_isCoatomic", "code": "theorem isAtomic_iff_isCoatomic : IsAtomic \u03b1 \u2194 IsCoatomic \u03b1", "start": [964, 1], "end": [966, 77], "kind": "commanddeclaration"}, {"full_name": "Prop.isAtom_iff", "code": "@[simp] theorem isAtom_iff {p : Prop} : IsAtom p \u2194 p", "start": [973, 1], "end": [974, 89], "kind": "commanddeclaration"}, {"full_name": "Prop.isCoatom_iff", "code": "@[simp] theorem isCoatom_iff {p : Prop} : IsCoatom p \u2194 \u00ac p", "start": [976, 1], "end": [977, 97], "kind": "commanddeclaration"}, {"full_name": "Pi.eq_bot_iff", "code": "protected theorem eq_bot_iff [\u2200 i, Bot (\u03c0 i)] {f : \u2200 i, \u03c0 i} : f = \u22a5 \u2194 \u2200 i, f i = \u22a5", "start": [988, 1], "end": [989, 56], "kind": "commanddeclaration"}, {"full_name": "Pi.isAtom_iff", "code": "theorem isAtom_iff {f : \u2200 i, \u03c0 i} [\u2200 i, PartialOrder (\u03c0 i)] [\u2200 i, OrderBot (\u03c0 i)] :\n    IsAtom f \u2194 \u2203 i, IsAtom (f i) \u2227 \u2200 j, j \u2260 i \u2192 f j = \u22a5", "start": [991, 1], "end": [1018, 86], "kind": "commanddeclaration"}, {"full_name": "Pi.isAtom_single", "code": "theorem isAtom_single [DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03c0 i)] [\u2200 i, OrderBot (\u03c0 i)] {a : \u03c0 i}\n    (h : IsAtom a) : IsAtom (Function.update (\u22a5 : \u2200 i, \u03c0 i) i a)", "start": [1020, 1], "end": [1022, 73], "kind": "commanddeclaration"}, {"full_name": "Pi.isAtom_iff_eq_single", "code": "theorem isAtom_iff_eq_single [DecidableEq \u03b9] [\u2200 i, PartialOrder (\u03c0 i)]\n    [\u2200 i, OrderBot (\u03c0 i)] {f : \u2200 i, \u03c0 i} :\n    IsAtom f \u2194 \u2203 i a, IsAtom a \u2227 f = Function.update \u22a5 i a", "start": [1024, 1], "end": [1035, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.isAtomic", "code": "instance isAtomic [\u2200 i, PartialOrder (\u03c0 i)] [\u2200 i, OrderBot (\u03c0 i)] [\u2200 i, IsAtomic (\u03c0 i)] :\n    IsAtomic (\u2200 i, \u03c0 i) where\n  eq_bot_or_exists_atom_le b := or_iff_not_imp_left.2 fun h =>\n    have \u27e8i, hi\u27e9 : \u2203 i, b i \u2260 \u22a5 := not_forall.1 (h.imp Pi.eq_bot_iff.2)\n    have \u27e8a, ha, hab\u27e9 := (eq_bot_or_exists_atom_le (b i)).resolve_left hi\n    have : DecidableEq \u03b9 := open Classical in inferInstance\n    \u27e8Function.update \u22a5 i a, isAtom_single ha, update_le_iff.2 \u27e8hab, by simp\u27e9\u27e9", "start": [1037, 1], "end": [1043, 78], "kind": "commanddeclaration"}, {"full_name": "Pi.isCoatomic", "code": "instance isCoatomic [\u2200 i, PartialOrder (\u03c0 i)] [\u2200 i, OrderTop (\u03c0 i)] [\u2200 i, IsCoatomic (\u03c0 i)] :\n    IsCoatomic (\u2200 i, \u03c0 i) :=\n  isAtomic_dual_iff_isCoatomic.1 <|\n    show IsAtomic (\u2200 i, (\u03c0 i)\u1d52\u1d48) from inferInstance", "start": [1045, 1], "end": [1048, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.isAtomistic", "code": "instance isAtomistic [\u2200 i, CompleteLattice (\u03c0 i)] [\u2200 i, IsAtomistic (\u03c0 i)] :\n    IsAtomistic (\u2200 i, \u03c0 i) where\n  eq_sSup_atoms s := by\n    classical\n    refine \u27e8{ f | IsAtom f \u2227 f \u2264 s }, ?_, by simp; tauto\u27e9\n    ext i\n    rw [\u2190 sSup_atoms_le_eq (s i)]\n    simp_rw [isAtom_iff_eq_single]\n    refine le_antisymm ?le ?ge\n    case le =>\n      refine sSup_le fun a \u27e8ha, hle\u27e9 => ?_\n      refine le_sSup \u27e8\u27e8_, \u27e8_, _, ha, rfl\u27e9, ?_\u27e9, by simp\u27e9\n      intro j; by_cases hij : j = i\n      case pos => subst hij; simpa\n      case neg => simp [hij]\n    case ge =>\n      refine sSup_le ?_\n      rintro _ \u27e8\u27e8_, \u27e8j, a, ha, rfl\u27e9, hle\u27e9, rfl\u27e9\n      by_cases hij : i = j; case neg => simp [Function.update_noteq hij]\n      subst hij; simp only [Function.update_same]\n      refine le_sSup \u27e8ha, by simpa using hle i\u27e9", "start": [1050, 1], "end": [1070, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.isCoatomistic", "code": "instance isCoatomistic [\u2200 i, CompleteLattice (\u03c0 i)] [\u2200 i, IsCoatomistic (\u03c0 i)] :\n    IsCoatomistic (\u2200 i, \u03c0 i) :=\n  isAtomistic_dual_iff_isCoatomistic.1 <|\n    show IsAtomistic (\u2200 i, (\u03c0 i)\u1d52\u1d48) from inferInstance", "start": [1072, 1], "end": [1075, 55], "kind": "commanddeclaration"}, {"full_name": "Set.isAtom_singleton", "code": "theorem isAtom_singleton (x : \u03b1) : IsAtom ({x} : Set \u03b1)", "start": [1081, 1], "end": [1082, 66], "kind": "commanddeclaration"}, {"full_name": "Set.isAtom_iff", "code": "theorem isAtom_iff (s : Set \u03b1) : IsAtom s \u2194 \u2203 x, s = {x}", "start": [1085, 1], "end": [1094, 95], "kind": "commanddeclaration"}, {"full_name": "Set.isCoatom_iff", "code": "theorem isCoatom_iff (s : Set \u03b1) : IsCoatom s \u2194 \u2203 x, s = {x}\u1d9c", "start": [1097, 1], "end": [1099, 40], "kind": "commanddeclaration"}, {"full_name": "Set.isCoatom_singleton_compl", "code": "theorem isCoatom_singleton_compl (x : \u03b1) : IsCoatom ({x}\u1d9c : Set \u03b1)", "start": [1102, 1], "end": [1103, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/LocallyFinite.lean", "imports": ["Mathlib/Data/Set/Intervals/Image.lean", "Mathlib/Data/Finset/Preimage.lean", "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyFiniteOrder", "code": "class LocallyFiniteOrder (\u03b1 : Type*) [Preorder \u03b1] where\n  \n  finsetIcc : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1\n  \n  finsetIco : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1\n  \n  finsetIoc : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1\n  \n  finsetIoo : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1\n  \n  finset_mem_Icc : \u2200 a b x : \u03b1, x \u2208 finsetIcc a b \u2194 a \u2264 x \u2227 x \u2264 b\n  \n  finset_mem_Ico : \u2200 a b x : \u03b1, x \u2208 finsetIco a b \u2194 a \u2264 x \u2227 x < b\n  \n  finset_mem_Ioc : \u2200 a b x : \u03b1, x \u2208 finsetIoc a b \u2194 a < x \u2227 x \u2264 b\n  \n  finset_mem_Ioo : \u2200 a b x : \u03b1, x \u2208 finsetIoo a b \u2194 a < x \u2227 x < b", "start": [111, 1], "end": [131, 66], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderTop", "code": "class LocallyFiniteOrderTop (\u03b1 : Type*) [Preorder \u03b1] where\n  \n  finsetIoi : \u03b1 \u2192 Finset \u03b1\n  \n  finsetIci : \u03b1 \u2192 Finset \u03b1\n  \n  finset_mem_Ici : \u2200 a x : \u03b1, x \u2208 finsetIci a \u2194 a \u2264 x\n  \n  finset_mem_Ioi : \u2200 a x : \u03b1, x \u2208 finsetIoi a \u2194 a < x", "start": [134, 1], "end": [144, 54], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderBot", "code": "class LocallyFiniteOrderBot (\u03b1 : Type*) [Preorder \u03b1] where\n  \n  finsetIio : \u03b1 \u2192 Finset \u03b1\n  \n  finsetIic : \u03b1 \u2192 Finset \u03b1\n  \n  finset_mem_Iic : \u2200 a x : \u03b1, x \u2208 finsetIic a \u2194 x \u2264 a\n  \n  finset_mem_Iio : \u2200 a x : \u03b1, x \u2208 finsetIio a \u2194 x < a", "start": [147, 1], "end": [157, 54], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrder.ofIcc'", "code": "def LocallyFiniteOrder.ofIcc' (\u03b1 : Type*) [Preorder \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    (finsetIcc : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1) (mem_Icc : \u2200 a b x, x \u2208 finsetIcc a b \u2194 a \u2264 x \u2227 x \u2264 b) :\n    LocallyFiniteOrder \u03b1 :=\n  { finsetIcc\n    finsetIco := fun a b => (finsetIcc a b).filter fun x => \u00acb \u2264 x\n    finsetIoc := fun a b => (finsetIcc a b).filter fun x => \u00acx \u2264 a\n    finsetIoo := fun a b => (finsetIcc a b).filter fun x => \u00acx \u2264 a \u2227 \u00acb \u2264 x\n    finset_mem_Icc := mem_Icc\n    finset_mem_Ico := fun a b x => by rw [Finset.mem_filter, mem_Icc, and_assoc, lt_iff_le_not_le]\n    finset_mem_Ioc := fun a b x => by\n      rw [Finset.mem_filter, mem_Icc, and_right_comm, lt_iff_le_not_le]\n    finset_mem_Ioo := fun a b x => by\n      rw [Finset.mem_filter, mem_Icc, and_and_and_comm, lt_iff_le_not_le, lt_iff_le_not_le] }", "start": [160, 1], "end": [175, 94], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrder.ofIcc", "code": "def LocallyFiniteOrder.ofIcc (\u03b1 : Type*) [PartialOrder \u03b1] [DecidableEq \u03b1]\n    (finsetIcc : \u03b1 \u2192 \u03b1 \u2192 Finset \u03b1) (mem_Icc : \u2200 a b x, x \u2208 finsetIcc a b \u2194 a \u2264 x \u2227 x \u2264 b) :\n    LocallyFiniteOrder \u03b1 :=\n  { finsetIcc\n    finsetIco := fun a b => (finsetIcc a b).filter fun x => x \u2260 b\n    finsetIoc := fun a b => (finsetIcc a b).filter fun x => a \u2260 x\n    finsetIoo := fun a b => (finsetIcc a b).filter fun x => a \u2260 x \u2227 x \u2260 b\n    finset_mem_Icc := mem_Icc\n    finset_mem_Ico := fun a b x => by rw [Finset.mem_filter, mem_Icc, and_assoc, lt_iff_le_and_ne]\n    finset_mem_Ioc := fun a b x => by\n      rw [Finset.mem_filter, mem_Icc, and_right_comm, lt_iff_le_and_ne]\n    finset_mem_Ioo := fun a b x => by\n      rw [Finset.mem_filter, mem_Icc, and_and_and_comm, lt_iff_le_and_ne, lt_iff_le_and_ne] }", "start": [178, 1], "end": [193, 94], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderTop.ofIci'", "code": "def LocallyFiniteOrderTop.ofIci' (\u03b1 : Type*) [Preorder \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    (finsetIci : \u03b1 \u2192 Finset \u03b1) (mem_Ici : \u2200 a x, x \u2208 finsetIci a \u2194 a \u2264 x) :\n    LocallyFiniteOrderTop \u03b1 :=\n  { finsetIci\n    finsetIoi := fun a => (finsetIci a).filter fun x => \u00acx \u2264 a\n    finset_mem_Ici := mem_Ici\n    finset_mem_Ioi := fun a x => by rw [mem_filter, mem_Ici, lt_iff_le_not_le] }", "start": [196, 1], "end": [205, 81], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderTop.ofIci", "code": "def LocallyFiniteOrderTop.ofIci (\u03b1 : Type*) [PartialOrder \u03b1] [DecidableEq \u03b1]\n    (finsetIci : \u03b1 \u2192 Finset \u03b1) (mem_Ici : \u2200 a x, x \u2208 finsetIci a \u2194 a \u2264 x) :\n    LocallyFiniteOrderTop \u03b1 :=\n  { finsetIci\n    finsetIoi := fun a => (finsetIci a).filter fun x => a \u2260 x\n    finset_mem_Ici := mem_Ici\n    finset_mem_Ioi := fun a x => by rw [mem_filter, mem_Ici, lt_iff_le_and_ne] }", "start": [208, 1], "end": [217, 81], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderBot.ofIic'", "code": "def LocallyFiniteOrderBot.ofIic' (\u03b1 : Type*) [Preorder \u03b1] [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)]\n    (finsetIic : \u03b1 \u2192 Finset \u03b1) (mem_Iic : \u2200 a x, x \u2208 finsetIic a \u2194 x \u2264 a) :\n    LocallyFiniteOrderBot \u03b1 :=\n  { finsetIic\n    finsetIio := fun a => (finsetIic a).filter fun x => \u00aca \u2264 x\n    finset_mem_Iic := mem_Iic\n    finset_mem_Iio := fun a x => by rw [mem_filter, mem_Iic, lt_iff_le_not_le] }", "start": [220, 1], "end": [229, 81], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrderTop.ofIic", "code": "def LocallyFiniteOrderTop.ofIic (\u03b1 : Type*) [PartialOrder \u03b1] [DecidableEq \u03b1]\n    (finsetIic : \u03b1 \u2192 Finset \u03b1) (mem_Iic : \u2200 a x, x \u2208 finsetIic a \u2194 x \u2264 a) :\n    LocallyFiniteOrderBot \u03b1 :=\n  { finsetIic\n    finsetIio := fun a => (finsetIic a).filter fun x => x \u2260 a\n    finset_mem_Iic := mem_Iic\n    finset_mem_Iio := fun a x => by rw [mem_filter, mem_Iic, lt_iff_le_and_ne] }", "start": [232, 1], "end": [241, 81], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toLocallyFiniteOrder", "code": "@[reducible]\nprotected def IsEmpty.toLocallyFiniteOrder [Preorder \u03b1] [IsEmpty \u03b1] : LocallyFiniteOrder \u03b1 where\n  finsetIcc := isEmptyElim\n  finsetIco := isEmptyElim\n  finsetIoc := isEmptyElim\n  finsetIoo := isEmptyElim\n  finset_mem_Icc := isEmptyElim\n  finset_mem_Ico := isEmptyElim\n  finset_mem_Ioc := isEmptyElim\n  finset_mem_Ioo := isEmptyElim", "start": [247, 1], "end": [259, 32], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toLocallyFiniteOrderTop", "code": "@[reducible]\nprotected def IsEmpty.toLocallyFiniteOrderTop [Preorder \u03b1] [IsEmpty \u03b1] : LocallyFiniteOrderTop \u03b1\n    where\n  finsetIci := isEmptyElim\n  finsetIoi := isEmptyElim\n  finset_mem_Ici := isEmptyElim\n  finset_mem_Ioi := isEmptyElim", "start": [263, 1], "end": [272, 32], "kind": "commanddeclaration"}, {"full_name": "IsEmpty.toLocallyFiniteOrderBot", "code": "@[reducible]\nprotected def IsEmpty.toLocallyFiniteOrderBot [Preorder \u03b1] [IsEmpty \u03b1] : LocallyFiniteOrderBot \u03b1\n    where\n  finsetIic := isEmptyElim\n  finsetIio := isEmptyElim\n  finset_mem_Iic := isEmptyElim\n  finset_mem_Iio := isEmptyElim", "start": [276, 1], "end": [285, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc", "code": "def Icc (a b : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrder.finsetIcc a b", "start": [301, 1], "end": [304, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico", "code": "def Ico (a b : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrder.finsetIco a b", "start": [307, 1], "end": [310, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc", "code": "def Ioc (a b : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrder.finsetIoc a b", "start": [313, 1], "end": [316, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo", "code": "def Ioo (a b : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrder.finsetIoo a b", "start": [319, 1], "end": [322, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Icc", "code": "@[simp]\ntheorem mem_Icc : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b", "start": [325, 1], "end": [327, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Ico", "code": "@[simp]\ntheorem mem_Ico : x \u2208 Ico a b \u2194 a \u2264 x \u2227 x < b", "start": [330, 1], "end": [332, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Ioc", "code": "@[simp]\ntheorem mem_Ioc : x \u2208 Ioc a b \u2194 a < x \u2227 x \u2264 b", "start": [335, 1], "end": [337, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Ioo", "code": "@[simp]\ntheorem mem_Ioo : x \u2208 Ioo a b \u2194 a < x \u2227 x < b", "start": [340, 1], "end": [342, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Icc", "code": "@[simp, norm_cast]\ntheorem coe_Icc (a b : \u03b1) : (Icc a b : Set \u03b1) = Set.Icc a b", "start": [345, 1], "end": [347, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Ico", "code": "@[simp, norm_cast]\ntheorem coe_Ico (a b : \u03b1) : (Ico a b : Set \u03b1) = Set.Ico a b", "start": [350, 1], "end": [352, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Ioc", "code": "@[simp, norm_cast]\ntheorem coe_Ioc (a b : \u03b1) : (Ioc a b : Set \u03b1) = Set.Ioc a b", "start": [355, 1], "end": [357, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Ioo", "code": "@[simp, norm_cast]\ntheorem coe_Ioo (a b : \u03b1) : (Ioo a b : Set \u03b1) = Set.Ioo a b", "start": [360, 1], "end": [362, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Ici", "code": "def Ici (a : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrderTop.finsetIci a", "start": [371, 1], "end": [373, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioi", "code": "def Ioi (a : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrderTop.finsetIoi a", "start": [376, 1], "end": [378, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Ici", "code": "@[simp]\ntheorem mem_Ici : x \u2208 Ici a \u2194 a \u2264 x", "start": [381, 1], "end": [383, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Ioi", "code": "@[simp]\ntheorem mem_Ioi : x \u2208 Ioi a \u2194 a < x", "start": [386, 1], "end": [388, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Ici", "code": "@[simp, norm_cast]\ntheorem coe_Ici (a : \u03b1) : (Ici a : Set \u03b1) = Set.Ici a", "start": [391, 1], "end": [393, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Ioi", "code": "@[simp, norm_cast]\ntheorem coe_Ioi (a : \u03b1) : (Ioi a : Set \u03b1) = Set.Ioi a", "start": [396, 1], "end": [398, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic", "code": "def Iic (a : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrderBot.finsetIic a", "start": [407, 1], "end": [409, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio", "code": "def Iio (a : \u03b1) : Finset \u03b1 :=\n  LocallyFiniteOrderBot.finsetIio a", "start": [412, 1], "end": [414, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Iic", "code": "@[simp]\ntheorem mem_Iic : x \u2208 Iic a \u2194 x \u2264 a", "start": [417, 1], "end": [419, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_Iio", "code": "@[simp]\ntheorem mem_Iio : x \u2208 Iio a \u2194 x < a", "start": [422, 1], "end": [424, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Iic", "code": "@[simp, norm_cast]\ntheorem coe_Iic (a : \u03b1) : (Iic a : Set \u03b1) = Set.Iic a", "start": [427, 1], "end": [429, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_Iio", "code": "@[simp, norm_cast]\ntheorem coe_Iio (a : \u03b1) : (Iio a : Set \u03b1) = Set.Iio a", "start": [432, 1], "end": [434, 27], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrder.toLocallyFiniteOrderTop", "code": "instance (priority := 100) _root_.LocallyFiniteOrder.toLocallyFiniteOrderTop :\n    LocallyFiniteOrderTop \u03b1 where\n  finsetIci b := Icc b \u22a4\n  finsetIoi b := Ioc b \u22a4\n  finset_mem_Ici a x := by rw [mem_Icc, and_iff_left le_top]\n  finset_mem_Ioi a x := by rw [mem_Ioc, and_iff_left le_top]", "start": [444, 1], "end": [449, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.Ici_eq_Icc", "code": "theorem Ici_eq_Icc (a : \u03b1) : Ici a = Icc a \u22a4", "start": [452, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioi_eq_Ioc", "code": "theorem Ioi_eq_Ioc (a : \u03b1) : Ioi a = Ioc a \u22a4", "start": [456, 1], "end": [457, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.LocallyFiniteOrder.toLocallyFiniteOrderBot", "code": "instance (priority := 100) LocallyFiniteOrder.toLocallyFiniteOrderBot : LocallyFiniteOrderBot \u03b1\n    where\n  finsetIic := Icc \u22a5\n  finsetIio := Ico \u22a5\n  finset_mem_Iic a x := by rw [mem_Icc, and_iff_right bot_le]\n  finset_mem_Iio a x := by rw [mem_Ico, and_iff_right bot_le]", "start": [467, 1], "end": [472, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic_eq_Icc", "code": "theorem Iic_eq_Icc : Iic = Icc (\u22a5 : \u03b1)", "start": [475, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio_eq_Ico", "code": "theorem Iio_eq_Ico : Iio = Ico (\u22a5 : \u03b1)", "start": [479, 1], "end": [480, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc", "code": "def uIcc (a b : \u03b1) : Finset \u03b1 :=\n  Icc (a \u2293 b) (a \u2294 b)", "start": [491, 1], "end": [495, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_uIcc", "code": "@[simp]\ntheorem mem_uIcc : x \u2208 uIcc a b \u2194 a \u2293 b \u2264 x \u2227 x \u2264 a \u2294 b", "start": [501, 1], "end": [503, 10], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_uIcc", "code": "@[simp, norm_cast]\ntheorem coe_uIcc (a b : \u03b1) : (Finset.uIcc a b : Set \u03b1) = Set.uIcc a b", "start": [506, 1], "end": [508, 14], "kind": "commanddeclaration"}, {"full_name": "Multiset.Icc", "code": "def Icc (a b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Icc a b).val", "start": [526, 1], "end": [529, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ico", "code": "def Ico (a b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Ico a b).val", "start": [532, 1], "end": [535, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioc", "code": "def Ioc (a b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Ioc a b).val", "start": [538, 1], "end": [541, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioo", "code": "def Ioo (a b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Ioo a b).val", "start": [544, 1], "end": [547, 23], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Icc", "code": "@[simp]\ntheorem mem_Icc {a b x : \u03b1} : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b", "start": [550, 1], "end": [552, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Ico", "code": "@[simp]\ntheorem mem_Ico {a b x : \u03b1} : x \u2208 Ico a b \u2194 a \u2264 x \u2227 x < b", "start": [555, 1], "end": [557, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Ioc", "code": "@[simp]\ntheorem mem_Ioc {a b x : \u03b1} : x \u2208 Ioc a b \u2194 a < x \u2227 x \u2264 b", "start": [560, 1], "end": [562, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Ioo", "code": "@[simp]\ntheorem mem_Ioo {a b x : \u03b1} : x \u2208 Ioo a b \u2194 a < x \u2227 x < b", "start": [565, 1], "end": [567, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ici", "code": "def Ici (a : \u03b1) : Multiset \u03b1 :=\n  (Finset.Ici a).val", "start": [576, 1], "end": [578, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.Ioi", "code": "def Ioi (a : \u03b1) : Multiset \u03b1 :=\n  (Finset.Ioi a).val", "start": [581, 1], "end": [583, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Ici", "code": "@[simp]\ntheorem mem_Ici {a x : \u03b1} : x \u2208 Ici a \u2194 a \u2264 x", "start": [586, 1], "end": [587, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Ioi", "code": "@[simp]\ntheorem mem_Ioi {a x : \u03b1} : x \u2208 Ioi a \u2194 a < x", "start": [590, 1], "end": [591, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.Iic", "code": "def Iic (b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Iic b).val", "start": [600, 1], "end": [602, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.Iio", "code": "def Iio (b : \u03b1) : Multiset \u03b1 :=\n  (Finset.Iio b).val", "start": [605, 1], "end": [607, 21], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Iic", "code": "@[simp]\ntheorem mem_Iic {b x : \u03b1} : x \u2208 Iic b \u2194 x \u2264 b", "start": [610, 1], "end": [611, 95], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_Iio", "code": "@[simp]\ntheorem mem_Iio {b x : \u03b1} : x \u2208 Iio b \u2194 x < b", "start": [614, 1], "end": [615, 95], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIcc", "code": "instance fintypeIcc : Fintype (Icc a b) := Fintype.ofFinset (Finset.Icc a b) fun _ => Finset.mem_Icc", "start": [631, 1], "end": [631, 101], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIco", "code": "instance fintypeIco : Fintype (Ico a b) := Fintype.ofFinset (Finset.Ico a b) fun _ => Finset.mem_Ico", "start": [634, 1], "end": [634, 101], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIoc", "code": "instance fintypeIoc : Fintype (Ioc a b) := Fintype.ofFinset (Finset.Ioc a b) fun _ => Finset.mem_Ioc", "start": [637, 1], "end": [637, 101], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIoo", "code": "instance fintypeIoo : Fintype (Ioo a b) := Fintype.ofFinset (Finset.Ioo a b) fun _ => Finset.mem_Ioo", "start": [640, 1], "end": [640, 101], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Icc", "code": "theorem finite_Icc : (Icc a b).Finite", "start": [643, 1], "end": [644, 21], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Ico", "code": "theorem finite_Ico : (Ico a b).Finite", "start": [647, 1], "end": [648, 21], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Ioc", "code": "theorem finite_Ioc : (Ioc a b).Finite", "start": [651, 1], "end": [652, 21], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Ioo", "code": "theorem finite_Ioo : (Ioo a b).Finite", "start": [655, 1], "end": [656, 21], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIci", "code": "instance fintypeIci : Fintype (Ici a) := Fintype.ofFinset (Finset.Ici a) fun _ => Finset.mem_Ici", "start": [665, 1], "end": [665, 97], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIoi", "code": "instance fintypeIoi : Fintype (Ioi a) := Fintype.ofFinset (Finset.Ioi a) fun _ => Finset.mem_Ioi", "start": [668, 1], "end": [668, 97], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Ici", "code": "theorem finite_Ici : (Ici a).Finite", "start": [671, 1], "end": [672, 19], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Ioi", "code": "theorem finite_Ioi : (Ioi a).Finite", "start": [675, 1], "end": [676, 19], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIic", "code": "instance fintypeIic : Fintype (Iic b) := Fintype.ofFinset (Finset.Iic b) fun _ => Finset.mem_Iic", "start": [685, 1], "end": [685, 97], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeIio", "code": "instance fintypeIio : Fintype (Iio b) := Fintype.ofFinset (Finset.Iio b) fun _ => Finset.mem_Iio", "start": [688, 1], "end": [688, 97], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Iic", "code": "theorem finite_Iic : (Iic b).Finite", "start": [691, 1], "end": [692, 19], "kind": "commanddeclaration"}, {"full_name": "Set.finite_Iio", "code": "theorem finite_Iio : (Iio b).Finite", "start": [695, 1], "end": [696, 19], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeUIcc", "code": "instance fintypeUIcc : Fintype (uIcc a b) :=\n  Fintype.ofFinset (Finset.uIcc a b) fun _ => Finset.mem_uIcc", "start": [704, 1], "end": [705, 62], "kind": "commanddeclaration"}, {"full_name": "Set.finite_interval", "code": "@[simp]\ntheorem finite_interval : (uIcc a b).Finite", "start": [708, 1], "end": [709, 67], "kind": "commanddeclaration"}, {"full_name": "LocallyFiniteOrder.ofFiniteIcc", "code": "noncomputable def LocallyFiniteOrder.ofFiniteIcc (h : \u2200 a b : \u03b1, (Set.Icc a b).Finite) :\n    LocallyFiniteOrder \u03b1 :=\n  @LocallyFiniteOrder.ofIcc' \u03b1 _ (Classical.decRel _) (fun a b => (h a b).toFinset) fun a b x => by\n    rw [Set.Finite.mem_toFinset, Set.mem_Icc]", "start": [725, 1], "end": [729, 46], "kind": "commanddeclaration"}, {"full_name": "Fintype.toLocallyFiniteOrder", "code": "@[reducible]\ndef Fintype.toLocallyFiniteOrder [Fintype \u03b1] [@DecidableRel \u03b1 (\u00b7 < \u00b7)] [@DecidableRel \u03b1 (\u00b7 \u2264 \u00b7)] :\n    LocallyFiniteOrder \u03b1 where\n  finsetIcc a b := (Set.Icc a b).toFinset\n  finsetIco a b := (Set.Ico a b).toFinset\n  finsetIoc a b := (Set.Ioc a b).toFinset\n  finsetIoo a b := (Set.Ioo a b).toFinset\n  finset_mem_Icc a b x := by simp only [Set.mem_toFinset, Set.mem_Icc]\n  finset_mem_Ico a b x := by simp only [Set.mem_toFinset, Set.mem_Ico]\n  finset_mem_Ioc a b x := by simp only [Set.mem_toFinset, Set.mem_Ioc]\n  finset_mem_Ioo a b x := by simp only [Set.mem_toFinset, Set.mem_Ioo]", "start": [732, 1], "end": [747, 71], "kind": "commanddeclaration"}, {"full_name": "OrderEmbedding.locallyFiniteOrder", "code": "protected noncomputable def OrderEmbedding.locallyFiniteOrder [LocallyFiniteOrder \u03b2] (f : \u03b1 \u21aao \u03b2) :\n    LocallyFiniteOrder \u03b1 where\n  finsetIcc a b := (Icc (f a) (f b)).preimage f (f.toEmbedding.injective.injOn _)\n  finsetIco a b := (Ico (f a) (f b)).preimage f (f.toEmbedding.injective.injOn _)\n  finsetIoc a b := (Ioc (f a) (f b)).preimage f (f.toEmbedding.injective.injOn _)\n  finsetIoo a b := (Ioo (f a) (f b)).preimage f (f.toEmbedding.injective.injOn _)\n  finset_mem_Icc a b x := by rw [mem_preimage, mem_Icc, f.le_iff_le, f.le_iff_le]\n  finset_mem_Ico a b x := by rw [mem_preimage, mem_Ico, f.le_iff_le, f.lt_iff_lt]\n  finset_mem_Ioc a b x := by rw [mem_preimage, mem_Ioc, f.lt_iff_lt, f.le_iff_le]\n  finset_mem_Ioo a b x := by rw [mem_preimage, mem_Ioo, f.lt_iff_lt, f.lt_iff_lt]", "start": [795, 1], "end": [805, 82], "kind": "commanddeclaration"}, {"full_name": "OrderDual.locallyFiniteOrder", "code": "instance OrderDual.locallyFiniteOrder : LocallyFiniteOrder \u03b1\u1d52\u1d48 where\n  finsetIcc a b := @Icc \u03b1 _ _ (ofDual b) (ofDual a)\n  finsetIco a b := @Ioc \u03b1 _ _ (ofDual b) (ofDual a)\n  finsetIoc a b := @Ico \u03b1 _ _ (ofDual b) (ofDual a)\n  finsetIoo a b := @Ioo \u03b1 _ _ (ofDual b) (ofDual a)\n  finset_mem_Icc _ _ _ := (mem_Icc (\u03b1 := \u03b1)).trans and_comm\n  finset_mem_Ico _ _ _ := (mem_Ioc (\u03b1 := \u03b1)).trans and_comm\n  finset_mem_Ioc _ _ _ := (mem_Ico (\u03b1 := \u03b1)).trans and_comm\n  finset_mem_Ioo _ _ _ := (mem_Ioo (\u03b1 := \u03b1)).trans and_comm", "start": [814, 1], "end": [829, 60], "kind": "commanddeclaration"}, {"full_name": "Icc_toDual", "code": "theorem Icc_toDual : Icc (toDual a) (toDual b) = (Icc b a).map toDual.toEmbedding", "start": [831, 1], "end": [835, 17], "kind": "commanddeclaration"}, {"full_name": "Ico_toDual", "code": "theorem Ico_toDual : Ico (toDual a) (toDual b) = (Ioc b a).map toDual.toEmbedding", "start": [838, 1], "end": [842, 17], "kind": "commanddeclaration"}, {"full_name": "Ioc_toDual", "code": "theorem Ioc_toDual : Ioc (toDual a) (toDual b) = (Ico b a).map toDual.toEmbedding", "start": [845, 1], "end": [849, 17], "kind": "commanddeclaration"}, {"full_name": "Ioo_toDual", "code": "theorem Ioo_toDual : Ioo (toDual a) (toDual b) = (Ioo b a).map toDual.toEmbedding", "start": [852, 1], "end": [856, 17], "kind": "commanddeclaration"}, {"full_name": "Icc_ofDual", "code": "theorem Icc_ofDual (a b : \u03b1\u1d52\u1d48) : Icc (ofDual a) (ofDual b) = (Icc b a).map ofDual.toEmbedding", "start": [859, 1], "end": [863, 17], "kind": "commanddeclaration"}, {"full_name": "Ico_ofDual", "code": "theorem Ico_ofDual (a b : \u03b1\u1d52\u1d48) : Ico (ofDual a) (ofDual b) = (Ioc b a).map ofDual.toEmbedding", "start": [866, 1], "end": [870, 17], "kind": "commanddeclaration"}, {"full_name": "Ioc_ofDual", "code": "theorem Ioc_ofDual (a b : \u03b1\u1d52\u1d48) : Ioc (ofDual a) (ofDual b) = (Ico b a).map ofDual.toEmbedding", "start": [873, 1], "end": [877, 17], "kind": "commanddeclaration"}, {"full_name": "Ioo_ofDual", "code": "theorem Ioo_ofDual (a b : \u03b1\u1d52\u1d48) : Ioo (ofDual a) (ofDual b) = (Ioo b a).map ofDual.toEmbedding", "start": [880, 1], "end": [884, 17], "kind": "commanddeclaration"}, {"full_name": "Iic_toDual", "code": "theorem Iic_toDual (a : \u03b1) : Iic (toDual a) = (Ici a).map toDual.toEmbedding", "start": [905, 1], "end": [906, 16], "kind": "commanddeclaration"}, {"full_name": "Iio_toDual", "code": "theorem Iio_toDual (a : \u03b1) : Iio (toDual a) = (Ioi a).map toDual.toEmbedding", "start": [909, 1], "end": [910, 16], "kind": "commanddeclaration"}, {"full_name": "Ici_ofDual", "code": "theorem Ici_ofDual (a : \u03b1\u1d52\u1d48) : Ici (ofDual a) = (Iic a).map ofDual.toEmbedding", "start": [913, 1], "end": [914, 16], "kind": "commanddeclaration"}, {"full_name": "Ioi_ofDual", "code": "theorem Ioi_ofDual (a : \u03b1\u1d52\u1d48) : Ioi (ofDual a) = (Iio a).map ofDual.toEmbedding", "start": [917, 1], "end": [918, 16], "kind": "commanddeclaration"}, {"full_name": "Ici_toDual", "code": "theorem Ici_toDual (a : \u03b1) : Ici (toDual a) = (Iic a).map toDual.toEmbedding", "start": [939, 1], "end": [940, 16], "kind": "commanddeclaration"}, {"full_name": "Ioi_toDual", "code": "theorem Ioi_toDual (a : \u03b1) : Ioi (toDual a) = (Iio a).map toDual.toEmbedding", "start": [943, 1], "end": [944, 16], "kind": "commanddeclaration"}, {"full_name": "Iic_ofDual", "code": "theorem Iic_ofDual (a : \u03b1\u1d52\u1d48) : Iic (ofDual a) = (Ici a).map ofDual.toEmbedding", "start": [947, 1], "end": [948, 16], "kind": "commanddeclaration"}, {"full_name": "Iio_ofDual", "code": "theorem Iio_ofDual (a : \u03b1\u1d52\u1d48) : Iio (ofDual a) = (Ioi a).map ofDual.toEmbedding", "start": [951, 1], "end": [952, 16], "kind": "commanddeclaration"}, {"full_name": "Prod.Icc_eq", "code": "theorem Icc_eq [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (p q : \u03b1 \u00d7 \u03b2) :\n    Finset.Icc p q = Finset.Icc p.1 q.1 \u00d7\u02e2 Finset.Icc p.2 q.2", "start": [977, 1], "end": [980, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.Icc_mk_mk", "code": "@[simp]\ntheorem Icc_mk_mk [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) :\n    Finset.Icc (a\u2081, b\u2081) (a\u2082, b\u2082) = Finset.Icc a\u2081 a\u2082 \u00d7\u02e2 Finset.Icc b\u2081 b\u2082", "start": [983, 1], "end": [987, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.card_Icc", "code": "theorem card_Icc [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (p q : \u03b1 \u00d7 \u03b2) :\n    (Finset.Icc p q).card = (Finset.Icc p.1 q.1).card * (Finset.Icc p.2 q.2).card", "start": [990, 1], "end": [993, 26], "kind": "commanddeclaration"}, {"full_name": "Prod.uIcc_eq", "code": "theorem uIcc_eq [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (p q : \u03b1 \u00d7 \u03b2) :\n    Finset.uIcc p q = Finset.uIcc p.1 q.1 \u00d7\u02e2 Finset.uIcc p.2 q.2", "start": [1004, 1], "end": [1007, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.uIcc_mk_mk", "code": "@[simp]\ntheorem uIcc_mk_mk [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) :\n    Finset.uIcc (a\u2081, b\u2081) (a\u2082, b\u2082) = Finset.uIcc a\u2081 a\u2082 \u00d7\u02e2 Finset.uIcc b\u2081 b\u2082", "start": [1010, 1], "end": [1014, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.card_uIcc", "code": "theorem card_uIcc [LocallyFiniteOrder \u03b1] [LocallyFiniteOrder \u03b2]\n    [DecidableRel ((\u00b7 \u2264 \u00b7) : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7 \u03b2 \u2192 Prop)] (p q : \u03b1 \u00d7 \u03b2) :\n    (Finset.uIcc p q).card = (Finset.uIcc p.1 q.1).card * (Finset.uIcc p.2 q.2).card", "start": [1017, 1], "end": [1020, 20], "kind": "commanddeclaration"}, {"full_name": "WithTop.aux", "code": "private lemma aux (x : \u03b1) (p : \u03b1 \u2192 Prop) :\n    (\u2203 a : \u03b1, p a \u2227 Option.some a = Option.some x) \u2194 p x := by\n  constructor\n  \u00b7 rintro \u27e8x', hx, hx'\u27e9\n    obtain rfl := Option.some_inj.mp hx'\n    exact hx\n  \u00b7 exact fun h => \u27e8x, h, rfl\u27e9", "start": [1041, 1], "end": [1048, 31], "kind": "mathlibtacticlemma"}, {"full_name": "WithTop.locallyFiniteOrder", "code": "instance locallyFiniteOrder : LocallyFiniteOrder (WithTop \u03b1) where\n  finsetIcc a b :=\n    match a, b with\n    | \u22a4, \u22a4 => {\u22a4}\n    | \u22a4, (b : \u03b1) => \u2205\n    | (a : \u03b1), \u22a4 => insertNone (Ici a)\n    | (a : \u03b1), (b : \u03b1) => (Icc a b).map Embedding.some\n  finsetIco a b :=\n    match a, b with\n    | \u22a4, _ => \u2205\n    | (a : \u03b1), \u22a4 => (Ici a).map Embedding.some\n    | (a : \u03b1), (b : \u03b1) => (Ico a b).map Embedding.some\n  finsetIoc a b :=\n    match a, b with\n    | \u22a4, _ => \u2205\n    | (a : \u03b1), \u22a4 => insertNone (Ioi a)\n    | (a : \u03b1), (b : \u03b1) => (Ioc a b).map Embedding.some\n  finsetIoo a b :=\n    match a, b with\n    | \u22a4, _ => \u2205\n    | (a : \u03b1), \u22a4 => (Ioi a).map Embedding.some\n    | (a : \u03b1), (b : \u03b1) => (Ioo a b).map Embedding.some\n  finset_mem_Icc a b x :=\n    match a, b, x with\n    | \u22a4, \u22a4, x => mem_singleton.trans (le_antisymm_iff.trans and_comm)\n    | \u22a4, (b : \u03b1), x =>\n      iff_of_false (not_mem_empty _) fun h => (h.1.trans h.2).not_lt <| coe_lt_top _\n    | (a : \u03b1), \u22a4, \u22a4 => by simp [WithTop.some, WithTop.top, insertNone]\n    | (a : \u03b1), \u22a4, (x : \u03b1) => by\n        simp only [some, le_eq_subset, some_le_some, le_top, and_true]\n        rw [some_mem_insertNone]\n        simp\n    | (a : \u03b1), (b : \u03b1), \u22a4 => by\n        simp only [some, le_eq_subset, mem_map, mem_Icc, le_top, top_le_iff, and_false, iff_false,\n          not_exists, not_and, and_imp, Embedding.some, forall_const]\n    | (a : \u03b1), (b : \u03b1), (x : \u03b1) => by\n        simp only [some, le_eq_subset, Embedding.some, mem_map, mem_Icc, Embedding.coeFn_mk,\n          some_le_some]\n        erw [aux]\n  finset_mem_Ico a b x :=\n    match a, b, x with\n    | \u22a4, b, x => iff_of_false (not_mem_empty _) fun h => not_top_lt <| h.1.trans_lt h.2\n    | (a : \u03b1), \u22a4, \u22a4 => by simp [some, Embedding.some]\n    | (a : \u03b1), \u22a4, (x : \u03b1) => by\n        simp only [some, Embedding.some, mem_map, mem_Ici, Embedding.coeFn_mk, some_le_some, aux,\n          top, some_lt_none, and_true]\n        erw [aux]\n    | (a : \u03b1), (b : \u03b1), \u22a4 => by simp [some, Embedding.some]\n    | (a : \u03b1), (b : \u03b1), (x : \u03b1) => by simp [some, Embedding.some, aux]\n                                      erw [aux]\n  finset_mem_Ioc a b x :=\n    match a, b, x with\n    | \u22a4, b, x => iff_of_false (not_mem_empty _) fun h => not_top_lt <| h.1.trans_le h.2\n    | (a : \u03b1), \u22a4, \u22a4 => by simp [some, insertNone, top]\n    | (a : \u03b1), \u22a4, (x : \u03b1) => by simp [some, Embedding.some, insertNone, aux]\n                                erw [aux]\n    | (a : \u03b1), (b : \u03b1), \u22a4 => by simp [some, Embedding.some, insertNone]\n    | (a : \u03b1), (b : \u03b1), (x : \u03b1) => by simp [some, Embedding.some, insertNone, aux]\n                                      erw [aux]\n  finset_mem_Ioo a b x :=\n    match a, b, x with\n    | \u22a4, b, x => iff_of_false (not_mem_empty _) fun h => not_top_lt <| h.1.trans h.2\n    | (a : \u03b1), \u22a4, \u22a4 => by simp [some, Embedding.some, insertNone]\n    | (a : \u03b1), \u22a4, (x : \u03b1) => by simp [some, Embedding.some, insertNone, aux, top]\n                                erw [aux]\n    | (a : \u03b1), (b : \u03b1), \u22a4 => by simp [some, Embedding.some, insertNone]\n    | (a : \u03b1), (b : \u03b1), (x : \u03b1) => by\n      simp [some, Embedding.some, insertNone, aux]\n      erw [aux]", "start": [1050, 1], "end": [1131, 16], "kind": "commanddeclaration"}, {"full_name": "WithTop.Icc_coe_top", "code": "theorem Icc_coe_top : Icc (a : WithTop \u03b1) \u22a4 = insertNone (Ici a)", "start": [1135, 1], "end": [1136, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Icc_coe_coe", "code": "theorem Icc_coe_coe : Icc (a : WithTop \u03b1) b = (Icc a b).map Embedding.some", "start": [1139, 1], "end": [1140, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ico_coe_top", "code": "theorem Ico_coe_top : Ico (a : WithTop \u03b1) \u22a4 = (Ici a).map Embedding.some", "start": [1143, 1], "end": [1144, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ico_coe_coe", "code": "theorem Ico_coe_coe : Ico (a : WithTop \u03b1) b = (Ico a b).map Embedding.some", "start": [1147, 1], "end": [1148, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ioc_coe_top", "code": "theorem Ioc_coe_top : Ioc (a : WithTop \u03b1) \u22a4 = insertNone (Ioi a)", "start": [1151, 1], "end": [1152, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ioc_coe_coe", "code": "theorem Ioc_coe_coe : Ioc (a : WithTop \u03b1) b = (Ioc a b).map Embedding.some", "start": [1155, 1], "end": [1156, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ioo_coe_top", "code": "theorem Ioo_coe_top : Ioo (a : WithTop \u03b1) \u22a4 = (Ioi a).map Embedding.some", "start": [1159, 1], "end": [1160, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.Ioo_coe_coe", "code": "theorem Ioo_coe_coe : Ioo (a : WithTop \u03b1) b = (Ioo a b).map Embedding.some", "start": [1163, 1], "end": [1164, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Icc_bot_coe", "code": "theorem Icc_bot_coe : Icc (\u22a5 : WithBot \u03b1) b = insertNone (Iic b)", "start": [1178, 1], "end": [1179, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Icc_coe_coe", "code": "theorem Icc_coe_coe : Icc (a : WithBot \u03b1) b = (Icc a b).map Embedding.some", "start": [1182, 1], "end": [1183, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ico_bot_coe", "code": "theorem Ico_bot_coe : Ico (\u22a5 : WithBot \u03b1) b = insertNone (Iio b)", "start": [1186, 1], "end": [1187, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ico_coe_coe", "code": "theorem Ico_coe_coe : Ico (a : WithBot \u03b1) b = (Ico a b).map Embedding.some", "start": [1190, 1], "end": [1191, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ioc_bot_coe", "code": "theorem Ioc_bot_coe : Ioc (\u22a5 : WithBot \u03b1) b = (Iic b).map Embedding.some", "start": [1194, 1], "end": [1195, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ioc_coe_coe", "code": "theorem Ioc_coe_coe : Ioc (a : WithBot \u03b1) b = (Ioc a b).map Embedding.some", "start": [1198, 1], "end": [1199, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ioo_bot_coe", "code": "theorem Ioo_bot_coe : Ioo (\u22a5 : WithBot \u03b1) b = (Iio b).map Embedding.some", "start": [1202, 1], "end": [1203, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.Ioo_coe_coe", "code": "theorem Ioo_coe_coe : Ioo (a : WithBot \u03b1) b = (Ioo a b).map Embedding.some", "start": [1206, 1], "end": [1207, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.locallyFiniteOrder", "code": "@[reducible]\ndef locallyFiniteOrder [LocallyFiniteOrder \u03b2] (f : \u03b1 \u2243o \u03b2) : LocallyFiniteOrder \u03b1 where\n  finsetIcc a b := (Icc (f a) (f b)).map f.symm.toEquiv.toEmbedding\n  finsetIco a b := (Ico (f a) (f b)).map f.symm.toEquiv.toEmbedding\n  finsetIoc a b := (Ioc (f a) (f b)).map f.symm.toEquiv.toEmbedding\n  finsetIoo a b := (Ioo (f a) (f b)).map f.symm.toEquiv.toEmbedding\n  finset_mem_Icc := by simp\n  finset_mem_Ico := by simp\n  finset_mem_Ioc := by simp\n  finset_mem_Ioo := by simp", "start": [1220, 1], "end": [1230, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.locallyFiniteOrderTop", "code": "@[reducible]\ndef locallyFiniteOrderTop [LocallyFiniteOrderTop \u03b2] (f : \u03b1 \u2243o \u03b2) : LocallyFiniteOrderTop \u03b1 where\n  finsetIci a := (Ici (f a)).map f.symm.toEquiv.toEmbedding\n  finsetIoi a := (Ioi (f a)).map f.symm.toEquiv.toEmbedding\n  finset_mem_Ici := by simp\n  finset_mem_Ioi := by simp", "start": [1234, 1], "end": [1240, 28], "kind": "commanddeclaration"}, {"full_name": "OrderIso.locallyFiniteOrderBot", "code": "@[reducible]\ndef locallyFiniteOrderBot [LocallyFiniteOrderBot \u03b2] (f : \u03b1 \u2243o \u03b2) : LocallyFiniteOrderBot \u03b1 where\n  finsetIic a := (Iic (f a)).map f.symm.toEquiv.toEmbedding\n  finsetIio a := (Iio (f a)).map f.symm.toEquiv.toEmbedding\n  finset_mem_Iic := by simp\n  finset_mem_Iio := by simp", "start": [1244, 1], "end": [1250, 28], "kind": "commanddeclaration"}, {"full_name": "Subtype.instLocallyFiniteOrder", "code": "instance Subtype.instLocallyFiniteOrder [LocallyFiniteOrder \u03b1] :\n    LocallyFiniteOrder (Subtype p) where\n  finsetIcc a b := (Icc (a : \u03b1) b).subtype p\n  finsetIco a b := (Ico (a : \u03b1) b).subtype p\n  finsetIoc a b := (Ioc (a : \u03b1) b).subtype p\n  finsetIoo a b := (Ioo (a : \u03b1) b).subtype p\n  finset_mem_Icc a b x := by simp_rw [Finset.mem_subtype, mem_Icc, Subtype.coe_le_coe]\n  finset_mem_Ico a b x := by\n    simp_rw [Finset.mem_subtype, mem_Ico, Subtype.coe_le_coe, Subtype.coe_lt_coe]\n  finset_mem_Ioc a b x := by\n    simp_rw [Finset.mem_subtype, mem_Ioc, Subtype.coe_le_coe, Subtype.coe_lt_coe]\n  finset_mem_Ioo a b x := by simp_rw [Finset.mem_subtype, mem_Ioo, Subtype.coe_lt_coe]", "start": [1260, 1], "end": [1271, 87], "kind": "commanddeclaration"}, {"full_name": "Subtype.instLocallyFiniteOrderTop", "code": "instance Subtype.instLocallyFiniteOrderTop [LocallyFiniteOrderTop \u03b1] :\n    LocallyFiniteOrderTop (Subtype p) where\n  finsetIci a := (Ici (a : \u03b1)).subtype p\n  finsetIoi a := (Ioi (a : \u03b1)).subtype p\n  finset_mem_Ici a x := by simp_rw [Finset.mem_subtype, mem_Ici, Subtype.coe_le_coe]\n  finset_mem_Ioi a x := by simp_rw [Finset.mem_subtype, mem_Ioi, Subtype.coe_lt_coe]", "start": [1273, 1], "end": [1278, 85], "kind": "commanddeclaration"}, {"full_name": "Subtype.instLocallyFiniteOrderBot", "code": "instance Subtype.instLocallyFiniteOrderBot [LocallyFiniteOrderBot \u03b1] :\n    LocallyFiniteOrderBot (Subtype p) where\n  finsetIic a := (Iic (a : \u03b1)).subtype p\n  finsetIio a := (Iio (a : \u03b1)).subtype p\n  finset_mem_Iic a x := by simp_rw [Finset.mem_subtype, mem_Iic, Subtype.coe_le_coe]\n  finset_mem_Iio a x := by simp_rw [Finset.mem_subtype, mem_Iio, Subtype.coe_lt_coe]", "start": [1280, 1], "end": [1285, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Icc_eq", "code": "theorem subtype_Icc_eq : Icc a b = (Icc (a : \u03b1) b).subtype p", "start": [1293, 1], "end": [1294, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Ico_eq", "code": "theorem subtype_Ico_eq : Ico a b = (Ico (a : \u03b1) b).subtype p", "start": [1297, 1], "end": [1298, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Ioc_eq", "code": "theorem subtype_Ioc_eq : Ioc a b = (Ioc (a : \u03b1) b).subtype p", "start": [1301, 1], "end": [1302, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Ioo_eq", "code": "theorem subtype_Ioo_eq : Ioo a b = (Ioo (a : \u03b1) b).subtype p", "start": [1305, 1], "end": [1306, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Icc", "code": "theorem map_subtype_embedding_Icc : (Icc a b).map (Embedding.subtype p) = (Icc a b : Finset \u03b1)", "start": [1311, 1], "end": [1315, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Ico", "code": "theorem map_subtype_embedding_Ico : (Ico a b).map (Embedding.subtype p) = (Ico a b : Finset \u03b1)", "start": [1318, 1], "end": [1322, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Ioc", "code": "theorem map_subtype_embedding_Ioc : (Ioc a b).map (Embedding.subtype p) = (Ioc a b : Finset \u03b1)", "start": [1325, 1], "end": [1329, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Ioo", "code": "theorem map_subtype_embedding_Ioo : (Ioo a b).map (Embedding.subtype p) = (Ioo a b : Finset \u03b1)", "start": [1332, 1], "end": [1336, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Ici_eq", "code": "theorem subtype_Ici_eq : Ici a = (Ici (a : \u03b1)).subtype p", "start": [1345, 1], "end": [1346, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Ioi_eq", "code": "theorem subtype_Ioi_eq : Ioi a = (Ioi (a : \u03b1)).subtype p", "start": [1349, 1], "end": [1350, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Ici", "code": "theorem map_subtype_embedding_Ici : (Ici a).map (Embedding.subtype p) = (Ici a : Finset \u03b1)", "start": [1355, 1], "end": [1357, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Ioi", "code": "theorem map_subtype_embedding_Ioi : (Ioi a).map (Embedding.subtype p) = (Ioi a : Finset \u03b1)", "start": [1360, 1], "end": [1362, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Iic_eq", "code": "theorem subtype_Iic_eq : Iic a = (Iic (a : \u03b1)).subtype p", "start": [1371, 1], "end": [1372, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.subtype_Iio_eq", "code": "theorem subtype_Iio_eq : Iio a = (Iio (a : \u03b1)).subtype p", "start": [1375, 1], "end": [1376, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Iic", "code": "theorem map_subtype_embedding_Iic : (Iic a).map (Embedding.subtype p) = (Iic a : Finset \u03b1)", "start": [1381, 1], "end": [1383, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.map_subtype_embedding_Iio", "code": "theorem map_subtype_embedding_Iio : (Iio a).map (Embedding.subtype p) = (Iio a : Finset \u03b1)", "start": [1386, 1], "end": [1388, 74], "kind": "commanddeclaration"}, {"full_name": "Set.finite_iff_bddAbove", "code": "theorem Set.finite_iff_bddAbove [SemilatticeSup \u03b1] [LocallyFiniteOrder \u03b1] [OrderBot \u03b1]:\n    s.Finite \u2194 BddAbove s", "start": [1399, 1], "end": [1402, 76], "kind": "commanddeclaration"}, {"full_name": "Set.finite_iff_bddBelow", "code": "theorem Set.finite_iff_bddBelow [SemilatticeInf \u03b1] [LocallyFiniteOrder \u03b1] [OrderTop \u03b1] :\n    s.Finite \u2194 BddBelow s", "start": [1404, 1], "end": [1406, 33], "kind": "commanddeclaration"}, {"full_name": "Set.finite_iff_bddBelow_bddAbove", "code": "theorem Set.finite_iff_bddBelow_bddAbove [Nonempty \u03b1] [Lattice \u03b1] [LocallyFiniteOrder \u03b1] :\n    s.Finite \u2194 BddBelow s \u2227 BddAbove s", "start": [1408, 1], "end": [1414, 83], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_Icc", "code": "@[simp] lemma toFinset_Icc (a b : \u03b1) [Fintype (Icc a b)] : (Icc a b).toFinset = Finset.Icc a b := by\n  ext; simp", "start": [1499, 1], "end": [1500, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Ico", "code": "@[simp] lemma toFinset_Ico (a b : \u03b1) [Fintype (Ico a b)] : (Ico a b).toFinset = Finset.Ico a b := by\n  ext; simp", "start": [1502, 1], "end": [1503, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Ioc", "code": "@[simp] lemma toFinset_Ioc (a b : \u03b1) [Fintype (Ioc a b)] : (Ioc a b).toFinset = Finset.Ioc a b := by\n  ext; simp", "start": [1505, 1], "end": [1506, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Ioo", "code": "@[simp] lemma toFinset_Ioo (a b : \u03b1) [Fintype (Ioo a b)] : (Ioo a b).toFinset = Finset.Ioo a b := by\n  ext; simp", "start": [1508, 1], "end": [1509, 12], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Ici", "code": "@[simp]\nlemma toFinset_Ici (a : \u03b1) [Fintype (Ici a)] : (Ici a).toFinset = Finset.Ici a := by ext; simp", "start": [1516, 1], "end": [1517, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Ioi", "code": "@[simp]\nlemma toFinset_Ioi (a : \u03b1) [Fintype (Ioi a)] : (Ioi a).toFinset = Finset.Ioi a := by ext; simp", "start": [1519, 1], "end": [1520, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Iic", "code": "@[simp]\nlemma toFinset_Iic (a : \u03b1) [Fintype (Iic a)] : (Iic a).toFinset = Finset.Iic a := by ext; simp", "start": [1527, 1], "end": [1528, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Set.toFinset_Iio", "code": "@[simp]\nlemma toFinset_Iio (a : \u03b1) [Fintype (Iio a)] : (Iio a).toFinset = Finset.Iio a := by ext; simp", "start": [1530, 1], "end": [1531, 95], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Set/Intervals/Monoid.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/Data/Set/Intervals/Basic.lean"], "premises": [{"full_name": "Set.Ici_add_bij", "code": "theorem Ici_add_bij : BijOn (\u00b7 + d) (Ici a) (Ici (a + d))", "start": [28, 1], "end": [33, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Ioi_add_bij", "code": "theorem Ioi_add_bij : BijOn (\u00b7 + d) (Ioi a) (Ioi (a + d))", "start": [36, 1], "end": [42, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_add_bij", "code": "theorem Icc_add_bij : BijOn (\u00b7 + d) (Icc a b) (Icc (a + d) (b + d))", "start": [45, 1], "end": [49, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Ioo_add_bij", "code": "theorem Ioo_add_bij : BijOn (\u00b7 + d) (Ioo a b) (Ioo (a + d) (b + d))", "start": [52, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Ioc_add_bij", "code": "theorem Ioc_add_bij : BijOn (\u00b7 + d) (Ioc a b) (Ioc (a + d) (b + d))", "start": [59, 1], "end": [63, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Ico_add_bij", "code": "theorem Ico_add_bij : BijOn (\u00b7 + d) (Ico a b) (Ico (a + d) (b + d))", "start": [66, 1], "end": [70, 34], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Ici", "code": "@[simp]\ntheorem image_add_const_Ici : (fun x => x + a) '' Ici b = Ici (b + a)", "start": [78, 1], "end": [80, 29], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Ioi", "code": "@[simp]\ntheorem image_add_const_Ioi : (fun x => x + a) '' Ioi b = Ioi (b + a)", "start": [83, 1], "end": [85, 29], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Icc", "code": "@[simp]\ntheorem image_add_const_Icc : (fun x => x + a) '' Icc b c = Icc (b + a) (c + a)", "start": [88, 1], "end": [90, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Ico", "code": "@[simp]\ntheorem image_add_const_Ico : (fun x => x + a) '' Ico b c = Ico (b + a) (c + a)", "start": [93, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Ioc", "code": "@[simp]\ntheorem image_add_const_Ioc : (fun x => x + a) '' Ioc b c = Ioc (b + a) (c + a)", "start": [98, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Ioo", "code": "@[simp]\ntheorem image_add_const_Ioo : (fun x => x + a) '' Ioo b c = Ioo (b + a) (c + a)", "start": [103, 1], "end": [105, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Ici", "code": "@[simp]\ntheorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b)", "start": [113, 1], "end": [115, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Ioi", "code": "@[simp]\ntheorem image_const_add_Ioi : (fun x => a + x) '' Ioi b = Ioi (a + b)", "start": [118, 1], "end": [120, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Icc", "code": "@[simp]\ntheorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c)", "start": [123, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Ico", "code": "@[simp]\ntheorem image_const_add_Ico : (fun x => a + x) '' Ico b c = Ico (a + b) (a + c)", "start": [128, 1], "end": [130, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Ioc", "code": "@[simp]\ntheorem image_const_add_Ioc : (fun x => a + x) '' Ioc b c = Ioc (a + b) (a + c)", "start": [133, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Ioo", "code": "@[simp]\ntheorem image_const_add_Ioo : (fun x => a + x) '' Ioo b c = Ioo (a + b) (a + c)", "start": [138, 1], "end": [140, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subsemigroup/Center.lean", "imports": ["Mathlib/Algebra/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "Mathlib/Algebra/Group/Commute/Units.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "Mathlib/Algebra/Invertible/Basic.lean"], "premises": [{"full_name": "Set.center", "code": "@[to_additive addCenter \" The center of an additive magma. \"]\ndef center [Mul M] : Set M :=\n  { z | \u2200 m, m * z = z * m }", "start": [35, 1], "end": [38, 29], "kind": "commanddeclaration"}, {"full_name": "Set.mem_center_iff", "code": "@[to_additive mem_addCenter_iff]\ntheorem mem_center_iff [Mul M] {z : M} : z \u2208 center M \u2194 \u2200 g, g * z = z * g", "start": [43, 1], "end": [45, 10], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemCenter", "code": "instance decidableMemCenter [Mul M] [\u2200 a : M, Decidable <| \u2200 b : M, b * a = a * b] :\n    DecidablePred (\u00b7 \u2208 center M) := fun _ => decidable_of_iff' _ (mem_center_iff M)", "start": [49, 1], "end": [50, 84], "kind": "commanddeclaration"}, {"full_name": "Set.one_mem_center", "code": "@[to_additive (attr := simp) zero_mem_addCenter]\ntheorem one_mem_center [MulOneClass M] : (1 : M) \u2208 Set.center M", "start": [53, 1], "end": [54, 92], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mem_center", "code": "@[simp]\ntheorem zero_mem_center [MulZeroClass M] : (0 : M) \u2208 Set.center M", "start": [58, 1], "end": [59, 94], "kind": "commanddeclaration"}, {"full_name": "Set.natCast_mem_center", "code": "@[simp]\ntheorem natCast_mem_center [NonAssocSemiring M] (n : \u2115) : (n : M) \u2208 Set.center M", "start": [62, 1], "end": [64, 25], "kind": "commanddeclaration"}, {"full_name": "Set.ofNat_mem_center", "code": "@[simp]\ntheorem ofNat_mem_center [NonAssocSemiring M] (n : \u2115) [n.AtLeastTwo] :\n    OfNat.ofNat n \u2208 Set.center M", "start": [66, 1], "end": [69, 25], "kind": "commanddeclaration"}, {"full_name": "Set.intCast_mem_center", "code": "@[simp]\ntheorem intCast_mem_center [NonAssocRing M] (n : \u2124) : (n : M) \u2208 Set.center M", "start": [71, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "Set.mul_mem_center", "code": "@[to_additive (attr := simp) add_mem_addCenter]\ntheorem mul_mem_center [Semigroup M] {a b : M} (ha : a \u2208 Set.center M) (hb : b \u2208 Set.center M) :\n    a * b \u2208 Set.center M", "start": [77, 1], "end": [79, 93], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_center", "code": "@[to_additive (attr := simp) neg_mem_addCenter]\ntheorem inv_mem_center [Group M] {a : M} (ha : a \u2208 Set.center M) :\n    a\u207b\u00b9 \u2208 Set.center M", "start": [83, 1], "end": [86, 67], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_center", "code": "@[simp]\ntheorem add_mem_center [Distrib M] {a b : M} (ha : a \u2208 Set.center M) (hb : b \u2208 Set.center M) :\n    a + b \u2208 Set.center M", "start": [90, 1], "end": [92, 74], "kind": "commanddeclaration"}, {"full_name": "Set.neg_mem_center", "code": "@[simp]\ntheorem neg_mem_center [NonUnitalNonAssocRing M] {a : M} (ha : a \u2208 Set.center M) :\n    -a \u2208 Set.center M", "start": [95, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "Set.subset_center_units", "code": "@[to_additive subset_addCenter_add_units]\ntheorem subset_center_units [Monoid M] : ((\u2191) : M\u02e3 \u2192 M) \u207b\u00b9' center M \u2286 Set.center M\u02e3", "start": [101, 1], "end": [103, 34], "kind": "commanddeclaration"}, {"full_name": "Set.center_units_subset", "code": "theorem center_units_subset [GroupWithZero M] : Set.center M\u02e3 \u2286 ((\u2191) : M\u02e3 \u2192 M) \u207b\u00b9' center M", "start": [107, 1], "end": [111, 49], "kind": "commanddeclaration"}, {"full_name": "Set.center_units_eq", "code": "theorem center_units_eq [GroupWithZero M] : Set.center M\u02e3 = ((\u2191) : M\u02e3 \u2192 M) \u207b\u00b9' center M", "start": [114, 1], "end": [116, 58], "kind": "commanddeclaration"}, {"full_name": "Set.units_inv_mem_center", "code": "@[simp]\ntheorem units_inv_mem_center [Monoid M] {a : M\u02e3} (ha : \u2191a \u2208 Set.center M) :\n    \u2191a\u207b\u00b9 \u2208 Set.center M", "start": [119, 1], "end": [122, 36], "kind": "commanddeclaration"}, {"full_name": "Set.invOf_mem_center", "code": "@[simp]\ntheorem invOf_mem_center [Monoid M] {a : M} [Invertible a] (ha : a \u2208 Set.center M) :\n    \u215fa \u2208 Set.center M", "start": [124, 1], "end": [127, 32], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_center\u2080", "code": "@[simp]\ntheorem inv_mem_center\u2080 [GroupWithZero M] {a : M} (ha : a \u2208 Set.center M) : a\u207b\u00b9 \u2208 Set.center M", "start": [129, 1], "end": [135, 72], "kind": "commanddeclaration"}, {"full_name": "Set.div_mem_center", "code": "@[to_additive (attr := simp) sub_mem_addCenter]\ntheorem div_mem_center [Group M] {a b : M} (ha : a \u2208 Set.center M) (hb : b \u2208 Set.center M) :\n    a / b \u2208 Set.center M", "start": [138, 1], "end": [142, 46], "kind": "commanddeclaration"}, {"full_name": "Set.div_mem_center\u2080", "code": "@[simp]\ntheorem div_mem_center\u2080 [GroupWithZero M] {a b : M} (ha : a \u2208 Set.center M)\n    (hb : b \u2208 Set.center M) : a / b \u2208 Set.center M", "start": [146, 1], "end": [150, 47], "kind": "commanddeclaration"}, {"full_name": "Set.center_eq_univ", "code": "@[to_additive (attr := simp) addCenter_eq_univ]\ntheorem center_eq_univ [CommSemigroup M] : center M = Set.univ", "start": [155, 1], "end": [157, 62], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.center", "code": "@[to_additive\n      \"The center of a semigroup `M` is the set of elements that commute with everything in `M`\"]\ndef center : Subsemigroup M where\n  carrier := Set.center M\n  mul_mem' := Set.mul_mem_center", "start": [169, 1], "end": [174, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_center_iff", "code": "@[to_additive]\ntheorem mem_center_iff {z : M} : z \u2208 center M \u2194 \u2200 g, g * z = z * g", "start": [184, 1], "end": [186, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.decidableMemCenter", "code": "@[to_additive]\ninstance decidableMemCenter (a) [Decidable <| \u2200 b : M, b * a = a * b] : Decidable (a \u2208 center M) :=\n  decidable_of_iff' _ mem_center_iff", "start": [190, 1], "end": [192, 37], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.center.commSemigroup", "code": "@[to_additive \"The center of an additive semigroup is commutative.\"]\ninstance center.commSemigroup : CommSemigroup (center M) :=\n  { MulMemClass.toSemigroup (center M) with mul_comm := fun _ b => Subtype.ext <| b.2 _ }", "start": [196, 1], "end": [199, 90], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.center_eq_top", "code": "@[to_additive (attr := simp)]\ntheorem center_eq_top : center M = \u22a4", "start": [209, 1], "end": [211, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Operations.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Cancel/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subsemigroup/Operations.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean"], "premises": [{"full_name": "Submonoid.toAddSubmonoid", "code": "@[simps]\ndef Submonoid.toAddSubmonoid : Submonoid M \u2243o AddSubmonoid (Additive M) where\n  toFun S :=\n    { carrier := Additive.toMul \u207b\u00b9' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb }\n  invFun S :=\n    { carrier := Additive.ofMul \u207b\u00b9' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl", "start": [77, 1], "end": [90, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toSubmonoid'", "code": "abbrev AddSubmonoid.toSubmonoid' : AddSubmonoid (Additive M) \u2243o Submonoid M :=\n  Submonoid.toAddSubmonoid.symm", "start": [95, 1], "end": [97, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toAddSubmonoid_closure", "code": "theorem Submonoid.toAddSubmonoid_closure (S : Set M) :\n    Submonoid.toAddSubmonoid (Submonoid.closure S)\n      = AddSubmonoid.closure (Additive.toMul \u207b\u00b9' S)", "start": [100, 1], "end": [106, 69], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toSubmonoid'_closure", "code": "theorem AddSubmonoid.toSubmonoid'_closure (S : Set (Additive M)) :\n    AddSubmonoid.toSubmonoid' (AddSubmonoid.closure S)\n      = Submonoid.closure (Multiplicative.ofAdd \u207b\u00b9' S)", "start": [109, 1], "end": [115, 78], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toSubmonoid", "code": "@[simps]\ndef AddSubmonoid.toSubmonoid : AddSubmonoid A \u2243o Submonoid (Multiplicative A) where\n  toFun S :=\n    { carrier := Multiplicative.toAdd \u207b\u00b9' S\n      one_mem' := S.zero_mem'\n      mul_mem' := fun ha hb => S.add_mem' ha hb }\n  invFun S :=\n    { carrier := Multiplicative.ofAdd \u207b\u00b9' S\n      zero_mem' := S.one_mem'\n      add_mem' := fun ha hb => S.mul_mem' ha hb}\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl", "start": [124, 1], "end": [138, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toAddSubmonoid'", "code": "abbrev Submonoid.toAddSubmonoid' : Submonoid (Multiplicative A) \u2243o AddSubmonoid A :=\n  AddSubmonoid.toSubmonoid.symm", "start": [143, 1], "end": [145, 32], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toSubmonoid_closure", "code": "theorem AddSubmonoid.toSubmonoid_closure (S : Set A) :\n    (AddSubmonoid.toSubmonoid) (AddSubmonoid.closure S)\n      = Submonoid.closure (Multiplicative.toAdd \u207b\u00b9' S)", "start": [148, 1], "end": [154, 69], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toAddSubmonoid'_closure", "code": "theorem Submonoid.toAddSubmonoid'_closure (S : Set (Multiplicative A)) :\n    Submonoid.toAddSubmonoid' (Submonoid.closure S)\n      = AddSubmonoid.closure (Additive.ofMul \u207b\u00b9' S)", "start": [157, 1], "end": [163, 84], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap", "code": "@[to_additive\n      \"The preimage of an `AddSubmonoid` along an `AddMonoid` homomorphism is an `AddSubmonoid`.\"]\ndef comap (f : F) (S : Submonoid N) :\n    Submonoid M where\n  carrier := f \u207b\u00b9' S\n  one_mem' := show f 1 \u2208 S by rw [map_one]; exact S.one_mem\n  mul_mem' ha hb := show f (_ * _) \u2208 S by rw [map_mul]; exact S.mul_mem ha hb", "start": [178, 1], "end": [185, 78], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_comap", "code": "@[to_additive (attr := simp)]\ntheorem coe_comap (S : Submonoid N) (f : F) : (S.comap f : Set M) = f \u207b\u00b9' S", "start": [189, 1], "end": [191, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_comap", "code": "@[to_additive (attr := simp)]\ntheorem mem_comap {S : Submonoid N} {f : F} {x : M} : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [195, 1], "end": [197, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_comap", "code": "@[to_additive]\ntheorem comap_comap (S : Submonoid P) (g : N \u2192* P) (f : M \u2192* N) :\n    (S.comap g).comap f = S.comap (g.comp f)", "start": [201, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_id", "code": "@[to_additive (attr := simp)]\ntheorem comap_id (S : Submonoid P) : S.comap (MonoidHom.id P) = S", "start": [208, 1], "end": [210, 16], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map", "code": "@[to_additive\n      \"The image of an `AddSubmonoid` along an `AddMonoid` homomorphism is an `AddSubmonoid`.\"]\ndef map (f : F) (S : Submonoid M) :\n    Submonoid N where\n  carrier := f '' S\n  one_mem' := \u27e81, S.one_mem, map_one f\u27e9\n  mul_mem' := by\n    rintro _ _ \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9;\n    exact \u27e8x * y, S.mul_mem hx hy, by rw [map_mul]\u27e9", "start": [214, 1], "end": [223, 52], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_map", "code": "@[to_additive (attr := simp)]\ntheorem coe_map (f : F) (S : Submonoid M) : (S.map f : Set N) = f '' S", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_map", "code": "@[to_additive (attr := simp)]\ntheorem mem_map {f : F} {S : Submonoid M} {y : N} : y \u2208 S.map f \u2194 \u2203 x \u2208 S, f x = y", "start": [233, 1], "end": [236, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_map_of_mem", "code": "@[to_additive]\ntheorem mem_map_of_mem (f : F) {S : Submonoid M} {x : M} (hx : x \u2208 S) : f x \u2208 S.map f", "start": [240, 1], "end": [242, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.apply_coe_mem_map", "code": "@[to_additive]\ntheorem apply_coe_mem_map (f : F) (S : Submonoid M) (x : S) : f x \u2208 S.map f", "start": [246, 1], "end": [248, 23], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_map", "code": "@[to_additive]\ntheorem map_map (g : N \u2192* P) (f : M \u2192* N) : (S.map f).map g = S.map (g.comp f)", "start": [252, 1], "end": [254, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_map_iff_mem", "code": "@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : F} (hf : Function.Injective f) {S : Submonoid M} {x : M} :\n    f x \u2208 S.map f \u2194 x \u2208 S", "start": [261, 1], "end": [264, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_le_iff_le_comap", "code": "@[to_additive]\ntheorem map_le_iff_le_comap {f : F} {S : Submonoid M} {T : Submonoid N} :\n    S.map f \u2264 T \u2194 S \u2264 T.comap f", "start": [268, 1], "end": [271, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.gc_map_comap", "code": "@[to_additive]\ntheorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f)", "start": [275, 1], "end": [276, 100], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_le_of_le_comap", "code": "@[to_additive]\ntheorem map_le_of_le_comap {T : Submonoid N} {f : F} : S \u2264 T.comap f \u2192 S.map f \u2264 T", "start": [280, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.le_comap_of_map_le", "code": "@[to_additive]\ntheorem le_comap_of_map_le {T : Submonoid N} {f : F} : S.map f \u2264 T \u2192 S \u2264 T.comap f", "start": [286, 1], "end": [288, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.le_comap_map", "code": "@[to_additive]\ntheorem le_comap_map {f : F} : S \u2264 (S.map f).comap f", "start": [292, 1], "end": [294, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_comap_le", "code": "@[to_additive]\ntheorem map_comap_le {S : Submonoid N} {f : F} : (S.comap f).map f \u2264 S", "start": [298, 1], "end": [300, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.monotone_map", "code": "@[to_additive]\ntheorem monotone_map {f : F} : Monotone (map f)", "start": [304, 1], "end": [306, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.monotone_comap", "code": "@[to_additive]\ntheorem monotone_comap {f : F} : Monotone (comap f)", "start": [310, 1], "end": [312, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_comap_map", "code": "@[to_additive (attr := simp)]\ntheorem map_comap_map {f : F} : ((S.map f).comap f).map f = S.map f", "start": [316, 1], "end": [318, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_map_comap", "code": "@[to_additive (attr := simp)]\ntheorem comap_map_comap {S : Submonoid N} {f : F} : ((S.comap f).map f).comap f = S.comap f", "start": [322, 1], "end": [324, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_sup", "code": "@[to_additive]\ntheorem map_sup (S T : Submonoid M) (f : F) : (S \u2294 T).map f = S.map f \u2294 T.map f", "start": [328, 1], "end": [330, 62], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_iSup", "code": "@[to_additive]\ntheorem map_iSup {\u03b9 : Sort*} (f : F) (s : \u03b9 \u2192 Submonoid M) : (iSup s).map f = \u2a06 i, (s i).map f", "start": [334, 1], "end": [336, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_inf", "code": "@[to_additive]\ntheorem comap_inf (S T : Submonoid N) (f : F) : (S \u2293 T).comap f = S.comap f \u2293 T.comap f", "start": [340, 1], "end": [342, 62], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_iInf", "code": "@[to_additive]\ntheorem comap_iInf {\u03b9 : Sort*} (f : F) (s : \u03b9 \u2192 Submonoid N) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [346, 1], "end": [349, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_bot", "code": "@[to_additive (attr := simp)]\ntheorem map_bot (f : F) : (\u22a5 : Submonoid M).map f = \u22a5", "start": [353, 1], "end": [355, 25], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_top", "code": "@[to_additive (attr := simp)]\ntheorem comap_top (f : F) : (\u22a4 : Submonoid N).comap f = \u22a4", "start": [359, 1], "end": [361, 25], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id (S : Submonoid M) : S.map (MonoidHom.id M) = S", "start": [365, 1], "end": [367, 60], "kind": "commanddeclaration"}, {"full_name": "Submonoid.gciMapComap", "code": "@[to_additive \" `map f` and `comap f` form a `GaloisCoinsertion` when `f` is injective. \"]\ndef gciMapComap : GaloisCoinsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisCoinsertion fun S x => by simp [mem_comap, mem_map, hf.eq_iff]", "start": [375, 1], "end": [378, 90], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_map_eq_of_injective", "code": "@[to_additive]\ntheorem comap_map_eq_of_injective (S : Submonoid M) : (S.map f).comap f = S", "start": [382, 1], "end": [384, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_surjective_of_injective", "code": "@[to_additive]\ntheorem comap_surjective_of_injective : Function.Surjective (comap f)", "start": [388, 1], "end": [390, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_injective_of_injective", "code": "@[to_additive]\ntheorem map_injective_of_injective : Function.Injective (map f)", "start": [394, 1], "end": [396, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_inf_map_of_injective", "code": "@[to_additive]\ntheorem comap_inf_map_of_injective (S T : Submonoid M) : (S.map f \u2293 T.map f).comap f = S \u2293 T", "start": [400, 1], "end": [402, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_iInf_map_of_injective", "code": "@[to_additive]\ntheorem comap_iInf_map_of_injective (S : \u03b9 \u2192 Submonoid M) : (\u2a05 i, (S i).map f).comap f = iInf S", "start": [406, 1], "end": [408, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_sup_map_of_injective", "code": "@[to_additive]\ntheorem comap_sup_map_of_injective (S T : Submonoid M) : (S.map f \u2294 T.map f).comap f = S \u2294 T", "start": [412, 1], "end": [414, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_iSup_map_of_injective", "code": "@[to_additive]\ntheorem comap_iSup_map_of_injective (S : \u03b9 \u2192 Submonoid M) : (\u2a06 i, (S i).map f).comap f = iSup S", "start": [418, 1], "end": [420, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_le_map_iff_of_injective", "code": "@[to_additive]\ntheorem map_le_map_iff_of_injective {S T : Submonoid M} : S.map f \u2264 T.map f \u2194 S \u2264 T", "start": [424, 1], "end": [426, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_strictMono_of_injective", "code": "@[to_additive]\ntheorem map_strictMono_of_injective : StrictMono (map f)", "start": [430, 1], "end": [432, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.giMapComap", "code": "@[to_additive \" `map f` and `comap f` form a `GaloisInsertion` when `f` is surjective. \"]\ndef giMapComap : GaloisInsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisInsertion fun S x h =>\n    let \u27e8y, hy\u27e9 := hf x\n    mem_map.2 \u27e8y, by simp [hy, h]\u27e9", "start": [442, 1], "end": [447, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_comap_eq_of_surjective", "code": "@[to_additive]\ntheorem map_comap_eq_of_surjective (S : Submonoid N) : (S.comap f).map f = S", "start": [451, 1], "end": [453, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_surjective_of_surjective", "code": "@[to_additive]\ntheorem map_surjective_of_surjective : Function.Surjective (map f)", "start": [457, 1], "end": [459, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_injective_of_surjective", "code": "@[to_additive]\ntheorem comap_injective_of_surjective : Function.Injective (comap f)", "start": [463, 1], "end": [465, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_inf_comap_of_surjective", "code": "@[to_additive]\ntheorem map_inf_comap_of_surjective (S T : Submonoid N) : (S.comap f \u2293 T.comap f).map f = S \u2293 T", "start": [469, 1], "end": [471, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_iInf_comap_of_surjective", "code": "@[to_additive]\ntheorem map_iInf_comap_of_surjective (S : \u03b9 \u2192 Submonoid N) : (\u2a05 i, (S i).comap f).map f = iInf S", "start": [475, 1], "end": [477, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_sup_comap_of_surjective", "code": "@[to_additive]\ntheorem map_sup_comap_of_surjective (S T : Submonoid N) : (S.comap f \u2294 T.comap f).map f = S \u2294 T", "start": [481, 1], "end": [483, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_iSup_comap_of_surjective", "code": "@[to_additive]\ntheorem map_iSup_comap_of_surjective (S : \u03b9 \u2192 Submonoid N) : (\u2a06 i, (S i).comap f).map f = iSup S", "start": [487, 1], "end": [489, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_le_comap_iff_of_surjective", "code": "@[to_additive]\ntheorem comap_le_comap_iff_of_surjective {S T : Submonoid N} : S.comap f \u2264 T.comap f \u2194 S \u2264 T", "start": [493, 1], "end": [495, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_strictMono_of_surjective", "code": "@[to_additive]\ntheorem comap_strictMono_of_surjective : StrictMono (comap f)", "start": [499, 1], "end": [501, 31], "kind": "commanddeclaration"}, {"full_name": "OneMemClass.one", "code": "@[to_additive \"An `AddSubmonoid` of an `AddMonoid` inherits a zero.\"]\ninstance one : One S' :=\n  \u27e8\u27e81, OneMemClass.one_mem S'\u27e9\u27e9", "start": [513, 1], "end": [516, 32], "kind": "commanddeclaration"}, {"full_name": "OneMemClass.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S') : M\u2081) = 1", "start": [520, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "OneMemClass.coe_eq_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_eq_one {x : S'} : (\u2191x : M\u2081) = 1 \u2194 x = 1", "start": [528, 1], "end": [530, 55], "kind": "commanddeclaration"}, {"full_name": "OneMemClass.one_def", "code": "@[to_additive]\ntheorem one_def : (1 : S') = \u27e81, OneMemClass.one_mem S'\u27e9", "start": [536, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoidClass.nSMul", "code": "instance AddSubmonoidClass.nSMul {M} [AddMonoid M] {A : Type*} [SetLike A M]\n    [AddSubmonoidClass A M] (S : A) : SMul \u2115 S :=\n  \u27e8fun n a => \u27e8n \u2022 a.1, nsmul_mem a.2 n\u27e9\u27e9", "start": [546, 1], "end": [549, 42], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.nPow", "code": "instance nPow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] (S : A) : Pow S \u2115 :=\n  \u27e8fun a n => \u27e8a.1 ^ n, pow_mem a.2 n\u27e9\u27e9", "start": [554, 1], "end": [556, 40], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.coe_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : S)\n    (n : \u2115) : (x ^ n : M) = (x : M) ^ n", "start": [561, 1], "end": [564, 6], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.mk_pow", "code": "@[to_additive (attr := simp)]\ntheorem mk_pow {M} [Monoid M] {A : Type*} [SetLike A M] [SubmonoidClass A M] {S : A} (x : M)\n    (hx : x \u2208 S) (n : \u2115) : (\u27e8x, hx\u27e9 : S) ^ n = \u27e8x ^ n, pow_mem hx n\u27e9", "start": [568, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toMulOneClass", "code": "@[to_additive\n      \"An `AddSubmonoid` of a unital additive magma inherits a unital additive magma structure.\"]\ninstance (priority := 75) toMulOneClass {M : Type*} [MulOneClass M] {A : Type*} [SetLike A M]\n    [SubmonoidClass A M] (S : A) : MulOneClass S :=\n    Subtype.coe_injective.mulOneClass (\u2191) rfl (fun _ _ => rfl)", "start": [576, 1], "end": [581, 63], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `AddMonoid` inherits an `AddMonoid` structure.\"]\ninstance (priority := 75) toMonoid {M : Type*} [Monoid M] {A : Type*} [SetLike A M]\n    [SubmonoidClass A M] (S : A) : Monoid S :=\n  Subtype.coe_injective.monoid (\u2191) rfl (fun _ _ => rfl) (fun _ _ => rfl)", "start": [586, 1], "end": [590, 73], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toCommMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `AddCommMonoid` is an `AddCommMonoid`.\"]\ninstance (priority := 75) toCommMonoid {M} [CommMonoid M] {A : Type*} [SetLike A M]\n    [SubmonoidClass A M] (S : A) : CommMonoid S :=\n  Subtype.coe_injective.commMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [595, 1], "end": [599, 75], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toOrderedCommMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `OrderedAddCommMonoid` is an `OrderedAddCommMonoid`.\"]\ninstance (priority := 75) toOrderedCommMonoid {M} [OrderedCommMonoid M] {A : Type*} [SetLike A M]\n    [SubmonoidClass A M] (S : A) : OrderedCommMonoid S :=\n  Subtype.coe_injective.orderedCommMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [604, 1], "end": [608, 82], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toLinearOrderedCommMonoid", "code": "@[to_additive\n      \"An `AddSubmonoid` of a `LinearOrderedAddCommMonoid` is a `LinearOrderedAddCommMonoid`.\"]\ninstance (priority := 75) toLinearOrderedCommMonoid {M} [LinearOrderedCommMonoid M] {A : Type*}\n    [SetLike A M] [SubmonoidClass A M] (S : A) : LinearOrderedCommMonoid S :=\n  Subtype.coe_injective.linearOrderedCommMonoid (\u2191) rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [613, 1], "end": [619, 36], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toOrderedCancelCommMonoid", "code": "@[to_additive AddSubmonoidClass.toOrderedCancelAddCommMonoid\n      \"An `AddSubmonoid` of an `OrderedCancelAddCommMonoid` is an `OrderedCancelAddCommMonoid`.\"]\ninstance (priority := 75) toOrderedCancelCommMonoid {M} [OrderedCancelCommMonoid M] {A : Type*}\n    [SetLike A M] [SubmonoidClass A M] (S : A) : OrderedCancelCommMonoid S :=\n  Subtype.coe_injective.orderedCancelCommMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [624, 1], "end": [629, 88], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.toLinearOrderedCancelCommMonoid", "code": "@[to_additive AddSubmonoidClass.toLinearOrderedCancelAddCommMonoid\n      \"An `AddSubmonoid` of a `LinearOrderedCancelAddCommMonoid` is\n      a `LinearOrderedCancelAddCommMonoid`.\"]\ninstance (priority := 75) toLinearOrderedCancelCommMonoid {M} [LinearOrderedCancelCommMonoid M]\n    {A : Type*} [SetLike A M] [SubmonoidClass A M] (S : A) : LinearOrderedCancelCommMonoid S :=\n  Subtype.coe_injective.linearOrderedCancelCommMonoid (\u2191) rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [634, 1], "end": [642, 36], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.subtype", "code": "@[to_additive \"The natural monoid hom from an `AddSubmonoid` of `AddMonoid` `M` to `M`.\"]\ndef subtype : S' \u2192* M where\n  toFun := Subtype.val; map_one' := rfl; map_mul' _ _ := by simp", "start": [646, 1], "end": [649, 65], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.coe_subtype", "code": "@[to_additive (attr := simp)]\ntheorem coe_subtype : (SubmonoidClass.subtype S' : S' \u2192 M) = Subtype.val", "start": [653, 1], "end": [655, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mul", "code": "@[to_additive \"An `AddSubmonoid` of an `AddMonoid` inherits an addition.\"]\ninstance mul : Mul S :=\n  \u27e8fun a b => \u27e8a.1 * b.1, S.mul_mem a.2 b.2\u27e9\u27e9", "start": [663, 1], "end": [666, 46], "kind": "commanddeclaration"}, {"full_name": "Submonoid.one", "code": "@[to_additive \"An `AddSubmonoid` of an `AddMonoid` inherits a zero.\"]\ninstance one : One S :=\n  \u27e8\u27e8_, S.one_mem\u27e9\u27e9", "start": [670, 1], "end": [673, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : S) : (\u2191(x * y) : M) = \u2191x * \u2191y", "start": [677, 1], "end": [679, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : S) : M) = 1", "start": [683, 1], "end": [685, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mk_mul_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul_mk (x y : M) (hx : x \u2208 S) (hy : y \u2208 S) :\n    (\u27e8x, hx\u27e9 : S) * \u27e8y, hy\u27e9 = \u27e8x * y, S.mul_mem hx hy\u27e9", "start": [689, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mul_def", "code": "@[to_additive]\ntheorem mul_def (x y : S) : x * y = \u27e8x * y, S.mul_mem x.2 y.2\u27e9", "start": [696, 1], "end": [698, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.one_def", "code": "@[to_additive]\ntheorem one_def : (1 : S) = \u27e81, S.one_mem\u27e9", "start": [702, 1], "end": [704, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toMulOneClass", "code": "@[to_additive\n      \"An `AddSubmonoid` of a unital additive magma inherits a unital additive magma structure.\"]\ninstance toMulOneClass {M : Type*} [MulOneClass M] (S : Submonoid M) : MulOneClass S :=\n  Subtype.coe_injective.mulOneClass (\u2191) rfl fun _ _ => rfl", "start": [708, 1], "end": [712, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow_mem", "code": "@[to_additive]\nprotected theorem pow_mem {M : Type*} [Monoid M] (S : Submonoid M) {x : M} (hx : x \u2208 S) (n : \u2115) :\n    x ^ n \u2208 S", "start": [716, 1], "end": [719, 15], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `AddMonoid` inherits an `AddMonoid` structure.\"]\ninstance toMonoid {M : Type*} [Monoid M] (S : Submonoid M) : Monoid S :=\n  Subtype.coe_injective.monoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [727, 1], "end": [730, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toCommMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `AddCommMonoid` is an `AddCommMonoid`.\"]\ninstance toCommMonoid {M} [CommMonoid M] (S : Submonoid M) : CommMonoid S :=\n  Subtype.coe_injective.commMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [734, 1], "end": [737, 75], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toOrderedCommMonoid", "code": "@[to_additive \"An `AddSubmonoid` of an `OrderedAddCommMonoid` is an `OrderedAddCommMonoid`.\"]\ninstance toOrderedCommMonoid {M} [OrderedCommMonoid M] (S : Submonoid M) : OrderedCommMonoid S :=\n  Subtype.coe_injective.orderedCommMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [741, 1], "end": [744, 82], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toLinearOrderedCommMonoid", "code": "@[to_additive\n      \"An `AddSubmonoid` of a `LinearOrderedAddCommMonoid` is a `LinearOrderedAddCommMonoid`.\"]\ninstance toLinearOrderedCommMonoid {M} [LinearOrderedCommMonoid M] (S : Submonoid M) :\n    LinearOrderedCommMonoid S :=\n  Subtype.coe_injective.linearOrderedCommMonoid (\u2191) rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [748, 1], "end": [754, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toOrderedCancelCommMonoid", "code": "@[to_additive AddSubmonoid.toOrderedCancelAddCommMonoid\n      \"An `AddSubmonoid` of an `OrderedCancelAddCommMonoid` is an `OrderedCancelAddCommMonoid`.\"]\ninstance toOrderedCancelCommMonoid {M} [OrderedCancelCommMonoid M] (S : Submonoid M) :\n    OrderedCancelCommMonoid S :=\n  Subtype.coe_injective.orderedCancelCommMonoid (\u2191) rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [758, 1], "end": [763, 88], "kind": "commanddeclaration"}, {"full_name": "Submonoid.toLinearOrderedCancelCommMonoid", "code": "@[to_additive AddSubmonoid.toLinearOrderedCancelAddCommMonoid\n      \"An `AddSubmonoid` of a `LinearOrderedCancelAddCommMonoid` is\n      a `LinearOrderedCancelAddCommMonoid`.\"]\ninstance toLinearOrderedCancelCommMonoid {M} [LinearOrderedCancelCommMonoid M] (S : Submonoid M) :\n    LinearOrderedCancelCommMonoid S :=\n  Subtype.coe_injective.linearOrderedCancelCommMonoid (\u2191) rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [767, 1], "end": [775, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subtype", "code": "@[to_additive \"The natural monoid hom from an `AddSubmonoid` of `AddMonoid` `M` to `M`.\"]\ndef subtype : S \u2192* M where\n  toFun := Subtype.val; map_one' := rfl; map_mul' _ _ := by simp", "start": [779, 1], "end": [782, 65], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_subtype", "code": "@[to_additive (attr := simp)]\ntheorem coe_subtype : \u21d1S.subtype = Subtype.val", "start": [786, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.topEquiv", "code": "@[to_additive (attr := simps) \"The top additive submonoid is isomorphic to the additive monoid.\"]\ndef topEquiv : (\u22a4 : Submonoid M) \u2243* M where\n  toFun x := x\n  invFun x := \u27e8x, mem_top x\u27e9\n  left_inv x := x.eta _\n  right_inv _ := rfl\n  map_mul' _ _ := rfl", "start": [792, 1], "end": [799, 22], "kind": "commanddeclaration"}, {"full_name": "Submonoid.topEquiv_toMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem topEquiv_toMonoidHom : (topEquiv : _ \u2243* M).toMonoidHom = (\u22a4 : Submonoid M).subtype", "start": [805, 1], "end": [807, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.equivMapOfInjective", "code": "@[to_additive \"An additive subgroup is isomorphic to its image under an injective function. If you\nhave an isomorphism, use `AddEquiv.addSubmonoidMap` for better definitional equalities.\"]\nnoncomputable def equivMapOfInjective (f : M \u2192* N) (hf : Function.Injective f) : S \u2243* S.map f :=\n  { Equiv.Set.image f S hf with map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _) }", "start": [811, 1], "end": [816, 85], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_equivMapOfInjective_apply", "code": "@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (f : M \u2192* N) (hf : Function.Injective f) (x : S) :\n    (equivMapOfInjective S f hf x : N) = f x", "start": [820, 1], "end": [823, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_closure_coe_preimage", "code": "@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {s : Set M} : closure (((\u2191) : closure s \u2192 M) \u207b\u00b9' s) = \u22a4", "start": [827, 1], "end": [833, 34], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod", "code": "@[to_additive prod\n      \"Given `AddSubmonoid`s `s`, `t` of `AddMonoid`s `A`, `B` respectively, `s \u00d7 t`\n      as an `AddSubmonoid` of `A \u00d7 B`.\"]\ndef prod (s : Submonoid M) (t : Submonoid N) :\n    Submonoid (M \u00d7 N) where\n  carrier := s \u00d7\u02e2 t\n  one_mem' := \u27e8s.one_mem, t.one_mem\u27e9\n  mul_mem' hp hq := \u27e8s.mul_mem hp.1 hq.1, t.mul_mem hp.2 hq.2\u27e9", "start": [837, 1], "end": [846, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_prod", "code": "@[to_additive coe_prod]\ntheorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n    (s.prod t : Set (M \u00d7 N)) = (s : Set M) \u00d7\u02e2 (t : Set N)", "start": [850, 1], "end": [853, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_prod", "code": "@[to_additive mem_prod]\ntheorem mem_prod {s : Submonoid M} {t : Submonoid N} {p : M \u00d7 N} :\n    p \u2208 s.prod t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [857, 1], "end": [860, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_mono", "code": "@[to_additive prod_mono]\ntheorem prod_mono {s\u2081 s\u2082 : Submonoid M} {t\u2081 t\u2082 : Submonoid N} (hs : s\u2081 \u2264 s\u2082) (ht : t\u2081 \u2264 t\u2082) :\n    s\u2081.prod t\u2081 \u2264 s\u2082.prod t\u2082", "start": [864, 1], "end": [867, 22], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_top", "code": "@[to_additive prod_top]\ntheorem prod_top (s : Submonoid M) : s.prod (\u22a4 : Submonoid N) = s.comap (MonoidHom.fst M N)", "start": [871, 1], "end": [873, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.top_prod", "code": "@[to_additive top_prod]\ntheorem top_prod (s : Submonoid N) : (\u22a4 : Submonoid M).prod s = s.comap (MonoidHom.snd M N)", "start": [877, 1], "end": [879, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.top_prod_top", "code": "@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (\u22a4 : Submonoid M).prod (\u22a4 : Submonoid N) = \u22a4", "start": [883, 1], "end": [885, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.bot_prod_bot", "code": "@[to_additive bot_prod_bot]\ntheorem bot_prod_bot : (\u22a5 : Submonoid M).prod (\u22a5 : Submonoid N) = \u22a5", "start": [889, 1], "end": [891, 62], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prodEquiv", "code": "@[to_additive prodEquiv\n      \"The product of additive submonoids is isomorphic to their product as additive monoids\"]\ndef prodEquiv (s : Submonoid M) (t : Submonoid N) : s.prod t \u2243* s \u00d7 t :=\n  { (Equiv.Set.prod (s : Set M) (t : Set N)) with\n    map_mul' := fun _ _ => rfl }", "start": [896, 1], "end": [901, 33], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_inl", "code": "@[to_additive]\ntheorem map_inl (s : Submonoid M) : s.map (inl M N) = s.prod \u22a5", "start": [907, 1], "end": [911, 70], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_inr", "code": "@[to_additive]\ntheorem map_inr (s : Submonoid N) : s.map (inr M N) = prod \u22a5 s", "start": [915, 1], "end": [919, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_bot_sup_bot_prod", "code": "@[to_additive (attr := simp) prod_bot_sup_bot_prod]\ntheorem prod_bot_sup_bot_prod (s : Submonoid M) (t : Submonoid N) :\n    (prod s \u22a5) \u2294 (prod \u22a5 t) = prod s t", "start": [923, 1], "end": [929, 86], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_map_equiv", "code": "@[to_additive]\ntheorem mem_map_equiv {f : M \u2243* N} {K : Submonoid M} {x : N} :\n    x \u2208 K.map f.toMonoidHom \u2194 f.symm x \u2208 K", "start": [933, 1], "end": [936, 22], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_equiv_eq_comap_symm", "code": "@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : M \u2243* N) (K : Submonoid M) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom", "start": [940, 1], "end": [943, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.comap_equiv_eq_map_symm", "code": "@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N \u2243* M) (K : Submonoid M) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom", "start": [947, 1], "end": [950, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_equiv_top", "code": "@[to_additive (attr := simp)]\ntheorem map_equiv_top (f : M \u2243* N) : (\u22a4 : Submonoid M).map f.toMonoidHom = \u22a4", "start": [954, 1], "end": [956, 70], "kind": "commanddeclaration"}, {"full_name": "Submonoid.le_prod_iff", "code": "@[to_additive le_prod_iff]\ntheorem le_prod_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M \u00d7 N)} :\n    u \u2264 s.prod t \u2194 u.map (fst M N) \u2264 s \u2227 u.map (snd M N) \u2264 t", "start": [960, 1], "end": [971, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_le_iff", "code": "@[to_additive prod_le_iff]\ntheorem prod_le_iff {s : Submonoid M} {t : Submonoid N} {u : Submonoid (M \u00d7 N)} :\n    s.prod t \u2264 u \u2194 s.map (inl M N) \u2264 u \u2227 t.map (inr M N) \u2264 u", "start": [975, 1], "end": [994, 44], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrange", "code": "@[to_additive \"The range of an `AddMonoidHom` is an `AddSubmonoid`.\"]\ndef mrange (f : F) : Submonoid N :=\n  ((\u22a4 : Submonoid M).map f).copy (Set.range f) Set.image_univ.symm", "start": [1037, 1], "end": [1040, 67], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_mrange", "code": "@[to_additive (attr := simp)]\ntheorem coe_mrange (f : F) : (mrange f : Set N) = Set.range f", "start": [1044, 1], "end": [1046, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mem_mrange", "code": "@[to_additive (attr := simp)]\ntheorem mem_mrange {f : F} {y : N} : y \u2208 mrange f \u2194 \u2203 x, f x = y", "start": [1050, 1], "end": [1052, 10], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrange_eq_map", "code": "@[to_additive]\ntheorem mrange_eq_map (f : F) : mrange f = (\u22a4 : Submonoid M).map f", "start": [1056, 1], "end": [1058, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mrange", "code": "@[to_additive]\ntheorem map_mrange (g : N \u2192* P) (f : M \u2192* N) : f.mrange.map g = mrange (comp g f)", "start": [1062, 1], "end": [1064, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrange_top_iff_surjective", "code": "@[to_additive]\ntheorem mrange_top_iff_surjective {f : F} : mrange f = (\u22a4 : Submonoid N) \u2194 Function.Surjective f", "start": [1068, 1], "end": [1070, 93], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrange_top_of_surjective", "code": "@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` hom is the whole of the codomain.\"]\ntheorem mrange_top_of_surjective (f : F) (hf : Function.Surjective f) :\n    mrange f = (\u22a4 : Submonoid N)", "start": [1074, 1], "end": [1079, 33], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mclosure_preimage_le", "code": "@[to_additive]\ntheorem mclosure_preimage_le (f : F) (s : Set N) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [1083, 1], "end": [1085, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mclosure", "code": "@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubmonoid` generated by a set equals\n      the `AddSubmonoid` generated by the image of the set.\"]\ntheorem map_mclosure (f : F) (s : Set M) : (closure s).map f = closure (f '' s)", "start": [1089, 1], "end": [1098, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.restrict", "code": "@[to_additive \"Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the domain.\"]\ndef restrict {N S : Type*} [MulOneClass N] [SetLike S M] [SubmonoidClass S M] (f : M \u2192* N)\n    (s : S) : s \u2192* N :=\n  f.comp (SubmonoidClass.subtype _)", "start": [1102, 1], "end": [1106, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.restrict_apply", "code": "@[to_additive (attr := simp)]\ntheorem restrict_apply {N S : Type*} [MulOneClass N] [SetLike S M] [SubmonoidClass S M]\n    (f : M \u2192* N) (s : S) (x : s) : f.restrict s x = f x", "start": [1110, 1], "end": [1113, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.restrict_mrange", "code": "@[to_additive (attr := simp)]\ntheorem restrict_mrange (f : M \u2192* N) : mrange (f.restrict S) = S.map f", "start": [1117, 1], "end": [1119, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.codRestrict", "code": "@[to_additive (attr := simps apply)\n  \"Restriction of an `AddMonoid` hom to an `AddSubmonoid` of the codomain.\"]\ndef codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : M \u2192* N) (s : S) (h : \u2200 x, f x \u2208 s) :\n    M \u2192* s where\n  toFun n := \u27e8f n, h n\u27e9\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)", "start": [1123, 1], "end": [1130, 45], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrangeRestrict", "code": "@[to_additive \"Restriction of an `AddMonoid` hom to its range interpreted as a submonoid.\"]\ndef mrangeRestrict {N} [MulOneClass N] (f : M \u2192* N) : M \u2192* (mrange f) :=\n  (f.codRestrict (mrange f)) fun x => \u27e8x, rfl\u27e9", "start": [1135, 1], "end": [1138, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_mrangeRestrict", "code": "@[to_additive (attr := simp)]\ntheorem coe_mrangeRestrict {N} [MulOneClass N] (f : M \u2192* N) (x : M) :\n    (f.mrangeRestrict x : N) = f x", "start": [1142, 1], "end": [1145, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrangeRestrict_surjective", "code": "@[to_additive]\ntheorem mrangeRestrict_surjective (f : M \u2192* N) : Function.Surjective f.mrangeRestrict", "start": [1149, 1], "end": [1151, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker", "code": "@[to_additive\n      \"The additive kernel of an `AddMonoid` hom is the `AddSubmonoid` of\n      elements such that `f x = 0`\"]\ndef mker (f : F) : Submonoid M :=\n  (\u22a5 : Submonoid N).comap f", "start": [1155, 1], "end": [1161, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mem_mker", "code": "@[to_additive]\ntheorem mem_mker (f : F) {x : M} : x \u2208 mker f \u2194 f x = 1", "start": [1165, 1], "end": [1167, 10], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_mker", "code": "@[to_additive]\ntheorem coe_mker (f : F) : (mker f : Set M) = (f : M \u2192 N) \u207b\u00b9' {1}", "start": [1171, 1], "end": [1173, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.decidableMemMker", "code": "@[to_additive]\ninstance decidableMemMker [DecidableEq N] (f : F) : DecidablePred (\u00b7 \u2208 mker f) := fun x =>\n  decidable_of_iff (f x = 1) (mem_mker f)", "start": [1177, 1], "end": [1179, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comap_mker", "code": "@[to_additive]\ntheorem comap_mker (g : N \u2192* P) (f : M \u2192* N) : g.mker.comap f = mker (comp g f)", "start": [1183, 1], "end": [1185, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comap_bot'", "code": "@[to_additive (attr := simp)]\ntheorem comap_bot' (f : F) : (\u22a5 : Submonoid N).comap f = mker f", "start": [1189, 1], "end": [1191, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.restrict_mker", "code": "@[to_additive (attr := simp)]\ntheorem restrict_mker (f : M \u2192* N) : mker (f.restrict S) = f.mker.comap S.subtype", "start": [1195, 1], "end": [1197, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mrangeRestrict_mker", "code": "@[to_additive]\ntheorem mrangeRestrict_mker (f : M \u2192* N) : mker (mrangeRestrict f) = mker f", "start": [1201, 1], "end": [1205, 7], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker_one", "code": "@[to_additive (attr := simp)]\ntheorem mker_one : mker (1 : M \u2192* N) = \u22a4", "start": [1209, 1], "end": [1212, 18], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prod_map_comap_prod'", "code": "@[to_additive prod_map_comap_prod']\ntheorem prod_map_comap_prod' {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N']\n    (f : M \u2192* N) (g : M' \u2192* N') (S : Submonoid N) (S' : Submonoid N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g)", "start": [1216, 1], "end": [1220, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker_prod_map", "code": "@[to_additive mker_prod_map]\ntheorem mker_prod_map {M' : Type*} {N' : Type*} [MulOneClass M'] [MulOneClass N'] (f : M \u2192* N)\n    (g : M' \u2192* N') : mker (prodMap f g) = f.mker.prod (mker g)", "start": [1225, 1], "end": [1228, 86], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker_inl", "code": "@[to_additive (attr := simp)]\ntheorem mker_inl : mker (inl M N) = \u22a5", "start": [1233, 1], "end": [1236, 18], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker_inr", "code": "@[to_additive (attr := simp)]\ntheorem mker_inr : mker (inr M N) = \u22a5", "start": [1240, 1], "end": [1243, 18], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mker_fst", "code": "@[to_additive (attr := simp)]\nlemma mker_fst : mker (fst M N) = .prod \u22a5 \u22a4 := SetLike.ext fun _ => (and_true_iff _).symm", "start": [1247, 1], "end": [1248, 90], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.mker_snd", "code": "@[to_additive (attr := simp)]\nlemma mker_snd : mker (snd M N) = .prod \u22a4 \u22a5 := SetLike.ext fun _ => (true_and_iff _).symm", "start": [1250, 1], "end": [1251, 90], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.submonoidComap", "code": "@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from the preimage of an additive submonoid to itself.\"]\ndef submonoidComap (f : M \u2192* N) (N' : Submonoid N) :\n    N'.comap f \u2192* N' where\n  toFun x := \u27e8f x, x.2\u27e9\n  map_one' := Subtype.eq f.map_one\n  map_mul' x y := Subtype.eq (f.map_mul x y)", "start": [1253, 1], "end": [1260, 45], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.submonoidMap", "code": "@[to_additive (attr := simps)\n      \"the `AddMonoidHom` from an additive submonoid to its image. See\n      `AddEquiv.AddSubmonoidMap` for a variant for `AddEquiv`s.\"]\ndef submonoidMap (f : M \u2192* N) (M' : Submonoid M) : M' \u2192* M'.map f where\n  toFun x := \u27e8f x, \u27e8x, x.2, rfl\u27e9\u27e9\n  map_one' := Subtype.eq <| f.map_one\n  map_mul' x y := Subtype.eq <| f.map_mul x y", "start": [1266, 1], "end": [1274, 46], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.submonoidMap_surjective", "code": "@[to_additive]\ntheorem submonoidMap_surjective (f : M \u2192* N) (M' : Submonoid M) :\n    Function.Surjective (f.submonoidMap M')", "start": [1280, 1], "end": [1284, 23], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_inl", "code": "@[to_additive]\ntheorem mrange_inl : mrange (inl M N) = prod \u22a4 \u22a5", "start": [1294, 1], "end": [1295, 98], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_inr", "code": "@[to_additive]\ntheorem mrange_inr : mrange (inr M N) = prod \u22a5 \u22a4", "start": [1299, 1], "end": [1300, 98], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_inl'", "code": "@[to_additive]\ntheorem mrange_inl' : mrange (inl M N) = comap (snd M N) \u22a5", "start": [1304, 1], "end": [1306, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_inr'", "code": "@[to_additive]\ntheorem mrange_inr' : mrange (inr M N) = comap (fst M N) \u22a5", "start": [1310, 1], "end": [1312, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_fst", "code": "@[to_additive (attr := simp)]\ntheorem mrange_fst : mrange (fst M N) = \u22a4", "start": [1316, 1], "end": [1318, 69], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_snd", "code": "@[to_additive (attr := simp)]\ntheorem mrange_snd : mrange (snd M N) = \u22a4", "start": [1322, 1], "end": [1324, 69], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_eq_bot_iff", "code": "@[to_additive prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = \u22a5 \u2194 s = \u22a5 \u2227 t = \u22a5", "start": [1328, 1], "end": [1330, 98], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_eq_top_iff", "code": "@[to_additive prod_eq_top_iff]\ntheorem prod_eq_top_iff {s : Submonoid M} {t : Submonoid N} : s.prod t = \u22a4 \u2194 s = \u22a4 \u2227 t = \u22a4", "start": [1335, 1], "end": [1338, 16], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mrange_inl_sup_mrange_inr", "code": "@[to_additive (attr := simp)]\ntheorem mrange_inl_sup_mrange_inr : mrange (inl M N) \u2294 mrange (inr M N) = \u22a4", "start": [1343, 1], "end": [1345, 74], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inclusion", "code": "@[to_additive\n      \"The `AddMonoid` hom associated to an inclusion of submonoids.\"]\ndef inclusion {S T : Submonoid M} (h : S \u2264 T) : S \u2192* T :=\n  S.subtype.codRestrict _ fun x => h x.2", "start": [1349, 1], "end": [1353, 41], "kind": "commanddeclaration"}, {"full_name": "Submonoid.range_subtype", "code": "@[to_additive (attr := simp)]\ntheorem range_subtype (s : Submonoid M) : mrange s.subtype = s", "start": [1357, 1], "end": [1359, 69], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_top_iff'", "code": "@[to_additive]\ntheorem eq_top_iff' : S = \u22a4 \u2194 \u2200 x : M, x \u2208 S", "start": [1363, 1], "end": [1365, 65], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_bot_iff_forall", "code": "@[to_additive]\ntheorem eq_bot_iff_forall : S = \u22a5 \u2194 \u2200 x \u2208 S, x = (1 : M)", "start": [1369, 1], "end": [1371, 91], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_bot_of_subsingleton", "code": "@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton S] : S = \u22a5", "start": [1375, 1], "end": [1380, 41], "kind": "commanddeclaration"}, {"full_name": "Submonoid.nontrivial_iff_exists_ne_one", "code": "@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (S : Submonoid M) : Nontrivial S \u2194 \u2203 x \u2208 S, x \u2260 (1 : M)", "start": [1382, 1], "end": [1387, 49], "kind": "commanddeclaration"}, {"full_name": "Submonoid.bot_or_nontrivial", "code": "@[to_additive \"An additive submonoid is either the trivial additive submonoid or nontrivial.\"]\ntheorem bot_or_nontrivial (S : Submonoid M) : S = \u22a5 \u2228 Nontrivial S", "start": [1391, 1], "end": [1394, 101], "kind": "commanddeclaration"}, {"full_name": "Submonoid.bot_or_exists_ne_one", "code": "@[to_additive\n      \"An additive submonoid is either the trivial additive submonoid or contains a nonzero\n      element.\"]\ntheorem bot_or_exists_ne_one (S : Submonoid M) : S = \u22a5 \u2228 \u2203 x \u2208 S, x \u2260 (1 : M)", "start": [1398, 1], "end": [1403, 66], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.submonoidCongr", "code": "@[to_additive\n      \"Makes the identity additive isomorphism from a proof two\n      submonoids of an additive monoid are equal.\"]\ndef submonoidCongr (h : S = T) : S \u2243* T :=\n  { Equiv.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }", "start": [1413, 1], "end": [1419, 70], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ofLeftInverse'", "code": "@[to_additive (attr := simps (config := { simpRhs := true }))\n      \"An additive monoid homomorphism `f : M \u2192+ N` with a left-inverse `g : N \u2192 M`\n      defines an additive equivalence between `M` and `f.mrange`.\n      This is a bidirectional version of `AddMonoidHom.mrange_restrict`. \"]\ndef ofLeftInverse' (f : M \u2192* N) {g : N \u2192 M} (h : Function.LeftInverse g f) :\n    M \u2243* MonoidHom.mrange f :=\n  { f.mrangeRestrict with\n    toFun := f.mrangeRestrict\n    invFun := g \u2218 f.mrange.subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := MonoidHom.mem_mrange.mp x.2\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [1424, 1], "end": [1440, 47], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.submonoidMap", "code": "@[to_additive\n      \"An `AddEquiv` `\u03c6` between two additive monoids `M` and `N` induces an `AddEquiv`\n      between a submonoid `S \u2264 M` and the submonoid `\u03c6(S) \u2264 N`. See\n      `AddMonoidHom.addSubmonoidMap` for a variant for `AddMonoidHom`s.\"]\ndef submonoidMap (e : M \u2243* N) (S : Submonoid M) : S \u2243* S.map e.toMonoidHom :=\n  { (e : M \u2243 N).image S with map_mul' := fun _ _ => Subtype.ext (map_mul e _ _) }", "start": [1448, 1], "end": [1456, 82], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_submonoidMap_apply", "code": "@[to_additive (attr := simp)]\ntheorem coe_submonoidMap_apply (e : M \u2243* N) (S : Submonoid M) (g : S) :\n    ((submonoidMap e S g : S.map (e : M \u2192* N)) : N) = e g", "start": [1460, 1], "end": [1463, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.submonoidMap_symm_apply", "code": "@[to_additive (attr := simp) AddEquiv.add_submonoid_map_symm_apply]\ntheorem submonoidMap_symm_apply (e : M \u2243* N) (S : Submonoid M) (g : S.map (e : M \u2192* N)) :\n    (e.submonoidMap S).symm g = \u27e8e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2\u27e9", "start": [1467, 1], "end": [1470, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.equivMapOfInjective_coe_mulEquiv", "code": "@[to_additive (attr := simp)]\ntheorem Submonoid.equivMapOfInjective_coe_mulEquiv (e : M \u2243* N) :\n    S.equivMapOfInjective (e : M \u2192* N) (EquivLike.injective e) = e.submonoidMap S", "start": [1476, 1], "end": [1480, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul", "code": "@[to_additive]\ninstance smul [SMul M' \u03b1] (S : Submonoid M') : SMul S \u03b1 :=\n  SMul.comp _ S.subtype", "start": [1504, 1], "end": [1506, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smulCommClass_left", "code": "@[to_additive]\ninstance smulCommClass_left [SMul M' \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass M' \u03b1 \u03b2]\n    (S : Submonoid M') : SMulCommClass S \u03b1 \u03b2 :=\n  \u27e8fun a _ _ => (smul_comm (a : M') _ _ : _)\u27e9", "start": [1508, 1], "end": [1511, 46], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smulCommClass_right", "code": "@[to_additive]\ninstance smulCommClass_right [SMul \u03b1 \u03b2] [SMul M' \u03b2] [SMulCommClass \u03b1 M' \u03b2]\n    (S : Submonoid M') : SMulCommClass \u03b1 S \u03b2 :=\n  \u27e8fun a s => (smul_comm a (s : M') : _)\u27e9", "start": [1515, 1], "end": [1518, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.isScalarTower", "code": "instance isScalarTower [SMul \u03b1 \u03b2] [SMul M' \u03b1] [SMul M' \u03b2] [IsScalarTower M' \u03b1 \u03b2]\n      (S : Submonoid M') :\n    IsScalarTower S \u03b1 \u03b2 :=\n  \u27e8fun a => (smul_assoc (a : M') : _)\u27e9", "start": [1522, 1], "end": [1526, 39], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_def", "code": "@[to_additive]\ntheorem smul_def [SMul M' \u03b1] {S : Submonoid M'} (g : S) (m : \u03b1) : g \u2022 m = (g : M') \u2022 m", "start": [1528, 1], "end": [1530, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.faithfulSMul", "code": "instance faithfulSMul [SMul M' \u03b1] [FaithfulSMul M' \u03b1] (S : Submonoid M') : FaithfulSMul S \u03b1 :=\n  \u27e8fun h => Subtype.ext <| eq_of_smul_eq_smul h\u27e9", "start": [1534, 1], "end": [1535, 49], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mulAction", "code": "@[to_additive\n      \"The additive action by an `AddSubmonoid` is the action by the underlying `AddMonoid`. \"]\ninstance mulAction [MulAction M' \u03b1] (S : Submonoid M') : MulAction S \u03b1 :=\n  MulAction.compHom _ S.subtype", "start": [1541, 1], "end": [1545, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.distribMulAction", "code": "instance distribMulAction [AddMonoid \u03b1] [DistribMulAction M' \u03b1] (S : Submonoid M') :\n    DistribMulAction S \u03b1 :=\n  DistribMulAction.compHom _ S.subtype", "start": [1547, 1], "end": [1550, 39], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mulDistribMulAction", "code": "instance mulDistribMulAction [Monoid \u03b1] [MulDistribMulAction M' \u03b1] (S : Submonoid M') :\n    MulDistribMulAction S \u03b1 :=\n  MulDistribMulAction.compHom _ S.subtype", "start": [1552, 1], "end": [1555, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Equiv.lean", "imports": ["Mathlib/Algebra/Field/IsField.lean", "Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Init/CCLemmas.lean", "Mathlib/Algebra/Group/Opposite.lean", "Mathlib/Algebra/GroupWithZero/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Util/AssertExists.lean", "Mathlib/Logic/Equiv/Set.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "NonUnitalRingHom.inverse", "code": "@[simps] def NonUnitalRingHom.inverse\n    [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]\n    (f : R \u2192\u2099+* S) (g : S \u2192 R)\n    (h\u2081 : Function.LeftInverse g f) (h\u2082 : Function.RightInverse g f) : S \u2192\u2099+* R :=\n  { (f : R \u2192+ S).inverse g h\u2081 h\u2082, (f : R \u2192\u2099* S).inverse g h\u2081 h\u2082 with toFun := g }", "start": [48, 1], "end": [53, 82], "kind": "commanddeclaration"}, {"full_name": "RingHom.inverse", "code": "@[simps] def RingHom.inverse [NonAssocSemiring R] [NonAssocSemiring S]\n    (f : RingHom R S) (g : S \u2192 R)\n    (h\u2081 : Function.LeftInverse g f) (h\u2082 : Function.RightInverse g f) : S \u2192+* R :=\n  { (f : OneHom R S).inverse g h\u2081,\n    (f : MulHom R S).inverse g h\u2081 h\u2082,\n    (f : R \u2192+ S).inverse g h\u2081 h\u2082 with toFun := g }", "start": [55, 1], "end": [61, 51], "kind": "commanddeclaration"}, {"full_name": "RingEquiv", "code": "structure RingEquiv (R S : Type*) [Mul R] [Mul S] [Add R] [Add S] extends R \u2243 S, R \u2243* S, R \u2243+ S", "start": [63, 1], "end": [65, 96], "kind": "commanddeclaration"}, {"full_name": "RingEquivClass", "code": "class RingEquivClass (F : Type*) (R S : outParam (Type*)) [Mul R] [Add R] [Mul S] [Add S] extends\n  MulEquivClass F R S where\n  \n  map_add : \u2200 (f : F) (a b), f (a + b) = f a + f b", "start": [84, 1], "end": [89, 51], "kind": "commanddeclaration"}, {"full_name": "RingEquivClass.toAddEquivClass", "code": "instance (priority := 100) toAddEquivClass [Mul R] [Add R]\n    [Mul S] [Add S] [h : RingEquivClass F R S] : AddEquivClass F R S :=\n  { h with coe := h.coe }", "start": [95, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "RingEquivClass.toRingHomClass", "code": "instance (priority := 100) toRingHomClass [NonAssocSemiring R] [NonAssocSemiring S]\n    [h : RingEquivClass F R S] : RingHomClass F R S :=\n  { h with\n    coe := h.coe\n    coe_injective' := FunLike.coe_injective\n    map_zero := map_zero\n    map_one := map_one }", "start": [101, 1], "end": [107, 25], "kind": "commanddeclaration"}, {"full_name": "RingEquivClass.toNonUnitalRingHomClass", "code": "instance (priority := 100) toNonUnitalRingHomClass [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] [h : RingEquivClass F R S] : NonUnitalRingHomClass F R S :=\n  { h with\n    coe := h.coe\n    coe_injective' := FunLike.coe_injective\n    map_zero := map_zero }", "start": [111, 1], "end": [116, 27], "kind": "commanddeclaration"}, {"full_name": "RingEquivClass.toRingEquiv", "code": "@[coe]\ndef toRingEquiv [Mul \u03b1] [Add \u03b1] [Mul \u03b2] [Add \u03b2] [RingEquivClass F \u03b1 \u03b2] (f : F) :\n    \u03b1 \u2243+* \u03b2 :=\n  { (f : \u03b1 \u2243* \u03b2), (f : \u03b1 \u2243+ \u03b2) with }", "start": [119, 1], "end": [124, 38], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toEquiv_eq_coe", "code": "@[simp]\ntheorem toEquiv_eq_coe (f : R \u2243+* S) : f.toEquiv = f", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (f : R \u2243+* S) : \u21d1(f : R \u2243 S) = f", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_mul", "code": "protected theorem map_mul (e : R \u2243+* S) (x y : R) : e (x * y) = e x * e y", "start": [165, 1], "end": [167, 16], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_add", "code": "protected theorem map_add (e : R \u2243+* S) (x y : R) : e (x + y) = e x + e y", "start": [170, 1], "end": [172, 16], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ext", "code": "@[ext]\ntheorem ext {f g : R \u2243+* S} (h : \u2200 x, f x = g x) : f = g", "start": [175, 1], "end": [179, 20], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk (e h\u2083 h\u2084) : \u21d1(\u27e8e, h\u2083, h\u2084\u27e9 : R \u2243+* S) = e", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mk_coe", "code": "@[simp]\ntheorem mk_coe (e : R \u2243+* S) (e' h\u2081 h\u2082 h\u2083 h\u2084) : (\u27e8\u27e8e, e', h\u2081, h\u2082\u27e9, h\u2083, h\u2084\u27e9 : R \u2243+* S) = e", "start": [190, 1], "end": [192, 19], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.congr_arg", "code": "protected theorem congr_arg {f : R \u2243+* S} {x x' : R} : x = x' \u2192 f x = f x'", "start": [195, 1], "end": [196, 22], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.congr_fun", "code": "protected theorem congr_fun {f g : R \u2243+* S} (h : f = g) (x : R) : f x = g x", "start": [199, 1], "end": [200, 24], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ext_iff", "code": "protected theorem ext_iff {f g : R \u2243+* S} : f = g \u2194 \u2200 x, f x = g x", "start": [203, 1], "end": [204, 18], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toAddEquiv_eq_coe", "code": "@[simp]\ntheorem toAddEquiv_eq_coe (f : R \u2243+* S) : f.toAddEquiv = \u2191f", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toMulEquiv_eq_coe", "code": "@[simp]\ntheorem toMulEquiv_eq_coe (f : R \u2243+* S) : f.toMulEquiv = \u2191f", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toMulEquiv", "code": "@[simp, norm_cast]\ntheorem coe_toMulEquiv (f : R \u2243+* S) : \u21d1(f : R \u2243* S) = f", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toAddEquiv", "code": "@[simp]\ntheorem coe_toAddEquiv (f : R \u2243+* S) : \u21d1(f : R \u2243+ S) = f", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ringEquivOfUnique", "code": "def ringEquivOfUnique {M N} [Unique M] [Unique N] [Add M] [Mul M] [Add N] [Mul N] : M \u2243+* N :=\n  { AddEquiv.addEquivOfUnique, MulEquiv.mulEquivOfUnique with }", "start": [227, 1], "end": [229, 64], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.refl", "code": "@[refl]\ndef refl : R \u2243+* R :=\n  { MulEquiv.refl R, AddEquiv.refl R with }", "start": [239, 1], "end": [242, 44], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : R) : RingEquiv.refl R x = x", "start": [245, 1], "end": [247, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_addEquiv_refl", "code": "@[simp]\ntheorem coe_addEquiv_refl : (RingEquiv.refl R : R \u2243+ R) = AddEquiv.refl R", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_mulEquiv_refl", "code": "@[simp]\ntheorem coe_mulEquiv_refl : (RingEquiv.refl R : R \u2243* R) = MulEquiv.refl R", "start": [255, 1], "end": [257, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm", "code": "@[symm]\nprotected def symm (e : R \u2243+* S) : S \u2243+* R :=\n  { e.toMulEquiv.symm, e.toAddEquiv.symm with }", "start": [265, 1], "end": [268, 48], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : R \u2243+* S) : S \u2192 R :=\n  e.symm", "start": [271, 1], "end": [273, 9], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.invFun_eq_symm", "code": "@[simp]\ntheorem invFun_eq_symm (f : R \u2243+* S) : EquivLike.inv f = f.symm", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : R \u2243+* S) : e.symm.symm = e", "start": [283, 1], "end": [285, 19], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_refl", "code": "@[simp]\ntheorem symm_refl : (RingEquiv.refl R).symm = RingEquiv.refl R", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toEquiv_symm", "code": "@[simp]\ntheorem coe_toEquiv_symm (e : R \u2243+* S) : (e.symm : S \u2243 R) = (e : R \u2243 S).symm", "start": [293, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_bijective", "code": "theorem symm_bijective : Function.Bijective (RingEquiv.symm : R \u2243+* S \u2192 S \u2243+* R)", "start": [298, 1], "end": [299, 73], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mk_coe'", "code": "@[simp]\ntheorem mk_coe' (e : R \u2243+* S) (f h\u2081 h\u2082 h\u2083 h\u2084) :\n    (\u27e8\u27e8f, \u21d1e, h\u2081, h\u2082\u27e9, h\u2083, h\u2084\u27e9 : S \u2243+* R) = e.symm", "start": [302, 1], "end": [305, 47], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_mk", "code": "@[simp]\ntheorem symm_mk (f : R \u2192 S) (g h\u2081 h\u2082 h\u2083 h\u2084) :\n    (mk \u27e8f, g, h\u2081, h\u2082\u27e9 h\u2083 h\u2084).symm =\n      { (mk \u27e8f, g, h\u2081, h\u2082\u27e9 h\u2083 h\u2084).symm with\n        toFun := g\n        invFun := f }", "start": [308, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.trans", "code": "@[trans]\nprotected def trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') : R \u2243+* S' :=\n  { e\u2081.toMulEquiv.trans e\u2082.toMulEquiv, e\u2081.toAddEquiv.trans e\u2082.toAddEquiv with }", "start": [317, 1], "end": [320, 80], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.trans_apply", "code": "theorem trans_apply (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') (a : R) : e\u2081.trans e\u2082 a = e\u2082 (e\u2081 a)", "start": [323, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') : (e\u2081.trans e\u2082 : R \u2192 S') = e\u2082 \u2218 e\u2081", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') (a : S') :\n    (e\u2081.trans e\u2082).symm a = e\u2081.symm (e\u2082.symm a)", "start": [332, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_trans", "code": "theorem symm_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') : (e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm", "start": [338, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.bijective", "code": "protected theorem bijective (e : R \u2243+* S) : Function.Bijective e", "start": [342, 1], "end": [343, 24], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.injective", "code": "protected theorem injective (e : R \u2243+* S) : Function.Injective e", "start": [346, 1], "end": [347, 24], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.surjective", "code": "protected theorem surjective (e : R \u2243+* S) : Function.Surjective e", "start": [350, 1], "end": [351, 25], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : R \u2243+* S) : \u2200 x, e (e.symm x) = x", "start": [354, 1], "end": [356, 29], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : R \u2243+* S) : \u2200 x, e.symm (e x) = x", "start": [359, 1], "end": [361, 29], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.image_eq_preimage", "code": "theorem image_eq_preimage (e : R \u2243+* S) (s : Set R) : e '' s = e.symm \u207b\u00b9' s", "start": [364, 1], "end": [365, 32], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_mulEquiv_trans", "code": "@[simp]\ntheorem coe_mulEquiv_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082 : R \u2243* S') = (e\u2081 : R \u2243* S).trans \u2191e\u2082", "start": [368, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_addEquiv_trans", "code": "@[simp]\ntheorem coe_addEquiv_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082 : R \u2243+ S') = (e\u2081 : R \u2243+ S).trans \u2191e\u2082", "start": [374, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.op", "code": "@[simps! symm_apply_apply symm_apply_symm_apply apply_apply apply_symm_apply]\nprotected def op {\u03b1 \u03b2} [Add \u03b1] [Mul \u03b1] [Add \u03b2] [Mul \u03b2] :\n    \u03b1 \u2243+* \u03b2 \u2243 (\u03b1\u1d50\u1d52\u1d56 \u2243+* \u03b2\u1d50\u1d52\u1d56) where\n  toFun f := { AddEquiv.mulOp f.toAddEquiv, MulEquiv.op f.toMulEquiv with }\n  invFun f := { AddEquiv.mulOp.symm f.toAddEquiv, MulEquiv.op.symm f.toMulEquiv with }\n  left_inv f := by\n    ext\n    rfl\n  right_inv f := by\n    ext\n    rfl", "start": [386, 1], "end": [397, 8], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.unop", "code": "@[simp]\nprotected def unop {\u03b1 \u03b2} [Add \u03b1] [Mul \u03b1] [Add \u03b2] [Mul \u03b2] : \u03b1\u1d50\u1d52\u1d56 \u2243+* \u03b2\u1d50\u1d52\u1d56 \u2243 (\u03b1 \u2243+* \u03b2) :=\n  RingEquiv.op.symm", "start": [402, 1], "end": [405, 20], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.opOp", "code": "@[simps!]\ndef opOp (R : Type*) [Add R] [Mul R] : R \u2243+* R\u1d50\u1d52\u1d56\u1d50\u1d52\u1d56 where\n  __ := MulEquiv.opOp R\n  map_add' _ _ := rfl", "start": [408, 1], "end": [412, 22], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toOpposite", "code": "def toOpposite : R \u2243+* R\u1d50\u1d52\u1d56 :=\n  { MulOpposite.opEquiv with\n    map_add' := fun _ _ => rfl\n    map_mul' := fun x y => mul_comm (op y) (op x) }", "start": [418, 1], "end": [422, 52], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toOpposite_apply", "code": "@[simp]\ntheorem toOpposite_apply (r : R) : toOpposite R r = op r", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toOpposite_symm_apply", "code": "@[simp]\ntheorem toOpposite_symm_apply (r : R\u1d50\u1d52\u1d56) : (toOpposite R).symm r = unop r", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_zero", "code": "protected theorem map_zero : f 0 = 0", "start": [443, 1], "end": [445, 13], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_eq_zero_iff", "code": "protected theorem map_eq_zero_iff : f x = 0 \u2194 x = 0", "start": [450, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_ne_zero_iff", "code": "theorem map_ne_zero_iff : f x \u2260 0 \u2194 x \u2260 0", "start": [454, 1], "end": [455, 34], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofBijective", "code": "noncomputable def ofBijective [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f) :\n    R \u2243+* S :=\n  { Equiv.ofBijective f hf with\n    map_mul' := map_mul f\n    map_add' := map_add f }", "start": [458, 1], "end": [463, 28], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_ofBijective", "code": "@[simp]\ntheorem coe_ofBijective [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f) :\n    (ofBijective f hf : R \u2192 S) = f", "start": [466, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofBijective_apply", "code": "theorem ofBijective_apply [NonUnitalRingHomClass F R S] (f : F) (hf : Function.Bijective f)\n    (x : R) : ofBijective f hf x = f x", "start": [472, 1], "end": [474, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.piCongrRight", "code": "@[simps apply]\ndef piCongrRight {\u03b9 : Type*} {R S : \u03b9 \u2192 Type*} [\u2200 i, NonUnitalNonAssocSemiring (R i)]\n    [\u2200 i, NonUnitalNonAssocSemiring (S i)] (e : \u2200 i, R i \u2243+* S i) : (\u2200 i, R i) \u2243+* \u2200 i, S i :=\n  { @MulEquiv.piCongrRight \u03b9 R S _ _ fun i => (e i).toMulEquiv,\n    @AddEquiv.piCongrRight \u03b9 R S _ _ fun i => (e i).toAddEquiv with\n    toFun := fun x j => e j (x j)\n    invFun := fun x j => (e j).symm (x j) }", "start": [477, 1], "end": [489, 44], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.piCongrRight_refl", "code": "@[simp]\ntheorem piCongrRight_refl {\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, NonUnitalNonAssocSemiring (R i)] :\n    (piCongrRight fun i => RingEquiv.refl (R i)) = RingEquiv.refl _", "start": [493, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.piCongrRight_symm", "code": "@[simp]\ntheorem piCongrRight_symm {\u03b9 : Type*} {R S : \u03b9 \u2192 Type*} [\u2200 i, NonUnitalNonAssocSemiring (R i)]\n    [\u2200 i, NonUnitalNonAssocSemiring (S i)] (e : \u2200 i, R i \u2243+* S i) :\n    (piCongrRight e).symm = piCongrRight fun i => (e i).symm", "start": [499, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.piCongrRight_trans", "code": "@[simp]\ntheorem piCongrRight_trans {\u03b9 : Type*} {R S T : \u03b9 \u2192 Type*}\n    [\u2200 i, NonUnitalNonAssocSemiring (R i)] [\u2200 i, NonUnitalNonAssocSemiring (S i)]\n    [\u2200 i, NonUnitalNonAssocSemiring (T i)] (e : \u2200 i, R i \u2243+* S i) (f : \u2200 i, S i \u2243+* T i) :\n    (piCongrRight e).trans (piCongrRight f) = piCongrRight fun i => (e i).trans (f i)", "start": [506, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_one", "code": "protected theorem map_one : f 1 = 1", "start": [520, 1], "end": [522, 12], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_eq_one_iff", "code": "protected theorem map_eq_one_iff : f x = 1 \u2194 x = 1", "start": [527, 1], "end": [528, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_ne_one_iff", "code": "theorem map_ne_one_iff : f x \u2260 1 \u2194 x \u2260 1", "start": [531, 1], "end": [532, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_monoidHom_refl", "code": "theorem coe_monoidHom_refl : (RingEquiv.refl R : R \u2192* R) = MonoidHom.id R", "start": [535, 1], "end": [536, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_addMonoidHom_refl", "code": "@[simp]\ntheorem coe_addMonoidHom_refl : (RingEquiv.refl R : R \u2192+ R) = AddMonoidHom.id R", "start": [539, 1], "end": [541, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_ringHom_refl", "code": "@[simp]\ntheorem coe_ringHom_refl : (RingEquiv.refl R : R \u2192+* R) = RingHom.id R", "start": [548, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_monoidHom_trans", "code": "@[simp]\ntheorem coe_monoidHom_trans [NonAssocSemiring S'] (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082 : R \u2192* S') = (e\u2082 : S \u2192* S').comp \u2191e\u2081", "start": [553, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_addMonoidHom_trans", "code": "@[simp]\ntheorem coe_addMonoidHom_trans [NonAssocSemiring S'] (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082 : R \u2192+ S') = (e\u2082 : S \u2192+ S').comp \u2191e\u2081", "start": [559, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_ringHom_trans", "code": "@[simp]\ntheorem coe_ringHom_trans [NonAssocSemiring S'] (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082 : R \u2192+* S') = (e\u2082 : S \u2192+* S').comp \u2191e\u2081", "start": [568, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.comp_symm", "code": "@[simp]\ntheorem comp_symm (e : R \u2243+* S) : (e : R \u2192+* S).comp (e.symm : S \u2192+* R) = RingHom.id S", "start": [574, 1], "end": [576, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_comp", "code": "@[simp]\ntheorem symm_comp (e : R \u2243+* S) : (e.symm : S \u2192+* R).comp (e : R \u2192+* S) = RingHom.id R", "start": [579, 1], "end": [581, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_neg", "code": "protected theorem map_neg : f (-x) = -f x", "start": [590, 1], "end": [591, 14], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_sub", "code": "protected theorem map_sub : f (x - y) = f x - f y", "start": [594, 1], "end": [595, 16], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_neg_one", "code": "theorem map_neg_one : f (-1) = -1", "start": [605, 1], "end": [606, 26], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_eq_neg_one_iff", "code": "theorem map_eq_neg_one_iff {x : R} : f x = -1 \u2194 x = -1", "start": [609, 1], "end": [610, 85], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom", "code": "def toNonUnitalRingHom (e : R \u2243+* S) : R \u2192\u2099+* S :=\n  { e.toMulEquiv.toMulHom, e.toAddEquiv.toAddMonoidHom with }", "start": [619, 1], "end": [621, 62], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_injective", "code": "theorem toNonUnitalRingHom_injective :\n    Function.Injective (toNonUnitalRingHom : R \u2243+* S \u2192 R \u2192\u2099+* S)", "start": [624, 1], "end": [626, 47], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_eq_coe", "code": "theorem toNonUnitalRingHom_eq_coe (f : R \u2243+* S) : f.toNonUnitalRingHom = \u2191f", "start": [629, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toNonUnitalRingHom", "code": "@[simp, norm_cast]\ntheorem coe_toNonUnitalRingHom (f : R \u2243+* S) : \u21d1(f : R \u2192\u2099+* S) = f", "start": [633, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_nonUnitalRingHom_inj_iff", "code": "theorem coe_nonUnitalRingHom_inj_iff {R S : Type*} [NonUnitalNonAssocSemiring R]\n    [NonUnitalNonAssocSemiring S] (f g : R \u2243+* S) : f = g \u2194 (f : R \u2192\u2099+* S) = g", "start": [638, 1], "end": [640, 70], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_refl", "code": "@[simp]\ntheorem toNonUnitalRingHom_refl :\n    (RingEquiv.refl R).toNonUnitalRingHom = NonUnitalRingHom.id R", "start": [643, 1], "end": [646, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply", "code": "@[simp]\ntheorem toNonUnitalRingHom_apply_symm_toNonUnitalRingHom_apply (e : R \u2243+* S) :\n    \u2200 y : S, e.toNonUnitalRingHom (e.symm.toNonUnitalRingHom y) = y", "start": [649, 1], "end": [652, 29], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply", "code": "@[simp]\ntheorem symm_toNonUnitalRingHom_apply_toNonUnitalRingHom_apply (e : R \u2243+* S) :\n    \u2200 x : R, e.symm.toNonUnitalRingHom (e.toNonUnitalRingHom x) = x", "start": [655, 1], "end": [658, 35], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_trans", "code": "@[simp]\ntheorem toNonUnitalRingHom_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082).toNonUnitalRingHom = e\u2082.toNonUnitalRingHom.comp e\u2081.toNonUnitalRingHom", "start": [661, 1], "end": [664, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom", "code": "@[simp]\ntheorem toNonUnitalRingHomm_comp_symm_toNonUnitalRingHom (e : R \u2243+* S) :\n    e.toNonUnitalRingHom.comp e.symm.toNonUnitalRingHom = NonUnitalRingHom.id _", "start": [667, 1], "end": [671, 7], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_toNonUnitalRingHom_comp_toNonUnitalRingHom", "code": "@[simp]\ntheorem symm_toNonUnitalRingHom_comp_toNonUnitalRingHom (e : R \u2243+* S) :\n    e.symm.toNonUnitalRingHom.comp e.toNonUnitalRingHom = NonUnitalRingHom.id _", "start": [674, 1], "end": [678, 7], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom", "code": "def toRingHom (e : R \u2243+* S) : R \u2192+* S :=\n  { e.toMulEquiv.toMonoidHom, e.toAddEquiv.toAddMonoidHom with }", "start": [687, 1], "end": [689, 65], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_injective", "code": "theorem toRingHom_injective : Function.Injective (toRingHom : R \u2243+* S \u2192 R \u2192+* S)", "start": [692, 1], "end": [693, 38], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_eq_coe", "code": "@[simp] theorem toRingHom_eq_coe (f : R \u2243+* S) : f.toRingHom = \u2191f", "start": [696, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_toRingHom", "code": "@[simp, norm_cast]\ntheorem coe_toRingHom (f : R \u2243+* S) : \u21d1(f : R \u2192+* S) = f", "start": [700, 1], "end": [702, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_ringHom_inj_iff", "code": "theorem coe_ringHom_inj_iff {R S : Type*} [NonAssocSemiring R] [NonAssocSemiring S]\n    (f g : R \u2243+* S) : f = g \u2194 (f : R \u2192+* S) = g", "start": [705, 1], "end": [707, 61], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toNonUnitalRingHom_commutes", "code": "@[simp, norm_cast]\ntheorem toNonUnitalRingHom_commutes (f : R \u2243+* S) :\n    ((f : R \u2192+* S) : R \u2192\u2099+* S) = (f : R \u2192\u2099+* S)", "start": [710, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toMonoidHom", "code": "abbrev toMonoidHom (e : R \u2243+* S) : R \u2192* S :=\n  e.toRingHom.toMonoidHom", "start": [717, 1], "end": [719, 26], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toAddMonoidHom", "code": "abbrev toAddMonoidHom (e : R \u2243+* S) : R \u2192+ S :=\n  e.toRingHom.toAddMonoidHom", "start": [722, 1], "end": [724, 29], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toAddMonoidMom_commutes", "code": "theorem toAddMonoidMom_commutes (f : R \u2243+* S) :\n    (f : R \u2192+* S).toAddMonoidHom = (f : R \u2243+ S).toAddMonoidHom", "start": [727, 1], "end": [730, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toMonoidHom_commutes", "code": "theorem toMonoidHom_commutes (f : R \u2243+* S) :\n    (f : R \u2192+* S).toMonoidHom = (f : R \u2243* S).toMonoidHom", "start": [733, 1], "end": [736, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toEquiv_commutes", "code": "theorem toEquiv_commutes (f : R \u2243+* S) : (f : R \u2243+ S).toEquiv = (f : R \u2243* S).toEquiv", "start": [739, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_refl", "code": "@[simp]\ntheorem toRingHom_refl : (RingEquiv.refl R).toRingHom = RingHom.id R", "start": [744, 1], "end": [746, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toMonoidHom_refl", "code": "@[simp]\ntheorem toMonoidHom_refl : (RingEquiv.refl R).toMonoidHom = MonoidHom.id R", "start": [749, 1], "end": [751, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toAddMonoidHom_refl", "code": "@[simp]\ntheorem toAddMonoidHom_refl : (RingEquiv.refl R).toAddMonoidHom = AddMonoidHom.id R", "start": [754, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_apply_symm_toRingHom_apply", "code": "theorem toRingHom_apply_symm_toRingHom_apply (e : R \u2243+* S) :\n    \u2200 y : S, e.toRingHom (e.symm.toRingHom y) = y", "start": [760, 1], "end": [762, 29], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_toRingHom_apply_toRingHom_apply", "code": "theorem symm_toRingHom_apply_toRingHom_apply (e : R \u2243+* S) :\n    \u2200 x : R, e.symm.toRingHom (e.toRingHom x) = x", "start": [766, 1], "end": [768, 35], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_trans", "code": "@[simp]\ntheorem toRingHom_trans (e\u2081 : R \u2243+* S) (e\u2082 : S \u2243+* S') :\n    (e\u2081.trans e\u2082).toRingHom = e\u2082.toRingHom.comp e\u2081.toRingHom", "start": [771, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toRingHom_comp_symm_toRingHom", "code": "theorem toRingHom_comp_symm_toRingHom (e : R \u2243+* S) :\n    e.toRingHom.comp e.symm.toRingHom = RingHom.id _", "start": [778, 1], "end": [781, 7], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_toRingHom_comp_toRingHom", "code": "theorem symm_toRingHom_comp_toRingHom (e : R \u2243+* S) :\n    e.symm.toRingHom.comp e.toRingHom = RingHom.id _", "start": [785, 1], "end": [788, 7], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofHomInv'", "code": "@[simps]\ndef ofHomInv' {R S F G : Type*} [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S]\n    [NonUnitalRingHomClass F R S] [NonUnitalRingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S \u2192\u2099+* R).comp (hom : R \u2192\u2099+* S) = NonUnitalRingHom.id R)\n    (inv_hom_id : (hom : R \u2192\u2099+* S).comp (inv : S \u2192\u2099+* R) = NonUnitalRingHom.id S) :\n    R \u2243+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := FunLike.congr_fun hom_inv_id\n  right_inv := FunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom", "start": [791, 1], "end": [804, 26], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofHomInv", "code": "@[simps]\ndef ofHomInv {R S F G : Type*} [NonAssocSemiring R] [NonAssocSemiring S] [RingHomClass F R S]\n    [RingHomClass G S R] (hom : F) (inv : G)\n    (hom_inv_id : (inv : S \u2192+* R).comp (hom : R \u2192+* S) = RingHom.id R)\n    (inv_hom_id : (hom : R \u2192+* S).comp (inv : S \u2192+* R) = RingHom.id S) :\n    R \u2243+* S where\n  toFun := hom\n  invFun := inv\n  left_inv := FunLike.congr_fun hom_inv_id\n  right_inv := FunLike.congr_fun inv_hom_id\n  map_mul' := map_mul hom\n  map_add' := map_add hom", "start": [809, 1], "end": [823, 26], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_pow", "code": "protected theorem map_pow (f : R \u2243+* S) (a) : \u2200 n : \u2115, f (a ^ n) = f a ^ n", "start": [834, 1], "end": [835, 14], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.toRingEquiv", "code": "def toRingEquiv {R S F : Type*} [Add R] [Add S] [Mul R] [Mul S] [MulEquivClass F R S] (f : F)\n    (H : \u2200 x y : R, f (x + y) = f x + f y) : R \u2243+* S :=\n  { (f : R \u2243* S).toEquiv, (f : R \u2243* S), AddEquiv.mk' (f : R \u2243* S).toEquiv H with }", "start": [844, 1], "end": [847, 83], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toRingEquiv", "code": "def toRingEquiv {R S F : Type*} [Add R] [Add S] [Mul R] [Mul S] [AddEquivClass F R S] (f : F)\n    (H : \u2200 x y : R, f (x * y) = f x * f y) : R \u2243+* S :=\n  { (f : R \u2243+ S).toEquiv, (f : R \u2243+ S), MulEquiv.mk' (f : R \u2243+ S).toEquiv H with }", "start": [854, 1], "end": [857, 83], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (e : R \u2243+* S) : e.trans e.symm = RingEquiv.refl R", "start": [866, 1], "end": [868, 17], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (e : R \u2243+* S) : e.symm.trans e = RingEquiv.refl S", "start": [871, 1], "end": [873, 18], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.noZeroDivisors", "code": "protected theorem noZeroDivisors {A : Type*} (B : Type*) [MulZeroClass A] [MulZeroClass B]\n    [NoZeroDivisors B] (e : A \u2243* B) : NoZeroDivisors A", "start": [880, 1], "end": [884, 56], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.isDomain", "code": "protected theorem isDomain {A : Type*} (B : Type*) [Semiring A] [Semiring B] [IsDomain B]\n    (e : A \u2243* B) : IsDomain A", "start": [887, 1], "end": [892, 78], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.isField", "code": "protected theorem isField {A : Type*} (B : Type*) [Semiring A] [Semiring B] (hB : IsField B)\n    (e : A \u2243* B) : IsField A where", "start": [895, 1], "end": [901, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Basic.lean", "imports": ["Mathlib/Data/Rat/Defs.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/Algebra/SMulWithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Data/Rat/Basic.lean"], "premises": [{"full_name": "Module", "code": "@[ext]\nclass Module (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] extends\n  DistribMulAction R M where\n  \n  protected add_smul : \u2200 (r s : R) (x : M), (r + s) \u2022 x = r \u2022 x + s \u2022 x\n  \n  protected zero_smul : \u2200 x : M, (0 : R) \u2022 x = 0", "start": [49, 1], "end": [60, 49], "kind": "commanddeclaration"}, {"full_name": "Module.toMulActionWithZero", "code": "instance (priority := 100) Module.toMulActionWithZero : MulActionWithZero R M :=\n  { (inferInstance : MulAction R M) with\n    smul_zero := smul_zero\n    zero_smul := Module.zero_smul }", "start": [70, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "AddCommMonoid.natModule", "code": "instance AddCommMonoid.natModule : Module \u2115 M where\n  one_smul := one_nsmul\n  mul_smul m n a := mul_nsmul' a m n\n  smul_add n a b := nsmul_add a b n\n  smul_zero := nsmul_zero\n  zero_smul := zero_nsmul\n  add_smul r s x := add_nsmul x r s", "start": [77, 1], "end": [83, 36], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.nat_cast_def", "code": "theorem AddMonoid.End.nat_cast_def (n : \u2115) :\n    (\u2191n : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd \u2115 M n", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "add_smul", "code": "theorem add_smul : (r + s) \u2022 x = r \u2022 x + s \u2022 x", "start": [91, 1], "end": [92, 24], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_self", "code": "theorem Convex.combo_self {a b : R} (h : a + b = 1) (x : M) : a \u2022 x + b \u2022 x = x", "start": [95, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "two_smul", "code": "theorem two_smul : (2 : R) \u2022 x = x + x", "start": [102, 1], "end": [102, 91], "kind": "commanddeclaration"}, {"full_name": "two_smul'", "code": "@[deprecated] theorem two_smul' : (2 : R) \u2022 x = bit0 x", "start": [106, 1], "end": [107, 15], "kind": "commanddeclaration"}, {"full_name": "invOf_two_smul_add_invOf_two_smul", "code": "@[simp]\ntheorem invOf_two_smul_add_invOf_two_smul [Invertible (2 : R)] (x : M) :\n    (\u215f 2 : R) \u2022 x + (\u215f 2 : R) \u2022 x = x", "start": [110, 1], "end": [113, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.module", "code": "@[reducible]\nprotected def Function.Injective.module [AddCommMonoid M\u2082] [SMul R M\u2082] (f : M\u2082 \u2192+ M)\n    (hf : Injective f) (smul : \u2200 (c : R) (x), f (c \u2022 x) = c \u2022 f x) : Module R M\u2082 :=\n  { hf.distribMulAction f smul with\n    add_smul := fun c\u2081 c\u2082 x => hf <| by simp only [smul, f.map_add, add_smul]\n    zero_smul := fun x => hf <| by simp only [smul, zero_smul, f.map_zero] }", "start": [116, 1], "end": [123, 77], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.module", "code": "protected def Function.Surjective.module [AddCommMonoid M\u2082] [SMul R M\u2082] (f : M \u2192+ M\u2082)\n    (hf : Surjective f) (smul : \u2200 (c : R) (x), f (c \u2022 x) = c \u2022 f x) : Module R M\u2082 :=\n  { toDistribMulAction := hf.distribMulAction f smul\n    add_smul := fun c\u2081 c\u2082 x => by\n      rcases hf x with \u27e8x, rfl\u27e9\n      simp only [add_smul, \u2190 smul, \u2190 f.map_add]\n    zero_smul := fun x => by\n      rcases hf x with \u27e8x, rfl\u27e9\n      rw [\u2190 f.map_zero, \u2190 smul, zero_smul] }", "start": [126, 1], "end": [135, 45], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.moduleLeft", "code": "@[reducible]\ndef Function.Surjective.moduleLeft {R S M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]\n    [Semiring S] [SMul S M] (f : R \u2192+* S) (hf : Function.Surjective f)\n    (hsmul : \u2200 (c) (x : M), f c \u2022 x = c \u2022 x) : Module S M :=\n  { hf.distribMulActionLeft f.toMonoidHom hsmul with\n    zero_smul := fun x => by rw [\u2190 f.map_zero, hsmul, zero_smul]\n    add_smul := hf.forall\u2082.mpr fun a b x => by simp only [\u2190 f.map_add, hsmul, add_smul] }", "start": [138, 1], "end": [148, 90], "kind": "commanddeclaration"}, {"full_name": "Module.compHom", "code": "@[reducible]\ndef Module.compHom [Semiring S] (f : S \u2192+* R) : Module S M :=\n  { MulActionWithZero.compHom M f.toMonoidWithZeroHom, DistribMulAction.compHom M (f : S \u2192* R) with\n    add_smul := fun r s x => show f (r + s) \u2022 x = f r \u2022 x + f s \u2022 x by simp [add_smul] }", "start": [153, 1], "end": [163, 89], "kind": "commanddeclaration"}, {"full_name": "Module.toAddMonoidEnd", "code": "@[simps! apply_apply]\ndef Module.toAddMonoidEnd : R \u2192+* AddMonoid.End M :=\n  { DistribMulAction.toAddMonoidEnd R M with\n    map_zero' := AddMonoidHom.ext fun r => show (0:R) \u2022 r = 0 by simp\n    map_add' := fun x y =>\n      AddMonoidHom.ext fun r => show (x + y) \u2022 r = x \u2022 r + y \u2022 r by simp [add_smul] }", "start": [168, 1], "end": [180, 86], "kind": "commanddeclaration"}, {"full_name": "smulAddHom", "code": "def smulAddHom : R \u2192+ M \u2192+ M :=\n  (Module.toAddMonoidEnd R M).toAddMonoidHom", "start": [184, 1], "end": [187, 45], "kind": "commanddeclaration"}, {"full_name": "smulAddHom_apply", "code": "@[simp]\ntheorem smulAddHom_apply (r : R) (x : M) : smulAddHom R M r x = r \u2022 x", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "Module.eq_zero_of_zero_eq_one", "code": "theorem Module.eq_zero_of_zero_eq_one (zero_eq_one : (0 : R) = 1) : x = 0", "start": [197, 1], "end": [198, 48], "kind": "commanddeclaration"}, {"full_name": "smul_add_one_sub_smul", "code": "@[simp]\ntheorem smul_add_one_sub_smul {R : Type*} [Ring R] [Module R M] {r : R} {m : M} :\n    r \u2022 m + (1 - r) \u2022 m = m", "start": [201, 1], "end": [203, 83], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.intModule", "code": "instance AddCommGroup.intModule : Module \u2124 M where\n  one_smul := one_zsmul\n  mul_smul m n a := mul_zsmul a m n\n  smul_add n a b := zsmul_add a b n\n  smul_zero := zsmul_zero\n  zero_smul := zero_zsmul\n  add_smul r s x := add_zsmul x r s", "start": [213, 1], "end": [219, 36], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.End.int_cast_def", "code": "theorem AddMonoid.End.int_cast_def (z : \u2124) :\n    (\u2191z : AddMonoid.End M) = DistribMulAction.toAddMonoidEnd \u2124 M z", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "Module.Core", "code": "structure Module.Core extends SMul R M where\n  \n  smul_add : \u2200 (r : R) (x y : M), r \u2022 (x + y) = r \u2022 x + r \u2022 y\n  \n  add_smul : \u2200 (r s : R) (x : M), (r + s) \u2022 x = r \u2022 x + s \u2022 x\n  \n  mul_smul : \u2200 (r s : R) (x : M), (r * s) \u2022 x = r \u2022 s \u2022 x\n  \n  one_smul : \u2200 x : M, (1 : R) \u2022 x = x", "start": [227, 1], "end": [240, 38], "kind": "commanddeclaration"}, {"full_name": "Module.ofCore", "code": "def Module.ofCore (H : Module.Core R M) : Module R M :=\n  letI := H.toSMul\n  { H with\n    zero_smul := fun x =>\n      (AddMonoidHom.mk' (fun r : R => r \u2022 x) fun r s => H.add_smul r s x).map_zero\n    smul_zero := fun r => (AddMonoidHom.mk' ((\u00b7 \u2022 \u00b7) r) (H.smul_add r)).map_zero }", "start": [245, 1], "end": [252, 83], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_eq_smul_sub_add", "code": "theorem Convex.combo_eq_smul_sub_add [Module R M] {x y : M} {a b : R} (h : a + b = 1) :\n    a \u2022 x + b \u2022 y = b \u2022 (y - x) + x", "start": [255, 1], "end": [259, 65], "kind": "commanddeclaration"}, {"full_name": "Module.ext'", "code": "theorem Module.ext' {R : Type*} [Semiring R] {M : Type*} [AddCommMonoid M] (P Q : Module R M)\n    (w : \u2200 (r : R) (m : M), (haveI := P; r \u2022 m) = (haveI := Q; r \u2022 m)) :\n    P = Q", "start": [265, 1], "end": [270, 14], "kind": "commanddeclaration"}, {"full_name": "neg_smul", "code": "@[simp]\ntheorem neg_smul : -r \u2022 x = -(r \u2022 x)", "start": [277, 1], "end": [279, 76], "kind": "commanddeclaration"}, {"full_name": "neg_smul_neg", "code": "theorem neg_smul_neg : -r \u2022 -x = r \u2022 x", "start": [284, 1], "end": [284, 78], "kind": "commanddeclaration"}, {"full_name": "Units.neg_smul", "code": "@[simp]\ntheorem Units.neg_smul (u : R\u02e3) (x : M) : -u \u2022 x = -(u \u2022 x)", "start": [287, 1], "end": [289, 70], "kind": "commanddeclaration"}, {"full_name": "neg_one_smul", "code": "theorem neg_one_smul (x : M) : (-1 : R) \u2022 x = -x", "start": [294, 1], "end": [294, 60], "kind": "commanddeclaration"}, {"full_name": "sub_smul", "code": "theorem sub_smul (r s : R) (y : M) : (r - s) \u2022 y = r \u2022 y - s \u2022 y", "start": [299, 1], "end": [300, 34], "kind": "commanddeclaration"}, {"full_name": "Module.addCommMonoidToAddCommGroup", "code": "@[reducible]\ndef Module.addCommMonoidToAddCommGroup [Ring R] [AddCommMonoid M] [Module R M] : AddCommGroup M :=\n  { (inferInstance : AddCommMonoid M) with\n    neg := fun a => (-1 : R) \u2022 a\n    add_left_neg := fun a =>\n      show (-1 : R) \u2022 a + a = 0 by\n        nth_rw 2 [\u2190 one_smul R a]\n        rw [\u2190 add_smul, add_left_neg, zero_smul]\n    zsmul := fun z a => (z : R) \u2022 a\n    zsmul_zero' := fun a => by simpa only [Int.cast_zero] using zero_smul R a\n    zsmul_succ' := fun z a => by simp [add_comm, add_smul]\n    zsmul_neg' := fun z a => by simp [\u2190smul_assoc, neg_one_smul] }", "start": [307, 1], "end": [321, 67], "kind": "commanddeclaration"}, {"full_name": "Module.subsingleton", "code": "protected theorem Module.subsingleton (R M : Type*) [Semiring R] [Subsingleton R] [AddCommMonoid M]\n    [Module R M] : Subsingleton M", "start": [326, 1], "end": [330, 37], "kind": "commanddeclaration"}, {"full_name": "Module.nontrivial", "code": "protected theorem Module.nontrivial (R M : Type*) [Semiring R] [Nontrivial M] [AddCommMonoid M]\n    [Module R M] : Nontrivial R", "start": [333, 1], "end": [336, 35], "kind": "commanddeclaration"}, {"full_name": "Semiring.toModule", "code": "instance (priority := 910) Semiring.toModule [Semiring R] : Module R R where\n  smul_add := mul_add\n  add_smul := add_mul\n  zero_smul := zero_mul\n  smul_zero := mul_zero", "start": [340, 1], "end": [344, 24], "kind": "commanddeclaration"}, {"full_name": "Semiring.toOppositeModule", "code": "instance (priority := 910) Semiring.toOppositeModule [Semiring R] : Module R\u1d50\u1d52\u1d56 R :=\n  { MonoidWithZero.toOppositeMulActionWithZero R with\n    smul_add := fun _ _ _ => add_mul _ _ _\n    add_smul := fun _ _ _ => mul_add _ _ _ }", "start": [348, 1], "end": [352, 45], "kind": "commanddeclaration"}, {"full_name": "RingHom.toModule", "code": "def RingHom.toModule [Semiring R] [Semiring S] (f : R \u2192+* S) : Module R S :=\n  Module.compHom S f", "start": [355, 1], "end": [357, 21], "kind": "commanddeclaration"}, {"full_name": "RingHom.applyDistribMulAction", "code": "instance RingHom.applyDistribMulAction [Semiring R] : DistribMulAction (R \u2192+* R) R where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := RingHom.map_zero\n  smul_add := RingHom.map_add\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [360, 1], "end": [368, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.smul_def", "code": "@[simp]\nprotected theorem RingHom.smul_def [Semiring R] (f : R \u2192+* R) (a : R) : f \u2022 a = f a", "start": [371, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.applyFaithfulSMul", "code": "instance RingHom.applyFaithfulSMul [Semiring R] : FaithfulSMul (R \u2192+* R) R :=\n  \u27e8fun {_ _} h => RingHom.ext h\u27e9", "start": [376, 1], "end": [378, 33], "kind": "commanddeclaration"}, {"full_name": "nsmul_eq_smul_cast", "code": "theorem nsmul_eq_smul_cast (n : \u2115) (b : M) : n \u2022 b = (n : R) \u2022 b", "start": [389, 1], "end": [393, 88], "kind": "commanddeclaration"}, {"full_name": "nat_smul_eq_nsmul", "code": "theorem nat_smul_eq_nsmul (h : Module \u2115 M) (n : \u2115) (x : M) :\n    @SMul.smul \u2115 M h.toSMul n x = n \u2022 x", "start": [398, 1], "end": [402, 94], "kind": "commanddeclaration"}, {"full_name": "AddCommMonoid.natModule.unique", "code": "def AddCommMonoid.natModule.unique : Unique (Module \u2115 M) where\n  default := by infer_instance\n  uniq P := (Module.ext' P _) fun n => by convert nat_smul_eq_nsmul P n", "start": [405, 1], "end": [409, 72], "kind": "commanddeclaration"}, {"full_name": "AddCommMonoid.nat_isScalarTower", "code": "instance AddCommMonoid.nat_isScalarTower : IsScalarTower \u2115 R M where\n  smul_assoc n x y :=\n    Nat.recOn n (by simp only [Nat.zero_eq, zero_smul])\n    fun n ih => by simp only [Nat.succ_eq_add_one, add_smul, one_smul, ih]", "start": [412, 1], "end": [415, 75], "kind": "commanddeclaration"}, {"full_name": "zsmul_eq_smul_cast", "code": "theorem zsmul_eq_smul_cast (n : \u2124) (b : M) : n \u2022 b = (n : R) \u2022 b", "start": [428, 1], "end": [433, 27], "kind": "commanddeclaration"}, {"full_name": "int_smul_eq_zsmul", "code": "theorem int_smul_eq_zsmul (h : Module \u2124 M) (n : \u2124) (x : M) :\n    @SMul.smul \u2124 M h.toSMul n x = n \u2022 x", "start": [438, 1], "end": [441, 94], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.intModule.unique", "code": "def AddCommGroup.intModule.unique : Unique (Module \u2124 M) where\n  default := by infer_instance\n  uniq P := (Module.ext' P _) fun n => by convert int_smul_eq_zsmul P n", "start": [444, 1], "end": [448, 72], "kind": "commanddeclaration"}, {"full_name": "map_int_cast_smul", "code": "theorem map_int_cast_smul [AddCommGroup M] [AddCommGroup M\u2082] {F : Type*} [AddMonoidHomClass F M M\u2082]\n    (f : F) (R S : Type*) [Ring R] [Ring S] [Module R M] [Module S M\u2082] (x : \u2124) (a : M) :\n    f ((x : R) \u2022 a) = (x : S) \u2022 f a", "start": [453, 1], "end": [455, 86], "kind": "commanddeclaration"}, {"full_name": "map_nat_cast_smul", "code": "theorem map_nat_cast_smul [AddCommMonoid M] [AddCommMonoid M\u2082] {F : Type*}\n    [AddMonoidHomClass F M M\u2082] (f : F) (R S : Type*) [Semiring R] [Semiring S] [Module R M]\n    [Module S M\u2082] (x : \u2115) (a : M) : f ((x : R) \u2022 a) = (x : S) \u2022 f a", "start": [458, 1], "end": [461, 70], "kind": "commanddeclaration"}, {"full_name": "map_inv_nat_cast_smul", "code": "theorem map_inv_nat_cast_smul [AddCommMonoid M] [AddCommMonoid M\u2082] {F : Type*}\n    [AddMonoidHomClass F M M\u2082] (f : F) (R S : Type*)\n    [DivisionSemiring R] [DivisionSemiring S] [Module R M]\n    [Module S M\u2082] (n : \u2115) (x : M) : f ((n\u207b\u00b9 : R) \u2022 x) = (n\u207b\u00b9 : S) \u2022 f x", "start": [464, 1], "end": [479, 81], "kind": "commanddeclaration"}, {"full_name": "map_inv_int_cast_smul", "code": "theorem map_inv_int_cast_smul [AddCommGroup M] [AddCommGroup M\u2082] {F : Type*}\n    [AddMonoidHomClass F M M\u2082] (f : F) (R S : Type*) [DivisionRing R] [DivisionRing S] [Module R M]\n    [Module S M\u2082] (z : \u2124) (x : M) : f ((z\u207b\u00b9 : R) \u2022 x) = (z\u207b\u00b9 : S) \u2022 f x", "start": [482, 1], "end": [488, 35], "kind": "commanddeclaration"}, {"full_name": "map_rat_cast_smul", "code": "theorem map_rat_cast_smul [AddCommGroup M] [AddCommGroup M\u2082] {F : Type*} [AddMonoidHomClass F M M\u2082]\n    (f : F) (R S : Type*) [DivisionRing R] [DivisionRing S] [Module R M] [Module S M\u2082] (c : \u211a)\n    (x : M) : f ((c : R) \u2022 x) = (c : S) \u2022 f x", "start": [491, 1], "end": [495, 58], "kind": "commanddeclaration"}, {"full_name": "map_rat_smul", "code": "theorem map_rat_smul [AddCommGroup M] [AddCommGroup M\u2082] [Module \u211a M] [Module \u211a M\u2082] {F : Type*}\n    [AddMonoidHomClass F M M\u2082] (f : F) (c : \u211a) (x : M) : f (c \u2022 x) = c \u2022 f x", "start": [498, 1], "end": [500, 30], "kind": "commanddeclaration"}, {"full_name": "subsingleton_rat_module", "code": "instance subsingleton_rat_module (E : Type*) [AddCommGroup E] : Subsingleton (Module \u211a E) :=\n  \u27e8fun P Q => (Module.ext' P Q) fun r x => @map_rat_smul _ _ _ _ P Q _ _ (AddMonoidHom.id E) r x\u27e9", "start": [503, 1], "end": [505, 98], "kind": "commanddeclaration"}, {"full_name": "inv_nat_cast_smul_eq", "code": "theorem inv_nat_cast_smul_eq {E : Type*} (R S : Type*) [AddCommMonoid E] [DivisionSemiring R]\n    [DivisionSemiring S] [Module R E] [Module S E] (n : \u2115) (x : E) :\n    (n\u207b\u00b9 : R) \u2022 x = (n\u207b\u00b9 : S) \u2022 x", "start": [508, 1], "end": [513, 52], "kind": "commanddeclaration"}, {"full_name": "inv_int_cast_smul_eq", "code": "theorem inv_int_cast_smul_eq {E : Type*} (R S : Type*) [AddCommGroup E] [DivisionRing R]\n    [DivisionRing S] [Module R E] [Module S E] (n : \u2124) (x : E) : (n\u207b\u00b9 : R) \u2022 x = (n\u207b\u00b9 : S) \u2022 x", "start": [516, 1], "end": [520, 52], "kind": "commanddeclaration"}, {"full_name": "inv_nat_cast_smul_comm", "code": "theorem inv_nat_cast_smul_comm {\u03b1 E : Type*} (R : Type*) [AddCommMonoid E] [DivisionSemiring R]\n    [Monoid \u03b1] [Module R E] [DistribMulAction \u03b1 E] (n : \u2115) (s : \u03b1) (x : E) :\n    (n\u207b\u00b9 : R) \u2022 s \u2022 x = s \u2022 (n\u207b\u00b9 : R) \u2022 x", "start": [523, 1], "end": [528, 77], "kind": "commanddeclaration"}, {"full_name": "inv_int_cast_smul_comm", "code": "theorem inv_int_cast_smul_comm {\u03b1 E : Type*} (R : Type*) [AddCommGroup E] [DivisionRing R]\n    [Monoid \u03b1] [Module R E] [DistribMulAction \u03b1 E] (n : \u2124) (s : \u03b1) (x : E) :\n    (n\u207b\u00b9 : R) \u2022 s \u2022 x = s \u2022 (n\u207b\u00b9 : R) \u2022 x", "start": [531, 1], "end": [536, 77], "kind": "commanddeclaration"}, {"full_name": "rat_cast_smul_eq", "code": "theorem rat_cast_smul_eq {E : Type*} (R S : Type*) [AddCommGroup E] [DivisionRing R]\n    [DivisionRing S] [Module R E] [Module S E] (r : \u211a) (x : E) : (r : R) \u2022 x = (r : S) \u2022 x", "start": [539, 1], "end": [543, 48], "kind": "commanddeclaration"}, {"full_name": "AddCommGroup.intIsScalarTower", "code": "instance AddCommGroup.intIsScalarTower {R : Type u} {M : Type v} [Ring R] [AddCommGroup M]\n    [Module R M] : IsScalarTower \u2124 R M where\n  smul_assoc n x y := ((smulAddHom R M).flip y).map_zsmul x n", "start": [546, 1], "end": [548, 62], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.rat", "code": "instance IsScalarTower.rat {R : Type u} {M : Type v} [Ring R] [AddCommGroup M] [Module R M]\n    [Module \u211a R] [Module \u211a M] : IsScalarTower \u211a R M where\n  smul_assoc r x y := map_rat_smul ((smulAddHom R M).flip y) r x", "start": [551, 1], "end": [553, 65], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.rat", "code": "instance SMulCommClass.rat {R : Type u} {M : Type v} [Semiring R] [AddCommGroup M] [Module R M]\n    [Module \u211a M] : SMulCommClass \u211a R M where\n  smul_comm r x y := (map_rat_smul (smulAddHom R M x) r y).symm", "start": [556, 1], "end": [558, 64], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.rat'", "code": "instance SMulCommClass.rat' {R : Type u} {M : Type v} [Semiring R] [AddCommGroup M] [Module R M]\n    [Module \u211a M] : SMulCommClass R \u211a M :=\n  SMulCommClass.symm _ _ _", "start": [561, 1], "end": [563, 27], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors", "code": "class NoZeroSMulDivisors (R M : Type*) [Zero R] [Zero M] [SMul R M] : Prop where\n  \n  eq_zero_or_eq_zero_of_smul_eq_zero : \u2200 {c : R} {x : M}, c \u2022 x = 0 \u2192 c = 0 \u2228 x = 0", "start": [575, 1], "end": [585, 84], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.noZeroSMulDivisors", "code": "theorem Function.Injective.noZeroSMulDivisors {R M N : Type*} [Zero R] [Zero M] [Zero N]\n    [SMul R M] [SMul R N] [NoZeroSMulDivisors R N] (f : M \u2192 N) (hf : Function.Injective f)\n    (h0 : f 0 = 0) (hs : \u2200 (c : R) (x : M), f (c \u2022 x) = c \u2022 f x) : NoZeroSMulDivisors R M", "start": [590, 1], "end": [595, 98], "kind": "commanddeclaration"}, {"full_name": "NoZeroDivisors.toNoZeroSMulDivisors", "code": "instance (priority := 100) NoZeroDivisors.toNoZeroSMulDivisors [Zero R] [Mul R]\n    [NoZeroDivisors R] : NoZeroSMulDivisors R R :=\n  \u27e8fun {_ _} => eq_zero_or_eq_zero_of_mul_eq_zero\u27e9", "start": [599, 1], "end": [601, 51], "kind": "commanddeclaration"}, {"full_name": "smul_ne_zero", "code": "theorem smul_ne_zero [Zero R] [Zero M] [SMul R M] [NoZeroSMulDivisors R M] {c : R} {x : M}\n    (hc : c \u2260 0) (hx : x \u2260 0) : c \u2022 x \u2260 0", "start": [604, 1], "end": [606, 52], "kind": "commanddeclaration"}, {"full_name": "smul_eq_zero", "code": "@[simp]\ntheorem smul_eq_zero : c \u2022 x = 0 \u2194 c = 0 \u2228 x = 0", "start": [613, 1], "end": [616, 76], "kind": "commanddeclaration"}, {"full_name": "smul_ne_zero_iff", "code": "theorem smul_ne_zero_iff : c \u2022 x \u2260 0 \u2194 c \u2260 0 \u2227 x \u2260 0", "start": [619, 1], "end": [619, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.noZeroSMulDivisors", "code": "theorem Nat.noZeroSMulDivisors : NoZeroSMulDivisors \u2115 M", "start": [635, 1], "end": [639, 10], "kind": "commanddeclaration"}, {"full_name": "two_nsmul_eq_zero", "code": "theorem two_nsmul_eq_zero {v : M} : 2 \u2022 v = 0 \u2194 v = 0", "start": [644, 1], "end": [646, 22], "kind": "commanddeclaration"}, {"full_name": "CharZero.of_module", "code": "theorem CharZero.of_module (M) [AddCommMonoidWithOne M] [CharZero M] [Module R M] : CharZero R", "start": [653, 1], "end": [657, 99], "kind": "commanddeclaration"}, {"full_name": "smul_right_injective", "code": "theorem smul_right_injective [NoZeroSMulDivisors R M] {c : R} (hc : c \u2260 0) :\n    Function.Injective ((\u00b7 \u2022 \u00b7) c : M \u2192 M)", "start": [671, 1], "end": [673, 100], "kind": "commanddeclaration"}, {"full_name": "smul_right_inj", "code": "theorem smul_right_inj [NoZeroSMulDivisors R M] {c : R} (hc : c \u2260 0) {x y : M} :\n    c \u2022 x = c \u2022 y \u2194 x = y", "start": [678, 1], "end": [680, 37], "kind": "commanddeclaration"}, {"full_name": "self_eq_neg", "code": "theorem self_eq_neg {v : M} : v = -v \u2194 v = 0", "start": [691, 1], "end": [692, 65], "kind": "commanddeclaration"}, {"full_name": "neg_eq_self", "code": "theorem neg_eq_self {v : M} : -v = v \u2194 v = 0", "start": [695, 1], "end": [695, 81], "kind": "commanddeclaration"}, {"full_name": "self_ne_neg", "code": "theorem self_ne_neg {v : M} : v \u2260 -v \u2194 v \u2260 0", "start": [698, 1], "end": [699, 24], "kind": "commanddeclaration"}, {"full_name": "neg_ne_self", "code": "theorem neg_ne_self {v : M} : -v \u2260 v \u2194 v \u2260 0", "start": [702, 1], "end": [703, 24], "kind": "commanddeclaration"}, {"full_name": "smul_left_injective", "code": "theorem smul_left_injective {x : M} (hx : x \u2260 0) : Function.Injective fun c : R => c \u2022 x", "start": [718, 1], "end": [726, 10], "kind": "commanddeclaration"}, {"full_name": "GroupWithZero.toNoZeroSMulDivisors", "code": "instance (priority := 100) GroupWithZero.toNoZeroSMulDivisors : NoZeroSMulDivisors R M :=\n  \u27e8fun {_ _} h => or_iff_not_imp_left.2 fun hc => (smul_eq_zero_iff_eq' hc).1 h\u27e9", "start": [738, 1], "end": [740, 81], "kind": "commanddeclaration"}, {"full_name": "RatModule.noZeroSMulDivisors", "code": "instance (priority := 100) RatModule.noZeroSMulDivisors [AddCommGroup M] [Module \u211a M] :\n    NoZeroSMulDivisors \u2124 M :=\n  \u27e8fun {k} {x : M} h => by\n    simpa only [zsmul_eq_smul_cast \u211a k x, smul_eq_zero, Rat.zero_iff_num_zero] using h\u27e9", "start": [746, 1], "end": [749, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.smul_one_eq_coe", "code": "theorem Nat.smul_one_eq_coe {R : Type*} [Semiring R] (m : \u2115) : m \u2022 (1 : R) = \u2191m", "start": [758, 1], "end": [759, 29], "kind": "commanddeclaration"}, {"full_name": "Int.smul_one_eq_coe", "code": "theorem Int.smul_one_eq_coe {R : Type*} [Ring R] (m : \u2124) : m \u2022 (1 : R) = \u2191m", "start": [764, 1], "end": [765, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Continuity/Init.lean", "imports": ["lake-packages/aesop/Aesop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Order/Filter/Cofinite.lean", "imports": ["Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Order/Filter/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.cofinite", "code": "def cofinite : Filter \u03b1 where\n  sets := { s | s\u1d9c.Finite }\n  univ_sets := by simp only [compl_univ, finite_empty, mem_setOf_eq]\n  sets_of_superset hs st := hs.subset <| compl_subset_compl.2 st\n  inter_sets hs ht := by simpa only [compl_inter, mem_setOf_eq] using hs.union ht", "start": [31, 1], "end": [36, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_cofinite", "code": "@[simp]\ntheorem mem_cofinite {s : Set \u03b1} : s \u2208 @cofinite \u03b1 \u2194 s\u1d9c.Finite", "start": [39, 1], "end": [41, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_cofinite", "code": "@[simp]\ntheorem eventually_cofinite {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in cofinite, p x) \u2194 { x | \u00acp x }.Finite", "start": [44, 1], "end": [46, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_cofinite", "code": "theorem hasBasis_cofinite : HasBasis cofinite (fun s : Set \u03b1 => s.Finite) compl", "start": [49, 1], "end": [52, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite_neBot", "code": "instance cofinite_neBot [Infinite \u03b1] : NeBot (@cofinite \u03b1) :=\n  hasBasis_cofinite.neBot_iff.2 fun hs => hs.infinite_compl.nonempty", "start": [55, 1], "end": [56, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite_eq_bot_iff", "code": "@[simp]\ntheorem cofinite_eq_bot_iff : @cofinite \u03b1 = \u22a5 \u2194 Finite \u03b1", "start": [59, 1], "end": [61, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.cofinite_eq_bot", "code": "@[simp]\ntheorem cofinite_eq_bot [Finite \u03b1] : @cofinite \u03b1 = \u22a5", "start": [63, 1], "end": [64, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_cofinite_iff_infinite", "code": "theorem frequently_cofinite_iff_infinite {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in cofinite, p x) \u2194 Set.Infinite { x | p x }", "start": [66, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.compl_mem_cofinite", "code": "theorem _root_.Set.Finite.compl_mem_cofinite {s : Set \u03b1} (hs : s.Finite) : s\u1d9c \u2208 @cofinite \u03b1", "start": [72, 1], "end": [73, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.eventually_cofinite_nmem", "code": "theorem _root_.Set.Finite.eventually_cofinite_nmem {s : Set \u03b1} (hs : s.Finite) :\n    \u2200\u1da0 x in cofinite, x \u2209 s", "start": [76, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.eventually_cofinite_nmem", "code": "theorem _root_.Finset.eventually_cofinite_nmem (s : Finset \u03b1) : \u2200\u1da0 x in cofinite, x \u2209 s", "start": [81, 1], "end": [82, 42], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_iff_frequently_cofinite", "code": "theorem _root_.Set.infinite_iff_frequently_cofinite {s : Set \u03b1} :\n    Set.Infinite s \u2194 \u2203\u1da0 x in cofinite, x \u2208 s", "start": [85, 1], "end": [87, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_cofinite_ne", "code": "theorem eventually_cofinite_ne (x : \u03b1) : \u2200\u1da0 a in cofinite, a \u2260 x", "start": [90, 1], "end": [91, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.le_cofinite_iff_compl_singleton_mem", "code": "theorem le_cofinite_iff_compl_singleton_mem : l \u2264 cofinite \u2194 \u2200 x, {x}\u1d9c \u2208 l", "start": [94, 1], "end": [97, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.le_cofinite_iff_eventually_ne", "code": "theorem le_cofinite_iff_eventually_ne : l \u2264 cofinite \u2194 \u2200 x, \u2200\u1da0 y in l, y \u2260 x", "start": [100, 1], "end": [101, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_le_cofinite", "code": "theorem atTop_le_cofinite [Preorder \u03b1] [NoMaxOrder \u03b1] : (atTop : Filter \u03b1) \u2264 cofinite", "start": [104, 1], "end": [106, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_cofinite_le", "code": "theorem comap_cofinite_le (f : \u03b1 \u2192 \u03b2) : comap f cofinite \u2264 cofinite", "start": [109, 1], "end": [111, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_cofinite", "code": "theorem coprod_cofinite : (cofinite : Filter \u03b1).coprod (cofinite : Filter \u03b2) = cofinite", "start": [114, 1], "end": [117, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_cofinite", "code": "theorem coprod\u1d62_cofinite {\u03b1 : \u03b9 \u2192 Type*} [Finite \u03b9] :\n    (Filter.coprod\u1d62 fun i => (cofinite : Filter (\u03b1 i))) = cofinite", "start": [120, 1], "end": [123, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_cofinite_left", "code": "@[simp]\ntheorem disjoint_cofinite_left : Disjoint cofinite l \u2194 \u2203 s \u2208 l, Set.Finite s", "start": [127, 1], "end": [131, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.disjoint_cofinite_right", "code": "@[simp]\ntheorem disjoint_cofinite_right : Disjoint l cofinite \u2194 \u2203 s \u2208 l, Set.Finite s", "start": [134, 1], "end": [136, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.countable_compl_ker", "code": "theorem countable_compl_ker [l.IsCountablyGenerated] (h : cofinite \u2264 l) : Set.Countable l.ker\u1d9c", "start": [139, 1], "end": [143, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.countable_compl_preimage_ker", "code": "theorem Tendsto.countable_compl_preimage_ker {f : \u03b1 \u2192 \u03b2}\n    {l : Filter \u03b2} [l.IsCountablyGenerated] (h : Tendsto f cofinite l) :\n    Set.Countable (f \u207b\u00b9' l.ker)\u1d9c", "start": [145, 1], "end": [149, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.cofinite_eq_atTop", "code": "theorem Nat.cofinite_eq_atTop : @cofinite \u2115 = atTop", "start": [155, 1], "end": [159, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.frequently_atTop_iff_infinite", "code": "theorem Nat.frequently_atTop_iff_infinite {p : \u2115 \u2192 Prop} :\n    (\u2203\u1da0 n in atTop, p n) \u2194 Set.Infinite { n | p n }", "start": [162, 1], "end": [164, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.exists_within_forall_le", "code": "theorem Filter.Tendsto.exists_within_forall_le {\u03b1 \u03b2 : Type*} [LinearOrder \u03b2] {s : Set \u03b1}\n    (hs : s.Nonempty) {f : \u03b1 \u2192 \u03b2} (hf : Filter.Tendsto f Filter.cofinite Filter.atTop) :\n    \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a\u2080 \u2264 f a", "start": [167, 1], "end": [181, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.exists_forall_le", "code": "theorem Filter.Tendsto.exists_forall_le [Nonempty \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Tendsto f cofinite atTop) : \u2203 a\u2080, \u2200 a, f a\u2080 \u2264 f a", "start": [184, 1], "end": [187, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.exists_within_forall_ge", "code": "theorem Filter.Tendsto.exists_within_forall_ge [LinearOrder \u03b2] {s : Set \u03b1} (hs : s.Nonempty)\n    {f : \u03b1 \u2192 \u03b2} (hf : Filter.Tendsto f Filter.cofinite Filter.atBot) :\n    \u2203 a\u2080 \u2208 s, \u2200 a \u2208 s, f a \u2264 f a\u2080", "start": [190, 1], "end": [193, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.exists_forall_ge", "code": "theorem Filter.Tendsto.exists_forall_ge [Nonempty \u03b1] [LinearOrder \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Tendsto f cofinite atBot) : \u2203 a\u2080, \u2200 a, f a \u2264 f a\u2080", "start": [196, 1], "end": [198, 50], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.le_map_cofinite", "code": "theorem Function.Surjective.le_map_cofinite {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) :\n    cofinite \u2264 map f cofinite", "start": [201, 1], "end": [202, 62], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.tendsto_cofinite", "code": "theorem Function.Injective.tendsto_cofinite {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Tendsto f cofinite cofinite", "start": [204, 1], "end": [207, 70], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.comap_cofinite_eq", "code": "theorem Function.Injective.comap_cofinite_eq {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    comap f cofinite = cofinite", "start": [210, 1], "end": [214, 62], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.nat_tendsto_atTop", "code": "theorem Function.Injective.nat_tendsto_atTop {f : \u2115 \u2192 \u2115} (hf : Injective f) :\n    Tendsto f atTop atTop", "start": [217, 1], "end": [220, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ZornAtoms.lean", "imports": ["Mathlib/Order/Atoms.lean", "Mathlib/Order/Zorn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsCoatomic.of_isChain_bounded", "code": "theorem IsCoatomic.of_isChain_bounded {\u03b1 : Type*} [PartialOrder \u03b1] [OrderTop \u03b1]\n    (h :\n      \u2200 c : Set \u03b1,\n        IsChain (\u00b7 \u2264 \u00b7) c \u2192 c.Nonempty \u2192 \u22a4 \u2209 c \u2192 \u2203 (x : _) (_ : x \u2260 \u22a4), x \u2208 upperBounds c) :\n    IsCoatomic \u03b1", "start": [22, 1], "end": [36, 54], "kind": "commanddeclaration"}, {"full_name": "IsAtomic.of_isChain_bounded", "code": "theorem IsAtomic.of_isChain_bounded {\u03b1 : Type*} [PartialOrder \u03b1] [OrderBot \u03b1]\n    (h :\n      \u2200 c : Set \u03b1,\n        IsChain (\u00b7 \u2264 \u00b7) c \u2192 c.Nonempty \u2192 \u22a5 \u2209 c \u2192 \u2203 (x : _) (_ : x \u2260 \u22a5), x \u2208 lowerBounds c) :\n    IsAtomic \u03b1", "start": [39, 1], "end": [46, 91], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/LocallyFinite.lean", "imports": ["Mathlib/Order/Cover.lean", "Mathlib/Data/Set/Intervals/Monoid.lean", "Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.nonempty_Icc", "code": "@[simp]\ntheorem nonempty_Icc : (Icc a b).Nonempty \u2194 a \u2264 b", "start": [55, 1], "end": [57, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_Ico", "code": "@[simp]\ntheorem nonempty_Ico : (Ico a b).Nonempty \u2194 a < b", "start": [60, 1], "end": [62, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_Ioc", "code": "@[simp]\ntheorem nonempty_Ioc : (Ioc a b).Nonempty \u2194 a < b", "start": [65, 1], "end": [67, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_Ioo", "code": "@[simp]\ntheorem nonempty_Ioo [DenselyOrdered \u03b1] : (Ioo a b).Nonempty \u2194 a < b", "start": [71, 1], "end": [73, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_empty_iff", "code": "@[simp]\ntheorem Icc_eq_empty_iff : Icc a b = \u2205 \u2194 \u00aca \u2264 b", "start": [76, 1], "end": [78, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_eq_empty_iff", "code": "@[simp]\ntheorem Ico_eq_empty_iff : Ico a b = \u2205 \u2194 \u00aca < b", "start": [81, 1], "end": [83, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_eq_empty_iff", "code": "@[simp]\ntheorem Ioc_eq_empty_iff : Ioc a b = \u2205 \u2194 \u00aca < b", "start": [86, 1], "end": [88, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_eq_empty_iff", "code": "@[simp]\ntheorem Ioo_eq_empty_iff [DenselyOrdered \u03b1] : Ioo a b = \u2205 \u2194 \u00aca < b", "start": [92, 1], "end": [94, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_empty", "code": "alias \u27e8_, Icc_eq_empty\u27e9 := Icc_eq_empty_iff", "start": [97, 1], "end": [97, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Ico_eq_empty", "code": "alias \u27e8_, Ico_eq_empty\u27e9 := Ico_eq_empty_iff", "start": [100, 1], "end": [100, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Ioc_eq_empty", "code": "alias \u27e8_, Ioc_eq_empty\u27e9 := Ioc_eq_empty_iff", "start": [103, 1], "end": [103, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Ioo_eq_empty", "code": "@[simp]\ntheorem Ioo_eq_empty (h : \u00aca < b) : Ioo a b = \u2205", "start": [106, 1], "end": [108, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_empty_of_lt", "code": "@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = \u2205", "start": [111, 1], "end": [113, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_eq_empty_of_le", "code": "@[simp]\ntheorem Ico_eq_empty_of_le (h : b \u2264 a) : Ico a b = \u2205", "start": [116, 1], "end": [118, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_eq_empty_of_le", "code": "@[simp]\ntheorem Ioc_eq_empty_of_le (h : b \u2264 a) : Ioc a b = \u2205", "start": [121, 1], "end": [123, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_eq_empty_of_le", "code": "@[simp]\ntheorem Ioo_eq_empty_of_le (h : b \u2264 a) : Ioo a b = \u2205", "start": [126, 1], "end": [128, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.left_mem_Icc", "code": "theorem left_mem_Icc : a \u2208 Icc a b \u2194 a \u2264 b", "start": [133, 1], "end": [133, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.left_mem_Ico", "code": "theorem left_mem_Ico : a \u2208 Ico a b \u2194 a < b", "start": [138, 1], "end": [138, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.right_mem_Icc", "code": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b", "start": [143, 1], "end": [143, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.right_mem_Ioc", "code": "theorem right_mem_Ioc : b \u2208 Ioc a b \u2194 a < b", "start": [148, 1], "end": [148, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.left_not_mem_Ioc", "code": "theorem left_not_mem_Ioc : a \u2209 Ioc a b", "start": [153, 1], "end": [153, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.left_not_mem_Ioo", "code": "theorem left_not_mem_Ioo : a \u2209 Ioo a b", "start": [158, 1], "end": [158, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.right_not_mem_Ico", "code": "theorem right_not_mem_Ico : b \u2209 Ico a b", "start": [163, 1], "end": [163, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.right_not_mem_Ioo", "code": "theorem right_not_mem_Ioo : b \u2209 Ioo a b", "start": [168, 1], "end": [168, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Icc", "code": "theorem Icc_subset_Icc (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 \u2264 b\u2082) : Icc a\u2081 b\u2081 \u2286 Icc a\u2082 b\u2082", "start": [171, 1], "end": [172, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ico", "code": "theorem Ico_subset_Ico (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 \u2264 b\u2082) : Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082", "start": [175, 1], "end": [176, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ioc", "code": "theorem Ioc_subset_Ioc (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 \u2264 b\u2082) : Ioc a\u2081 b\u2081 \u2286 Ioc a\u2082 b\u2082", "start": [179, 1], "end": [180, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ioo", "code": "theorem Ioo_subset_Ioo (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 \u2264 b\u2082) : Ioo a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082", "start": [183, 1], "end": [184, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Icc_left", "code": "theorem Icc_subset_Icc_left (h : a\u2081 \u2264 a\u2082) : Icc a\u2082 b \u2286 Icc a\u2081 b", "start": [187, 1], "end": [188, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ico_left", "code": "theorem Ico_subset_Ico_left (h : a\u2081 \u2264 a\u2082) : Ico a\u2082 b \u2286 Ico a\u2081 b", "start": [191, 1], "end": [192, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ioc_left", "code": "theorem Ioc_subset_Ioc_left (h : a\u2081 \u2264 a\u2082) : Ioc a\u2082 b \u2286 Ioc a\u2081 b", "start": [195, 1], "end": [196, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ioo_left", "code": "theorem Ioo_subset_Ioo_left (h : a\u2081 \u2264 a\u2082) : Ioo a\u2082 b \u2286 Ioo a\u2081 b", "start": [199, 1], "end": [200, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Icc_right", "code": "theorem Icc_subset_Icc_right (h : b\u2081 \u2264 b\u2082) : Icc a b\u2081 \u2286 Icc a b\u2082", "start": [203, 1], "end": [204, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ico_right", "code": "theorem Ico_subset_Ico_right (h : b\u2081 \u2264 b\u2082) : Ico a b\u2081 \u2286 Ico a b\u2082", "start": [207, 1], "end": [208, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ioc_right", "code": "theorem Ioc_subset_Ioc_right (h : b\u2081 \u2264 b\u2082) : Ioc a b\u2081 \u2286 Ioc a b\u2082", "start": [211, 1], "end": [212, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ioo_right", "code": "theorem Ioo_subset_Ioo_right (h : b\u2081 \u2264 b\u2082) : Ioo a b\u2081 \u2286 Ioo a b\u2082", "start": [215, 1], "end": [216, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ioo_left", "code": "theorem Ico_subset_Ioo_left (h : a\u2081 < a\u2082) : Ico a\u2082 b \u2286 Ioo a\u2081 b", "start": [219, 1], "end": [221, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ioo_right", "code": "theorem Ioc_subset_Ioo_right (h : b\u2081 < b\u2082) : Ioc a b\u2081 \u2286 Ioo a b\u2082", "start": [224, 1], "end": [226, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Ico_right", "code": "theorem Icc_subset_Ico_right (h : b\u2081 < b\u2082) : Icc a b\u2081 \u2286 Ico a b\u2082", "start": [229, 1], "end": [231, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ico_self", "code": "theorem Ioo_subset_Ico_self : Ioo a b \u2286 Ico a b", "start": [234, 1], "end": [236, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ioc_self", "code": "theorem Ioo_subset_Ioc_self : Ioo a b \u2286 Ioc a b", "start": [239, 1], "end": [241, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Icc_self", "code": "theorem Ico_subset_Icc_self : Ico a b \u2286 Icc a b", "start": [244, 1], "end": [246, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Icc_self", "code": "theorem Ioc_subset_Icc_self : Ioc a b \u2286 Icc a b", "start": [249, 1], "end": [251, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Icc_self", "code": "theorem Ioo_subset_Icc_self : Ioo a b \u2286 Icc a b", "start": [254, 1], "end": [255, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Icc_iff", "code": "theorem Icc_subset_Icc_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Icc a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [258, 1], "end": [259, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Ioo_iff", "code": "theorem Icc_subset_Ioo_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ioo a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 < b\u2082", "start": [262, 1], "end": [263, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Ico_iff", "code": "theorem Icc_subset_Ico_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 < b\u2082", "start": [266, 1], "end": [267, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_Ioc_iff", "code": "theorem Icc_subset_Ioc_iff (h\u2081 : a\u2081 \u2264 b\u2081) : Icc a\u2081 b\u2081 \u2286 Ioc a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [270, 1], "end": [271, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_ssubset_Icc_left", "code": "theorem Icc_ssubset_Icc_left (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 < a\u2081) (hb : b\u2081 \u2264 b\u2082) :\n    Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082", "start": [275, 1], "end": [278, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_ssubset_Icc_right", "code": "theorem Icc_ssubset_Icc_right (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 \u2264 a\u2081) (hb : b\u2081 < b\u2082) :\n    Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082", "start": [281, 1], "end": [284, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_self", "code": "theorem Ico_self : Ico a a = \u2205", "start": [291, 1], "end": [292, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_self", "code": "theorem Ioc_self : Ioc a a = \u2205", "start": [297, 1], "end": [298, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_self", "code": "theorem Ioo_self : Ioo a a = \u2205", "start": [303, 1], "end": [304, 30], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeOfMemBounds", "code": "def _root_.Set.fintypeOfMemBounds {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 upperBounds s) : Fintype s :=\n  Set.fintypeSubset (Set.Icc a b) fun _ hx => \u27e8ha hx, hb hx\u27e9", "start": [309, 1], "end": [312, 61], "kind": "commanddeclaration"}, {"full_name": "BddBelow.finite_of_bddAbove", "code": "theorem _root_.BddBelow.finite_of_bddAbove {s : Set \u03b1} (h\u2080 : BddBelow s) (h\u2081 : BddAbove s) :\n    s.Finite", "start": [315, 1], "end": [319, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_lt_of_le_left", "code": "theorem Ico_filter_lt_of_le_left [DecidablePred (\u00b7 < c)] (hca : c \u2264 a) :\n    (Ico a b).filter (\u00b7 < c) = \u2205", "start": [324, 1], "end": [326, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_lt_of_right_le", "code": "theorem Ico_filter_lt_of_right_le [DecidablePred (\u00b7 < c)] (hbc : b \u2264 c) :\n    (Ico a b).filter (\u00b7 < c) = Ico a b", "start": [329, 1], "end": [331, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_lt_of_le_right", "code": "theorem Ico_filter_lt_of_le_right [DecidablePred (\u00b7 < c)] (hcb : c \u2264 b) :\n    (Ico a b).filter (\u00b7 < c) = Ico a c", "start": [334, 1], "end": [338, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_le_of_le_left", "code": "theorem Ico_filter_le_of_le_left {a b c : \u03b1} [DecidablePred ((\u00b7 \u2264 \u00b7) c)] (hca : c \u2264 a) :\n    (Ico a b).filter ((\u00b7 \u2264 \u00b7) c) = Ico a b", "start": [341, 1], "end": [343, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_le_of_right_le", "code": "theorem Ico_filter_le_of_right_le {a b : \u03b1} [DecidablePred ((\u00b7 \u2264 \u00b7) b)] :\n    (Ico a b).filter ((\u00b7 \u2264 \u00b7) b) = \u2205", "start": [346, 1], "end": [348, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_le_of_left_le", "code": "theorem Ico_filter_le_of_left_le {a b c : \u03b1} [DecidablePred ((\u00b7 \u2264 \u00b7) c)] (hac : a \u2264 c) :\n    (Ico a b).filter ((\u00b7 \u2264 \u00b7) c) = Ico c b", "start": [351, 1], "end": [355, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_filter_lt_of_lt_right", "code": "theorem Icc_filter_lt_of_lt_right {a b c : \u03b1} [DecidablePred (\u00b7 < c)] (h : b < c) :\n    (Icc a b).filter (\u00b7 < c) = Icc a b", "start": [358, 1], "end": [360, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_filter_lt_of_lt_right", "code": "theorem Ioc_filter_lt_of_lt_right {a b c : \u03b1} [DecidablePred (\u00b7 < c)] (h : b < c) :\n    (Ioc a b).filter (\u00b7 < c) = Ioc a b", "start": [363, 1], "end": [365, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic_filter_lt_of_lt_right", "code": "theorem Iic_filter_lt_of_lt_right {\u03b1} [Preorder \u03b1] [LocallyFiniteOrderBot \u03b1] {a c : \u03b1}\n    [DecidablePred (\u00b7 < c)] (h : a < c) : (Iic a).filter (\u00b7 < c) = Iic a", "start": [368, 1], "end": [370, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_lt_lt_eq_Ioo", "code": "theorem filter_lt_lt_eq_Ioo [DecidablePred fun j => a < j \u2227 j < b] :\n    (univ.filter fun j => a < j \u2227 j < b) = Ioo a b", "start": [375, 1], "end": [378, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_lt_le_eq_Ioc", "code": "theorem filter_lt_le_eq_Ioc [DecidablePred fun j => a < j \u2227 j \u2264 b] :\n    (univ.filter fun j => a < j \u2227 j \u2264 b) = Ioc a b", "start": [381, 1], "end": [384, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_le_lt_eq_Ico", "code": "theorem filter_le_lt_eq_Ico [DecidablePred fun j => a \u2264 j \u2227 j < b] :\n    (univ.filter fun j => a \u2264 j \u2227 j < b) = Ico a b", "start": [387, 1], "end": [390, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_le_le_eq_Icc", "code": "theorem filter_le_le_eq_Icc [DecidablePred fun j => a \u2264 j \u2227 j \u2264 b] :\n    (univ.filter fun j => a \u2264 j \u2227 j \u2264 b) = Icc a b", "start": [393, 1], "end": [396, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_Ici", "code": "@[simp] lemma nonempty_Ici : (Ici a).Nonempty := \u27e8a, mem_Ici.2 le_rfl\u27e9", "start": [405, 1], "end": [405, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.nonempty_Ioi", "code": "@[simp] lemma nonempty_Ioi : (Ioi a).Nonempty \u2194 \u00ac IsMax a := by simp [Finset.Nonempty]", "start": [406, 1], "end": [406, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Icc_subset_Ici_self", "code": "theorem Icc_subset_Ici_self : Icc a b \u2286 Ici a", "start": [408, 1], "end": [409, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ici_self", "code": "theorem Ico_subset_Ici_self : Ico a b \u2286 Ici a", "start": [412, 1], "end": [413, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ioi_self", "code": "theorem Ioc_subset_Ioi_self : Ioc a b \u2286 Ioi a", "start": [416, 1], "end": [417, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ioi_self", "code": "theorem Ioo_subset_Ioi_self : Ioo a b \u2286 Ioi a", "start": [420, 1], "end": [421, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Ici_self", "code": "theorem Ioc_subset_Ici_self : Ioc a b \u2286 Ici a", "start": [424, 1], "end": [425, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Ici_self", "code": "theorem Ioo_subset_Ici_self : Ioo a b \u2286 Ici a", "start": [428, 1], "end": [429, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_Iic", "code": "@[simp] lemma nonempty_Iic : (Iic a).Nonempty := \u27e8a, mem_Iic.2 le_rfl\u27e9", "start": [438, 1], "end": [438, 71], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.nonempty_Iio", "code": "@[simp] lemma nonempty_Iio : (Iio a).Nonempty \u2194 \u00ac IsMin a := by simp [Finset.Nonempty]", "start": [439, 1], "end": [439, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Icc_subset_Iic_self", "code": "theorem Icc_subset_Iic_self : Icc a b \u2286 Iic b", "start": [441, 1], "end": [442, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_subset_Iic_self", "code": "theorem Ioc_subset_Iic_self : Ioc a b \u2286 Iic b", "start": [445, 1], "end": [446, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Iio_self", "code": "theorem Ico_subset_Iio_self : Ico a b \u2286 Iio b", "start": [449, 1], "end": [450, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Iio_self", "code": "theorem Ioo_subset_Iio_self : Ioo a b \u2286 Iio b", "start": [453, 1], "end": [454, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Iic_self", "code": "theorem Ico_subset_Iic_self : Ico a b \u2286 Iic b", "start": [457, 1], "end": [458, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_subset_Iic_self", "code": "theorem Ioo_subset_Iic_self : Ioo a b \u2286 Iic b", "start": [461, 1], "end": [462, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioi_subset_Ici_self", "code": "theorem Ioi_subset_Ici_self : Ioi a \u2286 Ici a", "start": [473, 1], "end": [474, 53], "kind": "commanddeclaration"}, {"full_name": "BddBelow.finite", "code": "theorem _root_.BddBelow.finite {s : Set \u03b1} (hs : BddBelow s) : s.Finite", "start": [477, 1], "end": [479, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.not_bddBelow", "code": "theorem _root_.Set.Infinite.not_bddBelow {s : Set \u03b1} : s.Infinite \u2192 \u00acBddBelow s", "start": [482, 1], "end": [483, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_lt_eq_Ioi", "code": "theorem filter_lt_eq_Ioi [DecidablePred ((\u00b7 < \u00b7) a)] : univ.filter ((\u00b7 < \u00b7) a) = Ioi a", "start": [488, 1], "end": [490, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_le_eq_Ici", "code": "theorem filter_le_eq_Ici [DecidablePred ((\u00b7 \u2264 \u00b7) a)] : univ.filter ((\u00b7 \u2264 \u00b7) a) = Ici a", "start": [493, 1], "end": [495, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio_subset_Iic_self", "code": "theorem Iio_subset_Iic_self : Iio a \u2286 Iic a", "start": [504, 1], "end": [505, 53], "kind": "commanddeclaration"}, {"full_name": "BddAbove.finite", "code": "theorem _root_.BddAbove.finite {s : Set \u03b1} (hs : BddAbove s) : s.Finite", "start": [508, 1], "end": [509, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.not_bddAbove", "code": "theorem _root_.Set.Infinite.not_bddAbove {s : Set \u03b1} : s.Infinite \u2192 \u00acBddAbove s", "start": [512, 1], "end": [513, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_gt_eq_Iio", "code": "theorem filter_gt_eq_Iio [DecidablePred (\u00b7 < a)] : univ.filter (\u00b7 < a) = Iio a", "start": [518, 1], "end": [520, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.filter_ge_eq_Iic", "code": "theorem filter_ge_eq_Iic [DecidablePred (\u00b7 \u2264 a)] : univ.filter (\u00b7 \u2264 a) = Iic a", "start": [523, 1], "end": [525, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.disjoint_Ioi_Iio", "code": "theorem disjoint_Ioi_Iio (a : \u03b1) : Disjoint (Ioi a) (Iio a)", "start": [532, 1], "end": [533, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_self", "code": "@[simp]\ntheorem Icc_self (a : \u03b1) : Icc a a = {a}", "start": [542, 1], "end": [543, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_singleton_iff", "code": "@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} \u2194 a = c \u2227 b = c", "start": [546, 1], "end": [548, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_disjoint_Ico_consecutive", "code": "theorem Ico_disjoint_Ico_consecutive (a b c : \u03b1) : Disjoint (Ico a b) (Ico b c)", "start": [551, 1], "end": [552, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_erase_left", "code": "@[simp]\ntheorem Icc_erase_left (a b : \u03b1) : (Icc a b).erase a = Ioc a b", "start": [559, 1], "end": [560, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_erase_right", "code": "@[simp]\ntheorem Icc_erase_right (a b : \u03b1) : (Icc a b).erase b = Ico a b", "start": [563, 1], "end": [564, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_erase_left", "code": "@[simp]\ntheorem Ico_erase_left (a b : \u03b1) : (Ico a b).erase a = Ioo a b", "start": [567, 1], "end": [568, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_erase_right", "code": "@[simp]\ntheorem Ioc_erase_right (a b : \u03b1) : (Ioc a b).erase b = Ioo a b", "start": [571, 1], "end": [572, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_diff_both", "code": "@[simp]\ntheorem Icc_diff_both (a b : \u03b1) : Icc a b \\ {a, b} = Ioo a b", "start": [575, 1], "end": [576, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_insert_right", "code": "@[simp]\ntheorem Ico_insert_right (h : a \u2264 b) : insert b (Ico a b) = Icc a b", "start": [579, 1], "end": [581, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_insert_left", "code": "@[simp]\ntheorem Ioc_insert_left (h : a \u2264 b) : insert a (Ioc a b) = Icc a b", "start": [584, 1], "end": [586, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_insert_left", "code": "@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b", "start": [589, 1], "end": [591, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_insert_right", "code": "@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b", "start": [594, 1], "end": [596, 101], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_diff_Ico_self", "code": "@[simp]\ntheorem Icc_diff_Ico_self (h : a \u2264 b) : Icc a b \\ Ico a b = {b}", "start": [599, 1], "end": [600, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_diff_Ioc_self", "code": "@[simp]\ntheorem Icc_diff_Ioc_self (h : a \u2264 b) : Icc a b \\ Ioc a b = {a}", "start": [603, 1], "end": [604, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_diff_Ioo_self", "code": "@[simp]\ntheorem Icc_diff_Ioo_self (h : a \u2264 b) : Icc a b \\ Ioo a b = {a, b}", "start": [607, 1], "end": [608, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_diff_Ioo_self", "code": "@[simp]\ntheorem Ico_diff_Ioo_self (h : a < b) : Ico a b \\ Ioo a b = {a}", "start": [611, 1], "end": [612, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_diff_Ioo_self", "code": "@[simp]\ntheorem Ioc_diff_Ioo_self (h : a < b) : Ioc a b \\ Ioo a b = {b}", "start": [615, 1], "end": [616, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_inter_Ico_consecutive", "code": "@[simp]\ntheorem Ico_inter_Ico_consecutive (a b c : \u03b1) : Ico a b \u2229 Ico b c = \u2205", "start": [619, 1], "end": [621, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_cons_Ico", "code": "theorem Icc_eq_cons_Ico (h : a \u2264 b) : Icc a b = (Ico a b).cons b right_not_mem_Ico", "start": [628, 1], "end": [630, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_eq_cons_Ioc", "code": "theorem Icc_eq_cons_Ioc (h : a \u2264 b) : Icc a b = (Ioc a b).cons a left_not_mem_Ioc", "start": [633, 1], "end": [635, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_eq_cons_Ioo", "code": "theorem Ioc_eq_cons_Ioo (h : a < b) : Ioc a b = (Ioo a b).cons b right_not_mem_Ioo", "start": [638, 1], "end": [640, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_eq_cons_Ioo", "code": "theorem Ico_eq_cons_Ioo (h : a < b) : Ico a b = (Ioo a b).cons a left_not_mem_Ioo", "start": [643, 1], "end": [645, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_le_left", "code": "theorem Ico_filter_le_left {a b : \u03b1} [DecidablePred (\u00b7 \u2264 a)] (hab : a < b) :\n    ((Ico a b).filter fun x => x \u2264 a) = {a}", "start": [648, 1], "end": [652, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ico_eq_card_Icc_sub_one", "code": "theorem card_Ico_eq_card_Icc_sub_one (a b : \u03b1) : (Ico a b).card = (Icc a b).card - 1", "start": [655, 1], "end": [660, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioc_eq_card_Icc_sub_one", "code": "theorem card_Ioc_eq_card_Icc_sub_one (a b : \u03b1) : (Ioc a b).card = (Icc a b).card - 1", "start": [663, 1], "end": [664, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioo_eq_card_Ico_sub_one", "code": "theorem card_Ioo_eq_card_Ico_sub_one (a b : \u03b1) : (Ioo a b).card = (Ico a b).card - 1", "start": [667, 1], "end": [672, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioo_eq_card_Ioc_sub_one", "code": "theorem card_Ioo_eq_card_Ioc_sub_one (a b : \u03b1) : (Ioo a b).card = (Ioc a b).card - 1", "start": [675, 1], "end": [676, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioo_eq_card_Icc_sub_two", "code": "theorem card_Ioo_eq_card_Icc_sub_two (a b : \u03b1) : (Ioo a b).card = (Icc a b).card - 2", "start": [679, 1], "end": [681, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Ici_erase", "code": "@[simp]\ntheorem Ici_erase [DecidableEq \u03b1] (a : \u03b1) : (Ici a).erase a = Ioi a", "start": [694, 1], "end": [697, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioi_insert", "code": "@[simp]\ntheorem Ioi_insert [DecidableEq \u03b1] (a : \u03b1) : insert a (Ioi a) = Ici a", "start": [700, 1], "end": [703, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_Ioi_self", "code": "theorem not_mem_Ioi_self {b : \u03b1} : b \u2209 Ioi b", "start": [708, 1], "end": [708, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.Ici_eq_cons_Ioi", "code": "theorem Ici_eq_cons_Ioi (a : \u03b1) : Ici a = (Ioi a).cons a not_mem_Ioi_self", "start": [712, 1], "end": [714, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Ioi_eq_card_Ici_sub_one", "code": "theorem card_Ioi_eq_card_Ici_sub_one (a : \u03b1) : (Ioi a).card = (Ici a).card - 1", "start": [717, 1], "end": [718, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic_erase", "code": "@[simp]\ntheorem Iic_erase [DecidableEq \u03b1] (b : \u03b1) : (Iic b).erase b = Iio b", "start": [727, 1], "end": [730, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio_insert", "code": "@[simp]\ntheorem Iio_insert [DecidableEq \u03b1] (b : \u03b1) : insert b (Iio b) = Iic b", "start": [733, 1], "end": [736, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_Iio_self", "code": "theorem not_mem_Iio_self {b : \u03b1} : b \u2209 Iio b", "start": [741, 1], "end": [741, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.Iic_eq_cons_Iio", "code": "theorem Iic_eq_cons_Iio (b : \u03b1) : Iic b = (Iio b).cons b not_mem_Iio_self", "start": [745, 1], "end": [747, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.card_Iio_eq_card_Iic_sub_one", "code": "theorem card_Iio_eq_card_Iic_sub_one (a : \u03b1) : (Iio a).card = (Iic a).card - 1", "start": [750, 1], "end": [751, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_Iic", "code": "lemma sup'_Iic (a : \u03b1) : (Iic a).sup' nonempty_Iic id = a :=\n  le_antisymm (sup'_le _ _ fun _ \u21a6 mem_Iic.1) <| le_sup' (f := id) <| mem_Iic.2 <| le_refl a", "start": [762, 1], "end": [763, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.sup_Iic", "code": "@[simp] lemma sup_Iic [OrderBot \u03b1] (a : \u03b1) : (Iic a).sup id = a :=\n  le_antisymm (Finset.sup_le fun _ \u21a6 mem_Iic.1) <| le_sup (f := id) <| mem_Iic.2 <| le_refl a", "start": [765, 1], "end": [766, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inf'_Ici", "code": "lemma inf'_Ici (a : \u03b1) : (Ici a).inf' nonempty_Ici id = a :=\n  ge_antisymm (le_inf' _ _ fun _ \u21a6 mem_Ici.1) <| inf'_le (f := id) <| mem_Ici.2 <| le_refl a", "start": [773, 1], "end": [774, 93], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.inf_Ici", "code": "@[simp] lemma inf_Ici [OrderTop \u03b1] (a : \u03b1) : (Ici a).inf id = a :=\n  le_antisymm (inf_le (f := id) <| mem_Ici.2 <| le_refl a) <| Finset.le_inf fun _ \u21a6 mem_Ici.1", "start": [776, 1], "end": [777, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Ico_subset_Ico_iff", "code": "theorem Ico_subset_Ico_iff {a\u2081 b\u2081 a\u2082 b\u2082 : \u03b1} (h : a\u2081 < b\u2081) :\n    Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082", "start": [789, 1], "end": [791, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_union_Ico_eq_Ico", "code": "theorem Ico_union_Ico_eq_Ico {a b c : \u03b1} (hab : a \u2264 b) (hbc : b \u2264 c) :\n    Ico a b \u222a Ico b c = Ico a c", "start": [794, 1], "end": [796, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioc_union_Ioc_eq_Ioc", "code": "@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc {a b c : \u03b1} (h\u2081 : a \u2264 b) (h\u2082 : b \u2264 c) :\n    Ioc a b \u222a Ioc b c = Ioc a c", "start": [799, 1], "end": [802, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_subset_Ico_union_Ico", "code": "theorem Ico_subset_Ico_union_Ico {a b c : \u03b1} : Ico a c \u2286 Ico a b \u222a Ico b c", "start": [805, 1], "end": [807, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_union_Ico'", "code": "theorem Ico_union_Ico' {a b c d : \u03b1} (hcb : c \u2264 b) (had : a \u2264 d) :\n    Ico a b \u222a Ico c d = Ico (min a c) (max b d)", "start": [810, 1], "end": [812, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_union_Ico", "code": "theorem Ico_union_Ico {a b c d : \u03b1} (h\u2081 : min a b \u2264 max c d) (h\u2082 : min c d \u2264 max a b) :\n    Ico a b \u222a Ico c d = Ico (min a c) (max b d)", "start": [815, 1], "end": [817, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_inter_Ico", "code": "theorem Ico_inter_Ico {a b c d : \u03b1} : Ico a b \u2229 Ico c d = Ico (max a c) (min b d)", "start": [820, 1], "end": [822, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_lt", "code": "@[simp]\ntheorem Ico_filter_lt (a b c : \u03b1) : ((Ico a b).filter fun x => x < c) = Ico a (min b c)", "start": [825, 1], "end": [829, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_filter_le", "code": "@[simp]\ntheorem Ico_filter_le (a b c : \u03b1) : ((Ico a b).filter fun x => c \u2264 x) = Ico (max a c) b", "start": [832, 1], "end": [836, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioo_filter_lt", "code": "@[simp]\ntheorem Ioo_filter_lt (a b c : \u03b1) : (Ioo a b).filter (\u00b7 < c) = Ioo a (min b c)", "start": [839, 1], "end": [842, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.Iio_filter_lt", "code": "@[simp]\ntheorem Iio_filter_lt {\u03b1} [LinearOrder \u03b1] [LocallyFiniteOrderBot \u03b1] (a b : \u03b1) :\n    (Iio a).filter (\u00b7 < b) = Iio (min a b)", "start": [845, 1], "end": [849, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_diff_Ico_left", "code": "@[simp]\ntheorem Ico_diff_Ico_left (a b c : \u03b1) : Ico a b \\ Ico a c = Ico (max a c) b", "start": [852, 1], "end": [859, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.Ico_diff_Ico_right", "code": "@[simp]\ntheorem Ico_diff_Ico_right (a b c : \u03b1) : Ico a b \\ Ico c b = Ico a (min b c)", "start": [862, 1], "end": [869, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_gt", "code": "theorem _root_.Set.Infinite.exists_gt (hs : s.Infinite) : \u2200 a, \u2203 b \u2208 s, a < b", "start": [877, 1], "end": [878, 37], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_iff_exists_gt", "code": "theorem _root_.Set.infinite_iff_exists_gt [Nonempty \u03b1] : s.Infinite \u2194 \u2200 a, \u2203 b \u2208 s, a < b", "start": [881, 1], "end": [882, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.exists_lt", "code": "theorem _root_.Set.Infinite.exists_lt (hs : s.Infinite) : \u2200 a, \u2203 b \u2208 s, b < a", "start": [890, 1], "end": [891, 37], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_iff_exists_lt", "code": "theorem _root_.Set.infinite_iff_exists_lt [Nonempty \u03b1] : s.Infinite \u2194 \u2200 a, \u2203 b \u2208 s, b < a", "start": [894, 1], "end": [895, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.Ioi_disjUnion_Iio", "code": "theorem Ioi_disjUnion_Iio (a : \u03b1) :\n    (Ioi a).disjUnion (Iio a) (disjoint_Ioi_Iio a) = ({a} : Finset \u03b1)\u1d9c", "start": [902, 1], "end": [905, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_toDual", "code": "theorem uIcc_toDual (a b : \u03b1) : [[toDual a, toDual b]] = [[a, b]].map toDual.toEmbedding", "start": [914, 1], "end": [915, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_of_le", "code": "@[simp]\ntheorem uIcc_of_le (h : a \u2264 b) : [[a, b]] = Icc a b", "start": [918, 1], "end": [920, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_of_ge", "code": "@[simp]\ntheorem uIcc_of_ge (h : b \u2264 a) : [[a, b]] = Icc b a", "start": [923, 1], "end": [925, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_comm", "code": "theorem uIcc_comm (a b : \u03b1) : [[a, b]] = [[b, a]]", "start": [928, 1], "end": [929, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_self", "code": "theorem uIcc_self : [[a, a]] = {a}", "start": [934, 1], "end": [934, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.nonempty_uIcc", "code": "@[simp]\ntheorem nonempty_uIcc : Finset.Nonempty [[a, b]]", "start": [937, 1], "end": [939, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_uIcc", "code": "theorem Icc_subset_uIcc : Icc a b \u2286 [[a, b]]", "start": [942, 1], "end": [943, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_subset_uIcc'", "code": "theorem Icc_subset_uIcc' : Icc b a \u2286 [[a, b]]", "start": [946, 1], "end": [947, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.left_mem_uIcc", "code": "theorem left_mem_uIcc : a \u2208 [[a, b]]", "start": [952, 1], "end": [953, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.right_mem_uIcc", "code": "theorem right_mem_uIcc : b \u2208 [[a, b]]", "start": [958, 1], "end": [959, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_uIcc_of_le", "code": "theorem mem_uIcc_of_le (ha : a \u2264 x) (hb : x \u2264 b) : x \u2208 [[a, b]]", "start": [962, 1], "end": [963, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_uIcc_of_ge", "code": "theorem mem_uIcc_of_ge (hb : b \u2264 x) (ha : x \u2264 a) : x \u2208 [[a, b]]", "start": [966, 1], "end": [967, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc", "code": "theorem uIcc_subset_uIcc (h\u2081 : a\u2081 \u2208 [[a\u2082, b\u2082]]) (h\u2082 : b\u2081 \u2208 [[a\u2082, b\u2082]]) :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]]", "start": [970, 1], "end": [973, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_Icc", "code": "theorem uIcc_subset_Icc (ha : a\u2081 \u2208 Icc a\u2082 b\u2082) (hb : b\u2081 \u2208 Icc a\u2082 b\u2082) : [[a\u2081, b\u2081]] \u2286 Icc a\u2082 b\u2082", "start": [976, 1], "end": [978, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_iff_mem", "code": "theorem uIcc_subset_uIcc_iff_mem : [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 a\u2081 \u2208 [[a\u2082, b\u2082]] \u2227 b\u2081 \u2208 [[a\u2082, b\u2082]]", "start": [981, 1], "end": [982, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_iff_le'", "code": "theorem uIcc_subset_uIcc_iff_le' :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 a\u2082 \u2293 b\u2082 \u2264 a\u2081 \u2293 b\u2081 \u2227 a\u2081 \u2294 b\u2081 \u2264 a\u2082 \u2294 b\u2082", "start": [985, 1], "end": [987, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_right", "code": "theorem uIcc_subset_uIcc_right (h : x \u2208 [[a, b]]) : [[x, b]] \u2286 [[a, b]]", "start": [990, 1], "end": [991, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_left", "code": "theorem uIcc_subset_uIcc_left (h : x \u2208 [[a, b]]) : [[a, x]] \u2286 [[a, b]]", "start": [994, 1], "end": [995, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_mem_uIcc_of_mem_uIcc", "code": "theorem eq_of_mem_uIcc_of_mem_uIcc : a \u2208 [[b, c]] \u2192 b \u2208 [[a, c]] \u2192 a = b", "start": [1004, 1], "end": [1006, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.eq_of_mem_uIcc_of_mem_uIcc'", "code": "theorem eq_of_mem_uIcc_of_mem_uIcc' : b \u2208 [[a, c]] \u2192 c \u2208 [[a, b]] \u2192 b = c", "start": [1009, 1], "end": [1011, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_injective_right", "code": "theorem uIcc_injective_right (a : \u03b1) : Injective fun b => [[b, a]]", "start": [1014, 1], "end": [1016, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_injective_left", "code": "theorem uIcc_injective_left (a : \u03b1) : Injective (uIcc a)", "start": [1019, 1], "end": [1020, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Icc_min_max", "code": "theorem Icc_min_max : Icc (min a b) (max a b) = [[a, b]]", "start": [1029, 1], "end": [1030, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_of_not_le", "code": "theorem uIcc_of_not_le (h : \u00aca \u2264 b) : [[a, b]] = Icc b a", "start": [1033, 1], "end": [1034, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_of_not_ge", "code": "theorem uIcc_of_not_ge (h : \u00acb \u2264 a) : [[a, b]] = Icc a b", "start": [1037, 1], "end": [1038, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_eq_union", "code": "theorem uIcc_eq_union : [[a, b]] = Icc a b \u222a Icc b a", "start": [1041, 1], "end": [1044, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_uIcc'", "code": "theorem mem_uIcc' : a \u2208 [[b, c]] \u2194 b \u2264 a \u2227 a \u2264 c \u2228 c \u2264 a \u2227 a \u2264 b", "start": [1047, 1], "end": [1047, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_uIcc_of_lt", "code": "theorem not_mem_uIcc_of_lt : c < a \u2192 c < b \u2192 c \u2209 [[a, b]]", "start": [1050, 1], "end": [1052, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.not_mem_uIcc_of_gt", "code": "theorem not_mem_uIcc_of_gt : a < c \u2192 b < c \u2192 c \u2209 [[a, b]]", "start": [1055, 1], "end": [1057, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_iff_le", "code": "theorem uIcc_subset_uIcc_iff_le :\n    [[a\u2081, b\u2081]] \u2286 [[a\u2082, b\u2082]] \u2194 min a\u2082 b\u2082 \u2264 min a\u2081 b\u2081 \u2227 max a\u2081 b\u2081 \u2264 max a\u2082 b\u2082", "start": [1060, 1], "end": [1062, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.uIcc_subset_uIcc_union_uIcc", "code": "theorem uIcc_subset_uIcc_union_uIcc : [[a, c]] \u2286 [[a, b]] \u222a [[b, c]]", "start": [1065, 1], "end": [1069, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_left_Icc", "code": "@[simp]\ntheorem map_add_left_Icc (a b c : \u03b1) :\n    (Icc a b).map (addLeftEmbedding c) = Icc (c + a) (c + b)", "start": [1078, 1], "end": [1082, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_right_Icc", "code": "@[simp]\ntheorem map_add_right_Icc (a b c : \u03b1) :\n    (Icc a b).map (addRightEmbedding c) = Icc (a + c) (b + c)", "start": [1085, 1], "end": [1089, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_left_Ico", "code": "@[simp]\ntheorem map_add_left_Ico (a b c : \u03b1) :\n    (Ico a b).map (addLeftEmbedding c) = Ico (c + a) (c + b)", "start": [1092, 1], "end": [1096, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_right_Ico", "code": "@[simp]\ntheorem map_add_right_Ico (a b c : \u03b1) :\n    (Ico a b).map (addRightEmbedding c) = Ico (a + c) (b + c)", "start": [1099, 1], "end": [1103, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_left_Ioc", "code": "@[simp]\ntheorem map_add_left_Ioc (a b c : \u03b1) :\n    (Ioc a b).map (addLeftEmbedding c) = Ioc (c + a) (c + b)", "start": [1106, 1], "end": [1110, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_right_Ioc", "code": "@[simp]\ntheorem map_add_right_Ioc (a b c : \u03b1) :\n    (Ioc a b).map (addRightEmbedding c) = Ioc (a + c) (b + c)", "start": [1113, 1], "end": [1117, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_left_Ioo", "code": "@[simp]\ntheorem map_add_left_Ioo (a b c : \u03b1) :\n    (Ioo a b).map (addLeftEmbedding c) = Ioo (c + a) (c + b)", "start": [1120, 1], "end": [1124, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.map_add_right_Ioo", "code": "@[simp]\ntheorem map_add_right_Ioo (a b c : \u03b1) :\n    (Ioo a b).map (addRightEmbedding c) = Ioo (a + c) (b + c)", "start": [1127, 1], "end": [1131, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_left_Icc", "code": "@[simp]\ntheorem image_add_left_Icc (a b c : \u03b1) : (Icc a b).image ((\u00b7 + \u00b7) c) = Icc (c + a) (c + b)", "start": [1136, 1], "end": [1138, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_left_Ico", "code": "@[simp]\ntheorem image_add_left_Ico (a b c : \u03b1) : (Ico a b).image ((\u00b7 + \u00b7) c) = Ico (c + a) (c + b)", "start": [1141, 1], "end": [1143, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_left_Ioc", "code": "@[simp]\ntheorem image_add_left_Ioc (a b c : \u03b1) : (Ioc a b).image ((\u00b7 + \u00b7) c) = Ioc (c + a) (c + b)", "start": [1146, 1], "end": [1148, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_left_Ioo", "code": "@[simp]\ntheorem image_add_left_Ioo (a b c : \u03b1) : (Ioo a b).image ((\u00b7 + \u00b7) c) = Ioo (c + a) (c + b)", "start": [1151, 1], "end": [1153, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_right_Icc", "code": "@[simp]\ntheorem image_add_right_Icc (a b c : \u03b1) : (Icc a b).image (\u00b7 + c) = Icc (a + c) (b + c)", "start": [1156, 1], "end": [1158, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_right_Ico", "code": "theorem image_add_right_Ico (a b c : \u03b1) : (Ico a b).image (\u00b7 + c) = Ico (a + c) (b + c)", "start": [1161, 1], "end": [1162, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_right_Ioc", "code": "theorem image_add_right_Ioc (a b c : \u03b1) : (Ioc a b).image (\u00b7 + c) = Ioc (a + c) (b + c)", "start": [1165, 1], "end": [1166, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.image_add_right_Ioo", "code": "theorem image_add_right_Ioo (a b c : \u03b1) : (Ioo a b).image (\u00b7 + c) = Ioo (a + c) (b + c)", "start": [1169, 1], "end": [1170, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_prod_Ioi_mul_eq_prod_prod_off_diag", "code": "@[to_additive]\ntheorem prod_prod_Ioi_mul_eq_prod_prod_off_diag [Fintype \u03b9] [LinearOrder \u03b9]\n    [LocallyFiniteOrderTop \u03b9] [LocallyFiniteOrderBot \u03b9] [CommMonoid \u03b1] (f : \u03b9 \u2192 \u03b9 \u2192 \u03b1) :\n    (\u220f i, \u220f j in Ioi i, f j i * f i j) = \u220f i, \u220f j in {i}\u1d9c, f j i", "start": [1175, 1], "end": [1182, 87], "kind": "commanddeclaration"}, {"full_name": "transGen_wcovby_of_le", "code": "lemma transGen_wcovby_of_le [Preorder \u03b1] [LocallyFiniteOrder \u03b1] {x y : \u03b1} (hxy : x \u2264 y) :\n    TransGen (\u00b7 \u2a7f \u00b7) x y := by\n  have : (Ico x y).card < (Icc x y).card := card_lt_card <|\n    \u27e8Ico_subset_Icc_self, not_subset.mpr \u27e8y, \u27e8right_mem_Icc.mpr hxy, right_not_mem_Ico\u27e9\u27e9\u27e9\n  by_cases hxy' : y \u2264 x\n  \u00b7 exact .single <| wcovby_of_le_of_le hxy hxy'\n  \n  \u00b7 have h_non : (Ico x y).Nonempty := \u27e8x, mem_Ico.mpr \u27e8le_rfl, lt_of_le_not_le hxy hxy'\u27e9\u27e9\n    obtain \u27e8z, z_mem, hz\u27e9 := (Ico x y).exists_maximal h_non\n    have z_card : (Icc x z).card <(Icc x y).card := calc\n      (Icc x z).card \u2264 (Ico x y).card :=\n        card_le_of_subset <| Icc_subset_Ico_right (mem_Ico.mp z_mem).2\n      _              < (Icc x y).card := this\n    have h\u2081 := transGen_wcovby_of_le (mem_Ico.mp z_mem).1\n    have h\u2082 : z \u2a7f y := by\n      refine \u27e8(mem_Ico.mp z_mem).2.le, fun c hzc hcy \u21a6 hz c ?_ hzc\u27e9\n      exact mem_Ico.mpr <| \u27e8(mem_Ico.mp z_mem).1.trans hzc.le, hcy\u27e9\n    exact .tail h\u2081 h\u2082\ntermination_by _ => (Icc x y).card", "start": [1195, 1], "end": [1218, 35], "kind": "mathlibtacticlemma"}, {"full_name": "le_iff_transGen_wcovby", "code": "lemma le_iff_transGen_wcovby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] {x y : \u03b1} :\n    x \u2264 y \u2194 TransGen (\u00b7 \u2a7f \u00b7) x y := by\n  refine \u27e8transGen_wcovby_of_le, fun h \u21a6 ?_\u27e9\n  induction h with\n  | single h => exact h.le\n  | tail _ h\u2081 h\u2082 => exact h\u2082.trans h\u2081.le", "start": [1220, 1], "end": [1226, 41], "kind": "mathlibtacticlemma"}, {"full_name": "le_iff_reflTransGen_covby", "code": "lemma le_iff_reflTransGen_covby [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] {x y : \u03b1} :\n    x \u2264 y \u2194 ReflTransGen (\u00b7 \u22d6 \u00b7) x y := by\n  rw [le_iff_transGen_wcovby, wcovby_eq_reflGen_covby, transGen_reflGen]", "start": [1228, 1], "end": [1231, 73], "kind": "mathlibtacticlemma"}, {"full_name": "transGen_covby_of_lt", "code": "lemma transGen_covby_of_lt [Preorder \u03b1] [LocallyFiniteOrder \u03b1] {x y : \u03b1} (hxy : x < y) :\n    TransGen (\u00b7 \u22d6 \u00b7) x y := by\n  have h_non : (Ico x y).Nonempty := \u27e8x, mem_Ico.mpr \u27e8le_rfl, hxy\u27e9\u27e9\n  obtain \u27e8z, z_mem, hz\u27e9 := (Ico x y).exists_maximal h_non\n  have z_card : (Ico x z).card < (Ico x y).card := card_lt_card <| ssubset_iff_of_subset\n    (Ico_subset_Ico le_rfl (mem_Ico.mp z_mem).2.le) |>.mpr \u27e8z, z_mem, right_not_mem_Ico\u27e9\n  \n  have hzy : z \u22d6 y := by\n    refine \u27e8(mem_Ico.mp z_mem).2, fun c hc hcy \u21a6 ?_\u27e9\n    exact hz _ (mem_Ico.mpr \u27e8((mem_Ico.mp z_mem).1.trans_lt hc).le, hcy\u27e9) hc\n  by_cases hxz : x < z\n  \n  \u00b7 exact .tail (transGen_covby_of_lt hxz) hzy\n  \n  \u00b7 simp only [lt_iff_le_not_le, not_and, not_not] at hxz\n    exact .single (hzy.of_le_of_lt (hxz (mem_Ico.mp z_mem).1) hxy)\ntermination_by _ => (Ico x y).card", "start": [1234, 1], "end": [1256, 35], "kind": "mathlibtacticlemma"}, {"full_name": "lt_iff_transGen_covby", "code": "lemma lt_iff_transGen_covby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] {x y : \u03b1} :\n    x < y \u2194 TransGen (\u00b7 \u22d6 \u00b7) x y := by\n  refine \u27e8transGen_covby_of_lt, fun h \u21a6 ?_\u27e9\n  induction h with\n  | single hx => exact hx.1\n  | tail _ hb ih => exact ih.trans hb.1", "start": [1258, 1], "end": [1264, 40], "kind": "mathlibtacticlemma"}, {"full_name": "monotone_iff_forall_wcovby", "code": "lemma monotone_iff_forall_wcovby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Monotone f \u2194 \u2200 a b : \u03b1, a \u2a7f b \u2192 f a \u2264 f b := by\n  refine \u27e8fun hf _ _ h \u21a6 hf h.le, fun h a b hab \u21a6 ?_\u27e9\n  simpa [transGen_eq_self (r := ((\u00b7 : \u03b2) \u2264 \u00b7)) transitive_le]\n    using TransGen.lift f h <| le_iff_transGen_wcovby.mp hab", "start": [1268, 1], "end": [1274, 61], "kind": "mathlibtacticlemma"}, {"full_name": "monotone_iff_forall_covby", "code": "lemma monotone_iff_forall_covby [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Monotone f \u2194 \u2200 a b : \u03b1, a \u22d6 b \u2192 f a \u2264 f b := by\n  refine \u27e8fun hf _ _ h \u21a6 hf h.le, fun h a b hab \u21a6 ?_\u27e9\n  simpa [reflTransGen_eq_self (r := ((\u00b7 : \u03b2) \u2264 \u00b7)) IsRefl.reflexive transitive_le]\n    using ReflTransGen.lift f h <| le_iff_reflTransGen_covby.mp hab", "start": [1276, 1], "end": [1282, 68], "kind": "mathlibtacticlemma"}, {"full_name": "strictMono_iff_forall_covby", "code": "lemma strictMono_iff_forall_covby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : StrictMono f \u2194 \u2200 a b : \u03b1, a \u22d6 b \u2192 f a < f b := by\n  refine \u27e8fun hf _ _ h \u21a6 hf h.lt, fun h a b hab \u21a6 ?_\u27e9\n  have := Relation.TransGen.lift f h (a := a) (b := b)\n  rw [\u2190 lt_iff_transGen_covby, transGen_eq_self (@lt_trans \u03b2 _)] at this\n  \u00b7 exact this hab", "start": [1284, 1], "end": [1291, 19], "kind": "mathlibtacticlemma"}, {"full_name": "antitone_iff_forall_wcovby", "code": "lemma antitone_iff_forall_wcovby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Antitone f \u2194 \u2200 a b : \u03b1, a \u2a7f b \u2192 f b \u2264 f a :=\n  monotone_iff_forall_wcovby (\u03b2 := \u03b2\u1d52\u1d48) f", "start": [1293, 1], "end": [1297, 42], "kind": "mathlibtacticlemma"}, {"full_name": "antitone_iff_forall_covby", "code": "lemma antitone_iff_forall_covby [PartialOrder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Antitone f \u2194 \u2200 a b : \u03b1, a \u22d6 b \u2192 f b \u2264 f a :=\n  monotone_iff_forall_covby (\u03b2 := \u03b2\u1d52\u1d48) f", "start": [1299, 1], "end": [1303, 41], "kind": "mathlibtacticlemma"}, {"full_name": "strictAnti_iff_forall_covby", "code": "lemma strictAnti_iff_forall_covby [Preorder \u03b1] [LocallyFiniteOrder \u03b1] [Preorder \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : StrictAnti f \u2194 \u2200 a b : \u03b1, a \u22d6 b \u2192 f b < f a :=\n  strictMono_iff_forall_covby (\u03b2 := \u03b2\u1d52\u1d48) f", "start": [1305, 1], "end": [1309, 43], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean", "Mathlib/GroupTheory/Subsemigroup/Center.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.centralizer", "code": "@[to_additive addCentralizer \" The centralizer of a subset of an additive magma. \"]\ndef centralizer [Mul M] : Set M :=\n  { c | \u2200 m \u2208 S, m * c = c * m }", "start": [32, 1], "end": [35, 33], "kind": "commanddeclaration"}, {"full_name": "Set.mem_centralizer_iff", "code": "@[to_additive mem_addCentralizer]\ntheorem mem_centralizer_iff [Mul M] {c : M} : c \u2208 centralizer S \u2194 \u2200 m \u2208 S, m * c = c * m", "start": [41, 1], "end": [43, 10], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemCentralizer", "code": "@[to_additive decidableMemAddCentralizer]\ninstance decidableMemCentralizer [Mul M] [\u2200 a : M, Decidable <| \u2200 b \u2208 S, b * a = a * b] :\n    DecidablePred (\u00b7 \u2208 centralizer S) := fun _ => decidable_of_iff' _ mem_centralizer_iff", "start": [47, 1], "end": [49, 90], "kind": "commanddeclaration"}, {"full_name": "Set.one_mem_centralizer", "code": "@[to_additive (attr := simp) zero_mem_addCentralizer]\ntheorem one_mem_centralizer [MulOneClass M] : (1 : M) \u2208 centralizer S", "start": [55, 1], "end": [57, 29], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mem_centralizer", "code": "@[simp]\ntheorem zero_mem_centralizer [MulZeroClass M] : (0 : M) \u2208 centralizer S", "start": [61, 1], "end": [63, 29], "kind": "commanddeclaration"}, {"full_name": "Set.mul_mem_centralizer", "code": "@[to_additive (attr := simp) add_mem_addCentralizer]\ntheorem mul_mem_centralizer [Semigroup M] (ha : a \u2208 centralizer S) (hb : b \u2208 centralizer S) :\n    a * b \u2208 centralizer S", "start": [68, 1], "end": [71, 61], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_centralizer", "code": "@[to_additive (attr := simp) neg_mem_addCentralizer]\ntheorem inv_mem_centralizer [Group M] (ha : a \u2208 centralizer S) : a\u207b\u00b9 \u2208 centralizer S", "start": [75, 1], "end": [77, 75], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_centralizer", "code": "@[simp]\ntheorem add_mem_centralizer [Distrib M] (ha : a \u2208 centralizer S) (hb : b \u2208 centralizer S) :\n    a + b \u2208 centralizer S", "start": [81, 1], "end": [83, 84], "kind": "commanddeclaration"}, {"full_name": "Set.neg_mem_centralizer", "code": "@[simp]\ntheorem neg_mem_centralizer [Mul M] [HasDistribNeg M] (ha : a \u2208 centralizer S) :\n    -a \u2208 centralizer S", "start": [86, 1], "end": [88, 72], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_centralizer\u2080", "code": "@[simp]\ntheorem inv_mem_centralizer\u2080 [GroupWithZero M] (ha : a \u2208 centralizer S) : a\u207b\u00b9 \u2208 centralizer S", "start": [91, 1], "end": [98, 84], "kind": "commanddeclaration"}, {"full_name": "Set.div_mem_centralizer", "code": "@[to_additive (attr := simp) sub_mem_addCentralizer]\ntheorem div_mem_centralizer [Group M] (ha : a \u2208 centralizer S) (hb : b \u2208 centralizer S) :\n    a / b \u2208 centralizer S", "start": [101, 1], "end": [105, 56], "kind": "commanddeclaration"}, {"full_name": "Set.div_mem_centralizer\u2080", "code": "@[simp]\ntheorem div_mem_centralizer\u2080 [GroupWithZero M] (ha : a \u2208 centralizer S) (hb : b \u2208 centralizer S) :\n    a / b \u2208 centralizer S", "start": [109, 1], "end": [113, 57], "kind": "commanddeclaration"}, {"full_name": "Set.centralizer_subset", "code": "@[to_additive addCentralizer_subset]\ntheorem centralizer_subset [Mul M] (h : S \u2286 T) : centralizer T \u2286 centralizer S", "start": [116, 1], "end": [118, 14], "kind": "commanddeclaration"}, {"full_name": "Set.center_subset_centralizer", "code": "@[to_additive addCenter_subset_addCentralizer]\ntheorem center_subset_centralizer [Mul M] (S : Set M) : Set.center M \u2286 S.centralizer", "start": [122, 1], "end": [124, 23], "kind": "commanddeclaration"}, {"full_name": "Set.centralizer_eq_top_iff_subset", "code": "@[to_additive (attr := simp) addCentralizer_eq_top_iff_subset]\ntheorem centralizer_eq_top_iff_subset {s : Set M} [Mul M] :\n    centralizer s = Set.univ \u2194 s \u2286 center M", "start": [128, 1], "end": [131, 95], "kind": "commanddeclaration"}, {"full_name": "Set.centralizer_univ", "code": "@[to_additive (attr := simp) addCentralizer_univ]\ntheorem centralizer_univ [Mul M] : centralizer univ = center M", "start": [137, 1], "end": [139, 77], "kind": "commanddeclaration"}, {"full_name": "Set.centralizer_eq_univ", "code": "@[to_additive (attr := simp) addCentralizer_eq_univ]\ntheorem centralizer_eq_univ [CommSemigroup M] : centralizer S = univ", "start": [145, 1], "end": [147, 64], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.centralizer", "code": "@[to_additive \"The centralizer of a subset of an additive semigroup.\"]\ndef centralizer : Subsemigroup M where\n  carrier := S.centralizer\n  mul_mem' := Set.mul_mem_centralizer", "start": [159, 1], "end": [163, 38], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.coe_centralizer", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_centralizer : \u2191(centralizer S) = S.centralizer", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.mem_centralizer_iff", "code": "@[to_additive]\ntheorem mem_centralizer_iff {z : M} : z \u2208 centralizer S \u2194 \u2200 g \u2208 S, g * z = z * g", "start": [175, 1], "end": [177, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.decidableMemCentralizer", "code": "@[to_additive]\ninstance decidableMemCentralizer (a) [Decidable <| \u2200 b \u2208 S, b * a = a * b] :\n    Decidable (a \u2208 centralizer S) :=\n  decidable_of_iff' _ mem_centralizer_iff", "start": [181, 1], "end": [184, 42], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.center_le_centralizer", "code": "@[to_additive]\ntheorem center_le_centralizer (S) : center M \u2264 centralizer S", "start": [188, 1], "end": [190, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.centralizer_le", "code": "@[to_additive]\ntheorem centralizer_le (h : S \u2286 T) : centralizer T \u2264 centralizer S", "start": [194, 1], "end": [196, 27], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.centralizer_eq_top_iff_subset", "code": "@[to_additive (attr := simp)]\ntheorem centralizer_eq_top_iff_subset {s : Set M} : centralizer s = \u22a4 \u2194 s \u2286 center M", "start": [200, 1], "end": [202, 59], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.centralizer_univ", "code": "@[to_additive (attr := simp)]\ntheorem centralizer_univ : centralizer Set.univ = center M", "start": [207, 1], "end": [209, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Center.lean", "imports": ["Mathlib/GroupTheory/Subsemigroup/Center.lean", "Mathlib/GroupTheory/Submonoid/Operations.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submonoid.center", "code": "@[to_additive\n      \"The center of a monoid `M` is the set of elements that commute with everything in `M`\"]\ndef center : Submonoid M where\n  carrier := Set.center M\n  one_mem' := Set.one_mem_center M\n  mul_mem' := Set.mul_mem_center", "start": [30, 1], "end": [36, 33], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_center", "code": "@[to_additive]\ntheorem coe_center : \u2191(center M) = Set.center M", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center_toSubsemigroup", "code": "@[to_additive (attr := simp) AddSubmonoid.center_toAddSubsemigroup]\ntheorem center_toSubsemigroup : (center M).toSubsemigroup = Subsemigroup.center M", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_center_iff", "code": "@[to_additive]\ntheorem mem_center_iff {z : M} : z \u2208 center M \u2194 \u2200 g, g * z = z * g", "start": [53, 1], "end": [55, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.decidableMemCenter", "code": "@[to_additive]\ninstance decidableMemCenter (a) [Decidable <| \u2200 b : M, b * a = a * b] : Decidable (a \u2208 center M) :=\n  decidable_of_iff' _ mem_center_iff", "start": [59, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center.commMonoid", "code": "instance center.commMonoid : CommMonoid (center M) :=\n  { (center M).toMonoid with\n    mul_comm := fun _ b => Subtype.ext <| b.prop _ }", "start": [65, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center.smulCommClass_left", "code": "instance center.smulCommClass_left : SMulCommClass (center M) M M where\n  smul_comm m x y := (Commute.left_comm (m.prop x) y).symm", "start": [70, 1], "end": [72, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center.smulCommClass_right", "code": "instance center.smulCommClass_right : SMulCommClass M (center M) M :=\n  SMulCommClass.symm _ _ _", "start": [75, 1], "end": [77, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center_eq_top", "code": "@[simp]\ntheorem center_eq_top : center M = \u22a4", "start": [91, 1], "end": [93, 47], "kind": "commanddeclaration"}, {"full_name": "unitsCenterToCenterUnits", "code": "@[to_additive (attr := simps! apply_coe_val)\n  \"For an additive monoid, the units of the center inject into the center of the units.\"]\ndef unitsCenterToCenterUnits [Monoid M] : (Submonoid.center M)\u02e3 \u2192* Submonoid.center (M\u02e3) :=\n  (Units.map (Submonoid.center M).subtype).codRestrict _ <| fun u r \u21a6 Units.ext <| u.1.prop r", "start": [102, 1], "end": [108, 94], "kind": "commanddeclaration"}, {"full_name": "unitsCenterToCenterUnits_injective", "code": "@[to_additive]\ntheorem unitsCenterToCenterUnits_injective [Monoid M] :\n    Function.Injective (unitsCenterToCenterUnits M)", "start": [110, 1], "end": [113, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupRingAction/Basic.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Algebra/Ring/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulSemiringAction", "code": "class MulSemiringAction (M : Type u) (R : Type v) [Monoid M] [Semiring R] extends\n  DistribMulAction M R where\n  \n  smul_one : \u2200 g : M, (g \u2022 (1 : R) : R) = 1\n  \n  smul_mul : \u2200 (g : M) (x y : R), g \u2022 (x * y) = g \u2022 x * g \u2022 y", "start": [34, 1], "end": [42, 62], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toMulDistribMulAction", "code": "instance (priority := 100) MulSemiringAction.toMulDistribMulAction [h : MulSemiringAction M R] :\n    MulDistribMulAction M R :=\n  { h with }", "start": [52, 1], "end": [54, 13], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toRingHom", "code": "@[simps!]\ndef MulSemiringAction.toRingHom [MulSemiringAction M R] (x : M) : R \u2192+* R :=\n  { MulDistribMulAction.toMonoidHom R x, DistribMulAction.toAddMonoidHom R x with }", "start": [57, 1], "end": [60, 84], "kind": "commanddeclaration"}, {"full_name": "toRingHom_injective", "code": "theorem toRingHom_injective [MulSemiringAction M R] [FaithfulSMul M R] :\n    Function.Injective (MulSemiringAction.toRingHom M R)", "start": [64, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toRingEquiv", "code": "@[simps!]\ndef MulSemiringAction.toRingEquiv [MulSemiringAction G R] (x : G) : R \u2243+* R :=\n  { DistribMulAction.toAddEquiv R x, MulSemiringAction.toRingHom G R x with }", "start": [69, 1], "end": [72, 78], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.compHom", "code": "@[reducible]\ndef MulSemiringAction.compHom (f : N \u2192* M) [MulSemiringAction M R] : MulSemiringAction N R :=\n  { DistribMulAction.compHom R f, MulDistribMulAction.compHom R f with }", "start": [81, 1], "end": [85, 73], "kind": "commanddeclaration"}, {"full_name": "smul_inv''", "code": "@[simp]\ntheorem smul_inv'' [MulSemiringAction M F] (x : M) (m : F) : x \u2022 m\u207b\u00b9 = (x \u2022 m)\u207b\u00b9", "start": [96, 1], "end": [100, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Support.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Pi.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Module/Basic.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/Algebra/Group/Pi.lean"], "premises": [{"full_name": "Function.support", "code": "def support [Zero A] (f : \u03b1 \u2192 A) : Set \u03b1 :=\n  { x | f x \u2260 0 }", "start": [36, 1], "end": [38, 18], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport", "code": "@[to_additive existing]\ndef mulSupport (f : \u03b1 \u2192 M) : Set \u03b1 :=\n  { x | f x \u2260 1 }", "start": [41, 1], "end": [44, 18], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_eq_preimage", "code": "@[to_additive]\ntheorem mulSupport_eq_preimage (f : \u03b1 \u2192 M) : mulSupport f = f \u207b\u00b9' {1}\u1d9c", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Function.nmem_mulSupport", "code": "@[to_additive]\ntheorem nmem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2209 mulSupport f \u2194 f x = 1", "start": [53, 1], "end": [55, 10], "kind": "commanddeclaration"}, {"full_name": "Function.compl_mulSupport", "code": "@[to_additive]\ntheorem compl_mulSupport {f : \u03b1 \u2192 M} : (mulSupport f)\u1d9c = { x | f x = 1 }", "start": [59, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "Function.mem_mulSupport", "code": "@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : \u03b1 \u2192 M} {x : \u03b1} : x \u2208 mulSupport f \u2194 f x \u2260 1", "start": [65, 1], "end": [67, 10], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_subset_iff", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : mulSupport f \u2286 s \u2194 \u2200 x, f x \u2260 1 \u2192 x \u2208 s", "start": [71, 1], "end": [73, 10], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_subset_iff'", "code": "@[to_additive]\ntheorem mulSupport_subset_iff' {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f \u2286 s \u2194 \u2200 (x) (_ : x \u2209 s), f x = 1", "start": [77, 1], "end": [80, 38], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_eq_iff", "code": "@[to_additive]\ntheorem mulSupport_eq_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    mulSupport f = s \u2194 (\u2200 x, x \u2208 s \u2192 f x \u2260 1) \u2227 \u2200 x, x \u2209 s \u2192 f x = 1", "start": [84, 1], "end": [88, 40], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_disjoint_iff", "code": "@[to_additive]\ntheorem mulSupport_disjoint_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} :\n    Disjoint (mulSupport f) s \u2194 EqOn f 1 s", "start": [92, 1], "end": [96, 18], "kind": "commanddeclaration"}, {"full_name": "Function.disjoint_mulSupport_iff", "code": "@[to_additive]\ntheorem disjoint_mulSupport_iff {f : \u03b1 \u2192 M} {s : Set \u03b1} : Disjoint s (mulSupport f) \u2194 EqOn f 1 s", "start": [100, 1], "end": [102, 49], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_eq_empty_iff", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_eq_empty_iff {f : \u03b1 \u2192 M} : mulSupport f = \u2205 \u2194 f = 1", "start": [106, 1], "end": [109, 7], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_nonempty_iff", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_nonempty_iff {f : \u03b1 \u2192 M} : (mulSupport f).Nonempty \u2194 f \u2260 1", "start": [113, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "Function.range_subset_insert_image_mulSupport", "code": "@[to_additive]\ntheorem range_subset_insert_image_mulSupport (f : \u03b1 \u2192 M) :\n    range f \u2286 insert 1 (f '' mulSupport f)", "start": [119, 1], "end": [123, 59], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one'", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_one' : mulSupport (1 : \u03b1 \u2192 M) = \u2205", "start": [127, 1], "end": [129, 32], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_one : (mulSupport fun _ : \u03b1 => (1 : M)) = \u2205", "start": [133, 1], "end": [135, 18], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_const", "code": "@[to_additive]\ntheorem mulSupport_const {c : M} (hc : c \u2260 1) : (mulSupport fun _ : \u03b1 => c) = Set.univ", "start": [139, 1], "end": [142, 12], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_binop_subset", "code": "@[to_additive]\ntheorem mulSupport_binop_subset (op : M \u2192 N \u2192 P) (op1 : op 1 1 = 1) (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 N) :\n    (mulSupport fun x => op (f x) (g x)) \u2286 mulSupport f \u222a mulSupport g", "start": [146, 1], "end": [149, 62], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_sup", "code": "@[to_additive]\ntheorem mulSupport_sup [SemilatticeSup M] (f g : \u03b1 \u2192 M) :\n    (mulSupport fun x => f x \u2294 g x) \u2286 mulSupport f \u222a mulSupport g", "start": [153, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_inf", "code": "@[to_additive]\ntheorem mulSupport_inf [SemilatticeInf M] (f g : \u03b1 \u2192 M) :\n    (mulSupport fun x => f x \u2293 g x) \u2286 mulSupport f \u222a mulSupport g", "start": [160, 1], "end": [163, 47], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_max", "code": "@[to_additive]\ntheorem mulSupport_max [LinearOrder M] (f g : \u03b1 \u2192 M) :\n    (mulSupport fun x => max (f x) (g x)) \u2286 mulSupport f \u222a mulSupport g", "start": [167, 1], "end": [170, 21], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_min", "code": "@[to_additive]\ntheorem mulSupport_min [LinearOrder M] (f g : \u03b1 \u2192 M) :\n    (mulSupport fun x => min (f x) (g x)) \u2286 mulSupport f \u222a mulSupport g", "start": [174, 1], "end": [177, 21], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_iSup", "code": "@[to_additive]\ntheorem mulSupport_iSup [ConditionallyCompleteLattice M] [Nonempty \u03b9] (f : \u03b9 \u2192 \u03b1 \u2192 M) :\n    (mulSupport fun x => \u2a06 i, f i x) \u2286 \u22c3 i, mulSupport (f i)", "start": [181, 1], "end": [187, 30], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_iInf", "code": "@[to_additive]\ntheorem mulSupport_iInf [ConditionallyCompleteLattice M] [Nonempty \u03b9] (f : \u03b9 \u2192 \u03b1 \u2192 M) :\n    (mulSupport fun x => \u2a05 i, f i x) \u2286 \u22c3 i, mulSupport (f i)", "start": [191, 1], "end": [194, 43], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_comp_subset", "code": "@[to_additive]\ntheorem mulSupport_comp_subset {g : M \u2192 N} (hg : g 1 = 1) (f : \u03b1 \u2192 M) :\n    mulSupport (g \u2218 f) \u2286 mulSupport f", "start": [198, 1], "end": [200, 88], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_subset_comp", "code": "@[to_additive]\ntheorem mulSupport_subset_comp {g : M \u2192 N} (hg : \u2200 {x}, g x = 1 \u2192 x = 1) (f : \u03b1 \u2192 M) :\n    mulSupport f \u2286 mulSupport (g \u2218 f)", "start": [204, 1], "end": [206, 56], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_comp_eq", "code": "@[to_additive]\ntheorem mulSupport_comp_eq (g : M \u2192 N) (hg : \u2200 {x}, g x = 1 \u2194 x = 1) (f : \u03b1 \u2192 M) :\n    mulSupport (g \u2218 f) = mulSupport f", "start": [210, 1], "end": [213, 32], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_comp_eq_of_range_subset", "code": "@[to_additive]\ntheorem mulSupport_comp_eq_of_range_subset {g : M \u2192 N} {f : \u03b1 \u2192 M}\n    (hg : \u2200 {x}, x \u2208 range f \u2192 (g x = 1 \u2194 x = 1)) :\n    mulSupport (g \u2218 f) = mulSupport f", "start": [217, 1], "end": [221, 76], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_comp_eq_preimage", "code": "@[to_additive]\ntheorem mulSupport_comp_eq_preimage (g : \u03b2 \u2192 M) (f : \u03b1 \u2192 \u03b2) :\n    mulSupport (g \u2218 f) = f \u207b\u00b9' mulSupport g", "start": [223, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_prod_mk", "code": "@[to_additive support_prod_mk]\ntheorem mulSupport_prod_mk (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 N) :\n    (mulSupport fun x => (f x, g x)) = mulSupport f \u222a mulSupport g", "start": [230, 1], "end": [234, 88], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_prod_mk'", "code": "@[to_additive support_prod_mk']\ntheorem mulSupport_prod_mk' (f : \u03b1 \u2192 M \u00d7 N) :\n    mulSupport f = (mulSupport fun x => (f x).1) \u222a mulSupport fun x => (f x).2", "start": [238, 1], "end": [241, 35], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_along_fiber_subset", "code": "@[to_additive]\ntheorem mulSupport_along_fiber_subset (f : \u03b1 \u00d7 \u03b2 \u2192 M) (a : \u03b1) :\n    (mulSupport fun b => f (a, b)) \u2286 (mulSupport f).image Prod.snd", "start": [245, 1], "end": [248, 42], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_along_fiber_finite_of_finite", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_along_fiber_finite_of_finite (f : \u03b1 \u00d7 \u03b2 \u2192 M) (a : \u03b1)\n    (h : (mulSupport f).Finite) : (mulSupport fun b => f (a, b)).Finite", "start": [252, 1], "end": [255, 64], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_mul", "code": "@[to_additive]\ntheorem mulSupport_mul [MulOneClass M] (f g : \u03b1 \u2192 M) :\n    (mulSupport fun x => f x * g x) \u2286 mulSupport f \u222a mulSupport g", "start": [261, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_pow", "code": "@[to_additive]\ntheorem mulSupport_pow [Monoid M] (f : \u03b1 \u2192 M) (n : \u2115) :\n    (mulSupport fun x => f x ^ n) \u2286 mulSupport f", "start": [268, 1], "end": [273, 89], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_inv", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_inv : (mulSupport fun x => (f x)\u207b\u00b9) = mulSupport f", "start": [281, 1], "end": [283, 26], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_inv'", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_inv' : mulSupport f\u207b\u00b9 = mulSupport f", "start": [287, 1], "end": [289, 19], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_mul_inv", "code": "@[to_additive]\ntheorem mulSupport_mul_inv : (mulSupport fun x => f x * (g x)\u207b\u00b9) \u2286 mulSupport f \u222a mulSupport g", "start": [293, 1], "end": [295, 61], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_div", "code": "@[to_additive]\ntheorem mulSupport_div : (mulSupport fun x => f x / g x) \u2286 mulSupport f \u222a mulSupport g", "start": [299, 1], "end": [301, 50], "kind": "commanddeclaration"}, {"full_name": "Function.support_one", "code": "@[simp]\ntheorem support_one : support (1 : \u03b1 \u2192 R) = univ", "start": [311, 1], "end": [313, 28], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_zero", "code": "@[simp]\ntheorem mulSupport_zero : mulSupport (0 : \u03b1 \u2192 R) = univ", "start": [316, 1], "end": [318, 31], "kind": "commanddeclaration"}, {"full_name": "Function.support_nat_cast", "code": "theorem support_nat_cast (hn : n \u2260 0) : support (n : \u03b1 \u2192 R) = univ", "start": [327, 1], "end": [328, 41], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_nat_cast", "code": "theorem mulSupport_nat_cast (hn : n \u2260 1) : mulSupport (n : \u03b1 \u2192 R) = univ", "start": [331, 1], "end": [332, 43], "kind": "commanddeclaration"}, {"full_name": "Function.support_int_cast", "code": "theorem support_int_cast (hn : n \u2260 0) : support (n : \u03b1 \u2192 R) = univ", "start": [341, 1], "end": [342, 41], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_int_cast", "code": "theorem mulSupport_int_cast (hn : n \u2260 1) : mulSupport (n : \u03b1 \u2192 R) = univ", "start": [345, 1], "end": [346, 43], "kind": "commanddeclaration"}, {"full_name": "Function.support_smul", "code": "theorem support_smul [Zero R] [Zero M] [SMulWithZero R M] [NoZeroSMulDivisors R M] (f : \u03b1 \u2192 R)\n    (g : \u03b1 \u2192 M) : support (f \u2022 g) = support f \u2229 support g", "start": [351, 1], "end": [353, 32], "kind": "commanddeclaration"}, {"full_name": "Function.support_mul", "code": "@[simp]\ntheorem support_mul [MulZeroClass R] [NoZeroDivisors R] (f g : \u03b1 \u2192 R) :\n    (support fun x => f x * g x) = support f \u2229 support g", "start": [356, 1], "end": [359, 19], "kind": "commanddeclaration"}, {"full_name": "Function.support_mul_subset_left", "code": "theorem support_mul_subset_left [MulZeroClass R] (f g : \u03b1 \u2192 R) :\n    (support fun x => f x * g x) \u2286 support f", "start": [363, 1], "end": [364, 99], "kind": "commanddeclaration"}, {"full_name": "Function.support_mul_subset_right", "code": "theorem support_mul_subset_right [MulZeroClass R] (f g : \u03b1 \u2192 R) :\n    (support fun x => f x * g x) \u2286 support g", "start": [368, 1], "end": [369, 99], "kind": "commanddeclaration"}, {"full_name": "Function.support_smul_subset_right", "code": "theorem support_smul_subset_right [AddMonoid A] [Monoid B] [DistribMulAction B A] (b : B)\n    (f : \u03b1 \u2192 A) : support (b \u2022 f) \u2286 support f", "start": [372, 1], "end": [374, 46], "kind": "commanddeclaration"}, {"full_name": "Function.support_smul_subset_left", "code": "theorem support_smul_subset_left [Zero M] [Zero \u03b2] [SMulWithZero M \u03b2] (f : \u03b1 \u2192 M) (g : \u03b1 \u2192 \u03b2) :\n    support (f \u2022 g) \u2286 support f", "start": [377, 1], "end": [378, 96], "kind": "commanddeclaration"}, {"full_name": "Function.support_const_smul_of_ne_zero", "code": "theorem support_const_smul_of_ne_zero [Semiring R] [AddCommMonoid M] [Module R M]\n    [NoZeroSMulDivisors R M] (c : R) (g : \u03b1 \u2192 M) (hc : c \u2260 0) : support (c \u2022 g) = support g", "start": [381, 1], "end": [383, 97], "kind": "commanddeclaration"}, {"full_name": "Function.support_inv", "code": "@[simp]\ntheorem support_inv [GroupWithZero G\u2080] (f : \u03b1 \u2192 G\u2080) : (support fun x => (f x)\u207b\u00b9) = support f", "start": [386, 1], "end": [388, 41], "kind": "commanddeclaration"}, {"full_name": "Function.support_div", "code": "@[simp]\ntheorem support_div [GroupWithZero G\u2080] (f g : \u03b1 \u2192 G\u2080) :\n    (support fun x => f x / g x) = support f \u2229 support g", "start": [391, 1], "end": [393, 85], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_prod", "code": "@[to_additive]\ntheorem mulSupport_prod [CommMonoid M] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 M) :\n    (mulSupport fun x => \u220f i in s, f i x) \u2286 \u22c3 i \u2208 s, mulSupport (f i)", "start": [396, 1], "end": [401, 36], "kind": "commanddeclaration"}, {"full_name": "Function.support_prod_subset", "code": "theorem support_prod_subset [CommMonoidWithZero A] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 A) :\n    (support fun x => \u220f i in s, f i x) \u2286 \u22c2 i \u2208 s, support (f i)", "start": [405, 1], "end": [407, 61], "kind": "commanddeclaration"}, {"full_name": "Function.support_prod", "code": "theorem support_prod [CommMonoidWithZero A] [NoZeroDivisors A] [Nontrivial A] (s : Finset \u03b1)\n    (f : \u03b1 \u2192 \u03b2 \u2192 A) : (support fun x => \u220f i in s, f i x) = \u22c2 i \u2208 s, support (f i)", "start": [410, 1], "end": [413, 94], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one_add", "code": "theorem mulSupport_one_add [One R] [AddLeftCancelMonoid R] (f : \u03b1 \u2192 R) :\n    (mulSupport fun x => 1 + f x) = support f", "start": [416, 1], "end": [418, 47], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one_add'", "code": "theorem mulSupport_one_add' [One R] [AddLeftCancelMonoid R] (f : \u03b1 \u2192 R) :\n    mulSupport (1 + f) = support f", "start": [421, 1], "end": [423, 23], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_add_one", "code": "theorem mulSupport_add_one [One R] [AddRightCancelMonoid R] (f : \u03b1 \u2192 R) :\n    (mulSupport fun x => f x + 1) = support f", "start": [426, 1], "end": [428, 46], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_add_one'", "code": "theorem mulSupport_add_one' [One R] [AddRightCancelMonoid R] (f : \u03b1 \u2192 R) :\n    mulSupport (f + 1) = support f", "start": [431, 1], "end": [433, 23], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one_sub'", "code": "theorem mulSupport_one_sub' [One R] [AddGroup R] (f : \u03b1 \u2192 R) : mulSupport (1 - f) = support f", "start": [436, 1], "end": [437, 57], "kind": "commanddeclaration"}, {"full_name": "Function.mulSupport_one_sub", "code": "theorem mulSupport_one_sub [One R] [AddGroup R] (f : \u03b1 \u2192 R) :\n    (mulSupport fun x => 1 - f x) = support f", "start": [440, 1], "end": [442, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image_inter_mulSupport_eq", "code": "@[to_additive]\ntheorem image_inter_mulSupport_eq {s : Set \u03b2} {g : \u03b2 \u2192 \u03b1} :\n    g '' s \u2229 mulSupport f = g '' (s \u2229 mulSupport (f \u2218 g))", "start": [453, 1], "end": [456, 61], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSupport_mulSingle_subset", "code": "@[to_additive]\ntheorem mulSupport_mulSingle_subset : mulSupport (mulSingle a b) \u2286 {a}", "start": [468, 1], "end": [470, 54], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSupport_mulSingle_one", "code": "@[to_additive]\ntheorem mulSupport_mulSingle_one : mulSupport (mulSingle a (1 : B)) = \u2205", "start": [474, 1], "end": [475, 83], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSupport_mulSingle_of_ne", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_mulSingle_of_ne (h : b \u2260 1) : mulSupport (mulSingle a b) = {a}", "start": [479, 1], "end": [482, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSupport_mulSingle", "code": "@[to_additive]\ntheorem mulSupport_mulSingle [DecidableEq B] :\n    mulSupport (mulSingle a b) = if b = 1 then \u2205 else {a}", "start": [486, 1], "end": [488, 94], "kind": "commanddeclaration"}, {"full_name": "Pi.mulSupport_mulSingle_disjoint", "code": "@[to_additive]\ntheorem mulSupport_mulSingle_disjoint {b' : B} (hb : b \u2260 1) (hb' : b' \u2260 1) {i j : A} :\n    Disjoint (mulSupport (mulSingle i b)) (mulSupport (mulSingle j b')) \u2194 i \u2260 j", "start": [492, 1], "end": [495, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Lift.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Order/Filter/Bases.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.lift", "code": "protected def lift (f : Filter \u03b1) (g : Set \u03b1 \u2192 Filter \u03b2) :=\n  \u2a05 s \u2208 f, g s", "start": [23, 1], "end": [26, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_top", "code": "@[simp]\ntheorem lift_top (g : Set \u03b1 \u2192 Filter \u03b2) : (\u22a4 : Filter \u03b1).lift g = g univ", "start": [31, 1], "end": [32, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.mem_lift_iff", "code": "theorem HasBasis.mem_lift_iff {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {f : Filter \u03b1}\n    (hf : f.HasBasis p s) {\u03b2 : \u03b9 \u2192 Type*} {pg : \u2200 i, \u03b2 i \u2192 Prop} {sg : \u2200 i, \u03b2 i \u2192 Set \u03b3}\n    {g : Set \u03b1 \u2192 Filter \u03b3} (hg : \u2200 i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)\n    {s : Set \u03b3} : s \u2208 f.lift g \u2194 \u2203 i, p i \u2227 \u2203 x, pg i x \u2227 sg i x \u2286 s", "start": [36, 1], "end": [52, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.lift", "code": "theorem HasBasis.lift {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {f : Filter \u03b1} (hf : f.HasBasis p s)\n    {\u03b2 : \u03b9 \u2192 Type*} {pg : \u2200 i, \u03b2 i \u2192 Prop} {sg : \u2200 i, \u03b2 i \u2192 Set \u03b3} {g : Set \u03b1 \u2192 Filter \u03b3}\n    (hg : \u2200 i, (g (s i)).HasBasis (pg i) (sg i)) (gm : Monotone g) :\n    (f.lift g).HasBasis (fun i : \u03a3i, \u03b2 i => p i.1 \u2227 pg i.1 i.2) fun i : \u03a3i, \u03b2 i => sg i.1 i.2", "start": [55, 1], "end": [68, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_lift_sets", "code": "theorem mem_lift_sets (hg : Monotone g) {s : Set \u03b2} : s \u2208 f.lift g \u2194 \u2203 t \u2208 f, s \u2208 g t", "start": [71, 1], "end": [73, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.sInter_lift_sets", "code": "theorem sInter_lift_sets (hg : Monotone g) :\n    \u22c2\u2080 { s | s \u2208 f.lift g } = \u22c2 s \u2208 f, \u22c2\u2080 { t | t \u2208 g s }", "start": [76, 1], "end": [79, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_lift", "code": "theorem mem_lift {s : Set \u03b2} {t : Set \u03b1} (ht : t \u2208 f) (hs : s \u2208 g t) : s \u2208 f.lift g", "start": [82, 1], "end": [84, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_le", "code": "theorem lift_le {f : Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} {h : Filter \u03b2} {s : Set \u03b1} (hs : s \u2208 f)\n    (hg : g s \u2264 h) : f.lift g \u2264 h", "start": [87, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.le_lift", "code": "theorem le_lift {f : Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} {h : Filter \u03b2} :\n    h \u2264 f.lift g \u2194 \u2200 s \u2208 f, h \u2264 g s", "start": [92, 1], "end": [94, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_mono", "code": "theorem lift_mono (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264 g\u2082) : f\u2081.lift g\u2081 \u2264 f\u2082.lift g\u2082", "start": [97, 1], "end": [98, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_mono'", "code": "theorem lift_mono' (hg : \u2200 s \u2208 f, g\u2081 s \u2264 g\u2082 s) : f.lift g\u2081 \u2264 f.lift g\u2082", "start": [101, 1], "end": [101, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_lift", "code": "theorem tendsto_lift {m : \u03b3 \u2192 \u03b2} {l : Filter \u03b3} :\n    Tendsto m l (f.lift g) \u2194 \u2200 s \u2208 f, Tendsto m l (g s)", "start": [104, 1], "end": [106, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.map_lift_eq", "code": "theorem map_lift_eq {m : \u03b2 \u2192 \u03b3} (hg : Monotone g) : map m (f.lift g) = f.lift (map m \u2218 g)", "start": [109, 1], "end": [112, 96], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_lift_eq", "code": "theorem comap_lift_eq {m : \u03b3 \u2192 \u03b2} : comap m (f.lift g) = f.lift (comap m \u2218 g)", "start": [115, 1], "end": [116, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_lift_eq2", "code": "theorem comap_lift_eq2 {m : \u03b2 \u2192 \u03b1} {g : Set \u03b2 \u2192 Filter \u03b3} (hg : Monotone g) :\n    (comap m f).lift g = f.lift (g \u2218 preimage m)", "start": [119, 1], "end": [122, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_map_le", "code": "theorem lift_map_le {g : Set \u03b2 \u2192 Filter \u03b3} {m : \u03b1 \u2192 \u03b2} : (map m f).lift g \u2264 f.lift (g \u2218 image m)", "start": [125, 1], "end": [126, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.map_lift_eq2", "code": "theorem map_lift_eq2 {g : Set \u03b2 \u2192 Filter \u03b3} {m : \u03b1 \u2192 \u03b2} (hg : Monotone g) :\n    (map m f).lift g = f.lift (g \u2218 image m)", "start": [129, 1], "end": [131, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_comm", "code": "theorem lift_comm {g : Filter \u03b2} {h : Set \u03b1 \u2192 Set \u03b2 \u2192 Filter \u03b3} :\n    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t", "start": [134, 1], "end": [140, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_assoc", "code": "theorem lift_assoc {h : Set \u03b2 \u2192 Filter \u03b3} (hg : Monotone g) :\n    (f.lift g).lift h = f.lift fun s => (g s).lift h", "start": [143, 1], "end": [150, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_lift_same_le_lift", "code": "theorem lift_lift_same_le_lift {g : Set \u03b1 \u2192 Set \u03b1 \u2192 Filter \u03b2} :\n    (f.lift fun s => f.lift (g s)) \u2264 f.lift fun s => g s s", "start": [153, 1], "end": [155, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_lift_same_eq_lift", "code": "theorem lift_lift_same_eq_lift {g : Set \u03b1 \u2192 Set \u03b1 \u2192 Filter \u03b2} (hg\u2081 : \u2200 s, Monotone fun t => g s t)\n    (hg\u2082 : \u2200 t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s", "start": [158, 1], "end": [164, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_principal", "code": "theorem lift_principal {s : Set \u03b1} (hg : Monotone g) : (\ud835\udcdf s).lift g = g s", "start": [167, 1], "end": [168, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_lift", "code": "theorem monotone_lift [Preorder \u03b3] {f : \u03b3 \u2192 Filter \u03b1} {g : \u03b3 \u2192 Set \u03b1 \u2192 Filter \u03b2} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift (g c)", "start": [171, 1], "end": [172, 99], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_neBot_iff", "code": "theorem lift_neBot_iff (hm : Monotone g) : (NeBot (f.lift g)) \u2194 \u2200 s \u2208 f, NeBot (g s)", "start": [175, 1], "end": [176, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_const", "code": "@[simp]\ntheorem lift_const {f : Filter \u03b1} {g : Filter \u03b2} : (f.lift fun _ => g) = g", "start": [179, 1], "end": [181, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_inf", "code": "@[simp]\ntheorem lift_inf {f : Filter \u03b1} {g h : Set \u03b1 \u2192 Filter \u03b2} :\n    (f.lift fun x => g x \u2293 h x) = f.lift g \u2293 f.lift h", "start": [184, 1], "end": [186, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_principal2", "code": "@[simp]\ntheorem lift_principal2 {f : Filter \u03b1} : f.lift \ud835\udcdf = f", "start": [189, 1], "end": [192, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_iInf_le", "code": "theorem lift_iInf_le {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} :\n    (iInf f).lift g \u2264 \u2a05 i, (f i).lift g", "start": [195, 1], "end": [197, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_iInf", "code": "theorem lift_iInf [Nonempty \u03b9] {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2}\n    (hg : \u2200 s t, g (s \u2229 t) = g s \u2293 g t) : (iInf f).lift g = \u2a05 i, (f i).lift g", "start": [200, 1], "end": [211, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_iInf_of_directed", "code": "theorem lift_iInf_of_directed [Nonempty \u03b9] {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2}\n    (hf : Directed (\u00b7 \u2265 \u00b7) f) (hg : Monotone g) : (iInf f).lift g = \u2a05 i, (f i).lift g", "start": [214, 1], "end": [218, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_iInf_of_map_univ", "code": "theorem lift_iInf_of_map_univ {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2}\n    (hg : \u2200 s t, g (s \u2229 t) = g s \u2293 g t) (hg' : g univ = \u22a4) :\n    (iInf f).lift g = \u2a05 i, (f i).lift g", "start": [221, 1], "end": [226, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'", "code": "protected def lift' (f : Filter \u03b1) (h : Set \u03b1 \u2192 Set \u03b2) :=\n  f.lift (\ud835\udcdf \u2218 h)", "start": [233, 1], "end": [236, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_top", "code": "@[simp]\ntheorem lift'_top (h : Set \u03b1 \u2192 Set \u03b2) : (\u22a4 : Filter \u03b1).lift' h = \ud835\udcdf (h univ)", "start": [241, 1], "end": [243, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_lift'", "code": "theorem mem_lift' {t : Set \u03b1} (ht : t \u2208 f) : h t \u2208 f.lift' h", "start": [246, 1], "end": [247, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_lift'", "code": "theorem tendsto_lift' {m : \u03b3 \u2192 \u03b2} {l : Filter \u03b3} :\n    Tendsto m l (f.lift' h) \u2194 \u2200 s \u2208 f, \u2200\u1da0 a in l, m a \u2208 h s", "start": [250, 1], "end": [252, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.lift'", "code": "theorem HasBasis.lift' {\u03b9} {p : \u03b9 \u2192 Prop} {s} (hf : f.HasBasis p s) (hh : Monotone h) :\n    (f.lift' h).HasBasis p (h \u2218 s)", "start": [255, 1], "end": [258, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_lift'_sets", "code": "theorem mem_lift'_sets (hh : Monotone h) {s : Set \u03b2} : s \u2208 f.lift' h \u2194 \u2203 t \u2208 f, h t \u2286 s", "start": [261, 1], "end": [262, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_lift'_iff", "code": "theorem eventually_lift'_iff (hh : Monotone h) {p : \u03b2 \u2192 Prop} :\n    (\u2200\u1da0 y in f.lift' h, p y) \u2194 \u2203 t \u2208 f, \u2200 y \u2208 h t, p y", "start": [265, 1], "end": [267, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.sInter_lift'_sets", "code": "theorem sInter_lift'_sets (hh : Monotone h) : \u22c2\u2080 { s | s \u2208 f.lift' h } = \u22c2 s \u2208 f, h s", "start": [270, 1], "end": [271, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_le", "code": "theorem lift'_le {f : Filter \u03b1} {g : Set \u03b1 \u2192 Set \u03b2} {h : Filter \u03b2} {s : Set \u03b1} (hs : s \u2208 f)\n    (hg : \ud835\udcdf (g s) \u2264 h) : f.lift' g \u2264 h", "start": [274, 1], "end": [276, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_mono", "code": "theorem lift'_mono (hf : f\u2081 \u2264 f\u2082) (hh : h\u2081 \u2264 h\u2082) : f\u2081.lift' h\u2081 \u2264 f\u2082.lift' h\u2082", "start": [279, 1], "end": [280, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_mono'", "code": "theorem lift'_mono' (hh : \u2200 s \u2208 f, h\u2081 s \u2286 h\u2082 s) : f.lift' h\u2081 \u2264 f.lift' h\u2082", "start": [283, 1], "end": [284, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_cong", "code": "theorem lift'_cong (hh : \u2200 s \u2208 f, h\u2081 s = h\u2082 s) : f.lift' h\u2081 = f.lift' h\u2082", "start": [287, 1], "end": [289, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.map_lift'_eq", "code": "theorem map_lift'_eq {m : \u03b2 \u2192 \u03b3} (hh : Monotone h) : map m (f.lift' h) = f.lift' (image m \u2218 h)", "start": [292, 1], "end": [295, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_map_le", "code": "theorem lift'_map_le {g : Set \u03b2 \u2192 Set \u03b3} {m : \u03b1 \u2192 \u03b2} : (map m f).lift' g \u2264 f.lift' (g \u2218 image m)", "start": [298, 1], "end": [299, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.map_lift'_eq2", "code": "theorem map_lift'_eq2 {g : Set \u03b2 \u2192 Set \u03b3} {m : \u03b1 \u2192 \u03b2} (hg : Monotone g) :\n    (map m f).lift' g = f.lift' (g \u2218 image m)", "start": [302, 1], "end": [304, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_lift'_eq", "code": "theorem comap_lift'_eq {m : \u03b3 \u2192 \u03b2} : comap m (f.lift' h) = f.lift' (preimage m \u2218 h)", "start": [307, 1], "end": [308, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_lift'_eq2", "code": "theorem comap_lift'_eq2 {m : \u03b2 \u2192 \u03b1} {g : Set \u03b2 \u2192 Set \u03b3} (hg : Monotone g) :\n    (comap m f).lift' g = f.lift' (g \u2218 preimage m)", "start": [311, 1], "end": [313, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_principal", "code": "theorem lift'_principal {s : Set \u03b1} (hh : Monotone h) : (\ud835\udcdf s).lift' h = \ud835\udcdf (h s)", "start": [316, 1], "end": [317, 47], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_pure", "code": "theorem lift'_pure {a : \u03b1} (hh : Monotone h) : (pure a : Filter \u03b1).lift' h = \ud835\udcdf (h {a})", "start": [320, 1], "end": [321, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_bot", "code": "theorem lift'_bot (hh : Monotone h) : (\u22a5 : Filter \u03b1).lift' h = \ud835\udcdf (h \u2205)", "start": [324, 1], "end": [325, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.le_lift'", "code": "theorem le_lift' {f : Filter \u03b1} {h : Set \u03b1 \u2192 Set \u03b2} {g : Filter \u03b2} :\n    g \u2264 f.lift' h \u2194 \u2200 s \u2208 f, h s \u2208 g", "start": [328, 1], "end": [330, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_le_lift'", "code": "theorem principal_le_lift' {t : Set \u03b2} : \ud835\udcdf t \u2264 f.lift' h \u2194 \u2200 s \u2208 f, t \u2286 h s", "start": [333, 1], "end": [334, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_lift'", "code": "theorem monotone_lift' [Preorder \u03b3] {f : \u03b3 \u2192 Filter \u03b1} {g : \u03b3 \u2192 Set \u03b1 \u2192 Set \u03b2} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift' (g c)", "start": [337, 1], "end": [338, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_lift'_assoc", "code": "theorem lift_lift'_assoc {g : Set \u03b1 \u2192 Set \u03b2} {h : Set \u03b2 \u2192 Filter \u03b3} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift h = f.lift fun s => h (g s)", "start": [341, 1], "end": [345, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_lift'_assoc", "code": "theorem lift'_lift'_assoc {g : Set \u03b1 \u2192 Set \u03b2} {h : Set \u03b2 \u2192 Set \u03b3} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s)", "start": [348, 1], "end": [350, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_lift_assoc", "code": "theorem lift'_lift_assoc {g : Set \u03b1 \u2192 Filter \u03b2} {h : Set \u03b2 \u2192 Set \u03b3} (hg : Monotone g) :\n    (f.lift g).lift' h = f.lift fun s => (g s).lift' h", "start": [353, 1], "end": [355, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_lift'_same_le_lift'", "code": "theorem lift_lift'_same_le_lift' {g : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b2} :\n    (f.lift fun s => f.lift' (g s)) \u2264 f.lift' fun s => g s s", "start": [358, 1], "end": [360, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.lift_lift'_same_eq_lift'", "code": "theorem lift_lift'_same_eq_lift' {g : Set \u03b1 \u2192 Set \u03b1 \u2192 Set \u03b2} (hg\u2081 : \u2200 s, Monotone fun t => g s t)\n    (hg\u2082 : \u2200 t, Monotone fun s => g s t) :\n    (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s", "start": [363, 1], "end": [367, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_inf_principal_eq", "code": "theorem lift'_inf_principal_eq {h : Set \u03b1 \u2192 Set \u03b2} {s : Set \u03b2} :\n    f.lift' h \u2293 \ud835\udcdf s = f.lift' fun t => h t \u2229 s", "start": [370, 1], "end": [372, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_neBot_iff", "code": "theorem lift'_neBot_iff (hh : Monotone h) : NeBot (f.lift' h) \u2194 \u2200 s \u2208 f, (h s).Nonempty", "start": [375, 1], "end": [378, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_id", "code": "@[simp]\ntheorem lift'_id {f : Filter \u03b1} : f.lift' id = f", "start": [381, 1], "end": [383, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_iInf", "code": "theorem lift'_iInf [Nonempty \u03b9] {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Set \u03b2}\n    (hg : \u2200 s t, g (s \u2229 t) = g s \u2229 g t) : (iInf f).lift' g = \u2a05 i, (f i).lift' g", "start": [386, 1], "end": [388, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_iInf_of_map_univ", "code": "theorem lift'_iInf_of_map_univ {f : \u03b9 \u2192 Filter \u03b1} {g : Set \u03b1 \u2192 Set \u03b2}\n    (hg : \u2200 {s t}, g (s \u2229 t) = g s \u2229 g t) (hg' : g univ = univ) :\n    (iInf f).lift' g = \u2a05 i, (f i).lift' g", "start": [391, 1], "end": [395, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_inf", "code": "theorem lift'_inf (f g : Filter \u03b1) {s : Set \u03b1 \u2192 Set \u03b2} (hs : \u2200 t\u2081 t\u2082, s (t\u2081 \u2229 t\u2082) = s t\u2081 \u2229 s t\u2082) :\n    (f \u2293 g).lift' s = f.lift' s \u2293 g.lift' s", "start": [398, 1], "end": [402, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_inf_le", "code": "theorem lift'_inf_le (f g : Filter \u03b1) (s : Set \u03b1 \u2192 Set \u03b2) :\n    (f \u2293 g).lift' s \u2264 f.lift' s \u2293 g.lift' s", "start": [405, 1], "end": [407, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_eq_lift'", "code": "theorem comap_eq_lift' {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} : comap m f = f.lift' (preimage m)", "start": [410, 1], "end": [411, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_def", "code": "theorem prod_def {f : Filter \u03b1} {g : Filter \u03b2} :\n    f \u00d7\u02e2 g = f.lift fun s => g.lift' fun t => s \u00d7\u02e2 t", "start": [420, 1], "end": [423, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_prod_same_iff", "code": "alias mem_prod_same_iff := mem_prod_self_iff", "start": [426, 1], "end": [426, 45], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.prod_same_eq", "code": "theorem prod_same_eq : f \u00d7\u02e2 f = f.lift' fun t : Set \u03b1 => t \u00d7\u02e2 t", "start": [429, 1], "end": [430, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_prod_self_iff", "code": "theorem tendsto_prod_self_iff {f : \u03b1 \u00d7 \u03b1 \u2192 \u03b2} {x : Filter \u03b1} {y : Filter \u03b2} :\n    Filter.Tendsto f (x \u00d7\u02e2 x) y \u2194 \u2200 W \u2208 y, \u2203 U \u2208 x, \u2200 x x' : \u03b1, x \u2208 U \u2192 x' \u2208 U \u2192 f (x, x') \u2208 W", "start": [433, 1], "end": [435, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_lift_lift", "code": "theorem prod_lift_lift {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {g\u2081 : Set \u03b1\u2081 \u2192 Filter \u03b2\u2081}\n    {g\u2082 : Set \u03b1\u2082 \u2192 Filter \u03b2\u2082} (hg\u2081 : Monotone g\u2081) (hg\u2082 : Monotone g\u2082) :\n    f\u2081.lift g\u2081 \u00d7\u02e2 f\u2082.lift g\u2082 = f\u2081.lift fun s => f\u2082.lift fun t => g\u2081 s \u00d7\u02e2 g\u2082 t", "start": [440, 1], "end": [447, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.prod_lift'_lift'", "code": "theorem prod_lift'_lift' {f\u2081 : Filter \u03b1\u2081} {f\u2082 : Filter \u03b1\u2082} {g\u2081 : Set \u03b1\u2081 \u2192 Set \u03b2\u2081}\n    {g\u2082 : Set \u03b1\u2082 \u2192 Set \u03b2\u2082} (hg\u2081 : Monotone g\u2081) (hg\u2082 : Monotone g\u2082) :\n    f\u2081.lift' g\u2081 \u00d7\u02e2 f\u2082.lift' g\u2082 = f\u2081.lift fun s => f\u2082.lift' fun t => g\u2081 s \u00d7\u02e2 g\u2082 t", "start": [450, 1], "end": [457, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Continuity.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "Mathlib/Tactic/Continuity/Init.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Order/Filter/Ultrafilter.lean", "imports": ["Mathlib/Order/ZornAtoms.lean", "Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ultrafilter", "code": "structure Ultrafilter (\u03b1 : Type*) extends Filter \u03b1 where\n  \n  protected neBot' : NeBot toFilter\n  \n  protected le_of_le : \u2200 g, Filter.NeBot g \u2192 g \u2264 toFilter \u2192 toFilter \u2264 g", "start": [40, 1], "end": [46, 73], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.unique", "code": "theorem unique (f : Ultrafilter \u03b1) {g : Filter \u03b1} (h : g \u2264 f) (hne : NeBot g := by infer_instance) :\n    g = f", "start": [61, 1], "end": [63, 38], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.neBot", "code": "instance neBot (f : Ultrafilter \u03b1) : NeBot (f : Filter \u03b1) :=\n  f.neBot'", "start": [66, 1], "end": [67, 11], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.isAtom", "code": "protected theorem isAtom (f : Ultrafilter \u03b1) : IsAtom (f : Filter \u03b1)", "start": [70, 1], "end": [71, 80], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.mem_coe", "code": "@[simp, norm_cast]\ntheorem mem_coe : s \u2208 (f : Filter \u03b1) \u2194 s \u2208 f", "start": [74, 1], "end": [76, 10], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_injective", "code": "theorem coe_injective : Injective ((\u2191) : Ultrafilter \u03b1 \u2192 Filter \u03b1)", "start": [79, 1], "end": [80, 42], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eq_of_le", "code": "theorem eq_of_le {f g : Ultrafilter \u03b1} (h : (f : Filter \u03b1) \u2264 g) : f = g", "start": [83, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {f g : Ultrafilter \u03b1} : (f : Filter \u03b1) \u2264 g \u2194 f = g", "start": [87, 1], "end": [89, 45], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_inj", "code": "@[simp, norm_cast]\ntheorem coe_inj : (f : Filter \u03b1) = g \u2194 f = g", "start": [92, 1], "end": [94, 23], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ext", "code": "@[ext]\ntheorem ext \u2983f g : Ultrafilter \u03b1\u2984 (h : \u2200 s, s \u2208 f \u2194 s \u2208 g) : f = g", "start": [97, 1], "end": [99, 32], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.le_of_inf_neBot", "code": "theorem le_of_inf_neBot (f : Ultrafilter \u03b1) {g : Filter \u03b1} (hg : NeBot (\u2191f \u2293 g)) : \u2191f \u2264 g", "start": [102, 1], "end": [103, 41], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.le_of_inf_neBot'", "code": "theorem le_of_inf_neBot' (f : Ultrafilter \u03b1) {g : Filter \u03b1} (hg : NeBot (g \u2293 f)) : \u2191f \u2264 g", "start": [106, 1], "end": [107, 41], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.inf_neBot_iff", "code": "theorem inf_neBot_iff {f : Ultrafilter \u03b1} {g : Filter \u03b1} : NeBot (\u2191f \u2293 g) \u2194 \u2191f \u2264 g", "start": [110, 1], "end": [111, 66], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.disjoint_iff_not_le", "code": "theorem disjoint_iff_not_le {f : Ultrafilter \u03b1} {g : Filter \u03b1} : Disjoint (\u2191f) g \u2194 \u00ac\u2191f \u2264 g", "start": [114, 1], "end": [115, 65], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.compl_not_mem_iff", "code": "@[simp]\ntheorem compl_not_mem_iff : s\u1d9c \u2209 f \u2194 s \u2208 f", "start": [118, 1], "end": [123, 19], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.frequently_iff_eventually", "code": "@[simp]\ntheorem frequently_iff_eventually : (\u2203\u1da0 x in f, p x) \u2194 \u2200\u1da0 x in f, p x", "start": [126, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.eventually", "code": "alias \u27e8_root_.Filter.Frequently.eventually, _\u27e9 := frequently_iff_eventually", "start": [131, 1], "end": [131, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ultrafilter.compl_mem_iff_not_mem", "code": "theorem compl_mem_iff_not_mem : s\u1d9c \u2208 f \u2194 s \u2209 f", "start": [134, 1], "end": [134, 91], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.diff_mem_iff", "code": "theorem diff_mem_iff (f : Ultrafilter \u03b1) : s \\ t \u2208 f \u2194 s \u2208 f \u2227 t \u2209 f", "start": [137, 1], "end": [138, 65], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ofComplNotMemIff", "code": "def ofComplNotMemIff (f : Filter \u03b1) (h : \u2200 s, s\u1d9c \u2209 f \u2194 s \u2208 f) : Ultrafilter \u03b1 where\n  toFilter := f\n  neBot' := \u27e8fun hf => by simp [hf] at h\u27e9\n  le_of_le g hg hgf s hs := (h s).1 fun hsc => compl_not_mem hs (hgf hsc)", "start": [141, 1], "end": [146, 74], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ofAtom", "code": "def ofAtom (f : Filter \u03b1) (hf : IsAtom f) : Ultrafilter \u03b1 where\n  toFilter := f\n  neBot' := \u27e8hf.1\u27e9\n  le_of_le g hg := (isAtom_iff.1 hf).2 g hg.ne", "start": [149, 1], "end": [153, 47], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.nonempty_of_mem", "code": "theorem nonempty_of_mem (hs : s \u2208 f) : s.Nonempty", "start": [156, 1], "end": [157, 28], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ne_empty_of_mem", "code": "theorem ne_empty_of_mem (hs : s \u2208 f) : s \u2260 \u2205", "start": [160, 1], "end": [161, 32], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.empty_not_mem", "code": "@[simp]\ntheorem empty_not_mem : \u2205 \u2209 f", "start": [164, 1], "end": [166, 38], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.le_sup_iff", "code": "@[simp]\ntheorem le_sup_iff {u : Ultrafilter \u03b1} {f g : Filter \u03b1} : \u2191u \u2264 f \u2294 g \u2194 \u2191u \u2264 f \u2228 \u2191u \u2264 g", "start": [169, 1], "end": [171, 84], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.union_mem_iff", "code": "@[simp]\ntheorem union_mem_iff : s \u222a t \u2208 f \u2194 s \u2208 f \u2228 t \u2208 f", "start": [174, 1], "end": [176, 73], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.mem_or_compl_mem", "code": "theorem mem_or_compl_mem (f : Ultrafilter \u03b1) (s : Set \u03b1) : s \u2208 f \u2228 s\u1d9c \u2208 f", "start": [179, 1], "end": [180, 48], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.em", "code": "protected theorem em (f : Ultrafilter \u03b1) (p : \u03b1 \u2192 Prop) : (\u2200\u1da0 x in f, p x) \u2228 \u2200\u1da0 x in f, \u00acp x", "start": [183, 1], "end": [184, 33], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eventually_or", "code": "theorem eventually_or : (\u2200\u1da0 x in f, p x \u2228 q x) \u2194 (\u2200\u1da0 x in f, p x) \u2228 \u2200\u1da0 x in f, q x", "start": [187, 1], "end": [188, 16], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eventually_not", "code": "theorem eventually_not : (\u2200\u1da0 x in f, \u00acp x) \u2194 \u00ac\u2200\u1da0 x in f, p x", "start": [191, 1], "end": [192, 24], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eventually_imp", "code": "theorem eventually_imp : (\u2200\u1da0 x in f, p x \u2192 q x) \u2194 (\u2200\u1da0 x in f, p x) \u2192 \u2200\u1da0 x in f, q x", "start": [195, 1], "end": [196, 60], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.finite_sUnion_mem_iff", "code": "theorem finite_sUnion_mem_iff {s : Set (Set \u03b1)} (hs : s.Finite) : \u22c3\u2080 s \u2208 f \u2194 \u2203 t \u2208 s, t \u2208 f", "start": [199, 1], "end": [201, 55], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.finite_biUnion_mem_iff", "code": "theorem finite_biUnion_mem_iff {is : Set \u03b2} {s : \u03b2 \u2192 Set \u03b1} (his : is.Finite) :\n    (\u22c3 i \u2208 is, s i) \u2208 f \u2194 \u2203 i \u2208 is, s i \u2208 f", "start": [204, 1], "end": [206, 81], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.map", "code": "nonrec def map (m : \u03b1 \u2192 \u03b2) (f : Ultrafilter \u03b1) : Ultrafilter \u03b2 :=\n  ofComplNotMemIff (map m f) fun s => @compl_not_mem_iff _ f (m \u207b\u00b9' s)", "start": [209, 1], "end": [211, 71], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map (m : \u03b1 \u2192 \u03b2) (f : Ultrafilter \u03b1) : (map m f : Filter \u03b2) = Filter.map m \u2191f", "start": [214, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.mem_map", "code": "@[simp]\ntheorem mem_map {m : \u03b1 \u2192 \u03b2} {f : Ultrafilter \u03b1} {s : Set \u03b2} : s \u2208 map m f \u2194 m \u207b\u00b9' s \u2208 f", "start": [219, 1], "end": [221, 10], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.map_id", "code": "@[simp]\nnonrec theorem map_id (f : Ultrafilter \u03b1) : f.map id = f", "start": [224, 1], "end": [226, 23], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.map_id'", "code": "@[simp]\ntheorem map_id' (f : Ultrafilter \u03b1) : (f.map fun x => x) = f", "start": [229, 1], "end": [231, 11], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.map_map", "code": "@[simp]\nnonrec theorem map_map (f : Ultrafilter \u03b1) (m : \u03b1 \u2192 \u03b2) (n : \u03b2 \u2192 \u03b3) :\n  (f.map m).map n = f.map (n \u2218 m)", "start": [234, 1], "end": [237, 24], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.comap", "code": "nonrec def comap {m : \u03b1 \u2192 \u03b2} (u : Ultrafilter \u03b2) (inj : Injective m) (large : Set.range m \u2208 u) :\n    Ultrafilter \u03b1 where\n  toFilter := comap m u\n  neBot' := u.neBot'.comap_of_range_mem large\n  le_of_le g hg hgu := by\n    simp only [\u2190 u.unique (map_le_iff_le_comap.2 hgu), comap_map inj, le_rfl]", "start": [240, 1], "end": [247, 78], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.mem_comap", "code": "@[simp]\ntheorem mem_comap {m : \u03b1 \u2192 \u03b2} (u : Ultrafilter \u03b2) (inj : Injective m) (large : Set.range m \u2208 u)\n    {s : Set \u03b1} : s \u2208 u.comap inj large \u2194 m '' s \u2208 u", "start": [250, 1], "end": [253, 26], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap {m : \u03b1 \u2192 \u03b2} (u : Ultrafilter \u03b2) (inj : Injective m) (large : Set.range m \u2208 u) :\n    (u.comap inj large : Filter \u03b1) = Filter.comap m u", "start": [256, 1], "end": [259, 6], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.comap_id", "code": "@[simp]\nnonrec theorem comap_id (f : Ultrafilter \u03b1) (h\u2080 : Injective (id : \u03b1 \u2192 \u03b1) := injective_id)\n    (h\u2081 : range id \u2208 f := (by rw [range_id]; exact univ_mem)) :\n    f.comap h\u2080 h\u2081 = f", "start": [262, 1], "end": [266, 25], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.comap_comap", "code": "@[simp]\nnonrec theorem comap_comap (f : Ultrafilter \u03b3) {m : \u03b1 \u2192 \u03b2} {n : \u03b2 \u2192 \u03b3} (inj\u2080 : Injective n)\n    (large\u2080 : range n \u2208 f) (inj\u2081 : Injective m) (large\u2081 : range m \u2208 f.comap inj\u2080 large\u2080)\n    (inj\u2082 : Injective (n \u2218 m) := inj\u2080.comp inj\u2081)\n    (large\u2082 : range (n \u2218 m) \u2208 f :=\n      (by rw [range_comp]; exact image_mem_of_mem_comap large\u2080 large\u2081)) :\n    (f.comap inj\u2080 large\u2080).comap inj\u2081 large\u2081 = f.comap inj\u2082 large\u2082", "start": [269, 1], "end": [276, 28], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.mem_pure", "code": "@[simp]\ntheorem mem_pure {a : \u03b1} {s : Set \u03b1} : s \u2208 (pure a : Ultrafilter \u03b1) \u2194 a \u2208 s", "start": [283, 1], "end": [285, 10], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.coe_pure", "code": "@[simp]\ntheorem coe_pure (a : \u03b1) : \u2191(pure a : Ultrafilter \u03b1) = (pure a : Filter \u03b1)", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.map_pure", "code": "@[simp]\ntheorem map_pure (m : \u03b1 \u2192 \u03b2) (a : \u03b1) : map m (pure a) = pure (m a)", "start": [293, 1], "end": [295, 6], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.comap_pure", "code": "@[simp]\ntheorem comap_pure {m : \u03b1 \u2192 \u03b2} (a : \u03b1) (inj : Injective m) (large) :\n    comap (pure <| m a) inj large = pure a", "start": [298, 1], "end": [303, 87], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.pure_injective", "code": "theorem pure_injective : Injective (pure : \u03b1 \u2192 Ultrafilter \u03b1)", "start": [306, 1], "end": [307, 63], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eq_pure_of_finite_mem", "code": "theorem eq_pure_of_finite_mem (h : s.Finite) (h' : s \u2208 f) : \u2203 x \u2208 s, f = pure x", "start": [316, 1], "end": [319, 54], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.eq_pure_of_finite", "code": "theorem eq_pure_of_finite [Finite \u03b1] (f : Ultrafilter \u03b1) : \u2203 a, f = pure a", "start": [322, 1], "end": [323, 71], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.le_cofinite_or_eq_pure", "code": "theorem le_cofinite_or_eq_pure (f : Ultrafilter \u03b1) : (f : Filter \u03b1) \u2264 cofinite \u2228 \u2203 a, f = pure a", "start": [326, 1], "end": [330, 12], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.bind", "code": "def bind (f : Ultrafilter \u03b1) (m : \u03b1 \u2192 Ultrafilter \u03b2) : Ultrafilter \u03b2 :=\n  ofComplNotMemIff (Filter.bind \u2191f fun x => \u2191(m x)) fun s => by\n    simp only [mem_bind', mem_coe, \u2190 compl_mem_iff_not_mem, compl_setOf, compl_compl]", "start": [333, 1], "end": [337, 86], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.instBind", "code": "instance instBind : Bind Ultrafilter :=\n  \u27e8@Ultrafilter.bind\u27e9", "start": [340, 1], "end": [341, 22], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.functor", "code": "instance functor : Functor Ultrafilter where map := @Ultrafilter.map", "start": [344, 1], "end": [344, 69], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.monad", "code": "instance monad : Monad Ultrafilter where map := @Ultrafilter.map", "start": [347, 1], "end": [347, 65], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.lawfulMonad", "code": "instance lawfulMonad : LawfulMonad Ultrafilter where\n  id_map f := coe_injective (id_map f.toFilter)\n  pure_bind a f := coe_injective (Filter.pure_bind a ((Ultrafilter.toFilter) \u2218 f))\n  bind_assoc _ _ _ := coe_injective (filter_eq rfl)\n  bind_pure_comp f x := coe_injective (bind_pure_comp f x.1)\n  map_const := rfl\n  seqLeft_eq _ _ := rfl\n  seqRight_eq _ _ := rfl\n  pure_seq _ _ := rfl\n  bind_map _ _ := rfl", "start": [354, 1], "end": [363, 22], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.exists_le", "code": "theorem exists_le (f : Filter \u03b1) [h : NeBot f] : \u2203 u : Ultrafilter \u03b1, \u2191u \u2264 f", "start": [368, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_ultrafilter_le", "code": "alias _root_.Filter.exists_ultrafilter_le := exists_le", "start": [374, 1], "end": [374, 55], "kind": "stdtacticaliasalias"}, {"full_name": "Ultrafilter.of", "code": "noncomputable def of (f : Filter \u03b1) [NeBot f] : Ultrafilter \u03b1 :=\n  Classical.choose (exists_le f)", "start": [377, 1], "end": [381, 33], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.of_le", "code": "theorem of_le (f : Filter \u03b1) [NeBot f] : \u2191(of f) \u2264 f", "start": [384, 1], "end": [385, 38], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.of_coe", "code": "theorem of_coe (f : Ultrafilter \u03b1) : of \u2191f = f", "start": [388, 1], "end": [389, 43], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.exists_ultrafilter_of_finite_inter_nonempty", "code": "theorem exists_ultrafilter_of_finite_inter_nonempty (S : Set (Set \u03b1))\n    (cond : \u2200 T : Finset (Set \u03b1), (\u2191T : Set (Set \u03b1)) \u2286 S \u2192 (\u22c2\u2080 (\u2191T : Set (Set \u03b1))).Nonempty) :\n    \u2203 F : Ultrafilter \u03b1, S \u2286 F.sets", "start": [392, 1], "end": [398, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.isAtom_pure", "code": "theorem isAtom_pure : IsAtom (pure a : Filter \u03b1)", "start": [409, 1], "end": [410, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.le_pure_iff", "code": "protected theorem NeBot.le_pure_iff (hf : f.NeBot) : f \u2264 pure a \u2194 f = pure a", "start": [413, 1], "end": [414, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.eq_pure_iff", "code": "protected theorem NeBot.eq_pure_iff (hf : f.NeBot) {x : \u03b1} :\n    f = pure x \u2194 {x} \u2208 f", "start": [417, 1], "end": [419, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.atTop_eq_pure_of_isTop", "code": "lemma atTop_eq_pure_of_isTop [LinearOrder \u03b1] {x : \u03b1} (hx : IsTop x) :\n    (atTop : Filter \u03b1) = pure x := by\n  have : Nonempty \u03b1 := \u27e8x\u27e9\n  apply atTop_neBot.eq_pure_iff.2\n  convert Ici_mem_atTop x using 1\n  exact (Ici_eq_singleton_iff_isTop.2 hx).symm", "start": [421, 1], "end": [426, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.atBot_eq_pure_of_isBot", "code": "lemma atBot_eq_pure_of_isBot [LinearOrder \u03b1] {x : \u03b1} (hx : IsBot x) :\n    (atBot : Filter \u03b1) = pure x :=\n  @atTop_eq_pure_of_isTop \u03b1\u1d52\u1d48 _ _ hx", "start": [428, 1], "end": [430, 37], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.lt_pure_iff", "code": "@[simp]\ntheorem lt_pure_iff : f < pure a \u2194 f = \u22a5", "start": [432, 1], "end": [434, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.le_pure_iff'", "code": "theorem le_pure_iff' : f \u2264 pure a \u2194 f = \u22a5 \u2228 f = pure a", "start": [437, 1], "end": [438, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.Iic_pure", "code": "@[simp]\ntheorem Iic_pure (a : \u03b1) : Iic (pure a : Filter \u03b1) = {\u22a5, pure a}", "start": [441, 1], "end": [443, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_iff_ultrafilter", "code": "theorem mem_iff_ultrafilter : s \u2208 f \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 f \u2192 s \u2208 g", "start": [446, 1], "end": [450, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.le_iff_ultrafilter", "code": "theorem le_iff_ultrafilter {f\u2081 f\u2082 : Filter \u03b1} : f\u2081 \u2264 f\u2082 \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 f\u2081 \u2192 \u2191g \u2264 f\u2082", "start": [453, 1], "end": [454, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.iSup_ultrafilter_le_eq", "code": "theorem iSup_ultrafilter_le_eq (f : Filter \u03b1) :\n    \u2a06 (g : Ultrafilter \u03b1) (_ : g \u2264 f), (g : Filter \u03b1) = f", "start": [457, 1], "end": [460, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_iff_ultrafilter", "code": "theorem tendsto_iff_ultrafilter (f : \u03b1 \u2192 \u03b2) (l\u2081 : Filter \u03b1) (l\u2082 : Filter \u03b2) :\n    Tendsto f l\u2081 l\u2082 \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 l\u2081 \u2192 Tendsto f g l\u2082", "start": [463, 1], "end": [466, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.exists_ultrafilter_iff", "code": "theorem exists_ultrafilter_iff {f : Filter \u03b1} : (\u2203 u : Ultrafilter \u03b1, \u2191u \u2264 f) \u2194 NeBot f", "start": [469, 1], "end": [470, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.forall_neBot_le_iff", "code": "theorem forall_neBot_le_iff {g : Filter \u03b1} {p : Filter \u03b1 \u2192 Prop} (hp : Monotone p) :\n    (\u2200 f : Filter \u03b1, NeBot f \u2192 f \u2264 g \u2192 p f) \u2194 \u2200 f : Ultrafilter \u03b1, \u2191f \u2264 g \u2192 p f", "start": [473, 1], "end": [477, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.hyperfilter", "code": "noncomputable def hyperfilter : Ultrafilter \u03b1 :=\n  Ultrafilter.of cofinite", "start": [484, 1], "end": [486, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.hyperfilter_le_cofinite", "code": "theorem hyperfilter_le_cofinite : \u2191(hyperfilter \u03b1) \u2264 @cofinite \u03b1", "start": [491, 1], "end": [492, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.hyperfilter_le_atTop", "code": "theorem _root_.Nat.hyperfilter_le_atTop : (hyperfilter \u2115).toFilter \u2264 atTop", "start": [495, 1], "end": [496, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_ne_hyperfilter", "code": "@[simp]\ntheorem bot_ne_hyperfilter : (\u22a5 : Filter \u03b1) \u2260 hyperfilter \u03b1", "start": [498, 1], "end": [500, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.nmem_hyperfilter_of_finite", "code": "theorem nmem_hyperfilter_of_finite {s : Set \u03b1} (hf : s.Finite) : s \u2209 hyperfilter \u03b1", "start": [503, 1], "end": [504, 68], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.nmem_hyperfilter", "code": "alias _root_.Set.Finite.nmem_hyperfilter := nmem_hyperfilter_of_finite", "start": [507, 1], "end": [507, 71], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.compl_mem_hyperfilter_of_finite", "code": "theorem compl_mem_hyperfilter_of_finite {s : Set \u03b1} (hf : Set.Finite s) : s\u1d9c \u2208 hyperfilter \u03b1", "start": [510, 1], "end": [511, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.compl_mem_hyperfilter", "code": "alias _root_.Set.Finite.compl_mem_hyperfilter := compl_mem_hyperfilter_of_finite", "start": [514, 1], "end": [514, 81], "kind": "stdtacticaliasalias"}, {"full_name": "Filter.mem_hyperfilter_of_finite_compl", "code": "theorem mem_hyperfilter_of_finite_compl {s : Set \u03b1} (hf : Set.Finite s\u1d9c) : s \u2208 hyperfilter \u03b1", "start": [517, 1], "end": [518, 43], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.comap_inf_principal_neBot_of_image_mem", "code": "theorem comap_inf_principal_neBot_of_image_mem (h : m '' s \u2208 g) : (Filter.comap m g \u2293 \ud835\udcdf s).NeBot", "start": [531, 1], "end": [532, 58], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ofComapInfPrincipal", "code": "noncomputable def ofComapInfPrincipal (h : m '' s \u2208 g) : Ultrafilter \u03b1 :=\n  @of _ (Filter.comap m g \u2293 \ud835\udcdf s) (comap_inf_principal_neBot_of_image_mem h)", "start": [535, 1], "end": [537, 76], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ofComapInfPrincipal_mem", "code": "theorem ofComapInfPrincipal_mem (h : m '' s \u2208 g) : s \u2208 ofComapInfPrincipal h", "start": [540, 1], "end": [544, 35], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.ofComapInfPrincipal_eq_of_map", "code": "theorem ofComapInfPrincipal_eq_of_map (h : m '' s \u2208 g) : (ofComapInfPrincipal h).map m = g", "start": [547, 1], "end": [556, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Interval.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.Icc_eq_range'", "code": "theorem Icc_eq_range' : Icc a b = \u27e8List.range' a (b + 1 - a), List.nodup_range' _ _\u27e9", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_eq_range'", "code": "theorem Ico_eq_range' : Ico a b = \u27e8List.range' a (b - a), List.nodup_range' _ _\u27e9", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Ioc_eq_range'", "code": "theorem Ioc_eq_range' : Ioc a b = \u27e8List.range' (a + 1) (b - a), List.nodup_range' _ _\u27e9", "start": [72, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Ioo_eq_range'", "code": "theorem Ioo_eq_range' : Ioo a b = \u27e8List.range' (a + 1) (b - a - 1), List.nodup_range' _ _\u27e9", "start": [76, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.uIcc_eq_range'", "code": "theorem uIcc_eq_range' :\n    uIcc a b = \u27e8List.range' (min a b) (max a b + 1 - min a b), List.nodup_range' _ _\u27e9", "start": [80, 1], "end": [81, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.Iio_eq_range", "code": "theorem Iio_eq_range : Iio = range", "start": [84, 1], "end": [86, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_zero_eq_range", "code": "@[simp]\ntheorem Ico_zero_eq_range : Ico 0 = range", "start": [89, 1], "end": [90, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.range_eq_Ico", "code": "theorem _root_.Finset.range_eq_Ico : range = Ico 0", "start": [93, 1], "end": [94, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Icc", "code": "@[simp]\ntheorem card_Icc : (Icc a b).card = b + 1 - a", "start": [97, 1], "end": [99, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Ico", "code": "@[simp]\ntheorem card_Ico : (Ico a b).card = b - a", "start": [102, 1], "end": [104, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Ioc", "code": "@[simp]\ntheorem card_Ioc : (Ioc a b).card = b - a", "start": [107, 1], "end": [109, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Ioo", "code": "@[simp]\ntheorem card_Ioo : (Ioo a b).card = b - a - 1", "start": [112, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.card_uIcc", "code": "@[simp]\ntheorem card_uIcc : (uIcc a b).card = (b - a : \u2124).natAbs + 1", "start": [117, 1], "end": [128, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Iic", "code": "@[simp]\ntheorem card_Iic : (Iic b).card = b + 1", "start": [131, 1], "end": [132, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.card_Iio", "code": "@[simp]\ntheorem card_Iio : (Iio b).card = b", "start": [135, 1], "end": [136, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIcc", "code": "theorem card_fintypeIcc : Fintype.card (Set.Icc a b) = b + 1 - a", "start": [141, 1], "end": [142, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIco", "code": "theorem card_fintypeIco : Fintype.card (Set.Ico a b) = b - a", "start": [147, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIoc", "code": "theorem card_fintypeIoc : Fintype.card (Set.Ioc a b) = b - a", "start": [153, 1], "end": [154, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIoo", "code": "theorem card_fintypeIoo : Fintype.card (Set.Ioo a b) = b - a - 1", "start": [159, 1], "end": [160, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIic", "code": "theorem card_fintypeIic : Fintype.card (Set.Iic b) = b + 1", "start": [165, 1], "end": [166, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fintypeIio", "code": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b", "start": [171, 1], "end": [171, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.Icc_succ_left", "code": "theorem Icc_succ_left : Icc a.succ b = Ioc a b", "start": [175, 1], "end": [177, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_right", "code": "theorem Ico_succ_right : Ico a b.succ = Icc a b", "start": [180, 1], "end": [182, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_left", "code": "theorem Ico_succ_left : Ico a.succ b = Ioo a b", "start": [185, 1], "end": [187, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Icc_pred_right", "code": "theorem Icc_pred_right {b : \u2115} (h : 0 < b) : Icc a (b - 1) = Ico a b", "start": [190, 1], "end": [192, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_succ", "code": "theorem Ico_succ_succ : Ico a.succ b.succ = Ioc a b", "start": [195, 1], "end": [197, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_singleton", "code": "@[simp]\ntheorem Ico_succ_singleton : Ico a (a + 1) = {a}", "start": [200, 1], "end": [201, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_pred_singleton", "code": "@[simp]\ntheorem Ico_pred_singleton {a : \u2115} (h : 0 < a) : Ico (a - 1) a = {a - 1}", "start": [204, 1], "end": [206, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.Ioc_succ_singleton", "code": "@[simp]\ntheorem Ioc_succ_singleton : Ioc b (b + 1) = {b + 1}", "start": [209, 1], "end": [210, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_right_eq_insert_Ico", "code": "theorem Ico_succ_right_eq_insert_Ico (h : a \u2264 b) : Ico a (b + 1) = insert b (Ico a b)", "start": [215, 1], "end": [216, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_insert_succ_left", "code": "theorem Ico_insert_succ_left (h : a < b) : insert a (Ico a.succ b) = Ico a b", "start": [219, 1], "end": [220, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.image_sub_const_Ico", "code": "theorem image_sub_const_Ico (h : c \u2264 a) :\n    ((Ico a b).image fun x => x - c) = Ico (a - c) (b - c)", "start": [223, 1], "end": [234, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_image_const_sub_eq_Ico", "code": "theorem Ico_image_const_sub_eq_Ico (hac : a \u2264 c) :\n    ((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a)", "start": [237, 1], "end": [262, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.Ico_succ_left_eq_erase_Ico", "code": "theorem Ico_succ_left_eq_erase_Ico : Ico a.succ b = erase (Ico a b) a", "start": [265, 1], "end": [268, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_injOn_Ico", "code": "theorem mod_injOn_Ico (n a : \u2115) : Set.InjOn (\u00b7 % a) (Finset.Ico n (n + a))", "start": [271, 1], "end": [294, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.image_Ico_mod", "code": "theorem image_Ico_mod (n a : \u2115) : (Ico n (n + a)).image (\u00b7 % a) = range a", "start": [297, 1], "end": [322, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.multiset_Ico_map_mod", "code": "theorem multiset_Ico_map_mod (n a : \u2115) :\n    (Multiset.Ico n (n + a)).map (\u00b7 % a) = Multiset.range a", "start": [329, 1], "end": [333, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.range_image_pred_top_sub", "code": "theorem range_image_pred_top_sub (n : \u2115) :\n    ((Finset.range n).image fun j => n - 1 - j) = Finset.range n", "start": [342, 1], "end": [347, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.range_add_eq_union", "code": "theorem range_add_eq_union : range (a + b) = range a \u222a (range b).map (addLeftEmbedding a)", "start": [351, 1], "end": [354, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasing_induction_of_not_bddAbove", "code": "theorem Nat.decreasing_induction_of_not_bddAbove (hP : \u00acBddAbove { x | P x }) (n : \u2115) : P n", "start": [363, 1], "end": [365, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.decreasing_induction_of_infinite", "code": "theorem Nat.decreasing_induction_of_infinite (hP : { x | P x }.Infinite) (n : \u2115) : P n", "start": [368, 1], "end": [369, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.cauchy_induction'", "code": "theorem Nat.cauchy_induction' (seed : \u2115) (hs : P seed) (hi : \u2200 x, seed \u2264 x \u2192 P x \u2192 \u2203 y, x < y \u2227 P y)\n    (n : \u2115) : P n", "start": [372, 1], "end": [378, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.cauchy_induction", "code": "theorem Nat.cauchy_induction (seed : \u2115) (hs : P seed) (f : \u2115 \u2192 \u2115)\n    (hf : \u2200 x, seed \u2264 x \u2192 P x \u2192 x < f x \u2227 P (f x)) (n : \u2115) : P n", "start": [381, 1], "end": [383, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.cauchy_induction_mul", "code": "theorem Nat.cauchy_induction_mul (k seed : \u2115) (hk : 1 < k) (hs : P seed.succ)\n    (hm : \u2200 x, seed < x \u2192 P x \u2192 P (k * x)) (n : \u2115) : P n", "start": [386, 1], "end": [391, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.cauchy_induction_two_mul", "code": "theorem Nat.cauchy_induction_two_mul (seed : \u2115) (hs : P seed.succ)\n    (hm : \u2200 x, seed < x \u2192 P x \u2192 P (2 * x)) (n : \u2115) : P n", "start": [394, 1], "end": [396, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/Basic.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Data/Set/Lattice.lean", "Mathlib/Algebra/Hom/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Tactic/Common.lean", "Mathlib/Data/Nat/Order/Basic.lean"], "premises": [{"full_name": "Set.one", "code": "@[to_additive \"The set `0 : Set \u03b1` is defined as `{0}` in locale `Pointwise`.\"]\nprotected noncomputable def one : One (Set \u03b1) :=\n  \u27e8{1}\u27e9", "start": [82, 1], "end": [85, 8], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_one", "code": "@[to_additive]\ntheorem singleton_one : ({1} : Set \u03b1) = 1", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_one", "code": "@[to_additive (attr := simp)]\ntheorem mem_one : a \u2208 (1 : Set \u03b1) \u2194 a = 1", "start": [99, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "Set.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one : (1 : \u03b1) \u2208 (1 : Set \u03b1)", "start": [105, 1], "end": [107, 12], "kind": "commanddeclaration"}, {"full_name": "Set.one_subset", "code": "@[to_additive (attr := simp)]\ntheorem one_subset : 1 \u2286 s \u2194 (1 : \u03b1) \u2208 s", "start": [111, 1], "end": [113, 23], "kind": "commanddeclaration"}, {"full_name": "Set.one_nonempty", "code": "@[to_additive]\ntheorem one_nonempty : (1 : Set \u03b1).Nonempty", "start": [117, 1], "end": [119, 11], "kind": "commanddeclaration"}, {"full_name": "Set.image_one", "code": "@[to_additive (attr := simp)]\ntheorem image_one {f : \u03b1 \u2192 \u03b2} : f '' 1 = {f 1}", "start": [123, 1], "end": [125, 18], "kind": "commanddeclaration"}, {"full_name": "Set.subset_one_iff_eq", "code": "@[to_additive]\ntheorem subset_one_iff_eq : s \u2286 1 \u2194 s = \u2205 \u2228 s = 1", "start": [129, 1], "end": [131, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.subset_one_iff", "code": "@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s \u2286 1 \u2194 s = 1", "start": [135, 1], "end": [137, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singletonOneHom", "code": "@[to_additive \"The singleton operation as a `ZeroHom`.\"]\nnoncomputable def singletonOneHom : OneHom \u03b1 (Set \u03b1) where\n  toFun := singleton; map_one' := singleton_one", "start": [141, 1], "end": [144, 48], "kind": "commanddeclaration"}, {"full_name": "Set.coe_singletonOneHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : \u03b1 \u2192 Set \u03b1) = singleton", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inv", "code": "@[to_additive\n      \"The pointwise negation of set `-s` is defined as `{x | -x \u2208 s}` in locale `Pointwise`.\n      It is equal to `{-x | x \u2208 s}`, see `Set.image_neg`.\"]\nprotected def inv [Inv \u03b1] : Inv (Set \u03b1) :=\n  \u27e8preimage Inv.inv\u27e9", "start": [161, 1], "end": [167, 21], "kind": "commanddeclaration"}, {"full_name": "Set.mem_inv", "code": "@[to_additive (attr := simp)]\ntheorem mem_inv : a \u2208 s\u207b\u00b9 \u2194 a\u207b\u00b9 \u2208 s", "start": [179, 1], "end": [181, 10], "kind": "commanddeclaration"}, {"full_name": "Set.inv_preimage", "code": "@[to_additive (attr := simp)]\ntheorem inv_preimage : Inv.inv \u207b\u00b9' s = s\u207b\u00b9", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inv_empty", "code": "@[to_additive (attr := simp)]\ntheorem inv_empty : (\u2205 : Set \u03b1)\u207b\u00b9 = \u2205", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inv_univ", "code": "@[to_additive (attr := simp)]\ntheorem inv_univ : (univ : Set \u03b1)\u207b\u00b9 = univ", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "Set.inter_inv", "code": "@[to_additive (attr := simp)]\ntheorem inter_inv : (s \u2229 t)\u207b\u00b9 = s\u207b\u00b9 \u2229 t\u207b\u00b9", "start": [203, 1], "end": [205, 17], "kind": "commanddeclaration"}, {"full_name": "Set.union_inv", "code": "@[to_additive (attr := simp)]\ntheorem union_inv : (s \u222a t)\u207b\u00b9 = s\u207b\u00b9 \u222a t\u207b\u00b9", "start": [209, 1], "end": [211, 17], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_inv", "code": "@[to_additive (attr := simp)]\ntheorem iInter_inv (s : \u03b9 \u2192 Set \u03b1) : (\u22c2 i, s i)\u207b\u00b9 = \u22c2 i, (s i)\u207b\u00b9", "start": [215, 1], "end": [217, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inv", "code": "@[to_additive (attr := simp)]\ntheorem iUnion_inv (s : \u03b9 \u2192 Set \u03b1) : (\u22c3 i, s i)\u207b\u00b9 = \u22c3 i, (s i)\u207b\u00b9", "start": [221, 1], "end": [223, 18], "kind": "commanddeclaration"}, {"full_name": "Set.compl_inv", "code": "@[to_additive (attr := simp)]\ntheorem compl_inv : s\u1d9c\u207b\u00b9 = s\u207b\u00b9\u1d9c", "start": [227, 1], "end": [229, 17], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_inv", "code": "@[to_additive]\ntheorem inv_mem_inv : a\u207b\u00b9 \u2208 s\u207b\u00b9 \u2194 a \u2208 s", "start": [239, 1], "end": [240, 75], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_inv", "code": "@[to_additive (attr := simp)]\ntheorem nonempty_inv : s\u207b\u00b9.Nonempty \u2194 s.Nonempty", "start": [244, 1], "end": [246, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.inv", "code": "@[to_additive]\ntheorem Nonempty.inv (h : s.Nonempty) : s\u207b\u00b9.Nonempty", "start": [250, 1], "end": [252, 19], "kind": "commanddeclaration"}, {"full_name": "Set.image_inv", "code": "@[to_additive (attr := simp)]\ntheorem image_inv : Inv.inv '' s = s\u207b\u00b9", "start": [256, 1], "end": [258, 100], "kind": "commanddeclaration"}, {"full_name": "Set.involutiveInv", "code": "@[to_additive (attr := simp)]\nnoncomputable instance involutiveInv : InvolutiveInv (Set \u03b1) where\n  inv := Inv.inv\n  inv_inv s := by simp only [\u2190 inv_preimage, preimage_preimage, inv_inv, preimage_id']", "start": [262, 1], "end": [265, 87], "kind": "commanddeclaration"}, {"full_name": "Set.inv_subset_inv", "code": "@[to_additive (attr := simp)]\ntheorem inv_subset_inv : s\u207b\u00b9 \u2286 t\u207b\u00b9 \u2194 s \u2286 t", "start": [267, 1], "end": [269, 56], "kind": "commanddeclaration"}, {"full_name": "Set.inv_subset", "code": "@[to_additive]\ntheorem inv_subset : s\u207b\u00b9 \u2286 t \u2194 s \u2286 t\u207b\u00b9", "start": [273, 1], "end": [274, 76], "kind": "commanddeclaration"}, {"full_name": "Set.inv_singleton", "code": "@[to_additive (attr := simp)]\ntheorem inv_singleton (a : \u03b1) : ({a} : Set \u03b1)\u207b\u00b9 = {a\u207b\u00b9}", "start": [278, 1], "end": [279, 96], "kind": "commanddeclaration"}, {"full_name": "Set.inv_insert", "code": "@[to_additive (attr := simp)]\ntheorem inv_insert (a : \u03b1) (s : Set \u03b1) : (insert a s)\u207b\u00b9 = insert a\u207b\u00b9 s\u207b\u00b9", "start": [283, 1], "end": [285, 54], "kind": "commanddeclaration"}, {"full_name": "Set.inv_range", "code": "@[to_additive]\ntheorem inv_range {\u03b9 : Sort*} {f : \u03b9 \u2192 \u03b1} : (range f)\u207b\u00b9 = range fun i => (f i)\u207b\u00b9", "start": [289, 1], "end": [292, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_op_inv", "code": "@[to_additive]\ntheorem image_op_inv : op '' s\u207b\u00b9 = (op '' s)\u207b\u00b9", "start": [298, 1], "end": [300, 62], "kind": "commanddeclaration"}, {"full_name": "Set.mul", "code": "@[to_additive\n      \"The pointwise addition of sets `s + t` is defined as `{x + y | x \u2208 s, y \u2208 t}` in locale\n      `Pointwise`.\"]\nprotected def mul : Mul (Set \u03b1) :=\n  \u27e8image2 (\u00b7 * \u00b7)\u27e9", "start": [317, 1], "end": [323, 19], "kind": "commanddeclaration"}, {"full_name": "Set.image2_mul", "code": "@[to_additive (attr := simp)]\ntheorem image2_mul : image2 (\u00b7 * \u00b7) s t = s * t", "start": [329, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_mul", "code": "@[to_additive]\ntheorem mem_mul : a \u2208 s * t \u2194 \u2203 x y, x \u2208 s \u2227 y \u2208 t \u2227 x * y = a", "start": [335, 1], "end": [337, 10], "kind": "commanddeclaration"}, {"full_name": "Set.mul_mem_mul", "code": "@[to_additive]\ntheorem mul_mem_mul : a \u2208 s \u2192 b \u2208 t \u2192 a * b \u2208 s * t", "start": [341, 1], "end": [343, 20], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_prod", "code": "@[to_additive add_image_prod]\ntheorem image_mul_prod : (fun x : \u03b1 \u00d7 \u03b1 => x.fst * x.snd) '' s \u00d7\u02e2 t = s * t", "start": [348, 1], "end": [350, 15], "kind": "commanddeclaration"}, {"full_name": "Set.empty_mul", "code": "@[to_additive (attr := simp)]\ntheorem empty_mul : \u2205 * s = \u2205", "start": [354, 1], "end": [356, 20], "kind": "commanddeclaration"}, {"full_name": "Set.mul_empty", "code": "@[to_additive (attr := simp)]\ntheorem mul_empty : s * \u2205 = \u2205", "start": [360, 1], "end": [362, 21], "kind": "commanddeclaration"}, {"full_name": "Set.mul_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [366, 1], "end": [368, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mul_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [372, 1], "end": [374, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.mul", "code": "@[to_additive]\ntheorem Nonempty.mul : s.Nonempty \u2192 t.Nonempty \u2192 (s * t).Nonempty", "start": [378, 1], "end": [380, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_mul_left", "code": "@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty \u2192 s.Nonempty", "start": [384, 1], "end": [386, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_mul_right", "code": "@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty \u2192 t.Nonempty", "start": [390, 1], "end": [392, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mul_singleton", "code": "@[to_additive (attr := simp)]\ntheorem mul_singleton : s * {b} = (\u00b7 * b) '' s", "start": [396, 1], "end": [398, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_mul", "code": "@[to_additive (attr := simp)]\ntheorem singleton_mul : {a} * t = (\u00b7 * \u00b7) a '' t", "start": [402, 1], "end": [404, 24], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_mul_singleton", "code": "@[to_additive]\ntheorem singleton_mul_singleton : ({a} : Set \u03b1) * {b} = {a * b}", "start": [409, 1], "end": [411, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_mul", "code": "@[to_additive (attr := mono)]\ntheorem mul_subset_mul : s\u2081 \u2286 t\u2081 \u2192 s\u2082 \u2286 t\u2082 \u2192 s\u2081 * s\u2082 \u2286 t\u2081 * t\u2082", "start": [415, 1], "end": [417, 16], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_mul_left", "code": "@[to_additive]\ntheorem mul_subset_mul_left : t\u2081 \u2286 t\u2082 \u2192 s * t\u2081 \u2286 s * t\u2082", "start": [421, 1], "end": [423, 21], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_mul_right", "code": "@[to_additive]\ntheorem mul_subset_mul_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 * t \u2286 s\u2082 * t", "start": [427, 1], "end": [429, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_iff", "code": "@[to_additive]\ntheorem mul_subset_iff : s * t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x * y \u2208 u", "start": [433, 1], "end": [435, 20], "kind": "commanddeclaration"}, {"full_name": "Set.union_mul", "code": "@[to_additive]\ntheorem union_mul : (s\u2081 \u222a s\u2082) * t = s\u2081 * t \u222a s\u2082 * t", "start": [439, 1], "end": [441, 20], "kind": "commanddeclaration"}, {"full_name": "Set.mul_union", "code": "@[to_additive]\ntheorem mul_union : s * (t\u2081 \u222a t\u2082) = s * t\u2081 \u222a s * t\u2082", "start": [445, 1], "end": [447, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_mul_subset", "code": "@[to_additive]\ntheorem inter_mul_subset : s\u2081 \u2229 s\u2082 * t \u2286 s\u2081 * t \u2229 (s\u2082 * t)", "start": [451, 1], "end": [453, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mul_inter_subset", "code": "@[to_additive]\ntheorem mul_inter_subset : s * (t\u2081 \u2229 t\u2082) \u2286 s * t\u2081 \u2229 (s * t\u2082)", "start": [457, 1], "end": [459, 28], "kind": "commanddeclaration"}, {"full_name": "Set.inter_mul_union_subset_union", "code": "@[to_additive]\ntheorem inter_mul_union_subset_union : s\u2081 \u2229 s\u2082 * (t\u2081 \u222a t\u2082) \u2286 s\u2081 * t\u2081 \u222a s\u2082 * t\u2082", "start": [463, 1], "end": [465, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_mul_inter_subset_union", "code": "@[to_additive]\ntheorem union_mul_inter_subset_union : (s\u2081 \u222a s\u2082) * (t\u2081 \u2229 t\u2082) \u2286 s\u2081 * t\u2081 \u222a s\u2082 * t\u2082", "start": [469, 1], "end": [471, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mul_left_image", "code": "@[to_additive]\ntheorem iUnion_mul_left_image : \u22c3 a \u2208 s, (\u00b7 * \u00b7) a '' t = s * t", "start": [475, 1], "end": [477, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mul_right_image", "code": "@[to_additive]\ntheorem iUnion_mul_right_image : \u22c3 a \u2208 t, (\u00b7 * a) '' s = s * t", "start": [481, 1], "end": [483, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_mul", "code": "@[to_additive]\ntheorem iUnion_mul (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (\u22c3 i, s i) * t = \u22c3 i, s i * t", "start": [487, 1], "end": [489, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mul_iUnion", "code": "@[to_additive]\ntheorem mul_iUnion (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b1) : (s * \u22c3 i, t i) = \u22c3 i, s * t i", "start": [493, 1], "end": [495, 28], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_mul", "code": "@[to_additive]\ntheorem iUnion\u2082_mul (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c3 (i) (j), s i j) * t = \u22c3 (i) (j), s i j * t", "start": [501, 1], "end": [504, 28], "kind": "commanddeclaration"}, {"full_name": "Set.mul_iUnion\u2082", "code": "@[to_additive]\ntheorem mul_iUnion\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s * \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s * t i j", "start": [510, 1], "end": [513, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_mul_subset", "code": "@[to_additive]\ntheorem iInter_mul_subset (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (\u22c2 i, s i) * t \u2286 \u22c2 i, s i * t", "start": [517, 1], "end": [519, 34], "kind": "commanddeclaration"}, {"full_name": "Set.mul_iInter_subset", "code": "@[to_additive]\ntheorem mul_iInter_subset (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b1) : (s * \u22c2 i, t i) \u2286 \u22c2 i, s * t i", "start": [523, 1], "end": [525, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_mul_subset", "code": "@[to_additive]\ntheorem iInter\u2082_mul_subset (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) * t \u2286 \u22c2 (i) (j), s i j * t", "start": [531, 1], "end": [534, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mul_iInter\u2082_subset", "code": "@[to_additive]\ntheorem mul_iInter\u2082_subset (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s * \u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), s * t i j", "start": [540, 1], "end": [543, 36], "kind": "commanddeclaration"}, {"full_name": "Set.singletonMulHom", "code": "@[to_additive \"The singleton operation as an `AddHom`.\"]\nnoncomputable def singletonMulHom : \u03b1 \u2192\u2099* Set \u03b1 where\n  toFun := singleton\n  map_mul' _ _ := singleton_mul_singleton.symm", "start": [547, 1], "end": [551, 47], "kind": "commanddeclaration"}, {"full_name": "Set.coe_singletonMulHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : \u03b1 \u2192 Set \u03b1) = singleton", "start": [555, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "Set.singletonMulHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : \u03b1) : singletonMulHom a = {a}", "start": [561, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "Set.image_op_mul", "code": "@[to_additive (attr := simp)]\ntheorem image_op_mul : op '' (s * t) = op '' t * op '' s", "start": [569, 1], "end": [571, 34], "kind": "commanddeclaration"}, {"full_name": "Set.div", "code": "@[to_additive\n      \"The pointwise subtraction of sets `s - t` is defined as `{x - y | x \u2208 s, y \u2208 t}` in locale\n      `Pointwise`.\"]\nprotected def div : Div (Set \u03b1) :=\n  \u27e8image2 (\u00b7 / \u00b7)\u27e9", "start": [584, 1], "end": [590, 19], "kind": "commanddeclaration"}, {"full_name": "Set.image2_div", "code": "@[to_additive (attr := simp)]\ntheorem image2_div : image2 Div.div s t = s / t", "start": [596, 1], "end": [598, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_div", "code": "@[to_additive]\ntheorem mem_div : a \u2208 s / t \u2194 \u2203 x y, x \u2208 s \u2227 y \u2208 t \u2227 x / y = a", "start": [602, 1], "end": [604, 10], "kind": "commanddeclaration"}, {"full_name": "Set.div_mem_div", "code": "@[to_additive]\ntheorem div_mem_div : a \u2208 s \u2192 b \u2208 t \u2192 a / b \u2208 s / t", "start": [608, 1], "end": [610, 20], "kind": "commanddeclaration"}, {"full_name": "Set.image_div_prod", "code": "@[to_additive sub_image_prod]\ntheorem image_div_prod : (fun x : \u03b1 \u00d7 \u03b1 => x.fst / x.snd) '' s \u00d7\u02e2 t = s / t", "start": [615, 1], "end": [617, 15], "kind": "commanddeclaration"}, {"full_name": "Set.empty_div", "code": "@[to_additive (attr := simp)]\ntheorem empty_div : \u2205 / s = \u2205", "start": [621, 1], "end": [623, 20], "kind": "commanddeclaration"}, {"full_name": "Set.div_empty", "code": "@[to_additive (attr := simp)]\ntheorem div_empty : s / \u2205 = \u2205", "start": [627, 1], "end": [629, 21], "kind": "commanddeclaration"}, {"full_name": "Set.div_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [633, 1], "end": [635, 22], "kind": "commanddeclaration"}, {"full_name": "Set.div_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [639, 1], "end": [641, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.div", "code": "@[to_additive]\ntheorem Nonempty.div : s.Nonempty \u2192 t.Nonempty \u2192 (s / t).Nonempty", "start": [645, 1], "end": [647, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_div_left", "code": "@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty \u2192 s.Nonempty", "start": [651, 1], "end": [653, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_div_right", "code": "@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty \u2192 t.Nonempty", "start": [657, 1], "end": [659, 27], "kind": "commanddeclaration"}, {"full_name": "Set.div_singleton", "code": "@[to_additive (attr := simp)]\ntheorem div_singleton : s / {b} = (\u00b7 / b) '' s", "start": [663, 1], "end": [665, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_div", "code": "@[to_additive (attr := simp)]\ntheorem singleton_div : {a} / t = (\u00b7 / \u00b7) a '' t", "start": [669, 1], "end": [671, 24], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_div_singleton", "code": "@[to_additive]\ntheorem singleton_div_singleton : ({a} : Set \u03b1) / {b} = {a / b}", "start": [676, 1], "end": [678, 19], "kind": "commanddeclaration"}, {"full_name": "Set.div_subset_div", "code": "@[to_additive (attr := mono)]\ntheorem div_subset_div : s\u2081 \u2286 t\u2081 \u2192 s\u2082 \u2286 t\u2082 \u2192 s\u2081 / s\u2082 \u2286 t\u2081 / t\u2082", "start": [682, 1], "end": [684, 16], "kind": "commanddeclaration"}, {"full_name": "Set.div_subset_div_left", "code": "@[to_additive]\ntheorem div_subset_div_left : t\u2081 \u2286 t\u2082 \u2192 s / t\u2081 \u2286 s / t\u2082", "start": [688, 1], "end": [690, 21], "kind": "commanddeclaration"}, {"full_name": "Set.div_subset_div_right", "code": "@[to_additive]\ntheorem div_subset_div_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 / t \u2286 s\u2082 / t", "start": [694, 1], "end": [696, 22], "kind": "commanddeclaration"}, {"full_name": "Set.div_subset_iff", "code": "@[to_additive]\ntheorem div_subset_iff : s / t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x / y \u2208 u", "start": [700, 1], "end": [702, 20], "kind": "commanddeclaration"}, {"full_name": "Set.union_div", "code": "@[to_additive]\ntheorem union_div : (s\u2081 \u222a s\u2082) / t = s\u2081 / t \u222a s\u2082 / t", "start": [706, 1], "end": [708, 20], "kind": "commanddeclaration"}, {"full_name": "Set.div_union", "code": "@[to_additive]\ntheorem div_union : s / (t\u2081 \u222a t\u2082) = s / t\u2081 \u222a s / t\u2082", "start": [712, 1], "end": [714, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_div_subset", "code": "@[to_additive]\ntheorem inter_div_subset : s\u2081 \u2229 s\u2082 / t \u2286 s\u2081 / t \u2229 (s\u2082 / t)", "start": [718, 1], "end": [720, 27], "kind": "commanddeclaration"}, {"full_name": "Set.div_inter_subset", "code": "@[to_additive]\ntheorem div_inter_subset : s / (t\u2081 \u2229 t\u2082) \u2286 s / t\u2081 \u2229 (s / t\u2082)", "start": [724, 1], "end": [726, 28], "kind": "commanddeclaration"}, {"full_name": "Set.inter_div_union_subset_union", "code": "@[to_additive]\ntheorem inter_div_union_subset_union : s\u2081 \u2229 s\u2082 / (t\u2081 \u222a t\u2082) \u2286 s\u2081 / t\u2081 \u222a s\u2082 / t\u2082", "start": [730, 1], "end": [732, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_div_inter_subset_union", "code": "@[to_additive]\ntheorem union_div_inter_subset_union : (s\u2081 \u222a s\u2082) / (t\u2081 \u2229 t\u2082) \u2286 s\u2081 / t\u2081 \u222a s\u2082 / t\u2082", "start": [736, 1], "end": [738, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_div_left_image", "code": "@[to_additive]\ntheorem iUnion_div_left_image : \u22c3 a \u2208 s, (\u00b7 / \u00b7) a '' t = s / t", "start": [742, 1], "end": [744, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_div_right_image", "code": "@[to_additive]\ntheorem iUnion_div_right_image : \u22c3 a \u2208 t, (\u00b7 / a) '' s = s / t", "start": [748, 1], "end": [750, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_div", "code": "@[to_additive]\ntheorem iUnion_div (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (\u22c3 i, s i) / t = \u22c3 i, s i / t", "start": [754, 1], "end": [756, 27], "kind": "commanddeclaration"}, {"full_name": "Set.div_iUnion", "code": "@[to_additive]\ntheorem div_iUnion (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b1) : (s / \u22c3 i, t i) = \u22c3 i, s / t i", "start": [760, 1], "end": [762, 28], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_div", "code": "@[to_additive]\ntheorem iUnion\u2082_div (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c3 (i) (j), s i j) / t = \u22c3 (i) (j), s i j / t", "start": [768, 1], "end": [771, 28], "kind": "commanddeclaration"}, {"full_name": "Set.div_iUnion\u2082", "code": "@[to_additive]\ntheorem div_iUnion\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s / \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s / t i j", "start": [777, 1], "end": [780, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_div_subset", "code": "@[to_additive]\ntheorem iInter_div_subset (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b1) : (\u22c2 i, s i) / t \u2286 \u22c2 i, s i / t", "start": [784, 1], "end": [786, 34], "kind": "commanddeclaration"}, {"full_name": "Set.div_iInter_subset", "code": "@[to_additive]\ntheorem div_iInter_subset (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b1) : (s / \u22c2 i, t i) \u2286 \u22c2 i, s / t i", "start": [790, 1], "end": [792, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_div_subset", "code": "@[to_additive]\ntheorem iInter\u2082_div_subset (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b1) :\n    (\u22c2 (i) (j), s i j) / t \u2286 \u22c2 (i) (j), s i j / t", "start": [798, 1], "end": [801, 35], "kind": "commanddeclaration"}, {"full_name": "Set.div_iInter\u2082_subset", "code": "@[to_additive]\ntheorem div_iInter\u2082_subset (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b1) :\n    (s / \u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), s / t i j", "start": [807, 1], "end": [810, 36], "kind": "commanddeclaration"}, {"full_name": "Set.NSMul", "code": "protected def NSMul [Zero \u03b1] [Add \u03b1] : SMul \u2115 (Set \u03b1) :=\n  \u27e8nsmulRec\u27e9", "start": [818, 1], "end": [821, 13], "kind": "commanddeclaration"}, {"full_name": "Set.NPow", "code": "@[to_additive existing]\nprotected def NPow [One \u03b1] [Mul \u03b1] : Pow (Set \u03b1) \u2115 :=\n  \u27e8fun s n => npowRec n s\u27e9", "start": [824, 1], "end": [828, 27], "kind": "commanddeclaration"}, {"full_name": "Set.ZSMul", "code": "protected def ZSMul [Zero \u03b1] [Add \u03b1] [Neg \u03b1] : SMul \u2124 (Set \u03b1) :=\n  \u27e8zsmulRec\u27e9", "start": [831, 1], "end": [834, 13], "kind": "commanddeclaration"}, {"full_name": "Set.ZPow", "code": "@[to_additive existing]\nprotected def ZPow [One \u03b1] [Mul \u03b1] [Inv \u03b1] : Pow (Set \u03b1) \u2124 :=\n  \u27e8fun s n => zpowRec n s\u27e9", "start": [837, 1], "end": [841, 27], "kind": "commanddeclaration"}, {"full_name": "Set.semigroup", "code": "@[to_additive \"`Set \u03b1` is an `AddSemigroup` under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def semigroup [Semigroup \u03b1] : Semigroup (Set \u03b1) :=\n  { Set.mul with mul_assoc := fun _ _ _ => image2_assoc mul_assoc }", "start": [846, 1], "end": [849, 68], "kind": "commanddeclaration"}, {"full_name": "Set.commSemigroup", "code": "@[to_additive \"`Set \u03b1` is an `AddCommSemigroup` under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def commSemigroup : CommSemigroup (Set \u03b1) :=\n  { Set.semigroup with mul_comm := fun _ _ => image2_comm mul_comm }", "start": [857, 1], "end": [860, 69], "kind": "commanddeclaration"}, {"full_name": "Set.inter_mul_union_subset", "code": "@[to_additive]\ntheorem inter_mul_union_subset : s \u2229 t * (s \u222a t) \u2286 s * t", "start": [864, 1], "end": [866, 37], "kind": "commanddeclaration"}, {"full_name": "Set.union_mul_inter_subset", "code": "@[to_additive]\ntheorem union_mul_inter_subset : (s \u222a t) * (s \u2229 t) \u2286 s * t", "start": [870, 1], "end": [872, 37], "kind": "commanddeclaration"}, {"full_name": "Set.mulOneClass", "code": "@[to_additive \"`Set \u03b1` is an `AddZeroClass` under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def mulOneClass : MulOneClass (Set \u03b1) :=\n  { Set.one, Set.mul with\n    mul_one := image2_right_identity mul_one\n    one_mul := image2_left_identity one_mul }", "start": [882, 1], "end": [887, 46], "kind": "commanddeclaration"}, {"full_name": "Set.subset_mul_left", "code": "@[to_additive]\ntheorem subset_mul_left (s : Set \u03b1) {t : Set \u03b1} (ht : (1 : \u03b1) \u2208 t) : s \u2286 s * t", "start": [896, 1], "end": [898, 28], "kind": "commanddeclaration"}, {"full_name": "Set.subset_mul_right", "code": "@[to_additive]\ntheorem subset_mul_right {s : Set \u03b1} (t : Set \u03b1) (hs : (1 : \u03b1) \u2208 s) : t \u2286 s * t", "start": [902, 1], "end": [904, 28], "kind": "commanddeclaration"}, {"full_name": "Set.singletonMonoidHom", "code": "@[to_additive \"The singleton operation as an `AddMonoidHom`.\"]\nnoncomputable def singletonMonoidHom : \u03b1 \u2192* Set \u03b1 :=\n  { singletonMulHom, singletonOneHom with }", "start": [908, 1], "end": [911, 44], "kind": "commanddeclaration"}, {"full_name": "Set.coe_singletonMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : \u03b1 \u2192 Set \u03b1) = singleton", "start": [915, 1], "end": [917, 6], "kind": "commanddeclaration"}, {"full_name": "Set.singletonMonoidHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : \u03b1) : singletonMonoidHom a = {a}", "start": [921, 1], "end": [923, 6], "kind": "commanddeclaration"}, {"full_name": "Set.monoid", "code": "@[to_additive \"`Set \u03b1` is an `AddMonoid` under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def monoid : Monoid (Set \u03b1) :=\n  { Set.semigroup, Set.mulOneClass, @Set.NPow \u03b1 _ _ with }", "start": [933, 1], "end": [936, 59], "kind": "commanddeclaration"}, {"full_name": "Set.pow_mem_pow", "code": "@[to_additive]\ntheorem pow_mem_pow (ha : a \u2208 s) : \u2200 n : \u2115, a ^ n \u2208 s ^ n", "start": [942, 1], "end": [949, 44], "kind": "commanddeclaration"}, {"full_name": "Set.pow_subset_pow", "code": "@[to_additive]\ntheorem pow_subset_pow (hst : s \u2286 t) : \u2200 n : \u2115, s ^ n \u2286 t ^ n", "start": [953, 1], "end": [960, 52], "kind": "commanddeclaration"}, {"full_name": "Set.pow_subset_pow_of_one_mem", "code": "@[to_additive]\ntheorem pow_subset_pow_of_one_mem (hs : (1 : \u03b1) \u2208 s) (hn : m \u2264 n) : s ^ m \u2286 s ^ n", "start": [964, 1], "end": [972, 43], "kind": "commanddeclaration"}, {"full_name": "Set.empty_pow", "code": "@[to_additive (attr := simp)]\ntheorem empty_pow {n : \u2115} (hn : n \u2260 0) : (\u2205 : Set \u03b1) ^ n = \u2205", "start": [976, 1], "end": [978, 97], "kind": "commanddeclaration"}, {"full_name": "Set.mul_univ_of_one_mem", "code": "@[to_additive]\ntheorem mul_univ_of_one_mem (hs : (1 : \u03b1) \u2208 s) : s * univ = univ", "start": [982, 1], "end": [984, 76], "kind": "commanddeclaration"}, {"full_name": "Set.univ_mul_of_one_mem", "code": "@[to_additive]\ntheorem univ_mul_of_one_mem (ht : (1 : \u03b1) \u2208 t) : univ * t = univ", "start": [988, 1], "end": [990, 76], "kind": "commanddeclaration"}, {"full_name": "Set.univ_mul_univ", "code": "@[to_additive (attr := simp)]\ntheorem univ_mul_univ : (univ : Set \u03b1) * univ = univ", "start": [994, 1], "end": [996, 36], "kind": "commanddeclaration"}, {"full_name": "Set.nsmul_univ", "code": "@[simp]\ntheorem nsmul_univ {\u03b1 : Type*} [AddMonoid \u03b1] : \u2200 {n : \u2115}, n \u2260 0 \u2192 n \u2022 (univ : Set \u03b1) = univ", "start": [1001, 1], "end": [1005, 83], "kind": "commanddeclaration"}, {"full_name": "Set.univ_pow", "code": "@[to_additive existing (attr := simp) nsmul_univ]\ntheorem univ_pow : \u2200 {n : \u2115}, n \u2260 0 \u2192 (univ : Set \u03b1) ^ n = univ", "start": [1008, 1], "end": [1012, 79], "kind": "commanddeclaration"}, {"full_name": "IsUnit.set", "code": "@[to_additive]\nprotected theorem _root_.IsUnit.set : IsUnit a \u2192 IsUnit ({a} : Set \u03b1)", "start": [1015, 1], "end": [1017, 47], "kind": "commanddeclaration"}, {"full_name": "Set.commMonoid", "code": "@[to_additive \"`Set \u03b1` is an `AddCommMonoid` under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def commMonoid [CommMonoid \u03b1] : CommMonoid (Set \u03b1) :=\n  { Set.monoid, Set.commSemigroup with }", "start": [1023, 1], "end": [1026, 41], "kind": "commanddeclaration"}, {"full_name": "Set.mul_eq_one_iff", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 \u2194 \u2203 a b, s = {a} \u2227 t = {b} \u2227 a * b = 1", "start": [1038, 1], "end": [1050, 51], "kind": "commanddeclaration"}, {"full_name": "Set.divisionMonoid", "code": "@[to_additive subtractionMonoid\n    \"`Set \u03b1` is a subtraction monoid under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def divisionMonoid : DivisionMonoid (Set \u03b1) :=\n  { Set.monoid, Set.involutiveInv, Set.div, @Set.ZPow \u03b1 _ _ _ with\n    mul_inv_rev := fun s t => by\n      simp_rw [\u2190 image_inv]\n      exact image_image2_antidistrib mul_inv_rev\n    inv_eq_of_mul := fun s t h => by\n      obtain \u27e8a, b, rfl, rfl, hab\u27e9 := Set.mul_eq_one_iff.1 h\n      rw [inv_singleton, inv_eq_of_mul_eq_one_right hab]\n    div_eq_mul_inv := fun s t => by\n      rw [\u2190 image_id (s / t), \u2190 image_inv]\n      exact image_image2_distrib_right div_eq_mul_inv }", "start": [1054, 1], "end": [1067, 56], "kind": "commanddeclaration"}, {"full_name": "Set.isUnit_iff", "code": "@[to_additive (attr := simp 500)]\ntheorem isUnit_iff : IsUnit s \u2194 \u2203 a, s = {a} \u2227 IsUnit a", "start": [1071, 1], "end": [1080, 17], "kind": "commanddeclaration"}, {"full_name": "Set.divisionCommMonoid", "code": "@[to_additive subtractionCommMonoid\n      \"`Set \u03b1` is a commutative subtraction monoid under pointwise operations if `\u03b1` is.\"]\nprotected noncomputable def divisionCommMonoid [DivisionCommMonoid \u03b1] :\n    DivisionCommMonoid (Set \u03b1) :=\n  { Set.divisionMonoid, Set.commSemigroup with }", "start": [1086, 1], "end": [1091, 49], "kind": "commanddeclaration"}, {"full_name": "Set.hasDistribNeg", "code": "protected noncomputable def hasDistribNeg [Mul \u03b1] [HasDistribNeg \u03b1] : HasDistribNeg (Set \u03b1) :=\n  { Set.involutiveNeg with\n    neg_mul := fun _ _ => by\n      simp_rw [\u2190 image_neg]\n      exact image2_image_left_comm neg_mul\n    mul_neg := fun _ _ => by\n      simp_rw [\u2190 image_neg]\n      exact image_image2_right_comm mul_neg }", "start": [1095, 1], "end": [1103, 46], "kind": "commanddeclaration"}, {"full_name": "Set.mul_add_subset", "code": "theorem mul_add_subset : s * (t + u) \u2286 s * t + s * u", "start": [1121, 1], "end": [1122, 37], "kind": "commanddeclaration"}, {"full_name": "Set.add_mul_subset", "code": "theorem add_mul_subset : (s + t) * u \u2286 s * u + t * u", "start": [1125, 1], "end": [1126, 38], "kind": "commanddeclaration"}, {"full_name": "Set.mul_zero_subset", "code": "theorem mul_zero_subset (s : Set \u03b1) : s * 0 \u2286 0", "start": [1138, 1], "end": [1138, 81], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mul_subset", "code": "theorem zero_mul_subset (s : Set \u03b1) : 0 * s \u2286 0", "start": [1141, 1], "end": [1141, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.mul_zero", "code": "theorem Nonempty.mul_zero (hs : s.Nonempty) : s * 0 = 0", "start": [1144, 1], "end": [1145, 60], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.zero_mul", "code": "theorem Nonempty.zero_mul (hs : s.Nonempty) : 0 * s = 0", "start": [1148, 1], "end": [1149, 60], "kind": "commanddeclaration"}, {"full_name": "Set.one_mem_div_iff", "code": "@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : \u03b1) \u2208 s / t \u2194 \u00acDisjoint s t", "start": [1161, 1], "end": [1163, 76], "kind": "commanddeclaration"}, {"full_name": "Set.not_one_mem_div_iff", "code": "@[to_additive]\ntheorem not_one_mem_div_iff : (1 : \u03b1) \u2209 s / t \u2194 Disjoint s t", "start": [1167, 1], "end": [1169, 27], "kind": "commanddeclaration"}, {"full_name": "Disjoint.one_not_mem_div_set", "code": "alias \u27e8_, _root_.Disjoint.one_not_mem_div_set\u27e9 := not_one_mem_div_iff", "start": [1173, 1], "end": [1173, 70], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Nonempty.one_mem_div", "code": "@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : \u03b1) \u2208 s / s", "start": [1179, 1], "end": [1182, 40], "kind": "commanddeclaration"}, {"full_name": "Set.isUnit_singleton", "code": "@[to_additive]\ntheorem isUnit_singleton (a : \u03b1) : IsUnit ({a} : Set \u03b1)", "start": [1186, 1], "end": [1188, 23], "kind": "commanddeclaration"}, {"full_name": "Set.isUnit_iff_singleton", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_iff_singleton : IsUnit s \u2194 \u2203 a, s = {a}", "start": [1192, 1], "end": [1194, 53], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem image_mul_left : (\u00b7 * \u00b7) a '' t = (\u00b7 * \u00b7) a\u207b\u00b9 \u207b\u00b9' t", "start": [1198, 1], "end": [1200, 57], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem image_mul_right : (\u00b7 * b) '' t = (\u00b7 * b\u207b\u00b9) \u207b\u00b9' t", "start": [1204, 1], "end": [1206, 57], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_left'", "code": "@[to_additive]\ntheorem image_mul_left' : (fun b => a\u207b\u00b9 * b) '' t = (fun b => a * b) \u207b\u00b9' t", "start": [1210, 1], "end": [1211, 86], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_right'", "code": "@[to_additive]\ntheorem image_mul_right' : (\u00b7 * b\u207b\u00b9) '' t = (\u00b7 * b) \u207b\u00b9' t", "start": [1215, 1], "end": [1216, 69], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_left_singleton", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton : (\u00b7 * \u00b7) a \u207b\u00b9' {b} = {a\u207b\u00b9 * b}", "start": [1220, 1], "end": [1222, 42], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_right_singleton", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton : (\u00b7 * a) \u207b\u00b9' {b} = {b * a\u207b\u00b9}", "start": [1226, 1], "end": [1228, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_left_one", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : (\u00b7 * \u00b7) a \u207b\u00b9' 1 = {a\u207b\u00b9}", "start": [1232, 1], "end": [1234, 45], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_right_one", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : (\u00b7 * b) \u207b\u00b9' 1 = {b\u207b\u00b9}", "start": [1238, 1], "end": [1240, 46], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_left_one'", "code": "@[to_additive]\ntheorem preimage_mul_left_one' : (fun b => a\u207b\u00b9 * b) \u207b\u00b9' 1 = {a}", "start": [1244, 1], "end": [1245, 75], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_right_one'", "code": "@[to_additive]\ntheorem preimage_mul_right_one' : (\u00b7 * b\u207b\u00b9) \u207b\u00b9' 1 = {b}", "start": [1249, 1], "end": [1250, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mul_univ", "code": "@[to_additive (attr := simp)]\ntheorem mul_univ (hs : s.Nonempty) : s * (univ : Set \u03b1) = univ", "start": [1254, 1], "end": [1257, 80], "kind": "commanddeclaration"}, {"full_name": "Set.univ_mul", "code": "@[to_additive (attr := simp)]\ntheorem univ_mul (ht : t.Nonempty) : (univ : Set \u03b1) * t = univ", "start": [1261, 1], "end": [1264, 81], "kind": "commanddeclaration"}, {"full_name": "Set.div_zero_subset", "code": "theorem div_zero_subset (s : Set \u03b1) : s / 0 \u2286 0", "start": [1274, 1], "end": [1274, 81], "kind": "commanddeclaration"}, {"full_name": "Set.zero_div_subset", "code": "theorem zero_div_subset (s : Set \u03b1) : 0 / s \u2286 0", "start": [1277, 1], "end": [1277, 81], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.div_zero", "code": "theorem Nonempty.div_zero (hs : s.Nonempty) : s / 0 = 0", "start": [1280, 1], "end": [1281, 60], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.zero_div", "code": "theorem Nonempty.zero_div (hs : s.Nonempty) : 0 / s = 0", "start": [1284, 1], "end": [1285, 60], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul", "code": "@[to_additive]\ntheorem image_mul : m '' (s * t) = m '' s * m '' t", "start": [1294, 1], "end": [1296, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_preimage_subset", "code": "@[to_additive]\ntheorem preimage_mul_preimage_subset {s t : Set \u03b2} : m \u207b\u00b9' s * m \u207b\u00b9' t \u2286 m \u207b\u00b9' (s * t)", "start": [1300, 1], "end": [1303, 47], "kind": "commanddeclaration"}, {"full_name": "Set.image_div", "code": "@[to_additive]\ntheorem image_div : m '' (s / t) = m '' s / m '' t", "start": [1313, 1], "end": [1315, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_div_preimage_subset", "code": "@[to_additive]\ntheorem preimage_div_preimage_subset {s t : Set \u03b2} : m \u207b\u00b9' s / m \u207b\u00b9' t \u2286 m \u207b\u00b9' (s / t)", "start": [1319, 1], "end": [1322, 47], "kind": "commanddeclaration"}, {"full_name": "Set.bddAbove_mul", "code": "@[to_additive]\ntheorem bddAbove_mul [OrderedCommMonoid \u03b1] {A B : Set \u03b1} :\n    BddAbove A \u2192 BddAbove B \u2192 BddAbove (A * B)", "start": [1328, 1], "end": [1334, 40], "kind": "commanddeclaration"}, {"full_name": "Group.card_pow_eq_card_pow_card_univ_aux", "code": "@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ_aux {f : \u2115 \u2192 \u2115} (h1 : Monotone f) {B : \u2115} (h2 : \u2200 n, f n \u2264 B)\n    (h3 : \u2200 n, f n = f (n + 1) \u2192 f (n + 1) = f (n + 2)) : \u2200 k, B \u2264 k \u2192 f k = f B", "start": [1349, 1], "end": [1366, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pairwise/Lattice.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.pairwise_iUnion", "code": "theorem pairwise_iUnion {f : \u03ba \u2192 Set \u03b1} (h : Directed (\u00b7 \u2286 \u00b7) f) :\n    (\u22c3 n, f n).Pairwise r \u2194 \u2200 n, (f n).Pairwise r", "start": [27, 1], "end": [36, 34], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_sUnion", "code": "theorem pairwise_sUnion {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : Set (Set \u03b1)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).Pairwise r \u2194 \u2200 a \u2208 s, Set.Pairwise a r", "start": [39, 1], "end": [41, 71], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_iUnion", "code": "theorem pairwiseDisjoint_iUnion {g : \u03b9' \u2192 Set \u03b9} (h : Directed (\u00b7 \u2286 \u00b7) g) :\n    (\u22c3 n, g n).PairwiseDisjoint f \u2194 \u2200 \u2983n\u2984, (g n).PairwiseDisjoint f", "start": [54, 1], "end": [56, 20], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_sUnion", "code": "theorem pairwiseDisjoint_sUnion {s : Set (Set \u03b9)} (h : DirectedOn (\u00b7 \u2286 \u00b7) s) :\n    (\u22c3\u2080 s).PairwiseDisjoint f \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Set.PairwiseDisjoint a f", "start": [59, 1], "end": [61, 20], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.biUnion", "code": "theorem PairwiseDisjoint.biUnion {s : Set \u03b9'} {g : \u03b9' \u2192 Set \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => \u2a06 i \u2208 g i', f i)\n    (hg : \u2200 i \u2208 s, (g i).PairwiseDisjoint f) : (\u22c3 i \u2208 s, g i).PairwiseDisjoint f", "start": [70, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.prod_left", "code": "theorem PairwiseDisjoint.prod_left {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i'))\n    (ht : t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i')) :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f", "start": [87, 1], "end": [101, 45], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_prod_left", "code": "theorem pairwiseDisjoint_prod_left {s : Set \u03b9} {t : Set \u03b9'} {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1} :\n    (s \u00d7\u02e2 t : Set (\u03b9 \u00d7 \u03b9')).PairwiseDisjoint f \u2194\n      (s.PairwiseDisjoint fun i => \u2a06 i' \u2208 t, f (i, i')) \u2227\n        t.PairwiseDisjoint fun i' => \u2a06 i \u2208 s, f (i, i')", "start": [110, 1], "end": [119, 84], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_diff_biUnion_eq", "code": "theorem biUnion_diff_biUnion_eq {s t : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : (s \u222a t).PairwiseDisjoint f) :\n    ((\u22c3 i \u2208 s, f i) \\ \u22c3 i \u2208 t, f i) = \u22c3 i \u2208 s \\ t, f i", "start": [124, 1], "end": [130, 91], "kind": "commanddeclaration"}, {"full_name": "Set.biUnionEqSigmaOfDisjoint", "code": "noncomputable def biUnionEqSigmaOfDisjoint {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (h : s.PairwiseDisjoint f) :\n    (\u22c3 i \u2208 s, f i) \u2243 \u03a3i : s, f i :=\n  (Equiv.setCongr (biUnion_eq_iUnion _ _)).trans <|\n    unionEqSigmaOfDisjoint fun \u27e8_i, hi\u27e9 \u27e8_j, hj\u27e9 ne => h hi hj fun eq => ne <| Subtype.eq eq", "start": [134, 1], "end": [138, 93], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion", "code": "theorem Set.PairwiseDisjoint.subset_of_biUnion_subset_biUnion (h\u2080 : (s \u222a t).PairwiseDisjoint f)\n    (h\u2081 : \u2200 i \u2208 s, (f i).Nonempty) (h : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i) : s \u2286 t", "start": [147, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "Pairwise.subset_of_biUnion_subset_biUnion", "code": "theorem Pairwise.subset_of_biUnion_subset_biUnion (h\u2080 : Pairwise (Disjoint on f))\n    (h\u2081 : \u2200 i \u2208 s, (f i).Nonempty) (h : \u22c3 i \u2208 s, f i \u2286 \u22c3 i \u2208 t, f i) : s \u2286 t", "start": [156, 1], "end": [158, 81], "kind": "commanddeclaration"}, {"full_name": "Pairwise.biUnion_injective", "code": "theorem Pairwise.biUnion_injective (h\u2080 : Pairwise (Disjoint on f)) (h\u2081 : \u2200 i, (f i).Nonempty) :\n    Injective fun s : Set \u03b9 => \u22c3 i \u2208 s, f i", "start": [161, 1], "end": [164, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Center.lean", "Mathlib/GroupTheory/Subsemigroup/Centralizer.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submonoid.centralizer", "code": "@[to_additive \"The centralizer of a subset of an additive monoid.\"]\ndef centralizer : Submonoid M where\n  carrier := S.centralizer\n  one_mem' := S.one_mem_centralizer\n  mul_mem' := Set.mul_mem_centralizer", "start": [31, 1], "end": [36, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_centralizer", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_centralizer : \u2191(centralizer S) = S.centralizer", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.centralizer_toSubsemigroup", "code": "theorem centralizer_toSubsemigroup : (centralizer S).toSubsemigroup = Subsemigroup.centralizer S", "start": [46, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.centralizer_toAddSubsemigroup", "code": "theorem _root_.AddSubmonoid.centralizer_toAddSubsemigroup {M} [AddMonoid M] (S : Set M) :\n    (AddSubmonoid.centralizer S).toAddSubsemigroup = AddSubsemigroup.centralizer S", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_centralizer_iff", "code": "@[to_additive]\ntheorem mem_centralizer_iff {z : M} : z \u2208 centralizer S \u2194 \u2200 g \u2208 S, g * z = z * g", "start": [60, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.center_le_centralizer", "code": "@[to_additive]\ntheorem center_le_centralizer (s) : center M \u2264 centralizer s", "start": [66, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "Submonoid.decidableMemCentralizer", "code": "@[to_additive]\ninstance decidableMemCentralizer (a) [Decidable <| \u2200 b \u2208 S, b * a = a * b] :\n    Decidable (a \u2208 centralizer S) :=\n  decidable_of_iff' _ mem_centralizer_iff", "start": [72, 1], "end": [75, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.centralizer_le", "code": "@[to_additive]\ntheorem centralizer_le (h : S \u2286 T) : centralizer T \u2264 centralizer S", "start": [79, 1], "end": [81, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.centralizer_eq_top_iff_subset", "code": "@[to_additive (attr := simp)]\ntheorem centralizer_eq_top_iff_subset {s : Set M} : centralizer s = \u22a4 \u2194 s \u2286 center M", "start": [85, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.centralizer_univ", "code": "@[to_additive (attr := simp)]\ntheorem centralizer_univ : centralizer Set.univ = center M", "start": [93, 1], "end": [95, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/InjSurj.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Basic.lean", "Mathlib/Algebra/Order/Group/Instances.lean", "Mathlib/Algebra/Order/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.orderedCommGroup", "code": "@[to_additive (attr := reducible) \"Pullback an `OrderedAddCommGroup` under an injective map.\"]\ndef Function.Injective.orderedCommGroup [OrderedCommGroup \u03b1] {\u03b2 : Type*} [One \u03b2] [Mul \u03b2] [Inv \u03b2]\n    [Div \u03b2] [Pow \u03b2 \u2115] [Pow \u03b2 \u2124] (f : \u03b2 \u2192 \u03b1) (hf : Function.Injective f) (one : f 1 = 1)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n) : OrderedCommGroup \u03b2 :=\n  { PartialOrder.lift f hf, hf.orderedCommMonoid f one mul npow,\n    hf.commGroup f one mul inv div npow zpow with }", "start": [19, 1], "end": [28, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCommGroup", "code": "@[to_additive (attr := reducible) \"Pullback a `LinearOrderedAddCommGroup` under an injective map.\"]\ndef Function.Injective.linearOrderedCommGroup [LinearOrderedCommGroup \u03b1] {\u03b2 : Type*} [One \u03b2]\n    [Mul \u03b2] [Inv \u03b2] [Div \u03b2] [Pow \u03b2 \u2115] [Pow \u03b2 \u2124] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1)\n    (hf : Function.Injective f) (one : f 1 = 1) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) (div : \u2200 x y, f (x / y) = f x / f y)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedCommGroup \u03b2 :=\n  { LinearOrder.lift f hf hsup hinf, hf.orderedCommGroup f one mul inv div npow zpow with }", "start": [32, 1], "end": [42, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/Conj.lean", "imports": ["Mathlib/Algebra/Hom/Aut.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Group/Semiconj/Defs.lean", "Mathlib/Algebra/GroupWithZero/Basic.lean", "Mathlib/Algebra/Hom/Group/Defs.lean"], "premises": [{"full_name": "IsConj", "code": "def IsConj (a b : \u03b1) :=\n  \u2203 c : \u03b1\u02e3, SemiconjBy (\u2191c) a b", "start": [27, 1], "end": [29, 32], "kind": "commanddeclaration"}, {"full_name": "IsConj.refl", "code": "@[refl]\ntheorem IsConj.refl (a : \u03b1) : IsConj a a", "start": [32, 1], "end": [34, 29], "kind": "commanddeclaration"}, {"full_name": "IsConj.symm", "code": "@[symm]\ntheorem IsConj.symm {a b : \u03b1} : IsConj a b \u2192 IsConj b a", "start": [37, 1], "end": [39, 45], "kind": "commanddeclaration"}, {"full_name": "isConj_comm", "code": "theorem isConj_comm {g h : \u03b1} : IsConj g h \u2194 IsConj h g", "start": [42, 1], "end": [43, 29], "kind": "commanddeclaration"}, {"full_name": "IsConj.trans", "code": "@[trans]\ntheorem IsConj.trans {a b c : \u03b1} : IsConj a b \u2192 IsConj b c \u2192 IsConj a c", "start": [46, 1], "end": [48, 56], "kind": "commanddeclaration"}, {"full_name": "isConj_iff_eq", "code": "@[simp]\ntheorem isConj_iff_eq {\u03b1 : Type*} [CommMonoid \u03b1] {a b : \u03b1} : IsConj a b \u2194 a = b", "start": [51, 1], "end": [55, 34], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_isConj", "code": "protected theorem MonoidHom.map_isConj (f : \u03b1 \u2192* \u03b2) {a b : \u03b1} : IsConj a b \u2192 IsConj (f a) (f b)", "start": [58, 1], "end": [59, 97], "kind": "commanddeclaration"}, {"full_name": "isConj_one_right", "code": "@[simp]\ntheorem isConj_one_right {a : \u03b1} : IsConj 1 a \u2194 a = 1", "start": [71, 1], "end": [74, 12], "kind": "commanddeclaration"}, {"full_name": "isConj_one_left", "code": "@[simp]\ntheorem isConj_one_left {a : \u03b1} : IsConj a 1 \u2194 a = 1", "start": [77, 1], "end": [81, 34], "kind": "commanddeclaration"}, {"full_name": "isConj_iff", "code": "@[simp]\ntheorem isConj_iff {a b : \u03b1} : IsConj a b \u2194 \u2203 c : \u03b1, c * a * c\u207b\u00b9 = b", "start": [90, 1], "end": [93, 76], "kind": "commanddeclaration"}, {"full_name": "conj_inv", "code": "theorem conj_inv {a b : \u03b1} : (b * a * b\u207b\u00b9)\u207b\u00b9 = b * a\u207b\u00b9 * b\u207b\u00b9", "start": [98, 1], "end": [99, 35], "kind": "commanddeclaration"}, {"full_name": "conj_mul", "code": "@[simp]\ntheorem conj_mul {a b c : \u03b1} : b * a * b\u207b\u00b9 * (b * c * b\u207b\u00b9) = b * (a * c) * b\u207b\u00b9", "start": [102, 1], "end": [104, 37], "kind": "commanddeclaration"}, {"full_name": "conj_pow", "code": "@[simp]\ntheorem conj_pow {i : \u2115} {a b : \u03b1} : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9", "start": [107, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "conj_zpow", "code": "@[simp]\ntheorem conj_zpow {i : \u2124} {a b : \u03b1} : (a * b * a\u207b\u00b9) ^ i = a * b ^ i * a\u207b\u00b9", "start": [114, 1], "end": [120, 19], "kind": "commanddeclaration"}, {"full_name": "conj_injective", "code": "theorem conj_injective {x : \u03b1} : Function.Injective fun g : \u03b1 => x * g * x\u207b\u00b9", "start": [124, 1], "end": [125, 28], "kind": "commanddeclaration"}, {"full_name": "isConj_iff\u2080", "code": "@[simp]\ntheorem isConj_iff\u2080 [GroupWithZero \u03b1] {a b : \u03b1} : IsConj a b \u2194 \u2203 c : \u03b1, c \u2260 0 \u2227 c * a * c\u207b\u00b9 = b", "start": [130, 1], "end": [139, 17], "kind": "commanddeclaration"}, {"full_name": "IsConj.setoid", "code": "protected def setoid (\u03b1 : Type*) [Monoid \u03b1] : Setoid \u03b1 where\n  r := IsConj\n  iseqv := \u27e8IsConj.refl, IsConj.symm, IsConj.trans\u27e9", "start": [146, 1], "end": [149, 52], "kind": "commanddeclaration"}, {"full_name": "ConjClasses", "code": "def ConjClasses (\u03b1 : Type*) [Monoid \u03b1] : Type _ :=\n  Quotient (IsConj.setoid \u03b1)", "start": [156, 1], "end": [158, 29], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mk", "code": "protected def mk {\u03b1 : Type*} [Monoid \u03b1] (a : \u03b1) : ConjClasses \u03b1 := \u27e6a\u27e7", "start": [167, 1], "end": [168, 71], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mk_eq_mk_iff_isConj", "code": "theorem mk_eq_mk_iff_isConj {a b : \u03b1} : ConjClasses.mk a = ConjClasses.mk b \u2194 IsConj a b", "start": [173, 1], "end": [174, 38], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.quotient_mk_eq_mk", "code": "theorem quotient_mk_eq_mk (a : \u03b1) : \u27e6a\u27e7 = ConjClasses.mk a", "start": [177, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.quot_mk_eq_mk", "code": "theorem quot_mk_eq_mk (a : \u03b1) : Quot.mk Setoid.r a = ConjClasses.mk a", "start": [181, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.forall_isConj", "code": "theorem forall_isConj {p : ConjClasses \u03b1 \u2192 Prop} : (\u2200 a, p a) \u2194 \u2200 a, p (ConjClasses.mk a)", "start": [185, 1], "end": [186, 65], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mk_surjective", "code": "theorem mk_surjective : Function.Surjective (@ConjClasses.mk \u03b1 _)", "start": [189, 1], "end": [190, 36], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.one_eq_mk_one", "code": "theorem one_eq_mk_one : (1 : ConjClasses \u03b1) = ConjClasses.mk 1", "start": [196, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.exists_rep", "code": "theorem exists_rep (a : ConjClasses \u03b1) : \u2203 a0 : \u03b1, ConjClasses.mk a0 = a", "start": [200, 1], "end": [201, 20], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.map", "code": "def map (f : \u03b1 \u2192* \u03b2) : ConjClasses \u03b1 \u2192 ConjClasses \u03b2 :=\n  Quotient.lift (ConjClasses.mk \u2218 f) fun _ _ ab => mk_eq_mk_iff_isConj.2 (f.map_isConj ab)", "start": [204, 1], "end": [206, 91], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.map_surjective", "code": "theorem map_surjective {f : \u03b1 \u2192* \u03b2} (hf : Function.Surjective f) :\n    Function.Surjective (ConjClasses.map f)", "start": [209, 1], "end": [214, 32], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mk_injective", "code": "theorem mk_injective : Function.Injective (@ConjClasses.mk \u03b1 _)", "start": [257, 1], "end": [258, 46], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mk_bijective", "code": "theorem mk_bijective : Function.Bijective (@ConjClasses.mk \u03b1 _)", "start": [261, 1], "end": [262, 32], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mkEquiv", "code": "def mkEquiv : \u03b1 \u2243 ConjClasses \u03b1 :=\n  \u27e8ConjClasses.mk, Quotient.lift id fun (a : \u03b1) b => isConj_iff_eq.1, Quotient.lift_mk _ _, by\n    rw [Function.RightInverse, Function.LeftInverse, forall_isConj]\n    intro x\n    rw [\u2190 quotient_mk_eq_mk, \u2190 quotient_mk_eq_mk, Quotient.lift_mk, id.def]\u27e9", "start": [265, 1], "end": [270, 77], "kind": "commanddeclaration"}, {"full_name": "conjugatesOf", "code": "def conjugatesOf (a : \u03b1) : Set \u03b1 :=\n  { b | IsConj a b }", "start": [281, 1], "end": [283, 21], "kind": "commanddeclaration"}, {"full_name": "mem_conjugatesOf_self", "code": "theorem mem_conjugatesOf_self {a : \u03b1} : a \u2208 conjugatesOf a", "start": [286, 1], "end": [287, 16], "kind": "commanddeclaration"}, {"full_name": "IsConj.conjugatesOf_eq", "code": "theorem IsConj.conjugatesOf_eq {a b : \u03b1} (ab : IsConj a b) : conjugatesOf a = conjugatesOf b", "start": [290, 1], "end": [291, 71], "kind": "commanddeclaration"}, {"full_name": "isConj_iff_conjugatesOf_eq", "code": "theorem isConj_iff_conjugatesOf_eq {a b : \u03b1} : IsConj a b \u2194 conjugatesOf a = conjugatesOf b", "start": [294, 1], "end": [297, 21], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.carrier", "code": "def carrier : ConjClasses \u03b1 \u2192 Set \u03b1 :=\n  Quotient.lift conjugatesOf fun (_ : \u03b1) _ ab => IsConj.conjugatesOf_eq ab", "start": [308, 1], "end": [310, 75], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mem_carrier_mk", "code": "theorem mem_carrier_mk {a : \u03b1} : a \u2208 carrier (ConjClasses.mk a)", "start": [313, 1], "end": [314, 16], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mem_carrier_iff_mk_eq", "code": "theorem mem_carrier_iff_mk_eq {a : \u03b1} {b : ConjClasses \u03b1} :\n    a \u2208 carrier b \u2194 ConjClasses.mk a = b", "start": [317, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.carrier_eq_preimage_mk", "code": "theorem carrier_eq_preimage_mk {a : ConjClasses \u03b1} : a.carrier = ConjClasses.mk \u207b\u00b9' {a}", "start": [326, 1], "end": [327, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Pi.lean", "imports": ["Mathlib/Algebra/Group/Pi.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.distrib", "code": "instance distrib [\u2200 i, Distrib <| f i] : Distrib (\u2200 i : I, f i) :=\n  { add := (\u00b7 + \u00b7)\n    mul := (\u00b7 * \u00b7)\n    left_distrib := by intros; ext; exact mul_add _ _ _\n    right_distrib := by intros; ext; exact add_mul _ _ _}", "start": [33, 1], "end": [37, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.hasDistribNeg", "code": "instance hasDistribNeg [\u2200 i, Mul (f i)] [\u2200 i, HasDistribNeg (f i)] : HasDistribNeg (\u2200 i, f i) where\n  neg_mul _ _ := funext fun _ \u21a6 neg_mul _ _\n  mul_neg _ _ := funext fun _ \u21a6 mul_neg _ _", "start": [40, 1], "end": [42, 44], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [\u2200 i, NonUnitalNonAssocSemiring <| f i] :\n    NonUnitalNonAssocSemiring (\u2200 i : I, f i) :=\n  { Pi.distrib, Pi.addCommMonoid, Pi.mulZeroClass with }", "start": [44, 1], "end": [46, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalSemiring", "code": "instance nonUnitalSemiring [\u2200 i, NonUnitalSemiring <| f i] : NonUnitalSemiring (\u2200 i : I, f i) :=\n  { Pi.nonUnitalNonAssocSemiring, Pi.semigroupWithZero with }", "start": [49, 1], "end": [50, 62], "kind": "commanddeclaration"}, {"full_name": "Pi.nonAssocSemiring", "code": "instance nonAssocSemiring [\u2200 i, NonAssocSemiring <| f i] : NonAssocSemiring (\u2200 i : I, f i) :=\n  { Pi.nonUnitalNonAssocSemiring, Pi.mulZeroOneClass, Pi.addMonoidWithOne with }", "start": [53, 1], "end": [54, 81], "kind": "commanddeclaration"}, {"full_name": "Pi.semiring", "code": "instance semiring [\u2200 i, Semiring <| f i] : Semiring (\u2200 i : I, f i) :=\n  { Pi.nonUnitalSemiring, Pi.nonAssocSemiring, Pi.monoidWithZero with }", "start": [57, 1], "end": [58, 72], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [\u2200 i, NonUnitalCommSemiring <| f i] :\n    NonUnitalCommSemiring (\u2200 i : I, f i) :=\n  { Pi.nonUnitalSemiring, Pi.commSemigroup with }", "start": [61, 1], "end": [63, 50], "kind": "commanddeclaration"}, {"full_name": "Pi.commSemiring", "code": "instance commSemiring [\u2200 i, CommSemiring <| f i] : CommSemiring (\u2200 i : I, f i) :=\n  { Pi.semiring, Pi.commMonoid with }", "start": [66, 1], "end": [67, 38], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [\u2200 i, NonUnitalNonAssocRing <| f i] :\n    NonUnitalNonAssocRing (\u2200 i : I, f i) :=\n  { Pi.addCommGroup, Pi.nonUnitalNonAssocSemiring with }", "start": [70, 1], "end": [72, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalRing", "code": "instance nonUnitalRing [\u2200 i, NonUnitalRing <| f i] : NonUnitalRing (\u2200 i : I, f i) :=\n  { Pi.nonUnitalNonAssocRing, Pi.nonUnitalSemiring with }", "start": [75, 1], "end": [76, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.nonAssocRing", "code": "instance nonAssocRing [\u2200 i, NonAssocRing <| f i] : NonAssocRing (\u2200 i : I, f i) :=\n  { Pi.nonUnitalNonAssocRing, Pi.nonAssocSemiring, Pi.addGroupWithOne with }", "start": [79, 1], "end": [80, 77], "kind": "commanddeclaration"}, {"full_name": "Pi.ring", "code": "instance ring [\u2200 i, Ring <| f i] : Ring (\u2200 i : I, f i) :=\n  { Pi.semiring, Pi.addCommGroup, Pi.addGroupWithOne with }", "start": [83, 1], "end": [84, 60], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalCommRing", "code": "instance nonUnitalCommRing [\u2200 i, NonUnitalCommRing <| f i] : NonUnitalCommRing (\u2200 i : I, f i) :=\n  { Pi.nonUnitalRing, Pi.commSemigroup with }", "start": [87, 1], "end": [88, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.commRing", "code": "instance commRing [\u2200 i, CommRing <| f i] : CommRing (\u2200 i : I, f i) :=\n  { Pi.ring, Pi.commSemiring with }", "start": [91, 1], "end": [92, 36], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalRingHom", "code": "@[simps]\nprotected def nonUnitalRingHom {\u03b3 : Type w} [\u2200 i, NonUnitalNonAssocSemiring (f i)]\n    [NonUnitalNonAssocSemiring \u03b3] (g : \u2200 i, \u03b3 \u2192\u2099+* f i) : \u03b3 \u2192\u2099+* \u2200 i, f i :=\n  { Pi.mulHom fun i => (g i).toMulHom, Pi.addMonoidHom fun i => (g i).toAddMonoidHom with\n    toFun := fun x b => g b x }", "start": [95, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.nonUnitalRingHom_injective", "code": "theorem nonUnitalRingHom_injective {\u03b3 : Type w} [Nonempty I]\n    [\u2200 i, NonUnitalNonAssocSemiring (f i)] [NonUnitalNonAssocSemiring \u03b3] (g : \u2200 i, \u03b3 \u2192\u2099+* f i)\n    (hg : \u2200 i, Function.Injective (g i)) : Function.Injective (Pi.nonUnitalRingHom g)", "start": [105, 1], "end": [108, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.ringHom", "code": "@[simps]\nprotected def ringHom {\u03b3 : Type w} [\u2200 i, NonAssocSemiring (f i)] [NonAssocSemiring \u03b3]\n    (g : \u2200 i, \u03b3 \u2192+* f i) : \u03b3 \u2192+* \u2200 i, f i :=\n  { Pi.monoidHom fun i => (g i).toMonoidHom, Pi.addMonoidHom fun i => (g i).toAddMonoidHom with\n    toFun := fun x b => g b x }", "start": [111, 1], "end": [117, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.ringHom_injective", "code": "theorem ringHom_injective {\u03b3 : Type w} [Nonempty I] [\u2200 i, NonAssocSemiring (f i)]\n    [NonAssocSemiring \u03b3] (g : \u2200 i, \u03b3 \u2192+* f i) (hg : \u2200 i, Function.Injective (g i)) :\n    Function.Injective (Pi.ringHom g)", "start": [121, 1], "end": [124, 54], "kind": "commanddeclaration"}, {"full_name": "Pi.evalNonUnitalRingHom", "code": "@[simps]\ndef Pi.evalNonUnitalRingHom (f : I \u2192 Type v) [\u2200 i, NonUnitalNonAssocSemiring (f i)] (i : I) :\n    (\u2200 i, f i) \u2192\u2099+* f i :=\n  { Pi.evalMulHom f i, Pi.evalAddMonoidHom f i with }", "start": [135, 1], "end": [140, 54], "kind": "commanddeclaration"}, {"full_name": "Pi.constNonUnitalRingHom", "code": "@[simps]\ndef Pi.constNonUnitalRingHom (\u03b1 \u03b2 : Type*) [NonUnitalNonAssocSemiring \u03b2] : \u03b2 \u2192\u2099+* \u03b1 \u2192 \u03b2 :=\n  { Pi.nonUnitalRingHom fun _ => NonUnitalRingHom.id \u03b2 with toFun := Function.const _ }", "start": [143, 1], "end": [146, 88], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.compLeft", "code": "@[simps]\nprotected def NonUnitalRingHom.compLeft {\u03b1 \u03b2 : Type*} [NonUnitalNonAssocSemiring \u03b1]\n    [NonUnitalNonAssocSemiring \u03b2] (f : \u03b1 \u2192\u2099+* \u03b2) (I : Type*) : (I \u2192 \u03b1) \u2192\u2099+* I \u2192 \u03b2 :=\n  { f.toMulHom.compLeft I, f.toAddMonoidHom.compLeft I with toFun := fun h => f \u2218 h }", "start": [149, 1], "end": [154, 86], "kind": "commanddeclaration"}, {"full_name": "Pi.evalRingHom", "code": "@[simps!]\ndef Pi.evalRingHom (f : I \u2192 Type v) [\u2200 i, NonAssocSemiring (f i)] (i : I) : (\u2200 i, f i) \u2192+* f i :=\n  { Pi.evalMonoidHom f i, Pi.evalAddMonoidHom f i with }", "start": [165, 1], "end": [169, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.constRingHom", "code": "@[simps]\ndef Pi.constRingHom (\u03b1 \u03b2 : Type*) [NonAssocSemiring \u03b2] : \u03b2 \u2192+* \u03b1 \u2192 \u03b2 :=\n  { Pi.ringHom fun _ => RingHom.id \u03b2 with toFun := Function.const _ }", "start": [173, 1], "end": [176, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.compLeft", "code": "@[simps]\nprotected def RingHom.compLeft {\u03b1 \u03b2 : Type*} [NonAssocSemiring \u03b1] [NonAssocSemiring \u03b2]\n    (f : \u03b1 \u2192+* \u03b2) (I : Type*) : (I \u2192 \u03b1) \u2192+* I \u2192 \u03b2 :=\n  { f.toMonoidHom.compLeft I, f.toAddMonoidHom.compLeft I with toFun := fun h => f \u2218 h }", "start": [180, 1], "end": [185, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Regular/SMul.lean", "imports": ["Mathlib/Algebra/Regular/Basic.lean", "Mathlib/Algebra/SMulWithZero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSMulRegular", "code": "def IsSMulRegular [SMul R M] (c : R) :=\n  Function.Injective ((c \u2022 \u00b7) : M \u2192 M)", "start": [33, 1], "end": [36, 39], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.isSMulRegular", "code": "theorem IsLeftRegular.isSMulRegular [Mul R] {c : R} (h : IsLeftRegular c) : IsSMulRegular R c", "start": [39, 1], "end": [40, 4], "kind": "commanddeclaration"}, {"full_name": "isLeftRegular_iff", "code": "theorem isLeftRegular_iff [Mul R] {a : R} : IsLeftRegular a \u2194 IsSMulRegular R a", "start": [43, 1], "end": [45, 10], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.isSMulRegular", "code": "theorem IsRightRegular.isSMulRegular [Mul R] {c : R} (h : IsRightRegular c) :\n    IsSMulRegular R (MulOpposite.op c)", "start": [48, 1], "end": [50, 4], "kind": "commanddeclaration"}, {"full_name": "isRightRegular_iff", "code": "theorem isRightRegular_iff [Mul R] {a : R} :\n    IsRightRegular a \u2194 IsSMulRegular R (MulOpposite.op a)", "start": [53, 1], "end": [56, 10], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.smul", "code": "theorem smul (ra : IsSMulRegular M a) (rs : IsSMulRegular M s) : IsSMulRegular M (a \u2022 s)", "start": [67, 1], "end": [69, 86], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.of_smul", "code": "theorem of_smul (a : R) (ab : IsSMulRegular M (a \u2022 s)) : IsSMulRegular M s", "start": [72, 1], "end": [78, 14], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.smul_iff", "code": "@[simp]\ntheorem smul_iff (b : S) (ha : IsSMulRegular M a) : IsSMulRegular M (a \u2022 b) \u2194 IsSMulRegular M b", "start": [81, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.isLeftRegular", "code": "theorem isLeftRegular [Mul R] {a : R} (h : IsSMulRegular R a) : IsLeftRegular a", "start": [88, 1], "end": [89, 4], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.isRightRegular", "code": "theorem isRightRegular [Mul R] {a : R} (h : IsSMulRegular R (MulOpposite.op a)) :\n    IsRightRegular a", "start": [92, 1], "end": [94, 4], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.mul", "code": "theorem mul [Mul R] [IsScalarTower R R M] (ra : IsSMulRegular M a) (rb : IsSMulRegular M b) :\n    IsSMulRegular M (a * b)", "start": [97, 1], "end": [99, 13], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.of_mul", "code": "theorem of_mul [Mul R] [IsScalarTower R R M] (ab : IsSMulRegular M (a * b)) :\n    IsSMulRegular M b", "start": [102, 1], "end": [105, 21], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.mul_iff_right", "code": "@[simp]\ntheorem mul_iff_right [Mul R] [IsScalarTower R R M] (ha : IsSMulRegular M a) :\n    IsSMulRegular M (a * b) \u2194 IsSMulRegular M b", "start": [108, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.mul_and_mul_iff", "code": "theorem mul_and_mul_iff [Mul R] [IsScalarTower R R M] :\n    IsSMulRegular M (a * b) \u2227 IsSMulRegular M (b * a) \u2194 IsSMulRegular M a \u2227 IsSMulRegular M b", "start": [114, 1], "end": [122, 33], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.one", "code": "@[simp]\ntheorem one : IsSMulRegular M (1 : R)", "start": [133, 1], "end": [138, 13], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.of_mul_eq_one", "code": "theorem of_mul_eq_one (h : a * b = 1) : IsSMulRegular M b", "start": [143, 1], "end": [148, 19], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.pow", "code": "theorem pow (n : \u2115) (ra : IsSMulRegular M a) : IsSMulRegular M (a ^ n)", "start": [151, 1], "end": [156, 39], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.pow_iff", "code": "theorem pow_iff {n : \u2115} (n0 : 0 < n) : IsSMulRegular M (a ^ n) \u2194 IsSMulRegular M a", "start": [159, 1], "end": [163, 18], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.of_smul_eq_one", "code": "theorem of_smul_eq_one (h : a \u2022 s = 1) : IsSMulRegular M s", "start": [172, 1], "end": [177, 19], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.subsingleton", "code": "protected theorem subsingleton (h : IsSMulRegular M (0 : R)) : Subsingleton M", "start": [187, 1], "end": [189, 91], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.zero_iff_subsingleton", "code": "theorem zero_iff_subsingleton : IsSMulRegular M (0 : R) \u2194 Subsingleton M", "start": [192, 1], "end": [194, 71], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.not_zero_iff", "code": "theorem not_zero_iff : \u00acIsSMulRegular M (0 : R) \u2194 Nontrivial M", "start": [197, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.zero", "code": "theorem zero [sM : Subsingleton M] : IsSMulRegular M (0 : R)", "start": [204, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.not_zero", "code": "theorem not_zero [nM : Nontrivial M] : \u00acIsSMulRegular M (0 : R)", "start": [209, 1], "end": [211, 22], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.mul_iff", "code": "theorem mul_iff : IsSMulRegular M (a * b) \u2194 IsSMulRegular M a \u2227 IsSMulRegular M b", "start": [220, 1], "end": [223, 62], "kind": "commanddeclaration"}, {"full_name": "isSMulRegular_of_group", "code": "theorem isSMulRegular_of_group [MulAction G R] (g : G) : IsSMulRegular R g", "start": [234, 1], "end": [238, 64], "kind": "commanddeclaration"}, {"full_name": "Units.isSMulRegular", "code": "theorem Units.isSMulRegular (a : R\u02e3) : IsSMulRegular M (a : R)", "start": [247, 1], "end": [249, 40], "kind": "commanddeclaration"}, {"full_name": "IsUnit.isSMulRegular", "code": "theorem IsUnit.isSMulRegular (ua : IsUnit a) : IsSMulRegular M a", "start": [252, 1], "end": [255, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Field/Opposite.lean", "imports": ["Mathlib/Algebra/Ring/Opposite.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.ratCast", "code": "@[to_additive]\ninstance ratCast [RatCast \u03b1] : RatCast \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun n => op n\u27e9", "start": [22, 1], "end": [24, 18], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_ratCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem op_ratCast [RatCast \u03b1] (q : \u211a) : op (q : \u03b1) = q", "start": [28, 1], "end": [30, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_ratCast", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem unop_ratCast [RatCast \u03b1] (q : \u211a) : unop (q : \u03b1\u1d50\u1d52\u1d56) = q", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.divisionSemiring", "code": "instance divisionSemiring [DivisionSemiring \u03b1] : DivisionSemiring \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.groupWithZero \u03b1, MulOpposite.semiring \u03b1 with }", "start": [42, 1], "end": [43, 63], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.divisionRing", "code": "instance divisionRing [DivisionRing \u03b1] : DivisionRing \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divisionSemiring \u03b1, MulOpposite.ring \u03b1, MulOpposite.ratCast \u03b1 with\n    ratCast_mk := fun a b hb h => unop_injective $ by\n      rw [unop_ratCast, Rat.cast_def, unop_mul, unop_inv, unop_natCast, unop_intCast,\n        Int.commute_cast, div_eq_mul_inv] }", "start": [45, 1], "end": [49, 44], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.semifield", "code": "instance semifield [Semifield \u03b1] : Semifield \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divisionSemiring \u03b1, MulOpposite.commSemiring \u03b1 with }", "start": [51, 1], "end": [52, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.field", "code": "instance field [Field \u03b1] : Field \u03b1\u1d50\u1d52\u1d56 :=\n  { MulOpposite.divisionRing \u03b1, MulOpposite.commRing \u03b1 with }", "start": [54, 1], "end": [55, 62], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.divisionSemiring", "code": "instance divisionSemiring [DivisionSemiring \u03b1] : DivisionSemiring \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.groupWithZero \u03b1, AddOpposite.semiring \u03b1 with }", "start": [61, 1], "end": [62, 63], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.divisionRing", "code": "instance divisionRing [DivisionRing \u03b1] : DivisionRing \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.ring \u03b1, AddOpposite.groupWithZero \u03b1, AddOpposite.ratCast \u03b1 with\n    ratCast_mk := fun a b hb h => unop_injective $ by\n      rw [unop_ratCast, Rat.cast_def, unop_mul, unop_inv, unop_natCast, unop_intCast,\n        div_eq_mul_inv] }", "start": [64, 1], "end": [68, 26], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.semifield", "code": "instance semifield [Semifield \u03b1] : Semifield \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.divisionSemiring, AddOpposite.commSemiring \u03b1 with }", "start": [70, 1], "end": [71, 68], "kind": "commanddeclaration"}, {"full_name": "AddOpposite.field", "code": "instance field [Field \u03b1] : Field \u03b1\u1d43\u1d52\u1d56 :=\n  { AddOpposite.divisionRing, AddOpposite.commRing \u03b1 with }", "start": [73, 1], "end": [74, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Aut.lean", "imports": ["Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/Algebra/Hom/Aut.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingAut", "code": "@[reducible]\ndef RingAut (R : Type*) [Mul R] [Add R] :=\n  RingEquiv R R", "start": [32, 1], "end": [35, 16], "kind": "commanddeclaration"}, {"full_name": "RingAut.toAddAut", "code": "def toAddAut : RingAut R \u2192* AddAut R := by\n  refine'\n  { toFun := RingEquiv.toAddEquiv\n    .. } <;> (intros; rfl)", "start": [80, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "RingAut.toMulAut", "code": "def toMulAut : RingAut R \u2192* MulAut R := by\n  refine'\n  { toFun := RingEquiv.toMulEquiv\n    .. } <;> (intros; rfl)", "start": [87, 1], "end": [91, 27], "kind": "commanddeclaration"}, {"full_name": "RingAut.toPerm", "code": "def toPerm : RingAut R \u2192* Equiv.Perm R := by\n  refine'\n  { toFun := RingEquiv.toEquiv\n    .. } <;> (intros; rfl)", "start": [94, 1], "end": [98, 27], "kind": "commanddeclaration"}, {"full_name": "RingAut.applyMulSemiringAction", "code": "instance applyMulSemiringAction :\n    MulSemiringAction (RingAut R) R where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := RingEquiv.map_zero\n  smul_add := RingEquiv.map_add\n  smul_one := RingEquiv.map_one\n  smul_mul := RingEquiv.map_mul\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [107, 1], "end": [116, 24], "kind": "commanddeclaration"}, {"full_name": "RingAut.smul_def", "code": "@[simp]\nprotected theorem smul_def (f : RingAut R) (r : R) : f \u2022 r = f r", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "RingAut.apply_faithfulSMul", "code": "instance apply_faithfulSMul : FaithfulSMul (RingAut R) R :=\n  \u27e8RingEquiv.ext\u27e9", "start": [124, 1], "end": [125, 18], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toRingAut", "code": "@[simps]\ndef _root_.MulSemiringAction.toRingAut [MulSemiringAction G R] :\n    G \u2192* RingAut R where\n  toFun := MulSemiringAction.toRingEquiv G R\n  map_mul' g h := RingEquiv.ext <| mul_smul g h\n  map_one' := RingEquiv.ext <| one_smul _", "start": [130, 1], "end": [139, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/CompTypeclasses.lean", "imports": ["Mathlib/Algebra/Ring/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingHomId", "code": "class RingHomId {R : Type*} [Semiring R] (\u03c3 : R \u2192+* R) : Prop where\n  eq_id : \u03c3 = RingHom.id R", "start": [49, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "RingHomCompTriple", "code": "class RingHomCompTriple (\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082) (\u03c3\u2082\u2083 : R\u2082 \u2192+* R\u2083) (\u03c3\u2081\u2083 : outParam (R\u2081 \u2192+* R\u2083)) :\n  Prop where\n  \n  comp_eq : \u03c3\u2082\u2083.comp \u03c3\u2081\u2082 = \u03c3\u2081\u2083", "start": [60, 1], "end": [65, 31], "kind": "commanddeclaration"}, {"full_name": "RingHomCompTriple.comp_apply", "code": "@[simp]\ntheorem comp_apply [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] {x : R\u2081} : \u03c3\u2082\u2083 (\u03c3\u2081\u2082 x) = \u03c3\u2081\u2083 x", "start": [74, 1], "end": [76, 30], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair", "code": "class RingHomInvPair (\u03c3 : R\u2081 \u2192+* R\u2082) (\u03c3' : outParam (R\u2082 \u2192+* R\u2081)) : Prop where\n  \n  comp_eq : \u03c3'.comp \u03c3 = RingHom.id R\u2081\n  \n  comp_eq\u2082 : \u03c3.comp \u03c3' = RingHom.id R\u2082", "start": [81, 1], "end": [87, 39], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.comp_apply_eq", "code": "theorem comp_apply_eq {x : R\u2081} : \u03c3' (\u03c3 x) = x", "start": [101, 1], "end": [103, 7], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.comp_apply_eq\u2082", "code": "theorem comp_apply_eq\u2082 {x : R\u2082} : \u03c3 (\u03c3' x) = x", "start": [107, 1], "end": [109, 7], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.ids", "code": "instance ids : RingHomInvPair (RingHom.id R\u2081) (RingHom.id R\u2081) :=\n  \u27e8rfl, rfl\u27e9", "start": [112, 1], "end": [113, 13], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.triples", "code": "instance triples {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] :\n    RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2081 (RingHom.id R\u2081) :=\n  \u27e8by simp only [comp_eq]\u27e9", "start": [116, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.triples\u2082", "code": "instance triples\u2082 {\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081} [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] :\n    RingHomCompTriple \u03c3\u2082\u2081 \u03c3\u2081\u2082 (RingHom.id R\u2082) :=\n  \u27e8by simp only [comp_eq\u2082]\u27e9", "start": [121, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.of_ringEquiv", "code": "@[reducible]\ntheorem of_ringEquiv (e : R\u2081 \u2243+* R\u2082) : RingHomInvPair (\u2191e : R\u2081 \u2192+* R\u2082) \u2191e.symm", "start": [126, 1], "end": [135, 74], "kind": "commanddeclaration"}, {"full_name": "RingHomInvPair.symm", "code": "@[reducible]\ntheorem symm (\u03c3\u2081\u2082 : R\u2081 \u2192+* R\u2082) (\u03c3\u2082\u2081 : R\u2082 \u2192+* R\u2081) [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] :\n    RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082", "start": [138, 1], "end": [148, 52], "kind": "commanddeclaration"}, {"full_name": "RingHomCompTriple.ids", "code": "instance ids : RingHomCompTriple (RingHom.id R\u2081) \u03c3\u2081\u2082 \u03c3\u2081\u2082 :=\n  \u27e8by\n    ext\n    simp\u27e9", "start": [155, 1], "end": [158, 10], "kind": "commanddeclaration"}, {"full_name": "RingHomCompTriple.right_ids", "code": "instance right_ids : RingHomCompTriple \u03c3\u2081\u2082 (RingHom.id R\u2082) \u03c3\u2081\u2082 :=\n  \u27e8by\n    ext\n    simp\u27e9", "start": [161, 1], "end": [164, 10], "kind": "commanddeclaration"}, {"full_name": "RingHomSurjective", "code": "class RingHomSurjective (\u03c3 : R\u2081 \u2192+* R\u2082) : Prop where\n  \n  is_surjective : Function.Surjective \u03c3", "start": [169, 1], "end": [173, 40], "kind": "commanddeclaration"}, {"full_name": "RingHom.surjective", "code": "theorem RingHom.surjective (\u03c3 : R\u2081 \u2192+* R\u2082) [t : RingHomSurjective \u03c3] : Function.Surjective \u03c3", "start": [176, 1], "end": [177, 18], "kind": "commanddeclaration"}, {"full_name": "RingHomSurjective.invPair", "code": "instance (priority := 100) invPair {\u03c3\u2081 : R\u2081 \u2192+* R\u2082} {\u03c3\u2082 : R\u2082 \u2192+* R\u2081} [RingHomInvPair \u03c3\u2081 \u03c3\u2082] :\n    RingHomSurjective \u03c3\u2081 :=\n  \u27e8fun x => \u27e8\u03c3\u2082 x, RingHomInvPair.comp_apply_eq\u2082\u27e9\u27e9", "start": [184, 1], "end": [186, 51], "kind": "commanddeclaration"}, {"full_name": "RingHomSurjective.ids", "code": "instance ids : RingHomSurjective (RingHom.id R\u2081) :=\n  \u27e8is_surjective\u27e9", "start": [189, 1], "end": [190, 18], "kind": "commanddeclaration"}, {"full_name": "RingHomSurjective.comp", "code": "theorem comp [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [RingHomSurjective \u03c3\u2081\u2082] [RingHomSurjective \u03c3\u2082\u2083] :\n    RingHomSurjective \u03c3\u2081\u2083", "start": [193, 1], "end": [198, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Basic.lean", "imports": ["Mathlib/Order/Filter/Ultrafilter.lean", "Mathlib/Tactic/Continuity.lean", "Mathlib/Order/Filter/Lift.lean", "Mathlib/Algebra/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace", "code": "@[to_additive existing TopologicalSpace]\nclass TopologicalSpace (\u03b1 : Type u) where\n  \n  protected IsOpen : Set \u03b1 \u2192 Prop\n  \n  protected isOpen_univ : IsOpen univ\n  \n  protected isOpen_inter : \u2200 s t, IsOpen s \u2192 IsOpen t \u2192 IsOpen (s \u2229 t)\n  \n  protected isOpen_sUnion : \u2200 s, (\u2200 t \u2208 s, IsOpen t) \u2192 IsOpen (\u22c3\u2080 s)", "start": [68, 1], "end": [80, 69], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.ofClosed", "code": "def TopologicalSpace.ofClosed {\u03b1 : Type u} (T : Set (Set \u03b1)) (empty_mem : \u2205 \u2208 T)\n    (sInter_mem : \u2200 A, A \u2286 T \u2192 \u22c2\u2080 A \u2208 T)\n    (union_mem : \u2200 A, A \u2208 T \u2192 \u2200 B, B \u2208 T \u2192 A \u222a B \u2208 T) : TopologicalSpace \u03b1 where\n  IsOpen X := X\u1d9c \u2208 T\n  isOpen_univ := by simp [empty_mem]\n  isOpen_inter s t hs ht := by simpa only [compl_inter] using union_mem s\u1d9c hs t\u1d9c ht\n  isOpen_sUnion s hs := by\n    simp only [Set.compl_sUnion]\n    exact sInter_mem (compl '' s) fun z \u27e8y, hy, hz\u27e9 => hz \u25b8 hs y hy", "start": [83, 1], "end": [93, 68], "kind": "commanddeclaration"}, {"full_name": "IsOpen", "code": "def IsOpen [TopologicalSpace \u03b1] : Set \u03b1 \u2192 Prop := TopologicalSpace.IsOpen", "start": [100, 1], "end": [101, 74], "kind": "commanddeclaration"}, {"full_name": "isOpen_mk", "code": "lemma isOpen_mk {p h\u2081 h\u2082 h\u2083} {s : Set \u03b1} : IsOpen[\u27e8p, h\u2081, h\u2082, h\u2083\u27e9] s \u2194 p s := Iff.rfl", "start": [110, 1], "end": [110, 86], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.ext", "code": "@[ext]\nprotected theorem TopologicalSpace.ext :\n    \u2200 {f g : TopologicalSpace \u03b1}, IsOpen[f] = IsOpen[g] \u2192 f = g", "start": [113, 1], "end": [116, 43], "kind": "commanddeclaration"}, {"full_name": "isOpen_univ", "code": "@[simp] theorem isOpen_univ : IsOpen (univ : Set \u03b1)", "start": [123, 1], "end": [123, 84], "kind": "commanddeclaration"}, {"full_name": "IsOpen.inter", "code": "theorem IsOpen.inter (h\u2081 : IsOpen s\u2081) (h\u2082 : IsOpen s\u2082) : IsOpen (s\u2081 \u2229 s\u2082)", "start": [126, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "isOpen_sUnion", "code": "theorem isOpen_sUnion {s : Set (Set \u03b1)} (h : \u2200 t \u2208 s, IsOpen t) : IsOpen (\u22c3\u2080 s)", "start": [130, 1], "end": [131, 37], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.ext_iff", "code": "protected theorem TopologicalSpace.ext_iff {t t' : TopologicalSpace \u03b1} :\n    t = t' \u2194 \u2200 s, IsOpen[t] s \u2194 IsOpen[t'] s", "start": [136, 1], "end": [138, 55], "kind": "commanddeclaration"}, {"full_name": "isOpen_fold", "code": "theorem isOpen_fold {s : Set \u03b1} {t : TopologicalSpace \u03b1} : t.IsOpen s = IsOpen[t] s", "start": [141, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "isOpen_iUnion", "code": "theorem isOpen_iUnion {f : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, IsOpen (f i)) : IsOpen (\u22c3 i, f i)", "start": [147, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "isOpen_biUnion", "code": "theorem isOpen_biUnion {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsOpen (f i)) :\n    IsOpen (\u22c3 i \u2208 s, f i)", "start": [151, 1], "end": [153, 56], "kind": "commanddeclaration"}, {"full_name": "IsOpen.union", "code": "theorem IsOpen.union (h\u2081 : IsOpen s\u2081) (h\u2082 : IsOpen s\u2082) : IsOpen (s\u2081 \u222a s\u2082)", "start": [156, 1], "end": [157, 74], "kind": "commanddeclaration"}, {"full_name": "isOpen_empty", "code": "@[simp] theorem isOpen_empty : IsOpen (\u2205 : Set \u03b1)", "start": [160, 1], "end": [161, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isOpen_sInter", "code": "theorem Set.Finite.isOpen_sInter {s : Set (Set \u03b1)} (hs : s.Finite) :\n    (\u2200 t \u2208 s, IsOpen t) \u2192 IsOpen (\u22c2\u2080 s)", "start": [164, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isOpen_biInter", "code": "theorem Set.Finite.isOpen_biInter {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Finite)\n    (h : \u2200 i \u2208 s, IsOpen (f i)) :\n    IsOpen (\u22c2 i \u2208 s, f i)", "start": [171, 1], "end": [174, 69], "kind": "commanddeclaration"}, {"full_name": "isOpen_iInter_of_finite", "code": "theorem isOpen_iInter_of_finite [Finite \u03b9] {s : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, IsOpen (s i)) :\n    IsOpen (\u22c2 i, s i)", "start": [177, 1], "end": [179, 57], "kind": "commanddeclaration"}, {"full_name": "isOpen_biInter_finset", "code": "theorem isOpen_biInter_finset {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsOpen (f i)) :\n    IsOpen (\u22c2 i \u2208 s, f i)", "start": [182, 1], "end": [184, 34], "kind": "commanddeclaration"}, {"full_name": "isOpen_const", "code": "@[simp] theorem isOpen_const {p : Prop} : IsOpen { _a : \u03b1 | p }", "start": [187, 1], "end": [188, 86], "kind": "commanddeclaration"}, {"full_name": "IsOpen.and", "code": "theorem IsOpen.and : IsOpen { a | p\u2081 a } \u2192 IsOpen { a | p\u2082 a } \u2192 IsOpen { a | p\u2081 a \u2227 p\u2082 a }", "start": [191, 1], "end": [192, 15], "kind": "commanddeclaration"}, {"full_name": "IsClosed", "code": "class IsClosed (s : Set \u03b1) : Prop where\n  \n  isOpen_compl : IsOpen s\u1d9c", "start": [195, 1], "end": [198, 27], "kind": "commanddeclaration"}, {"full_name": "isOpen_compl_iff", "code": "@[simp] theorem isOpen_compl_iff {s : Set \u03b1} : IsOpen s\u1d9c \u2194 IsClosed s", "start": [205, 1], "end": [206, 42], "kind": "commanddeclaration"}, {"full_name": "isClosed_const", "code": "theorem isClosed_const {p : Prop} : IsClosed { _a : \u03b1 | p }", "start": [210, 1], "end": [210, 88], "kind": "commanddeclaration"}, {"full_name": "isClosed_empty", "code": "@[simp] theorem isClosed_empty : IsClosed (\u2205 : Set \u03b1)", "start": [212, 1], "end": [212, 72], "kind": "commanddeclaration"}, {"full_name": "isClosed_univ", "code": "@[simp] theorem isClosed_univ : IsClosed (univ : Set \u03b1)", "start": [215, 1], "end": [215, 74], "kind": "commanddeclaration"}, {"full_name": "IsClosed.union", "code": "theorem IsClosed.union : IsClosed s\u2081 \u2192 IsClosed s\u2082 \u2192 IsClosed (s\u2081 \u222a s\u2082)", "start": [218, 1], "end": [219, 66], "kind": "commanddeclaration"}, {"full_name": "isClosed_sInter", "code": "theorem isClosed_sInter {s : Set (Set \u03b1)} : (\u2200 t \u2208 s, IsClosed t) \u2192 IsClosed (\u22c2\u2080 s)", "start": [222, 1], "end": [223, 83], "kind": "commanddeclaration"}, {"full_name": "isClosed_iInter", "code": "theorem isClosed_iInter {f : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, IsClosed (f i)) : IsClosed (\u22c2 i, f i)", "start": [226, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "isClosed_biInter", "code": "theorem isClosed_biInter {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsClosed (f i)) :\n    IsClosed (\u22c2 i \u2208 s, f i)", "start": [230, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "isClosed_compl_iff", "code": "@[simp]\ntheorem isClosed_compl_iff {s : Set \u03b1} : IsClosed s\u1d9c \u2194 IsOpen s", "start": [235, 1], "end": [237, 39], "kind": "commanddeclaration"}, {"full_name": "IsOpen.isClosed_compl", "code": "alias \u27e8_, IsOpen.isClosed_compl\u27e9 := isClosed_compl_iff", "start": [240, 1], "end": [240, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsOpen.sdiff", "code": "theorem IsOpen.sdiff {s t : Set \u03b1} (h\u2081 : IsOpen s) (h\u2082 : IsClosed t) : IsOpen (s \\ t)", "start": [243, 1], "end": [244, 34], "kind": "commanddeclaration"}, {"full_name": "IsClosed.inter", "code": "theorem IsClosed.inter (h\u2081 : IsClosed s\u2081) (h\u2082 : IsClosed s\u2082) : IsClosed (s\u2081 \u2229 s\u2082)", "start": [247, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "IsClosed.sdiff", "code": "theorem IsClosed.sdiff {s t : Set \u03b1} (h\u2081 : IsClosed s) (h\u2082 : IsOpen t) : IsClosed (s \\ t)", "start": [253, 1], "end": [254, 48], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isClosed_biUnion", "code": "theorem Set.Finite.isClosed_biUnion {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Finite)\n    (h : \u2200 i \u2208 s, IsClosed (f i)) :\n    IsClosed (\u22c3 i \u2208 s, f i)", "start": [257, 1], "end": [261, 28], "kind": "commanddeclaration"}, {"full_name": "isClosed_biUnion_finset", "code": "lemma isClosed_biUnion_finset {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsClosed (f i)) :\n    IsClosed (\u22c3 i \u2208 s, f i) :=\n  s.finite_toSet.isClosed_biUnion h", "start": [264, 1], "end": [266, 36], "kind": "mathlibtacticlemma"}, {"full_name": "isClosed_iUnion_of_finite", "code": "theorem isClosed_iUnion_of_finite [Finite \u03b9] {s : \u03b9 \u2192 Set \u03b1} (h : \u2200 i, IsClosed (s i)) :\n    IsClosed (\u22c3 i, s i)", "start": [268, 1], "end": [271, 34], "kind": "commanddeclaration"}, {"full_name": "isClosed_imp", "code": "theorem isClosed_imp {p q : \u03b1 \u2192 Prop} (hp : IsOpen { x | p x }) (hq : IsClosed { x | q x }) :\n    IsClosed { x | p x \u2192 q x }", "start": [274, 1], "end": [276, 63], "kind": "commanddeclaration"}, {"full_name": "IsClosed.not", "code": "theorem IsClosed.not : IsClosed { a | p a } \u2192 IsOpen { a | \u00acp a }", "start": [279, 1], "end": [280, 23], "kind": "commanddeclaration"}, {"full_name": "interior", "code": "def interior (s : Set \u03b1) : Set \u03b1 :=\n  \u22c3\u2080 { t | IsOpen t \u2227 t \u2286 s }", "start": [287, 1], "end": [289, 30], "kind": "commanddeclaration"}, {"full_name": "mem_interior", "code": "theorem mem_interior {s : Set \u03b1} {x : \u03b1} : x \u2208 interior s \u2194 \u2203 t, t \u2286 s \u2227 IsOpen t \u2227 x \u2208 t", "start": [293, 1], "end": [294, 75], "kind": "commanddeclaration"}, {"full_name": "isOpen_interior", "code": "@[simp]\ntheorem isOpen_interior {s : Set \u03b1} : IsOpen (interior s)", "start": [297, 1], "end": [299, 34], "kind": "commanddeclaration"}, {"full_name": "interior_subset", "code": "theorem interior_subset {s : Set \u03b1} : interior s \u2286 s", "start": [302, 1], "end": [303, 35], "kind": "commanddeclaration"}, {"full_name": "interior_maximal", "code": "theorem interior_maximal {s t : Set \u03b1} (h\u2081 : t \u2286 s) (h\u2082 : IsOpen t) : t \u2286 interior s", "start": [306, 1], "end": [307, 32], "kind": "commanddeclaration"}, {"full_name": "IsOpen.interior_eq", "code": "theorem IsOpen.interior_eq {s : Set \u03b1} (h : IsOpen s) : interior s = s", "start": [310, 1], "end": [311, 64], "kind": "commanddeclaration"}, {"full_name": "interior_eq_iff_isOpen", "code": "theorem interior_eq_iff_isOpen {s : Set \u03b1} : interior s = s \u2194 IsOpen s", "start": [314, 1], "end": [315, 53], "kind": "commanddeclaration"}, {"full_name": "subset_interior_iff_isOpen", "code": "theorem subset_interior_iff_isOpen {s : Set \u03b1} : s \u2286 interior s \u2194 IsOpen s", "start": [318, 1], "end": [319, 90], "kind": "commanddeclaration"}, {"full_name": "IsOpen.subset_interior_iff", "code": "theorem IsOpen.subset_interior_iff {s t : Set \u03b1} (h\u2081 : IsOpen s) : s \u2286 interior t \u2194 s \u2286 t", "start": [322, 1], "end": [323, 78], "kind": "commanddeclaration"}, {"full_name": "subset_interior_iff", "code": "theorem subset_interior_iff {s t : Set \u03b1} : t \u2286 interior s \u2194 \u2203 U, IsOpen U \u2227 t \u2286 U \u2227 U \u2286 s", "start": [326, 1], "end": [328, 41], "kind": "commanddeclaration"}, {"full_name": "interior_subset_iff", "code": "lemma interior_subset_iff : interior s \u2286 t \u2194 \u2200 U, IsOpen U \u2192 U \u2286 s \u2192 U \u2286 t := by\n  simp [interior]", "start": [331, 1], "end": [332, 18], "kind": "mathlibtacticlemma"}, {"full_name": "interior_mono", "code": "@[mono]\ntheorem interior_mono {s t : Set \u03b1} (h : s \u2286 t) : interior s \u2286 interior t", "start": [334, 1], "end": [336, 68], "kind": "commanddeclaration"}, {"full_name": "interior_empty", "code": "@[simp]\ntheorem interior_empty : interior (\u2205 : Set \u03b1) = \u2205", "start": [339, 1], "end": [341, 27], "kind": "commanddeclaration"}, {"full_name": "interior_univ", "code": "@[simp]\ntheorem interior_univ : interior (univ : Set \u03b1) = univ", "start": [344, 1], "end": [346, 26], "kind": "commanddeclaration"}, {"full_name": "interior_eq_univ", "code": "@[simp]\ntheorem interior_eq_univ {s : Set \u03b1} : interior s = univ \u2194 s = univ", "start": [349, 1], "end": [351, 100], "kind": "commanddeclaration"}, {"full_name": "interior_interior", "code": "@[simp]\ntheorem interior_interior {s : Set \u03b1} : interior (interior s) = interior s", "start": [354, 1], "end": [356, 30], "kind": "commanddeclaration"}, {"full_name": "interior_inter", "code": "@[simp]\ntheorem interior_inter {s t : Set \u03b1} : interior (s \u2229 t) = interior s \u2229 interior t", "start": [359, 1], "end": [365, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.interior_iInter", "code": "@[simp]\ntheorem Finset.interior_iInter {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 Set \u03b1) :\n    interior (\u22c2 i \u2208 s, f i) = \u22c2 i \u2208 s, interior (f i)", "start": [368, 1], "end": [374, 14], "kind": "commanddeclaration"}, {"full_name": "interior_iInter_of_finite", "code": "@[simp]\ntheorem interior_iInter_of_finite {\u03b9 : Type*} [Finite \u03b9] (f : \u03b9 \u2192 Set \u03b1) :\n    interior (\u22c2 i, f i) = \u22c2 i, interior (f i)", "start": [378, 1], "end": [382, 49], "kind": "commanddeclaration"}, {"full_name": "interior_union_isClosed_of_interior_empty", "code": "theorem interior_union_isClosed_of_interior_empty {s t : Set \u03b1} (h\u2081 : IsClosed s)\n    (h\u2082 : interior t = \u2205) : interior (s \u222a t) = interior s", "start": [385, 1], "end": [393, 99], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_forall_mem_open", "code": "theorem isOpen_iff_forall_mem_open : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 t, t \u2286 s \u2227 IsOpen t \u2227 x \u2208 t", "start": [396, 1], "end": [398, 39], "kind": "commanddeclaration"}, {"full_name": "interior_iInter_subset", "code": "theorem interior_iInter_subset (s : \u03b9 \u2192 Set \u03b1) : interior (\u22c2 i, s i) \u2286 \u22c2 i, interior (s i)", "start": [401, 1], "end": [402, 60], "kind": "commanddeclaration"}, {"full_name": "interior_iInter\u2082_subset", "code": "theorem interior_iInter\u2082_subset (p : \u03b9 \u2192 Sort*) (s : \u2200 i, p i \u2192 Set \u03b1) :\n    interior (\u22c2 (i) (j), s i j) \u2286 \u22c2 (i) (j), interior (s i j)", "start": [405, 1], "end": [407, 84], "kind": "commanddeclaration"}, {"full_name": "interior_sInter_subset", "code": "theorem interior_sInter_subset (S : Set (Set \u03b1)) : interior (\u22c2\u2080 S) \u2286 \u22c2 s \u2208 S, interior s", "start": [410, 1], "end": [413, 59], "kind": "commanddeclaration"}, {"full_name": "closure", "code": "def closure (s : Set \u03b1) : Set \u03b1 :=\n  \u22c2\u2080 { t | IsClosed t \u2227 s \u2286 t }", "start": [421, 1], "end": [423, 32], "kind": "commanddeclaration"}, {"full_name": "isClosed_closure", "code": "@[simp]\ntheorem isClosed_closure {s : Set \u03b1} : IsClosed (closure s)", "start": [430, 1], "end": [432, 36], "kind": "commanddeclaration"}, {"full_name": "subset_closure", "code": "theorem subset_closure {s : Set \u03b1} : s \u2286 closure s", "start": [435, 1], "end": [436, 35], "kind": "commanddeclaration"}, {"full_name": "not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set \u03b1} {P : \u03b1} (hP : P \u2209 closure s) : P \u2209 s", "start": [439, 1], "end": [440, 24], "kind": "commanddeclaration"}, {"full_name": "closure_minimal", "code": "theorem closure_minimal {s t : Set \u03b1} (h\u2081 : s \u2286 t) (h\u2082 : IsClosed t) : closure s \u2286 t", "start": [443, 1], "end": [444, 32], "kind": "commanddeclaration"}, {"full_name": "Disjoint.closure_left", "code": "theorem Disjoint.closure_left {s t : Set \u03b1} (hd : Disjoint s t) (ht : IsOpen t) :\n    Disjoint (closure s) t", "start": [447, 1], "end": [449, 91], "kind": "commanddeclaration"}, {"full_name": "Disjoint.closure_right", "code": "theorem Disjoint.closure_right {s t : Set \u03b1} (hd : Disjoint s t) (hs : IsOpen s) :\n    Disjoint s (closure t)", "start": [452, 1], "end": [454, 33], "kind": "commanddeclaration"}, {"full_name": "IsClosed.closure_eq", "code": "theorem IsClosed.closure_eq {s : Set \u03b1} (h : IsClosed s) : closure s = s", "start": [457, 1], "end": [458, 69], "kind": "commanddeclaration"}, {"full_name": "IsClosed.closure_subset", "code": "theorem IsClosed.closure_subset {s : Set \u03b1} (hs : IsClosed s) : closure s \u2286 s", "start": [461, 1], "end": [462, 37], "kind": "commanddeclaration"}, {"full_name": "IsClosed.closure_subset_iff", "code": "theorem IsClosed.closure_subset_iff {s t : Set \u03b1} (h\u2081 : IsClosed t) : closure s \u2286 t \u2194 s \u2286 t", "start": [465, 1], "end": [466, 63], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_iff_closure_subset", "code": "theorem IsClosed.mem_iff_closure_subset {s : Set \u03b1} (hs : IsClosed s) {x : \u03b1} :\n    x \u2208 s \u2194 closure ({x} : Set \u03b1) \u2286 s", "start": [469, 1], "end": [471, 62], "kind": "commanddeclaration"}, {"full_name": "closure_mono", "code": "@[mono]\ntheorem closure_mono {s t : Set \u03b1} (h : s \u2286 t) : closure s \u2286 closure t", "start": [474, 1], "end": [476, 67], "kind": "commanddeclaration"}, {"full_name": "monotone_closure", "code": "theorem monotone_closure (\u03b1 : Type*) [TopologicalSpace \u03b1] : Monotone (@closure \u03b1 _)", "start": [479, 1], "end": [480, 15], "kind": "commanddeclaration"}, {"full_name": "diff_subset_closure_iff", "code": "theorem diff_subset_closure_iff {s t : Set \u03b1} : s \\ t \u2286 closure t \u2194 s \u2286 closure t", "start": [483, 1], "end": [484, 68], "kind": "commanddeclaration"}, {"full_name": "closure_inter_subset_inter_closure", "code": "theorem closure_inter_subset_inter_closure (s t : Set \u03b1) :\n    closure (s \u2229 t) \u2286 closure s \u2229 closure t", "start": [487, 1], "end": [489, 38], "kind": "commanddeclaration"}, {"full_name": "isClosed_of_closure_subset", "code": "theorem isClosed_of_closure_subset {s : Set \u03b1} (h : closure s \u2286 s) : IsClosed s", "start": [492, 1], "end": [493, 57], "kind": "commanddeclaration"}, {"full_name": "closure_eq_iff_isClosed", "code": "theorem closure_eq_iff_isClosed {s : Set \u03b1} : closure s = s \u2194 IsClosed s", "start": [496, 1], "end": [497, 55], "kind": "commanddeclaration"}, {"full_name": "closure_subset_iff_isClosed", "code": "theorem closure_subset_iff_isClosed {s : Set \u03b1} : closure s \u2286 s \u2194 IsClosed s", "start": [500, 1], "end": [501, 56], "kind": "commanddeclaration"}, {"full_name": "closure_empty", "code": "@[simp]\ntheorem closure_empty : closure (\u2205 : Set \u03b1) = \u2205", "start": [504, 1], "end": [506, 28], "kind": "commanddeclaration"}, {"full_name": "closure_empty_iff", "code": "@[simp]\ntheorem closure_empty_iff (s : Set \u03b1) : closure s = \u2205 \u2194 s = \u2205", "start": [509, 1], "end": [511, 68], "kind": "commanddeclaration"}, {"full_name": "closure_nonempty_iff", "code": "@[simp]\ntheorem closure_nonempty_iff {s : Set \u03b1} : (closure s).Nonempty \u2194 s.Nonempty", "start": [514, 1], "end": [516, 63], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_closure", "code": "alias \u27e8Set.Nonempty.of_closure, Set.Nonempty.closure\u27e9 := closure_nonempty_iff", "start": [519, 1], "end": [519, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Nonempty.closure", "code": "alias \u27e8Set.Nonempty.of_closure, Set.Nonempty.closure\u27e9 := closure_nonempty_iff", "start": [519, 1], "end": [519, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "closure_univ", "code": "@[simp]\ntheorem closure_univ : closure (univ : Set \u03b1) = univ", "start": [523, 1], "end": [525, 27], "kind": "commanddeclaration"}, {"full_name": "closure_closure", "code": "@[simp]\ntheorem closure_closure {s : Set \u03b1} : closure (closure s) = closure s", "start": [528, 1], "end": [530, 30], "kind": "commanddeclaration"}, {"full_name": "closure_union", "code": "@[simp]\ntheorem closure_union {s t : Set \u03b1} : closure (s \u222a t) = closure s \u222a closure t", "start": [533, 1], "end": [538, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.closure_biUnion", "code": "@[simp]\ntheorem Finset.closure_biUnion {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 Set \u03b1) :\n    closure (\u22c3 i \u2208 s, f i) = \u22c3 i \u2208 s, closure (f i)", "start": [541, 1], "end": [547, 14], "kind": "commanddeclaration"}, {"full_name": "closure_iUnion_of_finite", "code": "@[simp]\ntheorem closure_iUnion_of_finite {\u03b9 : Type*} [Finite \u03b9] (f : \u03b9 \u2192 Set \u03b1) :\n    closure (\u22c3 i, f i) = \u22c3 i, closure (f i)", "start": [550, 1], "end": [554, 49], "kind": "commanddeclaration"}, {"full_name": "interior_subset_closure", "code": "theorem interior_subset_closure {s : Set \u03b1} : interior s \u2286 closure s", "start": [557, 1], "end": [558, 46], "kind": "commanddeclaration"}, {"full_name": "closure_eq_compl_interior_compl", "code": "theorem closure_eq_compl_interior_compl {s : Set \u03b1} : closure s = (interior s\u1d9c)\u1d9c", "start": [561, 1], "end": [563, 51], "kind": "commanddeclaration"}, {"full_name": "interior_compl", "code": "@[simp]\ntheorem interior_compl {s : Set \u03b1} : interior s\u1d9c = (closure s)\u1d9c", "start": [566, 1], "end": [568, 41], "kind": "commanddeclaration"}, {"full_name": "closure_compl", "code": "@[simp]\ntheorem closure_compl {s : Set \u03b1} : closure s\u1d9c = (interior s)\u1d9c", "start": [571, 1], "end": [573, 41], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff", "code": "theorem mem_closure_iff {s : Set \u03b1} {a : \u03b1} :\n    a \u2208 closure s \u2194 \u2200 o, IsOpen o \u2192 a \u2208 o \u2192 (o \u2229 s).Nonempty", "start": [576, 1], "end": [585, 18], "kind": "commanddeclaration"}, {"full_name": "closure_inter_open_nonempty_iff", "code": "theorem closure_inter_open_nonempty_iff {s t : Set \u03b1} (h : IsOpen t) :\n    (closure s \u2229 t).Nonempty \u2194 (s \u2229 t).Nonempty", "start": [588, 1], "end": [591, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.le_lift'_closure", "code": "theorem Filter.le_lift'_closure (l : Filter \u03b1) : l \u2264 l.lift' closure", "start": [594, 1], "end": [595, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.lift'_closure", "code": "theorem Filter.HasBasis.lift'_closure {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : l.HasBasis p s) : (l.lift' closure).HasBasis p fun i => closure (s i)", "start": [598, 1], "end": [600, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.lift'_closure_eq_self", "code": "theorem Filter.HasBasis.lift'_closure_eq_self {l : Filter \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : l.HasBasis p s) (hc : \u2200 i, p i \u2192 IsClosed (s i)) : l.lift' closure = l", "start": [603, 1], "end": [606, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.lift'_closure_eq_bot", "code": "@[simp]\ntheorem Filter.lift'_closure_eq_bot {l : Filter \u03b1} : l.lift' closure = \u22a5 \u2194 l = \u22a5", "start": [609, 1], "end": [612, 85], "kind": "commanddeclaration"}, {"full_name": "Dense", "code": "def Dense (s : Set \u03b1) : Prop :=\n  \u2200 x, x \u2208 closure s", "start": [615, 1], "end": [617, 21], "kind": "commanddeclaration"}, {"full_name": "dense_iff_closure_eq", "code": "theorem dense_iff_closure_eq {s : Set \u03b1} : Dense s \u2194 closure s = univ", "start": [620, 1], "end": [621, 26], "kind": "commanddeclaration"}, {"full_name": "Dense.closure_eq", "code": "alias \u27e8Dense.closure_eq, _\u27e9 := dense_iff_closure_eq", "start": [624, 1], "end": [624, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "interior_eq_empty_iff_dense_compl", "code": "theorem interior_eq_empty_iff_dense_compl {s : Set \u03b1} : interior s = \u2205 \u2194 Dense s\u1d9c", "start": [627, 1], "end": [628, 59], "kind": "commanddeclaration"}, {"full_name": "Dense.interior_compl", "code": "theorem Dense.interior_compl {s : Set \u03b1} (h : Dense s) : interior s\u1d9c = \u2205", "start": [631, 1], "end": [632, 62], "kind": "commanddeclaration"}, {"full_name": "dense_closure", "code": "@[simp]\ntheorem dense_closure {s : Set \u03b1} : Dense (closure s) \u2194 Dense s", "start": [635, 1], "end": [638, 37], "kind": "commanddeclaration"}, {"full_name": "Dense.closure", "code": "protected alias \u27e8_, Dense.closure\u27e9 := dense_closure", "start": [641, 1], "end": [641, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Dense.of_closure", "code": "alias \u27e8Dense.of_closure, _\u27e9 := dense_closure", "start": [642, 1], "end": [642, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "dense_univ", "code": "@[simp]\ntheorem dense_univ : Dense (univ : Set \u03b1)", "start": [646, 1], "end": [647, 77], "kind": "commanddeclaration"}, {"full_name": "dense_iff_inter_open", "code": "theorem dense_iff_inter_open {s : Set \u03b1} :\n    Dense s \u2194 \u2200 U, IsOpen U \u2192 U.Nonempty \u2192 (U \u2229 s).Nonempty", "start": [650, 1], "end": [659, 29], "kind": "commanddeclaration"}, {"full_name": "Dense.inter_open_nonempty", "code": "alias \u27e8Dense.inter_open_nonempty, _\u27e9 := dense_iff_inter_open", "start": [662, 1], "end": [662, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Dense.exists_mem_open", "code": "theorem Dense.exists_mem_open {s : Set \u03b1} (hs : Dense s) {U : Set \u03b1} (ho : IsOpen U)\n    (hne : U.Nonempty) : \u2203 x \u2208 s, x \u2208 U", "start": [665, 1], "end": [668, 18], "kind": "commanddeclaration"}, {"full_name": "Dense.nonempty_iff", "code": "theorem Dense.nonempty_iff {s : Set \u03b1} (hs : Dense s) : s.Nonempty \u2194 Nonempty \u03b1", "start": [671, 1], "end": [674, 15], "kind": "commanddeclaration"}, {"full_name": "Dense.nonempty", "code": "theorem Dense.nonempty [h : Nonempty \u03b1] {s : Set \u03b1} (hs : Dense s) : s.Nonempty", "start": [677, 1], "end": [678, 22], "kind": "commanddeclaration"}, {"full_name": "Dense.mono", "code": "@[mono]\ntheorem Dense.mono {s\u2081 s\u2082 : Set \u03b1} (h : s\u2081 \u2286 s\u2082) (hd : Dense s\u2081) : Dense s\u2082", "start": [681, 1], "end": [683, 24], "kind": "commanddeclaration"}, {"full_name": "dense_compl_singleton_iff_not_open", "code": "theorem dense_compl_singleton_iff_not_open {x : \u03b1} :\n    Dense ({x}\u1d9c : Set \u03b1) \u2194 \u00acIsOpen ({x} : Set \u03b1)", "start": [686, 1], "end": [695, 16], "kind": "commanddeclaration"}, {"full_name": "frontier", "code": "def frontier (s : Set \u03b1) : Set \u03b1 :=\n  closure s \\ interior s", "start": [702, 1], "end": [704, 25], "kind": "commanddeclaration"}, {"full_name": "closure_diff_interior", "code": "@[simp]\ntheorem closure_diff_interior (s : Set \u03b1) : closure s \\ interior s = frontier s", "start": [707, 1], "end": [709, 6], "kind": "commanddeclaration"}, {"full_name": "closure_diff_frontier", "code": "@[simp]\ntheorem closure_diff_frontier (s : Set \u03b1) : closure s \\ frontier s = interior s", "start": [712, 1], "end": [714, 93], "kind": "commanddeclaration"}, {"full_name": "self_diff_frontier", "code": "@[simp]\ntheorem self_diff_frontier (s : Set \u03b1) : s \\ frontier s = interior s", "start": [717, 1], "end": [720, 64], "kind": "commanddeclaration"}, {"full_name": "frontier_eq_closure_inter_closure", "code": "theorem frontier_eq_closure_inter_closure {s : Set \u03b1} : frontier s = closure s \u2229 closure s\u1d9c", "start": [723, 1], "end": [724, 40], "kind": "commanddeclaration"}, {"full_name": "frontier_subset_closure", "code": "theorem frontier_subset_closure {s : Set \u03b1} : frontier s \u2286 closure s", "start": [727, 1], "end": [728, 18], "kind": "commanddeclaration"}, {"full_name": "IsClosed.frontier_subset", "code": "theorem IsClosed.frontier_subset (hs : IsClosed s) : frontier s \u2286 s", "start": [731, 1], "end": [732, 53], "kind": "commanddeclaration"}, {"full_name": "frontier_closure_subset", "code": "theorem frontier_closure_subset {s : Set \u03b1} : frontier (closure s) \u2286 frontier s", "start": [735, 1], "end": [736, 74], "kind": "commanddeclaration"}, {"full_name": "frontier_interior_subset", "code": "theorem frontier_interior_subset {s : Set \u03b1} : frontier (interior s) \u2286 frontier s", "start": [739, 1], "end": [740, 80], "kind": "commanddeclaration"}, {"full_name": "frontier_compl", "code": "@[simp]\ntheorem frontier_compl (s : Set \u03b1) : frontier s\u1d9c = frontier s", "start": [743, 1], "end": [746, 73], "kind": "commanddeclaration"}, {"full_name": "frontier_univ", "code": "@[simp]\ntheorem frontier_univ : frontier (univ : Set \u03b1) = \u2205", "start": [749, 1], "end": [750, 74], "kind": "commanddeclaration"}, {"full_name": "frontier_empty", "code": "@[simp]\ntheorem frontier_empty : frontier (\u2205 : Set \u03b1) = \u2205", "start": [753, 1], "end": [754, 72], "kind": "commanddeclaration"}, {"full_name": "frontier_inter_subset", "code": "theorem frontier_inter_subset (s t : Set \u03b1) :\n    frontier (s \u2229 t) \u2286 frontier s \u2229 closure t \u222a closure s \u2229 frontier t", "start": [757, 1], "end": [761, 91], "kind": "commanddeclaration"}, {"full_name": "frontier_union_subset", "code": "theorem frontier_union_subset (s t : Set \u03b1) :\n    frontier (s \u222a t) \u2286 frontier s \u2229 closure t\u1d9c \u222a closure s\u1d9c \u2229 frontier t", "start": [764, 1], "end": [766, 79], "kind": "commanddeclaration"}, {"full_name": "IsClosed.frontier_eq", "code": "theorem IsClosed.frontier_eq {s : Set \u03b1} (hs : IsClosed s) : frontier s = s \\ interior s", "start": [769, 1], "end": [770, 31], "kind": "commanddeclaration"}, {"full_name": "IsOpen.frontier_eq", "code": "theorem IsOpen.frontier_eq {s : Set \u03b1} (hs : IsOpen s) : frontier s = closure s \\ s", "start": [773, 1], "end": [774, 32], "kind": "commanddeclaration"}, {"full_name": "IsOpen.inter_frontier_eq", "code": "theorem IsOpen.inter_frontier_eq {s : Set \u03b1} (hs : IsOpen s) : s \u2229 frontier s = \u2205", "start": [777, 1], "end": [778, 39], "kind": "commanddeclaration"}, {"full_name": "isClosed_frontier", "code": "theorem isClosed_frontier {s : Set \u03b1} : IsClosed (frontier s)", "start": [781, 1], "end": [783, 97], "kind": "commanddeclaration"}, {"full_name": "interior_frontier", "code": "theorem interior_frontier {s : Set \u03b1} (h : IsClosed s) : interior (frontier s) = \u2205", "start": [786, 1], "end": [793, 50], "kind": "commanddeclaration"}, {"full_name": "closure_eq_interior_union_frontier", "code": "theorem closure_eq_interior_union_frontier (s : Set \u03b1) : closure s = interior s \u222a frontier s", "start": [796, 1], "end": [797, 51], "kind": "commanddeclaration"}, {"full_name": "closure_eq_self_union_frontier", "code": "theorem closure_eq_self_union_frontier (s : Set \u03b1) : closure s = s \u222a frontier s", "start": [800, 1], "end": [801, 59], "kind": "commanddeclaration"}, {"full_name": "Disjoint.frontier_left", "code": "theorem Disjoint.frontier_left (ht : IsOpen t) (hd : Disjoint s t) : Disjoint (frontier s) t", "start": [804, 1], "end": [806, 101], "kind": "commanddeclaration"}, {"full_name": "Disjoint.frontier_right", "code": "theorem Disjoint.frontier_right (hs : IsOpen s) (hd : Disjoint s t) : Disjoint s (frontier t)", "start": [809, 1], "end": [810, 34], "kind": "commanddeclaration"}, {"full_name": "frontier_eq_inter_compl_interior", "code": "theorem frontier_eq_inter_compl_interior {s : Set \u03b1} :\n    frontier s = (interior s)\u1d9c \u2229 (interior s\u1d9c)\u1d9c", "start": [813, 1], "end": [815, 46], "kind": "commanddeclaration"}, {"full_name": "compl_frontier_eq_union_interior", "code": "theorem compl_frontier_eq_union_interior {s : Set \u03b1} :\n    (frontier s)\u1d9c = interior s \u222a interior s\u1d9c", "start": [818, 1], "end": [821, 39], "kind": "commanddeclaration"}, {"full_name": "nhds", "code": "irreducible_def nhds (a : \u03b1) : Filter \u03b1 :=\n  \u2a05 s \u2208 { s : Set \u03b1 | a \u2208 s \u2227 IsOpen s }, \ud835\udcdf s", "start": [828, 1], "end": [832, 46], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "nhdsWithin", "code": "def nhdsWithin (a : \u03b1) (s : Set \u03b1) : Filter \u03b1 :=\n  nhds a \u2293 \ud835\udcdf s", "start": [836, 1], "end": [839, 15], "kind": "commanddeclaration"}, {"full_name": "nhds_def'", "code": "theorem nhds_def' (a : \u03b1) : \ud835\udcdd a = \u2a05 (s : Set \u03b1) (_ : IsOpen s) (_ : a \u2208 s), \ud835\udcdf s", "start": [867, 1], "end": [868, 66], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_opens", "code": "theorem nhds_basis_opens (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun s : Set \u03b1 => a \u2208 s \u2227 IsOpen s) fun s => s", "start": [871, 1], "end": [879, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_closeds", "code": "theorem nhds_basis_closeds (a : \u03b1) : (\ud835\udcdd a).HasBasis (fun s : Set \u03b1 => a \u2209 s \u2227 IsClosed s) compl", "start": [882, 1], "end": [884, 85], "kind": "commanddeclaration"}, {"full_name": "le_nhds_iff", "code": "theorem le_nhds_iff {f a} : f \u2264 \ud835\udcdd a \u2194 \u2200 s : Set \u03b1, a \u2208 s \u2192 IsOpen s \u2192 s \u2208 f", "start": [887, 1], "end": [888, 98], "kind": "commanddeclaration"}, {"full_name": "nhds_le_of_le", "code": "theorem nhds_le_of_le {f a} {s : Set \u03b1} (h : a \u2208 s) (o : IsOpen s) (sf : \ud835\udcdf s \u2264 f) : \ud835\udcdd a \u2264 f", "start": [891, 1], "end": [894, 50], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_iff", "code": "theorem mem_nhds_iff {a : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd a \u2194 \u2203 t, t \u2286 s \u2227 IsOpen t \u2227 a \u2208 t", "start": [898, 1], "end": [900, 67], "kind": "commanddeclaration"}, {"full_name": "eventually_nhds_iff", "code": "theorem eventually_nhds_iff {a : \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in \ud835\udcdd a, p x) \u2194 \u2203 t : Set \u03b1, (\u2200 x \u2208 t, p x) \u2227 IsOpen t \u2227 a \u2208 t", "start": [903, 1], "end": [907, 77], "kind": "commanddeclaration"}, {"full_name": "mem_interior_iff_mem_nhds", "code": "theorem mem_interior_iff_mem_nhds {s : Set \u03b1} {a : \u03b1} : a \u2208 interior s \u2194 s \u2208 \ud835\udcdd a", "start": [910, 1], "end": [911, 39], "kind": "commanddeclaration"}, {"full_name": "map_nhds", "code": "theorem map_nhds {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    map f (\ud835\udcdd a) = \u2a05 s \u2208 { s : Set \u03b1 | a \u2208 s \u2227 IsOpen s }, \ud835\udcdf (image f s)", "start": [914, 1], "end": [916, 40], "kind": "commanddeclaration"}, {"full_name": "mem_of_mem_nhds", "code": "theorem mem_of_mem_nhds {a : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd a \u2192 a \u2208 s", "start": [919, 1], "end": [920, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.self_of_nhds", "code": "theorem Filter.Eventually.self_of_nhds {p : \u03b1 \u2192 Prop} {a : \u03b1} (h : \u2200\u1da0 y in \ud835\udcdd a, p y) : p a", "start": [923, 1], "end": [925, 20], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mem_nhds", "code": "theorem IsOpen.mem_nhds {a : \u03b1} {s : Set \u03b1} (hs : IsOpen s) (ha : a \u2208 s) : s \u2208 \ud835\udcdd a", "start": [928, 1], "end": [929, 44], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mem_nhds_iff", "code": "protected theorem IsOpen.mem_nhds_iff {a : \u03b1} {s : Set \u03b1} (hs : IsOpen s) : s \u2208 \ud835\udcdd a \u2194 a \u2208 s", "start": [932, 1], "end": [933, 70], "kind": "commanddeclaration"}, {"full_name": "IsClosed.compl_mem_nhds", "code": "theorem IsClosed.compl_mem_nhds {a : \u03b1} {s : Set \u03b1} (hs : IsClosed s) (ha : a \u2209 s) : s\u1d9c \u2208 \ud835\udcdd a", "start": [936, 1], "end": [937, 42], "kind": "commanddeclaration"}, {"full_name": "IsOpen.eventually_mem", "code": "theorem IsOpen.eventually_mem {a : \u03b1} {s : Set \u03b1} (hs : IsOpen s) (ha : a \u2208 s) :\n    \u2200\u1da0 x in \ud835\udcdd a, x \u2208 s", "start": [940, 1], "end": [942, 24], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_opens'", "code": "theorem nhds_basis_opens' (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun s : Set \u03b1 => s \u2208 \ud835\udcdd a \u2227 IsOpen s) fun x => x", "start": [945, 1], "end": [950, 49], "kind": "commanddeclaration"}, {"full_name": "exists_open_set_nhds", "code": "theorem exists_open_set_nhds {s U : Set \u03b1} (h : \u2200 x \u2208 s, U \u2208 \ud835\udcdd x) :\n    \u2203 V : Set \u03b1, s \u2286 V \u2227 IsOpen V \u2227 V \u2286 U", "start": [953, 1], "end": [957, 100], "kind": "commanddeclaration"}, {"full_name": "exists_open_set_nhds'", "code": "theorem exists_open_set_nhds' {s U : Set \u03b1} (h : U \u2208 \u2a06 x \u2208 s, \ud835\udcdd x) :\n    \u2203 V : Set \u03b1, s \u2286 V \u2227 IsOpen V \u2227 V \u2286 U", "start": [960, 1], "end": [964, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.eventually_nhds", "code": "theorem Filter.Eventually.eventually_nhds {p : \u03b1 \u2192 Prop} {a : \u03b1} (h : \u2200\u1da0 y in \ud835\udcdd a, p y) :\n    \u2200\u1da0 y in \ud835\udcdd a, \u2200\u1da0 x in \ud835\udcdd y, p x", "start": [967, 1], "end": [972, 91], "kind": "commanddeclaration"}, {"full_name": "eventually_eventually_nhds", "code": "@[simp]\ntheorem eventually_eventually_nhds {p : \u03b1 \u2192 Prop} {a : \u03b1} :\n    (\u2200\u1da0 y in \ud835\udcdd a, \u2200\u1da0 x in \ud835\udcdd y, p x) \u2194 \u2200\u1da0 x in \ud835\udcdd a, p x", "start": [975, 1], "end": [978, 56], "kind": "commanddeclaration"}, {"full_name": "frequently_frequently_nhds", "code": "@[simp]\ntheorem frequently_frequently_nhds {p : \u03b1 \u2192 Prop} {a : \u03b1} :\n    (\u2203\u1da0 y in \ud835\udcdd a, \u2203\u1da0 x in \ud835\udcdd y, p x) \u2194 \u2203\u1da0 x in \ud835\udcdd a, p x", "start": [981, 1], "end": [985, 57], "kind": "commanddeclaration"}, {"full_name": "eventually_mem_nhds", "code": "@[simp]\ntheorem eventually_mem_nhds {s : Set \u03b1} {a : \u03b1} : (\u2200\u1da0 x in \ud835\udcdd a, s \u2208 \ud835\udcdd x) \u2194 s \u2208 \ud835\udcdd a", "start": [988, 1], "end": [990, 29], "kind": "commanddeclaration"}, {"full_name": "nhds_bind_nhds", "code": "@[simp]\ntheorem nhds_bind_nhds : (\ud835\udcdd a).bind \ud835\udcdd = \ud835\udcdd a", "start": [993, 1], "end": [995, 49], "kind": "commanddeclaration"}, {"full_name": "eventually_eventuallyEq_nhds", "code": "@[simp]\ntheorem eventually_eventuallyEq_nhds {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} :\n    (\u2200\u1da0 y in \ud835\udcdd a, f =\u1da0[\ud835\udcdd y] g) \u2194 f =\u1da0[\ud835\udcdd a] g", "start": [998, 1], "end": [1001, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.eq_of_nhds", "code": "theorem Filter.EventuallyEq.eq_of_nhds {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f =\u1da0[\ud835\udcdd a] g) : f a = g a", "start": [1004, 1], "end": [1005, 17], "kind": "commanddeclaration"}, {"full_name": "eventually_eventuallyLE_nhds", "code": "@[simp]\ntheorem eventually_eventuallyLE_nhds [LE \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} :\n    (\u2200\u1da0 y in \ud835\udcdd a, f \u2264\u1da0[\ud835\udcdd y] g) \u2194 f \u2264\u1da0[\ud835\udcdd a] g", "start": [1008, 1], "end": [1011, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.eventuallyEq_nhds", "code": "theorem Filter.EventuallyEq.eventuallyEq_nhds {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f =\u1da0[\ud835\udcdd a] g) :\n    \u2200\u1da0 y in \ud835\udcdd a, f =\u1da0[\ud835\udcdd y] g", "start": [1014, 1], "end": [1018, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.eventuallyLE_nhds", "code": "theorem Filter.EventuallyLE.eventuallyLE_nhds [LE \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f \u2264\u1da0[\ud835\udcdd a] g) :\n    \u2200\u1da0 y in \ud835\udcdd a, f \u2264\u1da0[\ud835\udcdd y] g", "start": [1021, 1], "end": [1025, 20], "kind": "commanddeclaration"}, {"full_name": "all_mem_nhds", "code": "theorem all_mem_nhds (x : \u03b1) (P : Set \u03b1 \u2192 Prop) (hP : \u2200 s t, s \u2286 t \u2192 P s \u2192 P t) :\n    (\u2200 s \u2208 \ud835\udcdd x, P s) \u2194 \u2200 s, IsOpen s \u2192 x \u2208 s \u2192 P s", "start": [1028, 1], "end": [1030, 90], "kind": "commanddeclaration"}, {"full_name": "all_mem_nhds_filter", "code": "theorem all_mem_nhds_filter (x : \u03b1) (f : Set \u03b1 \u2192 Set \u03b2) (hf : \u2200 s t, s \u2286 t \u2192 f s \u2286 f t)\n    (l : Filter \u03b2) : (\u2200 s \u2208 \ud835\udcdd x, f s \u2208 l) \u2194 \u2200 s, IsOpen s \u2192 x \u2208 s \u2192 f s \u2208 l", "start": [1033, 1], "end": [1035, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds", "code": "theorem tendsto_nhds {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} :\n    Tendsto f l (\ud835\udcdd a) \u2194 \u2200 s, IsOpen s \u2192 a \u2208 s \u2192 f \u207b\u00b9' s \u2208 l", "start": [1038, 1], "end": [1040, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_nhds", "code": "theorem tendsto_atTop_nhds [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto f atTop (\ud835\udcdd a) \u2194 \u2200 U : Set \u03b1, a \u2208 U \u2192 IsOpen U \u2192 \u2203 N, \u2200 n, N \u2264 n \u2192 f n \u2208 U", "start": [1043, 1], "end": [1046, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_nhds", "code": "theorem tendsto_const_nhds {a : \u03b1} {f : Filter \u03b2} : Tendsto (fun _ : \u03b2 => a) f (\ud835\udcdd a)", "start": [1049, 1], "end": [1050, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_of_eventually_const", "code": "theorem tendsto_atTop_of_eventually_const {\u03b9 : Type*} [SemilatticeSup \u03b9] [Nonempty \u03b9] {x : \u03b1}\n    {u : \u03b9 \u2192 \u03b1} {i\u2080 : \u03b9} (h : \u2200 i \u2265 i\u2080, u i = x) : Tendsto u atTop (\ud835\udcdd x)", "start": [1053, 1], "end": [1055, 87], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_of_eventually_const", "code": "theorem tendsto_atBot_of_eventually_const {\u03b9 : Type*} [SemilatticeInf \u03b9] [Nonempty \u03b9] {x : \u03b1}\n    {u : \u03b9 \u2192 \u03b1} {i\u2080 : \u03b9} (h : \u2200 i \u2264 i\u2080, u i = x) : Tendsto u atBot (\ud835\udcdd x)", "start": [1058, 1], "end": [1060, 87], "kind": "commanddeclaration"}, {"full_name": "pure_le_nhds", "code": "theorem pure_le_nhds : pure \u2264 (\ud835\udcdd : \u03b1 \u2192 Filter \u03b1)", "start": [1063, 1], "end": [1063, 99], "kind": "commanddeclaration"}, {"full_name": "tendsto_pure_nhds", "code": "theorem tendsto_pure_nhds {\u03b1 : Type*} [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    Tendsto f (pure a) (\ud835\udcdd (f a))", "start": [1066, 1], "end": [1068, 54], "kind": "commanddeclaration"}, {"full_name": "OrderTop.tendsto_atTop_nhds", "code": "theorem OrderTop.tendsto_atTop_nhds {\u03b1 : Type*} [PartialOrder \u03b1] [OrderTop \u03b1] [TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Tendsto f atTop (\ud835\udcdd (f \u22a4))", "start": [1071, 1], "end": [1073, 53], "kind": "commanddeclaration"}, {"full_name": "nhds_neBot", "code": "@[simp]\ninstance nhds_neBot {a : \u03b1} : NeBot (\ud835\udcdd a) :=\n  neBot_of_le (pure_le_nhds a)", "start": [1076, 1], "end": [1078, 31], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_of_eventually_eq", "code": "theorem tendsto_nhds_of_eventually_eq {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (h : \u2200\u1da0 x in l, f x = a) :\n    Tendsto f l (\ud835\udcdd a)", "start": [1081, 1], "end": [1083, 38], "kind": "commanddeclaration"}, {"full_name": "ClusterPt", "code": "def ClusterPt (x : \u03b1) (F : Filter \u03b1) : Prop :=\n  NeBot (\ud835\udcdd x \u2293 F)", "start": [1093, 1], "end": [1097, 18], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.neBot", "code": "theorem ClusterPt.neBot {x : \u03b1} {F : Filter \u03b1} (h : ClusterPt x F) : NeBot (\ud835\udcdd x \u2293 F)", "start": [1100, 1], "end": [1101, 4], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.clusterPt_iff", "code": "theorem Filter.HasBasis.clusterPt_iff {\u03b9a \u03b9F} {pa : \u03b9a \u2192 Prop} {sa : \u03b9a \u2192 Set \u03b1} {pF : \u03b9F \u2192 Prop}\n    {sF : \u03b9F \u2192 Set \u03b1} {F : Filter \u03b1} (ha : (\ud835\udcdd a).HasBasis pa sa) (hF : F.HasBasis pF sF) :\n    ClusterPt a F \u2194 \u2200 \u2983i\u2984, pa i \u2192 \u2200 \u2983j\u2984, pF j \u2192 (sa i \u2229 sF j).Nonempty", "start": [1104, 1], "end": [1107, 28], "kind": "commanddeclaration"}, {"full_name": "clusterPt_iff", "code": "theorem clusterPt_iff {x : \u03b1} {F : Filter \u03b1} :\n    ClusterPt x F \u2194 \u2200 \u2983U : Set \u03b1\u2984, U \u2208 \ud835\udcdd x \u2192 \u2200 \u2983V\u2984, V \u2208 F \u2192 (U \u2229 V).Nonempty", "start": [1110, 1], "end": [1112, 16], "kind": "commanddeclaration"}, {"full_name": "clusterPt_iff_not_disjoint", "code": "theorem clusterPt_iff_not_disjoint {x : \u03b1} {F : Filter \u03b1} :\n    ClusterPt x F \u2194 \u00acDisjoint (\ud835\udcdd x) F", "start": [1115, 1], "end": [1117, 42], "kind": "commanddeclaration"}, {"full_name": "clusterPt_principal_iff", "code": "theorem clusterPt_principal_iff {x : \u03b1} {s : Set \u03b1} :\n    ClusterPt x (\ud835\udcdf s) \u2194 \u2200 U \u2208 \ud835\udcdd x, (U \u2229 s).Nonempty", "start": [1119, 1], "end": [1123, 26], "kind": "commanddeclaration"}, {"full_name": "clusterPt_principal_iff_frequently", "code": "theorem clusterPt_principal_iff_frequently {x : \u03b1} {s : Set \u03b1} :\n    ClusterPt x (\ud835\udcdf s) \u2194 \u2203\u1da0 y in \ud835\udcdd x, y \u2208 s", "start": [1126, 1], "end": [1128, 96], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.of_le_nhds", "code": "theorem ClusterPt.of_le_nhds {x : \u03b1} {f : Filter \u03b1} (H : f \u2264 \ud835\udcdd x) [NeBot f] : ClusterPt x f", "start": [1131, 1], "end": [1132, 38], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.of_le_nhds'", "code": "theorem ClusterPt.of_le_nhds' {x : \u03b1} {f : Filter \u03b1} (H : f \u2264 \ud835\udcdd x) (_hf : NeBot f) :\n    ClusterPt x f", "start": [1135, 1], "end": [1137, 25], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.of_nhds_le", "code": "theorem ClusterPt.of_nhds_le {x : \u03b1} {f : Filter \u03b1} (H : \ud835\udcdd x \u2264 f) : ClusterPt x f", "start": [1140, 1], "end": [1141, 55], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.mono", "code": "theorem ClusterPt.mono {x : \u03b1} {f g : Filter \u03b1} (H : ClusterPt x f) (h : f \u2264 g) : ClusterPt x g", "start": [1144, 1], "end": [1145, 38], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.of_inf_left", "code": "theorem ClusterPt.of_inf_left {x : \u03b1} {f g : Filter \u03b1} (H : ClusterPt x <| f \u2293 g) : ClusterPt x f", "start": [1148, 1], "end": [1149, 21], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.of_inf_right", "code": "theorem ClusterPt.of_inf_right {x : \u03b1} {f g : Filter \u03b1} (H : ClusterPt x <| f \u2293 g) :\n    ClusterPt x g", "start": [1152, 1], "end": [1154, 22], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.clusterPt_iff", "code": "theorem Ultrafilter.clusterPt_iff {x : \u03b1} {f : Ultrafilter \u03b1} : ClusterPt x f \u2194 \u2191f \u2264 \ud835\udcdd x", "start": [1157, 1], "end": [1158, 56], "kind": "commanddeclaration"}, {"full_name": "MapClusterPt", "code": "def MapClusterPt {\u03b9 : Type*} (x : \u03b1) (F : Filter \u03b9) (u : \u03b9 \u2192 \u03b1) : Prop :=\n  ClusterPt x (map u F)", "start": [1161, 1], "end": [1164, 24], "kind": "commanddeclaration"}, {"full_name": "mapClusterPt_iff", "code": "theorem mapClusterPt_iff {\u03b9 : Type*} (x : \u03b1) (F : Filter \u03b9) (u : \u03b9 \u2192 \u03b1) :\n    MapClusterPt x F u \u2194 \u2200 s \u2208 \ud835\udcdd x, \u2203\u1da0 a in F, u a \u2208 s", "start": [1167, 1], "end": [1170, 6], "kind": "commanddeclaration"}, {"full_name": "mapClusterPt_of_comp", "code": "theorem mapClusterPt_of_comp {\u03b9 \u03b4 : Type*} {F : Filter \u03b9} {\u03c6 : \u03b4 \u2192 \u03b9} {p : Filter \u03b4} {x : \u03b1}\n    {u : \u03b9 \u2192 \u03b1} [NeBot p] (h : Tendsto \u03c6 p F) (H : Tendsto (u \u2218 \u03c6) p (\ud835\udcdd x)) :\n    MapClusterPt x F u", "start": [1173, 1], "end": [1181, 25], "kind": "commanddeclaration"}, {"full_name": "AccPt", "code": "def AccPt (x : \u03b1) (F : Filter \u03b1) : Prop :=\n  NeBot (\ud835\udcdd[\u2260] x \u2293 F)", "start": [1184, 1], "end": [1186, 21], "kind": "commanddeclaration"}, {"full_name": "acc_iff_cluster", "code": "theorem acc_iff_cluster (x : \u03b1) (F : Filter \u03b1) : AccPt x F \u2194 ClusterPt x (\ud835\udcdf {x}\u1d9c \u2293 F)", "start": [1189, 1], "end": [1190, 47], "kind": "commanddeclaration"}, {"full_name": "acc_principal_iff_cluster", "code": "theorem acc_principal_iff_cluster (x : \u03b1) (C : Set \u03b1) : AccPt x (\ud835\udcdf C) \u2194 ClusterPt x (\ud835\udcdf (C \\ {x}))", "start": [1193, 1], "end": [1195, 58], "kind": "commanddeclaration"}, {"full_name": "accPt_iff_nhds", "code": "theorem accPt_iff_nhds (x : \u03b1) (C : Set \u03b1) : AccPt x (\ud835\udcdf C) \u2194 \u2200 U \u2208 \ud835\udcdd x, \u2203 y \u2208 U \u2229 C, y \u2260 x", "start": [1198, 1], "end": [1202, 24], "kind": "commanddeclaration"}, {"full_name": "accPt_iff_frequently", "code": "theorem accPt_iff_frequently (x : \u03b1) (C : Set \u03b1) : AccPt x (\ud835\udcdf C) \u2194 \u2203\u1da0 y in \ud835\udcdd x, y \u2260 x \u2227 y \u2208 C", "start": [1205, 1], "end": [1208, 81], "kind": "commanddeclaration"}, {"full_name": "AccPt.mono", "code": "theorem AccPt.mono {x : \u03b1} {F G : Filter \u03b1} (h : AccPt x F) (hFG : F \u2264 G) : AccPt x G", "start": [1211, 1], "end": [1214, 39], "kind": "commanddeclaration"}, {"full_name": "interior_eq_nhds'", "code": "theorem interior_eq_nhds' {s : Set \u03b1} : interior s = { a | s \u2208 \ud835\udcdd a }", "start": [1221, 1], "end": [1222, 75], "kind": "commanddeclaration"}, {"full_name": "interior_eq_nhds", "code": "theorem interior_eq_nhds {s : Set \u03b1} : interior s = { a | \ud835\udcdd a \u2264 \ud835\udcdf s }", "start": [1225, 1], "end": [1226, 61], "kind": "commanddeclaration"}, {"full_name": "interior_mem_nhds", "code": "@[simp]\ntheorem interior_mem_nhds {s : Set \u03b1} {a : \u03b1} : interior s \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a", "start": [1229, 1], "end": [1232, 69], "kind": "commanddeclaration"}, {"full_name": "interior_setOf_eq", "code": "theorem interior_setOf_eq {p : \u03b1 \u2192 Prop} : interior { x | p x } = { x | \u2200\u1da0 y in \ud835\udcdd x, p y }", "start": [1235, 1], "end": [1236, 20], "kind": "commanddeclaration"}, {"full_name": "isOpen_setOf_eventually_nhds", "code": "theorem isOpen_setOf_eventually_nhds {p : \u03b1 \u2192 Prop} : IsOpen { x | \u2200\u1da0 y in \ud835\udcdd x, p y }", "start": [1239, 1], "end": [1240, 51], "kind": "commanddeclaration"}, {"full_name": "subset_interior_iff_nhds", "code": "theorem subset_interior_iff_nhds {s V : Set \u03b1} : s \u2286 interior V \u2194 \u2200 x \u2208 s, V \u2208 \ud835\udcdd x", "start": [1243, 1], "end": [1244, 50], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_nhds", "code": "theorem isOpen_iff_nhds {s : Set \u03b1} : IsOpen s \u2194 \u2200 a \u2208 s, \ud835\udcdd a \u2264 \ud835\udcdf s", "start": [1247, 1], "end": [1250, 60], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_mem_nhds", "code": "theorem isOpen_iff_mem_nhds {s : Set \u03b1} : IsOpen s \u2194 \u2200 a \u2208 s, s \u2208 \ud835\udcdd a", "start": [1253, 1], "end": [1254, 92], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_eventually", "code": "theorem isOpen_iff_eventually {s : Set \u03b1} : IsOpen s \u2194 \u2200 x, x \u2208 s \u2192 \u2200\u1da0 y in \ud835\udcdd x, y \u2208 s", "start": [1257, 1], "end": [1259, 22], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_ultrafilter", "code": "theorem isOpen_iff_ultrafilter {s : Set \u03b1} :\n    IsOpen s \u2194 \u2200 x \u2208 s, \u2200 (l : Ultrafilter \u03b1), \u2191l \u2264 \ud835\udcdd x \u2192 s \u2208 l", "start": [1262, 1], "end": [1264, 55], "kind": "commanddeclaration"}, {"full_name": "isOpen_singleton_iff_nhds_eq_pure", "code": "theorem isOpen_singleton_iff_nhds_eq_pure (a : \u03b1) : IsOpen ({a} : Set \u03b1) \u2194 \ud835\udcdd a = pure a", "start": [1267, 1], "end": [1274, 30], "kind": "commanddeclaration"}, {"full_name": "isOpen_singleton_iff_punctured_nhds", "code": "theorem isOpen_singleton_iff_punctured_nhds {\u03b1 : Type*} [TopologicalSpace \u03b1] (a : \u03b1) :\n    IsOpen ({a} : Set \u03b1) \u2194 \ud835\udcdd[\u2260] a = \u22a5", "start": [1277, 1], "end": [1280, 28], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_frequently", "code": "theorem mem_closure_iff_frequently {s : Set \u03b1} {a : \u03b1} : a \u2208 closure s \u2194 \u2203\u1da0 x in \ud835\udcdd a, x \u2208 s", "start": [1283, 1], "end": [1285, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.mem_closure", "code": "alias \u27e8_, Filter.Frequently.mem_closure\u27e9 := mem_closure_iff_frequently", "start": [1288, 1], "end": [1288, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "isClosed_iff_frequently", "code": "theorem isClosed_iff_frequently {s : Set \u03b1} : IsClosed s \u2194 \u2200 x, (\u2203\u1da0 y in \ud835\udcdd x, y \u2208 s) \u2192 x \u2208 s", "start": [1291, 1], "end": [1296, 34], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_clusterPt", "code": "theorem isClosed_setOf_clusterPt {f : Filter \u03b1} : IsClosed { x | ClusterPt x f }", "start": [1299, 1], "end": [1304, 54], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_clusterPt", "code": "theorem mem_closure_iff_clusterPt {s : Set \u03b1} {a : \u03b1} : a \u2208 closure s \u2194 ClusterPt a (\ud835\udcdf s)", "start": [1307, 1], "end": [1308, 75], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds_neBot", "code": "theorem mem_closure_iff_nhds_neBot {s : Set \u03b1} : a \u2208 closure s \u2194 \ud835\udcdd a \u2293 \ud835\udcdf s \u2260 \u22a5", "start": [1311, 1], "end": [1312, 44], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhdsWithin_neBot", "code": "theorem mem_closure_iff_nhdsWithin_neBot {s : Set \u03b1} {x : \u03b1} : x \u2208 closure s \u2194 NeBot (\ud835\udcdd[s] x)", "start": [1315, 1], "end": [1316, 28], "kind": "commanddeclaration"}, {"full_name": "dense_compl_singleton", "code": "theorem dense_compl_singleton (x : \u03b1) [NeBot (\ud835\udcdd[\u2260] x)] : Dense ({x}\u1d9c : Set \u03b1)", "start": [1319, 1], "end": [1325, 29], "kind": "commanddeclaration"}, {"full_name": "closure_compl_singleton", "code": "theorem closure_compl_singleton (x : \u03b1) [NeBot (\ud835\udcdd[\u2260] x)] : closure {x}\u1d9c = (univ : Set \u03b1)", "start": [1328, 1], "end": [1332, 39], "kind": "commanddeclaration"}, {"full_name": "interior_singleton", "code": "@[simp]\ntheorem interior_singleton (x : \u03b1) [NeBot (\ud835\udcdd[\u2260] x)] : interior {x} = (\u2205 : Set \u03b1)", "start": [1335, 1], "end": [1338, 64], "kind": "commanddeclaration"}, {"full_name": "not_isOpen_singleton", "code": "theorem not_isOpen_singleton (x : \u03b1) [NeBot (\ud835\udcdd[\u2260] x)] : \u00acIsOpen ({x} : Set \u03b1)", "start": [1341, 1], "end": [1342, 65], "kind": "commanddeclaration"}, {"full_name": "closure_eq_cluster_pts", "code": "theorem closure_eq_cluster_pts {s : Set \u03b1} : closure s = { a | ClusterPt a (\ud835\udcdf s) }", "start": [1345, 1], "end": [1346, 45], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds", "code": "theorem mem_closure_iff_nhds {s : Set \u03b1} {a : \u03b1} : a \u2208 closure s \u2194 \u2200 t \u2208 \ud835\udcdd a, (t \u2229 s).Nonempty", "start": [1349, 1], "end": [1350, 58], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds'", "code": "theorem mem_closure_iff_nhds' {s : Set \u03b1} {a : \u03b1} : a \u2208 closure s \u2194 \u2200 t \u2208 \ud835\udcdd a, \u2203 y : s, \u2191y \u2208 t", "start": [1353, 1], "end": [1354, 100], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_comap_neBot", "code": "theorem mem_closure_iff_comap_neBot {A : Set \u03b1} {x : \u03b1} :\n    x \u2208 closure A \u2194 NeBot (comap ((\u2191) : A \u2192 \u03b1) (\ud835\udcdd x))", "start": [1357, 1], "end": [1360, 32], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds_basis'", "code": "theorem mem_closure_iff_nhds_basis' {a : \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : (\ud835\udcdd a).HasBasis p s)\n    {t : Set \u03b1} : a \u2208 closure t \u2194 \u2200 i, p i \u2192 (s i \u2229 t).Nonempty", "start": [1363, 1], "end": [1366, 95], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds_basis", "code": "theorem mem_closure_iff_nhds_basis {a : \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : (\ud835\udcdd a).HasBasis p s)\n    {t : Set \u03b1} : a \u2208 closure t \u2194 \u2200 i, p i \u2192 \u2203 y \u2208 t, y \u2208 s i", "start": [1369, 1], "end": [1372, 67], "kind": "commanddeclaration"}, {"full_name": "clusterPt_iff_forall_mem_closure", "code": "theorem clusterPt_iff_forall_mem_closure {F : Filter \u03b1} {a : \u03b1} :\n    ClusterPt a F \u2194 \u2200 s \u2208 F, a \u2208 closure s", "start": [1375, 1], "end": [1378, 20], "kind": "commanddeclaration"}, {"full_name": "clusterPt_iff_lift'_closure", "code": "theorem clusterPt_iff_lift'_closure {F : Filter \u03b1} {a : \u03b1} :\n    ClusterPt a F \u2194 pure a \u2264 (F.lift' closure)", "start": [1380, 1], "end": [1384, 18], "kind": "commanddeclaration"}, {"full_name": "clusterPt_iff_lift'_closure'", "code": "theorem clusterPt_iff_lift'_closure' {F : Filter \u03b1} {a : \u03b1} :\n    ClusterPt a F \u2194 (F.lift' closure \u2293 pure a).NeBot", "start": [1386, 1], "end": [1388, 96], "kind": "commanddeclaration"}, {"full_name": "clusterPt_lift'_closure_iff", "code": "@[simp]\ntheorem clusterPt_lift'_closure_iff {F : Filter \u03b1} {a : \u03b1} :\n    ClusterPt a (F.lift' closure) \u2194 ClusterPt a F", "start": [1390, 1], "end": [1393, 98], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_ultrafilter", "code": "theorem mem_closure_iff_ultrafilter {s : Set \u03b1} {x : \u03b1} :\n    x \u2208 closure s \u2194 \u2203 u : Ultrafilter \u03b1, s \u2208 u \u2227 \u2191u \u2264 \ud835\udcdd x", "start": [1395, 1], "end": [1399, 79], "kind": "commanddeclaration"}, {"full_name": "isClosed_iff_clusterPt", "code": "theorem isClosed_iff_clusterPt {s : Set \u03b1} : IsClosed s \u2194 \u2200 a, ClusterPt a (\ud835\udcdf s) \u2192 a \u2208 s", "start": [1402, 1], "end": [1405, 95], "kind": "commanddeclaration"}, {"full_name": "isClosed_iff_nhds", "code": "theorem isClosed_iff_nhds {s : Set \u03b1} : IsClosed s \u2194 \u2200 x, (\u2200 U \u2208 \ud835\udcdd x, (U \u2229 s).Nonempty) \u2192 x \u2208 s", "start": [1408, 1], "end": [1409, 74], "kind": "commanddeclaration"}, {"full_name": "IsClosed.interior_union_left", "code": "theorem IsClosed.interior_union_left {s t : Set \u03b1} (_ : IsClosed s) :\n    interior (s \u222a t) \u2286 s \u222a interior t", "start": [1412, 1], "end": [1417, 17], "kind": "commanddeclaration"}, {"full_name": "IsClosed.interior_union_right", "code": "theorem IsClosed.interior_union_right {s t : Set \u03b1} (h : IsClosed t) :\n    interior (s \u222a t) \u2286 interior s \u222a t", "start": [1420, 1], "end": [1422, 58], "kind": "commanddeclaration"}, {"full_name": "IsOpen.inter_closure", "code": "theorem IsOpen.inter_closure {s t : Set \u03b1} (h : IsOpen s) : s \u2229 closure t \u2286 closure (s \u2229 t)", "start": [1425, 1], "end": [1427, 99], "kind": "commanddeclaration"}, {"full_name": "IsOpen.closure_inter", "code": "theorem IsOpen.closure_inter {s t : Set \u03b1} (h : IsOpen t) : closure s \u2229 t \u2286 closure (s \u2229 t)", "start": [1430, 1], "end": [1431, 50], "kind": "commanddeclaration"}, {"full_name": "Dense.open_subset_closure_inter", "code": "theorem Dense.open_subset_closure_inter {s t : Set \u03b1} (hs : Dense s) (ht : IsOpen t) :\n    t \u2286 closure (t \u2229 s)", "start": [1434, 1], "end": [1438, 44], "kind": "commanddeclaration"}, {"full_name": "mem_closure_of_mem_closure_union", "code": "theorem mem_closure_of_mem_closure_union {s\u2081 s\u2082 : Set \u03b1} {x : \u03b1} (h : x \u2208 closure (s\u2081 \u222a s\u2082))\n    (h\u2081 : s\u2081\u1d9c \u2208 \ud835\udcdd x) : x \u2208 closure s\u2082", "start": [1441, 1], "end": [1450, 8], "kind": "commanddeclaration"}, {"full_name": "Dense.inter_of_open_left", "code": "theorem Dense.inter_of_open_left {s t : Set \u03b1} (hs : Dense s) (ht : Dense t) (hso : IsOpen s) :\n    Dense (s \u2229 t)", "start": [1453, 1], "end": [1456, 95], "kind": "commanddeclaration"}, {"full_name": "Dense.inter_of_open_right", "code": "theorem Dense.inter_of_open_right {s t : Set \u03b1} (hs : Dense s) (ht : Dense t) (hto : IsOpen t) :\n    Dense (s \u2229 t)", "start": [1459, 1], "end": [1462, 48], "kind": "commanddeclaration"}, {"full_name": "Dense.inter_nhds_nonempty", "code": "theorem Dense.inter_nhds_nonempty {s t : Set \u03b1} (hs : Dense s) {x : \u03b1} (ht : t \u2208 \ud835\udcdd x) :\n    (s \u2229 t).Nonempty", "start": [1465, 1], "end": [1468, 76], "kind": "commanddeclaration"}, {"full_name": "closure_diff", "code": "theorem closure_diff {s t : Set \u03b1} : closure s \\ closure t \u2286 closure (s \\ t)", "start": [1471, 1], "end": [1476, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.Frequently.mem_of_closed", "code": "theorem Filter.Frequently.mem_of_closed {a : \u03b1} {s : Set \u03b1} (h : \u2203\u1da0 x in \ud835\udcdd a, x \u2208 s)\n    (hs : IsClosed s) : a \u2208 s", "start": [1479, 1], "end": [1481, 34], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_of_frequently_of_tendsto", "code": "theorem IsClosed.mem_of_frequently_of_tendsto {f : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1} {s : Set \u03b1}\n    (hs : IsClosed s) (h : \u2203\u1da0 x in b, f x \u2208 s) (hf : Tendsto f b (\ud835\udcdd a)) : a \u2208 s", "start": [1484, 1], "end": [1486, 84], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_of_tendsto", "code": "theorem IsClosed.mem_of_tendsto {f : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1} {s : Set \u03b1} [NeBot b]\n    (hs : IsClosed s) (hf : Tendsto f b (\ud835\udcdd a)) (h : \u2200\u1da0 x in b, f x \u2208 s) : a \u2208 s", "start": [1489, 1], "end": [1491, 50], "kind": "commanddeclaration"}, {"full_name": "mem_closure_of_frequently_of_tendsto", "code": "theorem mem_closure_of_frequently_of_tendsto {f : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1} {s : Set \u03b1}\n    (h : \u2203\u1da0 x in b, f x \u2208 s) (hf : Tendsto f b (\ud835\udcdd a)) : a \u2208 closure s", "start": [1494, 1], "end": [1496, 32], "kind": "commanddeclaration"}, {"full_name": "mem_closure_of_tendsto", "code": "theorem mem_closure_of_tendsto {f : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1} {s : Set \u03b1} [NeBot b]\n    (hf : Tendsto f b (\ud835\udcdd a)) (h : \u2200\u1da0 x in b, f x \u2208 s) : a \u2208 closure s", "start": [1499, 1], "end": [1501, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_inf_principal_nhds_iff_of_forall_eq", "code": "theorem tendsto_inf_principal_nhds_iff_of_forall_eq {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {s : Set \u03b2} {a : \u03b1}\n    (h : \u2200 (x) (_ : x \u2209 s), f x = a) : Tendsto f (l \u2293 \ud835\udcdf s) (\ud835\udcdd a) \u2194 Tendsto f l (\ud835\udcdd a)", "start": [1504, 1], "end": [1517, 15], "kind": "commanddeclaration"}, {"full_name": "lim", "code": "noncomputable def lim [Nonempty \u03b1] (f : Filter \u03b1) : \u03b1 :=\n  Classical.epsilon fun a => f \u2264 \ud835\udcdd a", "start": [1535, 1], "end": [1537, 37], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.lim", "code": "noncomputable nonrec def Ultrafilter.lim (F : Ultrafilter \u03b1) : \u03b1 :=\n  @lim \u03b1 _ (nonempty_of_neBot F) F", "start": [1540, 1], "end": [1545, 35], "kind": "commanddeclaration"}, {"full_name": "limUnder", "code": "noncomputable def limUnder [Nonempty \u03b1] (f : Filter \u03b2) (g : \u03b2 \u2192 \u03b1) : \u03b1 :=\n  lim (f.map g)", "start": [1548, 1], "end": [1551, 16], "kind": "commanddeclaration"}, {"full_name": "le_nhds_lim", "code": "theorem le_nhds_lim {f : Filter \u03b1} (h : \u2203 a, f \u2264 \ud835\udcdd a) : f \u2264 \ud835\udcdd (@lim _ _ (nonempty_of_exists h) f)", "start": [1554, 1], "end": [1559, 27], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_limUnder", "code": "theorem tendsto_nhds_limUnder {f : Filter \u03b2} {g : \u03b2 \u2192 \u03b1} (h : \u2203 a, Tendsto g f (\ud835\udcdd a)) :\n    Tendsto g f (\ud835\udcdd (@limUnder _ _ _ (nonempty_of_exists h) f g))", "start": [1562, 1], "end": [1568, 16], "kind": "commanddeclaration"}, {"full_name": "Continuous", "code": "structure Continuous (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  isOpen_preimage : \u2200 s, IsOpen s \u2192 IsOpen (f \u207b\u00b9' s)", "start": [1589, 1], "end": [1594, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_def", "code": "theorem continuous_def {_ : TopologicalSpace \u03b1} {_ : TopologicalSpace \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    Continuous f \u2194 \u2200 s, IsOpen s \u2192 IsOpen (f \u207b\u00b9' s)", "start": [1602, 1], "end": [1604, 33], "kind": "commanddeclaration"}, {"full_name": "IsOpen.preimage", "code": "theorem IsOpen.preimage {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) {s : Set \u03b2} (h : IsOpen s) :\n    IsOpen (f \u207b\u00b9' s)", "start": [1607, 1], "end": [1609, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.congr", "code": "theorem Continuous.congr {f g : \u03b1 \u2192 \u03b2} (h : Continuous f) (h' : \u2200 x, f x = g x) : Continuous g", "start": [1612, 1], "end": [1615, 10], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt", "code": "def ContinuousAt (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :=\n  Tendsto f (\ud835\udcdd x) (\ud835\udcdd (f x))", "start": [1618, 1], "end": [1621, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.tendsto", "code": "theorem ContinuousAt.tendsto {f : \u03b1 \u2192 \u03b2} {x : \u03b1} (h : ContinuousAt f x) :\n    Tendsto f (\ud835\udcdd x) (\ud835\udcdd (f x))", "start": [1624, 1], "end": [1626, 4], "kind": "commanddeclaration"}, {"full_name": "continuousAt_def", "code": "theorem continuousAt_def {f : \u03b1 \u2192 \u03b2} {x : \u03b1} : ContinuousAt f x \u2194 \u2200 A \u2208 \ud835\udcdd (f x), f \u207b\u00b9' A \u2208 \ud835\udcdd x", "start": [1629, 1], "end": [1630, 10], "kind": "commanddeclaration"}, {"full_name": "continuousAt_congr", "code": "theorem continuousAt_congr {f g : \u03b1 \u2192 \u03b2} {x : \u03b1} (h : f =\u1da0[\ud835\udcdd x] g) :\n    ContinuousAt f x \u2194 ContinuousAt g x", "start": [1633, 1], "end": [1635, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.congr", "code": "theorem ContinuousAt.congr {f g : \u03b1 \u2192 \u03b2} {x : \u03b1} (hf : ContinuousAt f x) (h : f =\u1da0[\ud835\udcdd x] g) :\n    ContinuousAt g x", "start": [1638, 1], "end": [1640, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.preimage_mem_nhds", "code": "theorem ContinuousAt.preimage_mem_nhds {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {t : Set \u03b2} (h : ContinuousAt f x)\n    (ht : t \u2208 \ud835\udcdd (f x)) : f \u207b\u00b9' t \u2208 \ud835\udcdd x", "start": [1643, 1], "end": [1645, 7], "kind": "commanddeclaration"}, {"full_name": "eventuallyEq_zero_nhds", "code": "theorem eventuallyEq_zero_nhds {M\u2080} [Zero M\u2080] {a : \u03b1} {f : \u03b1 \u2192 M\u2080} :\n    f =\u1da0[\ud835\udcdd a] 0 \u2194 a \u2209 closure (Function.support f)", "start": [1648, 1], "end": [1650, 97], "kind": "commanddeclaration"}, {"full_name": "ClusterPt.map", "code": "theorem ClusterPt.map {x : \u03b1} {la : Filter \u03b1} {lb : Filter \u03b2} (H : ClusterPt x la) {f : \u03b1 \u2192 \u03b2}\n    (hfc : ContinuousAt f x) (hf : Tendsto f la lb) : ClusterPt (f x) lb", "start": [1653, 1], "end": [1655, 45], "kind": "commanddeclaration"}, {"full_name": "preimage_interior_subset_interior_preimage", "code": "theorem preimage_interior_subset_interior_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hf : Continuous f) :\n    f \u207b\u00b9' interior s \u2286 interior (f \u207b\u00b9' s)", "start": [1658, 1], "end": [1661, 81], "kind": "commanddeclaration"}, {"full_name": "continuous_id", "code": "@[continuity]\ntheorem continuous_id : Continuous (id : \u03b1 \u2192 \u03b1)", "start": [1664, 1], "end": [1666, 31], "kind": "commanddeclaration"}, {"full_name": "continuous_id'", "code": "@[continuity]\ntheorem continuous_id' : Continuous (fun (x : \u03b1) => x)", "start": [1670, 1], "end": [1671, 72], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp", "code": "theorem Continuous.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Continuous g) (hf : Continuous f) :\n    Continuous (g \u2218 f)", "start": [1673, 1], "end": [1675, 58], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp'", "code": "@[continuity]\ntheorem Continuous.comp' {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Continuous g) (hf : Continuous f) :\n    Continuous (fun x => g (f x))", "start": [1679, 1], "end": [1681, 48], "kind": "commanddeclaration"}, {"full_name": "Continuous.iterate", "code": "theorem Continuous.iterate {f : \u03b1 \u2192 \u03b1} (h : Continuous f) (n : \u2115) : Continuous f^[n]", "start": [1683, 1], "end": [1684, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp", "code": "nonrec theorem ContinuousAt.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {x : \u03b1} (hg : ContinuousAt g (f x))\n    (hf : ContinuousAt f x) : ContinuousAt (g \u2218 f) x", "start": [1687, 1], "end": [1689, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_of_eq", "code": "theorem ContinuousAt.comp_of_eq {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {y : \u03b2} (hg : ContinuousAt g y)\n    (hf : ContinuousAt f x) (hy : f x = y) : ContinuousAt (g \u2218 f) x", "start": [1692, 1], "end": [1694, 101], "kind": "commanddeclaration"}, {"full_name": "Continuous.tendsto", "code": "theorem Continuous.tendsto {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (x) : Tendsto f (\ud835\udcdd x) (\ud835\udcdd (f x))", "start": [1697, 1], "end": [1699, 49], "kind": "commanddeclaration"}, {"full_name": "Continuous.tendsto'", "code": "theorem Continuous.tendsto' {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (x : \u03b1) (y : \u03b2) (h : f x = y) :\n    Tendsto f (\ud835\udcdd x) (\ud835\udcdd y)", "start": [1702, 1], "end": [1706, 19], "kind": "commanddeclaration"}, {"full_name": "Continuous.continuousAt", "code": "theorem Continuous.continuousAt {f : \u03b1 \u2192 \u03b2} {x : \u03b1} (h : Continuous f) : ContinuousAt f x", "start": [1709, 1], "end": [1710, 14], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_continuousAt", "code": "theorem continuous_iff_continuousAt {f : \u03b1 \u2192 \u03b2} : Continuous f \u2194 \u2200 x, ContinuousAt f x", "start": [1713, 1], "end": [1715, 28], "kind": "commanddeclaration"}, {"full_name": "continuousAt_const", "code": "theorem continuousAt_const {x : \u03b1} {b : \u03b2} : ContinuousAt (fun _ : \u03b1 => b) x", "start": [1718, 1], "end": [1719, 21], "kind": "commanddeclaration"}, {"full_name": "continuous_const", "code": "@[continuity]\ntheorem continuous_const {b : \u03b2} : Continuous fun _ : \u03b1 => b", "start": [1722, 1], "end": [1724, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.continuousAt", "code": "theorem Filter.EventuallyEq.continuousAt {x : \u03b1} {f : \u03b1 \u2192 \u03b2} {y : \u03b2} (h : f =\u1da0[\ud835\udcdd x] fun _ => y) :\n    ContinuousAt f x", "start": [1727, 1], "end": [1729, 46], "kind": "commanddeclaration"}, {"full_name": "continuous_of_const", "code": "theorem continuous_of_const {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, f x = f y) : Continuous f", "start": [1732, 1], "end": [1734, 76], "kind": "commanddeclaration"}, {"full_name": "continuousAt_id", "code": "theorem continuousAt_id {x : \u03b1} : ContinuousAt id x", "start": [1737, 1], "end": [1738, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.iterate", "code": "theorem ContinuousAt.iterate {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (hf : ContinuousAt f x) (hx : f x = x) (n : \u2115) :\n    ContinuousAt f^[n] x", "start": [1741, 1], "end": [1744, 78], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_isClosed", "code": "theorem continuous_iff_isClosed {f : \u03b1 \u2192 \u03b2} : Continuous f \u2194 \u2200 s, IsClosed s \u2192 IsClosed (f \u207b\u00b9' s)", "start": [1747, 1], "end": [1749, 49], "kind": "commanddeclaration"}, {"full_name": "IsClosed.preimage", "code": "theorem IsClosed.preimage {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) {s : Set \u03b2} (h : IsClosed s) :\n    IsClosed (f \u207b\u00b9' s)", "start": [1752, 1], "end": [1754, 36], "kind": "commanddeclaration"}, {"full_name": "mem_closure_image", "code": "theorem mem_closure_image {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1} (hf : ContinuousAt f x)\n    (hx : x \u2208 closure s) : f x \u2208 closure (f '' s)", "start": [1757, 1], "end": [1760, 76], "kind": "commanddeclaration"}, {"full_name": "continuousAt_iff_ultrafilter", "code": "theorem continuousAt_iff_ultrafilter {f : \u03b1 \u2192 \u03b2} {x} :\n    ContinuousAt f x \u2194 \u2200 g : Ultrafilter \u03b1, \u2191g \u2264 \ud835\udcdd x \u2192 Tendsto f g (\ud835\udcdd (f x))", "start": [1763, 1], "end": [1765, 44], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_ultrafilter", "code": "theorem continuous_iff_ultrafilter {f : \u03b1 \u2192 \u03b2} :\n    Continuous f \u2194 \u2200 (x) (g : Ultrafilter \u03b1), \u2191g \u2264 \ud835\udcdd x \u2192 Tendsto f g (\ud835\udcdd (f x))", "start": [1768, 1], "end": [1770, 72], "kind": "commanddeclaration"}, {"full_name": "Continuous.closure_preimage_subset", "code": "theorem Continuous.closure_preimage_subset {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (t : Set \u03b2) :\n    closure (f \u207b\u00b9' t) \u2286 f \u207b\u00b9' closure t", "start": [1773, 1], "end": [1776, 52], "kind": "commanddeclaration"}, {"full_name": "Continuous.frontier_preimage_subset", "code": "theorem Continuous.frontier_preimage_subset {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (t : Set \u03b2) :\n    frontier (f \u207b\u00b9' t) \u2286 f \u207b\u00b9' frontier t", "start": [1779, 1], "end": [1781, 98], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.closure", "code": "protected theorem Set.MapsTo.closure {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (h : MapsTo f s t)\n    (hc : Continuous f) : MapsTo f (closure s) (closure t)", "start": [1784, 1], "end": [1788, 77], "kind": "commanddeclaration"}, {"full_name": "image_closure_subset_closure_image", "code": "theorem image_closure_subset_closure_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : Continuous f) :\n    f '' closure s \u2286 closure (f '' s)", "start": [1791, 1], "end": [1794, 46], "kind": "commanddeclaration"}, {"full_name": "closure_image_closure", "code": "theorem closure_image_closure {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : Continuous f) :\n    closure (f '' closure s) = closure (f '' s)", "start": [1798, 1], "end": [1802, 52], "kind": "commanddeclaration"}, {"full_name": "closure_subset_preimage_closure_image", "code": "theorem closure_subset_preimage_closure_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : Continuous f) :\n    closure s \u2286 f \u207b\u00b9' closure (f '' s)", "start": [1804, 1], "end": [1807, 45], "kind": "commanddeclaration"}, {"full_name": "map_mem_closure", "code": "theorem map_mem_closure {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (hf : Continuous f)\n    (ha : a \u2208 closure s) (ht : MapsTo f s t) : f a \u2208 closure t", "start": [1810, 1], "end": [1812, 19], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.closure_left", "code": "theorem Set.MapsTo.closure_left {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} (h : MapsTo f s t)\n    (hc : Continuous f) (ht : IsClosed t) : MapsTo f (closure s) t", "start": [1815, 1], "end": [1818, 31], "kind": "commanddeclaration"}, {"full_name": "DenseRange", "code": "def DenseRange := Dense (range f)", "start": [1829, 1], "end": [1830, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.denseRange", "code": "theorem Function.Surjective.denseRange (hf : Function.Surjective f) : DenseRange f", "start": [1835, 1], "end": [1837, 21], "kind": "commanddeclaration"}, {"full_name": "denseRange_id", "code": "theorem denseRange_id : DenseRange (id : \u03b1 \u2192 \u03b1)", "start": [1840, 1], "end": [1841, 56], "kind": "commanddeclaration"}, {"full_name": "denseRange_iff_closure_range", "code": "theorem denseRange_iff_closure_range : DenseRange f \u2194 closure (range f) = univ", "start": [1844, 1], "end": [1845, 23], "kind": "commanddeclaration"}, {"full_name": "DenseRange.closure_range", "code": "theorem DenseRange.closure_range (h : DenseRange f) : closure (range f) = univ", "start": [1848, 1], "end": [1849, 15], "kind": "commanddeclaration"}, {"full_name": "Dense.denseRange_val", "code": "theorem Dense.denseRange_val {s : Set \u03b1} (h : Dense s) : DenseRange ((\u2191) : s \u2192 \u03b1)", "start": [1852, 1], "end": [1853, 53], "kind": "commanddeclaration"}, {"full_name": "Continuous.range_subset_closure_image_dense", "code": "theorem Continuous.range_subset_closure_image_dense {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) {s : Set \u03b1}\n    (hs : Dense s) : range f \u2286 closure (f '' s)", "start": [1856, 1], "end": [1859, 46], "kind": "commanddeclaration"}, {"full_name": "DenseRange.dense_image", "code": "theorem DenseRange.dense_image {f : \u03b1 \u2192 \u03b2} (hf' : DenseRange f) (hf : Continuous f) {s : Set \u03b1}\n    (hs : Dense s) : Dense (f '' s)", "start": [1862, 1], "end": [1865, 66], "kind": "commanddeclaration"}, {"full_name": "DenseRange.subset_closure_image_preimage_of_isOpen", "code": "theorem DenseRange.subset_closure_image_preimage_of_isOpen (hf : DenseRange f) {s : Set \u03b2}\n    (hs : IsOpen s) : s \u2286 closure (f '' (f \u207b\u00b9' s))", "start": [1868, 1], "end": [1873, 40], "kind": "commanddeclaration"}, {"full_name": "DenseRange.dense_of_mapsTo", "code": "theorem DenseRange.dense_of_mapsTo {f : \u03b1 \u2192 \u03b2} (hf' : DenseRange f) (hf : Continuous f) {s : Set \u03b1}\n    (hs : Dense s) {t : Set \u03b2} (ht : MapsTo f s t) : Dense t", "start": [1876, 1], "end": [1880, 47], "kind": "commanddeclaration"}, {"full_name": "DenseRange.comp", "code": "theorem DenseRange.comp {g : \u03b2 \u2192 \u03b3} {f : \u03ba \u2192 \u03b2} (hg : DenseRange g) (hf : DenseRange f)\n    (cg : Continuous g) : DenseRange (g \u2218 f)", "start": [1883, 1], "end": [1888, 29], "kind": "commanddeclaration"}, {"full_name": "DenseRange.nonempty_iff", "code": "nonrec theorem DenseRange.nonempty_iff (hf : DenseRange f) : Nonempty \u03ba \u2194 Nonempty \u03b2", "start": [1891, 1], "end": [1892, 57], "kind": "commanddeclaration"}, {"full_name": "DenseRange.nonempty", "code": "theorem DenseRange.nonempty [h : Nonempty \u03b2] (hf : DenseRange f) : Nonempty \u03ba", "start": [1895, 1], "end": [1896, 24], "kind": "commanddeclaration"}, {"full_name": "DenseRange.some", "code": "def DenseRange.some (hf : DenseRange f) (b : \u03b2) : \u03ba :=\n  Classical.choice <| hf.nonempty_iff.mpr \u27e8b\u27e9", "start": [1899, 1], "end": [1901, 46], "kind": "commanddeclaration"}, {"full_name": "DenseRange.exists_mem_open", "code": "nonrec theorem DenseRange.exists_mem_open (hf : DenseRange f) {s : Set \u03b2} (ho : IsOpen s)\n    (hs : s.Nonempty) : \u2203 a, f a \u2208 s", "start": [1904, 1], "end": [1906, 49], "kind": "commanddeclaration"}, {"full_name": "DenseRange.mem_nhds", "code": "theorem DenseRange.mem_nhds {f : \u03ba \u2192 \u03b2} (h : DenseRange f) {b : \u03b2} {U : Set \u03b2} (U_in : U \u2208 \ud835\udcdd b) :\n    \u2203 a, f a \u2208 U", "start": [1909, 1], "end": [1912, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Prod/Lex.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.Lex.decidableEq", "code": "instance decidableEq (\u03b1 \u03b2 : Type*) [DecidableEq \u03b1] [DecidableEq \u03b2] : DecidableEq (\u03b1 \u00d7\u2097 \u03b2) :=\n  instDecidableEqProd", "start": [42, 1], "end": [43, 22], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.inhabited", "code": "instance inhabited (\u03b1 \u03b2 : Type*) [Inhabited \u03b1] [Inhabited \u03b2] : Inhabited (\u03b1 \u00d7\u2097 \u03b2) :=\n  instInhabitedProd", "start": [46, 1], "end": [47, 20], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.instLE", "code": "instance instLE (\u03b1 \u03b2 : Type*) [LT \u03b1] [LE \u03b2] : LE (\u03b1 \u00d7\u2097 \u03b2) where le := Prod.Lex (\u00b7 < \u00b7) (\u00b7 \u2264 \u00b7)", "start": [50, 1], "end": [51, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.instLT", "code": "instance instLT (\u03b1 \u03b2 : Type*) [LT \u03b1] [LT \u03b2] : LT (\u03b1 \u00d7\u2097 \u03b2) where lt := Prod.Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7)", "start": [54, 1], "end": [54, 95], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.le_iff", "code": "theorem le_iff [LT \u03b1] [LE \u03b2] (a b : \u03b1 \u00d7 \u03b2) :\n    toLex a \u2264 toLex b \u2194 a.1 < b.1 \u2228 a.1 = b.1 \u2227 a.2 \u2264 b.2", "start": [57, 1], "end": [59, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.lt_iff", "code": "theorem lt_iff [LT \u03b1] [LT \u03b2] (a b : \u03b1 \u00d7 \u03b2) :\n    toLex a < toLex b \u2194 a.1 < b.1 \u2228 a.1 = b.1 \u2227 a.2 < b.2", "start": [62, 1], "end": [64, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.preorder", "code": "instance preorder (\u03b1 \u03b2 : Type*) [Preorder \u03b1] [Preorder \u03b2] : Preorder (\u03b1 \u00d7\u2097 \u03b2) :=\n  { Prod.Lex.instLE \u03b1 \u03b2, Prod.Lex.instLT \u03b1 \u03b2 with\n    le_refl := refl_of <| Prod.Lex _ _,\n    le_trans := fun _ _ _ => trans_of <| Prod.Lex _ _,\n    lt_iff_le_not_le := fun x\u2081 x\u2082 =>\n      match x\u2081, x\u2082 with\n      | (a\u2081, b\u2081), (a\u2082, b\u2082) => by\n        constructor\n        \u00b7 rintro (\u27e8_, _, hlt\u27e9 | \u27e8_, hlt\u27e9)\n          \u00b7 constructor\n            \u00b7 exact left _ _ hlt\n            \u00b7 rintro \u27e8\u27e9\n              \u00b7 apply lt_asymm hlt; assumption\n              \u00b7 exact lt_irrefl _ hlt\n          \u00b7 constructor\n            \u00b7 right\n              rw [lt_iff_le_not_le] at hlt\n              exact hlt.1\n            \u00b7 rintro \u27e8\u27e9\n              \u00b7 apply lt_irrefl a\u2081\n                assumption\n              \u00b7 rw [lt_iff_le_not_le] at hlt\n                apply hlt.2\n                assumption\n        \u00b7 rintro \u27e8\u27e8\u27e9, h\u2082r\u27e9\n          \u00b7 left\n            assumption\n          \u00b7 right\n            rw [lt_iff_le_not_le]\n            constructor\n            \u00b7 assumption\n            \u00b7 intro h\n              apply h\u2082r\n              right\n              exact h }", "start": [69, 1], "end": [104, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.toLex_mono", "code": "theorem toLex_mono : @Monotone _ _ _ (Prod.Lex.preorder \u03b1 \u03b2) (toLex : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7\u2097 \u03b2)", "start": [115, 1], "end": [119, 22], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.toLex_strictMono", "code": "theorem toLex_strictMono : @StrictMono _ _ _ (Prod.Lex.preorder \u03b1 \u03b2) (toLex : \u03b1 \u00d7 \u03b2 \u2192 \u03b1 \u00d7\u2097 \u03b2)", "start": [126, 1], "end": [130, 22], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.partialOrder", "code": "instance partialOrder (\u03b1 \u03b2 : Type*) [PartialOrder \u03b1] [PartialOrder \u03b2] : PartialOrder (\u03b1 \u00d7\u2097 \u03b2) :=\n  { Prod.Lex.preorder \u03b1 \u03b2 with\n    le_antisymm := by\n      haveI : IsStrictOrder \u03b1 (\u00b7 < \u00b7) := { irrefl := lt_irrefl, trans := fun _ _ _ => lt_trans }\n      haveI : IsAntisymm \u03b2 (\u00b7 \u2264 \u00b7) := \u27e8fun _ _ => le_antisymm\u27e9\n      exact @antisymm _ (Prod.Lex _ _) _ }", "start": [135, 1], "end": [141, 43], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.linearOrder", "code": "instance linearOrder (\u03b1 \u03b2 : Type*) [LinearOrder \u03b1] [LinearOrder \u03b2] : LinearOrder (\u03b1 \u00d7\u2097 \u03b2) :=\n  { Prod.Lex.partialOrder \u03b1 \u03b2 with\n    le_total := total_of (Prod.Lex _ _),\n    decidableLE := Prod.Lex.decidable _ _,\n    decidableLT := Prod.Lex.decidable _ _,\n    decidableEq := Lex.decidableEq _ _, }", "start": [144, 1], "end": [150, 42], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.orderBot", "code": "instance orderBot [PartialOrder \u03b1] [Preorder \u03b2] [OrderBot \u03b1] [OrderBot \u03b2] : OrderBot (\u03b1 \u00d7\u2097 \u03b2) where\n  bot := toLex \u22a5\n  bot_le _ := toLex_mono bot_le", "start": [156, 1], "end": [158, 32], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.orderTop", "code": "instance orderTop [PartialOrder \u03b1] [Preorder \u03b2] [OrderTop \u03b1] [OrderTop \u03b2] : OrderTop (\u03b1 \u00d7\u2097 \u03b2) where\n  top := toLex \u22a4\n  le_top _ := toLex_mono le_top", "start": [161, 1], "end": [163, 32], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.boundedOrder", "code": "instance boundedOrder [PartialOrder \u03b1] [Preorder \u03b2] [BoundedOrder \u03b1] [BoundedOrder \u03b2] :\n    BoundedOrder (\u03b1 \u00d7\u2097 \u03b2) :=\n  { Lex.orderBot, Lex.orderTop with }", "start": [166, 1], "end": [168, 38], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.noMaxOrder_of_left", "code": "instance noMaxOrder_of_left [Preorder \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b1] : NoMaxOrder (\u03b1 \u00d7\u2097 \u03b2) where\n  exists_gt := by\n    rintro \u27e8a, b\u27e9\n    obtain \u27e8c, h\u27e9 := exists_gt a\n    exact \u27e8\u27e8c, b\u27e9, left _ _ h\u27e9", "start": [180, 1], "end": [184, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.noMinOrder_of_left", "code": "instance noMinOrder_of_left [Preorder \u03b1] [Preorder \u03b2] [NoMinOrder \u03b1] : NoMinOrder (\u03b1 \u00d7\u2097 \u03b2) where\n  exists_lt := by\n    rintro \u27e8a, b\u27e9\n    obtain \u27e8c, h\u27e9 := exists_lt a\n    exact \u27e8\u27e8c, b\u27e9, left _ _ h\u27e9", "start": [187, 1], "end": [191, 31], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.noMaxOrder_of_right", "code": "instance noMaxOrder_of_right [Preorder \u03b1] [Preorder \u03b2] [NoMaxOrder \u03b2] : NoMaxOrder (\u03b1 \u00d7\u2097 \u03b2) where\n  exists_gt := by\n    rintro \u27e8a, b\u27e9\n    obtain \u27e8c, h\u27e9 := exists_gt b\n    exact \u27e8\u27e8a, c\u27e9, right _ h\u27e9", "start": [194, 1], "end": [198, 30], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.noMinOrder_of_right", "code": "instance noMinOrder_of_right [Preorder \u03b1] [Preorder \u03b2] [NoMinOrder \u03b2] : NoMinOrder (\u03b1 \u00d7\u2097 \u03b2) where\n  exists_lt := by\n    rintro \u27e8a, b\u27e9\n    obtain \u27e8c, h\u27e9 := exists_lt b\n    exact \u27e8\u27e8a, c\u27e9, right _ h\u27e9", "start": [201, 1], "end": [205, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fin/Interval.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Data/Nat/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup : \u2191(a \u2294 b) = (a \u2294 b : \u2115)", "start": [22, 1], "end": [23, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf : \u2191(a \u2293 b) = (a \u2293 b : \u2115)", "start": [26, 1], "end": [27, 48], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max : \u2191(max a b) = (max a b : \u2115)", "start": [30, 1], "end": [31, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min : \u2191(min a b) = (min a b : \u2115)", "start": [34, 1], "end": [35, 52], "kind": "commanddeclaration"}, {"full_name": "Fin.Icc_eq_finset_subtype", "code": "theorem Icc_eq_finset_subtype : Icc a b = (Icc (a : \u2115) b).fin n", "start": [60, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.Ico_eq_finset_subtype", "code": "theorem Ico_eq_finset_subtype : Ico a b = (Ico (a : \u2115) b).fin n", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.Ioc_eq_finset_subtype", "code": "theorem Ioc_eq_finset_subtype : Ioc a b = (Ioc (a : \u2115) b).fin n", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.Ioo_eq_finset_subtype", "code": "theorem Ioo_eq_finset_subtype : Ioo a b = (Ioo (a : \u2115) b).fin n", "start": [72, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.uIcc_eq_finset_subtype", "code": "theorem uIcc_eq_finset_subtype : uIcc a b = (uIcc (a : \u2115) b).fin n", "start": [76, 1], "end": [76, 74], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Icc", "code": "@[simp]\ntheorem map_valEmbedding_Icc : (Icc a b).map Fin.valEmbedding = Icc \u2191a \u2191b", "start": [79, 1], "end": [81, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Ico", "code": "@[simp]\ntheorem map_valEmbedding_Ico : (Ico a b).map Fin.valEmbedding = Ico \u2191a \u2191b", "start": [84, 1], "end": [86, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Ioc", "code": "@[simp]\ntheorem map_valEmbedding_Ioc : (Ioc a b).map Fin.valEmbedding = Ioc \u2191a \u2191b", "start": [89, 1], "end": [91, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Ioo", "code": "@[simp]\ntheorem map_valEmbedding_Ioo : (Ioo a b).map Fin.valEmbedding = Ioo \u2191a \u2191b", "start": [94, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.map_subtype_embedding_uIcc", "code": "@[simp]\ntheorem map_subtype_embedding_uIcc : (uIcc a b).map valEmbedding = uIcc \u2191a \u2191b", "start": [99, 1], "end": [101, 27], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Icc", "code": "@[simp]\ntheorem card_Icc : (Icc a b).card = b + 1 - a", "start": [104, 1], "end": [106, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Ico", "code": "@[simp]\ntheorem card_Ico : (Ico a b).card = b - a", "start": [109, 1], "end": [111, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Ioc", "code": "@[simp]\ntheorem card_Ioc : (Ioc a b).card = b - a", "start": [114, 1], "end": [116, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Ioo", "code": "@[simp]\ntheorem card_Ioo : (Ioo a b).card = b - a - 1", "start": [119, 1], "end": [121, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.card_uIcc", "code": "@[simp]\ntheorem card_uIcc : (uIcc a b).card = (b - a : \u2124).natAbs + 1", "start": [124, 1], "end": [126, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIcc", "code": "theorem card_fintypeIcc : Fintype.card (Set.Icc a b) = b + 1 - a", "start": [131, 1], "end": [132, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIco", "code": "theorem card_fintypeIco : Fintype.card (Set.Ico a b) = b - a", "start": [137, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIoc", "code": "theorem card_fintypeIoc : Fintype.card (Set.Ioc a b) = b - a", "start": [143, 1], "end": [144, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIoo", "code": "theorem card_fintypeIoo : Fintype.card (Set.Ioo a b) = b - a - 1", "start": [149, 1], "end": [150, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintype_uIcc", "code": "theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a : \u2124).natAbs + 1", "start": [153, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.Ici_eq_finset_subtype", "code": "theorem Ici_eq_finset_subtype : Ici a = (Icc (a : \u2115) n).fin n", "start": [157, 1], "end": [159, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.Ioi_eq_finset_subtype", "code": "theorem Ioi_eq_finset_subtype : Ioi a = (Ioc (a : \u2115) n).fin n", "start": [162, 1], "end": [164, 7], "kind": "commanddeclaration"}, {"full_name": "Fin.Iic_eq_finset_subtype", "code": "theorem Iic_eq_finset_subtype : Iic b = (Iic (b : \u2115)).fin n", "start": [167, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.Iio_eq_finset_subtype", "code": "theorem Iio_eq_finset_subtype : Iio b = (Iio (b : \u2115)).fin n", "start": [171, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Ici", "code": "@[simp]\ntheorem map_valEmbedding_Ici : (Ici a).map Fin.valEmbedding = Icc \u2191a (n - 1)", "start": [175, 1], "end": [187, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Ioi", "code": "@[simp]\ntheorem map_valEmbedding_Ioi : (Ioi a).map Fin.valEmbedding = Ioc \u2191a (n - 1)", "start": [190, 1], "end": [202, 61], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Iic", "code": "@[simp]\ntheorem map_valEmbedding_Iic : (Iic b).map Fin.valEmbedding = Iic \u2191b", "start": [205, 1], "end": [207, 86], "kind": "commanddeclaration"}, {"full_name": "Fin.map_valEmbedding_Iio", "code": "@[simp]\ntheorem map_valEmbedding_Iio : (Iio b).map Fin.valEmbedding = Iio \u2191b", "start": [210, 1], "end": [212, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Ici", "code": "@[simp]\ntheorem card_Ici : (Ici a).card = n - a", "start": [215, 1], "end": [222, 74], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Ioi", "code": "@[simp]\ntheorem card_Ioi : (Ioi a).card = n - 1 - a", "start": [225, 1], "end": [227, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Iic", "code": "@[simp]\ntheorem card_Iic : (Iic b).card = b + 1", "start": [230, 1], "end": [232, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.card_Iio", "code": "@[simp]\ntheorem card_Iio : (Iio b).card = b", "start": [235, 1], "end": [237, 58], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIci", "code": "theorem card_fintypeIci : Fintype.card (Set.Ici a) = n - a", "start": [242, 1], "end": [243, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIoi", "code": "theorem card_fintypeIoi : Fintype.card (Set.Ioi a) = n - 1 - a", "start": [248, 1], "end": [249, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIic", "code": "theorem card_fintypeIic : Fintype.card (Set.Iic b) = b + 1", "start": [254, 1], "end": [255, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.card_fintypeIio", "code": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b", "start": [260, 1], "end": [261, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Option.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Finset/Option.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.prod_insertNone", "code": "@[to_additive (attr := simp)]\ntheorem prod_insertNone (f : Option \u03b1 \u2192 M) (s : Finset \u03b1) :\n    \u220f x in insertNone s, f x = f none * \u220f x in s, f (some x)", "start": [26, 1], "end": [28, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_prod_eq_prod_insertNone", "code": "@[to_additive]\ntheorem mul_prod_eq_prod_insertNone (f : \u03b1 \u2192 M) (x : M) (s : Finset \u03b1) :\n    x * \u220f i in s, f i = \u220f i in insertNone s, i.elim x f", "start": [32, 1], "end": [35, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eraseNone", "code": "@[to_additive]\ntheorem prod_eraseNone (f : \u03b1 \u2192 M) (s : Finset (Option \u03b1)) :\n    \u220f x in eraseNone s, f x = \u220f x in s, Option.elim' 1 f x", "start": [37, 1], "end": [44, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Option.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Data/Finset/Option.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "univ_option", "code": "theorem univ_option (\u03b1 : Type*) [Fintype \u03b1] : (univ : Finset (Option \u03b1)) = insertNone univ", "start": [29, 1], "end": [30, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_option", "code": "@[simp]\ntheorem Fintype.card_option {\u03b1 : Type*} [Fintype \u03b1] :\n    Fintype.card (Option \u03b1) = Fintype.card \u03b1 + 1", "start": [33, 1], "end": [36, 70], "kind": "commanddeclaration"}, {"full_name": "fintypeOfOption", "code": "def fintypeOfOption {\u03b1 : Type*} [Fintype (Option \u03b1)] : Fintype \u03b1 :=\n  \u27e8Finset.eraseNone (Fintype.elems (\u03b1 := Option \u03b1)), fun x =>\n    mem_eraseNone.mpr (Fintype.complete (some x))\u27e9", "start": [39, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "fintypeOfOptionEquiv", "code": "def fintypeOfOptionEquiv [Fintype \u03b1] (f : \u03b1 \u2243 Option \u03b2) : Fintype \u03b2 :=\n  haveI := Fintype.ofEquiv _ f\n  fintypeOfOption", "start": [45, 1], "end": [48, 18], "kind": "commanddeclaration"}, {"full_name": "Fintype.truncRecEmptyOption", "code": "def truncRecEmptyOption {P : Type u \u2192 Sort v} (of_equiv : \u2200 {\u03b1 \u03b2}, \u03b1 \u2243 \u03b2 \u2192 P \u03b1 \u2192 P \u03b2)\n    (h_empty : P PEmpty) (h_option : \u2200 {\u03b1} [Fintype \u03b1] [DecidableEq \u03b1], P \u03b1 \u2192 P (Option \u03b1))\n    (\u03b1 : Type u) [Fintype \u03b1] [DecidableEq \u03b1] : Trunc (P \u03b1) := by\n  suffices \u2200 n : \u2115, Trunc (P (ULift <| Fin n)) by\n    apply Trunc.bind (this (Fintype.card \u03b1))\n    intro h\n    apply Trunc.map _ (Fintype.truncEquivFin \u03b1)\n    intro e\n    exact of_equiv (Equiv.ulift.trans e.symm) h\n  apply ind where\n    \n    ind : \u2200 n : \u2115, Trunc (P (ULift <| Fin n))\n    | Nat.zero => by\n          have : card PEmpty = card (ULift (Fin 0)) := by simp only [card_fin, card_pempty,\n                                                                     card_ulift]\n          apply Trunc.bind (truncEquivOfCardEq this)\n          intro e\n          apply Trunc.mk\n          refine' of_equiv e h_empty\n      | Nat.succ n => by\n          have : card (Option (ULift (Fin n))) = card (ULift (Fin n.succ)) := by\n            simp only [card_fin, card_option, card_ulift]\n          apply Trunc.bind (truncEquivOfCardEq this)\n          intro e\n          apply Trunc.map _ (ind n)\n          intro ih\n          refine' of_equiv e (h_option ih)", "start": [53, 1], "end": [83, 43], "kind": "commanddeclaration"}, {"full_name": "Fintype.induction_empty_option", "code": "@[elab_as_elim]\ntheorem induction_empty_option {P : \u2200 (\u03b1 : Type u) [Fintype \u03b1], Prop}\n    (of_equiv : \u2200 (\u03b1 \u03b2) [Fintype \u03b2] (e : \u03b1 \u2243 \u03b2), @P \u03b1 (@Fintype.ofEquiv \u03b1 \u03b2 \u2039_\u203a e.symm) \u2192 @P \u03b2 \u2039_\u203a)\n    (h_empty : P PEmpty) (h_option : \u2200 (\u03b1) [Fintype \u03b1], P \u03b1 \u2192 P (Option \u03b1)) (\u03b1 : Type u)\n    [h_fintype : Fintype \u03b1] : P \u03b1", "start": [89, 1], "end": [104, 14], "kind": "commanddeclaration"}, {"full_name": "Finite.induction_empty_option", "code": "theorem Finite.induction_empty_option {P : Type u \u2192 Prop} (of_equiv : \u2200 {\u03b1 \u03b2}, \u03b1 \u2243 \u03b2 \u2192 P \u03b1 \u2192 P \u03b2)\n    (h_empty : P PEmpty) (h_option : \u2200 {\u03b1} [Fintype \u03b1], P \u03b1 \u2192 P (Option \u03b1)) (\u03b1 : Type u)\n    [Finite \u03b1] : P \u03b1", "start": [110, 1], "end": [117, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Ring.lean", "imports": ["Mathlib/Data/Finset/Pi.lean", "Mathlib/Data/Finset/Powerset.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Field/Defs.lean"], "premises": [{"full_name": "Finset.prod_pow_eq_pow_sum", "code": "theorem prod_pow_eq_pow_sum {x : \u03b2} {f : \u03b1 \u2192 \u2115} :\n    \u2200 {s : Finset \u03b1}, \u220f i in s, x ^ f i = x ^ \u2211 x in s, f x", "start": [37, 1], "end": [42, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_mul", "code": "theorem sum_mul : (\u2211 x in s, f x) * b = \u2211 x in s, f x * b", "start": [51, 1], "end": [52, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_sum", "code": "theorem mul_sum : (b * \u2211 x in s, f x) = \u2211 x in s, b * f x", "start": [55, 1], "end": [56, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_mul_sum", "code": "theorem sum_mul_sum {\u03b9\u2081 : Type*} {\u03b9\u2082 : Type*} (s\u2081 : Finset \u03b9\u2081) (s\u2082 : Finset \u03b9\u2082) (f\u2081 : \u03b9\u2081 \u2192 \u03b2)\n    (f\u2082 : \u03b9\u2082 \u2192 \u03b2) :\n    ((\u2211 x\u2081 in s\u2081, f\u2081 x\u2081) * \u2211 x\u2082 in s\u2082, f\u2082 x\u2082) = \u2211 p in s\u2081 \u00d7\u02e2 s\u2082, f\u2081 p.1 * f\u2082 p.2", "start": [59, 1], "end": [64, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.dvd_sum", "code": "theorem dvd_sum [NonUnitalSemiring \u03b2]\n    {b : \u03b2} {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} (h : \u2200 x \u2208 s, b \u2223 f x) : b \u2223 \u2211 x in s, f x", "start": [71, 1], "end": [73, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_mul_boole", "code": "theorem sum_mul_boole [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (\u2211 x in s, f x * ite (a = x) 1 0) = ite (a \u2208 s) (f a) 0", "start": [78, 1], "end": [79, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_boole_mul", "code": "theorem sum_boole_mul [DecidableEq \u03b1] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) :\n    (\u2211 x in s, ite (a = x) 1 0 * f x) = ite (a \u2208 s) (f a) 0", "start": [82, 1], "end": [83, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_div", "code": "theorem sum_div [DivisionSemiring \u03b2] {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} :\n    (\u2211 x in s, f x) / b = \u2211 x in s, f x / b", "start": [88, 1], "end": [89, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sum", "code": "theorem prod_sum {\u03b4 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [\u2200 a, DecidableEq (\u03b4 a)] {s : Finset \u03b1}\n    {t : \u2200 a, Finset (\u03b4 a)} {f : \u2200 a, \u03b4 a \u2192 \u03b2} :\n    (\u220f a in s, \u2211 b in t a, f a b) = \u2211 p in s.pi t, \u220f x in s.attach, f x.1 (p x.1 x.2)", "start": [96, 1], "end": [126, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_add", "code": "theorem prod_add [DecidableEq \u03b1] (f g : \u03b1 \u2192 \u03b2) (s : Finset \u03b1) :\n    \u220f a in s, (f a + g a) = \u2211 t in s.powerset, (\u220f a in t, f a) * \u220f a in s \\ t, g a", "start": [129, 1], "end": [160, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_add_ordered", "code": "theorem prod_add_ordered {\u03b9 R : Type*} [CommSemiring R] [LinearOrder \u03b9] (s : Finset \u03b9)\n    (f g : \u03b9 \u2192 R) :\n    \u220f i in s, (f i + g i) =\n      (\u220f i in s, f i) +\n        \u2211 i in s,\n          g i * (\u220f j in s.filter (\u00b7 < i), (f j + g j)) * \u220f j in s.filter fun j => i < j, f j", "start": [163, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_sub_ordered", "code": "theorem prod_sub_ordered {\u03b9 R : Type*} [CommRing R] [LinearOrder \u03b9] (s : Finset \u03b9) (f g : \u03b9 \u2192 R) :\n    \u220f i in s, (f i - g i) =\n      (\u220f i in s, f i) -\n        \u2211 i in s,\n          g i * (\u220f j in s.filter (\u00b7 < i), (f j - g j)) * \u220f j in s.filter fun j => i < j, f j", "start": [188, 1], "end": [196, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_one_sub_ordered", "code": "theorem prod_one_sub_ordered {\u03b9 R : Type*} [CommRing R] [LinearOrder \u03b9] (s : Finset \u03b9)\n    (f : \u03b9 \u2192 R) : \u220f i in s, (1 - f i) = 1 - \u2211 i in s, f i * \u220f j in s.filter (\u00b7 < i), (1 - f j)", "start": [199, 1], "end": [204, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_pow_mul_eq_add_pow", "code": "theorem sum_pow_mul_eq_add_pow {\u03b1 R : Type*} [CommSemiring R] (a b : R) (s : Finset \u03b1) :\n    (\u2211 t in s.powerset, a ^ t.card * b ^ (s.card - t.card)) = (a + b) ^ s.card", "start": [207, 1], "end": [214, 64], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_natCast", "code": "@[norm_cast]\ntheorem prod_natCast (s : Finset \u03b1) (f : \u03b1 \u2192 \u2115) : \u2191(\u220f x in s, f x : \u2115) = \u220f x in s, (f x : \u03b2)", "start": [217, 1], "end": [219, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_cast_nat_sub", "code": "theorem prod_range_cast_nat_sub (n k : \u2115) :\n    \u220f i in range k, (n - i : R) = (\u220f i in range k, (n - i) : \u2115)", "start": [228, 1], "end": [234, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_powerset_insert", "code": "@[to_additive\n      \"A sum over all subsets of `s \u222a {x}` is obtained by summing the sum over all subsets\n      of `s`, and over all subsets of `s` to which one adds `x`.\"]\ntheorem prod_powerset_insert [DecidableEq \u03b1] [CommMonoid \u03b2] {s : Finset \u03b1} {x : \u03b1} (h : x \u2209 s)\n    (f : Finset \u03b1 \u2192 \u03b2) :\n    (\u220f a in (insert x s).powerset, f a) =\n      (\u220f a in s.powerset, f a) * \u220f t in s.powerset, f (insert x t)", "start": [239, 1], "end": [256, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_powerset", "code": "@[to_additive\n      \"A sum over `powerset s` is equal to the double sum over sets of subsets of `s` with\n      `card s = k`, for `k = 1, ..., card s`\"]\ntheorem prod_powerset [CommMonoid \u03b2] (s : Finset \u03b1) (f : Finset \u03b1 \u2192 \u03b2) :\n    \u220f t in powerset s, f t = \u220f j in range (card s + 1), \u220f t in powersetCard j s, f t", "start": [260, 1], "end": [267, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_succ_mul_sum_range_succ", "code": "theorem sum_range_succ_mul_sum_range_succ [NonUnitalNonAssocSemiring \u03b2] (n k : \u2115) (f g : \u2115 \u2192 \u03b2) :\n    ((\u2211 i in range (n + 1), f i) * \u2211 i in range (k + 1), g i) =\n      (((\u2211 i in range n, f i) * \u2211 i in range k, g i) + f n * \u2211 i in range k, g i) +\n          (\u2211 i in range n, f i) * g k +\n        f n * g k", "start": [271, 1], "end": [276, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/IndicatorFunction.lean", "imports": ["Mathlib/Algebra/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.mulIndicator", "code": "@[to_additive \"`Set.indicator s f a` is `f a` if `a \u2208 s`, `0` otherwise.\"]\nnoncomputable def mulIndicator (s : Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) : M :=\n  haveI := Classical.decPred (\u00b7 \u2208 s)\n  if x \u2208 s then f x else 1", "start": [45, 1], "end": [49, 27], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_eq_mulIndicator", "code": "@[to_additive (attr := simp)]\ntheorem piecewise_eq_mulIndicator [DecidablePred (\u00b7 \u2208 s)] : s.piecewise f 1 = s.mulIndicator f", "start": [52, 1], "end": [54, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply", "code": "@[to_additive]\ntheorem mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) [Decidable (a \u2208 s)] :\n    mulIndicator s f a = if a \u2208 s then f a else 1", "start": [59, 1], "end": [63, 8], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_of_mem", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_of_mem (h : a \u2208 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = f a", "start": [67, 1], "end": [69, 11], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_of_not_mem", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_of_not_mem (h : a \u2209 s) (f : \u03b1 \u2192 M) : mulIndicator s f a = 1", "start": [73, 1], "end": [75, 11], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_eq_one_or_self", "code": "@[to_additive]\ntheorem mulIndicator_eq_one_or_self (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a = 1 \u2228 mulIndicator s f a = f a", "start": [79, 1], "end": [84, 47], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_self : s.mulIndicator f a = f a \u2194 a \u2209 s \u2192 f a = 1", "start": [88, 1], "end": [91, 51], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_eq_self", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_self : s.mulIndicator f = f \u2194 mulSupport f \u2286 s", "start": [95, 1], "end": [97, 95], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_eq_self_of_superset", "code": "@[to_additive]\ntheorem mulIndicator_eq_self_of_superset (h1 : s.mulIndicator f = f) (h2 : s \u2286 t) :\n    t.mulIndicator f = f", "start": [101, 1], "end": [105, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_apply_eq_one : mulIndicator s f a = 1 \u2194 a \u2208 s \u2192 f a = 1", "start": [109, 1], "end": [112, 19], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one : (mulIndicator s f = fun x => 1) \u2194 Disjoint (mulSupport f) s", "start": [116, 1], "end": [119, 17], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_eq_one'", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_eq_one' : mulIndicator s f = 1 \u2194 Disjoint (mulSupport f) s", "start": [123, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_ne_one", "code": "@[to_additive]\ntheorem mulIndicator_apply_ne_one {a : \u03b1} : s.mulIndicator f a \u2260 1 \u2194 a \u2208 s \u2229 mulSupport f", "start": [129, 1], "end": [131, 88], "kind": "commanddeclaration"}, {"full_name": "Set.mulSupport_mulIndicator", "code": "@[to_additive (attr := simp)]\ntheorem mulSupport_mulIndicator :\n    Function.mulSupport (s.mulIndicator f) = s \u2229 Function.mulSupport f", "start": [135, 1], "end": [138, 76], "kind": "commanddeclaration"}, {"full_name": "Set.mem_of_mulIndicator_ne_one", "code": "@[to_additive\n      \"If an additive indicator function is not equal to `0` at a point, then that point is\n      in the set.\"]\ntheorem mem_of_mulIndicator_ne_one (h : mulIndicator s f a \u2260 1) : a \u2208 s", "start": [142, 1], "end": [148, 60], "kind": "commanddeclaration"}, {"full_name": "Set.eqOn_mulIndicator", "code": "@[to_additive]\ntheorem eqOn_mulIndicator : EqOn (mulIndicator s f) f s", "start": [152, 1], "end": [153, 96], "kind": "commanddeclaration"}, {"full_name": "Set.mulSupport_mulIndicator_subset", "code": "@[to_additive]\ntheorem mulSupport_mulIndicator_subset : mulSupport (s.mulIndicator f) \u2286 s", "start": [157, 1], "end": [159, 51], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mulSupport", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_mulSupport : mulIndicator (mulSupport f) f = f", "start": [163, 1], "end": [165, 36], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_range_comp", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_range_comp {\u03b9 : Sort*} (f : \u03b9 \u2192 \u03b1) (g : \u03b1 \u2192 M) :\n    mulIndicator (range f) g \u2218 f = g \u2218 f", "start": [169, 1], "end": [173, 29], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_congr", "code": "@[to_additive]\ntheorem mulIndicator_congr (h : EqOn f g s) : mulIndicator s f = mulIndicator s g", "start": [177, 1], "end": [183, 8], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_univ", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_univ (f : \u03b1 \u2192 M) : mulIndicator (univ : Set \u03b1) f = f", "start": [187, 1], "end": [189, 42], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_empty", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_empty (f : \u03b1 \u2192 M) : mulIndicator (\u2205 : Set \u03b1) f = fun _ => 1", "start": [193, 1], "end": [195, 44], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_empty'", "code": "@[to_additive]\ntheorem mulIndicator_empty' (f : \u03b1 \u2192 M) : mulIndicator (\u2205 : Set \u03b1) f = 1", "start": [199, 1], "end": [201, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_one", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_one (s : Set \u03b1) : (mulIndicator s fun _ => (1 : M)) = fun _ => (1 : M)", "start": [207, 1], "end": [209, 73], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_one'", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_one' {s : Set \u03b1} : s.mulIndicator (1 : \u03b1 \u2192 M) = 1", "start": [213, 1], "end": [215, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mulIndicator", "code": "@[to_additive]\ntheorem mulIndicator_mulIndicator (s t : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator s (mulIndicator t f) = mulIndicator (s \u2229 t) f", "start": [221, 1], "end": [226, 62], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_inter_mulSupport", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_inter_mulSupport (s : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator (s \u2229 mulSupport f) f = mulIndicator s f", "start": [230, 1], "end": [233, 60], "kind": "commanddeclaration"}, {"full_name": "Set.comp_mulIndicator", "code": "@[to_additive]\ntheorem comp_mulIndicator (h : M \u2192 \u03b2) (f : \u03b1 \u2192 M) {s : Set \u03b1} {x : \u03b1} [DecidablePred (\u00b7 \u2208 s)] :\n    h (s.mulIndicator f x) = s.piecewise (h \u2218 f) (const \u03b1 (h 1)) x", "start": [237, 1], "end": [241, 72], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_comp_right", "code": "@[to_additive]\ntheorem mulIndicator_comp_right {s : Set \u03b1} (f : \u03b2 \u2192 \u03b1) {g : \u03b1 \u2192 M} {x : \u03b2} :\n    mulIndicator (f \u207b\u00b9' s) (g \u2218 f) x = mulIndicator s g (f x)", "start": [245, 1], "end": [249, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_image", "code": "@[to_additive]\ntheorem mulIndicator_image {s : Set \u03b1} {f : \u03b2 \u2192 M} {g : \u03b1 \u2192 \u03b2} (hg : Injective g) {x : \u03b1} :\n    mulIndicator (g '' s) f (g x) = mulIndicator s (f \u2218 g) x", "start": [253, 1], "end": [256, 57], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_comp_of_one", "code": "@[to_additive]\ntheorem mulIndicator_comp_of_one {g : M \u2192 N} (hg : g 1 = 1) :\n    mulIndicator s (g \u2218 f) = g \u2218 mulIndicator s f", "start": [260, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "Set.comp_mulIndicator_const", "code": "@[to_additive]\ntheorem comp_mulIndicator_const (c : M) (f : M \u2192 N) (hf : f 1 = 1) :\n    (fun x => f (s.mulIndicator (fun _ => c) x)) = s.mulIndicator fun _ => f c", "start": [269, 1], "end": [272, 37], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_preimage", "code": "@[to_additive]\ntheorem mulIndicator_preimage (s : Set \u03b1) (f : \u03b1 \u2192 M) (B : Set M) :\n    mulIndicator s f \u207b\u00b9' B = s.ite (f \u207b\u00b9' B) (1 \u207b\u00b9' B)", "start": [276, 1], "end": [280, 29], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_one_preimage", "code": "@[to_additive]\ntheorem mulIndicator_one_preimage (s : Set M) :\n    t.mulIndicator 1 \u207b\u00b9' s \u2208 ({Set.univ, \u2205} : Set (Set \u03b1))", "start": [284, 1], "end": [289, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_const_preimage_eq_union", "code": "@[to_additive]\ntheorem mulIndicator_const_preimage_eq_union (U : Set \u03b1) (s : Set M) (a : M) [Decidable (a \u2208 s)]\n    [Decidable ((1 : M) \u2208 s)] : (U.mulIndicator fun _ => a) \u207b\u00b9' s =\n      (if a \u2208 s then U else \u2205) \u222a if (1 : M) \u2208 s then U\u1d9c else \u2205", "start": [293, 1], "end": [298, 44], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_const_preimage", "code": "@[to_additive]\ntheorem mulIndicator_const_preimage (U : Set \u03b1) (s : Set M) (a : M) :\n    (U.mulIndicator fun _ => a) \u207b\u00b9' s \u2208 ({Set.univ, U, U\u1d9c, \u2205} : Set (Set \u03b1))", "start": [302, 1], "end": [307, 23], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_one_preimage", "code": "theorem indicator_one_preimage [Zero M] (U : Set \u03b1) (s : Set M) :\n    U.indicator 1 \u207b\u00b9' s \u2208 ({Set.univ, U, U\u1d9c, \u2205} : Set (Set \u03b1))", "start": [311, 1], "end": [313, 33], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_preimage_of_not_mem", "code": "@[to_additive]\ntheorem mulIndicator_preimage_of_not_mem (s : Set \u03b1) (f : \u03b1 \u2192 M) {t : Set M} (ht : (1 : M) \u2209 t) :\n    mulIndicator s f \u207b\u00b9' t = f \u207b\u00b9' t \u2229 s", "start": [316, 1], "end": [319, 77], "kind": "commanddeclaration"}, {"full_name": "Set.mem_range_mulIndicator", "code": "@[to_additive]\ntheorem mem_range_mulIndicator {r : M} {s : Set \u03b1} {f : \u03b1 \u2192 M} :\n    r \u2208 range (mulIndicator s f) \u2194 r = 1 \u2227 s \u2260 univ \u2228 r \u2208 f '' s", "start": [323, 1], "end": [337, 78], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_rel_mulIndicator", "code": "@[to_additive]\ntheorem mulIndicator_rel_mulIndicator {r : M \u2192 M \u2192 Prop} (h1 : r 1 1) (ha : a \u2208 s \u2192 r (f a) (g a)) :\n    r (mulIndicator s f a) (mulIndicator s g a)", "start": [341, 1], "end": [346, 22], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_union_mul_inter_apply", "code": "@[to_additive]\ntheorem mulIndicator_union_mul_inter_apply (f : \u03b1 \u2192 M) (s t : Set \u03b1) (a : \u03b1) :\n    mulIndicator (s \u222a t) f a * mulIndicator (s \u2229 t) f a = mulIndicator s f a * mulIndicator t f a", "start": [356, 1], "end": [359, 62], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_union_mul_inter", "code": "@[to_additive]\ntheorem mulIndicator_union_mul_inter (f : \u03b1 \u2192 M) (s t : Set \u03b1) :\n    mulIndicator (s \u222a t) f * mulIndicator (s \u2229 t) f = mulIndicator s f * mulIndicator t f", "start": [363, 1], "end": [366, 53], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_union_of_not_mem_inter", "code": "@[to_additive]\ntheorem mulIndicator_union_of_not_mem_inter (h : a \u2209 s \u2229 t) (f : \u03b1 \u2192 M) :\n    mulIndicator (s \u222a t) f a = mulIndicator s f a * mulIndicator t f a", "start": [370, 1], "end": [373, 86], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_union_of_disjoint", "code": "@[to_additive]\ntheorem mulIndicator_union_of_disjoint (h : Disjoint s t) (f : \u03b1 \u2192 M) :\n    mulIndicator (s \u222a t) f = fun a => mulIndicator s f a * mulIndicator t f a", "start": [377, 1], "end": [380, 80], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_symmDiff", "code": "@[to_additive]\ntheorem mulIndicator_symmDiff (s t : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator (s \u2206 t) f = mulIndicator (s \\ t) f * mulIndicator (t \\ s) f", "start": [384, 1], "end": [387, 82], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mul", "code": "@[to_additive]\ntheorem mulIndicator_mul (s : Set \u03b1) (f g : \u03b1 \u2192 M) :\n    (mulIndicator s fun a => f a * g a) = fun a => mulIndicator s f a * mulIndicator s g a", "start": [389, 1], "end": [396, 15], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mul'", "code": "@[to_additive]\ntheorem mulIndicator_mul' (s : Set \u03b1) (f g : \u03b1 \u2192 M) :\n    mulIndicator s (f * g) = mulIndicator s f * mulIndicator s g", "start": [400, 1], "end": [403, 25], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_compl_mul_self_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s\u1d9c f a * mulIndicator s f a = f a", "start": [407, 1], "end": [410, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_compl_mul_self", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_compl_mul_self (s : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator s\u1d9c f * mulIndicator s f = f", "start": [414, 1], "end": [417, 50], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_self_mul_compl_apply", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    mulIndicator s f a * mulIndicator s\u1d9c f a = f a", "start": [421, 1], "end": [424, 67], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_self_mul_compl", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_self_mul_compl (s : Set \u03b1) (f : \u03b1 \u2192 M) :\n    mulIndicator s f * mulIndicator s\u1d9c f = f", "start": [428, 1], "end": [431, 50], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mul_eq_left", "code": "@[to_additive]\ntheorem mulIndicator_mul_eq_left {f g : \u03b1 \u2192 M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport f).mulIndicator (f * g) = f", "start": [435, 1], "end": [440, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mul_eq_right", "code": "@[to_additive]\ntheorem mulIndicator_mul_eq_right {f g : \u03b1 \u2192 M} (h : Disjoint (mulSupport f) (mulSupport g)) :\n    (mulSupport g).mulIndicator (f * g) = g", "start": [444, 1], "end": [449, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_mul_compl_eq_piecewise", "code": "@[to_additive]\ntheorem mulIndicator_mul_compl_eq_piecewise [DecidablePred (\u00b7 \u2208 s)] (f g : \u03b1 \u2192 M) :\n    s.mulIndicator f * s\u1d9c.mulIndicator g = s.piecewise f g", "start": [453, 1], "end": [461, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicatorHom", "code": "@[to_additive \"`Set.indicator` as an `addMonoidHom`.\"]\nnoncomputable def mulIndicatorHom {\u03b1} (M) [MulOneClass M] (s : Set \u03b1) : (\u03b1 \u2192 M) \u2192* \u03b1 \u2192 M\n    where\n  toFun := mulIndicator s\n  map_one' := mulIndicator_one M s\n  map_mul' := mulIndicator_mul s", "start": [465, 1], "end": [471, 33], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul_apply", "code": "theorem indicator_smul_apply (s : Set \u03b1) (r : \u03b1 \u2192 M) (f : \u03b1 \u2192 A) (x : \u03b1) :\n    indicator s (fun x => r x \u2022 f x) x = r x \u2022 indicator s f x", "start": [481, 1], "end": [485, 39], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul", "code": "theorem indicator_smul (s : Set \u03b1) (r : \u03b1 \u2192 M) (f : \u03b1 \u2192 A) :\n    (indicator s fun x : \u03b1 => r x \u2022 f x) = fun x : \u03b1 => r x \u2022 indicator s f x", "start": [488, 1], "end": [490, 39], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_const_smul_apply", "code": "theorem indicator_const_smul_apply (s : Set \u03b1) (r : M) (f : \u03b1 \u2192 A) (x : \u03b1) :\n    indicator s (fun x => r \u2022 f x) x = r \u2022 indicator s f x", "start": [493, 1], "end": [495, 42], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_const_smul", "code": "theorem indicator_const_smul (s : Set \u03b1) (r : M) (f : \u03b1 \u2192 A) :\n    (indicator s fun x : \u03b1 => r \u2022 f x) = fun x : \u03b1 => r \u2022 indicator s f x", "start": [498, 1], "end": [500, 45], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul_apply_left", "code": "theorem indicator_smul_apply_left (s : Set \u03b1) (r : \u03b1 \u2192 M) (f : \u03b1 \u2192 A) (x : \u03b1) :\n    indicator s (fun x => r x \u2022 f x) x = indicator s r x \u2022 f x", "start": [509, 1], "end": [513, 41], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul_left", "code": "theorem indicator_smul_left (s : Set \u03b1) (r : \u03b1 \u2192 M) (f : \u03b1 \u2192 A) :\n    (indicator s fun x : \u03b1 => r x \u2022 f x) = fun x : \u03b1 => indicator s r x \u2022 f x", "start": [515, 1], "end": [517, 44], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul_const_apply", "code": "theorem indicator_smul_const_apply (s : Set \u03b1) (r : \u03b1 \u2192 M) (a : A) (x : \u03b1) :\n    indicator s (fun x => r x \u2022 a) x = indicator s r x \u2022 a", "start": [519, 1], "end": [521, 47], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_smul_const", "code": "theorem indicator_smul_const (s : Set \u03b1) (r : \u03b1 \u2192 M) (a : A) :\n    (indicator s fun x : \u03b1 => r x \u2022 a) = fun x : \u03b1 => indicator s r x \u2022 a", "start": [523, 1], "end": [525, 45], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_inv'", "code": "@[to_additive]\ntheorem mulIndicator_inv' (s : Set \u03b1) (f : \u03b1 \u2192 G) : mulIndicator s f\u207b\u00b9 = (mulIndicator s f)\u207b\u00b9", "start": [533, 1], "end": [535, 34], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_inv", "code": "@[to_additive]\ntheorem mulIndicator_inv (s : Set \u03b1) (f : \u03b1 \u2192 G) :\n    (mulIndicator s fun a => (f a)\u207b\u00b9) = fun a => (mulIndicator s f a)\u207b\u00b9", "start": [539, 1], "end": [542, 24], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_div", "code": "@[to_additive]\ntheorem mulIndicator_div (s : Set \u03b1) (f g : \u03b1 \u2192 G) :\n    (mulIndicator s fun a => f a / g a) = fun a => mulIndicator s f a / mulIndicator s g a", "start": [546, 1], "end": [549, 36], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_div'", "code": "@[to_additive]\ntheorem mulIndicator_div' (s : Set \u03b1) (f g : \u03b1 \u2192 G) :\n    mulIndicator s (f / g) = mulIndicator s f / mulIndicator s g", "start": [553, 1], "end": [556, 25], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_compl", "code": "@[to_additive indicator_compl']\ntheorem mulIndicator_compl (s : Set \u03b1) (f : \u03b1 \u2192 G) :\n    mulIndicator s\u1d9c f = f * (mulIndicator s f)\u207b\u00b9", "start": [560, 1], "end": [563, 58], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_compl'", "code": "@[to_additive indicator_compl]\ntheorem mulIndicator_compl' (s : Set \u03b1) (f : \u03b1 \u2192 G) :\n    mulIndicator s\u1d9c f = f / mulIndicator s f", "start": [567, 1], "end": [569, 91], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_diff", "code": "@[to_additive indicator_diff']\ntheorem mulIndicator_diff (h : s \u2286 t) (f : \u03b1 \u2192 G) :\n    mulIndicator (t \\ s) f = mulIndicator t f * (mulIndicator s f)\u207b\u00b9", "start": [572, 1], "end": [578, 35], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_diff'", "code": "@[to_additive indicator_diff]\ntheorem mulIndicator_diff' (h : s \u2286 t) (f : \u03b1 \u2192 G) :\n    mulIndicator (t \\ s) f = mulIndicator t f / mulIndicator s f", "start": [582, 1], "end": [585, 43], "kind": "commanddeclaration"}, {"full_name": "Set.apply_mulIndicator_symmDiff", "code": "@[to_additive]\ntheorem apply_mulIndicator_symmDiff {g : G \u2192 \u03b2} (hg : \u2200 x, g x\u207b\u00b9 = g x)\n    (s t : Set \u03b1) (f : \u03b1 \u2192 G) (x : \u03b1):\n    g (mulIndicator (s \u2206 t) f x) = g (mulIndicator s f x / mulIndicator t f x)", "start": [588, 1], "end": [592, 73], "kind": "commanddeclaration"}, {"full_name": "Set.abs_indicator_symmDiff", "code": "theorem abs_indicator_symmDiff {G : Type*} [LinearOrderedAddCommGroup G]\n    (s t : Set \u03b1) (f : \u03b1 \u2192 G) (x : \u03b1) :\n    |indicator (s \u2206 t) f x| = |indicator s f x - indicator t f x|", "start": [596, 1], "end": [599, 43], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mulIndicator_subset_of_eq_one", "code": "@[to_additive]\ntheorem prod_mulIndicator_subset_of_eq_one [One N] (f : \u03b1 \u2192 N) (g : \u03b1 \u2192 N \u2192 M) {s t : Finset \u03b1}\n    (h : s \u2286 t) (hg : \u2200 a, g a 1 = 1) :\n    (\u220f i in s, g i (f i)) = \u220f i in t, g i (mulIndicator (\u2191s) f i)", "start": [605, 1], "end": [624, 48], "kind": "commanddeclaration"}, {"full_name": "Set.prod_mulIndicator_subset", "code": "@[to_additive\n      \"Summing an indicator function over a possibly larger `Finset` is the same as summing\n      the original function over the original `finset`.\"]\ntheorem prod_mulIndicator_subset (f : \u03b1 \u2192 M) {s t : Finset \u03b1} (h : s \u2286 t) :\n    \u220f i in s, f i = \u220f i in t, mulIndicator (\u2191s) f i", "start": [637, 1], "end": [644, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mulIndicator_eq_prod_filter", "code": "@[to_additive]\ntheorem _root_.Finset.prod_mulIndicator_eq_prod_filter (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192 M)\n    (t : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1) [DecidablePred fun i => g i \u2208 t i] :\n    (\u220f i in s, mulIndicator (t i) (f i) (g i)) = \u220f i in s.filter fun i => g i \u2208 t i, f i (g i)", "start": [648, 1], "end": [657, 92], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_finset_prod", "code": "@[to_additive]\ntheorem mulIndicator_finset_prod (I : Finset \u03b9) (s : Set \u03b1) (f : \u03b9 \u2192 \u03b1 \u2192 M) :\n    mulIndicator s (\u220f i in I, f i) = \u220f i in I, mulIndicator s (f i)", "start": [661, 1], "end": [664, 37], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_finset_biUnion", "code": "@[to_additive]\ntheorem mulIndicator_finset_biUnion (I : Finset \u03b9) (s : \u03b9 \u2192 Set \u03b1) {f : \u03b1 \u2192 M} :\n    (\u2200 i \u2208 I, \u2200 j \u2208 I, i \u2260 j \u2192 Disjoint (s i) (s j)) \u2192\n      mulIndicator (\u22c3 i \u2208 I, s i) f = fun a => \u220f i in I, mulIndicator (s i) f a", "start": [668, 1], "end": [687, 46], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_finset_biUnion_apply", "code": "@[to_additive]\ntheorem mulIndicator_finset_biUnion_apply (I : Finset \u03b9) (s : \u03b9 \u2192 Set \u03b1) {f : \u03b1 \u2192 M}\n    (h : \u2200 i \u2208 I, \u2200 j \u2208 I, i \u2260 j \u2192 Disjoint (s i) (s j)) (x : \u03b1) :\n    mulIndicator (\u22c3 i \u2208 I, s i) f x = \u220f i in I, mulIndicator (s i) f x", "start": [691, 1], "end": [695, 45], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_mul", "code": "theorem indicator_mul (s : Set \u03b1) (f g : \u03b1 \u2192 M) :\n    (indicator s fun a => f a * g a) = fun a => indicator s f a * indicator s g a", "start": [705, 1], "end": [711, 16], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_mul_left", "code": "theorem indicator_mul_left (s : Set \u03b1) (f g : \u03b1 \u2192 M) :\n    indicator s (fun a => f a * g a) a = indicator s f a * g a", "start": [714, 1], "end": [719, 16], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_mul_right", "code": "theorem indicator_mul_right (s : Set \u03b1) (f g : \u03b1 \u2192 M) :\n    indicator s (fun a => f a * g a) a = f a * indicator s g a", "start": [722, 1], "end": [727, 16], "kind": "commanddeclaration"}, {"full_name": "Set.inter_indicator_mul", "code": "theorem inter_indicator_mul {t1 t2 : Set \u03b1} (f g : \u03b1 \u2192 M) (x : \u03b1) :\n    (t1 \u2229 t2).indicator (fun x => f x * g x) x = t1.indicator f x * t2.indicator g x", "start": [730, 1], "end": [734, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_indicator_one", "code": "theorem inter_indicator_one {s t : Set \u03b1} :\n    (s \u2229 t).indicator (1 : \u03b1 \u2192 M) = s.indicator 1 * t.indicator 1", "start": [743, 1], "end": [747, 10], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_prod_one", "code": "theorem indicator_prod_one {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1} {y : \u03b2} :\n    (s \u00d7\u02e2 t).indicator (1 : \u03b1 \u00d7 \u03b2 \u2192 M) (x, y) = s.indicator 1 x * t.indicator 1 y", "start": [752, 1], "end": [755, 78], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_eq_zero_iff_not_mem", "code": "theorem indicator_eq_zero_iff_not_mem {U : Set \u03b1} {x : \u03b1} : indicator U 1 x = (0 : M) \u2194 x \u2209 U", "start": [760, 1], "end": [761, 46], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_eq_one_iff_mem", "code": "theorem indicator_eq_one_iff_mem {U : Set \u03b1} {x : \u03b1} : indicator U 1 x = (1 : M) \u2194 x \u2208 U", "start": [764, 1], "end": [765, 46], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_one_inj", "code": "theorem indicator_one_inj {U V : Set \u03b1} (h : indicator U (1 : \u03b1 \u2192 M) = indicator V 1) : U = V", "start": [768, 1], "end": [770, 44], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_le'", "code": "@[to_additive]\ntheorem mulIndicator_apply_le' (hfg : a \u2208 s \u2192 f a \u2264 y) (hg : a \u2209 s \u2192 1 \u2264 y) :\n    mulIndicator s f a \u2264 y", "start": [783, 1], "end": [788, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le'", "code": "@[to_additive]\ntheorem mulIndicator_le' (hfg : \u2200 a \u2208 s, f a \u2264 g a) (hg : \u2200 (a) (_ : a \u2209 s), 1 \u2264 g a) :\n    mulIndicator s f \u2264 g", "start": [794, 1], "end": [796, 75], "kind": "commanddeclaration"}, {"full_name": "Set.le_mulIndicator_apply", "code": "@[to_additive]\ntheorem le_mulIndicator_apply {y} (hfg : a \u2208 s \u2192 y \u2264 g a) (hf : a \u2209 s \u2192 y \u2264 1) :\n    y \u2264 mulIndicator s g a", "start": [800, 1], "end": [803, 53], "kind": "commanddeclaration"}, {"full_name": "Set.le_mulIndicator", "code": "@[to_additive]\ntheorem le_mulIndicator (hfg : \u2200 a \u2208 s, f a \u2264 g a) (hf : \u2200 (a) (_ : a \u2209 s), f a \u2264 1) :\n    f \u2264 mulIndicator s g", "start": [807, 1], "end": [809, 74], "kind": "commanddeclaration"}, {"full_name": "Set.one_le_mulIndicator_apply", "code": "@[to_additive indicator_apply_nonneg]\ntheorem one_le_mulIndicator_apply (h : a \u2208 s \u2192 1 \u2264 f a) : 1 \u2264 mulIndicator s f a", "start": [817, 1], "end": [819, 42], "kind": "commanddeclaration"}, {"full_name": "Set.one_le_mulIndicator", "code": "@[to_additive indicator_nonneg]\ntheorem one_le_mulIndicator (h : \u2200 a \u2208 s, 1 \u2264 f a) (a : \u03b1) : 1 \u2264 mulIndicator s f a", "start": [823, 1], "end": [825, 34], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_le_one", "code": "@[to_additive]\ntheorem mulIndicator_apply_le_one (h : a \u2208 s \u2192 f a \u2264 1) : mulIndicator s f a \u2264 1", "start": [829, 1], "end": [831, 43], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le_one", "code": "@[to_additive]\ntheorem mulIndicator_le_one (h : \u2200 a \u2208 s, f a \u2264 1) (a : \u03b1) : mulIndicator s f a \u2264 1", "start": [835, 1], "end": [837, 34], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le_mulIndicator", "code": "@[to_additive]\ntheorem mulIndicator_le_mulIndicator (h : f a \u2264 g a) : mulIndicator s f a \u2264 mulIndicator s g a", "start": [841, 1], "end": [843, 50], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le_mulIndicator_of_subset", "code": "@[to_additive]\ntheorem mulIndicator_le_mulIndicator_of_subset (h : s \u2286 t) (hf : \u2200 a, 1 \u2264 f a) (a : \u03b1) :\n    mulIndicator s f a \u2264 mulIndicator t f a", "start": [849, 1], "end": [854, 44], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le_self'", "code": "@[to_additive]\ntheorem mulIndicator_le_self' (hf : \u2200 (x) (_ : x \u2209 s), 1 \u2264 f x) : mulIndicator s f \u2264 f", "start": [858, 1], "end": [860, 42], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_iUnion_apply", "code": "@[to_additive]\ntheorem mulIndicator_iUnion_apply {\u03b9 : Sort*} {M : Type*} [CompleteLattice M] [One M]\n    (h1 : (\u22a5 : M) = 1) (s : \u03b9 \u2192 Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) :\n    mulIndicator (\u22c3 i, s i) f x = \u2a06 i, mulIndicator (s i) f x", "start": [864, 1], "end": [876, 20], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_iInter_apply", "code": "@[to_additive] lemma mulIndicator_iInter_apply {\u03b9 : Sort*} {M : Type*} [Nonempty \u03b9]\n    [CompleteLattice M] [One M] (h1 : (\u22a5 : M) = 1) (s : \u03b9 \u2192 Set \u03b1) (f : \u03b1 \u2192 M) (x : \u03b1) :\n    mulIndicator (\u22c2 i, s i) f x = \u2a05 i, mulIndicator (s i) f x := by\n  by_cases hx : x \u2208 \u22c2 i, s i\n  \u00b7 rw [mulIndicator_of_mem hx]\n    rw [mem_iInter] at hx\n    refine le_antisymm ?_ (by simp only [mulIndicator_of_mem (hx _), ciInf_const, le_refl])\n    exact le_iInf (fun j \u21a6 by simp only [mulIndicator_of_mem (hx j), le_refl])\n  \u00b7 rw [mulIndicator_of_not_mem hx]\n    simp only [mem_iInter, not_exists, not_forall] at hx\n    rcases hx with \u27e8j, hj\u27e9\n    refine le_antisymm (by simp only [\u2190 h1, le_iInf_iff, bot_le, forall_const]) ?_\n    simpa [mulIndicator_of_not_mem hj] using (iInf_le (fun i \u21a6 (s i).mulIndicator f) j) x", "start": [880, 1], "end": [892, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Set.mulIndicator_le_self", "code": "@[to_additive]\ntheorem mulIndicator_le_self (s : Set \u03b1) (f : \u03b1 \u2192 M) : mulIndicator s f \u2264 f", "start": [900, 1], "end": [902, 44], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_apply_le", "code": "@[to_additive]\ntheorem mulIndicator_apply_le {a : \u03b1} {s : Set \u03b1} {f g : \u03b1 \u2192 M} (hfg : a \u2208 s \u2192 f a \u2264 g a) :\n    mulIndicator s f a \u2264 g a", "start": [906, 1], "end": [909, 47], "kind": "commanddeclaration"}, {"full_name": "Set.mulIndicator_le", "code": "@[to_additive]\ntheorem mulIndicator_le {s : Set \u03b1} {f g : \u03b1 \u2192 M} (hfg : \u2200 a \u2208 s, f a \u2264 g a) :\n    mulIndicator s f \u2264 g", "start": [913, 1], "end": [916, 43], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_le_indicator_nonneg", "code": "theorem indicator_le_indicator_nonneg {\u03b2} [LinearOrder \u03b2] [Zero \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    s.indicator f \u2264 { x | 0 \u2264 f x }.indicator f", "start": [922, 1], "end": [931, 19], "kind": "commanddeclaration"}, {"full_name": "Set.indicator_nonpos_le_indicator", "code": "theorem indicator_nonpos_le_indicator {\u03b2} [LinearOrder \u03b2] [Zero \u03b2] (s : Set \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    { x | f x \u2264 0 }.indicator f \u2264 s.indicator f", "start": [934, 1], "end": [936, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_mulIndicator", "code": "@[to_additive]\ntheorem MonoidHom.map_mulIndicator {M N : Type*} [MulOneClass M] [MulOneClass N] (f : M \u2192* N)\n    (s : Set \u03b1) (g : \u03b1 \u2192 M) (x : \u03b1) : f (s.mulIndicator g x) = s.mulIndicator (f \u2218 g) x", "start": [941, 1], "end": [944, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/Commute.lean", "imports": ["Mathlib/Algebra/Group/Commute/Defs.lean", "Mathlib/Algebra/Hom/Group/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SemiconjBy.map", "code": "@[to_additive (attr := simp)]\nprotected theorem SemiconjBy.map [MulHomClass F M N] (h : SemiconjBy a x y) (f : F) :\n    SemiconjBy (f a) (f x) (f y)", "start": [21, 1], "end": [23, 92], "kind": "commanddeclaration"}, {"full_name": "Commute.map", "code": "@[to_additive (attr := simp)]\nprotected theorem Commute.map [MulHomClass F M N] (h : Commute x y) (f : F) : Commute (f x) (f y)", "start": [27, 1], "end": [29, 21], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.of_map", "code": "@[to_additive (attr := simp)]\nprotected theorem SemiconjBy.of_map [MulHomClass F M N] (f : F) (hf : Function.Injective f)\n    (h : SemiconjBy (f a) (f x) (f y)) : SemiconjBy a x y", "start": [33, 1], "end": [36, 51], "kind": "commanddeclaration"}, {"full_name": "Commute.of_map", "code": "@[to_additive (attr := simp)]\ntheorem Commute.of_map [MulHomClass F M N] {f : F} (hf : Function.Injective f)\n    (h : Commute (f x) (f y)) : Commute x y", "start": [38, 1], "end": [41, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Hom/Basic.lean", "imports": ["Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Tactic/Positivity/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonnegHomClass", "code": "class NonnegHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Zero \u03b2] [LE \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_nonneg (f : F) : \u2200 a, 0 \u2264 f a", "start": [78, 1], "end": [82, 36], "kind": "commanddeclaration"}, {"full_name": "SubadditiveHomClass", "code": "class SubadditiveHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Add \u03b1] [Add \u03b2] [LE \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_add_le_add (f : F) : \u2200 a b, f (a + b) \u2264 f a + f b", "start": [85, 1], "end": [89, 56], "kind": "commanddeclaration"}, {"full_name": "SubmultiplicativeHomClass", "code": "@[to_additive SubadditiveHomClass]\nclass SubmultiplicativeHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Mul \u03b1] [Mul \u03b2] [LE \u03b2]\n  extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_mul_le_mul (f : F) : \u2200 a b, f (a * b) \u2264 f a * f b", "start": [92, 1], "end": [97, 56], "kind": "commanddeclaration"}, {"full_name": "MulLEAddHomClass", "code": "@[to_additive SubadditiveHomClass]\nclass MulLEAddHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Mul \u03b1] [Add \u03b2] [LE \u03b2]\n  extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_mul_le_add (f : F) : \u2200 a b, f (a * b) \u2264 f a + f b", "start": [100, 1], "end": [105, 56], "kind": "commanddeclaration"}, {"full_name": "NonarchimedeanHomClass", "code": "class NonarchimedeanHomClass (F : Type*) (\u03b1 \u03b2 : outParam (Type*)) [Add \u03b1] [LinearOrder \u03b2]\n  extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_add_le_max (f : F) : \u2200 a b, f (a + b) \u2264 max (f a) (f b)", "start": [108, 1], "end": [112, 62], "kind": "commanddeclaration"}, {"full_name": "le_map_mul_map_div", "code": "@[to_additive]\ntheorem le_map_mul_map_div [Group \u03b1] [CommSemigroup \u03b2] [LE \u03b2] [SubmultiplicativeHomClass F \u03b1 \u03b2]\n    (f : F) (a b : \u03b1) : f a \u2264 f b * f (a / b)", "start": [127, 1], "end": [130, 74], "kind": "commanddeclaration"}, {"full_name": "le_map_add_map_div", "code": "@[to_additive existing]\ntheorem le_map_add_map_div [Group \u03b1] [AddCommSemigroup \u03b2] [LE \u03b2] [MulLEAddHomClass F \u03b1 \u03b2] (f : F)\n    (a b : \u03b1) : f a \u2264 f b + f (a / b)", "start": [134, 1], "end": [137, 74], "kind": "commanddeclaration"}, {"full_name": "le_map_div_mul_map_div", "code": "@[to_additive]\ntheorem le_map_div_mul_map_div [Group \u03b1] [CommSemigroup \u03b2] [LE \u03b2] [SubmultiplicativeHomClass F \u03b1 \u03b2]\n    (f : F) (a b c : \u03b1) : f (a / c) \u2264 f (a / b) * f (b / c)", "start": [141, 1], "end": [144, 74], "kind": "commanddeclaration"}, {"full_name": "le_map_div_add_map_div", "code": "@[to_additive existing]\ntheorem le_map_div_add_map_div [Group \u03b1] [AddCommSemigroup \u03b2] [LE \u03b2] [MulLEAddHomClass F \u03b1 \u03b2]\n    (f : F) (a b c : \u03b1) : f (a / c) \u2264 f (a / b) + f (b / c)", "start": [148, 1], "end": [151, 76], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalMap", "code": "@[positivity FunLike.coe _ _]\ndef evalMap : PositivityExt where eval {_ \u03b2} _ _ e := do\n  let .app (.app _ f) a \u2190 whnfR e\n    | throwError \"not \u2191f \u00b7 where f is of NonnegHomClass\"\n  let pa \u2190 mkAppOptM ``map_nonneg #[none, none, \u03b2, none, none, none, f, a]\n  pure (.nonnegative pa)", "start": [159, 1], "end": [165, 25], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminormClass", "code": "class AddGroupSeminormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [AddGroup \u03b1]\n  [OrderedAddCommMonoid \u03b2] extends SubadditiveHomClass F \u03b1 \u03b2 where\n  \n  map_zero (f : F) : f 0 = 0\n  \n  map_neg_eq_map (f : F) (a : \u03b1) : f (-a) = f a", "start": [172, 1], "end": [181, 48], "kind": "commanddeclaration"}, {"full_name": "GroupSeminormClass", "code": "@[to_additive]\nclass GroupSeminormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Group \u03b1]\n  [OrderedAddCommMonoid \u03b2] extends MulLEAddHomClass F \u03b1 \u03b2 where\n  \n  map_one_eq_zero (f : F) : f 1 = 0\n  \n  map_inv_eq_map (f : F) (a : \u03b1) : f a\u207b\u00b9 = f a", "start": [184, 1], "end": [193, 47], "kind": "commanddeclaration"}, {"full_name": "AddGroupNormClass", "code": "class AddGroupNormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [AddGroup \u03b1]\n  [OrderedAddCommMonoid \u03b2] extends AddGroupSeminormClass F \u03b1 \u03b2 where\n  \n  eq_zero_of_map_eq_zero (f : F) {a : \u03b1} : f a = 0 \u2192 a = 0", "start": [196, 1], "end": [203, 59], "kind": "commanddeclaration"}, {"full_name": "GroupNormClass", "code": "@[to_additive]\nclass GroupNormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Group \u03b1]\n  [OrderedAddCommMonoid \u03b2] extends GroupSeminormClass F \u03b1 \u03b2 where\n  \n  eq_one_of_map_eq_zero (f : F) {a : \u03b1} : f a = 0 \u2192 a = 1", "start": [206, 1], "end": [213, 58], "kind": "commanddeclaration"}, {"full_name": "AddGroupSeminormClass.toZeroHomClass", "code": "instance (priority := 100) AddGroupSeminormClass.toZeroHomClass [AddGroup \u03b1]\n    [OrderedAddCommMonoid \u03b2] [AddGroupSeminormClass F \u03b1 \u03b2] : ZeroHomClass F \u03b1 \u03b2 :=\n  { \u2039AddGroupSeminormClass F \u03b1 \u03b2\u203a with }", "start": [233, 1], "end": [235, 41], "kind": "commanddeclaration"}, {"full_name": "map_div_le_add", "code": "@[to_additive]\ntheorem map_div_le_add : f (x / y) \u2264 f x + f y", "start": [242, 1], "end": [245, 29], "kind": "commanddeclaration"}, {"full_name": "map_div_rev", "code": "@[to_additive]\ntheorem map_div_rev : f (x / y) = f (y / x)", "start": [249, 1], "end": [250, 81], "kind": "commanddeclaration"}, {"full_name": "le_map_add_map_div'", "code": "@[to_additive]\ntheorem le_map_add_map_div' : f x \u2264 f y + f (y / x)", "start": [254, 1], "end": [256, 87], "kind": "commanddeclaration"}, {"full_name": "abs_sub_map_le_div", "code": "@[to_additive]\ntheorem abs_sub_map_le_div [Group \u03b1] [LinearOrderedAddCommGroup \u03b2] [GroupSeminormClass F \u03b1 \u03b2]\n    (f : F) (x y : \u03b1) : |f x - f y| \u2264 f (x / y)", "start": [265, 1], "end": [269, 62], "kind": "commanddeclaration"}, {"full_name": "GroupSeminormClass.toNonnegHomClass", "code": "@[to_additive]\ninstance (priority := 100) GroupSeminormClass.toNonnegHomClass [Group \u03b1]\n    [LinearOrderedAddCommMonoid \u03b2] [GroupSeminormClass F \u03b1 \u03b2] : NonnegHomClass F \u03b1 \u03b2 :=\n  { \u2039GroupSeminormClass F \u03b1 \u03b2\u203a with\n    map_nonneg := fun f a =>\n      (nsmul_nonneg_iff two_ne_zero).1 <| by\n        rw [two_nsmul, \u2190 map_one_eq_zero f, \u2190 div_self' a]\n        exact map_div_le_add _ _ _ }", "start": [274, 1], "end": [281, 37], "kind": "commanddeclaration"}, {"full_name": "map_eq_zero_iff_eq_one", "code": "@[to_additive (attr := simp)]\ntheorem map_eq_zero_iff_eq_one : f x = 0 \u2194 x = 1", "start": [289, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "map_ne_zero_iff_ne_one", "code": "@[to_additive]\ntheorem map_ne_zero_iff_ne_one : f x \u2260 0 \u2194 x \u2260 1", "start": [297, 1], "end": [299, 33], "kind": "commanddeclaration"}, {"full_name": "map_pos_of_ne_one", "code": "@[to_additive]\ntheorem map_pos_of_ne_one [Group \u03b1] [LinearOrderedAddCommMonoid \u03b2] [GroupNormClass F \u03b1 \u03b2] (f : F)\n    {x : \u03b1} (hx : x \u2260 1) : 0 < f x", "start": [305, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "RingSeminormClass", "code": "class RingSeminormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [NonUnitalNonAssocRing \u03b1]\n  [OrderedSemiring \u03b2] extends AddGroupSeminormClass F \u03b1 \u03b2, SubmultiplicativeHomClass F \u03b1 \u03b2", "start": [315, 1], "end": [319, 91], "kind": "commanddeclaration"}, {"full_name": "RingNormClass", "code": "class RingNormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [NonUnitalNonAssocRing \u03b1]\n  [OrderedSemiring \u03b2] extends RingSeminormClass F \u03b1 \u03b2, AddGroupNormClass F \u03b1 \u03b2", "start": [322, 1], "end": [326, 79], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminormClass", "code": "class MulRingSeminormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [NonAssocRing \u03b1]\n  [OrderedSemiring \u03b2] extends AddGroupSeminormClass F \u03b1 \u03b2, MonoidWithZeroHomClass F \u03b1 \u03b2", "start": [329, 1], "end": [334, 88], "kind": "commanddeclaration"}, {"full_name": "MulRingNormClass", "code": "class MulRingNormClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [NonAssocRing \u03b1]\n  [OrderedSemiring \u03b2] extends MulRingSeminormClass F \u03b1 \u03b2, AddGroupNormClass F \u03b1 \u03b2", "start": [337, 1], "end": [342, 82], "kind": "commanddeclaration"}, {"full_name": "RingSeminormClass.toNonnegHomClass", "code": "instance (priority := 100) RingSeminormClass.toNonnegHomClass [NonUnitalNonAssocRing \u03b1]\n    [LinearOrderedSemiring \u03b2] [RingSeminormClass F \u03b1 \u03b2] : NonnegHomClass F \u03b1 \u03b2 :=\n  AddGroupSeminormClass.toNonnegHomClass", "start": [347, 1], "end": [349, 41], "kind": "commanddeclaration"}, {"full_name": "MulRingSeminormClass.toRingSeminormClass", "code": "instance (priority := 100) MulRingSeminormClass.toRingSeminormClass [NonAssocRing \u03b1]\n    [OrderedSemiring \u03b2] [MulRingSeminormClass F \u03b1 \u03b2] : RingSeminormClass F \u03b1 \u03b2 :=\n  { \u2039MulRingSeminormClass F \u03b1 \u03b2\u203a with map_mul_le_mul := fun f a b => (map_mul _ _ _).le }", "start": [353, 1], "end": [355, 90], "kind": "commanddeclaration"}, {"full_name": "MulRingNormClass.toRingNormClass", "code": "instance (priority := 100) MulRingNormClass.toRingNormClass [NonAssocRing \u03b1]\n    [OrderedSemiring \u03b2] [MulRingNormClass F \u03b1 \u03b2] : RingNormClass F \u03b1 \u03b2 :=\n  { \u2039MulRingNormClass F \u03b1 \u03b2\u203a, MulRingSeminormClass.toRingSeminormClass with }", "start": [359, 1], "end": [361, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Parity.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Data/Nat/Cast/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSquare", "code": "@[to_additive\n      \"An element `a` of a type `\u03b1` with addition satisfies `Even a` if `a = r + r`,\n      for some `r : \u03b1`.\"]\ndef IsSquare (a : \u03b1) : Prop :=\n  \u2203 r, a = r * r", "start": [44, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "isSquare_mul_self", "code": "@[to_additive (attr := simp)]\ntheorem isSquare_mul_self (m : \u03b1) : IsSquare (m * m)", "start": [54, 1], "end": [56, 11], "kind": "commanddeclaration"}, {"full_name": "isSquare_op_iff", "code": "@[to_additive]\ntheorem isSquare_op_iff (a : \u03b1) : IsSquare (op a) \u2194 IsSquare a", "start": [60, 1], "end": [62, 92], "kind": "commanddeclaration"}, {"full_name": "isSquare_one", "code": "@[to_additive (attr := simp)]\ntheorem isSquare_one [MulOneClass \u03b1] : IsSquare (1 : \u03b1)", "start": [68, 1], "end": [70, 24], "kind": "commanddeclaration"}, {"full_name": "IsSquare.map", "code": "@[to_additive]\ntheorem IsSquare.map [MulOneClass \u03b1] [MulOneClass \u03b2] [MonoidHomClass F \u03b1 \u03b2] {m : \u03b1} (f : F) :\n    IsSquare m \u2192 IsSquare (f m)", "start": [74, 1], "end": [78, 23], "kind": "commanddeclaration"}, {"full_name": "isSquare_iff_exists_sq", "code": "@[to_additive even_iff_exists_two_nsmul]\ntheorem isSquare_iff_exists_sq (m : \u03b1) : IsSquare m \u2194 \u2203 c, m = c ^ 2", "start": [87, 1], "end": [88, 100], "kind": "commanddeclaration"}, {"full_name": "IsSquare.exists_sq", "code": "alias \u27e8IsSquare.exists_sq, isSquare_of_exists_sq\u27e9 := isSquare_iff_exists_sq", "start": [92, 1], "end": [92, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "isSquare_of_exists_sq", "code": "alias \u27e8IsSquare.exists_sq, isSquare_of_exists_sq\u27e9 := isSquare_iff_exists_sq", "start": [92, 1], "end": [92, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsSquare.pow", "code": "@[to_additive]\ntheorem IsSquare.pow (n : \u2115) : IsSquare a \u2192 IsSquare (a ^ n)", "start": [102, 1], "end": [105, 44], "kind": "commanddeclaration"}, {"full_name": "Even.isSquare_pow", "code": "@[to_additive Even.nsmul']\ntheorem Even.isSquare_pow : Even n \u2192 \u2200 a : \u03b1, IsSquare (a ^ n)", "start": [113, 1], "end": [116, 31], "kind": "commanddeclaration"}, {"full_name": "IsSquare_sq", "code": "@[to_additive even_two_nsmul]\ntheorem IsSquare_sq (a : \u03b1) : IsSquare (a ^ 2)", "start": [124, 1], "end": [126, 17], "kind": "commanddeclaration"}, {"full_name": "Even.neg_pow", "code": "@[simp]\ntheorem Even.neg_pow : Even n \u2192 \u2200 a : \u03b1, (-a) ^ n = a ^ n", "start": [132, 1], "end": [135, 39], "kind": "commanddeclaration"}, {"full_name": "Even.neg_one_pow", "code": "theorem Even.neg_one_pow (h : Even n) : (-1 : \u03b1) ^ n = 1", "start": [138, 1], "end": [138, 87], "kind": "commanddeclaration"}, {"full_name": "IsSquare.mul", "code": "@[to_additive]\ntheorem IsSquare.mul [CommSemigroup \u03b1] {a b : \u03b1} : IsSquare a \u2192 IsSquare b \u2192 IsSquare (a * b)", "start": [143, 1], "end": [146, 42], "kind": "commanddeclaration"}, {"full_name": "isSquare_zero", "code": "@[simp]\ntheorem isSquare_zero [MulZeroClass \u03b1] : IsSquare (0 : \u03b1)", "start": [152, 1], "end": [154, 25], "kind": "commanddeclaration"}, {"full_name": "isSquare_inv", "code": "@[to_additive (attr := simp)]\ntheorem isSquare_inv : IsSquare a\u207b\u00b9 \u2194 IsSquare a", "start": [163, 1], "end": [168, 65], "kind": "commanddeclaration"}, {"full_name": "IsSquare.inv", "code": "alias \u27e8_, IsSquare.inv\u27e9 := isSquare_inv", "start": [172, 1], "end": [172, 40], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsSquare.zpow", "code": "@[to_additive]\ntheorem IsSquare.zpow (n : \u2124) : IsSquare a \u2192 IsSquare (a ^ n)", "start": [178, 1], "end": [181, 45], "kind": "commanddeclaration"}, {"full_name": "Even.neg_zpow", "code": "theorem Even.neg_zpow : Even n \u2192 \u2200 a : \u03b1, (-a) ^ n = a ^ n", "start": [187, 1], "end": [189, 26], "kind": "commanddeclaration"}, {"full_name": "Even.neg_one_zpow", "code": "theorem Even.neg_one_zpow (h : Even n) : (-1 : \u03b1) ^ n = 1", "start": [192, 1], "end": [192, 90], "kind": "commanddeclaration"}, {"full_name": "even_abs", "code": "theorem even_abs [SubtractionMonoid \u03b1] [LinearOrder \u03b1] {a : \u03b1} : Even |a| \u2194 Even a", "start": [197, 1], "end": [202, 28], "kind": "commanddeclaration"}, {"full_name": "IsSquare.div", "code": "@[to_additive]\ntheorem IsSquare.div [DivisionCommMonoid \u03b1] {a b : \u03b1} (ha : IsSquare a) (hb : IsSquare b) :\n    IsSquare (a / b)", "start": [205, 1], "end": [209, 22], "kind": "commanddeclaration"}, {"full_name": "Even.isSquare_zpow", "code": "@[to_additive (attr := simp) Even.zsmul']\ntheorem Even.isSquare_zpow [Group \u03b1] {n : \u2124} : Even n \u2192 \u2200 a : \u03b1, IsSquare (a ^ n)", "start": [213, 1], "end": [216, 32], "kind": "commanddeclaration"}, {"full_name": "Even.tsub", "code": "theorem Even.tsub [CanonicallyLinearOrderedAddCommMonoid \u03b1] [Sub \u03b1] [OrderedSub \u03b1]\n    [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {m n : \u03b1} (hm : Even m) (hn : Even n) :\n    Even (m - n)", "start": [221, 1], "end": [229, 40], "kind": "commanddeclaration"}, {"full_name": "even_iff_exists_bit0", "code": "theorem even_iff_exists_bit0 [Add \u03b1] {a : \u03b1} : Even a \u2194 \u2203 b, a = bit0 b", "start": [233, 1], "end": [234, 10], "kind": "commanddeclaration"}, {"full_name": "Even.exists_bit0", "code": "alias \u27e8Even.exists_bit0, _\u27e9 := even_iff_exists_bit0", "start": [237, 1], "end": [237, 52], "kind": "stdtacticaliasaliaslr"}, {"full_name": "even_iff_exists_two_mul", "code": "theorem even_iff_exists_two_mul (m : \u03b1) : Even m \u2194 \u2203 c, m = 2 * c", "start": [244, 1], "end": [245, 35], "kind": "commanddeclaration"}, {"full_name": "even_iff_two_dvd", "code": "theorem even_iff_two_dvd {a : \u03b1} : Even a \u2194 2 \u2223 a", "start": [248, 1], "end": [248, 86], "kind": "commanddeclaration"}, {"full_name": "Even.two_dvd", "code": "alias \u27e8Even.two_dvd, _\u27e9 := even_iff_two_dvd", "start": [251, 1], "end": [251, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Even.trans_dvd", "code": "theorem Even.trans_dvd (hm : Even m) (hn : m \u2223 n) : Even n", "start": [254, 1], "end": [255, 44], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.even", "code": "theorem Dvd.dvd.even (hn : m \u2223 n) (hm : Even m) : Even n", "start": [258, 1], "end": [259, 18], "kind": "commanddeclaration"}, {"full_name": "range_two_mul", "code": "@[simp]\ntheorem range_two_mul (\u03b1) [Semiring \u03b1] : (Set.range fun x : \u03b1 => 2 * x) = { a | Even a }", "start": [262, 1], "end": [265, 32], "kind": "commanddeclaration"}, {"full_name": "even_bit0", "code": "@[simp] theorem even_bit0 (a : \u03b1) : Even (bit0 a)", "start": [269, 1], "end": [270, 11], "kind": "commanddeclaration"}, {"full_name": "even_two", "code": "@[simp]\ntheorem even_two : Even (2 : \u03b1)", "start": [273, 1], "end": [275, 33], "kind": "commanddeclaration"}, {"full_name": "Even.mul_left", "code": "@[simp]\ntheorem Even.mul_left (hm : Even m) (n) : Even (n * m)", "start": [278, 1], "end": [280, 34], "kind": "commanddeclaration"}, {"full_name": "Even.mul_right", "code": "@[simp]\ntheorem Even.mul_right (hm : Even m) (n) : Even (m * n)", "start": [283, 1], "end": [285, 35], "kind": "commanddeclaration"}, {"full_name": "even_two_mul", "code": "theorem even_two_mul (m : \u03b1) : Even (2 * m)", "start": [288, 1], "end": [289, 17], "kind": "commanddeclaration"}, {"full_name": "Even.pow_of_ne_zero", "code": "theorem Even.pow_of_ne_zero (hm : Even m) : \u2200 {a : \u2115}, a \u2260 0 \u2192 Even (m ^ a)", "start": [292, 1], "end": [296, 25], "kind": "commanddeclaration"}, {"full_name": "Odd", "code": "def Odd (a : \u03b1) : Prop :=\n  \u2203 k, a = 2 * k + 1", "start": [301, 1], "end": [303, 21], "kind": "commanddeclaration"}, {"full_name": "odd_iff_exists_bit1", "code": "theorem odd_iff_exists_bit1 {a : \u03b1} : Odd a \u2194 \u2203 b, a = bit1 b", "start": [307, 1], "end": [310, 8], "kind": "commanddeclaration"}, {"full_name": "Odd.exists_bit1", "code": "alias \u27e8Odd.exists_bit1, _\u27e9 := odd_iff_exists_bit1", "start": [313, 1], "end": [313, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "odd_bit1", "code": "@[simp] theorem odd_bit1 (a : \u03b1) : Odd (bit1 a)", "start": [317, 1], "end": [318, 33], "kind": "commanddeclaration"}, {"full_name": "range_two_mul_add_one", "code": "@[simp]\ntheorem range_two_mul_add_one (\u03b1 : Type*) [Semiring \u03b1] :\n    (Set.range fun x : \u03b1 => 2 * x + 1) = { a | Odd a }", "start": [321, 1], "end": [325, 22], "kind": "commanddeclaration"}, {"full_name": "Even.add_odd", "code": "theorem Even.add_odd : Even m \u2192 Odd n \u2192 Odd (m + n)", "start": [328, 1], "end": [330, 55], "kind": "commanddeclaration"}, {"full_name": "Even.odd_add", "code": "theorem Even.odd_add : Even m \u2192 Odd n \u2192 Odd (n + m)", "start": [333, 1], "end": [334, 57], "kind": "commanddeclaration"}, {"full_name": "Odd.add_even", "code": "theorem Odd.add_even (hm : Odd m) (hn : Even n) : Odd (m + n)", "start": [336, 1], "end": [338, 22], "kind": "commanddeclaration"}, {"full_name": "Odd.add_odd", "code": "theorem Odd.add_odd : Odd m \u2192 Odd n \u2192 Even (m + n)", "start": [341, 1], "end": [345, 9], "kind": "commanddeclaration"}, {"full_name": "odd_one", "code": "@[simp]\ntheorem odd_one : Odd (1 : \u03b1)", "start": [348, 1], "end": [350, 75], "kind": "commanddeclaration"}, {"full_name": "Even.add_one", "code": "@[simp] lemma Even.add_one (h : Even m) : Odd (m + 1) := h.add_odd odd_one", "start": [353, 1], "end": [353, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Even.one_add", "code": "@[simp] lemma Even.one_add (h : Even m) : Odd (1 + m) := h.odd_add odd_one", "start": [355, 1], "end": [355, 75], "kind": "mathlibtacticlemma"}, {"full_name": "odd_two_mul_add_one", "code": "theorem odd_two_mul_add_one (m : \u03b1) : Odd (2 * m + 1)", "start": [357, 1], "end": [358, 11], "kind": "commanddeclaration"}, {"full_name": "odd_add_self_one'", "code": "@[simp] lemma odd_add_self_one' : Odd (m + (m + 1)) := by simp [\u2190 add_assoc]", "start": [361, 1], "end": [361, 77], "kind": "mathlibtacticlemma"}, {"full_name": "odd_add_one_self", "code": "@[simp] lemma odd_add_one_self : Odd (m + 1 + m) := by simp [add_comm _ m]", "start": [363, 1], "end": [363, 75], "kind": "mathlibtacticlemma"}, {"full_name": "odd_add_one_self'", "code": "@[simp] lemma odd_add_one_self' : Odd (m + (1 + m)) := by simp [add_comm 1 m]", "start": [365, 1], "end": [365, 78], "kind": "mathlibtacticlemma"}, {"full_name": "one_add_self_self", "code": "@[simp] lemma one_add_self_self : Odd (1 + m + m) := by simp [add_comm 1 m]", "start": [367, 1], "end": [367, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Odd.map", "code": "theorem Odd.map [RingHomClass F \u03b1 \u03b2] (f : F) : Odd m \u2192 Odd (f m)", "start": [369, 1], "end": [371, 33], "kind": "commanddeclaration"}, {"full_name": "Odd.mul", "code": "@[simp]\ntheorem Odd.mul : Odd m \u2192 Odd n \u2192 Odd (m * n)", "start": [374, 1], "end": [379, 37], "kind": "commanddeclaration"}, {"full_name": "Odd.pow", "code": "theorem Odd.pow (hm : Odd m) : \u2200 {a : \u2115}, Odd (m ^ a)", "start": [382, 1], "end": [388, 31], "kind": "commanddeclaration"}, {"full_name": "Odd.neg_pow", "code": "theorem Odd.neg_pow : Odd n \u2192 \u2200 a : \u03b1, (-a) ^ n = -a ^ n", "start": [399, 1], "end": [401, 55], "kind": "commanddeclaration"}, {"full_name": "Odd.neg_one_pow", "code": "@[simp]\ntheorem Odd.neg_one_pow (h : Odd n) : (-1 : \u03b1) ^ n = -1", "start": [404, 1], "end": [405, 86], "kind": "commanddeclaration"}, {"full_name": "Odd.pos", "code": "theorem Odd.pos [Nontrivial \u03b1] {n : \u03b1} (hn : Odd n) : 0 < n", "start": [416, 1], "end": [419, 38], "kind": "commanddeclaration"}, {"full_name": "even_neg_two", "code": "theorem even_neg_two : Even (-2 : \u03b1)", "start": [433, 1], "end": [433, 74], "kind": "commanddeclaration"}, {"full_name": "Odd.neg", "code": "theorem Odd.neg (hp : Odd a) : Odd (-a)", "start": [436, 1], "end": [440, 17], "kind": "commanddeclaration"}, {"full_name": "odd_neg", "code": "@[simp]\ntheorem odd_neg : Odd (-a) \u2194 Odd a", "start": [443, 1], "end": [445, 40], "kind": "commanddeclaration"}, {"full_name": "odd_neg_one", "code": "theorem odd_neg_one : Odd (-1 : \u03b1)", "start": [453, 1], "end": [453, 46], "kind": "commanddeclaration"}, {"full_name": "Odd.sub_even", "code": "theorem Odd.sub_even (ha : Odd a) (hb : Even b) : Odd (a - b)", "start": [456, 1], "end": [458, 27], "kind": "commanddeclaration"}, {"full_name": "Even.sub_odd", "code": "theorem Even.sub_odd (ha : Even a) (hb : Odd b) : Odd (a - b)", "start": [461, 1], "end": [463, 26], "kind": "commanddeclaration"}, {"full_name": "Odd.sub_odd", "code": "theorem Odd.sub_odd (ha : Odd a) (hb : Odd b) : Even (a - b)", "start": [466, 1], "end": [468, 26], "kind": "commanddeclaration"}, {"full_name": "odd_abs", "code": "theorem odd_abs [LinearOrder \u03b1] : Odd (abs a) \u2194 Odd a", "start": [471, 1], "end": [472, 58], "kind": "commanddeclaration"}, {"full_name": "Even.pow_nonneg", "code": "theorem Even.pow_nonneg (hn : Even n) (a : R) : 0 \u2264 a ^ n", "start": [483, 1], "end": [484, 74], "kind": "commanddeclaration"}, {"full_name": "Even.pow_pos", "code": "theorem Even.pow_pos (hn : Even n) (ha : a \u2260 0) : 0 < a ^ n", "start": [487, 1], "end": [488, 72], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_nonpos", "code": "theorem Odd.pow_nonpos (hn : Odd n) (ha : a \u2264 0) : a ^ n \u2264 0", "start": [491, 1], "end": [492, 81], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_neg", "code": "theorem Odd.pow_neg (hn : Odd n) (ha : a < 0) : a ^ n < 0", "start": [495, 1], "end": [496, 78], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_nonneg_iff", "code": "theorem Odd.pow_nonneg_iff (hn : Odd n) : 0 \u2264 a ^ n \u2194 0 \u2264 a", "start": [499, 1], "end": [500, 89], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_nonpos_iff", "code": "theorem Odd.pow_nonpos_iff (hn : Odd n) : a ^ n \u2264 0 \u2194 a \u2264 0", "start": [503, 1], "end": [504, 76], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_pos_iff", "code": "theorem Odd.pow_pos_iff (hn : Odd n) : 0 < a ^ n \u2194 0 < a", "start": [507, 1], "end": [508, 89], "kind": "commanddeclaration"}, {"full_name": "Odd.pow_neg_iff", "code": "theorem Odd.pow_neg_iff (hn : Odd n) : a ^ n < 0 \u2194 a < 0", "start": [511, 1], "end": [512, 76], "kind": "commanddeclaration"}, {"full_name": "Even.pow_pos_iff", "code": "theorem Even.pow_pos_iff (hn : Even n) (h\u2080 : 0 < n) : 0 < a ^ n \u2194 a \u2260 0", "start": [515, 1], "end": [518, 37], "kind": "commanddeclaration"}, {"full_name": "Even.pow_abs", "code": "theorem Even.pow_abs {p : \u2115} (hp : Even p) (a : R) : |a| ^ p = a ^ p", "start": [521, 1], "end": [523, 24], "kind": "commanddeclaration"}, {"full_name": "pow_bit0_abs", "code": "@[simp]\ntheorem pow_bit0_abs (a : R) (p : \u2115) : |a| ^ bit0 p = a ^ bit0 p", "start": [526, 1], "end": [528, 26], "kind": "commanddeclaration"}, {"full_name": "Odd.strictMono_pow", "code": "theorem Odd.strictMono_pow (hn : Odd n) : StrictMono fun a : R => a ^ n", "start": [531, 1], "end": [532, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/SMul.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "Mathlib/Data/Set/Pairwise/Lattice.lean", "Mathlib/Data/Set/Pointwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.smulSet", "code": "@[to_additive\n      \"The translation of set `x +\u1d65 s` is defined as `{x +\u1d65 y | y \u2208 s}` in\n      locale `Pointwise`.\"]\nprotected def smulSet [SMul \u03b1 \u03b2] : SMul \u03b1 (Set \u03b2) :=\n  \u27e8fun a \u21a6 image (a \u2022 \u00b7)\u27e9", "start": [52, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "Set.smul", "code": "@[to_additive\n      \"The pointwise scalar addition of sets `s +\u1d65 t` is defined as\n      `{x +\u1d65 y | x \u2208 s, y \u2208 t}` in locale `Pointwise`.\"]\nprotected def smul [SMul \u03b1 \u03b2] : SMul (Set \u03b1) (Set \u03b2) :=\n  \u27e8image2 (\u00b7 \u2022 \u00b7)\u27e9", "start": [61, 1], "end": [67, 19], "kind": "commanddeclaration"}, {"full_name": "Set.image2_smul", "code": "@[to_additive (attr := simp)]\ntheorem image2_smul : image2 SMul.smul s t = s \u2022 t", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Set.image_smul_prod", "code": "theorem image_smul_prod : (fun x : \u03b1 \u00d7 \u03b2 \u21a6 x.fst \u2022 x.snd) '' s \u00d7\u02e2 t = s \u2022 t", "start": [90, 1], "end": [91, 15], "kind": "commanddeclaration"}, {"full_name": "Set.mem_smul", "code": "@[to_additive]\ntheorem mem_smul : b \u2208 s \u2022 t \u2194 \u2203 x y, x \u2208 s \u2227 y \u2208 t \u2227 x \u2022 y = b", "start": [94, 1], "end": [96, 10], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_smul", "code": "@[to_additive]\ntheorem smul_mem_smul : a \u2208 s \u2192 b \u2208 t \u2192 a \u2022 b \u2208 s \u2022 t", "start": [100, 1], "end": [102, 20], "kind": "commanddeclaration"}, {"full_name": "Set.empty_smul", "code": "@[to_additive (attr := simp)]\ntheorem empty_smul : (\u2205 : Set \u03b1) \u2022 t = \u2205", "start": [106, 1], "end": [108, 20], "kind": "commanddeclaration"}, {"full_name": "Set.smul_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_empty : s \u2022 (\u2205 : Set \u03b2) = \u2205", "start": [112, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "Set.smul_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_eq_empty : s \u2022 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [118, 1], "end": [120, 22], "kind": "commanddeclaration"}, {"full_name": "Set.smul_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem smul_nonempty : (s \u2022 t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [124, 1], "end": [126, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.smul", "code": "@[to_additive]\ntheorem Nonempty.smul : s.Nonempty \u2192 t.Nonempty \u2192 (s \u2022 t).Nonempty", "start": [130, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_smul_left", "code": "@[to_additive]\ntheorem Nonempty.of_smul_left : (s \u2022 t).Nonempty \u2192 s.Nonempty", "start": [136, 1], "end": [138, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_smul_right", "code": "@[to_additive]\ntheorem Nonempty.of_smul_right : (s \u2022 t).Nonempty \u2192 t.Nonempty", "start": [142, 1], "end": [144, 27], "kind": "commanddeclaration"}, {"full_name": "Set.smul_singleton", "code": "@[to_additive (attr := simp low+1)]\ntheorem smul_singleton : s \u2022 ({b} : Set \u03b2) = (\u00b7 \u2022 b) '' s", "start": [148, 1], "end": [150, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_smul", "code": "@[to_additive (attr := simp low+1)]\ntheorem singleton_smul : ({a} : Set \u03b1) \u2022 t = a \u2022 t", "start": [154, 1], "end": [156, 24], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_smul_singleton", "code": "@[to_additive (attr := simp high)]\ntheorem singleton_smul_singleton : ({a} : Set \u03b1) \u2022 ({b} : Set \u03b2) = {a \u2022 b}", "start": [160, 1], "end": [162, 19], "kind": "commanddeclaration"}, {"full_name": "Set.smul_subset_smul", "code": "@[to_additive (attr := mono)]\ntheorem smul_subset_smul : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u2022 t\u2081 \u2286 s\u2082 \u2022 t\u2082", "start": [166, 1], "end": [168, 16], "kind": "commanddeclaration"}, {"full_name": "Set.smul_subset_smul_left", "code": "@[to_additive]\ntheorem smul_subset_smul_left : t\u2081 \u2286 t\u2082 \u2192 s \u2022 t\u2081 \u2286 s \u2022 t\u2082", "start": [172, 1], "end": [174, 21], "kind": "commanddeclaration"}, {"full_name": "Set.smul_subset_smul_right", "code": "@[to_additive]\ntheorem smul_subset_smul_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u2022 t \u2286 s\u2082 \u2022 t", "start": [178, 1], "end": [180, 22], "kind": "commanddeclaration"}, {"full_name": "Set.smul_subset_iff", "code": "@[to_additive]\ntheorem smul_subset_iff : s \u2022 t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2022 b \u2208 u", "start": [184, 1], "end": [186, 20], "kind": "commanddeclaration"}, {"full_name": "Set.union_smul", "code": "@[to_additive]\ntheorem union_smul : (s\u2081 \u222a s\u2082) \u2022 t = s\u2081 \u2022 t \u222a s\u2082 \u2022 t", "start": [191, 1], "end": [193, 20], "kind": "commanddeclaration"}, {"full_name": "Set.smul_union", "code": "@[to_additive]\ntheorem smul_union : s \u2022 (t\u2081 \u222a t\u2082) = s \u2022 t\u2081 \u222a s \u2022 t\u2082", "start": [197, 1], "end": [199, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_smul_subset", "code": "@[to_additive]\ntheorem inter_smul_subset : (s\u2081 \u2229 s\u2082) \u2022 t \u2286 s\u2081 \u2022 t \u2229 s\u2082 \u2022 t", "start": [203, 1], "end": [205, 27], "kind": "commanddeclaration"}, {"full_name": "Set.smul_inter_subset", "code": "@[to_additive]\ntheorem smul_inter_subset : s \u2022 (t\u2081 \u2229 t\u2082) \u2286 s \u2022 t\u2081 \u2229 s \u2022 t\u2082", "start": [209, 1], "end": [211, 28], "kind": "commanddeclaration"}, {"full_name": "Set.inter_smul_union_subset_union", "code": "@[to_additive]\ntheorem inter_smul_union_subset_union : (s\u2081 \u2229 s\u2082) \u2022 (t\u2081 \u222a t\u2082) \u2286 s\u2081 \u2022 t\u2081 \u222a s\u2082 \u2022 t\u2082", "start": [215, 1], "end": [217, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_smul_inter_subset_union", "code": "@[to_additive]\ntheorem union_smul_inter_subset_union : (s\u2081 \u222a s\u2082) \u2022 (t\u2081 \u2229 t\u2082) \u2286 s\u2081 \u2022 t\u2081 \u222a s\u2082 \u2022 t\u2082", "start": [221, 1], "end": [223, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_smul_left_image", "code": "@[to_additive]\ntheorem iUnion_smul_left_image : \u22c3 a \u2208 s, a \u2022 t = s \u2022 t", "start": [227, 1], "end": [229, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_smul_right_image", "code": "@[to_additive]\ntheorem iUnion_smul_right_image : \u22c3 a \u2208 t, (\u00b7 \u2022 a) '' s = s \u2022 t", "start": [233, 1], "end": [235, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_smul", "code": "@[to_additive]\ntheorem iUnion_smul (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) : (\u22c3 i, s i) \u2022 t = \u22c3 i, s i \u2022 t", "start": [239, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "Set.smul_iUnion", "code": "@[to_additive]\ntheorem smul_iUnion (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) : (s \u2022 \u22c3 i, t i) = \u22c3 i, s \u2022 t i", "start": [245, 1], "end": [247, 28], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_smul", "code": "@[to_additive]\ntheorem iUnion\u2082_smul (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    (\u22c3 (i) (j), s i j) \u2022 t = \u22c3 (i) (j), s i j \u2022 t", "start": [251, 1], "end": [254, 28], "kind": "commanddeclaration"}, {"full_name": "Set.smul_iUnion\u2082", "code": "@[to_additive]\ntheorem smul_iUnion\u2082 (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (s \u2022 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s \u2022 t i j", "start": [258, 1], "end": [261, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_smul_subset", "code": "@[to_additive]\ntheorem iInter_smul_subset (s : \u03b9 \u2192 Set \u03b1) (t : Set \u03b2) : (\u22c2 i, s i) \u2022 t \u2286 \u22c2 i, s i \u2022 t", "start": [265, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "Set.smul_iInter_subset", "code": "@[to_additive]\ntheorem smul_iInter_subset (s : Set \u03b1) (t : \u03b9 \u2192 Set \u03b2) : (s \u2022 \u22c2 i, t i) \u2286 \u22c2 i, s \u2022 t i", "start": [271, 1], "end": [273, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_smul_subset", "code": "@[to_additive]\ntheorem iInter\u2082_smul_subset (s : \u2200 i, \u03ba i \u2192 Set \u03b1) (t : Set \u03b2) :\n    (\u22c2 (i) (j), s i j) \u2022 t \u2286 \u22c2 (i) (j), s i j \u2022 t", "start": [277, 1], "end": [280, 35], "kind": "commanddeclaration"}, {"full_name": "Set.smul_iInter\u2082_subset", "code": "@[to_additive]\ntheorem smul_iInter\u2082_subset (s : Set \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (s \u2022 \u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), s \u2022 t i j", "start": [284, 1], "end": [287, 36], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_subset_smul", "code": "@[to_additive]\ntheorem smul_set_subset_smul {s : Set \u03b1} : a \u2208 s \u2192 a \u2022 t \u2286 s \u2022 t", "start": [291, 1], "end": [293, 28], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_smul_set", "code": "@[to_additive (attr := simp)]\ntheorem iUnion_smul_set (s : Set \u03b1) (t : Set \u03b2) : \u22c3 a \u2208 s, a \u2022 t = s \u2022 t", "start": [297, 1], "end": [299, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_smul", "code": "@[to_additive]\ntheorem image_smul : (fun x \u21a6 a \u2022 x) '' t = a \u2022 t", "start": [309, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_smul_set", "code": "@[to_additive]\ntheorem mem_smul_set : x \u2208 a \u2022 t \u2194 \u2203 y, y \u2208 t \u2227 a \u2022 y = x", "start": [317, 1], "end": [319, 10], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_smul_set", "code": "@[to_additive]\ntheorem smul_mem_smul_set : b \u2208 s \u2192 a \u2022 b \u2208 a \u2022 s", "start": [323, 1], "end": [325, 21], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_set_empty : a \u2022 (\u2205 : Set \u03b2) = \u2205", "start": [329, 1], "end": [331, 16], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_set_eq_empty : a \u2022 s = \u2205 \u2194 s = \u2205", "start": [335, 1], "end": [337, 17], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem smul_set_nonempty : (a \u2022 s).Nonempty \u2194 s.Nonempty", "start": [341, 1], "end": [343, 21], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_singleton", "code": "@[to_additive (attr := simp)]\ntheorem smul_set_singleton : a \u2022 ({b} : Set \u03b2) = {a \u2022 b}", "start": [347, 1], "end": [349, 18], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_mono", "code": "@[to_additive]\ntheorem smul_set_mono : s \u2286 t \u2192 a \u2022 s \u2286 a \u2022 t", "start": [353, 1], "end": [355, 17], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_subset_iff", "code": "@[to_additive]\ntheorem smul_set_subset_iff : a \u2022 s \u2286 t \u2194 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2022 b \u2208 t", "start": [359, 1], "end": [361, 19], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_union", "code": "@[to_additive]\ntheorem smul_set_union : a \u2022 (t\u2081 \u222a t\u2082) = a \u2022 t\u2081 \u222a a \u2022 t\u2082", "start": [365, 1], "end": [367, 20], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_inter_subset", "code": "@[to_additive]\ntheorem smul_set_inter_subset : a \u2022 (t\u2081 \u2229 t\u2082) \u2286 a \u2022 t\u2081 \u2229 a \u2022 t\u2082", "start": [371, 1], "end": [373, 27], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_iUnion", "code": "@[to_additive]\ntheorem smul_set_iUnion (a : \u03b1) (s : \u03b9 \u2192 Set \u03b2) : (a \u2022 \u22c3 i, s i) = \u22c3 i, a \u2022 s i", "start": [377, 1], "end": [379, 15], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_iUnion\u2082", "code": "@[to_additive]\ntheorem smul_set_iUnion\u2082 (a : \u03b1) (s : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (a \u2022 \u22c3 (i) (j), s i j) = \u22c3 (i) (j), a \u2022 s i j", "start": [383, 1], "end": [386, 20], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_iInter_subset", "code": "@[to_additive]\ntheorem smul_set_iInter_subset (a : \u03b1) (t : \u03b9 \u2192 Set \u03b2) : (a \u2022 \u22c2 i, t i) \u2286 \u22c2 i, a \u2022 t i", "start": [390, 1], "end": [392, 26], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_iInter\u2082_subset", "code": "@[to_additive]\ntheorem smul_set_iInter\u2082_subset (a : \u03b1) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (a \u2022 \u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), a \u2022 t i j", "start": [396, 1], "end": [399, 27], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.smul_set", "code": "@[to_additive]\ntheorem Nonempty.smul_set : s.Nonempty \u2192 (a \u2022 s).Nonempty", "start": [403, 1], "end": [405, 19], "kind": "commanddeclaration"}, {"full_name": "Set.op_smul_set_subset_mul", "code": "@[to_additive]\ntheorem op_smul_set_subset_mul : a \u2208 t \u2192 op a \u2022 s \u2286 s * t", "start": [415, 1], "end": [417, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_op_smul", "code": "@[to_additive]\ntheorem image_op_smul : (op '' s) \u2022 t = t * s", "start": [421, 1], "end": [424, 6], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_op_smul_set", "code": "@[to_additive (attr := simp)]\ntheorem iUnion_op_smul_set (s t : Set \u03b1) : \u22c3 a \u2208 t, MulOpposite.op a \u2022 s = s * t", "start": [426, 1], "end": [428, 23], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_iff_left", "code": "@[to_additive]\ntheorem mul_subset_iff_left : s * t \u2286 u \u2194 \u2200 a \u2208 s, a \u2022 t \u2286 u", "start": [432, 1], "end": [434, 25], "kind": "commanddeclaration"}, {"full_name": "Set.mul_subset_iff_right", "code": "@[to_additive]\ntheorem mul_subset_iff_right : s * t \u2286 u \u2194 \u2200 b \u2208 t, op b \u2022 s \u2286 u", "start": [438, 1], "end": [440, 26], "kind": "commanddeclaration"}, {"full_name": "Set.range_smul_range", "code": "@[to_additive]\ntheorem range_smul_range {\u03b9 \u03ba : Type*} [SMul \u03b1 \u03b2] (b : \u03b9 \u2192 \u03b1) (c : \u03ba \u2192 \u03b2) :\n    range b \u2022 range c = range fun p : \u03b9 \u00d7 \u03ba \u21a6 b p.1 \u2022 c p.2", "start": [448, 1], "end": [455, 74], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_range", "code": "@[to_additive]\ntheorem smul_set_range [SMul \u03b1 \u03b2] {\u03b9 : Sort*} {f : \u03b9 \u2192 \u03b2} :\n    a \u2022 range f = range fun i \u21a6 a \u2022 f i", "start": [459, 1], "end": [462, 24], "kind": "commanddeclaration"}, {"full_name": "Set.smulCommClass_set", "code": "@[to_additive]\ninstance smulCommClass_set [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 \u03b2 (Set \u03b3) :=\n  \u27e8fun _ _ \u21a6 Commute.set_image <| smul_comm _ _\u27e9", "start": [466, 1], "end": [469, 49], "kind": "commanddeclaration"}, {"full_name": "Set.smulCommClass_set'", "code": "@[to_additive]\ninstance smulCommClass_set' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 (Set \u03b2) (Set \u03b3) :=\n  \u27e8fun _ _ _ \u21a6 image_image2_distrib_right <| smul_comm _\u27e9", "start": [473, 1], "end": [476, 58], "kind": "commanddeclaration"}, {"full_name": "Set.smulCommClass_set''", "code": "@[to_additive]\ninstance smulCommClass_set'' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Set \u03b1) \u03b2 (Set \u03b3) :=\n  haveI := SMulCommClass.symm \u03b1 \u03b2 \u03b3\n  SMulCommClass.symm _ _ _", "start": [480, 1], "end": [484, 27], "kind": "commanddeclaration"}, {"full_name": "Set.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Set \u03b1) (Set \u03b2) (Set \u03b3) :=\n  \u27e8fun _ _ _ \u21a6 image2_left_comm smul_comm\u27e9", "start": [488, 1], "end": [491, 43], "kind": "commanddeclaration"}, {"full_name": "Set.isScalarTower", "code": "@[to_additive vAddAssocClass]\ninstance isScalarTower [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 \u03b2 (Set \u03b3) where\n  smul_assoc a b T := by simp only [\u2190 image_smul, image_image, smul_assoc]", "start": [495, 1], "end": [498, 75], "kind": "commanddeclaration"}, {"full_name": "Set.isScalarTower'", "code": "@[to_additive vAddAssocClass']\ninstance isScalarTower' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 (Set \u03b2) (Set \u03b3) :=\n  \u27e8fun _ _ _ \u21a6 image2_image_left_comm <| smul_assoc _\u27e9", "start": [502, 1], "end": [505, 55], "kind": "commanddeclaration"}, {"full_name": "Set.isScalarTower''", "code": "@[to_additive vAddAssocClass'']\ninstance isScalarTower'' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower (Set \u03b1) (Set \u03b2) (Set \u03b3) where\n  smul_assoc _ _ _ := image2_assoc smul_assoc", "start": [509, 1], "end": [512, 46], "kind": "commanddeclaration"}, {"full_name": "Set.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar [SMul \u03b1 \u03b2] [SMul \u03b1\u1d50\u1d52\u1d56 \u03b2] [IsCentralScalar \u03b1 \u03b2] :\n    IsCentralScalar \u03b1 (Set \u03b2) :=\n  \u27e8fun _ S \u21a6 (congr_arg fun f \u21a6 f '' S) <| funext fun _ \u21a6 op_smul_eq_smul _ _\u27e9", "start": [516, 1], "end": [519, 79], "kind": "commanddeclaration"}, {"full_name": "Set.mulAction", "code": "@[to_additive\n      \"An additive action of an additive monoid `\u03b1` on a type `\u03b2` gives an additive action of\n      `Set \u03b1` on `Set \u03b2`\"]\nprotected def mulAction [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction (Set \u03b1) (Set \u03b2) where\n  mul_smul _ _ _ := image2_assoc mul_smul\n  one_smul s := image2_singleton_left.trans <| by simp_rw [one_smul, image_id']", "start": [523, 1], "end": [530, 80], "kind": "commanddeclaration"}, {"full_name": "Set.mulActionSet", "code": "@[to_additive\n      \"An additive action of an additive monoid on a type `\u03b2` gives an additive action on `Set \u03b2`.\"]\nprotected def mulActionSet [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction \u03b1 (Set \u03b2) where\n  mul_smul := by\n    intros\n    simp only [\u2190 image_smul, image_image, \u2190 mul_smul]\n  one_smul := by\n    intros\n    simp only [\u2190 image_smul, one_smul, image_id']", "start": [534, 1], "end": [543, 50], "kind": "commanddeclaration"}, {"full_name": "Set.distribMulActionSet", "code": "protected def distribMulActionSet [Monoid \u03b1] [AddMonoid \u03b2] [DistribMulAction \u03b1 \u03b2] :\n    DistribMulAction \u03b1 (Set \u03b2) where\n  smul_add _ _ _ := image_image2_distrib <| smul_add _\n  smul_zero _ := image_singleton.trans <| by rw [smul_zero, singleton_zero]", "start": [549, 1], "end": [554, 76], "kind": "commanddeclaration"}, {"full_name": "Set.mulDistribMulActionSet", "code": "protected def mulDistribMulActionSet [Monoid \u03b1] [Monoid \u03b2] [MulDistribMulAction \u03b1 \u03b2] :\n    MulDistribMulAction \u03b1 (Set \u03b2) where\n  smul_mul _ _ _ := image_image2_distrib <| smul_mul' _\n  smul_one _ := image_singleton.trans <| by rw [smul_one, singleton_one]", "start": [557, 1], "end": [561, 73], "kind": "commanddeclaration"}, {"full_name": "Set.noZeroSMulDivisors_set", "code": "instance noZeroSMulDivisors_set [Zero \u03b1] [Zero \u03b2] [SMul \u03b1 \u03b2] [NoZeroSMulDivisors \u03b1 \u03b2] :\n    NoZeroSMulDivisors \u03b1 (Set \u03b2) :=\n  \u27e8fun {a s} h \u21a6 by\n    by_contra' H\n    have hst : (a \u2022 s).Nonempty := h.symm.subst zero_nonempty\n    rw [Ne.def, Ne.def, \u2190 hst.of_image.subset_zero_iff, not_subset] at H\n    obtain \u27e8ha, b, ht, hb\u27e9 := H\n    exact (eq_zero_or_eq_zero_of_smul_eq_zero <| h.subset <| smul_mem_smul_set ht).elim ha hb\u27e9", "start": [577, 1], "end": [584, 95], "kind": "commanddeclaration"}, {"full_name": "Set.vsub", "code": "instance vsub : VSub (Set \u03b1) (Set \u03b2) :=\n  \u27e8image2 (\u00b7 -\u1d65 \u00b7)\u27e9", "start": [597, 1], "end": [598, 20], "kind": "commanddeclaration"}, {"full_name": "Set.image2_vsub", "code": "@[simp]\ntheorem image2_vsub : (image2 VSub.vsub s t : Set \u03b1) = s -\u1d65 t", "start": [601, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "Set.image_vsub_prod", "code": "theorem image_vsub_prod : (fun x : \u03b2 \u00d7 \u03b2 \u21a6 x.fst -\u1d65 x.snd) '' s \u00d7\u02e2 t = s -\u1d65 t", "start": [606, 1], "end": [607, 15], "kind": "commanddeclaration"}, {"full_name": "Set.mem_vsub", "code": "theorem mem_vsub : a \u2208 s -\u1d65 t \u2194 \u2203 x y, x \u2208 s \u2227 y \u2208 t \u2227 x -\u1d65 y = a", "start": [610, 1], "end": [611, 10], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_mem_vsub", "code": "theorem vsub_mem_vsub (hb : b \u2208 s) (hc : c \u2208 t) : b -\u1d65 c \u2208 s -\u1d65 t", "start": [614, 1], "end": [615, 26], "kind": "commanddeclaration"}, {"full_name": "Set.empty_vsub", "code": "@[simp]\ntheorem empty_vsub (t : Set \u03b2) : \u2205 -\u1d65 t = \u2205", "start": [618, 1], "end": [620, 20], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_empty", "code": "@[simp]\ntheorem vsub_empty (s : Set \u03b2) : s -\u1d65 \u2205 = \u2205", "start": [623, 1], "end": [625, 21], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_eq_empty", "code": "@[simp]\ntheorem vsub_eq_empty : s -\u1d65 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [628, 1], "end": [630, 22], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_nonempty", "code": "@[simp]\ntheorem vsub_nonempty : (s -\u1d65 t : Set \u03b1).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [633, 1], "end": [635, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.vsub", "code": "theorem Nonempty.vsub : s.Nonempty \u2192 t.Nonempty \u2192 (s -\u1d65 t : Set \u03b1).Nonempty", "start": [638, 1], "end": [639, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_vsub_left", "code": "theorem Nonempty.of_vsub_left : (s -\u1d65 t : Set \u03b1).Nonempty \u2192 s.Nonempty", "start": [642, 1], "end": [643, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.of_vsub_right", "code": "theorem Nonempty.of_vsub_right : (s -\u1d65 t : Set \u03b1).Nonempty \u2192 t.Nonempty", "start": [646, 1], "end": [647, 27], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_singleton", "code": "@[simp low+1]\ntheorem vsub_singleton (s : Set \u03b2) (b : \u03b2) : s -\u1d65 {b} = (\u00b7 -\u1d65 b) '' s", "start": [650, 1], "end": [652, 25], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_vsub", "code": "@[simp low+1]\ntheorem singleton_vsub (t : Set \u03b2) (b : \u03b2) : {b} -\u1d65 t = (\u00b7 -\u1d65 \u00b7) b '' t", "start": [655, 1], "end": [657, 24], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_vsub_singleton", "code": "@[simp high]\ntheorem singleton_vsub_singleton : ({b} : Set \u03b2) -\u1d65 {c} = {b -\u1d65 c}", "start": [660, 1], "end": [662, 19], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_subset_vsub", "code": "@[mono]\ntheorem vsub_subset_vsub : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 -\u1d65 t\u2081 \u2286 s\u2082 -\u1d65 t\u2082", "start": [665, 1], "end": [667, 16], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_subset_vsub_left", "code": "theorem vsub_subset_vsub_left : t\u2081 \u2286 t\u2082 \u2192 s -\u1d65 t\u2081 \u2286 s -\u1d65 t\u2082", "start": [670, 1], "end": [671, 21], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_subset_vsub_right", "code": "theorem vsub_subset_vsub_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 -\u1d65 t \u2286 s\u2082 -\u1d65 t", "start": [674, 1], "end": [675, 22], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_subset_iff", "code": "theorem vsub_subset_iff : s -\u1d65 t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x -\u1d65 y \u2208 u", "start": [678, 1], "end": [679, 20], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_self_mono", "code": "theorem vsub_self_mono (h : s \u2286 t) : s -\u1d65 s \u2286 t -\u1d65 t", "start": [682, 1], "end": [683, 23], "kind": "commanddeclaration"}, {"full_name": "Set.union_vsub", "code": "theorem union_vsub : s\u2081 \u222a s\u2082 -\u1d65 t = s\u2081 -\u1d65 t \u222a (s\u2082 -\u1d65 t)", "start": [686, 1], "end": [687, 20], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_union", "code": "theorem vsub_union : s -\u1d65 (t\u2081 \u222a t\u2082) = s -\u1d65 t\u2081 \u222a (s -\u1d65 t\u2082)", "start": [690, 1], "end": [691, 21], "kind": "commanddeclaration"}, {"full_name": "Set.inter_vsub_subset", "code": "theorem inter_vsub_subset : s\u2081 \u2229 s\u2082 -\u1d65 t \u2286 (s\u2081 -\u1d65 t) \u2229 (s\u2082 -\u1d65 t)", "start": [694, 1], "end": [695, 27], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_inter_subset", "code": "theorem vsub_inter_subset : s -\u1d65 t\u2081 \u2229 t\u2082 \u2286 (s -\u1d65 t\u2081) \u2229 (s -\u1d65 t\u2082)", "start": [698, 1], "end": [699, 28], "kind": "commanddeclaration"}, {"full_name": "Set.inter_vsub_union_subset_union", "code": "theorem inter_vsub_union_subset_union : s\u2081 \u2229 s\u2082 -\u1d65 (t\u2081 \u222a t\u2082) \u2286 s\u2081 -\u1d65 t\u2081 \u222a (s\u2082 -\u1d65 t\u2082)", "start": [702, 1], "end": [703, 34], "kind": "commanddeclaration"}, {"full_name": "Set.union_vsub_inter_subset_union", "code": "theorem union_vsub_inter_subset_union : s\u2081 \u222a s\u2082 -\u1d65 t\u2081 \u2229 t\u2082 \u2286 s\u2081 -\u1d65 t\u2081 \u222a (s\u2082 -\u1d65 t\u2082)", "start": [706, 1], "end": [707, 34], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_vsub_left_image", "code": "theorem iUnion_vsub_left_image : \u22c3 a \u2208 s, (\u00b7 -\u1d65 \u00b7) a '' t = s -\u1d65 t", "start": [710, 1], "end": [711, 22], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_vsub_right_image", "code": "theorem iUnion_vsub_right_image : \u22c3 a \u2208 t, (\u00b7 -\u1d65 a) '' s = s -\u1d65 t", "start": [714, 1], "end": [715, 23], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_vsub", "code": "theorem iUnion_vsub (s : \u03b9 \u2192 Set \u03b2) (t : Set \u03b2) : (\u22c3 i, s i) -\u1d65 t = \u22c3 i, s i -\u1d65 t", "start": [718, 1], "end": [719, 27], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_iUnion", "code": "theorem vsub_iUnion (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s -\u1d65 \u22c3 i, t i) = \u22c3 i, s -\u1d65 t i", "start": [722, 1], "end": [723, 28], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion\u2082_vsub", "code": "theorem iUnion\u2082_vsub (s : \u2200 i, \u03ba i \u2192 Set \u03b2) (t : Set \u03b2) :\n    (\u22c3 (i) (j), s i j) -\u1d65 t = \u22c3 (i) (j), s i j -\u1d65 t", "start": [726, 1], "end": [728, 28], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_iUnion\u2082", "code": "theorem vsub_iUnion\u2082 (s : Set \u03b2) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (s -\u1d65 \u22c3 (i) (j), t i j) = \u22c3 (i) (j), s -\u1d65 t i j", "start": [731, 1], "end": [733, 29], "kind": "commanddeclaration"}, {"full_name": "Set.iInter_vsub_subset", "code": "theorem iInter_vsub_subset (s : \u03b9 \u2192 Set \u03b2) (t : Set \u03b2) : (\u22c2 i, s i) -\u1d65 t \u2286 \u22c2 i, s i -\u1d65 t", "start": [736, 1], "end": [737, 34], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_iInter_subset", "code": "theorem vsub_iInter_subset (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s -\u1d65 \u22c2 i, t i) \u2286 \u22c2 i, s -\u1d65 t i", "start": [740, 1], "end": [741, 35], "kind": "commanddeclaration"}, {"full_name": "Set.iInter\u2082_vsub_subset", "code": "theorem iInter\u2082_vsub_subset (s : \u2200 i, \u03ba i \u2192 Set \u03b2) (t : Set \u03b2) :\n    (\u22c2 (i) (j), s i j) -\u1d65 t \u2286 \u22c2 (i) (j), s i j -\u1d65 t", "start": [744, 1], "end": [746, 35], "kind": "commanddeclaration"}, {"full_name": "Set.vsub_iInter\u2082_subset", "code": "theorem vsub_iInter\u2082_subset (s : Set \u03b2) (t : \u2200 i, \u03ba i \u2192 Set \u03b2) :\n    (s -\u1d65 \u22c2 (i) (j), t i j) \u2286 \u22c2 (i) (j), s -\u1d65 t i j", "start": [749, 1], "end": [751, 36], "kind": "commanddeclaration"}, {"full_name": "Set.image_smul_comm", "code": "@[to_additive]\ntheorem image_smul_comm [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] (f : \u03b2 \u2192 \u03b3) (a : \u03b1) (s : Set \u03b2) :\n    (\u2200 b, f (a \u2022 b) = a \u2022 f b) \u2192 f '' (a \u2022 s) = a \u2022 f '' s", "start": [758, 1], "end": [761, 13], "kind": "commanddeclaration"}, {"full_name": "Set.image_smul_distrib", "code": "@[to_additive]\ntheorem image_smul_distrib [MulOneClass \u03b1] [MulOneClass \u03b2] [MonoidHomClass F \u03b1 \u03b2] (f : F) (a : \u03b1)\n    (s : Set \u03b1) : f '' (a \u2022 s) = f a \u2022 f '' s", "start": [765, 1], "end": [768, 28], "kind": "commanddeclaration"}, {"full_name": "Set.op_smul_set_smul_eq_smul_smul_set", "code": "@[to_additive]\ntheorem op_smul_set_smul_eq_smul_smul_set (a : \u03b1) (s : Set \u03b2) (t : Set \u03b3)\n    (h : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), (op a \u2022 b) \u2022 c = b \u2022 a \u2022 c) : (op a \u2022 s) \u2022 t = s \u2022 a \u2022 t", "start": [777, 1], "end": [781, 35], "kind": "commanddeclaration"}, {"full_name": "Set.smul_zero_subset", "code": "theorem smul_zero_subset (s : Set \u03b1) : s \u2022 (0 : Set \u03b2) \u2286 0", "start": [797, 1], "end": [797, 93], "kind": "commanddeclaration"}, {"full_name": "Set.zero_smul_subset", "code": "theorem zero_smul_subset (t : Set \u03b2) : (0 : Set \u03b1) \u2022 t \u2286 0", "start": [800, 1], "end": [800, 93], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.smul_zero", "code": "theorem Nonempty.smul_zero (hs : s.Nonempty) : s \u2022 (0 : Set \u03b2) = 0", "start": [803, 1], "end": [804, 62], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.zero_smul", "code": "theorem Nonempty.zero_smul (ht : t.Nonempty) : (0 : Set \u03b1) \u2022 t = 0", "start": [807, 1], "end": [808, 62], "kind": "commanddeclaration"}, {"full_name": "Set.zero_smul_set", "code": "theorem zero_smul_set {s : Set \u03b2} (h : s.Nonempty) : (0 : \u03b1) \u2022 s = (0 : Set \u03b2)", "start": [811, 1], "end": [813, 80], "kind": "commanddeclaration"}, {"full_name": "Set.zero_smul_set_subset", "code": "theorem zero_smul_set_subset (s : Set \u03b2) : (0 : \u03b1) \u2022 s \u2286 0", "start": [816, 1], "end": [817, 45], "kind": "commanddeclaration"}, {"full_name": "Set.subsingleton_zero_smul_set", "code": "theorem subsingleton_zero_smul_set (s : Set \u03b2) : ((0 : \u03b1) \u2022 s).Subsingleton", "start": [820, 1], "end": [821, 56], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mem_smul_set", "code": "theorem zero_mem_smul_set {t : Set \u03b2} {a : \u03b1} (h : (0 : \u03b2) \u2208 t) : (0 : \u03b2) \u2208 a \u2022 t", "start": [824, 1], "end": [825, 22], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mem_smul_iff", "code": "theorem zero_mem_smul_iff :\n    (0 : \u03b2) \u2208 s \u2022 t \u2194 (0 : \u03b1) \u2208 s \u2227 t.Nonempty \u2228 (0 : \u03b2) \u2208 t \u2227 s.Nonempty", "start": [830, 1], "end": [839, 40], "kind": "commanddeclaration"}, {"full_name": "Set.zero_mem_smul_set_iff", "code": "theorem zero_mem_smul_set_iff (ha : a \u2260 0) : (0 : \u03b2) \u2208 a \u2022 t \u2194 (0 : \u03b2) \u2208 t", "start": [842, 1], "end": [845, 69], "kind": "commanddeclaration"}, {"full_name": "Set.op_smul_set_mul_eq_mul_smul_set", "code": "@[to_additive]\ntheorem op_smul_set_mul_eq_mul_smul_set (a : \u03b1) (s : Set \u03b1) (t : Set \u03b1) :\n    op a \u2022 s * t = s * a \u2022 t", "start": [854, 1], "end": [857, 71], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_smul_iff", "code": "@[to_additive]\ntheorem pairwiseDisjoint_smul_iff :\n    s.PairwiseDisjoint (\u00b7 \u2022 t) \u2194 (s \u00d7\u02e2 t).InjOn fun p \u21a6 p.1 * p.2", "start": [867, 1], "end": [870, 67], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_smul_set_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_mem_smul_set_iff : a \u2022 x \u2208 a \u2022 s \u2194 x \u2208 s", "start": [880, 1], "end": [882, 40], "kind": "commanddeclaration"}, {"full_name": "Set.mem_smul_set_iff_inv_smul_mem", "code": "@[to_additive]\ntheorem mem_smul_set_iff_inv_smul_mem : x \u2208 a \u2022 A \u2194 a\u207b\u00b9 \u2022 x \u2208 A", "start": [886, 1], "end": [888, 60], "kind": "commanddeclaration"}, {"full_name": "Set.mem_inv_smul_set_iff", "code": "@[to_additive]\ntheorem mem_inv_smul_set_iff : x \u2208 a\u207b\u00b9 \u2022 A \u2194 a \u2022 x \u2208 A", "start": [892, 1], "end": [894, 72], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_smul", "code": "@[to_additive]\ntheorem preimage_smul (a : \u03b1) (t : Set \u03b2) : (fun x \u21a6 a \u2022 x) \u207b\u00b9' t = a\u207b\u00b9 \u2022 t", "start": [898, 1], "end": [900, 55], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_smul_inv", "code": "@[to_additive]\ntheorem preimage_smul_inv (a : \u03b1) (t : Set \u03b2) : (fun x \u21a6 a\u207b\u00b9 \u2022 x) \u207b\u00b9' t = a \u2022 t", "start": [904, 1], "end": [906, 32], "kind": "commanddeclaration"}, {"full_name": "Set.set_smul_subset_set_smul_iff", "code": "@[to_additive (attr := simp)]\ntheorem set_smul_subset_set_smul_iff : a \u2022 A \u2286 a \u2022 B \u2194 A \u2286 B", "start": [910, 1], "end": [912, 50], "kind": "commanddeclaration"}, {"full_name": "Set.set_smul_subset_iff", "code": "@[to_additive]\ntheorem set_smul_subset_iff : a \u2022 A \u2286 B \u2194 A \u2286 a\u207b\u00b9 \u2022 B", "start": [916, 1], "end": [919, 85], "kind": "commanddeclaration"}, {"full_name": "Set.subset_set_smul_iff", "code": "@[to_additive]\ntheorem subset_set_smul_iff : A \u2286 a \u2022 B \u2194 a\u207b\u00b9 \u2022 A \u2286 B", "start": [923, 1], "end": [927, 99], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_inter", "code": "@[to_additive]\ntheorem smul_set_inter : a \u2022 (s \u2229 t) = a \u2022 s \u2229 a \u2022 t", "start": [931, 1], "end": [933, 39], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_sdiff", "code": "@[to_additive]\ntheorem smul_set_sdiff : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t", "start": [937, 1], "end": [939, 41], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_symmDiff", "code": "@[to_additive]\ntheorem smul_set_symmDiff : a \u2022 s \u2206 t = (a \u2022 s) \u2206 (a \u2022 t)", "start": [943, 1], "end": [945, 45], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_univ", "code": "@[to_additive (attr := simp)]\ntheorem smul_set_univ : a \u2022 (univ : Set \u03b2) = univ", "start": [949, 1], "end": [951, 53], "kind": "commanddeclaration"}, {"full_name": "Set.smul_univ", "code": "@[to_additive (attr := simp)]\ntheorem smul_univ {s : Set \u03b1} (hs : s.Nonempty) : s \u2022 (univ : Set \u03b2) = univ", "start": [955, 1], "end": [958, 73], "kind": "commanddeclaration"}, {"full_name": "Set.smul_inter_ne_empty_iff", "code": "@[to_additive]\ntheorem smul_inter_ne_empty_iff {s t : Set \u03b1} {x : \u03b1} :\n    x \u2022 s \u2229 t \u2260 \u2205 \u2194 \u2203 a b, (a \u2208 t \u2227 b \u2208 s) \u2227 a * b\u207b\u00b9 = x", "start": [962, 1], "end": [971, 64], "kind": "commanddeclaration"}, {"full_name": "Set.smul_inter_ne_empty_iff'", "code": "@[to_additive]\ntheorem smul_inter_ne_empty_iff' {s t : Set \u03b1} {x : \u03b1} :\n    x \u2022 s \u2229 t \u2260 \u2205 \u2194 \u2203 a b, (a \u2208 t \u2227 b \u2208 s) \u2227 a / b = x", "start": [975, 1], "end": [978, 52], "kind": "commanddeclaration"}, {"full_name": "Set.op_smul_inter_ne_empty_iff", "code": "@[to_additive]\ntheorem op_smul_inter_ne_empty_iff {s t : Set \u03b1} {x : \u03b1\u1d50\u1d52\u1d56} :\n    x \u2022 s \u2229 t \u2260 \u2205 \u2194 \u2203 a b, (a \u2208 s \u2227 b \u2208 t) \u2227 a\u207b\u00b9 * b = MulOpposite.unop x", "start": [982, 1], "end": [992, 73], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_inv_smul", "code": "@[to_additive (attr := simp)]\ntheorem iUnion_inv_smul : \u22c3 g : \u03b1, g\u207b\u00b9 \u2022 s = \u22c3 g : \u03b1, g \u2022 s", "start": [996, 1], "end": [998, 64], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_smul_eq_setOf_exists", "code": "@[to_additive]\ntheorem iUnion_smul_eq_setOf_exists {s : Set \u03b2} : \u22c3 g : \u03b1, g \u2022 s = { a | \u2203 g : \u03b1, g \u2022 a \u2208 s }", "start": [1002, 1], "end": [1004, 76], "kind": "commanddeclaration"}, {"full_name": "Set.smul_mem_smul_set_iff\u2080", "code": "@[simp]\ntheorem smul_mem_smul_set_iff\u2080 (ha : a \u2260 0) (A : Set \u03b2) (x : \u03b2) : a \u2022 x \u2208 a \u2022 A \u2194 x \u2208 A", "start": [1014, 1], "end": [1016, 61], "kind": "commanddeclaration"}, {"full_name": "Set.mem_smul_set_iff_inv_smul_mem\u2080", "code": "theorem mem_smul_set_iff_inv_smul_mem\u2080 (ha : a \u2260 0) (A : Set \u03b2) (x : \u03b2) : x \u2208 a \u2022 A \u2194 a\u207b\u00b9 \u2022 x \u2208 A", "start": [1019, 1], "end": [1020, 69], "kind": "commanddeclaration"}, {"full_name": "Set.mem_inv_smul_set_iff\u2080", "code": "theorem mem_inv_smul_set_iff\u2080 (ha : a \u2260 0) (A : Set \u03b2) (x : \u03b2) : x \u2208 a\u207b\u00b9 \u2022 A \u2194 a \u2022 x \u2208 A", "start": [1023, 1], "end": [1024, 64], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_smul\u2080", "code": "theorem preimage_smul\u2080 (ha : a \u2260 0) (t : Set \u03b2) : (fun x \u21a6 a \u2022 x) \u207b\u00b9' t = a\u207b\u00b9 \u2022 t", "start": [1027, 1], "end": [1028, 35], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_smul_inv\u2080", "code": "theorem preimage_smul_inv\u2080 (ha : a \u2260 0) (t : Set \u03b2) : (fun x \u21a6 a\u207b\u00b9 \u2022 x) \u207b\u00b9' t = a \u2022 t", "start": [1031, 1], "end": [1032, 37], "kind": "commanddeclaration"}, {"full_name": "Set.set_smul_subset_set_smul_iff\u2080", "code": "@[simp]\ntheorem set_smul_subset_set_smul_iff\u2080 (ha : a \u2260 0) {A B : Set \u03b2} : a \u2022 A \u2286 a \u2022 B \u2194 A \u2286 B", "start": [1035, 1], "end": [1037, 68], "kind": "commanddeclaration"}, {"full_name": "Set.set_smul_subset_iff\u2080", "code": "theorem set_smul_subset_iff\u2080 (ha : a \u2260 0) {A B : Set \u03b2} : a \u2022 A \u2286 B \u2194 A \u2286 a\u207b\u00b9 \u2022 B", "start": [1040, 1], "end": [1041, 59], "kind": "commanddeclaration"}, {"full_name": "Set.subset_set_smul_iff\u2080", "code": "theorem subset_set_smul_iff\u2080 (ha : a \u2260 0) {A B : Set \u03b2} : A \u2286 a \u2022 B \u2194 a\u207b\u00b9 \u2022 A \u2286 B", "start": [1044, 1], "end": [1045, 59], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_inter\u2080", "code": "theorem smul_set_inter\u2080 (ha : a \u2260 0) : a \u2022 (s \u2229 t) = a \u2022 s \u2229 a \u2022 t", "start": [1048, 1], "end": [1049, 50], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_sdiff\u2080", "code": "theorem smul_set_sdiff\u2080 (ha : a \u2260 0) : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t", "start": [1052, 1], "end": [1053, 43], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_symmDiff\u2080", "code": "theorem smul_set_symmDiff\u2080 (ha : a \u2260 0) : a \u2022 s \u2206 t = (a \u2022 s) \u2206 (a \u2022 t)", "start": [1056, 1], "end": [1057, 47], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_univ\u2080", "code": "theorem smul_set_univ\u2080 (ha : a \u2260 0) : a \u2022 (univ : Set \u03b2) = univ", "start": [1060, 1], "end": [1061, 55], "kind": "commanddeclaration"}, {"full_name": "Set.smul_univ\u2080", "code": "theorem smul_univ\u2080 {s : Set \u03b1} (hs : \u00acs \u2286 0) : s \u2022 (univ : Set \u03b2) = univ", "start": [1064, 1], "end": [1066, 76], "kind": "commanddeclaration"}, {"full_name": "Set.smul_univ\u2080'", "code": "theorem smul_univ\u2080' {s : Set \u03b1} (hs : s.Nontrivial) : s \u2022 (univ : Set \u03b2) = univ", "start": [1069, 1], "end": [1070, 37], "kind": "commanddeclaration"}, {"full_name": "Set.smul_set_neg", "code": "@[simp]\ntheorem smul_set_neg : a \u2022 -t = -(a \u2022 t)", "start": [1079, 1], "end": [1081, 61], "kind": "commanddeclaration"}, {"full_name": "Set.smul_neg", "code": "@[simp]\nprotected theorem smul_neg : s \u2022 -t = -(s \u2022 t)", "start": [1084, 1], "end": [1087, 41], "kind": "commanddeclaration"}, {"full_name": "Set.add_smul_subset", "code": "theorem add_smul_subset (a b : \u03b1) (s : Set \u03b2) : (a + b) \u2022 s \u2286 a \u2022 s + b \u2022 s", "start": [1097, 1], "end": [1099, 88], "kind": "commanddeclaration"}, {"full_name": "Set.neg_smul_set", "code": "@[simp]\ntheorem neg_smul_set : -a \u2022 t = -(a \u2022 t)", "start": [1107, 1], "end": [1109, 61], "kind": "commanddeclaration"}, {"full_name": "Set.neg_smul", "code": "@[simp]\nprotected theorem neg_smul : -s \u2022 t = -(s \u2022 t)", "start": [1112, 1], "end": [1115, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/Basic.lean", "imports": ["Mathlib/Algebra/Group/Conj.lean", "Mathlib/Algebra/Order/Group/InjSurj.lean", "Mathlib/Order/Atoms.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Data/Countable/Basic.lean", "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "Mathlib/Logic/Encodable/Basic.lean"], "premises": [{"full_name": "InvMemClass", "code": "class InvMemClass (S G : Type*) [Inv G] [SetLike S G] : Prop where\n  \n  inv_mem : \u2200 {s : S} {x}, x \u2208 s \u2192 x\u207b\u00b9 \u2208 s", "start": [98, 1], "end": [101, 43], "kind": "commanddeclaration"}, {"full_name": "NegMemClass", "code": "class NegMemClass (S G : Type*) [Neg G] [SetLike S G] : Prop where\n  \n  neg_mem : \u2200 {s : S} {x}, x \u2208 s \u2192 -x \u2208 s", "start": [106, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass", "code": "class SubgroupClass (S G : Type*) [DivInvMonoid G] [SetLike S G] extends SubmonoidClass S G,\n  InvMemClass S G : Prop", "start": [114, 1], "end": [116, 25], "kind": "commanddeclaration"}, {"full_name": "AddSubgroupClass", "code": "class AddSubgroupClass (S G : Type*) [SubNegMonoid G] [SetLike S G] extends AddSubmonoidClass S G,\n  NegMemClass S G : Prop", "start": [119, 1], "end": [122, 25], "kind": "commanddeclaration"}, {"full_name": "inv_mem_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n    {x : G} : x\u207b\u00b9 \u2208 H \u2194 x \u2208 H", "start": [129, 1], "end": [132, 44], "kind": "commanddeclaration"}, {"full_name": "abs_mem_iff", "code": "@[simp] theorem abs_mem_iff {S G} [InvolutiveNeg G] [LinearOrder G] {_ : SetLike S G}\n    [NegMemClass S G] {H : S} {x : G} : |x| \u2208 H \u2194 x \u2208 H", "start": [136, 1], "end": [138, 34], "kind": "commanddeclaration"}, {"full_name": "div_mem", "code": "@[to_additive (attr := aesop safe apply (rule_sets [SetLike]))\n  \"An additive subgroup is closed under subtraction.\"]\ntheorem div_mem {x y : M} (hx : x \u2208 H) (hy : y \u2208 H) : x / y \u2208 H", "start": [142, 1], "end": [146, 53], "kind": "commanddeclaration"}, {"full_name": "zpow_mem", "code": "@[to_additive (attr := aesop safe apply (rule_sets [SetLike]))]\ntheorem zpow_mem {x : M} (hx : x \u2208 K) : \u2200 n : \u2124, x ^ n \u2208 K", "start": [150, 1], "end": [157, 38], "kind": "commanddeclaration"}, {"full_name": "div_mem_comm_iff", "code": "@[to_additive]\ntheorem div_mem_comm_iff {a b : G} : a / b \u2208 H \u2194 b / a \u2208 H", "start": [163, 1], "end": [165, 28], "kind": "commanddeclaration"}, {"full_name": "exists_inv_mem_iff_exists_mem", "code": "@[to_additive ] theorem exists_inv_mem_iff_exists_mem {P : G \u2192 Prop} :\n    (\u2203 x : G, x \u2208 H \u2227 P x\u207b\u00b9) \u2194 \u2203 x \u2208 H, P x", "start": [169, 1], "end": [174, 46], "kind": "commanddeclaration"}, {"full_name": "mul_mem_cancel_right", "code": "@[to_additive]\ntheorem mul_mem_cancel_right {x y : G} (h : x \u2208 H) : y * x \u2208 H \u2194 y \u2208 H", "start": [178, 1], "end": [182, 78], "kind": "commanddeclaration"}, {"full_name": "mul_mem_cancel_left", "code": "@[to_additive]\ntheorem mul_mem_cancel_left {x y : G} (h : x \u2208 H) : x * y \u2208 H \u2194 y \u2208 H", "start": [186, 1], "end": [190, 65], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inv", "code": "@[to_additive \"An additive subgroup of an `AddGroup` inherits an inverse.\"]\ninstance inv {G : Type u_1} {S : Type u_2} [DivInvMonoid G] [SetLike S G]\n  [SubgroupClass S G] {H : S} : Inv H :=\n  \u27e8fun a => \u27e8a\u207b\u00b9, inv_mem a.2\u27e9\u27e9", "start": [196, 1], "end": [200, 32], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.div", "code": "@[to_additive \"An additive subgroup of an `AddGroup` inherits a subtraction.\"]\ninstance div {G : Type u_1} {S : Type u_2} [DivInvMonoid G] [SetLike S G]\n  [SubgroupClass S G] {H : S} : Div H :=\n  \u27e8fun a b => \u27e8a / b, div_mem a.2 b.2\u27e9\u27e9", "start": [204, 1], "end": [208, 40], "kind": "commanddeclaration"}, {"full_name": "AddSubgroupClass.zsmul", "code": "instance _root_.AddSubgroupClass.zsmul {M S} [SubNegMonoid M] [SetLike S M]\n    [AddSubgroupClass S M] {H : S} : SMul \u2124 H :=\n  \u27e8fun n a => \u27e8n \u2022 a.1, zsmul_mem a.2 n\u27e9\u27e9", "start": [212, 1], "end": [215, 42], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.zpow", "code": "@[to_additive existing]\ninstance zpow {M S} [DivInvMonoid M] [SetLike S M] [SubgroupClass S M] {H : S} : Pow H \u2124 :=\n  \u27e8fun a n => \u27e8a.1 ^ n, zpow_mem a.2 n\u27e9\u27e9", "start": [218, 1], "end": [221, 41], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : (x\u207b\u00b9).1 = x.1\u207b\u00b9", "start": [225, 1], "end": [227, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coe_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (x / y).1 = x.1 / y.1", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.toGroup", "code": "@[to_additive \"An additive subgroup of an `AddGroup` inherits an `AddGroup` structure.\"]\ninstance (priority := 75) toGroup : Group H :=\n  Subtype.coe_injective.group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [240, 1], "end": [244, 36], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.toCommGroup", "code": "@[to_additive \"An additive subgroup of an `AddCommGroup` is an `AddCommGroup`.\"]\ninstance (priority := 75) toCommGroup {G : Type*} [CommGroup G] [SetLike S G] [SubgroupClass S G] :\n    CommGroup H :=\n  Subtype.coe_injective.commGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [249, 1], "end": [254, 36], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.toOrderedCommGroup", "code": "@[to_additive \"An additive subgroup of an `AddOrderedCommGroup` is an `AddOrderedCommGroup`.\"]\ninstance (priority := 75) toOrderedCommGroup {G : Type*} [OrderedCommGroup G] [SetLike S G]\n    [SubgroupClass S G] : OrderedCommGroup H :=\n  Subtype.coe_injective.orderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [259, 1], "end": [264, 36], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.toLinearOrderedCommGroup", "code": "@[to_additive\n      \"An additive subgroup of a `LinearOrderedAddCommGroup` is a\n        `LinearOrderedAddCommGroup`.\"]\ninstance (priority := 75) toLinearOrderedCommGroup {G : Type*} [LinearOrderedCommGroup G]\n    [SetLike S G] [SubgroupClass S G] : LinearOrderedCommGroup H :=\n  Subtype.coe_injective.linearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [269, 1], "end": [276, 87], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.subtype", "code": "@[to_additive (attr := coe)\n  \"The natural group hom from an additive subgroup of `AddGroup` `G` to `G`.\"]\nprotected def subtype : H \u2192* G where\n  toFun := ((\u2191) : H \u2192 G); map_one' := rfl; map_mul' := fun _ _ => rfl", "start": [280, 1], "end": [284, 70], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coeSubtype", "code": "@[to_additive (attr := simp)]\ntheorem coeSubtype : (SubgroupClass.subtype H : H \u2192 G) = ((\u2191) : H \u2192 G)", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coe_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : \u2115) : ((x ^ n : H) : G) = (x : G) ^ n", "start": [296, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coe_zpow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zpow (x : H) (n : \u2124) : ((x ^ n : H) : G) = (x : G) ^ n", "start": [302, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inclusion", "code": "@[to_additive \"The inclusion homomorphism from an additive subgroup `H` contained in `K` to `K`.\"]\ndef inclusion {H K : S} (h : H \u2264 K) : H \u2192* K :=\n  MonoidHom.mk' (fun x => \u27e8x, h x.prop\u27e9) fun _ _=> rfl", "start": [308, 1], "end": [311, 55], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inclusion_self", "code": "@[to_additive (attr := simp)]\ntheorem inclusion_self (x : H) : inclusion le_rfl x = x", "start": [315, 1], "end": [318, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inclusion_mk", "code": "@[to_additive (attr := simp)]\ntheorem inclusion_mk {h : H \u2264 K} (x : G) (hx : x \u2208 H) : inclusion h \u27e8x, hx\u27e9 = \u27e8x, h hx\u27e9", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inclusion_right", "code": "@[to_additive]\ntheorem inclusion_right (h : H \u2264 K) (x : K) (hx : (x : G) \u2208 H) : inclusion h \u27e8x, hx\u27e9 = x", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.inclusion_inclusion", "code": "@[simp]\ntheorem inclusion_inclusion {L : S} (hHK : H \u2264 K) (hKL : K \u2264 L) (x : H) :\n    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x", "start": [335, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.coe_inclusion", "code": "@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : S} {h : H \u2264 K} (a : H) : (inclusion h a : G) = a", "start": [342, 1], "end": [345, 45], "kind": "commanddeclaration"}, {"full_name": "SubgroupClass.subtype_comp_inclusion", "code": "@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : S} (hH : H \u2264 K) :\n    (SubgroupClass.subtype K).comp (inclusion hH) = SubgroupClass.subtype H", "start": [349, 1], "end": [353, 62], "kind": "commanddeclaration"}, {"full_name": "Subgroup", "code": "structure Subgroup (G : Type*) [Group G] extends Submonoid G where\n  \n  inv_mem' {x} : x \u2208 carrier \u2192 x\u207b\u00b9 \u2208 carrier", "start": [361, 1], "end": [365, 45], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup", "code": "structure AddSubgroup (G : Type*) [AddGroup G] extends AddSubmonoid G where\n  \n  neg_mem' {x} : x \u2208 carrier \u2192 -x \u2208 carrier", "start": [368, 1], "end": [372, 44], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_carrier", "code": "@[to_additive (attr := simp, nolint simpNF)] theorem mem_carrier {s : Subgroup G} {x : G} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [405, 1], "end": [407, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_mk", "code": "@[to_additive (attr := simp)]\ntheorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) :\n    x \u2208 mk \u27e8\u27e8s, h_one\u27e9, h_mul\u27e9 h_inv \u2194 x \u2208 s", "start": [411, 1], "end": [414, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_set_mk", "code": "@[to_additive (attr := simp)]\ntheorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) :\n    (mk \u27e8\u27e8s, h_one\u27e9, h_mul\u27e9 h_inv : Set G) = s", "start": [418, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mk_le_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :\n    mk \u27e8\u27e8s, h_one\u27e9, h_mul\u27e9 h_inv \u2264 mk \u27e8\u27e8t, h_one'\u27e9, h_mul'\u27e9 h_inv' \u2194 s \u2286 t", "start": [425, 1], "end": [428, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_toSubmonoid", "code": "@[to_additive (attr := simp)]\ntheorem coe_toSubmonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K", "start": [435, 1], "end": [437, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_toSubmonoid", "code": "@[to_additive (attr := simp)]\ntheorem mem_toSubmonoid (K : Subgroup G) (x : G) : x \u2208 K.toSubmonoid \u2194 x \u2208 K", "start": [441, 1], "end": [443, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toSubmonoid_injective", "code": "@[to_additive]\ntheorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G \u2192 Submonoid G)", "start": [447, 1], "end": [453, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toSubmonoid_eq", "code": "@[to_additive (attr := simp)]\ntheorem toSubmonoid_eq {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid \u2194 p = q", "start": [457, 1], "end": [459, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toSubmonoid_strictMono", "code": "@[to_additive (attr := mono)]\ntheorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subgroup G \u2192 Submonoid G)", "start": [463, 1], "end": [465, 5], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toSubmonoid_mono", "code": "@[to_additive (attr := mono)]\ntheorem toSubmonoid_mono : Monotone (toSubmonoid : Subgroup G \u2192 Submonoid G)", "start": [469, 1], "end": [471, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toSubmonoid_le", "code": "@[to_additive (attr := simp)]\ntheorem toSubmonoid_le {p q : Subgroup G} : p.toSubmonoid \u2264 q.toSubmonoid \u2194 p \u2264 q", "start": [475, 1], "end": [477, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toAddSubgroup", "code": "@[simps!]\ndef Subgroup.toAddSubgroup : Subgroup G \u2243o AddSubgroup (Additive G) where\n  toFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  invFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl", "start": [490, 1], "end": [497, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toSubgroup'", "code": "abbrev AddSubgroup.toSubgroup' : AddSubgroup (Additive G) \u2243o Subgroup G :=\n  Subgroup.toAddSubgroup.symm", "start": [502, 1], "end": [504, 30], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toSubgroup", "code": "@[simps!]\ndef AddSubgroup.toSubgroup : AddSubgroup A \u2243o Subgroup (Multiplicative A) where\n  toFun S := { AddSubmonoid.toSubmonoid S.toAddSubmonoid with inv_mem' := S.neg_mem' }\n  invFun S := { Submonoid.toAddSubmonoid S.toSubmonoid with neg_mem' := S.inv_mem' }\n  left_inv x := by cases x; rfl\n  right_inv x := by cases x; rfl\n  map_rel_iff' := Iff.rfl", "start": [507, 1], "end": [515, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toAddSubgroup'", "code": "abbrev Subgroup.toAddSubgroup' : Subgroup (Multiplicative A) \u2243o AddSubgroup A :=\n  AddSubgroup.toSubgroup.symm", "start": [520, 1], "end": [523, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.copy", "code": "@[to_additive\n      \"Copy of an additive subgroup with a new `carrier` equal to the old one.\n      Useful to fix definitional equalities\"]\nprotected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G where\n  carrier := s\n  one_mem' := hs.symm \u25b8 K.one_mem'\n  mul_mem' := hs.symm \u25b8 K.mul_mem'\n  inv_mem' hx := by simpa [hs] using hx", "start": [532, 1], "end": [541, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_copy", "code": "@[to_additive (attr := simp)]\ntheorem coe_copy (K : Subgroup G) (s : Set G) (hs : s = \u2191K) : (K.copy s hs : Set G) = s", "start": [545, 1], "end": [547, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.copy_eq", "code": "@[to_additive]\ntheorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = \u2191K) : K.copy s hs = K", "start": [551, 1], "end": [553, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ext", "code": "@[to_additive (attr := ext) \"Two `AddSubgroup`s are equal if they have the same elements.\"]\ntheorem ext {H K : Subgroup G} (h : \u2200 x, x \u2208 H \u2194 x \u2208 K) : H = K", "start": [557, 1], "end": [560, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.one_mem", "code": "@[to_additive \"An `AddSubgroup` contains the group's 0.\"]\nprotected theorem one_mem : (1 : G) \u2208 H", "start": [564, 1], "end": [567, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_mem", "code": "@[to_additive \"An `AddSubgroup` is closed under addition.\"]\nprotected theorem mul_mem {x y : G} : x \u2208 H \u2192 y \u2208 H \u2192 x * y \u2208 H", "start": [571, 1], "end": [574, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inv_mem", "code": "@[to_additive \"An `AddSubgroup` is closed under inverse.\"]\nprotected theorem inv_mem {x : G} : x \u2208 H \u2192 x\u207b\u00b9 \u2208 H", "start": [578, 1], "end": [581, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.div_mem", "code": "@[to_additive \"An `AddSubgroup` is closed under subtraction.\"]\nprotected theorem div_mem {x y : G} (hx : x \u2208 H) (hy : y \u2208 H) : x / y \u2208 H", "start": [585, 1], "end": [588, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inv_mem_iff", "code": "@[to_additive]\nprotected theorem inv_mem_iff {x : G} : x\u207b\u00b9 \u2208 H \u2194 x \u2208 H", "start": [592, 1], "end": [594, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.div_mem_comm_iff", "code": "@[to_additive]\nprotected theorem div_mem_comm_iff {a b : G} : a / b \u2208 H \u2194 b / a \u2208 H", "start": [598, 1], "end": [600, 19], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_inv_mem_iff_exists_mem", "code": "@[to_additive]\nprotected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G \u2192 Prop} :\n    (\u2203 x : G, x \u2208 K \u2227 P x\u207b\u00b9) \u2194 \u2203 x \u2208 K, P x", "start": [604, 1], "end": [607, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_mem_cancel_right", "code": "@[to_additive]\nprotected theorem mul_mem_cancel_right {x y : G} (h : x \u2208 H) : y * x \u2208 H \u2194 y \u2208 H", "start": [611, 1], "end": [613, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_mem_cancel_left", "code": "@[to_additive]\nprotected theorem mul_mem_cancel_left {x y : G} (h : x \u2208 H) : x * y \u2208 H \u2194 y \u2208 H", "start": [617, 1], "end": [619, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pow_mem", "code": "@[to_additive]\nprotected theorem pow_mem {x : G} (hx : x \u2208 K) : \u2200 n : \u2115, x ^ n \u2208 K", "start": [623, 1], "end": [625, 13], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpow_mem", "code": "@[to_additive]\nprotected theorem zpow_mem {x : G} (hx : x \u2208 K) : \u2200 n : \u2124, x ^ n \u2208 K", "start": [629, 1], "end": [631, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ofDiv", "code": "@[to_additive \"Construct a subgroup from a nonempty set that is closed under subtraction\"]\ndef ofDiv (s : Set G) (hsn : s.Nonempty) (hs : \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), x * y\u207b\u00b9 \u2208 s) :\n    Subgroup G :=\n  have one_mem : (1 : G) \u2208 s := by\n    let \u27e8x, hx\u27e9 := hsn\n    simpa using hs x hx x hx\n  have inv_mem : \u2200 x, x \u2208 s \u2192 x\u207b\u00b9 \u2208 s := fun x hx => by simpa using hs 1 one_mem x hx\n  { carrier := s\n    one_mem' := one_mem\n    inv_mem' := inv_mem _\n    mul_mem' := fun hx hy => by simpa using hs _ hx _ (inv_mem _ hy) }", "start": [635, 1], "end": [646, 71], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul", "code": "@[to_additive \"An `AddSubgroup` of an `AddGroup` inherits an addition.\"]\ninstance mul : Mul H :=\n  H.toSubmonoid.mul", "start": [650, 1], "end": [653, 20], "kind": "commanddeclaration"}, {"full_name": "Subgroup.one", "code": "@[to_additive \"An `AddSubgroup` of an `AddGroup` inherits a zero.\"]\ninstance one : One H :=\n  H.toSubmonoid.one", "start": [657, 1], "end": [660, 20], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inv", "code": "@[to_additive \"An `AddSubgroup` of an `AddGroup` inherits an inverse.\"]\ninstance inv : Inv H :=\n  \u27e8fun a => \u27e8a\u207b\u00b9, H.inv_mem a.2\u27e9\u27e9", "start": [664, 1], "end": [667, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.div", "code": "@[to_additive \"An `AddSubgroup` of an `AddGroup` inherits a subtraction.\"]\ninstance div : Div H :=\n  \u27e8fun a b => \u27e8a / b, H.div_mem a.2 b.2\u27e9\u27e9", "start": [671, 1], "end": [674, 42], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.nsmul", "code": "instance _root_.AddSubgroup.nsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul \u2115 H :=\n  \u27e8fun n a => \u27e8n \u2022 a, H.nsmul_mem a.2 n\u27e9\u27e9", "start": [678, 1], "end": [680, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.npow", "code": "@[to_additive existing]\nprotected instance npow : Pow H \u2115 :=\n  \u27e8fun a n => \u27e8a ^ n, H.pow_mem a.2 n\u27e9\u27e9", "start": [683, 1], "end": [686, 40], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.zsmul", "code": "instance _root_.AddSubgroup.zsmul {G} [AddGroup G] {H : AddSubgroup G} : SMul \u2124 H :=\n  \u27e8fun n a => \u27e8n \u2022 a, H.zsmul_mem a.2 n\u27e9\u27e9", "start": [689, 1], "end": [691, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpow", "code": "@[to_additive existing]\ninstance zpow : Pow H \u2124 :=\n  \u27e8fun a n => \u27e8a ^ n, H.zpow_mem a.2 n\u27e9\u27e9", "start": [694, 1], "end": [697, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (x y : H) : (\u2191(x * y) : G) = \u2191x * \u2191y", "start": [700, 1], "end": [702, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : ((1 : H) : G) = 1", "start": [706, 1], "end": [708, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv (x : H) : \u2191(x\u207b\u00b9 : H) = (x\u207b\u00b9 : G)", "start": [712, 1], "end": [714, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (x y : H) : (\u2191(x / y) : G) = \u2191x / \u2191y", "start": [718, 1], "end": [720, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_mk", "code": "@[to_additive (attr := norm_cast)]\ntheorem coe_mk (x : G) (hx : x \u2208 H) : ((\u27e8x, hx\u27e9 : H) : G) = x", "start": [725, 1], "end": [727, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (x : H) (n : \u2115) : ((x ^ n : H) : G) = (x : G) ^ n", "start": [731, 1], "end": [733, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_zpow", "code": "@[to_additive (attr := norm_cast)] theorem coe_zpow (x : H) (n : \u2124) : ((x ^ n : H) : G) = (x : G) ^ n", "start": [737, 1], "end": [739, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mk_eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem mk_eq_one_iff {g : G} {h} : (\u27e8g, h\u27e9 : H) = 1 \u2194 g = 1", "start": [743, 1], "end": [745, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toGroup", "code": "@[to_additive \"An `AddSubgroup` of an `AddGroup` inherits an `AddGroup` structure.\"]\ninstance toGroup {G : Type*} [Group G] (H : Subgroup G) : Group H :=\n  Subtype.coe_injective.group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [749, 1], "end": [753, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toCommGroup", "code": "@[to_additive \"An `AddSubgroup` of an `AddCommGroup` is an `AddCommGroup`.\"]\ninstance toCommGroup {G : Type*} [CommGroup G] (H : Subgroup G) : CommGroup H :=\n  Subtype.coe_injective.commGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [757, 1], "end": [761, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toOrderedCommGroup", "code": "@[to_additive \"An `AddSubgroup` of an `AddOrderedCommGroup` is an `AddOrderedCommGroup`.\"]\ninstance toOrderedCommGroup {G : Type*} [OrderedCommGroup G] (H : Subgroup G) :\n    OrderedCommGroup H :=\n  Subtype.coe_injective.orderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [765, 1], "end": [770, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toLinearOrderedCommGroup", "code": "@[to_additive\n      \"An `AddSubgroup` of a `LinearOrderedAddCommGroup` is a\n        `LinearOrderedAddCommGroup`.\"]\ninstance toLinearOrderedCommGroup {G : Type*} [LinearOrderedCommGroup G] (H : Subgroup G) :\n    LinearOrderedCommGroup H :=\n  Subtype.coe_injective.linearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [774, 1], "end": [781, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subtype", "code": "@[to_additive \"The natural group hom from an `AddSubgroup` of `AddGroup` `G` to `G`.\"]\nprotected def subtype : H \u2192* G where\n  toFun := ((\u2191) : H \u2192 G); map_one' := rfl; map_mul' _ _ := rfl", "start": [785, 1], "end": [788, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coeSubtype", "code": "@[to_additive (attr := simp)]\ntheorem coeSubtype : \u21d1 H.subtype = ((\u2191) : H \u2192 G)", "start": [792, 1], "end": [794, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subtype_injective", "code": "@[to_additive]\ntheorem subtype_injective : Function.Injective (Subgroup.subtype H)", "start": [798, 1], "end": [800, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inclusion", "code": "@[to_additive \"The inclusion homomorphism from an additive subgroup `H` contained in `K` to `K`.\"]\ndef inclusion {H K : Subgroup G} (h : H \u2264 K) : H \u2192* K :=\n  MonoidHom.mk' (fun x => \u27e8x, h x.2\u27e9) fun _ _ => rfl", "start": [804, 1], "end": [807, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_inclusion", "code": "@[to_additive (attr := simp)]\ntheorem coe_inclusion {H K : Subgroup G} {h : H \u2264 K} (a : H) : (inclusion h a : G) = a", "start": [811, 1], "end": [814, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inclusion_injective", "code": "@[to_additive]\ntheorem inclusion_injective {H K : Subgroup G} (h : H \u2264 K) : Function.Injective <| inclusion h", "start": [818, 1], "end": [820, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subtype_comp_inclusion", "code": "@[to_additive (attr := simp)]\ntheorem subtype_comp_inclusion {H K : Subgroup G} (hH : H \u2264 K) :\n    K.subtype.comp (inclusion hH) = H.subtype", "start": [824, 1], "end": [827, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.topEquiv", "code": "@[to_additive (attr := simps!)\n      \"The top additive subgroup is isomorphic to the additive group.\n\n      This is the additive group version of `AddSubmonoid.topEquiv`.\"]\ndef topEquiv : (\u22a4 : Subgroup G) \u2243* G :=\n  Submonoid.topEquiv", "start": [836, 1], "end": [844, 21], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_bot", "code": "@[to_additive (attr := simp)]\ntheorem mem_bot {x : G} : x \u2208 (\u22a5 : Subgroup G) \u2194 x = 1", "start": [860, 1], "end": [862, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_top", "code": "@[to_additive (attr := simp)]\ntheorem mem_top (x : G) : x \u2208 (\u22a4 : Subgroup G)", "start": [866, 1], "end": [868, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_top", "code": "@[to_additive (attr := simp)]\ntheorem coe_top : ((\u22a4 : Subgroup G) : Set G) = Set.univ", "start": [872, 1], "end": [874, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_bot", "code": "@[to_additive (attr := simp)]\ntheorem coe_bot : ((\u22a5 : Subgroup G) : Set G) = {1}", "start": [878, 1], "end": [880, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.top_toSubmonoid", "code": "@[to_additive (attr := simp)]\ntheorem top_toSubmonoid : (\u22a4 : Subgroup G).toSubmonoid = \u22a4", "start": [888, 1], "end": [890, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.bot_toSubmonoid", "code": "@[to_additive (attr := simp)]\ntheorem bot_toSubmonoid : (\u22a5 : Subgroup G).toSubmonoid = \u22a5", "start": [894, 1], "end": [896, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_bot_iff_forall", "code": "@[to_additive]\ntheorem eq_bot_iff_forall : H = \u22a5 \u2194 \u2200 x \u2208 H, x = (1 : G)", "start": [900, 1], "end": [902, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_bot_of_subsingleton", "code": "@[to_additive]\ntheorem eq_bot_of_subsingleton [Subsingleton H] : H = \u22a5", "start": [906, 1], "end": [910, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_eq_univ", "code": "@[to_additive]\ntheorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.univ \u2194 H = \u22a4", "start": [914, 1], "end": [916, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_eq_singleton", "code": "@[to_additive]\ntheorem coe_eq_singleton {H : Subgroup G} : (\u2203 g : G, (H : Set G) = {g}) \u2194 H = \u22a5", "start": [920, 1], "end": [927, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nontrivial_iff_exists_ne_one", "code": "@[to_additive]\ntheorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H \u2194 \u2203 x \u2208 H, x \u2260 (1 : G)", "start": [931, 1], "end": [934, 7], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_ne_one_of_nontrivial", "code": "@[to_additive]\ntheorem exists_ne_one_of_nontrivial (H : Subgroup G) [Nontrivial H] :\n    \u2203 x \u2208 H, x \u2260 1", "start": [938, 1], "end": [941, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nontrivial_iff_ne_bot", "code": "@[to_additive]\ntheorem nontrivial_iff_ne_bot (H : Subgroup G) : Nontrivial H \u2194 H \u2260 \u22a5", "start": [943, 1], "end": [946, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.bot_or_nontrivial", "code": "@[to_additive \"A subgroup is either the trivial subgroup or nontrivial.\"]\ntheorem bot_or_nontrivial (H : Subgroup G) : H = \u22a5 \u2228 Nontrivial H", "start": [948, 1], "end": [952, 8], "kind": "commanddeclaration"}, {"full_name": "Subgroup.bot_or_exists_ne_one", "code": "@[to_additive \"A subgroup is either the trivial subgroup or contains a nonzero element.\"]\ntheorem bot_or_exists_ne_one (H : Subgroup G) : H = \u22a5 \u2228 \u2203 x \u2208 H, x \u2260 (1 : G)", "start": [956, 1], "end": [960, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ne_bot_iff_exists_ne_one", "code": "@[to_additive]\nlemma ne_bot_iff_exists_ne_one {H : Subgroup G} : H \u2260 \u22a5 \u2194 \u2203 a : \u21a5H, a \u2260 1 := by\n  rw [\u2190nontrivial_iff_ne_bot, nontrivial_iff_exists_ne_one]\n  simp only [ne_eq, Subtype.exists, mk_eq_one_iff, exists_prop]", "start": [964, 1], "end": [967, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Subgroup.coe_inf", "code": "@[to_additive (attr := simp)]\ntheorem coe_inf (p p' : Subgroup G) : ((p \u2293 p' : Subgroup G) : Set G) = (p : Set G) \u2229 p'", "start": [976, 1], "end": [978, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_inf", "code": "@[to_additive (attr := simp)]\ntheorem mem_inf {p p' : Subgroup G} {x : G} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [982, 1], "end": [984, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_sInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sInf (H : Set (Subgroup G)) : ((sInf H : Subgroup G) : Set G) = \u22c2 s \u2208 H, \u2191s", "start": [995, 1], "end": [997, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sInf", "code": "@[to_additive (attr := simp)]\ntheorem mem_sInf {S : Set (Subgroup G)} {x : G} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [1001, 1], "end": [1003, 18], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_iInf", "code": "@[to_additive]\ntheorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subgroup G} {x : G} : (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [1007, 1], "end": [1009, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_iInf", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subgroup G} : (\u2191(\u2a05 i, S i) : Set G) = \u22c2 i, S i", "start": [1013, 1], "end": [1015, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sup_left", "code": "@[to_additive]\ntheorem mem_sup_left {S T : Subgroup G} : \u2200 {x : G}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [1033, 1], "end": [1035, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sup_right", "code": "@[to_additive]\ntheorem mem_sup_right {S T : Subgroup G} : \u2200 {x : G}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [1039, 1], "end": [1041, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_mem_sup", "code": "@[to_additive]\ntheorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x \u2208 S) (hy : y \u2208 T) : x * y \u2208 S \u2294 T", "start": [1045, 1], "end": [1047, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_iSup_of_mem", "code": "@[to_additive]\ntheorem mem_iSup_of_mem {\u03b9 : Sort*} {S : \u03b9 \u2192 Subgroup G} (i : \u03b9) :\n    \u2200 {x : G}, x \u2208 S i \u2192 x \u2208 iSup S", "start": [1051, 1], "end": [1054, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sSup_of_mem", "code": "@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s \u2208 S) :\n    \u2200 {x : G}, x \u2208 s \u2192 x \u2208 sSup S", "start": [1058, 1], "end": [1061, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subsingleton_iff", "code": "@[to_additive (attr := simp)]\ntheorem subsingleton_iff : Subsingleton (Subgroup G) \u2194 Subsingleton G", "start": [1065, 1], "end": [1072, 100], "kind": "commanddeclaration"}, {"full_name": "Subgroup.nontrivial_iff", "code": "@[to_additive (attr := simp)]\ntheorem nontrivial_iff : Nontrivial (Subgroup G) \u2194 Nontrivial G", "start": [1076, 1], "end": [1080, 44], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_top_iff'", "code": "@[to_additive]\ntheorem eq_top_iff' : H = \u22a4 \u2194 \u2200 x : G, x \u2208 H", "start": [1092, 1], "end": [1094, 65], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure", "code": "@[to_additive \"The `AddSubgroup` generated by a set\"]\ndef closure (k : Set G) : Subgroup G :=\n  sInf { K | k \u2286 K }", "start": [1098, 1], "end": [1101, 21], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_closure", "code": "@[to_additive]\ntheorem mem_closure {x : G} : x \u2208 closure k \u2194 \u2200 K : Subgroup G, k \u2286 K \u2192 x \u2208 K", "start": [1107, 1], "end": [1109, 11], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subset_closure", "code": "@[to_additive (attr := simp, aesop safe 20 apply (rule_sets [SetLike]))\n  \"The `AddSubgroup` generated by a set includes the set.\"]\ntheorem subset_closure : k \u2286 closure k", "start": [1113, 1], "end": [1116, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.not_mem_of_not_mem_closure", "code": "@[to_additive]\ntheorem not_mem_of_not_mem_closure {P : G} (hP : P \u2209 closure k) : P \u2209 k", "start": [1120, 1], "end": [1122, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_le", "code": "@[to_additive (attr := simp)\n  \"An additive subgroup `K` includes `closure k` if and only if it includes `k`\"]\ntheorem closure_le : closure k \u2264 K \u2194 k \u2286 K", "start": [1128, 1], "end": [1132, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_eq_of_le", "code": "@[to_additive]\ntheorem closure_eq_of_le (h\u2081 : k \u2286 K) (h\u2082 : K \u2264 closure k) : closure k = K", "start": [1136, 1], "end": [1138, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction", "code": "@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership. If `p`\n      holds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p`\n      holds for all elements of the additive closure of `k`.\"]\ntheorem closure_induction {p : G \u2192 Prop} {x} (h : x \u2208 closure k) (Hk : \u2200 x \u2208 k, p x) (H1 : p 1)\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (Hinv : \u2200 x, p x \u2192 p x\u207b\u00b9) : p x", "start": [1142, 1], "end": [1151, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction'", "code": "@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubgroup.closure_induction`. \"]\ntheorem closure_induction' {p : \u2200 x, x \u2208 closure k \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 k), p x (subset_closure h)) (H1 : p 1 (one_mem _))\n    (Hmul : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x * y) (mul_mem hx hy))\n    (Hinv : \u2200 x hx, p x hx \u2192 p x\u207b\u00b9 (inv_mem hx)) {x} (hx : x \u2208 closure k) : p x hx", "start": [1155, 1], "end": [1164, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction\u2082", "code": "@[to_additive (attr := elab_as_elim)\n      \"An induction principle for additive closure membership, for\n      predicates with two arguments.\"]\ntheorem closure_induction\u2082 {p : G \u2192 G \u2192 Prop} {x} {y : G} (hx : x \u2208 closure k) (hy : y \u2208 closure k)\n    (Hk : \u2200 x \u2208 k, \u2200 y \u2208 k, p x y) (H1_left : \u2200 x, p 1 x) (H1_right : \u2200 x, p x 1)\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)) (Hinv_left : \u2200 x y, p x y \u2192 p x\u207b\u00b9 y)\n    (Hinv_right : \u2200 x y, p x y \u2192 p x y\u207b\u00b9) : p x y", "start": [1168, 1], "end": [1179, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_closure_coe_preimage", "code": "@[to_additive (attr := simp)]\ntheorem closure_closure_coe_preimage {k : Set G} : closure (((\u2191) : closure k \u2192 G) \u207b\u00b9' k) = \u22a4", "start": [1183, 1], "end": [1191, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closureCommGroupOfComm", "code": "@[to_additive\n      \"If all the elements of a set `s` commute, then `closure s` is an additive\n      commutative group.\"]\ndef closureCommGroupOfComm {k : Set G} (hcomm : \u2200 x \u2208 k, \u2200 y \u2208 k, x * y = y * x) :\n    CommGroup (closure k) :=\n  { (closure k).toGroup with\n    mul_comm := fun x y => by\n      ext\n      simp only [Subgroup.coe_mul]\n      refine'\n        closure_induction\u2082 x.prop y.prop hcomm (fun x => by simp only [mul_one, one_mul])\n          (fun x => by simp only [mul_one, one_mul])\n          (fun x y z h\u2081 h\u2082 => by rw [mul_assoc, h\u2082, \u2190 mul_assoc, h\u2081, mul_assoc])\n          (fun x y z h\u2081 h\u2082 => by rw [\u2190 mul_assoc, h\u2081, mul_assoc, h\u2082, \u2190 mul_assoc])\n          (fun x y h => by\n            rw [inv_mul_eq_iff_eq_mul, \u2190 mul_assoc, h, mul_assoc, mul_inv_self, mul_one])\n          fun x y h => by\n          rw [mul_inv_eq_iff_eq_mul, mul_assoc, h, \u2190 mul_assoc, inv_mul_self, one_mul] }", "start": [1195, 1], "end": [1213, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.gi", "code": "@[to_additive \"`closure` forms a Galois insertion with the coercion to set.\"]\nprotected def gi : GaloisInsertion (@closure G _) (\u2191)\n    where\n  choice s _ := closure s\n  gc s t := @closure_le _ _ t s\n  le_l_u _s := subset_closure\n  choice_eq _s _h := rfl", "start": [1219, 1], "end": [1226, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_mono", "code": "@[to_additive\n      \"Additive subgroup closure of a set is monotone in its argument: if `h \u2286 k`,\n      then `closure h \u2264 closure k`\"]\ntheorem closure_mono \u2983h k : Set G\u2984 (h' : h \u2286 k) : closure h \u2264 closure k", "start": [1232, 1], "end": [1238, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_eq", "code": "@[to_additive (attr := simp) \"Additive closure of an additive subgroup `K` equals `K`\"]\ntheorem closure_eq : closure (K : Set G) = K", "start": [1242, 1], "end": [1245, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_empty", "code": "@[to_additive (attr := simp)]\ntheorem closure_empty : closure (\u2205 : Set G) = \u22a5", "start": [1249, 1], "end": [1251, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_univ", "code": "@[to_additive (attr := simp)]\ntheorem closure_univ : closure (univ : Set G) = \u22a4", "start": [1255, 1], "end": [1257, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_union", "code": "@[to_additive]\ntheorem closure_union (s t : Set G) : closure (s \u222a t) = closure s \u2294 closure t", "start": [1261, 1], "end": [1263, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sup_eq_closure", "code": "@[to_additive]\ntheorem sup_eq_closure (H H' : Subgroup G) : H \u2294 H' = closure ((H : Set G) \u222a (H' : Set G))", "start": [1267, 1], "end": [1269, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_iUnion", "code": "@[to_additive]\ntheorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set G) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [1271, 1], "end": [1273, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_eq_bot_iff", "code": "@[to_additive]\ntheorem closure_eq_bot_iff (G : Type*) [Group G] (S : Set G) : closure S = \u22a5 \u2194 S \u2286 {1}", "start": [1277, 1], "end": [1280, 21], "kind": "commanddeclaration"}, {"full_name": "Subgroup.iSup_eq_closure", "code": "@[to_additive]\ntheorem iSup_eq_closure {\u03b9 : Sort*} (p : \u03b9 \u2192 Subgroup G) :\n    \u2a06 i, p i = closure (\u22c3 i, (p i : Set G))", "start": [1284, 1], "end": [1286, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_closure_singleton", "code": "@[to_additive\n      \"The `AddSubgroup` generated by an element of an `AddGroup` equals the set of\n      natural number multiples of the element.\"]\ntheorem mem_closure_singleton {x y : G} : y \u2208 closure ({x} : Set G) \u2194 \u2203 n : \u2124, x ^ n = y", "start": [1290, 1], "end": [1306, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_singleton_one", "code": "@[to_additive]\ntheorem closure_singleton_one : closure ({1} : Set G) = \u22a5", "start": [1310, 1], "end": [1312, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_closure_toSubmonoid", "code": "@[to_additive]\ntheorem le_closure_toSubmonoid (S : Set G) : Submonoid.closure S \u2264 (closure S).toSubmonoid", "start": [1316, 1], "end": [1318, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_eq_top_of_mclosure_eq_top", "code": "@[to_additive]\ntheorem closure_eq_top_of_mclosure_eq_top {S : Set G} (h : Submonoid.closure S = \u22a4) :\n    closure S = \u22a4", "start": [1322, 1], "end": [1325, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_iSup_of_directed", "code": "@[to_additive]\ntheorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {K : \u03b9 \u2192 Subgroup G} (hK : Directed (\u00b7 \u2264 \u00b7) K)\n    {x : G} : x \u2208 (iSup K : Subgroup G) \u2194 \u2203 i, x \u2208 K i", "start": [1329, 1], "end": [1341, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_iSup_of_directed", "code": "@[to_additive]\ntheorem coe_iSup_of_directed {\u03b9} [Nonempty \u03b9] {S : \u03b9 \u2192 Subgroup G} (hS : Directed (\u00b7 \u2264 \u00b7) S) :\n    ((\u2a06 i, S i : Subgroup G) : Set G) = \u22c3 i, \u2191(S i)", "start": [1345, 1], "end": [1348, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sSup_of_directedOn", "code": "@[to_additive]\ntheorem mem_sSup_of_directedOn {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (\u00b7 \u2264 \u00b7) K)\n    {x : G} : x \u2208 sSup K \u2194 \u2203 s \u2208 K, x \u2208 s", "start": [1352, 1], "end": [1357, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap", "code": "@[to_additive\n      \"The preimage of an `AddSubgroup` along an `AddMonoid` homomorphism\n      is an `AddSubgroup`.\"]\ndef comap {N : Type*} [Group N] (f : G \u2192* N) (H : Subgroup N) : Subgroup G :=\n  { H.toSubmonoid.comap f with\n    carrier := f \u207b\u00b9' H\n    inv_mem' := fun {a} ha => show f a\u207b\u00b9 \u2208 H by rw [f.map_inv]; exact H.inv_mem ha }", "start": [1363, 1], "end": [1370, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_comap", "code": "@[to_additive (attr := simp)]\ntheorem coe_comap (K : Subgroup N) (f : G \u2192* N) : (K.comap f : Set G) = f \u207b\u00b9' K", "start": [1374, 1], "end": [1376, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.toAddSubgroup_comap", "code": "@[simp]\ntheorem toAddSubgroup_comap {G\u2082 : Type*} [Group G\u2082] (f : G \u2192* G\u2082) (s : Subgroup G\u2082) :\n    s.toAddSubgroup.comap (MonoidHom.toAdditive f) = Subgroup.toAddSubgroup (s.comap f)", "start": [1380, 1], "end": [1382, 95], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toSubgroup_comap", "code": "@[simp]\ntheorem _root_.AddSubgroup.toSubgroup_comap {A A\u2082 : Type*} [AddGroup A] [AddGroup A\u2082]\n    (f : A \u2192+ A\u2082)  (s : AddSubgroup A\u2082) :\n    s.toSubgroup.comap (AddMonoidHom.toMultiplicative f) = AddSubgroup.toSubgroup (s.comap f)", "start": [1384, 1], "end": [1387, 101], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_comap", "code": "@[to_additive (attr := simp)]\ntheorem mem_comap {K : Subgroup N} {f : G \u2192* N} {x : G} : x \u2208 K.comap f \u2194 f x \u2208 K", "start": [1389, 1], "end": [1391, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_mono", "code": "@[to_additive]\ntheorem comap_mono {f : G \u2192* N} {K K' : Subgroup N} : K \u2264 K' \u2192 comap f K \u2264 comap f K'", "start": [1395, 1], "end": [1397, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_comap", "code": "@[to_additive]\ntheorem comap_comap (K : Subgroup P) (g : N \u2192* P) (f : G \u2192* N) :\n    (K.comap g).comap f = K.comap (g.comp f)", "start": [1401, 1], "end": [1404, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_id", "code": "@[to_additive (attr := simp)]\ntheorem comap_id (K : Subgroup N) : K.comap (MonoidHom.id _) = K", "start": [1408, 1], "end": [1411, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map", "code": "@[to_additive\n      \"The image of an `AddSubgroup` along an `AddMonoid` homomorphism\n      is an `AddSubgroup`.\"]\ndef map (f : G \u2192* N) (H : Subgroup G) : Subgroup N :=\n  { H.toSubmonoid.map f with\n    carrier := f '' H\n    inv_mem' := by\n      rintro _ \u27e8x, hx, rfl\u27e9\n      exact \u27e8x\u207b\u00b9, H.inv_mem hx, f.map_inv x\u27e9 }", "start": [1415, 1], "end": [1424, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_map", "code": "@[to_additive (attr := simp)]\ntheorem coe_map (f : G \u2192* N) (K : Subgroup G) : (K.map f : Set N) = f '' K", "start": [1428, 1], "end": [1430, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_map", "code": "@[to_additive (attr := simp)]\ntheorem mem_map {f : G \u2192* N} {K : Subgroup G} {y : N} : y \u2208 K.map f \u2194 \u2203 x \u2208 K, f x = y", "start": [1434, 1], "end": [1436, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_map_of_mem", "code": "@[to_additive]\ntheorem mem_map_of_mem (f : G \u2192* N) {K : Subgroup G} {x : G} (hx : x \u2208 K) : f x \u2208 K.map f", "start": [1440, 1], "end": [1442, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.apply_coe_mem_map", "code": "@[to_additive]\ntheorem apply_coe_mem_map (f : G \u2192* N) (K : Subgroup G) (x : K) : f x \u2208 K.map f", "start": [1446, 1], "end": [1448, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_mono", "code": "@[to_additive]\ntheorem map_mono {f : G \u2192* N} {K K' : Subgroup G} : K \u2264 K' \u2192 map f K \u2264 map f K'", "start": [1452, 1], "end": [1454, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id : K.map (MonoidHom.id G) = K", "start": [1458, 1], "end": [1460, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_map", "code": "@[to_additive]\ntheorem map_map (g : N \u2192* P) (f : G \u2192* N) : (K.map f).map g = K.map (g.comp f)", "start": [1464, 1], "end": [1466, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_one_eq_bot", "code": "@[to_additive (attr := simp)]\ntheorem map_one_eq_bot : K.map (1 : G \u2192* N) = \u22a5", "start": [1470, 1], "end": [1474, 9], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_map_equiv", "code": "@[to_additive]\ntheorem mem_map_equiv {f : G \u2243* N} {K : Subgroup G} {x : N} :\n    x \u2208 K.map f.toMonoidHom \u2194 f.symm x \u2208 K", "start": [1478, 1], "end": [1481, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_map_iff_mem", "code": "@[to_additive (attr := simp 1100, nolint simpNF)]\ntheorem mem_map_iff_mem {f : G \u2192* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} :\n    f x \u2208 K.map f \u2194 x \u2208 K", "start": [1488, 1], "end": [1491, 19], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_equiv_eq_comap_symm", "code": "@[to_additive]\ntheorem map_equiv_eq_comap_symm (f : G \u2243* N) (K : Subgroup G) :\n    K.map f.toMonoidHom = K.comap f.symm.toMonoidHom", "start": [1495, 1], "end": [1498, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_equiv_eq_map_symm", "code": "@[to_additive]\ntheorem comap_equiv_eq_map_symm (f : N \u2243* G) (K : Subgroup G) :\n    K.comap f.toMonoidHom = K.map f.symm.toMonoidHom", "start": [1502, 1], "end": [1505, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_symm_eq_iff_map_eq", "code": "@[to_additive]\ntheorem map_symm_eq_iff_map_eq {H : Subgroup N} {e : G \u2243* N} :\n    H.map \u2191e.symm = K \u2194 K.map \u2191e = H", "start": [1509, 1], "end": [1516, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_le_iff_le_comap", "code": "@[to_additive]\ntheorem map_le_iff_le_comap {f : G \u2192* N} {K : Subgroup G} {H : Subgroup N} :\n    K.map f \u2264 H \u2194 K \u2264 H.comap f", "start": [1520, 1], "end": [1523, 19], "kind": "commanddeclaration"}, {"full_name": "Subgroup.gc_map_comap", "code": "@[to_additive]\ntheorem gc_map_comap (f : G \u2192* N) : GaloisConnection (map f) (comap f)", "start": [1527, 1], "end": [1529, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_sup", "code": "@[to_additive]\ntheorem map_sup (H K : Subgroup G) (f : G \u2192* N) : (H \u2294 K).map f = H.map f \u2294 K.map f", "start": [1533, 1], "end": [1535, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_iSup", "code": "@[to_additive]\ntheorem map_iSup {\u03b9 : Sort*} (f : G \u2192* N) (s : \u03b9 \u2192 Subgroup G) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [1539, 1], "end": [1542, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_sup_comap_le", "code": "@[to_additive]\ntheorem comap_sup_comap_le (H K : Subgroup N) (f : G \u2192* N) :\n    comap f H \u2294 comap f K \u2264 comap f (H \u2294 K)", "start": [1546, 1], "end": [1549, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.iSup_comap_le", "code": "@[to_additive]\ntheorem iSup_comap_le {\u03b9 : Sort*} (f : G \u2192* N) (s : \u03b9 \u2192 Subgroup N) :\n    \u2a06 i, (s i).comap f \u2264 (iSup s).comap f", "start": [1553, 1], "end": [1556, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_inf", "code": "@[to_additive]\ntheorem comap_inf (H K : Subgroup N) (f : G \u2192* N) : (H \u2293 K).comap f = H.comap f \u2293 K.comap f", "start": [1560, 1], "end": [1562, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_iInf", "code": "@[to_additive]\ntheorem comap_iInf {\u03b9 : Sort*} (f : G \u2192* N) (s : \u03b9 \u2192 Subgroup N) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [1566, 1], "end": [1569, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_inf_le", "code": "@[to_additive]\ntheorem map_inf_le (H K : Subgroup G) (f : G \u2192* N) : map f (H \u2293 K) \u2264 map f H \u2293 map f K", "start": [1573, 1], "end": [1575, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_inf_eq", "code": "@[to_additive]\ntheorem map_inf_eq (H K : Subgroup G) (f : G \u2192* N) (hf : Function.Injective f) :\n    map f (H \u2293 K) = map f H \u2293 map f K", "start": [1579, 1], "end": [1583, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_bot", "code": "@[to_additive (attr := simp)]\ntheorem map_bot (f : G \u2192* N) : (\u22a5 : Subgroup G).map f = \u22a5", "start": [1587, 1], "end": [1589, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_top_of_surjective", "code": "@[to_additive (attr := simp)]\ntheorem map_top_of_surjective (f : G \u2192* N) (h : Function.Surjective f) : Subgroup.map f \u22a4 = \u22a4", "start": [1593, 1], "end": [1598, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_top", "code": "@[to_additive (attr := simp)]\ntheorem comap_top (f : G \u2192* N) : (\u22a4 : Subgroup N).comap f = \u22a4", "start": [1602, 1], "end": [1604, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf", "code": "@[to_additive \"For any subgroups `H` and `K`, view `H \u2293 K` as a subgroup of `K`.\"]\ndef subgroupOf (H K : Subgroup G) : Subgroup K :=\n  H.comap K.subtype", "start": [1608, 1], "end": [1611, 20], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOfEquivOfLe", "code": "@[to_additive (attr := simps) \"If `H \u2264 K`, then `H` as a subgroup of `K` is isomorphic to `H`.\"]\ndef subgroupOfEquivOfLe {G : Type*} [Group G] {H K : Subgroup G} (h : H \u2264 K) :\n    H.subgroupOf K \u2243* H where\n  toFun g := \u27e8g.1, g.2\u27e9\n  invFun g := \u27e8\u27e8g.1, h g.2\u27e9, g.2\u27e9\n  left_inv _g := Subtype.ext (Subtype.ext rfl)\n  right_inv _g := Subtype.ext rfl\n  map_mul' _g _h := rfl", "start": [1615, 1], "end": [1623, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_subtype", "code": "@[to_additive (attr := simp)]\ntheorem comap_subtype (H K : Subgroup G) : H.comap K.subtype = H.subgroupOf K", "start": [1631, 1], "end": [1633, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_inclusion_subgroupOf", "code": "@[to_additive (attr := simp)]\ntheorem comap_inclusion_subgroupOf {K\u2081 K\u2082 : Subgroup G} (h : K\u2081 \u2264 K\u2082) (H : Subgroup G) :\n    (H.subgroupOf K\u2082).comap (inclusion h) = H.subgroupOf K\u2081", "start": [1637, 1], "end": [1640, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_subgroupOf", "code": "@[to_additive]\ntheorem coe_subgroupOf (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.subtype \u207b\u00b9' H", "start": [1644, 1], "end": [1646, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_subgroupOf", "code": "@[to_additive]\ntheorem mem_subgroupOf {H K : Subgroup G} {h : K} : h \u2208 H.subgroupOf K \u2194 (h : G) \u2208 H", "start": [1650, 1], "end": [1652, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_map_subtype", "code": "@[to_additive (attr := simp)]\ntheorem subgroupOf_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.subtype = H \u2293 K", "start": [1656, 1], "end": [1658, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.bot_subgroupOf", "code": "@[to_additive (attr := simp)]\ntheorem bot_subgroupOf : (\u22a5 : Subgroup G).subgroupOf H = \u22a5", "start": [1662, 1], "end": [1664, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.top_subgroupOf", "code": "@[to_additive (attr := simp)]\ntheorem top_subgroupOf : (\u22a4 : Subgroup G).subgroupOf H = \u22a4", "start": [1668, 1], "end": [1670, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_bot_eq_bot", "code": "@[to_additive]\ntheorem subgroupOf_bot_eq_bot : H.subgroupOf \u22a5 = \u22a5", "start": [1674, 1], "end": [1676, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_bot_eq_top", "code": "@[to_additive]\ntheorem subgroupOf_bot_eq_top : H.subgroupOf \u22a5 = \u22a4", "start": [1680, 1], "end": [1682, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_self", "code": "@[to_additive (attr := simp)]\ntheorem subgroupOf_self : H.subgroupOf H = \u22a4", "start": [1686, 1], "end": [1688, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_inj", "code": "@[to_additive (attr := simp)]\ntheorem subgroupOf_inj {H\u2081 H\u2082 K : Subgroup G} :\n    H\u2081.subgroupOf K = H\u2082.subgroupOf K \u2194 H\u2081 \u2293 K = H\u2082 \u2293 K", "start": [1692, 1], "end": [1695, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_subgroupOf_right", "code": "@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_right (H K : Subgroup G) : (H \u2293 K).subgroupOf K = H.subgroupOf K", "start": [1699, 1], "end": [1701, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_subgroupOf_left", "code": "@[to_additive (attr := simp)]\ntheorem inf_subgroupOf_left (H K : Subgroup G) : (K \u2293 H).subgroupOf K = H.subgroupOf K", "start": [1705, 1], "end": [1707, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_eq_bot", "code": "@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_bot {H K : Subgroup G} : H.subgroupOf K = \u22a5 \u2194 Disjoint H K", "start": [1711, 1], "end": [1713, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_eq_top", "code": "@[to_additive (attr := simp)]\ntheorem subgroupOf_eq_top {H K : Subgroup G} : H.subgroupOf K = \u22a4 \u2194 K \u2264 H", "start": [1717, 1], "end": [1719, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod", "code": "@[to_additive prod\n      \"Given `AddSubgroup`s `H`, `K` of `AddGroup`s `A`, `B` respectively, `H \u00d7 K`\n      as an `AddSubgroup` of `A \u00d7 B`.\"]\ndef prod (H : Subgroup G) (K : Subgroup N) : Subgroup (G \u00d7 N) :=\n  { Submonoid.prod H.toSubmonoid K.toSubmonoid with\n    inv_mem' := fun hx => \u27e8H.inv_mem' hx.1, K.inv_mem' hx.2\u27e9 }", "start": [1723, 1], "end": [1729, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_prod", "code": "@[to_additive coe_prod]\ntheorem coe_prod (H : Subgroup G) (K : Subgroup N) :\n    (H.prod K : Set (G \u00d7 N)) = (H : Set G) \u00d7\u02e2 (K : Set N)", "start": [1733, 1], "end": [1736, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_prod", "code": "@[to_additive mem_prod]\ntheorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G \u00d7 N} : p \u2208 H.prod K \u2194 p.1 \u2208 H \u2227 p.2 \u2208 K", "start": [1740, 1], "end": [1742, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_mono", "code": "@[to_additive prod_mono]\ntheorem prod_mono : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) (@prod G _ N _) (@prod G _ N _)", "start": [1746, 1], "end": [1748, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_mono_right", "code": "@[to_additive prod_mono_right]\ntheorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.prod t", "start": [1752, 1], "end": [1754, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_mono_left", "code": "@[to_additive prod_mono_left]\ntheorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.prod H", "start": [1758, 1], "end": [1760, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_top", "code": "@[to_additive prod_top]\ntheorem prod_top (K : Subgroup G) : K.prod (\u22a4 : Subgroup N) = K.comap (MonoidHom.fst G N)", "start": [1764, 1], "end": [1766, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.top_prod", "code": "@[to_additive top_prod]\ntheorem top_prod (H : Subgroup N) : (\u22a4 : Subgroup G).prod H = H.comap (MonoidHom.snd G N)", "start": [1770, 1], "end": [1772, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.top_prod_top", "code": "@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (\u22a4 : Subgroup G).prod (\u22a4 : Subgroup N) = \u22a4", "start": [1776, 1], "end": [1778, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.bot_prod_bot", "code": "@[to_additive]\ntheorem bot_prod_bot : (\u22a5 : Subgroup G).prod (\u22a5 : Subgroup N) = \u22a5", "start": [1782, 1], "end": [1784, 62], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_prod_iff", "code": "@[to_additive le_prod_iff]\ntheorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G \u00d7 N)} :\n    J \u2264 H.prod K \u2194 map (MonoidHom.fst G N) J \u2264 H \u2227 map (MonoidHom.snd G N) J \u2264 K", "start": [1788, 1], "end": [1791, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_le_iff", "code": "@[to_additive prod_le_iff]\ntheorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G \u00d7 N)} :\n    H.prod K \u2264 J \u2194 map (MonoidHom.inl G N) H \u2264 J \u2227 map (MonoidHom.inr G N) K \u2264 J", "start": [1795, 1], "end": [1798, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_eq_bot_iff", "code": "@[to_additive (attr := simp) prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.prod K = \u22a5 \u2194 H = \u22a5 \u2227 K = \u22a5", "start": [1802, 1], "end": [1804, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prodEquiv", "code": "@[to_additive prodEquiv\n      \"Product of additive subgroups is isomorphic to their product\n      as additive groups\"]\ndef prodEquiv (H : Subgroup G) (K : Subgroup N) : H.prod K \u2243* H \u00d7 K :=\n  { Equiv.Set.prod (H : Set G) (K : Set N) with map_mul' := fun _ _ => rfl }", "start": [1808, 1], "end": [1813, 77], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pi", "code": "@[to_additive \" A version of `Set.pi` for `AddSubmonoid`s. Given an index set `I` and a family\n  of submodules `s : \u03a0 i, AddSubmonoid f i`, `pi I s` is the `AddSubmonoid` of dependent functions\n  `f : \u03a0 i, f i` such that `f i` belongs to `pi I s` whenever `i \u2208 I`. -/ \"]\ndef _root_.Submonoid.pi [\u2200 i, MulOneClass (f i)] (I : Set \u03b7) (s : \u2200 i, Submonoid (f i)) :\n    Submonoid (\u2200 i, f i) where\n  carrier := I.pi fun i => (s i).carrier\n  one_mem' i _ := (s i).one_mem\n  mul_mem' hp hq i hI := (s i).mul_mem (hp i hI) (hq i hI)", "start": [1822, 1], "end": [1832, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi", "code": "@[to_additive\n      \" A version of `Set.pi` for `AddSubgroup`s. Given an index set `I` and a family\n      of submodules `s : \u03a0 i, AddSubgroup f i`, `pi I s` is the `AddSubgroup` of dependent functions\n      `f : \u03a0 i, f i` such that `f i` belongs to `pi I s` whenever `i \u2208 I`. -/ \"]\ndef pi (I : Set \u03b7) (H : \u2200 i, Subgroup (f i)) : Subgroup (\u2200 i, f i) :=\n  { Submonoid.pi I fun i => (H i).toSubmonoid with\n    inv_mem' := fun hp i hI => (H i).inv_mem (hp i hI) }", "start": [1838, 1], "end": [1847, 57], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_pi", "code": "@[to_additive]\ntheorem coe_pi (I : Set \u03b7) (H : \u2200 i, Subgroup (f i)) :\n    (pi I H : Set (\u2200 i, f i)) = Set.pi I fun i => (H i : Set (f i))", "start": [1851, 1], "end": [1854, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_pi", "code": "@[to_additive]\ntheorem mem_pi (I : Set \u03b7) {H : \u2200 i, Subgroup (f i)} {p : \u2200 i, f i} :\n    p \u2208 pi I H \u2194 \u2200 i : \u03b7, i \u2208 I \u2192 p i \u2208 H i", "start": [1858, 1], "end": [1861, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_top", "code": "@[to_additive]\ntheorem pi_top (I : Set \u03b7) : (pi I fun i => (\u22a4 : Subgroup (f i))) = \u22a4", "start": [1865, 1], "end": [1867, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_empty", "code": "@[to_additive]\ntheorem pi_empty (H : \u2200 i, Subgroup (f i)) : pi \u2205 H = \u22a4", "start": [1871, 1], "end": [1873, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_bot", "code": "@[to_additive]\ntheorem pi_bot : (pi Set.univ fun i => (\u22a5 : Subgroup (f i))) = \u22a5", "start": [1877, 1], "end": [1882, 23], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_pi_iff", "code": "@[to_additive]\ntheorem le_pi_iff {I : Set \u03b7} {H : \u2200 i, Subgroup (f i)} {J : Subgroup (\u2200 i, f i)} :\n    J \u2264 pi I H \u2194 \u2200 i : \u03b7, i \u2208 I \u2192 map (Pi.evalMonoidHom f i) J \u2264 H i", "start": [1886, 1], "end": [1894, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mulSingle_mem_pi", "code": "@[to_additive (attr := simp)]\ntheorem mulSingle_mem_pi [DecidableEq \u03b7] {I : Set \u03b7} {H : \u2200 i, Subgroup (f i)} (i : \u03b7) (x : f i) :\n    Pi.mulSingle i x \u2208 pi I H \u2194 i \u2208 I \u2192 x \u2208 H i", "start": [1898, 1], "end": [1908, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_eq_bot_iff", "code": "@[to_additive]\ntheorem pi_eq_bot_iff (H : \u2200 i, Subgroup (f i)) : pi Set.univ H = \u22a5 \u2194 \u2200 i, H i = \u22a5", "start": [1912, 1], "end": [1921, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal", "code": "structure Normal : Prop where\n  \n  conj_mem : \u2200 n, n \u2208 H \u2192 \u2200 g : G, g * n * g\u207b\u00b9 \u2208 H", "start": [1927, 1], "end": [1930, 51], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.Normal", "code": "structure Normal (H : AddSubgroup A) : Prop where\n  \n  conj_mem : \u2200 n, n \u2208 H \u2192 \u2200 g : A, g + n + -g \u2208 H", "start": [1939, 1], "end": [1942, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_of_comm", "code": "@[to_additive]\ninstance (priority := 100) normal_of_comm {G : Type*} [CommGroup G] (H : Subgroup G) : H.Normal :=\n  \u27e8by simp [mul_comm, mul_left_comm]\u27e9", "start": [1955, 1], "end": [1957, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.mem_comm", "code": "@[to_additive]\ntheorem mem_comm {a b : G} (h : a * b \u2208 H) : b * a \u2208 H", "start": [1965, 1], "end": [1970, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.mem_comm_iff", "code": "@[to_additive]\ntheorem mem_comm_iff {a b : G} : a * b \u2208 H \u2194 b * a \u2208 H", "start": [1974, 1], "end": [1976, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Characteristic", "code": "structure Characteristic : Prop where\n  \n  fixed : \u2200 \u03d5 : G \u2243* G, H.comap \u03d5.toMonoidHom = H", "start": [1984, 1], "end": [1988, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_of_characteristic", "code": "instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=\n  \u27e8fun a ha b => (SetLike.ext_iff.mp (h.fixed (MulAut.conj b)) a).mpr ha\u27e9", "start": [1993, 1], "end": [1994, 74], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.Characteristic", "code": "structure Characteristic : Prop where\n  \n  fixed : \u2200 \u03d5 : A \u2243+ A, H.comap \u03d5.toAddMonoidHom = H", "start": [2003, 1], "end": [2007, 53], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.normal_of_characteristic", "code": "instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=\n  \u27e8fun a ha b => (SetLike.ext_iff.mp (h.fixed (AddAut.conj b)) a).mpr ha\u27e9", "start": [2014, 1], "end": [2015, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_comap_eq", "code": "@[to_additive]\ntheorem characteristic_iff_comap_eq : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H.comap \u03d5.toMonoidHom = H", "start": [2024, 1], "end": [2026, 44], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_comap_le", "code": "@[to_additive]\ntheorem characteristic_iff_comap_le : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H.comap \u03d5.toMonoidHom \u2264 H", "start": [2030, 1], "end": [2034, 98], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_le_comap", "code": "@[to_additive]\ntheorem characteristic_iff_le_comap : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H \u2264 H.comap \u03d5.toMonoidHom", "start": [2038, 1], "end": [2042, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_map_eq", "code": "@[to_additive]\ntheorem characteristic_iff_map_eq : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H.map \u03d5.toMonoidHom = H", "start": [2046, 1], "end": [2049, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_map_le", "code": "@[to_additive]\ntheorem characteristic_iff_map_le : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H.map \u03d5.toMonoidHom \u2264 H", "start": [2053, 1], "end": [2056, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.characteristic_iff_le_map", "code": "@[to_additive]\ntheorem characteristic_iff_le_map : H.Characteristic \u2194 \u2200 \u03d5 : G \u2243* G, H \u2264 H.map \u03d5.toMonoidHom", "start": [2060, 1], "end": [2063, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.botCharacteristic", "code": "@[to_additive]\ninstance botCharacteristic : Characteristic (\u22a5 : Subgroup G) :=\n  characteristic_iff_le_map.mpr fun _\u03d5 => bot_le", "start": [2067, 1], "end": [2069, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.topCharacteristic", "code": "@[to_additive]\ninstance topCharacteristic : Characteristic (\u22a4 : Subgroup G) :=\n  characteristic_iff_map_le.mpr fun _\u03d5 => le_top", "start": [2073, 1], "end": [2075, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center", "code": "@[to_additive\n      \"The center of an additive group `G` is the set of elements that commute with\n      everything in `G`\"]\ndef center : Subgroup G :=\n  { Submonoid.center G with\n    carrier := Set.center G\n    inv_mem' := Set.inv_mem_center }", "start": [2081, 1], "end": [2088, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_center", "code": "@[to_additive]\ntheorem coe_center : \u2191(center G) = Set.center G", "start": [2092, 1], "end": [2094, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center_toSubmonoid", "code": "@[to_additive (attr := simp)]\ntheorem center_toSubmonoid : (center G).toSubmonoid = Submonoid.center G", "start": [2098, 1], "end": [2100, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centerUnitsEquivUnitsCenter", "code": "@[simps! apply_val_coe symm_apply_coe_val]\ndef centerUnitsEquivUnitsCenter (G\u2080 : Type*) [GroupWithZero G\u2080] :\n    Subgroup.center (G\u2080\u02e3) \u2243* (Submonoid.center G\u2080)\u02e3 where\n  toFun := MonoidHom.toHomUnits <|\n    { toFun := fun u \u21a6 \u27e8(u : G\u2080\u02e3), fun r \u21a6 by\n        rcases eq_or_ne r 0 with (rfl | hr)\n        \u00b7 rw [mul_zero, zero_mul]\n        exact congrArg Units.val <| u.2 <| Units.mk0 r hr\u27e9\n      map_one' := rfl\n      map_mul' := fun _ _ \u21a6 rfl }\n  invFun u := unitsCenterToCenterUnits G\u2080 u\n  left_inv _ := by ext; rfl\n  right_inv _ := by ext; rfl\n  map_mul' := map_mul _", "start": [2104, 1], "end": [2118, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_center_iff", "code": "@[to_additive]\ntheorem mem_center_iff {z : G} : z \u2208 center G \u2194 \u2200 g, g * z = z * g", "start": [2122, 1], "end": [2124, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.decidableMemCenter", "code": "instance decidableMemCenter (z : G) [Decidable (\u2200 g, g * z = z * g)] : Decidable (z \u2208 center G) :=\n  decidable_of_iff' _ mem_center_iff", "start": [2128, 1], "end": [2129, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centerCharacteristic", "code": "@[to_additive]\ninstance centerCharacteristic : (center G).Characteristic := by\n  refine' characteristic_iff_comap_le.mpr fun \u03d5 g hg h => _\n  rw [\u2190 \u03d5.injective.eq_iff, \u03d5.map_mul, \u03d5.map_mul]\n  exact hg (\u03d5 h)", "start": [2132, 1], "end": [2136, 17], "kind": "commanddeclaration"}, {"full_name": "CommGroup.center_eq_top", "code": "theorem _root_.CommGroup.center_eq_top {G : Type*} [CommGroup G] : center G = \u22a4", "start": [2140, 1], "end": [2143, 21], "kind": "commanddeclaration"}, {"full_name": "Group.commGroupOfCenterEqTop", "code": "def _root_.Group.commGroupOfCenterEqTop (h : center G = \u22a4) : CommGroup G :=\n  { (_ : Group G) with\n    mul_comm := by\n      rw [eq_top_iff'] at h\n      intro x y\n      exact h y x }", "start": [2146, 1], "end": [2152, 20], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalizer", "code": "@[to_additive \"The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal.\"]\ndef normalizer : Subgroup G where\n  carrier := { g : G | \u2200 n, n \u2208 H \u2194 g * n * g\u207b\u00b9 \u2208 H }\n  one_mem' := by simp\n  mul_mem' {a b} (ha : \u2200 n, n \u2208 H \u2194 a * n * a\u207b\u00b9 \u2208 H) (hb : \u2200 n, n \u2208 H \u2194 b * n * b\u207b\u00b9 \u2208 H) n := by\n    rw [hb, ha]\n    simp only [mul_assoc, mul_inv_rev]\n  inv_mem' {a} (ha : \u2200 n, n \u2208 H \u2194 a * n * a\u207b\u00b9 \u2208 H) n := by\n    rw [ha (a\u207b\u00b9 * n * a\u207b\u00b9\u207b\u00b9)]\n    simp only [inv_inv, mul_assoc, mul_inv_cancel_left, mul_right_inv, mul_one]", "start": [2159, 1], "end": [2169, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.setNormalizer", "code": "@[to_additive\n      \"The `setNormalizer` of `S` is the subgroup of `G` whose elements satisfy\n      `g+S-g=S`.\"]\ndef setNormalizer (S : Set G) : Subgroup G where\n  carrier := { g : G | \u2200 n, n \u2208 S \u2194 g * n * g\u207b\u00b9 \u2208 S }\n  one_mem' := by simp\n  mul_mem' {a b} (ha : \u2200 n, n \u2208 S \u2194 a * n * a\u207b\u00b9 \u2208 S) (hb : \u2200 n, n \u2208 S \u2194 b * n * b\u207b\u00b9 \u2208 S) n := by\n    rw [hb, ha]\n    simp only [mul_assoc, mul_inv_rev]\n  inv_mem' {a} (ha : \u2200 n, n \u2208 S \u2194 a * n * a\u207b\u00b9 \u2208 S) n := by\n    rw [ha (a\u207b\u00b9 * n * a\u207b\u00b9\u207b\u00b9)]\n    simp only [inv_inv, mul_assoc, mul_inv_cancel_left, mul_right_inv, mul_one]", "start": [2175, 1], "end": [2187, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_normalizer_iff", "code": "@[to_additive]\ntheorem mem_normalizer_iff {g : G} : g \u2208 H.normalizer \u2194 \u2200 h, h \u2208 H \u2194 g * h * g\u207b\u00b9 \u2208 H", "start": [2193, 1], "end": [2195, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_normalizer_iff''", "code": "@[to_additive]\ntheorem mem_normalizer_iff'' {g : G} : g \u2208 H.normalizer \u2194 \u2200 h : G, h \u2208 H \u2194 g\u207b\u00b9 * h * g \u2208 H", "start": [2199, 1], "end": [2201, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_normalizer_iff'", "code": "@[to_additive]\ntheorem mem_normalizer_iff' {g : G} : g \u2208 H.normalizer \u2194 \u2200 n, n * g \u2208 H \u2194 g * n \u2208 H", "start": [2205, 1], "end": [2208, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_normalizer", "code": "@[to_additive]\ntheorem le_normalizer : H \u2264 normalizer H", "start": [2212, 1], "end": [2214, 71], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_in_normalizer", "code": "@[to_additive]\ninstance (priority := 100) normal_in_normalizer : (H.subgroupOf H.normalizer).Normal :=\n  \u27e8fun x xH g => by simpa only [mem_subgroupOf] using (g.2 x.1).1 xH\u27e9", "start": [2218, 1], "end": [2220, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalizer_eq_top", "code": "@[to_additive]\ntheorem normalizer_eq_top : H.normalizer = \u22a4 \u2194 H.Normal", "start": [2224, 1], "end": [2228, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center_le_normalizer", "code": "@[to_additive]\ntheorem center_le_normalizer : center G \u2264 H.normalizer", "start": [2232, 1], "end": [2234, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_normalizer_of_normal", "code": "@[to_additive]\ntheorem le_normalizer_of_normal [hK : (H.subgroupOf K).Normal] (HK : H \u2264 K) : K \u2264 H.normalizer", "start": [2240, 1], "end": [2245, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_normalizer_comap", "code": "@[to_additive \"The preimage of the normalizer is contained in the normalizer of the preimage.\"]\ntheorem le_normalizer_comap (f : N \u2192* G) :\n    H.normalizer.comap f \u2264 (H.comap f).normalizer", "start": [2251, 1], "end": [2257, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_normalizer_map", "code": "@[to_additive \"The image of the normalizer is contained in the normalizer of the image.\"]\ntheorem le_normalizer_map (f : G \u2192* N) : H.normalizer.map f \u2264 (H.map f).normalizer", "start": [2261, 1], "end": [2273, 30], "kind": "commanddeclaration"}, {"full_name": "NormalizerCondition", "code": "def _root_.NormalizerCondition :=\n  \u2200 H : Subgroup G, H < \u22a4 \u2192 H < normalizer H", "start": [2279, 1], "end": [2281, 45], "kind": "commanddeclaration"}, {"full_name": "normalizerCondition_iff_only_full_group_self_normalizing", "code": "theorem _root_.normalizerCondition_iff_only_full_group_self_normalizing :\n    NormalizerCondition G \u2194 \u2200 H : Subgroup G, H.normalizer = H \u2192 H = \u22a4", "start": [2286, 1], "end": [2292, 8], "kind": "commanddeclaration"}, {"full_name": "Subgroup.NormalizerCondition.normal_of_coatom", "code": "theorem NormalizerCondition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) :\n    H.Normal", "start": [2297, 1], "end": [2300, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centralizer", "code": "@[to_additive\n      \"The `centralizer` of `H` is the additive subgroup of `g : G` commuting with\\nevery `h : H`.\"]\ndef centralizer (s : Set G) : Subgroup G :=\n  { Submonoid.centralizer s with\n    carrier := Set.centralizer s\n    inv_mem' := Set.inv_mem_centralizer }", "start": [2309, 1], "end": [2315, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_centralizer_iff", "code": "@[to_additive]\ntheorem mem_centralizer_iff {g : G} {s : Set G} : g \u2208 centralizer s \u2194 \u2200 h \u2208 s, h * g = g * h", "start": [2319, 1], "end": [2321, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_centralizer_iff_commutator_eq_one", "code": "@[to_additive]\ntheorem mem_centralizer_iff_commutator_eq_one {g : G} {s : Set G} :\n    g \u2208 centralizer s \u2194 \u2200 h \u2208 s, h * g * h\u207b\u00b9 * g\u207b\u00b9 = 1", "start": [2325, 1], "end": [2328, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centralizer_univ", "code": "@[to_additive]\ntheorem centralizer_univ : centralizer Set.univ = center G", "start": [2332, 1], "end": [2334, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_centralizer_iff", "code": "@[to_additive]\ntheorem le_centralizer_iff : H \u2264 centralizer K \u2194 K \u2264 centralizer H", "start": [2338, 1], "end": [2340, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center_le_centralizer", "code": "@[to_additive]\ntheorem center_le_centralizer (s) : center G \u2264 centralizer s", "start": [2344, 1], "end": [2346, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centralizer_le", "code": "@[to_additive]\ntheorem centralizer_le {s t : Set G} (h : s \u2286 t) : centralizer t \u2264 centralizer s", "start": [2350, 1], "end": [2352, 29], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centralizer_eq_top_iff_subset", "code": "@[to_additive (attr := simp)]\ntheorem centralizer_eq_top_iff_subset {s : Set G} : centralizer s = \u22a4 \u2194 s \u2286 center G", "start": [2356, 1], "end": [2358, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Centralizer.characteristic", "code": "@[to_additive]\ninstance Centralizer.characteristic [hH : H.Characteristic] :\n    (centralizer (H : Set G)).Characteristic := by\n  refine' Subgroup.characteristic_iff_comap_le.mpr fun \u03d5 g hg h hh => \u03d5.injective _\n  rw [map_mul, map_mul]\n  exact hg (\u03d5 h) (Subgroup.characteristic_iff_le_comap.mp hH \u03d5 hh)", "start": [2362, 1], "end": [2367, 67], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsCommutative", "code": "structure IsCommutative : Prop where\n  \n  is_comm : IsCommutative H (\u00b7 * \u00b7)", "start": [2373, 1], "end": [2376, 36], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.IsCommutative", "code": "structure _root_.AddSubgroup.IsCommutative (H : AddSubgroup A) : Prop where\n  \n  is_comm : _root_.IsCommutative H (\u00b7 + \u00b7)", "start": [2381, 1], "end": [2384, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.IsCommutative.commGroup", "code": "@[to_additive \"A commutative subgroup is commutative.\"]\ninstance IsCommutative.commGroup [h : H.IsCommutative] : CommGroup H :=\n  { H.toGroup with mul_comm := h.is_comm.comm }", "start": [2391, 1], "end": [2394, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center.isCommutative", "code": "instance center.isCommutative : (center G).IsCommutative :=\n  \u27e8\u27e8fun a b => Subtype.ext (b.2 a)\u27e9\u27e9", "start": [2398, 1], "end": [2399, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_isCommutative", "code": "@[to_additive]\ninstance map_isCommutative (f : G \u2192* G') [H.IsCommutative] : (H.map f).IsCommutative :=\n  \u27e8\u27e8by\n      rintro \u27e8-, a, ha, rfl\u27e9 \u27e8-, b, hb, rfl\u27e9\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, \u2190 map_mul, \u2190 map_mul]\n      exact congr_arg f (Subtype.ext_iff.mp (mul_comm (\u27e8a, ha\u27e9 : H) \u27e8b, hb\u27e9))\u27e9\u27e9", "start": [2402, 1], "end": [2407, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_injective_isCommutative", "code": "@[to_additive]\ntheorem comap_injective_isCommutative {f : G' \u2192* G} (hf : Injective f) [H.IsCommutative] :\n    (H.comap f).IsCommutative", "start": [2411, 1], "end": [2419, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_isCommutative", "code": "@[to_additive]\ninstance subgroupOf_isCommutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=\n  H.comap_injective_isCommutative Subtype.coe_injective", "start": [2423, 1], "end": [2425, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_centralizer_iff_isCommutative", "code": "@[to_additive]\ntheorem le_centralizer_iff_isCommutative : K \u2264 centralizer K \u2194 K.IsCommutative", "start": [2429, 1], "end": [2432, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_centralizer", "code": "@[to_additive]\ntheorem le_centralizer [h : H.IsCommutative] : H \u2264 centralizer H", "start": [2436, 1], "end": [2438, 41], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOfSet", "code": "def conjugatesOfSet (s : Set G) : Set G :=\n  \u22c3 a \u2208 s, conjugatesOf a", "start": [2448, 1], "end": [2451, 26], "kind": "commanddeclaration"}, {"full_name": "Group.mem_conjugatesOfSet_iff", "code": "theorem mem_conjugatesOfSet_iff {x : G} : x \u2208 conjugatesOfSet s \u2194 \u2203 a \u2208 s, IsConj a x", "start": [2454, 1], "end": [2455, 93], "kind": "commanddeclaration"}, {"full_name": "Group.subset_conjugatesOfSet", "code": "theorem subset_conjugatesOfSet : s \u2286 conjugatesOfSet s", "start": [2458, 1], "end": [2459, 50], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOfSet_mono", "code": "theorem conjugatesOfSet_mono {s t : Set G} (h : s \u2286 t) : conjugatesOfSet s \u2286 conjugatesOfSet t", "start": [2462, 1], "end": [2463, 36], "kind": "commanddeclaration"}, {"full_name": "Group.conjugates_subset_normal", "code": "theorem conjugates_subset_normal {N : Subgroup G} [tn : N.Normal] {a : G} (h : a \u2208 N) :\n    conjugatesOf a \u2286 N", "start": [2466, 1], "end": [2470, 26], "kind": "commanddeclaration"}, {"full_name": "Group.conjugatesOfSet_subset", "code": "theorem conjugatesOfSet_subset {s : Set G} {N : Subgroup G} [N.Normal] (h : s \u2286 N) :\n    conjugatesOfSet s \u2286 N", "start": [2473, 1], "end": [2475, 64], "kind": "commanddeclaration"}, {"full_name": "Group.conj_mem_conjugatesOfSet", "code": "theorem conj_mem_conjugatesOfSet {x c : G} :\n    x \u2208 conjugatesOfSet s \u2192 c * x * c\u207b\u00b9 \u2208 conjugatesOfSet s", "start": [2478, 1], "end": [2482, 76], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure", "code": "def normalClosure (s : Set G) : Subgroup G :=\n  closure (conjugatesOfSet s)", "start": [2493, 1], "end": [2496, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.conjugatesOfSet_subset_normalClosure", "code": "theorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s \u2286 normalClosure s", "start": [2499, 1], "end": [2500, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subset_normalClosure", "code": "theorem subset_normalClosure : s \u2286 normalClosure s", "start": [2503, 1], "end": [2504, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_normalClosure", "code": "theorem le_normalClosure {H : Subgroup G} : H \u2264 normalClosure \u2191H", "start": [2507, 1], "end": [2508, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_normal", "code": "instance normalClosure_normal : (normalClosure s).Normal :=\n  \u27e8fun n h g => by\n    refine' Subgroup.closure_induction h (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _\n    \u00b7 exact conjugatesOfSet_subset_normalClosure (conj_mem_conjugatesOfSet hx)\n    \u00b7 simpa using (normalClosure s).one_mem\n    \u00b7 rw [\u2190 conj_mul]\n      exact mul_mem ihx ihy\n    \u00b7 rw [\u2190 conj_inv]\n      exact inv_mem ihx\u27e9", "start": [2511, 1], "end": [2520, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_le_normal", "code": "theorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s \u2286 N) : normalClosure s \u2264 N", "start": [2523, 1], "end": [2530, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_subset_iff", "code": "theorem normalClosure_subset_iff {N : Subgroup G} [N.Normal] : s \u2286 N \u2194 normalClosure s \u2264 N", "start": [2533, 1], "end": [2534, 67], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_mono", "code": "theorem normalClosure_mono {s t : Set G} (h : s \u2286 t) : normalClosure s \u2264 normalClosure t", "start": [2537, 1], "end": [2538, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_eq_iInf", "code": "theorem normalClosure_eq_iInf :\n    normalClosure s = \u2a05 (N : Subgroup G) (_ : Normal N) (_ : s \u2286 N), N", "start": [2541, 1], "end": [2545, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_eq_self", "code": "@[simp]\ntheorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure \u2191H = H", "start": [2548, 1], "end": [2550, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_idempotent", "code": "theorem normalClosure_idempotent : normalClosure \u2191(normalClosure s) = normalClosure s", "start": [2554, 1], "end": [2555, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_le_normalClosure", "code": "theorem closure_le_normalClosure {s : Set G} : closure s \u2264 normalClosure s", "start": [2558, 1], "end": [2559, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalClosure_closure_eq_normalClosure", "code": "@[simp]\ntheorem normalClosure_closure_eq_normalClosure {s : Set G} :\n    normalClosure \u2191(closure s) = normalClosure s", "start": [2562, 1], "end": [2565, 101], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore", "code": "def normalCore (H : Subgroup G) : Subgroup G where\n  carrier := { a : G | \u2200 b : G, b * a * b\u207b\u00b9 \u2208 H }\n  one_mem' a := by rw [mul_one, mul_inv_self]; exact H.one_mem\n  inv_mem' {a} h b := (congr_arg (\u00b7 \u2208 H) conj_inv).mp (H.inv_mem (h b))\n  mul_mem' {a b} ha hb c := (congr_arg (\u00b7 \u2208 H) conj_mul).mp (H.mul_mem (ha c) (hb c))", "start": [2568, 1], "end": [2574, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_le", "code": "theorem normalCore_le (H : Subgroup G) : H.normalCore \u2264 H", "start": [2577, 1], "end": [2579, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_normal", "code": "instance normalCore_normal (H : Subgroup G) : H.normalCore.Normal :=\n  \u27e8fun a h b c => by\n    rw [mul_assoc, mul_assoc, \u2190 mul_inv_rev, \u2190 mul_assoc, \u2190 mul_assoc]; exact h (c * b)\u27e9", "start": [2582, 1], "end": [2584, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_le_normalCore", "code": "theorem normal_le_normalCore {H : Subgroup G} {N : Subgroup G} [hN : N.Normal] :\n    N \u2264 H.normalCore \u2194 N \u2264 H", "start": [2587, 1], "end": [2589, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_mono", "code": "theorem normalCore_mono {H K : Subgroup G} (h : H \u2264 K) : H.normalCore \u2264 K.normalCore", "start": [2592, 1], "end": [2593, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_eq_iSup", "code": "theorem normalCore_eq_iSup (H : Subgroup G) :\n    H.normalCore = \u2a06 (N : Subgroup G) (_ : Normal N) (_ : N \u2264 H), N", "start": [2596, 1], "end": [2601, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_eq_self", "code": "@[simp]\ntheorem normalCore_eq_self (H : Subgroup G) [H.Normal] : H.normalCore = H", "start": [2604, 1], "end": [2606, 64], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_idempotent", "code": "theorem normalCore_idempotent (H : Subgroup G) : H.normalCore.normalCore = H.normalCore", "start": [2610, 1], "end": [2611, 34], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range", "code": "@[to_additive \"The range of an `AddMonoidHom` from an `AddGroup` is an `AddSubgroup`.\"]\ndef range (f : G \u2192* N) : Subgroup N :=\n  Subgroup.copy ((\u22a4 : Subgroup G).map f) (Set.range f) (by simp [Set.ext_iff])", "start": [2622, 1], "end": [2625, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_range", "code": "@[to_additive (attr := simp)]\ntheorem coe_range (f : G \u2192* N) : (f.range : Set N) = Set.range f", "start": [2629, 1], "end": [2631, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mem_range", "code": "@[to_additive (attr := simp)]\ntheorem mem_range {f : G \u2192* N} {y : N} : y \u2208 f.range \u2194 \u2203 x, f x = y", "start": [2635, 1], "end": [2637, 10], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range_eq_map", "code": "@[to_additive]\ntheorem range_eq_map (f : G \u2192* N) : f.range = (\u22a4 : Subgroup G).map f", "start": [2641, 1], "end": [2642, 85], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.restrict_range", "code": "@[to_additive (attr := simp)]\ntheorem restrict_range (f : G \u2192* N) : (f.restrict K).range = K.map f", "start": [2646, 1], "end": [2649, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.rangeRestrict", "code": "@[to_additive\n      \"The canonical surjective `AddGroup` homomorphism `G \u2192+ f(G)` induced by a group\n      homomorphism `G \u2192+ N`.\"]\ndef rangeRestrict (f : G \u2192* N) : G \u2192* f.range :=\n  codRestrict f _ fun x => \u27e8x, rfl\u27e9", "start": [2653, 1], "end": [2659, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_rangeRestrict", "code": "@[to_additive (attr := simp)]\ntheorem coe_rangeRestrict (f : G \u2192* N) (g : G) : (f.rangeRestrict g : N) = f g", "start": [2663, 1], "end": [2665, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_comp_rangeRestrict", "code": "@[to_additive]\ntheorem coe_comp_rangeRestrict (f : G \u2192* N) :\n    ((\u2191) : f.range \u2192 N) \u2218 (\u21d1f.rangeRestrict : G \u2192 f.range) = f", "start": [2669, 1], "end": [2672, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.subtype_comp_rangeRestrict", "code": "@[to_additive]\ntheorem subtype_comp_rangeRestrict (f : G \u2192* N) : f.range.subtype.comp f.rangeRestrict = f", "start": [2676, 1], "end": [2678, 29], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.rangeRestrict_surjective", "code": "@[to_additive]\ntheorem rangeRestrict_surjective (f : G \u2192* N) : Function.Surjective f.rangeRestrict", "start": [2682, 1], "end": [2684, 30], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.rangeRestrict_injective_iff", "code": "@[to_additive (attr := simp)]\nlemma rangeRestrict_injective_iff {f : G \u2192* N} : Injective f.rangeRestrict \u2194 Injective f := by\n  convert Set.injective_codRestrict _", "start": [2688, 1], "end": [2690, 38], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.map_range", "code": "@[to_additive]\ntheorem map_range (g : N \u2192* P) (f : G \u2192* N) : f.range.map g = (g.comp f).range", "start": [2692, 1], "end": [2694, 70], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range_top_iff_surjective", "code": "@[to_additive]\ntheorem range_top_iff_surjective {N} [Group N] {f : G \u2192* N} :\n    f.range = (\u22a4 : Subgroup N) \u2194 Function.Surjective f", "start": [2698, 1], "end": [2701, 92], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range_top_of_surjective", "code": "@[to_additive (attr := simp)\n  \"The range of a surjective `AddMonoid` homomorphism is the whole of the codomain.\"]\ntheorem range_top_of_surjective {N} [Group N] (f : G \u2192* N) (hf : Function.Surjective f) :\n    f.range = (\u22a4 : Subgroup N)", "start": [2705, 1], "end": [2710, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range_one", "code": "@[to_additive (attr := simp)]\ntheorem range_one : (1 : G \u2192* N).range = \u22a5", "start": [2714, 1], "end": [2716, 60], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subtype_range", "code": "@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.subtype_range (H : Subgroup G) : H.subtype.range = H", "start": [2720, 1], "end": [2724, 7], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inclusion_range", "code": "@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.inclusion_range {H K : Subgroup G} (h_le : H \u2264 K) :\n    (inclusion h_le).range = H.subgroupOf K", "start": [2728, 1], "end": [2731, 68], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.subgroupOf_range_eq_of_le", "code": "@[to_additive]\ntheorem subgroupOf_range_eq_of_le {G\u2081 G\u2082 : Type*} [Group G\u2081] [Group G\u2082] {K : Subgroup G\u2082}\n    (f : G\u2081 \u2192* G\u2082) (h : f.range \u2264 K) :\n    f.range.subgroupOf K = (f.codRestrict K fun x => h \u27e8x, rfl\u27e9).range", "start": [2735, 1], "end": [2741, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_toAdditive_range", "code": "@[simp]\ntheorem coe_toAdditive_range (f : G \u2192* G') :\n    (MonoidHom.toAdditive f).range = Subgroup.toAddSubgroup f.range", "start": [2745, 1], "end": [2747, 75], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_toMultiplicative_range", "code": "@[simp]\ntheorem coe_toMultiplicative_range {A A' : Type*} [AddGroup A] [AddGroup A'] (f : A \u2192+ A') :\n    (AddMonoidHom.toMultiplicative f).range = AddSubgroup.toSubgroup f.range", "start": [2749, 1], "end": [2751, 84], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofLeftInverse", "code": "@[to_additive \"Computable alternative to `AddMonoidHom.ofInjective`.\"]\ndef ofLeftInverse {f : G \u2192* N} {g : N \u2192* G} (h : Function.LeftInverse g f) : G \u2243* f.range :=\n  { f.rangeRestrict with\n    toFun := f.rangeRestrict\n    invFun := g \u2218 f.range.subtype\n    left_inv := h\n    right_inv := by\n      rintro \u27e8x, y, rfl\u27e9\n      apply Subtype.ext\n      rw [coe_rangeRestrict, Function.comp_apply, Subgroup.coeSubtype, Subtype.coe_mk, h] }", "start": [2753, 1], "end": [2763, 92], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofLeftInverse_apply", "code": "@[to_additive (attr := simp)]\ntheorem ofLeftInverse_apply {f : G \u2192* N} {g : N \u2192* G} (h : Function.LeftInverse g f) (x : G) :\n    \u2191(ofLeftInverse h x) = f x", "start": [2767, 1], "end": [2770, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofLeftInverse_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem ofLeftInverse_symm_apply {f : G \u2192* N} {g : N \u2192* G} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x", "start": [2774, 1], "end": [2777, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofInjective", "code": "@[to_additive \"The range of an injective additive group homomorphism is isomorphic to its\ndomain.\"]\nnoncomputable def ofInjective {f : G \u2192* N} (hf : Function.Injective f) : G \u2243* f.range :=\n  MulEquiv.ofBijective (f.codRestrict f.range fun x => \u27e8x, rfl\u27e9)\n    \u27e8fun x y h => hf (Subtype.ext_iff.mp h), by\n      rintro \u27e8x, y, rfl\u27e9\n      exact \u27e8y, rfl\u27e9\u27e9", "start": [2781, 1], "end": [2788, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ofInjective_apply", "code": "@[to_additive]\ntheorem ofInjective_apply {f : G \u2192* N} (hf : Function.Injective f) {x : G} :\n    \u2191(ofInjective hf x) = f x", "start": [2792, 1], "end": [2795, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.apply_ofInjective_symm", "code": "@[to_additive (attr := simp)]\ntheorem apply_ofInjective_symm {f : G \u2192* N} (hf : Function.Injective f) (x : f.range) :\n    f ((ofInjective hf).symm x) = x", "start": [2799, 1], "end": [2802, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker", "code": "@[to_additive\n      \"The additive kernel of an `AddMonoid` homomorphism is the `AddSubgroup` of elements\n      such that `f x = 0`\"]\ndef ker (f : G \u2192* M) : Subgroup G :=\n  { MonoidHom.mker f with\n    inv_mem' := fun {x} (hx : f x = 1) =>\n      calc\n        f x\u207b\u00b9 = f x * f x\u207b\u00b9 := by rw [hx, one_mul]\n        _ = 1 := by rw [\u2190 map_mul, mul_inv_self, map_one] }", "start": [2808, 1], "end": [2818, 60], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.mem_ker", "code": "@[to_additive]\ntheorem mem_ker (f : G \u2192* M) {x : G} : x \u2208 f.ker \u2194 f x = 1", "start": [2822, 1], "end": [2824, 10], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_ker", "code": "@[to_additive]\ntheorem coe_ker (f : G \u2192* M) : (f.ker : Set G) = (f : G \u2192 M) \u207b\u00b9' {1}", "start": [2828, 1], "end": [2830, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_toHomUnits", "code": "@[to_additive (attr := simp)]\ntheorem ker_toHomUnits {M} [Monoid M] (f : G \u2192* M) : f.toHomUnits.ker = f.ker", "start": [2834, 1], "end": [2837, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_iff", "code": "@[to_additive]\ntheorem eq_iff (f : G \u2192* M) {x y : G} : f x = f y \u2194 y\u207b\u00b9 * x \u2208 f.ker", "start": [2841, 1], "end": [2845, 83], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.decidableMemKer", "code": "@[to_additive]\ninstance decidableMemKer [DecidableEq M] (f : G \u2192* M) : DecidablePred (\u00b7 \u2208 f.ker) := fun x =>\n  decidable_of_iff (f x = 1) f.mem_ker", "start": [2849, 1], "end": [2851, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comap_ker", "code": "@[to_additive]\ntheorem comap_ker (g : N \u2192* P) (f : G \u2192* N) : g.ker.comap f = (g.comp f).ker", "start": [2855, 1], "end": [2857, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.comap_bot", "code": "@[to_additive (attr := simp)]\ntheorem comap_bot (f : G \u2192* N) : (\u22a5 : Subgroup N).comap f = f.ker", "start": [2861, 1], "end": [2863, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_restrict", "code": "@[to_additive (attr := simp)]\ntheorem ker_restrict (f : G \u2192* N) : (f.restrict K).ker = f.ker.subgroupOf K", "start": [2867, 1], "end": [2869, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_codRestrict", "code": "@[to_additive (attr := simp)]\ntheorem ker_codRestrict {S} [SetLike S N] [SubmonoidClass S N] (f : G \u2192* N) (s : S)\n    (h : \u2200 x, f x \u2208 s) : (f.codRestrict s h).ker = f.ker", "start": [2873, 1], "end": [2876, 40], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_rangeRestrict", "code": "@[to_additive (attr := simp)]\ntheorem ker_rangeRestrict (f : G \u2192* N) : ker (rangeRestrict f) = ker f", "start": [2880, 1], "end": [2882, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_one", "code": "@[to_additive (attr := simp)]\ntheorem ker_one : (1 : G \u2192* M).ker = \u22a4", "start": [2886, 1], "end": [2888, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_id", "code": "@[to_additive (attr := simp)]\ntheorem ker_id : (MonoidHom.id G).ker = \u22a5", "start": [2892, 1], "end": [2894, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_eq_bot_iff", "code": "@[to_additive]\ntheorem ker_eq_bot_iff (f : G \u2192* M) : f.ker = \u22a5 \u2194 Function.Injective f", "start": [2898, 1], "end": [2901, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ker_subtype", "code": "@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = \u22a5", "start": [2905, 1], "end": [2907, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ker_inclusion", "code": "@[to_additive (attr := simp)]\ntheorem _root_.Subgroup.ker_inclusion {H K : Subgroup G} (h : H \u2264 K) : (inclusion h).ker = \u22a5", "start": [2911, 1], "end": [2913, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_prod", "code": "@[to_additive]\ntheorem ker_prod {M N : Type*} [MulOneClass M] [MulOneClass N] (f : G \u2192* M) (g : G \u2192* N) :\n    (f.prod g).ker = f.ker \u2293 g.ker", "start": [2917, 1], "end": [2920, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.prodMap_comap_prod", "code": "@[to_additive]\ntheorem prodMap_comap_prod {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G \u2192* N)\n    (g : G' \u2192* N') (S : Subgroup N) (S' : Subgroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g)", "start": [2922, 1], "end": [2926, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_prodMap", "code": "@[to_additive]\ntheorem ker_prodMap {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G \u2192* N) (g : G' \u2192* N') :\n    (prodMap f g).ker = f.ker.prod g.ker", "start": [2930, 1], "end": [2933, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.range_le_ker_iff", "code": "@[to_additive]\ntheorem range_le_ker_iff (f : G \u2192* G') (g : G' \u2192* G'') : f.range \u2264 g.ker \u2194 g.comp f = 1", "start": [2937, 1], "end": [2939, 90], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.normal_ker", "code": "@[to_additive]\ninstance (priority := 100) normal_ker (f : G \u2192* M) : f.ker.Normal :=\n  \u27e8fun x hx y => by\n    rw [mem_ker, map_mul, map_mul, f.mem_ker.1 hx, mul_one, map_mul_eq_one f (mul_inv_self y)]\u27e9", "start": [2941, 1], "end": [2944, 96], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.ker_fst", "code": "@[to_additive (attr := simp)]\nlemma ker_fst : ker (fst G G') = .prod \u22a5 \u22a4 := SetLike.ext fun _ => (and_true_iff _).symm", "start": [2948, 1], "end": [2949, 89], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.ker_snd", "code": "@[to_additive (attr := simp)]\nlemma ker_snd : ker (snd G G') = .prod \u22a4 \u22a5 := SetLike.ext fun _ => (true_and_iff _).symm", "start": [2951, 1], "end": [2952, 89], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.coe_toAdditive_ker", "code": "@[simp]\ntheorem coe_toAdditive_ker (f : G \u2192* G') :\n    (MonoidHom.toAdditive f).ker = Subgroup.toAddSubgroup f.ker", "start": [2954, 1], "end": [2956, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_toMultiplicative_ker", "code": "@[simp]\ntheorem coe_toMultiplicative_ker {A A' : Type*} [AddGroup A] [AddGroup A'] (f : A \u2192+ A') :\n    (AddMonoidHom.toMultiplicative f).ker = AddSubgroup.toSubgroup f.ker", "start": [2958, 1], "end": [2960, 80], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqLocus", "code": "@[to_additive \"The additive subgroup of elements `x : G` such that `f x = g x`\"]\ndef eqLocus (f g : G \u2192* M) : Subgroup G :=\n  { eqLocusM f g with inv_mem' := eq_on_inv f g }", "start": [2968, 1], "end": [2971, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqLocus_same", "code": "@[to_additive (attr := simp)]\ntheorem eqLocus_same (f : G \u2192* N) : f.eqLocus f = \u22a4", "start": [2975, 1], "end": [2977, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eqOn_closure", "code": "@[to_additive\n      \"If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\n      closure.\"]\ntheorem eqOn_closure {f g : G \u2192* M} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s)", "start": [2981, 1], "end": [2986, 55], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_of_eqOn_top", "code": "@[to_additive]\ntheorem eq_of_eqOn_top {f g : G \u2192* M} (h : Set.EqOn f g (\u22a4 : Subgroup G)) : f = g", "start": [2990, 1], "end": [2992, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_of_eqOn_dense", "code": "@[to_additive]\ntheorem eq_of_eqOn_dense {s : Set G} (hs : closure s = \u22a4) {f g : G \u2192* M} (h : s.EqOn f g) : f = g", "start": [2996, 1], "end": [2998, 40], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.closure_preimage_le", "code": "@[to_additive]\ntheorem closure_preimage_le (f : G \u2192* N) (s : Set N) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [3004, 1], "end": [3006, 91], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_closure", "code": "@[to_additive\n      \"The image under an `AddMonoid` hom of the `AddSubgroup` generated by a set equals\n      the `AddSubgroup` generated by the image of the set.\"]\ntheorem map_closure (f : G \u2192* N) (s : Set G) : (closure s).map f = closure (f '' s)", "start": [3010, 1], "end": [3017, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.map", "code": "@[to_additive]\ntheorem Normal.map {H : Subgroup G} (h : H.Normal) (f : G \u2192* N) (hf : Function.Surjective f) :\n    (H.map f).Normal", "start": [3027, 1], "end": [3032, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_eq_bot_iff", "code": "@[to_additive]\ntheorem map_eq_bot_iff {f : G \u2192* N} : H.map f = \u22a5 \u2194 H \u2264 f.ker", "start": [3036, 1], "end": [3038, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_eq_bot_iff_of_injective", "code": "@[to_additive]\ntheorem map_eq_bot_iff_of_injective {f : G \u2192* N} (hf : Function.Injective f) :\n    H.map f = \u22a5 \u2194 H = \u22a5", "start": [3042, 1], "end": [3044, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_le_range", "code": "@[to_additive]\ntheorem map_le_range (H : Subgroup G) : map f H \u2264 f.range", "start": [3056, 1], "end": [3058, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_subtype_le", "code": "@[to_additive]\ntheorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.subtype \u2264 H", "start": [3062, 1], "end": [3064, 62], "kind": "commanddeclaration"}, {"full_name": "Subgroup.ker_le_comap", "code": "@[to_additive]\ntheorem ker_le_comap (H : Subgroup N) : f.ker \u2264 comap f H", "start": [3068, 1], "end": [3070, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_comap_le", "code": "@[to_additive]\ntheorem map_comap_le (H : Subgroup N) : map f (comap f H) \u2264 H", "start": [3074, 1], "end": [3076, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_comap_map", "code": "@[to_additive]\ntheorem le_comap_map (H : Subgroup G) : H \u2264 comap f (map f H)", "start": [3080, 1], "end": [3082, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_comap_eq", "code": "@[to_additive]\ntheorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range \u2293 H", "start": [3086, 1], "end": [3089, 99], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_map_eq", "code": "@[to_additive]\ntheorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H \u2294 f.ker", "start": [3093, 1], "end": [3099, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_comap_eq_self", "code": "@[to_additive]\ntheorem map_comap_eq_self {f : G \u2192* N} {H : Subgroup N} (h : H \u2264 f.range) : map f (comap f H) = H", "start": [3103, 1], "end": [3105, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_comap_eq_self_of_surjective", "code": "@[to_additive]\ntheorem map_comap_eq_self_of_surjective {f : G \u2192* N} (h : Function.Surjective f) (H : Subgroup N) :\n    map f (comap f H) = H", "start": [3109, 1], "end": [3112, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_le_comap_of_le_range", "code": "@[to_additive]\ntheorem comap_le_comap_of_le_range {f : G \u2192* N} {K L : Subgroup N} (hf : K \u2264 f.range) :\n    K.comap f \u2264 L.comap f \u2194 K \u2264 L", "start": [3116, 1], "end": [3119, 74], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_le_comap_of_surjective", "code": "@[to_additive]\ntheorem comap_le_comap_of_surjective {f : G \u2192* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f \u2264 L.comap f \u2194 K \u2264 L", "start": [3123, 1], "end": [3126, 78], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_lt_comap_of_surjective", "code": "@[to_additive]\ntheorem comap_lt_comap_of_surjective {f : G \u2192* N} {K L : Subgroup N} (hf : Function.Surjective f) :\n    K.comap f < L.comap f \u2194 K < L", "start": [3130, 1], "end": [3132, 100], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_injective", "code": "@[to_additive]\ntheorem comap_injective {f : G \u2192* N} (h : Function.Surjective f) : Function.Injective (comap f)", "start": [3136, 1], "end": [3138, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_map_eq_self", "code": "@[to_additive]\ntheorem comap_map_eq_self {f : G \u2192* N} {H : Subgroup G} (h : f.ker \u2264 H) : comap f (map f H) = H", "start": [3142, 1], "end": [3144, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_map_eq_self_of_injective", "code": "@[to_additive]\ntheorem comap_map_eq_self_of_injective {f : G \u2192* N} (h : Function.Injective f) (H : Subgroup G) :\n    comap f (map f H) = H", "start": [3148, 1], "end": [3151, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_le_map_iff", "code": "@[to_additive]\ntheorem map_le_map_iff {f : G \u2192* N} {H K : Subgroup G} : H.map f \u2264 K.map f \u2194 H \u2264 K \u2294 f.ker", "start": [3155, 1], "end": [3157, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_le_map_iff'", "code": "@[to_additive]\ntheorem map_le_map_iff' {f : G \u2192* N} {H K : Subgroup G} :\n    H.map f \u2264 K.map f \u2194 H \u2294 f.ker \u2264 K \u2294 f.ker", "start": [3161, 1], "end": [3164, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_eq_map_iff", "code": "@[to_additive]\ntheorem map_eq_map_iff {f : G \u2192* N} {H K : Subgroup G} :\n    H.map f = K.map f \u2194 H \u2294 f.ker = K \u2294 f.ker", "start": [3168, 1], "end": [3170, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_eq_range_iff", "code": "@[to_additive]\ntheorem map_eq_range_iff {f : G \u2192* N} {H : Subgroup G} : H.map f = f.range \u2194 Codisjoint H f.ker", "start": [3174, 1], "end": [3176, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_le_map_iff_of_injective", "code": "@[to_additive]\ntheorem map_le_map_iff_of_injective {f : G \u2192* N} (hf : Function.Injective f) {H K : Subgroup G} :\n    H.map f \u2264 K.map f \u2194 H \u2264 K", "start": [3180, 1], "end": [3182, 96], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_subtype_le_map_subtype", "code": "@[to_additive (attr := simp)]\ntheorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :\n    H.map G'.subtype \u2264 K.map G'.subtype \u2194 H \u2264 K", "start": [3186, 1], "end": [3189, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_injective", "code": "@[to_additive]\ntheorem map_injective {f : G \u2192* N} (h : Function.Injective f) : Function.Injective (map f)", "start": [3193, 1], "end": [3195, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_eq_comap_of_inverse", "code": "@[to_additive]\ntheorem map_eq_comap_of_inverse {f : G \u2192* N} {g : N \u2192* G} (hl : Function.LeftInverse g f)\n    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H", "start": [3199, 1], "end": [3202, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_injective_of_ker_le", "code": "@[to_additive \"Given `f(A) = f(B)`, `ker f \u2264 A`, and `ker f \u2264 B`, deduce that `A = B`.\"]\ntheorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker \u2264 H) (hK : f.ker \u2264 K)\n    (hf : map f H = map f K) : H = K", "start": [3206, 1], "end": [3211, 79], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_preimage_eq_top", "code": "@[to_additive]\ntheorem closure_preimage_eq_top (s : Set G) : closure ((closure s).subtype \u207b\u00b9' s) = \u22a4", "start": [3215, 1], "end": [3221, 23], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_sup_eq_of_le_range", "code": "@[to_additive]\ntheorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H \u2264 f.range) (hK : K \u2264 f.range) :\n    comap f H \u2294 comap f K = comap f (H \u2294 K)", "start": [3225, 1], "end": [3231, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_sup_eq", "code": "@[to_additive]\ntheorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) :\n    comap f H \u2294 comap f K = comap f (H \u2294 K)", "start": [3235, 1], "end": [3239, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sup_subgroupOf_eq", "code": "@[to_additive]\ntheorem sup_subgroupOf_eq {H K L : Subgroup G} (hH : H \u2264 L) (hK : K \u2264 L) :\n    H.subgroupOf L \u2294 K.subgroupOf L = (H \u2294 K).subgroupOf L", "start": [3243, 1], "end": [3246, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.codisjoint_subgroupOf_sup", "code": "@[to_additive]\ntheorem codisjoint_subgroupOf_sup (H K : Subgroup G) :\n    Codisjoint (H.subgroupOf (H \u2294 K)) (K.subgroupOf (H \u2294 K))", "start": [3250, 1], "end": [3254, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.equivMapOfInjective", "code": "@[to_additive\n      \"An additive subgroup is isomorphic to its image under an injective function. If you\n      have an isomorphism, use `AddEquiv.addSubgroupMap` for better definitional equalities.\"]\nnoncomputable def equivMapOfInjective (H : Subgroup G) (f : G \u2192* N) (hf : Function.Injective f) :\n    H \u2243* H.map f :=\n  { Equiv.Set.image f H hf with map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _) }", "start": [3258, 1], "end": [3265, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_equivMapOfInjective_apply", "code": "@[to_additive (attr := simp)]\ntheorem coe_equivMapOfInjective_apply (H : Subgroup G) (f : G \u2192* N) (hf : Function.Injective f)\n    (h : H) : (equivMapOfInjective H f hf h : N) = f h", "start": [3269, 1], "end": [3272, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_normalizer_eq_of_surjective", "code": "@[to_additive\n      \"The preimage of the normalizer is equal to the normalizer of the preimage of\n      a surjective function.\"]\ntheorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N \u2192* G}\n    (hf : Function.Surjective f) : H.normalizer.comap f = (H.comap f).normalizer", "start": [3276, 1], "end": [3289, 19], "kind": "commanddeclaration"}, {"full_name": "Subgroup.comap_normalizer_eq_of_injective_of_le_range", "code": "@[to_additive]\ntheorem comap_normalizer_eq_of_injective_of_le_range {N : Type*} [Group N] (H : Subgroup G)\n    {f : N \u2192* G} (hf : Function.Injective f) (h : H.normalizer \u2264 f.range) :\n    comap f H.normalizer = (comap f H).normalizer", "start": [3293, 1], "end": [3303, 54], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_normalizer_eq", "code": "@[to_additive]\ntheorem subgroupOf_normalizer_eq {H N : Subgroup G} (h : H.normalizer \u2264 N) :\n    H.normalizer.subgroupOf N = (H.subgroupOf N).normalizer", "start": [3307, 1], "end": [3312, 8], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_equiv_normalizer_eq", "code": "@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of an\n      isomorphism.\"]\ntheorem map_equiv_normalizer_eq (H : Subgroup G) (f : G \u2243* N) :\n    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer", "start": [3316, 1], "end": [3328, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_normalizer_eq_of_bijective", "code": "@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of a bijective\n        function.\"]\ntheorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G \u2192* N} (hf : Function.Bijective f) :\n    H.normalizer.map f = (H.map f).normalizer", "start": [3332, 1], "end": [3339, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfRightInverseAux", "code": "@[to_additive \"Auxiliary definition used to define `liftOfRightInverse`\"]\ndef liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : G\u2081 \u2192* G\u2083) (hg : f.ker \u2264 g.ker) :\n    G\u2082 \u2192* G\u2083 where\n  toFun b := g (f_inv b)\n  map_one' := hg (hf 1)\n  map_mul' := by\n    intro x y\n    rw [\u2190 g.map_mul, \u2190 mul_inv_eq_one, \u2190 g.map_inv, \u2190 g.map_mul, \u2190 g.mem_ker]\n    apply hg\n    rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one, f.map_mul]\n    simp only [hf _]", "start": [3351, 1], "end": [3362, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfRightInverseAux_comp_apply", "code": "@[to_additive (attr := simp)]\ntheorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G\u2081 \u2192* G\u2083)\n    (hg : f.ker \u2264 g.ker) (x : G\u2081) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x", "start": [3366, 1], "end": [3373, 19], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfRightInverse", "code": "@[to_additive\n      \"`liftOfRightInverse f f_inv hf g hg` is the unique additive group homomorphism `\u03c6`\n      * such that `\u03c6.comp f = g` (`AddMonoidHom.liftOfRightInverse_comp`),\n      * where `f : G\u2081 \u2192+ G\u2082` has a RightInverse `f_inv` (`hf`),\n      * and `g : G\u2082 \u2192+ G\u2083` satisfies `hg : f.ker \u2264 g.ker`.\n      See `AddMonoidHom.eq_liftOfRightInverse` for the uniqueness lemma.\n      ```\n         G\u2081.\n         |  \\\\\n       f |   \\\\ g\n         |    \\\\\n         v     \\\\\u231f\n         G\u2082            \u2203!\u03c6\n      ```\"]\ndef liftOfRightInverse (hf : Function.RightInverse f_inv f) :\n    { g : G\u2081 \u2192* G\u2083 // f.ker \u2264 g.ker } \u2243 (G\u2082 \u2192* G\u2083)\n    where\n  toFun g := f.liftOfRightInverseAux f_inv hf g.1 g.2\n  invFun \u03c6 := \u27e8\u03c6.comp f, fun x hx => (mem_ker _).mpr <| by simp [(mem_ker _).mp hx]\u27e9\n  left_inv g := by\n    ext\n    simp only [comp_apply, liftOfRightInverseAux_comp_apply, Subtype.coe_mk]\n  right_inv \u03c6 := by\n    ext b\n    simp [liftOfRightInverseAux, hf b]", "start": [3377, 1], "end": [3420, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfSurjective", "code": "@[to_additive (attr := simp)\n      \"A non-computable version of `AddMonoidHom.liftOfRightInverse` for when no\n      computable right inverse is available.\"]\nnoncomputable abbrev liftOfSurjective (hf : Function.Surjective f) :\n    { g : G\u2081 \u2192* G\u2083 // f.ker \u2264 g.ker } \u2243 (G\u2082 \u2192* G\u2083) :=\n  f.liftOfRightInverse (Function.surjInv hf) (Function.rightInverse_surjInv hf)", "start": [3424, 1], "end": [3431, 80], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfRightInverse_comp_apply", "code": "@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)\n    (g : { g : G\u2081 \u2192* G\u2083 // f.ker \u2264 g.ker }) (x : G\u2081) :\n    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x", "start": [3435, 1], "end": [3439, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.liftOfRightInverse_comp", "code": "@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)\n    (g : { g : G\u2081 \u2192* G\u2083 // f.ker \u2264 g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g", "start": [3443, 1], "end": [3446, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.eq_liftOfRightInverse", "code": "@[to_additive]\ntheorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G\u2081 \u2192* G\u2083)\n    (hg : f.ker \u2264 g.ker) (h : G\u2082 \u2192* G\u2083) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf \u27e8g, hg\u27e9", "start": [3450, 1], "end": [3455, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.comap", "code": "@[to_additive]\ntheorem Subgroup.Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G \u2192* N) : (H.comap f).Normal", "start": [3464, 1], "end": [3466, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_comap", "code": "@[to_additive]\ninstance (priority := 100) Subgroup.normal_comap {H : Subgroup N} [nH : H.Normal] (f : G \u2192* N) :\n    (H.comap f).Normal :=\n  nH.comap _", "start": [3470, 1], "end": [3473, 13], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.subgroupOf", "code": "@[to_additive]\ntheorem Subgroup.Normal.subgroupOf {H : Subgroup G} (hH : H.Normal) (K : Subgroup G) :\n    (H.subgroupOf K).Normal", "start": [3478, 1], "end": [3481, 13], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_subgroupOf", "code": "@[to_additive]\ninstance (priority := 100) Subgroup.normal_subgroupOf {H N : Subgroup G} [N.Normal] :\n    (N.subgroupOf H).Normal :=\n  Subgroup.normal_comap _", "start": [3485, 1], "end": [3488, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.subgroupComap", "code": "@[to_additive (attr := simps!) \"the `AddMonoidHom` from the preimage of an\nadditive subgroup to itself.\"]\ndef subgroupComap (f : G \u2192* G') (H' : Subgroup G') : H'.comap f \u2192* H' :=\n  f.submonoidComap H'.toSubmonoid", "start": [3494, 1], "end": [3498, 34], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.subgroupMap", "code": "@[to_additive (attr := simps!) \"the `AddMonoidHom` from an additive subgroup to its image\"]\ndef subgroupMap (f : G \u2192* G') (H : Subgroup G) : H \u2192* H.map f :=\n  f.submonoidMap H.toSubmonoid", "start": [3504, 1], "end": [3507, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.subgroupMap_surjective", "code": "@[to_additive]\ntheorem subgroupMap_surjective (f : G \u2192* G') (H : Subgroup G) :\n    Function.Surjective (f.subgroupMap H)", "start": [3513, 1], "end": [3516, 42], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.subgroupCongr", "code": "@[to_additive\n      \"Makes the identity additive isomorphism from a proof\n      two subgroups of an additive group are equal.\"]\ndef subgroupCongr (h : H = K) : H \u2243* K :=\n  { Equiv.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }", "start": [3526, 1], "end": [3532, 70], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.subgroupMap", "code": "@[to_additive\n      \"An additive subgroup is isomorphic to its image under an isomorphism. If you only\n      have an injective map, use `AddSubgroup.equiv_map_of_injective`.\"]\ndef subgroupMap (e : G \u2243* G') (H : Subgroup G) : H \u2243* H.map (e : G \u2192* G') :=\n  MulEquiv.submonoidMap (e : G \u2243* G') H.toSubmonoid", "start": [3536, 1], "end": [3542, 52], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.coe_subgroupMap_apply", "code": "@[to_additive (attr := simp)]\ntheorem coe_subgroupMap_apply (e : G \u2243* G') (H : Subgroup G) (g : H) :\n    ((subgroupMap e H g : H.map (e : G \u2192* G')) : G') = e g", "start": [3546, 1], "end": [3549, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.subgroupMap_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem subgroupMap_symm_apply (e : G \u2243* G') (H : Subgroup G) (g : H.map (e : G \u2192* G')) :\n    (e.subgroupMap H).symm g = \u27e8e.symm g, SetLike.mem_coe.1 <| Set.mem_image_equiv.1 g.2\u27e9", "start": [3553, 1], "end": [3556, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.equivMapOfInjective_coe_mulEquiv", "code": "@[to_additive (attr := simp)]\ntheorem equivMapOfInjective_coe_mulEquiv (H : Subgroup G) (e : G \u2243* G') :\n    H.equivMapOfInjective (e : G \u2192* G') (EquivLike.injective e) = e.subgroupMap H", "start": [3564, 1], "end": [3568, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sup", "code": "@[to_additive]\ntheorem mem_sup : x \u2208 s \u2294 t \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x", "start": [3574, 1], "end": [3587, 57], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_sup'", "code": "@[to_additive]\ntheorem mem_sup' : x \u2208 s \u2294 t \u2194 \u2203 (y : s) (z : t), (y : C) * z = x", "start": [3591, 1], "end": [3593, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_closure_pair", "code": "@[to_additive]\ntheorem mem_closure_pair {x y z : C} :\n    z \u2208 closure ({x, y} : Set C) \u2194 \u2203 m n : \u2124, x ^ m * y ^ n = z", "start": [3597, 1], "end": [3601, 56], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_subgroupOf_iff", "code": "@[to_additive]\ntheorem normal_subgroupOf_iff {H K : Subgroup G} (hHK : H \u2264 K) :\n    (H.subgroupOf K).Normal \u2194 \u2200 h k, h \u2208 H \u2192 k \u2208 K \u2192 k * h * k\u207b\u00b9 \u2208 H", "start": [3619, 1], "end": [3623, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_subgroupOf_prod_normal", "code": "@[to_additive]\ninstance prod_subgroupOf_prod_normal {H\u2081 K\u2081 : Subgroup G} {H\u2082 K\u2082 : Subgroup N}\n    [h\u2081 : (H\u2081.subgroupOf K\u2081).Normal] [h\u2082 : (H\u2082.subgroupOf K\u2082).Normal] :\n    ((H\u2081.prod H\u2082).subgroupOf (K\u2081.prod K\u2082)).Normal where\n  conj_mem n hgHK g :=\n    \u27e8h\u2081.conj_mem \u27e8(n : G \u00d7 N).fst, (mem_prod.mp n.2).1\u27e9 hgHK.1\n        \u27e8(g : G \u00d7 N).fst, (mem_prod.mp g.2).1\u27e9,\n      h\u2082.conj_mem \u27e8(n : G \u00d7 N).snd, (mem_prod.mp n.2).2\u27e9 hgHK.2\n        \u27e8(g : G \u00d7 N).snd, (mem_prod.mp g.2).2\u27e9\u27e9", "start": [3627, 1], "end": [3635, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_normal", "code": "@[to_additive]\ninstance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :\n    (H.prod K).Normal where\n  conj_mem n hg g :=\n    \u27e8hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst,\n      hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd\u27e9", "start": [3639, 1], "end": [3644, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_subgroupOf_inf_normal_of_right", "code": "@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G) (hB : B' \u2264 B)\n    [hN : (B'.subgroupOf B).Normal] : ((A \u2293 B').subgroupOf (A \u2293 B)).Normal", "start": [3648, 1], "end": [3654, 72], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_subgroupOf_inf_normal_of_left", "code": "@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' \u2264 A)\n    [hN : (A'.subgroupOf A).Normal] : ((A' \u2293 B).subgroupOf (A \u2293 B)).Normal", "start": [3658, 1], "end": [3664, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_inf_normal", "code": "@[to_additive]\ninstance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H \u2293 K).Normal :=\n  \u27e8fun n hmem g => \u27e8hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g\u27e9\u27e9", "start": [3668, 1], "end": [3670, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroupOf_sup", "code": "@[to_additive]\ntheorem subgroupOf_sup (A A' B : Subgroup G) (hA : A \u2264 B) (hA' : A' \u2264 B) :\n    (A \u2294 A').subgroupOf B = A.subgroupOf B \u2294 A'.subgroupOf B", "start": [3674, 1], "end": [3681, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.SubgroupNormal.mem_comm", "code": "@[to_additive]\ntheorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H \u2264 K) [hN : (H.subgroupOf K).Normal]\n    {a b : G} (hb : b \u2208 K) (h : a * b \u2208 H) : b * a \u2208 H", "start": [3685, 1], "end": [3689, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commute_of_normal_of_disjoint", "code": "@[to_additive \"Elements of disjoint, normal subgroups commute.\"]\ntheorem commute_of_normal_of_disjoint (H\u2081 H\u2082 : Subgroup G) (hH\u2081 : H\u2081.Normal) (hH\u2082 : H\u2082.Normal)\n    (hdis : Disjoint H\u2081 H\u2082) (x y : G) (hx : x \u2208 H\u2081) (hy : y \u2208 H\u2082) : Commute x y", "start": [3693, 1], "end": [3709, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.disjoint_def", "code": "@[to_additive]\ntheorem disjoint_def {H\u2081 H\u2082 : Subgroup G} : Disjoint H\u2081 H\u2082 \u2194 \u2200 {x : G}, x \u2208 H\u2081 \u2192 x \u2208 H\u2082 \u2192 x = 1", "start": [3715, 1], "end": [3717, 98], "kind": "commanddeclaration"}, {"full_name": "Subgroup.disjoint_def'", "code": "@[to_additive]\ntheorem disjoint_def' {H\u2081 H\u2082 : Subgroup G} :\n    Disjoint H\u2081 H\u2082 \u2194 \u2200 {x y : G}, x \u2208 H\u2081 \u2192 y \u2208 H\u2082 \u2192 x = y \u2192 x = 1", "start": [3721, 1], "end": [3724, 101], "kind": "commanddeclaration"}, {"full_name": "Subgroup.disjoint_iff_mul_eq_one", "code": "@[to_additive]\ntheorem disjoint_iff_mul_eq_one {H\u2081 H\u2082 : Subgroup G} :\n    Disjoint H\u2081 H\u2082 \u2194 \u2200 {x y : G}, x \u2208 H\u2081 \u2192 y \u2208 H\u2082 \u2192 x * y = 1 \u2192 x = 1 \u2227 y = 1", "start": [3728, 1], "end": [3735, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_injective_of_disjoint", "code": "@[to_additive]\ntheorem mul_injective_of_disjoint {H\u2081 H\u2082 : Subgroup G} (h : Disjoint H\u2081 H\u2082) :\n    Function.Injective (fun g => g.1 * g.2 : H\u2081 \u00d7 H\u2082 \u2192 G)", "start": [3739, 1], "end": [3746, 53], "kind": "commanddeclaration"}, {"full_name": "IsConj.normalClosure_eq_top_of", "code": "theorem normalClosure_eq_top_of {N : Subgroup G} [hn : N.Normal] {g g' : G} {hg : g \u2208 N}\n    {hg' : g' \u2208 N} (hc : IsConj g g') (ht : normalClosure ({\u27e8g, hg\u27e9} : Set N) = \u22a4) :\n    normalClosure ({\u27e8g', hg'\u27e9} : Set N) = \u22a4", "start": [3756, 1], "end": [3776, 51], "kind": "commanddeclaration"}, {"full_name": "IsConj.eq_of_left_mem_center", "code": "theorem eq_of_left_mem_center {g h : M} (H : IsConj g h) (Hg : g \u2208 Set.center M) : g = h", "start": [3781, 1], "end": [3782, 56], "kind": "commanddeclaration"}, {"full_name": "IsConj.eq_of_right_mem_center", "code": "theorem eq_of_right_mem_center {g h : M} (H : IsConj g h) (Hh : h \u2208 Set.center M) : g = h", "start": [3785, 1], "end": [3786, 41], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.noncenter", "code": "def noncenter (G : Type*) [Monoid G] : Set (ConjClasses G) :=\n  {x | x.carrier.Nontrivial}", "start": [3793, 1], "end": [3795, 29], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.mem_noncenter", "code": "@[simp] lemma mem_noncenter [Monoid G] (g : ConjClasses G) :\n  g \u2208 noncenter G \u2194 g.carrier.Nontrivial := Iff.rfl", "start": [3797, 1], "end": [3798, 52], "kind": "mathlibtacticlemma"}, {"full_name": "ConjClasses.mk_bijOn", "code": "theorem mk_bijOn (G : Type*) [Group G] :\n    Set.BijOn ConjClasses.mk (\u2191(Subgroup.center G)) (noncenter G)\u1d9c", "start": [3800, 1], "end": [3818, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/GroupAction.lean", "imports": ["Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulActionHom", "code": "structure MulActionHom where\n  \n  protected toFun : X \u2192 Y\n  \n  protected map_smul' : \u2200 (m : M') (x : X), toFun (m \u2022 x) = m \u2022 toFun x", "start": [59, 1], "end": [66, 72], "kind": "commanddeclaration"}, {"full_name": "SMulHomClass", "code": "class SMulHomClass (F : Type*) (M X Y : outParam <| Type*) [SMul M X] [SMul M Y] extends\n  FunLike F X fun _ => Y where\n  \n  map_smul : \u2200 (f : F) (c : M) (x : X), f (c \u2022 x) = c \u2022 f x", "start": [74, 1], "end": [81, 60], "kind": "commanddeclaration"}, {"full_name": "SMulHomClass.toMulActionHom", "code": "@[coe]\ndef _root_.SMulHomClass.toMulActionHom [SMul M X] [SMul M Y] [SMulHomClass F M X Y] (f : F) :\n    X \u2192[M] Y where\n   toFun := FunLike.coe f\n   map_smul' := map_smul f", "start": [107, 1], "end": [113, 27], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.map_smul", "code": "protected theorem map_smul (f : X \u2192[M'] Y) (m : M') (x : X) : f (m \u2022 x) = m \u2022 f x", "start": [120, 1], "end": [121, 17], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.ext", "code": "@[ext]\ntheorem ext {f g : X \u2192[M'] Y} : (\u2200 x, f x = g x) \u2192 f = g", "start": [124, 1], "end": [126, 18], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.ext_iff", "code": "theorem ext_iff {f g : X \u2192[M'] Y} : f = g \u2194 \u2200 x, f x = g x", "start": [129, 1], "end": [130, 18], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.congr_fun", "code": "protected theorem congr_fun {f g : X \u2192[M'] Y} (h : f = g) (x : X) : f x = g x", "start": [133, 1], "end": [134, 24], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.id", "code": "protected def id : X \u2192[M'] X :=\n  \u27e8id, fun _ _ => rfl\u27e9", "start": [139, 1], "end": [141, 23], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.id_apply", "code": "@[simp]\ntheorem id_apply (x : X) : MulActionHom.id M' x = x", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.comp", "code": "def comp (g : Y \u2192[M'] Z) (f : X \u2192[M'] Y) : X \u2192[M'] Z :=\n  \u27e8g \u2218 f, fun m x =>\n    calc\n      g (f (m \u2022 x)) = g (m \u2022 f x) := by rw [f.map_smul]\n      _ = m \u2022 g (f x) := g.map_smul _ _\u27e9", "start": [151, 1], "end": [156, 41], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : Y \u2192[M'] Z) (f : X \u2192[M'] Y) (x : X) : g.comp f x = g (f x)", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : X \u2192[M'] Y) : (MulActionHom.id M').comp f = f", "start": [164, 1], "end": [166, 44], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : X \u2192[M'] Y) : f.comp (MulActionHom.id M') = f", "start": [169, 1], "end": [171, 44], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.inverse", "code": "@[simps]\ndef inverse (f : A \u2192[M] B) (g : B \u2192 A) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : B \u2192[M] A where\n  toFun := g\n  map_smul' m x :=\n    calc\n      g (m \u2022 x) = g (m \u2022 f (g x)) := by rw [h\u2082]\n      _ = g (f (m \u2022 g x)) := by rw [f.map_smul]\n      _ = m \u2022 g x := by rw [h\u2081]", "start": [176, 1], "end": [185, 32], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.toMulActionHom", "code": "@[simps]\ndef SMulCommClass.toMulActionHom {M} (N \u03b1 : Type*) [SMul M \u03b1] [SMul N \u03b1] [SMulCommClass M N \u03b1]\n    (c : M) : \u03b1 \u2192[N] \u03b1 where\n  toFun := (c \u2022 \u00b7)\n  map_smul' := smul_comm _", "start": [191, 1], "end": [197, 27], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom", "code": "structure DistribMulActionHom extends A \u2192[M] B, A \u2192+ B", "start": [199, 1], "end": [200, 55], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHomClass", "code": "class DistribMulActionHomClass (F : Type*) (M A B : outParam <| Type*) [Monoid M] [AddMonoid A]\n  [AddMonoid B] [DistribMulAction M A] [DistribMulAction M B] extends SMulHomClass F M A B,\n  AddMonoidHomClass F A B", "start": [217, 1], "end": [223, 26], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHomClass.toDistribMulActionHom", "code": "@[coe]\ndef _root_.DistribMulActionHomClass.toDistribMulActionHom [DistribMulActionHomClass F M A B]\n    (f : F) : A \u2192+[M] B :=\n  { (f : A \u2192+ B), (f : A \u2192[M] B) with }", "start": [261, 1], "end": [266, 40], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : A \u2192+[M] B) : f.toFun = f", "start": [273, 1], "end": [274, 58], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.coe_fn_coe", "code": "@[norm_cast]\ntheorem coe_fn_coe (f : A \u2192+[M] B) : \u21d1(f : A \u2192+ B) = f", "start": [277, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.coe_fn_coe'", "code": "@[norm_cast]\ntheorem coe_fn_coe' (f : A \u2192+[M] B) : \u21d1(f : A \u2192[M] B) = f", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.ext", "code": "@[ext]\ntheorem ext {f g : A \u2192+[M] B} : (\u2200 x, f x = g x) \u2192 f = g", "start": [287, 1], "end": [289, 18], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.ext_iff", "code": "theorem ext_iff {f g : A \u2192+[M] B} : f = g \u2194 \u2200 x, f x = g x", "start": [292, 1], "end": [293, 18], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.congr_fun", "code": "protected theorem congr_fun {f g : A \u2192+[M] B} (h : f = g) (x : A) : f x = g x", "start": [296, 1], "end": [297, 24], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.toMulActionHom_injective", "code": "theorem toMulActionHom_injective {f g : A \u2192+[M] B} (h : (f : A \u2192[M] B) = (g : A \u2192[M] B)) :\n    f = g", "start": [300, 1], "end": [303, 35], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.toAddMonoidHom_injective", "code": "theorem toAddMonoidHom_injective {f g : A \u2192+[M] B} (h : (f : A \u2192+ B) = (g : A \u2192+ B)) : f = g", "start": [306, 1], "end": [308, 30], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.map_zero", "code": "protected theorem map_zero (f : A \u2192+[M] B) : f 0 = 0", "start": [311, 1], "end": [312, 13], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.map_add", "code": "protected theorem map_add (f : A \u2192+[M] B) (x y : A) : f (x + y) = f x + f y", "start": [315, 1], "end": [316, 16], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.map_neg", "code": "protected theorem map_neg (f : A' \u2192+[M] B') (x : A') : f (-x) = -f x", "start": [319, 1], "end": [320, 14], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.map_sub", "code": "protected theorem map_sub (f : A' \u2192+[M] B') (x y : A') : f (x - y) = f x - f y", "start": [323, 1], "end": [324, 16], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.map_smul", "code": "protected theorem map_smul (f : A \u2192+[M] B) (m : M) (x : A) : f (m \u2022 x) = m \u2022 f x", "start": [327, 1], "end": [328, 17], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.id", "code": "protected def id : A \u2192+[M] A :=\n  \u27e8.id _, rfl, fun _ _ => rfl\u27e9", "start": [332, 1], "end": [334, 31], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.id_apply", "code": "@[simp]\ntheorem id_apply (x : A) : DistribMulActionHom.id M x = x", "start": [337, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : A \u2192+[M] B) = 0", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : A \u2192+[M] A) = id", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.zero_apply", "code": "theorem zero_apply (a : A) : (0 : A \u2192+[M] B) a = 0", "start": [361, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.one_apply", "code": "theorem one_apply (a : A) : (1 : A \u2192+[M] A) a = a", "start": [365, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.comp", "code": "def comp (g : B \u2192+[M] C) (f : A \u2192+[M] B) : A \u2192+[M] C :=\n  { MulActionHom.comp (g : B \u2192[M] C) (f : A \u2192[M] B),\n    AddMonoidHom.comp (g : B \u2192+ C) (f : A \u2192+ B) with }", "start": [372, 1], "end": [375, 55], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : B \u2192+[M] C) (f : A \u2192+[M] B) (x : A) : g.comp f x = g (f x)", "start": [378, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : A \u2192+[M] B) : (DistribMulActionHom.id M).comp f = f", "start": [383, 1], "end": [385, 44], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : A \u2192+[M] B) : f.comp (DistribMulActionHom.id M) = f", "start": [388, 1], "end": [390, 44], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.inverse", "code": "@[simps]\ndef inverse (f : A \u2192+[M] B) (g : B \u2192 A) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : B \u2192+[M] A :=\n  { (f : A \u2192+ B).inverse g h\u2081 h\u2082, (f : A \u2192[M] B).inverse g h\u2081 h\u2082 with toFun := g }", "start": [393, 1], "end": [397, 83], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.ext_ring", "code": "@[ext]\ntheorem ext_ring {f g : R \u2192+[R] M'} (h : f 1 = g 1) : f = g", "start": [405, 1], "end": [408, 63], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.ext_ring_iff", "code": "theorem ext_ring_iff {f g : R \u2192+[R] M'} : f = g \u2194 f 1 = g 1", "start": [411, 1], "end": [412, 31], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.toDistribMulActionHom", "code": "@[simps]\ndef SMulCommClass.toDistribMulActionHom {M} (N A : Type*) [Monoid N] [AddMonoid A]\n    [DistribSMul M A] [DistribMulAction N A] [SMulCommClass M N A] (c : M) : A \u2192+[N] A :=\n  { SMulCommClass.toMulActionHom N A c, DistribSMul.toAddMonoidHom _ c with\n    toFun := (c \u2022 \u00b7) }", "start": [419, 1], "end": [425, 23], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom", "code": "structure MulSemiringActionHom extends R \u2192+[M] S, R \u2192+* S", "start": [427, 1], "end": [430, 58], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHomClass", "code": "class MulSemiringActionHomClass (F : Type*) (M R S : outParam <| Type*) [Monoid M] [Semiring R]\n  [Semiring S] [DistribMulAction M R] [DistribMulAction M S] extends\n  DistribMulActionHomClass F M R S, RingHomClass F R S", "start": [447, 1], "end": [453, 55], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHomClass.toMulSemiringActionHom", "code": "@[coe]\ndef _root_.MulSemiringActionHomClass.toMulSemiringActionHom [MulSemiringActionHomClass F M R S]\n    (f : F) : R \u2192+*[M] S :=\n { (f : R \u2192+* S), (f : R \u2192+[M] S) with }", "start": [496, 1], "end": [502, 41], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.coe_fn_coe", "code": "@[norm_cast]\ntheorem coe_fn_coe (f : R \u2192+*[M] S) : \u21d1(f : R \u2192+* S) = f", "start": [509, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.coe_fn_coe'", "code": "@[norm_cast]\ntheorem coe_fn_coe' (f : R \u2192+*[M] S) : \u21d1(f : R \u2192+[M] S) = f", "start": [514, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.ext", "code": "@[ext]\ntheorem ext {f g : R \u2192+*[M] S} : (\u2200 x, f x = g x) \u2192 f = g", "start": [519, 1], "end": [521, 18], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.ext_iff", "code": "theorem ext_iff {f g : R \u2192+*[M] S} : f = g \u2194 \u2200 x, f x = g x", "start": [524, 1], "end": [525, 18], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_zero", "code": "protected theorem map_zero (f : R \u2192+*[M] S) : f 0 = 0", "start": [528, 1], "end": [529, 13], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_add", "code": "protected theorem map_add (f : R \u2192+*[M] S) (x y : R) : f (x + y) = f x + f y", "start": [532, 1], "end": [533, 16], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_neg", "code": "protected theorem map_neg (f : R' \u2192+*[M] S') (x : R') : f (-x) = -f x", "start": [536, 1], "end": [537, 14], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_sub", "code": "protected theorem map_sub (f : R' \u2192+*[M] S') (x y : R') : f (x - y) = f x - f y", "start": [540, 1], "end": [541, 16], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_one", "code": "protected theorem map_one (f : R \u2192+*[M] S) : f 1 = 1", "start": [544, 1], "end": [545, 12], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_mul", "code": "protected theorem map_mul (f : R \u2192+*[M] S) (x y : R) : f (x * y) = f x * f y", "start": [548, 1], "end": [549, 16], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.map_smul", "code": "protected theorem map_smul (f : R \u2192+*[M] S) (m : M) (x : R) : f (m \u2022 x) = m \u2022 f x", "start": [552, 1], "end": [553, 17], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.id", "code": "protected def id : R \u2192+*[M] R :=\n  \u27e8.id _, rfl, (fun _ _ => rfl)\u27e9", "start": [558, 1], "end": [560, 33], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.id_apply", "code": "@[simp]\ntheorem id_apply (x : R) : MulSemiringActionHom.id M x = x", "start": [563, 1], "end": [565, 6], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.comp", "code": "def comp (g : S \u2192+*[M] T) (f : R \u2192+*[M] S) : R \u2192+*[M] T :=\n  { DistribMulActionHom.comp (g : S \u2192+[M] T) (f : R \u2192+[M] S),\n    RingHom.comp (g : S \u2192+* T) (f : R \u2192+* S) with }", "start": [570, 1], "end": [573, 52], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (g : S \u2192+*[M] T) (f : R \u2192+*[M] S) (x : R) : g.comp f x = g (f x)", "start": [576, 1], "end": [578, 6], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : R \u2192+*[M] S) : (MulSemiringActionHom.id M).comp f = f", "start": [581, 1], "end": [583, 44], "kind": "commanddeclaration"}, {"full_name": "MulSemiringActionHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : R \u2192+*[M] S) : f.comp (MulSemiringActionHom.id M) = f", "start": [586, 1], "end": [588, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Pi.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Pi.lean", "Mathlib/Algebra/Regular/SMul.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Pi.lean"], "premises": [{"full_name": "IsSMulRegular.pi", "code": "theorem _root_.IsSMulRegular.pi {\u03b1 : Type*} [\u2200 i, SMul \u03b1 <| f i] {k : \u03b1}\n    (hk : \u2200 i, IsSMulRegular (f i) k) : IsSMulRegular (\u2200 i, f i) k", "start": [32, 1], "end": [34, 43], "kind": "commanddeclaration"}, {"full_name": "Pi.smulWithZero", "code": "instance smulWithZero (\u03b1) [Zero \u03b1] [\u2200 i, Zero (f i)] [\u2200 i, SMulWithZero \u03b1 (f i)] :\n    SMulWithZero \u03b1 (\u2200 i, f i) :=\n  { Pi.instSMul with\n    smul_zero := fun _ => funext fun _ => smul_zero _\n    zero_smul := fun _ => funext fun _ => zero_smul _ _ }", "start": [37, 1], "end": [41, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.smulWithZero'", "code": "instance smulWithZero' {g : I \u2192 Type*} [\u2200 i, Zero (g i)] [\u2200 i, Zero (f i)]\n    [\u2200 i, SMulWithZero (g i) (f i)] : SMulWithZero (\u2200 i, g i) (\u2200 i, f i) :=\n  { Pi.smul' with\n    smul_zero := fun _ => funext fun _ => smul_zero _\n    zero_smul := fun _ => funext fun _ => zero_smul _ _ }", "start": [44, 1], "end": [48, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.mulActionWithZero", "code": "instance mulActionWithZero (\u03b1) [MonoidWithZero \u03b1] [\u2200 i, Zero (f i)]\n    [\u2200 i, MulActionWithZero \u03b1 (f i)] : MulActionWithZero \u03b1 (\u2200 i, f i) :=\n  { Pi.mulAction _, Pi.smulWithZero _ with }", "start": [51, 1], "end": [53, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.mulActionWithZero'", "code": "instance mulActionWithZero' {g : I \u2192 Type*} [\u2200 i, MonoidWithZero (g i)] [\u2200 i, Zero (f i)]\n    [\u2200 i, MulActionWithZero (g i) (f i)] : MulActionWithZero (\u2200 i, g i) (\u2200 i, f i) :=\n  { Pi.mulAction', Pi.smulWithZero' with }", "start": [56, 1], "end": [58, 43], "kind": "commanddeclaration"}, {"full_name": "Pi.module", "code": "instance module (\u03b1) {r : Semiring \u03b1} {m : \u2200 i, AddCommMonoid <| f i} [\u2200 i, Module \u03b1 <| f i] :\n    @Module \u03b1 (\u2200 i : I, f i) r (@Pi.addCommMonoid I f m) :=\n  { Pi.distribMulAction _ with\n    add_smul := fun _ _ _ => funext fun _ => add_smul _ _ _\n    zero_smul := fun _ => funext fun _ => zero_smul \u03b1 _ }", "start": [63, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.Function.module", "code": "instance Function.module (\u03b1 \u03b2 : Type*) [Semiring \u03b1] [AddCommMonoid \u03b2] [Module \u03b1 \u03b2] :\n    Module \u03b1 (I \u2192 \u03b2) :=\n  Pi.module _ _ _", "start": [78, 1], "end": [82, 18], "kind": "commanddeclaration"}, {"full_name": "Pi.module'", "code": "instance module' {g : I \u2192 Type*} {r : \u2200 i, Semiring (f i)} {m : \u2200 i, AddCommMonoid (g i)}\n    [\u2200 i, Module (f i) (g i)] : Module (\u2200 i, f i) (\u2200 i, g i)\n    where\n  add_smul := by\n    intros\n    ext1\n    apply add_smul\n  zero_smul := by\n    intros\n    ext1\n    rw [zero_smul]", "start": [87, 1], "end": [98, 19], "kind": "commanddeclaration"}, {"full_name": "Pi.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors (\u03b1) [Semiring \u03b1] [\u2200 i, AddCommMonoid <| f i]\n    [\u2200 i, Module \u03b1 <| f i] [\u2200 i, NoZeroSMulDivisors \u03b1 <| f i] :\n    NoZeroSMulDivisors \u03b1 (\u2200 i : I, f i) :=\n  \u27e8fun {_ _} h =>\n    or_iff_not_imp_left.mpr fun hc =>\n      funext fun i => (smul_eq_zero.mp (congr_fun h i)).resolve_left hc\u27e9", "start": [101, 1], "end": [106, 73], "kind": "commanddeclaration"}, {"full_name": "Function.noZeroSMulDivisors", "code": "instance _root_.Function.noZeroSMulDivisors {\u03b9 \u03b1 \u03b2 : Type*} [Semiring \u03b1] [AddCommMonoid \u03b2]\n    [Module \u03b1 \u03b2] [NoZeroSMulDivisors \u03b1 \u03b2] : NoZeroSMulDivisors \u03b1 (\u03b9 \u2192 \u03b2) :=\n  Pi.noZeroSMulDivisors _", "start": [108, 1], "end": [112, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Basic.lean", "imports": ["Mathlib/Algebra/Ring/CompTypeclasses.lean", "Mathlib/Algebra/Ring/Aut.lean", "Mathlib/GroupTheory/GroupAction/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Rat/Cast/CharZero.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/Algebra/Field/Opposite.lean"], "premises": [{"full_name": "Star", "code": "class Star (R : Type u) where\n  star : R \u2192 R", "start": [40, 1], "end": [43, 15], "kind": "commanddeclaration"}, {"full_name": "StarMemClass", "code": "class StarMemClass (S R : Type*) [Star R] [SetLike S R] : Prop where\n  \n  star_mem : \u2200 {s : S} {r : R}, r \u2208 s \u2192 star r \u2208 s", "start": [57, 1], "end": [60, 51], "kind": "commanddeclaration"}, {"full_name": "StarMemClass.instStar", "code": "instance instStar : Star s where\n  star r := \u27e8star (r : R), star_mem r.prop\u27e9", "start": [71, 1], "end": [72, 44], "kind": "commanddeclaration"}, {"full_name": "InvolutiveStar", "code": "class InvolutiveStar (R : Type u) extends Star R where\n  \n  star_involutive : Function.Involutive star", "start": [76, 1], "end": [80, 45], "kind": "commanddeclaration"}, {"full_name": "star_star", "code": "@[simp]\ntheorem star_star [InvolutiveStar R] (r : R) : star (star r) = r", "start": [85, 1], "end": [87, 20], "kind": "commanddeclaration"}, {"full_name": "star_injective", "code": "theorem star_injective [InvolutiveStar R] : Function.Injective (star : R \u2192 R)", "start": [90, 1], "end": [91, 48], "kind": "commanddeclaration"}, {"full_name": "star_inj", "code": "@[simp]\ntheorem star_inj [InvolutiveStar R] {x y : R} : star x = star y \u2194 x = y", "start": [94, 1], "end": [96, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.star", "code": "protected def Equiv.star [InvolutiveStar R] : Equiv.Perm R :=\n  star_involutive.toPerm _", "start": [99, 1], "end": [101, 27], "kind": "commanddeclaration"}, {"full_name": "eq_star_of_eq_star", "code": "theorem eq_star_of_eq_star [InvolutiveStar R] {r s : R} (h : r = star s) : s = star r", "start": [104, 1], "end": [105, 11], "kind": "commanddeclaration"}, {"full_name": "eq_star_iff_eq_star", "code": "theorem eq_star_iff_eq_star [InvolutiveStar R] {r s : R} : r = star s \u2194 s = star r", "start": [108, 1], "end": [109, 43], "kind": "commanddeclaration"}, {"full_name": "star_eq_iff_star_eq", "code": "theorem star_eq_iff_star_eq [InvolutiveStar R] {r s : R} : star r = s \u2194 star s = r", "start": [112, 1], "end": [113, 53], "kind": "commanddeclaration"}, {"full_name": "TrivialStar", "code": "class TrivialStar (R : Type u) [Star R] : Prop where\n  \n  star_trivial : \u2200 r : R, star r = r", "start": [116, 1], "end": [120, 37], "kind": "commanddeclaration"}, {"full_name": "StarMul", "code": "class StarMul (R : Type u) [Mul R] extends InvolutiveStar R where\n  \n  star_mul : \u2200 r s : R, star (r * s) = star s * star r", "start": [127, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "star_star_mul", "code": "theorem star_star_mul (x y : R) : star (star x * y) = star y * x", "start": [143, 1], "end": [143, 96], "kind": "commanddeclaration"}, {"full_name": "star_mul_star", "code": "theorem star_mul_star (x y : R) : star (x * star y) = y * star x", "start": [146, 1], "end": [146, 96], "kind": "commanddeclaration"}, {"full_name": "semiconjBy_star_star_star", "code": "@[simp]\ntheorem semiconjBy_star_star_star {x y z : R} :\n    SemiconjBy (star x) (star z) (star y) \u2194 SemiconjBy x y z", "start": [149, 1], "end": [152, 54], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.star_star_star", "code": "alias \u27e8_, SemiconjBy.star_star_star\u27e9 := semiconjBy_star_star_star", "start": [155, 1], "end": [155, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "commute_star_star", "code": "@[simp]\ntheorem commute_star_star {x y : R} : Commute (star x) (star y) \u2194 Commute x y", "start": [158, 1], "end": [160, 28], "kind": "commanddeclaration"}, {"full_name": "Commute.star_star", "code": "alias \u27e8_, Commute.star_star\u27e9 := commute_star_star", "start": [163, 1], "end": [163, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "commute_star_comm", "code": "theorem commute_star_comm {x y : R} : Commute (star x) y \u2194 Commute x (star y)", "start": [166, 1], "end": [167, 38], "kind": "commanddeclaration"}, {"full_name": "star_mul'", "code": "@[simp]\ntheorem star_mul' [CommSemigroup R] [StarMul R] (x y : R) : star (x * y) = star x * star y", "start": [172, 1], "end": [175, 38], "kind": "commanddeclaration"}, {"full_name": "starMulEquiv", "code": "@[simps apply]\ndef starMulEquiv [Mul R] [StarMul R] : R \u2243* R\u1d50\u1d52\u1d56 :=\n  { (InvolutiveStar.star_involutive.toPerm star).trans opEquiv with\n    toFun := fun x => MulOpposite.op (star x)\n    map_mul' := fun x y => by simp only [star_mul, op_mul] }", "start": [178, 1], "end": [183, 61], "kind": "commanddeclaration"}, {"full_name": "starMulAut", "code": "@[simps apply]\ndef starMulAut [CommSemigroup R] [StarMul R] : MulAut R :=\n  { InvolutiveStar.star_involutive.toPerm star with\n    toFun := star\n    map_mul' := star_mul' }", "start": [187, 1], "end": [192, 28], "kind": "commanddeclaration"}, {"full_name": "star_one", "code": "@[simp]\ntheorem star_one [MulOneClass R] [StarMul R] : star (1 : R) = 1", "start": [198, 1], "end": [200, 75], "kind": "commanddeclaration"}, {"full_name": "star_pow", "code": "@[simp]\ntheorem star_pow [Monoid R] [StarMul R] (x : R) (n : \u2115) : star (x ^ n) = star x ^ n", "start": [205, 1], "end": [208, 88], "kind": "commanddeclaration"}, {"full_name": "star_inv", "code": "@[simp]\ntheorem star_inv [Group R] [StarMul R] (x : R) : star x\u207b\u00b9 = (star x)\u207b\u00b9", "start": [211, 1], "end": [213, 98], "kind": "commanddeclaration"}, {"full_name": "star_zpow", "code": "@[simp]\ntheorem star_zpow [Group R] [StarMul R] (x : R) (z : \u2124) : star (x ^ z) = star x ^ z", "start": [216, 1], "end": [219, 90], "kind": "commanddeclaration"}, {"full_name": "star_div", "code": "@[simp]\ntheorem star_div [CommGroup R] [StarMul R] (x y : R) : star (x / y) = star x / star y", "start": [222, 1], "end": [225, 36], "kind": "commanddeclaration"}, {"full_name": "starMulOfComm", "code": "@[reducible]\ndef starMulOfComm {R : Type*} [CommMonoid R] : StarMul R where\n  star := id\n  star_involutive _ := rfl\n  star_mul := mul_comm", "start": [228, 1], "end": [236, 23], "kind": "commanddeclaration"}, {"full_name": "star_id_of_comm", "code": "theorem star_id_of_comm {R : Type*} [CommSemiring R] {x : R} : star x = x", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "StarAddMonoid", "code": "class StarAddMonoid (R : Type u) [AddMonoid R] extends InvolutiveStar R where\n  \n  star_add : \u2200 r s : R, star (r + s) = star r + star s", "start": [250, 1], "end": [254, 55], "kind": "commanddeclaration"}, {"full_name": "starAddEquiv", "code": "@[simps apply]\ndef starAddEquiv [AddMonoid R] [StarAddMonoid R] : R \u2243+ R :=\n  { InvolutiveStar.star_involutive.toPerm star with\n    toFun := star\n    map_add' := star_add }", "start": [261, 1], "end": [266, 27], "kind": "commanddeclaration"}, {"full_name": "star_zero", "code": "@[simp]\ntheorem star_zero [AddMonoid R] [StarAddMonoid R] : star (0 : R) = 0", "start": [272, 1], "end": [274, 35], "kind": "commanddeclaration"}, {"full_name": "star_eq_zero", "code": "@[simp]\ntheorem star_eq_zero [AddMonoid R] [StarAddMonoid R] {x : R} : star x = 0 \u2194 x = 0", "start": [279, 1], "end": [281, 40], "kind": "commanddeclaration"}, {"full_name": "star_ne_zero", "code": "theorem star_ne_zero [AddMonoid R] [StarAddMonoid R] {x : R} : star x \u2260 0 \u2194 x \u2260 0", "start": [284, 1], "end": [285, 34], "kind": "commanddeclaration"}, {"full_name": "star_neg", "code": "@[simp]\ntheorem star_neg [AddGroup R] [StarAddMonoid R] (r : R) : star (-r) = -star r", "start": [288, 1], "end": [290, 36], "kind": "commanddeclaration"}, {"full_name": "star_sub", "code": "@[simp]\ntheorem star_sub [AddGroup R] [StarAddMonoid R] (r s : R) : star (r - s) = star r - star s", "start": [293, 1], "end": [295, 38], "kind": "commanddeclaration"}, {"full_name": "star_nsmul", "code": "@[simp]\ntheorem star_nsmul [AddMonoid R] [StarAddMonoid R] (x : R) (n : \u2115) : star (n \u2022 x) = n \u2022 star x", "start": [298, 1], "end": [300, 55], "kind": "commanddeclaration"}, {"full_name": "star_zsmul", "code": "@[simp]\ntheorem star_zsmul [AddGroup R] [StarAddMonoid R] (x : R) (n : \u2124) : star (n \u2022 x) = n \u2022 star x", "start": [303, 1], "end": [305, 55], "kind": "commanddeclaration"}, {"full_name": "StarRing", "code": "class StarRing (R : Type u) [NonUnitalNonAssocSemiring R] extends StarMul R where\n  \n  star_add : \u2200 r s : R, star (r + s) = star r + star s", "start": [308, 1], "end": [313, 55], "kind": "commanddeclaration"}, {"full_name": "StarRing.toStarAddMonoid", "code": "instance (priority := 100) StarRing.toStarAddMonoid [NonUnitalNonAssocSemiring R] [StarRing R] :\n    StarAddMonoid R where\n  star_add := StarRing.star_add", "start": [316, 1], "end": [318, 32], "kind": "commanddeclaration"}, {"full_name": "starRingEquiv", "code": "@[simps apply]\ndef starRingEquiv [NonUnitalNonAssocSemiring R] [StarRing R] : R \u2243+* R\u1d50\u1d52\u1d56 :=\n  { starAddEquiv.trans (MulOpposite.opAddEquiv : R \u2243+ R\u1d50\u1d52\u1d56), starMulEquiv with\n    toFun := fun x => MulOpposite.op (star x) }", "start": [321, 1], "end": [325, 48], "kind": "commanddeclaration"}, {"full_name": "star_natCast", "code": "@[simp, norm_cast]\ntheorem star_natCast [NonAssocSemiring R] [StarRing R] (n : \u2115) : star (n : R) = n", "start": [329, 1], "end": [331, 87], "kind": "commanddeclaration"}, {"full_name": "star_ofNat", "code": "@[simp]\ntheorem star_ofNat [NonAssocSemiring R] [StarRing R] (n : \u2115) [n.AtLeastTwo] :\n    star (no_index (OfNat.ofNat n) : R) = OfNat.ofNat n", "start": [335, 1], "end": [338, 17], "kind": "commanddeclaration"}, {"full_name": "star_intCast", "code": "@[simp, norm_cast]\ntheorem star_intCast [Ring R] [StarRing R] (z : \u2124) : star (z : R) = z", "start": [342, 1], "end": [344, 88], "kind": "commanddeclaration"}, {"full_name": "star_ratCast", "code": "@[simp, norm_cast]\ntheorem star_ratCast [DivisionRing R] [StarRing R] (r : \u211a) : star (r : R) = r", "start": [347, 1], "end": [349, 88], "kind": "commanddeclaration"}, {"full_name": "starRingAut", "code": "@[simps apply]\ndef starRingAut [CommSemiring R] [StarRing R] : RingAut R :=\n  { starAddEquiv, starMulAut (R := R) with toFun := star }", "start": [354, 1], "end": [357, 59], "kind": "commanddeclaration"}, {"full_name": "starRingEnd", "code": "def starRingEnd [CommSemiring R] [StarRing R] : R \u2192+* R :=\n  @starRingAut R _ _", "start": [363, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "starRingEnd_apply", "code": "theorem starRingEnd_apply [CommSemiring R] [StarRing R] {x : R} : starRingEnd R x = star x", "start": [379, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "starRingEnd_self_apply", "code": "theorem starRingEnd_self_apply [CommSemiring R] [StarRing R] (x : R) :\n    starRingEnd R (starRingEnd R x) = x", "start": [394, 1], "end": [396, 14], "kind": "commanddeclaration"}, {"full_name": "RingHom.involutiveStar", "code": "instance RingHom.involutiveStar {S : Type*} [NonAssocSemiring S] [CommSemiring R] [StarRing R] :\n    InvolutiveStar (S \u2192+* R) where\n  toStar := { star := fun f => RingHom.comp (starRingEnd R) f }\n  star_involutive := by\n    intro\n    ext\n    simp only [RingHom.coe_comp, Function.comp_apply, starRingEnd_self_apply]", "start": [399, 1], "end": [405, 78], "kind": "commanddeclaration"}, {"full_name": "RingHom.star_def", "code": "theorem RingHom.star_def {S : Type*} [NonAssocSemiring S] [CommSemiring R] [StarRing R]\n    (f : S \u2192+* R) : Star.star f = RingHom.comp (starRingEnd R) f", "start": [408, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.star_apply", "code": "theorem RingHom.star_apply {S : Type*} [NonAssocSemiring S] [CommSemiring R] [StarRing R]\n    (f : S \u2192+* R) (s : S) : star f s = star (f s)", "start": [413, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "Complex.conj_conj", "code": "alias Complex.conj_conj := starRingEnd_self_apply", "start": [419, 1], "end": [419, 50], "kind": "stdtacticaliasalias"}, {"full_name": "IsROrC.conj_conj", "code": "alias IsROrC.conj_conj := starRingEnd_self_apply", "start": [422, 1], "end": [422, 49], "kind": "stdtacticaliasalias"}, {"full_name": "star_inv'", "code": "@[simp]\ntheorem star_inv' [DivisionSemiring R] [StarRing R] (x : R) : star x\u207b\u00b9 = (star x)\u207b\u00b9", "start": [426, 1], "end": [428, 89], "kind": "commanddeclaration"}, {"full_name": "star_zpow\u2080", "code": "@[simp]\ntheorem star_zpow\u2080 [DivisionSemiring R] [StarRing R] (x : R) (z : \u2124) : star (x ^ z) = star x ^ z", "start": [431, 1], "end": [433, 95], "kind": "commanddeclaration"}, {"full_name": "star_div'", "code": "@[simp]\ntheorem star_div' [Semifield R] [StarRing R] (x y : R) : star (x / y) = star x / star y", "start": [436, 1], "end": [440, 75], "kind": "commanddeclaration"}, {"full_name": "star_bit0", "code": "@[simp]\ntheorem star_bit0 [AddMonoid R] [StarAddMonoid R] (r : R) : star (bit0 r) = bit0 (star r)", "start": [447, 1], "end": [449, 14], "kind": "commanddeclaration"}, {"full_name": "star_bit1", "code": "@[simp]\ntheorem star_bit1 [Semiring R] [StarRing R] (r : R) : star (bit1 r) = bit1 (star r)", "start": [452, 1], "end": [454, 14], "kind": "commanddeclaration"}, {"full_name": "starRingOfComm", "code": "@[reducible]\ndef starRingOfComm {R : Type*} [CommSemiring R] : StarRing R :=\n  { starMulOfComm with\n    star_add := fun _ _ => rfl }", "start": [459, 1], "end": [466, 33], "kind": "commanddeclaration"}, {"full_name": "StarModule", "code": "class StarModule (R : Type u) (A : Type v) [Star R] [Star A] [SMul R A] : Prop where\n  \n  star_smul : \u2200 (r : R) (a : A), star (r \u2022 a) = star r \u2022 star a", "start": [469, 1], "end": [483, 64], "kind": "commanddeclaration"}, {"full_name": "StarSemigroup.to_starModule", "code": "instance StarSemigroup.to_starModule [CommMonoid R] [StarMul R] : StarModule R R :=\n  \u27e8star_mul'\u27e9", "start": [490, 1], "end": [492, 14], "kind": "commanddeclaration"}, {"full_name": "StarHomClass", "code": "class StarHomClass (F : Type*) (R S : outParam (Type*)) [Star R] [Star S] extends\n  FunLike F R fun _ => S where\n  \n  map_star : \u2200 (f : F) (r : R), f (star r) = star (f r)", "start": [506, 1], "end": [510, 56], "kind": "commanddeclaration"}, {"full_name": "Units.coe_star", "code": "@[simp]\ntheorem coe_star (u : R\u02e3) : \u2191(star u) = (star \u2191u : R)", "start": [533, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "Units.coe_star_inv", "code": "@[simp]\ntheorem coe_star_inv (u : R\u02e3) : \u2191(star u)\u207b\u00b9 = (star \u2191u\u207b\u00b9 : R)", "start": [538, 1], "end": [540, 6], "kind": "commanddeclaration"}, {"full_name": "IsUnit.star", "code": "theorem IsUnit.star [Monoid R] [StarMul R] {a : R} : IsUnit a \u2192 IsUnit (star a)", "start": [548, 1], "end": [549, 39], "kind": "commanddeclaration"}, {"full_name": "isUnit_star", "code": "@[simp]\ntheorem isUnit_star [Monoid R] [StarMul R] {a : R} : IsUnit (star a) \u2194 IsUnit a", "start": [552, 1], "end": [554, 47], "kind": "commanddeclaration"}, {"full_name": "Ring.inverse_star", "code": "theorem Ring.inverse_star [Semiring R] [StarRing R] (a : R) :\n    Ring.inverse (star a) = star (Ring.inverse a)", "start": [557, 1], "end": [562, 93], "kind": "commanddeclaration"}, {"full_name": "Invertible.star", "code": "instance Invertible.star {R : Type*} [MulOneClass R] [StarMul R] (r : R) [Invertible r] :\n    Invertible (star r) where\n  invOf := Star.star (\u215f r)\n  invOf_mul_self := by rw [\u2190 star_mul, mul_invOf_self, star_one]\n  mul_invOf_self := by rw [\u2190 star_mul, invOf_mul_self, star_one]", "start": [565, 1], "end": [569, 65], "kind": "commanddeclaration"}, {"full_name": "star_invOf", "code": "theorem star_invOf {R : Type*} [Monoid R] [StarMul R] (r : R) [Invertible r]\n    [Invertible (star r)] : star (\u215f r) = \u215f (star r)", "start": [572, 1], "end": [578, 31], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.unop_star", "code": "@[simp]\ntheorem unop_star [Star R] (r : R\u1d50\u1d52\u1d56) : unop (star r) = star (unop r)", "start": [586, 1], "end": [588, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.op_star", "code": "@[simp]\ntheorem op_star [Star R] (r : R) : op (star r) = star (op r)", "start": [591, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "StarSemigroup.toOpposite_starModule", "code": "instance StarSemigroup.toOpposite_starModule [CommMonoid R] [StarMul R] :\n    StarModule R\u1d50\u1d52\u1d56 R :=\n  \u27e8fun r s => star_mul' s r.unop\u27e9", "start": [610, 1], "end": [614, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/NhdsSet.lean", "imports": ["Mathlib/Topology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhdsSet", "code": "def nhdsSet (s : Set \u03b1) : Filter \u03b1 :=\n  sSup (nhds '' s)", "start": [35, 1], "end": [37, 19], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_diagonal", "code": "theorem nhdsSet_diagonal (\u03b1) [TopologicalSpace (\u03b1 \u00d7 \u03b1)] :\n    \ud835\udcdd\u02e2 (diagonal \u03b1) = \u2a06 (x : \u03b1), \ud835\udcdd (x, x)", "start": [42, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsSet_iff_forall", "code": "theorem mem_nhdsSet_iff_forall : s \u2208 \ud835\udcdd\u02e2 t \u2194 \u2200 x : \u03b1, x \u2208 t \u2192 s \u2208 \ud835\udcdd x", "start": [48, 1], "end": [49, 53], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_le", "code": "lemma nhdsSet_le : \ud835\udcdd\u02e2 s \u2264 f \u2194 \u2200 a \u2208 s, \ud835\udcdd a \u2264 f := by simp [nhdsSet]", "start": [52, 1], "end": [52, 68], "kind": "mathlibtacticlemma"}, {"full_name": "bUnion_mem_nhdsSet", "code": "theorem bUnion_mem_nhdsSet {t : \u03b1 \u2192 Set \u03b1} (h : \u2200 x \u2208 s, t x \u2208 \ud835\udcdd x) : (\u22c3 x \u2208 s, t x) \u2208 \ud835\udcdd\u02e2 s", "start": [54, 1], "end": [56, 46], "kind": "commanddeclaration"}, {"full_name": "subset_interior_iff_mem_nhdsSet", "code": "theorem subset_interior_iff_mem_nhdsSet : s \u2286 interior t \u2194 t \u2208 \ud835\udcdd\u02e2 s", "start": [59, 1], "end": [60, 61], "kind": "commanddeclaration"}, {"full_name": "disjoint_principal_nhdsSet", "code": "theorem disjoint_principal_nhdsSet : Disjoint (\ud835\udcdf s) (\ud835\udcdd\u02e2 t) \u2194 Disjoint (closure s) t", "start": [63, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhdsSet_principal", "code": "theorem disjoint_nhdsSet_principal : Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdf t) \u2194 Disjoint s (closure t)", "start": [67, 1], "end": [68, 64], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsSet_iff_exists", "code": "theorem mem_nhdsSet_iff_exists : s \u2208 \ud835\udcdd\u02e2 t \u2194 \u2203 U : Set \u03b1, IsOpen U \u2227 t \u2286 U \u2227 U \u2286 s", "start": [70, 1], "end": [71, 62], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhdsSet", "code": "theorem hasBasis_nhdsSet (s : Set \u03b1) : (\ud835\udcdd\u02e2 s).HasBasis (fun U => IsOpen U \u2227 s \u2286 U) fun U => U", "start": [74, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mem_nhdsSet", "code": "theorem IsOpen.mem_nhdsSet (hU : IsOpen s) : s \u2208 \ud835\udcdd\u02e2 t \u2194 t \u2286 s", "start": [78, 1], "end": [79, 57], "kind": "commanddeclaration"}, {"full_name": "principal_le_nhdsSet", "code": "theorem principal_le_nhdsSet : \ud835\udcdf s \u2264 \ud835\udcdd\u02e2 s", "start": [82, 1], "end": [83, 65], "kind": "commanddeclaration"}, {"full_name": "subset_of_mem_nhdsSet", "code": "theorem subset_of_mem_nhdsSet (h : t \u2208 \ud835\udcdd\u02e2 s) : s \u2286 t", "start": [86, 1], "end": [86, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.self_of_nhdsSet", "code": "theorem Filter.Eventually.self_of_nhdsSet {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in \ud835\udcdd\u02e2 s, p x) : \u2200 x \u2208 s, p x", "start": [88, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.self_of_nhdsSet", "code": "nonrec theorem Filter.EventuallyEq.self_of_nhdsSet {f g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[\ud835\udcdd\u02e2 s] g) : EqOn f g s", "start": [91, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_eq_principal_iff", "code": "@[simp]\ntheorem nhdsSet_eq_principal_iff : \ud835\udcdd\u02e2 s = \ud835\udcdf s \u2194 IsOpen s", "start": [94, 1], "end": [97, 25], "kind": "commanddeclaration"}, {"full_name": "IsOpen.nhdsSet_eq", "code": "alias \u27e8_, IsOpen.nhdsSet_eq\u27e9 := nhdsSet_eq_principal_iff", "start": [100, 1], "end": [100, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "nhdsSet_interior", "code": "@[simp]\ntheorem nhdsSet_interior : \ud835\udcdd\u02e2 (interior s) = \ud835\udcdf (interior s)", "start": [103, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_singleton", "code": "@[simp]\ntheorem nhdsSet_singleton : \ud835\udcdd\u02e2 {x} = \ud835\udcdd x", "start": [108, 1], "end": [109, 62], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsSet_interior", "code": "theorem mem_nhdsSet_interior : s \u2208 \ud835\udcdd\u02e2 (interior s)", "start": [112, 1], "end": [113, 48], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_empty", "code": "@[simp]\ntheorem nhdsSet_empty : \ud835\udcdd\u02e2 (\u2205 : Set \u03b1) = \u22a5", "start": [116, 1], "end": [117, 95], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsSet_empty", "code": "theorem mem_nhdsSet_empty : s \u2208 \ud835\udcdd\u02e2 (\u2205 : Set \u03b1)", "start": [120, 1], "end": [120, 58], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_univ", "code": "@[simp]\ntheorem nhdsSet_univ : \ud835\udcdd\u02e2 (univ : Set \u03b1) = \u22a4", "start": [123, 1], "end": [124, 95], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_mono", "code": "@[mono]\ntheorem nhdsSet_mono (h : s \u2286 t) : \ud835\udcdd\u02e2 s \u2264 \ud835\udcdd\u02e2 t", "start": [127, 1], "end": [129, 35], "kind": "commanddeclaration"}, {"full_name": "monotone_nhdsSet", "code": "theorem monotone_nhdsSet : Monotone (\ud835\udcdd\u02e2 : Set \u03b1 \u2192 Filter \u03b1)", "start": [132, 1], "end": [132, 87], "kind": "commanddeclaration"}, {"full_name": "nhds_le_nhdsSet", "code": "theorem nhds_le_nhdsSet (h : x \u2208 s) : \ud835\udcdd x \u2264 \ud835\udcdd\u02e2 s", "start": [135, 1], "end": [136, 34], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_union", "code": "@[simp]\ntheorem nhdsSet_union (s t : Set \u03b1) : \ud835\udcdd\u02e2 (s \u222a t) = \ud835\udcdd\u02e2 s \u2294 \ud835\udcdd\u02e2 t", "start": [139, 1], "end": [141, 47], "kind": "commanddeclaration"}, {"full_name": "union_mem_nhdsSet", "code": "theorem union_mem_nhdsSet (h\u2081 : s\u2081 \u2208 \ud835\udcdd\u02e2 t\u2081) (h\u2082 : s\u2082 \u2208 \ud835\udcdd\u02e2 t\u2082) : s\u2081 \u222a s\u2082 \u2208 \ud835\udcdd\u02e2 (t\u2081 \u222a t\u2082)", "start": [144, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_insert", "code": "@[simp]\ntheorem nhdsSet_insert (x : \u03b1) (s : Set \u03b1) : \ud835\udcdd\u02e2 (insert x s) = \ud835\udcdd x \u2294 \ud835\udcdd\u02e2 s", "start": [149, 1], "end": [151, 51], "kind": "commanddeclaration"}, {"full_name": "Continuous.tendsto_nhdsSet", "code": "theorem Continuous.tendsto_nhdsSet {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2} (hf : Continuous f)\n    (hst : MapsTo f s t) : Tendsto f (\ud835\udcdd\u02e2 s) (\ud835\udcdd\u02e2 t)", "start": [153, 1], "end": [158, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order.lean", "imports": ["Mathlib/Topology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.GenerateOpen", "code": "inductive GenerateOpen (g : Set (Set \u03b1)) : Set \u03b1 \u2192 Prop\n  | basic : \u2200 s \u2208 g, GenerateOpen g s\n  | univ : GenerateOpen g univ\n  | inter : \u2200 s t, GenerateOpen g s \u2192 GenerateOpen g t \u2192 GenerateOpen g (s \u2229 t)\n  | sUnion : \u2200 S : Set (Set \u03b1), (\u2200 s \u2208 S, GenerateOpen g s) \u2192 GenerateOpen g (\u22c3\u2080 S)", "start": [59, 1], "end": [64, 84], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.generateFrom", "code": "def generateFrom (g : Set (Set \u03b1)) : TopologicalSpace \u03b1 where\n  IsOpen := GenerateOpen g\n  isOpen_univ := GenerateOpen.univ\n  isOpen_inter := GenerateOpen.inter\n  isOpen_sUnion := GenerateOpen.sUnion", "start": [67, 1], "end": [72, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isOpen_generateFrom_of_mem", "code": "theorem isOpen_generateFrom_of_mem {g : Set (Set \u03b1)} {s : Set \u03b1} (hs : s \u2208 g) :\n    IsOpen[generateFrom g] s", "start": [75, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.nhds_generateFrom", "code": "theorem nhds_generateFrom {g : Set (Set \u03b1)} {a : \u03b1} :\n    @nhds \u03b1 (generateFrom g) a = \u2a05 s \u2208 { s | a \u2208 s \u2227 s \u2208 g }, \ud835\udcdf s", "start": [80, 1], "end": [92, 78], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.tendsto_nhds_generateFrom", "code": "theorem tendsto_nhds_generateFrom {\u03b2 : Type*} {m : \u03b1 \u2192 \u03b2} {f : Filter \u03b1} {g : Set (Set \u03b2)} {b : \u03b2}\n    (h : \u2200 s \u2208 g, b \u2208 s \u2192 m \u207b\u00b9' s \u2208 f) : Tendsto m f (@nhds \u03b2 (generateFrom g) b)", "start": [95, 1], "end": [98, 100], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.mkOfNhds", "code": "protected def mkOfNhds (n : \u03b1 \u2192 Filter \u03b1) : TopologicalSpace \u03b1 where\n  IsOpen s := \u2200 a \u2208 s, s \u2208 n a\n  isOpen_univ _ _ := univ_mem\n  isOpen_inter := fun _s _t hs ht x \u27e8hxs, hxt\u27e9 => inter_mem (hs x hxs) (ht x hxt)\n  isOpen_sUnion := fun _s hs _a \u27e8x, hx, hxa\u27e9 =>\n    mem_of_superset (hs x hx _ hxa) (subset_sUnion_of_mem hx)", "start": [101, 1], "end": [107, 62], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.nhds_mkOfNhds", "code": "theorem nhds_mkOfNhds (n : \u03b1 \u2192 Filter \u03b1) (a : \u03b1) (h\u2080 : pure \u2264 n)\n    (h\u2081 : \u2200 a s, s \u2208 n a \u2192 \u2203 t \u2208 n a, t \u2286 s \u2227 \u2200 a' \u2208 t, s \u2208 n a') :\n    @nhds \u03b1 (TopologicalSpace.mkOfNhds n) a = n a", "start": [110, 1], "end": [122, 48], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.nhds_mkOfNhds_single", "code": "theorem nhds_mkOfNhds_single [DecidableEq \u03b1] {a\u2080 : \u03b1} {l : Filter \u03b1} (h : pure a\u2080 \u2264 l) (b : \u03b1) :\n    @nhds \u03b1 (TopologicalSpace.mkOfNhds (update pure a\u2080 l)) b =\n      (update pure a\u2080 l : \u03b1 \u2192 Filter \u03b1) b", "start": [125, 1], "end": [136, 67], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.nhds_mkOfNhds_filterBasis", "code": "theorem nhds_mkOfNhds_filterBasis (B : \u03b1 \u2192 FilterBasis \u03b1) (a : \u03b1) (h\u2080 : \u2200 (x), \u2200 n \u2208 B x, x \u2208 n)\n    (h\u2081 : \u2200 (x), \u2200 n \u2208 B x, \u2203 n\u2081 \u2208 B x, n\u2081 \u2286 n \u2227 \u2200 x' \u2208 n\u2081, \u2203 n\u2082 \u2208 B x', n\u2082 \u2286 n) :\n    @nhds \u03b1 (TopologicalSpace.mkOfNhds fun x => (B x).filter) a = (B a).filter", "start": [139, 1], "end": [149, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.le_def", "code": "protected theorem le_def {\u03b1} {t s : TopologicalSpace \u03b1} : t \u2264 s \u2194 IsOpen[s] \u2264 IsOpen[t]", "start": [162, 1], "end": [163, 10], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.le_generateFrom_iff_subset_isOpen", "code": "theorem le_generateFrom_iff_subset_isOpen {g : Set (Set \u03b1)} {t : TopologicalSpace \u03b1} :\n    t \u2264 generateFrom g \u2194 g \u2286 { s | IsOpen[t] s }", "start": [166, 1], "end": [169, 99], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.mkOfClosure", "code": "protected def mkOfClosure (s : Set (Set \u03b1)) (hs : { u | GenerateOpen s u } = s) :\n    TopologicalSpace \u03b1 where\n  IsOpen u := u \u2208 s\n  isOpen_univ := hs \u25b8 TopologicalSpace.GenerateOpen.univ\n  isOpen_inter := hs \u25b8 TopologicalSpace.GenerateOpen.inter\n  isOpen_sUnion := hs \u25b8 TopologicalSpace.GenerateOpen.sUnion", "start": [172, 1], "end": [179, 61], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.mkOfClosure_sets", "code": "theorem mkOfClosure_sets {s : Set (Set \u03b1)} {hs : { u | GenerateOpen s u } = s} :\n    TopologicalSpace.mkOfClosure s hs = generateFrom s", "start": [182, 1], "end": [184, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.gc_generateFrom", "code": "theorem gc_generateFrom (\u03b1) :\n    GaloisConnection (fun t : TopologicalSpace \u03b1 => OrderDual.toDual { s | IsOpen[t] s })\n      (generateFrom \u2218 OrderDual.ofDual)", "start": [187, 1], "end": [190, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.gciGenerateFrom", "code": "def gciGenerateFrom (\u03b1 : Type*) :\n    GaloisCoinsertion (fun t : TopologicalSpace \u03b1 => OrderDual.toDual { s | IsOpen[t] s })\n      (generateFrom \u2218 OrderDual.ofDual) where\n  gc := gc_generateFrom \u03b1\n  u_l_le _ s hs := TopologicalSpace.GenerateOpen.basic s hs\n  choice g hg := TopologicalSpace.mkOfClosure g\n    (Subset.antisymm hg <| le_generateFrom_iff_subset_isOpen.1 <| le_rfl)\n  choice_eq _ _ := mkOfClosure_sets", "start": [192, 1], "end": [202, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.generateFrom_anti", "code": "@[mono]\ntheorem generateFrom_anti {\u03b1} {g\u2081 g\u2082 : Set (Set \u03b1)} (h : g\u2081 \u2286 g\u2082) :\n    generateFrom g\u2082 \u2264 generateFrom g\u2081", "start": [211, 1], "end": [214, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.generateFrom_setOf_isOpen", "code": "theorem generateFrom_setOf_isOpen (t : TopologicalSpace \u03b1) :\n    generateFrom { s | IsOpen[t] s } = t", "start": [217, 1], "end": [219, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.leftInverse_generateFrom", "code": "theorem leftInverse_generateFrom :\n    LeftInverse generateFrom fun t : TopologicalSpace \u03b1 => { s | IsOpen[t] s }", "start": [222, 1], "end": [224, 38], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.generateFrom_surjective", "code": "theorem generateFrom_surjective : Surjective (generateFrom : Set (Set \u03b1) \u2192 TopologicalSpace \u03b1)", "start": [227, 1], "end": [228, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.setOf_isOpen_injective", "code": "theorem setOf_isOpen_injective : Injective fun t : TopologicalSpace \u03b1 => { s | IsOpen[t] s }", "start": [231, 1], "end": [232, 34], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mono", "code": "theorem IsOpen.mono (hs : IsOpen[t\u2082] s) (h : t\u2081 \u2264 t\u2082) : IsOpen[t\u2081] s", "start": [243, 1], "end": [243, 79], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mono", "code": "theorem IsClosed.mono (hs : IsClosed[t\u2082] s) (h : t\u2081 \u2264 t\u2082) : IsClosed[t\u2081] s", "start": [246, 1], "end": [247, 58], "kind": "commanddeclaration"}, {"full_name": "closure.mono", "code": "theorem closure.mono (h : t\u2081 \u2264 t\u2082) : closure[t\u2081] s \u2286 closure[t\u2082] s", "start": [250, 1], "end": [251, 94], "kind": "commanddeclaration"}, {"full_name": "isOpen_implies_isOpen_iff", "code": "theorem isOpen_implies_isOpen_iff : (\u2200 s, IsOpen[t\u2081] s \u2192 IsOpen[t\u2082] s) \u2194 t\u2082 \u2264 t\u2081", "start": [253, 1], "end": [254, 10], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isOpen_top_iff", "code": "theorem TopologicalSpace.isOpen_top_iff {\u03b1} (U : Set \u03b1) : IsOpen[\u22a4] U \u2194 U = \u2205 \u2228 U = univ", "start": [257, 1], "end": [267, 52], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology", "code": "class DiscreteTopology (\u03b1 : Type*) [t : TopologicalSpace \u03b1] : Prop where\n  \n  eq_bot : t = \u22a5", "start": [270, 1], "end": [274, 17], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_bot", "code": "theorem discreteTopology_bot (\u03b1 : Type*) : @DiscreteTopology \u03b1 \u22a5", "start": [277, 1], "end": [278, 31], "kind": "commanddeclaration"}, {"full_name": "isOpen_discrete", "code": "@[simp]\ntheorem isOpen_discrete (s : Set \u03b1) : IsOpen s", "start": [285, 1], "end": [286, 96], "kind": "commanddeclaration"}, {"full_name": "isClosed_discrete", "code": "@[simp] theorem isClosed_discrete (s : Set \u03b1) : IsClosed s", "start": [289, 1], "end": [289, 82], "kind": "commanddeclaration"}, {"full_name": "closure_discrete", "code": "@[simp] theorem closure_discrete (s : Set \u03b1) : closure s = s", "start": [292, 1], "end": [292, 97], "kind": "commanddeclaration"}, {"full_name": "dense_discrete", "code": "@[simp] theorem dense_discrete {s : Set \u03b1} : Dense s \u2194 s = univ", "start": [294, 1], "end": [294, 98], "kind": "commanddeclaration"}, {"full_name": "denseRange_discrete", "code": "@[simp]\ntheorem denseRange_discrete {f : \u03b9 \u2192 \u03b1} : DenseRange f \u2194 Surjective f", "start": [296, 1], "end": [298, 56], "kind": "commanddeclaration"}, {"full_name": "continuous_of_discreteTopology", "code": "@[nontriviality, continuity]\ntheorem continuous_of_discreteTopology [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} : Continuous f", "start": [300, 1], "end": [302, 48], "kind": "commanddeclaration"}, {"full_name": "nhds_discrete", "code": "@[simp]\ntheorem nhds_discrete (\u03b1 : Type*) [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] : @nhds \u03b1 _ = pure", "start": [305, 1], "end": [307, 75], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_discrete", "code": "theorem mem_nhds_discrete {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 x \u2208 s", "start": [310, 1], "end": [311, 55], "kind": "commanddeclaration"}, {"full_name": "le_of_nhds_le_nhds", "code": "theorem le_of_nhds_le_nhds (h : \u2200 x, @nhds \u03b1 t\u2081 x \u2264 @nhds \u03b1 t\u2082 x) : t\u2081 \u2264 t\u2082", "start": [316, 1], "end": [318, 37], "kind": "commanddeclaration"}, {"full_name": "eq_of_nhds_eq_nhds", "code": "theorem eq_of_nhds_eq_nhds (h : \u2200 x, @nhds \u03b1 t\u2081 x = @nhds \u03b1 t\u2082 x) : t\u2081 = t\u2082", "start": [321, 1], "end": [323, 43], "kind": "commanddeclaration"}, {"full_name": "eq_bot_of_singletons_open", "code": "theorem eq_bot_of_singletons_open {t : TopologicalSpace \u03b1} (h : \u2200 x, IsOpen[t] {x}) : t = \u22a5", "start": [326, 1], "end": [327, 79], "kind": "commanddeclaration"}, {"full_name": "forall_open_iff_discrete", "code": "theorem forall_open_iff_discrete {X : Type*} [TopologicalSpace X] :\n    (\u2200 s : Set X, IsOpen s) \u2194 DiscreteTopology X", "start": [330, 1], "end": [332, 76], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_iff_forall_isClosed", "code": "theorem discreteTopology_iff_forall_isClosed [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 s : Set \u03b1, IsClosed s", "start": [335, 1], "end": [338, 21], "kind": "commanddeclaration"}, {"full_name": "singletons_open_iff_discrete", "code": "theorem singletons_open_iff_discrete {X : Type*} [TopologicalSpace X] :\n    (\u2200 a : X, IsOpen ({a} : Set X)) \u2194 DiscreteTopology X", "start": [340, 1], "end": [342, 80], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_iff_singleton_mem_nhds", "code": "theorem discreteTopology_iff_singleton_mem_nhds [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, {x} \u2208 \ud835\udcdd x", "start": [345, 1], "end": [347, 96], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_iff_nhds", "code": "theorem discreteTopology_iff_nhds [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, \ud835\udcdd x = pure x", "start": [350, 1], "end": [354, 93], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_iff_nhds_ne", "code": "theorem discreteTopology_iff_nhds_ne [TopologicalSpace \u03b1] :\n    DiscreteTopology \u03b1 \u2194 \u2200 x : \u03b1, \ud835\udcdd[\u2260] x = \u22a5", "start": [357, 1], "end": [359, 101], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.of_continuous_injective", "code": "theorem DiscreteTopology.of_continuous_injective\n    {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [DiscreteTopology \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hc : Continuous f) (hinj : Injective f) : DiscreteTopology \u03b1", "start": [362, 1], "end": [369, 93], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.induced", "code": "def TopologicalSpace.induced {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (t : TopologicalSpace \u03b2) :\n    TopologicalSpace \u03b1 where\n  IsOpen s := \u2203 s', IsOpen s' \u2227 f \u207b\u00b9' s' = s\n  isOpen_univ := \u27e8univ, isOpen_univ, preimage_univ\u27e9\n  isOpen_inter := by\n    rintro s\u2081 s\u2082 \u27e8s'\u2081, hs\u2081, rfl\u27e9 \u27e8s'\u2082, hs\u2082, rfl\u27e9\n    exact \u27e8s'\u2081 \u2229 s'\u2082, hs\u2081.inter hs\u2082, preimage_inter\u27e9\n  isOpen_sUnion S h := by\n    choose! g hgo hfg using h\n    refine \u27e8\u22c3 s \u2208 S, g s, isOpen_biUnion fun s hs => hgo s hs, ?_\u27e9\n    rw [preimage_iUnion\u2082, sUnion_eq_biUnion]\n    exact iUnion\u2082_congr hfg", "start": [377, 1], "end": [391, 28], "kind": "commanddeclaration"}, {"full_name": "isOpen_induced_iff", "code": "theorem isOpen_induced_iff [t : TopologicalSpace \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    IsOpen[t.induced f] s \u2194 \u2203 t, IsOpen t \u2227 f \u207b\u00b9' t = s", "start": [394, 1], "end": [396, 10], "kind": "commanddeclaration"}, {"full_name": "isClosed_induced_iff", "code": "theorem isClosed_induced_iff [t : TopologicalSpace \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    IsClosed[t.induced f] s \u2194 \u2203 t, IsClosed t \u2227 f \u207b\u00b9' t = s", "start": [399, 1], "end": [403, 85], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.coinduced", "code": "def TopologicalSpace.coinduced {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (t : TopologicalSpace \u03b1) :\n    TopologicalSpace \u03b2 where\n  IsOpen s := IsOpen[t] (f \u207b\u00b9' s)\n  isOpen_univ := t.isOpen_univ\n  isOpen_inter s\u2081 s\u2082 h\u2081 h\u2082 := h\u2081.inter h\u2082\n  isOpen_sUnion s h := by simpa only [preimage_sUnion] using isOpen_biUnion h", "start": [406, 1], "end": [414, 78], "kind": "commanddeclaration"}, {"full_name": "isOpen_coinduced", "code": "theorem isOpen_coinduced {t : TopologicalSpace \u03b1} {s : Set \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    IsOpen[t.coinduced f] s \u2194 IsOpen (f \u207b\u00b9' s)", "start": [417, 1], "end": [419, 10], "kind": "commanddeclaration"}, {"full_name": "preimage_nhds_coinduced", "code": "theorem preimage_nhds_coinduced [TopologicalSpace \u03b1] {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {a : \u03b1}\n    (hs : s \u2208 @nhds \u03b2 (TopologicalSpace.coinduced \u03c0 \u2039_\u203a) (\u03c0 a)) : \u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd a", "start": [422, 1], "end": [426, 71], "kind": "commanddeclaration"}, {"full_name": "Continuous.coinduced_le", "code": "theorem Continuous.coinduced_le (h : Continuous[t, t'] f) : t.coinduced f \u2264 t'", "start": [431, 1], "end": [432, 33], "kind": "commanddeclaration"}, {"full_name": "coinduced_le_iff_le_induced", "code": "theorem coinduced_le_iff_le_induced {f : \u03b1 \u2192 \u03b2} {t\u03b1 : TopologicalSpace \u03b1}\n    {t\u03b2 : TopologicalSpace \u03b2} : t\u03b1.coinduced f \u2264 t\u03b2 \u2194 t\u03b1 \u2264 t\u03b2.induced f", "start": [435, 1], "end": [437, 75], "kind": "commanddeclaration"}, {"full_name": "Continuous.le_induced", "code": "theorem Continuous.le_induced (h : Continuous[t, t'] f) : t \u2264 t'.induced f", "start": [440, 1], "end": [441, 47], "kind": "commanddeclaration"}, {"full_name": "gc_coinduced_induced", "code": "theorem gc_coinduced_induced (f : \u03b1 \u2192 \u03b2) :\n    GaloisConnection (TopologicalSpace.coinduced f) (TopologicalSpace.induced f)", "start": [444, 1], "end": [446, 30], "kind": "commanddeclaration"}, {"full_name": "induced_mono", "code": "theorem induced_mono (h : t\u2081 \u2264 t\u2082) : t\u2081.induced g \u2264 t\u2082.induced g", "start": [449, 1], "end": [450, 40], "kind": "commanddeclaration"}, {"full_name": "coinduced_mono", "code": "theorem coinduced_mono (h : t\u2081 \u2264 t\u2082) : t\u2081.coinduced f \u2264 t\u2082.coinduced f", "start": [453, 1], "end": [454, 40], "kind": "commanddeclaration"}, {"full_name": "induced_top", "code": "@[simp]\ntheorem induced_top : (\u22a4 : TopologicalSpace \u03b1).induced g = \u22a4", "start": [457, 1], "end": [459, 33], "kind": "commanddeclaration"}, {"full_name": "induced_inf", "code": "@[simp]\ntheorem induced_inf : (t\u2081 \u2293 t\u2082).induced g = t\u2081.induced g \u2293 t\u2082.induced g", "start": [462, 1], "end": [464, 33], "kind": "commanddeclaration"}, {"full_name": "induced_iInf", "code": "@[simp]\ntheorem induced_iInf {\u03b9 : Sort w} {t : \u03b9 \u2192 TopologicalSpace \u03b1} :\n    (\u2a05 i, t i).induced g = \u2a05 i, (t i).induced g", "start": [467, 1], "end": [470, 34], "kind": "commanddeclaration"}, {"full_name": "coinduced_bot", "code": "@[simp]\ntheorem coinduced_bot : (\u22a5 : TopologicalSpace \u03b1).coinduced f = \u22a5", "start": [473, 1], "end": [475, 33], "kind": "commanddeclaration"}, {"full_name": "coinduced_sup", "code": "@[simp]\ntheorem coinduced_sup : (t\u2081 \u2294 t\u2082).coinduced f = t\u2081.coinduced f \u2294 t\u2082.coinduced f", "start": [478, 1], "end": [480, 33], "kind": "commanddeclaration"}, {"full_name": "coinduced_iSup", "code": "@[simp]\ntheorem coinduced_iSup {\u03b9 : Sort w} {t : \u03b9 \u2192 TopologicalSpace \u03b1} :\n    (\u2a06 i, t i).coinduced f = \u2a06 i, (t i).coinduced f", "start": [483, 1], "end": [486, 34], "kind": "commanddeclaration"}, {"full_name": "induced_id", "code": "theorem induced_id [t : TopologicalSpace \u03b1] : t.induced id = t", "start": [489, 1], "end": [491, 82], "kind": "commanddeclaration"}, {"full_name": "induced_compose", "code": "theorem induced_compose [t\u03b3 : TopologicalSpace \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    (t\u03b3.induced g).induced f = t\u03b3.induced (g \u2218 f)", "start": [494, 1], "end": [499, 65], "kind": "commanddeclaration"}, {"full_name": "induced_const", "code": "theorem induced_const [t : TopologicalSpace \u03b1] {x : \u03b1} : (t.induced fun _ : \u03b2 => x) = \u22a4", "start": [502, 1], "end": [503, 62], "kind": "commanddeclaration"}, {"full_name": "coinduced_id", "code": "theorem coinduced_id [t : TopologicalSpace \u03b1] : t.coinduced id = t", "start": [506, 1], "end": [507, 27], "kind": "commanddeclaration"}, {"full_name": "coinduced_compose", "code": "theorem coinduced_compose [t\u03b1 : TopologicalSpace \u03b1] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    (t\u03b1.coinduced f).coinduced g = t\u03b1.coinduced (g \u2218 f)", "start": [510, 1], "end": [512, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.induced_symm", "code": "theorem Equiv.induced_symm {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) :\n    TopologicalSpace.induced e.symm = TopologicalSpace.coinduced e", "start": [515, 1], "end": [519, 95], "kind": "commanddeclaration"}, {"full_name": "Equiv.coinduced_symm", "code": "theorem Equiv.coinduced_symm {\u03b1 \u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) :\n    TopologicalSpace.coinduced e.symm = TopologicalSpace.induced e", "start": [522, 1], "end": [524, 27], "kind": "commanddeclaration"}, {"full_name": "inhabitedTopologicalSpace", "code": "instance inhabitedTopologicalSpace {\u03b1 : Type u} : Inhabited (TopologicalSpace \u03b1) :=\n  \u27e8\u22a5\u27e9", "start": [536, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.uniqueTopologicalSpace", "code": "instance (priority := 100) Subsingleton.uniqueTopologicalSpace [Subsingleton \u03b1] :\n    Unique (TopologicalSpace \u03b1) where\n  default := \u22a5\n  uniq t :=\n    eq_bot_of_singletons_open fun x =>\n      Subsingleton.set_cases (@isOpen_empty _ t) (@isOpen_univ _ t) ({x} : Set \u03b1)", "start": [540, 1], "end": [545, 82], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.discreteTopology", "code": "instance (priority := 100) Subsingleton.discreteTopology [t : TopologicalSpace \u03b1] [Subsingleton \u03b1] :\n    DiscreteTopology \u03b1 :=\n  \u27e8Unique.eq_default t\u27e9", "start": [548, 1], "end": [550, 24], "kind": "commanddeclaration"}, {"full_name": "sierpinskiSpace", "code": "instance sierpinskiSpace : TopologicalSpace Prop :=\n  generateFrom {{True}}", "start": [574, 1], "end": [575, 24], "kind": "commanddeclaration"}, {"full_name": "continuous_empty_function", "code": "theorem continuous_empty_function [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [IsEmpty \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Continuous f", "start": [578, 1], "end": [581, 33], "kind": "commanddeclaration"}, {"full_name": "le_generateFrom", "code": "theorem le_generateFrom {t : TopologicalSpace \u03b1} {g : Set (Set \u03b1)} (h : \u2200 s \u2208 g, IsOpen s) :\n    t \u2264 generateFrom g", "start": [584, 1], "end": [586, 40], "kind": "commanddeclaration"}, {"full_name": "induced_generateFrom_eq", "code": "theorem induced_generateFrom_eq {\u03b1 \u03b2} {b : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} :\n    (generateFrom b).induced f = generateFrom (preimage f '' b)", "start": [589, 1], "end": [592, 101], "kind": "commanddeclaration"}, {"full_name": "le_induced_generateFrom", "code": "theorem le_induced_generateFrom {\u03b1 \u03b2} [t : TopologicalSpace \u03b1] {b : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 a : Set \u03b2, a \u2208 b \u2192 IsOpen (f \u207b\u00b9' a)) : t \u2264 induced f (generateFrom b)", "start": [595, 1], "end": [600, 10], "kind": "commanddeclaration"}, {"full_name": "nhdsAdjoint", "code": "def nhdsAdjoint (a : \u03b1) (f : Filter \u03b1) : TopologicalSpace \u03b1 where\n  IsOpen s := a \u2208 s \u2192 s \u2208 f\n  isOpen_univ _ := univ_mem\n  isOpen_inter := fun _s _t hs ht \u27e8has, hat\u27e9 => inter_mem (hs has) (ht hat)\n  isOpen_sUnion := fun _k hk \u27e8u, hu, hau\u27e9 => mem_of_superset (hk u hu hau) (subset_sUnion_of_mem hu)", "start": [603, 1], "end": [609, 101], "kind": "commanddeclaration"}, {"full_name": "gc_nhds", "code": "theorem gc_nhds (a : \u03b1) : GaloisConnection (nhdsAdjoint a) fun t => @nhds \u03b1 t a", "start": [612, 1], "end": [614, 69], "kind": "commanddeclaration"}, {"full_name": "nhds_mono", "code": "theorem nhds_mono {t\u2081 t\u2082 : TopologicalSpace \u03b1} {a : \u03b1} (h : t\u2081 \u2264 t\u2082) :\n    @nhds \u03b1 t\u2081 a \u2264 @nhds \u03b1 t\u2082 a", "start": [617, 1], "end": [619, 27], "kind": "commanddeclaration"}, {"full_name": "le_iff_nhds", "code": "theorem le_iff_nhds {\u03b1 : Type*} (t t' : TopologicalSpace \u03b1) :\n    t \u2264 t' \u2194 \u2200 x, @nhds \u03b1 t x \u2264 @nhds \u03b1 t' x", "start": [622, 1], "end": [624, 47], "kind": "commanddeclaration"}, {"full_name": "nhdsAdjoint_nhds", "code": "theorem nhdsAdjoint_nhds {\u03b1 : Type*} (a : \u03b1) (f : Filter \u03b1) :\n    @nhds \u03b1 (nhdsAdjoint a f) a = pure a \u2294 f", "start": [627, 1], "end": [636, 44], "kind": "commanddeclaration"}, {"full_name": "nhdsAdjoint_nhds_of_ne", "code": "theorem nhdsAdjoint_nhds_of_ne {\u03b1 : Type*} (a : \u03b1) (f : Filter \u03b1) {b : \u03b1} (h : b \u2260 a) :\n    @nhds \u03b1 (nhdsAdjoint a f) b = pure b", "start": [639, 1], "end": [648, 46], "kind": "commanddeclaration"}, {"full_name": "isOpen_singleton_nhdsAdjoint", "code": "theorem isOpen_singleton_nhdsAdjoint {\u03b1 : Type*} {a b : \u03b1} (f : Filter \u03b1) (hb : b \u2260 a) :\n    IsOpen[nhdsAdjoint a f] {b}", "start": [651, 1], "end": [655, 38], "kind": "commanddeclaration"}, {"full_name": "le_nhdsAdjoint_iff'", "code": "theorem le_nhdsAdjoint_iff' {\u03b1 : Type*} (a : \u03b1) (f : Filter \u03b1) (t : TopologicalSpace \u03b1) :\n    t \u2264 nhdsAdjoint a f \u2194 @nhds \u03b1 t a \u2264 pure a \u2294 f \u2227 \u2200 b, b \u2260 a \u2192 @nhds \u03b1 t b = pure b", "start": [658, 1], "end": [673, 52], "kind": "commanddeclaration"}, {"full_name": "le_nhdsAdjoint_iff", "code": "theorem le_nhdsAdjoint_iff {\u03b1 : Type*} (a : \u03b1) (f : Filter \u03b1) (t : TopologicalSpace \u03b1) :\n    t \u2264 nhdsAdjoint a f \u2194 @nhds \u03b1 t a \u2264 pure a \u2294 f \u2227 \u2200 b, b \u2260 a \u2192 IsOpen[t] {b}", "start": [676, 1], "end": [681, 48], "kind": "commanddeclaration"}, {"full_name": "nhds_iInf", "code": "theorem nhds_iInf {\u03b9 : Sort*} {t : \u03b9 \u2192 TopologicalSpace \u03b1} {a : \u03b1} :\n    @nhds \u03b1 (iInf t) a = \u2a05 i, @nhds \u03b1 (t i) a", "start": [684, 1], "end": [686, 21], "kind": "commanddeclaration"}, {"full_name": "nhds_sInf", "code": "theorem nhds_sInf {s : Set (TopologicalSpace \u03b1)} {a : \u03b1} :\n    @nhds \u03b1 (sInf s) a = \u2a05 t \u2208 s, @nhds \u03b1 t a", "start": [689, 1], "end": [691, 21], "kind": "commanddeclaration"}, {"full_name": "nhds_inf", "code": "theorem nhds_inf {t\u2081 t\u2082 : TopologicalSpace \u03b1} {a : \u03b1} :\n    @nhds \u03b1 (t\u2081 \u2293 t\u2082) a = @nhds \u03b1 t\u2081 a \u2293 @nhds \u03b1 t\u2082 a", "start": [695, 1], "end": [697, 48], "kind": "commanddeclaration"}, {"full_name": "nhds_top", "code": "theorem nhds_top {a : \u03b1} : @nhds \u03b1 \u22a4 a = \u22a4", "start": [700, 1], "end": [701, 20], "kind": "commanddeclaration"}, {"full_name": "isOpen_sup", "code": "theorem isOpen_sup {t\u2081 t\u2082 : TopologicalSpace \u03b1} {s : Set \u03b1} :\n    IsOpen[t\u2081 \u2294 t\u2082] s \u2194 IsOpen[t\u2081] s \u2227 IsOpen[t\u2082] s", "start": [704, 1], "end": [706, 10], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_coinduced_le", "code": "theorem continuous_iff_coinduced_le {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2082] f \u2194 coinduced f t\u2081 \u2264 t\u2082", "start": [713, 1], "end": [715, 17], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_le_induced", "code": "theorem continuous_iff_le_induced {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2082] f \u2194 t\u2081 \u2264 induced f t\u2082", "start": [718, 1], "end": [720, 69], "kind": "commanddeclaration"}, {"full_name": "continuous_generateFrom", "code": "theorem continuous_generateFrom {t : TopologicalSpace \u03b1} {b : Set (Set \u03b2)}\n    (h : \u2200 s \u2208 b, IsOpen (f \u207b\u00b9' s)) :\n    Continuous[t, generateFrom b] f", "start": [723, 1], "end": [726, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_induced_dom", "code": "@[continuity]\ntheorem continuous_induced_dom {t : TopologicalSpace \u03b2} : Continuous[induced f t, t] f", "start": [729, 1], "end": [731, 37], "kind": "commanddeclaration"}, {"full_name": "continuous_induced_rng", "code": "theorem continuous_induced_rng {g : \u03b3 \u2192 \u03b1} {t\u2082 : TopologicalSpace \u03b2} {t\u2081 : TopologicalSpace \u03b3} :\n    Continuous[t\u2081, induced f t\u2082] g \u2194 Continuous[t\u2081, t\u2082] (f \u2218 g)", "start": [734, 1], "end": [736, 57], "kind": "commanddeclaration"}, {"full_name": "continuous_coinduced_rng", "code": "theorem continuous_coinduced_rng {t : TopologicalSpace \u03b1} :\n    Continuous[t, coinduced f t] f", "start": [739, 1], "end": [741, 39], "kind": "commanddeclaration"}, {"full_name": "continuous_coinduced_dom", "code": "theorem continuous_coinduced_dom {g : \u03b2 \u2192 \u03b3} {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b3} :\n    Continuous[coinduced f t\u2081, t\u2082] g \u2194 Continuous[t\u2081, t\u2082] (g \u2218 f)", "start": [744, 1], "end": [746, 61], "kind": "commanddeclaration"}, {"full_name": "continuous_le_dom", "code": "theorem continuous_le_dom {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} (h\u2081 : t\u2082 \u2264 t\u2081)\n    (h\u2082 : Continuous[t\u2081, t\u2083] f) : Continuous[t\u2082, t\u2083] f", "start": [749, 1], "end": [752, 23], "kind": "commanddeclaration"}, {"full_name": "continuous_le_rng", "code": "theorem continuous_le_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 t\u2083 : TopologicalSpace \u03b2} (h\u2081 : t\u2082 \u2264 t\u2083)\n    (h\u2082 : Continuous[t\u2081, t\u2082] f) : Continuous[t\u2081, t\u2083] f", "start": [755, 1], "end": [758, 23], "kind": "commanddeclaration"}, {"full_name": "continuous_sup_dom", "code": "theorem continuous_sup_dom {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081 \u2294 t\u2082, t\u2083] f \u2194 Continuous[t\u2081, t\u2083] f \u2227 Continuous[t\u2082, t\u2083] f", "start": [761, 1], "end": [763, 52], "kind": "commanddeclaration"}, {"full_name": "continuous_sup_rng_left", "code": "theorem continuous_sup_rng_left {t\u2081 : TopologicalSpace \u03b1} {t\u2083 t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2082] f \u2192 Continuous[t\u2081, t\u2082 \u2294 t\u2083] f", "start": [766, 1], "end": [768, 32], "kind": "commanddeclaration"}, {"full_name": "continuous_sup_rng_right", "code": "theorem continuous_sup_rng_right {t\u2081 : TopologicalSpace \u03b1} {t\u2083 t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2083] f \u2192 Continuous[t\u2081, t\u2082 \u2294 t\u2083] f", "start": [771, 1], "end": [773, 33], "kind": "commanddeclaration"}, {"full_name": "continuous_sSup_dom", "code": "theorem continuous_sSup_dom {T : Set (TopologicalSpace \u03b1)} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[sSup T, t\u2082] f \u2194 \u2200 t \u2208 T, Continuous[t, t\u2082] f", "start": [776, 1], "end": [778, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_sSup_rng", "code": "theorem continuous_sSup_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : Set (TopologicalSpace \u03b2)}\n    {t : TopologicalSpace \u03b2} (h\u2081 : t \u2208 t\u2082) (hf : Continuous[t\u2081, t] f) :\n    Continuous[t\u2081, sSup t\u2082] f", "start": [781, 1], "end": [784, 88], "kind": "commanddeclaration"}, {"full_name": "continuous_iSup_dom", "code": "theorem continuous_iSup_dom {t\u2081 : \u03b9 \u2192 TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b2} :\n    Continuous[iSup t\u2081, t\u2082] f \u2194 \u2200 i, Continuous[t\u2081 i, t\u2082] f", "start": [787, 1], "end": [789, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_iSup_rng", "code": "theorem continuous_iSup_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : \u03b9 \u2192 TopologicalSpace \u03b2} {i : \u03b9}\n    (h : Continuous[t\u2081, t\u2082 i] f) : Continuous[t\u2081, iSup t\u2082] f", "start": [792, 1], "end": [794, 33], "kind": "commanddeclaration"}, {"full_name": "continuous_inf_rng", "code": "theorem continuous_inf_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2082 \u2293 t\u2083] f \u2194 Continuous[t\u2081, t\u2082] f \u2227 Continuous[t\u2081, t\u2083] f", "start": [797, 1], "end": [799, 54], "kind": "commanddeclaration"}, {"full_name": "continuous_inf_dom_left", "code": "theorem continuous_inf_dom_left {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2081, t\u2083] f \u2192 Continuous[t\u2081 \u2293 t\u2082, t\u2083] f", "start": [802, 1], "end": [804, 32], "kind": "commanddeclaration"}, {"full_name": "continuous_inf_dom_right", "code": "theorem continuous_inf_dom_right {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2} :\n    Continuous[t\u2082, t\u2083] f \u2192 Continuous[t\u2081 \u2293 t\u2082, t\u2083] f", "start": [807, 1], "end": [809, 33], "kind": "commanddeclaration"}, {"full_name": "continuous_sInf_dom", "code": "theorem continuous_sInf_dom {t\u2081 : Set (TopologicalSpace \u03b1)} {t\u2082 : TopologicalSpace \u03b2}\n    {t : TopologicalSpace \u03b1} (h\u2081 : t \u2208 t\u2081) :\n    Continuous[t, t\u2082] f \u2192 Continuous[sInf t\u2081, t\u2082] f", "start": [812, 1], "end": [815, 34], "kind": "commanddeclaration"}, {"full_name": "continuous_sInf_rng", "code": "theorem continuous_sInf_rng {t\u2081 : TopologicalSpace \u03b1} {T : Set (TopologicalSpace \u03b2)} :\n    Continuous[t\u2081, sInf T] f \u2194 \u2200 t \u2208 T, Continuous[t\u2081, t] f", "start": [818, 1], "end": [820, 55], "kind": "commanddeclaration"}, {"full_name": "continuous_iInf_dom", "code": "theorem continuous_iInf_dom {t\u2081 : \u03b9 \u2192 TopologicalSpace \u03b1} {t\u2082 : TopologicalSpace \u03b2} {i : \u03b9} :\n    Continuous[t\u2081 i, t\u2082] f \u2192 Continuous[iInf t\u2081, t\u2082] f", "start": [823, 1], "end": [825, 35], "kind": "commanddeclaration"}, {"full_name": "continuous_iInf_rng", "code": "theorem continuous_iInf_rng {t\u2081 : TopologicalSpace \u03b1} {t\u2082 : \u03b9 \u2192 TopologicalSpace \u03b2} :\n    Continuous[t\u2081, iInf t\u2082] f \u2194 \u2200 i, Continuous[t\u2081, t\u2082 i] f", "start": [828, 1], "end": [830, 55], "kind": "commanddeclaration"}, {"full_name": "continuous_bot", "code": "@[continuity]\ntheorem continuous_bot {t : TopologicalSpace \u03b2} : Continuous[\u22a5, t] f", "start": [833, 1], "end": [835, 37], "kind": "commanddeclaration"}, {"full_name": "continuous_top", "code": "@[continuity]\ntheorem continuous_top {t : TopologicalSpace \u03b1} : Continuous[t, \u22a4] f", "start": [838, 1], "end": [840, 39], "kind": "commanddeclaration"}, {"full_name": "continuous_id_iff_le", "code": "theorem continuous_id_iff_le {t t' : TopologicalSpace \u03b1} : Continuous[t, t'] id \u2194 t \u2264 t'", "start": [843, 1], "end": [844, 30], "kind": "commanddeclaration"}, {"full_name": "continuous_id_of_le", "code": "theorem continuous_id_of_le {t t' : TopologicalSpace \u03b1} (h : t \u2264 t') : Continuous[t, t'] id", "start": [847, 1], "end": [848, 27], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_induced", "code": "theorem mem_nhds_induced [T : TopologicalSpace \u03b1] (f : \u03b2 \u2192 \u03b1) (a : \u03b2) (s : Set \u03b2) :\n    s \u2208 @nhds \u03b2 (TopologicalSpace.induced f T) a \u2194 \u2203 u \u2208 \ud835\udcdd (f a), f \u207b\u00b9' u \u2286 s", "start": [852, 1], "end": [860, 86], "kind": "commanddeclaration"}, {"full_name": "nhds_induced", "code": "theorem nhds_induced [T : TopologicalSpace \u03b1] (f : \u03b2 \u2192 \u03b1) (a : \u03b2) :\n    @nhds \u03b2 (TopologicalSpace.induced f T) a = comap f (\ud835\udcdd (f a))", "start": [863, 1], "end": [866, 35], "kind": "commanddeclaration"}, {"full_name": "induced_iff_nhds_eq", "code": "theorem induced_iff_nhds_eq [t\u03b1 : TopologicalSpace \u03b1] [t\u03b2 : TopologicalSpace \u03b2] (f : \u03b2 \u2192 \u03b1) :\n    t\u03b2 = t\u03b1.induced f \u2194 \u2200 b, \ud835\udcdd b = comap f (\ud835\udcdd <| f b)", "start": [869, 1], "end": [872, 57], "kind": "commanddeclaration"}, {"full_name": "map_nhds_induced_of_surjective", "code": "theorem map_nhds_induced_of_surjective [T : TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Surjective f)\n    (a : \u03b2) : map f (@nhds \u03b2 (TopologicalSpace.induced f T) a) = \ud835\udcdd (f a)", "start": [875, 1], "end": [877, 48], "kind": "commanddeclaration"}, {"full_name": "isOpen_induced_eq", "code": "theorem isOpen_induced_eq {s : Set \u03b1} :\n    IsOpen[induced f t] s \u2194 s \u2208 preimage f '' { s | IsOpen s }", "start": [890, 1], "end": [892, 10], "kind": "commanddeclaration"}, {"full_name": "isOpen_induced", "code": "theorem isOpen_induced {s : Set \u03b2} (h : IsOpen s) : IsOpen[induced f t] (f \u207b\u00b9' s)", "start": [895, 1], "end": [896, 14], "kind": "commanddeclaration"}, {"full_name": "map_nhds_induced_eq", "code": "theorem map_nhds_induced_eq (a : \u03b1) : map f (@nhds \u03b1 (induced f t) a) = \ud835\udcdd[range f] f a", "start": [899, 1], "end": [900, 50], "kind": "commanddeclaration"}, {"full_name": "map_nhds_induced_of_mem", "code": "theorem map_nhds_induced_of_mem {a : \u03b1} (h : range f \u2208 \ud835\udcdd (f a)) :\n    map f (@nhds \u03b1 (induced f t) a) = \ud835\udcdd (f a)", "start": [903, 1], "end": [904, 97], "kind": "commanddeclaration"}, {"full_name": "closure_induced", "code": "theorem closure_induced [t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} :\n    a \u2208 @closure \u03b1 (t.induced f) s \u2194 f a \u2208 closure (f '' s)", "start": [907, 1], "end": [910, 94], "kind": "commanddeclaration"}, {"full_name": "isClosed_induced_iff'", "code": "theorem isClosed_induced_iff' [t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    IsClosed[t.induced f] s \u2194 \u2200 a, f a \u2208 closure (f '' s) \u2192 a \u2208 s", "start": [913, 1], "end": [916, 73], "kind": "commanddeclaration"}, {"full_name": "isOpen_singleton_true", "code": "@[simp]\ntheorem isOpen_singleton_true : IsOpen ({True} : Set Prop)", "start": [925, 1], "end": [927, 58], "kind": "commanddeclaration"}, {"full_name": "nhds_true", "code": "@[simp]\ntheorem nhds_true : \ud835\udcdd True = pure True", "start": [930, 1], "end": [932, 100], "kind": "commanddeclaration"}, {"full_name": "nhds_false", "code": "@[simp]\ntheorem nhds_false : \ud835\udcdd False = \u22a4", "start": [935, 1], "end": [937, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_true", "code": "theorem tendsto_nhds_true {l : Filter \u03b1} {p : \u03b1 \u2192 Prop} :\n    Tendsto p l (\ud835\udcdd True) \u2194 \u2200\u1da0 x in l, p x", "start": [940, 1], "end": [941, 53], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_Prop", "code": "theorem tendsto_nhds_Prop {l : Filter \u03b1} {p : \u03b1 \u2192 Prop} {q : Prop} :\n    Tendsto p l (\ud835\udcdd q) \u2194 (q \u2192 \u2200\u1da0 x in l, p x)", "start": [943, 1], "end": [945, 26], "kind": "commanddeclaration"}, {"full_name": "continuous_Prop", "code": "theorem continuous_Prop {p : \u03b1 \u2192 Prop} : Continuous p \u2194 IsOpen { x | p x }", "start": [947, 1], "end": [948, 101], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_continuous_mem", "code": "theorem isOpen_iff_continuous_mem {s : Set \u03b1} : IsOpen s \u2194 Continuous (\u00b7 \u2208 s)", "start": [951, 1], "end": [952, 23], "kind": "commanddeclaration"}, {"full_name": "generateFrom_union", "code": "theorem generateFrom_union (a\u2081 a\u2082 : Set (Set \u03b1)) :\n    generateFrom (a\u2081 \u222a a\u2082) = generateFrom a\u2081 \u2293 generateFrom a\u2082", "start": [963, 1], "end": [965, 28], "kind": "commanddeclaration"}, {"full_name": "setOf_isOpen_sup", "code": "theorem setOf_isOpen_sup (t\u2081 t\u2082 : TopologicalSpace \u03b1) :\n    { s | IsOpen[t\u2081 \u2294 t\u2082] s } = { s | IsOpen[t\u2081] s } \u2229 { s | IsOpen[t\u2082] s }", "start": [968, 1], "end": [970, 6], "kind": "commanddeclaration"}, {"full_name": "generateFrom_iUnion", "code": "theorem generateFrom_iUnion {f : \u03b9 \u2192 Set (Set \u03b1)} :\n    generateFrom (\u22c3 i, f i) = \u2a05 i, generateFrom (f i)", "start": [973, 1], "end": [975, 29], "kind": "commanddeclaration"}, {"full_name": "setOf_isOpen_iSup", "code": "theorem setOf_isOpen_iSup {t : \u03b9 \u2192 TopologicalSpace \u03b1} :\n    { s | IsOpen[\u2a06 i, t i] s } = \u22c2 i, { s | IsOpen[t i] s }", "start": [978, 1], "end": [980, 29], "kind": "commanddeclaration"}, {"full_name": "generateFrom_sUnion", "code": "theorem generateFrom_sUnion {S : Set (Set (Set \u03b1))} :\n    generateFrom (\u22c3\u2080 S) = \u2a05 s \u2208 S, generateFrom s", "start": [983, 1], "end": [985, 29], "kind": "commanddeclaration"}, {"full_name": "setOf_isOpen_sSup", "code": "theorem setOf_isOpen_sSup {T : Set (TopologicalSpace \u03b1)} :\n    { s | IsOpen[sSup T] s } = \u22c2 t \u2208 T, { s | IsOpen[t] s }", "start": [988, 1], "end": [990, 29], "kind": "commanddeclaration"}, {"full_name": "generateFrom_union_isOpen", "code": "theorem generateFrom_union_isOpen (a b : TopologicalSpace \u03b1) :\n    generateFrom ({ s | IsOpen[a] s } \u222a { s | IsOpen[b] s }) = a \u2293 b", "start": [993, 1], "end": [995, 34], "kind": "commanddeclaration"}, {"full_name": "generateFrom_iUnion_isOpen", "code": "theorem generateFrom_iUnion_isOpen (f : \u03b9 \u2192 TopologicalSpace \u03b1) :\n    generateFrom (\u22c3 i, { s | IsOpen[f i] s }) = \u2a05 i, f i", "start": [998, 1], "end": [1000, 33], "kind": "commanddeclaration"}, {"full_name": "generateFrom_inter", "code": "theorem generateFrom_inter (a b : TopologicalSpace \u03b1) :\n    generateFrom ({ s | IsOpen[a] s } \u2229 { s | IsOpen[b] s }) = a \u2294 b", "start": [1003, 1], "end": [1005, 34], "kind": "commanddeclaration"}, {"full_name": "generateFrom_iInter", "code": "theorem generateFrom_iInter (f : \u03b9 \u2192 TopologicalSpace \u03b1) :\n    generateFrom (\u22c2 i, { s | IsOpen[f i] s }) = \u2a06 i, f i", "start": [1008, 1], "end": [1010, 33], "kind": "commanddeclaration"}, {"full_name": "generateFrom_iInter_of_generateFrom_eq_self", "code": "theorem generateFrom_iInter_of_generateFrom_eq_self (f : \u03b9 \u2192 Set (Set \u03b1))\n    (hf : \u2200 i, { s | IsOpen[generateFrom (f i)] s } = f i) :\n    generateFrom (\u22c2 i, f i) = \u2a06 i, generateFrom (f i)", "start": [1013, 1], "end": [1016, 48], "kind": "commanddeclaration"}, {"full_name": "isOpen_iSup_iff", "code": "theorem isOpen_iSup_iff {s : Set \u03b1} : IsOpen[\u2a06 i, t i] s \u2194 \u2200 i, IsOpen[t i] s", "start": [1021, 1], "end": [1023, 29], "kind": "commanddeclaration"}, {"full_name": "isClosed_iSup_iff", "code": "theorem isClosed_iSup_iff {s : Set \u03b1} : IsClosed[\u2a06 i, t i] s \u2194 \u2200 i, IsClosed[t i] s", "start": [1026, 1], "end": [1027, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Prod.lean", "imports": ["Mathlib/Data/Nat/Cast/Basic.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.instAddMonoidWithOne", "code": "instance instAddMonoidWithOne : AddMonoidWithOne (\u03b1 \u00d7 \u03b2) :=\n  { Prod.instAddMonoid, @Prod.instOne \u03b1 \u03b2 _ _ with\n    natCast := fun n => (n, n)\n    natCast_zero := congr_arg\u2082 Prod.mk Nat.cast_zero Nat.cast_zero\n    natCast_succ := fun _ => congr_arg\u2082 Prod.mk (Nat.cast_succ _) (Nat.cast_succ _) }", "start": [22, 1], "end": [26, 86], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_natCast", "code": "@[simp]\ntheorem fst_natCast (n : \u2115) : (n : \u03b1 \u00d7 \u03b2).fst = n", "start": [28, 1], "end": [29, 81], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_natCast", "code": "@[simp]\ntheorem snd_natCast (n : \u2115) : (n : \u03b1 \u00d7 \u03b2).snd = n", "start": [32, 1], "end": [33, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Monoid/Prod.lean", "imports": ["Mathlib/Algebra/Order/Monoid/Cancel/Defs.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Monoid/Canonical/Defs.lean", "Mathlib/Data/Prod/Lex.lean"], "premises": [{"full_name": "Prod.instOrderedCancelCommMonoid", "code": "@[to_additive]\ninstance instOrderedCancelCommMonoid [OrderedCancelCommMonoid M] [OrderedCancelCommMonoid N] :\n    OrderedCancelCommMonoid (M \u00d7 N) :=\n  { (inferInstance : OrderedCommMonoid (M \u00d7 N)) with\n    le_of_mul_le_mul_left :=\n      fun _ _ _ h \u21a6 \u27e8le_of_mul_le_mul_left' h.1, le_of_mul_le_mul_left' h.2\u27e9 }", "start": [23, 1], "end": [28, 79], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.orderedCommMonoid", "code": "@[to_additive]\ninstance orderedCommMonoid [OrderedCommMonoid \u03b1]\n    [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] [OrderedCommMonoid \u03b2] :\n    OrderedCommMonoid (\u03b1 \u00d7\u2097 \u03b2) where\n  mul_le_mul_left x y hxy z := ((le_iff _ _).1 hxy).elim\n    (fun hxy => left _ _ <| mul_lt_mul_left' hxy _)\n    (fun hxy => (le_iff _ _).2 <| Or.inr \u27e8by rw [hxy.1], mul_le_mul_left' hxy.2 _\u27e9)", "start": [47, 1], "end": [53, 84], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance orderedCancelCommMonoid [OrderedCancelCommMonoid \u03b1] [OrderedCancelCommMonoid \u03b2] :\n    OrderedCancelCommMonoid (\u03b1 \u00d7\u2097 \u03b2) where\n  mul_le_mul_left _ _ := mul_le_mul_left'\n  le_of_mul_le_mul_left _ _ _ hxyz := ((le_iff _ _).1 hxyz).elim\n    (fun hxy => left _ _ <| lt_of_mul_lt_mul_left' hxy)\n    (fun hxy => (le_iff _ _).2 <| Or.inr \u27e8mul_left_cancel hxy.1, le_of_mul_le_mul_left' hxy.2\u27e9)", "start": [55, 1], "end": [61, 96], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.linearOrderedCancelCommMonoid", "code": "@[to_additive]\ninstance linearOrderedCancelCommMonoid [LinearOrderedCancelCommMonoid \u03b1]\n    [LinearOrderedCancelCommMonoid \u03b2] : LinearOrderedCancelCommMonoid (\u03b1 \u00d7\u2097 \u03b2) where\n  __ : LinearOrder (\u03b1 \u00d7\u2097 \u03b2) := inferInstance\n  __ : OrderedCancelCommMonoid (\u03b1 \u00d7\u2097 \u03b2) := inferInstance", "start": [63, 1], "end": [67, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Fin.lean", "imports": ["Mathlib/Data/Fin/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.map_valEmbedding_univ", "code": "theorem map_valEmbedding_univ : (Finset.univ : Finset (Fin n)).map Fin.valEmbedding = Iio n", "start": [25, 1], "end": [27, 63], "kind": "commanddeclaration"}, {"full_name": "Fin.Ioi_zero_eq_map", "code": "@[simp]\ntheorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).toEmbedding", "start": [30, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "Fin.Iio_last_eq_map", "code": "@[simp]\ntheorem Iio_last_eq_map : Iio (Fin.last n) = Finset.univ.map Fin.castSuccEmb.toEmbedding", "start": [44, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "Fin.Ioi_succ", "code": "@[simp]\ntheorem Ioi_succ (i : Fin n) : Ioi i.succ = (Ioi i).map (Fin.succEmbedding _).toEmbedding", "start": [51, 1], "end": [62, 10], "kind": "commanddeclaration"}, {"full_name": "Fin.Iio_castSucc", "code": "@[simp]\ntheorem Iio_castSucc (i : Fin n) :\n    Iio (castSucc i) = (Iio i).map Fin.castSuccEmb.toEmbedding", "start": [65, 1], "end": [70, 42], "kind": "commanddeclaration"}, {"full_name": "Fin.card_filter_univ_succ'", "code": "theorem card_filter_univ_succ' (p : Fin (n + 1) \u2192 Prop) [DecidablePred p] :\n    (univ.filter p).card = ite (p 0) 1 0 + (univ.filter (p \u2218 Fin.succ)).card", "start": [73, 1], "end": [76, 21], "kind": "commanddeclaration"}, {"full_name": "Fin.card_filter_univ_succ", "code": "theorem card_filter_univ_succ (p : Fin (n + 1) \u2192 Prop) [DecidablePred p] :\n    (univ.filter p).card =\n    if p 0 then (univ.filter (p \u2218 Fin.succ)).card + 1 else (univ.filter (p \u2218 Fin.succ)).card", "start": [79, 1], "end": [82, 72], "kind": "commanddeclaration"}, {"full_name": "Fin.card_filter_univ_eq_vector_get_eq_count", "code": "theorem card_filter_univ_eq_vector_get_eq_count [DecidableEq \u03b1] (a : \u03b1) (v : Vector \u03b1 n) :\n    (univ.filter fun i => a = v.get i).card = v.toList.count a", "start": [85, 1], "end": [90, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/FinRange.lean", "imports": ["Mathlib/Data/List/OfFn.lean", "Mathlib/Data/List/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.map_coe_finRange", "code": "@[simp]\ntheorem map_coe_finRange (n : \u2115) : ((finRange n) : List (Fin n)).map (Fin.val) = List.range n", "start": [24, 1], "end": [27, 22], "kind": "commanddeclaration"}, {"full_name": "List.finRange_succ_eq_map", "code": "theorem finRange_succ_eq_map (n : \u2115) : finRange n.succ = 0 :: (finRange n).map Fin.succ", "start": [30, 1], "end": [34, 42], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_eq_pmap", "code": "theorem ofFn_eq_pmap {\u03b1 n} {f : Fin n \u2192 \u03b1} :\n    ofFn f = pmap (fun i hi => f \u27e8i, hi\u27e9) (range n) fun _ => mem_range.1", "start": [39, 1], "end": [42, 73], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_id", "code": "theorem ofFn_id (n) : ofFn id = finRange n", "start": [45, 1], "end": [46, 15], "kind": "commanddeclaration"}, {"full_name": "List.ofFn_eq_map", "code": "theorem ofFn_eq_map {\u03b1 n} {f : Fin n \u2192 \u03b1} : ofFn f = (finRange n).map f", "start": [49, 1], "end": [50, 46], "kind": "commanddeclaration"}, {"full_name": "List.nodup_ofFn_ofInjective", "code": "theorem nodup_ofFn_ofInjective {\u03b1 n} {f : Fin n \u2192 \u03b1} (hf : Function.Injective f) :\n    Nodup (ofFn f)", "start": [53, 1], "end": [56, 68], "kind": "commanddeclaration"}, {"full_name": "List.nodup_ofFn", "code": "theorem nodup_ofFn {\u03b1 n} {f : Fin n \u2192 \u03b1} : Nodup (ofFn f) \u2194 Function.Injective f", "start": [59, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.map_finRange_perm", "code": "theorem Equiv.Perm.map_finRange_perm {n : \u2115} (\u03c3 : Equiv.Perm (Fin n)) :\n    map \u03c3 (finRange n) ~ finRange n", "start": [74, 1], "end": [77, 79], "kind": "commanddeclaration"}, {"full_name": "Equiv.Perm.ofFn_comp_perm", "code": "theorem Equiv.Perm.ofFn_comp_perm {n : \u2115} {\u03b1 : Type u} (\u03c3 : Equiv.Perm (Fin n)) (f : Fin n \u2192 \u03b1) :\n    ofFn (f \u2218 \u03c3) ~ ofFn f", "start": [80, 1], "end": [85, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/BigOperators.lean", "imports": ["Mathlib/Data/Fintype/Sigma.lean", "Mathlib/Data/Fintype/Vector.lean", "Mathlib/Data/Fintype/Sum.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Powerset.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "Mathlib/Data/Fintype/Option.lean", "Mathlib/Algebra/BigOperators/Option.lean"], "premises": [{"full_name": "Fintype.prod_bool", "code": "@[to_additive]\ntheorem prod_bool [CommMonoid \u03b1] (f : Bool \u2192 \u03b1) : \u220f b, f b = f true * f false", "start": [38, 1], "end": [39, 89], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_sum_ones", "code": "theorem card_eq_sum_ones {\u03b1} [Fintype \u03b1] : Fintype.card \u03b1 = \u2211 _a : \u03b1, 1", "start": [43, 1], "end": [44, 28], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_extend_by_one", "code": "@[to_additive]\ntheorem prod_extend_by_one [CommMonoid \u03b1] (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) :\n    \u220f i, (if i \u2208 s then f i else 1) = \u220f i in s, f i", "start": [53, 1], "end": [56, 54], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_eq_one", "code": "@[to_additive]\ntheorem prod_eq_one (f : \u03b1 \u2192 M) (h : \u2200 a, f a = 1) : \u220f a, f a = 1", "start": [66, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_congr", "code": "@[to_additive]\ntheorem prod_congr (f g : \u03b1 \u2192 M) (h : \u2200 a, f a = g a) : \u220f a, f a = \u220f a, g a", "start": [72, 1], "end": [74, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_eq_single", "code": "@[to_additive]\ntheorem prod_eq_single {f : \u03b1 \u2192 M} (a : \u03b1) (h : \u2200 (x) (_ : x \u2260 a), f x = 1) : \u220f x, f x = f a", "start": [78, 1], "end": [80, 89], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_eq_mul", "code": "@[to_additive]\ntheorem prod_eq_mul {f : \u03b1 \u2192 M} (a b : \u03b1) (h\u2081 : a \u2260 b) (h\u2082 : \u2200 x, x \u2260 a \u2227 x \u2260 b \u2192 f x = 1) :\n    \u220f x, f x = f a * f b", "start": [84, 1], "end": [88, 50], "kind": "commanddeclaration"}, {"full_name": "Fintype.eq_of_subsingleton_of_prod_eq", "code": "@[to_additive \"If a sum of a `Finset` of a subsingleton type has a given\n  value, so do the terms in that sum.\"]\ntheorem eq_of_subsingleton_of_prod_eq {\u03b9 : Type*} [Subsingleton \u03b9] {s : Finset \u03b9} {f : \u03b9 \u2192 M}\n    {b : M} (h : \u220f i in s, f i = b) : \u2200 i \u2208 s, f i = b", "start": [92, 1], "end": [98, 79], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_option", "code": "@[to_additive (attr := simp)]\ntheorem Fintype.prod_option (f : Option \u03b1 \u2192 M) : \u220f i, f i = f none * \u220f i, f (some i)", "start": [112, 1], "end": [114, 32], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_sigma", "code": "@[simp]\nnonrec theorem Fintype.card_sigma {\u03b1 : Type*} (\u03b2 : \u03b1 \u2192 Type*) [Fintype \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    Fintype.card (Sigma \u03b2) = \u2211 a, Fintype.card (\u03b2 a)", "start": [122, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.card_pi", "code": "@[simp]\ntheorem Finset.card_pi [DecidableEq \u03b1] {\u03b4 : \u03b1 \u2192 Type*} (s : Finset \u03b1) (t : \u2200 a, Finset (\u03b4 a)) :\n    (s.pi t).card = \u220f a in s, card (t a)", "start": [128, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_piFinset", "code": "@[simp]\ntheorem Fintype.card_piFinset [DecidableEq \u03b1] [Fintype \u03b1] {\u03b4 : \u03b1 \u2192 Type*} (t : \u2200 a, Finset (\u03b4 a)) :\n    (Fintype.piFinset t).card = \u220f a, Finset.card (t a)", "start": [134, 1], "end": [136, 95], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_pi", "code": "@[simp]\ntheorem Fintype.card_pi {\u03b2 : \u03b1 \u2192 Type*} [DecidableEq \u03b1] [Fintype \u03b1] [\u2200 a, Fintype (\u03b2 a)] :\n    Fintype.card (\u2200 a, \u03b2 a) = \u220f a, Fintype.card (\u03b2 a)", "start": [139, 1], "end": [142, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_fun", "code": "@[simp]\ntheorem Fintype.card_fun [DecidableEq \u03b1] [Fintype \u03b1] [Fintype \u03b2] :\n    Fintype.card (\u03b1 \u2192 \u03b2) = Fintype.card \u03b2 ^ Fintype.card \u03b1", "start": [146, 1], "end": [149, 47], "kind": "commanddeclaration"}, {"full_name": "card_vector", "code": "@[simp]\ntheorem card_vector [Fintype \u03b1] (n : \u2115) : Fintype.card (Vector \u03b1 n) = Fintype.card \u03b1 ^ n", "start": [152, 1], "end": [154, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_attach_univ", "code": "@[to_additive (attr := simp)]\ntheorem Finset.prod_attach_univ [Fintype \u03b1] [CommMonoid \u03b2] (f : { a : \u03b1 // a \u2208 @univ \u03b1 _ } \u2192 \u03b2) :\n    \u220f x in univ.attach, f x = \u220f x, f \u27e8x, mem_univ _\u27e9", "start": [157, 1], "end": [160, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_univ_pi", "code": "@[to_additive \"Taking a sum over `univ.pi t` is the same as taking the sum over\n  `Fintype.piFinset t`. `univ.pi t` and `Fintype.piFinset t` are essentially the same `Finset`,\n  but differ in the type of their element, `univ.pi t` is a `Finset (\u03a0 a \u2208 univ, t a)` and\n  `Fintype.piFinset t` is a `Finset (\u03a0 a, t a)`.\"]\ntheorem Finset.prod_univ_pi [DecidableEq \u03b1] [Fintype \u03b1] [CommMonoid \u03b2] {\u03b4 : \u03b1 \u2192 Type*}\n    {t : \u2200 a : \u03b1, Finset (\u03b4 a)} (f : (\u2200 a : \u03b1, a \u2208 (univ : Finset \u03b1) \u2192 \u03b4 a) \u2192 \u03b2) :\n    \u220f x in univ.pi t, f x = \u220f x in Fintype.piFinset t, f fun a _ => x a", "start": [164, 1], "end": [181, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_univ_sum", "code": "theorem Finset.prod_univ_sum [DecidableEq \u03b1] [Fintype \u03b1] [CommSemiring \u03b2] {\u03b4 : \u03b1 \u2192 Type u_1}\n    [\u2200 a : \u03b1, DecidableEq (\u03b4 a)] {t : \u2200 a : \u03b1, Finset (\u03b4 a)} {f : \u2200 a : \u03b1, \u03b4 a \u2192 \u03b2} :\n    (\u220f a, \u2211 b in t a, f a b) = \u2211 p in Fintype.piFinset t, \u220f x, f x (p x)", "start": [185, 1], "end": [191, 68], "kind": "commanddeclaration"}, {"full_name": "Fintype.sum_pow_mul_eq_add_pow", "code": "theorem Fintype.sum_pow_mul_eq_add_pow (\u03b1 : Type*) [Fintype \u03b1] {R : Type*} [CommSemiring R]\n    (a b : R) :\n    (\u2211 s : Finset \u03b1, a ^ s.card * b ^ (Fintype.card \u03b1 - s.card)) = (a + b) ^ Fintype.card \u03b1", "start": [194, 1], "end": [201, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.prod_comp", "code": "@[to_additive]\ntheorem Function.Bijective.prod_comp [Fintype \u03b1] [Fintype \u03b2] [CommMonoid \u03b3] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Bijective f) (g : \u03b2 \u2192 \u03b3) : (\u220f i, g (f i)) = \u220f i, g i", "start": [204, 1], "end": [207, 48], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_comp", "code": "@[to_additive]\ntheorem Equiv.prod_comp [Fintype \u03b1] [Fintype \u03b2] [CommMonoid \u03b3] (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b3) :\n    (\u220f i, f (e i)) = \u220f i, f i", "start": [211, 1], "end": [214, 26], "kind": "commanddeclaration"}, {"full_name": "Equiv.prod_comp'", "code": "@[to_additive]\ntheorem Equiv.prod_comp' [Fintype \u03b1] [Fintype \u03b2] [CommMonoid \u03b3] (e : \u03b1 \u2243 \u03b2) (f : \u03b1 \u2192 \u03b3) (g : \u03b2 \u2192 \u03b3)\n    (h : \u2200 i, f i = g (e i)) : \u220f i, f i = \u220f i, g i", "start": [218, 1], "end": [221, 54], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_eq_prod_range", "code": "@[to_additive \"It is equivalent to sum a function over `fin n` or `finset.range n`.\"]\ntheorem Fin.prod_univ_eq_prod_range [CommMonoid \u03b1] (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    \u220f i : Fin n, f i = \u220f i in range n, f i", "start": [225, 1], "end": [232, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_fin_eq_prod_range", "code": "@[to_additive]\ntheorem Finset.prod_fin_eq_prod_range [CommMonoid \u03b2] {n : \u2115} (c : Fin n \u2192 \u03b2) :\n    \u220f i, c i = \u220f i in Finset.range n, if h : i < n then c \u27e8i, h\u27e9 else 1", "start": [236, 1], "end": [241, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_toFinset_eq_subtype", "code": "@[to_additive]\ntheorem Finset.prod_toFinset_eq_subtype {M : Type*} [CommMonoid M] [Fintype \u03b1] (p : \u03b1 \u2192 Prop)\n    [DecidablePred p] (f : \u03b1 \u2192 M) : \u220f a in { x | p x }.toFinset, f a = \u220f a : Subtype p, f a", "start": [245, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_fiberwise", "code": "@[to_additive]\ntheorem Finset.prod_fiberwise [DecidableEq \u03b2] [Fintype \u03b2] [CommMonoid \u03b3] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (g : \u03b1 \u2192 \u03b3) : (\u220f b : \u03b2, \u220f a in s.filter fun a => f a = b, g a) = \u220f a in s, g a", "start": [253, 1], "end": [256, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_fiberwise", "code": "@[to_additive]\ntheorem Fintype.prod_fiberwise [Fintype \u03b1] [DecidableEq \u03b2] [Fintype \u03b2] [CommMonoid \u03b3] (f : \u03b1 \u2192 \u03b2)\n    (g : \u03b1 \u2192 \u03b3) : (\u220f b : \u03b2, \u220f a : { a // f a = b }, g (a : \u03b1)) = \u220f a, g a", "start": [260, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_dite", "code": "nonrec theorem Fintype.prod_dite [Fintype \u03b1] {p : \u03b1 \u2192 Prop} [DecidablePred p] [CommMonoid \u03b2]\n    (f : \u2200 (a : \u03b1) (_ha : p a), \u03b2) (g : \u2200 (a : \u03b1) (_ha : \u00acp a), \u03b2) :\n    (\u220f a, dite (p a) (f a) (g a)) =\n    (\u220f a : { a // p a }, f a a.2) * \u220f a : { a // \u00acp a }, g a a.2", "start": [268, 1], "end": [275, 89], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_sum_elim", "code": "@[to_additive]\ntheorem Fintype.prod_sum_elim (f : \u03b1\u2081 \u2192 M) (g : \u03b1\u2082 \u2192 M) :\n    \u220f x, Sum.elim f g x = (\u220f a\u2081, f a\u2081) * \u220f a\u2082, g a\u2082", "start": [284, 1], "end": [287, 22], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_sum_type", "code": "@[to_additive (attr := simp)]\ntheorem Fintype.prod_sum_type (f : Sum \u03b1\u2081 \u03b1\u2082 \u2192 M) :\n    \u220f x, f x = (\u220f a\u2081, f (Sum.inl a\u2081)) * \u220f a\u2082, f (Sum.inr a\u2082)", "start": [291, 1], "end": [294, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Defs.lean", "imports": ["Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp", "code": "structure Finsupp (\u03b1 : Type*) (M : Type*) [Zero M] where\n  \n  support : Finset \u03b1\n  \n  toFun : \u03b1 \u2192 M\n  \n  mem_support_toFun : \u2200 a, a \u2208 support \u2194 toFun a \u2260 0", "start": [92, 1], "end": [101, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.funLike", "code": "instance funLike : FunLike (\u03b1 \u2192\u2080 M) \u03b1 fun _ => M :=\n  \u27e8toFun, by\n    rintro \u27e8s, f, hf\u27e9 \u27e8t, g, hg\u27e9 (rfl : f = g)\n    congr\n    ext a\n    exact (hf _).trans (hg _).symm\u27e9", "start": [119, 1], "end": [124, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coeFun", "code": "instance coeFun : CoeFun (\u03b1 \u2192\u2080 M) fun _ => \u03b1 \u2192 M :=\n  inferInstance", "start": [127, 1], "end": [130, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ext", "code": "@[ext]\ntheorem ext {f g : \u03b1 \u2192\u2080 M} (h : \u2200 a, f a = g a) : f = g", "start": [133, 1], "end": [135, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ext_iff", "code": "@[deprecated FunLike.ext_iff]\ntheorem ext_iff {f g : \u03b1 \u2192\u2080 M} : f = g \u2194 \u2200 a, f a = g a", "start": [138, 1], "end": [140, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coeFn_inj", "code": "@[deprecated FunLike.coe_fn_eq]\ntheorem coeFn_inj {f g : \u03b1 \u2192\u2080 M} : (f : \u03b1 \u2192 M) = g \u2194 f = g", "start": [143, 1], "end": [145, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coeFn_injective", "code": "@[deprecated FunLike.coe_injective]\ntheorem coeFn_injective : @Function.Injective (\u03b1 \u2192\u2080 M) (\u03b1 \u2192 M) (\u21d1)", "start": [148, 1], "end": [150, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.congr_fun", "code": "@[deprecated FunLike.congr_fun]\ntheorem congr_fun {f g : \u03b1 \u2192\u2080 M} (h : f = g) (a : \u03b1) : f a = g a", "start": [153, 1], "end": [155, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u03b1 \u2192 M) (s : Finset \u03b1) (h : \u2200 a, a \u2208 s \u2194 f a \u2260 0) : \u21d1(\u27e8s, f, h\u27e9 : \u03b1 \u2192\u2080 M) = f", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zero", "code": "instance zero : Zero (\u03b1 \u2192\u2080 M) :=\n  \u27e8\u27e8\u2205, 0, fun _ => \u27e8fun h \u21a6 (not_mem_empty _ h).elim, fun H => (H rfl).elim\u27e9\u27e9\u27e9", "start": [163, 1], "end": [164, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : \u03b1 \u2192\u2080 M) = 0", "start": [167, 1], "end": [169, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zero_apply", "code": "theorem zero_apply {a : \u03b1} : (0 : \u03b1 \u2192\u2080 M) a = 0", "start": [172, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_zero", "code": "@[simp]\ntheorem support_zero : (0 : \u03b1 \u2192\u2080 M).support = \u2205", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.inhabited", "code": "instance inhabited : Inhabited (\u03b1 \u2192\u2080 M) :=\n  \u27e80\u27e9", "start": [181, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_support_iff", "code": "@[simp]\ntheorem mem_support_iff {f : \u03b1 \u2192\u2080 M} : \u2200 {a : \u03b1}, a \u2208 f.support \u2194 f a \u2260 0", "start": [185, 1], "end": [187, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.fun_support_eq", "code": "@[simp, norm_cast]\ntheorem fun_support_eq (f : \u03b1 \u2192\u2080 M) : Function.support f = f.support", "start": [190, 1], "end": [192, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.not_mem_support_iff", "code": "theorem not_mem_support_iff {f : \u03b1 \u2192\u2080 M} {a} : a \u2209 f.support \u2194 f a = 0", "start": [195, 1], "end": [196, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_eq_zero", "code": "@[simp, norm_cast]\ntheorem coe_eq_zero {f : \u03b1 \u2192\u2080 M} : (f : \u03b1 \u2192 M) = 0 \u2194 f = 0", "start": [199, 1], "end": [200, 100], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ext_iff'", "code": "theorem ext_iff' {f g : \u03b1 \u2192\u2080 M} : f = g \u2194 f.support = g.support \u2227 \u2200 x \u2208 f.support, f x = g x", "start": [203, 1], "end": [210, 21], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_eq_empty", "code": "@[simp]\ntheorem support_eq_empty {f : \u03b1 \u2192\u2080 M} : f.support = \u2205 \u2194 f = 0", "start": [213, 1], "end": [215, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_nonempty_iff", "code": "theorem support_nonempty_iff {f : \u03b1 \u2192\u2080 M} : f.support.Nonempty \u2194 f \u2260 0", "start": [218, 1], "end": [219, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.nonzero_iff_exists", "code": "theorem nonzero_iff_exists {f : \u03b1 \u2192\u2080 M} : f \u2260 0 \u2194 \u2203 a : \u03b1, f a \u2260 0", "start": [222, 1], "end": [223, 72], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_support_eq_zero", "code": "theorem card_support_eq_zero {f : \u03b1 \u2192\u2080 M} : card f.support = 0 \u2194 f = 0", "start": [226, 1], "end": [226, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] [DecidableEq M] : DecidableEq (\u03b1 \u2192\u2080 M) := fun f g =>\n  decidable_of_iff (f.support = g.support \u2227 \u2200 a \u2208 f.support, f a = g a) ext_iff'.symm", "start": [229, 1], "end": [230, 86], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finite_support", "code": "theorem finite_support (f : \u03b1 \u2192\u2080 M) : Set.Finite (Function.support f)", "start": [233, 1], "end": [234, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_subset_iff", "code": "theorem support_subset_iff {s : Set \u03b1} {f : \u03b1 \u2192\u2080 M} :\n    \u2191f.support \u2286 s \u2194 \u2200 (a) (_ : a \u2209 s), f a = 0", "start": [239, 1], "end": [241, 98], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivFunOnFinite", "code": "@[simps]\ndef equivFunOnFinite [Finite \u03b1] : (\u03b1 \u2192\u2080 M) \u2243 (\u03b1 \u2192 M) where\n  toFun := (\u21d1)\n  invFun f := mk (Function.support f).toFinite.toFinset f fun _a => Set.Finite.mem_toFinset _\n  left_inv _f := ext fun _x => rfl\n  right_inv _f := rfl", "start": [244, 1], "end": [251, 22], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivFunOnFinite_symm_coe", "code": "@[simp]\ntheorem equivFunOnFinite_symm_coe {\u03b1} [Finite \u03b1] (f : \u03b1 \u2192\u2080 M) : equivFunOnFinite.symm f = f", "start": [254, 1], "end": [256, 38], "kind": "commanddeclaration"}, {"full_name": "Equiv.finsuppUnique", "code": "@[simps!]\nnoncomputable def _root_.Equiv.finsuppUnique {\u03b9 : Type*} [Unique \u03b9] : (\u03b9 \u2192\u2080 M) \u2243 M :=\n  Finsupp.equivFunOnFinite.trans (Equiv.funUnique \u03b9 M)", "start": [259, 1], "end": [264, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.unique_ext", "code": "@[ext]\ntheorem unique_ext [Unique \u03b1] {f g : \u03b1 \u2192\u2080 M} (h : f default = g default) : f = g", "start": [270, 1], "end": [272, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.unique_ext_iff", "code": "theorem unique_ext_iff [Unique \u03b1] {f g : \u03b1 \u2192\u2080 M} : f = g \u2194 f default = g default", "start": [275, 1], "end": [276, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single", "code": "def single (a : \u03b1) (b : M) : \u03b1 \u2192\u2080 M\n    where\n  support :=\n    haveI := Classical.decEq M\n    if b = 0 then \u2205 else {a}\n  toFun :=\n    haveI := Classical.decEq \u03b1\n    Pi.single a b\n  mem_support_toFun a' := by\n    classical\n      obtain rfl | hb := eq_or_ne b 0\n      \u00b7 simp [Pi.single, update]\n      rw [if_neg hb, mem_singleton]\n      obtain rfl | ha := eq_or_ne a' a\n      \u00b7 simp [hb, Pi.single, update]\n      simp [Pi.single_eq_of_ne' ha.symm, ha]", "start": [288, 1], "end": [304, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_apply", "code": "theorem single_apply [Decidable (a = a')] : single a b a' = if a = a' then b else 0", "start": [307, 1], "end": [310, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_apply_left", "code": "theorem single_apply_left {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (x z : \u03b1) (y : M) :\n    single (f x) y (f z) = single x y z", "start": [313, 1], "end": [314, 92], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_set_indicator", "code": "theorem single_eq_set_indicator : \u21d1(single a b) = Set.indicator {a} fun _ => b", "start": [317, 1], "end": [320, 51], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_same", "code": "@[simp]\ntheorem single_eq_same : (single a b : \u03b1 \u2192\u2080 M) a = b", "start": [323, 1], "end": [325, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_of_ne", "code": "@[simp]\ntheorem single_eq_of_ne (h : a \u2260 a') : (single a b : \u03b1 \u2192\u2080 M) a' = 0", "start": [328, 1], "end": [330, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_update", "code": "theorem single_eq_update [DecidableEq \u03b1] (a : \u03b1) (b : M) :\n    \u21d1(single a b) = Function.update (0 : _) a b", "start": [333, 1], "end": [335, 99], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_pi_single", "code": "theorem single_eq_pi_single [DecidableEq \u03b1] (a : \u03b1) (b : M) : \u21d1(single a b) = Pi.single a b", "start": [338, 1], "end": [339, 23], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_zero", "code": "@[simp]\ntheorem single_zero (a : \u03b1) : (single a 0 : \u03b1 \u2192\u2080 M) = 0", "start": [342, 1], "end": [345, 98], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_of_single_apply", "code": "theorem single_of_single_apply (a a' : \u03b1) (b : M) :\n    single a ((single a' b) a) = single a' (single a' b) a", "start": [348, 1], "end": [355, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_single_ne_zero", "code": "theorem support_single_ne_zero (a : \u03b1) (hb : b \u2260 0) : (single a b).support = {a}", "start": [358, 1], "end": [359, 12], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_single_subset", "code": "theorem support_single_subset : (single a b).support \u2286 {a}", "start": [362, 1], "end": [363, 90], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_apply_mem", "code": "theorem single_apply_mem (x) : single a b x \u2208 ({0, b} : Set M)", "start": [366, 1], "end": [367, 74], "kind": "commanddeclaration"}, {"full_name": "Finsupp.range_single_subset", "code": "theorem range_single_subset : Set.range (single a b) \u2286 {0, b}", "start": [370, 1], "end": [371, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_injective", "code": "theorem single_injective (a : \u03b1) : Function.Injective (single a : M \u2192 \u03b1 \u2192\u2080 M)", "start": [374, 1], "end": [378, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_apply_eq_zero", "code": "theorem single_apply_eq_zero {a x : \u03b1} {b : M} : single a b x = 0 \u2194 x = a \u2192 b = 0", "start": [381, 1], "end": [382, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_apply_ne_zero", "code": "theorem single_apply_ne_zero {a x : \u03b1} {b : M} : single a b x \u2260 0 \u2194 x = a \u2227 b \u2260 0", "start": [385, 1], "end": [386, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_support_single", "code": "theorem mem_support_single (a a' : \u03b1) (b : M) : a \u2208 (single a' b).support \u2194 a = a' \u2227 b \u2260 0", "start": [389, 1], "end": [390, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.eq_single_iff", "code": "theorem eq_single_iff {f : \u03b1 \u2192\u2080 M} {a b} : f = single a b \u2194 f.support \u2286 {a} \u2227 f a = b", "start": [393, 1], "end": [398, 80], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_single_iff", "code": "theorem single_eq_single_iff (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : M) :\n    single a\u2081 b\u2081 = single a\u2082 b\u2082 \u2194 a\u2081 = a\u2082 \u2227 b\u2081 = b\u2082 \u2228 b\u2081 = 0 \u2227 b\u2082 = 0", "start": [401, 1], "end": [415, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_left_injective", "code": "theorem single_left_injective (h : b \u2260 0) : Function.Injective fun a : \u03b1 => single a b", "start": [418, 1], "end": [421, 94], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_left_inj", "code": "theorem single_left_inj (h : b \u2260 0) : single a b = single a' b \u2194 a = a'", "start": [424, 1], "end": [425, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_single_ne_bot", "code": "theorem support_single_ne_bot (i : \u03b1) (h : b \u2260 0) : (single i b).support \u2260 \u22a5", "start": [428, 1], "end": [429, 69], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_single_disjoint", "code": "theorem support_single_disjoint {b' : M} (hb : b \u2260 0) (hb' : b' \u2260 0) {i j : \u03b1} :\n    Disjoint (single i b).support (single j b').support \u2194 i \u2260 j", "start": [432, 1], "end": [434, 85], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_zero", "code": "@[simp]\ntheorem single_eq_zero : single a b = 0 \u2194 b = 0", "start": [437, 1], "end": [439, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_swap", "code": "theorem single_swap (a\u2081 a\u2082 : \u03b1) (b : M) : single a\u2081 b a\u2082 = single a\u2082 b a\u2081", "start": [442, 1], "end": [443, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.nontrivial", "code": "instance nontrivial [Nonempty \u03b1] [Nontrivial M] : Nontrivial (\u03b1 \u2192\u2080 M) := by\n  inhabit \u03b1\n  rcases exists_ne (0 : M) with \u27e8x, hx\u27e9\n  exact nontrivial_of_ne (single default x) 0 (mt single_eq_zero.1 hx)", "start": [446, 1], "end": [449, 71], "kind": "commanddeclaration"}, {"full_name": "Finsupp.unique_single", "code": "theorem unique_single [Unique \u03b1] (x : \u03b1 \u2192\u2080 M) : x = single default (x default)", "start": [452, 1], "end": [453, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.unique_single_eq_iff", "code": "@[simp]\ntheorem unique_single_eq_iff [Unique \u03b1] {b' : M} : single a b = single a' b' \u2194 b = b'", "start": [456, 1], "end": [458, 97], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_eq_singleton", "code": "theorem support_eq_singleton {f : \u03b1 \u2192\u2080 M} {a : \u03b1} :\n    f.support = {a} \u2194 f a \u2260 0 \u2227 f = single a (f a)", "start": [461, 1], "end": [466, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_eq_singleton'", "code": "theorem support_eq_singleton' {f : \u03b1 \u2192\u2080 M} {a : \u03b1} :\n    f.support = {a} \u2194 \u2203 (b : _) (_ : b \u2260 0), f = single a b", "start": [471, 1], "end": [476, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_support_eq_one", "code": "theorem card_support_eq_one {f : \u03b1 \u2192\u2080 M} : card f.support = 1 \u2194 \u2203 a, f a \u2260 0 \u2227 f = single a (f a)", "start": [479, 1], "end": [480, 51], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_support_eq_one'", "code": "theorem card_support_eq_one' {f : \u03b1 \u2192\u2080 M} :\n    card f.support = 1 \u2194 \u2203 (a : _) (b : _) (_ : b \u2260 0), f = single a b", "start": [485, 1], "end": [487, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_subset_singleton", "code": "theorem support_subset_singleton {f : \u03b1 \u2192\u2080 M} {a : \u03b1} : f.support \u2286 {a} \u2194 f = single a (f a)", "start": [490, 1], "end": [491, 76], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_subset_singleton'", "code": "theorem support_subset_singleton' {f : \u03b1 \u2192\u2080 M} {a : \u03b1} : f.support \u2286 {a} \u2194 \u2203 b, f = single a b", "start": [494, 1], "end": [496, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_support_le_one", "code": "theorem card_support_le_one [Nonempty \u03b1] {f : \u03b1 \u2192\u2080 M} :\n    card f.support \u2264 1 \u2194 \u2203 a, f = single a (f a)", "start": [499, 1], "end": [501, 73], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_support_le_one'", "code": "theorem card_support_le_one' [Nonempty \u03b1] {f : \u03b1 \u2192\u2080 M} :\n    card f.support \u2264 1 \u2194 \u2203 a b, f = single a b", "start": [504, 1], "end": [506, 74], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivFunOnFinite_single", "code": "@[simp]\ntheorem equivFunOnFinite_single [DecidableEq \u03b1] [Finite \u03b1] (x : \u03b1) (m : M) :\n    Finsupp.equivFunOnFinite (Finsupp.single x m) = Pi.single x m", "start": [509, 1], "end": [513, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivFunOnFinite_symm_single", "code": "@[simp]\ntheorem equivFunOnFinite_symm_single [DecidableEq \u03b1] [Finite \u03b1] (x : \u03b1) (m : M) :\n    Finsupp.equivFunOnFinite.symm (Pi.single x m) = Finsupp.single x m", "start": [516, 1], "end": [519, 57], "kind": "commanddeclaration"}, {"full_name": "Finsupp.update", "code": "def update (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : M) : \u03b1 \u2192\u2080 M where\n  support := by\n    haveI := Classical.decEq \u03b1; haveI := Classical.decEq M\n    exact if b = 0 then f.support.erase a else insert a f.support\n  toFun :=\n    haveI := Classical.decEq \u03b1\n    Function.update f a b\n  mem_support_toFun i := by\n    classical\n    rw [Function.update]\n    simp only [eq_rec_constant, dite_eq_ite, ne_eq]\n    split_ifs with hb ha ha <;>\n      try simp only [*, not_false_iff, iff_true, not_true, iff_false]\n    \u00b7 rw [Finset.mem_erase]\n      simp\n    \u00b7 rw [Finset.mem_erase]\n      simp [ha]\n    \u00b7 rw [Finset.mem_insert]\n      simp [ha]\n    \u00b7 rw [Finset.mem_insert]\n      simp [ha]", "start": [531, 1], "end": [556, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_update", "code": "@[simp]\ntheorem coe_update [DecidableEq \u03b1] : (f.update a b : \u03b1 \u2192 M) = Function.update f a b", "start": [559, 1], "end": [564, 21], "kind": "commanddeclaration"}, {"full_name": "Finsupp.update_self", "code": "@[simp]\ntheorem update_self : f.update a (f a) = f", "start": [567, 1], "end": [571, 9], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zero_update", "code": "@[simp]\ntheorem zero_update : update 0 a b = single a b", "start": [574, 1], "end": [579, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_update", "code": "theorem support_update [DecidableEq \u03b1] [DecidableEq M] :\n    support (f.update a b) = if b = 0 then f.support.erase a else insert a f.support", "start": [582, 1], "end": [585, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_update_zero", "code": "@[simp]\ntheorem support_update_zero [DecidableEq \u03b1] : support (f.update a 0) = f.support.erase a", "start": [588, 1], "end": [592, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_update_ne_zero", "code": "theorem support_update_ne_zero [DecidableEq \u03b1] (h : b \u2260 0) :\n    support (f.update a b) = insert a f.support", "start": [597, 1], "end": [601, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase", "code": "def erase (a : \u03b1) (f : \u03b1 \u2192\u2080 M) : \u03b1 \u2192\u2080 M where\n  support :=\n    haveI := Classical.decEq \u03b1\n    f.support.erase a\n  toFun a' :=\n    haveI := Classical.decEq \u03b1\n    if a' = a then 0 else f a'\n  mem_support_toFun a' := by\n    classical\n    rw [mem_erase, mem_support_iff]; dsimp\n    split_ifs with h\n    exact \u27e8fun H _ => H.1 h, fun H => (H rfl).elim\u27e9\n    exact and_iff_right h", "start": [613, 1], "end": [629, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_erase", "code": "@[simp]\ntheorem support_erase [DecidableEq \u03b1] {a : \u03b1} {f : \u03b1 \u2192\u2080 M} :\n    (f.erase a).support = f.support.erase a", "start": [632, 1], "end": [637, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_same", "code": "@[simp]\ntheorem erase_same {a : \u03b1} {f : \u03b1 \u2192\u2080 M} : (f.erase a) a = 0", "start": [640, 1], "end": [642, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_ne", "code": "@[simp]\ntheorem erase_ne {a a' : \u03b1} {f : \u03b1 \u2192\u2080 M} (h : a' \u2260 a) : (f.erase a) a' = f a'", "start": [645, 1], "end": [647, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_single", "code": "@[simp]\ntheorem erase_single {a : \u03b1} {b : M} : erase a (single a b) = 0", "start": [650, 1], "end": [656, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_single_ne", "code": "theorem erase_single_ne {a a' : \u03b1} {b : M} (h : a \u2260 a') : erase a (single a' b) = single a' b", "start": [659, 1], "end": [662, 21], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_of_not_mem_support", "code": "@[simp]\ntheorem erase_of_not_mem_support {f : \u03b1 \u2192\u2080 M} {a} (haf : a \u2209 f.support) : erase a f = f", "start": [665, 1], "end": [669, 22], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_zero", "code": "@[simp, nolint simpNF] theorem erase_zero (a : \u03b1) : erase a (0 : \u03b1 \u2192\u2080 M) = 0", "start": [672, 1], "end": [674, 78], "kind": "commanddeclaration"}, {"full_name": "Finsupp.onFinset", "code": "def onFinset (s : Finset \u03b1) (f : \u03b1 \u2192 M) (hf : \u2200 a, f a \u2260 0 \u2192 a \u2208 s) : \u03b1 \u2192\u2080 M where\n  support :=\n    haveI := Classical.decEq M\n    s.filter (f \u00b7 \u2260 0)\n  toFun := f\n  mem_support_toFun := by classical simpa", "start": [686, 1], "end": [694, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.onFinset_apply", "code": "@[simp]\ntheorem onFinset_apply {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf a} : (onFinset s f hf : \u03b1 \u2192\u2080 M) a = f a", "start": [697, 1], "end": [699, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_onFinset_subset", "code": "@[simp]\ntheorem support_onFinset_subset {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf} :\n    (onFinset s f hf).support \u2286 s", "start": [702, 1], "end": [705, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_support_onFinset", "code": "theorem mem_support_onFinset {s : Finset \u03b1} {f : \u03b1 \u2192 M} (hf : \u2200 a : \u03b1, f a \u2260 0 \u2192 a \u2208 s) {a : \u03b1} :\n    a \u2208 (Finsupp.onFinset s f hf).support \u2194 f a \u2260 0", "start": [709, 1], "end": [711, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_onFinset", "code": "theorem support_onFinset [DecidableEq M] {s : Finset \u03b1} {f : \u03b1 \u2192 M}\n    (hf : \u2200 a : \u03b1, f a \u2260 0 \u2192 a \u2208 s) :\n    (Finsupp.onFinset s f hf).support = s.filter fun a => f a \u2260 0", "start": [714, 1], "end": [717, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ofSupportFinite", "code": "noncomputable def ofSupportFinite (f : \u03b1 \u2192 M) (hf : (Function.support f).Finite) : \u03b1 \u2192\u2080 M where\n  support := hf.toFinset\n  toFun := f\n  mem_support_toFun _ := hf.mem_toFinset", "start": [726, 1], "end": [730, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ofSupportFinite_coe", "code": "theorem ofSupportFinite_coe {f : \u03b1 \u2192 M} {hf : (Function.support f).Finite} :\n    (ofSupportFinite f hf : \u03b1 \u2192 M) = f", "start": [733, 1], "end": [735, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.canLift", "code": "instance canLift : CanLift (\u03b1 \u2192 M) (\u03b1 \u2192\u2080 M) (\u21d1) fun f => (Function.support f).Finite where\n  prf f hf := \u27e8ofSupportFinite f hf, rfl\u27e9", "start": [738, 1], "end": [739, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange", "code": "def mapRange (f : M \u2192 N) (hf : f 0 = 0) (g : \u03b1 \u2192\u2080 M) : \u03b1 \u2192\u2080 N :=\n  onFinset g.support (f \u2218 g) fun a => by\n    rw [mem_support_iff, not_imp_not]; exact fun H => (congr_arg f H).trans hf", "start": [751, 1], "end": [766, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_apply", "code": "@[simp]\ntheorem mapRange_apply {f : M \u2192 N} {hf : f 0 = 0} {g : \u03b1 \u2192\u2080 M} {a : \u03b1} :\n    mapRange f hf g a = f (g a)", "start": [769, 1], "end": [772, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_zero", "code": "@[simp]\ntheorem mapRange_zero {f : M \u2192 N} {hf : f 0 = 0} : mapRange f hf (0 : \u03b1 \u2192\u2080 M) = 0", "start": [775, 1], "end": [777, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_id", "code": "@[simp]\ntheorem mapRange_id (g : \u03b1 \u2192\u2080 M) : mapRange id rfl g = g", "start": [780, 1], "end": [782, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_comp", "code": "theorem mapRange_comp (f : N \u2192 P) (hf : f 0 = 0) (f\u2082 : M \u2192 N) (hf\u2082 : f\u2082 0 = 0) (h : (f \u2218 f\u2082) 0 = 0)\n    (g : \u03b1 \u2192\u2080 M) : mapRange (f \u2218 f\u2082) h g = mapRange f hf (mapRange f\u2082 hf\u2082 g)", "start": [785, 1], "end": [787, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_mapRange", "code": "theorem support_mapRange {f : M \u2192 N} {hf : f 0 = 0} {g : \u03b1 \u2192\u2080 M} :\n    (mapRange f hf g).support \u2286 g.support", "start": [790, 1], "end": [792, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_single", "code": "@[simp]\ntheorem mapRange_single {f : M \u2192 N} {hf : f 0 = 0} {a : \u03b1} {b : M} :\n    mapRange f hf (single a b) = single a (f b)", "start": [795, 1], "end": [799, 92], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_mapRange_of_injective", "code": "theorem support_mapRange_of_injective {e : M \u2192 N} (he0 : e 0 = 0) (f : \u03b9 \u2192\u2080 M)\n    (he : Function.Injective e) : (Finsupp.mapRange e he0 f).support = f.support", "start": [802, 1], "end": [806, 23], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain", "code": "def embDomain (f : \u03b1 \u21aa \u03b2) (v : \u03b1 \u2192\u2080 M) : \u03b2 \u2192\u2080 M where\n  support := v.support.map f\n  toFun a\u2082 :=\n    haveI := Classical.decEq \u03b2\n    if h : a\u2082 \u2208 v.support.map f then\n      v\n        (v.support.choose (fun a\u2081 => f a\u2081 = a\u2082)\n          (by\n            rcases Finset.mem_map.1 h with \u27e8a, ha, rfl\u27e9\n            exact ExistsUnique.intro a \u27e8ha, rfl\u27e9 fun b \u27e8_, hb\u27e9 => f.injective hb))\n    else 0\n  mem_support_toFun a\u2082 := by\n    dsimp\n    split_ifs with h\n    \u00b7 simp only [h, true_iff_iff, Ne.def]\n      rw [\u2190 not_mem_support_iff, not_not]\n      classical apply Finset.choose_mem\n    \u00b7 simp only [h, Ne.def, ne_self_iff_false]", "start": [818, 1], "end": [838, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_embDomain", "code": "@[simp]\ntheorem support_embDomain (f : \u03b1 \u21aa \u03b2) (v : \u03b1 \u2192\u2080 M) : (embDomain f v).support = v.support.map f", "start": [841, 1], "end": [843, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_zero", "code": "@[simp]\ntheorem embDomain_zero (f : \u03b1 \u21aa \u03b2) : (embDomain f 0 : \u03b2 \u2192\u2080 M) = 0", "start": [846, 1], "end": [848, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_apply", "code": "@[simp]\ntheorem embDomain_apply (f : \u03b1 \u21aa \u03b2) (v : \u03b1 \u2192\u2080 M) (a : \u03b1) : embDomain f v (f a) = v a", "start": [851, 1], "end": [858, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_notin_range", "code": "theorem embDomain_notin_range (f : \u03b1 \u21aa \u03b2) (v : \u03b1 \u2192\u2080 M) (a : \u03b2) (h : a \u2209 Set.range f) :\n    embDomain f v a = 0", "start": [861, 1], "end": [866, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_injective", "code": "theorem embDomain_injective (f : \u03b1 \u21aa \u03b2) : Function.Injective (embDomain f : (\u03b1 \u2192\u2080 M) \u2192 \u03b2 \u2192\u2080 M)", "start": [869, 1], "end": [870, 94], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_inj", "code": "@[simp]\ntheorem embDomain_inj {f : \u03b1 \u21aa \u03b2} {l\u2081 l\u2082 : \u03b1 \u2192\u2080 M} : embDomain f l\u2081 = embDomain f l\u2082 \u2194 l\u2081 = l\u2082", "start": [873, 1], "end": [875, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_eq_zero", "code": "@[simp]\ntheorem embDomain_eq_zero {f : \u03b1 \u21aa \u03b2} {l : \u03b1 \u2192\u2080 M} : embDomain f l = 0 \u2194 l = 0", "start": [878, 1], "end": [880, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_mapRange", "code": "theorem embDomain_mapRange (f : \u03b1 \u21aa \u03b2) (g : M \u2192 N) (p : \u03b1 \u2192\u2080 M) (hg : g 0 = 0) :\n    embDomain f (mapRange g hg p) = mapRange g hg (embDomain f p)", "start": [883, 1], "end": [889, 91], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_of_embDomain_single", "code": "theorem single_of_embDomain_single (l : \u03b1 \u2192\u2080 M) (f : \u03b1 \u21aa \u03b2) (a : \u03b2) (b : M) (hb : b \u2260 0)\n    (h : l.embDomain f = single a b) : \u2203 x, l = single x b \u2227 f x = a", "start": [892, 1], "end": [908, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_single", "code": "@[simp]\ntheorem embDomain_single (f : \u03b1 \u21aa \u03b2) (a : \u03b1) (m : M) :\n    embDomain f (single a m) = single (f a) m", "start": [911, 1], "end": [922, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zipWith", "code": "def zipWith (f : M \u2192 N \u2192 P) (hf : f 0 0 = 0) (g\u2081 : \u03b1 \u2192\u2080 M) (g\u2082 : \u03b1 \u2192\u2080 N) : \u03b1 \u2192\u2080 P :=\n  onFinset\n    (haveI := Classical.decEq \u03b1; g\u2081.support \u222a g\u2082.support)\n    (fun a => f (g\u2081 a) (g\u2082 a))\n    fun a (H : f _ _ \u2260 0) => by\n      classical\n      rw [mem_union, mem_support_iff, mem_support_iff, \u2190 not_and_or]\n      rintro \u27e8h\u2081, h\u2082\u27e9; rw [h\u2081, h\u2082] at H; exact H hf", "start": [934, 1], "end": [944, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zipWith_apply", "code": "@[simp]\ntheorem zipWith_apply {f : M \u2192 N \u2192 P} {hf : f 0 0 = 0} {g\u2081 : \u03b1 \u2192\u2080 M} {g\u2082 : \u03b1 \u2192\u2080 N} {a : \u03b1} :\n    zipWith f hf g\u2081 g\u2082 a = f (g\u2081 a) (g\u2082 a)", "start": [947, 1], "end": [950, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_zipWith", "code": "theorem support_zipWith [D : DecidableEq \u03b1] {f : M \u2192 N \u2192 P} {hf : f 0 0 = 0} {g\u2081 : \u03b1 \u2192\u2080 M}\n    {g\u2082 : \u03b1 \u2192\u2080 N} : (zipWith f hf g\u2081 g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support", "start": [953, 1], "end": [955, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.add", "code": "instance add : Add (\u03b1 \u2192\u2080 M) :=\n  \u27e8zipWith (\u00b7 + \u00b7) (add_zero 0)\u27e9", "start": [967, 1], "end": [968, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_add", "code": "@[simp]\ntheorem coe_add (f g : \u03b1 \u2192\u2080 M) : \u21d1(f + g) = f + g", "start": [971, 1], "end": [973, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.add_apply", "code": "theorem add_apply (g\u2081 g\u2082 : \u03b1 \u2192\u2080 M) (a : \u03b1) : (g\u2081 + g\u2082) a = g\u2081 a + g\u2082 a", "start": [976, 1], "end": [977, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_add", "code": "theorem support_add [DecidableEq \u03b1] {g\u2081 g\u2082 : \u03b1 \u2192\u2080 M} :\n    (g\u2081 + g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support", "start": [980, 1], "end": [982, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_add_eq", "code": "theorem support_add_eq [DecidableEq \u03b1] {g\u2081 g\u2082 : \u03b1 \u2192\u2080 M} (h : Disjoint g\u2081.support g\u2082.support) :\n    (g\u2081 + g\u2082).support = g\u2081.support \u222a g\u2082.support", "start": [985, 1], "end": [994, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_add", "code": "@[simp]\ntheorem single_add (a : \u03b1) (b\u2081 b\u2082 : M) : single a (b\u2081 + b\u2082) = single a b\u2081 + single a b\u2082", "start": [997, 1], "end": [1002, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addZeroClass", "code": "instance addZeroClass : AddZeroClass (\u03b1 \u2192\u2080 M) :=\n  FunLike.coe_injective.addZeroClass _ coe_zero coe_add", "start": [1005, 1], "end": [1006, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.instIsLeftCancelAdd", "code": "instance instIsLeftCancelAdd [IsLeftCancelAdd M] : IsLeftCancelAdd (\u03b1 \u2192\u2080 M) where\n  add_left_cancel _ _ _ h := ext fun x => add_left_cancel <| FunLike.congr_fun h x", "start": [1009, 1], "end": [1010, 83], "kind": "commanddeclaration"}, {"full_name": "Finsupp.instIsRightCancelAdd", "code": "instance instIsRightCancelAdd [IsRightCancelAdd M] : IsRightCancelAdd (\u03b1 \u2192\u2080 M) where\n  add_right_cancel _ _ _ h := ext fun x => add_right_cancel <| FunLike.congr_fun h x", "start": [1012, 1], "end": [1013, 85], "kind": "commanddeclaration"}, {"full_name": "Finsupp.instIsCancelAdd", "code": "instance instIsCancelAdd [IsCancelAdd M] : IsCancelAdd (\u03b1 \u2192\u2080 M) where", "start": [1015, 1], "end": [1015, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.singleAddHom", "code": "@[simps]\ndef singleAddHom (a : \u03b1) : M \u2192+ \u03b1 \u2192\u2080 M where\n  toFun := single a\n  map_zero' := single_zero a\n  map_add' := single_add a", "start": [1017, 1], "end": [1024, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.applyAddHom", "code": "@[simps apply]\ndef applyAddHom (a : \u03b1) : (\u03b1 \u2192\u2080 M) \u2192+ M where\n  toFun g := g a\n  map_zero' := zero_apply\n  map_add' _ _ := add_apply _ _ _", "start": [1027, 1], "end": [1034, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coeFnAddHom", "code": "@[simps]\nnoncomputable def coeFnAddHom : (\u03b1 \u2192\u2080 M) \u2192+ \u03b1 \u2192 M where\n  toFun := (\u21d1)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [1038, 1], "end": [1043, 22], "kind": "commanddeclaration"}, {"full_name": "Finsupp.update_eq_single_add_erase", "code": "theorem update_eq_single_add_erase (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : M) :\n    f.update a b = single a b + f.erase a", "start": [1047, 1], "end": [1053, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.update_eq_erase_add_single", "code": "theorem update_eq_erase_add_single (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : M) :\n    f.update a b = f.erase a + single a b", "start": [1056, 1], "end": [1062, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_add_erase", "code": "theorem single_add_erase (a : \u03b1) (f : \u03b1 \u2192\u2080 M) : single a (f a) + f.erase a = f", "start": [1065, 1], "end": [1066, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_add_single", "code": "theorem erase_add_single (a : \u03b1) (f : \u03b1 \u2192\u2080 M) : f.erase a + single a (f a) = f", "start": [1069, 1], "end": [1070, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_add", "code": "@[simp]\ntheorem erase_add (a : \u03b1) (f f' : \u03b1 \u2192\u2080 M) : erase a (f + f') = erase a f + erase a f'", "start": [1073, 1], "end": [1077, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.eraseAddHom", "code": "@[simps]\ndef eraseAddHom (a : \u03b1) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b1 \u2192\u2080 M where\n  toFun := erase a\n  map_zero' := erase_zero a\n  map_add' := erase_add a", "start": [1080, 1], "end": [1085, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.induction", "code": "@[elab_as_elim]\nprotected theorem induction {p : (\u03b1 \u2192\u2080 M) \u2192 Prop} (f : \u03b1 \u2192\u2080 M) (h0 : p 0)\n    (ha : \u2200 (a b) (f : \u03b1 \u2192\u2080 M), a \u2209 f.support \u2192 b \u2260 0 \u2192 p f \u2192 p (single a b + f)) : p f", "start": [1088, 1], "end": [1102, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.induction\u2082", "code": "theorem induction\u2082 {p : (\u03b1 \u2192\u2080 M) \u2192 Prop} (f : \u03b1 \u2192\u2080 M) (h0 : p 0)\n    (ha : \u2200 (a b) (f : \u03b1 \u2192\u2080 M), a \u2209 f.support \u2192 b \u2260 0 \u2192 p f \u2192 p (f + single a b)) : p f", "start": [1105, 1], "end": [1118, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.induction_linear", "code": "theorem induction_linear {p : (\u03b1 \u2192\u2080 M) \u2192 Prop} (f : \u03b1 \u2192\u2080 M) (h0 : p 0)\n    (hadd : \u2200 f g : \u03b1 \u2192\u2080 M, p f \u2192 p g \u2192 p (f + g)) (hsingle : \u2200 a b, p (single a b)) : p f", "start": [1121, 1], "end": [1123, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.add_closure_setOf_eq_single", "code": "@[simp]\ntheorem add_closure_setOf_eq_single :\n    AddSubmonoid.closure { f : \u03b1 \u2192\u2080 M | \u2203 a b, f = single a b } = \u22a4", "start": [1126, 1], "end": [1131, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addHom_ext", "code": "theorem addHom_ext [AddZeroClass N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984\n    (H : \u2200 x y, f (single x y) = g (single x y)) : f = g", "start": [1134, 1], "end": [1140, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addHom_ext'", "code": "@[ext high]\ntheorem addHom_ext' [AddZeroClass N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984\n    (H : \u2200 x, f.comp (singleAddHom x) = g.comp (singleAddHom x)) : f = g", "start": [1143, 1], "end": [1152, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mulHom_ext", "code": "theorem mulHom_ext [MulOneClass N] \u2983f g : Multiplicative (\u03b1 \u2192\u2080 M) \u2192* N\u2984\n    (H : \u2200 x y, f (Multiplicative.ofAdd <| single x y) = g (Multiplicative.ofAdd <| single x y)) :\n    f = g", "start": [1155, 1], "end": [1164, 17], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mulHom_ext'", "code": "@[ext]\ntheorem mulHom_ext' [MulOneClass N] {f g : Multiplicative (\u03b1 \u2192\u2080 M) \u2192* N}\n    (H : \u2200 x, f.comp (AddMonoidHom.toMultiplicative (singleAddHom x)) =\n              g.comp (AddMonoidHom.toMultiplicative (singleAddHom x))) :\n    f = g", "start": [1167, 1], "end": [1172, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_add", "code": "theorem mapRange_add [AddZeroClass N] {f : M \u2192 N} {hf : f 0 = 0}\n    (hf' : \u2200 x y, f (x + y) = f x + f y) (v\u2081 v\u2082 : \u03b1 \u2192\u2080 M) :\n    mapRange f hf (v\u2081 + v\u2082) = mapRange f hf v\u2081 + mapRange f hf v\u2082", "start": [1175, 1], "end": [1178, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_add'", "code": "theorem mapRange_add' [AddZeroClass N] [AddMonoidHomClass \u03b2 M N] {f : \u03b2} (v\u2081 v\u2082 : \u03b1 \u2192\u2080 M) :\n    mapRange f (map_zero f) (v\u2081 + v\u2082) = mapRange f (map_zero f) v\u2081 + mapRange f (map_zero f) v\u2082", "start": [1181, 1], "end": [1183, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain.addMonoidHom", "code": "@[simps]\ndef embDomain.addMonoidHom (f : \u03b1 \u21aa \u03b2) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b2 \u2192\u2080 M where\n  toFun v := embDomain f v\n  map_zero' := by simp\n  map_add' v w := by\n    ext b\n    by_cases h : b \u2208 Set.range f\n    \u00b7 rcases h with \u27e8a, rfl\u27e9\n      simp\n    \u00b7 simp only [Set.mem_range, not_exists, coe_add, Pi.add_apply,\n        embDomain_notin_range _ _ _ h, add_zero]", "start": [1186, 1], "end": [1197, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_add", "code": "@[simp]\ntheorem embDomain_add (f : \u03b1 \u21aa \u03b2) (v w : \u03b1 \u2192\u2080 M) :\n    embDomain f (v + w) = embDomain f v + embDomain f w", "start": [1200, 1], "end": [1203, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.hasNatScalar", "code": "instance hasNatScalar : SMul \u2115 (\u03b1 \u2192\u2080 M) :=\n  \u27e8fun n v => v.mapRange ((\u00b7 \u2022 \u00b7) n) (nsmul_zero _)\u27e9", "start": [1212, 1], "end": [1215, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addMonoid", "code": "instance addMonoid : AddMonoid (\u03b1 \u2192\u2080 M) :=\n  FunLike.coe_injective.addMonoid _ coe_zero coe_add fun _ _ => rfl", "start": [1218, 1], "end": [1219, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid M] : AddCommMonoid (\u03b1 \u2192\u2080 M) :=\n  { FunLike.coe_injective.addCommMonoid (\u2191) coe_zero coe_add (fun _ _ => rfl) with\n    toAddMonoid := Finsupp.addMonoid }", "start": [1224, 1], "end": [1227, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neg", "code": "instance neg [NegZeroClass G] : Neg (\u03b1 \u2192\u2080 G) :=\n  \u27e8mapRange Neg.neg neg_zero\u27e9", "start": [1230, 1], "end": [1231, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_neg", "code": "@[simp]\ntheorem coe_neg [NegZeroClass G] (g : \u03b1 \u2192\u2080 G) : \u21d1(-g) = -g", "start": [1234, 1], "end": [1236, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.neg_apply", "code": "theorem neg_apply [NegZeroClass G] (g : \u03b1 \u2192\u2080 G) (a : \u03b1) : (-g) a = -g a", "start": [1239, 1], "end": [1240, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_neg", "code": "theorem mapRange_neg [NegZeroClass G] [NegZeroClass H] {f : G \u2192 H} {hf : f 0 = 0}\n    (hf' : \u2200 x, f (-x) = -f x) (v : \u03b1 \u2192\u2080 G) : mapRange f hf (-v) = -mapRange f hf v", "start": [1243, 1], "end": [1245, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_neg'", "code": "theorem mapRange_neg' [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass \u03b2 G H] {f : \u03b2}\n    (v : \u03b1 \u2192\u2080 G) : mapRange f (map_zero f) (-v) = -mapRange f (map_zero f) v", "start": [1248, 1], "end": [1250, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sub", "code": "instance sub [SubNegZeroMonoid G] : Sub (\u03b1 \u2192\u2080 G) :=\n  \u27e8zipWith Sub.sub (sub_zero _)\u27e9", "start": [1253, 1], "end": [1254, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_sub", "code": "@[simp]\ntheorem coe_sub [SubNegZeroMonoid G] (g\u2081 g\u2082 : \u03b1 \u2192\u2080 G) : \u21d1(g\u2081 - g\u2082) = g\u2081 - g\u2082", "start": [1257, 1], "end": [1259, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sub_apply", "code": "theorem sub_apply [SubNegZeroMonoid G] (g\u2081 g\u2082 : \u03b1 \u2192\u2080 G) (a : \u03b1) : (g\u2081 - g\u2082) a = g\u2081 a - g\u2082 a", "start": [1262, 1], "end": [1263, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_sub", "code": "theorem mapRange_sub [SubNegZeroMonoid G] [SubNegZeroMonoid H] {f : G \u2192 H} {hf : f 0 = 0}\n    (hf' : \u2200 x y, f (x - y) = f x - f y) (v\u2081 v\u2082 : \u03b1 \u2192\u2080 G) :\n    mapRange f hf (v\u2081 - v\u2082) = mapRange f hf v\u2081 - mapRange f hf v\u2082", "start": [1266, 1], "end": [1269, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_sub'", "code": "theorem mapRange_sub' [AddGroup G] [SubtractionMonoid H] [AddMonoidHomClass \u03b2 G H] {f : \u03b2}\n    (v\u2081 v\u2082 : \u03b1 \u2192\u2080 G) :\n    mapRange f (map_zero f) (v\u2081 - v\u2082) = mapRange f (map_zero f) v\u2081 - mapRange f (map_zero f) v\u2082", "start": [1272, 1], "end": [1275, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.hasIntScalar", "code": "instance hasIntScalar [AddGroup G] : SMul \u2124 (\u03b1 \u2192\u2080 G) :=\n  \u27e8fun n v => v.mapRange ((\u00b7 \u2022 \u00b7) n) (zsmul_zero _)\u27e9", "start": [1278, 1], "end": [1281, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addGroup", "code": "instance addGroup [AddGroup G] : AddGroup (\u03b1 \u2192\u2080 G) :=\n  { FunLike.coe_injective.addGroup (\u2191) coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl)\n      fun _ _ => rfl with\n    toAddMonoid := Finsupp.addMonoid }", "start": [1284, 1], "end": [1288, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.addCommGroup", "code": "instance addCommGroup [AddCommGroup G] : AddCommGroup (\u03b1 \u2192\u2080 G) :=\n  { FunLike.coe_injective.addCommGroup (\u2191) coe_zero coe_add coe_neg coe_sub (fun _ _ => rfl)\n      fun _ _ => rfl with\n    toAddGroup := Finsupp.addGroup }", "start": [1291, 1], "end": [1295, 37], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_add_single_eq_single_add_single", "code": "theorem single_add_single_eq_single_add_single [AddCommMonoid M] {k l m n : \u03b1} {u v : M}\n    (hu : u \u2260 0) (hv : v \u2260 0) :\n    single k u + single l v = single m u + single n v \u2194\n      (k = m \u2227 l = n) \u2228 (u = v \u2227 k = n \u2227 l = m) \u2228 (u + v = 0 \u2227 k = l \u2227 m = n)", "start": [1298, 1], "end": [1304, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_neg", "code": "@[simp]\ntheorem support_neg [AddGroup G] (f : \u03b1 \u2192\u2080 G) : support (-f) = support f", "start": [1307, 1], "end": [1313, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_sub", "code": "theorem support_sub [DecidableEq \u03b1] [AddGroup G] {f g : \u03b1 \u2192\u2080 G} :\n    support (f - g) \u2286 support f \u222a support g", "start": [1316, 1], "end": [1319, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_eq_sub_single", "code": "theorem erase_eq_sub_single [AddGroup G] (f : \u03b1 \u2192\u2080 G) (a : \u03b1) : f.erase a = f - single a (f a)", "start": [1322, 1], "end": [1326, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.update_eq_sub_add_single", "code": "theorem update_eq_sub_add_single [AddGroup G] (f : \u03b1 \u2192\u2080 G) (a : \u03b1) (b : G) :\n    f.update a b = f - single a (f a) + single a b", "start": [1329, 1], "end": [1331, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/NoncommProd.lean", "imports": ["Mathlib/Algebra/Hom/Commute.lean", "Mathlib/Data/Fintype/Card.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.noncommFoldr", "code": "def noncommFoldr (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise fun x y => \u2200 b, f x (f y b) = f y (f x b)) (b : \u03b2) : \u03b2 :=\n  s.attach.foldr (f \u2218 Subtype.val)\n    (fun \u27e8_, hx\u27e9 \u27e8_, hy\u27e9 =>\n      haveI : IsRefl \u03b1 fun x y => \u2200 b, f x (f y b) = f y (f x b) := \u27e8fun _ _ => rfl\u27e9\n      comm.of_refl hx hy)\n    b", "start": [40, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFoldr_coe", "code": "@[simp]\ntheorem noncommFoldr_coe (l : List \u03b1) (comm) (b : \u03b2) :\n    noncommFoldr f (l : Multiset \u03b1) comm b = l.foldr f b", "start": [51, 1], "end": [56, 41], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFoldr_empty", "code": "@[simp]\ntheorem noncommFoldr_empty (h) (b : \u03b2) : noncommFoldr f (0 : Multiset \u03b1) h b = b", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFoldr_cons", "code": "theorem noncommFoldr_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (b : \u03b2) :\n    noncommFoldr f (a ::\u2098 s) h b = f a (noncommFoldr f s h' b)", "start": [64, 1], "end": [67, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFoldr_eq_foldr", "code": "theorem noncommFoldr_eq_foldr (s : Multiset \u03b1) (h : LeftCommutative f) (b : \u03b2) :\n    noncommFoldr f s (fun x _ y _ _ => h x y) b = foldr f h b s", "start": [70, 1], "end": [73, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFold", "code": "def noncommFold (s : Multiset \u03b1) (comm : { x | x \u2208 s }.Pairwise fun x y => op x y = op y x) :\n    \u03b1 \u2192 \u03b1 :=\n  noncommFoldr op s fun x hx y hy h b => by rw [\u2190 assoc.assoc, comm hx hy h, assoc.assoc]", "start": [80, 1], "end": [84, 90], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFold_coe", "code": "@[simp]\ntheorem noncommFold_coe (l : List \u03b1) (comm) (a : \u03b1) :\n    noncommFold op (l : Multiset \u03b1) comm a = l.foldr op a", "start": [87, 1], "end": [89, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFold_empty", "code": "@[simp]\ntheorem noncommFold_empty (h) (a : \u03b1) : noncommFold op (0 : Multiset \u03b1) h a = a", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFold_cons", "code": "theorem noncommFold_cons (s : Multiset \u03b1) (a : \u03b1) (h h') (x : \u03b1) :\n    noncommFold op (a ::\u2098 s) h x = op a (noncommFold op s h' x)", "start": [97, 1], "end": [100, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommFold_eq_fold", "code": "theorem noncommFold_eq_fold (s : Multiset \u03b1) [IsCommutative \u03b1 op] (a : \u03b1) :\n    noncommFold op s (fun x _ y _ _ => IsCommutative.comm x y) a = fold op a s", "start": [103, 1], "end": [106, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd", "code": "@[to_additive\n      \"Sum of a `s : Multiset \u03b1` with `[AddMonoid \u03b1]`, given a proof that `+` commutes\n      on all elements `x \u2208 s`.\"]\ndef noncommProd (s : Multiset \u03b1) (comm : { x | x \u2208 s }.Pairwise Commute) : \u03b1 :=\n  s.noncommFold (\u00b7 * \u00b7) comm 1", "start": [113, 1], "end": [119, 31], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_coe", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_coe (l : List \u03b1) (comm) : noncommProd (l : Multiset \u03b1) comm = l.prod", "start": [123, 1], "end": [131, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_empty", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_empty (h) : noncommProd (0 : Multiset \u03b1) h = 1", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_cons", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_cons (s : Multiset \u03b1) (a : \u03b1) (comm) :\n    noncommProd (a ::\u2098 s) comm = a * noncommProd s (comm.mono fun _ => mem_cons_of_mem)", "start": [141, 1], "end": [145, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_cons'", "code": "@[to_additive]\ntheorem noncommProd_cons' (s : Multiset \u03b1) (a : \u03b1) (comm) :\n    noncommProd (a ::\u2098 s) comm = noncommProd s (comm.mono fun _ => mem_cons_of_mem) * a", "start": [149, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_add", "code": "@[to_additive]\ntheorem noncommProd_add (s t : Multiset \u03b1) (comm) :\n    noncommProd (s + t) comm =\n      noncommProd s (comm.mono <| subset_of_le <| s.le_add_right t) *\n        noncommProd t (comm.mono <| subset_of_le <| t.le_add_left s)", "start": [167, 1], "end": [174, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_map_aux", "code": "@[to_additive]\nprotected theorem noncommProd_map_aux [MonoidHomClass F \u03b1 \u03b2] (s : Multiset \u03b1)\n    (comm : { x | x \u2208 s }.Pairwise Commute) (f : F) : { x | x \u2208 s.map f }.Pairwise Commute", "start": [178, 1], "end": [183, 35], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_map", "code": "@[to_additive]\ntheorem noncommProd_map [MonoidHomClass F \u03b1 \u03b2] (s : Multiset \u03b1) (comm) (f : F) :\n    f (s.noncommProd comm) = (s.map f).noncommProd (Multiset.noncommProd_map_aux s comm f)", "start": [187, 1], "end": [191, 32], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_eq_pow_card", "code": "@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Multiset \u03b1) (comm) (m : \u03b1) (h : \u2200 x \u2208 s, x = m) :\n    s.noncommProd comm = m ^ Multiset.card s", "start": [195, 1], "end": [200, 36], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_eq_prod", "code": "@[to_additive]\ntheorem noncommProd_eq_prod {\u03b1 : Type*} [CommMonoid \u03b1] (s : Multiset \u03b1) :\n    (noncommProd s fun _ _ _ _ _ => Commute.all _ _) = prod s", "start": [204, 1], "end": [208, 7], "kind": "commanddeclaration"}, {"full_name": "Multiset.noncommProd_commute", "code": "@[to_additive noncommSum_addCommute]\ntheorem noncommProd_commute (s : Multiset \u03b1) (comm) (y : \u03b1) (h : \u2200 x \u2208 s, Commute y x) :\n    Commute y (s.noncommProd comm)", "start": [212, 1], "end": [217, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_lemma", "code": "@[to_additive]\ntheorem noncommProd_lemma (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (comm : (s : Set \u03b1).Pairwise fun a b => Commute (f a) (f b)) :\n    Set.Pairwise { x | x \u2208 Multiset.map f s.val } Commute", "start": [228, 1], "end": [235, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd", "code": "@[to_additive\n      \"Sum of a `s : Finset \u03b1` mapped with `f : \u03b1 \u2192 \u03b2` with `[AddMonoid \u03b2]`,\ngiven a proof that `+` commutes on all elements `f x` for `x \u2208 s`.\"]\ndef noncommProd (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2)\n    (comm : (s : Set \u03b1).Pairwise fun a b => Commute (f a) (f b)) : \u03b2 :=\n  (s.1.map f).noncommProd <| noncommProd_lemma s f comm", "start": [237, 1], "end": [244, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_congr", "code": "@[to_additive (attr := congr)]\ntheorem noncommProd_congr {s\u2081 s\u2082 : Finset \u03b1} {f g : \u03b1 \u2192 \u03b2} (h\u2081 : s\u2081 = s\u2082)\n    (h\u2082 : \u2200 x \u2208 s\u2082, f x = g x) (comm) :\n    noncommProd s\u2081 f comm =\n      noncommProd s\u2082 g fun x hx y hy h => by\n        dsimp only\n        rw [\u2190 h\u2082 _ hx, \u2190 h\u2082 _ hy]\n        subst h\u2081\n        exact comm hx hy h", "start": [248, 1], "end": [257, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_toFinset", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_toFinset [DecidableEq \u03b1] (l : List \u03b1) (f : \u03b1 \u2192 \u03b2) (comm) (hl : l.Nodup) :\n    noncommProd l.toFinset f comm = (l.map f).prod", "start": [261, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_empty", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_empty (f : \u03b1 \u2192 \u03b2) (h) : noncommProd (\u2205 : Finset \u03b1) f h = 1", "start": [269, 1], "end": [271, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_insert_of_not_mem", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_insert_of_not_mem [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (f : \u03b1 \u2192 \u03b2) (comm)\n    (ha : a \u2209 s) :\n    noncommProd (insert a s) f comm =\n      f a * noncommProd s f (comm.mono fun _ => mem_insert_of_mem)", "start": [275, 1], "end": [287, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_insert_of_not_mem'", "code": "@[to_additive]\ntheorem noncommProd_insert_of_not_mem' [DecidableEq \u03b1] (s : Finset \u03b1) (a : \u03b1) (f : \u03b1 \u2192 \u03b2) (comm)\n    (ha : a \u2209 s) :\n    noncommProd (insert a s) f comm =\n      noncommProd s f (comm.mono fun _ => mem_insert_of_mem) * f a", "start": [291, 1], "end": [303, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_singleton", "code": "@[to_additive (attr := simp)]\ntheorem noncommProd_singleton (a : \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    noncommProd ({a} : Finset \u03b1) f\n        (by\n          norm_cast\n          exact Set.pairwise_singleton _ _) =\n      f a", "start": [307, 1], "end": [313, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_map", "code": "@[to_additive]\ntheorem noncommProd_map [MonoidHomClass F \u03b2 \u03b3] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (comm) (g : F) :\n    g (s.noncommProd f comm) =\n      s.noncommProd (fun i => g (f i)) fun x hx y hy _ => (comm.of_refl hx hy).map g", "start": [317, 1], "end": [321, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_eq_pow_card", "code": "@[to_additive noncommSum_eq_card_nsmul]\ntheorem noncommProd_eq_pow_card (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (comm) (m : \u03b2) (h : \u2200 x \u2208 s, f x = m) :\n    s.noncommProd f comm = m ^ s.card", "start": [325, 1], "end": [330, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_commute", "code": "@[to_additive noncommSum_addCommute]\ntheorem noncommProd_commute (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (comm) (y : \u03b2)\n    (h : \u2200 x \u2208 s, Commute y (f x)) : Commute y (s.noncommProd f comm)", "start": [334, 1], "end": [341, 15], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_eq_prod", "code": "@[to_additive]\ntheorem noncommProd_eq_prod {\u03b2 : Type*} [CommMonoid \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    (noncommProd s f fun _ _ _ _ _ => Commute.all _ _) = s.prod f", "start": [345, 1], "end": [351, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_union_of_disjoint", "code": "@[to_additive \"The non-commutative version of `Finset.sum_union`\"]\ntheorem noncommProd_union_of_disjoint [DecidableEq \u03b1] {s t : Finset \u03b1} (h : Disjoint s t)\n    (f : \u03b1 \u2192 \u03b2) (comm : { x | x \u2208 s \u222a t }.Pairwise fun a b => Commute (f a) (f b)) :\n    noncommProd (s \u222a t) f comm =\n      noncommProd s f (comm.mono <| coe_subset.2 <| subset_union_left _ _) *\n        noncommProd t f (comm.mono <| coe_subset.2 <| subset_union_right _ _)", "start": [355, 1], "end": [370, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_mul_distrib_aux", "code": "@[to_additive]\ntheorem noncommProd_mul_distrib_aux {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2}\n    (comm_ff : (s : Set \u03b1).Pairwise fun x y => Commute (f x) (f y))\n    (comm_gg : (s : Set \u03b1).Pairwise fun x y => Commute (g x) (g y))\n    (comm_gf : (s : Set \u03b1).Pairwise fun x y => Commute (g x) (f y)) :\n    (s : Set \u03b1).Pairwise fun x y => Commute ((f * g) x) ((f * g) y)", "start": [374, 1], "end": [385, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_mul_distrib", "code": "@[to_additive \"The non-commutative version of `Finset.sum_add_distrib`\"]\ntheorem noncommProd_mul_distrib {s : Finset \u03b1} (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2) (comm_ff comm_gg comm_gf) :\n    noncommProd s (f * g) (noncommProd_mul_distrib_aux comm_ff comm_gg comm_gf) =\n      noncommProd s f comm_ff * noncommProd s g comm_gg", "start": [389, 1], "end": [407, 100], "kind": "commanddeclaration"}, {"full_name": "Finset.noncommProd_mul_single", "code": "@[to_additive]\ntheorem noncommProd_mul_single [Fintype \u03b9] [DecidableEq \u03b9] (x : \u2200 i, M i) :\n    (univ.noncommProd (fun i => Pi.mulSingle i (x i)) fun i _ j _ _ =>\n        Pi.mulSingle_apply_commute x i j) = x", "start": [415, 1], "end": [436, 20], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.pi_ext", "code": "@[to_additive]\ntheorem _root_.MonoidHom.pi_ext [Finite \u03b9] [DecidableEq \u03b9] {f g : (\u2200 i, M i) \u2192* \u03b3}\n    (h : \u2200 i x, f (Pi.mulSingle i x) = g (Pi.mulSingle i x)) : f = g", "start": [440, 1], "end": [446, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/FreeMonoid/Basic.lean", "imports": ["Mathlib/Data/List/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "FreeMonoid", "code": "@[to_additive \"Free nonabelian additive monoid over a given alphabet\"]\ndef FreeMonoid (\u03b1) := List \u03b1", "start": [25, 1], "end": [27, 29], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList", "code": "@[to_additive \"The identity equivalence between `FreeAddMonoid \u03b1` and `List \u03b1`.\"]\ndef toList : FreeMonoid \u03b1 \u2243 List \u03b1 := Equiv.refl _", "start": [37, 1], "end": [39, 51], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList", "code": "@[to_additive \"The identity equivalence between `List \u03b1` and `FreeAddMonoid \u03b1`.\"]\ndef ofList : List \u03b1 \u2243 FreeMonoid \u03b1 := Equiv.refl _", "start": [43, 1], "end": [45, 51], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_symm", "code": "@[to_additive (attr := simp)]\ntheorem toList_symm : (@toList \u03b1).symm = ofList", "start": [49, 1], "end": [50, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_symm", "code": "@[to_additive (attr := simp)]\ntheorem ofList_symm : (@ofList \u03b1).symm = toList", "start": [54, 1], "end": [55, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_ofList", "code": "@[to_additive (attr := simp)]\ntheorem toList_ofList (l : List \u03b1) : toList (ofList l) = l", "start": [59, 1], "end": [60, 66], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_toList", "code": "@[to_additive (attr := simp)]\ntheorem ofList_toList (xs : FreeMonoid \u03b1) : ofList (toList xs) = xs", "start": [64, 1], "end": [65, 75], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_comp_ofList", "code": "@[to_additive (attr := simp)]\ntheorem toList_comp_ofList : @toList \u03b1 \u2218 ofList = id", "start": [69, 1], "end": [70, 60], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_comp_toList", "code": "@[to_additive (attr := simp)]\ntheorem ofList_comp_toList : @ofList \u03b1 \u2218 toList = id", "start": [74, 1], "end": [75, 60], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_one", "code": "@[to_additive (attr := simp)]\ntheorem toList_one : toList (1 : FreeMonoid \u03b1) = []", "start": [93, 1], "end": [94, 59], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_nil", "code": "@[to_additive (attr := simp)]\ntheorem ofList_nil : ofList ([] : List \u03b1) = 1", "start": [98, 1], "end": [99, 53], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_mul", "code": "@[to_additive (attr := simp)]\ntheorem toList_mul (xs ys : FreeMonoid \u03b1) : toList (xs * ys) = toList xs ++ toList ys", "start": [103, 1], "end": [104, 93], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_append", "code": "@[to_additive (attr := simp)]\ntheorem ofList_append (xs ys : List \u03b1) : ofList (xs ++ ys) = ofList xs * ofList ys", "start": [108, 1], "end": [109, 90], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_prod", "code": "@[to_additive (attr := simp)]\ntheorem toList_prod (xs : List (FreeMonoid \u03b1)) : toList xs.prod = (xs.map toList).join", "start": [113, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_join", "code": "@[to_additive (attr := simp)]\ntheorem ofList_join (xs : List (List \u03b1)) : ofList xs.join = (xs.map ofList).prod", "start": [119, 1], "end": [121, 30], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.of", "code": "@[to_additive \"Embeds an element of `\u03b1` into `FreeAddMonoid \u03b1` as a singleton list.\"]\ndef of (x : \u03b1) : FreeMonoid \u03b1 := ofList [x]", "start": [125, 1], "end": [127, 44], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_of", "code": "@[to_additive (attr := simp)]\ntheorem toList_of (x : \u03b1) : toList (of x) = [x]", "start": [131, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_singleton", "code": "@[to_additive]\ntheorem ofList_singleton (x : \u03b1) : ofList [x] = of x", "start": [136, 1], "end": [137, 60], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_cons", "code": "@[to_additive (attr := simp)]\ntheorem ofList_cons (x : \u03b1) (xs : List \u03b1) : ofList (x :: xs) = of x * ofList xs", "start": [141, 1], "end": [142, 87], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_of_mul", "code": "@[to_additive]\ntheorem toList_of_mul (x : \u03b1) (xs : FreeMonoid \u03b1) : toList (of x * xs) = x :: toList xs", "start": [146, 1], "end": [147, 95], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.of_injective", "code": "@[to_additive]\ntheorem of_injective : Function.Injective (@of \u03b1)", "start": [151, 1], "end": [152, 78], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.recOn", "code": "@[to_additive (attr := elab_as_elim) \"Recursor for `FreeAddMonoid` using `0` and\n`FreeAddMonoid.of x + xs` instead of `[]` and `x :: xs`.\"]\ndef recOn {C : FreeMonoid \u03b1 \u2192 Sort*} (xs : FreeMonoid \u03b1) (h0 : C 1)\n    (ih : \u2200 x xs, C xs \u2192 C (of x * xs)) : C xs := List.rec h0 ih xs", "start": [156, 1], "end": [161, 68], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.recOn_one", "code": "@[to_additive (attr := simp)]\ntheorem recOn_one {C : FreeMonoid \u03b1 \u2192 Sort*} (h0 : C 1) (ih : \u2200 x xs, C xs \u2192 C (of x * xs)) :\n    @recOn \u03b1 C 1 h0 ih = h0", "start": [165, 1], "end": [167, 35], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.recOn_of_mul", "code": "@[to_additive (attr := simp)]\ntheorem recOn_of_mul {C : FreeMonoid \u03b1 \u2192 Sort*} (x : \u03b1) (xs : FreeMonoid \u03b1) (h0 : C 1)\n    (ih : \u2200 x xs, C xs \u2192 C (of x * xs)) : @recOn \u03b1 C (of x * xs) h0 ih = ih x xs (recOn xs h0 ih)", "start": [171, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.casesOn", "code": "@[to_additive (attr := elab_as_elim) \"A version of `List.casesOn` for `FreeAddMonoid` using `0` and\n`FreeAddMonoid.of x + xs` instead of `[]` and `x :: xs`.\"]\ndef casesOn {C : FreeMonoid \u03b1 \u2192 Sort*} (xs : FreeMonoid \u03b1) (h0 : C 1)\n    (ih : \u2200 x xs, C (of x * xs)) : C xs := List.casesOn xs h0 ih", "start": [178, 1], "end": [183, 65], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.casesOn_one", "code": "@[to_additive (attr := simp)]\ntheorem casesOn_one {C : FreeMonoid \u03b1 \u2192 Sort*} (h0 : C 1) (ih : \u2200 x xs, C (of x * xs)) :\n    @casesOn \u03b1 C 1 h0 ih = h0", "start": [187, 1], "end": [189, 37], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.casesOn_of_mul", "code": "@[to_additive (attr := simp)]\ntheorem casesOn_of_mul {C : FreeMonoid \u03b1 \u2192 Sort*} (x : \u03b1) (xs : FreeMonoid \u03b1) (h0 : C 1)\n    (ih : \u2200 x xs, C (of x * xs)) : @casesOn \u03b1 C (of x * xs) h0 ih = ih x xs", "start": [193, 1], "end": [195, 83], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.hom_eq", "code": "@[to_additive (attr := ext)]\ntheorem hom_eq \u2983f g : FreeMonoid \u03b1 \u2192* M\u2984 (h : \u2200 x, f (of x) = g (of x)) : f = g", "start": [199, 1], "end": [202, 62], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.prodAux", "code": "@[to_additive \"A variant of `List.sum` that has `[x].sum = x` true definitionally.\nThe purpose is to make `FreeAddMonoid.lift_eval_of` true by `rfl`.\"]\ndef prodAux {M} [Monoid M] : List M \u2192 M\n  | [] => 1\n  | (x :: xs) => List.foldl (\u00b7 * \u00b7) x xs", "start": [206, 1], "end": [212, 41], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.prodAux_eq", "code": "@[to_additive]\nlemma prodAux_eq : \u2200 l : List M, FreeMonoid.prodAux l = l.prod\n  | [] => rfl\n  | (_ :: xs) => congr_arg (fun x => List.foldl (\u00b7 * \u00b7) x xs) (one_mul _).symm", "start": [216, 1], "end": [219, 79], "kind": "mathlibtacticlemma"}, {"full_name": "FreeMonoid.lift", "code": "@[to_additive \"Equivalence between maps `\u03b1 \u2192 A` and additive monoid homomorphisms\n`FreeAddMonoid \u03b1 \u2192+ A`.\"]\ndef lift : (\u03b1 \u2192 M) \u2243 (FreeMonoid \u03b1 \u2192* M) where\n  toFun f :=\n  { toFun := fun l \u21a6 prodAux ((toList l).map f)\n    map_one' := rfl\n    map_mul' := fun _ _ \u21a6 by simp only [prodAux_eq, toList_mul, List.map_append, List.prod_append] }\n  invFun f x := f (of x)\n  left_inv f := rfl\n  right_inv f := hom_eq fun x \u21a6 rfl", "start": [223, 1], "end": [233, 36], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_ofList", "code": "@[to_additive (attr := simp)]\ntheorem lift_ofList (f : \u03b1 \u2192 M) (l : List \u03b1) : lift f (ofList l) = (l.map f).prod", "start": [238, 1], "end": [240, 15], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem lift_symm_apply (f : FreeMonoid \u03b1 \u2192* M) : lift.symm f = f \u2218 of", "start": [242, 1], "end": [243, 78], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_apply", "code": "@[to_additive]\ntheorem lift_apply (f : \u03b1 \u2192 M) (l : FreeMonoid \u03b1) : lift f l = ((toList l).map f).prod", "start": [247, 1], "end": [249, 15], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_comp_of", "code": "@[to_additive]\ntheorem lift_comp_of (f : \u03b1 \u2192 M) : lift f \u2218 of = f", "start": [253, 1], "end": [254, 58], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_eval_of", "code": "@[to_additive (attr := simp)]\ntheorem lift_eval_of (f : \u03b1 \u2192 M) (x : \u03b1) : lift f (of x) = f x", "start": [258, 1], "end": [259, 70], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_restrict", "code": "@[to_additive (attr := simp)]\ntheorem lift_restrict (f : FreeMonoid \u03b1 \u2192* M) : lift (f \u2218 of) = f", "start": [263, 1], "end": [264, 93], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.comp_lift", "code": "@[to_additive]\ntheorem comp_lift (g : M \u2192* N) (f : \u03b1 \u2192 M) : g.comp (lift f) = lift (g \u2218 f)", "start": [268, 1], "end": [271, 7], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.hom_map_lift", "code": "@[to_additive]\ntheorem hom_map_lift (g : M \u2192* N) (f : \u03b1 \u2192 M) (x : FreeMonoid \u03b1) : g (lift f x) = lift (g \u2218 f) x", "start": [275, 1], "end": [277, 38], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.mkMulAction", "code": "@[to_additive \"Define an additive action of `FreeAddMonoid \u03b1` on `\u03b2`.\"]\ndef mkMulAction (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) : MulAction (FreeMonoid \u03b1) \u03b2 where\n  smul l b := l.toList.foldr f b\n  one_smul _ := rfl\n  mul_smul _ _ _ := List.foldr_append _ _ _ _", "start": [281, 1], "end": [286, 46], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.smul_def", "code": "@[to_additive]\ntheorem smul_def (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (l : FreeMonoid \u03b1) (b : \u03b2) :\n    haveI := mkMulAction f\n    l \u2022 b = l.toList.foldr f b", "start": [290, 1], "end": [293, 38], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_smul", "code": "@[to_additive]\ntheorem ofList_smul (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (l : List \u03b1) (b : \u03b2) :\n    haveI := mkMulAction f\n    ofList l \u2022 b = l.foldr f b", "start": [297, 1], "end": [300, 38], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.of_smul", "code": "@[to_additive (attr := simp)]\ntheorem of_smul (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (x : \u03b1) (y : \u03b2) :\n    (haveI := mkMulAction f\n    of x \u2022 y) = f x y", "start": [304, 1], "end": [307, 29], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.map", "code": "@[to_additive \"The unique additive monoid homomorphism `FreeAddMonoid \u03b1 \u2192+ FreeAddMonoid \u03b2`\nthat sends each `of x` to `of (f x)`.\"]\ndef map (f : \u03b1 \u2192 \u03b2) : FreeMonoid \u03b1 \u2192* FreeMonoid \u03b2\n    where\n  toFun l := ofList <| l.toList.map f\n  map_one' := rfl\n  map_mul' _ _ := List.map_append _ _ _", "start": [311, 1], "end": [319, 40], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.map_of", "code": "@[to_additive (attr := simp)]\ntheorem map_of (f : \u03b1 \u2192 \u03b2) (x : \u03b1) : map f (of x) = of (f x)", "start": [323, 1], "end": [324, 68], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.toList_map", "code": "@[to_additive]\ntheorem toList_map (f : \u03b1 \u2192 \u03b2) (xs : FreeMonoid \u03b1) : toList (map f xs) = xs.toList.map f", "start": [328, 1], "end": [329, 96], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.ofList_map", "code": "@[to_additive]\ntheorem ofList_map (f : \u03b1 \u2192 \u03b2) (xs : List \u03b1) : ofList (xs.map f) = map f (ofList xs)", "start": [333, 1], "end": [334, 92], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.lift_of_comp_eq_map", "code": "@[to_additive]\ntheorem lift_of_comp_eq_map (f : \u03b1 \u2192 \u03b2) : (lift fun x \u21a6 of (f x)) = map f", "start": [338, 1], "end": [339, 96], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.map_comp", "code": "@[to_additive]\ntheorem map_comp (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) : map (g \u2218 f) = (map g).comp (map f)", "start": [343, 1], "end": [344, 100], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id : map (@id \u03b1) = MonoidHom.id (FreeMonoid \u03b1)", "start": [348, 1], "end": [349, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/AbsoluteValue.lean", "imports": ["Mathlib/Algebra/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean"], "premises": [{"full_name": "AbsoluteValue", "code": "structure AbsoluteValue (R S : Type*) [Semiring R] [OrderedSemiring S] extends R \u2192\u2099* S where\n  \n  nonneg' : \u2200 x, 0 \u2264 toFun x\n  \n  eq_zero' : \u2200 x, toFun x = 0 \u2194 x = 0\n  \n  add_le' : \u2200 x y, toFun (x + y) \u2264 toFun x + toFun y", "start": [31, 1], "end": [39, 53], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.zeroHomClass", "code": "instance zeroHomClass : ZeroHomClass (AbsoluteValue R S) R S where\n  coe f := f.toFun\n  coe_injective' f g h := by obtain \u27e8\u27e8_, _\u27e9, _\u27e9 := f; obtain \u27e8\u27e8_, _\u27e9, _\u27e9 := g; congr\n  map_zero f := (f.eq_zero' _).2 rfl", "start": [52, 1], "end": [55, 37], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.mulHomClass", "code": "instance mulHomClass : MulHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass with map_mul := fun f => f.map_mul' }", "start": [58, 1], "end": [59, 69], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.nonnegHomClass", "code": "instance nonnegHomClass : NonnegHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass with map_nonneg := fun f => f.nonneg' }", "start": [62, 1], "end": [63, 71], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.subadditiveHomClass", "code": "instance subadditiveHomClass : SubadditiveHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.zeroHomClass with map_add_le_add := fun f => f.add_le' }", "start": [66, 1], "end": [67, 75], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : R \u2192\u2099* S) {h\u2081 h\u2082 h\u2083} : (AbsoluteValue.mk f h\u2081 h\u2082 h\u2083 : R \u2192 S) = f", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.ext", "code": "@[ext]\ntheorem ext \u2983f g : AbsoluteValue R S\u2984 : (\u2200 x, f x = g x) \u2192 f = g", "start": [75, 1], "end": [77, 18], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.Simps.apply", "code": "def Simps.apply (f : AbsoluteValue R S) : R \u2192 S :=\n  f", "start": [80, 1], "end": [82, 4], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.coe_toMulHom", "code": "@[simp]\ntheorem coe_toMulHom : \u21d1abv.toMulHom = abv", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.nonneg", "code": "protected theorem nonneg (x : R) : 0 \u2264 abv x", "start": [97, 1], "end": [98, 16], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.eq_zero", "code": "@[simp]\nprotected theorem eq_zero {x : R} : abv x = 0 \u2194 x = 0", "start": [101, 1], "end": [103, 17], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.add_le", "code": "protected theorem add_le (x y : R) : abv (x + y) \u2264 abv x + abv y", "start": [106, 1], "end": [107, 18], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_mul", "code": "protected theorem map_mul (x y : R) : abv (x * y) = abv x * abv y", "start": [111, 1], "end": [112, 19], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.ne_zero_iff", "code": "protected theorem ne_zero_iff {x : R} : abv x \u2260 0 \u2194 x \u2260 0", "start": [115, 1], "end": [116, 18], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.pos", "code": "protected theorem pos {x : R} (hx : x \u2260 0) : 0 < abv x", "start": [119, 1], "end": [120, 66], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.pos_iff", "code": "@[simp]\nprotected theorem pos_iff {x : R} : 0 < abv x \u2194 x \u2260 0", "start": [123, 1], "end": [125, 49], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.ne_zero", "code": "protected theorem ne_zero {x : R} (hx : x \u2260 0) : abv x \u2260 0", "start": [128, 1], "end": [129, 19], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_one_of_isLeftRegular", "code": "theorem map_one_of_isLeftRegular (h : IsLeftRegular (abv 1)) : abv 1 = 1", "start": [132, 1], "end": [133, 31], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_zero", "code": "protected theorem map_zero : abv 0 = 0", "start": [137, 1], "end": [138, 20], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.sub_le", "code": "protected theorem sub_le (a b c : R) : abv (a - c) \u2264 abv (a - b) + abv (b - c)", "start": [147, 1], "end": [148, 69], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_sub_eq_zero_iff", "code": "@[simp high] theorem map_sub_eq_zero_iff (a b : R) : abv (a - b) = 0 \u2194 a = b", "start": [151, 1], "end": [153, 32], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_one", "code": "protected theorem map_one : abv 1 = 1", "start": [173, 1], "end": [174, 86], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.monoidWithZeroHomClass", "code": "instance monoidWithZeroHomClass : MonoidWithZeroHomClass (AbsoluteValue R S) R S :=\n  { AbsoluteValue.mulHomClass with\n    map_zero := fun f => f.map_zero\n    map_one := fun f => f.map_one }", "start": [177, 1], "end": [180, 36], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.toMonoidWithZeroHom", "code": "def toMonoidWithZeroHom : R \u2192*\u2080 S :=\n  abv", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.coe_toMonoidWithZeroHom", "code": "@[simp]\ntheorem coe_toMonoidWithZeroHom : \u21d1abv.toMonoidWithZeroHom = abv", "start": [187, 1], "end": [189, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.toMonoidHom", "code": "def toMonoidHom : R \u2192* S :=\n  abv", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.coe_toMonoidHom", "code": "@[simp]\ntheorem coe_toMonoidHom : \u21d1abv.toMonoidHom = abv", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_pow", "code": "protected theorem map_pow (a : R) (n : \u2115) : abv (a ^ n) = abv a ^ n", "start": [203, 1], "end": [204, 30], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.le_sub", "code": "protected theorem le_sub (a b : R) : abv a - abv b \u2264 abv (a - b)", "start": [215, 1], "end": [216, 61], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_neg", "code": "@[simp]\nprotected theorem map_neg (a : R) : abv (-a) = abv a", "start": [229, 1], "end": [234, 82], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_sub", "code": "protected theorem map_sub (a b : R) : abv (a - b) = abv (b - a)", "start": [237, 1], "end": [237, 98], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.abs", "code": "@[simps]\nprotected def abs : AbsoluteValue S S where\n  toFun := abs\n  nonneg' := abs_nonneg\n  eq_zero' _ := abs_eq_zero\n  add_le' := abs_add\n  map_mul' := abs_mul", "start": [253, 1], "end": [260, 22], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.abs_abv_sub_le_abv_sub", "code": "theorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) \u2264 abv (a - b)", "start": [274, 1], "end": [275, 75], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue", "code": "class IsAbsoluteValue {S} [OrderedSemiring S] {R} [Semiring R] (f : R \u2192 S) : Prop where\n  \n  abv_nonneg' : \u2200 x, 0 \u2264 f x\n  \n  abv_eq_zero' : \u2200 {x}, f x = 0 \u2194 x = 0\n  \n  abv_add' : \u2200 x y, f (x + y) \u2264 f x + f y\n  \n  abv_mul' : \u2200 x y, f (x * y) = f x * f y", "start": [285, 1], "end": [298, 42], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_nonneg", "code": "lemma abv_nonneg (x) : 0 \u2264 abv x := abv_nonneg' x", "start": [309, 1], "end": [309, 50], "kind": "mathlibtacticlemma"}, {"full_name": "IsAbsoluteValue.Mathlib.Meta.Positivity.evalAbv", "code": "@[positivity (_ : \u03b1)]\ndef Mathlib.Meta.Positivity.evalAbv : PositivityExt where eval {_ _\u03b1} _z\u03b1 _p\u03b1 e := do\n  let (.app f a) \u2190 whnfR e | throwError \"not abv \u00b7\"\n  let pa' \u2190 mkAppM ``abv_nonneg #[f, a]\n  pure (.nonnegative pa')", "start": [313, 1], "end": [318, 26], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_eq_zero", "code": "lemma abv_eq_zero {x} : abv x = 0 \u2194 x = 0 := abv_eq_zero'", "start": [320, 1], "end": [320, 58], "kind": "mathlibtacticlemma"}, {"full_name": "IsAbsoluteValue.abv_add", "code": "lemma abv_add (x y) : abv (x + y) \u2264 abv x + abv y := abv_add' x y", "start": [323, 1], "end": [323, 66], "kind": "mathlibtacticlemma"}, {"full_name": "IsAbsoluteValue.abv_mul", "code": "lemma abv_mul (x y) : abv (x * y) = abv x * abv y := abv_mul' x y", "start": [326, 1], "end": [326, 66], "kind": "mathlibtacticlemma"}, {"full_name": "AbsoluteValue.isAbsoluteValue", "code": "instance _root_.AbsoluteValue.isAbsoluteValue (abv : AbsoluteValue R S) : IsAbsoluteValue abv where\n  abv_nonneg' := abv.nonneg\n  abv_eq_zero' := abv.eq_zero\n  abv_add' := abv.add_le\n  abv_mul' := abv.map_mul", "start": [329, 1], "end": [334, 26], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.toAbsoluteValue", "code": "@[simps]\ndef toAbsoluteValue : AbsoluteValue R S where\n  toFun := abv\n  add_le' := abv_add'\n  eq_zero' _ := abv_eq_zero'\n  nonneg' := abv_nonneg'\n  map_mul' := abv_mul'", "start": [337, 1], "end": [344, 23], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_zero", "code": "theorem abv_zero : abv 0 = 0", "start": [349, 1], "end": [350, 33], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_pos", "code": "theorem abv_pos {a : R} : 0 < abv a \u2194 a \u2260 0", "start": [353, 1], "end": [354, 32], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abs_isAbsoluteValue", "code": "instance abs_isAbsoluteValue : IsAbsoluteValue (abs : S \u2192 S) :=\n  AbsoluteValue.abs.isAbsoluteValue", "start": [363, 1], "end": [364, 36], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_one", "code": "theorem abv_one [Nontrivial R] : abv 1 = 1", "start": [379, 1], "end": [380, 32], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abvHom", "code": "def abvHom [Nontrivial R] : R \u2192*\u2080 S :=\n  (toAbsoluteValue abv).toMonoidWithZeroHom", "start": [383, 1], "end": [385, 44], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_pow", "code": "theorem abv_pow [Nontrivial R] (abv : R \u2192 S) [IsAbsoluteValue abv] (a : R) (n : \u2115) :\n    abv (a ^ n) = abv a ^ n", "start": [388, 1], "end": [390, 36], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_sub_le", "code": "theorem abv_sub_le (a b c : R) : abv (a - c) \u2264 abv (a - b) + abv (b - c)", "start": [399, 1], "end": [400, 70], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.sub_abv_le_abv_sub", "code": "theorem sub_abv_le_abv_sub (a b : R) : abv a - abv b \u2264 abv (a - b)", "start": [403, 1], "end": [404, 35], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_neg", "code": "theorem abv_neg (a : R) : abv (-a) = abv a", "start": [421, 1], "end": [422, 34], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_sub", "code": "theorem abv_sub (a b : R) : abv (a - b) = abv (b - a)", "start": [425, 1], "end": [426, 36], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abs_abv_sub_le_abv_sub", "code": "theorem abs_abv_sub_le_abv_sub (a b : R) : abs (abv a - abv b) \u2264 abv (a - b)", "start": [441, 1], "end": [442, 51], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_one'", "code": "theorem abv_one' : abv 1 = 1", "start": [457, 1], "end": [459, 77], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abvHom'", "code": "def abvHom' : R \u2192*\u2080 S where\n  toFun := abv; map_zero' := abv_zero abv; map_one' := abv_one' abv; map_mul' := abv_mul abv", "start": [462, 1], "end": [464, 93], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_inv", "code": "theorem abv_inv (a : R) : abv a\u207b\u00b9 = (abv a)\u207b\u00b9", "start": [473, 1], "end": [474, 27], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_div", "code": "theorem abv_div (a b : R) : abv (a / b) = abv a / abv b", "start": [477, 1], "end": [478, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/WithTop.lean", "imports": ["lake-packages/std/Std/Data/Option/Lemmas.lean", "Mathlib/Tactic/Tauto.lean", "Mathlib/Algebra/Order/Monoid/WithTop.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Ring/Canonical.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "WithTop.instMulZeroClassWithTop", "code": "instance instMulZeroClassWithTop : MulZeroClass (WithTop \u03b1) where\n  zero := 0\n  mul m n := if m = 0 \u2228 n = 0 then 0 else Option.map\u2082 (\u00b7 * \u00b7) m n\n  zero_mul _ := if_pos <| Or.inl rfl\n  mul_zero _ := if_pos <| Or.inr rfl", "start": [31, 1], "end": [35, 37], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_def", "code": "theorem mul_def {a b : WithTop \u03b1} :\n    a * b = (if a = 0 \u2228 b = 0 then 0 else Option.map\u2082 (\u00b7 * \u00b7) a b : WithTop \u03b1)", "start": [37, 1], "end": [39, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_mul_top", "code": "theorem top_mul_top : (\u22a4 * \u22a4 : WithTop \u03b1) = \u22a4", "start": [44, 1], "end": [44, 72], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_top'", "code": "theorem mul_top' (a : WithTop \u03b1) : a * \u22a4 = if a = 0 then 0 else \u22a4", "start": [47, 1], "end": [48, 57], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_top", "code": "@[simp] theorem mul_top {a : WithTop \u03b1} (h : a \u2260 0) : a * \u22a4 = \u22a4", "start": [51, 1], "end": [51, 94], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_mul'", "code": "theorem top_mul' (a : WithTop \u03b1) : \u22a4 * a = if a = 0 then 0 else \u22a4", "start": [54, 1], "end": [55, 57], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_mul", "code": "@[simp] theorem top_mul {a : WithTop \u03b1} (h : a \u2260 0) : \u22a4 * a = \u22a4", "start": [58, 1], "end": [58, 94], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_eq_top_iff", "code": "theorem mul_eq_top_iff {a b : WithTop \u03b1} : a * b = \u22a4 \u2194 a \u2260 0 \u2227 b = \u22a4 \u2228 a = \u22a4 \u2227 b \u2260 0", "start": [61, 1], "end": [65, 8], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_lt_top'", "code": "theorem mul_lt_top' [LT \u03b1] {a b : WithTop \u03b1} (ha : a < \u22a4) (hb : b < \u22a4) : a * b < \u22a4", "start": [68, 1], "end": [70, 72], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_lt_top", "code": "theorem mul_lt_top [LT \u03b1] {a b : WithTop \u03b1} (ha : a \u2260 \u22a4) (hb : b \u2260 \u22a4) : a * b < \u22a4", "start": [73, 1], "end": [74, 80], "kind": "commanddeclaration"}, {"full_name": "WithTop.noZeroDivisors", "code": "instance noZeroDivisors [NoZeroDivisors \u03b1] : NoZeroDivisors (WithTop \u03b1) := by\n  refine \u27e8fun h\u2081 => Decidable.by_contradiction <| fun h\u2082 => ?_\u27e9\n  rw [mul_def, if_neg h\u2082] at h\u2081\n  rcases Option.mem_map\u2082_iff.1 h\u2081 with \u27e8a, b, (rfl : _ = _), (rfl : _ = _), hab\u27e9\n  exact h\u2082 ((eq_zero_or_eq_zero_of_mul_eq_zero hab).imp (congr_arg some) (congr_arg some))", "start": [77, 1], "end": [81, 91], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul {a b : \u03b1} : (\u2191(a * b) : WithTop \u03b1) = a * b", "start": [89, 1], "end": [96, 10], "kind": "commanddeclaration"}, {"full_name": "WithTop.mul_coe", "code": "theorem mul_coe {b : \u03b1} (hb : b \u2260 0) : \u2200 {a : WithTop \u03b1},\n    a * (b : WithTop \u03b1) = a.bind fun a : \u03b1 => \u2191(a * b)", "start": [99, 1], "end": [105, 8], "kind": "commanddeclaration"}, {"full_name": "WithTop.untop'_zero_mul", "code": "@[simp]\ntheorem untop'_zero_mul (a b : WithTop \u03b1) : (a * b).untop' 0 = a.untop' 0 * b.untop' 0", "start": [108, 1], "end": [114, 53], "kind": "commanddeclaration"}, {"full_name": "WithTop.instMulZeroOneClassWithTop", "code": "instance instMulZeroOneClassWithTop [MulZeroOneClass \u03b1] [Nontrivial \u03b1] :\n    MulZeroOneClass (WithTop \u03b1) :=\n  { WithTop.instMulZeroClassWithTop with\n    one_mul := fun a =>\n      match a with\n      | \u22a4 => mul_top (mt coe_eq_coe.1 one_ne_zero)\n      | (a : \u03b1) => by rw [\u2190 coe_one, \u2190 coe_mul, one_mul],\n    mul_one := fun a =>\n      match a with\n      | \u22a4 => top_mul (mt coe_eq_coe.1 one_ne_zero)\n      | (a : \u03b1) => by rw [\u2190 coe_one, \u2190 coe_mul, mul_one] }", "start": [119, 1], "end": [130, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidWithZeroHom.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.MonoidWithZeroHom.withTopMap {R S : Type*} [MulZeroOneClass R] [DecidableEq R]\n    [Nontrivial R] [MulZeroOneClass S] [DecidableEq S] [Nontrivial S] (f : R \u2192*\u2080 S)\n    (hf : Function.Injective f) : WithTop R \u2192*\u2080 WithTop S :=\n  { f.toZeroHom.withTopMap, f.toMonoidHom.toOneHom.withTopMap with\n    toFun := WithTop.map f\n    map_mul' := fun x y => by\n      have : \u2200 z, map f z = 0 \u2194 z = 0 := fun z =>\n        (Option.map_injective hf).eq_iff' f.toZeroHom.withTopMap.map_zero\n      rcases Decidable.eq_or_ne x 0 with (rfl | hx)\n      \u00b7 simp\n      rcases Decidable.eq_or_ne y 0 with (rfl | hy)\n      \u00b7 simp\n      induction' x using WithTop.recTopCoe with x\n      \u00b7 simp [hy, this]\n      induction' y using WithTop.recTopCoe with y\n      \u00b7 have : (f x : WithTop S) \u2260 0 := by simpa [hf.eq_iff' (map_zero f)] using hx\n        simp [mul_top hx, mul_top this]\n      \u00b7 simp only [map_coe, \u2190 coe_mul, map_mul] }", "start": [132, 1], "end": [152, 50], "kind": "commanddeclaration"}, {"full_name": "WithTop.instSemigroupWithZeroWithTop", "code": "instance instSemigroupWithZeroWithTop [SemigroupWithZero \u03b1] [NoZeroDivisors \u03b1] :\n    SemigroupWithZero (WithTop \u03b1) :=\n  { WithTop.instMulZeroClassWithTop with\n    mul_assoc := fun a b c => by\n      rcases eq_or_ne a 0 with (rfl | ha); \u00b7 simp only [zero_mul]\n      rcases eq_or_ne b 0 with (rfl | hb); \u00b7 simp only [zero_mul, mul_zero]\n      rcases eq_or_ne c 0 with (rfl | hc); \u00b7 simp only [mul_zero]\n    induction' a using WithTop.recTopCoe with a; \u00b7 simp [hb, hc]\n      induction' b using WithTop.recTopCoe with b; \u00b7 simp [mul_top ha, top_mul hc]\n      induction' c using WithTop.recTopCoe with c\n      \u00b7 rw [mul_top hb, mul_top ha]\n        rw [\u2190 coe_zero, ne_eq, coe_eq_coe] at ha hb\n        simp [ha, hb]\n      simp only [\u2190 coe_mul, mul_assoc] }", "start": [155, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "WithTop.monoidWithZero", "code": "instance monoidWithZero [MonoidWithZero \u03b1] [NoZeroDivisors \u03b1] [Nontrivial \u03b1] :\n    MonoidWithZero (WithTop \u03b1) :=\n  { WithTop.instMulZeroOneClassWithTop, WithTop.instSemigroupWithZeroWithTop with }", "start": [171, 1], "end": [173, 84], "kind": "commanddeclaration"}, {"full_name": "WithTop.commMonoidWithZero", "code": "instance commMonoidWithZero [CommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] [Nontrivial \u03b1] :\n    CommMonoidWithZero (WithTop \u03b1) :=\n  { WithTop.monoidWithZero with\n    mul_comm := fun _ _ => ite_congr (propext or_comm) (fun _ => rfl)\n      (fun _ => Option.map\u2082_comm mul_comm) }", "start": [175, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "WithTop.distrib'", "code": "private theorem distrib' (a b c : WithTop \u03b1) : (a + b) * c = a * c + b * c", "start": [183, 1], "end": [190, 62], "kind": "commanddeclaration"}, {"full_name": "WithTop.commSemiring", "code": "instance commSemiring [Nontrivial \u03b1] : CommSemiring (WithTop \u03b1) :=\n  { WithTop.addCommMonoidWithOne, WithTop.commMonoidWithZero with\n    right_distrib := distrib'\n    left_distrib := fun a b c => by\n      rw [mul_comm, distrib', mul_comm b, mul_comm c] }", "start": [192, 1], "end": [199, 56], "kind": "commanddeclaration"}, {"full_name": "RingHom.withTopMap", "code": "@[simps (config := { fullyApplied := false })]\nprotected def _root_.RingHom.withTopMap {R S : Type*} [CanonicallyOrderedCommSemiring R]\n    [DecidableEq R] [Nontrivial R] [CanonicallyOrderedCommSemiring S] [DecidableEq S] [Nontrivial S]\n    (f : R \u2192+* S) (hf : Function.Injective f) : WithTop R \u2192+* WithTop S :=\n  {MonoidWithZeroHom.withTopMap f.toMonoidWithZeroHom hf, f.toAddMonoidHom.withTopMap with}", "start": [205, 1], "end": [210, 92], "kind": "commanddeclaration"}, {"full_name": "WithBot.mul_def", "code": "theorem mul_def {a b : WithBot \u03b1} :\n    a * b = if a = 0 \u2228 b = 0 then (0 : WithBot \u03b1) else Option.map\u2082 (\u00b7 * \u00b7) a b", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.mul_bot", "code": "@[simp]\ntheorem mul_bot {a : WithBot \u03b1} (h : a \u2260 0) : a * \u22a5 = \u22a5", "start": [233, 1], "end": [235, 20], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_mul", "code": "@[simp]\ntheorem bot_mul {a : WithBot \u03b1} (h : a \u2260 0) : \u22a5 * a = \u22a5", "start": [238, 1], "end": [240, 20], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_mul_bot", "code": "@[simp]\ntheorem bot_mul_bot : (\u22a5 * \u22a5 : WithBot \u03b1) = \u22a5", "start": [243, 1], "end": [245, 22], "kind": "commanddeclaration"}, {"full_name": "WithBot.mul_eq_bot_iff", "code": "theorem mul_eq_bot_iff {a b : WithBot \u03b1} : a * b = \u22a5 \u2194 a \u2260 0 \u2227 b = \u22a5 \u2228 a = \u22a5 \u2227 b \u2260 0", "start": [248, 1], "end": [249, 25], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_lt_mul'", "code": "theorem bot_lt_mul' [LT \u03b1] {a b : WithBot \u03b1} (ha : \u22a5 < a) (hb : \u22a5 < b) : \u22a5 < a * b", "start": [252, 1], "end": [253, 39], "kind": "commanddeclaration"}, {"full_name": "WithBot.bot_lt_mul", "code": "theorem bot_lt_mul [LT \u03b1] {a b : WithBot \u03b1} (ha : a \u2260 \u22a5) (hb : b \u2260 \u22a5) : \u22a5 < a * b", "start": [256, 1], "end": [257, 38], "kind": "commanddeclaration"}, {"full_name": "WithBot.coe_mul", "code": "@[simp, norm_cast] theorem coe_mul {a b : \u03b1} : (\u2191(a * b) : WithBot \u03b1) = a * b", "start": [266, 1], "end": [268, 18], "kind": "commanddeclaration"}, {"full_name": "WithBot.mul_coe", "code": "theorem mul_coe {b : \u03b1} (hb : b \u2260 0) {a : WithBot \u03b1} :\n    a * (b : WithBot \u03b1) = a.bind fun a : \u03b1 => \u2191(a * b)", "start": [271, 1], "end": [273, 21], "kind": "commanddeclaration"}, {"full_name": "WithBot.commMonoidWithZero", "code": "instance commMonoidWithZero [CommMonoidWithZero \u03b1] [NoZeroDivisors \u03b1] [Nontrivial \u03b1] :\n    CommMonoidWithZero (WithBot \u03b1) :=\n  WithTop.commMonoidWithZero", "start": [291, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "WithBot.commSemiring", "code": "instance commSemiring [CanonicallyOrderedCommSemiring \u03b1] [Nontrivial \u03b1] :\n    CommSemiring (WithBot \u03b1) :=\n  WithTop.commSemiring", "start": [295, 1], "end": [297, 23], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderedCommSemiring", "code": "instance orderedCommSemiring [CanonicallyOrderedCommSemiring \u03b1] [Nontrivial \u03b1] :\n    OrderedCommSemiring (WithBot \u03b1) :=\n  { WithBot.zeroLEOneClass, WithBot.orderedAddCommMonoid, WithBot.commSemiring with\n    mul_le_mul_of_nonneg_left  := fun _ _ _ => mul_le_mul_of_nonneg_left\n    mul_le_mul_of_nonneg_right := fun _ _ _ => mul_le_mul_of_nonneg_right }", "start": [423, 1], "end": [427, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Associated.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Parity.lean", "Mathlib/Algebra/GroupPower/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prime", "code": "def Prime (p : \u03b1) : Prop :=\n  p \u2260 0 \u2227 \u00acIsUnit p \u2227 \u2200 a b, p \u2223 a * b \u2192 p \u2223 a \u2228 p \u2223 b", "start": [23, 1], "end": [25, 55], "kind": "commanddeclaration"}, {"full_name": "Prime.ne_zero", "code": "theorem ne_zero : p \u2260 0", "start": [32, 1], "end": [33, 7], "kind": "commanddeclaration"}, {"full_name": "Prime.not_unit", "code": "theorem not_unit : \u00acIsUnit p", "start": [36, 1], "end": [37, 9], "kind": "commanddeclaration"}, {"full_name": "Prime.not_dvd_one", "code": "theorem not_dvd_one : \u00acp \u2223 1", "start": [40, 1], "end": [41, 39], "kind": "commanddeclaration"}, {"full_name": "Prime.ne_one", "code": "theorem ne_one : p \u2260 1", "start": [44, 1], "end": [44, 64], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_or_dvd", "code": "theorem dvd_or_dvd (hp : Prime p) {a b : \u03b1} (h : p \u2223 a * b) : p \u2223 a \u2228 p \u2223 b", "start": [47, 1], "end": [48, 15], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_mul", "code": "theorem dvd_mul {a b : \u03b1} : p \u2223 a * b \u2194 p \u2223 a \u2228 p \u2223 b", "start": [51, 1], "end": [52, 84], "kind": "commanddeclaration"}, {"full_name": "Prime.not_dvd_mul", "code": "theorem not_dvd_mul {a b : \u03b1} (ha : \u00ac p \u2223 a) (hb : \u00ac p \u2223 b) : \u00ac p \u2223 a * b", "start": [54, 1], "end": [55, 44], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_of_dvd_pow", "code": "theorem dvd_of_dvd_pow (hp : Prime p) {a : \u03b1} {n : \u2115} (h : p \u2223 a ^ n) : p \u2223 a", "start": [57, 1], "end": [66, 19], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_pow_iff_dvd", "code": "theorem dvd_pow_iff_dvd {a : \u03b1} {n : \u2115} (hn : n \u2260 0) : p \u2223 a ^ n \u2194 p \u2223 a", "start": [69, 1], "end": [70, 38], "kind": "commanddeclaration"}, {"full_name": "not_prime_zero", "code": "@[simp]\ntheorem not_prime_zero : \u00acPrime (0 : \u03b1)", "start": [74, 1], "end": [75, 66], "kind": "commanddeclaration"}, {"full_name": "not_prime_one", "code": "@[simp]\ntheorem not_prime_one : \u00acPrime (1 : \u03b1)", "start": [78, 1], "end": [79, 73], "kind": "commanddeclaration"}, {"full_name": "comap_prime", "code": "theorem comap_prime (hinv : \u2200 a, g (f a : \u03b2) = a) (hp : Prime (f p)) : Prime p", "start": [87, 1], "end": [95, 46], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.prime_iff", "code": "theorem MulEquiv.prime_iff (e : \u03b1 \u2243* \u03b2) : Prime p \u2194 Prime (e p)", "start": [98, 1], "end": [100, 43], "kind": "commanddeclaration"}, {"full_name": "Prime.left_dvd_or_dvd_right_of_dvd_mul", "code": "theorem Prime.left_dvd_or_dvd_right_of_dvd_mul [CancelCommMonoidWithZero \u03b1] {p : \u03b1} (hp : Prime p)\n    {a b : \u03b1} : a \u2223 p * b \u2192 p \u2223 a \u2228 a \u2223 b", "start": [107, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "Prime.pow_dvd_of_dvd_mul_left", "code": "theorem Prime.pow_dvd_of_dvd_mul_left [CancelCommMonoidWithZero \u03b1] {p a b : \u03b1} (hp : Prime p)\n    (n : \u2115) (h : \u00acp \u2223 a) (h' : p ^ n \u2223 a * b) : p ^ n \u2223 b", "start": [116, 1], "end": [124, 88], "kind": "commanddeclaration"}, {"full_name": "Prime.pow_dvd_of_dvd_mul_right", "code": "theorem Prime.pow_dvd_of_dvd_mul_right [CancelCommMonoidWithZero \u03b1] {p a b : \u03b1} (hp : Prime p)\n    (n : \u2115) (h : \u00acp \u2223 b) (h' : p ^ n \u2223 a * b) : p ^ n \u2223 a", "start": [127, 1], "end": [130, 42], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd", "code": "theorem Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd [CancelCommMonoidWithZero \u03b1] {p a b : \u03b1}\n    {n : \u2115} (hp : Prime p) (hpow : p ^ n.succ \u2223 a ^ n.succ * b ^ n) (hb : \u00acp ^ 2 \u2223 b) : p \u2223 a", "start": [133, 1], "end": [149, 26], "kind": "commanddeclaration"}, {"full_name": "prime_pow_succ_dvd_mul", "code": "theorem prime_pow_succ_dvd_mul {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] {p x y : \u03b1} (h : Prime p)\n    {i : \u2115} (hxy : p ^ (i + 1) \u2223 x * y) : p ^ (i + 1) \u2223 x \u2228 p \u2223 y", "start": [152, 1], "end": [162, 74], "kind": "commanddeclaration"}, {"full_name": "Irreducible", "code": "structure Irreducible [Monoid \u03b1] (p : \u03b1) : Prop where\n  \n  not_unit : \u00acIsUnit p\n  \n  isUnit_or_isUnit' : \u2200 a b, p = a * b \u2192 IsUnit a \u2228 IsUnit b", "start": [165, 1], "end": [174, 61], "kind": "commanddeclaration"}, {"full_name": "Irreducible.not_dvd_one", "code": "theorem not_dvd_one [CommMonoid \u03b1] {p : \u03b1} (hp : Irreducible p) : \u00acp \u2223 1", "start": [179, 1], "end": [180, 39], "kind": "commanddeclaration"}, {"full_name": "Irreducible.isUnit_or_isUnit", "code": "theorem isUnit_or_isUnit [Monoid \u03b1] {p : \u03b1} (hp : Irreducible p) {a b : \u03b1} (h : p = a * b) :\n    IsUnit a \u2228 IsUnit b", "start": [183, 1], "end": [185, 29], "kind": "commanddeclaration"}, {"full_name": "irreducible_iff", "code": "theorem irreducible_iff [Monoid \u03b1] {p : \u03b1} :\n    Irreducible p \u2194 \u00acIsUnit p \u2227 \u2200 a b, p = a * b \u2192 IsUnit a \u2228 IsUnit b", "start": [190, 1], "end": [192, 45], "kind": "commanddeclaration"}, {"full_name": "not_irreducible_one", "code": "@[simp]\ntheorem not_irreducible_one [Monoid \u03b1] : \u00acIrreducible (1 : \u03b1)", "start": [195, 1], "end": [196, 91], "kind": "commanddeclaration"}, {"full_name": "Irreducible.ne_one", "code": "theorem Irreducible.ne_one [Monoid \u03b1] : \u2200 {p : \u03b1}, Irreducible p \u2192 p \u2260 1", "start": [199, 1], "end": [200, 41], "kind": "commanddeclaration"}, {"full_name": "not_irreducible_zero", "code": "@[simp]\ntheorem not_irreducible_zero [MonoidWithZero \u03b1] : \u00acIrreducible (0 : \u03b1)", "start": [203, 1], "end": [207, 22], "kind": "commanddeclaration"}, {"full_name": "Irreducible.ne_zero", "code": "theorem Irreducible.ne_zero [MonoidWithZero \u03b1] : \u2200 {p : \u03b1}, Irreducible p \u2192 p \u2260 0", "start": [210, 1], "end": [211, 42], "kind": "commanddeclaration"}, {"full_name": "of_irreducible_mul", "code": "theorem of_irreducible_mul {\u03b1} [Monoid \u03b1] {x y : \u03b1} : Irreducible (x * y) \u2192 IsUnit x \u2228 IsUnit y", "start": [214, 1], "end": [215, 24], "kind": "commanddeclaration"}, {"full_name": "of_irreducible_pow", "code": "theorem of_irreducible_pow {\u03b1} [Monoid \u03b1] {x : \u03b1} {n : \u2115} (hn : n \u2260 1) :\n    Irreducible (x ^ n) \u2192 IsUnit x", "start": [218, 1], "end": [225, 78], "kind": "commanddeclaration"}, {"full_name": "irreducible_or_factor", "code": "theorem irreducible_or_factor {\u03b1} [Monoid \u03b1] (x : \u03b1) (h : \u00acIsUnit x) :\n    Irreducible x \u2228 \u2203 a b, \u00acIsUnit a \u2227 \u00acIsUnit b \u2227 a * b = x", "start": [228, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "Irreducible.dvd_symm", "code": "theorem Irreducible.dvd_symm [Monoid \u03b1] {p q : \u03b1} (hp : Irreducible p) (hq : Irreducible q) :\n    p \u2223 q \u2192 q \u2223 p", "start": [238, 1], "end": [242, 82], "kind": "commanddeclaration"}, {"full_name": "Irreducible.dvd_comm", "code": "theorem Irreducible.dvd_comm [Monoid \u03b1] {p q : \u03b1} (hp : Irreducible p) (hq : Irreducible q) :\n    p \u2223 q \u2194 q \u2223 p", "start": [245, 1], "end": [247, 35], "kind": "commanddeclaration"}, {"full_name": "irreducible_units_mul", "code": "theorem irreducible_units_mul (a : \u03b1\u02e3) (b : \u03b1) : Irreducible (\u2191a * b) \u2194 Irreducible b", "start": [254, 1], "end": [262, 53], "kind": "commanddeclaration"}, {"full_name": "irreducible_isUnit_mul", "code": "theorem irreducible_isUnit_mul {a b : \u03b1} (h : IsUnit a) : Irreducible (a * b) \u2194 Irreducible b", "start": [265, 1], "end": [267, 33], "kind": "commanddeclaration"}, {"full_name": "irreducible_mul_units", "code": "theorem irreducible_mul_units (a : \u03b1\u02e3) (b : \u03b1) : Irreducible (b * \u2191a) \u2194 Irreducible b", "start": [270, 1], "end": [278, 56], "kind": "commanddeclaration"}, {"full_name": "irreducible_mul_isUnit", "code": "theorem irreducible_mul_isUnit {a b : \u03b1} (h : IsUnit a) : Irreducible (b * a) \u2194 Irreducible b", "start": [281, 1], "end": [283, 33], "kind": "commanddeclaration"}, {"full_name": "irreducible_mul_iff", "code": "theorem irreducible_mul_iff {a b : \u03b1} :\n    Irreducible (a * b) \u2194 Irreducible a \u2227 IsUnit b \u2228 Irreducible b \u2227 IsUnit a", "start": [286, 1], "end": [294, 38], "kind": "commanddeclaration"}, {"full_name": "Irreducible.not_square", "code": "theorem Irreducible.not_square (ha : Irreducible a) : \u00acIsSquare a", "start": [303, 1], "end": [306, 27], "kind": "commanddeclaration"}, {"full_name": "IsSquare.not_irreducible", "code": "theorem IsSquare.not_irreducible (ha : IsSquare a) : \u00acIrreducible a", "start": [309, 1], "end": [309, 96], "kind": "commanddeclaration"}, {"full_name": "Prime.irreducible", "code": "protected theorem Prime.irreducible (hp : Prime p) : Irreducible p", "start": [318, 1], "end": [349, 61], "kind": "commanddeclaration"}, {"full_name": "succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul", "code": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul (hp : Prime p) {a b : \u03b1} {k l : \u2115} :\n    p ^ k \u2223 a \u2192 p ^ l \u2223 b \u2192 p ^ (k + l + 1) \u2223 a * b \u2192 p ^ (k + 1) \u2223 a \u2228 p ^ (l + 1) \u2223 b", "start": [352, 1], "end": [361, 89], "kind": "commanddeclaration"}, {"full_name": "Prime.not_square", "code": "theorem Prime.not_square (hp : Prime p) : \u00acIsSquare p", "start": [364, 1], "end": [365, 28], "kind": "commanddeclaration"}, {"full_name": "IsSquare.not_prime", "code": "theorem IsSquare.not_prime (ha : IsSquare a) : \u00acPrime a", "start": [368, 1], "end": [368, 84], "kind": "commanddeclaration"}, {"full_name": "pow_not_prime", "code": "theorem pow_not_prime {n : \u2115} (hn : n \u2260 1) : \u00acPrime (a ^ n)", "start": [371, 1], "end": [372, 73], "kind": "commanddeclaration"}, {"full_name": "Associated", "code": "def Associated [Monoid \u03b1] (x y : \u03b1) : Prop :=\n  \u2203 u : \u03b1\u02e3, x * u = y", "start": [377, 1], "end": [380, 22], "kind": "commanddeclaration"}, {"full_name": "Associated.refl", "code": "@[refl]\nprotected theorem refl [Monoid \u03b1] (x : \u03b1) : x ~\u1d64 x", "start": [389, 1], "end": [391, 15], "kind": "commanddeclaration"}, {"full_name": "Associated.symm", "code": "@[symm]\nprotected theorem symm [Monoid \u03b1] : \u2200 {x y : \u03b1}, x ~\u1d64 y \u2192 y ~\u1d64 x", "start": [397, 1], "end": [399, 71], "kind": "commanddeclaration"}, {"full_name": "Associated.comm", "code": "protected theorem comm [Monoid \u03b1] {x y : \u03b1} : x ~\u1d64 y \u2194 y ~\u1d64 x", "start": [405, 1], "end": [406, 37], "kind": "commanddeclaration"}, {"full_name": "Associated.trans", "code": "@[trans]\nprotected theorem trans [Monoid \u03b1] : \u2200 {x y z : \u03b1}, x ~\u1d64 y \u2192 y ~\u1d64 z \u2192 x ~\u1d64 z", "start": [409, 1], "end": [411, 77], "kind": "commanddeclaration"}, {"full_name": "Associated.setoid", "code": "protected def setoid (\u03b1 : Type*) [Monoid \u03b1] :\n    Setoid \u03b1 where\n  r := Associated\n  iseqv := \u27e8Associated.refl, Associated.symm, Associated.trans\u27e9", "start": [417, 1], "end": [421, 64], "kind": "commanddeclaration"}, {"full_name": "unit_associated_one", "code": "theorem unit_associated_one [Monoid \u03b1] {u : \u03b1\u02e3} : (u : \u03b1) ~\u1d64 1", "start": [428, 1], "end": [429, 25], "kind": "commanddeclaration"}, {"full_name": "associated_one_iff_isUnit", "code": "theorem associated_one_iff_isUnit [Monoid \u03b1] {a : \u03b1} : (a : \u03b1) ~\u1d64 1 \u2194 IsUnit a", "start": [432, 1], "end": [437, 51], "kind": "commanddeclaration"}, {"full_name": "associated_zero_iff_eq_zero", "code": "theorem associated_zero_iff_eq_zero [MonoidWithZero \u03b1] (a : \u03b1) : a ~\u1d64 0 \u2194 a = 0", "start": [440, 1], "end": [445, 35], "kind": "commanddeclaration"}, {"full_name": "associated_one_of_mul_eq_one", "code": "theorem associated_one_of_mul_eq_one [CommMonoid \u03b1] {a : \u03b1} (b : \u03b1) (hab : a * b = 1) : a ~\u1d64 1", "start": [448, 1], "end": [449, 70], "kind": "commanddeclaration"}, {"full_name": "associated_one_of_associated_mul_one", "code": "theorem associated_one_of_associated_mul_one [CommMonoid \u03b1] {a b : \u03b1} : a * b ~\u1d64 1 \u2192 a ~\u1d64 1", "start": [452, 1], "end": [453, 83], "kind": "commanddeclaration"}, {"full_name": "associated_mul_unit_left", "code": "theorem associated_mul_unit_left {\u03b2 : Type*} [Monoid \u03b2] (a u : \u03b2) (hu : IsUnit u) :\n    Associated (a * u) a", "start": [456, 1], "end": [459, 46], "kind": "commanddeclaration"}, {"full_name": "associated_unit_mul_left", "code": "theorem associated_unit_mul_left {\u03b2 : Type*} [CommMonoid \u03b2] (a u : \u03b2) (hu : IsUnit u) :\n    Associated (u * a) a", "start": [462, 1], "end": [465, 40], "kind": "commanddeclaration"}, {"full_name": "associated_mul_unit_right", "code": "theorem associated_mul_unit_right {\u03b2 : Type*} [Monoid \u03b2] (a u : \u03b2) (hu : IsUnit u) :\n    Associated a (a * u)", "start": [468, 1], "end": [470, 41], "kind": "commanddeclaration"}, {"full_name": "associated_unit_mul_right", "code": "theorem associated_unit_mul_right {\u03b2 : Type*} [CommMonoid \u03b2] (a u : \u03b2) (hu : IsUnit u) :\n    Associated a (u * a)", "start": [473, 1], "end": [475, 41], "kind": "commanddeclaration"}, {"full_name": "associated_mul_isUnit_left_iff", "code": "theorem associated_mul_isUnit_left_iff {\u03b2 : Type*} [Monoid \u03b2] {a u b : \u03b2} (hu : IsUnit u) :\n    Associated (a * u) b \u2194 Associated a b", "start": [478, 1], "end": [480, 86], "kind": "commanddeclaration"}, {"full_name": "associated_isUnit_mul_left_iff", "code": "theorem associated_isUnit_mul_left_iff {\u03b2 : Type*} [CommMonoid \u03b2] {u a b : \u03b2} (hu : IsUnit u) :\n    Associated (u * a) b \u2194 Associated a b", "start": [483, 1], "end": [486, 42], "kind": "commanddeclaration"}, {"full_name": "associated_mul_isUnit_right_iff", "code": "theorem associated_mul_isUnit_right_iff {\u03b2 : Type*} [Monoid \u03b2] {a b u : \u03b2} (hu : IsUnit u) :\n    Associated a (b * u) \u2194 Associated a b", "start": [489, 1], "end": [491, 85], "kind": "commanddeclaration"}, {"full_name": "associated_isUnit_mul_right_iff", "code": "theorem associated_isUnit_mul_right_iff {\u03b2 : Type*} [CommMonoid \u03b2] {a u b : \u03b2} (hu : IsUnit u) :\n    Associated a (u * b) \u2194 Associated a b", "start": [494, 1], "end": [496, 85], "kind": "commanddeclaration"}, {"full_name": "associated_mul_unit_left_iff", "code": "@[simp]\ntheorem associated_mul_unit_left_iff {\u03b2 : Type*} [Monoid \u03b2] {a b : \u03b2} {u : Units \u03b2} :\n    Associated (a * u) b \u2194 Associated a b", "start": [499, 1], "end": [502, 42], "kind": "commanddeclaration"}, {"full_name": "associated_unit_mul_left_iff", "code": "@[simp]\ntheorem associated_unit_mul_left_iff {\u03b2 : Type*} [CommMonoid \u03b2] {a b : \u03b2} {u : Units \u03b2} :\n    Associated (\u2191u * a) b \u2194 Associated a b", "start": [505, 1], "end": [508, 42], "kind": "commanddeclaration"}, {"full_name": "associated_mul_unit_right_iff", "code": "@[simp]\ntheorem associated_mul_unit_right_iff {\u03b2 : Type*} [Monoid \u03b2] {a b : \u03b2} {u : Units \u03b2} :\n    Associated a (b * u) \u2194 Associated a b", "start": [511, 1], "end": [514, 43], "kind": "commanddeclaration"}, {"full_name": "associated_unit_mul_right_iff", "code": "@[simp]\ntheorem associated_unit_mul_right_iff {\u03b2 : Type*} [CommMonoid \u03b2] {a b : \u03b2} {u : Units \u03b2} :\n    Associated a (\u2191u * b) \u2194 Associated a b", "start": [517, 1], "end": [520, 43], "kind": "commanddeclaration"}, {"full_name": "Associated.mul_mul", "code": "theorem Associated.mul_mul [CommMonoid \u03b1] {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    a\u2081 ~\u1d64 b\u2081 \u2192 a\u2082 ~\u1d64 b\u2082 \u2192 a\u2081 * a\u2082 ~\u1d64 b\u2081 * b\u2082", "start": [523, 1], "end": [525, 100], "kind": "commanddeclaration"}, {"full_name": "Associated.mul_left", "code": "theorem Associated.mul_left [CommMonoid \u03b1] (a : \u03b1) {b c : \u03b1} (h : b ~\u1d64 c) : a * b ~\u1d64 a * c", "start": [528, 1], "end": [529, 32], "kind": "commanddeclaration"}, {"full_name": "Associated.mul_right", "code": "theorem Associated.mul_right [CommMonoid \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) (c : \u03b1) : a * c ~\u1d64 b * c", "start": [532, 1], "end": [533, 32], "kind": "commanddeclaration"}, {"full_name": "Associated.pow_pow", "code": "theorem Associated.pow_pow [CommMonoid \u03b1] {a b : \u03b1} {n : \u2115} (h : a ~\u1d64 b) : a ^ n ~\u1d64 b ^ n", "start": [536, 1], "end": [539, 41], "kind": "commanddeclaration"}, {"full_name": "Associated.dvd", "code": "protected theorem Associated.dvd [Monoid \u03b1] {a b : \u03b1} : a ~\u1d64 b \u2192 a \u2223 b", "start": [542, 1], "end": [543, 15], "kind": "commanddeclaration"}, {"full_name": "Associated.dvd_dvd", "code": "protected theorem Associated.dvd_dvd [Monoid \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) : a \u2223 b \u2227 b \u2223 a", "start": [546, 1], "end": [547, 22], "kind": "commanddeclaration"}, {"full_name": "associated_of_dvd_dvd", "code": "theorem associated_of_dvd_dvd [CancelMonoidWithZero \u03b1] {a b : \u03b1} (hab : a \u2223 b) (hba : b \u2223 a) :\n    a ~\u1d64 b", "start": [550, 1], "end": [564, 32], "kind": "commanddeclaration"}, {"full_name": "dvd_dvd_iff_associated", "code": "theorem dvd_dvd_iff_associated [CancelMonoidWithZero \u03b1] {a b : \u03b1} : a \u2223 b \u2227 b \u2223 a \u2194 a ~\u1d64 b", "start": [567, 1], "end": [568, 68], "kind": "commanddeclaration"}, {"full_name": "Associated.dvd_iff_dvd_left", "code": "theorem Associated.dvd_iff_dvd_left [Monoid \u03b1] {a b c : \u03b1} (h : a ~\u1d64 b) : a \u2223 c \u2194 b \u2223 c", "start": [574, 1], "end": [576, 32], "kind": "commanddeclaration"}, {"full_name": "Associated.dvd_iff_dvd_right", "code": "theorem Associated.dvd_iff_dvd_right [Monoid \u03b1] {a b c : \u03b1} (h : b ~\u1d64 c) : a \u2223 b \u2194 a \u2223 c", "start": [579, 1], "end": [581, 32], "kind": "commanddeclaration"}, {"full_name": "Associated.eq_zero_iff", "code": "theorem Associated.eq_zero_iff [MonoidWithZero \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) : a = 0 \u2194 b = 0", "start": [584, 1], "end": [589, 24], "kind": "commanddeclaration"}, {"full_name": "Associated.ne_zero_iff", "code": "theorem Associated.ne_zero_iff [MonoidWithZero \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) : a \u2260 0 \u2194 b \u2260 0", "start": [592, 1], "end": [593, 26], "kind": "commanddeclaration"}, {"full_name": "Associated.prime", "code": "protected theorem Associated.prime [CommMonoidWithZero \u03b1] {p q : \u03b1} (h : p ~\u1d64 q) (hp : Prime p) :\n    Prime q", "start": [596, 1], "end": [604, 30], "kind": "commanddeclaration"}, {"full_name": "Irreducible.dvd_iff", "code": "theorem Irreducible.dvd_iff [Monoid \u03b1] {x y : \u03b1} (hx : Irreducible x) :\n    y \u2223 x \u2194 IsUnit y \u2228 Associated x y", "start": [607, 1], "end": [617, 23], "kind": "commanddeclaration"}, {"full_name": "Irreducible.associated_of_dvd", "code": "theorem Irreducible.associated_of_dvd [Monoid \u03b1] {p q : \u03b1} (p_irr : Irreducible p)\n    (q_irr : Irreducible q) (dvd : p \u2223 q) : Associated p q", "start": [619, 1], "end": [621, 60], "kind": "commanddeclaration"}, {"full_name": "Irreducible.dvd_irreducible_iff_associated", "code": "theorem Irreducible.dvd_irreducible_iff_associated [Monoid \u03b1] {p q : \u03b1}\n    (pp : Irreducible p) (qp : Irreducible q) : p \u2223 q \u2194 Associated p q", "start": [624, 1], "end": [626, 56], "kind": "commanddeclaration"}, {"full_name": "Prime.associated_of_dvd", "code": "theorem Prime.associated_of_dvd [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (p_prime : Prime p)\n    (q_prime : Prime q) (dvd : p \u2223 q) : Associated p q", "start": [629, 1], "end": [631, 64], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_prime_iff_associated", "code": "theorem Prime.dvd_prime_iff_associated [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (pp : Prime p)\n    (qp : Prime q) : p \u2223 q \u2194 Associated p q", "start": [634, 1], "end": [636, 63], "kind": "commanddeclaration"}, {"full_name": "Associated.prime_iff", "code": "theorem Associated.prime_iff [CommMonoidWithZero \u03b1] {p q : \u03b1} (h : p ~\u1d64 q) : Prime p \u2194 Prime q", "start": [639, 1], "end": [640, 26], "kind": "commanddeclaration"}, {"full_name": "Associated.isUnit", "code": "protected theorem Associated.isUnit [Monoid \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) : IsUnit a \u2192 IsUnit b", "start": [643, 1], "end": [645, 48], "kind": "commanddeclaration"}, {"full_name": "Associated.isUnit_iff", "code": "theorem Associated.isUnit_iff [Monoid \u03b1] {a b : \u03b1} (h : a ~\u1d64 b) : IsUnit a \u2194 IsUnit b", "start": [648, 1], "end": [649, 28], "kind": "commanddeclaration"}, {"full_name": "Irreducible.isUnit_iff_not_associated_of_dvd", "code": "theorem Irreducible.isUnit_iff_not_associated_of_dvd [Monoid \u03b1]\n    {x y : \u03b1} (hx : Irreducible x) (hy : y \u2223 x) : IsUnit y \u2194 \u00ac Associated x y", "start": [652, 1], "end": [654, 78], "kind": "commanddeclaration"}, {"full_name": "Associated.irreducible", "code": "protected theorem Associated.irreducible [Monoid \u03b1] {p q : \u03b1} (h : p ~\u1d64 q) (hp : Irreducible p) :\n    Irreducible q", "start": [656, 1], "end": [666, 88], "kind": "commanddeclaration"}, {"full_name": "Associated.irreducible_iff", "code": "protected theorem Associated.irreducible_iff [Monoid \u03b1] {p q : \u03b1} (h : p ~\u1d64 q) :\n    Irreducible p \u2194 Irreducible q", "start": [669, 1], "end": [671, 38], "kind": "commanddeclaration"}, {"full_name": "Associated.of_mul_left", "code": "theorem Associated.of_mul_left [CancelCommMonoidWithZero \u03b1] {a b c d : \u03b1} (h : a * b ~\u1d64 c * d)\n    (h\u2081 : a ~\u1d64 c) (ha : a \u2260 0) : b ~\u1d64 d", "start": [674, 1], "end": [682, 61], "kind": "commanddeclaration"}, {"full_name": "Associated.of_mul_right", "code": "theorem Associated.of_mul_right [CancelCommMonoidWithZero \u03b1] {a b c d : \u03b1} :\n    a * b ~\u1d64 c * d \u2192 b ~\u1d64 d \u2192 b \u2260 0 \u2192 a ~\u1d64 c", "start": [685, 1], "end": [687, 60], "kind": "commanddeclaration"}, {"full_name": "Associated.of_pow_associated_of_prime", "code": "theorem Associated.of_pow_associated_of_prime [CancelCommMonoidWithZero \u03b1] {p\u2081 p\u2082 : \u03b1} {k\u2081 k\u2082 : \u2115}\n    (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2081 : 0 < k\u2081) (h : p\u2081 ^ k\u2081 ~\u1d64 p\u2082 ^ k\u2082) : p\u2081 ~\u1d64 p\u2082", "start": [690, 1], "end": [696, 32], "kind": "commanddeclaration"}, {"full_name": "Associated.of_pow_associated_of_prime'", "code": "theorem Associated.of_pow_associated_of_prime' [CancelCommMonoidWithZero \u03b1] {p\u2081 p\u2082 : \u03b1} {k\u2081 k\u2082 : \u2115}\n    (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2082 : 0 < k\u2082) (h : p\u2081 ^ k\u2081 ~\u1d64 p\u2082 ^ k\u2082) : p\u2081 ~\u1d64 p\u2082", "start": [699, 1], "end": [701, 55], "kind": "commanddeclaration"}, {"full_name": "units_eq_one", "code": "theorem units_eq_one (u : \u03b1\u02e3) : u = 1", "start": [708, 1], "end": [709, 24], "kind": "commanddeclaration"}, {"full_name": "associated_iff_eq", "code": "theorem associated_iff_eq {x y : \u03b1} : x ~\u1d64 y \u2194 x = y", "start": [712, 1], "end": [717, 8], "kind": "commanddeclaration"}, {"full_name": "associated_eq_eq", "code": "theorem associated_eq_eq : (Associated : \u03b1 \u2192 \u03b1 \u2192 Prop) = Eq", "start": [720, 1], "end": [722, 25], "kind": "commanddeclaration"}, {"full_name": "prime_dvd_prime_iff_eq", "code": "theorem prime_dvd_prime_iff_eq {M : Type*} [CancelCommMonoidWithZero M] [Unique M\u02e3] {p q : M}\n    (pp : Prime p) (qp : Prime q) : p \u2223 q \u2194 p = q", "start": [725, 1], "end": [727, 58], "kind": "commanddeclaration"}, {"full_name": "eq_of_prime_pow_eq", "code": "theorem eq_of_prime_pow_eq (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2081 : 0 < k\u2081)\n    (h : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082) : p\u2081 = p\u2082", "start": [736, 1], "end": [739, 49], "kind": "commanddeclaration"}, {"full_name": "eq_of_prime_pow_eq'", "code": "theorem eq_of_prime_pow_eq' (hp\u2081 : Prime p\u2081) (hp\u2082 : Prime p\u2082) (hk\u2081 : 0 < k\u2082)\n    (h : p\u2081 ^ k\u2081 = p\u2082 ^ k\u2082) : p\u2081 = p\u2082", "start": [742, 1], "end": [745, 50], "kind": "commanddeclaration"}, {"full_name": "Associates", "code": "abbrev Associates (\u03b1 : Type*) [Monoid \u03b1] : Type _ :=\n  Quotient (Associated.setoid \u03b1)", "start": [750, 1], "end": [754, 33], "kind": "commanddeclaration"}, {"full_name": "Associates.mk", "code": "protected abbrev mk {\u03b1 : Type*} [Monoid \u03b1] (a : \u03b1) : Associates \u03b1 :=\n  \u27e6a\u27e7", "start": [761, 1], "end": [763, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_eq_mk_iff_associated", "code": "theorem mk_eq_mk_iff_associated [Monoid \u03b1] {a b : \u03b1} : Associates.mk a = Associates.mk b \u2194 a ~\u1d64 b", "start": [769, 1], "end": [770, 38], "kind": "commanddeclaration"}, {"full_name": "Associates.quotient_mk_eq_mk", "code": "theorem quotient_mk_eq_mk [Monoid \u03b1] (a : \u03b1) : \u27e6a\u27e7 = Associates.mk a", "start": [773, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.quot_mk_eq_mk", "code": "theorem quot_mk_eq_mk [Monoid \u03b1] (a : \u03b1) : Quot.mk Setoid.r a = Associates.mk a", "start": [777, 1], "end": [778, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.forall_associated", "code": "theorem forall_associated [Monoid \u03b1] {p : Associates \u03b1 \u2192 Prop} :\n    (\u2200 a, p a) \u2194 \u2200 a, p (Associates.mk a)", "start": [781, 1], "end": [783, 65], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_surjective", "code": "theorem mk_surjective [Monoid \u03b1] : Function.Surjective (@Associates.mk \u03b1 _)", "start": [786, 1], "end": [787, 40], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_one", "code": "@[simp]\ntheorem mk_one [Monoid \u03b1] : Associates.mk (1 : \u03b1) = 1", "start": [793, 1], "end": [795, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.one_eq_mk_one", "code": "theorem one_eq_mk_one [Monoid \u03b1] : (1 : Associates \u03b1) = Associates.mk 1", "start": [798, 1], "end": [799, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.bot_eq_one", "code": "theorem bot_eq_one [Monoid \u03b1] : (\u22a5 : Associates \u03b1) = 1", "start": [805, 1], "end": [806, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.exists_rep", "code": "theorem exists_rep [Monoid \u03b1] (a : Associates \u03b1) : \u2203 a0 : \u03b1, Associates.mk a0 = a", "start": [809, 1], "end": [810, 20], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_injective", "code": "theorem mk_injective [Monoid \u03b1] [Unique (Units \u03b1)] : Function.Injective (@Associates.mk \u03b1 _)", "start": [822, 1], "end": [823, 78], "kind": "commanddeclaration"}, {"full_name": "Associates.instMul", "code": "instance instMul : Mul (Associates \u03b1) :=\n  \u27e8fun a' b' =>\n    (Quotient.liftOn\u2082 a' b' fun a b => \u27e6a * b\u27e7) fun a\u2081 a\u2082 b\u2081 b\u2082 \u27e8c\u2081, h\u2081\u27e9 \u27e8c\u2082, h\u2082\u27e9 =>\n      Quotient.sound <| \u27e8c\u2081 * c\u2082, by\n        rw [\u2190 h\u2081, \u2190 h\u2082]\n        simp only [Units.val_mul, mul_left_comm, mul_comm]\u27e9\u27e9", "start": [830, 1], "end": [835, 61], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_mul_mk", "code": "theorem mk_mul_mk {x y : \u03b1} : Associates.mk x * Associates.mk y = Associates.mk (x * y)", "start": [837, 1], "end": [838, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.instCommMonoid", "code": "instance instCommMonoid : CommMonoid (Associates \u03b1) where\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  mul_one a' := Quotient.inductionOn a' <| fun a => show \u27e6a * 1\u27e7 = \u27e6a\u27e7 by simp\n  one_mul a' := Quotient.inductionOn a' <| fun a => show \u27e61 * a\u27e7 = \u27e6a\u27e7 by simp\n  mul_assoc a' b' c' :=\n    Quotient.inductionOn\u2083 a' b' c' <| fun a b c =>\n      show \u27e6a * b * c\u27e7 = \u27e6a * (b * c)\u27e7 by rw [mul_assoc]\n  mul_comm a' b' :=\n    Quotient.inductionOn\u2082 a' b' <| fun a b => show \u27e6a * b\u27e7 = \u27e6b * a\u27e7 by rw [mul_comm]", "start": [841, 1], "end": [850, 86], "kind": "commanddeclaration"}, {"full_name": "Associates.instPreorder", "code": "instance instPreorder : Preorder (Associates \u03b1) where\n  le := Dvd.dvd\n  le_refl := dvd_refl\n  le_trans a b c := dvd_trans", "start": [852, 1], "end": [855, 30], "kind": "commanddeclaration"}, {"full_name": "Associates.mkMonoidHom", "code": "protected def mkMonoidHom : \u03b1 \u2192* Associates \u03b1 :=\n  {\n    toFun := Associates.mk\n    map_one' := mk_one\n    map_mul' := fun _ _ => mk_mul_mk}", "start": [857, 1], "end": [862, 38], "kind": "commanddeclaration"}, {"full_name": "Associates.mkMonoidHom_apply", "code": "@[simp]\ntheorem mkMonoidHom_apply (a : \u03b1) : Associates.mkMonoidHom a = Associates.mk a", "start": [865, 1], "end": [867, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.associated_map_mk", "code": "theorem associated_map_mk {f : Associates \u03b1 \u2192* \u03b1} (hinv : Function.RightInverse f Associates.mk)\n    (a : \u03b1) : a ~\u1d64 f (Associates.mk a)", "start": [870, 1], "end": [872, 69], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_pow", "code": "theorem mk_pow (a : \u03b1) (n : \u2115) : Associates.mk (a ^ n) = Associates.mk a ^ n", "start": [875, 1], "end": [876, 64], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_eq_le", "code": "theorem dvd_eq_le : ((\u00b7 \u2223 \u00b7) : Associates \u03b1 \u2192 Associates \u03b1 \u2192 Prop) = (\u00b7 \u2264 \u00b7)", "start": [879, 1], "end": [880, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.mul_eq_one_iff", "code": "theorem mul_eq_one_iff {x y : Associates \u03b1} : x * y = 1 \u2194 x = 1 \u2227 y = 1", "start": [883, 1], "end": [889, 49], "kind": "commanddeclaration"}, {"full_name": "Associates.units_eq_one", "code": "theorem units_eq_one (u : (Associates \u03b1)\u02e3) : u = 1", "start": [892, 1], "end": [893, 43], "kind": "commanddeclaration"}, {"full_name": "Associates.uniqueUnits", "code": "instance uniqueUnits : Unique (Associates \u03b1)\u02e3 where\n  default := 1\n  uniq := Associates.units_eq_one", "start": [896, 1], "end": [898, 34], "kind": "commanddeclaration"}, {"full_name": "Associates.coe_unit_eq_one", "code": "theorem coe_unit_eq_one (u : (Associates \u03b1)\u02e3) : (u : Associates \u03b1) = 1", "start": [901, 1], "end": [901, 82], "kind": "commanddeclaration"}, {"full_name": "Associates.isUnit_iff_eq_one", "code": "theorem isUnit_iff_eq_one (a : Associates \u03b1) : IsUnit a \u2194 a = 1", "start": [904, 1], "end": [905, 79], "kind": "commanddeclaration"}, {"full_name": "Associates.isUnit_iff_eq_bot", "code": "theorem isUnit_iff_eq_bot {a : Associates \u03b1} : IsUnit a \u2194 a = \u22a5", "start": [908, 1], "end": [909, 48], "kind": "commanddeclaration"}, {"full_name": "Associates.isUnit_mk", "code": "theorem isUnit_mk {a : \u03b1} : IsUnit (Associates.mk a) \u2194 IsUnit a", "start": [912, 1], "end": [916, 46], "kind": "commanddeclaration"}, {"full_name": "Associates.mul_mono", "code": "theorem mul_mono {a b c d : Associates \u03b1} (h\u2081 : a \u2264 b) (h\u2082 : c \u2264 d) : a * c \u2264 b * d", "start": [921, 1], "end": [924, 64], "kind": "commanddeclaration"}, {"full_name": "Associates.one_le", "code": "theorem one_le {a : Associates \u03b1} : 1 \u2264 a", "start": [927, 1], "end": [928, 26], "kind": "commanddeclaration"}, {"full_name": "Associates.le_mul_right", "code": "theorem le_mul_right {a b : Associates \u03b1} : a \u2264 a * b", "start": [931, 1], "end": [932, 11], "kind": "commanddeclaration"}, {"full_name": "Associates.le_mul_left", "code": "theorem le_mul_left {a b : Associates \u03b1} : a \u2264 b * a", "start": [935, 1], "end": [935, 93], "kind": "commanddeclaration"}, {"full_name": "Associates.instOrderBot", "code": "instance instOrderBot : OrderBot (Associates \u03b1) where\n  bot := 1\n  bot_le _ := one_le", "start": [938, 1], "end": [940, 21], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_of_mk_le_mk", "code": "theorem dvd_of_mk_le_mk {a b : \u03b1} : Associates.mk a \u2264 Associates.mk b \u2192 a \u2223 b", "start": [944, 1], "end": [955, 37], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_le_mk_of_dvd", "code": "theorem mk_le_mk_of_dvd {a b : \u03b1} : a \u2223 b \u2192 Associates.mk a \u2264 Associates.mk b", "start": [958, 1], "end": [959, 39], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_le_mk_iff_dvd_iff", "code": "theorem mk_le_mk_iff_dvd_iff {a b : \u03b1} : Associates.mk a \u2264 Associates.mk b \u2194 a \u2223 b", "start": [962, 1], "end": [963, 44], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_dvd_mk", "code": "theorem mk_dvd_mk {a b : \u03b1} : Associates.mk a \u2223 Associates.mk b \u2194 a \u2223 b", "start": [966, 1], "end": [967, 44], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_eq_zero", "code": "@[simp]\ntheorem mk_eq_zero {a : \u03b1} : Associates.mk a = 0 \u2194 a = 0", "start": [982, 1], "end": [984, 90], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_ne_zero", "code": "theorem mk_ne_zero {a : \u03b1} : Associates.mk a \u2260 0 \u2194 a \u2260 0", "start": [987, 1], "end": [988, 23], "kind": "commanddeclaration"}, {"full_name": "Associates.exists_non_zero_rep", "code": "theorem exists_non_zero_rep {a : Associates \u03b1} : a \u2260 0 \u2192 \u2203 a0 : \u03b1, a0 \u2260 0 \u2227 Associates.mk a0 = a", "start": [997, 1], "end": [998, 79], "kind": "commanddeclaration"}, {"full_name": "Associates.instCommMonoidWithZero", "code": "instance instCommMonoidWithZero : CommMonoidWithZero (Associates \u03b1) where\n    zero_mul := by\n      rintro \u27e8a\u27e9\n      show Associates.mk (0 * a) = Associates.mk 0\n      rw [zero_mul]\n    mul_zero := by\n      rintro \u27e8a\u27e9\n      show Associates.mk (a * 0) = Associates.mk 0\n      rw [mul_zero]", "start": [1007, 1], "end": [1015, 20], "kind": "commanddeclaration"}, {"full_name": "Associates.instOrderTop", "code": "instance instOrderTop : OrderTop (Associates \u03b1) where\n  top := 0\n  le_top a := \u27e80, (mul_zero a).symm\u27e9", "start": [1017, 1], "end": [1019, 37], "kind": "commanddeclaration"}, {"full_name": "Associates.instBoundedOrder", "code": "instance instBoundedOrder : BoundedOrder (Associates \u03b1) where", "start": [1021, 1], "end": [1021, 62], "kind": "commanddeclaration"}, {"full_name": "Associates.Prime.le_or_le", "code": "theorem Prime.le_or_le {p : Associates \u03b1} (hp : Prime p) {a b : Associates \u03b1} (h : p \u2264 a * b) :\n    p \u2264 a \u2228 p \u2264 b", "start": [1027, 1], "end": [1029, 15], "kind": "commanddeclaration"}, {"full_name": "Associates.prime_mk", "code": "theorem prime_mk (p : \u03b1) : Prime (Associates.mk p) \u2194 Prime p", "start": [1032, 1], "end": [1046, 50], "kind": "commanddeclaration"}, {"full_name": "Associates.irreducible_mk", "code": "theorem irreducible_mk (a : \u03b1) : Irreducible (Associates.mk a) \u2194 Irreducible a", "start": [1049, 1], "end": [1060, 44], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_dvdNotUnit_mk_iff", "code": "theorem mk_dvdNotUnit_mk_iff {a b : \u03b1} :\n    DvdNotUnit (Associates.mk a) (Associates.mk b) \u2194 DvdNotUnit a b", "start": [1063, 1], "end": [1082, 36], "kind": "commanddeclaration"}, {"full_name": "Associates.dvdNotUnit_of_lt", "code": "theorem dvdNotUnit_of_lt {a b : Associates \u03b1} (hlt : a < b) : DvdNotUnit a b", "start": [1085, 1], "end": [1094, 7], "kind": "commanddeclaration"}, {"full_name": "Associates.irreducible_iff_prime_iff", "code": "theorem irreducible_iff_prime_iff :\n    (\u2200 a : \u03b1, Irreducible a \u2194 Prime a) \u2194 \u2200 a : Associates \u03b1, Irreducible a \u2194 Prime a", "start": [1097, 1], "end": [1099, 56], "kind": "commanddeclaration"}, {"full_name": "Associates.instPartialOrder", "code": "instance instPartialOrder : PartialOrder (Associates \u03b1) where\n    le_antisymm := fun a' b' =>\n      Quotient.inductionOn\u2082 a' b' fun _ _ hab hba =>\n        Quot.sound <| associated_of_dvd_dvd (dvd_of_mk_le_mk hab) (dvd_of_mk_le_mk hba)", "start": [1108, 1], "end": [1111, 88], "kind": "commanddeclaration"}, {"full_name": "Associates.instOrderedCommMonoid", "code": "instance instOrderedCommMonoid : OrderedCommMonoid (Associates \u03b1) where\n    mul_le_mul_left := fun a _ \u27e8d, hd\u27e9 c => hd.symm \u25b8 mul_assoc c a d \u25b8 le_mul_right", "start": [1113, 1], "end": [1114, 85], "kind": "commanddeclaration"}, {"full_name": "Associates.instCancelCommMonoidWithZero", "code": "instance instCancelCommMonoidWithZero : CancelCommMonoidWithZero (Associates \u03b1) :=\n{ (by infer_instance : CommMonoidWithZero (Associates \u03b1)) with\n  mul_left_cancel_of_ne_zero := by\n    rintro \u27e8a\u27e9 \u27e8b\u27e9 \u27e8c\u27e9 ha h\n    rcases Quotient.exact' h with \u27e8u, hu\u27e9\n    have hu : a * (b * \u2191u) = a * c := by rwa [\u2190 mul_assoc]\n    exact Quotient.sound' \u27e8u, mul_left_cancel\u2080 (mk_ne_zero.1 ha) hu\u27e9 }", "start": [1116, 1], "end": [1122, 71], "kind": "commanddeclaration"}, {"full_name": "Associates.le_of_mul_le_mul_left", "code": "theorem le_of_mul_le_mul_left (a b c : Associates \u03b1) (ha : a \u2260 0) : a * b \u2264 a * c \u2192 b \u2264 c", "start": [1127, 1], "end": [1128, 64], "kind": "commanddeclaration"}, {"full_name": "Associates.one_or_eq_of_le_of_prime", "code": "theorem one_or_eq_of_le_of_prime : \u2200 p m : Associates \u03b1, Prime p \u2192 m \u2264 p \u2192 m = 1 \u2228 m = p", "start": [1131, 1], "end": [1155, 92], "kind": "commanddeclaration"}, {"full_name": "Associates.dvdNotUnit_iff_lt", "code": "theorem dvdNotUnit_iff_lt {a b : Associates \u03b1} : DvdNotUnit a b \u2194 a < b", "start": [1163, 1], "end": [1164, 27], "kind": "commanddeclaration"}, {"full_name": "Associates.le_one_iff", "code": "theorem le_one_iff {p : Associates \u03b1} : p \u2264 1 \u2194 p = 1", "start": [1167, 1], "end": [1167, 101], "kind": "commanddeclaration"}, {"full_name": "DvdNotUnit.isUnit_of_irreducible_right", "code": "theorem DvdNotUnit.isUnit_of_irreducible_right [CommMonoidWithZero \u03b1] {p q : \u03b1}\n    (h : DvdNotUnit p q) (hq : Irreducible q) : IsUnit p", "start": [1176, 1], "end": [1179, 67], "kind": "commanddeclaration"}, {"full_name": "not_irreducible_of_not_unit_dvdNotUnit", "code": "theorem not_irreducible_of_not_unit_dvdNotUnit [CommMonoidWithZero \u03b1] {p q : \u03b1} (hp : \u00acIsUnit p)\n    (h : DvdNotUnit p q) : \u00acIrreducible q", "start": [1182, 1], "end": [1184, 38], "kind": "commanddeclaration"}, {"full_name": "DvdNotUnit.not_unit", "code": "theorem DvdNotUnit.not_unit [CommMonoidWithZero \u03b1] {p q : \u03b1} (hp : DvdNotUnit p q) : \u00acIsUnit q", "start": [1187, 1], "end": [1189, 95], "kind": "commanddeclaration"}, {"full_name": "dvdNotUnit_of_dvdNotUnit_associated", "code": "theorem dvdNotUnit_of_dvdNotUnit_associated [CommMonoidWithZero \u03b1] [Nontrivial \u03b1] {p q r : \u03b1}\n    (h : DvdNotUnit p q) (h' : Associated q r) : DvdNotUnit p r", "start": [1192, 1], "end": [1197, 66], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_associated_mul", "code": "theorem isUnit_of_associated_mul [CancelCommMonoidWithZero \u03b1] {p b : \u03b1} (h : Associated (p * b) p)\n    (hp : p \u2260 0) : IsUnit b", "start": [1204, 1], "end": [1208, 29], "kind": "commanddeclaration"}, {"full_name": "DvdNotUnit.not_associated", "code": "theorem DvdNotUnit.not_associated [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (h : DvdNotUnit p q) :\n    \u00acAssociated p q", "start": [1211, 1], "end": [1216, 20], "kind": "commanddeclaration"}, {"full_name": "DvdNotUnit.ne", "code": "theorem DvdNotUnit.ne [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (h : DvdNotUnit p q) : p \u2260 q", "start": [1219, 1], "end": [1224, 23], "kind": "commanddeclaration"}, {"full_name": "pow_injective_of_not_unit", "code": "theorem pow_injective_of_not_unit [CancelCommMonoidWithZero \u03b1] {q : \u03b1} (hq : \u00acIsUnit q)\n    (hq' : q \u2260 0) : Function.Injective fun n : \u2115 => q ^ n", "start": [1227, 1], "end": [1231, 40], "kind": "commanddeclaration"}, {"full_name": "dvd_prime_pow", "code": "theorem dvd_prime_pow [CancelCommMonoidWithZero \u03b1] {p q : \u03b1} (hp : Prime p) (n : \u2115) :\n    q \u2223 p ^ n \u2194 \u2203 i \u2264 n, Associated q (p ^ i)", "start": [1234, 1], "end": [1247, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Basic.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Data/Fintype/Card.lean", "Mathlib/Data/Setoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean"], "premises": [{"full_name": "MulAction.orbit", "code": "@[to_additive \"The orbit of an element under an action.\"]\ndef orbit (a : \u03b1) :=\n  Set.range fun m : M => m \u2022 a", "start": [42, 1], "end": [45, 31], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_orbit_iff", "code": "@[to_additive]\ntheorem mem_orbit_iff {a\u2081 a\u2082 : \u03b1} : a\u2082 \u2208 orbit M a\u2081 \u2194 \u2203 x : M, x \u2022 a\u2081 = a\u2082", "start": [51, 1], "end": [53, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_orbit", "code": "@[to_additive (attr := simp)]\ntheorem mem_orbit (a : \u03b1) (x : M) : x \u2022 a \u2208 orbit M a", "start": [57, 1], "end": [59, 11], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_orbit_self", "code": "@[to_additive (attr := simp)]\ntheorem mem_orbit_self (a : \u03b1) : a \u2208 orbit M a", "start": [63, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit_nonempty", "code": "@[to_additive]\ntheorem orbit_nonempty (a : \u03b1) : Set.Nonempty (orbit M a)", "start": [69, 1], "end": [71, 23], "kind": "commanddeclaration"}, {"full_name": "MulAction.mapsTo_smul_orbit", "code": "@[to_additive]\ntheorem mapsTo_smul_orbit (m : M) (a : \u03b1) : Set.MapsTo ((\u00b7 \u2022 \u00b7) m) (orbit M a) (orbit M a)", "start": [75, 1], "end": [77, 60], "kind": "commanddeclaration"}, {"full_name": "MulAction.smul_orbit_subset", "code": "@[to_additive]\ntheorem smul_orbit_subset (m : M) (a : \u03b1) : m \u2022 orbit M a \u2286 orbit M a", "start": [81, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit_smul_subset", "code": "@[to_additive]\ntheorem orbit_smul_subset (m : M) (a : \u03b1) : orbit M (m \u2022 a) \u2286 orbit M a", "start": [87, 1], "end": [89, 67], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit.coe_smul", "code": "@[to_additive (attr := simp)]\ntheorem orbit.coe_smul {a : \u03b1} {m : M} {a' : orbit M a} : \u2191(m \u2022 a') = m \u2022 (a' : \u03b1)", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.fixedPoints", "code": "@[to_additive \"The set of elements fixed under the whole action.\"]\ndef fixedPoints : Set \u03b1 :=\n  { a : \u03b1 | \u2200 m : M, m \u2022 a = a }", "start": [107, 1], "end": [110, 33], "kind": "commanddeclaration"}, {"full_name": "MulAction.fixedBy", "code": "@[to_additive \"`fixedBy m` is the set of elements fixed by `m`.\"]\ndef fixedBy (m : M) : Set \u03b1 :=\n  { x | m \u2022 x = x }", "start": [114, 1], "end": [117, 20], "kind": "commanddeclaration"}, {"full_name": "MulAction.fixed_eq_iInter_fixedBy", "code": "@[to_additive]\ntheorem fixed_eq_iInter_fixedBy : fixedPoints M \u03b1 = \u22c2 m : M, fixedBy M \u03b1 m", "start": [121, 1], "end": [124, 88], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_fixedPoints", "code": "@[to_additive (attr := simp)]\ntheorem mem_fixedPoints {a : \u03b1} : a \u2208 fixedPoints M \u03b1 \u2194 \u2200 m : M, m \u2022 a = a", "start": [130, 1], "end": [132, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_fixedBy", "code": "@[to_additive (attr := simp)]\ntheorem mem_fixedBy {m : M} {a : \u03b1} : a \u2208 fixedBy M \u03b1 m \u2194 m \u2022 a = a", "start": [136, 1], "end": [138, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_fixedPoints'", "code": "@[to_additive]\ntheorem mem_fixedPoints' {a : \u03b1} : a \u2208 fixedPoints M \u03b1 \u2194 \u2200 a', a' \u2208 orbit M a \u2192 a' = a", "start": [142, 1], "end": [147, 36], "kind": "commanddeclaration"}, {"full_name": "MulAction.Stabilizer.submonoid", "code": "@[to_additive \"The stabilizer of m point `a` as an additive submonoid of `M`.\"]\ndef Stabilizer.submonoid (a : \u03b1) : Submonoid M where\n  carrier := { m | m \u2022 a = a }\n  one_mem' := one_smul _ a\n  mul_mem' {m m'} (ha : m \u2022 a = a) (hb : m' \u2022 a = a) :=\n    show (m * m') \u2022 a = a by rw [\u2190 smul_smul, hb, ha]", "start": [153, 1], "end": [159, 54], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_stabilizer_submonoid_iff", "code": "@[to_additive (attr := simp)]\ntheorem mem_stabilizer_submonoid_iff {a : \u03b1} {m : M} : m \u2208 Stabilizer.submonoid M a \u2194 m \u2022 a = a", "start": [163, 1], "end": [165, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit_eq_univ", "code": "@[to_additive]\ntheorem orbit_eq_univ [IsPretransitive M \u03b1] (a : \u03b1) : orbit M a = Set.univ", "start": [173, 1], "end": [175, 33], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_fixedPoints_iff_card_orbit_eq_one", "code": "@[to_additive mem_fixedPoints_iff_card_orbit_eq_one]\ntheorem mem_fixedPoints_iff_card_orbit_eq_one {a : \u03b1} [Fintype (orbit M a)] :\n    a \u2208 fixedPoints M \u03b1 \u2194 Fintype.card (orbit M a) = 1", "start": [181, 1], "end": [191, 65], "kind": "commanddeclaration"}, {"full_name": "MulAction.stabilizer", "code": "@[to_additive\n      \"The stabilizer of an element under an action, i.e. what sends the element to itself.\n      An additive subgroup.\"]\ndef stabilizer (a : \u03b1) : Subgroup G :=\n  { Stabilizer.submonoid G a with\n    inv_mem' := fun {m} (ha : m \u2022 a = a) => show m\u207b\u00b9 \u2022 a = a by rw [inv_smul_eq_iff, ha] }", "start": [201, 1], "end": [208, 91], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_stabilizer_iff", "code": "@[to_additive (attr := simp)]\ntheorem mem_stabilizer_iff {g : G} {a : \u03b1} : g \u2208 stabilizer G a \u2194 g \u2022 a = a", "start": [214, 1], "end": [216, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.smul_orbit", "code": "@[to_additive (attr := simp)]\ntheorem smul_orbit (g : G) (a : \u03b1) : g \u2022 orbit G a = orbit G a", "start": [224, 1], "end": [229, 70], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit_smul", "code": "@[to_additive (attr := simp)]\ntheorem orbit_smul (g : G) (a : \u03b1) : orbit G (g \u2022 a) = orbit G a", "start": [233, 1], "end": [238, 51], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbit_eq_iff", "code": "@[to_additive]\ntheorem orbit_eq_iff {a b : \u03b1} : orbit G a = orbit G b \u2194 a \u2208 orbit G b", "start": [251, 1], "end": [253, 70], "kind": "commanddeclaration"}, {"full_name": "MulAction.mem_orbit_smul", "code": "@[to_additive]\ntheorem mem_orbit_smul (g : G) (a : \u03b1) : a \u2208 orbit G (g \u2022 a)", "start": [259, 1], "end": [261, 41], "kind": "commanddeclaration"}, {"full_name": "MulAction.smul_mem_orbit_smul", "code": "@[to_additive]\ntheorem smul_mem_orbit_smul (g h : G) (a : \u03b1) : g \u2022 a \u2208 orbit G (h \u2022 a)", "start": [265, 1], "end": [267, 36], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel", "code": "@[to_additive \"The relation 'in the same orbit'.\"]\ndef orbitRel : Setoid \u03b1 where\n  r a b := a \u2208 orbit G b\n  iseqv :=\n    \u27e8mem_orbit_self, fun {a b} => by simp [orbit_eq_iff.symm, eq_comm], fun {a b} => by\n      simp (config := { contextual := true }) [orbit_eq_iff.symm, eq_comm]\u27e9", "start": [273, 1], "end": [279, 76], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel_apply", "code": "@[to_additive]\ntheorem orbitRel_apply {a b : \u03b1} : (orbitRel G \u03b1).Rel a b \u2194 a \u2208 orbit G b", "start": [285, 1], "end": [287, 10], "kind": "commanddeclaration"}, {"full_name": "MulAction.quotient_preimage_image_eq_union_mul", "code": "@[to_additive\n      \"When you take a set `U` in `\u03b1`, push it down to the quotient, and pull back, you get the\n      union of the orbit of `U` under `G`.\"]\ntheorem quotient_preimage_image_eq_union_mul (U : Set \u03b1) :\n    letI := orbitRel G \u03b1\n    Quotient.mk' \u207b\u00b9' (Quotient.mk' '' U) = \u22c3 g : G, (\u00b7 \u2022 \u00b7) g '' U", "start": [291, 1], "end": [314, 30], "kind": "commanddeclaration"}, {"full_name": "MulAction.disjoint_image_image_iff", "code": "@[to_additive]\ntheorem disjoint_image_image_iff {U V : Set \u03b1} :\n    letI := orbitRel G \u03b1\n    Disjoint (Quotient.mk' '' U) (Quotient.mk' '' V) \u2194 \u2200 x \u2208 U, \u2200 g : G, g \u2022 x \u2209 V", "start": [318, 1], "end": [332, 24], "kind": "commanddeclaration"}, {"full_name": "MulAction.image_inter_image_iff", "code": "@[to_additive]\ntheorem image_inter_image_iff (U V : Set \u03b1) :\n    letI := orbitRel G \u03b1\n    Quotient.mk' '' U \u2229 Quotient.mk' '' V = \u2205 \u2194 \u2200 x \u2208 U, \u2200 g : G, g \u2022 x \u2209 V", "start": [336, 1], "end": [340, 70], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel.Quotient", "code": "@[to_additive (attr := reducible)\n    \"The quotient by `AddAction.orbitRel`, given a name to enable dot notation.\"]\ndef orbitRel.Quotient : Type _ :=\n  _root_.Quotient <| orbitRel G \u03b1", "start": [346, 1], "end": [350, 34], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel.Quotient.orbit", "code": "@[to_additive \"The orbit corresponding to an element of the quotient by `AddAction.orbitRel`\"]\nnonrec def orbitRel.Quotient.orbit (x : orbitRel.Quotient G \u03b1) : Set \u03b1 :=\n  Quotient.liftOn' x (orbit G) fun _ _ => MulAction.orbit_eq_iff.2", "start": [356, 1], "end": [359, 67], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel.Quotient.orbit_mk", "code": "@[to_additive (attr := simp)]\ntheorem orbitRel.Quotient.orbit_mk (a : \u03b1) :\n    orbitRel.Quotient.orbit (Quotient.mk'' a : orbitRel.Quotient G \u03b1) = MulAction.orbit G a", "start": [363, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel.Quotient.mem_orbit", "code": "@[to_additive]\ntheorem orbitRel.Quotient.mem_orbit {a : \u03b1} {x : orbitRel.Quotient G \u03b1} :\n    a \u2208 x.orbit \u2194 Quotient.mk'' a = x", "start": [370, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitRel.Quotient.orbit_eq_orbit_out", "code": "@[to_additive \"Note that `h\u03c6 = quotient.out_eq'` is m useful choice here.\"]\ntheorem orbitRel.Quotient.orbit_eq_orbit_out (x : orbitRel.Quotient G \u03b1)\n    {\u03c6 : orbitRel.Quotient G \u03b1 \u2192 \u03b1} (h\u03c6 : letI := orbitRel G \u03b1; RightInverse \u03c6 Quotient.mk') :\n    orbitRel.Quotient.orbit x = MulAction.orbit G (\u03c6 x)", "start": [379, 1], "end": [384, 26], "kind": "commanddeclaration"}, {"full_name": "MulAction.selfEquivSigmaOrbits'", "code": "@[to_additive\n      \"Decomposition of a type `X` as a disjoint union of its orbits under an additive group action.\n\n      This version is expressed in terms of `AddAction.orbitRel.Quotient.orbit` instead of\n      `AddAction.orbit`, to avoid mentioning `Quotient.out'`. \"]\ndef selfEquivSigmaOrbits' : \u03b1 \u2243 \u03a3\u03c9 : \u03a9, \u03c9.orbit :=\n  letI := orbitRel G \u03b1\n  calc\n    \u03b1 \u2243 \u03a3\u03c9 : \u03a9, { a // Quotient.mk' a = \u03c9 } := (Equiv.sigmaFiberEquiv Quotient.mk').symm\n    _ \u2243 \u03a3\u03c9 : \u03a9, \u03c9.orbit :=\n      Equiv.sigmaCongrRight fun _ =>\n        Equiv.subtypeEquivRight fun _ => orbitRel.Quotient.mem_orbit.symm", "start": [393, 1], "end": [408, 74], "kind": "commanddeclaration"}, {"full_name": "MulAction.selfEquivSigmaOrbits", "code": "@[to_additive\n      \"Decomposition of a type `X` as a disjoint union of its orbits under an additive group\n      action.\"]\ndef selfEquivSigmaOrbits : \u03b1 \u2243 \u03a3\u03c9 : \u03a9, orbit G \u03c9.out' :=\n  (selfEquivSigmaOrbits' G \u03b1).trans <|\n    Equiv.sigmaCongrRight fun _ =>\n      Equiv.Set.ofEq <| orbitRel.Quotient.orbit_eq_orbit_out _ Quotient.out_eq'", "start": [412, 1], "end": [419, 80], "kind": "commanddeclaration"}, {"full_name": "MulAction.stabilizer_smul_eq_stabilizer_map_conj", "code": "theorem stabilizer_smul_eq_stabilizer_map_conj (g : G) (a : \u03b1) :\n    stabilizer G (g \u2022 a) = (stabilizer G a).map (MulAut.conj g).toMonoidHom", "start": [425, 1], "end": [430, 84], "kind": "commanddeclaration"}, {"full_name": "MulAction.stabilizerEquivStabilizerOfOrbitRel", "code": "noncomputable def stabilizerEquivStabilizerOfOrbitRel {a b : \u03b1} (h : (orbitRel G \u03b1).Rel a b) :\n    stabilizer G a \u2243* stabilizer G b :=\n  let g : G := Classical.choose h\n  have hg : g \u2022 b = a := Classical.choose_spec h\n  have this : stabilizer G a = (stabilizer G b).map (MulAut.conj g).toMonoidHom := by\n    rw [\u2190 hg, stabilizer_smul_eq_stabilizer_map_conj]\n  (MulEquiv.subgroupCongr this).trans ((MulAut.conj g).subgroupMap <| stabilizer G b).symm", "start": [433, 1], "end": [440, 91], "kind": "commanddeclaration"}, {"full_name": "AddAction.stabilizer_vadd_eq_stabilizer_map_conj", "code": "theorem stabilizer_vadd_eq_stabilizer_map_conj (g : G) (a : \u03b1) :\n    stabilizer G (g +\u1d65 a) = (stabilizer G a).map (AddAut.conj g).toAddMonoidHom", "start": [449, 1], "end": [455, 28], "kind": "commanddeclaration"}, {"full_name": "AddAction.stabilizerEquivStabilizerOfOrbitRel", "code": "noncomputable def stabilizerEquivStabilizerOfOrbitRel {a b : \u03b1} (h : (orbitRel G \u03b1).Rel a b) :\n    stabilizer G a \u2243+ stabilizer G b :=\n  let g : G := Classical.choose h\n  have hg : g +\u1d65 b = a := Classical.choose_spec h\n  have this : stabilizer G a = (stabilizer G b).map (AddAut.conj g).toAddMonoidHom := by\n    rw [\u2190 hg, stabilizer_vadd_eq_stabilizer_map_conj]\n  (AddEquiv.addSubgroupCongr this).trans ((AddAut.conj g).addSubgroupMap <| stabilizer G b).symm", "start": [458, 1], "end": [465, 97], "kind": "commanddeclaration"}, {"full_name": "smul_cancel_of_non_zero_divisor", "code": "theorem smul_cancel_of_non_zero_divisor {M R : Type*} [Monoid M] [NonUnitalNonAssocRing R]\n    [DistribMulAction M R] (k : M) (h : \u2200 x : R, k \u2022 x = 0 \u2192 x = 0) {a b : R} (h' : k \u2022 a = k \u2022 b) :\n    a = b", "start": [470, 1], "end": [478, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/LinearMap.lean", "imports": ["Mathlib/Algebra/Ring/CompTypeclasses.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Module/Pi.lean", "Mathlib/Algebra/Hom/GroupAction.lean"], "premises": [{"full_name": "IsLinearMap", "code": "structure IsLinearMap (R : Type u) {M : Type v} {M\u2082 : Type w} [Semiring R] [AddCommMonoid M]\n  [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082] (f : M \u2192 M\u2082) : Prop where\n  \n  map_add : \u2200 x y, f (x + y) = f x + f y\n  \n  map_smul : \u2200 (c : R) (x), f (c \u2022 x) = c \u2022 f x", "start": [70, 1], "end": [79, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap", "code": "structure LinearMap {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S) (M : Type*)\n    (M\u2082 : Type*) [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082] extends\n    AddHom M M\u2082 where\n  \n  protected map_smul' : \u2200 (r : R) (x : M), toFun (r \u2022 x) = \u03c3 r \u2022 toFun x", "start": [84, 1], "end": [95, 73], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass", "code": "class SemilinearMapClass (F : Type*) {R S : outParam (Type*)} [Semiring R] [Semiring S]\n  (\u03c3 : outParam (R \u2192+* S)) (M M\u2082 : outParam (Type*)) [AddCommMonoid M] [AddCommMonoid M\u2082]\n  [Module R M] [Module S M\u2082] extends AddHomClass F M M\u2082 where\n  \n  map_smul\u209b\u2097 : \u2200 (f : F) (r : R) (x : M), f (r \u2022 x) = \u03c3 r \u2022 f x", "start": [114, 1], "end": [126, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMapClass", "code": "abbrev LinearMapClass (F : Type*) (R M M\u2082 : outParam (Type*)) [Semiring R] [AddCommMonoid M]\n    [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082] :=\n  SemilinearMapClass F (RingHom.id R) M M\u2082", "start": [139, 1], "end": [145, 43], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass.addMonoidHomClass", "code": "instance (priority := 100) addMonoidHomClass [SemilinearMapClass F \u03c3 M M\u2083] :\n    AddMonoidHomClass F M M\u2083 :=\n  { SemilinearMapClass.toAddHomClass with\n    map_zero := fun f \u21a6\n      show f 0 = 0 by\n        rw [\u2190 zero_smul R (0 : M), map_smul\u209b\u2097]\n        simp }", "start": [158, 1], "end": [164, 15], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass.distribMulActionHomClass", "code": "instance (priority := 100) distribMulActionHomClass [LinearMapClass F R M M\u2082] :\n    DistribMulActionHomClass F R M M\u2082 :=\n  { SemilinearMapClass.addMonoidHomClass F with\n    map_smul := fun f c x \u21a6 by rw [map_smul\u209b\u2097, RingHom.id_apply] }", "start": [166, 1], "end": [169, 67], "kind": "commanddeclaration"}, {"full_name": "SemilinearMapClass.map_smul_inv", "code": "theorem map_smul_inv {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] (c : S) (x : M) :\n    c \u2022 f x = f (\u03c3' c \u2022 x)", "start": [173, 1], "end": [174, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.semilinearMapClass", "code": "instance semilinearMapClass : SemilinearMapClass (M \u2192\u209b\u2097[\u03c3] M\u2083) \u03c3 M M\u2083 where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    cases f\n    cases g\n    congr\n    apply FunLike.coe_injective'\n    exact h\n  map_add f := f.map_add'\n  map_smul\u209b\u2097 := LinearMap.map_smul'", "start": [195, 1], "end": [204, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.instFunLike", "code": "instance instFunLike {\u03c3 : R \u2192+* S} : FunLike (M \u2192\u209b\u2097[\u03c3] M\u2083) M (\u03bb _ \u21a6 M\u2083) :=\n  { AddHomClass.toFunLike with }", "start": [211, 1], "end": [212, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toDistribMulActionHom", "code": "def toDistribMulActionHom (f : M \u2192\u2097[R] M\u2082) : DistribMulActionHom R M M\u2082 :=\n  { f with map_zero' := show f 0 = 0 from map_zero f }", "start": [214, 1], "end": [216, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toAddHom", "code": "@[simp]\ntheorem coe_toAddHom (f : M \u2192\u209b\u2097[\u03c3] M\u2083) : \u21d1f.toAddHom = f", "start": [219, 1], "end": [220, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toFun_eq_coe", "code": "theorem toFun_eq_coe {f : M \u2192\u209b\u2097[\u03c3] M\u2083} : f.toFun = (f : M \u2192 M\u2083)", "start": [223, 1], "end": [223, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext", "code": "@[ext]\ntheorem ext {f g : M \u2192\u209b\u2097[\u03c3] M\u2083} (h : \u2200 x, f x = g x) : f = g", "start": [226, 1], "end": [228, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.copy", "code": "protected def copy (f : M \u2192\u209b\u2097[\u03c3] M\u2083) (f' : M \u2192 M\u2083) (h : f' = \u21d1f) : M \u2192\u209b\u2097[\u03c3] M\u2083 where\n  toFun := f'\n  map_add' := h.symm \u25b8 f.map_add'\n  map_smul' := h.symm \u25b8 f.map_smul'", "start": [231, 1], "end": [236, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : M \u2192\u209b\u2097[\u03c3] M\u2083) (f' : M \u2192 M\u2083) (h : f' = \u21d1f) : \u21d1(f.copy f' h) = f'", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.copy_eq", "code": "theorem copy_eq (f : M \u2192\u209b\u2097[\u03c3] M\u2083) (f' : M \u2192 M\u2083) (h : f' = \u21d1f) : f.copy f' h = f", "start": [244, 1], "end": [245, 17], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_mk", "code": "@[simp]\ntheorem coe_mk {\u03c3 : R \u2192+* S} (f : AddHom M M\u2083) (h) :\n    ((LinearMap.mk f h : M \u2192\u209b\u2097[\u03c3] M\u2083) : M \u2192 M\u2083) = f", "start": [250, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_addHom_mk", "code": "@[simp]\ntheorem coe_addHom_mk {\u03c3 : R \u2192+* S} (f : AddHom M M\u2083) (h) :\n    ((LinearMap.mk f h : M \u2192\u209b\u2097[\u03c3] M\u2083) : AddHom M M\u2083) = f", "start": [257, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id", "code": "def id : M \u2192\u2097[R] M :=\n  { DistribMulActionHom.id R with }", "start": [262, 1], "end": [264, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id_apply", "code": "theorem id_apply (x : M) : @id R M _ _ _ x = x", "start": [267, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id_coe", "code": "@[simp, norm_cast]\ntheorem id_coe : ((LinearMap.id : M \u2192\u2097[R] M) : M \u2192 M) = _root_.id", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id'", "code": "@[simps]\ndef id' {\u03c3 : R \u2192+* R} [RingHomId \u03c3] : M \u2192\u209b\u2097[\u03c3] M where\n  toFun x := x\n  map_add' x y := rfl\n  map_smul' r x := by\n    have := (RingHomId.eq_id : \u03c3 = _)\n    subst this\n    rfl", "start": [276, 1], "end": [285, 8], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id'_coe", "code": "@[simp, norm_cast]\ntheorem id'_coe {\u03c3 : R \u2192+* R} [RingHomId \u03c3] : ((id' : M \u2192\u209b\u2097[\u03c3] M) : M \u2192 M) = _root_.id", "start": [287, 1], "end": [289, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isLinear", "code": "theorem isLinear : IsLinearMap R f\u2097", "start": [305, 1], "end": [306, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_injective", "code": "theorem coe_injective : Injective (FunLike.coe : (M \u2192\u209b\u2097[\u03c3] M\u2083) \u2192 _)", "start": [311, 1], "end": [312, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.congr_arg", "code": "protected theorem congr_arg {x x' : M} : x = x' \u2192 f x = f x'", "start": [315, 1], "end": [316, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.congr_fun", "code": "protected theorem congr_fun (h : f = g) (x : M) : f x = g x", "start": [319, 1], "end": [321, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_iff", "code": "theorem ext_iff : f = g \u2194 \u2200 x, f x = g x", "start": [324, 1], "end": [325, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : M \u2192\u209b\u2097[\u03c3] M\u2083) (h) : (LinearMap.mk f h : M \u2192\u209b\u2097[\u03c3] M\u2083) = f", "start": [328, 1], "end": [330, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_add", "code": "protected theorem map_add (x y : M) : f (x + y) = f x + f y", "start": [335, 1], "end": [336, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_zero", "code": "protected theorem map_zero : f 0 = 0", "start": [339, 1], "end": [340, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul\u209b\u2097", "code": "protected theorem map_smul\u209b\u2097 (c : R) (x : M) : f (c \u2022 x) = \u03c3 c \u2022 f x", "start": [346, 1], "end": [347, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul", "code": "protected theorem map_smul (c : R) (x : M) : f\u2097 (c \u2022 x) = c \u2022 f\u2097 x", "start": [350, 1], "end": [351, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul_inv", "code": "protected theorem map_smul_inv {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] (c : S) (x : M) :\n    c \u2022 f x = f (\u03c3' c \u2022 x)", "start": [354, 1], "end": [355, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_eq_zero_iff", "code": "@[simp]\ntheorem map_eq_zero_iff (h : Function.Injective f) {x : M} : f x = 0 \u2194 x = 0", "start": [358, 1], "end": [360, 29], "kind": "commanddeclaration"}, {"full_name": "image_smul_set\u209b\u2097", "code": "@[simp]\ntheorem _root_.image_smul_set\u209b\u2097 [SemilinearMapClass F \u03c3 M M\u2083] (c : R) (s : Set M) :\n    h '' (c \u2022 s) = \u03c3 c \u2022 h '' s", "start": [369, 1], "end": [376, 86], "kind": "commanddeclaration"}, {"full_name": "preimage_smul_set\u209b\u2097", "code": "theorem _root_.preimage_smul_set\u209b\u2097 [SemilinearMapClass F \u03c3 M M\u2083] {c : R} (hc : IsUnit c)\n    (s : Set M\u2083) :\n    h \u207b\u00b9' (\u03c3 c \u2022 s) = c \u2022 h \u207b\u00b9' s", "start": [379, 1], "end": [389, 69], "kind": "commanddeclaration"}, {"full_name": "image_smul_set", "code": "theorem _root_.image_smul_set [LinearMapClass F R M M\u2082] (c : R) (s : Set M) :\n    h '' (c \u2022 s) = c \u2022 h '' s", "start": [394, 1], "end": [396, 31], "kind": "commanddeclaration"}, {"full_name": "preimage_smul_set", "code": "theorem _root_.preimage_smul_set [LinearMapClass F R M M\u2082] {c : R} (hc : IsUnit c) (s : Set M\u2082) :\n    h \u207b\u00b9' (c \u2022 s) = c \u2022 h \u207b\u00b9' s", "start": [399, 1], "end": [401, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.CompatibleSMul", "code": "class CompatibleSMul (R S : Type*) [Semiring S] [SMul R M] [Module S M] [SMul R M\u2082]\n  [Module S M\u2082] : Prop where\n  \n  map_smul : \u2200 (f\u2097 : M \u2192\u2097[S] M\u2082) (c : R) (x : M), f\u2097 (c \u2022 x) = c \u2022 f\u2097 x", "start": [408, 1], "end": [416, 72], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsScalarTower.compatibleSMul", "code": "instance (priority := 100) IsScalarTower.compatibleSMul {R S : Type*} [Semiring S] [SMul R S]\n    [SMul R M] [Module S M] [IsScalarTower R S M] [SMul R M\u2082] [Module S M\u2082] [IsScalarTower R S M\u2082] :\n    CompatibleSMul M M\u2082 R S :=\n  \u27e8fun f\u2097 c x \u21a6 by rw [\u2190 smul_one_smul S c x, \u2190 smul_one_smul S c (f\u2097 x), map_smul]\u27e9", "start": [421, 1], "end": [424, 85], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul_of_tower", "code": "@[simp]\ntheorem map_smul_of_tower {R S : Type*} [Semiring S] [SMul R M] [Module S M] [SMul R M\u2082]\n    [Module S M\u2082] [CompatibleSMul M M\u2082 R S] (f\u2097 : M \u2192\u2097[S] M\u2082) (c : R) (x : M) :\n    f\u2097 (c \u2022 x) = c \u2022 f\u2097 x", "start": [427, 1], "end": [431, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAddMonoidHom", "code": "def toAddMonoidHom : M \u2192+ M\u2083 where\n  toFun := f\n  map_zero' := f.map_zero\n  map_add' := f.map_add", "start": [434, 1], "end": [438, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAddMonoidHom_coe", "code": "@[simp]\ntheorem toAddMonoidHom_coe : \u21d1f.toAddMonoidHom = f", "start": [441, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrictScalars", "code": "@[coe] def restrictScalars (f\u2097 : M \u2192\u2097[S] M\u2082) : M \u2192\u2097[R] M\u2082 where\n  toFun := f\u2097\n  map_add' := f\u2097.map_add\n  map_smul' := f\u2097.map_smul_of_tower", "start": [451, 1], "end": [459, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coeIsScalarTower", "code": "instance coeIsScalarTower : CoeHTCT (M \u2192\u2097[S] M\u2082) (M \u2192\u2097[R] M\u2082) :=\n  \u27e8restrictScalars R\u27e9", "start": [463, 1], "end": [464, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_restrictScalars", "code": "@[simp, norm_cast]\ntheorem coe_restrictScalars (f : M \u2192\u2097[S] M\u2082) : ((f : M \u2192\u2097[R] M\u2082) : M \u2192 M\u2082) = f", "start": [467, 1], "end": [469, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrictScalars_apply", "code": "theorem restrictScalars_apply (f\u2097 : M \u2192\u2097[S] M\u2082) (x) : restrictScalars R f\u2097 x = f\u2097 x", "start": [472, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (M \u2192\u2097[S] M\u2082) \u2192 M \u2192\u2097[R] M\u2082)", "start": [476, 1], "end": [478, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrictScalars_inj", "code": "@[simp]\ntheorem restrictScalars_inj (f\u2097 g\u2097 : M \u2192\u2097[S] M\u2082) :\n    f\u2097.restrictScalars R = g\u2097.restrictScalars R \u2194 f\u2097 = g\u2097", "start": [481, 1], "end": [484, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAddMonoidHom_injective", "code": "theorem toAddMonoidHom_injective :\n    Function.Injective (toAddMonoidHom : (M \u2192\u209b\u2097[\u03c3] M\u2083) \u2192 M \u2192+ M\u2083)", "start": [489, 1], "end": [491, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_ring", "code": "@[ext high]\ntheorem ext_ring {f g : R \u2192\u209b\u2097[\u03c3] M\u2083} (h : f 1 = g 1) : f = g", "start": [494, 1], "end": [497, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_ring_iff", "code": "theorem ext_ring_iff {\u03c3 : R \u2192+* R} {f g : R \u2192\u209b\u2097[\u03c3] M} : f = g \u2194 f 1 = g 1", "start": [500, 1], "end": [501, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_ring_op", "code": "@[ext high]\ntheorem ext_ring_op {\u03c3 : R\u1d50\u1d52\u1d56 \u2192+* S} {f g : R \u2192\u209b\u2097[\u03c3] M\u2083} (h : f (1 : R) = g (1 : R)) :\n    f = g", "start": [504, 1], "end": [513, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.toSemilinearMap", "code": "@[simps]\ndef _root_.RingHom.toSemilinearMap (f : R \u2192+* S) : R \u2192\u209b\u2097[f] S :=\n  { f with\n    map_smul' := f.map_mul }", "start": [518, 1], "end": [522, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp", "code": "def comp : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083 where\n  toFun := f \u2218 g\n  map_add' := by simp only [map_add, forall_const, Function.comp_apply]\n  map_smul' r x := by simp only [Function.comp_apply, map_smul\u209b\u2097, RingHomCompTriple.comp_apply]", "start": [535, 1], "end": [539, 96], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_apply", "code": "theorem comp_apply (x : M\u2081) : f.comp g x = f (g x)", "start": [549, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_comp", "code": "@[simp, norm_cast]\ntheorem coe_comp : (f.comp g : M\u2081 \u2192 M\u2083) = f \u2218 g", "start": [553, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_id", "code": "@[simp]\ntheorem comp_id : f.comp id = f", "start": [558, 1], "end": [560, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id_comp", "code": "@[simp]\ntheorem id_comp : id.comp f = f", "start": [563, 1], "end": [565, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_assoc", "code": "theorem comp_assoc\n    {R\u2084 : Type*} {M\u2084 : Type*} [Semiring R\u2084] [AddCommMonoid M\u2084] [Module R\u2084 M\u2084]\n    {\u03c3\u2083\u2084 : R\u2083 \u2192+* R\u2084} {\u03c3\u2082\u2084 : R\u2082 \u2192+* R\u2084} {\u03c3\u2081\u2084 : R\u2081 \u2192+* R\u2084}\n    [RingHomCompTriple \u03c3\u2082\u2083 \u03c3\u2083\u2084 \u03c3\u2082\u2084] [RingHomCompTriple \u03c3\u2081\u2083 \u03c3\u2083\u2084 \u03c3\u2081\u2084] [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2084 \u03c3\u2081\u2084]\n    (f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (h : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2084] M\u2084) :\n    ((h.comp g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2084] M\u2084).comp f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2084] M\u2084) = h.comp (g.comp f : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083)", "start": [568, 1], "end": [574, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.injective_linearMapComp_right", "code": "lemma _root_.Function.Surjective.injective_linearMapComp_right (hg : Surjective g) :\n    Injective fun f : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083 \u21a6 f.comp g :=\n  fun _ _ h \u21a6 ext <| hg.forall.2 (ext_iff.1 h)", "start": [579, 1], "end": [582, 47], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.cancel_right", "code": "@[simp]\ntheorem cancel_right (hg : Surjective g) : f.comp g = f'.comp g \u2194 f = f'", "start": [584, 1], "end": [586, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.injective_linearMapComp_left", "code": "lemma _root_.Function.Injective.injective_linearMapComp_left (hf : Injective f) :\n    Injective fun g : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082 \u21a6 f.comp g :=\n  fun g\u2081 g\u2082 (h : f.comp g\u2081 = f.comp g\u2082) \u21a6 ext fun x \u21a6 hf <| by rw [\u2190 comp_apply, h, comp_apply]", "start": [589, 1], "end": [592, 96], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.cancel_left", "code": "@[simp]\ntheorem cancel_left (hf : Injective f) : f.comp g = f.comp g' \u2194 g = g'", "start": [594, 1], "end": [596, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inverse", "code": "def inverse [Module R M] [Module S M\u2082] {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3']\n    (f : M \u2192\u209b\u2097[\u03c3] M\u2082) (g : M\u2082 \u2192 M) (h\u2081 : LeftInverse g f) (h\u2082 : RightInverse g f) :\n    M\u2082 \u2192\u209b\u2097[\u03c3'] M := by\n  dsimp [LeftInverse, Function.RightInverse] at h\u2081 h\u2082\n  exact\n    { toFun := g\n      map_add' := fun x y \u21a6 by rw [\u2190 h\u2081 (g (x + y)), \u2190 h\u2081 (g x + g y)]; simp [h\u2082]\n      map_smul' := fun a b \u21a6 by\n        dsimp only\n        rw [\u2190 h\u2081 (g (a \u2022 b)), \u2190 h\u2081 (\u03c3' a \u2022 g b)]\n        simp [h\u2082] }", "start": [603, 1], "end": [614, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_neg", "code": "protected theorem map_neg (x : M) : f (-x) = -f x", "start": [627, 1], "end": [628, 14], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_sub", "code": "protected theorem map_sub (x y : M) : f (x - y) = f x - f y", "start": [631, 1], "end": [632, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.CompatibleSMul.intModule", "code": "instance CompatibleSMul.intModule {S : Type*} [Semiring S] [Module S M] [Module S M\u2082] :\n    CompatibleSMul M M\u2082 \u2124 S :=\n  \u27e8fun f\u2097 c x \u21a6 by\n    induction c using Int.induction_on\n    case hz => simp\n    case hp n ih => simp [add_smul, ih]\n    case hn n ih => simp [sub_smul, ih]\u27e9", "start": [635, 1], "end": [641, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.CompatibleSMul.units", "code": "instance CompatibleSMul.units {R S : Type*} [Monoid R] [MulAction R M] [MulAction R M\u2082]\n    [Semiring S] [Module S M] [Module S M\u2082] [CompatibleSMul M M\u2082 R S] : CompatibleSMul M M\u2082 R\u02e3 S :=\n  \u27e8fun f\u2097 c x \u21a6 (CompatibleSMul.map_smul f\u2097 (c : R) x : _)\u27e9", "start": [644, 1], "end": [646, 60], "kind": "commanddeclaration"}, {"full_name": "Module.compHom.toLinearMap", "code": "@[simps]\ndef compHom.toLinearMap {R S : Type*} [Semiring R] [Semiring S] (g : R \u2192+* S) :\n    letI := compHom S g; R \u2192\u2097[R] S :=\n  letI := compHom S g\n  { toFun := (g : R \u2192 S)\n    map_add' := g.map_add\n    map_smul' := g.map_mul }", "start": [655, 1], "end": [662, 29], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.toLinearMap", "code": "@[coe]\ndef toLinearMap (f\u2097 : M \u2192+[R] M\u2082) : M \u2192\u2097[R] M\u2082 :=\n  { f\u2097 with }", "start": [672, 1], "end": [675, 14], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.coe_toLinearMap", "code": "@[simp]\ntheorem coe_toLinearMap (f : M \u2192+[R] M\u2082) : ((f : M \u2192\u2097[R] M\u2082) : M \u2192 M\u2082) = f", "start": [686, 1], "end": [688, 6], "kind": "commanddeclaration"}, {"full_name": "DistribMulActionHom.toLinearMap_injective", "code": "theorem toLinearMap_injective {f g : M \u2192+[R] M\u2082} (h : (f : M \u2192\u2097[R] M\u2082) = (g : M \u2192\u2097[R] M\u2082)) :\n    f = g", "start": [691, 1], "end": [694, 32], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.mk'", "code": "def mk' (f : M \u2192 M\u2082) (H : IsLinearMap R f) : M \u2192\u2097[R] M\u2082 where\n  toFun := f\n  map_add' := H.1\n  map_smul' := H.2", "start": [706, 1], "end": [710, 19], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.mk'_apply", "code": "@[simp]\ntheorem mk'_apply {f : M \u2192 M\u2082} (H : IsLinearMap R f) (x : M) : mk' f H x = f x", "start": [713, 1], "end": [715, 6], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.isLinearMap_smul", "code": "theorem isLinearMap_smul {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] (c : R) :\n    IsLinearMap R fun z : M \u21a6 c \u2022 z", "start": [718, 1], "end": [722, 34], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.isLinearMap_smul'", "code": "theorem isLinearMap_smul' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] (a : M) :\n    IsLinearMap R fun c : R \u21a6 c \u2022 a", "start": [725, 1], "end": [727, 69], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.map_zero", "code": "theorem map_zero : f (0 : M) = (0 : M\u2082)", "start": [732, 1], "end": [733, 23], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.isLinearMap_neg", "code": "theorem isLinearMap_neg : IsLinearMap R fun z : M \u21a6 -z", "start": [743, 1], "end": [744, 55], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.map_neg", "code": "theorem map_neg (x : M) : f (-x) = -f x", "start": [749, 1], "end": [750, 24], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.map_sub", "code": "theorem map_sub (x y) : f (x - y) = f x - f y", "start": [753, 1], "end": [754, 26], "kind": "commanddeclaration"}, {"full_name": "Module.End", "code": "abbrev Module.End (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] :=\n  M \u2192\u2097[R] M", "start": [761, 1], "end": [764, 12], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toNatLinearMap", "code": "def AddMonoidHom.toNatLinearMap [AddCommMonoid M] [AddCommMonoid M\u2082] (f : M \u2192+ M\u2082) : M \u2192\u2097[\u2115] M\u2082\n    where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := map_nsmul f", "start": [767, 1], "end": [772, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toNatLinearMap_injective", "code": "theorem AddMonoidHom.toNatLinearMap_injective [AddCommMonoid M] [AddCommMonoid M\u2082] :\n    Function.Injective (@AddMonoidHom.toNatLinearMap M M\u2082 _ _)", "start": [775, 1], "end": [779, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toIntLinearMap", "code": "def AddMonoidHom.toIntLinearMap [AddCommGroup M] [AddCommGroup M\u2082] (f : M \u2192+ M\u2082) : M \u2192\u2097[\u2124] M\u2082\n    where\n  toFun := f\n  map_add' := f.map_add\n  map_smul' := map_zsmul f", "start": [782, 1], "end": [787, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toIntLinearMap_injective", "code": "theorem AddMonoidHom.toIntLinearMap_injective [AddCommGroup M] [AddCommGroup M\u2082] :\n    Function.Injective (@AddMonoidHom.toIntLinearMap M M\u2082 _ _)", "start": [790, 1], "end": [794, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toIntLinearMap", "code": "@[simp]\ntheorem AddMonoidHom.coe_toIntLinearMap [AddCommGroup M] [AddCommGroup M\u2082] (f : M \u2192+ M\u2082) :\n    \u21d1f.toIntLinearMap = f", "start": [797, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toRatLinearMap", "code": "def AddMonoidHom.toRatLinearMap [AddCommGroup M] [Module \u211a M] [AddCommGroup M\u2082] [Module \u211a M\u2082]\n    (f : M \u2192+ M\u2082) : M \u2192\u2097[\u211a] M\u2082 :=\n  { f with map_smul' := map_rat_smul f }", "start": [803, 1], "end": [806, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.toRatLinearMap_injective", "code": "theorem AddMonoidHom.toRatLinearMap_injective [AddCommGroup M] [Module \u211a M] [AddCommGroup M\u2082]\n    [Module \u211a M\u2082] : Function.Injective (@AddMonoidHom.toRatLinearMap M M\u2082 _ _ _ _)", "start": [809, 1], "end": [813, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toRatLinearMap", "code": "@[simp]\ntheorem AddMonoidHom.coe_toRatLinearMap [AddCommGroup M] [Module \u211a M] [AddCommGroup M\u2082]\n    [Module \u211a M\u2082] (f : M \u2192+ M\u2082) : \u21d1f.toRatLinearMap = f", "start": [816, 1], "end": [819, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smul_apply", "code": "@[simp]\ntheorem smul_apply (a : S) (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : (a \u2022 f) x = a \u2022 f x", "start": [840, 1], "end": [842, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_smul", "code": "theorem coe_smul (a : S) (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : (a \u2022 f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = a \u2022 (f : M \u2192 M\u2082)", "start": [845, 1], "end": [846, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : M) : (0 : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) x = 0", "start": [881, 1], "end": [883, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_zero", "code": "@[simp]\ntheorem comp_zero (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) : (g.comp (0 : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = 0", "start": [886, 1], "end": [888, 69], "kind": "commanddeclaration"}, {"full_name": "LinearMap.zero_comp", "code": "@[simp]\ntheorem zero_comp (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : ((0 : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083).comp f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = 0", "start": [891, 1], "end": [893, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.default_def", "code": "@[simp]\ntheorem default_def : (default : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = 0", "start": [899, 1], "end": [901, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.add_apply", "code": "@[simp]\ntheorem add_apply (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : (f + g) x = f x + g x", "start": [911, 1], "end": [913, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.add_comp", "code": "theorem add_comp (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) :\n    ((h + g).comp f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = h.comp f + g.comp f", "start": [916, 1], "end": [918, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_add", "code": "theorem comp_add (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) :\n    (h.comp (f + g) : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = h.comp f + h.comp g", "start": [921, 1], "end": [923, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :=\n  FunLike.coe_injective.addCommMonoid _ rfl (fun _ _ \u21a6 rfl) fun _ _ \u21a6 rfl", "start": [926, 1], "end": [928, 74], "kind": "commanddeclaration"}, {"full_name": "LinearMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (x : M) : (-f) x = -f x", "start": [937, 1], "end": [939, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.neg_comp", "code": "@[simp]\ntheorem neg_comp (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083) : (-g).comp f = -g.comp f", "start": [942, 1], "end": [944, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_neg", "code": "@[simp]\ntheorem comp_neg (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (g : N\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083) : g.comp (-f) = -g.comp f", "start": [947, 1], "end": [949, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sub_apply", "code": "@[simp]\ntheorem sub_apply (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (x : M) : (f - g) x = f x - g x", "start": [959, 1], "end": [961, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sub_comp", "code": "theorem sub_comp (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g h : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083) :\n    (g - h).comp f = g.comp f - h.comp f", "start": [964, 1], "end": [966, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_sub", "code": "theorem comp_sub (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) (h : N\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] N\u2083) :\n    h.comp (g - f) = h.comp g - h.comp f", "start": [969, 1], "end": [971, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.addCommGroup", "code": "instance addCommGroup : AddCommGroup (M \u2192\u209b\u2097[\u03c3\u2081\u2082] N\u2082) :=\n  FunLike.coe_injective.addCommGroup _ rfl (fun _ _ \u21a6 rfl) (fun _ \u21a6 rfl) (fun _ _ \u21a6 rfl)\n    (fun _ _ \u21a6 rfl) fun _ _ \u21a6 rfl", "start": [974, 1], "end": [977, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smul_comp", "code": "theorem smul_comp (a : S\u2083) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n    (a \u2022 g).comp f = a \u2022 g.comp f", "start": [1001, 1], "end": [1003, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_smul", "code": "theorem comp_smul [Module R M\u2082] [Module R M\u2083] [SMulCommClass R S M\u2082] [DistribMulAction S M\u2083]\n    [SMulCommClass R S M\u2083] [CompatibleSMul M\u2083 M\u2082 S R] (g : M\u2083 \u2192\u2097[R] M\u2082) (a : S) (f : M \u2192\u2097[R] M\u2083) :\n    g.comp (a \u2022 f) = a \u2022 g.comp f", "start": [1007, 1], "end": [1010, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.module", "code": "instance module : Module S (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) where\n  add_smul _ _ _ := ext fun _ \u21a6 add_smul _ _ _\n  zero_smul _ := ext fun _ \u21a6 zero_smul _ _", "start": [1019, 1], "end": [1021, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.one_eq_id", "code": "theorem one_eq_id : (1 : Module.End R M) = id", "start": [1045, 1], "end": [1046, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_eq_comp", "code": "theorem mul_eq_comp (f g : Module.End R M) : f * g = f.comp g", "start": [1049, 1], "end": [1050, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.one_apply", "code": "@[simp]\ntheorem one_apply (x : M) : (1 : Module.End R M) x = x", "start": [1053, 1], "end": [1055, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_apply", "code": "@[simp]\ntheorem mul_apply (f g : Module.End R M) (x : M) : (f * g) x = f (g x)", "start": [1058, 1], "end": [1060, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_one", "code": "theorem coe_one : \u21d1(1 : Module.End R M) = _root_.id", "start": [1063, 1], "end": [1064, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_mul", "code": "theorem coe_mul (f g : Module.End R M) : \u21d1(f * g) = f \u2218 g", "start": [1067, 1], "end": [1068, 6], "kind": "commanddeclaration"}, {"full_name": "Module.End.monoid", "code": "instance _root_.Module.End.monoid : Monoid (Module.End R M) where\n  mul := (\u00b7 * \u00b7)\n  one := (1 : M \u2192\u2097[R] M)\n  mul_assoc f g h := LinearMap.ext fun x \u21a6 rfl\n  mul_one := comp_id\n  one_mul := id_comp", "start": [1071, 1], "end": [1076, 21], "kind": "commanddeclaration"}, {"full_name": "Module.End.semiring", "code": "instance _root_.Module.End.semiring : Semiring (Module.End R M) :=\n  { AddMonoidWithOne.unary, Module.End.monoid, LinearMap.addCommMonoid with\n    mul_zero := comp_zero\n    zero_mul := zero_comp\n    left_distrib := fun _ _ _ \u21a6 comp_add _ _ _\n    right_distrib := fun _ _ _ \u21a6 add_comp _ _ _\n    natCast := fun n \u21a6 n \u2022 (1 : M \u2192\u2097[R] M)\n    natCast_zero := zero_smul \u2115 (1 : M \u2192\u2097[R] M)\n    natCast_succ := fun n \u21a6 (AddMonoid.nsmul_succ n (1 : M \u2192\u2097[R] M)).trans (add_comm _ _) }", "start": [1079, 1], "end": [1087, 92], "kind": "commanddeclaration"}, {"full_name": "Module.End.natCast_apply", "code": "@[simp]\ntheorem _root_.Module.End.natCast_apply (n : \u2115) (m : M) : (\u2191n : Module.End R M) m = n \u2022 m", "start": [1090, 1], "end": [1093, 6], "kind": "commanddeclaration"}, {"full_name": "Module.End.ring", "code": "instance _root_.Module.End.ring : Ring (Module.End R N\u2081) :=\n  { Module.End.semiring, LinearMap.addCommGroup with\n    intCast := fun z \u21a6 z \u2022 (1 : N\u2081 \u2192\u2097[R] N\u2081)\n    intCast_ofNat := ofNat_zsmul _\n    intCast_negSucc := negSucc_zsmul _ }", "start": [1096, 1], "end": [1100, 41], "kind": "commanddeclaration"}, {"full_name": "Module.End.intCast_apply", "code": "@[simp]\ntheorem _root_.Module.End.intCast_apply (z : \u2124) (m : N\u2081) : (z : Module.End R N\u2081) m = z \u2022 m", "start": [1103, 1], "end": [1106, 6], "kind": "commanddeclaration"}, {"full_name": "Module.End.isScalarTower", "code": "instance _root_.Module.End.isScalarTower :\n    IsScalarTower S (Module.End R M) (Module.End R M) :=\n  \u27e8smul_comp\u27e9", "start": [1113, 1], "end": [1115, 14], "kind": "commanddeclaration"}, {"full_name": "Module.End.smulCommClass", "code": "instance _root_.Module.End.smulCommClass [SMul S R] [IsScalarTower S R M] :\n    SMulCommClass S (Module.End R M) (Module.End R M) :=\n  \u27e8fun s _ _ \u21a6 (comp_smul _ s _).symm\u27e9", "start": [1118, 1], "end": [1120, 39], "kind": "commanddeclaration"}, {"full_name": "Module.End.smulCommClass'", "code": "instance _root_.Module.End.smulCommClass' [SMul S R] [IsScalarTower S R M] :\n    SMulCommClass (Module.End R M) S (Module.End R M) :=\n  SMulCommClass.symm _ _ _", "start": [1123, 1], "end": [1125, 27], "kind": "commanddeclaration"}, {"full_name": "Module.End_isUnit_apply_inv_apply_of_isUnit", "code": "theorem _root_.Module.End_isUnit_apply_inv_apply_of_isUnit\n    {f : Module.End R M} (h : IsUnit f) (x : M) :\n    f (h.unit.inv x) = x", "start": [1128, 1], "end": [1131, 38], "kind": "commanddeclaration"}, {"full_name": "Module.End_isUnit_inv_apply_apply_of_isUnit", "code": "theorem _root_.Module.End_isUnit_inv_apply_apply_of_isUnit\n    {f : Module.End R M} (h : IsUnit f) (x : M) :\n    h.unit.inv (f x) = x", "start": [1134, 1], "end": [1137, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_pow", "code": "theorem coe_pow (f : M \u2192\u2097[R] M) (n : \u2115) : \u21d1(f ^ n) = f^[n]", "start": [1140, 1], "end": [1140, 100], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_apply", "code": "theorem pow_apply (f : M \u2192\u2097[R] M) (n : \u2115) (m : M) : (f ^ n) m = f^[n] m", "start": [1143, 1], "end": [1143, 101], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_map_zero_of_le", "code": "theorem pow_map_zero_of_le {f : Module.End R M} {m : M} {k l : \u2115} (hk : k \u2264 l)\n    (hm : (f ^ k) m = 0) : (f ^ l) m = 0", "start": [1146, 1], "end": [1148, 68], "kind": "commanddeclaration"}, {"full_name": "LinearMap.commute_pow_left_of_commute", "code": "theorem commute_pow_left_of_commute\n    [Semiring R\u2082] [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] {\u03c3\u2081\u2082 : R \u2192+* R\u2082}\n    {f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082} {g : Module.End R M} {g\u2082 : Module.End R\u2082 M\u2082}\n    (h : g\u2082.comp f = f.comp g) (k : \u2115) : (g\u2082 ^ k).comp f = f.comp (g ^ k)", "start": [1151, 1], "end": [1158, 54], "kind": "commanddeclaration"}, {"full_name": "LinearMap.id_pow", "code": "@[simp]\ntheorem id_pow (n : \u2115) : (id : M \u2192\u2097[R] M) ^ n = id", "start": [1161, 1], "end": [1163, 12], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterate_succ", "code": "theorem iterate_succ (n : \u2115) : f' ^ (n + 1) = comp (f' ^ n) f'", "start": [1168, 1], "end": [1168, 97], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterate_surjective", "code": "theorem iterate_surjective (h : Surjective f') : \u2200 n : \u2115, Surjective (f' ^ n)", "start": [1171, 1], "end": [1175, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterate_injective", "code": "theorem iterate_injective (h : Injective f') : \u2200 n : \u2115, Injective (f' ^ n)", "start": [1178, 1], "end": [1182, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterate_bijective", "code": "theorem iterate_bijective (h : Bijective f') : \u2200 n : \u2115, Bijective (f' ^ n)", "start": [1185, 1], "end": [1189, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_of_iterate_injective", "code": "theorem injective_of_iterate_injective {n : \u2115} (hn : n \u2260 0) (h : Injective (f' ^ n)) :\n    Injective f'", "start": [1192, 1], "end": [1195, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.surjective_of_iterate_surjective", "code": "theorem surjective_of_iterate_surjective {n : \u2115} (hn : n \u2260 0) (h : Surjective (f' ^ n)) :\n    Surjective f'", "start": [1198, 1], "end": [1201, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.applyModule", "code": "instance applyModule : Module (Module.End R M) M where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := LinearMap.map_zero\n  smul_add := LinearMap.map_add\n  add_smul := LinearMap.add_apply\n  zero_smul := (LinearMap.zero_apply : \u2200 m, (0 : M \u2192\u2097[R] M) m = 0)\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [1209, 1], "end": [1219, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smul_def", "code": "@[simp]\nprotected theorem smul_def (f : Module.End R M) (a : M) : f \u2022 a = f a", "start": [1222, 1], "end": [1224, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply_faithfulSMul", "code": "instance apply_faithfulSMul : FaithfulSMul (Module.End R M) M :=\n  \u27e8LinearMap.ext\u27e9", "start": [1227, 1], "end": [1229, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply_smulCommClass", "code": "instance apply_smulCommClass : SMulCommClass R (Module.End R M) M where\n  smul_comm r e m := (e.map_smul r m).symm", "start": [1232, 1], "end": [1233, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply_smulCommClass'", "code": "instance apply_smulCommClass' : SMulCommClass (Module.End R M) R M where\n  smul_comm := LinearMap.map_smul", "start": [1236, 1], "end": [1237, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply_isScalarTower", "code": "instance apply_isScalarTower {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M] :\n    IsScalarTower R (Module.End R M) M :=\n  \u27e8fun _ _ _ \u21a6 rfl\u27e9", "start": [1240, 1], "end": [1242, 20], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toLinearMap", "code": "@[simps]\ndef toLinearMap (s : S) : M \u2192\u2097[R] M where\n  toFun := HSMul.hSMul s\n  map_add' := smul_add s\n  map_smul' _ _ := smul_comm _ _ _", "start": [1258, 1], "end": [1265, 35], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toModuleEnd", "code": "@[simps]\ndef toModuleEnd : S \u2192* Module.End R M where\n  toFun := toLinearMap R M\n  map_one' := LinearMap.ext <| one_smul _\n  map_mul' _ _ := LinearMap.ext <| mul_smul _ _", "start": [1269, 1], "end": [1276, 48], "kind": "commanddeclaration"}, {"full_name": "Module.toModuleEnd", "code": "@[simps]\ndef toModuleEnd : S \u2192+* Module.End R M :=\n  { DistribMulAction.toModuleEnd R M with\n    toFun := DistribMulAction.toLinearMap R M\n    map_zero' := LinearMap.ext <| zero_smul S\n    map_add' := fun _ _ \u21a6 LinearMap.ext <| add_smul _ _ }", "start": [1288, 1], "end": [1296, 58], "kind": "commanddeclaration"}, {"full_name": "Module.moduleEndSelf", "code": "@[simps]\ndef moduleEndSelf : R\u1d50\u1d52\u1d56 \u2243+* Module.End R R :=\n  { Module.toModuleEnd R R with\n    toFun := DistribMulAction.toLinearMap R R\n    invFun := fun f \u21a6 MulOpposite.op (f 1)\n    left_inv := mul_one\n    right_inv := fun _ \u21a6 LinearMap.ext_ring <| one_mul _ }", "start": [1300, 1], "end": [1308, 59], "kind": "commanddeclaration"}, {"full_name": "Module.moduleEndSelfOp", "code": "@[simps]\ndef moduleEndSelfOp : R \u2243+* Module.End R\u1d50\u1d52\u1d56 R :=\n  { Module.toModuleEnd _ _ with\n    toFun := DistribMulAction.toLinearMap _ _\n    invFun := fun f \u21a6 f 1\n    left_inv := mul_one\n    right_inv := fun _ \u21a6 LinearMap.ext_ring_op <| mul_one _ }", "start": [1312, 1], "end": [1320, 62], "kind": "commanddeclaration"}, {"full_name": "Module.End.natCast_def", "code": "theorem End.natCast_def (n : \u2115) [AddCommMonoid N\u2081] [Module R N\u2081] :\n    (\u2191n : Module.End R N\u2081) = Module.toModuleEnd R N\u2081 n", "start": [1325, 1], "end": [1327, 6], "kind": "commanddeclaration"}, {"full_name": "Module.End.intCast_def", "code": "theorem End.intCast_def (z : \u2124) [AddCommGroup N\u2081] [Module R N\u2081] :\n    (z : Module.End R N\u2081) = Module.toModuleEnd R N\u2081 z", "start": [1330, 1], "end": [1332, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Maps.lean", "imports": ["Mathlib/Topology/Order.lean", "Mathlib/Topology/NhdsSet.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Inducing", "code": "@[mk_iff inducing_iff]\nstructure Inducing [t\u03b1 : TopologicalSpace \u03b1] [t\u03b2 : TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  induced : t\u03b1 = t\u03b2.induced f", "start": [56, 1], "end": [62, 30], "kind": "commanddeclaration"}, {"full_name": "inducing_induced", "code": "theorem inducing_induced (f : \u03b1 \u2192 \u03b2) : @Inducing \u03b1 \u03b2 (TopologicalSpace.induced f \u2039_\u203a) _ f", "start": [68, 1], "end": [69, 60], "kind": "commanddeclaration"}, {"full_name": "inducing_id", "code": "theorem inducing_id : Inducing (@id \u03b1)", "start": [71, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "Inducing.comp", "code": "protected theorem Inducing.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Inducing g) (hf : Inducing f) :\n    Inducing (g \u2218 f)", "start": [75, 1], "end": [77, 52], "kind": "commanddeclaration"}, {"full_name": "inducing_of_inducing_compose", "code": "theorem inducing_of_inducing_compose {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : Continuous f) (hg : Continuous g)\n    (hgf : Inducing (g \u2218 f)) : Inducing f", "start": [80, 1], "end": [85, 43], "kind": "commanddeclaration"}, {"full_name": "inducing_iff_nhds", "code": "theorem inducing_iff_nhds {f : \u03b1 \u2192 \u03b2} : Inducing f \u2194 \u2200 a, \ud835\udcdd a = comap f (\ud835\udcdd (f a))", "start": [88, 1], "end": [89, 49], "kind": "commanddeclaration"}, {"full_name": "Inducing.nhds_eq_comap", "code": "theorem Inducing.nhds_eq_comap {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) : \u2200 a : \u03b1, \ud835\udcdd a = comap f (\ud835\udcdd <| f a)", "start": [92, 1], "end": [93, 25], "kind": "commanddeclaration"}, {"full_name": "Inducing.nhdsSet_eq_comap", "code": "theorem Inducing.nhdsSet_eq_comap {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) (s : Set \u03b1) :\n    \ud835\udcdd\u02e2 s = comap f (\ud835\udcdd\u02e2 (f '' s))", "start": [96, 1], "end": [98, 76], "kind": "commanddeclaration"}, {"full_name": "Inducing.map_nhds_eq", "code": "theorem Inducing.map_nhds_eq {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) (a : \u03b1) : (\ud835\udcdd a).map f = \ud835\udcdd[range f] f a", "start": [101, 1], "end": [102, 42], "kind": "commanddeclaration"}, {"full_name": "Inducing.map_nhds_of_mem", "code": "theorem Inducing.map_nhds_of_mem {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) (a : \u03b1) (h : range f \u2208 \ud835\udcdd (f a)) :\n    (\ud835\udcdd a).map f = \ud835\udcdd (f a)", "start": [105, 1], "end": [107, 46], "kind": "commanddeclaration"}, {"full_name": "Inducing.mapClusterPt_iff", "code": "theorem Inducing.mapClusterPt_iff {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {a : \u03b1} {l : Filter \u03b1} :\n    MapClusterPt (f a) l f \u2194 ClusterPt a l", "start": [111, 1], "end": [114, 62], "kind": "commanddeclaration"}, {"full_name": "Inducing.image_mem_nhdsWithin", "code": "theorem Inducing.image_mem_nhdsWithin {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {a : \u03b1} {s : Set \u03b1}\n    (hs : s \u2208 \ud835\udcdd a) : f '' s \u2208 \ud835\udcdd[range f] f a", "start": [116, 1], "end": [118, 38], "kind": "commanddeclaration"}, {"full_name": "Inducing.tendsto_nhds_iff", "code": "theorem Inducing.tendsto_nhds_iff {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b9} {b : \u03b2}\n    (hg : Inducing g) : Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (g \u2218 f) a (\ud835\udcdd (g b))", "start": [121, 1], "end": [123, 43], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousAt_iff", "code": "theorem Inducing.continuousAt_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) {x : \u03b1} :\n    ContinuousAt f x \u2194 ContinuousAt (g \u2218 f) x", "start": [126, 1], "end": [128, 22], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuous_iff", "code": "theorem Inducing.continuous_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) :\n    Continuous f \u2194 Continuous (g \u2218 f)", "start": [131, 1], "end": [133, 61], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousAt_iff'", "code": "theorem Inducing.continuousAt_iff' {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : Inducing f) {x : \u03b1}\n    (h : range f \u2208 \ud835\udcdd (f x)) : ContinuousAt (g \u2218 f) x \u2194 ContinuousAt g (f x)", "start": [136, 1], "end": [138, 89], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuous", "code": "protected theorem Inducing.continuous {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) : Continuous f", "start": [141, 1], "end": [142, 37], "kind": "commanddeclaration"}, {"full_name": "Inducing.inducing_iff", "code": "protected theorem Inducing.inducing_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) :\n    Inducing f \u2194 Inducing (g \u2218 f)", "start": [145, 1], "end": [149, 23], "kind": "commanddeclaration"}, {"full_name": "Inducing.closure_eq_preimage_closure_image", "code": "theorem Inducing.closure_eq_preimage_closure_image {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) (s : Set \u03b1) :\n    closure s = f \u207b\u00b9' closure (f '' s)", "start": [152, 1], "end": [155, 55], "kind": "commanddeclaration"}, {"full_name": "Inducing.isClosed_iff", "code": "theorem Inducing.isClosed_iff {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {s : Set \u03b1} :\n    IsClosed s \u2194 \u2203 t, IsClosed t \u2227 f \u207b\u00b9' t = s", "start": [158, 1], "end": [159, 91], "kind": "commanddeclaration"}, {"full_name": "Inducing.isClosed_iff'", "code": "theorem Inducing.isClosed_iff' {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {s : Set \u03b1} :\n    IsClosed s \u2194 \u2200 x, f x \u2208 closure (f '' s) \u2192 x \u2208 s", "start": [162, 1], "end": [163, 98], "kind": "commanddeclaration"}, {"full_name": "Inducing.isClosed_preimage", "code": "theorem Inducing.isClosed_preimage {f : \u03b1 \u2192 \u03b2} (h : Inducing f) (s : Set \u03b2) (hs : IsClosed s) :\n    IsClosed (f \u207b\u00b9' s)", "start": [166, 1], "end": [168, 45], "kind": "commanddeclaration"}, {"full_name": "Inducing.isOpen_iff", "code": "theorem Inducing.isOpen_iff {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {s : Set \u03b1} :\n    IsOpen s \u2194 \u2203 t, IsOpen t \u2227 f \u207b\u00b9' t = s", "start": [171, 1], "end": [172, 85], "kind": "commanddeclaration"}, {"full_name": "Inducing.setOf_isOpen", "code": "theorem Inducing.setOf_isOpen {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) :\n    {s : Set \u03b1 | IsOpen s} = preimage f '' {t | IsOpen t}", "start": [175, 1], "end": [177, 32], "kind": "commanddeclaration"}, {"full_name": "Inducing.dense_iff", "code": "theorem Inducing.dense_iff {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {s : Set \u03b1} :\n    Dense s \u2194 \u2200 x, f x \u2208 closure (f '' s)", "start": [179, 1], "end": [181, 72], "kind": "commanddeclaration"}, {"full_name": "Embedding", "code": "@[mk_iff embedding_iff]\nstructure Embedding [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) extends\n  Inducing f : Prop where\n  \n  inj : Injective f", "start": [188, 1], "end": [194, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.embedding_induced", "code": "theorem Function.Injective.embedding_induced [t : TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Injective f) : @_root_.Embedding \u03b1 \u03b2 (t.induced f) t f", "start": [198, 1], "end": [200, 69], "kind": "commanddeclaration"}, {"full_name": "Embedding.mk'", "code": "theorem Embedding.mk' (f : \u03b1 \u2192 \u03b2) (inj : Injective f) (induced : \u2200 a, comap f (\ud835\udcdd (f a)) = \ud835\udcdd a) :\n    Embedding f", "start": [205, 1], "end": [207, 55], "kind": "commanddeclaration"}, {"full_name": "embedding_id", "code": "theorem embedding_id : Embedding (@id \u03b1)", "start": [210, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "Embedding.comp", "code": "protected theorem Embedding.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : Embedding g) (hf : Embedding f) :\n    Embedding (g \u2218 f)", "start": [214, 1], "end": [216, 83], "kind": "commanddeclaration"}, {"full_name": "embedding_of_embedding_compose", "code": "theorem embedding_of_embedding_compose {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : Continuous f)\n    (hg : Continuous g) (hgf : Embedding (g \u2218 f)) : Embedding f", "start": [219, 1], "end": [222, 60], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.embedding", "code": "protected theorem Function.LeftInverse.embedding {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (h : LeftInverse f g)\n    (hf : Continuous f) (hg : Continuous g) : _root_.Embedding g", "start": [225, 1], "end": [227, 75], "kind": "commanddeclaration"}, {"full_name": "Embedding.map_nhds_eq", "code": "theorem Embedding.map_nhds_eq {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) (a : \u03b1) :\n    (\ud835\udcdd a).map f = \ud835\udcdd[range f] f a", "start": [230, 1], "end": [232, 21], "kind": "commanddeclaration"}, {"full_name": "Embedding.map_nhds_of_mem", "code": "theorem Embedding.map_nhds_of_mem {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) (a : \u03b1) (h : range f \u2208 \ud835\udcdd (f a)) :\n    (\ud835\udcdd a).map f = \ud835\udcdd (f a)", "start": [235, 1], "end": [237, 27], "kind": "commanddeclaration"}, {"full_name": "Embedding.tendsto_nhds_iff", "code": "theorem Embedding.tendsto_nhds_iff {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b9} {b : \u03b2}\n    (hg : Embedding g) : Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (g \u2218 f) a (\ud835\udcdd (g b))", "start": [240, 1], "end": [242, 33], "kind": "commanddeclaration"}, {"full_name": "Embedding.continuous_iff", "code": "theorem Embedding.continuous_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Embedding g) :\n    Continuous f \u2194 Continuous (g \u2218 f)", "start": [245, 1], "end": [247, 31], "kind": "commanddeclaration"}, {"full_name": "Embedding.continuous", "code": "theorem Embedding.continuous {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) : Continuous f", "start": [250, 1], "end": [251, 27], "kind": "commanddeclaration"}, {"full_name": "Embedding.closure_eq_preimage_closure_image", "code": "theorem Embedding.closure_eq_preimage_closure_image {e : \u03b1 \u2192 \u03b2} (he : Embedding e) (s : Set \u03b1) :\n    closure s = e \u207b\u00b9' closure (e '' s)", "start": [254, 1], "end": [256, 43], "kind": "commanddeclaration"}, {"full_name": "Embedding.discreteTopology", "code": "theorem Embedding.discreteTopology {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y]\n    [DiscreteTopology Y] {f : X \u2192 Y} (hf : Embedding f) : DiscreteTopology X", "start": [259, 1], "end": [265, 48], "kind": "commanddeclaration"}, {"full_name": "QuotientMap", "code": "def QuotientMap {\u03b1 : Type*} {\u03b2 : Type*} [t\u03b1 : TopologicalSpace \u03b1] [t\u03b2 : TopologicalSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : Prop :=\n  Surjective f \u2227 t\u03b2 = t\u03b1.coinduced f", "start": [270, 1], "end": [274, 37], "kind": "commanddeclaration"}, {"full_name": "quotientMap_iff", "code": "theorem quotientMap_iff [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    QuotientMap f \u2194 Surjective f \u2227 \u2200 s : Set \u03b2, IsOpen s \u2194 IsOpen (f \u207b\u00b9' s)", "start": [277, 1], "end": [279, 45], "kind": "commanddeclaration"}, {"full_name": "quotientMap_iff_closed", "code": "theorem quotientMap_iff_closed [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    QuotientMap f \u2194 Surjective f \u2227 \u2200 s : Set \u03b2, IsClosed s \u2194 IsClosed (f \u207b\u00b9' s)", "start": [282, 1], "end": [285, 49], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.id", "code": "protected theorem id : QuotientMap (@id \u03b1)", "start": [293, 1], "end": [294, 41], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.comp", "code": "protected theorem comp (hg : QuotientMap g) (hf : QuotientMap f) : QuotientMap (g \u2218 f)", "start": [297, 1], "end": [298, 72], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.of_quotientMap_compose", "code": "protected theorem of_quotientMap_compose (hf : Continuous f) (hg : Continuous g)\n    (hgf : QuotientMap (g \u2218 f)) : QuotientMap g", "start": [301, 1], "end": [306, 23], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.of_inverse", "code": "theorem of_inverse {g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) (h : LeftInverse g f) :\n    QuotientMap g", "start": [309, 1], "end": [311, 81], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.continuous_iff", "code": "protected theorem continuous_iff (hf : QuotientMap f) : Continuous g \u2194 Continuous (g \u2218 f)", "start": [314, 1], "end": [315, 93], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.continuous", "code": "protected theorem continuous (hf : QuotientMap f) : Continuous f", "start": [318, 1], "end": [319, 37], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.surjective", "code": "protected theorem surjective (hf : QuotientMap f) : Surjective f", "start": [322, 1], "end": [323, 7], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.isOpen_preimage", "code": "protected theorem isOpen_preimage (hf : QuotientMap f) {s : Set \u03b2} : IsOpen (f \u207b\u00b9' s) \u2194 IsOpen s", "start": [326, 1], "end": [327, 36], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.isClosed_preimage", "code": "protected theorem isClosed_preimage (hf : QuotientMap f) {s : Set \u03b2} :\n    IsClosed (f \u207b\u00b9' s) \u2194 IsClosed s", "start": [330, 1], "end": [332, 43], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap", "code": "def IsOpenMap [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 U : Set \u03b1, IsOpen U \u2192 IsOpen (f '' U)", "start": [337, 1], "end": [340, 42], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.id", "code": "protected theorem id : IsOpenMap (@id \u03b1)", "start": [347, 1], "end": [347, 74], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.comp", "code": "protected theorem comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : IsOpenMap g) (hf : IsOpenMap f) :\n    IsOpenMap (g \u2218 f)", "start": [350, 1], "end": [351, 78], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.isOpen_range", "code": "theorem isOpen_range (hf : IsOpenMap f) : IsOpen (range f)", "start": [354, 1], "end": [356, 25], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.image_mem_nhds", "code": "theorem image_mem_nhds (hf : IsOpenMap f) {x : \u03b1} {s : Set \u03b1} (hx : s \u2208 \ud835\udcdd x) : f '' s \u2208 \ud835\udcdd (f x)", "start": [359, 1], "end": [361, 92], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.range_mem_nhds", "code": "theorem range_mem_nhds (hf : IsOpenMap f) (x : \u03b1) : range f \u2208 \ud835\udcdd (f x)", "start": [364, 1], "end": [365, 47], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.mapsTo_interior", "code": "theorem mapsTo_interior (hf : IsOpenMap f) {s : Set \u03b1} {t : Set \u03b2} (h : MapsTo f s t) :\n    MapsTo f (interior s) (interior t)", "start": [368, 1], "end": [371, 93], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.image_interior_subset", "code": "theorem image_interior_subset (hf : IsOpenMap f) (s : Set \u03b1) :\n    f '' interior s \u2286 interior (f '' s)", "start": [374, 1], "end": [376, 55], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.nhds_le", "code": "theorem nhds_le (hf : IsOpenMap f) (a : \u03b1) : \ud835\udcdd (f a) \u2264 (\ud835\udcdd a).map f", "start": [379, 1], "end": [380, 36], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.of_nhds_le", "code": "theorem of_nhds_le (hf : \u2200 a, \ud835\udcdd (f a) \u2264 map f (\ud835\udcdd a)) : IsOpenMap f", "start": [383, 1], "end": [384, 95], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.of_sections", "code": "theorem of_sections {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 x, \u2203 g : \u03b2 \u2192 \u03b1, ContinuousAt g (f x) \u2227 g (f x) = x \u2227 RightInverse g f) : IsOpenMap f", "start": [387, 1], "end": [394, 37], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.of_inverse", "code": "theorem of_inverse {f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1} (h : Continuous f') (l_inv : LeftInverse f f')\n    (r_inv : RightInverse f f') : IsOpenMap f", "start": [397, 1], "end": [399, 60], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.to_quotientMap", "code": "theorem to_quotientMap {f : \u03b1 \u2192 \u03b2} (open_map : IsOpenMap f) (cont : Continuous f)\n    (surj : Surjective f) : QuotientMap f", "start": [402, 1], "end": [406, 95], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.interior_preimage_subset_preimage_interior", "code": "theorem interior_preimage_subset_preimage_interior (hf : IsOpenMap f) {s : Set \u03b2} :\n    interior (f \u207b\u00b9' s) \u2286 f \u207b\u00b9' interior s", "start": [409, 1], "end": [411, 43], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.preimage_interior_eq_interior_preimage", "code": "theorem preimage_interior_eq_interior_preimage (hf\u2081 : IsOpenMap f) (hf\u2082 : Continuous f)\n    (s : Set \u03b2) : f \u207b\u00b9' interior s = interior (f \u207b\u00b9' s)", "start": [414, 1], "end": [417, 53], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.preimage_closure_subset_closure_preimage", "code": "theorem preimage_closure_subset_closure_preimage (hf : IsOpenMap f) {s : Set \u03b2} :\n    f \u207b\u00b9' closure s \u2286 closure (f \u207b\u00b9' s)", "start": [420, 1], "end": [423, 96], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.preimage_closure_eq_closure_preimage", "code": "theorem preimage_closure_eq_closure_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set \u03b2) :\n    f \u207b\u00b9' closure s = closure (f \u207b\u00b9' s)", "start": [426, 1], "end": [428, 87], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.preimage_frontier_subset_frontier_preimage", "code": "theorem preimage_frontier_subset_frontier_preimage (hf : IsOpenMap f) {s : Set \u03b2} :\n    f \u207b\u00b9' frontier s \u2286 frontier (f \u207b\u00b9' s)", "start": [431, 1], "end": [435, 50], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.preimage_frontier_eq_frontier_preimage", "code": "theorem preimage_frontier_eq_frontier_preimage (hf : IsOpenMap f) (hfc : Continuous f) (s : Set \u03b2) :\n    f \u207b\u00b9' frontier s = frontier (f \u207b\u00b9' s)", "start": [438, 1], "end": [441, 49], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_iff_nhds_le", "code": "theorem isOpenMap_iff_nhds_le [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    IsOpenMap f \u2194 \u2200 a : \u03b1, \ud835\udcdd (f a) \u2264 (\ud835\udcdd a).map f", "start": [446, 1], "end": [448, 47], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_iff_interior", "code": "theorem isOpenMap_iff_interior [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    IsOpenMap f \u2194 \u2200 s, f '' interior s \u2286 interior (f '' s)", "start": [451, 1], "end": [457, 39], "kind": "commanddeclaration"}, {"full_name": "Inducing.isOpenMap", "code": "protected theorem Inducing.isOpenMap [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hi : Inducing f) (ho : IsOpen (range f)) : IsOpenMap f", "start": [460, 1], "end": [463, 100], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap", "code": "def IsClosedMap (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 U : Set \u03b1, IsClosed U \u2192 IsClosed (f '' U)", "start": [470, 1], "end": [473, 46], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.id", "code": "protected theorem id : IsClosedMap (@id \u03b1)", "start": [484, 1], "end": [484, 76], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.comp", "code": "protected theorem comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : IsClosedMap g) (hf : IsClosedMap f) :\n    IsClosedMap (g \u2218 f)", "start": [487, 1], "end": [491, 23], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.closure_image_subset", "code": "theorem closure_image_subset {f : \u03b1 \u2192 \u03b2} (hf : IsClosedMap f) (s : Set \u03b1) :\n    closure (f '' s) \u2286 f '' closure s", "start": [494, 1], "end": [496, 74], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.of_inverse", "code": "theorem of_inverse {f : \u03b1 \u2192 \u03b2} {f' : \u03b2 \u2192 \u03b1} (h : Continuous f') (l_inv : LeftInverse f f')\n    (r_inv : RightInverse f f') : IsClosedMap f", "start": [499, 1], "end": [502, 22], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.of_nonempty", "code": "theorem of_nonempty {f : \u03b1 \u2192 \u03b2} (h : \u2200 s, IsClosed s \u2192 s.Nonempty \u2192 IsClosed (f '' s)) :\n    IsClosedMap f", "start": [505, 1], "end": [509, 21], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.closed_range", "code": "theorem closed_range {f : \u03b1 \u2192 \u03b2} (hf : IsClosedMap f) : IsClosed (range f)", "start": [512, 1], "end": [513, 41], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.to_quotientMap", "code": "theorem to_quotientMap {f : \u03b1 \u2192 \u03b2} (hcl : IsClosedMap f) (hcont : Continuous f)\n    (hsurj : Surjective f) : QuotientMap f", "start": [516, 1], "end": [519, 80], "kind": "commanddeclaration"}, {"full_name": "Inducing.isClosedMap", "code": "theorem Inducing.isClosedMap [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Inducing f)\n    (h : IsClosed (range f)) : IsClosedMap f", "start": [524, 1], "end": [529, 19], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_iff_closure_image", "code": "theorem isClosedMap_iff_closure_image [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    IsClosedMap f \u2194 \u2200 s, closure (f '' s) \u2286 f '' closure s", "start": [532, 1], "end": [538, 45], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_iff_clusterPt", "code": "theorem isClosedMap_iff_clusterPt [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    IsClosedMap f \u2194 \u2200 s y, MapClusterPt y (\ud835\udcdf s) f \u2192 \u2203 x, f x = y \u2227 ClusterPt x (\ud835\udcdf s)", "start": [541, 1], "end": [548, 14], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.closure_image_eq_of_continuous", "code": "theorem IsClosedMap.closure_image_eq_of_continuous [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (f_closed : IsClosedMap f) (f_cont : Continuous f) (s : Set \u03b1) :\n    closure (f '' s) = f '' closure s", "start": [550, 1], "end": [553, 96], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.lift'_closure_map_eq", "code": "theorem IsClosedMap.lift'_closure_map_eq [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (f_closed : IsClosedMap f) (f_cont : Continuous f) (F : Filter \u03b1) :\n    (map f F).lift' closure = map f (F.lift' closure)", "start": [555, 1], "end": [561, 57], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.mapClusterPt_iff_lift'_closure", "code": "theorem IsClosedMap.mapClusterPt_iff_lift'_closure [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    {F : Filter \u03b1} {f : \u03b1 \u2192 \u03b2} (f_closed : IsClosedMap f) (f_cont : Continuous f) {y : \u03b2} :\n    MapClusterPt y F f \u2194 ((F.lift' closure) \u2293 \ud835\udcdf (f \u207b\u00b9' {y})).NeBot", "start": [563, 1], "end": [567, 83], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding", "code": "@[mk_iff openEmbedding_iff]\nstructure OpenEmbedding (f : \u03b1 \u2192 \u03b2) extends Embedding f : Prop where\n  \n  open_range : IsOpen <| range f", "start": [573, 1], "end": [577, 33], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.isOpenMap", "code": "theorem OpenEmbedding.isOpenMap {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) : IsOpenMap f", "start": [581, 1], "end": [582, 52], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.map_nhds_eq", "code": "theorem OpenEmbedding.map_nhds_eq {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) (a : \u03b1) :\n    map f (\ud835\udcdd a) = \ud835\udcdd (f a)", "start": [585, 1], "end": [587, 81], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.open_iff_image_open", "code": "theorem OpenEmbedding.open_iff_image_open {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) {s : Set \u03b1} :\n    IsOpen s \u2194 IsOpen (f '' s)", "start": [590, 1], "end": [594, 38], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.tendsto_nhds_iff", "code": "theorem OpenEmbedding.tendsto_nhds_iff {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} {a : Filter \u03b9} {b : \u03b2}\n    (hg : OpenEmbedding g) : Tendsto f a (\ud835\udcdd b) \u2194 Tendsto (g \u2218 f) a (\ud835\udcdd (g b))", "start": [597, 1], "end": [599, 34], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.tendsto_nhds_iff'", "code": "theorem OpenEmbedding.tendsto_nhds_iff' {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) {g : \u03b2 \u2192 \u03b3}\n    {l : Filter \u03b3} {a : \u03b1} : Tendsto (g \u2218 f) (\ud835\udcdd a) l \u2194 Tendsto g (\ud835\udcdd (f a)) l", "start": [602, 1], "end": [604, 47], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.continuous", "code": "theorem OpenEmbedding.continuous {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) : Continuous f", "start": [606, 1], "end": [607, 28], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.open_iff_preimage_open", "code": "theorem OpenEmbedding.open_iff_preimage_open {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) {s : Set \u03b2}\n    (hs : s \u2286 range f) : IsOpen s \u2194 IsOpen (f \u207b\u00b9' s)", "start": [610, 1], "end": [612, 94], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_of_embedding_open", "code": "theorem openEmbedding_of_embedding_open {f : \u03b1 \u2192 \u03b2} (h\u2081 : Embedding f) (h\u2082 : IsOpenMap f) :\n    OpenEmbedding f", "start": [615, 1], "end": [617, 24], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_iff_embedding_open", "code": "theorem openEmbedding_iff_embedding_open {f : \u03b1 \u2192 \u03b2} :\n    OpenEmbedding f \u2194 Embedding f \u2227 IsOpenMap f", "start": [620, 1], "end": [622, 82], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_of_continuous_injective_open", "code": "theorem openEmbedding_of_continuous_injective_open {f : \u03b1 \u2192 \u03b2} (h\u2081 : Continuous f)\n    (h\u2082 : Injective f) (h\u2083 : IsOpenMap f) : OpenEmbedding f", "start": [625, 1], "end": [629, 96], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_iff_continuous_injective_open", "code": "theorem openEmbedding_iff_continuous_injective_open {f : \u03b1 \u2192 \u03b2} :\n    OpenEmbedding f \u2194 Continuous f \u2227 Injective f \u2227 IsOpenMap f", "start": [632, 1], "end": [635, 64], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_id", "code": "theorem openEmbedding_id : OpenEmbedding (@id \u03b1)", "start": [638, 1], "end": [639, 44], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.comp", "code": "protected theorem OpenEmbedding.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : OpenEmbedding g)\n    (hf : OpenEmbedding f) : OpenEmbedding (g \u2218 f)", "start": [642, 1], "end": [644, 66], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.isOpenMap_iff", "code": "theorem OpenEmbedding.isOpenMap_iff {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : OpenEmbedding g) :\n    IsOpenMap f \u2194 IsOpenMap (g \u2218 f)", "start": [647, 1], "end": [649, 99], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.of_comp_iff", "code": "theorem OpenEmbedding.of_comp_iff (f : \u03b1 \u2192 \u03b2) {g : \u03b2 \u2192 \u03b3} (hg : OpenEmbedding g) :\n    OpenEmbedding (g \u2218 f) \u2194 OpenEmbedding f", "start": [652, 1], "end": [655, 45], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.of_comp", "code": "theorem OpenEmbedding.of_comp (f : \u03b1 \u2192 \u03b2) {g : \u03b2 \u2192 \u03b3} (hg : OpenEmbedding g)\n    (h : OpenEmbedding (g \u2218 f)) : OpenEmbedding f", "start": [658, 1], "end": [660, 39], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding", "code": "@[mk_iff closedEmbedding_iff]\nstructure ClosedEmbedding (f : \u03b1 \u2192 \u03b2) extends Embedding f : Prop where\n  \n  closed_range : IsClosed <| range f", "start": [669, 1], "end": [673, 37], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.tendsto_nhds_iff", "code": "theorem ClosedEmbedding.tendsto_nhds_iff {\u03b9 : Type*} {g : \u03b9 \u2192 \u03b1} {a : Filter \u03b9} {b : \u03b1}\n    (hf : ClosedEmbedding f) : Tendsto g a (\ud835\udcdd b) \u2194 Tendsto (f \u2218 g) a (\ud835\udcdd (f b))", "start": [679, 1], "end": [681, 34], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.continuous", "code": "theorem ClosedEmbedding.continuous (hf : ClosedEmbedding f) : Continuous f", "start": [684, 1], "end": [685, 28], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.isClosedMap", "code": "theorem ClosedEmbedding.isClosedMap (hf : ClosedEmbedding f) : IsClosedMap f", "start": [688, 1], "end": [689, 56], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.closed_iff_image_closed", "code": "theorem ClosedEmbedding.closed_iff_image_closed (hf : ClosedEmbedding f) {s : Set \u03b1} :\n    IsClosed s \u2194 IsClosed (f '' s)", "start": [692, 1], "end": [696, 36], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.closed_iff_preimage_closed", "code": "theorem ClosedEmbedding.closed_iff_preimage_closed (hf : ClosedEmbedding f) {s : Set \u03b2}\n    (hs : s \u2286 range f) : IsClosed s \u2194 IsClosed (f \u207b\u00b9' s)", "start": [699, 1], "end": [701, 66], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_of_embedding_closed", "code": "theorem closedEmbedding_of_embedding_closed (h\u2081 : Embedding f) (h\u2082 : IsClosedMap f) :\n    ClosedEmbedding f", "start": [704, 1], "end": [706, 52], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_of_continuous_injective_closed", "code": "theorem closedEmbedding_of_continuous_injective_closed (h\u2081 : Continuous f) (h\u2082 : Injective f)\n    (h\u2083 : IsClosedMap f) : ClosedEmbedding f", "start": [709, 1], "end": [714, 59], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_id", "code": "theorem closedEmbedding_id : ClosedEmbedding (@id \u03b1)", "start": [717, 1], "end": [718, 46], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.comp", "code": "theorem ClosedEmbedding.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : ClosedEmbedding g)\n    (hf : ClosedEmbedding f) : ClosedEmbedding (g \u2218 f)", "start": [721, 1], "end": [723, 90], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.closure_image_eq", "code": "theorem ClosedEmbedding.closure_image_eq {f : \u03b1 \u2192 \u03b2} (hf : ClosedEmbedding f) (s : Set \u03b1) :\n    closure (f '' s) = f '' closure s", "start": [726, 1], "end": [728, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Cast/Prod.lean", "imports": ["Mathlib/Data/Nat/Cast/Prod.lean", "Mathlib/Data/Int/Cast/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.fst_intCast", "code": "@[simp]\ntheorem fst_intCast (n : \u2124) : (n : \u03b1 \u00d7 \u03b2).fst = n", "start": [26, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_intCast", "code": "@[simp]\ntheorem snd_intCast (n : \u2124) : (n : \u03b1 \u00d7 \u03b2).snd = n", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Prod.lean", "imports": ["Mathlib/Algebra/Order/Group/Instances.lean", "Mathlib/Algebra/Order/Monoid/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.Lex.orderedCommGroup", "code": "@[to_additive]\ninstance orderedCommGroup [OrderedCommGroup G] [OrderedCommGroup H] :\n    OrderedCommGroup (G \u00d7\u2097 H) where\n  mul_le_mul_left _ _ := mul_le_mul_left'", "start": [29, 1], "end": [32, 42], "kind": "commanddeclaration"}, {"full_name": "Prod.Lex.linearOrderedCommGroup", "code": "@[to_additive]\ninstance linearOrderedCommGroup [LinearOrderedCommGroup G] [LinearOrderedCommGroup H] :\n    LinearOrderedCommGroup (G \u00d7\u2097 H) where\n  __ : LinearOrder (G \u00d7\u2097 H) := inferInstance\n  mul_le_mul_left _ _ := mul_le_mul_left'", "start": [34, 1], "end": [38, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Pi.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Ring/Pi.lean"], "premises": [{"full_name": "Pi.list_prod_apply", "code": "@[to_additive]\ntheorem list_prod_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, Monoid (\u03b2 a)] (a : \u03b1)\n    (l : List (\u2200 a, \u03b2 a)) : l.prod a = (l.map fun f : \u2200 a, \u03b2 a \u21a6 f a).prod", "start": [25, 1], "end": [28, 38], "kind": "commanddeclaration"}, {"full_name": "Pi.multiset_prod_apply", "code": "@[to_additive]\ntheorem multiset_prod_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} [\u2200 a, CommMonoid (\u03b2 a)] (a : \u03b1)\n    (s : Multiset (\u2200 a, \u03b2 a)) : s.prod a = (s.map fun f : \u2200 a, \u03b2 a \u21a6 f a).prod", "start": [32, 1], "end": [35, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_apply", "code": "@[to_additive (attr := simp)]\ntheorem Finset.prod_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b3} [\u2200 a, CommMonoid (\u03b2 a)] (a : \u03b1)\n    (s : Finset \u03b3) (g : \u03b3 \u2192 \u2200 a, \u03b2 a) : (\u220f c in s, g c) a = \u220f c in s, g c a", "start": [41, 1], "end": [44, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_fn", "code": "@[to_additive \"An 'unapplied' analogue of `Finset.sum_apply`.\"]\ntheorem Finset.prod_fn {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b3} [\u2200 a, CommMonoid (\u03b2 a)] (s : Finset \u03b3)\n    (g : \u03b3 \u2192 \u2200 a, \u03b2 a) : \u220f c in s, g c = fun a \u21a6 \u220f c in s, g c a", "start": [48, 1], "end": [52, 41], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_apply", "code": "@[to_additive]\ntheorem Fintype.prod_apply {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*} {\u03b3 : Type*} [Fintype \u03b3]\n    [\u2200 a, CommMonoid (\u03b2 a)] (a : \u03b1) (g : \u03b3 \u2192 \u2200 a, \u03b2 a) : (\u220f c, g c) a = \u220f c, g c a", "start": [56, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "prod_mk_prod", "code": "@[to_additive prod_mk_sum]\ntheorem prod_mk_prod {\u03b1 \u03b2 \u03b3 : Type*} [CommMonoid \u03b1] [CommMonoid \u03b2] (s : Finset \u03b3) (f : \u03b3 \u2192 \u03b1)\n    (g : \u03b3 \u2192 \u03b2) : (\u220f x in s, f x, \u220f x in s, g x) = \u220f x in s, (f x, g x)", "start": [63, 1], "end": [67, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_prod_mulSingle", "code": "@[to_additive]\ntheorem Finset.univ_prod_mulSingle [Fintype I] (f : \u2200 i, Z i) :\n    (\u220f i, Pi.mulSingle i (f i)) = f", "start": [77, 1], "end": [81, 7], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.functions_ext", "code": "@[to_additive]\ntheorem MonoidHom.functions_ext [Finite I] (G : Type*) [CommMonoid G] (g h : (\u2200 i, Z i) \u2192* G)\n    (H : \u2200 i x, g (Pi.mulSingle i x) = h (Pi.mulSingle i x)) : g = h", "start": [85, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.functions_ext'", "code": "@[to_additive (attr := ext)\n      \"\\nThis is used as the ext lemma instead of `AddMonoidHom.functions_ext` for reasons\n      explained in note [partially-applied ext lemmas].\"]\ntheorem MonoidHom.functions_ext' [Finite I] (M : Type*) [CommMonoid M] (g h : (\u2200 i, Z i) \u2192* M)\n    (H : \u2200 i, g.comp (MonoidHom.single Z i) = h.comp (MonoidHom.single Z i)) : g = h", "start": [95, 1], "end": [102, 55], "kind": "commanddeclaration"}, {"full_name": "RingHom.functions_ext", "code": "@[ext]\ntheorem RingHom.functions_ext [Finite I] (G : Type*) [NonAssocSemiring G] (g h : (\u2200 i, f i) \u2192+* G)\n    (H : \u2200 (i : I) (x : f i), g (single i x) = h (single i x)) : g = h", "start": [116, 1], "end": [120, 72], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_prod", "code": "@[to_additive]\ntheorem fst_prod : (\u220f c in s, f c).1 = \u220f c in s, (f c).1", "start": [129, 1], "end": [131, 35], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_prod", "code": "@[to_additive]\ntheorem snd_prod : (\u220f c in s, f c).2 = \u220f c in s, (f c).2", "start": [135, 1], "end": [137, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Fin.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Data/List/FinRange.lean", "Mathlib/Data/Fintype/Fin.lean"], "premises": [{"full_name": "Finset.prod_range", "code": "@[to_additive]\ntheorem prod_range [CommMonoid \u03b2] {n : \u2115} (f : \u2115 \u2192 \u03b2) :\n    \u220f i in Finset.range n, f i = \u220f i : Fin n, f i", "start": [35, 1], "end": [38, 41], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_def", "code": "@[to_additive]\ntheorem prod_univ_def [CommMonoid \u03b2] {n : \u2115} (f : Fin n \u2192 \u03b2) :\n    \u220f i, f i = ((List.finRange n).map f).prod", "start": [46, 1], "end": [48, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_ofFn", "code": "@[to_additive]\ntheorem prod_ofFn [CommMonoid \u03b2] {n : \u2115} (f : Fin n \u2192 \u03b2) : (List.ofFn f).prod = \u220f i, f i", "start": [52, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_zero", "code": "@[to_additive \"A sum of a function `f : Fin 0 \u2192 \u03b2` is `0` because `Fin 0` is empty\"]\ntheorem prod_univ_zero [CommMonoid \u03b2] (f : Fin 0 \u2192 \u03b2) : \u220f i, f i = 1", "start": [58, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_succAbove", "code": "@[to_additive \"A sum of a function `f : Fin (n + 1) \u2192 \u03b2` over all `Fin (n + 1)` is the sum of\n`f x`, for some `x : Fin (n + 1)` plus the remaining product\"]\ntheorem prod_univ_succAbove [CommMonoid \u03b2] {n : \u2115} (f : Fin (n + 1) \u2192 \u03b2) (x : Fin (n + 1)) :\n    \u220f i, f i = f x * \u220f i : Fin n, f (x.succAbove i)", "start": [65, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_succ", "code": "@[to_additive \"A sum of a function `f : Fin (n + 1) \u2192 \u03b2` over all `Fin (n + 1)` is the sum of\n`f 0` plus the remaining product\"]\ntheorem prod_univ_succ [CommMonoid \u03b2] {n : \u2115} (f : Fin (n + 1) \u2192 \u03b2) :\n    \u220f i, f i = f 0 * \u220f i : Fin n, f i.succ", "start": [77, 1], "end": [83, 26], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_castSucc", "code": "@[to_additive \"A sum of a function `f : Fin (n + 1) \u2192 \u03b2` over all `Fin (n + 1)` is the sum of\n`f (Fin.last n)` plus the remaining sum\"]\ntheorem prod_univ_castSucc [CommMonoid \u03b2] {n : \u2115} (f : Fin (n + 1) \u2192 \u03b2) :\n    \u220f i, f i = (\u220f i : Fin n, f (Fin.castSucc i)) * f (last n)", "start": [87, 1], "end": [93, 56], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_cons", "code": "@[to_additive]\ntheorem prod_cons [CommMonoid \u03b2] {n : \u2115} (x : \u03b2) (f : Fin n \u2192 \u03b2) :\n    (\u220f i : Fin n.succ, (cons x f : Fin n.succ \u2192 \u03b2) i) = x * \u220f i : Fin n, f i", "start": [97, 1], "end": [100, 49], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_one", "code": "@[to_additive sum_univ_one]\ntheorem prod_univ_one [CommMonoid \u03b2] (f : Fin 1 \u2192 \u03b2) : \u220f i, f i = f 0", "start": [104, 1], "end": [105, 81], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_two", "code": "@[to_additive (attr := simp)]\ntheorem prod_univ_two [CommMonoid \u03b2] (f : Fin 2 \u2192 \u03b2) : \u220f i, f i = f 0 * f 1", "start": [109, 1], "end": [111, 24], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_three", "code": "@[to_additive]\ntheorem prod_univ_three [CommMonoid \u03b2] (f : Fin 3 \u2192 \u03b2) : \u220f i, f i = f 0 * f 1 * f 2", "start": [115, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_four", "code": "@[to_additive]\ntheorem prod_univ_four [CommMonoid \u03b2] (f : Fin 4 \u2192 \u03b2) : \u220f i, f i = f 0 * f 1 * f 2 * f 3", "start": [122, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_five", "code": "@[to_additive]\ntheorem prod_univ_five [CommMonoid \u03b2] (f : Fin 5 \u2192 \u03b2) :\n    \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4", "start": [129, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_six", "code": "@[to_additive]\ntheorem prod_univ_six [CommMonoid \u03b2] (f : Fin 6 \u2192 \u03b2) :\n    \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5", "start": [137, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_seven", "code": "@[to_additive]\ntheorem prod_univ_seven [CommMonoid \u03b2] (f : Fin 7 \u2192 \u03b2) :\n    \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6", "start": [145, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_eight", "code": "@[to_additive]\ntheorem prod_univ_eight [CommMonoid \u03b2] (f : Fin 8 \u2192 \u03b2) :\n    \u220f i, f i = f 0 * f 1 * f 2 * f 3 * f 4 * f 5 * f 6 * f 7", "start": [153, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.sum_pow_mul_eq_add_pow", "code": "theorem sum_pow_mul_eq_add_pow {n : \u2115} {R : Type*} [CommSemiring R] (a b : R) :\n    (\u2211 s : Finset (Fin n), a ^ s.card * b ^ (n - s.card)) = (a + b) ^ n", "start": [161, 1], "end": [163, 57], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_const", "code": "theorem prod_const [CommMonoid \u03b1] (n : \u2115) (x : \u03b1) : \u220f _i : Fin n, x = x ^ n", "start": [166, 1], "end": [166, 87], "kind": "commanddeclaration"}, {"full_name": "Fin.sum_const", "code": "theorem sum_const [AddCommMonoid \u03b1] (n : \u2115) (x : \u03b1) : \u2211 _i : Fin n, x = n \u2022 x", "start": [169, 1], "end": [169, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_Ioi_zero", "code": "@[to_additive]\ntheorem prod_Ioi_zero {M : Type*} [CommMonoid M] {n : \u2115} {v : Fin n.succ \u2192 M} :\n    \u220f i in Ioi 0, v i = \u220f j : Fin n, v j.succ", "start": [172, 1], "end": [175, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_Ioi_succ", "code": "@[to_additive]\ntheorem prod_Ioi_succ {M : Type*} [CommMonoid M] {n : \u2115} (i : Fin n) (v : Fin n.succ \u2192 M) :\n    \u220f j in Ioi i.succ, v j = \u220f j in Ioi i, v j.succ", "start": [179, 1], "end": [182, 82], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_congr'", "code": "@[to_additive]\ntheorem prod_congr' {M : Type*} [CommMonoid M] {a b : \u2115} (f : Fin b \u2192 M) (h : a = b) :\n    (\u220f i : Fin a, f (cast h i)) = \u220f i : Fin b, f i", "start": [186, 1], "end": [190, 8], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_univ_add", "code": "@[to_additive]\ntheorem prod_univ_add {M : Type*} [CommMonoid M] {a b : \u2115} (f : Fin (a + b) \u2192 M) :\n    (\u220f i : Fin (a + b), f i) = (\u220f i : Fin a, f (castAdd b i)) * \u220f i : Fin b, f (natAdd a i)", "start": [194, 1], "end": [200, 59], "kind": "commanddeclaration"}, {"full_name": "Fin.prod_trunc", "code": "@[to_additive]\ntheorem prod_trunc {M : Type*} [CommMonoid M] {a b : \u2115} (f : Fin (a + b) \u2192 M)\n    (hf : \u2200 j : Fin b, f (natAdd a j) = 1) :\n    (\u220f i : Fin (a + b), f i) = \u220f i : Fin a, f (castLE (Nat.le.intro rfl) i)", "start": [204, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd", "code": "@[to_additive \"For `f = (a\u2081, ..., a\u2099)` in `\u03b1\u207f`, `partialSum f` is\\n\n`(0, a\u2081, a\u2081 + a\u2082, ..., a\u2081 + ... + a\u2099)` in `\u03b1\u207f\u207a\u00b9`.\"]\ndef partialProd (f : Fin n \u2192 \u03b1) (i : Fin (n + 1)) : \u03b1 :=\n  ((List.ofFn f).take i).prod", "start": [217, 1], "end": [221, 30], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd_zero", "code": "@[to_additive (attr := simp)]\ntheorem partialProd_zero (f : Fin n \u2192 \u03b1) : partialProd f 0 = 1", "start": [225, 1], "end": [226, 88], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd_succ", "code": "@[to_additive]\ntheorem partialProd_succ (f : Fin n \u2192 \u03b1) (j : Fin n) :\n    partialProd f j.succ = partialProd f (Fin.castSucc j) * f j", "start": [230, 1], "end": [233, 89], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd_succ'", "code": "@[to_additive]\ntheorem partialProd_succ' (f : Fin (n + 1) \u2192 \u03b1) (j : Fin (n + 1)) :\n    partialProd f j.succ = f 0 * partialProd (Fin.tail f) j", "start": [237, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd_left_inv", "code": "@[to_additive]\ntheorem partialProd_left_inv {G : Type*} [Group G] (f : Fin (n + 1) \u2192 G) :\n    (f 0 \u2022 partialProd fun i : Fin n => (f i)\u207b\u00b9 * f i.succ) = f", "start": [245, 1], "end": [250, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.partialProd_right_inv", "code": "@[to_additive]\ntheorem partialProd_right_inv {G : Type*} [Group G] (f : Fin n \u2192 G) (i : Fin n) :\n    (partialProd f (Fin.castSucc i))\u207b\u00b9 * partialProd f i.succ = f i", "start": [254, 1], "end": [268, 68], "kind": "commanddeclaration"}, {"full_name": "Fin.inv_partialProd_mul_eq_contractNth", "code": "@[to_additive\n      \"Let `(g\u2080, g\u2081, ..., g\u2099)` be a tuple of elements in `G\u207f\u207a\u00b9`.\n      Then if `k < j`, this says `-(g\u2080 + g\u2081 + ... + g\u2096\u208b\u2081) + (g\u2080 + g\u2081 + ... + g\u2096) = g\u2096`.\n      If `k = j`, it says `-(g\u2080 + g\u2081 + ... + g\u2096\u208b\u2081) + (g\u2080 + g\u2081 + ... + g\u2096\u208a\u2081) = g\u2096 + g\u2096\u208a\u2081`.\n      If `k > j`, it says `-(g\u2080 + g\u2081 + ... + g\u2096) + (g\u2080 + g\u2081 + ... + g\u2096\u208a\u2081) = g\u2096\u208a\u2081.`\n      Useful for defining group cohomology.\"]\ntheorem inv_partialProd_mul_eq_contractNth {G : Type*} [Group G] (g : Fin (n + 1) \u2192 G)\n    (j : Fin (n + 1)) (k : Fin n) :\n    (partialProd g (j.succ.succAbove (Fin.castSucc k)))\u207b\u00b9 * partialProd g (j.succAbove k).succ =\n      j.contractNth (\u00b7 * \u00b7) g k", "start": [272, 1], "end": [301, 32], "kind": "commanddeclaration"}, {"full_name": "finFunctionFinEquiv", "code": "@[simps!]\ndef finFunctionFinEquiv {m n : \u2115} : (Fin n \u2192 Fin m) \u2243 Fin (m ^ n) :=\n  Equiv.ofRightInverseOfCardLE (le_of_eq <| by simp_rw [Fintype.card_fun, Fintype.card_fin])\n    (fun f => \u27e8\u2211 i, f i * m ^ (i : \u2115), by\n      induction' n with n ih\n      \u00b7 simp\n      cases m\n      \u00b7 dsimp only [Nat.zero_eq] at f exact isEmptyElim (f <| Fin.last _)\n      simp_rw [Fin.sum_univ_castSucc, Fin.coe_castSucc, Fin.val_last]\n      refine' (add_lt_add_of_lt_of_le (ih _) <| mul_le_mul_right' (Fin.is_le _) _).trans_eq _\n      rw [\u2190 one_add_mul (_ : \u2115), add_comm, pow_succ]\n      rfl\u27e9)\n    (fun a b => \u27e8a / m ^ (b : \u2115) % m, by\n      cases' n with n\n      \u00b7 exact b.elim0\n      cases' m with m\n      \u00b7 dsimp only [Nat.zero_eq] at a rw [zero_pow n.succ_pos] at a\n        exact a.elim0\n      \u00b7 exact Nat.mod_lt _ m.succ_pos\u27e9)\n    fun a => by\n      dsimp\n      induction' n with n ih\n      \u00b7 haveI : Subsingleton (Fin (m ^ 0)) := (Fin.castIso <| pow_zero _).toEquiv.subsingleton\n        exact Subsingleton.elim _ _\n      simp_rw [Fin.forall_iff, Fin.ext_iff] at ih\n      ext\n      simp_rw [Fin.sum_univ_succ, Fin.val_zero, Fin.val_succ, pow_zero, Nat.div_one,\n        mul_one, pow_succ, \u2190 Nat.div_div_eq_div_mul, mul_left_comm _ m, \u2190 mul_sum]\n      rw [ih _ (Nat.div_lt_of_lt_mul ?_), Nat.mod_add_div]\n      exact a.is_lt.trans_eq (pow_succ _ _)", "start": [309, 1], "end": [344, 44], "kind": "commanddeclaration"}, {"full_name": "finFunctionFinEquiv_apply", "code": "theorem finFunctionFinEquiv_apply {m n : \u2115} (f : Fin n \u2192 Fin m) :\n    (finFunctionFinEquiv f : \u2115) = \u2211 i : Fin n, \u2191(f i) * m ^ (i : \u2115)", "start": [347, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "finFunctionFinEquiv_single", "code": "theorem finFunctionFinEquiv_single {m n : \u2115} [NeZero m] (i : Fin n) (j : Fin m) :\n    (finFunctionFinEquiv (Pi.single i j) : \u2115) = j * m ^ (i : \u2115)", "start": [352, 1], "end": [356, 54], "kind": "commanddeclaration"}, {"full_name": "finPiFinEquiv", "code": "def finPiFinEquiv {m : \u2115} {n : Fin m \u2192 \u2115} : (\u2200 i : Fin m, Fin (n i)) \u2243 Fin (\u220f i : Fin m, n i) :=\n  Equiv.ofRightInverseOfCardLE (le_of_eq <| by simp_rw [Fintype.card_pi, Fintype.card_fin])\n    (fun f => \u27e8\u2211 i, f i * \u220f j, n (Fin.castLE i.is_lt.le j), by\n      induction' m with m ih\n      \u00b7 simp\n      rw [Fin.prod_univ_castSucc, Fin.sum_univ_castSucc]\n      suffices\n        \u2200 (n : Fin m \u2192 \u2115) (nn : \u2115) (f : \u2200 i : Fin m, Fin (n i)) (fn : Fin nn),\n          ((\u2211 i : Fin m, \u2191(f i) * \u220f j : Fin i, n (Fin.castLE i.prop.le j)) + \u2191fn * \u220f j, n j) <\n            (\u220f i : Fin m, n i) * nn by\n        replace := this (Fin.init n) (n (Fin.last _)) (Fin.init f) (f (Fin.last _))\n        rw [\u2190 Fin.snoc_init_self f]\n        simp (config := { singlePass := true }) only [\u2190 Fin.snoc_init_self n]\n        simp_rw [Fin.snoc_castSucc, Fin.snoc_last, Fin.snoc_init_self n]\n        exact this\n      intro n nn f fn\n      cases nn\n      \u00b7 dsimp only [Nat.zero_eq] at fn exact isEmptyElim fn\n      refine' (add_lt_add_of_lt_of_le (ih _) <| mul_le_mul_right' (Fin.is_le _) _).trans_eq _\n      rw [\u2190 one_add_mul (_ : \u2115), mul_comm, add_comm]\n      rfl\u27e9)\n    (fun a b => \u27e8(a / \u220f j : Fin b, n (Fin.castLE b.is_lt.le j)) % n b, by\n      cases m\n      \u00b7 exact b.elim0\n      cases' h : n b with nb\n      \u00b7 rw [prod_eq_zero (Finset.mem_univ _) h] at a\n        exact isEmptyElim a\n      exact Nat.mod_lt _ nb.succ_pos\u27e9)\n    (by\n      intro a; revert a; dsimp only [Fin.val_mk]\n      refine' Fin.consInduction _ _ n\n      \u00b7 intro a\n        haveI : Subsingleton (Fin (\u220f i : Fin 0, i.elim0)) :=\n          (Fin.castIso <| prod_empty).toEquiv.subsingleton\n        exact Subsingleton.elim _ _\n      \u00b7 intro n x xs ih a\n        simp_rw [Fin.forall_iff, Fin.ext_iff] at ih\n        ext\n        simp_rw [Fin.sum_univ_succ, Fin.cons_succ]\n        have := fun i : Fin n =>\n          Fintype.prod_equiv (Fin.castIso <| Fin.val_succ i).toEquiv\n            (fun j => (Fin.cons x xs : _ \u2192 \u2115) (Fin.castLE (Fin.is_lt _).le j))\n            (fun j => (Fin.cons x xs : _ \u2192 \u2115) (Fin.castLE (Nat.succ_le_succ (Fin.is_lt _).le) j))\n            fun j => rfl\n        simp_rw [this]\n        clear this\n        dsimp only [Fin.val_zero]\n        simp_rw [Fintype.prod_empty, Nat.div_one, mul_one, Fin.cons_zero, Fin.prod_univ_succ]\n        change (_ + \u2211 y : _, _ / (x * _) % _ * (x * _)) = _\n        simp_rw [\u2190 Nat.div_div_eq_div_mul, mul_left_comm (_ % _ : \u2115), \u2190 mul_sum]\n        convert Nat.mod_add_div _ _\n        refine (ih (a / x) (Nat.div_lt_of_lt_mul <| a.is_lt.trans_eq ?_))\n        exact Fin.prod_univ_succ _\n        )", "start": [359, 1], "end": [427, 17], "kind": "commanddeclaration"}, {"full_name": "finPiFinEquiv_apply", "code": "theorem finPiFinEquiv_apply {m : \u2115} {n : Fin m \u2192 \u2115} (f : \u2200 i : Fin m, Fin (n i)) :\n    (finPiFinEquiv f : \u2115) = \u2211 i, f i * \u220f j, n (Fin.castLE i.is_lt.le j)", "start": [430, 1], "end": [431, 79], "kind": "commanddeclaration"}, {"full_name": "finPiFinEquiv_single", "code": "theorem finPiFinEquiv_single {m : \u2115} {n : Fin m \u2192 \u2115} [\u2200 i, NeZero (n i)] (i : Fin m)\n    (j : Fin (n i)) :\n    (finPiFinEquiv (Pi.single i j : \u2200 i : Fin m, Fin (n i)) : \u2115) =\n      j * \u220f j, n (Fin.castLE i.is_lt.le j)", "start": [434, 1], "end": [440, 54], "kind": "commanddeclaration"}, {"full_name": "List.prod_take_ofFn", "code": "@[to_additive]\ntheorem prod_take_ofFn {n : \u2115} (f : Fin n \u2192 \u03b1) (i : \u2115) :\n    ((ofFn f).take i).prod = \u220f j in Finset.univ.filter fun j : Fin n => j.val < i, f j", "start": [449, 1], "end": [475, 24], "kind": "commanddeclaration"}, {"full_name": "List.prod_ofFn", "code": "@[to_additive]\ntheorem prod_ofFn {n : \u2115} {f : Fin n \u2192 \u03b1} : (ofFn f).prod = \u220f i, f i", "start": [479, 1], "end": [483, 9], "kind": "commanddeclaration"}, {"full_name": "List.alternatingProd_eq_finset_prod", "code": "@[to_additive]\ntheorem alternatingProd_eq_finset_prod {G : Type*} [CommGroup G] :\n    \u2200 (L : List G), alternatingProd L = \u220f i : Fin L.length, L.get i ^ (-1 : \u2124) ^ (i : \u2115)", "start": [490, 1], "end": [505, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Indicator.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.indicator", "code": "def indicator (s : Finset \u03b9) (f : \u2200 i \u2208 s, \u03b1) : \u03b9 \u2192\u2080 \u03b1\n    where\n  toFun i :=\n    haveI := Classical.decEq \u03b9\n    if H : i \u2208 s then f i H else 0\n  support :=\n    haveI := Classical.decEq \u03b1\n    (s.attach.filter fun i : s => f i.1 i.2 \u2260 0).map (Embedding.subtype _)\n  mem_support_toFun i := by\n    classical simp", "start": [31, 1], "end": [41, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.indicator_of_mem", "code": "theorem indicator_of_mem (hi : i \u2208 s) (f : \u2200 i \u2208 s, \u03b1) : indicator s f i = f i hi", "start": [44, 1], "end": [45, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.indicator_of_not_mem", "code": "theorem indicator_of_not_mem (hi : i \u2209 s) (f : \u2200 i \u2208 s, \u03b1) : indicator s f i = 0", "start": [48, 1], "end": [49, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.indicator_apply", "code": "@[simp]\ntheorem indicator_apply [DecidableEq \u03b9] : indicator s f i = if hi : i \u2208 s then f i hi else 0", "start": [54, 1], "end": [57, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.indicator_injective", "code": "theorem indicator_injective : Injective fun f : \u2200 i \u2208 s, \u03b1 => indicator s f", "start": [60, 1], "end": [64, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_indicator_subset", "code": "theorem support_indicator_subset : ((indicator s f).support : Set \u03b9) \u2286 s", "start": [67, 1], "end": [71, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_eq_indicator", "code": "lemma single_eq_indicator (b : \u03b1) : single i b = indicator {i} (fun _ _ => b) := by\n  classical\n  ext j\n  simp [single_apply, indicator_apply, @eq_comm _ j]", "start": [74, 1], "end": [77, 53], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Membership.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Operations.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/FreeMonoid/Basic.lean", "Mathlib/Data/Finset/NoncommProd.lean"], "premises": [{"full_name": "SubmonoidClass.coe_list_prod", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_list_prod (l : List S) : (l.prod : M) = (l.map (\u2191)).prod", "start": [47, 1], "end": [49, 54], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.coe_multiset_prod", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_multiset_prod {M} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] (m : Multiset S) :\n    (m.prod : M) = (m.map (\u2191)).prod", "start": [53, 1], "end": [56, 58], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.coe_finset_prod", "code": "@[to_additive (attr := norm_cast)] theorem coe_finset_prod {\u03b9 M} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] (f : \u03b9 \u2192 S)\n    (s : Finset \u03b9) : \u2191(\u220f i in s, f i) = (\u220f i in s, f i : M)", "start": [60, 1], "end": [63, 51], "kind": "commanddeclaration"}, {"full_name": "list_prod_mem", "code": "@[to_additive \"Sum of a list of elements in an `AddSubmonoid` is in the `AddSubmonoid`.\"]\ntheorem list_prod_mem {l : List M} (hl : \u2200 x \u2208 l, x \u2208 S) : l.prod \u2208 S", "start": [71, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "multiset_prod_mem", "code": "@[to_additive\n      \"Sum of a multiset of elements in an `AddSubmonoid` of an `AddCommMonoid` is\n      in the `AddSubmonoid`.\"]\ntheorem multiset_prod_mem {M} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] (m : Multiset M)\n    (hm : \u2200 a \u2208 m, a \u2208 S) : m.prod \u2208 S", "start": [80, 1], "end": [88, 24], "kind": "commanddeclaration"}, {"full_name": "prod_mem", "code": "@[to_additive\n      \"Sum of elements in an `AddSubmonoid` of an `AddCommMonoid` indexed by a `Finset`\n      is in the `AddSubmonoid`.\"]\ntheorem prod_mem {M : Type*} [CommMonoid M] [SetLike B M] [SubmonoidClass B M] {\u03b9 : Type*}\n    {t : Finset \u03b9} {f : \u03b9 \u2192 M} (h : \u2200 c \u2208 t, f c \u2208 S) : (\u220f c in t, f c) \u2208 S", "start": [92, 1], "end": [101, 17], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_list_prod", "code": "@[to_additive (attr := norm_cast)] theorem coe_list_prod (l : List s) : (l.prod : M) = (l.map (\u2191)).prod", "start": [109, 1], "end": [111, 28], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_multiset_prod", "code": "@[to_additive (attr := norm_cast)] theorem coe_multiset_prod {M} [CommMonoid M] (S : Submonoid M) (m : Multiset S) :\n    (m.prod : M) = (m.map (\u2191)).prod", "start": [115, 1], "end": [118, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_finset_prod", "code": "@[to_additive (attr := norm_cast, simp)]\ntheorem coe_finset_prod {\u03b9 M} [CommMonoid M] (S : Submonoid M) (f : \u03b9 \u2192 S) (s : Finset \u03b9) :\n    \u2191(\u220f i in s, f i) = (\u220f i in s, f i : M)", "start": [122, 1], "end": [125, 25], "kind": "commanddeclaration"}, {"full_name": "Submonoid.list_prod_mem", "code": "@[to_additive \"Sum of a list of elements in an `AddSubmonoid` is in the `AddSubmonoid`.\"]\ntheorem list_prod_mem {l : List M} (hl : \u2200 x \u2208 l, x \u2208 s) : l.prod \u2208 s", "start": [129, 1], "end": [134, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.multiset_prod_mem", "code": "@[to_additive\n      \"Sum of a multiset of elements in an `AddSubmonoid` of an `AddCommMonoid` is\n      in the `AddSubmonoid`.\"]\ntheorem multiset_prod_mem {M} [CommMonoid M] (S : Submonoid M) (m : Multiset M)\n    (hm : \u2200 a \u2208 m, a \u2208 S) : m.prod \u2208 S", "start": [138, 1], "end": [146, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.multiset_noncommProd_mem", "code": "@[to_additive]\ntheorem multiset_noncommProd_mem (S : Submonoid M) (m : Multiset M) (comm) (h : \u2200 x \u2208 m, x \u2208 S) :\n    m.noncommProd comm \u2208 S", "start": [150, 1], "end": [155, 36], "kind": "commanddeclaration"}, {"full_name": "Submonoid.prod_mem", "code": "@[to_additive\n      \"Sum of elements in an `AddSubmonoid` of an `AddCommMonoid` indexed by a `Finset`\n      is in the `AddSubmonoid`.\"]\ntheorem prod_mem {M : Type*} [CommMonoid M] (S : Submonoid M) {\u03b9 : Type*} {t : Finset \u03b9}\n    {f : \u03b9 \u2192 M} (h : \u2200 c \u2208 t, f c \u2208 S) : (\u220f c in t, f c) \u2208 S", "start": [159, 1], "end": [168, 17], "kind": "commanddeclaration"}, {"full_name": "Submonoid.noncommProd_mem", "code": "@[to_additive]\ntheorem noncommProd_mem (S : Submonoid M) {\u03b9 : Type*} (t : Finset \u03b9) (f : \u03b9 \u2192 M) (comm)\n    (h : \u2200 c \u2208 t, f c \u2208 S) : t.noncommProd f comm \u2208 S", "start": [172, 1], "end": [179, 15], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_iSup_of_directed", "code": "@[to_additive]\ntheorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Submonoid M} (hS : Directed (\u00b7 \u2264 \u00b7) S)\n    {x : M} : (x \u2208 \u2a06 i, S i) \u2194 \u2203 i, x \u2208 S i", "start": [197, 1], "end": [207, 47], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_iSup_of_directed", "code": "@[to_additive]\ntheorem coe_iSup_of_directed {\u03b9} [Nonempty \u03b9] {S : \u03b9 \u2192 Submonoid M} (hS : Directed (\u00b7 \u2264 \u00b7) S) :\n    ((\u2a06 i, S i : Submonoid M) : Set M) = \u22c3 i, \u2191(S i)", "start": [211, 1], "end": [214, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sSup_of_directedOn", "code": "@[to_additive]\ntheorem mem_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) {x : M} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "start": [218, 1], "end": [222, 92], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_sSup_of_directedOn", "code": "@[to_additive]\ntheorem coe_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) : (\u2191(sSup S) : Set M) = \u22c3 s \u2208 S, \u2191s", "start": [226, 1], "end": [229, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sup_left", "code": "@[to_additive]\ntheorem mem_sup_left {S T : Submonoid M} : \u2200 {x : M}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [233, 1], "end": [236, 20], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sup_right", "code": "@[to_additive]\ntheorem mem_sup_right {S T : Submonoid M} : \u2200 {x : M}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [240, 1], "end": [243, 21], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mul_mem_sup", "code": "@[to_additive]\ntheorem mul_mem_sup {S T : Submonoid M} {x y : M} (hx : x \u2208 S) (hy : y \u2208 T) : x * y \u2208 S \u2294 T", "start": [247, 1], "end": [249, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_iSup_of_mem", "code": "@[to_additive]\ntheorem mem_iSup_of_mem {\u03b9 : Sort*} {S : \u03b9 \u2192 Submonoid M} (i : \u03b9) :\n    \u2200 {x : M}, x \u2208 S i \u2192 x \u2208 iSup S", "start": [253, 1], "end": [257, 20], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sSup_of_mem", "code": "@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Submonoid M)} {s : Submonoid M} (hs : s \u2208 S) :\n    \u2200 {x : M}, x \u2208 s \u2192 x \u2208 sSup S", "start": [261, 1], "end": [265, 19], "kind": "commanddeclaration"}, {"full_name": "Submonoid.iSup_induction", "code": "@[to_additive (attr := elab_as_elim)\n      \" An induction principle for elements of `\u2a06 i, S i`.\n      If `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\n      then it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {\u03b9 : Sort*} (S : \u03b9 \u2192 Submonoid M) {C : M \u2192 Prop} {x : M} (hx : x \u2208 \u2a06 i, S i)\n    (hp : \u2200 (i), \u2200 x \u2208 S i, C x) (h1 : C 1) (hmul : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C x", "start": [269, 1], "end": [281, 18], "kind": "commanddeclaration"}, {"full_name": "Submonoid.iSup_induction'", "code": "@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubmonoid.iSup_induction`. \"]\ntheorem iSup_induction' {\u03b9 : Sort*} (S : \u03b9 \u2192 Submonoid M) {C : \u2200 x, (x \u2208 \u2a06 i, S i) \u2192 Prop}\n    (hp : \u2200 (i), \u2200 (x) (hxS : x \u2208 S i), C x (mem_iSup_of_mem i hxS)) (h1 : C 1 (one_mem _))\n    (hmul : \u2200 x y hx hy, C x hx \u2192 C y hy \u2192 C (x * y) (mul_mem \u2039_\u203a \u2039_\u203a)) {x : M}\n    (hx : x \u2208 \u2a06 i, S i) : C x hx", "start": [285, 1], "end": [296, 36], "kind": "commanddeclaration"}, {"full_name": "FreeMonoid.closure_range_of", "code": "@[to_additive]\ntheorem closure_range_of : closure (Set.range <| @of \u03b1) = \u22a4", "start": [310, 1], "end": [314, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_singleton_eq", "code": "theorem closure_singleton_eq (x : M) : closure ({x} : Set M) = mrange (powersHom M x)", "start": [326, 1], "end": [328, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_closure_singleton", "code": "theorem mem_closure_singleton {x y : M} : y \u2208 closure ({x} : Set M) \u2194 \u2203 n : \u2115, x ^ n = y", "start": [331, 1], "end": [334, 45], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_closure_singleton_self", "code": "theorem mem_closure_singleton_self {y : M} : y \u2208 closure ({y} : Set M)", "start": [337, 1], "end": [338, 41], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_singleton_one", "code": "theorem closure_singleton_one : closure ({1} : Set M) = \u22a5", "start": [341, 1], "end": [342, 50], "kind": "commanddeclaration"}, {"full_name": "Submonoid.card_bot", "code": "@[to_additive]\ntheorem card_bot {_ : Fintype (\u22a5 : Submonoid M)} : card (\u22a5 : Submonoid M) = 1", "start": [351, 1], "end": [354, 81], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_bot_of_card_le", "code": "@[to_additive]\ntheorem eq_bot_of_card_le (h : card S \u2264 1) : S = \u22a5", "start": [356, 1], "end": [359, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_bot_of_card_eq", "code": "@[to_additive]\ntheorem eq_bot_of_card_eq (h : card S = 1) : S = \u22a5", "start": [361, 1], "end": [363, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.card_le_one_iff_eq_bot", "code": "@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot : card S \u2264 1 \u2194 S = \u22a5", "start": [365, 1], "end": [370, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.eq_bot_iff_card", "code": "@[to_additive]\nlemma eq_bot_iff_card : S = \u22a5 \u2194 card S = 1 :=\n  \u27e8by rintro rfl;  exact card_bot, eq_bot_of_card_eq\u27e9", "start": [372, 1], "end": [374, 54], "kind": "mathlibtacticlemma"}, {"full_name": "FreeMonoid.mrange_lift", "code": "@[to_additive]\ntheorem _root_.FreeMonoid.mrange_lift {\u03b1} (f : \u03b1 \u2192 M) :\n    mrange (FreeMonoid.lift f) = closure (Set.range f)", "start": [378, 1], "end": [382, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_eq_mrange", "code": "@[to_additive]\ntheorem closure_eq_mrange (s : Set M) : closure s = mrange (FreeMonoid.lift ((\u2191) : s \u2192 M))", "start": [386, 1], "end": [388, 49], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_eq_image_prod", "code": "@[to_additive]\ntheorem closure_eq_image_prod (s : Set M) :\n    (closure s : Set M) = List.prod '' { l : List M | \u2200 x \u2208 l, x \u2208 s }", "start": [392, 1], "end": [396, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.exists_list_of_mem_closure", "code": "@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set M} {x : M} (hx : x \u2208 closure s) :\n    \u2203 (l : List M) (_ : \u2200 y \u2208 l, y \u2208 s), l.prod = x", "start": [400, 1], "end": [403, 78], "kind": "commanddeclaration"}, {"full_name": "Submonoid.exists_multiset_of_mem_closure", "code": "@[to_additive]\ntheorem exists_multiset_of_mem_closure {M : Type*} [CommMonoid M] {s : Set M} {x : M}\n    (hx : x \u2208 closure s) : \u2203 (l : Multiset M) (_ : \u2200 y \u2208 l, y \u2208 s), l.prod = x", "start": [407, 1], "end": [411, 48], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_induction_left", "code": "@[to_additive]\ntheorem closure_induction_left {s : Set M} {p : M \u2192 Prop} {x : M} (h : x \u2208 closure s) (H1 : p 1)\n    (Hmul : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x * y)) : p x", "start": [415, 1], "end": [422, 75], "kind": "commanddeclaration"}, {"full_name": "Submonoid.induction_of_closure_eq_top_left", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_left {s : Set M} {p : M \u2192 Prop} (hs : closure s = \u22a4) (x : M)\n    (H1 : p 1) (Hmul : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x * y)) : p x", "start": [426, 1], "end": [433, 12], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_induction_right", "code": "@[to_additive]\ntheorem closure_induction_right {s : Set M} {p : M \u2192 Prop} {x : M} (h : x \u2208 closure s) (H1 : p 1)\n    (Hmul : \u2200 (x), \u2200 y \u2208 s, p x \u2192 p (x * y)) : p x", "start": [437, 1], "end": [443, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.induction_of_closure_eq_top_right", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_right {s : Set M} {p : M \u2192 Prop} (hs : closure s = \u22a4) (x : M)\n    (H1 : p 1) (Hmul : \u2200 (x), \u2200 y \u2208 s, p x \u2192 p (x * y)) : p x", "start": [447, 1], "end": [452, 12], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powers", "code": "def powers (n : M) : Submonoid M :=\n  Submonoid.copy (mrange (powersHom M n)) (Set.range ((\u00b7 ^ \u00b7) n : \u2115 \u2192 M)) <|\n    Set.ext fun n => exists_congr fun i => by simp; rfl", "start": [456, 1], "end": [459, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_powers", "code": "theorem mem_powers (n : M) : n \u2208 powers n", "start": [462, 1], "end": [463, 17], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_powers", "code": "theorem coe_powers (x : M) : \u2191(powers x) = Set.range fun n : \u2115 => x ^ n", "start": [466, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_powers_iff", "code": "theorem mem_powers_iff (x z : M) : x \u2208 powers z \u2194 \u2203 n : \u2115, z ^ n = x", "start": [470, 1], "end": [471, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powers_eq_closure", "code": "theorem powers_eq_closure (n : M) : powers n = closure {n}", "start": [474, 1], "end": [476, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powers_subset", "code": "theorem powers_subset {n : M} {P : Submonoid M} (h : n \u2208 P) : powers n \u2264 P", "start": [479, 1], "end": [481, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powers_one", "code": "theorem powers_one : powers (1 : M) = \u22a5", "start": [484, 1], "end": [485, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.groupPowers", "code": "abbrev groupPowers {x : M} {n : \u2115} (hpos : 0 < n) (hx : x ^ n = 1) : Group (powers x) where\n  inv x := x ^ (n - 1)\n  mul_left_inv y := Subtype.ext <| by\n    obtain \u27e8_, k, rfl\u27e9 := y\n    simp only [coe_one, coe_mul, SubmonoidClass.coe_pow]\n    rw [\u2190 pow_succ', Nat.sub_add_cancel hpos, \u2190 pow_mul, mul_comm, pow_mul, hx, one_pow]\n  zpow z x := x ^ z.natMod n\n  zpow_zero' z := by simp only [Int.natMod, Int.zero_emod, Int.toNat_zero, pow_zero]\n  zpow_neg' m x := Subtype.ext <| by\n    obtain \u27e8_, k, rfl\u27e9 := x\n    simp only [\u2190 pow_mul, Int.natMod, SubmonoidClass.coe_pow]\n    rw [Int.negSucc_coe, \u2190 Int.add_mul_emod_self (b := (m + 1 : \u2115))]\n    nth_rw 1 [\u2190 mul_one ((m + 1 : \u2115) : \u2124)]\n    rw [\u2190 sub_eq_neg_add, \u2190 mul_sub, \u2190 Int.coe_pred_of_pos hpos]; norm_cast\n    simp only [Int.toNat_coe_nat]\n    rw [mul_comm, pow_mul, \u2190 pow_eq_pow_mod _ hx, mul_comm k, mul_assoc, pow_mul _ (_ % _),\n      \u2190 pow_eq_pow_mod _ hx, pow_mul, pow_mul]\n  zpow_succ' m x := Subtype.ext <| by\n    obtain \u27e8_, k, rfl\u27e9 := x\n    simp only [\u2190 pow_mul, Int.natMod, Int.ofNat_eq_coe, SubmonoidClass.coe_pow, coe_mul]\n    norm_cast\n    iterate 2 rw [Int.toNat_coe_nat, mul_comm, pow_mul, \u2190 pow_eq_pow_mod _ hx]\n    rw [\u2190 pow_mul _ m, mul_comm, pow_mul, \u2190 pow_succ, \u2190 pow_mul, mul_comm, pow_mul]", "start": [488, 1], "end": [511, 84], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow", "code": "@[simps!]\ndef pow (n : M) (m : \u2115) : powers n :=\n  (powersHom M n).mrangeRestrict (Multiplicative.ofAdd m)", "start": [513, 1], "end": [516, 58], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow_apply", "code": "theorem pow_apply (n : M) (m : \u2115) : Submonoid.pow n m = \u27e8n ^ m, m, rfl\u27e9", "start": [520, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.log", "code": "def log [DecidableEq M] {n : M} (p : powers n) : \u2115 :=\n  Nat.find <| (mem_powers_iff p.val n).mp p.prop", "start": [524, 1], "end": [526, 49], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow_log_eq_self", "code": "@[simp]\ntheorem pow_log_eq_self [DecidableEq M] {n : M} (p : powers n) : pow n (log p) = p", "start": [529, 1], "end": [531, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow_right_injective_iff_pow_injective", "code": "theorem pow_right_injective_iff_pow_injective {n : M} :\n    (Function.Injective fun m : \u2115 => n ^ m) \u2194 Function.Injective (pow n)", "start": [534, 1], "end": [536, 44], "kind": "commanddeclaration"}, {"full_name": "Submonoid.log_pow_eq_self", "code": "@[simp]\ntheorem log_pow_eq_self [DecidableEq M] {n : M} (h : Function.Injective fun m : \u2115 => n ^ m)\n    (m : \u2115) : log (pow n m) = m", "start": [539, 1], "end": [542, 66], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powLogEquiv", "code": "@[simps]\ndef powLogEquiv [DecidableEq M] {n : M} (h : Function.Injective fun m : \u2115 => n ^ m) :\n    Multiplicative \u2115 \u2243* powers n where\n  toFun m := pow n (Multiplicative.toAdd m)\n  invFun m := Multiplicative.ofAdd (log m)\n  left_inv := log_pow_eq_self h\n  right_inv := pow_log_eq_self\n  map_mul' _ _ := by simp only [pow, map_mul, ofAdd_add, toAdd_mul]", "start": [545, 1], "end": [554, 68], "kind": "commanddeclaration"}, {"full_name": "Submonoid.log_mul", "code": "theorem log_mul [DecidableEq M] {n : M} (h : Function.Injective fun m : \u2115 => n ^ m)\n    (x y : powers (n : M)) : log (x * y) = log x + log y", "start": [559, 1], "end": [561, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.log_pow_int_eq_self", "code": "theorem log_pow_int_eq_self {x : \u2124} (h : 1 < x.natAbs) (m : \u2115) : log (pow x m) = m", "start": [564, 1], "end": [565, 63], "kind": "commanddeclaration"}, {"full_name": "Submonoid.map_powers", "code": "@[simp]\ntheorem map_powers {N : Type*} {F : Type*} [Monoid N] [MonoidHomClass F M N] (f : F) (m : M) :\n    (powers m).map f = powers (f m)", "start": [568, 1], "end": [571, 69], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closureCommMonoidOfComm", "code": "@[to_additive\n      \"If all the elements of a set `s` commute, then `closure s` forms an additive\n      commutative monoid.\"]\ndef closureCommMonoidOfComm {s : Set M} (hcomm : \u2200 (a) (_ : a \u2208 s) (b) (_ : b \u2208 s), a * b = b * a) :\n    CommMonoid (closure s) :=\n  { (closure s).toMonoid with\n    mul_comm := fun x y => by\n      ext\n      simp only [Submonoid.coe_mul]\n      exact\n        closure_induction\u2082 x.prop y.prop hcomm Commute.one_left Commute.one_right\n          (fun x y z => Commute.mul_left) fun x y z => Commute.mul_right }", "start": [574, 1], "end": [586, 75], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.of_mclosure_eq_top", "code": "@[to_additive]\ntheorem IsScalarTower.of_mclosure_eq_top {N \u03b1} [Monoid M] [MulAction M N] [SMul N \u03b1] [MulAction M \u03b1]\n    {s : Set M} (htop : Submonoid.closure s = \u22a4)\n    (hs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), (x \u2022 y) \u2022 z = x \u2022 y \u2022 z) : IsScalarTower M N \u03b1", "start": [592, 1], "end": [601, 42], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.of_mclosure_eq_top", "code": "@[to_additive]\ntheorem SMulCommClass.of_mclosure_eq_top {N \u03b1} [Monoid M] [SMul N \u03b1] [MulAction M \u03b1] {s : Set M}\n    (htop : Submonoid.closure s = \u22a4) (hs : \u2200 x \u2208 s, \u2200 (y : N) (z : \u03b1), x \u2022 y \u2022 z = y \u2022 x \u2022 z) :\n    SMulCommClass M N \u03b1", "start": [605, 1], "end": [614, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.sup_eq_range", "code": "@[to_additive]\ntheorem sup_eq_range (s t : Submonoid N) : s \u2294 t = mrange (s.subtype.coprod t.subtype)", "start": [624, 1], "end": [627, 51], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_sup", "code": "@[to_additive]\ntheorem mem_sup {s t : Submonoid N} {x : N} : x \u2208 s \u2294 t \u2194 \u2203 y \u2208 s, \u2203 z \u2208 t, y * z = x", "start": [631, 1], "end": [634, 33], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.closure_singleton_eq", "code": "theorem closure_singleton_eq (x : A) :\n    closure ({x} : Set A) = AddMonoidHom.mrange (multiplesHom A x)", "start": [646, 1], "end": [649, 61], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_closure_singleton", "code": "theorem mem_closure_singleton {x y : A} : y \u2208 closure ({x} : Set A) \u2194 \u2203 n : \u2115, n \u2022 x = y", "start": [652, 1], "end": [655, 58], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.closure_singleton_zero", "code": "theorem closure_singleton_zero : closure ({0} : Set A) = \u22a5", "start": [658, 1], "end": [659, 62], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.multiples", "code": "def multiples (x : A) : AddSubmonoid A :=\n  AddSubmonoid.copy (AddMonoidHom.mrange (multiplesHom A x)) (Set.range (fun i => i \u2022 x : \u2115 \u2192 A)) <|\n    Set.ext fun n => exists_congr fun i => by simp", "start": [662, 1], "end": [665, 51], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mul_right_mem_add_closure", "code": "theorem mul_right_mem_add_closure (ha : a \u2208 AddSubmonoid.closure (S : Set R)) (hb : b \u2208 S) :\n    a * b \u2208 AddSubmonoid.closure (S : Set R)", "start": [701, 1], "end": [711, 95], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mul_mem_add_closure", "code": "theorem mul_mem_add_closure (ha : a \u2208 AddSubmonoid.closure (S : Set R))\n    (hb : b \u2208 AddSubmonoid.closure (S : Set R)) : a * b \u2208 AddSubmonoid.closure (S : Set R)", "start": [714, 1], "end": [725, 91], "kind": "commanddeclaration"}, {"full_name": "MulMemClass.mul_left_mem_add_closure", "code": "theorem mul_left_mem_add_closure (ha : a \u2208 S) (hb : b \u2208 AddSubmonoid.closure (S : Set R)) :\n    a * b \u2208 AddSubmonoid.closure (S : Set R)", "start": [728, 1], "end": [732, 76], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_closure_pair", "code": "@[to_additive\n      \"An element is in the closure of a two-element set if it is a linear combination of\n      those two elements.\"]\ntheorem mem_closure_pair {A : Type*} [CommMonoid A] (a b c : A) :\n    c \u2208 Submonoid.closure ({a, b} : Set A) \u2194 \u2203 m n : \u2115, a ^ m * b ^ n = c", "start": [739, 1], "end": [747, 56], "kind": "commanddeclaration"}, {"full_name": "ofMul_image_powers_eq_multiples_ofMul", "code": "theorem ofMul_image_powers_eq_multiples_ofMul [Monoid M] {x : M} :\n    Additive.ofMul '' (Submonoid.powers x : Set M) = AddSubmonoid.multiples (Additive.ofMul x)", "start": [755, 1], "end": [764, 20], "kind": "commanddeclaration"}, {"full_name": "ofAdd_image_multiples_eq_powers_ofAdd", "code": "theorem ofAdd_image_multiples_eq_powers_ofAdd [AddMonoid A] {x : A} :\n    Multiplicative.ofAdd '' (AddSubmonoid.multiples x : Set A) =\n      Submonoid.powers (Multiplicative.ofAdd x)", "start": [767, 1], "end": [772, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Fin.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.tail", "code": "def tail (s : Fin (n + 1) \u2192\u2080 M) : Fin n \u2192\u2080 M :=\n  Finsupp.equivFunOnFinite.symm (Fin.tail s)", "start": [29, 1], "end": [31, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons", "code": "def cons (y : M) (s : Fin n \u2192\u2080 M) : Fin (n + 1) \u2192\u2080 M :=\n  Finsupp.equivFunOnFinite.symm (Fin.cons y s : Fin (n + 1) \u2192 M)", "start": [34, 1], "end": [36, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.tail_apply", "code": "theorem tail_apply : tail t i = t i.succ", "start": [39, 1], "end": [40, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_zero", "code": "@[simp]\ntheorem cons_zero : cons y s 0 = y", "start": [43, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_succ", "code": "@[simp]\ntheorem cons_succ : cons y s i.succ = s i", "start": [48, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.tail_cons", "code": "@[simp]\ntheorem tail_cons : tail (cons y s) = s", "start": [54, 1], "end": [56, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_tail", "code": "@[simp]\ntheorem cons_tail : cons (t 0) (tail t) = t", "start": [59, 1], "end": [64, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_zero_zero", "code": "@[simp]\ntheorem cons_zero_zero : cons 0 (0 : Fin n \u2192\u2080 M) = 0", "start": [67, 1], "end": [73, 9], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_ne_zero_of_left", "code": "theorem cons_ne_zero_of_left (h : y \u2260 0) : cons y s \u2260 0", "start": [78, 1], "end": [80, 59], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_ne_zero_of_right", "code": "theorem cons_ne_zero_of_right (h : s \u2260 0) : cons y s \u2260 0", "start": [83, 1], "end": [86, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.cons_ne_zero_iff", "code": "theorem cons_ne_zero_iff : cons y s \u2260 0 \u2194 y \u2260 0 \u2228 s \u2260 0", "start": [89, 1], "end": [92, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Order.lean", "imports": ["Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Algebra/Order/Ring/WithTop.lean", "Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Order/AbsoluteValue.lean"], "premises": [{"full_name": "Finset.le_prod_nonempty_of_submultiplicative_on_pred", "code": "@[to_additive le_sum_nonempty_of_subadditive_on_pred]\ntheorem le_prod_nonempty_of_submultiplicative_on_pred (f : M \u2192 N) (p : M \u2192 Prop)\n    (h_mul : \u2200 x y, p x \u2192 p y \u2192 f (x * y) \u2264 f x * f y) (hp_mul : \u2200 x y, p x \u2192 p y \u2192 p (x * y))\n    (g : \u03b9 \u2192 M) (s : Finset \u03b9) (hs_nonempty : s.Nonempty) (hs : \u2200 i \u2208 s, p (g i)) :\n    f (\u220f i in s, g i) \u2264 \u220f i in s, f (g i)", "start": [33, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.le_prod_nonempty_of_submultiplicative", "code": "@[to_additive le_sum_nonempty_of_subadditive]\ntheorem le_prod_nonempty_of_submultiplicative (f : M \u2192 N) (h_mul : \u2200 x y, f (x * y) \u2264 f x * f y)\n    {s : Finset \u03b9} (hs : s.Nonempty) (g : \u03b9 \u2192 M) : f (\u220f i in s, g i) \u2264 \u220f i in s, f (g i)", "start": [56, 1], "end": [62, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.le_prod_of_submultiplicative_on_pred", "code": "@[to_additive le_sum_of_subadditive_on_pred]\ntheorem le_prod_of_submultiplicative_on_pred (f : M \u2192 N) (p : M \u2192 Prop) (h_one : f 1 = 1)\n    (h_mul : \u2200 x y, p x \u2192 p y \u2192 f (x * y) \u2264 f x * f y) (hp_mul : \u2200 x y, p x \u2192 p y \u2192 p (x * y))\n    (g : \u03b9 \u2192 M) {s : Finset \u03b9} (hs : \u2200 i \u2208 s, p (g i)) : f (\u220f i in s, g i) \u2264 \u220f i in s, f (g i)", "start": [70, 1], "end": [80, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.le_prod_of_submultiplicative", "code": "@[to_additive le_sum_of_subadditive]\ntheorem le_prod_of_submultiplicative (f : M \u2192 N) (h_one : f 1 = 1)\n    (h_mul : \u2200 x y, f (x * y) \u2264 f x * f y) (s : Finset \u03b9) (g : \u03b9 \u2192 M) :\n    f (\u220f i in s, g i) \u2264 \u220f i in s, f (g i)", "start": [90, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod'", "code": "@[to_additive sum_le_sum]\ntheorem prod_le_prod' (h : \u2200 i \u2208 s, f i \u2264 g i) : \u220f i in s, f i \u2264 \u220f i in s, g i", "start": [108, 1], "end": [113, 38], "kind": "commanddeclaration"}, {"full_name": "GCongr.prod_le_prod'", "code": "@[to_additive (attr := gcongr) GCongr.sum_le_sum]\ntheorem _root_.GCongr.prod_le_prod' (h : \u2200 i \u2208 s, f i \u2264 g i) : s.prod f \u2264 s.prod g", "start": [122, 1], "end": [129, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.one_le_prod'", "code": "@[to_additive sum_nonneg]\ntheorem one_le_prod' (h : \u2200 i \u2208 s, 1 \u2264 f i) : 1 \u2264 \u220f i in s, f i", "start": [138, 1], "end": [140, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.one_le_prod''", "code": "@[to_additive Finset.sum_nonneg']\ntheorem one_le_prod'' (h : \u2200 i : \u03b9, 1 \u2264 f i) : 1 \u2264 \u220f i : \u03b9 in s, f i", "start": [144, 1], "end": [146, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_one'", "code": "@[to_additive sum_nonpos]\ntheorem prod_le_one' (h : \u2200 i \u2208 s, f i \u2264 1) : \u220f i in s, f i \u2264 1", "start": [150, 1], "end": [152, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod_of_subset_of_one_le'", "code": "@[to_additive sum_le_sum_of_subset_of_nonneg]\ntheorem prod_le_prod_of_subset_of_one_le' (h : s \u2286 t) (hf : \u2200 i \u2208 t, i \u2209 s \u2192 1 \u2264 f i) :\n    \u220f i in s, f i \u2264 \u220f i in t, f i", "start": [156, 1], "end": [163, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mono_set_of_one_le'", "code": "@[to_additive sum_mono_set_of_nonneg]\ntheorem prod_mono_set_of_one_le' (hf : \u2200 x, 1 \u2264 f x) : Monotone fun s \u21a6 \u220f x in s, f x", "start": [167, 1], "end": [169, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_univ_prod_of_one_le'", "code": "@[to_additive sum_le_univ_sum_of_nonneg]\ntheorem prod_le_univ_prod_of_one_le' [Fintype \u03b9] {s : Finset \u03b9} (w : \u2200 x, 1 \u2264 f x) :\n    \u220f x in s, f x \u2264 \u220f x, f x", "start": [173, 1], "end": [176, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_one_iff_of_one_le'", "code": "@[to_additive sum_eq_zero_iff_of_nonneg]\ntheorem prod_eq_one_iff_of_one_le' :\n    (\u2200 i \u2208 s, 1 \u2264 f i) \u2192 ((\u220f i in s, f i) = 1 \u2194 \u2200 i \u2208 s, f i = 1)", "start": [181, 1], "end": [190, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_one_iff_of_le_one'", "code": "@[to_additive existing sum_eq_zero_iff_of_nonneg]\ntheorem prod_eq_one_iff_of_le_one' :\n    (\u2200 i \u2208 s, f i \u2264 1) \u2192 ((\u220f i in s, f i) = 1 \u2194 \u2200 i \u2208 s, f i = 1)", "start": [194, 1], "end": [197, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.single_le_prod'", "code": "@[to_additive single_le_sum]\ntheorem single_le_prod' (hf : \u2200 i \u2208 s, 1 \u2264 f i) {a} (h : a \u2208 s) : f a \u2264 \u220f x in s, f x", "start": [202, 1], "end": [207, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_pow_card", "code": "@[to_additive sum_le_card_nsmul]\ntheorem prod_le_pow_card (s : Finset \u03b9) (f : \u03b9 \u2192 N) (n : N) (h : \u2200 x \u2208 s, f x \u2264 n) :\n    s.prod f \u2264 n ^ s.card", "start": [211, 1], "end": [217, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.pow_card_le_prod", "code": "@[to_additive card_nsmul_le_sum]\ntheorem pow_card_le_prod (s : Finset \u03b9) (f : \u03b9 \u2192 N) (n : N) (h : \u2200 x \u2208 s, n \u2264 f x) :\n    n ^ s.card \u2264 s.prod f", "start": [221, 1], "end": [223, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.card_biUnion_le_card_mul", "code": "theorem card_biUnion_le_card_mul [DecidableEq \u03b2] (s : Finset \u03b9) (f : \u03b9 \u2192 Finset \u03b2) (n : \u2115)\n    (h : \u2200 a \u2208 s, (f a).card \u2264 n) : (s.biUnion f).card \u2264 s.card * n", "start": [227, 1], "end": [229, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_fiberwise_le_prod_of_one_le_prod_fiber'", "code": "@[to_additive sum_fiberwise_le_sum_of_sum_fiber_nonneg]\ntheorem prod_fiberwise_le_prod_of_one_le_prod_fiber' {t : Finset \u03b9'} {g : \u03b9 \u2192 \u03b9'} {f : \u03b9 \u2192 N}\n    (h : \u2200 (y) (_ : y \u2209 t), (1 : N) \u2264 \u220f x in s.filter fun x \u21a6 g x = y, f x) :\n    (\u220f y in t, \u220f x in s.filter fun x \u21a6 g x = y, f x) \u2264 \u220f x in s, f x", "start": [235, 1], "end": [244, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod_fiberwise_of_prod_fiber_le_one'", "code": "@[to_additive sum_le_sum_fiberwise_of_sum_fiber_nonpos]\ntheorem prod_le_prod_fiberwise_of_prod_fiber_le_one' {t : Finset \u03b9'} {g : \u03b9 \u2192 \u03b9'} {f : \u03b9 \u2192 N}\n    (h : \u2200 (y) (_ : y \u2209 t), \u220f x in s.filter fun x \u21a6 g x = y, f x \u2264 1) :\n    \u220f x in s, f x \u2264 \u220f y in t, \u220f x in s.filter fun x \u21a6 g x = y, f x", "start": [249, 1], "end": [253, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.abs_sum_le_sum_abs", "code": "theorem abs_sum_le_sum_abs {G : Type*} [LinearOrderedAddCommGroup G] (f : \u03b9 \u2192 G) (s : Finset \u03b9) :\n    |\u2211 i in s, f i| \u2264 \u2211 i in s, |f i|", "start": [259, 1], "end": [260, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.abs_sum_of_nonneg", "code": "theorem abs_sum_of_nonneg {G : Type*} [LinearOrderedAddCommGroup G] {f : \u03b9 \u2192 G} {s : Finset \u03b9}\n    (hf : \u2200 i \u2208 s, 0 \u2264 f i) : |\u2211 i : \u03b9 in s, f i| = \u2211 i : \u03b9 in s, f i", "start": [263, 1], "end": [265, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.abs_sum_of_nonneg'", "code": "theorem abs_sum_of_nonneg' {G : Type*} [LinearOrderedAddCommGroup G] {f : \u03b9 \u2192 G} {s : Finset \u03b9}\n    (hf : \u2200 i, 0 \u2264 f i) : |\u2211 i : \u03b9 in s, f i| = \u2211 i : \u03b9 in s, f i", "start": [268, 1], "end": [270, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.abs_prod", "code": "theorem abs_prod {R : Type*} [LinearOrderedCommRing R] {f : \u03b9 \u2192 R} {s : Finset \u03b9} :\n    |\u220f x in s, f x| = \u220f x in s, |f x|", "start": [273, 1], "end": [275, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_mul_card_image_of_maps_to", "code": "theorem card_le_mul_card_image_of_maps_to {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2}\n    (Hf : \u2200 a \u2208 s, f a \u2208 t) (n : \u2115) (hn : \u2200 a \u2208 t, (s.filter fun x \u21a6 f x = a).card \u2264 n) :\n    s.card \u2264 n * t.card", "start": [282, 1], "end": [288, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_mul_card_image", "code": "theorem card_le_mul_card_image {f : \u03b1 \u2192 \u03b2} (s : Finset \u03b1) (n : \u2115)\n    (hn : \u2200 a \u2208 s.image f, (s.filter fun x \u21a6 f x = a).card \u2264 n) : s.card \u2264 n * (s.image f).card", "start": [291, 1], "end": [293, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_card_image_le_card_of_maps_to", "code": "theorem mul_card_image_le_card_of_maps_to {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b1} {t : Finset \u03b2}\n    (Hf : \u2200 a \u2208 s, f a \u2208 t) (n : \u2115) (hn : \u2200 a \u2208 t, n \u2264 (s.filter fun x \u21a6 f x = a).card) :\n    n * t.card \u2264 s.card", "start": [296, 1], "end": [302, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_card_image_le_card", "code": "theorem mul_card_image_le_card {f : \u03b1 \u2192 \u03b2} (s : Finset \u03b1) (n : \u2115)\n    (hn : \u2200 a \u2208 s.image f, n \u2264 (s.filter fun x \u21a6 f x = a).card) : n * (s.image f).card \u2264 s.card", "start": [305, 1], "end": [307, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_inter_le", "code": "theorem sum_card_inter_le (h : \u2200 a \u2208 s, (B.filter <| (\u00b7 \u2208 \u00b7) a).card \u2264 n) :\n    (\u2211 t in B, (s \u2229 t).card) \u2264 s.card * n", "start": [316, 1], "end": [322, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_le", "code": "theorem sum_card_le [Fintype \u03b1] (h : \u2200 a, (B.filter <| (\u00b7 \u2208 \u00b7) a).card \u2264 n) :\n    \u2211 s in B, s.card \u2264 Fintype.card \u03b1 * n", "start": [325, 1], "end": [331, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sum_card_inter", "code": "theorem le_sum_card_inter (h : \u2200 a \u2208 s, n \u2264 (B.filter <| (\u00b7 \u2208 \u00b7) a).card) :\n    s.card * n \u2264 \u2211 t in B, (s \u2229 t).card", "start": [334, 1], "end": [340, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.le_sum_card", "code": "theorem le_sum_card [Fintype \u03b1] (h : \u2200 a, n \u2264 (B.filter <| (\u00b7 \u2208 \u00b7) a).card) :\n    Fintype.card \u03b1 * n \u2264 \u2211 s in B, s.card", "start": [343, 1], "end": [349, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card_inter", "code": "theorem sum_card_inter (h : \u2200 a \u2208 s, (B.filter <| (\u00b7 \u2208 \u00b7) a).card = n) :\n    (\u2211 t in B, (s \u2229 t).card) = s.card * n", "start": [352, 1], "end": [356, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_card", "code": "theorem sum_card [Fintype \u03b1] (h : \u2200 a, (B.filter <| (\u00b7 \u2208 \u00b7) a).card = n) :\n    \u2211 s in B, s.card = Fintype.card \u03b1 * n", "start": [359, 1], "end": [363, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_biUnion", "code": "theorem card_le_card_biUnion {s : Finset \u03b9} {f : \u03b9 \u2192 Finset \u03b1} (hs : (s : Set \u03b9).PairwiseDisjoint f)\n    (hf : \u2200 i \u2208 s, (f i).Nonempty) : s.card \u2264 (s.biUnion f).card", "start": [366, 1], "end": [369, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_biUnion_add_card_fiber", "code": "theorem card_le_card_biUnion_add_card_fiber {s : Finset \u03b9} {f : \u03b9 \u2192 Finset \u03b1}\n    (hs : (s : Set \u03b9).PairwiseDisjoint f) :\n    s.card \u2264 (s.biUnion f).card + (s.filter fun i \u21a6 f i = \u2205).card", "start": [372, 1], "end": [381, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_biUnion_add_one", "code": "theorem card_le_card_biUnion_add_one {s : Finset \u03b9} {f : \u03b9 \u2192 Finset \u03b1} (hf : Injective f)\n    (hs : (s : Set \u03b9).PairwiseDisjoint f) : s.card \u2264 (s.biUnion f).card + 1", "start": [384, 1], "end": [388, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_one_iff'", "code": "@[to_additive (attr := simp) sum_eq_zero_iff]\ntheorem prod_eq_one_iff' : \u220f x in s, f x = 1 \u2194 \u2200 x \u2208 s, f x = 1", "start": [397, 1], "end": [399, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod_of_subset'", "code": "@[to_additive sum_le_sum_of_subset]\ntheorem prod_le_prod_of_subset' (h : s \u2286 t) : \u220f x in s, f x \u2264 \u220f x in t, f x", "start": [403, 1], "end": [405, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_mono_set'", "code": "@[to_additive sum_mono_set]\ntheorem prod_mono_set' (f : \u03b9 \u2192 M) : Monotone fun s \u21a6 \u220f x in s, f x", "start": [409, 1], "end": [411, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod_of_ne_one'", "code": "@[to_additive sum_le_sum_of_ne_zero]\ntheorem prod_le_prod_of_ne_one' (h : \u2200 x \u2208 s, f x \u2260 1 \u2192 x \u2208 t) :\n    \u220f x in s, f x \u2264 \u220f x in t, f x", "start": [415, 1], "end": [426, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_lt_prod'", "code": "@[to_additive sum_lt_sum]\ntheorem prod_lt_prod' (Hle : \u2200 i \u2208 s, f i \u2264 g i) (Hlt : \u2203 i \u2208 s, f i < g i) :\n    \u220f i in s, f i < \u220f i in s, g i", "start": [436, 1], "end": [442, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_lt_prod_of_nonempty'", "code": "@[to_additive sum_lt_sum_of_nonempty]\ntheorem prod_lt_prod_of_nonempty' (hs : s.Nonempty) (Hlt : \u2200 i \u2208 s, f i < g i) :\n    \u220f i in s, f i < \u220f i in s, g i", "start": [446, 1], "end": [453, 26], "kind": "commanddeclaration"}, {"full_name": "GCongr.prod_lt_prod_of_nonempty'", "code": "@[to_additive (attr := gcongr) GCongr.sum_lt_sum_of_nonempty]\ntheorem _root_.GCongr.prod_lt_prod_of_nonempty' (hs : s.Nonempty) (Hlt : \u2200 i \u2208 s, f i < g i) :\n    s.prod f < s.prod g", "start": [457, 1], "end": [466, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_lt_prod_of_subset'", "code": "@[to_additive sum_lt_sum_of_subset]\ntheorem prod_lt_prod_of_subset' (h : s \u2286 t) {i : \u03b9} (ht : i \u2208 t) (hs : i \u2209 s) (hlt : 1 < f i)\n    (hle : \u2200 j \u2208 t, j \u2209 s \u2192 1 \u2264 f j) : \u220f j in s, f j < \u220f j in t, f j", "start": [477, 1], "end": [489, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.single_lt_prod'", "code": "@[to_additive single_lt_sum]\ntheorem single_lt_prod' {i j : \u03b9} (hij : j \u2260 i) (hi : i \u2208 s) (hj : j \u2208 s) (hlt : 1 < f j)\n    (hle : \u2200 k \u2208 s, k \u2260 i \u2192 1 \u2264 f k) : f i < \u220f k in s, f k", "start": [493, 1], "end": [500, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.one_lt_prod", "code": "@[to_additive sum_pos]\ntheorem one_lt_prod (h : \u2200 i \u2208 s, 1 < f i) (hs : s.Nonempty) : 1 < \u220f i in s, f i", "start": [504, 1], "end": [506, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_lt_one", "code": "@[to_additive]\ntheorem prod_lt_one (h : \u2200 i \u2208 s, f i < 1) (hs : s.Nonempty) : \u220f i in s, f i < 1", "start": [510, 1], "end": [512, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.one_lt_prod'", "code": "@[to_additive sum_pos']\ntheorem one_lt_prod' (h : \u2200 i \u2208 s, 1 \u2264 f i) (hs : \u2203 i \u2208 s, 1 < f i) : 1 < \u220f i in s, f i", "start": [516, 1], "end": [518, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_lt_one'", "code": "@[to_additive]\ntheorem prod_lt_one' (h : \u2200 i \u2208 s, f i \u2264 1) (hs : \u2203 i \u2208 s, f i < 1) : \u220f i in s, f i < 1", "start": [522, 1], "end": [524, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_prod_iff_of_le", "code": "@[to_additive]\ntheorem prod_eq_prod_iff_of_le {f g : \u03b9 \u2192 M} (h : \u2200 i \u2208 s, f i \u2264 g i) :\n    ((\u220f i in s, f i) = \u220f i in s, g i) \u2194 \u2200 i \u2208 s, f i = g i", "start": [528, 1], "end": [539, 70], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_lt_of_prod_lt'", "code": "@[to_additive exists_lt_of_sum_lt]\ntheorem exists_lt_of_prod_lt' (Hlt : \u220f i in s, f i < \u220f i in s, g i) : \u2203 i \u2208 s, f i < g i", "start": [549, 1], "end": [552, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le_of_prod_le'", "code": "@[to_additive exists_le_of_sum_le]\ntheorem exists_le_of_prod_le' (hs : s.Nonempty) (Hle : \u220f i in s, f i \u2264 \u220f i in s, g i) :\n    \u2203 i \u2208 s, f i \u2264 g i", "start": [556, 1], "end": [560, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_one_lt_of_prod_one_of_exists_ne_one'", "code": "@[to_additive exists_pos_of_sum_zero_of_exists_nonzero]\ntheorem exists_one_lt_of_prod_one_of_exists_ne_one' (f : \u03b9 \u2192 M) (h\u2081 : \u220f i in s, f i = 1)\n    (h\u2082 : \u2203 i \u2208 s, f i \u2260 1) : \u2203 i \u2208 s, 1 < f i", "start": [564, 1], "end": [572, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_nonneg", "code": "theorem prod_nonneg (h0 : \u2200 i \u2208 s, 0 \u2264 f i) : 0 \u2264 \u220f i in s, f i", "start": [585, 1], "end": [586, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_prod", "code": "theorem prod_le_prod (h0 : \u2200 i \u2208 s, 0 \u2264 f i) (h1 : \u2200 i \u2208 s, f i \u2264 g i) :\n    \u220f i in s, f i \u2264 \u220f i in s, g i", "start": [589, 1], "end": [601, 79], "kind": "commanddeclaration"}, {"full_name": "GCongr.prod_le_prod", "code": "@[gcongr]\ntheorem _root_.GCongr.prod_le_prod (h0 : \u2200 i \u2208 s, 0 \u2264 f i) (h1 : \u2200 i \u2208 s, f i \u2264 g i) :\n    s.prod f \u2264 s.prod g", "start": [604, 1], "end": [612, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_le_one", "code": "theorem prod_le_one (h0 : \u2200 i \u2208 s, 0 \u2264 f i) (h1 : \u2200 i \u2208 s, f i \u2264 1) : \u220f i in s, f i \u2264 1", "start": [614, 1], "end": [618, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_add_prod_le", "code": "theorem prod_add_prod_le {i : \u03b9} {f g h : \u03b9 \u2192 R} (hi : i \u2208 s) (h2i : g i + h i \u2264 f i)\n    (hgf : \u2200 j \u2208 s, j \u2260 i \u2192 g j \u2264 f j) (hhf : \u2200 j \u2208 s, j \u2260 i \u2192 h j \u2264 f j) (hg : \u2200 i \u2208 s, 0 \u2264 g i)\n    (hh : \u2200 i \u2208 s, 0 \u2264 h i) : ((\u220f i in s, g i) + \u220f i in s, h i) \u2264 \u220f i in s, f i", "start": [621, 1], "end": [638, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pos", "code": "theorem prod_pos (h0 : \u2200 i \u2208 s, 0 < f i) : 0 < \u220f i in s, f i", "start": [648, 1], "end": [649, 82], "kind": "commanddeclaration"}, {"full_name": "CanonicallyOrderedCommSemiring.prod_pos", "code": "@[simp] lemma _root_.CanonicallyOrderedCommSemiring.prod_pos [Nontrivial R] :\n    0 < \u220f i in s, f i \u2194 (\u2200 i \u2208 s, (0 : R) < f i) :=\n  CanonicallyOrderedCommSemiring.multiset_prod_pos.trans Multiset.forall_mem_map_iff", "start": [658, 1], "end": [661, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.prod_add_prod_le'", "code": "theorem prod_add_prod_le' (hi : i \u2208 s) (h2i : g i + h i \u2264 f i) (hgf : \u2200 j \u2208 s, j \u2260 i \u2192 g j \u2264 f j)\n    (hhf : \u2200 j \u2208 s, j \u2260 i \u2192 h j \u2264 f j) : ((\u220f i in s, g i) + \u220f i in s, h i) \u2264 \u220f i in s, f i", "start": [664, 1], "end": [677, 17], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_mono'", "code": "@[to_additive (attr := mono) sum_mono]\ntheorem prod_mono' : Monotone fun f : \u03b9 \u2192 M \u21a6 \u220f i, f i", "start": [688, 1], "end": [690, 39], "kind": "commanddeclaration"}, {"full_name": "Fintype.one_le_prod", "code": "@[to_additive sum_nonneg]\nlemma one_le_prod (hf : 1 \u2264 f) : 1 \u2264 \u220f i, f i := Finset.one_le_prod' \u03bb _ _ \u21a6 hf _", "start": [694, 1], "end": [695, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_le_one", "code": "@[to_additive] lemma prod_le_one (hf : f \u2264 1) : \u220f i, f i \u2264 1 := Finset.prod_le_one' \u03bb _ _ \u21a6 hf _", "start": [697, 1], "end": [697, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_strictMono'", "code": "@[to_additive sum_strictMono]\ntheorem prod_strictMono' : StrictMono fun f : \u03b9 \u2192 M \u21a6 \u220f x, f x", "start": [704, 1], "end": [708, 69], "kind": "commanddeclaration"}, {"full_name": "Fintype.one_lt_prod", "code": "@[to_additive sum_pos]\nlemma one_lt_prod (hf : 1 < f) : 1 < \u220f i, f i :=\n  Finset.one_lt_prod' (\u03bb _ _ \u21a6 hf.le _) $ by simpa using (Pi.lt_def.1 hf).2", "start": [712, 1], "end": [714, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_lt_one", "code": "@[to_additive]\nlemma prod_lt_one (hf : f < 1) : \u220f i, f i < 1 :=\n  Finset.prod_lt_one' (\u03bb _ _ \u21a6 hf.le _) $ by simpa using (Pi.lt_def.1 hf).2", "start": [716, 1], "end": [718, 76], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.one_lt_prod_iff_of_one_le", "code": "@[to_additive sum_pos_iff_of_nonneg]\nlemma one_lt_prod_iff_of_one_le (hf : 1 \u2264 f) : 1 < \u220f i, f i \u2194 1 < f := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, one_lt_prod]", "start": [720, 1], "end": [722, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_lt_one_iff_of_le_one", "code": "@[to_additive]\nlemma prod_lt_one_iff_of_le_one (hf : f \u2264 1) : \u220f i, f i < 1 \u2194 f < 1 := by\n  obtain rfl | hf := hf.eq_or_lt <;> simp [*, prod_lt_one]", "start": [724, 1], "end": [726, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_eq_one_iff_of_one_le", "code": "@[to_additive]\nlemma prod_eq_one_iff_of_one_le (hf : 1 \u2264 f) : \u220f i, f i = 1 \u2194 f = 1 := by\n  simpa only [(one_le_prod hf).not_gt_iff_eq, hf.not_gt_iff_eq]\n    using (one_lt_prod_iff_of_one_le hf).not", "start": [728, 1], "end": [731, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Fintype.prod_eq_one_iff_of_le_one", "code": "@[to_additive]\nlemma prod_eq_one_iff_of_le_one (hf : f \u2264 1) : \u220f i, f i = 1 \u2194 f = 1 := by\n  simpa only [(prod_le_one hf).not_gt_iff_eq, hf.not_gt_iff_eq, eq_comm]\n    using (prod_lt_one_iff_of_le_one hf).not", "start": [733, 1], "end": [736, 45], "kind": "mathlibtacticlemma"}, {"full_name": "WithTop.prod_lt_top", "code": "theorem prod_lt_top [CommMonoidWithZero R] [NoZeroDivisors R] [Nontrivial R] [DecidableEq R] [LT R]\n    {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop R} (h : \u2200 i \u2208 s, f i \u2260 \u22a4) : \u220f i in s, f i < \u22a4", "start": [745, 1], "end": [749, 52], "kind": "commanddeclaration"}, {"full_name": "WithTop.sum_eq_top_iff", "code": "theorem sum_eq_top_iff [AddCommMonoid M] {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop M} :\n    \u2211 i in s, f i = \u22a4 \u2194 \u2203 i \u2208 s, f i = \u22a4", "start": [752, 1], "end": [755, 55], "kind": "commanddeclaration"}, {"full_name": "WithTop.sum_lt_top_iff", "code": "theorem sum_lt_top_iff [AddCommMonoid M] [LT M] {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop M} :\n    \u2211 i in s, f i < \u22a4 \u2194 \u2200 i \u2208 s, f i < \u22a4", "start": [758, 1], "end": [761, 84], "kind": "commanddeclaration"}, {"full_name": "WithTop.sum_lt_top", "code": "theorem sum_lt_top [AddCommMonoid M] [LT M] {s : Finset \u03b9} {f : \u03b9 \u2192 WithTop M}\n    (h : \u2200 i \u2208 s, f i \u2260 \u22a4) : \u2211 i in s, f i < \u22a4", "start": [764, 1], "end": [767, 68], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.sum_le", "code": "theorem AbsoluteValue.sum_le [Semiring R] [OrderedSemiring S] (abv : AbsoluteValue R S)\n    (s : Finset \u03b9) (f : \u03b9 \u2192 R) : abv (\u2211 i in s, f i) \u2264 \u2211 i in s, abv (f i)", "start": [776, 1], "end": [778, 63], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.abv_sum", "code": "theorem IsAbsoluteValue.abv_sum [Semiring R] [OrderedSemiring S] (abv : R \u2192 S) [IsAbsoluteValue abv]\n    (f : \u03b9 \u2192 R) (s : Finset \u03b9) : abv (\u2211 i in s, f i) \u2264 \u2211 i in s, abv (f i)", "start": [781, 1], "end": [783, 51], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.map_prod", "code": "theorem AbsoluteValue.map_prod [CommSemiring R] [Nontrivial R] [LinearOrderedCommRing S]\n    (abv : AbsoluteValue R S) (f : \u03b9 \u2192 R) (s : Finset \u03b9) :\n    abv (\u220f i in s, f i) = \u220f i in s, abv (f i)", "start": [786, 1], "end": [789, 31], "kind": "commanddeclaration"}, {"full_name": "IsAbsoluteValue.map_prod", "code": "theorem IsAbsoluteValue.map_prod [CommSemiring R] [Nontrivial R] [LinearOrderedCommRing S]\n    (abv : R \u2192 S) [IsAbsoluteValue abv] (f : \u03b9 \u2192 R) (s : Finset \u03b9) :\n    abv (\u220f i in s, f i) = \u220f i in s, abv (f i)", "start": [792, 1], "end": [795, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GCDMonoid/Basic.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Associated.lean", "Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "NormalizationMonoid", "code": "class NormalizationMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1] where\n  \n  normUnit : \u03b1 \u2192 \u03b1\u02e3\n  \n  normUnit_zero : normUnit 0 = 1\n  \n  normUnit_mul : \u2200 {a b}, a \u2260 0 \u2192 b \u2260 0 \u2192 normUnit (a * b) = normUnit a * normUnit b\n  \n  normUnit_coe_units : \u2200 u : \u03b1\u02e3, normUnit u = u\u207b\u00b9", "start": [72, 1], "end": [82, 50], "kind": "commanddeclaration"}, {"full_name": "normUnit_one", "code": "@[simp]\ntheorem normUnit_one : normUnit (1 : \u03b1) = 1", "start": [93, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "normalize", "code": "def normalize : \u03b1 \u2192*\u2080 \u03b1 where\n  toFun x := x * normUnit x\n  map_zero' := by\n    simp only [normUnit_zero]\n    exact mul_one (0:\u03b1)\n  map_one' := by dsimp only; rw [normUnit_one, one_mul]; rfl\n  map_mul' x y :=\n    (by_cases fun hx : x = 0 => by dsimp only; rw [hx, zero_mul, zero_mul, zero_mul]) fun hx =>\n      (by_cases fun hy : y = 0 => by dsimp only; rw [hy, mul_zero, zero_mul, mul_zero]) fun hy => by\n        simp only [normUnit_mul hx hy, Units.val_mul]; simp only [mul_assoc, mul_left_comm y]", "start": [99, 1], "end": [109, 94], "kind": "commanddeclaration"}, {"full_name": "associated_normalize", "code": "theorem associated_normalize (x : \u03b1) : Associated x (normalize x)", "start": [112, 1], "end": [113, 11], "kind": "commanddeclaration"}, {"full_name": "normalize_associated", "code": "theorem normalize_associated (x : \u03b1) : Associated (normalize x) x", "start": [116, 1], "end": [117, 32], "kind": "commanddeclaration"}, {"full_name": "associated_normalize_iff", "code": "theorem associated_normalize_iff {x y : \u03b1} : Associated x (normalize y) \u2194 Associated x y", "start": [120, 1], "end": [121, 89], "kind": "commanddeclaration"}, {"full_name": "normalize_associated_iff", "code": "theorem normalize_associated_iff {x y : \u03b1} : Associated (normalize x) y \u2194 Associated x y", "start": [124, 1], "end": [125, 89], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_normalize", "code": "theorem Associates.mk_normalize (x : \u03b1) : Associates.mk (normalize x) = Associates.mk x", "start": [128, 1], "end": [129, 64], "kind": "commanddeclaration"}, {"full_name": "normalize_apply", "code": "@[simp]\ntheorem normalize_apply (x : \u03b1) : normalize x = x * normUnit x", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "normalize_zero", "code": "theorem normalize_zero : normalize (0 : \u03b1) = 0", "start": [139, 1], "end": [140, 21], "kind": "commanddeclaration"}, {"full_name": "normalize_one", "code": "theorem normalize_one : normalize (1 : \u03b1) = 1", "start": [145, 1], "end": [146, 20], "kind": "commanddeclaration"}, {"full_name": "normalize_coe_units", "code": "theorem normalize_coe_units (u : \u03b1\u02e3) : normalize (u : \u03b1) = 1", "start": [149, 1], "end": [149, 72], "kind": "commanddeclaration"}, {"full_name": "normalize_eq_zero", "code": "theorem normalize_eq_zero {x : \u03b1} : normalize x = 0 \u2194 x = 0", "start": [152, 1], "end": [154, 38], "kind": "commanddeclaration"}, {"full_name": "normalize_eq_one", "code": "theorem normalize_eq_one {x : \u03b1} : normalize x = 1 \u2194 IsUnit x", "start": [157, 1], "end": [158, 89], "kind": "commanddeclaration"}, {"full_name": "normUnit_mul_normUnit", "code": "@[simp]\ntheorem normUnit_mul_normUnit (a : \u03b1) : normUnit (a * normUnit a) = 1", "start": [162, 1], "end": [167, 78], "kind": "commanddeclaration"}, {"full_name": "normalize_idem", "code": "theorem normalize_idem (x : \u03b1) : normalize (normalize x) = normalize x", "start": [170, 1], "end": [170, 82], "kind": "commanddeclaration"}, {"full_name": "normalize_eq_normalize", "code": "theorem normalize_eq_normalize {a b : \u03b1} (hab : a \u2223 b) (hba : b \u2223 a) :\n    normalize a = normalize b", "start": [173, 1], "end": [182, 66], "kind": "commanddeclaration"}, {"full_name": "normalize_eq_normalize_iff", "code": "theorem normalize_eq_normalize_iff {x y : \u03b1} : normalize x = normalize y \u2194 x \u2223 y \u2227 y \u2223 x", "start": [185, 1], "end": [187, 36], "kind": "commanddeclaration"}, {"full_name": "dvd_antisymm_of_normalize_eq", "code": "theorem dvd_antisymm_of_normalize_eq {a b : \u03b1} (ha : normalize a = a) (hb : normalize b = b)\n    (hab : a \u2223 b) (hba : b \u2223 a) : a = b", "start": [190, 1], "end": [192, 43], "kind": "commanddeclaration"}, {"full_name": "dvd_normalize_iff", "code": "theorem dvd_normalize_iff {a b : \u03b1} : a \u2223 normalize b \u2194 a \u2223 b", "start": [196, 1], "end": [197, 22], "kind": "commanddeclaration"}, {"full_name": "normalize_dvd_iff", "code": "theorem normalize_dvd_iff {a b : \u03b1} : normalize a \u2223 b \u2194 a \u2223 b", "start": [201, 1], "end": [202, 22], "kind": "commanddeclaration"}, {"full_name": "Associates.out", "code": "protected def out : Associates \u03b1 \u2192 \u03b1 :=\n  (Quotient.lift (normalize : \u03b1 \u2192 \u03b1)) fun a _ \u27e8_, hu\u27e9 =>\n    hu \u25b8 normalize_eq_normalize \u27e8_, rfl\u27e9 (Units.mul_right_dvd.2 <| dvd_refl a)", "start": [213, 1], "end": [216, 79], "kind": "commanddeclaration"}, {"full_name": "Associates.out_mk", "code": "@[simp]\ntheorem out_mk (a : \u03b1) : (Associates.mk a).out = normalize a", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.out_one", "code": "@[simp]\ntheorem out_one : (1 : Associates \u03b1).out = 1", "start": [224, 1], "end": [226, 16], "kind": "commanddeclaration"}, {"full_name": "Associates.out_mul", "code": "theorem out_mul (a b : Associates \u03b1) : (a * b).out = a.out * b.out", "start": [229, 1], "end": [231, 83], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_out_iff", "code": "theorem dvd_out_iff (a : \u03b1) (b : Associates \u03b1) : a \u2223 b.out \u2194 Associates.mk a \u2264 b", "start": [234, 1], "end": [236, 81], "kind": "commanddeclaration"}, {"full_name": "Associates.out_dvd_iff", "code": "theorem out_dvd_iff (a : \u03b1) (b : Associates \u03b1) : b.out \u2223 a \u2194 b \u2264 Associates.mk a", "start": [239, 1], "end": [241, 81], "kind": "commanddeclaration"}, {"full_name": "Associates.out_top", "code": "@[simp]\ntheorem out_top : (\u22a4 : Associates \u03b1).out = 0", "start": [244, 1], "end": [246, 17], "kind": "commanddeclaration"}, {"full_name": "Associates.normalize_out", "code": "@[simp 1100]\ntheorem normalize_out (a : Associates \u03b1) : normalize a.out = a.out", "start": [250, 1], "end": [252, 40], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_out", "code": "@[simp]\ntheorem mk_out (a : Associates \u03b1) : Associates.mk a.out = a", "start": [255, 1], "end": [257, 38], "kind": "commanddeclaration"}, {"full_name": "Associates.out_injective", "code": "theorem out_injective : Function.Injective (Associates.out : _ \u2192 \u03b1)", "start": [260, 1], "end": [261, 40], "kind": "commanddeclaration"}, {"full_name": "GCDMonoid", "code": "class GCDMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1] where\n  \n  gcd : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  \n  lcm : \u03b1 \u2192 \u03b1 \u2192 \u03b1\n  \n  gcd_dvd_left : \u2200 a b, gcd a b \u2223 a\n  \n  gcd_dvd_right : \u2200 a b, gcd a b \u2223 b\n  \n  dvd_gcd : \u2200 {a b c}, a \u2223 c \u2192 a \u2223 b \u2192 a \u2223 gcd c b\n  \n  gcd_mul_lcm : \u2200 a b, Associated (gcd a b * lcm a b) (a * b)\n  \n  lcm_zero_left : \u2200 a, lcm 0 a = 0\n  \n  lcm_zero_right : \u2200 a, lcm a 0 = 0", "start": [268, 1], "end": [288, 36], "kind": "commanddeclaration"}, {"full_name": "NormalizedGCDMonoid", "code": "class NormalizedGCDMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1] extends NormalizationMonoid \u03b1,\n  GCDMonoid \u03b1 where\n  \n  normalize_gcd : \u2200 a b, normalize (gcd a b) = gcd a b\n  \n  normalize_lcm : \u2200 a b, normalize (lcm a b) = lcm a b", "start": [291, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "normalize_gcd", "code": "@[simp 1100]\ntheorem normalize_gcd [NormalizedGCDMonoid \u03b1] : \u2200 a b : \u03b1, normalize (gcd a b) = gcd a b", "start": [314, 1], "end": [316, 36], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_lcm", "code": "theorem gcd_mul_lcm [GCDMonoid \u03b1] : \u2200 a b : \u03b1, Associated (gcd a b * lcm a b) (a * b)", "start": [319, 1], "end": [320, 24], "kind": "commanddeclaration"}, {"full_name": "dvd_gcd_iff", "code": "theorem dvd_gcd_iff [GCDMonoid \u03b1] (a b c : \u03b1) : a \u2223 gcd b c \u2194 a \u2223 b \u2227 a \u2223 c", "start": [325, 1], "end": [327, 20], "kind": "commanddeclaration"}, {"full_name": "gcd_comm", "code": "theorem gcd_comm [NormalizedGCDMonoid \u03b1] (a b : \u03b1) : gcd a b = gcd b a", "start": [330, 1], "end": [333, 53], "kind": "commanddeclaration"}, {"full_name": "gcd_comm'", "code": "theorem gcd_comm' [GCDMonoid \u03b1] (a b : \u03b1) : Associated (gcd a b) (gcd b a)", "start": [336, 1], "end": [338, 53], "kind": "commanddeclaration"}, {"full_name": "gcd_assoc", "code": "theorem gcd_assoc [NormalizedGCDMonoid \u03b1] (m n k : \u03b1) : gcd (gcd m n) k = gcd m (gcd n k)", "start": [341, 1], "end": [347, 63], "kind": "commanddeclaration"}, {"full_name": "gcd_assoc'", "code": "theorem gcd_assoc' [GCDMonoid \u03b1] (m n k : \u03b1) : Associated (gcd (gcd m n) k) (gcd m (gcd n k))", "start": [350, 1], "end": [356, 63], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_normalize", "code": "theorem gcd_eq_normalize [NormalizedGCDMonoid \u03b1] {a b c : \u03b1} (habc : gcd a b \u2223 c)\n    (hcab : c \u2223 gcd a b) : gcd a b = normalize c", "start": [365, 1], "end": [367, 55], "kind": "commanddeclaration"}, {"full_name": "gcd_zero_left", "code": "@[simp]\ntheorem gcd_zero_left [NormalizedGCDMonoid \u03b1] (a : \u03b1) : gcd 0 a = normalize a", "start": [370, 1], "end": [372, 75], "kind": "commanddeclaration"}, {"full_name": "gcd_zero_left'", "code": "theorem gcd_zero_left' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd 0 a) a", "start": [375, 1], "end": [376, 80], "kind": "commanddeclaration"}, {"full_name": "gcd_zero_right", "code": "@[simp]\ntheorem gcd_zero_right [NormalizedGCDMonoid \u03b1] (a : \u03b1) : gcd a 0 = normalize a", "start": [379, 1], "end": [381, 74], "kind": "commanddeclaration"}, {"full_name": "gcd_zero_right'", "code": "theorem gcd_zero_right' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd a 0) a", "start": [384, 1], "end": [385, 79], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_zero_iff", "code": "@[simp]\ntheorem gcd_eq_zero_iff [GCDMonoid \u03b1] (a b : \u03b1) : gcd a b = 0 \u2194 a = 0 \u2227 b = 0", "start": [388, 1], "end": [398, 26], "kind": "commanddeclaration"}, {"full_name": "gcd_one_left", "code": "@[simp]\ntheorem gcd_one_left [NormalizedGCDMonoid \u03b1] (a : \u03b1) : gcd 1 a = 1", "start": [401, 1], "end": [403, 96], "kind": "commanddeclaration"}, {"full_name": "gcd_one_left'", "code": "@[simp]\ntheorem gcd_one_left' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd 1 a) 1", "start": [406, 1], "end": [408, 55], "kind": "commanddeclaration"}, {"full_name": "gcd_one_right", "code": "@[simp]\ntheorem gcd_one_right [NormalizedGCDMonoid \u03b1] (a : \u03b1) : gcd a 1 = 1", "start": [411, 1], "end": [413, 97], "kind": "commanddeclaration"}, {"full_name": "gcd_one_right'", "code": "@[simp]\ntheorem gcd_one_right' [GCDMonoid \u03b1] (a : \u03b1) : Associated (gcd a 1) 1", "start": [416, 1], "end": [418, 56], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_gcd", "code": "theorem gcd_dvd_gcd [GCDMonoid \u03b1] {a b c d : \u03b1} (hab : a \u2223 b) (hcd : c \u2223 d) : gcd a c \u2223 gcd b d", "start": [421, 1], "end": [422, 73], "kind": "commanddeclaration"}, {"full_name": "gcd_same", "code": "@[simp]\ntheorem gcd_same [NormalizedGCDMonoid \u03b1] (a : \u03b1) : gcd a a = normalize a", "start": [425, 1], "end": [427, 74], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_left", "code": "@[simp]\ntheorem gcd_mul_left [NormalizedGCDMonoid \u03b1] (a b c : \u03b1) :\n    gcd (a * b) (a * c) = normalize a * gcd b c", "start": [430, 1], "end": [442, 99], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_left'", "code": "theorem gcd_mul_left' [GCDMonoid \u03b1] (a b c : \u03b1) :\n    Associated (gcd (a * b) (a * c)) (a * gcd b c)", "start": [445, 1], "end": [456, 101], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_right", "code": "@[simp]\ntheorem gcd_mul_right [NormalizedGCDMonoid \u03b1] (a b c : \u03b1) :\n    gcd (b * a) (c * a) = gcd b c * normalize a", "start": [459, 1], "end": [461, 89], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_right'", "code": "@[simp]\ntheorem gcd_mul_right' [GCDMonoid \u03b1] (a b c : \u03b1) : Associated (gcd (b * a) (c * a)) (gcd b c * a)", "start": [464, 1], "end": [466, 41], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_left_iff", "code": "theorem gcd_eq_left_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize a = a) :\n    gcd a b = a \u2194 a \u2223 b", "start": [469, 1], "end": [472, 101], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_right_iff", "code": "theorem gcd_eq_right_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize b = b) :\n    gcd a b = b \u2194 b \u2223 a", "start": [475, 1], "end": [476, 84], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_gcd_mul_left", "code": "theorem gcd_dvd_gcd_mul_left [GCDMonoid \u03b1] (m n k : \u03b1) : gcd m n \u2223 gcd (k * m) n", "start": [479, 1], "end": [480, 41], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_gcd_mul_right", "code": "theorem gcd_dvd_gcd_mul_right [GCDMonoid \u03b1] (m n k : \u03b1) : gcd m n \u2223 gcd (m * k) n", "start": [483, 1], "end": [484, 42], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_gcd_mul_left_right", "code": "theorem gcd_dvd_gcd_mul_left_right [GCDMonoid \u03b1] (m n k : \u03b1) : gcd m n \u2223 gcd m (k * n)", "start": [487, 1], "end": [488, 41], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_gcd_mul_right_right", "code": "theorem gcd_dvd_gcd_mul_right_right [GCDMonoid \u03b1] (m n k : \u03b1) : gcd m n \u2223 gcd m (n * k)", "start": [491, 1], "end": [492, 42], "kind": "commanddeclaration"}, {"full_name": "Associated.gcd_eq_left", "code": "theorem Associated.gcd_eq_left [NormalizedGCDMonoid \u03b1] {m n : \u03b1} (h : Associated m n) (k : \u03b1) :\n    gcd m k = gcd n k", "start": [495, 1], "end": [498, 37], "kind": "commanddeclaration"}, {"full_name": "Associated.gcd_eq_right", "code": "theorem Associated.gcd_eq_right [NormalizedGCDMonoid \u03b1] {m n : \u03b1} (h : Associated m n) (k : \u03b1) :\n    gcd k m = gcd k n", "start": [501, 1], "end": [504, 37], "kind": "commanddeclaration"}, {"full_name": "dvd_gcd_mul_of_dvd_mul", "code": "theorem dvd_gcd_mul_of_dvd_mul [GCDMonoid \u03b1] {m n k : \u03b1} (H : k \u2223 m * n) : k \u2223 gcd k m * n", "start": [507, 1], "end": [508, 67], "kind": "commanddeclaration"}, {"full_name": "dvd_gcd_mul_iff_dvd_mul", "code": "theorem dvd_gcd_mul_iff_dvd_mul [GCDMonoid \u03b1] {m n k : \u03b1} : k \u2223 gcd k m * n \u2194 k \u2223 m * n", "start": [511, 1], "end": [512, 87], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_gcd_of_dvd_mul", "code": "theorem dvd_mul_gcd_of_dvd_mul [GCDMonoid \u03b1] {m n k : \u03b1} (H : k \u2223 m * n) : k \u2223 m * gcd k n", "start": [514, 1], "end": [516, 33], "kind": "commanddeclaration"}, {"full_name": "dvd_mul_gcd_iff_dvd_mul", "code": "theorem dvd_mul_gcd_iff_dvd_mul [GCDMonoid \u03b1] {m n k : \u03b1} : k \u2223 m * gcd k n \u2194 k \u2223 m * n", "start": [519, 1], "end": [520, 87], "kind": "commanddeclaration"}, {"full_name": "exists_dvd_and_dvd_of_dvd_mul", "code": "theorem exists_dvd_and_dvd_of_dvd_mul [GCDMonoid \u03b1] {m n k : \u03b1} (H : k \u2223 m * n) :\n    \u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082", "start": [522, 1], "end": [545, 35], "kind": "commanddeclaration"}, {"full_name": "dvd_mul", "code": "theorem dvd_mul [GCDMonoid \u03b1] {k m n : \u03b1} : k \u2223 m * n \u2194 \u2203 d\u2081 d\u2082, d\u2081 \u2223 m \u2227 d\u2082 \u2223 n \u2227 k = d\u2081 * d\u2082", "start": [548, 1], "end": [551, 26], "kind": "commanddeclaration"}, {"full_name": "gcd_mul_dvd_mul_gcd", "code": "theorem gcd_mul_dvd_mul_gcd [GCDMonoid \u03b1] (k m n : \u03b1) : gcd k (m * n) \u2223 gcd k m * gcd k n", "start": [554, 1], "end": [563, 27], "kind": "commanddeclaration"}, {"full_name": "gcd_pow_right_dvd_pow_gcd", "code": "theorem gcd_pow_right_dvd_pow_gcd [GCDMonoid \u03b1] {a b : \u03b1} {k : \u2115} :\n    gcd a (b ^ k) \u2223 gcd a b ^ k", "start": [566, 1], "end": [580, 45], "kind": "commanddeclaration"}, {"full_name": "gcd_pow_left_dvd_pow_gcd", "code": "theorem gcd_pow_left_dvd_pow_gcd [GCDMonoid \u03b1] {a b : \u03b1} {k : \u2115} : gcd (a ^ k) b \u2223 gcd a b ^ k", "start": [583, 1], "end": [587, 64], "kind": "commanddeclaration"}, {"full_name": "pow_dvd_of_mul_eq_pow", "code": "theorem pow_dvd_of_mul_eq_pow [GCDMonoid \u03b1] {a b c d\u2081 d\u2082 : \u03b1} (ha : a \u2260 0) (hab : IsUnit (gcd a b))\n    {k : \u2115} (h : a * b = c ^ k) (hc : c = d\u2081 * d\u2082) (hd\u2081 : d\u2081 \u2223 a) : d\u2081 ^ k \u2260 0 \u2227 d\u2081 ^ k \u2223 a", "start": [590, 1], "end": [613, 17], "kind": "commanddeclaration"}, {"full_name": "exists_associated_pow_of_mul_eq_pow", "code": "theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid \u03b1] {a b c : \u03b1} (hab : IsUnit (gcd a b))\n    {k : \u2115} (h : a * b = c ^ k) : \u2203 d : \u03b1, Associated (d ^ k) a", "start": [616, 1], "end": [658, 35], "kind": "commanddeclaration"}, {"full_name": "exists_eq_pow_of_mul_eq_pow", "code": "theorem exists_eq_pow_of_mul_eq_pow [GCDMonoid \u03b1] [Unique \u03b1\u02e3] {a b c : \u03b1} (hab : IsUnit (gcd a b))\n    {k : \u2115} (h : a * b = c ^ k) : \u2203 d : \u03b1, a = d ^ k", "start": [661, 1], "end": [664, 38], "kind": "commanddeclaration"}, {"full_name": "gcd_greatest", "code": "theorem gcd_greatest {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [NormalizedGCDMonoid \u03b1] {a b d : \u03b1}\n    (hda : d \u2223 a) (hdb : d \u2223 b) (hd : \u2200 e : \u03b1, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) :\n    GCDMonoid.gcd a b = normalize d", "start": [667, 1], "end": [671, 49], "kind": "commanddeclaration"}, {"full_name": "gcd_greatest_associated", "code": "theorem gcd_greatest_associated {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1] {a b d : \u03b1}\n    (hda : d \u2223 a) (hdb : d \u2223 b) (hd : \u2200 e : \u03b1, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) :\n    Associated d (GCDMonoid.gcd a b)", "start": [674, 1], "end": [678, 54], "kind": "commanddeclaration"}, {"full_name": "isUnit_gcd_of_eq_mul_gcd", "code": "theorem isUnit_gcd_of_eq_mul_gcd {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1]\n    {x y x' y' : \u03b1} (ex : x = gcd x y * x') (ey : y = gcd x y * y') (h : gcd x y \u2260 0) :\n    IsUnit (gcd x' y')", "start": [681, 1], "end": [687, 27], "kind": "commanddeclaration"}, {"full_name": "extract_gcd", "code": "theorem extract_gcd {\u03b1 : Type*} [CancelCommMonoidWithZero \u03b1] [GCDMonoid \u03b1] (x y : \u03b1) :\n    \u2203 x' y', x = gcd x y * x' \u2227 y = gcd x y * y' \u2227 IsUnit (gcd x' y')", "start": [690, 1], "end": [698, 59], "kind": "commanddeclaration"}, {"full_name": "associated_gcd_left_iff", "code": "theorem associated_gcd_left_iff [GCDMonoid \u03b1] {x y : \u03b1} : Associated x (gcd x y) \u2194 x \u2223 y", "start": [701, 1], "end": [703, 79], "kind": "commanddeclaration"}, {"full_name": "associated_gcd_right_iff", "code": "theorem associated_gcd_right_iff [GCDMonoid \u03b1] {x y : \u03b1} : Associated y (gcd x y) \u2194 y \u2223 x", "start": [705, 1], "end": [707, 80], "kind": "commanddeclaration"}, {"full_name": "Irreducible.isUnit_gcd_iff", "code": "theorem Irreducible.isUnit_gcd_iff [GCDMonoid \u03b1] {x y : \u03b1} (hx : Irreducible x) :\n    IsUnit (gcd x y) \u2194 \u00ac(x \u2223 y)", "start": [709, 1], "end": [711, 100], "kind": "commanddeclaration"}, {"full_name": "Irreducible.gcd_eq_one_iff", "code": "theorem Irreducible.gcd_eq_one_iff [NormalizedGCDMonoid \u03b1] {x y : \u03b1} (hx : Irreducible x) :\n    gcd x y = 1 \u2194 \u00ac(x \u2223 y)", "start": [713, 1], "end": [715, 82], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_iff", "code": "theorem lcm_dvd_iff [GCDMonoid \u03b1] {a b c : \u03b1} : lcm a b \u2223 c \u2194 a \u2223 c \u2227 b \u2223 c", "start": [721, 1], "end": [730, 42], "kind": "commanddeclaration"}, {"full_name": "dvd_lcm_left", "code": "theorem dvd_lcm_left [GCDMonoid \u03b1] (a b : \u03b1) : a \u2223 lcm a b", "start": [733, 1], "end": [734, 41], "kind": "commanddeclaration"}, {"full_name": "dvd_lcm_right", "code": "theorem dvd_lcm_right [GCDMonoid \u03b1] (a b : \u03b1) : b \u2223 lcm a b", "start": [737, 1], "end": [738, 41], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd", "code": "theorem lcm_dvd [GCDMonoid \u03b1] {a b c : \u03b1} (hab : a \u2223 b) (hcb : c \u2223 b) : lcm a c \u2223 b", "start": [741, 1], "end": [742, 27], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_zero_iff", "code": "@[simp]\ntheorem lcm_eq_zero_iff [GCDMonoid \u03b1] (a b : \u03b1) : lcm a b = 0 \u2194 a = 0 \u2228 b = 0", "start": [745, 1], "end": [751, 76], "kind": "commanddeclaration"}, {"full_name": "normalize_lcm", "code": "@[simp 1100]\ntheorem normalize_lcm [NormalizedGCDMonoid \u03b1] (a b : \u03b1) : normalize (lcm a b) = lcm a b", "start": [755, 1], "end": [757, 40], "kind": "commanddeclaration"}, {"full_name": "lcm_comm", "code": "theorem lcm_comm [NormalizedGCDMonoid \u03b1] (a b : \u03b1) : lcm a b = lcm b a", "start": [760, 1], "end": [763, 53], "kind": "commanddeclaration"}, {"full_name": "lcm_comm'", "code": "theorem lcm_comm' [GCDMonoid \u03b1] (a b : \u03b1) : Associated (lcm a b) (lcm b a)", "start": [766, 1], "end": [768, 53], "kind": "commanddeclaration"}, {"full_name": "lcm_assoc", "code": "theorem lcm_assoc [NormalizedGCDMonoid \u03b1] (m n k : \u03b1) : lcm (lcm m n) k = lcm m (lcm n k)", "start": [771, 1], "end": [776, 84], "kind": "commanddeclaration"}, {"full_name": "lcm_assoc'", "code": "theorem lcm_assoc' [GCDMonoid \u03b1] (m n k : \u03b1) : Associated (lcm (lcm m n) k) (lcm m (lcm n k))", "start": [779, 1], "end": [784, 84], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_normalize", "code": "theorem lcm_eq_normalize [NormalizedGCDMonoid \u03b1] {a b c : \u03b1} (habc : lcm a b \u2223 c)\n    (hcab : c \u2223 lcm a b) : lcm a b = normalize c", "start": [793, 1], "end": [795, 55], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_lcm", "code": "theorem lcm_dvd_lcm [GCDMonoid \u03b1] {a b c d : \u03b1} (hab : a \u2223 b) (hcd : c \u2223 d) : lcm a c \u2223 lcm b d", "start": [798, 1], "end": [799, 73], "kind": "commanddeclaration"}, {"full_name": "lcm_units_coe_left", "code": "@[simp]\ntheorem lcm_units_coe_left [NormalizedGCDMonoid \u03b1] (u : \u03b1\u02e3) (a : \u03b1) : lcm (\u2191u) a = normalize a", "start": [802, 1], "end": [804, 71], "kind": "commanddeclaration"}, {"full_name": "lcm_units_coe_right", "code": "@[simp]\ntheorem lcm_units_coe_right [NormalizedGCDMonoid \u03b1] (a : \u03b1) (u : \u03b1\u02e3) : lcm a \u2191u = normalize a", "start": [807, 1], "end": [809, 49], "kind": "commanddeclaration"}, {"full_name": "lcm_one_left", "code": "@[simp]\ntheorem lcm_one_left [NormalizedGCDMonoid \u03b1] (a : \u03b1) : lcm 1 a = normalize a", "start": [812, 1], "end": [814, 25], "kind": "commanddeclaration"}, {"full_name": "lcm_one_right", "code": "@[simp]\ntheorem lcm_one_right [NormalizedGCDMonoid \u03b1] (a : \u03b1) : lcm a 1 = normalize a", "start": [817, 1], "end": [819, 26], "kind": "commanddeclaration"}, {"full_name": "lcm_same", "code": "@[simp]\ntheorem lcm_same [NormalizedGCDMonoid \u03b1] (a : \u03b1) : lcm a a = normalize a", "start": [822, 1], "end": [824, 64], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_one_iff", "code": "@[simp]\ntheorem lcm_eq_one_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) : lcm a b = 1 \u2194 a \u2223 1 \u2227 b \u2223 1", "start": [827, 1], "end": [831, 51], "kind": "commanddeclaration"}, {"full_name": "lcm_mul_left", "code": "@[simp]\ntheorem lcm_mul_left [NormalizedGCDMonoid \u03b1] (a b c : \u03b1) :\n    lcm (a * b) (a * c) = normalize a * lcm b c", "start": [834, 1], "end": [847, 70], "kind": "commanddeclaration"}, {"full_name": "lcm_mul_right", "code": "@[simp]\ntheorem lcm_mul_right [NormalizedGCDMonoid \u03b1] (a b c : \u03b1) :\n    lcm (b * a) (c * a) = lcm b c * normalize a", "start": [850, 1], "end": [852, 89], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_left_iff", "code": "theorem lcm_eq_left_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize a = a) :\n    lcm a b = a \u2194 b \u2223 a", "start": [855, 1], "end": [858, 101], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_right_iff", "code": "theorem lcm_eq_right_iff [NormalizedGCDMonoid \u03b1] (a b : \u03b1) (h : normalize b = b) :\n    lcm a b = b \u2194 a \u2223 b", "start": [861, 1], "end": [862, 84], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_lcm_mul_left", "code": "theorem lcm_dvd_lcm_mul_left [GCDMonoid \u03b1] (m n k : \u03b1) : lcm m n \u2223 lcm (k * m) n", "start": [865, 1], "end": [866, 41], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_lcm_mul_right", "code": "theorem lcm_dvd_lcm_mul_right [GCDMonoid \u03b1] (m n k : \u03b1) : lcm m n \u2223 lcm (m * k) n", "start": [869, 1], "end": [870, 42], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_lcm_mul_left_right", "code": "theorem lcm_dvd_lcm_mul_left_right [GCDMonoid \u03b1] (m n k : \u03b1) : lcm m n \u2223 lcm m (k * n)", "start": [873, 1], "end": [874, 41], "kind": "commanddeclaration"}, {"full_name": "lcm_dvd_lcm_mul_right_right", "code": "theorem lcm_dvd_lcm_mul_right_right [GCDMonoid \u03b1] (m n k : \u03b1) : lcm m n \u2223 lcm m (n * k)", "start": [877, 1], "end": [878, 42], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_of_associated_left", "code": "theorem lcm_eq_of_associated_left [NormalizedGCDMonoid \u03b1] {m n : \u03b1} (h : Associated m n) (k : \u03b1) :\n    lcm m k = lcm n k", "start": [881, 1], "end": [884, 37], "kind": "commanddeclaration"}, {"full_name": "lcm_eq_of_associated_right", "code": "theorem lcm_eq_of_associated_right [NormalizedGCDMonoid \u03b1] {m n : \u03b1} (h : Associated m n) (k : \u03b1) :\n    lcm k m = lcm k n", "start": [887, 1], "end": [890, 37], "kind": "commanddeclaration"}, {"full_name": "GCDMonoid.prime_of_irreducible", "code": "theorem prime_of_irreducible [GCDMonoid \u03b1] {x : \u03b1} (hi : Irreducible x) : Prime x", "start": [897, 1], "end": [909, 84], "kind": "commanddeclaration"}, {"full_name": "GCDMonoid.irreducible_iff_prime", "code": "theorem irreducible_iff_prime [GCDMonoid \u03b1] {p : \u03b1} : Irreducible p \u2194 Prime p", "start": [912, 1], "end": [913, 44], "kind": "commanddeclaration"}, {"full_name": "normalizationMonoidOfUniqueUnits", "code": "instance (priority := 100) normalizationMonoidOfUniqueUnits : NormalizationMonoid \u03b1 where\n  normUnit _ := 1\n  normUnit_zero := rfl\n  normUnit_mul _ _ := (mul_one 1).symm\n  normUnit_coe_units _ := Subsingleton.elim _ _", "start": [925, 1], "end": [929, 48], "kind": "commanddeclaration"}, {"full_name": "uniqueNormalizationMonoidOfUniqueUnits", "code": "instance uniqueNormalizationMonoidOfUniqueUnits : Unique (NormalizationMonoid \u03b1) where\n  default := normalizationMonoidOfUniqueUnits\n  uniq := fun \u27e8u, _, _, _\u27e9 => by congr; simp", "start": [932, 1], "end": [934, 45], "kind": "commanddeclaration"}, {"full_name": "subsingleton_gcdMonoid_of_unique_units", "code": "instance subsingleton_gcdMonoid_of_unique_units : Subsingleton (GCDMonoid \u03b1) :=\n  \u27e8fun g\u2081 g\u2082 => by\n    have hgcd : g\u2081.gcd = g\u2082.gcd := by\n      ext a b\n      refine' associated_iff_eq.mp (associated_of_dvd_dvd _ _)\n      \u00b7 exact dvd_gcd (@gcd_dvd_left _ _ g\u2081 _ _) (@gcd_dvd_right _ _ g\u2081 _ _)\n      \u00b7 exact @dvd_gcd _ _ g\u2081 _ _ _ (@gcd_dvd_left _ _ g\u2082 _ _) (@gcd_dvd_right _ _ g\u2082 _ _)\n    have hlcm : g\u2081.lcm = g\u2082.lcm := by\n      ext a b\n      refine' associated_iff_eq.mp (associated_of_dvd_dvd _ _)\n      \u00b7 exact (@lcm_dvd_iff _ _ g\u2081 ..).mpr \u27e8@dvd_lcm_left _ _ g\u2082 _ _, @dvd_lcm_right _ _ g\u2082 _ _\u27e9\n      \u00b7 exact lcm_dvd_iff.mpr \u27e8@dvd_lcm_left _ _ g\u2081 _ _, @dvd_lcm_right _ _ g\u2081 _ _\u27e9\n    cases g\u2081\n    cases g\u2082\n    dsimp only at hgcd hlcm\n    simp only [hgcd, hlcm]\u27e9", "start": [937, 1], "end": [954, 28], "kind": "commanddeclaration"}, {"full_name": "subsingleton_normalizedGCDMonoid_of_unique_units", "code": "instance subsingleton_normalizedGCDMonoid_of_unique_units : Subsingleton (NormalizedGCDMonoid \u03b1) :=\n  \u27e8by\n    intro a b\n    cases' a with a_norm a_gcd\n    cases' b with b_norm b_gcd\n    have := Subsingleton.elim a_gcd b_gcd\n    subst this\n    have := Subsingleton.elim a_norm b_norm\n    subst this\n    rfl\u27e9", "start": [957, 1], "end": [966, 9], "kind": "commanddeclaration"}, {"full_name": "normUnit_eq_one", "code": "@[simp]\ntheorem normUnit_eq_one (x : \u03b1) : normUnit x = 1", "start": [969, 1], "end": [971, 6], "kind": "commanddeclaration"}, {"full_name": "normalize_eq", "code": "theorem normalize_eq (x : \u03b1) : normalize x = x", "start": [976, 1], "end": [977, 12], "kind": "commanddeclaration"}, {"full_name": "associatesEquivOfUniqueUnits", "code": "@[simps]\ndef associatesEquivOfUniqueUnits : Associates \u03b1 \u2243* \u03b1 where\n  toFun := Associates.out\n  invFun := Associates.mk\n  left_inv := Associates.mk_out\n  right_inv _ := (Associates.out_mk _).trans <| normalize_eq _\n  map_mul' := Associates.out_mul", "start": [980, 1], "end": [987, 33], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_of_dvd_sub_right", "code": "theorem gcd_eq_of_dvd_sub_right {a b c : \u03b1} (h : a \u2223 b - c) : gcd a b = gcd a c", "start": [998, 1], "end": [1011, 95], "kind": "commanddeclaration"}, {"full_name": "gcd_eq_of_dvd_sub_left", "code": "theorem gcd_eq_of_dvd_sub_left {a b c : \u03b1} (h : a \u2223 b - c) : gcd b a = gcd c a", "start": [1014, 1], "end": [1015, 61], "kind": "commanddeclaration"}, {"full_name": "map_mk_unit_aux", "code": "private theorem map_mk_unit_aux [DecidableEq \u03b1] {f : Associates \u03b1 \u2192* \u03b1}\n    (hinv : Function.RightInverse f Associates.mk) (a : \u03b1) :\n    a * \u2191(Classical.choose (associated_map_mk hinv a)) = f (Associates.mk a)", "start": [1026, 1], "end": [1029, 51], "kind": "commanddeclaration"}, {"full_name": "normalizationMonoidOfMonoidHomRightInverse", "code": "def normalizationMonoidOfMonoidHomRightInverse [DecidableEq \u03b1] (f : Associates \u03b1 \u2192* \u03b1)\n    (hinv : Function.RightInverse f Associates.mk) :\n    NormalizationMonoid \u03b1 where\n  normUnit a :=\n    if a = 0 then 1\n    else Classical.choose (Associates.mk_eq_mk_iff_associated.1 (hinv (Associates.mk a)).symm)\n  normUnit_zero := if_pos rfl\n  normUnit_mul {a b} ha hb := by\n    simp_rw [if_neg (mul_ne_zero ha hb), if_neg ha, if_neg hb, Units.ext_iff, Units.val_mul]\n    suffices a * b * \u2191(Classical.choose (associated_map_mk hinv (a * b))) =\n        a * \u2191(Classical.choose (associated_map_mk hinv a)) *\n        (b * \u2191(Classical.choose (associated_map_mk hinv b))) by\n      apply mul_left_cancel\u2080 (mul_ne_zero ha hb) _\n      rw [this, mul_assoc, \u2190 mul_assoc _ b, mul_comm _ b, \u2190 mul_assoc, \u2190 mul_assoc,\n        mul_assoc (a * b)]\n    rw [map_mk_unit_aux hinv a, map_mk_unit_aux hinv (a * b), map_mk_unit_aux hinv b, \u2190\n      MonoidHom.map_mul, Associates.mk_mul_mk]\n  normUnit_coe_units u := by\n    nontriviality \u03b1\n    simp_rw [if_neg (Units.ne_zero u), Units.ext_iff]\n    apply mul_left_cancel\u2080 (Units.ne_zero u)\n    rw [Units.mul_inv, map_mk_unit_aux hinv u,\n      Associates.mk_eq_mk_iff_associated.2 (associated_one_iff_isUnit.2 \u27e8u, rfl\u27e9),\n      Associates.mk_one, MonoidHom.map_one]", "start": [1031, 1], "end": [1057, 44], "kind": "commanddeclaration"}, {"full_name": "gcdMonoidOfGCD", "code": "noncomputable def gcdMonoidOfGCD [DecidableEq \u03b1] (gcd : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (gcd_dvd_left : \u2200 a b, gcd a b \u2223 a) (gcd_dvd_right : \u2200 a b, gcd a b \u2223 b)\n    (dvd_gcd : \u2200 {a b c}, a \u2223 c \u2192 a \u2223 b \u2192 a \u2223 gcd c b) : GCDMonoid \u03b1 :=\n  { gcd\n    gcd_dvd_left\n    gcd_dvd_right\n    dvd_gcd := fun {a b c} => dvd_gcd\n    lcm := fun a b =>\n      if a = 0 then 0 else Classical.choose ((gcd_dvd_left a b).trans (Dvd.intro b rfl))\n    gcd_mul_lcm := fun a b => by\n      dsimp only\n      split_ifs with a0\n      \u00b7 rw [mul_zero, a0, zero_mul]\n      \u00b7 rw [\u2190 Classical.choose_spec ((gcd_dvd_left a b).trans (Dvd.intro b rfl))]\n    lcm_zero_left := fun a => if_pos rfl\n    lcm_zero_right := fun a => by\n      dsimp only\n      split_ifs with a0\n      \u00b7 rfl\n      have h := (Classical.choose_spec ((gcd_dvd_left a 0).trans (Dvd.intro 0 rfl))).symm\n      have a0' : gcd a 0 \u2260 0 := by\n        contrapose! a0\n        rw [\u2190 associated_zero_iff_eq_zero, \u2190 a0]\n        exact associated_of_dvd_dvd (dvd_gcd (dvd_refl a) (dvd_zero a)) (gcd_dvd_left _ _)\n      apply Or.resolve_left (mul_eq_zero.1 _) a0'\n      rw [h, mul_zero] }", "start": [1060, 1], "end": [1088, 25], "kind": "commanddeclaration"}, {"full_name": "normalizedGCDMonoidOfGCD", "code": "noncomputable def normalizedGCDMonoidOfGCD [NormalizationMonoid \u03b1] [DecidableEq \u03b1] (gcd : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (gcd_dvd_left : \u2200 a b, gcd a b \u2223 a) (gcd_dvd_right : \u2200 a b, gcd a b \u2223 b)\n    (dvd_gcd : \u2200 {a b c}, a \u2223 c \u2192 a \u2223 b \u2192 a \u2223 gcd c b)\n    (normalize_gcd : \u2200 a b, normalize (gcd a b) = gcd a b) : NormalizedGCDMonoid \u03b1 :=\n  { (inferInstance : NormalizationMonoid \u03b1) with\n    gcd\n    gcd_dvd_left\n    gcd_dvd_right\n    dvd_gcd := fun {a b c} => dvd_gcd\n    normalize_gcd\n    lcm := fun a b =>\n      if a = 0 then 0\n      else Classical.choose (dvd_normalize_iff.2 ((gcd_dvd_left a b).trans (Dvd.intro b rfl)))\n    normalize_lcm := fun a b => by\n      dsimp [normalize]\n      split_ifs with a0\n      \u00b7 exact @normalize_zero \u03b1 _ _\n      \u00b7 have := (Classical.choose_spec\n          (dvd_normalize_iff.2 ((gcd_dvd_left a b).trans (Dvd.intro b rfl)))).symm\n        set l := Classical.choose (dvd_normalize_iff.2 ((gcd_dvd_left a b).trans (Dvd.intro b rfl)))\n        obtain rfl | hb := eq_or_ne b 0\n        \u00b7 rw [mul_zero a, normalize_zero, mul_eq_zero] at this\n          obtain ha | hl := this\n          \u00b7 apply (a0 _).elim\n            rw [\u2190 zero_dvd_iff, \u2190 ha]\n            exact gcd_dvd_left _ _\n          \u00b7 rw [hl, zero_mul]\n        have h1 : gcd a b \u2260 0 := by\n          have hab : a * b \u2260 0 := mul_ne_zero a0 hb\n          contrapose! hab\n          rw [\u2190 normalize_eq_zero, \u2190 this, hab, zero_mul]\n        have h2 : normalize (gcd a b * l) = gcd a b * l := by rw [this, normalize_idem]\n        rw [\u2190 normalize_gcd] at this\n        rwa [normalize.map_mul, normalize_gcd, mul_right_inj' h1] at h2\n    gcd_mul_lcm := fun a b => by\n      dsimp only\n      split_ifs with a0\n      \u00b7 rw [mul_zero, a0, zero_mul]\n      \u00b7 rw [\u2190\n          Classical.choose_spec (dvd_normalize_iff.2 ((gcd_dvd_left a b).trans (Dvd.intro b rfl)))]\n        exact normalize_associated (a * b)\n    lcm_zero_left := fun a => if_pos rfl\n    lcm_zero_right := fun a => by\n      dsimp only\n      split_ifs with a0\n      \u00b7 rfl\n      rw [\u2190 normalize_eq_zero] at a0\n      have h :=\n        (Classical.choose_spec\n            (dvd_normalize_iff.2 ((gcd_dvd_left a 0).trans (Dvd.intro 0 rfl)))).symm\n      have gcd0 : gcd a 0 = normalize a := by\n        rw [\u2190 normalize_gcd]\n        exact normalize_eq_normalize (gcd_dvd_left _ _) (dvd_gcd (dvd_refl a) (dvd_zero a))\n      rw [\u2190 gcd0] at a0\n      apply Or.resolve_left (mul_eq_zero.1 _) a0\n      rw [h, mul_zero, normalize_zero] }", "start": [1091, 1], "end": [1153, 41], "kind": "commanddeclaration"}, {"full_name": "gcdMonoidOfLCM", "code": "noncomputable def gcdMonoidOfLCM [DecidableEq \u03b1] (lcm : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (dvd_lcm_left : \u2200 a b, a \u2223 lcm a b) (dvd_lcm_right : \u2200 a b, b \u2223 lcm a b)\n    (lcm_dvd : \u2200 {a b c}, c \u2223 a \u2192 b \u2223 a \u2192 lcm c b \u2223 a) : GCDMonoid \u03b1 :=\n  let exists_gcd a b := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n  { lcm\n    gcd := fun a b => if a = 0 then b else if b = 0 then a else Classical.choose (exists_gcd a b)\n    gcd_mul_lcm := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 rw [h, eq_zero_of_zero_dvd (dvd_lcm_left _ _), mul_zero, zero_mul]\n      \u00b7 rw [h_1, eq_zero_of_zero_dvd (dvd_lcm_right _ _), mul_zero]\n      rw [mul_comm, \u2190 Classical.choose_spec (exists_gcd a b)]\n    lcm_zero_left := fun a => eq_zero_of_zero_dvd (dvd_lcm_left _ _)\n    lcm_zero_right := fun a => eq_zero_of_zero_dvd (dvd_lcm_right _ _)\n    gcd_dvd_left := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 rw [h]\n        apply dvd_zero\n      \u00b7 exact dvd_rfl\n      have h0 : lcm a b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039a = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190 Classical.choose_spec (exists_gcd a b), mul_comm,\n        mul_dvd_mul_iff_right h]\n      apply dvd_lcm_right\n    gcd_dvd_right := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 exact dvd_rfl\n      \u00b7 rw [h_1]\n        apply dvd_zero\n      have h0 : lcm a b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039a = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190 Classical.choose_spec (exists_gcd a b),\n        mul_dvd_mul_iff_right h_1]\n      apply dvd_lcm_left\n    dvd_gcd := fun {a b c} ac ab => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 exact ab\n      \u00b7 exact ac\n      have h0 : lcm c b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left c rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039c = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190 Classical.choose_spec (exists_gcd c b)]\n      rcases ab with \u27e8d, rfl\u27e9\n      rw [mul_eq_zero] at \u2039a * d \u2260 0\u203a\n      push_neg at h_1\n      rw [mul_comm a, \u2190 mul_assoc, mul_dvd_mul_iff_right h_1.1]\n      apply lcm_dvd (Dvd.intro d rfl)\n      rw [mul_comm, mul_dvd_mul_iff_right h_1.2]\n      apply ac }", "start": [1156, 1], "end": [1226, 17], "kind": "commanddeclaration"}, {"full_name": "normalizedGCDMonoidOfLCM", "code": "noncomputable def normalizedGCDMonoidOfLCM [NormalizationMonoid \u03b1] [DecidableEq \u03b1] (lcm : \u03b1 \u2192 \u03b1 \u2192 \u03b1)\n    (dvd_lcm_left : \u2200 a b, a \u2223 lcm a b) (dvd_lcm_right : \u2200 a b, b \u2223 lcm a b)\n    (lcm_dvd : \u2200 {a b c}, c \u2223 a \u2192 b \u2223 a \u2192 lcm c b \u2223 a)\n    (normalize_lcm : \u2200 a b, normalize (lcm a b) = lcm a b) : NormalizedGCDMonoid \u03b1 :=\n  let exists_gcd a b := dvd_normalize_iff.2 (lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl))\n  { (inferInstance : NormalizationMonoid \u03b1) with\n    lcm\n    gcd := fun a b =>\n      if a = 0 then normalize b\n      else if b = 0 then normalize a else Classical.choose (exists_gcd a b)\n    gcd_mul_lcm := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 rw [h, eq_zero_of_zero_dvd (dvd_lcm_left _ _), mul_zero, zero_mul]\n      \u00b7 rw [h_1, eq_zero_of_zero_dvd (dvd_lcm_right _ _), mul_zero, mul_zero]\n      rw [mul_comm, \u2190 Classical.choose_spec (exists_gcd a b)]\n      exact normalize_associated (a * b)\n    normalize_lcm\n    normalize_gcd := fun a b => by\n      dsimp [normalize]\n      split_ifs with h h_1\n      \u00b7 apply normalize_idem\n      \u00b7 apply normalize_idem\n      have h0 : lcm a b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039a = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      apply mul_left_cancel\u2080 h0\n      refine' _root_.trans _ (Classical.choose_spec (exists_gcd a b))\n      conv_lhs =>\n        congr\n        rw [\u2190 normalize_lcm a b]\n      erw [\u2190 normalize.map_mul, \u2190 Classical.choose_spec (exists_gcd a b), normalize_idem]\n    lcm_zero_left := fun a => eq_zero_of_zero_dvd (dvd_lcm_left _ _)\n    lcm_zero_right := fun a => eq_zero_of_zero_dvd (dvd_lcm_right _ _)\n    gcd_dvd_left := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 rw [h]\n        apply dvd_zero\n      \u00b7 exact (normalize_associated _).dvd\n      have h0 : lcm a b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039a = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190 Classical.choose_spec (exists_gcd a b), normalize_dvd_iff,\n        mul_comm, mul_dvd_mul_iff_right h]\n      apply dvd_lcm_right\n    gcd_dvd_right := fun a b => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 exact (normalize_associated _).dvd\n      \u00b7 rw [h_1]\n        apply dvd_zero\n      have h0 : lcm a b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left a rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039a = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190 Classical.choose_spec (exists_gcd a b), normalize_dvd_iff,\n        mul_dvd_mul_iff_right h_1]\n      apply dvd_lcm_left\n    dvd_gcd := fun {a b c} ac ab => by\n      dsimp only\n      split_ifs with h h_1\n      \u00b7 apply dvd_normalize_iff.2 ab\n      \u00b7 apply dvd_normalize_iff.2 ac\n      have h0 : lcm c b \u2260 0 := by\n        intro con\n        have h := lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left c rfl)\n        rw [con, zero_dvd_iff, mul_eq_zero] at h\n        cases h\n        \u00b7 exact absurd \u2039c = 0\u203a h\n        \u00b7 exact absurd \u2039b = 0\u203a h_1\n      rw [\u2190 mul_dvd_mul_iff_left h0, \u2190\n      Classical.choose_spec\n        (dvd_normalize_iff.2 (lcm_dvd (Dvd.intro b rfl) (Dvd.intro_left c rfl))),\n      dvd_normalize_iff]\n      rcases ab with \u27e8d, rfl\u27e9\n      rw [mul_eq_zero] at h_1\n      push_neg at h_1\n      rw [mul_comm a, \u2190 mul_assoc, mul_dvd_mul_iff_right h_1.1]\n      apply lcm_dvd (Dvd.intro d rfl)\n      rw [mul_comm, mul_dvd_mul_iff_right h_1.2]\n      apply ac }", "start": [1230, 1], "end": [1323, 17], "kind": "commanddeclaration"}, {"full_name": "gcdMonoidOfExistsGCD", "code": "noncomputable def gcdMonoidOfExistsGCD [DecidableEq \u03b1]\n    (h : \u2200 a b : \u03b1, \u2203 c : \u03b1, \u2200 d : \u03b1, d \u2223 a \u2227 d \u2223 b \u2194 d \u2223 c) : GCDMonoid \u03b1 :=\n  gcdMonoidOfGCD (fun a b => Classical.choose (h a b))\n    (fun a b => ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).1)\n    (fun a b => ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).2)\n    fun {a b c} ac ab => (Classical.choose_spec (h c b) a).1 \u27e8ac, ab\u27e9", "start": [1326, 1], "end": [1332, 70], "kind": "commanddeclaration"}, {"full_name": "normalizedGCDMonoidOfExistsGCD", "code": "noncomputable def normalizedGCDMonoidOfExistsGCD [NormalizationMonoid \u03b1] [DecidableEq \u03b1]\n    (h : \u2200 a b : \u03b1, \u2203 c : \u03b1, \u2200 d : \u03b1, d \u2223 a \u2227 d \u2223 b \u2194 d \u2223 c) : NormalizedGCDMonoid \u03b1 :=\n  normalizedGCDMonoidOfGCD (fun a b => normalize (Classical.choose (h a b)))\n    (fun a b =>\n      normalize_dvd_iff.2 ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).1)\n    (fun a b =>\n      normalize_dvd_iff.2 ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).2)\n    (fun {a b c} ac ab => dvd_normalize_iff.2 ((Classical.choose_spec (h c b) a).1 \u27e8ac, ab\u27e9))\n    fun _ _ => normalize_idem _", "start": [1335, 1], "end": [1344, 32], "kind": "commanddeclaration"}, {"full_name": "gcdMonoidOfExistsLCM", "code": "noncomputable def gcdMonoidOfExistsLCM [DecidableEq \u03b1]\n    (h : \u2200 a b : \u03b1, \u2203 c : \u03b1, \u2200 d : \u03b1, a \u2223 d \u2227 b \u2223 d \u2194 c \u2223 d) : GCDMonoid \u03b1 :=\n  gcdMonoidOfLCM (fun a b => Classical.choose (h a b))\n    (fun a b => ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).1)\n    (fun a b => ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).2)\n    fun {a b c} ac ab => (Classical.choose_spec (h c b) a).1 \u27e8ac, ab\u27e9", "start": [1347, 1], "end": [1353, 70], "kind": "commanddeclaration"}, {"full_name": "normalizedGCDMonoidOfExistsLCM", "code": "noncomputable def normalizedGCDMonoidOfExistsLCM [NormalizationMonoid \u03b1] [DecidableEq \u03b1]\n    (h : \u2200 a b : \u03b1, \u2203 c : \u03b1, \u2200 d : \u03b1, a \u2223 d \u2227 b \u2223 d \u2194 c \u2223 d) : NormalizedGCDMonoid \u03b1 :=\n  normalizedGCDMonoidOfLCM (fun a b => normalize (Classical.choose (h a b)))\n    (fun a b =>\n      dvd_normalize_iff.2 ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).1)\n    (fun a b =>\n      dvd_normalize_iff.2 ((Classical.choose_spec (h a b) (Classical.choose (h a b))).2 dvd_rfl).2)\n    (fun {a b c} ac ab => normalize_dvd_iff.2 ((Classical.choose_spec (h c b) a).1 \u27e8ac, ab\u27e9))\n    fun _ _ => normalize_idem _", "start": [1356, 1], "end": [1365, 32], "kind": "commanddeclaration"}, {"full_name": "CommGroupWithZero.coe_normUnit", "code": "@[simp]\ntheorem coe_normUnit {a : G\u2080} (h0 : a \u2260 0) : (\u2191(normUnit a) : G\u2080) = a\u207b\u00b9", "start": [1435, 1], "end": [1436, 98], "kind": "commanddeclaration"}, {"full_name": "CommGroupWithZero.normalize_eq_one", "code": "theorem normalize_eq_one {a : G\u2080} (h0 : a \u2260 0) : normalize a = 1", "start": [1439, 1], "end": [1439, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Basic.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Hom/GroupAction.lean"], "premises": [{"full_name": "SMulMemClass", "code": "class SMulMemClass (S : Type*) (R : outParam <| Type*) (M : Type*) [SMul R M] [SetLike S M] :\n    Prop where\n  \n  smul_mem : \u2200 {s : S} (r : R) {m : M}, m \u2208 s \u2192 r \u2022 m \u2208 s", "start": [41, 1], "end": [50, 58], "kind": "commanddeclaration"}, {"full_name": "VAddMemClass", "code": "class VAddMemClass (S : Type*) (R : outParam <| Type*) (M : Type*) [VAdd R M] [SetLike S M] :\n    Prop where\n  \n  vadd_mem : \u2200 {s : S} (r : R) {m : M}, m \u2208 s \u2192 r +\u1d65 m \u2208 s", "start": [53, 1], "end": [61, 59], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoidClass.nsmulMemClass", "code": "lemma AddSubmonoidClass.nsmulMemClass {S M : Type*} [AddMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] : SMulMemClass S \u2115 M where\n  smul_mem n _x hx := nsmul_mem hx n", "start": [68, 1], "end": [71, 37], "kind": "mathlibtacticlemma"}, {"full_name": "AddSubgroupClass.zsmulMemClass", "code": "lemma AddSubgroupClass.zsmulMemClass {S M : Type*} [SubNegMonoid M] [SetLike S M]\n    [AddSubgroupClass S M] : SMulMemClass S \u2124 M where\n  smul_mem n _x hx := zsmul_mem hx n", "start": [73, 1], "end": [76, 37], "kind": "mathlibtacticlemma"}, {"full_name": "SetLike.smul", "code": "@[to_additive \"A subset closed under the additive action inherits that action.\"]\ninstance (priority := 900) smul : SMul R s :=\n  \u27e8fun r x => \u27e8r \u2022 x.1, smul_mem r x.2\u27e9\u27e9", "start": [85, 1], "end": [88, 41], "kind": "commanddeclaration"}, {"full_name": "SMulMemClass.ofIsScalarTower", "code": "theorem _root_.SMulMemClass.ofIsScalarTower (S M N \u03b1 : Type*) [SetLike S \u03b1] [SMul M N]\n    [SMul M \u03b1] [Monoid N] [MulAction N \u03b1] [SMulMemClass S N \u03b1] [IsScalarTower M N \u03b1] :\n    SMulMemClass S M \u03b1", "start": [92, 1], "end": [97, 81], "kind": "commanddeclaration"}, {"full_name": "SetLike.instIsScalarTower", "code": "instance instIsScalarTower [Mul M] [MulMemClass S M] [IsScalarTower R M M]\n    (s : S) : IsScalarTower R s s where\n  smul_assoc r x y := Subtype.ext <| smul_assoc r (x : M) (y : M)", "start": [99, 1], "end": [101, 66], "kind": "commanddeclaration"}, {"full_name": "SetLike.instSMulCommClass", "code": "instance instSMulCommClass [Mul M] [MulMemClass S M] [SMulCommClass R M M]\n    (s : S) : SMulCommClass R s s where\n  smul_comm r x y := Subtype.ext <| smul_comm r (x : M) (y : M)", "start": [103, 1], "end": [105, 64], "kind": "commanddeclaration"}, {"full_name": "SetLike.val_smul", "code": "@[to_additive (attr := simp, norm_cast)]\nprotected theorem val_smul (r : R) (x : s) : (\u2191(r \u2022 x) : M) = r \u2022 (x : M)", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.mk_smul_mk", "code": "@[to_additive (attr := simp)]\ntheorem mk_smul_mk (r : R) (x : M) (hx : x \u2208 s) : r \u2022 (\u27e8x, hx\u27e9 : s) = \u27e8r \u2022 x, smul_mem r hx\u27e9", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.smul_def", "code": "@[to_additive]\ntheorem smul_def (r : R) (x : s) : r \u2022 x = \u27e8r \u2022 x, smul_mem r x.2\u27e9", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "SetLike.forall_smul_mem_iff", "code": "@[simp]\ntheorem forall_smul_mem_iff {R M S : Type*} [Monoid R] [MulAction R M] [SetLike S M]\n    [SMulMemClass S R M] {N : S} {x : M} : (\u2200 a : R, a \u2022 x \u2208 N) \u2194 x \u2208 N", "start": [129, 1], "end": [132, 70], "kind": "commanddeclaration"}, {"full_name": "SubMulAction", "code": "structure SubMulAction (R : Type u) (M : Type v) [SMul R M] : Type v where\n  \n  carrier : Set M\n  \n  smul_mem' : \u2200 (c : R) {x : M}, x \u2208 carrier \u2192 c \u2022 x \u2208 carrier", "start": [137, 1], "end": [142, 63], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mem_carrier", "code": "@[simp]\ntheorem mem_carrier {p : SubMulAction R M} {x : M} : x \u2208 p.carrier \u2194 x \u2208 (p : Set M)", "start": [154, 1], "end": [156, 10], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.ext", "code": "@[ext]\ntheorem ext {p q : SubMulAction R M} (h : \u2200 x, x \u2208 p \u2194 x \u2208 q) : p = q", "start": [159, 1], "end": [161, 16], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.copy", "code": "protected def copy (p : SubMulAction R M) (s : Set M) (hs : s = \u2191p) : SubMulAction R M\n    where\n  carrier := s\n  smul_mem' := hs.symm \u25b8 p.smul_mem'", "start": [164, 1], "end": [169, 37], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.coe_copy", "code": "@[simp]\ntheorem coe_copy (p : SubMulAction R M) (s : Set M) (hs : s = \u2191p) : (p.copy s hs : Set M) = s", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.copy_eq", "code": "theorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = \u2191p) : p.copy s hs = p", "start": [177, 1], "end": [178, 27], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.smul_mem", "code": "theorem smul_mem (r : R) (h : x \u2208 p) : r \u2022 x \u2208 p", "start": [201, 1], "end": [202, 18], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.val_smul", "code": "@[simp, norm_cast]\ntheorem val_smul (r : R) (x : p) : (\u2191(r \u2022 x) : M) = r \u2022 (x : M)", "start": [209, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.subtype", "code": "protected def subtype : p \u2192[R] M := by refine' { toFun := Subtype.val.. }; simp [val_smul]", "start": [219, 1], "end": [220, 91], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.subtype_apply", "code": "@[simp]\ntheorem subtype_apply (x : p) : p.subtype x = x", "start": [223, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.subtype_eq_val", "code": "theorem subtype_eq_val : (SubMulAction.subtype p : p \u2192 M) = Subtype.val", "start": [228, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.SMulMemClass.toMulAction", "code": "instance (priority := 75) toMulAction : MulAction R S' :=\n  Subtype.coe_injective.mulAction Subtype.val (SetLike.val_smul S')", "start": [241, 1], "end": [243, 68], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.SMulMemClass.subtype", "code": "protected def subtype : S' \u2192[R] M where\n  toFun := Subtype.val; map_smul' _ _ := rfl", "start": [246, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.SMulMemClass.coeSubtype", "code": "@[simp]\nprotected theorem coeSubtype : (SMulMemClass.subtype S' : S' \u2192 M) = Subtype.val", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.smul_of_tower_mem", "code": "theorem smul_of_tower_mem (s : S) {x : M} (h : x \u2208 p) : s \u2022 x \u2208 p", "start": [268, 1], "end": [270, 23], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.smul'", "code": "instance smul' : SMul S p where smul c x := \u27e8c \u2022 x.1, smul_of_tower_mem _ c x.2\u27e9", "start": [273, 1], "end": [273, 81], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.isScalarTower", "code": "instance isScalarTower : IsScalarTower S R p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)", "start": [276, 1], "end": [277, 60], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.isScalarTower'", "code": "instance isScalarTower' {S' : Type*} [SMul S' R] [SMul S' S] [SMul S' M] [IsScalarTower S' R M]\n    [IsScalarTower S' S M] : IsScalarTower S' S p where\n  smul_assoc s r x := Subtype.ext <| smul_assoc s r (x : M)", "start": [280, 1], "end": [282, 60], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.val_smul_of_tower", "code": "@[simp, norm_cast]\ntheorem val_smul_of_tower (s : S) (x : p) : ((s \u2022 x : p) : M) = s \u2022 (x : M)", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.smul_mem_iff'", "code": "@[simp]\ntheorem smul_mem_iff' {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M] (g : G)\n    {x : M} : g \u2022 x \u2208 p \u2194 x \u2208 p", "start": [290, 1], "end": [293, 82], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.isCentralScalar", "code": "instance isCentralScalar [SMul S\u1d50\u1d52\u1d56 R] [SMul S\u1d50\u1d52\u1d56 M] [IsScalarTower S\u1d50\u1d52\u1d56 R M]\n    [IsCentralScalar S M] :\n    IsCentralScalar S p where\n  op_smul_eq_smul r x := Subtype.ext <| op_smul_eq_smul r (x : M)", "start": [296, 1], "end": [299, 66], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mulAction'", "code": "instance mulAction' : MulAction S p where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul x := Subtype.ext <| one_smul _ (x : M)\n  mul_smul c\u2081 c\u2082 x := Subtype.ext <| mul_smul c\u2081 c\u2082 (x : M)", "start": [309, 1], "end": [313, 60], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mulAction", "code": "instance mulAction : MulAction R p :=\n  p.mulAction'", "start": [316, 1], "end": [317, 15], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.val_image_orbit", "code": "theorem val_image_orbit {p : SubMulAction R M} (m : p) :\n    Subtype.val '' MulAction.orbit R m = MulAction.orbit R (m : M)", "start": [322, 1], "end": [325, 28], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.stabilizer_of_subMul.submonoid", "code": "theorem stabilizer_of_subMul.submonoid {p : SubMulAction R M} (m : p) :\n    MulAction.Stabilizer.submonoid R m = MulAction.Stabilizer.submonoid R (m : M)", "start": [332, 1], "end": [336, 98], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.stabilizer_of_subMul", "code": "theorem stabilizer_of_subMul {p : SubMulAction R M} (m : p) :\n    MulAction.stabilizer R m = MulAction.stabilizer R (m : M)", "start": [345, 1], "end": [349, 41], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.zero_mem", "code": "theorem zero_mem (h : (p : Set M).Nonempty) : (0 : M) \u2208 p", "start": [362, 1], "end": [364, 40], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.neg_mem", "code": "theorem neg_mem (hx : x \u2208 p) : -x \u2208 p", "start": [384, 1], "end": [386, 24], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.neg_mem_iff", "code": "@[simp]\ntheorem neg_mem_iff : -x \u2208 p \u2194 x \u2208 p", "start": [389, 1], "end": [393, 34], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.val_neg", "code": "@[simp, norm_cast]\ntheorem val_neg (x : p) : ((-x : p) : M) = -x", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.smul_mem_iff", "code": "theorem smul_mem_iff (s0 : s \u2260 0) : s \u2022 x \u2208 p \u2194 x \u2208 p", "start": [416, 1], "end": [417, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Equiv.lean", "imports": ["Mathlib/Algebra/Module/LinearMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearEquiv", "code": "structure LinearEquiv {R : Type*} {S : Type*} [Semiring R] [Semiring S] (\u03c3 : R \u2192+* S)\n  {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3] (M : Type*) (M\u2082 : Type*)\n  [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082] extends LinearMap \u03c3 M M\u2082, M \u2243+ M\u2082", "start": [48, 1], "end": [52, 100], "kind": "commanddeclaration"}, {"full_name": "SemilinearEquivClass", "code": "class SemilinearEquivClass (F : Type*) {R S : outParam (Type*)} [Semiring R] [Semiring S]\n  (\u03c3 : outParam <| R \u2192+* S) {\u03c3' : outParam <| S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]\n  (M M\u2082 : outParam (Type*)) [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082] extends\n  AddEquivClass F M M\u2082 where\n  \n  map_smul\u209b\u2097 : \u2200 (f : F) (r : R) (x : M), f (r \u2022 x) = \u03c3 r \u2022 f x", "start": [86, 1], "end": [99, 64], "kind": "commanddeclaration"}, {"full_name": "LinearEquivClass", "code": "abbrev LinearEquivClass (F : Type*) (R M M\u2082 : outParam (Type*)) [Semiring R] [AddCommMonoid M]\n    [AddCommMonoid M\u2082] [Module R M] [Module R M\u2082] :=\n  SemilinearEquivClass F (RingHom.id R) M M\u2082", "start": [104, 1], "end": [109, 45], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toEquiv", "code": "def toEquiv : (M \u2243\u209b\u2097[\u03c3] M\u2082) \u2192 M \u2243 M\u2082 := fun f => f.toAddEquiv.toEquiv", "start": [150, 1], "end": [151, 70], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Function.Injective (toEquiv : (M \u2243\u209b\u2097[\u03c3] M\u2082) \u2192 M \u2243 M\u2082)", "start": [154, 1], "end": [157, 73], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toEquiv_inj", "code": "@[simp]\ntheorem toEquiv_inj {e\u2081 e\u2082 : M \u2243\u209b\u2097[\u03c3] M\u2082} : e\u2081.toEquiv = e\u2082.toEquiv \u2194 e\u2081 = e\u2082", "start": [160, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toLinearMap_injective", "code": "theorem toLinearMap_injective : Injective (toLinearMap : (M \u2243\u209b\u2097[\u03c3] M\u2082) \u2192 M \u2192\u209b\u2097[\u03c3] M\u2082)", "start": [165, 1], "end": [166, 71], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toLinearMap_inj", "code": "@[simp, norm_cast]\ntheorem toLinearMap_inj {e\u2081 e\u2082 : M \u2243\u209b\u2097[\u03c3] M\u2082} : (\u2191e\u2081 : M \u2192\u209b\u2097[\u03c3] M\u2082) = e\u2082 \u2194 e\u2081 = e\u2082", "start": [169, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk {to_fun inv_fun map_add map_smul left_inv right_inv} :\n    (\u27e8\u27e8\u27e8to_fun, map_add\u27e9, map_smul\u27e9, inv_fun, left_inv, right_inv\u27e9 : M \u2243\u209b\u2097[\u03c3] M\u2082) = to_fun", "start": [183, 1], "end": [185, 98], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_injective", "code": "theorem coe_injective : @Injective (M \u2243\u209b\u2097[\u03c3] M\u2082) (M \u2192 M\u2082) CoeFun.coe", "start": [188, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe : \u21d1(e : M \u2192\u209b\u2097[\u03c3] M\u2082) = e", "start": [210, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv : \u21d1(e.toEquiv) = e", "start": [215, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toLinearMap", "code": "@[simp]\ntheorem coe_toLinearMap : \u21d1e.toLinearMap = e", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toFun_eq_coe", "code": "theorem toFun_eq_coe : e.toFun = e", "start": [226, 1], "end": [226, 42], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ext", "code": "@[ext]\ntheorem ext (h : \u2200 x, e x = e' x) : e = e'", "start": [233, 1], "end": [235, 20], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ext_iff", "code": "theorem ext_iff : e = e' \u2194 \u2200 x, e x = e' x", "start": [238, 1], "end": [239, 18], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.congr_arg", "code": "protected theorem congr_arg {x x'} : x = x' \u2192 e x = e x'", "start": [242, 1], "end": [243, 22], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.congr_fun", "code": "protected theorem congr_fun (h : e = e') (x : M) : e x = e' x", "start": [246, 1], "end": [247, 24], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.refl", "code": "@[refl]\ndef refl [Module R M] : M \u2243\u2097[R] M :=\n  { LinearMap.id, Equiv.refl M with }", "start": [256, 1], "end": [259, 38], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.refl_apply", "code": "@[simp]\ntheorem refl_apply [Module R M] (x : M) : refl R M x = x", "start": [264, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm", "code": "@[symm]\ndef symm (e : M \u2243\u209b\u2097[\u03c3] M\u2082) : M\u2082 \u2243\u209b\u2097[\u03c3'] M :=\n  { e.toLinearMap.inverse e.invFun e.left_inv e.right_inv,\n    e.toEquiv.symm with\n    toFun := e.toLinearMap.inverse e.invFun e.left_inv e.right_inv\n    invFun := e.toEquiv.symm.invFun\n    map_smul' := fun r x => by dsimp only; rw [map_smul\u209b\u2097] }", "start": [269, 1], "end": [276, 61], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.Simps.apply", "code": "def Simps.apply {R : Type*} {S : Type*} [Semiring R] [Semiring S]\n    {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]\n    {M : Type*} {M\u2082 : Type*} [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082]\n    (e : M \u2243\u209b\u2097[\u03c3] M\u2082) : M \u2192 M\u2082 :=\n  e", "start": [280, 1], "end": [285, 4], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.Simps.symm_apply", "code": "def Simps.symm_apply {R : Type*} {S : Type*} [Semiring R] [Semiring S]\n    {\u03c3 : R \u2192+* S} {\u03c3' : S \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]\n    {M : Type*} {M\u2082 : Type*} [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M] [Module S M\u2082]\n    (e : M \u2243\u209b\u2097[\u03c3] M\u2082) : M\u2082 \u2192 M :=\n  e.symm", "start": [288, 1], "end": [293, 9], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.invFun_eq_symm", "code": "@[simp]\ntheorem invFun_eq_symm : e.invFun = e.symm", "start": [298, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toEquiv_symm", "code": "@[simp]\ntheorem coe_toEquiv_symm : e.toEquiv.symm = e.symm", "start": [303, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.trans", "code": "@[trans, nolint unusedArguments]\ndef trans\n    [RingHomCompTriple \u03c3\u2081\u2082 \u03c3\u2082\u2083 \u03c3\u2081\u2083] [RingHomCompTriple \u03c3\u2083\u2082 \u03c3\u2082\u2081 \u03c3\u2083\u2081]\n    {re\u2081\u2082 : RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081} {re\u2082\u2083 : RingHomInvPair \u03c3\u2082\u2083 \u03c3\u2083\u2082}\n    [RingHomInvPair \u03c3\u2081\u2083 \u03c3\u2083\u2081] {re\u2082\u2081 : RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082}\n    {re\u2083\u2082 : RingHomInvPair \u03c3\u2083\u2082 \u03c3\u2082\u2083} [RingHomInvPair \u03c3\u2083\u2081 \u03c3\u2081\u2083]\n    (e\u2081\u2082 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (e\u2082\u2083 : M\u2082 \u2243\u209b\u2097[\u03c3\u2082\u2083] M\u2083) : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2083] M\u2083 :=\n  { e\u2082\u2083.toLinearMap.comp e\u2081\u2082.toLinearMap, e\u2081\u2082.toEquiv.trans e\u2082\u2083.toEquiv with }", "start": [331, 1], "end": [341, 79], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_toAddEquiv", "code": "@[simp]\ntheorem coe_toAddEquiv : e.toAddEquiv = e", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toAddMonoidHom_commutes", "code": "theorem toAddMonoidHom_commutes : e.toLinearMap.toAddMonoidHom = e.toAddEquiv.toAddMonoidHom", "start": [358, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (c : M\u2081) : (e\u2081\u2082.trans e\u2082\u2083 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2083] M\u2083) c = e\u2082\u2083 (e\u2081\u2082 c)", "start": [363, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_trans", "code": "theorem coe_trans :\n    (e\u2081\u2082.trans e\u2082\u2083 : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = (e\u2082\u2083 : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083).comp (e\u2081\u2082 : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (c : M\u2082) : e (e.symm c) = c", "start": [373, 1], "end": [375, 16], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (b : M) : e.symm (e b) = b", "start": [378, 1], "end": [380, 15], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.trans_symm", "code": "@[simp]\ntheorem trans_symm : (e\u2081\u2082.trans e\u2082\u2083 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2083] M\u2083).symm = e\u2082\u2083.symm.trans e\u2081\u2082.symm", "start": [383, 1], "end": [385, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_trans_apply", "code": "theorem symm_trans_apply (c : M\u2083) :\n    (e\u2081\u2082.trans e\u2082\u2083 : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2083] M\u2083).symm c = e\u2081\u2082.symm (e\u2082\u2083.symm c)", "start": [388, 1], "end": [390, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.trans_refl", "code": "@[simp]\ntheorem trans_refl : e.trans (refl S M\u2082) = e", "start": [393, 1], "end": [395, 41], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.refl_trans", "code": "@[simp]\ntheorem refl_trans : (refl R M).trans e = e", "start": [398, 1], "end": [400, 41], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_apply_eq", "code": "theorem symm_apply_eq {x y} : e.symm x = y \u2194 x = e y", "start": [403, 1], "end": [404, 26], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_symm_apply", "code": "theorem eq_symm_apply {x y} : y = e.symm x \u2194 e y = x", "start": [407, 1], "end": [408, 26], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_comp_symm", "code": "theorem eq_comp_symm {\u03b1 : Type*} (f : M\u2082 \u2192 \u03b1) (g : M\u2081 \u2192 \u03b1) : f = g \u2218 e\u2081\u2082.symm \u2194 f \u2218 e\u2081\u2082 = g", "start": [411, 1], "end": [412, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.comp_symm_eq", "code": "theorem comp_symm_eq {\u03b1 : Type*} (f : M\u2082 \u2192 \u03b1) (g : M\u2081 \u2192 \u03b1) : g \u2218 e\u2081\u2082.symm = f \u2194 g = f \u2218 e\u2081\u2082", "start": [415, 1], "end": [416, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_symm_comp", "code": "theorem eq_symm_comp {\u03b1 : Type*} (f : \u03b1 \u2192 M\u2081) (g : \u03b1 \u2192 M\u2082) : f = e\u2081\u2082.symm \u2218 g \u2194 e\u2081\u2082 \u2218 f = g", "start": [419, 1], "end": [420, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_comp_eq", "code": "theorem symm_comp_eq {\u03b1 : Type*} (f : \u03b1 \u2192 M\u2081) (g : \u03b1 \u2192 M\u2082) : e\u2081\u2082.symm \u2218 g = f \u2194 g = e\u2081\u2082 \u2218 f", "start": [423, 1], "end": [424, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_comp_toLinearMap_symm", "code": "theorem eq_comp_toLinearMap_symm (f : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (g : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) :\n    f = g.comp e\u2081\u2082.symm.toLinearMap \u2194 f.comp e\u2081\u2082.toLinearMap = g", "start": [429, 1], "end": [433, 47], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.comp_toLinearMap_symm_eq", "code": "theorem comp_toLinearMap_symm_eq (f : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (g : M\u2081 \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) :\n    g.comp e\u2081\u2082.symm.toLinearMap = f \u2194 g = f.comp e\u2081\u2082.toLinearMap", "start": [436, 1], "end": [440, 43], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_toLinearMap_symm_comp", "code": "theorem eq_toLinearMap_symm_comp (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) (g : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2082] M\u2082) :\n    f = e\u2081\u2082.symm.toLinearMap.comp g \u2194 e\u2081\u2082.toLinearMap.comp f = g", "start": [443, 1], "end": [447, 47], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toLinearMap_symm_comp_eq", "code": "theorem toLinearMap_symm_comp_eq (f : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2081] M\u2081) (g : M\u2083 \u2192\u209b\u2097[\u03c3\u2083\u2082] M\u2082) :\n    e\u2081\u2082.symm.toLinearMap.comp g = f \u2194 g = e\u2081\u2082.toLinearMap.comp f", "start": [450, 1], "end": [454, 43], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm [Module R M] : (refl R M).symm = LinearEquiv.refl R M", "start": [457, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (f : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : f.trans f.symm = LinearEquiv.refl R\u2081 M\u2081", "start": [462, 1], "end": [465, 7], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (f : M\u2081 \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : f.symm.trans f = LinearEquiv.refl R\u2082 M\u2082", "start": [468, 1], "end": [471, 7], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.refl_toLinearMap", "code": "@[simp]  theorem refl_toLinearMap [Module R M] : (LinearEquiv.refl R M : M \u2192\u2097[R] M) = LinearMap.id", "start": [474, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.comp_coe", "code": "@[simp]  theorem comp_coe [Module R M] [Module R M\u2082] [Module R M\u2083] (f : M \u2243\u2097[R] M\u2082) (f' : M\u2082 \u2243\u2097[R] M\u2083) :\n    (f' : M\u2082 \u2192\u2097[R] M\u2083).comp (f : M \u2192\u2097[R] M\u2082) = (f.trans f' : M \u2243\u2097[R] M\u2083)", "start": [479, 1], "end": [482, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mk_coe", "code": "@[simp]\ntheorem mk_coe (f h\u2081 h\u2082) : (LinearEquiv.mk e f h\u2081 h\u2082 : M \u2243\u209b\u2097[\u03c3] M\u2082) = e", "start": [485, 1], "end": [487, 19], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_add", "code": "protected theorem map_add (a b : M) : e (a + b) = e a + e b", "start": [490, 1], "end": [491, 16], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_zero", "code": "protected theorem map_zero : e 0 = 0", "start": [494, 1], "end": [495, 13], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_smul\u209b\u2097", "code": "protected theorem map_smul\u209b\u2097 (c : R) (x : M) : e (c \u2022 x) = (\u03c3 : R \u2192 S) c \u2022 e x", "start": [498, 1], "end": [499, 18], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_smul", "code": "theorem map_smul (e : N\u2081 \u2243\u2097[R\u2081] N\u2082) (c : R\u2081) (x : N\u2081) : e (c \u2022 x) = c \u2022 e x", "start": [502, 1], "end": [503, 19], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_eq_zero_iff", "code": "theorem map_eq_zero_iff {x : M} : e x = 0 \u2194 x = 0", "start": [506, 1], "end": [507, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_ne_zero_iff", "code": "theorem map_ne_zero_iff {x : M} : e x \u2260 0 \u2194 x \u2260 0", "start": [510, 1], "end": [511, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : M \u2243\u209b\u2097[\u03c3] M\u2082) : e.symm.symm = e", "start": [514, 1], "end": [517, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_bijective", "code": "theorem symm_bijective [Module R M] [Module S M\u2082] [RingHomInvPair \u03c3' \u03c3] [RingHomInvPair \u03c3 \u03c3'] :\n    Function.Bijective (symm : (M \u2243\u209b\u2097[\u03c3] M\u2082) \u2192 M\u2082 \u2243\u209b\u2097[\u03c3'] M)", "start": [520, 1], "end": [524, 17], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mk_coe'", "code": "@[simp]\ntheorem mk_coe' (f h\u2081 h\u2082 h\u2083 h\u2084) :\n    (LinearEquiv.mk \u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9 (\u21d1e) h\u2083 h\u2084 : M\u2082 \u2243\u209b\u2097[\u03c3'] M) = e.symm", "start": [527, 1], "end": [530, 47], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_mk", "code": "@[simp]\ntheorem symm_mk (f h\u2081 h\u2082 h\u2083 h\u2084) :\n    (\u27e8\u27e8\u27e8e, h\u2081\u27e9, h\u2082\u27e9, f, h\u2083, h\u2084\u27e9 : M \u2243\u209b\u2097[\u03c3] M\u2082).symm =\n      {\n        (\u27e8\u27e8\u27e8e, h\u2081\u27e9, h\u2082\u27e9, f, h\u2083, h\u2084\u27e9 : M \u2243\u209b\u2097[\u03c3]\n              M\u2082).symm with\n        toFun := f\n        invFun := e }", "start": [533, 1], "end": [541, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_symm_mk", "code": "@[simp]\ntheorem coe_symm_mk [Module R M] [Module R M\u2082]\n    {to_fun inv_fun map_add map_smul left_inv right_inv} :\n    \u21d1(\u27e8\u27e8\u27e8to_fun, map_add\u27e9, map_smul\u27e9, inv_fun, left_inv, right_inv\u27e9 : M \u2243\u2097[R] M\u2082).symm = inv_fun", "start": [544, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.bijective", "code": "protected theorem bijective : Function.Bijective e", "start": [551, 1], "end": [552, 22], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.injective", "code": "protected theorem injective : Function.Injective e", "start": [555, 1], "end": [556, 22], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.surjective", "code": "protected theorem surjective : Function.Surjective e", "start": [559, 1], "end": [560, 23], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.image_eq_preimage", "code": "protected theorem image_eq_preimage (s : Set M) : e '' s = e.symm \u207b\u00b9' s", "start": [563, 1], "end": [564, 32], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.image_symm_eq_preimage", "code": "protected theorem image_symm_eq_preimage (s : Set M\u2082) : e.symm '' s = e \u207b\u00b9' s", "start": [567, 1], "end": [568, 37], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.toSemilinearEquiv", "code": "@[simps]\ndef _root_.RingEquiv.toSemilinearEquiv (f : R \u2243+* S) :\n    haveI := RingHomInvPair.of_ringEquiv f\n    haveI := RingHomInvPair.symm (\u2191f : R \u2192+* S) (f.symm : S \u2192+* R)\n    R \u2243\u209b\u2097[(\u2191f : R \u2192+* S)] S :=\n  haveI := RingHomInvPair.of_ringEquiv f\n  haveI := RingHomInvPair.symm (\u2191f : R \u2192+* S) (f.symm : S \u2192+* R)\n  { f with\n    toFun := f\n    map_smul' := f.map_mul }", "start": [573, 1], "end": [583, 29], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInvolutive", "code": "def ofInvolutive {\u03c3 \u03c3' : R \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]\n    {_ : Module R M} (f : M \u2192\u209b\u2097[\u03c3] M) (hf : Involutive f) : M \u2243\u209b\u2097[\u03c3] M :=\n  { f, hf.toPerm f with }", "start": [591, 1], "end": [594, 26], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_ofInvolutive", "code": "@[simp]\ntheorem coe_ofInvolutive {\u03c3 \u03c3' : R \u2192+* R} [RingHomInvPair \u03c3 \u03c3'] [RingHomInvPair \u03c3' \u03c3]\n    {_ : Module R M} (f : M \u2192\u209b\u2097[\u03c3] M) (hf : Involutive f) : \u21d1(ofInvolutive f hf) = f", "start": [597, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.restrictScalars", "code": "@[simps]\ndef restrictScalars (f : M \u2243\u2097[S] M\u2082) : M \u2243\u2097[R] M\u2082 :=\n  { f.toLinearMap.restrictScalars R with\n    toFun := f\n    invFun := f.symm\n    left_inv := f.left_inv\n    right_inv := f.right_inv }", "start": [609, 1], "end": [620, 31], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (M \u2243\u2097[S] M\u2082) \u2192 M \u2243\u2097[R] M\u2082)", "start": [625, 1], "end": [627, 36], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.restrictScalars_inj", "code": "@[simp]\ntheorem restrictScalars_inj (f g : M \u2243\u2097[S] M\u2082) :\n    f.restrictScalars R = g.restrictScalars R \u2194 f = g", "start": [630, 1], "end": [633, 39], "kind": "commanddeclaration"}, {"full_name": "Module.End_isUnit_iff", "code": "theorem _root_.Module.End_isUnit_iff [Module R M] (f : Module.End R M) :\n    IsUnit f \u2194 Function.Bijective f", "start": [638, 1], "end": [647, 77], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.automorphismGroup", "code": "instance automorphismGroup : Group (M \u2243\u2097[R] M) where\n  mul f g := g.trans f\n  one := LinearEquiv.refl R M\n  inv f := f.symm\n  mul_assoc f g h := rfl\n  mul_one f := ext fun x => rfl\n  one_mul f := ext fun x => rfl\n  mul_left_inv f := ext <| f.left_inv", "start": [654, 1], "end": [661, 38], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.automorphismGroup.toLinearMapMonoidHom", "code": "@[simps]\ndef automorphismGroup.toLinearMapMonoidHom : (M \u2243\u2097[R] M) \u2192* M \u2192\u2097[R] M where\n  toFun e := e.toLinearMap\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [664, 1], "end": [670, 22], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.applyDistribMulAction", "code": "instance applyDistribMulAction : DistribMulAction (M \u2243\u2097[R] M) M where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := LinearEquiv.map_zero\n  smul_add := LinearEquiv.map_add\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [674, 1], "end": [682, 24], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.smul_def", "code": "@[simp]\nprotected theorem smul_def (f : M \u2243\u2097[R] M) (a : M) : f \u2022 a = f a", "start": [685, 1], "end": [687, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.apply_faithfulSMul", "code": "instance apply_faithfulSMul : FaithfulSMul (M \u2243\u2097[R] M) M :=\n  \u27e8@fun _ _ => LinearEquiv.ext\u27e9", "start": [690, 1], "end": [692, 32], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.apply_smulCommClass", "code": "instance apply_smulCommClass : SMulCommClass R (M \u2243\u2097[R] M) M where\n  smul_comm r e m := (e.map_smul r m).symm", "start": [695, 1], "end": [696, 43], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.apply_smulCommClass'", "code": "instance apply_smulCommClass' : SMulCommClass (M \u2243\u2097[R] M) R M where\n  smul_comm := LinearEquiv.map_smul", "start": [699, 1], "end": [700, 36], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubsingleton", "code": "@[simps]\ndef ofSubsingleton : M \u2243\u2097[R] M\u2082 :=\n  { (0 : M \u2192\u2097[R] M\u2082) with\n    toFun := fun _ => 0\n    invFun := fun _ => 0\n    left_inv := fun _ => Subsingleton.elim _ _\n    right_inv := fun _ => Subsingleton.elim _ _ }", "start": [710, 1], "end": [717, 50], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubsingleton_self", "code": "@[simp]\ntheorem ofSubsingleton_self : ofSubsingleton M M = refl R M", "start": [721, 1], "end": [724, 7], "kind": "commanddeclaration"}, {"full_name": "Module.compHom.toLinearEquiv", "code": "@[simps]\ndef compHom.toLinearEquiv {R S : Type*} [Semiring R] [Semiring S] (g : R \u2243+* S) :\n    haveI := compHom S (\u2191g : R \u2192+* S)\n    R \u2243\u2097[R] S :=\n  letI := compHom S (\u2191g : R \u2192+* S)\n  { g with\n    toFun := (g : R \u2192 S)\n    invFun := (g.symm : S \u2192 R)\n    map_smul' := g.map_mul }", "start": [735, 1], "end": [744, 29], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toLinearEquiv", "code": "@[simps!]\ndef toLinearEquiv (s : S) : M \u2243\u2097[R] M :=\n  { toAddEquiv M s, toLinearMap R M s with }", "start": [756, 1], "end": [761, 45], "kind": "commanddeclaration"}, {"full_name": "DistribMulAction.toModuleAut", "code": "@[simps]\ndef toModuleAut : S \u2192* M \u2243\u2097[R] M where\n  toFun := toLinearEquiv R M\n  map_one' := LinearEquiv.ext <| one_smul _\n  map_mul' _ _ := LinearEquiv.ext <| mul_smul _ _", "start": [766, 1], "end": [773, 50], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toLinearEquiv", "code": "def toLinearEquiv (h : \u2200 (c : R) (x), e (c \u2022 x) = c \u2022 e x) : M \u2243\u2097[R] M\u2082 :=\n  { e with map_smul' := h }", "start": [789, 1], "end": [791, 28], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.coe_toLinearEquiv", "code": "@[simp]\ntheorem coe_toLinearEquiv (h : \u2200 (c : R) (x), e (c \u2022 x) = c \u2022 e x) : \u21d1(e.toLinearEquiv h) = e", "start": [794, 1], "end": [796, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.coe_toLinearEquiv_symm", "code": "@[simp]\ntheorem coe_toLinearEquiv_symm (h : \u2200 (c : R) (x), e (c \u2022 x) = c \u2022 e x) :\n    \u21d1(e.toLinearEquiv h).symm = e.symm", "start": [799, 1], "end": [802, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toNatLinearEquiv", "code": "def toNatLinearEquiv : M \u2243\u2097[\u2115] M\u2082 :=\n  e.toLinearEquiv fun c a => by\n    erw [e.toAddMonoidHom.map_nsmul]\n    rfl", "start": [805, 1], "end": [810, 8], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.coe_toNatLinearEquiv", "code": "@[simp]\ntheorem coe_toNatLinearEquiv : \u21d1e.toNatLinearEquiv = e", "start": [813, 1], "end": [815, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toNatLinearEquiv_toAddEquiv", "code": "@[simp]\ntheorem toNatLinearEquiv_toAddEquiv : \u2191e.toNatLinearEquiv = e", "start": [818, 1], "end": [821, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toAddEquiv_toNatLinearEquiv", "code": "@[simp]\ntheorem _root_.LinearEquiv.toAddEquiv_toNatLinearEquiv (e : M \u2243\u2097[\u2115] M\u2082) :\n    AddEquiv.toNatLinearEquiv \u2191e = e", "start": [824, 1], "end": [827, 28], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toNatLinearEquiv_symm", "code": "@[simp]\ntheorem toNatLinearEquiv_symm : e.toNatLinearEquiv.symm = e.symm.toNatLinearEquiv", "start": [830, 1], "end": [832, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toNatLinearEquiv_refl", "code": "@[simp]\ntheorem toNatLinearEquiv_refl : (AddEquiv.refl M).toNatLinearEquiv = LinearEquiv.refl \u2115 M", "start": [835, 1], "end": [837, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toNatLinearEquiv_trans", "code": "@[simp]\ntheorem toNatLinearEquiv_trans (e\u2082 : M\u2082 \u2243+ M\u2083) :\n    e.toNatLinearEquiv.trans e\u2082.toNatLinearEquiv = (e.trans e\u2082).toNatLinearEquiv", "start": [840, 1], "end": [843, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toIntLinearEquiv", "code": "def toIntLinearEquiv : M \u2243\u2097[\u2124] M\u2082 :=\n  e.toLinearEquiv fun c a => e.toAddMonoidHom.map_zsmul a c", "start": [854, 1], "end": [857, 60], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.coe_toIntLinearEquiv", "code": "@[simp]\ntheorem coe_toIntLinearEquiv : \u21d1e.toIntLinearEquiv = e", "start": [860, 1], "end": [862, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toIntLinearEquiv_toAddEquiv", "code": "@[simp]\ntheorem toIntLinearEquiv_toAddEquiv : \u2191e.toIntLinearEquiv = e", "start": [865, 1], "end": [868, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toAddEquiv_toIntLinearEquiv", "code": "@[simp]\ntheorem _root_.LinearEquiv.toAddEquiv_toIntLinearEquiv (e : M \u2243\u2097[\u2124] M\u2082) :\n    AddEquiv.toIntLinearEquiv (e : M \u2243+ M\u2082) = e", "start": [871, 1], "end": [874, 28], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toIntLinearEquiv_symm", "code": "@[simp]\ntheorem toIntLinearEquiv_symm : e.toIntLinearEquiv.symm = e.symm.toIntLinearEquiv", "start": [877, 1], "end": [879, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toIntLinearEquiv_refl", "code": "@[simp]\ntheorem toIntLinearEquiv_refl : (AddEquiv.refl M).toIntLinearEquiv = LinearEquiv.refl \u2124 M", "start": [882, 1], "end": [884, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.toIntLinearEquiv_trans", "code": "@[simp]\ntheorem toIntLinearEquiv_trans (e\u2082 : M\u2082 \u2243+ M\u2083) :\n    e.toIntLinearEquiv.trans e\u2082.toIntLinearEquiv = (e.trans e\u2082).toIntLinearEquiv", "start": [887, 1], "end": [890, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Data/Set/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Nonempty.sup'_eq_cSup_image", "code": "theorem Finset.Nonempty.sup'_eq_cSup_image {s : Finset \u03b2} (hs : s.Nonempty) (f : \u03b2 \u2192 \u03b1) :\n    s.sup' hs f = sSup (f '' s)", "start": [25, 1], "end": [28, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.sup'_id_eq_cSup", "code": "theorem Finset.Nonempty.sup'_id_eq_cSup {s : Finset \u03b1} (hs : s.Nonempty) : s.sup' hs id = sSup s", "start": [31, 1], "end": [32, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.cSup_eq_max'", "code": "theorem Finset.Nonempty.cSup_eq_max' {s : Finset \u03b1} (h : s.Nonempty) : sSup \u2191s = s.max' h", "start": [41, 1], "end": [42, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.cInf_eq_min'", "code": "theorem Finset.Nonempty.cInf_eq_min' {s : Finset \u03b1} (h : s.Nonempty) : sInf \u2191s = s.min' h", "start": [45, 1], "end": [46, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.cSup_mem", "code": "theorem Finset.Nonempty.cSup_mem {s : Finset \u03b1} (h : s.Nonempty) : sSup (s : Set \u03b1) \u2208 s", "start": [49, 1], "end": [51, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.cInf_mem", "code": "theorem Finset.Nonempty.cInf_mem {s : Finset \u03b1} (h : s.Nonempty) : sInf (s : Set \u03b1) \u2208 s", "start": [54, 1], "end": [55, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.cSup_mem", "code": "theorem Set.Nonempty.cSup_mem (h : s.Nonempty) (hs : s.Finite) : sSup s \u2208 s", "start": [58, 1], "end": [60, 35], "kind": "commanddeclaration"}, {"full_name": "Set.Nonempty.cInf_mem", "code": "theorem Set.Nonempty.cInf_mem (h : s.Nonempty) (hs : s.Finite) : sInf s \u2208 s", "start": [63, 1], "end": [64, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.cSup_lt_iff", "code": "theorem Set.Finite.cSup_lt_iff (hs : s.Finite) (h : s.Nonempty) : sSup s < a \u2194 \u2200 x \u2208 s, x < a", "start": [67, 1], "end": [68, 86], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.lt_cInf_iff", "code": "theorem Set.Finite.lt_cInf_iff (hs : s.Finite) (h : s.Nonempty) : a < sInf s \u2194 \u2200 x \u2208 s, a < x", "start": [71, 1], "end": [72, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_eq_csSup_image", "code": "theorem sup'_eq_csSup_image [ConditionallyCompleteLattice \u03b2] (s : Finset \u03b1) (H) (f : \u03b1 \u2192 \u03b2) :\n    s.sup' H f = sSup (f '' s)", "start": [87, 1], "end": [96, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_eq_csInf_image", "code": "theorem inf'_eq_csInf_image [ConditionallyCompleteLattice \u03b2] (s : Finset \u03b1) (H) (f : \u03b1 \u2192 \u03b2) :\n    s.inf' H f = sInf (f '' s)", "start": [99, 1], "end": [101, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sup'_id_eq_csSup", "code": "theorem sup'_id_eq_csSup [ConditionallyCompleteLattice \u03b1] (s : Finset \u03b1) (H) :\n    s.sup' H id = sSup s", "start": [104, 1], "end": [105, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.inf'_id_eq_csInf", "code": "theorem inf'_id_eq_csInf [ConditionallyCompleteLattice \u03b1] (s : Finset \u03b1) (H) :\n    s.inf' H id = sInf s", "start": [108, 1], "end": [110, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Constructions.lean", "imports": ["Mathlib/Order/Filter/Pi.lean", "Mathlib/Topology/Maps.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "instTopologicalSpaceSubtype", "code": "instance instTopologicalSpaceSubtype {p : \u03b1 \u2192 Prop} [t : TopologicalSpace \u03b1] :\n    TopologicalSpace (Subtype p) :=\n  induced (\u2191) t", "start": [46, 1], "end": [48, 16], "kind": "commanddeclaration"}, {"full_name": "instTopologicalSpaceQuotient", "code": "instance instTopologicalSpaceQuotient {s : Setoid \u03b1} [t : TopologicalSpace \u03b1] :\n    TopologicalSpace (Quotient s) :=\n  coinduced Quotient.mk' t", "start": [53, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "instTopologicalSpaceProd", "code": "instance instTopologicalSpaceProd [t\u2081 : TopologicalSpace \u03b1] [t\u2082 : TopologicalSpace \u03b2] :\n    TopologicalSpace (\u03b1 \u00d7 \u03b2) :=\n  induced Prod.fst t\u2081 \u2293 induced Prod.snd t\u2082", "start": [57, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "instTopologicalSpaceSum", "code": "instance instTopologicalSpaceSum [t\u2081 : TopologicalSpace \u03b1] [t\u2082 : TopologicalSpace \u03b2] :\n    TopologicalSpace (\u03b1 \u2295 \u03b2) :=\n  coinduced Sum.inl t\u2081 \u2294 coinduced Sum.inr t\u2082", "start": [61, 1], "end": [63, 46], "kind": "commanddeclaration"}, {"full_name": "instTopologicalSpaceSigma", "code": "instance instTopologicalSpaceSigma {\u03b2 : \u03b1 \u2192 Type v} [t\u2082 : \u2200 a, TopologicalSpace (\u03b2 a)] :\n    TopologicalSpace (Sigma \u03b2) :=\n  \u2a06 a, coinduced (Sigma.mk a) (t\u2082 a)", "start": [65, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.topologicalSpace", "code": "instance Pi.topologicalSpace {\u03b2 : \u03b1 \u2192 Type v} [t\u2082 : (a : \u03b1) \u2192 TopologicalSpace (\u03b2 a)] :\n    TopologicalSpace ((a : \u03b1) \u2192 \u03b2 a) :=\n  \u2a05 a, induced (fun f => f a) (t\u2082 a)", "start": [69, 1], "end": [71, 37], "kind": "commanddeclaration"}, {"full_name": "ULift.topologicalSpace", "code": "instance ULift.topologicalSpace [t : TopologicalSpace \u03b1] : TopologicalSpace (ULift.{v, u} \u03b1) :=\n  t.induced ULift.down", "start": [74, 1], "end": [75, 23], "kind": "commanddeclaration"}, {"full_name": "continuous_ofMul", "code": "theorem continuous_ofMul : Continuous (ofMul : \u03b1 \u2192 Additive \u03b1)", "start": [96, 1], "end": [96, 80], "kind": "commanddeclaration"}, {"full_name": "continuous_toMul", "code": "theorem continuous_toMul : Continuous (toMul : Additive \u03b1 \u2192 \u03b1)", "start": [99, 1], "end": [99, 80], "kind": "commanddeclaration"}, {"full_name": "continuous_ofAdd", "code": "theorem continuous_ofAdd : Continuous (ofAdd : \u03b1 \u2192 Multiplicative \u03b1)", "start": [102, 1], "end": [102, 86], "kind": "commanddeclaration"}, {"full_name": "continuous_toAdd", "code": "theorem continuous_toAdd : Continuous (toAdd : Multiplicative \u03b1 \u2192 \u03b1)", "start": [105, 1], "end": [105, 86], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_ofMul", "code": "theorem isOpenMap_ofMul : IsOpenMap (ofMul : \u03b1 \u2192 Additive \u03b1)", "start": [108, 1], "end": [108, 77], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_toMul", "code": "theorem isOpenMap_toMul : IsOpenMap (toMul : Additive \u03b1 \u2192 \u03b1)", "start": [111, 1], "end": [111, 77], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_ofAdd", "code": "theorem isOpenMap_ofAdd : IsOpenMap (ofAdd : \u03b1 \u2192 Multiplicative \u03b1)", "start": [114, 1], "end": [114, 83], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_toAdd", "code": "theorem isOpenMap_toAdd : IsOpenMap (toAdd : Multiplicative \u03b1 \u2192 \u03b1)", "start": [117, 1], "end": [117, 83], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_ofMul", "code": "theorem isClosedMap_ofMul : IsClosedMap (ofMul : \u03b1 \u2192 Additive \u03b1)", "start": [120, 1], "end": [120, 83], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_toMul", "code": "theorem isClosedMap_toMul : IsClosedMap (toMul : Additive \u03b1 \u2192 \u03b1)", "start": [123, 1], "end": [123, 83], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_ofAdd", "code": "theorem isClosedMap_ofAdd : IsClosedMap (ofAdd : \u03b1 \u2192 Multiplicative \u03b1)", "start": [126, 1], "end": [126, 89], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_toAdd", "code": "theorem isClosedMap_toAdd : IsClosedMap (toAdd : Multiplicative \u03b1 \u2192 \u03b1)", "start": [129, 1], "end": [129, 89], "kind": "commanddeclaration"}, {"full_name": "nhds_ofMul", "code": "theorem nhds_ofMul (a : \u03b1) : \ud835\udcdd (ofMul a) = map ofMul (\ud835\udcdd a)", "start": [132, 1], "end": [132, 66], "kind": "commanddeclaration"}, {"full_name": "nhds_ofAdd", "code": "theorem nhds_ofAdd (a : \u03b1) : \ud835\udcdd (ofAdd a) = map ofAdd (\ud835\udcdd a)", "start": [135, 1], "end": [135, 66], "kind": "commanddeclaration"}, {"full_name": "nhds_toMul", "code": "theorem nhds_toMul (a : Additive \u03b1) : \ud835\udcdd (toMul a) = map toMul (\ud835\udcdd a)", "start": [138, 1], "end": [138, 75], "kind": "commanddeclaration"}, {"full_name": "nhds_toAdd", "code": "theorem nhds_toAdd (a : Multiplicative \u03b1) : \ud835\udcdd (toAdd a) = map toAdd (\ud835\udcdd a)", "start": [141, 1], "end": [141, 81], "kind": "commanddeclaration"}, {"full_name": "continuous_toDual", "code": "theorem continuous_toDual : Continuous (toDual : \u03b1 \u2192 \u03b1\u1d52\u1d48)", "start": [162, 1], "end": [162, 75], "kind": "commanddeclaration"}, {"full_name": "continuous_ofDual", "code": "theorem continuous_ofDual : Continuous (ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b1)", "start": [165, 1], "end": [165, 75], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_toDual", "code": "theorem isOpenMap_toDual : IsOpenMap (toDual : \u03b1 \u2192 \u03b1\u1d52\u1d48)", "start": [168, 1], "end": [168, 72], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_ofDual", "code": "theorem isOpenMap_ofDual : IsOpenMap (ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b1)", "start": [171, 1], "end": [171, 72], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_toDual", "code": "theorem isClosedMap_toDual : IsClosedMap (toDual : \u03b1 \u2192 \u03b1\u1d52\u1d48)", "start": [174, 1], "end": [174, 78], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_ofDual", "code": "theorem isClosedMap_ofDual : IsClosedMap (ofDual : \u03b1\u1d52\u1d48 \u2192 \u03b1)", "start": [177, 1], "end": [177, 78], "kind": "commanddeclaration"}, {"full_name": "nhds_toDual", "code": "theorem nhds_toDual (a : \u03b1) : \ud835\udcdd (toDual a) = map toDual (\ud835\udcdd a)", "start": [180, 1], "end": [180, 69], "kind": "commanddeclaration"}, {"full_name": "nhds_ofDual", "code": "theorem nhds_ofDual (a : \u03b1) : \ud835\udcdd (ofDual a) = map ofDual (\ud835\udcdd a)", "start": [183, 1], "end": [183, 69], "kind": "commanddeclaration"}, {"full_name": "Quotient.preimage_mem_nhds", "code": "theorem Quotient.preimage_mem_nhds [TopologicalSpace \u03b1] [s : Setoid \u03b1] {V : Set <| Quotient s}\n    {a : \u03b1} (hs : V \u2208 \ud835\udcdd (Quotient.mk' a)) : Quotient.mk' \u207b\u00b9' V \u2208 \ud835\udcdd a", "start": [188, 1], "end": [190, 29], "kind": "commanddeclaration"}, {"full_name": "Dense.quotient", "code": "theorem Dense.quotient [Setoid \u03b1] [TopologicalSpace \u03b1] {s : Set \u03b1} (H : Dense s) :\n    Dense (Quotient.mk' '' s)", "start": [193, 1], "end": [196, 86], "kind": "commanddeclaration"}, {"full_name": "DenseRange.quotient", "code": "theorem DenseRange.quotient [Setoid \u03b1] [TopologicalSpace \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : DenseRange f) :\n    DenseRange (Quotient.mk' \u2218 f)", "start": [199, 1], "end": [202, 80], "kind": "commanddeclaration"}, {"full_name": "Sum.discreteTopology", "code": "instance Sum.discreteTopology [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [h\u03b1 : DiscreteTopology \u03b1]\n    [h\u03b2 : DiscreteTopology \u03b2] : DiscreteTopology (Sum \u03b1 \u03b2) :=\n  \u27e8sup_eq_bot_iff.2 <| by simp [h\u03b1.eq_bot, h\u03b2.eq_bot]\u27e9", "start": [208, 1], "end": [210, 55], "kind": "commanddeclaration"}, {"full_name": "Sigma.discreteTopology", "code": "instance Sigma.discreteTopology {\u03b2 : \u03b1 \u2192 Type v} [\u2200 a, TopologicalSpace (\u03b2 a)]\n    [h : \u2200 a, DiscreteTopology (\u03b2 a)] : DiscreteTopology (Sigma \u03b2) :=\n  \u27e8iSup_eq_bot.2 <| fun _ => by simp only [(h _).eq_bot, coinduced_bot]\u27e9", "start": [213, 1], "end": [215, 73], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_subtype", "code": "theorem mem_nhds_subtype (s : Set \u03b1) (a : { x // x \u2208 s }) (t : Set { x // x \u2208 s }) :\n    t \u2208 \ud835\udcdd a \u2194 \u2203 u \u2208 \ud835\udcdd (a : \u03b1), Subtype.val \u207b\u00b9' u \u2286 t", "start": [225, 1], "end": [227, 25], "kind": "commanddeclaration"}, {"full_name": "nhds_subtype", "code": "theorem nhds_subtype (s : Set \u03b1) (a : { x // x \u2208 s }) : \ud835\udcdd a = comap (\u2191) (\ud835\udcdd (a : \u03b1))", "start": [230, 1], "end": [231, 19], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_subtype_eq_bot_iff", "code": "theorem nhdsWithin_subtype_eq_bot_iff {s t : Set \u03b1} {x : s} :\n    \ud835\udcdd[((\u2191) : s \u2192 \u03b1) \u207b\u00b9' t] x = \u22a5 \u2194 \ud835\udcdd[t] (x : \u03b1) \u2293 \ud835\udcdf s = \u22a5", "start": [234, 1], "end": [237, 18], "kind": "commanddeclaration"}, {"full_name": "nhds_ne_subtype_eq_bot_iff", "code": "theorem nhds_ne_subtype_eq_bot_iff {S : Set \u03b1} {x : S} :\n    \ud835\udcdd[\u2260] x = \u22a5 \u2194 \ud835\udcdd[\u2260] (x : \u03b1) \u2293 \ud835\udcdf S = \u22a5", "start": [240, 1], "end": [243, 42], "kind": "commanddeclaration"}, {"full_name": "nhds_ne_subtype_neBot_iff", "code": "theorem nhds_ne_subtype_neBot_iff {S : Set \u03b1} {x : S} :\n    (\ud835\udcdd[\u2260] x).NeBot \u2194 (\ud835\udcdd[\u2260] (x : \u03b1) \u2293 \ud835\udcdf S).NeBot", "start": [246, 1], "end": [248, 69], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_subtype_iff", "code": "theorem discreteTopology_subtype_iff {S : Set \u03b1} : DiscreteTopology S \u2194 \u2200 x \u2208 S, \ud835\udcdd[\u2260] x \u2293 \ud835\udcdf S = \u22a5", "start": [251, 1], "end": [252, 88], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology", "code": "def CofiniteTopology (\u03b1 : Type*) :=\n  \u03b1", "start": [257, 1], "end": [260, 4], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.of", "code": "def of : \u03b1 \u2243 CofiniteTopology \u03b1 :=\n  Equiv.refl \u03b1", "start": [265, 1], "end": [267, 15], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.isOpen_iff", "code": "theorem isOpen_iff {s : Set (CofiniteTopology \u03b1)} : IsOpen s \u2194 s.Nonempty \u2192 s\u1d9c.Finite", "start": [284, 1], "end": [285, 10], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.isOpen_iff'", "code": "theorem isOpen_iff' {s : Set (CofiniteTopology \u03b1)} : IsOpen s \u2194 s = \u2205 \u2228 s\u1d9c.Finite", "start": [288, 1], "end": [289, 69], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.isClosed_iff", "code": "theorem isClosed_iff {s : Set (CofiniteTopology \u03b1)} : IsClosed s \u2194 s = univ \u2228 s.Finite", "start": [292, 1], "end": [293, 76], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.nhds_eq", "code": "theorem nhds_eq (a : CofiniteTopology \u03b1) : \ud835\udcdd a = pure a \u2294 cofinite", "start": [296, 1], "end": [303, 44], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.mem_nhds_iff", "code": "theorem mem_nhds_iff {a : CofiniteTopology \u03b1} {s : Set (CofiniteTopology \u03b1)} :\n    s \u2208 \ud835\udcdd a \u2194 a \u2208 s \u2227 s\u1d9c.Finite", "start": [306, 1], "end": [307, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_prod_mk", "code": "@[simp] theorem continuous_prod_mk {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} :\n    (Continuous fun x => (f x, g x)) \u2194 Continuous f \u2227 Continuous g", "start": [320, 1], "end": [324, 54], "kind": "commanddeclaration"}, {"full_name": "continuous_fst", "code": "@[continuity]\ntheorem continuous_fst : Continuous (@Prod.fst \u03b1 \u03b2)", "start": [327, 1], "end": [329, 41], "kind": "commanddeclaration"}, {"full_name": "Continuous.fst", "code": "theorem Continuous.fst {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf : Continuous f) : Continuous fun a : \u03b1 => (f a).1", "start": [332, 1], "end": [334, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.fst'", "code": "theorem Continuous.fst' {f : \u03b1 \u2192 \u03b3} (hf : Continuous f) : Continuous fun x : \u03b1 \u00d7 \u03b2 => f x.fst", "start": [337, 1], "end": [339, 25], "kind": "commanddeclaration"}, {"full_name": "continuousAt_fst", "code": "theorem continuousAt_fst {p : \u03b1 \u00d7 \u03b2} : ContinuousAt Prod.fst p", "start": [342, 1], "end": [343, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.fst", "code": "theorem ContinuousAt.fst {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {x : \u03b1} (hf : ContinuousAt f x) :\n    ContinuousAt (fun a : \u03b1 => (f a).1) x", "start": [346, 1], "end": [349, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.fst'", "code": "theorem ContinuousAt.fst' {f : \u03b1 \u2192 \u03b3} {x : \u03b1} {y : \u03b2} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x : \u03b1 \u00d7 \u03b2 => f x.fst) (x, y)", "start": [352, 1], "end": [355, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.fst''", "code": "theorem ContinuousAt.fst'' {f : \u03b1 \u2192 \u03b3} {x : \u03b1 \u00d7 \u03b2} (hf : ContinuousAt f x.fst) :\n    ContinuousAt (fun x : \u03b1 \u00d7 \u03b2 => f x.fst) x", "start": [358, 1], "end": [361, 27], "kind": "commanddeclaration"}, {"full_name": "continuous_snd", "code": "@[continuity]\ntheorem continuous_snd : Continuous (@Prod.snd \u03b1 \u03b2)", "start": [364, 1], "end": [366, 41], "kind": "commanddeclaration"}, {"full_name": "Continuous.snd", "code": "theorem Continuous.snd {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} (hf : Continuous f) : Continuous fun a : \u03b1 => (f a).2", "start": [369, 1], "end": [371, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.snd'", "code": "theorem Continuous.snd' {f : \u03b2 \u2192 \u03b3} (hf : Continuous f) : Continuous fun x : \u03b1 \u00d7 \u03b2 => f x.snd", "start": [374, 1], "end": [376, 25], "kind": "commanddeclaration"}, {"full_name": "continuousAt_snd", "code": "theorem continuousAt_snd {p : \u03b1 \u00d7 \u03b2} : ContinuousAt Prod.snd p", "start": [379, 1], "end": [380, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.snd", "code": "theorem ContinuousAt.snd {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {x : \u03b1} (hf : ContinuousAt f x) :\n    ContinuousAt (fun a : \u03b1 => (f a).2) x", "start": [383, 1], "end": [386, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.snd'", "code": "theorem ContinuousAt.snd' {f : \u03b2 \u2192 \u03b3} {x : \u03b1} {y : \u03b2} (hf : ContinuousAt f y) :\n    ContinuousAt (fun x : \u03b1 \u00d7 \u03b2 => f x.snd) (x, y)", "start": [389, 1], "end": [392, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.snd''", "code": "theorem ContinuousAt.snd'' {f : \u03b2 \u2192 \u03b3} {x : \u03b1 \u00d7 \u03b2} (hf : ContinuousAt f x.snd) :\n    ContinuousAt (fun x : \u03b1 \u00d7 \u03b2 => f x.snd) x", "start": [395, 1], "end": [398, 27], "kind": "commanddeclaration"}, {"full_name": "Continuous.prod_mk", "code": "@[continuity]\ntheorem Continuous.prod_mk {f : \u03b3 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b2} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => (f x, g x)", "start": [401, 1], "end": [404, 32], "kind": "commanddeclaration"}, {"full_name": "Continuous.Prod.mk", "code": "@[continuity]\ntheorem Continuous.Prod.mk (a : \u03b1) : Continuous fun b : \u03b2 => (a, b)", "start": [407, 1], "end": [409, 41], "kind": "commanddeclaration"}, {"full_name": "Continuous.Prod.mk_left", "code": "@[continuity]\ntheorem Continuous.Prod.mk_left (b : \u03b2) : Continuous fun a : \u03b1 => (a, b)", "start": [412, 1], "end": [414, 41], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp\u2082", "code": "theorem Continuous.comp\u2082 {g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (hg : Continuous g) {e : \u03b4 \u2192 \u03b1} (he : Continuous e)\n    {f : \u03b4 \u2192 \u03b2} (hf : Continuous f) : Continuous fun x => g (e x, f x)", "start": [417, 1], "end": [419, 27], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp\u2083", "code": "theorem Continuous.comp\u2083 {g : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 \u03b5} (hg : Continuous g) {e : \u03b4 \u2192 \u03b1} (he : Continuous e)\n    {f : \u03b4 \u2192 \u03b2} (hf : Continuous f) {k : \u03b4 \u2192 \u03b3} (hk : Continuous k) :\n    Continuous fun x => g (e x, f x, k x)", "start": [422, 1], "end": [425, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp\u2084", "code": "theorem Continuous.comp\u2084 {g : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u00d7 \u03b6 \u2192 \u03b5} (hg : Continuous g) {e : \u03b4 \u2192 \u03b1} (he : Continuous e)\n    {f : \u03b4 \u2192 \u03b2} (hf : Continuous f) {k : \u03b4 \u2192 \u03b3} (hk : Continuous k) {l : \u03b4 \u2192 \u03b6}\n    (hl : Continuous l) : Continuous fun x => g (e x, f x, k x, l x)", "start": [428, 1], "end": [431, 34], "kind": "commanddeclaration"}, {"full_name": "Continuous.prod_map", "code": "@[continuity]\ntheorem Continuous.prod_map {f : \u03b3 \u2192 \u03b1} {g : \u03b4 \u2192 \u03b2} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x : \u03b3 \u00d7 \u03b4 => (f x.1, g x.2)", "start": [434, 1], "end": [437, 26], "kind": "commanddeclaration"}, {"full_name": "continuous_inf_dom_left\u2082", "code": "theorem continuous_inf_dom_left\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ta1 ta2 : TopologicalSpace \u03b1}\n    {tb1 tb2 : TopologicalSpace \u03b2} {tc1 : TopologicalSpace \u03b3}\n    (h : by haveI := ta1; haveI := tb1; exact Continuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n    haveI := ta1 \u2293 ta2; haveI := tb1 \u2293 tb2; exact Continuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [440, 1], "end": [448, 69], "kind": "commanddeclaration"}, {"full_name": "continuous_inf_dom_right\u2082", "code": "theorem continuous_inf_dom_right\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ta1 ta2 : TopologicalSpace \u03b1}\n    {tb1 tb2 : TopologicalSpace \u03b2} {tc1 : TopologicalSpace \u03b3}\n    (h : by haveI := ta2; haveI := tb2; exact Continuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n    haveI := ta1 \u2293 ta2; haveI := tb1 \u2293 tb2; exact Continuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [451, 1], "end": [459, 69], "kind": "commanddeclaration"}, {"full_name": "continuous_sInf_dom\u2082", "code": "theorem continuous_sInf_dom\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {tas : Set (TopologicalSpace \u03b1)}\n    {tbs : Set (TopologicalSpace \u03b2)} {ta : TopologicalSpace \u03b1} {tb : TopologicalSpace \u03b2}\n    {tc : TopologicalSpace \u03b3} (ha : ta \u2208 tas) (hb : tb \u2208 tbs)\n    (hf : Continuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n    haveI := sInf tas; haveI := sInf tbs;\n      exact @Continuous _ _ _ tc fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [462, 1], "end": [472, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_inl_nhds", "code": "theorem Filter.Eventually.prod_inl_nhds {p : \u03b1 \u2192 Prop} {a : \u03b1} (h : \u2200\u1da0 x in \ud835\udcdd a, p x) (b : \u03b2) :\n    \u2200\u1da0 x in \ud835\udcdd (a, b), p (x : \u03b1 \u00d7 \u03b2).1", "start": [475, 1], "end": [477, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_inr_nhds", "code": "theorem Filter.Eventually.prod_inr_nhds {p : \u03b2 \u2192 Prop} {b : \u03b2} (h : \u2200\u1da0 x in \ud835\udcdd b, p x) (a : \u03b1) :\n    \u2200\u1da0 x in \ud835\udcdd (a, b), p (x : \u03b1 \u00d7 \u03b2).2", "start": [480, 1], "end": [482, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_mk_nhds", "code": "theorem Filter.Eventually.prod_mk_nhds {pa : \u03b1 \u2192 Prop} {a} (ha : \u2200\u1da0 x in \ud835\udcdd a, pa x) {pb : \u03b2 \u2192 Prop}\n    {b} (hb : \u2200\u1da0 y in \ud835\udcdd b, pb y) : \u2200\u1da0 p in \ud835\udcdd (a, b), pa (p : \u03b1 \u00d7 \u03b2).1 \u2227 pb p.2", "start": [485, 1], "end": [487, 48], "kind": "commanddeclaration"}, {"full_name": "continuous_swap", "code": "theorem continuous_swap : Continuous (Prod.swap : \u03b1 \u00d7 \u03b2 \u2192 \u03b2 \u00d7 \u03b1)", "start": [490, 1], "end": [491, 40], "kind": "commanddeclaration"}, {"full_name": "continuous_uncurry_left", "code": "theorem continuous_uncurry_left {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (a : \u03b1) (h : Continuous (uncurry f)) :\n    Continuous (f a)", "start": [494, 1], "end": [496, 32], "kind": "commanddeclaration"}, {"full_name": "continuous_uncurry_right", "code": "theorem continuous_uncurry_right {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (b : \u03b2) (h : Continuous (uncurry f)) :\n    Continuous fun a => f a b", "start": [499, 1], "end": [501, 37], "kind": "commanddeclaration"}, {"full_name": "continuous_curry", "code": "theorem continuous_curry {g : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (a : \u03b1) (h : Continuous g) : Continuous (curry g a)", "start": [504, 1], "end": [505, 30], "kind": "commanddeclaration"}, {"full_name": "IsOpen.prod", "code": "theorem IsOpen.prod {s : Set \u03b1} {t : Set \u03b2} (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s \u00d7\u02e2 t)", "start": [508, 1], "end": [509, 66], "kind": "commanddeclaration"}, {"full_name": "nhds_prod_eq", "code": "theorem nhds_prod_eq {a : \u03b1} {b : \u03b2} : \ud835\udcdd (a, b) = \ud835\udcdd a \u00d7\u02e2 \ud835\udcdd b", "start": [513, 1], "end": [516, 77], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_prod_eq", "code": "theorem nhdsWithin_prod_eq (a : \u03b1) (b : \u03b2) (s : Set \u03b1) (t : Set \u03b2) :\n    \ud835\udcdd[s \u00d7\u02e2 t] (a, b) = \ud835\udcdd[s] a \u00d7\u02e2 \ud835\udcdd[t] b", "start": [520, 1], "end": [522, 82], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_prod_iff", "code": "theorem mem_nhds_prod_iff {a : \u03b1} {b : \u03b2} {s : Set (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 \ud835\udcdd (a, b) \u2194 \u2203 u \u2208 \ud835\udcdd a, \u2203 v \u2208 \ud835\udcdd b, u \u00d7\u02e2 v \u2286 s", "start": [527, 1], "end": [528, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_nhds", "code": "theorem Filter.HasBasis.prod_nhds {\u03b9a \u03b9b : Type*} {pa : \u03b9a \u2192 Prop} {pb : \u03b9b \u2192 Prop}\n    {sa : \u03b9a \u2192 Set \u03b1} {sb : \u03b9b \u2192 Set \u03b2} {a : \u03b1} {b : \u03b2} (ha : (\ud835\udcdd a).HasBasis pa sa)\n    (hb : (\ud835\udcdd b).HasBasis pb sb) :\n    (\ud835\udcdd (a, b)).HasBasis (fun i : \u03b9a \u00d7 \u03b9b => pa i.1 \u2227 pb i.2) fun i => sa i.1 \u00d7\u02e2 sb i.2", "start": [532, 1], "end": [537, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.prod_nhds'", "code": "theorem Filter.HasBasis.prod_nhds' {\u03b9a \u03b9b : Type*} {pa : \u03b9a \u2192 Prop} {pb : \u03b9b \u2192 Prop}\n    {sa : \u03b9a \u2192 Set \u03b1} {sb : \u03b9b \u2192 Set \u03b2} {ab : \u03b1 \u00d7 \u03b2} (ha : (\ud835\udcdd ab.1).HasBasis pa sa)\n    (hb : (\ud835\udcdd ab.2).HasBasis pb sb) :\n    (\ud835\udcdd ab).HasBasis (fun i : \u03b9a \u00d7 \u03b9b => pa i.1 \u2227 pb i.2) fun i => sa i.1 \u00d7\u02e2 sb i.2", "start": [541, 1], "end": [545, 18], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_prod_iff'", "code": "theorem mem_nhds_prod_iff' {a : \u03b1} {b : \u03b2} {s : Set (\u03b1 \u00d7 \u03b2)} :\n    s \u2208 \ud835\udcdd (a, b) \u2194 \u2203 u v, IsOpen u \u2227 a \u2208 u \u2227 IsOpen v \u2227 b \u2208 v \u2227 u \u00d7\u02e2 v \u2286 s", "start": [548, 1], "end": [551, 64], "kind": "commanddeclaration"}, {"full_name": "Prod.tendsto_iff", "code": "theorem Prod.tendsto_iff {\u03b1} (seq : \u03b1 \u2192 \u03b2 \u00d7 \u03b3) {f : Filter \u03b1} (x : \u03b2 \u00d7 \u03b3) :\n    Tendsto seq f (\ud835\udcdd x) \u2194\n      Tendsto (fun n => (seq n).fst) f (\ud835\udcdd x.fst) \u2227 Tendsto (fun n => (seq n).snd) f (\ud835\udcdd x.snd)", "start": [554, 1], "end": [557, 46], "kind": "commanddeclaration"}, {"full_name": "prod_mem_nhds_iff", "code": "theorem prod_mem_nhds_iff {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1} {b : \u03b2} :\n    s \u00d7\u02e2 t \u2208 \ud835\udcdd (a, b) \u2194 s \u2208 \ud835\udcdd a \u2227 t \u2208 \ud835\udcdd b", "start": [564, 1], "end": [565, 85], "kind": "commanddeclaration"}, {"full_name": "prod_mem_nhds", "code": "theorem prod_mem_nhds {s : Set \u03b1} {t : Set \u03b2} {a : \u03b1} {b : \u03b2} (ha : s \u2208 \ud835\udcdd a) (hb : t \u2208 \ud835\udcdd b) :\n    s \u00d7\u02e2 t \u2208 \ud835\udcdd (a, b)", "start": [568, 1], "end": [570, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.prod_nhds", "code": "theorem Filter.Eventually.prod_nhds {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {a : \u03b1} {b : \u03b2}\n    (ha : \u2200\u1da0 x in \ud835\udcdd a, p x) (hb : \u2200\u1da0 y in \ud835\udcdd b, q y) : \u2200\u1da0 z : \u03b1 \u00d7 \u03b2 in \ud835\udcdd (a, b), p z.1 \u2227 q z.2", "start": [573, 1], "end": [575, 22], "kind": "commanddeclaration"}, {"full_name": "nhds_swap", "code": "theorem nhds_swap (a : \u03b1) (b : \u03b2) : \ud835\udcdd (a, b) = (\ud835\udcdd (b, a)).map Prod.swap", "start": [578, 1], "end": [579, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.prod_mk_nhds", "code": "theorem Filter.Tendsto.prod_mk_nhds {\u03b3} {a : \u03b1} {b : \u03b2} {f : Filter \u03b3} {ma : \u03b3 \u2192 \u03b1} {mb : \u03b3 \u2192 \u03b2}\n    (ha : Tendsto ma f (\ud835\udcdd a)) (hb : Tendsto mb f (\ud835\udcdd b)) :\n    Tendsto (fun c => (ma c, mb c)) f (\ud835\udcdd (a, b))", "start": [582, 1], "end": [585, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.curry_nhds", "code": "theorem Filter.Eventually.curry_nhds {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} {x : \u03b1} {y : \u03b2}\n    (h : \u2200\u1da0 x in \ud835\udcdd (x, y), p x) : \u2200\u1da0 x' in \ud835\udcdd x, \u2200\u1da0 y' in \ud835\udcdd y, p (x', y')", "start": [588, 1], "end": [591, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.prod", "code": "theorem ContinuousAt.prod {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {x : \u03b1} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g x) : ContinuousAt (fun x => (f x, g x)) x", "start": [594, 1], "end": [596, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.prod_map", "code": "theorem ContinuousAt.prod_map {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {p : \u03b1 \u00d7 \u03b2} (hf : ContinuousAt f p.fst)\n    (hg : ContinuousAt g p.snd) : ContinuousAt (fun p : \u03b1 \u00d7 \u03b2 => (f p.1, g p.2)) p", "start": [599, 1], "end": [601, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.prod_map'", "code": "theorem ContinuousAt.prod_map' {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {x : \u03b1} {y : \u03b2} (hf : ContinuousAt f x)\n    (hg : ContinuousAt g y) : ContinuousAt (fun p : \u03b1 \u00d7 \u03b2 => (f p.1, g p.2)) (x, y)", "start": [604, 1], "end": [606, 23], "kind": "commanddeclaration"}, {"full_name": "prod_generateFrom_generateFrom_eq", "code": "theorem prod_generateFrom_generateFrom_eq {\u03b1 \u03b2 : Type*} {s : Set (Set \u03b1)} {t : Set (Set \u03b2)}\n    (hs : \u22c3\u2080 s = univ) (ht : \u22c3\u2080 t = univ) :\n    @instTopologicalSpaceProd \u03b1 \u03b2 (generateFrom s) (generateFrom t) =\n      generateFrom { g | \u2203 u \u2208 s, \u2203 v \u2208 t, g = u \u00d7\u02e2 v }", "start": [611, 1], "end": [639, 83], "kind": "commanddeclaration"}, {"full_name": "prod_eq_generateFrom", "code": "theorem prod_eq_generateFrom :\n    instTopologicalSpaceProd =\n      generateFrom { g | \u2203 (s : Set \u03b1) (t : Set \u03b2), IsOpen s \u2227 IsOpen t \u2227 g = s \u00d7\u02e2 t }", "start": [643, 1], "end": [651, 74], "kind": "commanddeclaration"}, {"full_name": "isOpen_prod_iff", "code": "theorem isOpen_prod_iff {s : Set (\u03b1 \u00d7 \u03b2)} :\n    IsOpen s \u2194 \u2200 a b, (a, b) \u2208 s \u2192\n      \u2203 u v, IsOpen u \u2227 IsOpen v \u2227 a \u2208 u \u2227 b \u2208 v \u2227 u \u00d7\u02e2 v \u2286 s", "start": [655, 1], "end": [658, 91], "kind": "commanddeclaration"}, {"full_name": "prod_induced_induced", "code": "theorem prod_induced_induced (f : \u03b1 \u2192 \u03b2) (g : \u03b3 \u2192 \u03b4) :\n    @instTopologicalSpaceProd \u03b1 \u03b3 (induced f \u2039_\u203a) (induced g \u2039_\u203a) =\n      induced (fun p => (f p.1, g p.2)) instTopologicalSpaceProd", "start": [661, 1], "end": [667, 6], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_square", "code": "theorem exists_nhds_square {s : Set (\u03b1 \u00d7 \u03b1)} {x : \u03b1} (hx : s \u2208 \ud835\udcdd (x, x)) :\n    \u2203 U : Set \u03b1, IsOpen U \u2227 x \u2208 U \u2227 U \u00d7\u02e2 U \u2286 s", "start": [672, 1], "end": [676, 98], "kind": "commanddeclaration"}, {"full_name": "map_fst_nhdsWithin", "code": "theorem map_fst_nhdsWithin (x : \u03b1 \u00d7 \u03b2) : map Prod.fst (\ud835\udcdd[Prod.snd \u207b\u00b9' {x.2}] x) = \ud835\udcdd x.1", "start": [679, 1], "end": [687, 73], "kind": "commanddeclaration"}, {"full_name": "map_fst_nhds", "code": "@[simp]\ntheorem map_fst_nhds (x : \u03b1 \u00d7 \u03b2) : map Prod.fst (\ud835\udcdd x) = \ud835\udcdd x.1", "start": [690, 1], "end": [692, 94], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_fst", "code": "theorem isOpenMap_fst : IsOpenMap (@Prod.fst \u03b1 \u03b2)", "start": [695, 1], "end": [697, 55], "kind": "commanddeclaration"}, {"full_name": "map_snd_nhdsWithin", "code": "theorem map_snd_nhdsWithin (x : \u03b1 \u00d7 \u03b2) : map Prod.snd (\ud835\udcdd[Prod.fst \u207b\u00b9' {x.1}] x) = \ud835\udcdd x.2", "start": [700, 1], "end": [708, 73], "kind": "commanddeclaration"}, {"full_name": "map_snd_nhds", "code": "@[simp]\ntheorem map_snd_nhds (x : \u03b1 \u00d7 \u03b2) : map Prod.snd (\ud835\udcdd x) = \ud835\udcdd x.2", "start": [711, 1], "end": [713, 94], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_snd", "code": "theorem isOpenMap_snd : IsOpenMap (@Prod.snd \u03b1 \u03b2)", "start": [716, 1], "end": [718, 55], "kind": "commanddeclaration"}, {"full_name": "isOpen_prod_iff'", "code": "theorem isOpen_prod_iff' {s : Set \u03b1} {t : Set \u03b2} :\n    IsOpen (s \u00d7\u02e2 t) \u2194 IsOpen s \u2227 IsOpen t \u2228 s = \u2205 \u2228 t = \u2205", "start": [721, 1], "end": [739, 25], "kind": "commanddeclaration"}, {"full_name": "closure_prod_eq", "code": "theorem closure_prod_eq {s : Set \u03b1} {t : Set \u03b2} : closure (s \u00d7\u02e2 t) = closure s \u00d7\u02e2 closure t", "start": [742, 1], "end": [744, 89], "kind": "commanddeclaration"}, {"full_name": "interior_prod_eq", "code": "theorem interior_prod_eq (s : Set \u03b1) (t : Set \u03b2) : interior (s \u00d7\u02e2 t) = interior s \u00d7\u02e2 interior t", "start": [747, 1], "end": [748, 94], "kind": "commanddeclaration"}, {"full_name": "frontier_prod_eq", "code": "theorem frontier_prod_eq (s : Set \u03b1) (t : Set \u03b2) :\n    frontier (s \u00d7\u02e2 t) = closure s \u00d7\u02e2 frontier t \u222a frontier s \u00d7\u02e2 closure t", "start": [751, 1], "end": [753, 74], "kind": "commanddeclaration"}, {"full_name": "frontier_prod_univ_eq", "code": "@[simp]\ntheorem frontier_prod_univ_eq (s : Set \u03b1) : frontier (s \u00d7\u02e2 (univ : Set \u03b2)) = frontier s \u00d7\u02e2 univ", "start": [756, 1], "end": [758, 29], "kind": "commanddeclaration"}, {"full_name": "frontier_univ_prod_eq", "code": "@[simp]\ntheorem frontier_univ_prod_eq (s : Set \u03b2) : frontier ((univ : Set \u03b1) \u00d7\u02e2 s) = univ \u00d7\u02e2 frontier s", "start": [761, 1], "end": [763, 29], "kind": "commanddeclaration"}, {"full_name": "map_mem_closure\u2082", "code": "theorem map_mem_closure\u2082 {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : \u03b1} {b : \u03b2} {s : Set \u03b1} {t : Set \u03b2} {u : Set \u03b3}\n    (hf : Continuous (uncurry f)) (ha : a \u2208 closure s) (hb : b \u2208 closure t)\n    (h : \u2200 a \u2208 s, \u2200 b \u2208 t, f a b \u2208 u) : f a b \u2208 closure u", "start": [766, 1], "end": [771, 19], "kind": "commanddeclaration"}, {"full_name": "IsClosed.prod", "code": "theorem IsClosed.prod {s\u2081 : Set \u03b1} {s\u2082 : Set \u03b2} (h\u2081 : IsClosed s\u2081) (h\u2082 : IsClosed s\u2082) :\n    IsClosed (s\u2081 \u00d7\u02e2 s\u2082)", "start": [774, 1], "end": [776, 93], "kind": "commanddeclaration"}, {"full_name": "Dense.prod", "code": "theorem Dense.prod {s : Set \u03b1} {t : Set \u03b2} (hs : Dense s) (ht : Dense t) : Dense (s \u00d7\u02e2 t)", "start": [779, 1], "end": [783, 25], "kind": "commanddeclaration"}, {"full_name": "DenseRange.prod_map", "code": "theorem DenseRange.prod_map {\u03b9 : Type*} {\u03ba : Type*} {f : \u03b9 \u2192 \u03b2} {g : \u03ba \u2192 \u03b3} (hf : DenseRange f)\n    (hg : DenseRange g) : DenseRange (Prod.map f g)", "start": [786, 1], "end": [789, 64], "kind": "commanddeclaration"}, {"full_name": "Inducing.prod_map", "code": "theorem Inducing.prod_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Inducing f) (hg : Inducing g) :\n    Inducing (Prod.map f g)", "start": [792, 1], "end": [795, 43], "kind": "commanddeclaration"}, {"full_name": "inducing_const_prod", "code": "@[simp]\ntheorem inducing_const_prod {a : \u03b1} {f : \u03b2 \u2192 \u03b3} : (Inducing fun x => (a, f x)) \u2194 Inducing f", "start": [798, 1], "end": [801, 31], "kind": "commanddeclaration"}, {"full_name": "inducing_prod_const", "code": "@[simp]\ntheorem inducing_prod_const {b : \u03b2} {f : \u03b1 \u2192 \u03b3} : (Inducing fun x => (f x, b)) \u2194 Inducing f", "start": [804, 1], "end": [807, 31], "kind": "commanddeclaration"}, {"full_name": "Embedding.prod_map", "code": "theorem Embedding.prod_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Embedding f) (hg : Embedding g) :\n    Embedding (Prod.map f g)", "start": [810, 1], "end": [813, 77], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.prod", "code": "protected theorem IsOpenMap.prod {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap fun p : \u03b1 \u00d7 \u03b3 => (f p.1, g p.2)", "start": [816, 1], "end": [821, 55], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.prod", "code": "protected theorem OpenEmbedding.prod {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : OpenEmbedding f)\n    (hg : OpenEmbedding g) : OpenEmbedding fun x : \u03b1 \u00d7 \u03b3 => (f x.1, g x.2)", "start": [824, 1], "end": [826, 88], "kind": "commanddeclaration"}, {"full_name": "embedding_graph", "code": "theorem embedding_graph {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) : Embedding fun x => (x, f x)", "start": [829, 1], "end": [830, 88], "kind": "commanddeclaration"}, {"full_name": "embedding_prod_mk", "code": "theorem embedding_prod_mk (x : \u03b1) : Embedding (Prod.mk x : \u03b2 \u2192 \u03b1 \u00d7 \u03b2)", "start": [833, 1], "end": [834, 84], "kind": "commanddeclaration"}, {"full_name": "continuous_sum_dom", "code": "theorem continuous_sum_dom {f : \u03b1 \u2295 \u03b2 \u2192 \u03b3} :\n    Continuous f \u2194 Continuous (f \u2218 Sum.inl) \u2227 Continuous (f \u2218 Sum.inr)", "start": [844, 1], "end": [848, 58], "kind": "commanddeclaration"}, {"full_name": "continuous_sum_elim", "code": "theorem continuous_sum_elim {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} :\n    Continuous (Sum.elim f g) \u2194 Continuous f \u2227 Continuous g", "start": [851, 1], "end": [853, 21], "kind": "commanddeclaration"}, {"full_name": "Continuous.sum_elim", "code": "@[continuity]\ntheorem Continuous.sum_elim {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.elim f g)", "start": [856, 1], "end": [859, 33], "kind": "commanddeclaration"}, {"full_name": "continuous_isLeft", "code": "@[continuity]\ntheorem continuous_isLeft : Continuous (isLeft : \u03b1 \u2295 \u03b2 \u2192 Bool)", "start": [862, 1], "end": [864, 60], "kind": "commanddeclaration"}, {"full_name": "continuous_isRight", "code": "@[continuity]\ntheorem continuous_isRight : Continuous (isRight : \u03b1 \u2295 \u03b2 \u2192 Bool)", "start": [866, 1], "end": [868, 60], "kind": "commanddeclaration"}, {"full_name": "continuous_inl", "code": "@[continuity]\ntheorem continuous_inl : Continuous (@inl \u03b1 \u03b2)", "start": [870, 1], "end": [872, 70], "kind": "commanddeclaration"}, {"full_name": "continuous_inr", "code": "@[continuity]\ntheorem continuous_inr : Continuous (@inr \u03b1 \u03b2)", "start": [875, 1], "end": [877, 71], "kind": "commanddeclaration"}, {"full_name": "isOpen_sum_iff", "code": "theorem isOpen_sum_iff {s : Set (Sum \u03b1 \u03b2)} : IsOpen s \u2194 IsOpen (inl \u207b\u00b9' s) \u2227 IsOpen (inr \u207b\u00b9' s)", "start": [880, 1], "end": [881, 10], "kind": "commanddeclaration"}, {"full_name": "isClosed_sum_iff", "code": "theorem isClosed_sum_iff {s : Set (\u03b1 \u2295 \u03b2)} :\n    IsClosed s \u2194 IsClosed (inl \u207b\u00b9' s) \u2227 IsClosed (inr \u207b\u00b9' s)", "start": [885, 1], "end": [887, 65], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_inl", "code": "theorem isOpenMap_inl : IsOpenMap (@inl \u03b1 \u03b2)", "start": [889, 1], "end": [890, 64], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_inr", "code": "theorem isOpenMap_inr : IsOpenMap (@inr \u03b1 \u03b2)", "start": [893, 1], "end": [894, 64], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_inl", "code": "theorem openEmbedding_inl : OpenEmbedding (@inl \u03b1 \u03b2)", "start": [897, 1], "end": [898, 88], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_inr", "code": "theorem openEmbedding_inr : OpenEmbedding (@inr \u03b1 \u03b2)", "start": [901, 1], "end": [902, 88], "kind": "commanddeclaration"}, {"full_name": "embedding_inl", "code": "theorem embedding_inl : Embedding (@inl \u03b1 \u03b2)", "start": [905, 1], "end": [906, 22], "kind": "commanddeclaration"}, {"full_name": "embedding_inr", "code": "theorem embedding_inr : Embedding (@inr \u03b1 \u03b2)", "start": [909, 1], "end": [910, 22], "kind": "commanddeclaration"}, {"full_name": "isOpen_range_inl", "code": "theorem isOpen_range_inl : IsOpen (range (inl : \u03b1 \u2192 Sum \u03b1 \u03b2))", "start": [913, 1], "end": [914, 22], "kind": "commanddeclaration"}, {"full_name": "isOpen_range_inr", "code": "theorem isOpen_range_inr : IsOpen (range (inr : \u03b2 \u2192 Sum \u03b1 \u03b2))", "start": [917, 1], "end": [918, 22], "kind": "commanddeclaration"}, {"full_name": "isClosed_range_inl", "code": "theorem isClosed_range_inl : IsClosed (range (inl : \u03b1 \u2192 Sum \u03b1 \u03b2))", "start": [921, 1], "end": [923, 25], "kind": "commanddeclaration"}, {"full_name": "isClosed_range_inr", "code": "theorem isClosed_range_inr : IsClosed (range (inr : \u03b2 \u2192 Sum \u03b1 \u03b2))", "start": [926, 1], "end": [928, 25], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_inl", "code": "theorem closedEmbedding_inl : ClosedEmbedding (inl : \u03b1 \u2192 Sum \u03b1 \u03b2)", "start": [931, 1], "end": [932, 38], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_inr", "code": "theorem closedEmbedding_inr : ClosedEmbedding (inr : \u03b2 \u2192 Sum \u03b1 \u03b2)", "start": [935, 1], "end": [936, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_inl", "code": "theorem nhds_inl (x : \u03b1) : \ud835\udcdd (inl x : Sum \u03b1 \u03b2) = map inl (\ud835\udcdd x)", "start": [939, 1], "end": [940, 41], "kind": "commanddeclaration"}, {"full_name": "nhds_inr", "code": "theorem nhds_inr (x : \u03b2) : \ud835\udcdd (inr x : Sum \u03b1 \u03b2) = map inr (\ud835\udcdd x)", "start": [943, 1], "end": [944, 41], "kind": "commanddeclaration"}, {"full_name": "continuous_sum_map", "code": "@[simp]\ntheorem continuous_sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} :\n    Continuous (Sum.map f g) \u2194 Continuous f \u2227 Continuous g", "start": [947, 1], "end": [951, 76], "kind": "commanddeclaration"}, {"full_name": "Continuous.sum_map", "code": "@[continuity]\ntheorem Continuous.sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (Sum.map f g)", "start": [954, 1], "end": [957, 32], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_sum", "code": "theorem isOpenMap_sum {f : Sum \u03b1 \u03b2 \u2192 \u03b3} :\n    IsOpenMap f \u2194 (IsOpenMap fun a => f (inl a)) \u2227 IsOpenMap fun b => f (inr b)", "start": [960, 1], "end": [962, 90], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_sum_elim", "code": "@[simp]\ntheorem isOpenMap_sum_elim {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} :\n    IsOpenMap (Sum.elim f g) \u2194 IsOpenMap f \u2227 IsOpenMap g", "start": [965, 1], "end": [968, 48], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.sum_elim", "code": "theorem IsOpenMap.sum_elim {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (hf : IsOpenMap f) (hg : IsOpenMap g) :\n    IsOpenMap (Sum.elim f g)", "start": [971, 1], "end": [973, 32], "kind": "commanddeclaration"}, {"full_name": "inducing_subtype_val", "code": "theorem inducing_subtype_val {b : Set \u03b2} : Inducing ((\u2191) : b \u2192 \u03b2)", "start": [982, 1], "end": [982, 75], "kind": "commanddeclaration"}, {"full_name": "Inducing.of_codRestrict", "code": "theorem Inducing.of_codRestrict {f : \u03b1 \u2192 \u03b2} {b : Set \u03b2} (hb : \u2200 a, f a \u2208 b)\n    (h : Inducing (b.codRestrict f hb)) : Inducing f", "start": [985, 1], "end": [987, 30], "kind": "commanddeclaration"}, {"full_name": "embedding_subtype_val", "code": "theorem embedding_subtype_val : Embedding ((\u2191) : Subtype p \u2192 \u03b1)", "start": [990, 1], "end": [991, 48], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_subtype_val", "code": "theorem closedEmbedding_subtype_val (h : IsClosed { a | p a }) :\n    ClosedEmbedding ((\u2191) : Subtype p \u2192 \u03b1)", "start": [994, 1], "end": [996, 62], "kind": "commanddeclaration"}, {"full_name": "continuous_subtype_val", "code": "@[continuity]\ntheorem continuous_subtype_val : Continuous (@Subtype.val \u03b1 p)", "start": [999, 1], "end": [1001, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.subtype_val", "code": "theorem Continuous.subtype_val {f : \u03b2 \u2192 Subtype p} (hf : Continuous f) :\n    Continuous fun x => (f x : \u03b1)", "start": [1005, 1], "end": [1007, 33], "kind": "commanddeclaration"}, {"full_name": "IsOpen.openEmbedding_subtype_val", "code": "theorem IsOpen.openEmbedding_subtype_val {s : Set \u03b1} (hs : IsOpen s) :\n    OpenEmbedding ((\u2191) : s \u2192 \u03b1)", "start": [1010, 1], "end": [1012, 62], "kind": "commanddeclaration"}, {"full_name": "IsOpen.isOpenMap_subtype_val", "code": "theorem IsOpen.isOpenMap_subtype_val {s : Set \u03b1} (hs : IsOpen s) : IsOpenMap ((\u2191) : s \u2192 \u03b1)", "start": [1015, 1], "end": [1016, 41], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.restrict", "code": "theorem IsOpenMap.restrict {f : \u03b1 \u2192 \u03b2} (hf : IsOpenMap f) {s : Set \u03b1} (hs : IsOpen s) :\n    IsOpenMap (s.restrict f)", "start": [1019, 1], "end": [1021, 35], "kind": "commanddeclaration"}, {"full_name": "IsClosedMap.restrictPreimage", "code": "lemma IsClosedMap.restrictPreimage {f : \u03b1 \u2192 \u03b2} (hcl : IsClosedMap f) (T : Set \u03b2) :\n    IsClosedMap (T.restrictPreimage f) := by\n  rw [isClosedMap_iff_clusterPt] at hcl \u22a2\n  intro A \u27e8y, hyT\u27e9 hy\n  rw [restrictPreimage, MapClusterPt, \u2190 inducing_subtype_val.mapClusterPt_iff, MapClusterPt,\n      map_map, MapsTo.restrict_commutes, \u2190 map_map, \u2190 MapClusterPt, map_principal] at hy\n  rcases hcl _ y hy with \u27e8x, hxy, hx\u27e9\n  have hxT : f x \u2208 T := hxy \u25b8 hyT\n  refine \u27e8\u27e8x, hxT\u27e9, Subtype.ext hxy, ?_\u27e9\n  rwa [\u2190 inducing_subtype_val.mapClusterPt_iff, MapClusterPt, map_principal]", "start": [1024, 1], "end": [1033, 77], "kind": "mathlibtacticlemma"}, {"full_name": "IsClosed.closedEmbedding_subtype_val", "code": "nonrec theorem IsClosed.closedEmbedding_subtype_val {s : Set \u03b1} (hs : IsClosed s) :\n    ClosedEmbedding ((\u2191) : s \u2192 \u03b1)", "start": [1035, 1], "end": [1037, 33], "kind": "commanddeclaration"}, {"full_name": "Continuous.subtype_mk", "code": "@[continuity]\ntheorem Continuous.subtype_mk {f : \u03b2 \u2192 \u03b1} (h : Continuous f) (hp : \u2200 x, p (f x)) :\n    Continuous fun x => (\u27e8f x, hp x\u27e9 : Subtype p)", "start": [1040, 1], "end": [1043, 29], "kind": "commanddeclaration"}, {"full_name": "Continuous.subtype_map", "code": "theorem Continuous.subtype_map {f : \u03b1 \u2192 \u03b2} (h : Continuous f) {q : \u03b2 \u2192 Prop}\n    (hpq : \u2200 x, p x \u2192 q (f x)) : Continuous (Subtype.map f hpq)", "start": [1046, 1], "end": [1048, 47], "kind": "commanddeclaration"}, {"full_name": "continuous_inclusion", "code": "theorem continuous_inclusion {s t : Set \u03b1} (h : s \u2286 t) : Continuous (inclusion h)", "start": [1051, 1], "end": [1052, 30], "kind": "commanddeclaration"}, {"full_name": "continuousAt_subtype_val", "code": "theorem continuousAt_subtype_val {p : \u03b1 \u2192 Prop} {a : Subtype p} :\n    ContinuousAt ((\u2191) : Subtype p \u2192 \u03b1) a", "start": [1055, 1], "end": [1057, 38], "kind": "commanddeclaration"}, {"full_name": "Subtype.dense_iff", "code": "theorem Subtype.dense_iff {s : Set \u03b1} {t : Set s} : Dense t \u2194 s \u2286 closure ((\u2191) '' t)", "start": [1060, 1], "end": [1062, 6], "kind": "commanddeclaration"}, {"full_name": "map_nhds_subtype_val", "code": "theorem map_nhds_subtype_val {s : Set \u03b1} (a : s) : map ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd a) = \ud835\udcdd[s] \u2191a", "start": [1066, 1], "end": [1067, 59], "kind": "commanddeclaration"}, {"full_name": "map_nhds_subtype_coe_eq_nhds", "code": "theorem map_nhds_subtype_coe_eq_nhds {a : \u03b1} (ha : p a) (h : \u2200\u1da0 x in \ud835\udcdd a, p x) :\n    map ((\u2191) : Subtype p \u2192 \u03b1) (\ud835\udcdd \u27e8a, ha\u27e9) = \ud835\udcdd a", "start": [1069, 1], "end": [1071, 64], "kind": "commanddeclaration"}, {"full_name": "nhds_subtype_eq_comap", "code": "theorem nhds_subtype_eq_comap {a : \u03b1} {h : p a} : \ud835\udcdd (\u27e8a, h\u27e9 : Subtype p) = comap (\u2191) (\ud835\udcdd a)", "start": [1074, 1], "end": [1075, 19], "kind": "commanddeclaration"}, {"full_name": "tendsto_subtype_rng", "code": "theorem tendsto_subtype_rng {\u03b2 : Type*} {p : \u03b1 \u2192 Prop} {b : Filter \u03b2} {f : \u03b2 \u2192 Subtype p} :\n    \u2200 {a : Subtype p}, Tendsto f b (\ud835\udcdd a) \u2194 Tendsto (fun x => (f x : \u03b1)) b (\ud835\udcdd (a : \u03b1))", "start": [1078, 1], "end": [1080, 69], "kind": "commanddeclaration"}, {"full_name": "closure_subtype", "code": "theorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :\n    x \u2208 closure s \u2194 (x : \u03b1) \u2208 closure (((\u2191) : _ \u2192 \u03b1) '' s)", "start": [1083, 1], "end": [1085, 18], "kind": "commanddeclaration"}, {"full_name": "continuousAt_codRestrict_iff", "code": "@[simp]\ntheorem continuousAt_codRestrict_iff {f : \u03b1 \u2192 \u03b2} {t : Set \u03b2} (h1 : \u2200 x, f x \u2208 t) {x : \u03b1} :\n    ContinuousAt (codRestrict f t h1) x \u2194 ContinuousAt f x", "start": [1088, 1], "end": [1091, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.codRestrict", "code": "alias \u27e8_, ContinuousAt.codRestrict\u27e9 := continuousAt_codRestrict_iff", "start": [1094, 1], "end": [1094, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ContinuousAt.restrict", "code": "theorem ContinuousAt.restrict {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (h1 : MapsTo f s t) {x : s}\n    (h2 : ContinuousAt f x) : ContinuousAt (h1.restrict f s t) x", "start": [1097, 1], "end": [1099, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.restrictPreimage", "code": "theorem ContinuousAt.restrictPreimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {x : f \u207b\u00b9' s} (h : ContinuousAt f x) :\n    ContinuousAt (s.restrictPreimage f) x", "start": [1102, 1], "end": [1104, 15], "kind": "commanddeclaration"}, {"full_name": "Continuous.codRestrict", "code": "@[continuity]\ntheorem Continuous.codRestrict {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hf : Continuous f) (hs : \u2200 a, f a \u2208 s) :\n    Continuous (s.codRestrict f hs)", "start": [1107, 1], "end": [1110, 19], "kind": "commanddeclaration"}, {"full_name": "Continuous.restrict", "code": "@[continuity]\ntheorem Continuous.restrict {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (h1 : MapsTo f s t)\n    (h2 : Continuous f) : Continuous (h1.restrict f s t)", "start": [1113, 1], "end": [1116, 49], "kind": "commanddeclaration"}, {"full_name": "Continuous.restrictPreimage", "code": "@[continuity]\ntheorem Continuous.restrictPreimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (h : Continuous f) :\n    Continuous (s.restrictPreimage f)", "start": [1118, 1], "end": [1121, 15], "kind": "commanddeclaration"}, {"full_name": "Inducing.codRestrict", "code": "theorem Inducing.codRestrict {e : \u03b1 \u2192 \u03b2} (he : Inducing e) {s : Set \u03b2} (hs : \u2200 x, e x \u2208 s) :\n    Inducing (codRestrict e s hs)", "start": [1123, 1], "end": [1125, 88], "kind": "commanddeclaration"}, {"full_name": "Embedding.codRestrict", "code": "theorem Embedding.codRestrict {e : \u03b1 \u2192 \u03b2} (he : Embedding e) (s : Set \u03b2) (hs : \u2200 x, e x \u2208 s) :\n    Embedding (codRestrict e s hs)", "start": [1128, 1], "end": [1130, 90], "kind": "commanddeclaration"}, {"full_name": "embedding_inclusion", "code": "theorem embedding_inclusion {s t : Set \u03b1} (h : s \u2286 t) : Embedding (Set.inclusion h)", "start": [1133, 1], "end": [1134, 40], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.of_subset", "code": "theorem DiscreteTopology.of_subset {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (_ : DiscreteTopology s) (ts : t \u2286 s) : DiscreteTopology t", "start": [1137, 1], "end": [1141, 44], "kind": "commanddeclaration"}, {"full_name": "quotientMap_quot_mk", "code": "theorem quotientMap_quot_mk : QuotientMap (@Quot.mk \u03b1 r)", "start": [1152, 1], "end": [1153, 25], "kind": "commanddeclaration"}, {"full_name": "continuous_quot_mk", "code": "@[continuity]\ntheorem continuous_quot_mk : Continuous (@Quot.mk \u03b1 r)", "start": [1156, 1], "end": [1158, 27], "kind": "commanddeclaration"}, {"full_name": "continuous_quot_lift", "code": "@[continuity]\ntheorem continuous_quot_lift {f : \u03b1 \u2192 \u03b2} (hr : \u2200 a b, r a b \u2192 f a = f b) (h : Continuous f) :\n    Continuous (Quot.lift f hr : Quot r \u2192 \u03b2)", "start": [1161, 1], "end": [1164, 31], "kind": "commanddeclaration"}, {"full_name": "quotientMap_quotient_mk'", "code": "theorem quotientMap_quotient_mk' : QuotientMap (@Quotient.mk' \u03b1 s)", "start": [1167, 1], "end": [1168, 22], "kind": "commanddeclaration"}, {"full_name": "continuous_quotient_mk'", "code": "theorem continuous_quotient_mk' : Continuous (@Quotient.mk' \u03b1 s)", "start": [1171, 1], "end": [1172, 27], "kind": "commanddeclaration"}, {"full_name": "Continuous.quotient_lift", "code": "theorem Continuous.quotient_lift {f : \u03b1 \u2192 \u03b2} (h : Continuous f) (hs : \u2200 a b, a \u2248 b \u2192 f a = f b) :\n    Continuous (Quotient.lift f hs : Quotient s \u2192 \u03b2)", "start": [1175, 1], "end": [1177, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.quotient_liftOn'", "code": "theorem Continuous.quotient_liftOn' {f : \u03b1 \u2192 \u03b2} (h : Continuous f)\n    (hs : \u2200 a b, @Setoid.r _ s a b \u2192 f a = f b) :\n    Continuous (fun x => Quotient.liftOn' x f hs : Quotient s \u2192 \u03b2)", "start": [1180, 1], "end": [1183, 21], "kind": "commanddeclaration"}, {"full_name": "Continuous.quotient_map'", "code": "@[continuity] theorem Continuous.quotient_map' {t : Setoid \u03b2} {f : \u03b1 \u2192 \u03b2} (hf : Continuous f)\n    (H : (s.r \u21d2 t.r) f f) : Continuous (Quotient.map' f H)", "start": [1186, 1], "end": [1188, 52], "kind": "commanddeclaration"}, {"full_name": "continuous_pi_iff", "code": "theorem continuous_pi_iff : Continuous f \u2194 \u2200 i, Continuous fun a => f a i", "start": [1198, 1], "end": [1199, 64], "kind": "commanddeclaration"}, {"full_name": "continuous_pi", "code": "@[continuity]\ntheorem continuous_pi (h : \u2200 i, Continuous fun a => f a i) : Continuous f", "start": [1202, 1], "end": [1204, 24], "kind": "commanddeclaration"}, {"full_name": "continuous_apply", "code": "@[continuity]\ntheorem continuous_apply (i : \u03b9) : Continuous fun p : \u2200 i, \u03c0 i => p i", "start": [1207, 1], "end": [1209, 45], "kind": "commanddeclaration"}, {"full_name": "continuous_apply_apply", "code": "@[continuity]\ntheorem continuous_apply_apply {\u03c1 : \u03ba \u2192 \u03b9 \u2192 Type*} [\u2200 j i, TopologicalSpace (\u03c1 j i)] (j : \u03ba)\n    (i : \u03b9) : Continuous fun p : \u2200 j, \u2200 i, \u03c1 j i => p j i", "start": [1212, 1], "end": [1215, 49], "kind": "commanddeclaration"}, {"full_name": "continuousAt_apply", "code": "theorem continuousAt_apply (i : \u03b9) (x : \u2200 i, \u03c0 i) : ContinuousAt (fun p : \u2200 i, \u03c0 i => p i) x", "start": [1218, 1], "end": [1219, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.apply", "code": "theorem Filter.Tendsto.apply {l : Filter \u03b2} {f : \u03b2 \u2192 \u2200 i, \u03c0 i} {x : \u2200 i, \u03c0 i}\n    (h : Tendsto f l (\ud835\udcdd x)) (i : \u03b9) : Tendsto (fun a => f a i) l (\ud835\udcdd <| x i)", "start": [1222, 1], "end": [1224, 42], "kind": "commanddeclaration"}, {"full_name": "nhds_pi", "code": "theorem nhds_pi {a : \u2200 i, \u03c0 i} : \ud835\udcdd a = pi fun i => \ud835\udcdd (a i)", "start": [1227, 1], "end": [1228, 49], "kind": "commanddeclaration"}, {"full_name": "tendsto_pi_nhds", "code": "theorem tendsto_pi_nhds {f : \u03b2 \u2192 \u2200 i, \u03c0 i} {g : \u2200 i, \u03c0 i} {u : Filter \u03b2} :\n    Tendsto f u (\ud835\udcdd g) \u2194 \u2200 x, Tendsto (fun i => f i x) u (\ud835\udcdd (g x))", "start": [1231, 1], "end": [1233, 34], "kind": "commanddeclaration"}, {"full_name": "continuousAt_pi", "code": "theorem continuousAt_pi {f : \u03b1 \u2192 \u2200 i, \u03c0 i} {x : \u03b1} :\n    ContinuousAt f x \u2194 \u2200 i, ContinuousAt (fun y => f y i) x", "start": [1236, 1], "end": [1238, 18], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_precomp'", "code": "theorem Pi.continuous_precomp' {\u03b9' : Type*} (\u03c6 : \u03b9' \u2192 \u03b9) :\n    Continuous (fun (f : (\u2200 i, \u03c0 i)) (j : \u03b9') \u21a6 f (\u03c6 j))", "start": [1241, 1], "end": [1243, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_precomp", "code": "theorem Pi.continuous_precomp {\u03b9' : Type*} (\u03c6 : \u03b9' \u2192 \u03b9) :\n    Continuous (\u00b7 \u2218 \u03c6 : (\u03b9 \u2192 \u03b1) \u2192 (\u03b9' \u2192 \u03b1))", "start": [1245, 1], "end": [1247, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_postcomp'", "code": "theorem Pi.continuous_postcomp' {\u03c1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c1 i)]\n    {g : \u2200 i, \u03c0 i \u2192 \u03c1 i} (hg : \u2200 i, Continuous (g i)) :\n    Continuous (fun (f : (\u2200 i, \u03c0 i)) (i : \u03b9) \u21a6 g i (f i))", "start": [1249, 1], "end": [1252, 58], "kind": "commanddeclaration"}, {"full_name": "Pi.continuous_postcomp", "code": "theorem Pi.continuous_postcomp [TopologicalSpace \u03b2] {g : \u03b1 \u2192 \u03b2} (hg : Continuous g) :\n    Continuous (g \u2218 \u00b7 : (\u03b9 \u2192 \u03b1) \u2192 (\u03b9 \u2192 \u03b2))", "start": [1254, 1], "end": [1256, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.induced_precomp'", "code": "lemma Pi.induced_precomp' {\u03b9' : Type*} (\u03c6 : \u03b9' \u2192 \u03b9) :\n    induced (fun (f : (\u2200 i, \u03c0 i)) (j : \u03b9') \u21a6 f (\u03c6 j)) Pi.topologicalSpace =\n    \u2a05 i', induced (eval (\u03c6 i')) (T (\u03c6 i')) := by\n  simp [Pi.topologicalSpace, induced_iInf, induced_compose, comp]", "start": [1258, 1], "end": [1261, 66], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.induced_precomp", "code": "lemma Pi.induced_precomp [TopologicalSpace \u03b2] {\u03b9' : Type*} (\u03c6 : \u03b9' \u2192 \u03b9) :\n    induced (\u00b7 \u2218 \u03c6) Pi.topologicalSpace =\n    \u2a05 i', induced (eval (\u03c6 i')) \u2039TopologicalSpace \u03b2\u203a :=\n  induced_precomp' \u03c6", "start": [1263, 1], "end": [1266, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.continuous_restrict", "code": "lemma Pi.continuous_restrict (S : Set \u03b9) :\n    Continuous (S.restrict : (\u2200 i : \u03b9, \u03c0 i) \u2192 (\u2200 i : S, \u03c0 i)) :=\n  Pi.continuous_precomp' ((\u2191) : S \u2192 \u03b9)", "start": [1268, 1], "end": [1270, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.induced_restrict", "code": "lemma Pi.induced_restrict (S : Set \u03b9) :\n    induced (S.restrict) Pi.topologicalSpace =\n    \u2a05 i \u2208 S, induced (eval i) (T i) := by\n  simp [\u2190 iInf_subtype'', \u2190 induced_precomp' ((\u2191) : S \u2192 \u03b9), Set.restrict]", "start": [1272, 1], "end": [1275, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.Tendsto.update", "code": "theorem Filter.Tendsto.update [DecidableEq \u03b9] {l : Filter \u03b2} {f : \u03b2 \u2192 \u2200 i, \u03c0 i} {x : \u2200 i, \u03c0 i}\n    (hf : Tendsto f l (\ud835\udcdd x)) (i : \u03b9) {g : \u03b2 \u2192 \u03c0 i} {xi : \u03c0 i} (hg : Tendsto g l (\ud835\udcdd xi)) :\n    Tendsto (fun a => update (f a) i (g a)) l (\ud835\udcdd <| update x i xi)", "start": [1277, 1], "end": [1280, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.update", "code": "theorem ContinuousAt.update [DecidableEq \u03b9] {a : \u03b1} (hf : ContinuousAt f a) (i : \u03b9) {g : \u03b1 \u2192 \u03c0 i}\n    (hg : ContinuousAt g a) : ContinuousAt (fun a => update (f a) i (g a)) a", "start": [1283, 1], "end": [1285, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.update", "code": "theorem Continuous.update [DecidableEq \u03b9] (hf : Continuous f) (i : \u03b9) {g : \u03b1 \u2192 \u03c0 i}\n    (hg : Continuous g) : Continuous fun a => update (f a) i (g a)", "start": [1288, 1], "end": [1290, 82], "kind": "commanddeclaration"}, {"full_name": "continuous_update", "code": "@[continuity]\ntheorem continuous_update [DecidableEq \u03b9] (i : \u03b9) :\n    Continuous fun f : (\u2200 j, \u03c0 j) \u00d7 \u03c0 i => update f.1 i f.2", "start": [1293, 1], "end": [1297, 41], "kind": "commanddeclaration"}, {"full_name": "continuous_mulSingle", "code": "@[to_additive \"`Pi.single i x` is continuous in `x`.\"]\ntheorem continuous_mulSingle [\u2200 i, One (\u03c0 i)] [DecidableEq \u03b9] (i : \u03b9) :\n    Continuous fun x => (Pi.mulSingle i x : \u2200 i, \u03c0 i)", "start": [1300, 1], "end": [1305, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.fin_insertNth", "code": "theorem Filter.Tendsto.fin_insertNth {n} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    (i : Fin (n + 1)) {f : \u03b2 \u2192 \u03c0 i} {l : Filter \u03b2} {x : \u03c0 i} (hf : Tendsto f l (\ud835\udcdd x))\n    {g : \u03b2 \u2192 \u2200 j : Fin n, \u03c0 (i.succAbove j)} {y : \u2200 j, \u03c0 (i.succAbove j)} (hg : Tendsto g l (\ud835\udcdd y)) :\n    Tendsto (fun a => i.insertNth (f a) (g a)) l (\ud835\udcdd <| i.insertNth x y)", "start": [1309, 1], "end": [1313, 101], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.fin_insertNth", "code": "theorem ContinuousAt.fin_insertNth {n} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    (i : Fin (n + 1)) {f : \u03b1 \u2192 \u03c0 i} {a : \u03b1} (hf : ContinuousAt f a)\n    {g : \u03b1 \u2192 \u2200 j : Fin n, \u03c0 (i.succAbove j)} (hg : ContinuousAt g a) :\n    ContinuousAt (fun a => i.insertNth (f a) (g a)) a", "start": [1316, 1], "end": [1320, 32], "kind": "commanddeclaration"}, {"full_name": "Continuous.fin_insertNth", "code": "theorem Continuous.fin_insertNth {n} {\u03c0 : Fin (n + 1) \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    (i : Fin (n + 1)) {f : \u03b1 \u2192 \u03c0 i} (hf : Continuous f) {g : \u03b1 \u2192 \u2200 j : Fin n, \u03c0 (i.succAbove j)}\n    (hg : Continuous g) : Continuous fun a => i.insertNth (f a) (g a)", "start": [1323, 1], "end": [1326, 89], "kind": "commanddeclaration"}, {"full_name": "isOpen_set_pi", "code": "theorem isOpen_set_pi {i : Set \u03b9} {s : \u2200 a, Set (\u03c0 a)} (hi : i.Finite)\n    (hs : \u2200 a \u2208 i, IsOpen (s a)) : IsOpen (pi i s)", "start": [1329, 1], "end": [1331, 91], "kind": "commanddeclaration"}, {"full_name": "isOpen_pi_iff", "code": "theorem isOpen_pi_iff {s : Set (\u2200 a, \u03c0 a)} :\n    IsOpen s \u2194\n      \u2200 f, f \u2208 s \u2192 \u2203 (I : Finset \u03b9) (u : \u2200 a, Set (\u03c0 a)),\n        (\u2200 a, a \u2208 I \u2192 IsOpen (u a) \u2227 f a \u2208 u a) \u2227 (I : Set \u03b9).pi u \u2286 s", "start": [1334, 1], "end": [1358, 81], "kind": "commanddeclaration"}, {"full_name": "isOpen_pi_iff'", "code": "theorem isOpen_pi_iff' [Finite \u03b9] {s : Set (\u2200 a, \u03c0 a)} :\n    IsOpen s \u2194\n      \u2200 f, f \u2208 s \u2192 \u2203 u : \u2200 a, Set (\u03c0 a), (\u2200 a, IsOpen (u a) \u2227 f a \u2208 u a) \u2227 Set.univ.pi u \u2286 s", "start": [1361, 1], "end": [1376, 87], "kind": "commanddeclaration"}, {"full_name": "isClosed_set_pi", "code": "theorem isClosed_set_pi {i : Set \u03b9} {s : \u2200 a, Set (\u03c0 a)} (hs : \u2200 a \u2208 i, IsClosed (s a)) :\n    IsClosed (pi i s)", "start": [1379, 1], "end": [1381, 90], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_of_pi_mem_nhds", "code": "theorem mem_nhds_of_pi_mem_nhds {I : Set \u03b9} {s : \u2200 i, Set (\u03c0 i)} (a : \u2200 i, \u03c0 i) (hs : I.pi s \u2208 \ud835\udcdd a)\n    {i : \u03b9} (hi : i \u2208 I) : s i \u2208 \ud835\udcdd (a i)", "start": [1384, 1], "end": [1386, 51], "kind": "commanddeclaration"}, {"full_name": "set_pi_mem_nhds", "code": "theorem set_pi_mem_nhds {i : Set \u03b9} {s : \u2200 a, Set (\u03c0 a)} {x : \u2200 a, \u03c0 a} (hi : i.Finite)\n    (hs : \u2200 a \u2208 i, s a \u2208 \ud835\udcdd (x a)) : pi i s \u2208 \ud835\udcdd x", "start": [1389, 1], "end": [1392, 64], "kind": "commanddeclaration"}, {"full_name": "set_pi_mem_nhds_iff", "code": "theorem set_pi_mem_nhds_iff {I : Set \u03b9} (hI : I.Finite) {s : \u2200 i, Set (\u03c0 i)} (a : \u2200 i, \u03c0 i) :\n    I.pi s \u2208 \ud835\udcdd a \u2194 \u2200 i : \u03b9, i \u2208 I \u2192 s i \u2208 \ud835\udcdd (a i)", "start": [1395, 1], "end": [1397, 33], "kind": "commanddeclaration"}, {"full_name": "interior_pi_set", "code": "theorem interior_pi_set {I : Set \u03b9} (hI : I.Finite) {s : \u2200 i, Set (\u03c0 i)} :\n    interior (pi I s) = I.pi fun i => interior (s i)", "start": [1400, 1], "end": [1403, 76], "kind": "commanddeclaration"}, {"full_name": "exists_finset_piecewise_mem_of_mem_nhds", "code": "theorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq \u03b9] {s : Set (\u2200 a, \u03c0 a)} {x : \u2200 a, \u03c0 a}\n    (hs : s \u2208 \ud835\udcdd x) (y : \u2200 a, \u03c0 a) : \u2203 I : Finset \u03b9, I.piecewise x y \u2208 s", "start": [1406, 1], "end": [1411, 60], "kind": "commanddeclaration"}, {"full_name": "pi_generateFrom_eq", "code": "theorem pi_generateFrom_eq {\u03c0 : \u03b9 \u2192 Type*} {g : \u2200 a, Set (Set (\u03c0 a))} :\n    (@Pi.topologicalSpace \u03b9 \u03c0 fun a => generateFrom (g a)) =\n      generateFrom\n        { t | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9), (\u2200 a \u2208 i, s a \u2208 g a) \u2227 t = pi (\u2191i) s }", "start": [1414, 1], "end": [1425, 14], "kind": "commanddeclaration"}, {"full_name": "pi_eq_generateFrom", "code": "theorem pi_eq_generateFrom :\n    Pi.topologicalSpace =\n      generateFrom\n        { g | \u2203 (s : \u2200 a, Set (\u03c0 a)) (i : Finset \u03b9), (\u2200 a \u2208 i, IsOpen (s a)) \u2227 g = pi (\u2191i) s }", "start": [1428, 1], "end": [1435, 30], "kind": "commanddeclaration"}, {"full_name": "pi_generateFrom_eq_finite", "code": "theorem pi_generateFrom_eq_finite {\u03c0 : \u03b9 \u2192 Type*} {g : \u2200 a, Set (Set (\u03c0 a))} [Finite \u03b9]\n    (hg : \u2200 a, \u22c3\u2080 g a = univ) :\n    (@Pi.topologicalSpace \u03b9 \u03c0 fun a => generateFrom (g a)) =\n      generateFrom { t | \u2203 s : \u2200 a, Set (\u03c0 a), (\u2200 a, s a \u2208 g a) \u2227 t = pi univ s }", "start": [1438, 1], "end": [1453, 32], "kind": "commanddeclaration"}, {"full_name": "induced_to_pi", "code": "theorem induced_to_pi {X : Type*} (f : X \u2192 \u2200 i, \u03c0 i) :\n    induced f Pi.topologicalSpace = \u2a05 i, induced (f \u00b7 i) inferInstance", "start": [1457, 1], "end": [1461, 6], "kind": "commanddeclaration"}, {"full_name": "inducing_iInf_to_pi", "code": "theorem inducing_iInf_to_pi {X : Type*} (f : \u2200 i, X \u2192 \u03c0 i) :\n    @Inducing X (\u2200 i, \u03c0 i) (\u2a05 i, induced (f i) inferInstance) _ fun x i => f i x", "start": [1463, 1], "end": [1470, 69], "kind": "commanddeclaration"}, {"full_name": "Pi.discreteTopology", "code": "instance Pi.discreteTopology : DiscreteTopology (\u2200 i, \u03c0 i) :=\n  singletons_open_iff_discrete.mp fun x => by\n    rw [\u2190 univ_pi_singleton]\n    exact isOpen_set_pi finite_univ fun i _ => (isOpen_discrete {x i})", "start": [1475, 1], "end": [1479, 71], "kind": "commanddeclaration"}, {"full_name": "continuous_sigmaMk", "code": "@[continuity]\ntheorem continuous_sigmaMk {i : \u03b9} : Continuous (@Sigma.mk \u03b9 \u03c3 i)", "start": [1489, 1], "end": [1491, 47], "kind": "commanddeclaration"}, {"full_name": "isOpen_sigma_iff", "code": "theorem isOpen_sigma_iff {s : Set (Sigma \u03c3)} : IsOpen s \u2194 \u2200 i, IsOpen (Sigma.mk i \u207b\u00b9' s)", "start": [1495, 1], "end": [1498, 6], "kind": "commanddeclaration"}, {"full_name": "isClosed_sigma_iff", "code": "theorem isClosed_sigma_iff {s : Set (Sigma \u03c3)} : IsClosed s \u2194 \u2200 i, IsClosed (Sigma.mk i \u207b\u00b9' s)", "start": [1501, 1], "end": [1502, 67], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_sigmaMk", "code": "theorem isOpenMap_sigmaMk {i : \u03b9} : IsOpenMap (@Sigma.mk \u03b9 \u03c3 i)", "start": [1505, 1], "end": [1512, 23], "kind": "commanddeclaration"}, {"full_name": "isOpen_range_sigmaMk", "code": "theorem isOpen_range_sigmaMk {i : \u03b9} : IsOpen (Set.range (@Sigma.mk \u03b9 \u03c3 i))", "start": [1515, 1], "end": [1516, 33], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_sigmaMk", "code": "theorem isClosedMap_sigmaMk {i : \u03b9} : IsClosedMap (@Sigma.mk \u03b9 \u03c3 i)", "start": [1519, 1], "end": [1526, 25], "kind": "commanddeclaration"}, {"full_name": "isClosed_range_sigmaMk", "code": "theorem isClosed_range_sigmaMk {i : \u03b9} : IsClosed (Set.range (@Sigma.mk \u03b9 \u03c3 i))", "start": [1529, 1], "end": [1530, 35], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_sigmaMk", "code": "theorem openEmbedding_sigmaMk {i : \u03b9} : OpenEmbedding (@Sigma.mk \u03b9 \u03c3 i)", "start": [1533, 1], "end": [1535, 22], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_sigmaMk", "code": "theorem closedEmbedding_sigmaMk {i : \u03b9} : ClosedEmbedding (@Sigma.mk \u03b9 \u03c3 i)", "start": [1538, 1], "end": [1540, 24], "kind": "commanddeclaration"}, {"full_name": "embedding_sigmaMk", "code": "theorem embedding_sigmaMk {i : \u03b9} : Embedding (@Sigma.mk \u03b9 \u03c3 i)", "start": [1543, 1], "end": [1544, 28], "kind": "commanddeclaration"}, {"full_name": "Sigma.nhds_mk", "code": "theorem Sigma.nhds_mk (i : \u03b9) (x : \u03c3 i) : \ud835\udcdd (\u27e8i, x\u27e9 : Sigma \u03c3) = Filter.map (Sigma.mk i) (\ud835\udcdd x)", "start": [1547, 1], "end": [1548, 45], "kind": "commanddeclaration"}, {"full_name": "Sigma.nhds_eq", "code": "theorem Sigma.nhds_eq (x : Sigma \u03c3) : \ud835\udcdd x = Filter.map (Sigma.mk x.1) (\ud835\udcdd x.2)", "start": [1551, 1], "end": [1553, 22], "kind": "commanddeclaration"}, {"full_name": "comap_sigmaMk_nhds", "code": "theorem comap_sigmaMk_nhds (i : \u03b9) (x : \u03c3 i) : comap (Sigma.mk i) (\ud835\udcdd \u27e8i, x\u27e9) = \ud835\udcdd x", "start": [1556, 1], "end": [1557, 43], "kind": "commanddeclaration"}, {"full_name": "isOpen_sigma_fst_preimage", "code": "theorem isOpen_sigma_fst_preimage (s : Set \u03b9) : IsOpen (Sigma.fst \u207b\u00b9' s : Set (\u03a3 a, \u03c3 a))", "start": [1560, 1], "end": [1563, 55], "kind": "commanddeclaration"}, {"full_name": "continuous_sigma_iff", "code": "@[simp]\ntheorem continuous_sigma_iff {f : Sigma \u03c3 \u2192 \u03b1} :\n    Continuous f \u2194 \u2200 i, Continuous fun a => f \u27e8i, a\u27e9", "start": [1566, 1], "end": [1572, 56], "kind": "commanddeclaration"}, {"full_name": "continuous_sigma", "code": "@[continuity]\ntheorem continuous_sigma {f : Sigma \u03c3 \u2192 \u03b1} (hf : \u2200 i, Continuous fun a => f \u27e8i, a\u27e9) :\n    Continuous f", "start": [1575, 1], "end": [1579, 28], "kind": "commanddeclaration"}, {"full_name": "inducing_sigma", "code": "theorem inducing_sigma {f : Sigma \u03c3 \u2192 \u03b1} :\n    Inducing f \u2194 (\u2200 i, Inducing (f \u2218 Sigma.mk i)) \u2227\n      (\u2200 i, \u2203 U, IsOpen U \u2227 \u2200 x, f x \u2208 U \u2194 x.1 = i)", "start": [1582, 1], "end": [1596, 24], "kind": "commanddeclaration"}, {"full_name": "continuous_sigma_map", "code": "@[simp 1100]\ntheorem continuous_sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} :\n    Continuous (Sigma.map f\u2081 f\u2082) \u2194 \u2200 i, Continuous (f\u2082 i)", "start": [1598, 1], "end": [1601, 97], "kind": "commanddeclaration"}, {"full_name": "Continuous.sigma_map", "code": "@[continuity]\ntheorem Continuous.sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} (hf : \u2200 i, Continuous (f\u2082 i)) :\n    Continuous (Sigma.map f\u2081 f\u2082)", "start": [1604, 1], "end": [1607, 28], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_sigma", "code": "theorem isOpenMap_sigma {f : Sigma \u03c3 \u2192 \u03b1} : IsOpenMap f \u2194 \u2200 i, IsOpenMap fun a => f \u27e8i, a\u27e9", "start": [1610, 1], "end": [1611, 80], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_sigma_map", "code": "theorem isOpenMap_sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} :\n    IsOpenMap (Sigma.map f\u2081 f\u2082) \u2194 \u2200 i, IsOpenMap (f\u2082 i)", "start": [1614, 1], "end": [1617, 84], "kind": "commanddeclaration"}, {"full_name": "inducing_sigma_map", "code": "theorem inducing_sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} (h\u2081 : Injective f\u2081) :\n    Inducing (Sigma.map f\u2081 f\u2082) \u2194 \u2200 i, Inducing (f\u2082 i)", "start": [1620, 1], "end": [1623, 32], "kind": "commanddeclaration"}, {"full_name": "embedding_sigma_map", "code": "theorem embedding_sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} (h : Injective f\u2081) :\n    Embedding (Sigma.map f\u2081 f\u2082) \u2194 \u2200 i, Embedding (f\u2082 i)", "start": [1626, 1], "end": [1628, 100], "kind": "commanddeclaration"}, {"full_name": "openEmbedding_sigma_map", "code": "theorem openEmbedding_sigma_map {f\u2081 : \u03b9 \u2192 \u03ba} {f\u2082 : \u2200 i, \u03c3 i \u2192 \u03c4 (f\u2081 i)} (h : Injective f\u2081) :\n    OpenEmbedding (Sigma.map f\u2081 f\u2082) \u2194 \u2200 i, OpenEmbedding (f\u2082 i)", "start": [1631, 1], "end": [1634, 16], "kind": "commanddeclaration"}, {"full_name": "continuous_uLift_down", "code": "@[continuity]\ntheorem continuous_uLift_down [TopologicalSpace \u03b1] : Continuous (ULift.down : ULift.{v, u} \u03b1 \u2192 \u03b1)", "start": [1641, 1], "end": [1643, 25], "kind": "commanddeclaration"}, {"full_name": "continuous_uLift_up", "code": "@[continuity]\ntheorem continuous_uLift_up [TopologicalSpace \u03b1] : Continuous (ULift.up : \u03b1 \u2192 ULift.{v, u} \u03b1)", "start": [1646, 1], "end": [1648, 41], "kind": "commanddeclaration"}, {"full_name": "embedding_uLift_down", "code": "theorem embedding_uLift_down [TopologicalSpace \u03b1] : Embedding (ULift.down : ULift.{v, u} \u03b1 \u2192 \u03b1)", "start": [1651, 1], "end": [1652, 32], "kind": "commanddeclaration"}, {"full_name": "ULift.closedEmbedding_down", "code": "theorem ULift.closedEmbedding_down [TopologicalSpace \u03b1] :\n    ClosedEmbedding (ULift.down : ULift.{v, u} \u03b1 \u2192 \u03b1)", "start": [1655, 1], "end": [1657, 87], "kind": "commanddeclaration"}, {"full_name": "IsOpen.trans", "code": "theorem IsOpen.trans (h\u03b3 : IsOpen \u03b3) (h\u03b2 : IsOpen \u03b2) : IsOpen (\u03b3 : Set \u03b1)", "start": [1669, 1], "end": [1673, 90], "kind": "commanddeclaration"}, {"full_name": "IsClosed.trans", "code": "theorem IsClosed.trans (h\u03b3 : IsClosed \u03b3) (h\u03b2 : IsClosed \u03b2) : IsClosed (\u03b3 : Set \u03b1)", "start": [1675, 1], "end": [1679, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupRingAction/Subobjects.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Algebra/GroupRingAction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submonoid.mulSemiringAction", "code": "instance Submonoid.mulSemiringAction [MulSemiringAction M R] (H : Submonoid M) :\n    MulSemiringAction H R :=\n  { inferInstanceAs (DistribMulAction H R), inferInstanceAs (MulDistribMulAction H R) with }", "start": [27, 1], "end": [30, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mulSemiringAction", "code": "instance Subgroup.mulSemiringAction [MulSemiringAction G R] (H : Subgroup G) :\n    MulSemiringAction H R :=\n  H.toSubmonoid.mulSemiringAction", "start": [33, 1], "end": [36, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Ring/InjSurj.lean", "imports": ["Mathlib/Algebra/Ring/InjSurj.lean", "Mathlib/Algebra/Order/Monoid/Cancel/Basic.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.orderedSemiring", "code": "@[reducible]\nprotected def orderedSemiring [OrderedSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115]\n    [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : OrderedSemiring \u03b2 :=\n  { hf.orderedAddCommMonoid f zero add nsmul,\n    hf.semiring f zero one add mul nsmul npow nat_cast with\n    zero_le_one := show f 0 \u2264 f 1 by simp only [zero, one, zero_le_one],\n    mul_le_mul_of_nonneg_left := fun a b c h hc =>\n      show f (c * a) \u2264 f (c * b) by\n        rw [mul, mul]\n        refine' mul_le_mul_of_nonneg_left h _\n        rwa [\u2190 zero],\n    mul_le_mul_of_nonneg_right := fun a b c h hc =>\n      show f (a * c) \u2264 f (b * c) by\n        rw [mul, mul]\n        refine' mul_le_mul_of_nonneg_right h _\n        rwa [\u2190 zero] }", "start": [27, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.orderedCommSemiring", "code": "@[reducible]\nprotected def orderedCommSemiring [OrderedCommSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115]\n    [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : OrderedCommSemiring \u03b2 :=\n  { hf.commSemiring f zero one add mul nsmul npow nat_cast,\n    hf.orderedSemiring f zero one add mul nsmul npow nat_cast with }", "start": [50, 1], "end": [58, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.orderedRing", "code": "@[reducible]\nprotected def orderedRing [OrderedRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : OrderedRing \u03b2 :=\n  { hf.orderedSemiring f zero one add mul nsmul npow nat_cast,\n    hf.ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with\n    mul_nonneg := fun a b ha hb =>\n      show f 0 \u2264 f (a * b) by\n        rw [zero, mul]\n        apply mul_nonneg <;> rwa [\u2190 zero] }", "start": [62, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.orderedCommRing", "code": "@[reducible]\nprotected def orderedCommRing [OrderedCommRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : OrderedCommRing \u03b2 :=\n  { hf.orderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,\n    hf.commRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }", "start": [80, 1], "end": [90, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.strictOrderedSemiring", "code": "@[reducible]\nprotected def strictOrderedSemiring [StrictOrderedSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2]\n    [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : StrictOrderedSemiring \u03b2 :=\n  { hf.orderedCancelAddCommMonoid f zero add nsmul,\n    hf.orderedSemiring f zero one add mul nsmul npow nat_cast, pullback_nonzero f zero one with\n    mul_lt_mul_of_pos_left := fun a b c h hc =>\n      show f (c * a) < f (c * b) by\n        simpa only [mul, zero] using mul_lt_mul_of_pos_left \u2039f a < f b\u203a (by rwa [\u2190 zero]),\n    mul_lt_mul_of_pos_right := fun a b c h hc =>\n      show f (a * c) < f (b * c) by\n        simpa only [mul, zero] using mul_lt_mul_of_pos_right \u2039f a < f b\u203a (by rwa [\u2190 zero]) }", "start": [94, 1], "end": [108, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.strictOrderedCommSemiring", "code": "@[reducible]\nprotected def strictOrderedCommSemiring [StrictOrderedCommSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2]\n    [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) : StrictOrderedCommSemiring \u03b2 :=\n  { hf.commSemiring f zero one add mul nsmul npow nat_cast,\n    hf.strictOrderedSemiring f zero one add mul nsmul npow nat_cast with }", "start": [112, 1], "end": [120, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.strictOrderedRing", "code": "@[reducible]\nprotected def strictOrderedRing [StrictOrderedRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2]\n    [Sub \u03b2] [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : StrictOrderedRing \u03b2 :=\n  { hf.strictOrderedSemiring f zero one add mul nsmul npow nat_cast,\n    hf.ring f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with\n    mul_pos := fun a b a0 b0 =>\n      show f 0 < f (a * b) by\n        rw [zero, mul]\n        apply mul_pos <;> rwa [\u2190 zero] }", "start": [124, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.strictOrderedCommRing", "code": "@[reducible]\nprotected def strictOrderedCommRing [StrictOrderedCommRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2]\n    [Neg \u03b2] [Sub \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [NatCast \u03b2] [IntCast \u03b2] (f : \u03b2 \u2192 \u03b1)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) : StrictOrderedCommRing \u03b2 :=\n  { hf.strictOrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast,\n    hf.commRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }", "start": [142, 1], "end": [152, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedSemiring", "code": "@[reducible]\nprotected def linearOrderedSemiring [LinearOrderedSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2]\n    [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedSemiring \u03b2 :=\n  { LinearOrder.lift f hf hsup hinf,\n    hf.strictOrderedSemiring f zero one add mul nsmul npow nat_cast with }", "start": [156, 1], "end": [166, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCommSemiring", "code": "@[reducible]\nprotected def linearOrderedCommSemiring [LinearOrderedCommSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2]\n    [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedCommSemiring \u03b2 :=\n  { hf.linearOrderedSemiring f zero one add mul nsmul npow nat_cast hsup hinf,\n    hf.strictOrderedCommSemiring f zero one add mul nsmul npow nat_cast with }", "start": [170, 1], "end": [180, 79], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedRing", "code": "@[reducible]\ndef linearOrderedRing [LinearOrderedRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2] [Sub \u03b2]\n    [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [Pow \u03b2 \u2115] [NatCast \u03b2] [IntCast \u03b2] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedRing \u03b2 :=\n  { LinearOrder.lift f hf hsup hinf,\n    hf.strictOrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }", "start": [184, 1], "end": [196, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedCommRing", "code": "@[reducible]\nprotected def linearOrderedCommRing [LinearOrderedCommRing \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2]\n    [Neg \u03b2] [Sub \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [NatCast \u03b2] [IntCast \u03b2] [Sup \u03b2]\n    [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (neg : \u2200 x, f (-x) = -f x) (sub : \u2200 x y, f (x - y) = f x - f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (nat_cast : \u2200 n : \u2115, f n = n)\n    (int_cast : \u2200 n : \u2124, f n = n) (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y))\n    (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) : LinearOrderedCommRing \u03b2 :=\n  { LinearOrder.lift f hf hsup hinf,\n    hf.strictOrderedCommRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast with }", "start": [200, 1], "end": [212, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Prod.lean", "imports": ["Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Group/Prod.lean", "Mathlib/Data/Int/Cast/Prod.lean", "Mathlib/Algebra/Ring/Equiv.lean"], "premises": [{"full_name": "Prod.instDistrib", "code": "instance instDistrib [Distrib R] [Distrib S] : Distrib (R \u00d7 S) :=\n  { left_distrib := fun _ _ _ => mk.inj_iff.mpr \u27e8left_distrib _ _ _, left_distrib _ _ _\u27e9\n    right_distrib := fun _ _ _ => mk.inj_iff.mpr \u27e8right_distrib _ _ _, right_distrib _ _ _\u27e9 }", "start": [32, 1], "end": [35, 94], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalNonAssocSemiring", "code": "instance instNonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring R] [NonUnitalNonAssocSemiring S] :\n    NonUnitalNonAssocSemiring (R \u00d7 S) :=\n  { inferInstanceAs (AddCommMonoid (R \u00d7 S)),\n    inferInstanceAs (Distrib (R \u00d7 S)),\n    inferInstanceAs (MulZeroClass (R \u00d7 S)) with }", "start": [37, 1], "end": [42, 50], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalSemiring", "code": "instance instNonUnitalSemiring [NonUnitalSemiring R] [NonUnitalSemiring S] :\n    NonUnitalSemiring (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalNonAssocSemiring (R \u00d7 S)),\n    inferInstanceAs (SemigroupWithZero (R \u00d7 S)) with }", "start": [44, 1], "end": [48, 55], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonAssocSemiring", "code": "instance instNonAssocSemiring [NonAssocSemiring R] [NonAssocSemiring S] :\n    NonAssocSemiring (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalNonAssocSemiring (R \u00d7 S)),\n    inferInstanceAs (MulZeroOneClass (R \u00d7 S)),\n    inferInstanceAs (AddMonoidWithOne (R \u00d7 S)) with }", "start": [50, 1], "end": [55, 54], "kind": "commanddeclaration"}, {"full_name": "Prod.instSemiring", "code": "instance instSemiring [Semiring R] [Semiring S] : Semiring (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalSemiring (R \u00d7 S)),\n    inferInstanceAs (NonAssocSemiring (R \u00d7 S)),\n    inferInstanceAs (MonoidWithZero (R \u00d7 S)) with }", "start": [57, 1], "end": [61, 52], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalCommSemiring", "code": "instance instNonUnitalCommSemiring [NonUnitalCommSemiring R] [NonUnitalCommSemiring S] :\n    NonUnitalCommSemiring (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalSemiring (R \u00d7 S)), inferInstanceAs (CommSemigroup (R \u00d7 S)) with }", "start": [63, 1], "end": [66, 96], "kind": "commanddeclaration"}, {"full_name": "Prod.instCommSemiring", "code": "instance instCommSemiring [CommSemiring R] [CommSemiring S] : CommSemiring (R \u00d7 S) :=\n  { inferInstanceAs (Semiring (R \u00d7 S)), inferInstanceAs (CommMonoid (R \u00d7 S)) with }", "start": [68, 1], "end": [70, 84], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalNonAssocRing", "code": "instance instNonUnitalNonAssocRing [NonUnitalNonAssocRing R] [NonUnitalNonAssocRing S] :\n    NonUnitalNonAssocRing (R \u00d7 S) :=\n  { inferInstanceAs (AddCommGroup (R \u00d7 S)),\n    inferInstanceAs (NonUnitalNonAssocSemiring (R \u00d7 S)) with }", "start": [72, 1], "end": [75, 63], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalRing", "code": "instance instNonUnitalRing [NonUnitalRing R] [NonUnitalRing S] : NonUnitalRing (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalNonAssocRing (R \u00d7 S)),\n    inferInstanceAs (NonUnitalSemiring (R \u00d7 S)) with }", "start": [77, 1], "end": [79, 55], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonAssocRing", "code": "instance instNonAssocRing [NonAssocRing R] [NonAssocRing S] : NonAssocRing (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalNonAssocRing (R \u00d7 S)),\n    inferInstanceAs (NonAssocSemiring (R \u00d7 S)),\n    inferInstanceAs (AddGroupWithOne (R \u00d7 S)) with }", "start": [81, 1], "end": [84, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.instRing", "code": "instance instRing [Ring R] [Ring S] : Ring (R \u00d7 S) :=\n  { inferInstanceAs (Semiring (R \u00d7 S)),\n    inferInstanceAs (AddCommGroup (R \u00d7 S)),\n    inferInstanceAs (AddGroupWithOne (R \u00d7 S)) with }", "start": [86, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.instNonUnitalCommRing", "code": "instance instNonUnitalCommRing [NonUnitalCommRing R] [NonUnitalCommRing S] :\n    NonUnitalCommRing (R \u00d7 S) :=\n  { inferInstanceAs (NonUnitalRing (R \u00d7 S)), inferInstanceAs (CommSemigroup (R \u00d7 S)) with }", "start": [92, 1], "end": [95, 92], "kind": "commanddeclaration"}, {"full_name": "Prod.instCommRing", "code": "instance instCommRing [CommRing R] [CommRing S] : CommRing (R \u00d7 S) :=\n  { inferInstanceAs (Ring (R \u00d7 S)), inferInstanceAs (CommMonoid (R \u00d7 S)) with }", "start": [97, 1], "end": [99, 80], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.fst", "code": "def fst : R \u00d7 S \u2192\u2099+* R :=\n  { MulHom.fst R S, AddMonoidHom.fst R S with toFun := Prod.fst }", "start": [107, 1], "end": [109, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.snd", "code": "def snd : R \u00d7 S \u2192\u2099+* S :=\n  { MulHom.snd R S, AddMonoidHom.snd R S with toFun := Prod.snd }", "start": [112, 1], "end": [114, 66], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_fst", "code": "@[simp]\ntheorem coe_fst : \u21d1(fst R S) = Prod.fst", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_snd", "code": "@[simp]\ntheorem coe_snd : \u21d1(snd R S) = Prod.snd", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prod", "code": "protected def prod (f : R \u2192\u2099+* S) (g : R \u2192\u2099+* T) : R \u2192\u2099+* S \u00d7 T :=\n  { MulHom.prod (f : MulHom R S) (g : MulHom R T), AddMonoidHom.prod (f : R \u2192+ S) (g : R \u2192+ T) with\n    toFun := fun x => (f x, g x) }", "start": [133, 1], "end": [137, 35], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prod_apply", "code": "@[simp]\ntheorem prod_apply (x) : f.prod g x = (f x, g x)", "start": [140, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.fst_comp_prod", "code": "@[simp]\ntheorem fst_comp_prod : (fst S T).comp (f.prod g) = f", "start": [145, 1], "end": [147, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.snd_comp_prod", "code": "@[simp]\ntheorem snd_comp_prod : (snd S T).comp (f.prod g) = g", "start": [150, 1], "end": [152, 19], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prod_unique", "code": "theorem prod_unique (f : R \u2192\u2099+* S \u00d7 T) : ((fst S T).comp f).prod ((snd S T).comp f) = f", "start": [155, 1], "end": [156, 71], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prodMap", "code": "def prodMap : R \u00d7 S \u2192\u2099+* R' \u00d7 S' :=\n  (f.comp (fst R S)).prod (g.comp (snd R S))", "start": [167, 1], "end": [169, 45], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prodMap_def", "code": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S))", "start": [172, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.coe_prodMap", "code": "@[simp]\ntheorem coe_prodMap : \u21d1(prodMap f g) = Prod.map f g", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalRingHom.prod_comp_prodMap", "code": "theorem prod_comp_prodMap (f : T \u2192\u2099+* R) (g : T \u2192\u2099+* S) (f' : R \u2192\u2099+* R') (g' : S \u2192\u2099+* S') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g)", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.fst", "code": "def fst : R \u00d7 S \u2192+* R :=\n  { MonoidHom.fst R S, AddMonoidHom.fst R S with toFun := Prod.fst }", "start": [194, 1], "end": [196, 69], "kind": "commanddeclaration"}, {"full_name": "RingHom.snd", "code": "def snd : R \u00d7 S \u2192+* S :=\n  { MonoidHom.snd R S, AddMonoidHom.snd R S with toFun := Prod.snd }", "start": [199, 1], "end": [201, 69], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_fst", "code": "@[simp]\ntheorem coe_fst : \u21d1(fst R S) = Prod.fst", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_snd", "code": "@[simp]\ntheorem coe_snd : \u21d1(snd R S) = Prod.snd", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.prod", "code": "protected def prod (f : R \u2192+* S) (g : R \u2192+* T) : R \u2192+* S \u00d7 T :=\n  { MonoidHom.prod (f : R \u2192* S) (g : R \u2192* T), AddMonoidHom.prod (f : R \u2192+ S) (g : R \u2192+ T) with\n    toFun := fun x => (f x, g x) }", "start": [220, 1], "end": [224, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.prod_apply", "code": "@[simp]\ntheorem prod_apply (x) : f.prod g x = (f x, g x)", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.fst_comp_prod", "code": "@[simp]\ntheorem fst_comp_prod : (fst S T).comp (f.prod g) = f", "start": [232, 1], "end": [234, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.snd_comp_prod", "code": "@[simp]\ntheorem snd_comp_prod : (snd S T).comp (f.prod g) = g", "start": [237, 1], "end": [239, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.prod_unique", "code": "theorem prod_unique (f : R \u2192+* S \u00d7 T) : ((fst S T).comp f).prod ((snd S T).comp f) = f", "start": [242, 1], "end": [243, 71], "kind": "commanddeclaration"}, {"full_name": "RingHom.prodMap", "code": "def prodMap : R \u00d7 S \u2192+* R' \u00d7 S' :=\n  (f.comp (fst R S)).prod (g.comp (snd R S))", "start": [254, 1], "end": [256, 45], "kind": "commanddeclaration"}, {"full_name": "RingHom.prodMap_def", "code": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S))", "start": [259, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_prodMap", "code": "@[simp]\ntheorem coe_prodMap : \u21d1(prodMap f g) = Prod.map f g", "start": [263, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.prod_comp_prodMap", "code": "theorem prod_comp_prodMap (f : T \u2192+* R) (g : T \u2192+* S) (f' : R \u2192+* R') (g' : S \u2192+* S') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g)", "start": [268, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodComm", "code": "def prodComm : R \u00d7 S \u2243+* S \u00d7 R :=\n  { AddEquiv.prodComm, MulEquiv.prodComm with }", "start": [281, 1], "end": [283, 48], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm : \u21d1(prodComm : R \u00d7 S \u2243+* S \u00d7 R) = Prod.swap", "start": [286, 1], "end": [288, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.coe_prodComm_symm", "code": "@[simp]\ntheorem coe_prodComm_symm : \u21d1(prodComm : R \u00d7 S \u2243+* S \u00d7 R).symm = Prod.swap", "start": [291, 1], "end": [293, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.fst_comp_coe_prodComm", "code": "@[simp]\ntheorem fst_comp_coe_prodComm :\n    (RingHom.fst S R).comp \u2191(prodComm : R \u00d7 S \u2243+* S \u00d7 R) = RingHom.snd R S", "start": [296, 1], "end": [299, 27], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.snd_comp_coe_prodComm", "code": "@[simp]\ntheorem snd_comp_coe_prodComm :\n    (RingHom.snd S R).comp \u2191(prodComm : R \u00d7 S \u2243+* S \u00d7 R) = RingHom.fst R S", "start": [302, 1], "end": [305, 27], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodProdProdComm", "code": "@[simps apply]\ndef prodProdProdComm : (R \u00d7 R') \u00d7 S \u00d7 S' \u2243+* (R \u00d7 S) \u00d7 R' \u00d7 S' :=\n  { AddEquiv.prodProdProdComm R R' S S', MulEquiv.prodProdProdComm R R' S S' with\n    toFun := fun rrss => ((rrss.1.1, rrss.2.1), (rrss.1.2, rrss.2.2))\n    invFun := fun rsrs => ((rsrs.1.1, rsrs.2.1), (rsrs.1.2, rsrs.2.2)) }", "start": [312, 1], "end": [317, 73], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodProdProdComm_symm", "code": "@[simp]\ntheorem prodProdProdComm_symm : (prodProdProdComm R R' S S').symm = prodProdProdComm R S R' S'", "start": [320, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodProdProdComm_toAddEquiv", "code": "@[simp]\ntheorem prodProdProdComm_toAddEquiv :\n    (prodProdProdComm R R' S S' : _ \u2243+ _) = AddEquiv.prodProdProdComm R R' S S'", "start": [325, 1], "end": [328, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodProdProdComm_toMulEquiv", "code": "@[simp]\ntheorem prodProdProdComm_toMulEquiv :\n    (prodProdProdComm R R' S S' : _ \u2243* _) = MulEquiv.prodProdProdComm R R' S S'", "start": [331, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodProdProdComm_toEquiv", "code": "@[simp]\ntheorem prodProdProdComm_toEquiv :\n    (prodProdProdComm R R' S S' : _ \u2243 _) = Equiv.prodProdProdComm R R' S S'", "start": [337, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.prodZeroRing", "code": "@[simps]\ndef prodZeroRing : R \u2243+* R \u00d7 S where\n  toFun x := (x, 0)\n  invFun := Prod.fst\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv x := rfl\n  right_inv x := by cases x; simp", "start": [347, 1], "end": [355, 34], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.zeroRingProd", "code": "@[simps]\ndef zeroRingProd : R \u2243+* S \u00d7 R where\n  toFun x := (0, x)\n  invFun := Prod.snd\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv x := rfl\n  right_inv x := by cases x; simp", "start": [360, 1], "end": [368, 34], "kind": "commanddeclaration"}, {"full_name": "false_of_nontrivial_of_product_domain", "code": "theorem false_of_nontrivial_of_product_domain (R S : Type*) [Ring R] [Ring S] [IsDomain (R \u00d7 S)]\n    [Nontrivial R] [Nontrivial S] : False", "start": [375, 1], "end": [383, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/ULift.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/Algebra/GroupWithZero/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Int/Cast/Defs.lean", "Mathlib/Logic/Nontrivial/Basic.lean"], "premises": [{"full_name": "ULift.one", "code": "@[to_additive]\ninstance one [One \u03b1] : One (ULift \u03b1) :=\n  \u27e8\u27e81\u27e9\u27e9", "start": [30, 1], "end": [32, 8], "kind": "commanddeclaration"}, {"full_name": "ULift.one_down", "code": "@[to_additive (attr := simp)]\ntheorem one_down [One \u03b1] : (1 : ULift \u03b1).down = 1", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.mul", "code": "@[to_additive]\ninstance mul [Mul \u03b1] : Mul (ULift \u03b1) :=\n  \u27e8fun f g => \u27e8f.down * g.down\u27e9\u27e9", "start": [42, 1], "end": [44, 33], "kind": "commanddeclaration"}, {"full_name": "ULift.mul_down", "code": "@[to_additive (attr := simp)]\ntheorem mul_down [Mul \u03b1] : (x * y).down = x.down * y.down", "start": [48, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.div", "code": "@[to_additive]\ninstance div [Div \u03b1] : Div (ULift \u03b1) :=\n  \u27e8fun f g => \u27e8f.down / g.down\u27e9\u27e9", "start": [54, 1], "end": [56, 33], "kind": "commanddeclaration"}, {"full_name": "ULift.div_down", "code": "@[to_additive (attr := simp)]\ntheorem div_down [Div \u03b1] : (x / y).down = x.down / y.down", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.inv", "code": "@[to_additive]\ninstance inv [Inv \u03b1] : Inv (ULift \u03b1) :=\n  \u27e8fun f => \u27e8f.down\u207b\u00b9\u27e9\u27e9", "start": [66, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "ULift.inv_down", "code": "@[to_additive (attr := simp)]\ntheorem inv_down [Inv \u03b1] : x\u207b\u00b9.down = x.down\u207b\u00b9", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.smul", "code": "@[to_additive]\ninstance smul [SMul \u03b1 \u03b2] : SMul \u03b1 (ULift \u03b2) :=\n  \u27e8fun n x => up (n \u2022 x.down)\u27e9", "start": [78, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "ULift.smul_down", "code": "@[to_additive (attr := simp)]\ntheorem smul_down [SMul \u03b1 \u03b2] (a : \u03b1) (b : ULift.{v} \u03b2) : (a \u2022 b).down = a \u2022 b.down", "start": [84, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.pow", "code": "@[to_additive existing (reorder := 1 2) smul]\ninstance pow [Pow \u03b1 \u03b2] : Pow (ULift \u03b1) \u03b2 :=\n  \u27e8fun x n => up (x.down ^ n)\u27e9", "start": [90, 1], "end": [92, 31], "kind": "commanddeclaration"}, {"full_name": "ULift.pow_down", "code": "@[to_additive existing (attr := simp) (reorder := 1 2) smul_down]\ntheorem pow_down [Pow \u03b1 \u03b2] (a : ULift.{v} \u03b1) (b : \u03b2) : (a ^ b).down = a.down ^ b", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.ulift", "code": "@[to_additive \"The additive equivalence between `ULift \u03b1` and `\u03b1`.\"]\ndef _root_.MulEquiv.ulift [Mul \u03b1] : ULift \u03b1 \u2243* \u03b1 :=\n  { Equiv.ulift with map_mul' := fun _ _ => rfl }", "start": [100, 1], "end": [104, 50], "kind": "commanddeclaration"}, {"full_name": "ULift.semigroup", "code": "instance semigroup [Semigroup \u03b1] : Semigroup (ULift \u03b1) :=\n  (MulEquiv.ulift.injective.semigroup _) fun _ _ => rfl", "start": [109, 1], "end": [110, 56], "kind": "commanddeclaration"}, {"full_name": "ULift.addSemigroup", "code": "instance addSemigroup [AddSemigroup \u03b1] : AddSemigroup (ULift \u03b1) :=\n  (Equiv.ulift.injective.addSemigroup _) fun _ _ => rfl", "start": [113, 1], "end": [114, 56], "kind": "commanddeclaration"}, {"full_name": "ULift.commSemigroup", "code": "@[to_additive]\ninstance commSemigroup [CommSemigroup \u03b1] : CommSemigroup (ULift \u03b1) :=\n  (Equiv.ulift.injective.commSemigroup _) fun _ _ => rfl", "start": [118, 1], "end": [120, 57], "kind": "commanddeclaration"}, {"full_name": "ULift.mulOneClass", "code": "@[to_additive]\ninstance mulOneClass [MulOneClass \u03b1] : MulOneClass (ULift \u03b1) :=\n  Equiv.ulift.injective.mulOneClass _ rfl (by intros; rfl)", "start": [124, 1], "end": [126, 59], "kind": "commanddeclaration"}, {"full_name": "ULift.mulZeroOneClass", "code": "instance mulZeroOneClass [MulZeroOneClass \u03b1] : MulZeroOneClass (ULift \u03b1) :=\n  Equiv.ulift.injective.mulZeroOneClass _ rfl rfl (by intros; rfl)", "start": [130, 1], "end": [131, 67], "kind": "commanddeclaration"}, {"full_name": "ULift.monoid", "code": "@[to_additive]\ninstance monoid [Monoid \u03b1] : Monoid (ULift \u03b1) :=\n  Equiv.ulift.injective.monoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [134, 1], "end": [136, 69], "kind": "commanddeclaration"}, {"full_name": "ULift.commMonoid", "code": "@[to_additive]\ninstance commMonoid [CommMonoid \u03b1] : CommMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.commMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [140, 1], "end": [142, 73], "kind": "commanddeclaration"}, {"full_name": "ULift.natCast", "code": "instance natCast [NatCast \u03b1] : NatCast (ULift \u03b1) := \u27e8\u03bb a \u21a6 up a\u27e9", "start": [146, 1], "end": [146, 65], "kind": "commanddeclaration"}, {"full_name": "ULift.intCast", "code": "instance intCast [IntCast \u03b1] : IntCast (ULift \u03b1) := \u27e8\u03bb a \u21a6 up a\u27e9", "start": [148, 1], "end": [148, 65], "kind": "commanddeclaration"}, {"full_name": "ULift.up_natCast", "code": "@[simp, norm_cast]\ntheorem up_natCast [NatCast \u03b1] (n : \u2115) : up (n : \u03b1) = n", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.up_intCast", "code": "@[simp, norm_cast]\ntheorem up_intCast [IntCast \u03b1] (n : \u2124) : up (n : \u03b1) = n", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.down_natCast", "code": "@[simp, norm_cast]\ntheorem down_natCast [NatCast \u03b1] (n : \u2115) : down (n : ULift \u03b1) = n", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.down_intCast", "code": "@[simp, norm_cast]\ntheorem down_intCast [IntCast \u03b1] (n : \u2124) : down (n : ULift \u03b1) = n", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.addMonoidWithOne", "code": "instance addMonoidWithOne [AddMonoidWithOne \u03b1] : AddMonoidWithOne (ULift \u03b1) :=\n  { ULift.one, ULift.addMonoid with\n      natCast := fun n => \u27e8n\u27e9\n      natCast_zero := congr_arg ULift.up Nat.cast_zero,\n      natCast_succ := fun _ => congr_arg ULift.up (Nat.cast_succ _) }", "start": [171, 1], "end": [175, 70], "kind": "commanddeclaration"}, {"full_name": "ULift.addCommMonoidWithOne", "code": "instance addCommMonoidWithOne [AddCommMonoidWithOne \u03b1] : AddCommMonoidWithOne (ULift \u03b1) :=\n  { ULift.addMonoidWithOne, ULift.addCommMonoid with }", "start": [178, 1], "end": [179, 55], "kind": "commanddeclaration"}, {"full_name": "ULift.monoidWithZero", "code": "instance monoidWithZero [MonoidWithZero \u03b1] : MonoidWithZero (ULift \u03b1) :=\n  Equiv.ulift.injective.monoidWithZero _ rfl rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [182, 1], "end": [183, 81], "kind": "commanddeclaration"}, {"full_name": "ULift.commMonoidWithZero", "code": "instance commMonoidWithZero [CommMonoidWithZero \u03b1] : CommMonoidWithZero (ULift \u03b1) :=\n  Equiv.ulift.injective.commMonoidWithZero _ rfl rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [186, 1], "end": [187, 85], "kind": "commanddeclaration"}, {"full_name": "ULift.divInvMonoid", "code": "@[to_additive]\ninstance divInvMonoid [DivInvMonoid \u03b1] : DivInvMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.divInvMonoid _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [190, 1], "end": [193, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.group", "code": "@[to_additive]\ninstance group [Group \u03b1] : Group (ULift \u03b1) :=\n  Equiv.ulift.injective.group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [197, 1], "end": [200, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.commGroup", "code": "@[to_additive]\ninstance commGroup [CommGroup \u03b1] : CommGroup (ULift \u03b1) :=\n  Equiv.ulift.injective.commGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [204, 1], "end": [207, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.addGroupWithOne", "code": "instance addGroupWithOne [AddGroupWithOne \u03b1] : AddGroupWithOne (ULift \u03b1) :=\n  { ULift.addMonoidWithOne, ULift.addGroup with\n      intCast := fun n => \u27e8n\u27e9,\n      intCast_ofNat := fun _ => congr_arg ULift.up (Int.cast_ofNat _),\n      intCast_negSucc := fun _ => congr_arg ULift.up (Int.cast_negSucc _) }", "start": [211, 1], "end": [215, 76], "kind": "commanddeclaration"}, {"full_name": "ULift.addCommGroupWithOne", "code": "instance addCommGroupWithOne [AddCommGroupWithOne \u03b1] : AddCommGroupWithOne (ULift \u03b1) :=\n  { ULift.addGroupWithOne, ULift.addCommGroup with }", "start": [218, 1], "end": [219, 53], "kind": "commanddeclaration"}, {"full_name": "ULift.groupWithZero", "code": "instance groupWithZero [GroupWithZero \u03b1] : GroupWithZero (ULift \u03b1) :=\n  Equiv.ulift.injective.groupWithZero _ rfl rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [222, 1], "end": [224, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.commGroupWithZero", "code": "instance commGroupWithZero [CommGroupWithZero \u03b1] : CommGroupWithZero (ULift \u03b1) :=\n  Equiv.ulift.injective.commGroupWithZero _ rfl rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [227, 1], "end": [229, 36], "kind": "commanddeclaration"}, {"full_name": "ULift.leftCancelSemigroup", "code": "@[to_additive]\ninstance leftCancelSemigroup [LeftCancelSemigroup \u03b1] : LeftCancelSemigroup (ULift \u03b1) :=\n  Equiv.ulift.injective.leftCancelSemigroup _ fun _ _ => rfl", "start": [232, 1], "end": [234, 61], "kind": "commanddeclaration"}, {"full_name": "ULift.rightCancelSemigroup", "code": "@[to_additive]\ninstance rightCancelSemigroup [RightCancelSemigroup \u03b1] : RightCancelSemigroup (ULift \u03b1) :=\n  Equiv.ulift.injective.rightCancelSemigroup _ fun _ _ => rfl", "start": [238, 1], "end": [240, 62], "kind": "commanddeclaration"}, {"full_name": "ULift.leftCancelMonoid", "code": "@[to_additive]\ninstance leftCancelMonoid [LeftCancelMonoid \u03b1] : LeftCancelMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.leftCancelMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [244, 1], "end": [246, 79], "kind": "commanddeclaration"}, {"full_name": "ULift.rightCancelMonoid", "code": "@[to_additive]\ninstance rightCancelMonoid [RightCancelMonoid \u03b1] : RightCancelMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.rightCancelMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [250, 1], "end": [252, 80], "kind": "commanddeclaration"}, {"full_name": "ULift.cancelMonoid", "code": "@[to_additive]\ninstance cancelMonoid [CancelMonoid \u03b1] : CancelMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.cancelMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [256, 1], "end": [258, 75], "kind": "commanddeclaration"}, {"full_name": "ULift.cancelCommMonoid", "code": "@[to_additive]\ninstance cancelCommMonoid [CancelCommMonoid \u03b1] : CancelCommMonoid (ULift \u03b1) :=\n  Equiv.ulift.injective.cancelCommMonoid _ rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [262, 1], "end": [264, 79], "kind": "commanddeclaration"}, {"full_name": "ULift.nontrivial", "code": "instance nontrivial [Nontrivial \u03b1] : Nontrivial (ULift \u03b1) :=\n  Equiv.ulift.symm.injective.nontrivial", "start": [268, 1], "end": [269, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/BigOperators.lean", "imports": ["Mathlib/Data/Finset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Multiset/Basic.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean"], "premises": [{"full_name": "List.smul_sum", "code": "theorem List.smul_sum {r : \u03b1} {l : List \u03b2} : r \u2022 l.sum = (l.map ((\u00b7 \u2022 \u00b7) r)).sum", "start": [28, 1], "end": [29, 50], "kind": "commanddeclaration"}, {"full_name": "List.smul_prod", "code": "theorem List.smul_prod {r : \u03b1} {l : List \u03b2} : r \u2022 l.prod = (l.map ((\u00b7 \u2022 \u00b7) r)).prod", "start": [38, 1], "end": [39, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.smul_sum", "code": "theorem Multiset.smul_sum {r : \u03b1} {s : Multiset \u03b2} : r \u2022 s.sum = (s.map ((\u00b7 \u2022 \u00b7) r)).sum", "start": [48, 1], "end": [49, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_sum", "code": "theorem Finset.smul_sum {r : \u03b1} {f : \u03b3 \u2192 \u03b2} {s : Finset \u03b3} :\n    (r \u2022 \u2211 x in s, f x) = \u2211 x in s, r \u2022 f x", "start": [52, 1], "end": [54, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.smul_prod", "code": "theorem Multiset.smul_prod {r : \u03b1} {s : Multiset \u03b2} : r \u2022 s.prod = (s.map ((\u00b7 \u2022 \u00b7) r)).prod", "start": [63, 1], "end": [64, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_prod", "code": "theorem Finset.smul_prod {r : \u03b1} {f : \u03b3 \u2192 \u03b2} {s : Finset \u03b3} :\n    (r \u2022 \u220f x in s, f x) = \u220f x in s, r \u2022 f x", "start": [67, 1], "end": [69, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Rat/BigOperators.lean", "imports": ["Mathlib/Data/Rat/Cast/CharZero.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.cast_list_sum", "code": "@[simp, norm_cast]\ntheorem cast_list_sum (s : List \u211a) : (\u2191s.sum : \u03b1) = (s.map (\u2191)).sum", "start": [24, 1], "end": [26, 33], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_multiset_sum", "code": "@[simp, norm_cast]\ntheorem cast_multiset_sum (s : Multiset \u211a) : (\u2191s.sum : \u03b1) = (s.map (\u2191)).sum", "start": [29, 1], "end": [31, 37], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_sum", "code": "@[simp, norm_cast]\ntheorem cast_sum (s : Finset \u03b9) (f : \u03b9 \u2192 \u211a) : \u2211 i in s, f i = \u2211 i in s, (f i : \u03b1)", "start": [34, 1], "end": [36, 32], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_list_prod", "code": "@[simp, norm_cast]\ntheorem cast_list_prod (s : List \u211a) : (\u2191s.prod : \u03b1) = (s.map (\u2191)).prod", "start": [39, 1], "end": [41, 34], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_multiset_prod", "code": "@[simp, norm_cast]\ntheorem cast_multiset_prod (s : Multiset \u211a) : (\u2191s.prod : \u03b1) = (s.map (\u2191)).prod", "start": [50, 1], "end": [52, 38], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_prod", "code": "@[simp, norm_cast]\ntheorem cast_prod (s : Finset \u03b9) (f : \u03b9 \u2192 \u211a) : \u220f i in s, f i = \u220f i in s, (f i : \u03b1)", "start": [55, 1], "end": [57, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Notation.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.fun\u2080.matchAlts", "code": "def fun\u2080.matchAlts : Parser :=\n  leading_parser withPosition $ ppRealGroup <| many1Indent (ppSpace >> ppGroup matchAlt)", "start": [22, 1], "end": [24, 89], "kind": "commanddeclaration"}, {"full_name": "Finsupp.fun\u2080", "code": "@[term_parser, inherit_doc Finsupp]\ndef fun\u2080 := leading_parser:maxPrec\n  ppAllowUngrouped >> unicodeSymbol \"\u03bb\u2080\" \"fun\u2080\" >> fun\u2080.matchAlts", "start": [26, 1], "end": [28, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.singleUnexpander", "code": "@[app_unexpander Finsupp.single]\ndef singleUnexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $pat $val) => `(fun\u2080 | $pat => $val)\n  | _ => throw ()", "start": [46, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.updateUnexpander", "code": "@[app_unexpander Finsupp.update]\ndef updateUnexpander : Lean.PrettyPrinter.Unexpander\n  | `($_ $f $pat $val) => match f with\n    | `(fun\u2080 $xs:matchAlt*) => `(fun\u2080 $xs:matchAlt* | $pat => $val)\n    | _ => throw ()\n  | _ => throw ()", "start": [52, 1], "end": [58, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Finsupp.lean", "imports": ["Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Data/Finsupp/Fin.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finsupp/Indicator.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/Algebra/BigOperators/Ring.lean"], "premises": [{"full_name": "Finsupp.prod", "code": "@[to_additive \"`sum f g` is the sum of `g a (f a)` over the support of `f`. \"]\ndef prod [Zero M] [CommMonoid N] (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) : N :=\n  \u220f a in f.support, g a (f a)", "start": [50, 1], "end": [53, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_of_support_subset", "code": "@[to_additive]\ntheorem prod_of_support_subset (f : \u03b1 \u2192\u2080 M) {s : Finset \u03b1} (hs : f.support \u2286 s) (g : \u03b1 \u2192 M \u2192 N)\n    (h : \u2200 i \u2208 s, g i 0 = 1) : f.prod g = \u220f x in s, g x (f x)", "start": [59, 1], "end": [63, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_fintype", "code": "@[to_additive]\ntheorem prod_fintype [Fintype \u03b1] (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) (h : \u2200 i, g i 0 = 1) :\n    f.prod g = \u220f i, g i (f i)", "start": [67, 1], "end": [70, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_single_index", "code": "@[to_additive (attr := simp)]\ntheorem prod_single_index {a : \u03b1} {b : M} {h : \u03b1 \u2192 M \u2192 N} (h_zero : h a 0 = 1) :\n    (single a b).prod h = h a b", "start": [74, 1], "end": [81, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_mapRange_index", "code": "@[to_additive]\ntheorem prod_mapRange_index {f : M \u2192 M'} {hf : f 0 = 0} {g : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M' \u2192 N}\n    (h0 : \u2200 a, h a 0 = 1) : (mapRange f hf g).prod h = g.prod fun a b => h a (f b)", "start": [85, 1], "end": [88, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_zero_index", "code": "@[to_additive (attr := simp)]\ntheorem prod_zero_index {h : \u03b1 \u2192 M \u2192 N} : (0 : \u03b1 \u2192\u2080 M).prod h = 1", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_comm", "code": "@[to_additive]\ntheorem prod_comm (f : \u03b1 \u2192\u2080 M) (g : \u03b2 \u2192\u2080 M') (h : \u03b1 \u2192 M \u2192 \u03b2 \u2192 M' \u2192 N) :\n    (f.prod fun x v => g.prod fun x' v' => h x v x' v') =\n      g.prod fun x' v' => f.prod fun x v => h x v x' v'", "start": [98, 1], "end": [102, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_ite_eq", "code": "@[to_additive (attr := simp)]\ntheorem prod_ite_eq [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N) :\n    (f.prod fun x v => ite (a = x) (b x v) 1) = ite (a \u2208 f.support) (b a (f a)) 1", "start": [106, 1], "end": [110, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_ite_self_eq", "code": "theorem sum_ite_self_eq [DecidableEq \u03b1] {N : Type*} [AddCommMonoid N] (f : \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (f.sum fun x v => ite (a = x) v 0) = f a", "start": [121, 1], "end": [125, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_ite_self_eq_aux", "code": "@[simp]\ntheorem sum_ite_self_eq_aux [DecidableEq \u03b1] {N : Type*} [AddCommMonoid N] (f : \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (if a \u2208 f.support then f a else 0) = f a", "start": [129, 1], "end": [133, 23], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_ite_eq'", "code": "@[to_additive (attr := simp) \"A restatement of `sum_ite_eq` with the equality test reversed.\"]\ntheorem prod_ite_eq' [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 M) (a : \u03b1) (b : \u03b1 \u2192 M \u2192 N) :\n    (f.prod fun x v => ite (x = a) (b x v) 1) = ite (a \u2208 f.support) (b a (f a)) 1", "start": [135, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_ite_self_eq'", "code": "theorem sum_ite_self_eq' [DecidableEq \u03b1] {N : Type*} [AddCommMonoid N] (f : \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (f.sum fun x v => ite (x = a) v 0) = f a", "start": [146, 1], "end": [150, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_pow", "code": "@[simp]\ntheorem prod_pow [Fintype \u03b1] (f : \u03b1 \u2192\u2080 \u2115) (g : \u03b1 \u2192 N) :\n    (f.prod fun a b => g a ^ b) = \u220f a, g a ^ f a", "start": [153, 1], "end": [156, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.onFinset_prod", "code": "@[to_additive\n      \"If `g` maps a second argument of 0 to 0, summing it over the\n      result of `onFinset` is the same as summing it over the original `Finset`.\"]\ntheorem onFinset_prod {s : Finset \u03b1} {f : \u03b1 \u2192 M} {g : \u03b1 \u2192 M \u2192 N} (hf : \u2200 a, f a \u2260 0 \u2192 a \u2208 s)\n    (hg : \u2200 a, g a 0 = 1) : (onFinset s f hf).prod g = \u220f a in s, g a (f a)", "start": [159, 1], "end": [166, 95], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mul_prod_erase", "code": "@[to_additive\n      \" Taking a sum over over `f : \u03b1 \u2192\u2080 M` is the same as adding the value on a\n      single element `y \u2208 f.support` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase (f : \u03b1 \u2192\u2080 M) (y : \u03b1) (g : \u03b1 \u2192 M \u2192 N) (hyf : y \u2208 f.support) :\n    g y (f y) * (erase y f).prod g = f.prod g", "start": [170, 1], "end": [181, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mul_prod_erase'", "code": "@[to_additive\n      \" Generalization of `Finsupp.add_sum_erase`: if `g` maps a second argument of 0\n      to 0, then its sum over `f : \u03b1 \u2192\u2080 M` is the same as adding the value on any element\n      `y : \u03b1` to the sum over `erase y f`. \"]\ntheorem mul_prod_erase' (f : \u03b1 \u2192\u2080 M) (y : \u03b1) (g : \u03b1 \u2192 M \u2192 N) (hg : \u2200 i : \u03b1, g i 0 = 1) :\n    g y (f y) * (erase y f).prod g = f.prod g", "start": [185, 1], "end": [197, 83], "kind": "commanddeclaration"}, {"full_name": "SubmonoidClass.finsupp_prod_mem", "code": "@[to_additive]\ntheorem _root_.SubmonoidClass.finsupp_prod_mem {S : Type*} [SetLike S N] [SubmonoidClass S N]\n    (s : S) (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 s) : f.prod g \u2208 s", "start": [201, 1], "end": [204, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_congr", "code": "@[to_additive]\ntheorem prod_congr {f : \u03b1 \u2192\u2080 M} {g1 g2 : \u03b1 \u2192 M \u2192 N} (h : \u2200 x \u2208 f.support, g1 x (f x) = g2 x (f x)) :\n    f.prod g1 = f.prod g2", "start": [208, 1], "end": [211, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_eq_single", "code": "@[to_additive]\ntheorem prod_eq_single {f : \u03b1 \u2192\u2080 M} (a : \u03b1) {g : \u03b1 \u2192 M \u2192 N}\n    (h\u2080 : \u2200 b, f b \u2260 0 \u2192 b \u2260 a \u2192 g b (f b) = 1) (h\u2081 : f a = 0 \u2192 g a 0 = 1) :\n    f.prod g = g a (f a)", "start": [215, 1], "end": [223, 16], "kind": "commanddeclaration"}, {"full_name": "map_finsupp_prod", "code": "@[to_additive]\ntheorem map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] {H : Type*} [MonoidHomClass H N P]\n    (h : H) (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) : h (f.prod g) = f.prod fun a b => h (g a b)", "start": [229, 1], "end": [232, 17], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_finsupp_prod", "code": "@[to_additive (attr := deprecated)\n  \"Deprecated, use `_root_.map_finsupp_sum` instead.\"]\nprotected theorem MulEquiv.map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] (h : N \u2243* P)\n    (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) : h (f.prod g) = f.prod fun a b => h (g a b)", "start": [236, 1], "end": [241, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finsupp_prod", "code": "@[to_additive (attr := deprecated)\n  \"Deprecated, use `_root_.map_finsupp_sum` instead.\"]\nprotected theorem MonoidHom.map_finsupp_prod [Zero M] [CommMonoid N] [CommMonoid P] (h : N \u2192* P)\n    (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 N) : h (f.prod g) = f.prod fun a b => h (g a b)", "start": [245, 1], "end": [250, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_finsupp_sum", "code": "@[deprecated map_finsupp_sum]\nprotected theorem RingHom.map_finsupp_sum [Zero M] [Semiring R] [Semiring S] (h : R \u2192+* S)\n    (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 R) : h (f.sum g) = f.sum fun a b => h (g a b)", "start": [254, 1], "end": [258, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_finsupp_prod", "code": "@[deprecated map_finsupp_prod]\nprotected theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : R \u2192+* S)\n    (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 R) : h (f.prod g) = f.prod fun a b => h (g a b)", "start": [261, 1], "end": [265, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_finsupp_prod", "code": "@[to_additive]\ntheorem MonoidHom.coe_finsupp_prod [Zero \u03b2] [Monoid N] [CommMonoid P] (f : \u03b1 \u2192\u2080 \u03b2)\n    (g : \u03b1 \u2192 \u03b2 \u2192 N \u2192* P) : \u21d1(f.prod g) = f.prod fun i fi => \u21d1(g i fi)", "start": [269, 1], "end": [272, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.finsupp_prod_apply", "code": "@[to_additive (attr := simp)]\ntheorem MonoidHom.finsupp_prod_apply [Zero \u03b2] [Monoid N] [CommMonoid P] (f : \u03b1 \u2192\u2080 \u03b2)\n    (g : \u03b1 \u2192 \u03b2 \u2192 N \u2192* P) (x : N) : f.prod g x = f.prod fun i fi => g i fi x", "start": [276, 1], "end": [279, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_multiset_sum", "code": "theorem single_multiset_sum [AddCommMonoid M] (s : Multiset M) (a : \u03b1) :\n    single a s.sum = (s.map (single a)).sum", "start": [285, 1], "end": [288, 81], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_finset_sum", "code": "theorem single_finset_sum [AddCommMonoid M] (s : Finset \u03b9) (f : \u03b9 \u2192 M) (a : \u03b1) :\n    single a (\u2211 b in s, f b) = \u2211 b in s, single a (f b)", "start": [291, 1], "end": [296, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_sum", "code": "theorem single_sum [Zero M] [AddCommMonoid N] (s : \u03b9 \u2192\u2080 M) (f : \u03b9 \u2192 M \u2192 N) (a : \u03b1) :\n    single a (s.sum f) = s.sum fun d c => single a (f d c)", "start": [299, 1], "end": [301, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_neg_index", "code": "@[to_additive]\ntheorem prod_neg_index [AddGroup G] [CommMonoid M] {g : \u03b1 \u2192\u2080 G} {h : \u03b1 \u2192 G \u2192 M}\n    (h0 : \u2200 a, h a 0 = 1) : (-g).prod h = g.prod fun a b => h a (-b)", "start": [304, 1], "end": [307, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finset_sum_apply", "code": "theorem finset_sum_apply [AddCommMonoid N] (S : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 N) (a : \u03b1) :\n    (\u2211 i in S, f i) a = \u2211 i in S, f i a", "start": [315, 1], "end": [317, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_apply", "code": "@[simp]\ntheorem sum_apply [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N} {a\u2082 : \u03b2} :\n    (f.sum g) a\u2082 = f.sum fun a\u2081 b => g a\u2081 b a\u2082", "start": [320, 1], "end": [323, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_finset_sum", "code": "theorem coe_finset_sum [AddCommMonoid N] (S : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 N) :\n    \u21d1(\u2211 i in S, f i) = \u2211 i in S, \u21d1(f i)", "start": [327, 1], "end": [329, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_sum", "code": "theorem coe_sum [Zero M] [AddCommMonoid N] (f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N) :\n    \u21d1(f.sum g) = f.sum fun a\u2081 b => \u21d1(g a\u2081 b)", "start": [333, 1], "end": [335, 21], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_sum", "code": "theorem support_sum [DecidableEq \u03b2] [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N} :\n    (f.sum g).support \u2286 f.support.biUnion fun a => (g a (f a)).support", "start": [338, 1], "end": [343, 94], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_finset_sum", "code": "theorem support_finset_sum [DecidableEq \u03b2] [AddCommMonoid M] {s : Finset \u03b1} {f : \u03b1 \u2192 \u03b2 \u2192\u2080 M} :\n    (Finset.sum s f).support \u2286 s.biUnion fun x => (f x).support", "start": [346, 1], "end": [352, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_zero", "code": "@[simp]\ntheorem sum_zero [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} : (f.sum fun _ _ => (0 : N)) = 0", "start": [355, 1], "end": [357, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_mul", "code": "@[to_additive (attr := simp)]\ntheorem prod_mul [Zero M] [CommMonoid N] {f : \u03b1 \u2192\u2080 M} {h\u2081 h\u2082 : \u03b1 \u2192 M \u2192 N} :\n    (f.prod fun a b => h\u2081 a b * h\u2082 a b) = f.prod h\u2081 * f.prod h\u2082", "start": [360, 1], "end": [363, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_inv", "code": "@[to_additive (attr := simp)]\ntheorem prod_inv [Zero M] [CommGroup G] {f : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 G} :\n    (f.prod fun a b => (h a b)\u207b\u00b9) = (f.prod h)\u207b\u00b9", "start": [367, 1], "end": [370, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_sub", "code": "@[simp]\ntheorem sum_sub [Zero M] [AddCommGroup G] {f : \u03b1 \u2192\u2080 M} {h\u2081 h\u2082 : \u03b1 \u2192 M \u2192 G} :\n    (f.sum fun a b => h\u2081 a b - h\u2082 a b) = f.sum h\u2081 - f.sum h\u2082", "start": [374, 1], "end": [377, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_add_index", "code": "@[to_additive\n      \"Taking the product under `h` is an additive homomorphism of finsupps,  if `h` is an\n      additive homomorphism on the support. This is a more general version of\n      `Finsupp.sum_add_index'`; the latter has simpler hypotheses.\"]\ntheorem prod_add_index [DecidableEq \u03b1] [AddZeroClass M] [CommMonoid N] {f g : \u03b1 \u2192\u2080 M}\n    {h : \u03b1 \u2192 M \u2192 N} (h_zero : \u2200 a \u2208 f.support \u222a g.support, h a 0 = 1)\n    (h_add : \u2200 a \u2208 f.support \u222a g.support, \u2200 (b\u2081 b\u2082), h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082) :\n    (f + g).prod h = f.prod h * g.prod h", "start": [380, 1], "end": [394, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_add_index'", "code": "@[to_additive\n      \"Taking the sum under `h` is an additive homomorphism of finsupps,if `h` is an additive\n      homomorphism. This is a more specific version of `finsupp.sum_add_index` with simpler\n      hypotheses.\"]\ntheorem prod_add_index' [AddZeroClass M] [CommMonoid N] {f g : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 N}\n    (h_zero : \u2200 a, h a 0 = 1) (h_add : \u2200 a b\u2081 b\u2082, h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082) :\n    (f + g).prod h = f.prod h * g.prod h", "start": [398, 1], "end": [408, 74], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_hom_add_index", "code": "@[simp]\ntheorem sum_hom_add_index [AddZeroClass M] [AddCommMonoid N] {f g : \u03b1 \u2192\u2080 M} (h : \u03b1 \u2192 M \u2192+ N) :\n    ((f + g).sum fun x => h x) = (f.sum fun x => h x) + g.sum fun x => h x", "start": [412, 1], "end": [415, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_hom_add_index", "code": "@[simp]\ntheorem prod_hom_add_index [AddZeroClass M] [CommMonoid N] {f g : \u03b1 \u2192\u2080 M}\n    (h : \u03b1 \u2192 Multiplicative M \u2192* N) :\n    ((f + g).prod fun a b => h a (Multiplicative.ofAdd b)) =\n      (f.prod fun a b => h a (Multiplicative.ofAdd b)) *\n        g.prod fun a b => h a (Multiplicative.ofAdd b)", "start": [418, 1], "end": [424, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom", "code": "def liftAddHom [AddZeroClass M] [AddCommMonoid N] : (\u03b1 \u2192 M \u2192+ N) \u2243+ ((\u03b1 \u2192\u2080 M) \u2192+ N)\n    where\n  toFun F :=\n    { toFun := fun f \u21a6 f.sum fun x \u21a6 F x\n      map_zero' := Finset.sum_empty\n      map_add' := fun _ _ => sum_add_index' (fun x => (F x).map_zero) fun x => (F x).map_add }\n  invFun F x := F.comp (singleAddHom x)\n  left_inv F := by\n    ext\n    simp [singleAddHom]\n  right_inv F := by\n  apply Finsupp.addHom_ext'\n    simp [singleAddHom, AddMonoidHom.comp, Function.comp]\n  map_add' F G := by\n    ext x\n    exact sum_add", "start": [427, 1], "end": [445, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_apply", "code": "@[simp]\ntheorem liftAddHom_apply [AddCommMonoid M] [AddCommMonoid N] (F : \u03b1 \u2192 M \u2192+ N) (f : \u03b1 \u2192\u2080 M) :\n    (liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) F f = f.sum fun x => F x", "start": [448, 1], "end": [451, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_symm_apply", "code": "@[simp]\ntheorem liftAddHom_symm_apply [AddCommMonoid M] [AddCommMonoid N] (F : (\u03b1 \u2192\u2080 M) \u2192+ N) (x : \u03b1) :\n    (liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)).symm F x = F.comp (singleAddHom x)", "start": [454, 1], "end": [457, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_symm_apply_apply", "code": "theorem liftAddHom_symm_apply_apply [AddCommMonoid M] [AddCommMonoid N] (F : (\u03b1 \u2192\u2080 M) \u2192+ N) (x : \u03b1)\n    (y : M) : (liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)).symm F x y = F (single x y)", "start": [460, 1], "end": [462, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_singleAddHom", "code": "@[simp]\ntheorem liftAddHom_singleAddHom [AddCommMonoid M] :\n    (liftAddHom (\u03b1 := \u03b1) (M := M) (N := \u03b1 \u2192\u2080 M)) (singleAddHom : \u03b1 \u2192 M \u2192+ \u03b1 \u2192\u2080 M) =\n      AddMonoidHom.id _", "start": [465, 1], "end": [469, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_single", "code": "@[simp]\ntheorem sum_single [AddCommMonoid M] (f : \u03b1 \u2192\u2080 M) : f.sum single = f", "start": [472, 1], "end": [474, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.univ_sum_single", "code": "@[simp]\ntheorem univ_sum_single [Fintype \u03b1] [AddCommMonoid M] (f : \u03b1 \u2192\u2080 M) :\n    \u2211 a : \u03b1, single a (f a) = f", "start": [477, 1], "end": [483, 72], "kind": "commanddeclaration"}, {"full_name": "Finsupp.univ_sum_single_apply", "code": "@[simp]\ntheorem univ_sum_single_apply [AddCommMonoid M] [Fintype \u03b1] (i : \u03b1) (m : M) :\n    \u2211 j : \u03b1, single i m j = m", "start": [485, 1], "end": [490, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.univ_sum_single_apply'", "code": "@[simp]\ntheorem univ_sum_single_apply' [AddCommMonoid M] [Fintype \u03b1] (i : \u03b1) (m : M) :\n    \u2211 j : \u03b1, single j m i = m", "start": [493, 1], "end": [499, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivFunOnFinite_symm_eq_sum", "code": "theorem equivFunOnFinite_symm_eq_sum [Fintype \u03b1] [AddCommMonoid M] (f : \u03b1 \u2192 M) :\n    equivFunOnFinite.symm f = \u2211 a, Finsupp.single a (f a)", "start": [503, 1], "end": [507, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_apply_single", "code": "theorem liftAddHom_apply_single [AddCommMonoid M] [AddCommMonoid N] (f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1)\n    (b : M) : (liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f (single a b) = f a b", "start": [511, 1], "end": [513, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.liftAddHom_comp_single", "code": "@[simp]\ntheorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1) :\n    ((liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f).comp (singleAddHom a) = f a", "start": [516, 1], "end": [519, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comp_liftAddHom", "code": "theorem comp_liftAddHom [AddCommMonoid M] [AddCommMonoid N] [AddCommMonoid P] (g : N \u2192+ P)\n    (f : \u03b1 \u2192 M \u2192+ N) :\n    g.comp ((liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f) =\n      (liftAddHom (\u03b1 := \u03b1) (M := M) (N := P)) fun a => g.comp (f a)", "start": [522, 1], "end": [528, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_sub_index", "code": "theorem sum_sub_index [AddCommGroup \u03b2] [AddCommGroup \u03b3] {f g : \u03b1 \u2192\u2080 \u03b2} {h : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n    (h_sub : \u2200 a b\u2081 b\u2082, h a (b\u2081 - b\u2082) = h a b\u2081 - h a b\u2082) : (f - g).sum h = f.sum h - g.sum h", "start": [531, 1], "end": [534, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_embDomain", "code": "@[to_additive]\ntheorem prod_embDomain [Zero M] [CommMonoid N] {v : \u03b1 \u2192\u2080 M} {f : \u03b1 \u21aa \u03b2} {g : \u03b2 \u2192 M \u2192 N} :\n    (v.embDomain f).prod g = v.prod fun a b => g (f a) b", "start": [537, 1], "end": [541, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_finset_sum_index", "code": "@[to_additive]\ntheorem prod_finset_sum_index [AddCommMonoid M] [CommMonoid N] {s : Finset \u03b9} {g : \u03b9 \u2192 \u03b1 \u2192\u2080 M}\n    {h : \u03b1 \u2192 M \u2192 N} (h_zero : \u2200 a, h a 0 = 1) (h_add : \u2200 a b\u2081 b\u2082, h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082) :\n    (\u220f i in s, (g i).prod h) = (\u2211 i in s, g i).prod h", "start": [545, 1], "end": [550, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_sum_index", "code": "@[to_additive]\ntheorem prod_sum_index [AddCommMonoid M] [AddCommMonoid N] [CommMonoid P] {f : \u03b1 \u2192\u2080 M}\n    {g : \u03b1 \u2192 M \u2192 \u03b2 \u2192\u2080 N} {h : \u03b2 \u2192 N \u2192 P} (h_zero : \u2200 a, h a 0 = 1)\n    (h_add : \u2200 a b\u2081 b\u2082, h a (b\u2081 + b\u2082) = h a b\u2081 * h a b\u2082) :\n    (f.sum g).prod h = f.prod fun a b => (g a b).prod h", "start": [554, 1], "end": [559, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multiset_sum_sum_index", "code": "theorem multiset_sum_sum_index [AddCommMonoid M] [AddCommMonoid N] (f : Multiset (\u03b1 \u2192\u2080 M))\n    (h : \u03b1 \u2192 M \u2192 N) (h\u2080 : \u2200 a, h a 0 = 0)\n    (h\u2081 : \u2200 (a : \u03b1) (b\u2081 b\u2082 : M), h a (b\u2081 + b\u2082) = h a b\u2081 + h a b\u2082) :\n    f.sum.sum h = (f.map fun g : \u03b1 \u2192\u2080 M => g.sum h).sum", "start": [563, 1], "end": [568, 91], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_sum_eq_biUnion", "code": "theorem support_sum_eq_biUnion {\u03b1 : Type*} {\u03b9 : Type*} {M : Type*} [DecidableEq \u03b1]\n    [AddCommMonoid M] {g : \u03b9 \u2192 \u03b1 \u2192\u2080 M} (s : Finset \u03b9)\n    (h : \u2200 i\u2081 i\u2082, i\u2081 \u2260 i\u2082 \u2192 Disjoint (g i\u2081).support (g i\u2082).support) :\n    (\u2211 i in s, g i).support = s.biUnion fun i => (g i).support", "start": [571, 1], "end": [585, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multiset_map_sum", "code": "theorem multiset_map_sum [Zero M] {f : \u03b1 \u2192\u2080 M} {m : \u03b2 \u2192 \u03b3} {h : \u03b1 \u2192 M \u2192 Multiset \u03b2} :\n    Multiset.map m (f.sum h) = f.sum fun a b => (h a b).map m", "start": [588, 1], "end": [590, 51], "kind": "commanddeclaration"}, {"full_name": "Finsupp.multiset_sum_sum", "code": "theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 Multiset N} :\n    Multiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b)", "start": [593, 1], "end": [595, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_add_index_of_disjoint", "code": "@[to_additive\n      \"For disjoint `f1` and `f2`, and function `g`, the sum of the sums of `g`\n      over `f1` and `f2` equals the sum of `g` over `f1 + f2`\"]\ntheorem prod_add_index_of_disjoint [AddCommMonoid M] {f1 f2 : \u03b1 \u2192\u2080 M}\n    (hd : Disjoint f1.support f2.support) {\u03b2 : Type*} [CommMonoid \u03b2] (g : \u03b1 \u2192 M \u2192 \u03b2) :\n    (f1 + f2).prod g = f1.prod g * f2.prod g", "start": [598, 1], "end": [613, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_dvd_prod_of_subset_of_dvd", "code": "theorem prod_dvd_prod_of_subset_of_dvd [AddCommMonoid M] [CommMonoid N] {f1 f2 : \u03b1 \u2192\u2080 M}\n    {g1 g2 : \u03b1 \u2192 M \u2192 N} (h1 : f1.support \u2286 f2.support)\n    (h2 : \u2200 a : \u03b1, a \u2208 f1.support \u2192 g1 a (f1 a) \u2223 g2 a (f2 a)) : f1.prod g1 \u2223 f2.prod g2", "start": [617, 1], "end": [625, 13], "kind": "commanddeclaration"}, {"full_name": "Finsupp.indicator_eq_sum_attach_single", "code": "lemma indicator_eq_sum_attach_single [AddCommMonoid M] {s : Finset \u03b1} (f : \u2200 a \u2208 s, M) :\n    indicator s f = \u2211 x in s.attach, single \u2191x (f x x.2) := by\n  rw [\u2190 sum_single (indicator s f), sum, sum_subset (support_indicator_subset _ _), \u2190 sum_attach]\n  \u00b7 refine' Finset.sum_congr rfl (fun _ _ => _)\n    rw [indicator_of_mem]\n  \u00b7 intro i _ hi\n    rw [not_mem_support_iff.mp hi, single_zero]", "start": [628, 1], "end": [634, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.indicator_eq_sum_single", "code": "lemma indicator_eq_sum_single [AddCommMonoid M] (s : Finset \u03b1) (f : \u03b1 \u2192 M) :\n    indicator s (fun x _ \u21a6 f x) = \u2211 x in s, single x (f x) :=\n  (indicator_eq_sum_attach_single _).trans <| sum_attach (f := fun x \u21a6 single x (f x))", "start": [637, 1], "end": [639, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.prod_indicator_index_eq_prod_attach", "code": "@[to_additive (attr := simp)]\nlemma prod_indicator_index_eq_prod_attach [Zero M] [CommMonoid N]\n    {s : Finset \u03b1} (f : \u2200 a \u2208 s, M) {h : \u03b1 \u2192 M \u2192 N} (h_zero : \u2200 a \u2208 s, h a 0 = 1) :\n    (indicator s f).prod h = \u220f x in s.attach, h \u2191x (f x x.2) := by\n  rw [prod_of_support_subset _ (support_indicator_subset _ _) h h_zero, \u2190 prod_attach]\n  refine' Finset.prod_congr rfl (fun _ _ => _)\n  rw [indicator_of_mem]", "start": [641, 1], "end": [647, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.prod_indicator_index", "code": "@[to_additive (attr := simp)]\nlemma prod_indicator_index [Zero M] [CommMonoid N]\n    {s : Finset \u03b1} (f : \u03b1 \u2192 M) {h : \u03b1 \u2192 M \u2192 N} (h_zero : \u2200 a \u2208 s, h a 0 = 1) :\n    (indicator s (fun x _ \u21a6 f x)).prod h = \u220f x in s, h x (f x) :=\n  (prod_indicator_index_eq_prod_attach _ h_zero).trans <| prod_attach (f := fun x \u21a6 h x (f x))", "start": [651, 1], "end": [655, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.sum_cons", "code": "lemma sum_cons [AddCommMonoid M] (n : \u2115) (\u03c3 : Fin n \u2192\u2080 M) (i : M) :\n    (sum (cons i \u03c3) fun _ e \u21a6 e) = i + sum \u03c3 (fun _ e \u21a6 e) := by\n  rw [sum_fintype _ _ (fun _ => rfl), sum_fintype _ _ (fun _ => rfl)]\n  exact Fin.sum_cons i \u03c3", "start": [657, 1], "end": [660, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.sum_cons'", "code": "lemma sum_cons' [AddCommMonoid M] [AddCommMonoid N] (n : \u2115) (\u03c3 : Fin n \u2192\u2080 M) (i : M)\n    (f : Fin (n+1) \u2192 M \u2192 N) (h : \u2200 x, f x 0 = 0) :\n    (sum (Finsupp.cons i \u03c3) f) = f 0 i + sum \u03c3 (Fin.tail f) := by\n  rw [sum_fintype _ _ (fun _ => by apply h), sum_fintype _ _ (fun _ => by apply h)]\n  simp_rw [Fin.sum_univ_succ, cons_zero, cons_succ]\n  congr", "start": [662, 1], "end": [667, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.sum_apply'", "code": "theorem Finset.sum_apply' : (\u2211 k in s, f k) i = \u2211 k in s, f k i", "start": [671, 1], "end": [672, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_apply'", "code": "theorem Finsupp.sum_apply' : g.sum k x = g.sum fun i b => k i b x", "start": [675, 1], "end": [676, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_sum_index'", "code": "theorem Finsupp.sum_sum_index' : (\u2211 x in s, f x).sum t = \u2211 x in s, (f x).sum t", "start": [683, 1], "end": [685, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_mul", "code": "theorem Finsupp.sum_mul (b : S) (s : \u03b1 \u2192\u2080 R) {f : \u03b1 \u2192 R \u2192 S} :\n    s.sum f * b = s.sum fun a c => f a c * b", "start": [694, 1], "end": [695, 91], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mul_sum", "code": "theorem Finsupp.mul_sum (b : S) (s : \u03b1 \u2192\u2080 R) {f : \u03b1 \u2192 R \u2192 S} :\n    b * s.sum f = s.sum fun a c => b * f a c", "start": [698, 1], "end": [699, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.prod_pow_pos_of_zero_not_mem_support", "code": "theorem prod_pow_pos_of_zero_not_mem_support {f : \u2115 \u2192\u2080 \u2115} (hf : 0 \u2209 f.support) :\n    0 < f.prod (\u00b7 ^ \u00b7)", "start": [707, 1], "end": [710, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/PUnitInstances.lean", "imports": ["Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "Mathlib/Order/CompleteBooleanAlgebra.lean", "Mathlib/GroupTheory/GroupAction/Defs.lean"], "premises": [{"full_name": "PUnit.commGroup", "code": "@[to_additive]\ninstance commGroup: CommGroup PUnit where\n  mul _ _ := unit\n  one := unit\n  inv _ := unit\n  div _ _ := unit\n  npow _ _ := unit\n  zpow _ _ := unit\n  mul_assoc := by intros; rfl\n  one_mul := by intros; rfl\n  mul_one := by intros; rfl\n  mul_left_inv := by intros; rfl\n  mul_comm := by intros; rfl", "start": [25, 1], "end": [37, 29], "kind": "commanddeclaration"}, {"full_name": "PUnit.one_eq", "code": "@[to_additive (attr := simp)]\ntheorem one_eq : (1 : PUnit) = unit", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.mul_eq", "code": "@[to_additive]\ntheorem mul_eq : x * y = unit", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.div_eq", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem div_eq : x / y = unit", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.inv_eq", "code": "@[to_additive (attr := simp, nolint simpNF)]\ntheorem inv_eq : x\u207b\u00b9 = unit", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.commRing", "code": "instance commRing: CommRing PUnit where\n  __ := PUnit.commGroup\n  __ := PUnit.addCommGroup\n  left_distrib := by intros; rfl\n  right_distrib := by intros; rfl\n  zero_mul := by intros; rfl\n  mul_zero := by intros; rfl\n  natCast _ := unit", "start": [72, 1], "end": [79, 20], "kind": "commanddeclaration"}, {"full_name": "PUnit.cancelCommMonoidWithZero", "code": "instance cancelCommMonoidWithZero: CancelCommMonoidWithZero PUnit := by\n  refine' { PUnit.commRing with .. }; intros; exact Subsingleton.elim _ _", "start": [81, 1], "end": [82, 74], "kind": "commanddeclaration"}, {"full_name": "PUnit.normalizedGCDMonoid", "code": "instance normalizedGCDMonoid: NormalizedGCDMonoid PUnit where\n  gcd _ _ := unit\n  lcm _ _ := unit\n  normUnit _ := 1\n  normUnit_zero := rfl\n  normUnit_mul := by intros; rfl\n  normUnit_coe_units := by intros; rfl\n  gcd_dvd_left _ _ := \u27e8unit, Subsingleton.elim _ _\u27e9\n  gcd_dvd_right _ _ := \u27e8unit, Subsingleton.elim _ _\u27e9\n  dvd_gcd {_ _} _ _ _ := \u27e8unit, Subsingleton.elim _ _\u27e9\n  gcd_mul_lcm _ _ := \u27e81, Subsingleton.elim _ _\u27e9\n  lcm_zero_left := by intros; rfl\n  lcm_zero_right := by intros; rfl\n  normalize_gcd := by intros; rfl\n  normalize_lcm := by intros; rfl", "start": [84, 1], "end": [98, 34], "kind": "commanddeclaration"}, {"full_name": "PUnit.gcd_eq", "code": "theorem gcd_eq : gcd x y = unit", "start": [101, 1], "end": [102, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.lcm_eq", "code": "theorem lcm_eq : lcm x y = unit", "start": [106, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.norm_unit_eq", "code": "@[simp]\ntheorem norm_unit_eq {x : PUnit} : normUnit x = 1", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.canonicallyOrderedAddCommMonoid", "code": "instance canonicallyOrderedAddCommMonoid: CanonicallyOrderedAddCommMonoid PUnit := by\n  refine'\n    { PUnit.commRing, PUnit.completeBooleanAlgebra with\n      exists_add_of_le := fun {_ _} _ => \u27e8unit, Subsingleton.elim _ _\u27e9.. } <;>\n    intros <;>\n    trivial", "start": [115, 1], "end": [120, 12], "kind": "commanddeclaration"}, {"full_name": "PUnit.linearOrderedCancelAddCommMonoid", "code": "instance linearOrderedCancelAddCommMonoid: LinearOrderedCancelAddCommMonoid PUnit where\n  __ := PUnit.canonicallyOrderedAddCommMonoid\n  __ := PUnit.linearOrder\n  le_of_add_le_add_left _ _ _ _ := trivial\n  add_le_add_left := by intros; rfl", "start": [122, 1], "end": [126, 36], "kind": "commanddeclaration"}, {"full_name": "PUnit.smul", "code": "@[to_additive]\ninstance smul : SMul R PUnit :=\n  \u27e8fun _ _ => unit\u27e9", "start": [132, 1], "end": [134, 20], "kind": "commanddeclaration"}, {"full_name": "PUnit.smul_eq", "code": "@[to_additive (attr := simp)]\ntheorem smul_eq {R : Type*} (y : PUnit) (r : R) : r \u2022 y = unit", "start": [136, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.smulWithZero", "code": "instance smulWithZero [Zero R] : SMulWithZero R PUnit := by\n  refine' { PUnit.smul with .. } <;> intros <;> exact Subsingleton.elim _ _", "start": [154, 1], "end": [155, 76], "kind": "commanddeclaration"}, {"full_name": "PUnit.mulAction", "code": "instance mulAction [Monoid R] : MulAction R PUnit := by\n  refine' { PUnit.smul with .. } <;> intros <;> exact Subsingleton.elim _ _", "start": [157, 1], "end": [158, 76], "kind": "commanddeclaration"}, {"full_name": "PUnit.distribMulAction", "code": "instance distribMulAction [Monoid R] : DistribMulAction R PUnit := by\n  refine' { PUnit.mulAction with .. } <;> intros <;> exact Subsingleton.elim _ _", "start": [160, 1], "end": [161, 81], "kind": "commanddeclaration"}, {"full_name": "PUnit.mulDistribMulAction", "code": "instance mulDistribMulAction [Monoid R] : MulDistribMulAction R PUnit := by\n  refine' { PUnit.mulAction with .. } <;> intros <;> exact Subsingleton.elim _ _", "start": [163, 1], "end": [164, 81], "kind": "commanddeclaration"}, {"full_name": "PUnit.mulSemiringAction", "code": "instance mulSemiringAction [Semiring R] : MulSemiringAction R PUnit :=\n  { PUnit.distribMulAction, PUnit.mulDistribMulAction with }", "start": [166, 1], "end": [167, 61], "kind": "commanddeclaration"}, {"full_name": "PUnit.mulActionWithZero", "code": "instance mulActionWithZero [MonoidWithZero R] : MulActionWithZero R PUnit :=\n  { PUnit.mulAction, PUnit.smulWithZero with }", "start": [169, 1], "end": [170, 47], "kind": "commanddeclaration"}, {"full_name": "PUnit.module", "code": "instance module [Semiring R] : Module R PUnit := by\n  refine' { PUnit.distribMulAction with .. } <;> intros <;> exact Subsingleton.elim _ _", "start": [172, 1], "end": [173, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Submodule/Basic.lean", "imports": ["Mathlib/Algebra/Module/Equiv.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Algebra/Module/LinearMap.lean", "Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule", "code": "structure Submodule (R : Type u) (M : Type v) [Semiring R] [AddCommMonoid M] [Module R M] extends\n  AddSubmonoid M, SubMulAction R M : Type v", "start": [38, 1], "end": [42, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.setLike", "code": "instance setLike : SetLike (Submodule R M) M where\n  coe s := s.carrier\n  coe_injective' p q h := by cases p; cases q; congr; exact SetLike.coe_injective' h", "start": [57, 1], "end": [59, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.addSubmonoidClass", "code": "instance addSubmonoidClass : AddSubmonoidClass (Submodule R M) M where\n  zero_mem _ := AddSubmonoid.zero_mem' _\n  add_mem := AddSubsemigroup.add_mem' _", "start": [62, 1], "end": [64, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.smulMemClass", "code": "instance smulMemClass : SMulMemClass (Submodule R M) R M where\n  smul_mem {s} c _ h := SubMulAction.smul_mem' s.toSubMulAction c h", "start": [67, 1], "end": [68, 68], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_toAddSubmonoid", "code": "@[simp]\ntheorem mem_toAddSubmonoid (p : Submodule R M) (x : M) : x \u2208 p.toAddSubmonoid \u2194 x \u2208 p", "start": [71, 1], "end": [73, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_mk", "code": "@[simp]\ntheorem mem_mk {S : AddSubmonoid M} {x : M} (h) : x \u2208 (\u27e8S, h\u27e9 : Submodule R M) \u2194 x \u2208 S", "start": [78, 1], "end": [80, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_set_mk", "code": "@[simp]\ntheorem coe_set_mk (S : AddSubmonoid M) (h) : ((\u27e8S, h\u27e9 : Submodule R M) : Set M) = S", "start": [83, 1], "end": [85, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.eta", "code": "@[simp] theorem eta (h) : ({p with smul_mem' := h} : Submodule R M) = p", "start": [88, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk {S S' : AddSubmonoid M} (h h') :\n    (\u27e8S, h\u27e9 : Submodule R M) \u2264 (\u27e8S', h'\u27e9 : Submodule R M) \u2194 S \u2264 S'", "start": [92, 1], "end": [95, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.ext", "code": "@[ext]\ntheorem ext (h : \u2200 x, x \u2208 p \u2194 x \u2208 q) : p = q", "start": [98, 1], "end": [100, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.carrier_inj", "code": "@[simp]\ntheorem carrier_inj : p.carrier = q.carrier \u2194 p = q", "start": [104, 1], "end": [106, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.copy", "code": "protected def copy (p : Submodule R M) (s : Set M) (hs : s = \u2191p) : Submodule R M where\n  carrier := s\n  zero_mem' := by simpa [hs] using p.zero_mem'\n  add_mem' := hs.symm \u25b8 p.add_mem'\n  smul_mem' := by simpa [hs] using p.smul_mem'", "start": [108, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : Submodule R M) (s : Set M) (hs : s = \u2191S) : (S.copy s hs : Set M) = s", "start": [117, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.copy_eq", "code": "theorem copy_eq (S : Submodule R M) (s : Set M) (hs : s = \u2191S) : S.copy s hs = S", "start": [122, 1], "end": [123, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_injective", "code": "theorem toAddSubmonoid_injective : Injective (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M)", "start": [126, 1], "end": [127, 98], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_eq", "code": "@[simp]\ntheorem toAddSubmonoid_eq : p.toAddSubmonoid = q.toAddSubmonoid \u2194 p = q", "start": [130, 1], "end": [132, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_strictMono", "code": "@[mono]\ntheorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M)", "start": [135, 1], "end": [137, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_le", "code": "theorem toAddSubmonoid_le : p.toAddSubmonoid \u2264 q.toAddSubmonoid \u2194 p \u2264 q", "start": [140, 1], "end": [141, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_mono", "code": "@[mono]\ntheorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M)", "start": [144, 1], "end": [146, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_toAddSubmonoid", "code": "@[simp]\ntheorem coe_toAddSubmonoid (p : Submodule R M) : (p.toAddSubmonoid : Set M) = p", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubMulAction_injective", "code": "theorem toSubMulAction_injective : Injective (toSubMulAction : Submodule R M \u2192 SubMulAction R M)", "start": [154, 1], "end": [155, 98], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubMulAction_eq", "code": "theorem toSubMulAction_eq : p.toSubMulAction = q.toSubMulAction \u2194 p = q", "start": [158, 1], "end": [159, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubMulAction_strictMono", "code": "@[mono]\ntheorem toSubMulAction_strictMono :\n    StrictMono (toSubMulAction : Submodule R M \u2192 SubMulAction R M)", "start": [162, 1], "end": [164, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubMulAction_mono", "code": "@[mono]\ntheorem toSubMulAction_mono : Monotone (toSubMulAction : Submodule R M \u2192 SubMulAction R M)", "start": [167, 1], "end": [169, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_toSubMulAction", "code": "@[simp]\ntheorem coe_toSubMulAction (p : Submodule R M) : (p.toSubMulAction : Set M) = p", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "SMulMemClass.toModule", "code": "instance (priority := 75) toModule : Module R S' :=\n  Subtype.coe_injective.module R (AddSubmonoidClass.subtype S') (SetLike.val_smul S')", "start": [185, 1], "end": [187, 86], "kind": "commanddeclaration"}, {"full_name": "SMulMemClass.toModule'", "code": "def toModule' (S R' R A : Type*) [Semiring R] [NonUnitalNonAssocSemiring A]\n    [Module R A] [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A]\n    [SetLike S A] [AddSubmonoidClass S A] [SMulMemClass S R A] (s : S) :\n    Module R' s :=\n  haveI : SMulMemClass S R' A := SMulMemClass.ofIsScalarTower S R' R A\n  SMulMemClass.toModule s", "start": [190, 1], "end": [197, 26], "kind": "commanddeclaration"}, {"full_name": "SMulMemClass.subtype", "code": "protected def subtype : S' \u2192\u2097[R] M where\n  toFun := Subtype.val\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [199, 1], "end": [203, 23], "kind": "commanddeclaration"}, {"full_name": "SMulMemClass.coeSubtype", "code": "@[simp]\nprotected theorem coeSubtype : (SMulMemClass.subtype S' : S' \u2192 M) = Subtype.val", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_carrier", "code": "theorem mem_carrier : x \u2208 p.carrier \u2194 x \u2208 (p : Set M)", "start": [230, 1], "end": [231, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.zero_mem", "code": "@[simp]\nprotected theorem zero_mem : (0 : M) \u2208 p", "start": [234, 1], "end": [236, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.add_mem", "code": "protected theorem add_mem (h\u2081 : x \u2208 p) (h\u2082 : y \u2208 p) : x + y \u2208 p", "start": [239, 1], "end": [240, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem", "code": "theorem smul_mem (r : R) (h : x \u2208 p) : r \u2022 x \u2208 p", "start": [243, 1], "end": [244, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_of_tower_mem", "code": "theorem smul_of_tower_mem [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (h : x \u2208 p) :\n    r \u2022 x \u2208 p", "start": [247, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.sum_mem", "code": "protected theorem sum_mem {t : Finset \u03b9} {f : \u03b9 \u2192 M} : (\u2200 c \u2208 t, f c \u2208 p) \u2192 (\u2211 i in t, f i) \u2208 p", "start": [252, 1], "end": [253, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.sum_smul_mem", "code": "theorem sum_smul_mem {t : Finset \u03b9} {f : \u03b9 \u2192 M} (r : \u03b9 \u2192 R) (hyp : \u2200 c \u2208 t, f c \u2208 p) :\n    (\u2211 i in t, r i \u2022 f i) \u2208 p", "start": [256, 1], "end": [258, 46], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_iff'", "code": "@[simp]\ntheorem smul_mem_iff' [Group G] [MulAction G M] [SMul G R] [IsScalarTower G R M] (g : G) :\n    g \u2022 x \u2208 p \u2194 x \u2208 p", "start": [261, 1], "end": [264, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.add", "code": "instance add : Add p :=\n  \u27e8fun x y => \u27e8x.1 + y.1, add_mem x.2 y.2\u27e9\u27e9", "start": [267, 1], "end": [268, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.zero", "code": "instance zero : Zero p :=\n  \u27e8\u27e80, zero_mem _\u27e9\u27e9", "start": [271, 1], "end": [272, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.inhabited", "code": "instance inhabited : Inhabited p :=\n  \u27e80\u27e9", "start": [275, 1], "end": [276, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul", "code": "instance smul [SMul S R] [SMul S M] [IsScalarTower S R M] : SMul S p :=\n  \u27e8fun c x => \u27e8c \u2022 x.1, smul_of_tower_mem _ c x.2\u27e9\u27e9", "start": [279, 1], "end": [280, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.isScalarTower", "code": "instance isScalarTower [SMul S R] [SMul S M] [IsScalarTower S R M] : IsScalarTower S R p :=\n  p.toSubMulAction.isScalarTower", "start": [283, 1], "end": [284, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.isScalarTower'", "code": "instance isScalarTower' {S' : Type*} [SMul S R] [SMul S M] [SMul S' R] [SMul S' M] [SMul S S']\n    [IsScalarTower S' R M] [IsScalarTower S S' M] [IsScalarTower S R M] : IsScalarTower S S' p :=\n  p.toSubMulAction.isScalarTower'", "start": [287, 1], "end": [289, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.isCentralScalar", "code": "instance isCentralScalar [SMul S R] [SMul S M] [IsScalarTower S R M] [SMul S\u1d50\u1d52\u1d56 R] [SMul S\u1d50\u1d52\u1d56 M]\n    [IsScalarTower S\u1d50\u1d52\u1d56 R M] [IsCentralScalar S M] : IsCentralScalar S p :=\n  p.toSubMulAction.isCentralScalar", "start": [292, 1], "end": [294, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.nonempty", "code": "protected theorem nonempty : (p : Set M).Nonempty", "start": [297, 1], "end": [298, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.mk_eq_zero", "code": "@[simp]\ntheorem mk_eq_zero {x} (h : x \u2208 p) : (\u27e8x, h\u27e9 : p) = 0 \u2194 x = 0", "start": [301, 1], "end": [303, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_eq_zero", "code": "@[norm_cast] theorem coe_eq_zero {x : p} : (x : M) = 0 \u2194 x = 0", "start": [308, 1], "end": [310, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : p) : (\u2191(x + y) : M) = \u2191x + \u2191y", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : p) : M) = 0", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_smul", "code": "@[norm_cast]\ntheorem coe_smul (r : R) (x : p) : ((r \u2022 x : p) : M) = r \u2022 (x : M)", "start": [323, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_smul_of_tower", "code": "@[simp, norm_cast]\ntheorem coe_smul_of_tower [SMul S R] [SMul S M] [IsScalarTower S R M] (r : S) (x : p) :\n    ((r \u2022 x : p) : M) = r \u2022 (x : M)", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_mk", "code": "@[norm_cast] theorem coe_mk (x : M) (hx : x \u2208 p) : ((\u27e8x, hx\u27e9 : p) : M) = x", "start": [334, 1], "end": [336, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_mem", "code": "theorem coe_mem (x : p) : (x : M) \u2208 p", "start": [340, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid p :=\n  { p.toAddSubmonoid.toAddCommMonoid with }", "start": [346, 1], "end": [347, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.module'", "code": "instance module' [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] : Module S p :=\n  { (show MulAction S p from p.toSubMulAction.mulAction') with\n    smul_zero := fun a => by ext; simp\n    zero_smul := fun a => by ext; simp\n    add_smul := fun a b x => by ext; simp [add_smul]\n    smul_add := fun a x y => by ext; simp [smul_add] }", "start": [350, 1], "end": [355, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.module", "code": "instance module : Module R p :=\n  p.module'", "start": [358, 1], "end": [359, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R p :=\n  \u27e8fun {c} {x : p} h =>\n    have : c = 0 \u2228 (x : M) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg Subtype.val h)\n    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr\u27e9", "start": [362, 1], "end": [365, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype", "code": "protected def subtype : p \u2192\u2097[R] M := by refine' { toFun := Subtype.val.. } <;> simp [coe_smul]", "start": [368, 1], "end": [369, 95], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype_apply", "code": "theorem subtype_apply (x : p) : p.subtype x = x", "start": [372, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coeSubtype", "code": "@[simp]\ntheorem coeSubtype : (Submodule.subtype p : p \u2192 M) = Subtype.val", "start": [376, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.injective_subtype", "code": "theorem injective_subtype : Injective p.subtype", "start": [381, 1], "end": [382, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_sum", "code": "theorem coe_sum (x : \u03b9 \u2192 p) (s : Finset \u03b9) : \u2191(\u2211 i in s, x i) = \u2211 i in s, (x i : M)", "start": [385, 1], "end": [388, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.vaddCommClass", "code": "instance vaddCommClass [VAdd M \u03b2] [VAdd \u03b1 \u03b2] [VAddCommClass M \u03b1 \u03b2] : VAddCommClass p \u03b1 \u03b2 :=\n  \u27e8fun a => (vadd_comm (a : M) : _)\u27e9", "start": [407, 1], "end": [408, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.vadd_def", "code": "theorem vadd_def [VAdd M \u03b1] (g : p) (m : \u03b1) : g +\u1d65 m = (g : M) +\u1d65 m", "start": [420, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars", "code": "def restrictScalars (V : Submodule R M) : Submodule S M where\n  carrier := V\n  zero_mem' := V.zero_mem\n  smul_mem' c _ h := V.smul_of_tower_mem c h\n  add_mem' hx hy := V.add_mem hx hy", "start": [430, 1], "end": [437, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (V : Submodule R M) : (V.restrictScalars S : Set M) = V", "start": [440, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_mem", "code": "@[simp]\ntheorem restrictScalars_mem (V : Submodule R M) (m : M) : m \u2208 V.restrictScalars S \u2194 m \u2208 V", "start": [445, 1], "end": [447, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_self", "code": "@[simp]\ntheorem restrictScalars_self (V : Submodule R M) : V.restrictScalars R = V", "start": [450, 1], "end": [452, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars S : Submodule R M \u2192 Submodule S M)", "start": [457, 1], "end": [459, 50], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_inj", "code": "@[simp]\ntheorem restrictScalars_inj {V\u2081 V\u2082 : Submodule R M} :\n    restrictScalars S V\u2081 = restrictScalars S V\u2082 \u2194 V\u2081 = V\u2082", "start": [462, 1], "end": [465, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars.origModule", "code": "instance restrictScalars.origModule (p : Submodule R M) : Module R (p.restrictScalars S) :=\n  (by infer_instance : Module R p)", "start": [468, 1], "end": [470, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars.isScalarTower", "code": "instance restrictScalars.isScalarTower (p : Submodule R M) :\n    IsScalarTower S R (p.restrictScalars S) where\n  smul_assoc r s x := Subtype.ext <| smul_assoc r s (x : M)", "start": [473, 1], "end": [475, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalarsEmbedding", "code": "@[simps]\ndef restrictScalarsEmbedding : Submodule R M \u21aao Submodule S M where\n  toFun := restrictScalars S\n  inj' := restrictScalars_injective S R M\n  map_rel_iff' := by simp [SetLike.le_def]", "start": [478, 1], "end": [484, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalarsEquiv", "code": "@[simps (config := { simpRhs := true })]\ndef restrictScalarsEquiv (p : Submodule R M) : p.restrictScalars S \u2243\u2097[R] p :=\n  { AddEquiv.refl p with\n    map_smul' := fun _ _ => rfl }", "start": [488, 1], "end": [493, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.addSubgroupClass", "code": "instance addSubgroupClass [Module R M] : AddSubgroupClass (Submodule R M) M :=\n  { Submodule.addSubmonoidClass with neg_mem := fun p {_} => p.toSubMulAction.neg_mem }", "start": [511, 1], "end": [512, 88], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_mem", "code": "protected theorem neg_mem (hx : x \u2208 p) : -x \u2208 p", "start": [515, 1], "end": [516, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup", "code": "def toAddSubgroup : AddSubgroup M :=\n  { p.toAddSubmonoid with neg_mem' := fun {_} => p.neg_mem }", "start": [519, 1], "end": [521, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_toAddSubgroup", "code": "@[simp]\ntheorem coe_toAddSubgroup : (p.toAddSubgroup : Set M) = p", "start": [524, 1], "end": [526, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_toAddSubgroup", "code": "@[simp]\ntheorem mem_toAddSubgroup : x \u2208 p.toAddSubgroup \u2194 x \u2208 p", "start": [529, 1], "end": [531, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_injective", "code": "theorem toAddSubgroup_injective : Injective (toAddSubgroup : Submodule R M \u2192 AddSubgroup M)", "start": [534, 1], "end": [535, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_eq", "code": "@[simp]\ntheorem toAddSubgroup_eq : p.toAddSubgroup = p'.toAddSubgroup \u2194 p = p'", "start": [538, 1], "end": [540, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_strictMono", "code": "@[mono]\ntheorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Submodule R M \u2192 AddSubgroup M)", "start": [543, 1], "end": [545, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_le", "code": "theorem toAddSubgroup_le : p.toAddSubgroup \u2264 p'.toAddSubgroup \u2194 p \u2264 p'", "start": [548, 1], "end": [549, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_mono", "code": "@[mono]\ntheorem toAddSubgroup_mono : Monotone (toAddSubgroup : Submodule R M \u2192 AddSubgroup M)", "start": [552, 1], "end": [554, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.sub_mem", "code": "protected theorem sub_mem : x \u2208 p \u2192 y \u2208 p \u2192 x - y \u2208 p", "start": [557, 1], "end": [558, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_mem_iff", "code": "protected theorem neg_mem_iff : -x \u2208 p \u2194 x \u2208 p", "start": [561, 1], "end": [562, 14], "kind": "commanddeclaration"}, {"full_name": "Submodule.add_mem_iff_left", "code": "protected theorem add_mem_iff_left : y \u2208 p \u2192 (x + y \u2208 p \u2194 x \u2208 p)", "start": [565, 1], "end": [566, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.add_mem_iff_right", "code": "protected theorem add_mem_iff_right : x \u2208 p \u2192 (x + y \u2208 p \u2194 y \u2208 p)", "start": [569, 1], "end": [570, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_neg", "code": "protected theorem coe_neg (x : p) : ((-x : p) : M) = -x", "start": [573, 1], "end": [574, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_sub", "code": "protected theorem coe_sub (x y : p) : (\u2191(x - y) : M) = \u2191x - \u2191y", "start": [577, 1], "end": [578, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.sub_mem_iff_left", "code": "theorem sub_mem_iff_left (hy : y \u2208 p) : x - y \u2208 p \u2194 x \u2208 p", "start": [581, 1], "end": [582, 57], "kind": "commanddeclaration"}, {"full_name": "Submodule.sub_mem_iff_right", "code": "theorem sub_mem_iff_right (hx : x \u2208 p) : x - y \u2208 p \u2194 y \u2208 p", "start": [585, 1], "end": [586, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.addCommGroup", "code": "instance addCommGroup : AddCommGroup p :=\n  { p.toAddSubgroup.toAddCommGroup with }", "start": [589, 1], "end": [590, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.not_mem_of_ortho", "code": "theorem not_mem_of_ortho {x : M} {N : Submodule R M}\n    (ortho : \u2200 (c : R), \u2200 y \u2208 N, c \u2022 x + y = (0 : M) \u2192 c = 0) : x \u2209 N", "start": [601, 1], "end": [604, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.ne_zero_of_ortho", "code": "theorem ne_zero_of_ortho {x : M} {N : Submodule R M}\n    (ortho : \u2200 (c : R), \u2200 y \u2208 N, c \u2022 x + y = (0 : M) \u2192 c = 0) : x \u2260 0", "start": [607, 1], "end": [609, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.toOrderedAddCommMonoid", "code": "instance toOrderedAddCommMonoid {M} [OrderedAddCommMonoid M] [Module R M] (S : Submodule R M) :\n    OrderedAddCommMonoid S :=\n  Subtype.coe_injective.orderedAddCommMonoid Subtype.val rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [618, 1], "end": [621, 93], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearOrderedAddCommMonoid", "code": "instance toLinearOrderedAddCommMonoid {M} [LinearOrderedAddCommMonoid M] [Module R M]\n    (S : Submodule R M) : LinearOrderedAddCommMonoid S :=\n  Subtype.coe_injective.linearOrderedAddCommMonoid Subtype.val rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [624, 1], "end": [628, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.toOrderedCancelAddCommMonoid", "code": "instance toOrderedCancelAddCommMonoid {M} [OrderedCancelAddCommMonoid M] [Module R M]\n    (S : Submodule R M) : OrderedCancelAddCommMonoid S :=\n  Subtype.coe_injective.orderedCancelAddCommMonoid Subtype.val rfl (fun _ _ => rfl) fun _ _ => rfl", "start": [631, 1], "end": [634, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearOrderedCancelAddCommMonoid", "code": "instance toLinearOrderedCancelAddCommMonoid {M} [LinearOrderedCancelAddCommMonoid M] [Module R M]\n    (S : Submodule R M) : LinearOrderedCancelAddCommMonoid S :=\n  Subtype.coe_injective.linearOrderedCancelAddCommMonoid Subtype.val rfl (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [637, 1], "end": [642, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.toOrderedAddCommGroup", "code": "instance toOrderedAddCommGroup {M} [OrderedAddCommGroup M] [Module R M] (S : Submodule R M) :\n    OrderedAddCommGroup S :=\n  Subtype.coe_injective.orderedAddCommGroup Subtype.val rfl (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [651, 1], "end": [655, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearOrderedAddCommGroup", "code": "instance toLinearOrderedAddCommGroup {M} [LinearOrderedAddCommGroup M] [Module R M]\n    (S : Submodule R M) : LinearOrderedAddCommGroup S :=\n  Subtype.coe_injective.linearOrderedAddCommGroup Subtype.val rfl (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [658, 1], "end": [663, 87], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_iff", "code": "theorem smul_mem_iff (s0 : s \u2260 0) : s \u2022 x \u2208 p \u2194 x \u2208 p", "start": [678, 1], "end": [679, 35], "kind": "commanddeclaration"}, {"full_name": "Subspace", "code": "abbrev Subspace (R : Type u) (M : Type v) [DivisionRing R] [AddCommGroup M] [Module R M] :=\n  Submodule R M", "start": [684, 1], "end": [686, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Iterate.lean", "imports": ["Mathlib/Order/Monotone/Basic.lean", "Mathlib/Logic/Function/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Monotone.seq_le_seq", "code": "theorem seq_le_seq (hf : Monotone f) (n : \u2115) (h\u2080 : x 0 \u2264 y 0) (hx : \u2200 k < n, x (k + 1) \u2264 f (x k))\n    (hy : \u2200 k < n, f (y k) \u2264 y (k + 1)) : x n \u2264 y n", "start": [45, 1], "end": [51, 53], "kind": "commanddeclaration"}, {"full_name": "Monotone.seq_pos_lt_seq_of_lt_of_le", "code": "theorem seq_pos_lt_seq_of_lt_of_le (hf : Monotone f) {n : \u2115} (hn : 0 < n) (h\u2080 : x 0 \u2264 y 0)\n    (hx : \u2200 k < n, x (k + 1) < f (x k)) (hy : \u2200 k < n, f (y k) \u2264 y (k + 1)) : x n < y n", "start": [54, 1], "end": [63, 39], "kind": "commanddeclaration"}, {"full_name": "Monotone.seq_pos_lt_seq_of_le_of_lt", "code": "theorem seq_pos_lt_seq_of_le_of_lt (hf : Monotone f) {n : \u2115} (hn : 0 < n) (h\u2080 : x 0 \u2264 y 0)\n    (hx : \u2200 k < n, x (k + 1) \u2264 f (x k)) (hy : \u2200 k < n, f (y k) < y (k + 1)) : x n < y n", "start": [66, 1], "end": [68, 49], "kind": "commanddeclaration"}, {"full_name": "Monotone.seq_lt_seq_of_lt_of_le", "code": "theorem seq_lt_seq_of_lt_of_le (hf : Monotone f) (n : \u2115) (h\u2080 : x 0 < y 0)\n    (hx : \u2200 k < n, x (k + 1) < f (x k)) (hy : \u2200 k < n, f (y k) \u2264 y (k + 1)) : x n < y n", "start": [71, 1], "end": [74, 78], "kind": "commanddeclaration"}, {"full_name": "Monotone.seq_lt_seq_of_le_of_lt", "code": "theorem seq_lt_seq_of_le_of_lt (hf : Monotone f) (n : \u2115) (h\u2080 : x 0 < y 0)\n    (hx : \u2200 k < n, x (k + 1) \u2264 f (x k)) (hy : \u2200 k < n, f (y k) < y (k + 1)) : x n < y n", "start": [77, 1], "end": [79, 44], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_iterate_comp_of_le", "code": "theorem le_iterate_comp_of_le (hf : Monotone f) (H : h \u2218 g \u2264 f \u2218 h) (n : \u2115) :\n    h \u2218 g^[n] \u2264 f^[n] \u2218 h", "start": [97, 1], "end": [101, 23], "kind": "commanddeclaration"}, {"full_name": "Monotone.iterate_comp_le_of_le", "code": "theorem iterate_comp_le_of_le (hf : Monotone f) (H : f \u2218 h \u2264 h \u2218 g) (n : \u2115) :\n    f^[n] \u2218 h \u2264 h \u2218 g^[n]", "start": [104, 1], "end": [106, 36], "kind": "commanddeclaration"}, {"full_name": "Monotone.iterate_le_of_le", "code": "theorem iterate_le_of_le {g : \u03b1 \u2192 \u03b1} (hf : Monotone f) (h : f \u2264 g) (n : \u2115) : f^[n] \u2264 g^[n]", "start": [109, 1], "end": [111, 31], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_iterate_of_le", "code": "theorem le_iterate_of_le {g : \u03b1 \u2192 \u03b1} (hg : Monotone g) (h : f \u2264 g) (n : \u2115) : f^[n] \u2264 g^[n]", "start": [114, 1], "end": [116, 31], "kind": "commanddeclaration"}, {"full_name": "Function.id_le_iterate_of_id_le", "code": "theorem id_le_iterate_of_id_le (h : id \u2264 f) (n : \u2115) : id \u2264 f^[n]", "start": [135, 1], "end": [138, 65], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_le_id_of_le_id", "code": "theorem iterate_le_id_of_le_id (h : f \u2264 id) (n : \u2115) : f^[n] \u2264 id", "start": [141, 1], "end": [142, 38], "kind": "commanddeclaration"}, {"full_name": "Function.monotone_iterate_of_id_le", "code": "theorem monotone_iterate_of_id_le (h : id \u2264 f) : Monotone fun m => f^[m]", "start": [145, 1], "end": [148, 14], "kind": "commanddeclaration"}, {"full_name": "Function.antitone_iterate_of_le_id", "code": "theorem antitone_iterate_of_le_id (h : f \u2264 id) : Antitone fun m => f^[m]", "start": [151, 1], "end": [152, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_le_of_map_le", "code": "theorem iterate_le_of_map_le (h : Commute f g) (hf : Monotone f) (hg : Monotone g) {x}\n    (hx : f x \u2264 g x) (n : \u2115) : f^[n] x \u2264 g^[n] x", "start": [172, 1], "end": [177, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_lt_of_map_lt", "code": "theorem iterate_pos_lt_of_map_lt (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x}\n    (hx : f x < g x) {n} (hn : 0 < n) : f^[n] x < g^[n] x", "start": [180, 1], "end": [185, 56], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_lt_of_map_lt'", "code": "theorem iterate_pos_lt_of_map_lt' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x}\n    (hx : f x < g x) {n} (hn : 0 < n) : f^[n] x < g^[n] x", "start": [188, 1], "end": [190, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_lt_iff_map_lt", "code": "theorem iterate_pos_lt_iff_map_lt (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x < g^[n] x \u2194 f x < g x", "start": [197, 1], "end": [202, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_lt_iff_map_lt'", "code": "theorem iterate_pos_lt_iff_map_lt' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x n}\n    (hn : 0 < n) : f^[n] x < g^[n] x \u2194 f x < g x", "start": [205, 1], "end": [207, 69], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_le_iff_map_le", "code": "theorem iterate_pos_le_iff_map_le (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x", "start": [210, 1], "end": [212, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_le_iff_map_le'", "code": "theorem iterate_pos_le_iff_map_le' (h : Commute f g) (hf : StrictMono f) (hg : Monotone g) {x n}\n    (hn : 0 < n) : f^[n] x \u2264 g^[n] x \u2194 f x \u2264 g x", "start": [215, 1], "end": [217, 82], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.iterate_pos_eq_iff_map_eq", "code": "theorem iterate_pos_eq_iff_map_eq (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n    (hn : 0 < n) : f^[n] x = g^[n] x \u2194 f x = g x", "start": [220, 1], "end": [223, 48], "kind": "commanddeclaration"}, {"full_name": "Monotone.monotone_iterate_of_le_map", "code": "theorem monotone_iterate_of_le_map (hf : Monotone f) (hx : x \u2264 f x) : Monotone fun n => f^[n] x", "start": [234, 1], "end": [239, 26], "kind": "commanddeclaration"}, {"full_name": "Monotone.antitone_iterate_of_map_le", "code": "theorem antitone_iterate_of_map_le (hf : Monotone f) (hx : f x \u2264 x) : Antitone fun n => f^[n] x", "start": [242, 1], "end": [245, 40], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictMono_iterate_of_lt_map", "code": "theorem strictMono_iterate_of_lt_map (hf : StrictMono f) (hx : x < f x) :\n    StrictMono fun n => f^[n] x", "start": [254, 1], "end": [260, 26], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictAnti_iterate_of_map_lt", "code": "theorem strictAnti_iterate_of_map_lt (hf : StrictMono f) (hx : f x < x) :\n    StrictAnti fun n => f^[n] x", "start": [263, 1], "end": [267, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Lattice.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "Mathlib/Data/Nat/Interval.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.sInf_def", "code": "theorem sInf_def {s : Set \u2115} (h : s.Nonempty) : sInf s = @Nat.find (fun n \u21a6 n \u2208 s) _ h", "start": [33, 1], "end": [34, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.sSup_def", "code": "theorem sSup_def {s : Set \u2115} (h : \u2203 n, \u2200 a \u2208 s, a \u2264 n) :\n    sSup s = @Nat.find (fun n \u21a6 \u2200 a \u2208 s, a \u2264 n) _ h", "start": [37, 1], "end": [39, 12], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.Nat.sSup_eq_zero", "code": "theorem _root_.Set.Infinite.Nat.sSup_eq_zero {s : Set \u2115} (h : s.Infinite) : sSup s = 0", "start": [42, 1], "end": [45, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_eq_zero", "code": "@[simp]\ntheorem sInf_eq_zero {s : Set \u2115} : sInf s = 0 \u2194 0 \u2208 s \u2228 s = \u2205", "start": [48, 1], "end": [54, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf \u2205 = 0", "start": [57, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.iInf_of_empty", "code": "@[simp]\ntheorem iInf_of_empty {\u03b9 : Sort*} [IsEmpty \u03b9] (f : \u03b9 \u2192 \u2115) : iInf f = 0", "start": [64, 1], "end": [66, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_mem", "code": "theorem sInf_mem {s : Set \u2115} (h : s.Nonempty) : sInf s \u2208 s", "start": [69, 1], "end": [71, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.not_mem_of_lt_sInf", "code": "theorem not_mem_of_lt_sInf {s : Set \u2115} {m : \u2115} (hm : m < sInf s) : m \u2209 s", "start": [74, 1], "end": [77, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_le", "code": "protected theorem sInf_le {s : Set \u2115} {m : \u2115} (hm : m \u2208 s) : sInf s \u2264 m", "start": [80, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.nonempty_of_pos_sInf", "code": "theorem nonempty_of_pos_sInf {s : Set \u2115} (h : 0 < sInf s) : s.Nonempty", "start": [85, 1], "end": [92, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.nonempty_of_sInf_eq_succ", "code": "theorem nonempty_of_sInf_eq_succ {s : Set \u2115} {k : \u2115} (h : sInf s = k + 1) : s.Nonempty", "start": [95, 1], "end": [96, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_Ici_of_nonempty_of_upward_closed", "code": "theorem eq_Ici_of_nonempty_of_upward_closed {s : Set \u2115} (hs : s.Nonempty)\n    (hs' : \u2200 k\u2081 k\u2082 : \u2115, k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s) : s = Ici (sInf s)", "start": [99, 1], "end": [101, 78], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_upward_closed_eq_succ_iff", "code": "theorem sInf_upward_closed_eq_succ_iff {s : Set \u2115} (hs : \u2200 k\u2081 k\u2082 : \u2115, k\u2081 \u2264 k\u2082 \u2192 k\u2081 \u2208 s \u2192 k\u2082 \u2208 s)\n    (k : \u2115) : sInf s = k + 1 \u2194 k + 1 \u2208 s \u2227 k \u2209 s", "start": [104, 1], "end": [113, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.sSup_mem", "code": "theorem sSup_mem {s : Set \u2115} (h\u2081 : s.Nonempty) (h\u2082 : BddAbove s) : sSup s \u2208 s", "start": [145, 1], "end": [147, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_add", "code": "theorem sInf_add {n : \u2115} {p : \u2115 \u2192 Prop} (hn : n \u2264 sInf { m | p m }) :\n    sInf { m | p (m + n) } + n = sInf { m | p m }", "start": [150, 1], "end": [163, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.sInf_add'", "code": "theorem sInf_add' {n : \u2115} {p : \u2115 \u2192 Prop} (h : 0 < sInf { m | p m }) :\n    sInf { m | p m } + n = sInf { m | p (m - n) }", "start": [166, 1], "end": [178, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.iSup_lt_succ", "code": "theorem iSup_lt_succ (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a06 k < n + 1, u k = (\u2a06 k < n, u k) \u2294 u n", "start": [185, 1], "end": [186, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.iSup_lt_succ'", "code": "theorem iSup_lt_succ' (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a06 k < n + 1, u k = u 0 \u2294 \u2a06 k < n, u (k + 1)", "start": [189, 1], "end": [191, 7], "kind": "commanddeclaration"}, {"full_name": "Nat.iInf_lt_succ", "code": "theorem iInf_lt_succ (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a05 k < n + 1, u k = (\u2a05 k < n, u k) \u2293 u n", "start": [194, 1], "end": [195, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.iInf_lt_succ'", "code": "theorem iInf_lt_succ' (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a05 k < n + 1, u k = u 0 \u2293 \u2a05 k < n, u (k + 1)", "start": [198, 1], "end": [199, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.iSup_le_succ", "code": "theorem iSup_le_succ (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a06 k \u2264 n + 1, u k = (\u2a06 k \u2264 n, u k) \u2294 u (n + 1)", "start": [202, 1], "end": [203, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.iSup_le_succ'", "code": "theorem iSup_le_succ' (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a06 k \u2264 n + 1, u k = u 0 \u2294 \u2a06 k \u2264 n, u (k + 1)", "start": [205, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.iInf_le_succ", "code": "theorem iInf_le_succ (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a05 k \u2264 n + 1, u k = (\u2a05 k \u2264 n, u k) \u2293 u (n + 1)", "start": [208, 1], "end": [209, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.iInf_le_succ'", "code": "theorem iInf_le_succ' (u : \u2115 \u2192 \u03b1) (n : \u2115) : \u2a05 k \u2264 n + 1, u k = u 0 \u2293 \u2a05 k \u2264 n, u (k + 1)", "start": [211, 1], "end": [212, 27], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_lt_succ", "code": "theorem biUnion_lt_succ (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c3 k < n + 1, u k = (\u22c3 k < n, u k) \u222a u n", "start": [222, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_lt_succ'", "code": "theorem biUnion_lt_succ' (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c3 k < n + 1, u k = u 0 \u222a \u22c3 k < n, u (k + 1)", "start": [226, 1], "end": [227, 24], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_lt_succ", "code": "theorem biInter_lt_succ (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c2 k < n + 1, u k = (\u22c2 k < n, u k) \u2229 u n", "start": [230, 1], "end": [231, 23], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_lt_succ'", "code": "theorem biInter_lt_succ' (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c2 k < n + 1, u k = u 0 \u2229 \u22c2 k < n, u (k + 1)", "start": [234, 1], "end": [235, 24], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_le_succ", "code": "theorem biUnion_le_succ (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c3 k \u2264 n + 1, u k = (\u22c3 k \u2264 n, u k) \u222a u (n + 1)", "start": [238, 1], "end": [239, 23], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_le_succ'", "code": "theorem biUnion_le_succ' (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c3 k \u2264 n + 1, u k = u 0 \u222a \u22c3 k \u2264 n, u (k + 1)", "start": [241, 1], "end": [242, 24], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_le_succ", "code": "theorem biInter_le_succ (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c2 k \u2264 n + 1, u k = (\u22c2 k \u2264 n, u k) \u2229 u (n + 1)", "start": [244, 1], "end": [245, 23], "kind": "commanddeclaration"}, {"full_name": "Set.biInter_le_succ'", "code": "theorem biInter_le_succ' (u : \u2115 \u2192 Set \u03b1) (n : \u2115) : \u22c2 k \u2264 n + 1, u k = u 0 \u2229 \u22c2 k \u2264 n, u (k + 1)", "start": [247, 1], "end": [248, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/TFAE.lean", "imports": ["Mathlib/Init/Data/List/Basic.lean", "Mathlib/Data/List/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.TFAE", "code": "def TFAE (l : List Prop) : Prop :=\n  \u2200 x \u2208 l, \u2200 y \u2208 l, x \u2194 y", "start": [22, 1], "end": [27, 26], "kind": "commanddeclaration"}, {"full_name": "List.tfae_nil", "code": "theorem tfae_nil : TFAE []", "start": [30, 1], "end": [31, 19], "kind": "commanddeclaration"}, {"full_name": "List.tfae_singleton", "code": "@[simp]\ntheorem tfae_singleton (p) : TFAE [p]", "start": [34, 1], "end": [35, 69], "kind": "commanddeclaration"}, {"full_name": "List.tfae_cons_of_mem", "code": "theorem tfae_cons_of_mem {a b} {l : List Prop} (h : b \u2208 l) : TFAE (a :: l) \u2194 (a \u2194 b) \u2227 TFAE l", "start": [38, 1], "end": [46, 29], "kind": "commanddeclaration"}, {"full_name": "List.tfae_cons_cons", "code": "theorem tfae_cons_cons {a b} {l : List Prop} : TFAE (a :: b :: l) \u2194 (a \u2194 b) \u2227 TFAE (b :: l)", "start": [49, 1], "end": [50, 32], "kind": "commanddeclaration"}, {"full_name": "List.tfae_cons_self", "code": "@[simp]\ntheorem tfae_cons_self {a} {l : List Prop} : TFAE (a :: a :: l) \u2194 TFAE (a :: l)", "start": [53, 1], "end": [55, 24], "kind": "commanddeclaration"}, {"full_name": "List.tfae_of_forall", "code": "theorem tfae_of_forall (b : Prop) (l : List Prop) (h : \u2200 a \u2208 l, a \u2194 b) : TFAE l", "start": [57, 1], "end": [58, 52], "kind": "commanddeclaration"}, {"full_name": "List.tfae_of_cycle", "code": "theorem tfae_of_cycle {a b} {l : List Prop} :\n    List.Chain (\u00b7 \u2192 \u00b7) a (b :: l) \u2192 (ilast' b l \u2192 a) \u2192 TFAE (a :: b :: l)", "start": [61, 1], "end": [69, 77], "kind": "commanddeclaration"}, {"full_name": "List.TFAE.out", "code": "theorem TFAE.out {l} (h : TFAE l) (n\u2081 n\u2082) {a b} (h\u2081 : List.get? l n\u2081 = some a := by rfl)\n    (h\u2082 : List.get? l n\u2082 = some b := by rfl) : a \u2194 b", "start": [72, 1], "end": [74, 46], "kind": "commanddeclaration"}, {"full_name": "List.forall_tfae", "code": "theorem forall_tfae {\u03b1 : Type*} (l : List (\u03b1 \u2192 Prop)) (H : \u2200 a : \u03b1, (l.map (fun p \u21a6 p a)).TFAE) :\n    (l.map (fun p \u21a6 \u2200 a, p a)).TFAE", "start": [77, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "List.exists_tfae", "code": "theorem exists_tfae {\u03b1 : Type*} (l : List (\u03b1 \u2192 Prop)) (H : \u2200 a : \u03b1, (l.map (fun p \u21a6 p a)).TFAE) :\n    (l.map (fun p \u21a6 \u2203 a, p a)).TFAE", "start": [96, 1], "end": [113, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/UpperLower/Basic.lean", "imports": ["Mathlib/Data/Set/Intervals/OrdConnected.lean", "Mathlib/Data/SetLike/Basic.lean", "Mathlib/Data/Set/Intervals/OrderIso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsUpperSet", "code": "@[aesop norm unfold]\ndef IsUpperSet (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a b : \u03b1\u2984, a \u2264 b \u2192 a \u2208 s \u2192 b \u2208 s", "start": [57, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet", "code": "@[aesop norm unfold]\ndef IsLowerSet (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a b : \u03b1\u2984, b \u2264 a \u2192 a \u2208 s \u2192 b \u2208 s", "start": [64, 1], "end": [68, 37], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_empty", "code": "theorem isUpperSet_empty : IsUpperSet (\u2205 : Set \u03b1)", "start": [71, 1], "end": [71, 69], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_empty", "code": "theorem isLowerSet_empty : IsLowerSet (\u2205 : Set \u03b1)", "start": [74, 1], "end": [74, 69], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_univ", "code": "theorem isUpperSet_univ : IsUpperSet (univ : Set \u03b1)", "start": [77, 1], "end": [77, 71], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_univ", "code": "theorem isLowerSet_univ : IsLowerSet (univ : Set \u03b1)", "start": [80, 1], "end": [80, 71], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.compl", "code": "theorem IsUpperSet.compl (hs : IsUpperSet s) : IsLowerSet s\u1d9c", "start": [83, 1], "end": [83, 99], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.compl", "code": "theorem IsLowerSet.compl (hs : IsLowerSet s) : IsUpperSet s\u1d9c", "start": [86, 1], "end": [86, 99], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_compl", "code": "@[simp]\ntheorem isUpperSet_compl : IsUpperSet s\u1d9c \u2194 IsLowerSet s", "start": [89, 1], "end": [93, 40], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_compl", "code": "@[simp]\ntheorem isLowerSet_compl : IsLowerSet s\u1d9c \u2194 IsUpperSet s", "start": [96, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.union", "code": "theorem IsUpperSet.union (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s \u222a t)", "start": [103, 1], "end": [104, 36], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.union", "code": "theorem IsLowerSet.union (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s \u222a t)", "start": [107, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.inter", "code": "theorem IsUpperSet.inter (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s \u2229 t)", "start": [111, 1], "end": [112, 37], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.inter", "code": "theorem IsLowerSet.inter (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s \u2229 t)", "start": [115, 1], "end": [116, 37], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_sUnion", "code": "theorem isUpperSet_sUnion {S : Set (Set \u03b1)} (hf : \u2200 s \u2208 S, IsUpperSet s) : IsUpperSet (\u22c3\u2080 S)", "start": [119, 1], "end": [120, 63], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_sUnion", "code": "theorem isLowerSet_sUnion {S : Set (Set \u03b1)} (hf : \u2200 s \u2208 S, IsLowerSet s) : IsLowerSet (\u22c3\u2080 S)", "start": [123, 1], "end": [124, 63], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iUnion", "code": "theorem isUpperSet_iUnion {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsUpperSet (f i)) : IsUpperSet (\u22c3 i, f i)", "start": [127, 1], "end": [128, 45], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iUnion", "code": "theorem isLowerSet_iUnion {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsLowerSet (f i)) : IsLowerSet (\u22c3 i, f i)", "start": [131, 1], "end": [132, 45], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iUnion\u2082", "code": "theorem isUpperSet_iUnion\u2082 {f : \u2200 i, \u03ba i \u2192 Set \u03b1} (hf : \u2200 i j, IsUpperSet (f i j)) :\n    IsUpperSet (\u22c3 (i) (j), f i j)", "start": [135, 1], "end": [137, 55], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iUnion\u2082", "code": "theorem isLowerSet_iUnion\u2082 {f : \u2200 i, \u03ba i \u2192 Set \u03b1} (hf : \u2200 i j, IsLowerSet (f i j)) :\n    IsLowerSet (\u22c3 (i) (j), f i j)", "start": [140, 1], "end": [142, 55], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_sInter", "code": "theorem isUpperSet_sInter {S : Set (Set \u03b1)} (hf : \u2200 s \u2208 S, IsUpperSet s) : IsUpperSet (\u22c2\u2080 S)", "start": [145, 1], "end": [146, 49], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_sInter", "code": "theorem isLowerSet_sInter {S : Set (Set \u03b1)} (hf : \u2200 s \u2208 S, IsLowerSet s) : IsLowerSet (\u22c2\u2080 S)", "start": [149, 1], "end": [150, 49], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iInter", "code": "theorem isUpperSet_iInter {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsUpperSet (f i)) : IsUpperSet (\u22c2 i, f i)", "start": [153, 1], "end": [154, 45], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iInter", "code": "theorem isLowerSet_iInter {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsLowerSet (f i)) : IsLowerSet (\u22c2 i, f i)", "start": [157, 1], "end": [158, 45], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iInter\u2082", "code": "theorem isUpperSet_iInter\u2082 {f : \u2200 i, \u03ba i \u2192 Set \u03b1} (hf : \u2200 i j, IsUpperSet (f i j)) :\n    IsUpperSet (\u22c2 (i) (j), f i j)", "start": [161, 1], "end": [163, 55], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iInter\u2082", "code": "theorem isLowerSet_iInter\u2082 {f : \u2200 i, \u03ba i \u2192 Set \u03b1} (hf : \u2200 i j, IsLowerSet (f i j)) :\n    IsLowerSet (\u22c2 (i) (j), f i j)", "start": [166, 1], "end": [168, 55], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_preimage_ofDual_iff", "code": "@[simp]\ntheorem isLowerSet_preimage_ofDual_iff : IsLowerSet (ofDual \u207b\u00b9' s) \u2194 IsUpperSet s", "start": [171, 1], "end": [173, 10], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_preimage_ofDual_iff", "code": "@[simp]\ntheorem isUpperSet_preimage_ofDual_iff : IsUpperSet (ofDual \u207b\u00b9' s) \u2194 IsLowerSet s", "start": [176, 1], "end": [178, 10], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_preimage_toDual_iff", "code": "@[simp]\ntheorem isLowerSet_preimage_toDual_iff {s : Set \u03b1\u1d52\u1d48} : IsLowerSet (toDual \u207b\u00b9' s) \u2194 IsUpperSet s", "start": [181, 1], "end": [183, 10], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_preimage_toDual_iff", "code": "@[simp]\ntheorem isUpperSet_preimage_toDual_iff {s : Set \u03b1\u1d52\u1d48} : IsUpperSet (toDual \u207b\u00b9' s) \u2194 IsLowerSet s", "start": [186, 1], "end": [188, 10], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.toDual", "code": "alias \u27e8_, IsUpperSet.toDual\u27e9 := isLowerSet_preimage_ofDual_iff", "start": [191, 1], "end": [191, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsLowerSet.toDual", "code": "alias \u27e8_, IsLowerSet.toDual\u27e9 := isUpperSet_preimage_ofDual_iff", "start": [194, 1], "end": [194, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsUpperSet.ofDual", "code": "alias \u27e8_, IsUpperSet.ofDual\u27e9 := isLowerSet_preimage_toDual_iff", "start": [197, 1], "end": [197, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsLowerSet.ofDual", "code": "alias \u27e8_, IsLowerSet.ofDual\u27e9 := isUpperSet_preimage_toDual_iff", "start": [200, 1], "end": [200, 63], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsUpperSet.isLowerSet_preimage_coe", "code": "lemma IsUpperSet.isLowerSet_preimage_coe (hs : IsUpperSet s) :\n    IsLowerSet ((\u2191) \u207b\u00b9' t : Set s) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t := by aesop", "start": [203, 1], "end": [204, 81], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.isUpperSet_preimage_coe", "code": "lemma IsLowerSet.isUpperSet_preimage_coe (hs : IsLowerSet s) :\n    IsUpperSet ((\u2191) \u207b\u00b9' t : Set s) \u2194 \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t := by aesop", "start": [206, 1], "end": [207, 81], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.sdiff", "code": "lemma IsUpperSet.sdiff (hs : IsUpperSet s) (ht : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t) :\n    IsUpperSet (s \\ t) :=\n  fun _b _c hbc hb \u21a6 \u27e8hs hbc hb.1, fun hc \u21a6 hb.2 $ ht _ hb.1 _ hc hbc\u27e9", "start": [209, 1], "end": [211, 71], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.sdiff", "code": "lemma IsLowerSet.sdiff (hs : IsLowerSet s) (ht : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t) :\n    IsLowerSet (s \\ t) :=\n  fun _b _c hcb hb \u21a6 \u27e8hs hcb hb.1, fun hc \u21a6 hb.2 $ ht _ hb.1 _ hc hcb\u27e9", "start": [213, 1], "end": [215, 71], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.sdiff_of_isLowerSet", "code": "lemma IsUpperSet.sdiff_of_isLowerSet (hs : IsUpperSet s) (ht : IsLowerSet t) : IsUpperSet (s \\ t) :=\n  hs.sdiff $ by aesop", "start": [217, 1], "end": [218, 22], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.sdiff_of_isUpperSet", "code": "lemma IsLowerSet.sdiff_of_isUpperSet (hs : IsLowerSet s) (ht : IsUpperSet t) : IsLowerSet (s \\ t) :=\n  hs.sdiff $ by aesop", "start": [220, 1], "end": [221, 22], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.erase", "code": "lemma IsUpperSet.erase (hs : IsUpperSet s) (has : \u2200 b \u2208 s, b \u2264 a \u2192 b = a) : IsUpperSet (s \\ {a}) :=\n  hs.sdiff $ by simpa using has", "start": [223, 1], "end": [224, 32], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.erase", "code": "lemma IsLowerSet.erase (hs : IsLowerSet s) (has : \u2200 b \u2208 s, a \u2264 b \u2192 b = a) : IsLowerSet (s \\ {a}) :=\n  hs.sdiff $ by simpa using has", "start": [226, 1], "end": [227, 32], "kind": "mathlibtacticlemma"}, {"full_name": "isUpperSet_Ici", "code": "theorem isUpperSet_Ici : IsUpperSet (Ici a)", "start": [235, 1], "end": [235, 67], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_Iic", "code": "theorem isLowerSet_Iic : IsLowerSet (Iic a)", "start": [238, 1], "end": [238, 67], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_Ioi", "code": "theorem isUpperSet_Ioi : IsUpperSet (Ioi a)", "start": [241, 1], "end": [241, 78], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_Iio", "code": "theorem isLowerSet_Iio : IsLowerSet (Iio a)", "start": [244, 1], "end": [244, 73], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iff_Ici_subset", "code": "theorem isUpperSet_iff_Ici_subset : IsUpperSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Ici a \u2286 s", "start": [247, 1], "end": [248, 54], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iff_Iic_subset", "code": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iic a \u2286 s", "start": [251, 1], "end": [252, 54], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.Ici_subset", "code": "alias \u27e8IsUpperSet.Ici_subset, _\u27e9 := isUpperSet_iff_Ici_subset", "start": [255, 1], "end": [255, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsLowerSet.Iic_subset", "code": "alias \u27e8IsLowerSet.Iic_subset, _\u27e9 := isLowerSet_iff_Iic_subset", "start": [258, 1], "end": [258, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsUpperSet.ordConnected", "code": "theorem IsUpperSet.ordConnected (h : IsUpperSet s) : s.OrdConnected", "start": [261, 1], "end": [262, 65], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.ordConnected", "code": "theorem IsLowerSet.ordConnected (h : IsLowerSet s) : s.OrdConnected", "start": [265, 1], "end": [266, 65], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.preimage", "code": "theorem IsUpperSet.preimage (hs : IsUpperSet s) {f : \u03b2 \u2192 \u03b1} (hf : Monotone f) :\n    IsUpperSet (f \u207b\u00b9' s : Set \u03b2)", "start": [269, 1], "end": [270, 60], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.preimage", "code": "theorem IsLowerSet.preimage (hs : IsLowerSet s) {f : \u03b2 \u2192 \u03b1} (hf : Monotone f) :\n    IsLowerSet (f \u207b\u00b9' s : Set \u03b2)", "start": [273, 1], "end": [274, 60], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.image", "code": "theorem IsUpperSet.image (hs : IsUpperSet s) (f : \u03b1 \u2243o \u03b2) : IsUpperSet (f '' s : Set \u03b2)", "start": [277, 1], "end": [280, 36], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.image", "code": "theorem IsLowerSet.image (hs : IsLowerSet s) (f : \u03b1 \u2243o \u03b2) : IsLowerSet (f '' s : Set \u03b2)", "start": [283, 1], "end": [286, 36], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_mem", "code": "@[simp]\ntheorem Set.monotone_mem : Monotone (\u00b7 \u2208 s) \u2194 IsUpperSet s", "start": [289, 1], "end": [291, 10], "kind": "commanddeclaration"}, {"full_name": "Set.antitone_mem", "code": "@[simp]\ntheorem Set.antitone_mem : Antitone (\u00b7 \u2208 s) \u2194 IsLowerSet s", "start": [294, 1], "end": [296, 14], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_setOf", "code": "@[simp]\ntheorem isUpperSet_setOf : IsUpperSet { a | p a } \u2194 Monotone p", "start": [299, 1], "end": [301, 10], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_setOf", "code": "@[simp]\ntheorem isLowerSet_setOf : IsLowerSet { a | p a } \u2194 Antitone p", "start": [304, 1], "end": [306, 14], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.top_mem", "code": "theorem IsLowerSet.top_mem (hs : IsLowerSet s) : \u22a4 \u2208 s \u2194 s = univ", "start": [313, 1], "end": [314, 82], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.top_mem", "code": "theorem IsUpperSet.top_mem (hs : IsUpperSet s) : \u22a4 \u2208 s \u2194 s.Nonempty", "start": [317, 1], "end": [318, 50], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.not_top_mem", "code": "theorem IsUpperSet.not_top_mem (hs : IsUpperSet s) : \u22a4 \u2209 s \u2194 s = \u2205", "start": [321, 1], "end": [322, 49], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.bot_mem", "code": "theorem IsUpperSet.bot_mem (hs : IsUpperSet s) : \u22a5 \u2208 s \u2194 s = univ", "start": [331, 1], "end": [332, 82], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.bot_mem", "code": "theorem IsLowerSet.bot_mem (hs : IsLowerSet s) : \u22a5 \u2208 s \u2194 s.Nonempty", "start": [335, 1], "end": [336, 50], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.not_bot_mem", "code": "theorem IsLowerSet.not_bot_mem (hs : IsLowerSet s) : \u22a5 \u2209 s \u2194 s = \u2205", "start": [339, 1], "end": [340, 49], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.not_bddAbove", "code": "theorem IsUpperSet.not_bddAbove (hs : IsUpperSet s) : s.Nonempty \u2192 \u00acBddAbove s", "start": [349, 1], "end": [352, 54], "kind": "commanddeclaration"}, {"full_name": "not_bddAbove_Ici", "code": "theorem not_bddAbove_Ici : \u00acBddAbove (Ici a)", "start": [355, 1], "end": [356, 47], "kind": "commanddeclaration"}, {"full_name": "not_bddAbove_Ioi", "code": "theorem not_bddAbove_Ioi : \u00acBddAbove (Ioi a)", "start": [359, 1], "end": [360, 47], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.not_bddBelow", "code": "theorem IsLowerSet.not_bddBelow (hs : IsLowerSet s) : s.Nonempty \u2192 \u00acBddBelow s", "start": [369, 1], "end": [372, 55], "kind": "commanddeclaration"}, {"full_name": "not_bddBelow_Iic", "code": "theorem not_bddBelow_Iic : \u00acBddBelow (Iic a)", "start": [375, 1], "end": [376, 47], "kind": "commanddeclaration"}, {"full_name": "not_bddBelow_Iio", "code": "theorem not_bddBelow_Iio : \u00acBddBelow (Iio a)", "start": [379, 1], "end": [380, 47], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iff_forall_lt", "code": "theorem isUpperSet_iff_forall_lt : IsUpperSet s \u2194 \u2200 \u2983a b : \u03b1\u2984, a < b \u2192 a \u2208 s \u2192 b \u2208 s", "start": [391, 1], "end": [392, 71], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iff_forall_lt", "code": "theorem isLowerSet_iff_forall_lt : IsLowerSet s \u2194 \u2200 \u2983a b : \u03b1\u2984, b < a \u2192 a \u2208 s \u2192 b \u2208 s", "start": [395, 1], "end": [396, 71], "kind": "commanddeclaration"}, {"full_name": "isUpperSet_iff_Ioi_subset", "code": "theorem isUpperSet_iff_Ioi_subset : IsUpperSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Ioi a \u2286 s", "start": [399, 1], "end": [400, 68], "kind": "commanddeclaration"}, {"full_name": "isLowerSet_iff_Iio_subset", "code": "theorem isLowerSet_iff_Iio_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iio a \u2286 s", "start": [403, 1], "end": [404, 68], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.Ioi_subset", "code": "alias \u27e8IsUpperSet.Ioi_subset, _\u27e9 := isUpperSet_iff_Ioi_subset", "start": [407, 1], "end": [407, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsLowerSet.Iio_subset", "code": "alias \u27e8IsLowerSet.Iio_subset, _\u27e9 := isLowerSet_iff_Iio_subset", "start": [410, 1], "end": [410, 62], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsUpperSet.total", "code": "theorem IsUpperSet.total (hs : IsUpperSet s) (ht : IsUpperSet t) : s \u2286 t \u2228 t \u2286 s", "start": [418, 1], "end": [424, 27], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.total", "code": "theorem IsLowerSet.total (hs : IsLowerSet s) (ht : IsLowerSet t) : s \u2286 t \u2228 t \u2286 s", "start": [427, 1], "end": [428, 28], "kind": "commanddeclaration"}, {"full_name": "UpperSet", "code": "structure UpperSet (\u03b1 : Type*) [LE \u03b1] where\n  \n  carrier : Set \u03b1\n  \n  upper' : IsUpperSet carrier", "start": [440, 1], "end": [445, 30], "kind": "commanddeclaration"}, {"full_name": "LowerSet", "code": "structure LowerSet (\u03b1 : Type*) [LE \u03b1] where\n  \n  carrier : Set \u03b1\n  \n  lower' : IsLowerSet carrier", "start": [448, 1], "end": [453, 30], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Simps.coe", "code": "def Simps.coe (s : UpperSet \u03b1) : Set \u03b1 := s", "start": [462, 1], "end": [463, 44], "kind": "commanddeclaration"}, {"full_name": "UpperSet.ext", "code": "@[ext]\ntheorem ext {s t : UpperSet \u03b1} : (s : Set \u03b1) = t \u2192 s = t", "start": [467, 1], "end": [469, 15], "kind": "commanddeclaration"}, {"full_name": "UpperSet.carrier_eq_coe", "code": "@[simp]\ntheorem carrier_eq_coe (s : UpperSet \u03b1) : s.carrier = s", "start": [472, 1], "end": [474, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.upper", "code": "@[simp] protected lemma upper (s : UpperSet \u03b1) : IsUpperSet (s : Set \u03b1) := s.upper'", "start": [477, 1], "end": [477, 84], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.coe_mk", "code": "@[simp, norm_cast] lemma coe_mk (s : Set \u03b1) (hs) : mk s hs = s := rfl", "start": [480, 1], "end": [480, 70], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.mem_mk", "code": "@[simp] lemma mem_mk {s : Set \u03b1} (hs) {a : \u03b1} : a \u2208 mk s hs \u2194 a \u2208 s := Iff.rfl", "start": [481, 1], "end": [481, 79], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Simps.coe", "code": "def Simps.coe (s : LowerSet \u03b1) : Set \u03b1 := s", "start": [492, 1], "end": [493, 44], "kind": "commanddeclaration"}, {"full_name": "LowerSet.ext", "code": "@[ext]\ntheorem ext {s t : LowerSet \u03b1} : (s : Set \u03b1) = t \u2192 s = t", "start": [497, 1], "end": [499, 15], "kind": "commanddeclaration"}, {"full_name": "LowerSet.carrier_eq_coe", "code": "@[simp]\ntheorem carrier_eq_coe (s : LowerSet \u03b1) : s.carrier = s", "start": [502, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.lower", "code": "@[simp] protected lemma lower (s : LowerSet \u03b1) : IsLowerSet (s : Set \u03b1) := s.lower'", "start": [507, 1], "end": [507, 84], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.coe_mk", "code": "@[simp, norm_cast] lemma coe_mk (s : Set \u03b1) (hs) : mk s hs = s := rfl", "start": [510, 1], "end": [510, 70], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.mem_mk", "code": "@[simp] lemma mem_mk {s : Set \u03b1} (hs) {a : \u03b1} : a \u2208 mk s hs \u2194 a \u2208 s := Iff.rfl", "start": [511, 1], "end": [511, 79], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.completelyDistribLattice", "code": "instance completelyDistribLattice : CompletelyDistribLattice (UpperSet \u03b1) :=\n  (toDual.injective.comp SetLike.coe_injective).completelyDistribLattice _ (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl) rfl rfl", "start": [540, 1], "end": [542, 59], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_subset_coe", "code": "@[simp 1100, norm_cast]\ntheorem coe_subset_coe : (s : Set \u03b1) \u2286 t \u2194 t \u2264 s", "start": [547, 1], "end": [549, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_ssubset_coe", "code": "@[simp 1100, norm_cast] lemma coe_ssubset_coe : (s : Set \u03b1) \u2282 t \u2194 t < s := Iff.rfl", "start": [552, 1], "end": [552, 83], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : UpperSet \u03b1) : Set \u03b1) = \u2205", "start": [554, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : UpperSet \u03b1) : Set \u03b1) = univ", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_eq_univ", "code": "@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set \u03b1) = univ \u2194 s = \u22a5", "start": [564, 1], "end": [565, 79], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_eq_empty", "code": "@[simp, norm_cast]\ntheorem coe_eq_empty : (s : Set \u03b1) = \u2205 \u2194 s = \u22a4", "start": [568, 1], "end": [569, 77], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_nonempty", "code": "@[simp, norm_cast] lemma coe_nonempty : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a4 :=\n  nonempty_iff_ne_empty.trans coe_eq_empty.not", "start": [572, 1], "end": [573, 47], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (s t : UpperSet \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = (s : Set \u03b1) \u2229 t", "start": [575, 1], "end": [577, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : UpperSet \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = (s : Set \u03b1) \u222a t", "start": [580, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_sSup", "code": "@[simp, norm_cast]\ntheorem coe_sSup (S : Set (UpperSet \u03b1)) : (\u2191(sSup S) : Set \u03b1) = \u22c2 s \u2208 S, \u2191s", "start": [585, 1], "end": [587, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (UpperSet \u03b1)) : (\u2191(sInf S) : Set \u03b1) = \u22c3 s \u2208 S, \u2191s", "start": [590, 1], "end": [592, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_iSup", "code": "@[simp, norm_cast]\ntheorem coe_iSup (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2191(\u2a06 i, f i) : Set \u03b1) = \u22c2 i, f i", "start": [595, 1], "end": [596, 91], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2191(\u2a05 i, f i) : Set \u03b1) = \u22c3 i, f i", "start": [599, 1], "end": [600, 91], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_iSup\u2082", "code": "@[norm_cast] theorem coe_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) : (\u2191(\u2a06 (i) (j), f i j) : Set \u03b1) = \u22c2 (i) (j), f i j", "start": [603, 1], "end": [605, 24], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_iInf\u2082", "code": "@[norm_cast] theorem coe_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) : (\u2191(\u2a05 (i) (j), f i j) : Set \u03b1) = \u22c3 (i) (j), f i j", "start": [608, 1], "end": [610, 24], "kind": "commanddeclaration"}, {"full_name": "UpperSet.not_mem_top", "code": "@[simp]\ntheorem not_mem_top : a \u2209 (\u22a4 : UpperSet \u03b1)", "start": [613, 1], "end": [615, 5], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_bot", "code": "@[simp]\ntheorem mem_bot : a \u2208 (\u22a5 : UpperSet \u03b1)", "start": [618, 1], "end": [620, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_sup_iff", "code": "@[simp]\ntheorem mem_sup_iff : a \u2208 s \u2294 t \u2194 a \u2208 s \u2227 a \u2208 t", "start": [623, 1], "end": [625, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_inf_iff", "code": "@[simp]\ntheorem mem_inf_iff : a \u2208 s \u2293 t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [628, 1], "end": [630, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_sSup_iff", "code": "@[simp]\ntheorem mem_sSup_iff : a \u2208 sSup S \u2194 \u2200 s \u2208 S, a \u2208 s", "start": [633, 1], "end": [635, 14], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_sInf_iff", "code": "@[simp]\ntheorem mem_sInf_iff : a \u2208 sInf S \u2194 \u2203 s \u2208 S, a \u2208 s", "start": [638, 1], "end": [640, 67], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_iSup_iff", "code": "@[simp]\ntheorem mem_iSup_iff {f : \u03b9 \u2192 UpperSet \u03b1} : (a \u2208 \u2a06 i, f i) \u2194 \u2200 i, a \u2208 f i", "start": [643, 1], "end": [646, 19], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_iInf_iff", "code": "@[simp]\ntheorem mem_iInf_iff {f : \u03b9 \u2192 UpperSet \u03b1} : (a \u2208 \u2a05 i, f i) \u2194 \u2203 i, a \u2208 f i", "start": [649, 1], "end": [652, 19], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_iSup\u2082_iff", "code": "theorem mem_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1} : (a \u2208 \u2a06 (i) (j), f i j) \u2194 \u2200 i j, a \u2208 f i j", "start": [656, 1], "end": [657, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_iInf\u2082_iff", "code": "theorem mem_iInf\u2082_iff {f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1} : (a \u2208 \u2a05 (i) (j), f i j) \u2194 \u2203 i j, a \u2208 f i j", "start": [661, 1], "end": [662, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.codisjoint_coe", "code": "@[simp, norm_cast]\ntheorem codisjoint_coe : Codisjoint (s : Set \u03b1) t \u2194 Disjoint s t", "start": [665, 1], "end": [667, 56], "kind": "commanddeclaration"}, {"full_name": "LowerSet.completelyDistribLattice", "code": "instance completelyDistribLattice : CompletelyDistribLattice (LowerSet \u03b1) :=\n  SetLike.coe_injective.completelyDistribLattice _ (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ => rfl) rfl rfl", "start": [694, 1], "end": [696, 27], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_subset_coe", "code": "@[norm_cast] lemma coe_subset_coe : (s : Set \u03b1) \u2286 t \u2194 s \u2264 t := Iff.rfl", "start": [701, 1], "end": [701, 71], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.coe_ssubset_coe", "code": "@[norm_cast] lemma coe_ssubset_coe : (s : Set \u03b1) \u2282 t \u2194 s < t := Iff.rfl", "start": [704, 1], "end": [704, 72], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.coe_top", "code": "@[simp, norm_cast]\ntheorem coe_top : ((\u22a4 : LowerSet \u03b1) : Set \u03b1) = univ", "start": [706, 1], "end": [708, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_bot", "code": "@[simp, norm_cast]\ntheorem coe_bot : ((\u22a5 : LowerSet \u03b1) : Set \u03b1) = \u2205", "start": [711, 1], "end": [713, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_eq_univ", "code": "@[simp, norm_cast]\ntheorem coe_eq_univ : (s : Set \u03b1) = univ \u2194 s = \u22a4", "start": [716, 1], "end": [717, 79], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_eq_empty", "code": "@[simp, norm_cast]\ntheorem coe_eq_empty : (s : Set \u03b1) = \u2205 \u2194 s = \u22a5", "start": [720, 1], "end": [721, 77], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_nonempty", "code": "@[simp, norm_cast] lemma coe_nonempty : (s : Set \u03b1).Nonempty \u2194 s \u2260 \u22a5 :=\n  nonempty_iff_ne_empty.trans coe_eq_empty.not", "start": [724, 1], "end": [725, 47], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (s t : LowerSet \u03b1) : (\u2191(s \u2294 t) : Set \u03b1) = (s : Set \u03b1) \u222a t", "start": [727, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (s t : LowerSet \u03b1) : (\u2191(s \u2293 t) : Set \u03b1) = (s : Set \u03b1) \u2229 t", "start": [732, 1], "end": [734, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_sSup", "code": "@[simp, norm_cast]\ntheorem coe_sSup (S : Set (LowerSet \u03b1)) : (\u2191(sSup S) : Set \u03b1) = \u22c3 s \u2208 S, \u2191s", "start": [737, 1], "end": [739, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (LowerSet \u03b1)) : (\u2191(sInf S) : Set \u03b1) = \u22c2 s \u2208 S, \u2191s", "start": [742, 1], "end": [744, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iSup", "code": "@[simp, norm_cast]\ntheorem coe_iSup (f : \u03b9 \u2192 LowerSet \u03b1) : (\u2191(\u2a06 i, f i) : Set \u03b1) = \u22c3 i, f i", "start": [747, 1], "end": [749, 72], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf (f : \u03b9 \u2192 LowerSet \u03b1) : (\u2191(\u2a05 i, f i) : Set \u03b1) = \u22c2 i, f i", "start": [752, 1], "end": [754, 72], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iSup\u2082", "code": "@[norm_cast] theorem coe_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) : (\u2191(\u2a06 (i) (j), f i j) : Set \u03b1) = \u22c3 (i) (j), f i j", "start": [757, 1], "end": [759, 24], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_iInf\u2082", "code": "@[norm_cast] theorem coe_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) : (\u2191(\u2a05 (i) (j), f i j) : Set \u03b1) = \u22c2 (i) (j), f i j", "start": [762, 1], "end": [764, 24], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_top", "code": "@[simp]\ntheorem mem_top : a \u2208 (\u22a4 : LowerSet \u03b1)", "start": [767, 1], "end": [769, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.not_mem_bot", "code": "@[simp]\ntheorem not_mem_bot : a \u2209 (\u22a5 : LowerSet \u03b1)", "start": [772, 1], "end": [774, 5], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_sup_iff", "code": "@[simp]\ntheorem mem_sup_iff : a \u2208 s \u2294 t \u2194 a \u2208 s \u2228 a \u2208 t", "start": [777, 1], "end": [779, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_inf_iff", "code": "@[simp]\ntheorem mem_inf_iff : a \u2208 s \u2293 t \u2194 a \u2208 s \u2227 a \u2208 t", "start": [782, 1], "end": [784, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_sSup_iff", "code": "@[simp]\ntheorem mem_sSup_iff : a \u2208 sSup S \u2194 \u2203 s \u2208 S, a \u2208 s", "start": [787, 1], "end": [789, 67], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_sInf_iff", "code": "@[simp]\ntheorem mem_sInf_iff : a \u2208 sInf S \u2194 \u2200 s \u2208 S, a \u2208 s", "start": [792, 1], "end": [794, 14], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_iSup_iff", "code": "@[simp]\ntheorem mem_iSup_iff {f : \u03b9 \u2192 LowerSet \u03b1} : (a \u2208 \u2a06 i, f i) \u2194 \u2203 i, a \u2208 f i", "start": [797, 1], "end": [800, 19], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_iInf_iff", "code": "@[simp]\ntheorem mem_iInf_iff {f : \u03b9 \u2192 LowerSet \u03b1} : (a \u2208 \u2a05 i, f i) \u2194 \u2200 i, a \u2208 f i", "start": [803, 1], "end": [806, 19], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_iSup\u2082_iff", "code": "theorem mem_iSup\u2082_iff {f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1} : (a \u2208 \u2a06 (i) (j), f i j) \u2194 \u2203 i j, a \u2208 f i j", "start": [810, 1], "end": [811, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_iInf\u2082_iff", "code": "theorem mem_iInf\u2082_iff {f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1} : (a \u2208 \u2a05 (i) (j), f i j) \u2194 \u2200 i j, a \u2208 f i j", "start": [815, 1], "end": [816, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSet.disjoint_coe", "code": "@[simp, norm_cast]\ntheorem disjoint_coe : Disjoint (s : Set \u03b1) t \u2194 Disjoint s t", "start": [819, 1], "end": [821, 40], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl", "code": "def UpperSet.compl (s : UpperSet \u03b1) : LowerSet \u03b1 :=\n  \u27e8s\u1d9c, s.upper.compl\u27e9", "start": [828, 1], "end": [830, 22], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl", "code": "def LowerSet.compl (s : LowerSet \u03b1) : UpperSet \u03b1 :=\n  \u27e8s\u1d9c, s.lower.compl\u27e9", "start": [833, 1], "end": [835, 22], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_compl", "code": "@[simp]\ntheorem coe_compl (s : UpperSet \u03b1) : (s.compl : Set \u03b1) = (\u2191s)\u1d9c", "start": [842, 1], "end": [844, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_compl_iff", "code": "@[simp]\ntheorem mem_compl_iff : a \u2208 s.compl \u2194 a \u2209 s", "start": [847, 1], "end": [849, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_compl", "code": "@[simp]\nnonrec theorem compl_compl (s : UpperSet \u03b1) : s.compl.compl = s", "start": [852, 1], "end": [854, 32], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_le_compl", "code": "@[simp]\ntheorem compl_le_compl : s.compl \u2264 t.compl \u2194 s \u2264 t", "start": [857, 1], "end": [859, 21], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_sup", "code": "@[simp]\nprotected theorem compl_sup (s t : UpperSet \u03b1) : (s \u2294 t).compl = s.compl \u2294 t.compl", "start": [862, 1], "end": [864, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_inf", "code": "@[simp]\nprotected theorem compl_inf (s t : UpperSet \u03b1) : (s \u2293 t).compl = s.compl \u2293 t.compl", "start": [867, 1], "end": [869, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_top", "code": "@[simp]\nprotected theorem compl_top : (\u22a4 : UpperSet \u03b1).compl = \u22a4", "start": [872, 1], "end": [874, 27], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_bot", "code": "@[simp]\nprotected theorem compl_bot : (\u22a5 : UpperSet \u03b1).compl = \u22a5", "start": [877, 1], "end": [879, 26], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_sSup", "code": "@[simp]\nprotected theorem compl_sSup (S : Set (UpperSet \u03b1)) : (sSup S).compl = \u2a06 s \u2208 S, UpperSet.compl s", "start": [882, 1], "end": [884, 88], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_sInf", "code": "@[simp]\nprotected theorem compl_sInf (S : Set (UpperSet \u03b1)) : (sInf S).compl = \u2a05 s \u2208 S, UpperSet.compl s", "start": [887, 1], "end": [889, 88], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_iSup", "code": "@[simp]\nprotected theorem compl_iSup (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2a06 i, f i).compl = \u2a06 i, (f i).compl", "start": [892, 1], "end": [894, 86], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_iInf", "code": "@[simp]\nprotected theorem compl_iInf (f : \u03b9 \u2192 UpperSet \u03b1) : (\u2a05 i, f i).compl = \u2a05 i, (f i).compl", "start": [897, 1], "end": [899, 86], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_iSup\u2082", "code": "theorem compl_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2a06 (i) (j), f i j).compl = \u2a06 (i) (j), (f i j).compl", "start": [903, 1], "end": [904, 92], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_iInf\u2082", "code": "theorem compl_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 UpperSet \u03b1) :\n    (\u2a05 (i) (j), f i j).compl = \u2a05 (i) (j), (f i j).compl", "start": [908, 1], "end": [909, 92], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_compl", "code": "@[simp]\ntheorem coe_compl (s : LowerSet \u03b1) : (s.compl : Set \u03b1) = (\u2191s)\u1d9c", "start": [918, 1], "end": [920, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_compl_iff", "code": "@[simp]\ntheorem mem_compl_iff : a \u2208 s.compl \u2194 a \u2209 s", "start": [923, 1], "end": [925, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_compl", "code": "@[simp]\nnonrec theorem compl_compl (s : LowerSet \u03b1) : s.compl.compl = s", "start": [928, 1], "end": [930, 32], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_le_compl", "code": "@[simp]\ntheorem compl_le_compl : s.compl \u2264 t.compl \u2194 s \u2264 t", "start": [933, 1], "end": [935, 21], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_sup", "code": "protected theorem compl_sup (s t : LowerSet \u03b1) : (s \u2294 t).compl = s.compl \u2294 t.compl", "start": [938, 1], "end": [939, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_inf", "code": "protected theorem compl_inf (s t : LowerSet \u03b1) : (s \u2293 t).compl = s.compl \u2293 t.compl", "start": [942, 1], "end": [943, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_top", "code": "protected theorem compl_top : (\u22a4 : LowerSet \u03b1).compl = \u22a4", "start": [946, 1], "end": [947, 26], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_bot", "code": "protected theorem compl_bot : (\u22a5 : LowerSet \u03b1).compl = \u22a5", "start": [950, 1], "end": [951, 27], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_sSup", "code": "protected theorem compl_sSup (S : Set (LowerSet \u03b1)) : (sSup S).compl = \u2a06 s \u2208 S, LowerSet.compl s", "start": [954, 1], "end": [955, 88], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_sInf", "code": "protected theorem compl_sInf (S : Set (LowerSet \u03b1)) : (sInf S).compl = \u2a05 s \u2208 S, LowerSet.compl s", "start": [958, 1], "end": [959, 88], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_iSup", "code": "protected theorem compl_iSup (f : \u03b9 \u2192 LowerSet \u03b1) : (\u2a06 i, f i).compl = \u2a06 i, (f i).compl", "start": [962, 1], "end": [963, 86], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_iInf", "code": "protected theorem compl_iInf (f : \u03b9 \u2192 LowerSet \u03b1) : (\u2a05 i, f i).compl = \u2a05 i, (f i).compl", "start": [966, 1], "end": [967, 86], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_iSup\u2082", "code": "@[simp]\ntheorem compl_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) :\n    (\u2a06 (i) (j), f i j).compl = \u2a06 (i) (j), (f i j).compl", "start": [970, 1], "end": [972, 92], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_iInf\u2082", "code": "@[simp]\ntheorem compl_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 LowerSet \u03b1) :\n    (\u2a05 (i) (j), f i j).compl = \u2a05 (i) (j), (f i j).compl", "start": [975, 1], "end": [977, 92], "kind": "commanddeclaration"}, {"full_name": "upperSetIsoLowerSet", "code": "@[simps]\ndef upperSetIsoLowerSet : UpperSet \u03b1 \u2243o LowerSet \u03b1\n    where\n  toFun := UpperSet.compl\n  invFun := LowerSet.compl\n  left_inv := UpperSet.compl_compl\n  right_inv := LowerSet.compl_compl\n  map_rel_iff' := UpperSet.compl_le_compl", "start": [982, 1], "end": [990, 42], "kind": "commanddeclaration"}, {"full_name": "UpperSet.isTotal_le", "code": "instance UpperSet.isTotal_le : IsTotal (UpperSet \u03b1) (\u00b7 \u2264 \u00b7) := \u27e8fun s t => t.upper.total s.upper\u27e9", "start": [998, 1], "end": [998, 98], "kind": "commanddeclaration"}, {"full_name": "LowerSet.isTotal_le", "code": "instance LowerSet.isTotal_le : IsTotal (LowerSet \u03b1) (\u00b7 \u2264 \u00b7) := \u27e8fun s t => s.lower.total t.lower\u27e9", "start": [1001, 1], "end": [1001, 98], "kind": "commanddeclaration"}, {"full_name": "UpperSet.map", "code": "def map (f : \u03b1 \u2243o \u03b2) : UpperSet \u03b1 \u2243o UpperSet \u03b2 where\n  toFun s := \u27e8f '' s, s.upper.image f\u27e9\n  invFun t := \u27e8f \u207b\u00b9' t, t.upper.preimage f.monotone\u27e9\n  left_inv _ := ext <| f.preimage_image _\n  right_inv _ := ext <| f.image_preimage _\n  map_rel_iff' := image_subset_image_iff f.injective", "start": [1031, 1], "end": [1037, 53], "kind": "commanddeclaration"}, {"full_name": "UpperSet.symm_map", "code": "@[simp]\ntheorem symm_map (f : \u03b1 \u2243o \u03b2) : (map f).symm = map f.symm", "start": [1040, 1], "end": [1042, 90], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_map", "code": "@[simp]\ntheorem mem_map : b \u2208 map f s \u2194 f.symm b \u2208 s", "start": [1045, 1], "end": [1048, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.map_refl", "code": "@[simp]\ntheorem map_refl : map (OrderIso.refl \u03b1) = OrderIso.refl _", "start": [1051, 1], "end": [1054, 7], "kind": "commanddeclaration"}, {"full_name": "UpperSet.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2243o \u03b3) (f : \u03b1 \u2243o \u03b2) : map g (map f s) = map (f.trans g) s", "start": [1057, 1], "end": [1060, 7], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map : (map f s : Set \u03b2) = f '' s", "start": [1065, 1], "end": [1067, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.map", "code": "def map (f : \u03b1 \u2243o \u03b2) : LowerSet \u03b1 \u2243o LowerSet \u03b2 where\n  toFun s := \u27e8f '' s, s.lower.image f\u27e9\n  invFun t := \u27e8f \u207b\u00b9' t, t.lower.preimage f.monotone\u27e9\n  left_inv _ := SetLike.coe_injective <| f.preimage_image _\n  right_inv _ := SetLike.coe_injective <| f.image_preimage _\n  map_rel_iff' := image_subset_image_iff f.injective", "start": [1076, 1], "end": [1082, 53], "kind": "commanddeclaration"}, {"full_name": "LowerSet.symm_map", "code": "@[simp]\ntheorem symm_map (f : \u03b1 \u2243o \u03b2) : (map f).symm = map f.symm", "start": [1085, 1], "end": [1087, 90], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_map", "code": "@[simp]\ntheorem mem_map {f : \u03b1 \u2243o \u03b2} {b : \u03b2} : b \u2208 map f s \u2194 f.symm b \u2208 s", "start": [1090, 1], "end": [1093, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.map_refl", "code": "@[simp]\ntheorem map_refl : map (OrderIso.refl \u03b1) = OrderIso.refl _", "start": [1096, 1], "end": [1099, 7], "kind": "commanddeclaration"}, {"full_name": "LowerSet.map_map", "code": "@[simp]\ntheorem map_map (g : \u03b2 \u2243o \u03b3) (f : \u03b1 \u2243o \u03b2) : map g (map f s) = map (f.trans g) s", "start": [1102, 1], "end": [1105, 7], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_map", "code": "@[simp, norm_cast]\ntheorem coe_map : (map f s : Set \u03b2) = f '' s", "start": [1110, 1], "end": [1112, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.compl_map", "code": "@[simp]\ntheorem compl_map (f : \u03b1 \u2243o \u03b2) (s : UpperSet \u03b1) : (map f s).compl = LowerSet.map f s.compl", "start": [1119, 1], "end": [1121, 62], "kind": "commanddeclaration"}, {"full_name": "LowerSet.compl_map", "code": "@[simp]\ntheorem compl_map (f : \u03b1 \u2243o \u03b2) (s : LowerSet \u03b1) : (map f s).compl = UpperSet.map f s.compl", "start": [1128, 1], "end": [1130, 62], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici", "code": "nonrec def Ici (a : \u03b1) : UpperSet \u03b1 :=\n  \u27e8Ici a, isUpperSet_Ici a\u27e9", "start": [1146, 1], "end": [1148, 28], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ioi", "code": "nonrec def Ioi (a : \u03b1) : UpperSet \u03b1 :=\n  \u27e8Ioi a, isUpperSet_Ioi a\u27e9", "start": [1151, 1], "end": [1153, 28], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_Ici", "code": "@[simp]\ntheorem coe_Ici (a : \u03b1) : \u2191(Ici a) = Set.Ici a", "start": [1156, 1], "end": [1158, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_Ioi", "code": "@[simp]\ntheorem coe_Ioi (a : \u03b1) : \u2191(Ioi a) = Set.Ioi a", "start": [1161, 1], "end": [1163, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_Ici_iff", "code": "@[simp]\ntheorem mem_Ici_iff : b \u2208 Ici a \u2194 a \u2264 b", "start": [1166, 1], "end": [1168, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_Ioi_iff", "code": "@[simp]\ntheorem mem_Ioi_iff : b \u2208 Ioi a \u2194 a < b", "start": [1171, 1], "end": [1173, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.map_Ici", "code": "@[simp]\ntheorem map_Ici (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Ici a) = Ici (f a)", "start": [1176, 1], "end": [1179, 7], "kind": "commanddeclaration"}, {"full_name": "UpperSet.map_Ioi", "code": "@[simp]\ntheorem map_Ioi (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Ioi a) = Ioi (f a)", "start": [1182, 1], "end": [1185, 7], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_le_Ioi", "code": "theorem Ici_le_Ioi (a : \u03b1) : Ici a \u2264 Ioi a", "start": [1188, 1], "end": [1189, 22], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_bot", "code": "@[simp]\nnonrec theorem Ici_bot [OrderBot \u03b1] : Ici (\u22a5 : \u03b1) = \u22a5", "start": [1192, 1], "end": [1194, 32], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ioi_top", "code": "@[simp]\nnonrec theorem Ioi_top [OrderTop \u03b1] : Ioi (\u22a4 : \u03b1) = \u22a4", "start": [1197, 1], "end": [1199, 32], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_ne_top", "code": "@[simp] lemma Ici_ne_top : Ici a \u2260 \u22a4 := SetLike.coe_ne_coe.1 nonempty_Ici.ne_empty", "start": [1202, 1], "end": [1202, 83], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_lt_top", "code": "@[simp] lemma Ici_lt_top : Ici a < \u22a4 := lt_top_iff_ne_top.2 Ici_ne_top", "start": [1203, 1], "end": [1203, 71], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.le_Ici", "code": "@[simp] lemma le_Ici : s \u2264 Ici a \u2194 a \u2208 s := \u27e8fun h \u21a6 h le_rfl, fun ha \u21a6 s.upper.Ici_subset ha\u27e9", "start": [1204, 1], "end": [1204, 95], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_injective", "code": "nonrec lemma Ici_injective : Injective (Ici : \u03b1 \u2192 UpperSet \u03b1) := fun _a _b hab \u21a6\n  Ici_injective $ congr_arg ((\u2191) : _ \u2192 Set \u03b1) hab", "start": [1211, 1], "end": [1212, 50], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_inj", "code": "@[simp] lemma Ici_inj : Ici a = Ici b \u2194 a = b := Ici_injective.eq_iff", "start": [1214, 1], "end": [1214, 70], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_ne_Ici", "code": "lemma Ici_ne_Ici : Ici a \u2260 Ici b \u2194 a \u2260 b := Ici_inj.not", "start": [1216, 1], "end": [1216, 56], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_sup", "code": "@[simp]\ntheorem Ici_sup [SemilatticeSup \u03b1] (a b : \u03b1) : Ici (a \u2294 b) = Ici a \u2294 Ici b", "start": [1220, 1], "end": [1222, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_sSup", "code": "@[simp]\ntheorem Ici_sSup (S : Set \u03b1) : Ici (sSup S) = \u2a06 a \u2208 S, Ici a", "start": [1229, 1], "end": [1231, 77], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_iSup", "code": "@[simp]\ntheorem Ici_iSup (f : \u03b9 \u2192 \u03b1) : Ici (\u2a06 i, f i) = \u2a06 i, Ici (f i)", "start": [1234, 1], "end": [1236, 77], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_iSup\u2082", "code": "theorem Ici_iSup\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Ici (\u2a06 (i) (j), f i j) = \u2a06 (i) (j), Ici (f i j)", "start": [1240, 1], "end": [1241, 21], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic", "code": "nonrec def Iic (a : \u03b1) : LowerSet \u03b1 :=\n  \u27e8Iic a, isLowerSet_Iic a\u27e9", "start": [1254, 1], "end": [1257, 28], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iio", "code": "nonrec def Iio (a : \u03b1) : LowerSet \u03b1 :=\n  \u27e8Iio a, isLowerSet_Iio a\u27e9", "start": [1260, 1], "end": [1262, 28], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_Iic", "code": "@[simp]\ntheorem coe_Iic (a : \u03b1) : \u2191(Iic a) = Set.Iic a", "start": [1265, 1], "end": [1267, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_Iio", "code": "@[simp]\ntheorem coe_Iio (a : \u03b1) : \u2191(Iio a) = Set.Iio a", "start": [1270, 1], "end": [1272, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_Iic_iff", "code": "@[simp]\ntheorem mem_Iic_iff : b \u2208 Iic a \u2194 b \u2264 a", "start": [1275, 1], "end": [1277, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_Iio_iff", "code": "@[simp]\ntheorem mem_Iio_iff : b \u2208 Iio a \u2194 b < a", "start": [1280, 1], "end": [1282, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.map_Iic", "code": "@[simp]\ntheorem map_Iic (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Iic a) = Iic (f a)", "start": [1285, 1], "end": [1288, 7], "kind": "commanddeclaration"}, {"full_name": "LowerSet.map_Iio", "code": "@[simp]\ntheorem map_Iio (f : \u03b1 \u2243o \u03b2) (a : \u03b1) : map f (Iio a) = Iio (f a)", "start": [1291, 1], "end": [1294, 7], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Ioi_le_Ici", "code": "theorem Ioi_le_Ici (a : \u03b1) : Ioi a \u2264 Ici a", "start": [1297, 1], "end": [1298, 22], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_top", "code": "@[simp]\nnonrec theorem Iic_top [OrderTop \u03b1] : Iic (\u22a4 : \u03b1) = \u22a4", "start": [1301, 1], "end": [1303, 32], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iio_bot", "code": "@[simp]\nnonrec theorem Iio_bot [OrderBot \u03b1] : Iio (\u22a5 : \u03b1) = \u22a5", "start": [1306, 1], "end": [1308, 32], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_ne_bot", "code": "@[simp] lemma Iic_ne_bot : Iic a \u2260 \u22a5 := SetLike.coe_ne_coe.1 nonempty_Iic.ne_empty", "start": [1311, 1], "end": [1311, 83], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.bot_lt_Iic", "code": "@[simp] lemma bot_lt_Iic : \u22a5 < Iic a := bot_lt_iff_ne_bot.2 Iic_ne_bot", "start": [1312, 1], "end": [1312, 71], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_le", "code": "@[simp] lemma Iic_le : Iic a \u2264 s \u2194 a \u2208 s := \u27e8fun h \u21a6 h le_rfl, fun ha \u21a6 s.lower.Iic_subset ha\u27e9", "start": [1313, 1], "end": [1313, 95], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_injective", "code": "nonrec lemma Iic_injective : Injective (Iic : \u03b1 \u2192 LowerSet \u03b1) := fun _a _b hab \u21a6\n  Iic_injective $ congr_arg ((\u2191) : _ \u2192 Set \u03b1) hab", "start": [1320, 1], "end": [1321, 50], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_inj", "code": "@[simp] lemma Iic_inj : Iic a = Iic b \u2194 a = b := Iic_injective.eq_iff", "start": [1323, 1], "end": [1323, 70], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_ne_Iic", "code": "lemma Iic_ne_Iic : Iic a \u2260 Iic b \u2194 a \u2260 b := Iic_inj.not", "start": [1325, 1], "end": [1325, 56], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_inf", "code": "@[simp]\ntheorem Iic_inf [SemilatticeInf \u03b1] (a b : \u03b1) : Iic (a \u2293 b) = Iic a \u2293 Iic b", "start": [1329, 1], "end": [1331, 43], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_sInf", "code": "@[simp]\ntheorem Iic_sInf (S : Set \u03b1) : Iic (sInf S) = \u2a05 a \u2208 S, Iic a", "start": [1338, 1], "end": [1340, 78], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_iInf", "code": "@[simp]\ntheorem Iic_iInf (f : \u03b9 \u2192 \u03b1) : Iic (\u2a05 i, f i) = \u2a05 i, Iic (f i)", "start": [1343, 1], "end": [1345, 77], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_iInf\u2082", "code": "theorem Iic_iInf\u2082 (f : \u2200 i, \u03ba i \u2192 \u03b1) : Iic (\u2a05 (i) (j), f i j) = \u2a05 (i) (j), Iic (f i j)", "start": [1349, 1], "end": [1350, 21], "kind": "commanddeclaration"}, {"full_name": "upperClosure", "code": "def upperClosure (s : Set \u03b1) : UpperSet \u03b1 :=\n  \u27e8{ x | \u2203 a \u2208 s, a \u2264 x }, fun _ _ hle h => h.imp fun _x hx => \u27e8hx.1, hx.2.trans hle\u27e9\u27e9", "start": [1361, 1], "end": [1363, 87], "kind": "commanddeclaration"}, {"full_name": "lowerClosure", "code": "def lowerClosure (s : Set \u03b1) : LowerSet \u03b1 :=\n  \u27e8{ x | \u2203 a \u2208 s, x \u2264 a }, fun _ _ hle h => h.imp fun _x hx => \u27e8hx.1, hle.trans hx.2\u27e9\u27e9", "start": [1366, 1], "end": [1368, 87], "kind": "commanddeclaration"}, {"full_name": "mem_upperClosure", "code": "@[simp]\ntheorem mem_upperClosure : x \u2208 upperClosure s \u2194 \u2203 a \u2208 s, a \u2264 x", "start": [1373, 1], "end": [1375, 10], "kind": "commanddeclaration"}, {"full_name": "mem_lowerClosure", "code": "@[simp]\ntheorem mem_lowerClosure : x \u2208 lowerClosure s \u2194 \u2203 a \u2208 s, x \u2264 a", "start": [1378, 1], "end": [1380, 10], "kind": "commanddeclaration"}, {"full_name": "coe_upperClosure", "code": "@[norm_cast]\ntheorem coe_upperClosure (s : Set \u03b1) : \u2191(upperClosure s) = \u22c3 a \u2208 s, Ici a", "start": [1384, 1], "end": [1387, 7], "kind": "commanddeclaration"}, {"full_name": "coe_lowerClosure", "code": "@[norm_cast]\ntheorem coe_lowerClosure (s : Set \u03b1) : \u2191(lowerClosure s) = \u22c3 a \u2208 s, Iic a", "start": [1390, 1], "end": [1393, 7], "kind": "commanddeclaration"}, {"full_name": "instDecidablePredMemUpperClosure", "code": "instance instDecidablePredMemUpperClosure [DecidablePred (\u2203 a \u2208 s, a \u2264 \u00b7)] :\n    DecidablePred (\u00b7 \u2208 upperClosure s) := \u2039DecidablePred _\u203a", "start": [1396, 1], "end": [1397, 60], "kind": "commanddeclaration"}, {"full_name": "instDecidablePredMemLowerClosure", "code": "instance instDecidablePredMemLowerClosure [DecidablePred (\u2203 a \u2208 s, \u00b7 \u2264 a)] :\n    DecidablePred (\u00b7 \u2208 lowerClosure s) := \u2039DecidablePred _\u203a", "start": [1399, 1], "end": [1400, 60], "kind": "commanddeclaration"}, {"full_name": "subset_upperClosure", "code": "theorem subset_upperClosure : s \u2286 upperClosure s", "start": [1402, 1], "end": [1402, 80], "kind": "commanddeclaration"}, {"full_name": "subset_lowerClosure", "code": "theorem subset_lowerClosure : s \u2286 lowerClosure s", "start": [1405, 1], "end": [1405, 80], "kind": "commanddeclaration"}, {"full_name": "upperClosure_min", "code": "theorem upperClosure_min (h : s \u2286 t) (ht : IsUpperSet t) : \u2191(upperClosure s) \u2286 t", "start": [1408, 1], "end": [1409, 41], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_min", "code": "theorem lowerClosure_min (h : s \u2286 t) (ht : IsLowerSet t) : \u2191(lowerClosure s) \u2286 t", "start": [1412, 1], "end": [1413, 41], "kind": "commanddeclaration"}, {"full_name": "IsUpperSet.upperClosure", "code": "protected theorem IsUpperSet.upperClosure (hs : IsUpperSet s) : \u2191(upperClosure s) = s", "start": [1416, 1], "end": [1417, 64], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.lowerClosure", "code": "protected theorem IsLowerSet.lowerClosure (hs : IsLowerSet s) : \u2191(lowerClosure s) = s", "start": [1420, 1], "end": [1421, 64], "kind": "commanddeclaration"}, {"full_name": "UpperSet.upperClosure", "code": "@[simp]\nprotected theorem UpperSet.upperClosure (s : UpperSet \u03b1) : upperClosure (s : Set \u03b1) = s", "start": [1424, 1], "end": [1426, 41], "kind": "commanddeclaration"}, {"full_name": "LowerSet.lowerClosure", "code": "@[simp]\nprotected theorem LowerSet.lowerClosure (s : LowerSet \u03b1) : lowerClosure (s : Set \u03b1) = s", "start": [1429, 1], "end": [1431, 41], "kind": "commanddeclaration"}, {"full_name": "upperClosure_image", "code": "@[simp]\ntheorem upperClosure_image (f : \u03b1 \u2243o \u03b2) :\n    upperClosure (f '' s) = UpperSet.map f (upperClosure s)", "start": [1434, 1], "end": [1439, 76], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_image", "code": "@[simp]\ntheorem lowerClosure_image (f : \u03b1 \u2243o \u03b2) :\n    lowerClosure (f '' s) = LowerSet.map f (lowerClosure s)", "start": [1442, 1], "end": [1447, 76], "kind": "commanddeclaration"}, {"full_name": "UpperSet.iInf_Ici", "code": "@[simp]\ntheorem UpperSet.iInf_Ici (s : Set \u03b1) : \u2a05 a \u2208 s, UpperSet.Ici a = upperClosure s", "start": [1450, 1], "end": [1453, 7], "kind": "commanddeclaration"}, {"full_name": "LowerSet.iSup_Iic", "code": "@[simp]\ntheorem LowerSet.iSup_Iic (s : Set \u03b1) : \u2a06 a \u2208 s, LowerSet.Iic a = lowerClosure s", "start": [1456, 1], "end": [1459, 7], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_le", "code": "@[simp] lemma lowerClosure_le {t : LowerSet \u03b1} : lowerClosure s \u2264 t \u2194 s \u2286 t :=\n  \u27e8fun h \u21a6 subset_lowerClosure.trans $ LowerSet.coe_subset_coe.2 h,\n    fun h \u21a6 lowerClosure_min h t.lower\u27e9", "start": [1462, 1], "end": [1464, 40], "kind": "mathlibtacticlemma"}, {"full_name": "le_upperClosure", "code": "@[simp] lemma le_upperClosure {s : UpperSet \u03b1} : s \u2264 upperClosure t \u2194 t \u2286 s :=\n  \u27e8fun h \u21a6 subset_upperClosure.trans $ UpperSet.coe_subset_coe.2 h,\n    fun h \u21a6 upperClosure_min h s.upper\u27e9", "start": [1466, 1], "end": [1468, 40], "kind": "mathlibtacticlemma"}, {"full_name": "gc_upperClosure_coe", "code": "theorem gc_upperClosure_coe :\n    GaloisConnection (toDual \u2218 upperClosure : Set \u03b1 \u2192 (UpperSet \u03b1)\u1d52\u1d48) ((\u2191) \u2218 ofDual)", "start": [1470, 1], "end": [1472, 30], "kind": "commanddeclaration"}, {"full_name": "gc_lowerClosure_coe", "code": "theorem gc_lowerClosure_coe :\n    GaloisConnection (lowerClosure : Set \u03b1 \u2192 LowerSet \u03b1) (\u2191)", "start": [1475, 1], "end": [1476, 92], "kind": "commanddeclaration"}, {"full_name": "giUpperClosureCoe", "code": "def giUpperClosureCoe :\n    GaloisInsertion (toDual \u2218 upperClosure : Set \u03b1 \u2192 (UpperSet \u03b1)\u1d52\u1d48) ((\u2191) \u2218 ofDual) where\n  choice s hs := toDual (\u27e8s, fun a _b hab ha => hs \u27e8a, ha, hab\u27e9\u27e9 : UpperSet \u03b1)\n  gc := gc_upperClosure_coe\n  le_l_u _ := subset_upperClosure\n  choice_eq _s hs := ofDual.injective <| SetLike.coe_injective <| subset_upperClosure.antisymm hs", "start": [1479, 1], "end": [1485, 98], "kind": "commanddeclaration"}, {"full_name": "giLowerClosureCoe", "code": "def giLowerClosureCoe : GaloisInsertion (lowerClosure : Set \u03b1 \u2192 LowerSet \u03b1) (\u2191) where\n  choice s hs := \u27e8s, fun a _b hba ha => hs \u27e8a, ha, hba\u27e9\u27e9\n  gc := gc_lowerClosure_coe\n  le_l_u _ := subset_lowerClosure\n  choice_eq _s hs := SetLike.coe_injective <| subset_lowerClosure.antisymm hs", "start": [1488, 1], "end": [1493, 78], "kind": "commanddeclaration"}, {"full_name": "upperClosure_anti", "code": "theorem upperClosure_anti : Antitone (upperClosure : Set \u03b1 \u2192 UpperSet \u03b1)", "start": [1496, 1], "end": [1497, 33], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_mono", "code": "theorem lowerClosure_mono : Monotone (lowerClosure : Set \u03b1 \u2192 LowerSet \u03b1)", "start": [1500, 1], "end": [1501, 33], "kind": "commanddeclaration"}, {"full_name": "upperClosure_empty", "code": "@[simp]\ntheorem upperClosure_empty : upperClosure (\u2205 : Set \u03b1) = \u22a4", "start": [1504, 1], "end": [1506, 33], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_empty", "code": "@[simp]\ntheorem lowerClosure_empty : lowerClosure (\u2205 : Set \u03b1) = \u22a5", "start": [1509, 1], "end": [1511, 33], "kind": "commanddeclaration"}, {"full_name": "upperClosure_singleton", "code": "@[simp]\ntheorem upperClosure_singleton (a : \u03b1) : upperClosure ({a} : Set \u03b1) = UpperSet.Ici a", "start": [1514, 1], "end": [1517, 7], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_singleton", "code": "@[simp]\ntheorem lowerClosure_singleton (a : \u03b1) : lowerClosure ({a} : Set \u03b1) = LowerSet.Iic a", "start": [1520, 1], "end": [1523, 7], "kind": "commanddeclaration"}, {"full_name": "upperClosure_univ", "code": "@[simp]\ntheorem upperClosure_univ : upperClosure (univ : Set \u03b1) = \u22a5", "start": [1526, 1], "end": [1528, 33], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_univ", "code": "@[simp]\ntheorem lowerClosure_univ : lowerClosure (univ : Set \u03b1) = \u22a4", "start": [1531, 1], "end": [1533, 33], "kind": "commanddeclaration"}, {"full_name": "upperClosure_eq_top_iff", "code": "@[simp]\ntheorem upperClosure_eq_top_iff : upperClosure s = \u22a4 \u2194 s = \u2205", "start": [1536, 1], "end": [1538, 61], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_eq_bot_iff", "code": "@[simp]\ntheorem lowerClosure_eq_bot_iff : lowerClosure s = \u22a5 \u2194 s = \u2205", "start": [1541, 1], "end": [1543, 61], "kind": "commanddeclaration"}, {"full_name": "upperClosure_union", "code": "@[simp]\ntheorem upperClosure_union (s t : Set \u03b1) : upperClosure (s \u222a t) = upperClosure s \u2293 upperClosure t", "start": [1546, 1], "end": [1548, 35], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_union", "code": "@[simp]\ntheorem lowerClosure_union (s t : Set \u03b1) : lowerClosure (s \u222a t) = lowerClosure s \u2294 lowerClosure t", "start": [1551, 1], "end": [1553, 35], "kind": "commanddeclaration"}, {"full_name": "upperClosure_iUnion", "code": "@[simp]\ntheorem upperClosure_iUnion (f : \u03b9 \u2192 Set \u03b1) : upperClosure (\u22c3 i, f i) = \u2a05 i, upperClosure (f i)", "start": [1556, 1], "end": [1558, 36], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_iUnion", "code": "@[simp]\ntheorem lowerClosure_iUnion (f : \u03b9 \u2192 Set \u03b1) : lowerClosure (\u22c3 i, f i) = \u2a06 i, lowerClosure (f i)", "start": [1561, 1], "end": [1563, 36], "kind": "commanddeclaration"}, {"full_name": "upperClosure_sUnion", "code": "@[simp]\ntheorem upperClosure_sUnion (S : Set (Set \u03b1)) : upperClosure (\u22c3\u2080 S) = \u2a05 s \u2208 S, upperClosure s", "start": [1566, 1], "end": [1568, 51], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_sUnion", "code": "@[simp]\ntheorem lowerClosure_sUnion (S : Set (Set \u03b1)) : lowerClosure (\u22c3\u2080 S) = \u2a06 s \u2208 S, lowerClosure s", "start": [1571, 1], "end": [1573, 51], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.upperClosure_inter_lowerClosure", "code": "theorem Set.OrdConnected.upperClosure_inter_lowerClosure (h : s.OrdConnected) :\n    \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s", "start": [1576, 1], "end": [1579, 66], "kind": "commanddeclaration"}, {"full_name": "ordConnected_iff_upperClosure_inter_lowerClosure", "code": "theorem ordConnected_iff_upperClosure_inter_lowerClosure :\n    s.OrdConnected \u2194 \u2191(upperClosure s) \u2229 \u2191(lowerClosure s) = s", "start": [1582, 1], "end": [1586, 78], "kind": "commanddeclaration"}, {"full_name": "upperBounds_lowerClosure", "code": "@[simp]\ntheorem upperBounds_lowerClosure : upperBounds (lowerClosure s : Set \u03b1) = upperBounds s", "start": [1589, 1], "end": [1591, 101], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_upperClosure", "code": "@[simp]\ntheorem lowerBounds_upperClosure : lowerBounds (upperClosure s : Set \u03b1) = lowerBounds s", "start": [1594, 1], "end": [1596, 100], "kind": "commanddeclaration"}, {"full_name": "bddAbove_lowerClosure", "code": "@[simp]\ntheorem bddAbove_lowerClosure : BddAbove (lowerClosure s : Set \u03b1) \u2194 BddAbove s", "start": [1599, 1], "end": [1601, 47], "kind": "commanddeclaration"}, {"full_name": "bddBelow_upperClosure", "code": "@[simp]\ntheorem bddBelow_upperClosure : BddBelow (upperClosure s : Set \u03b1) \u2194 BddBelow s", "start": [1604, 1], "end": [1606, 47], "kind": "commanddeclaration"}, {"full_name": "BddAbove.of_lowerClosure", "code": "protected alias \u27e8BddAbove.of_lowerClosure, BddAbove.lowerClosure\u27e9 := bddAbove_lowerClosure", "start": [1609, 1], "end": [1609, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "BddAbove.lowerClosure", "code": "protected alias \u27e8BddAbove.of_lowerClosure, BddAbove.lowerClosure\u27e9 := bddAbove_lowerClosure", "start": [1609, 1], "end": [1609, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "BddBelow.of_upperClosure", "code": "protected alias \u27e8BddBelow.of_upperClosure, BddBelow.upperClosure\u27e9 := bddBelow_upperClosure", "start": [1613, 1], "end": [1613, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "BddBelow.upperClosure", "code": "protected alias \u27e8BddBelow.of_upperClosure, BddBelow.upperClosure\u27e9 := bddBelow_upperClosure", "start": [1613, 1], "end": [1613, 91], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsLowerSet.disjoint_upperClosure_left", "code": "@[simp] lemma IsLowerSet.disjoint_upperClosure_left (ht : IsLowerSet t) :\n    Disjoint \u2191(upperClosure s) t \u2194 Disjoint s t := by\n  refine \u27e8Disjoint.mono_left subset_upperClosure, ?_\u27e9\n  simp only [disjoint_left, SetLike.mem_coe, mem_upperClosure, forall_exists_index, and_imp]\n  exact fun h a b hb hba ha \u21a6 h hb $ ht hba ha", "start": [1617, 1], "end": [1621, 47], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.disjoint_upperClosure_right", "code": "@[simp] lemma IsLowerSet.disjoint_upperClosure_right (hs : IsLowerSet s) :\n    Disjoint s (upperClosure t) \u2194 Disjoint s t := by\n  simpa only [disjoint_comm] using hs.disjoint_upperClosure_left", "start": [1623, 1], "end": [1625, 65], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.disjoint_lowerClosure_left", "code": "@[simp] lemma IsUpperSet.disjoint_lowerClosure_left (ht : IsUpperSet t) :\n    Disjoint \u2191(lowerClosure s) t \u2194 Disjoint s t := ht.toDual.disjoint_upperClosure_left", "start": [1627, 1], "end": [1628, 88], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.disjoint_lowerClosure_right", "code": "@[simp] lemma IsUpperSet.disjoint_lowerClosure_right (hs : IsUpperSet s) :\n    Disjoint s (lowerClosure t) \u2194 Disjoint s t := hs.toDual.disjoint_upperClosure_right", "start": [1630, 1], "end": [1631, 88], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff", "code": "def sdiff (s : LowerSet \u03b1) (t : Set \u03b1) : LowerSet \u03b1 where\n  carrier := s \\ upperClosure t\n  lower' := s.lower.sdiff_of_isUpperSet (upperClosure t).upper", "start": [1640, 1], "end": [1643, 63], "kind": "commanddeclaration"}, {"full_name": "LowerSet.erase", "code": "def erase (s : LowerSet \u03b1) (a : \u03b1) : LowerSet \u03b1 where\n  carrier := s \\ UpperSet.Ici a\n  lower' := s.lower.sdiff_of_isUpperSet (UpperSet.Ici a).upper", "start": [1645, 1], "end": [1648, 63], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_sdiff", "code": "@[simp, norm_cast]\nlemma coe_sdiff (s : LowerSet \u03b1) (t : Set \u03b1) : s.sdiff t = (s : Set \u03b1) \\ upperClosure t := rfl", "start": [1650, 1], "end": [1651, 95], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.coe_erase", "code": "@[simp, norm_cast]\nlemma coe_erase (s : LowerSet \u03b1) (a : \u03b1) : s.erase a = (s : Set \u03b1) \\ UpperSet.Ici a := rfl", "start": [1653, 1], "end": [1654, 91], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_singleton", "code": "@[simp] lemma sdiff_singleton (s : LowerSet \u03b1) (a : \u03b1) : s.sdiff {a} = s.erase a := by\n  simp [sdiff, erase]", "start": [1656, 1], "end": [1657, 22], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_le_left", "code": "lemma sdiff_le_left : s.sdiff t \u2264 s := diff_subset _ _", "start": [1659, 1], "end": [1659, 55], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.erase_le", "code": "lemma erase_le : s.erase a \u2264 s := diff_subset _ _", "start": [1660, 1], "end": [1660, 50], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_eq_left", "code": "@[simp] protected lemma sdiff_eq_left : s.sdiff t = s \u2194 Disjoint \u2191s t := by\n  simp [\u2190SetLike.coe_set_eq]", "start": [1662, 1], "end": [1663, 29], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.erase_eq", "code": "@[simp] lemma erase_eq : s.erase a = s \u2194 a \u2209 s := by rw [\u2190sdiff_singleton]; simp [-sdiff_singleton]", "start": [1665, 1], "end": [1665, 100], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_lt_left", "code": "@[simp] lemma sdiff_lt_left : s.sdiff t < s \u2194 \u00ac Disjoint \u2191s t :=\n  sdiff_le_left.lt_iff_ne.trans LowerSet.sdiff_eq_left.not", "start": [1667, 1], "end": [1668, 59], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.erase_lt", "code": "@[simp] lemma erase_lt : s.erase a < s \u2194 a \u2208 s := erase_le.lt_iff_ne.trans erase_eq.not_left", "start": [1670, 1], "end": [1670, 93], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_idem", "code": "@[simp] protected lemma sdiff_idem (s : LowerSet \u03b1) (t : Set \u03b1) : (s.sdiff t).sdiff t = s.sdiff t :=\n  SetLike.coe_injective sdiff_idem", "start": [1672, 1], "end": [1673, 35], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.erase_idem", "code": "@[simp] lemma erase_idem (s : LowerSet \u03b1) (a : \u03b1) : (s.erase a).erase a = s.erase a :=\n  SetLike.coe_injective sdiff_idem", "start": [1675, 1], "end": [1676, 35], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.sdiff_sup_lowerClosure", "code": "lemma sdiff_sup_lowerClosure (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t) :\n    s.sdiff t \u2294 lowerClosure t = s := by\n  refine' le_antisymm (sup_le sdiff_le_left $ lowerClosure_le.2 hts) fun a ha \u21a6 _\n  obtain hat | hat := em (a \u2208 t)\n  \u00b7 exact subset_union_right _ _ (subset_lowerClosure hat)\n  \u00b7 refine subset_union_left _ _ \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hba\u27e9\n    exact hat $ hst _ ha _ hb hba", "start": [1678, 1], "end": [1685, 34], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.lowerClosure_sup_sdiff", "code": "lemma lowerClosure_sup_sdiff (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, c \u2264 b \u2192 b \u2208 t) :\n    lowerClosure t \u2294 s.sdiff t = s := by rw [sup_comm, sdiff_sup_lowerClosure hts hst]", "start": [1687, 1], "end": [1688, 87], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.erase_sup_Iic", "code": "lemma erase_sup_Iic (ha : a \u2208 s) (has : \u2200 b \u2208 s, a \u2264 b \u2192 b = a) : s.erase a \u2294 Iic a = s := by\n  rw [\u2190lowerClosure_singleton, \u2190sdiff_singleton, sdiff_sup_lowerClosure] <;> simpa", "start": [1690, 1], "end": [1691, 83], "kind": "mathlibtacticlemma"}, {"full_name": "LowerSet.Iic_sup_erase", "code": "lemma Iic_sup_erase (ha : a \u2208 s) (has : \u2200 b \u2208 s, a \u2264 b \u2192 b = a) : Iic a \u2294 s.erase a = s := by\n  rw [sup_comm, erase_sup_Iic ha has]", "start": [1693, 1], "end": [1694, 38], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.sdiff", "code": "def sdiff (s : UpperSet \u03b1) (t : Set \u03b1) : UpperSet \u03b1 where\n  carrier := s \\ lowerClosure t\n  upper' := s.upper.sdiff_of_isLowerSet (lowerClosure t).lower", "start": [1701, 1], "end": [1704, 63], "kind": "commanddeclaration"}, {"full_name": "UpperSet.erase", "code": "def erase (s : UpperSet \u03b1) (a : \u03b1) : UpperSet \u03b1 where\n  carrier := s \\ LowerSet.Iic a\n  upper' := s.upper.sdiff_of_isLowerSet (LowerSet.Iic a).lower", "start": [1706, 1], "end": [1709, 63], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_sdiff", "code": "@[simp, norm_cast]\nlemma coe_sdiff (s : UpperSet \u03b1) (t : Set \u03b1) : s.sdiff t = (s : Set \u03b1) \\ lowerClosure t := rfl", "start": [1711, 1], "end": [1712, 95], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.coe_erase", "code": "@[simp, norm_cast]\nlemma coe_erase (s : UpperSet \u03b1) (a : \u03b1) : s.erase a = (s : Set \u03b1) \\ LowerSet.Iic a := rfl", "start": [1714, 1], "end": [1715, 91], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.sdiff_singleton", "code": "@[simp] lemma sdiff_singleton (s : UpperSet \u03b1) (a : \u03b1) : s.sdiff {a} = s.erase a := by\n  simp [sdiff, erase]", "start": [1717, 1], "end": [1718, 22], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.le_sdiff_left", "code": "lemma le_sdiff_left : s \u2264 s.sdiff t := diff_subset _ _", "start": [1720, 1], "end": [1720, 55], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.le_erase", "code": "lemma le_erase : s \u2264 s.erase a := diff_subset _ _", "start": [1721, 1], "end": [1721, 50], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.sdiff_eq_left", "code": "@[simp] protected lemma sdiff_eq_left : s.sdiff t = s \u2194 Disjoint \u2191s t := by\n  simp [\u2190SetLike.coe_set_eq]", "start": [1723, 1], "end": [1724, 29], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.erase_eq", "code": "@[simp] lemma erase_eq : s.erase a = s \u2194 a \u2209 s := by rw [\u2190sdiff_singleton]; simp [-sdiff_singleton]", "start": [1726, 1], "end": [1726, 100], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.lt_sdiff_left", "code": "@[simp] lemma lt_sdiff_left : s < s.sdiff t \u2194 \u00ac Disjoint \u2191s t :=\n  le_sdiff_left.gt_iff_ne.trans UpperSet.sdiff_eq_left.not", "start": [1728, 1], "end": [1729, 59], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.lt_erase", "code": "@[simp] lemma lt_erase : s < s.erase a \u2194 a \u2208 s := le_erase.gt_iff_ne.trans erase_eq.not_left", "start": [1731, 1], "end": [1731, 93], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.sdiff_idem", "code": "@[simp] protected lemma sdiff_idem (s : UpperSet \u03b1) (t : Set \u03b1) : (s.sdiff t).sdiff t = s.sdiff t :=\n  SetLike.coe_injective sdiff_idem", "start": [1733, 1], "end": [1734, 35], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.erase_idem", "code": "@[simp] lemma erase_idem (s : UpperSet \u03b1) (a : \u03b1) : (s.erase a).erase a = s.erase a :=\n  SetLike.coe_injective sdiff_idem", "start": [1736, 1], "end": [1737, 35], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.sdiff_inf_upperClosure", "code": "lemma sdiff_inf_upperClosure (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t) :\n    s.sdiff t \u2293 upperClosure t = s := by\n  refine' ge_antisymm (le_inf le_sdiff_left $ le_upperClosure.2 hts) fun a ha \u21a6 _\n  obtain hat | hat := em (a \u2208 t)\n  \u00b7 exact subset_union_right _ _ (subset_upperClosure hat)\n  \u00b7 refine subset_union_left _ _ \u27e8ha, ?_\u27e9\n    rintro \u27e8b, hb, hab\u27e9\n    exact hat $ hst _ ha _ hb hab", "start": [1739, 1], "end": [1746, 34], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.upperClosure_inf_sdiff", "code": "lemma upperClosure_inf_sdiff (hts : t \u2286 s) (hst : \u2200 b \u2208 s, \u2200 c \u2208 t, b \u2264 c \u2192 b \u2208 t) :\n    upperClosure t \u2293 s.sdiff t = s := by rw [inf_comm, sdiff_inf_upperClosure hts hst]", "start": [1748, 1], "end": [1749, 87], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.erase_inf_Ici", "code": "lemma erase_inf_Ici (ha : a \u2208 s) (has : \u2200 b \u2208 s, b \u2264 a \u2192 b = a) : s.erase a \u2293 Ici a = s := by\n  rw [\u2190upperClosure_singleton, \u2190sdiff_singleton, sdiff_inf_upperClosure] <;> simpa", "start": [1751, 1], "end": [1752, 83], "kind": "mathlibtacticlemma"}, {"full_name": "UpperSet.Ici_inf_erase", "code": "lemma Ici_inf_erase (ha : a \u2208 s) (has : \u2200 b \u2208 s, b \u2264 a \u2192 b = a) : Ici a \u2293 s.erase a = s := by\n  rw [inf_comm, erase_inf_Ici ha has]", "start": [1754, 1], "end": [1755, 38], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.prod", "code": "theorem IsUpperSet.prod (hs : IsUpperSet s) (ht : IsUpperSet t) : IsUpperSet (s \u00d7\u02e2 t)", "start": [1770, 1], "end": [1771, 45], "kind": "commanddeclaration"}, {"full_name": "IsLowerSet.prod", "code": "theorem IsLowerSet.prod (hs : IsLowerSet s) (ht : IsLowerSet t) : IsLowerSet (s \u00d7\u02e2 t)", "start": [1774, 1], "end": [1775, 45], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod", "code": "def prod : UpperSet (\u03b1 \u00d7 \u03b2) :=\n  \u27e8s \u00d7\u02e2 t, s.2.prod t.2\u27e9", "start": [1784, 1], "end": [1786, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.instSProd", "code": "instance instSProd : SProd (UpperSet \u03b1) (UpperSet \u03b2) (UpperSet (\u03b1 \u00d7 \u03b2)) where\n  sprod := UpperSet.prod", "start": [1789, 1], "end": [1790, 25], "kind": "commanddeclaration"}, {"full_name": "UpperSet.coe_prod", "code": "@[simp, norm_cast]\ntheorem coe_prod : ((s \u00d7\u02e2 t : UpperSet (\u03b1 \u00d7 \u03b2)) : Set (\u03b1 \u00d7 \u03b2)) = (s : Set \u03b1) \u00d7\u02e2 t", "start": [1792, 1], "end": [1794, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.mem_prod", "code": "@[simp]\ntheorem mem_prod {s : UpperSet \u03b1} {t : UpperSet \u03b2} : x \u2208 s \u00d7\u02e2 t \u2194 x.1 \u2208 s \u2227 x.2 \u2208 t", "start": [1797, 1], "end": [1799, 10], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_prod", "code": "theorem Ici_prod (x : \u03b1 \u00d7 \u03b2) : Ici x = Ici x.1 \u00d7\u02e2 Ici x.2", "start": [1802, 1], "end": [1803, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.Ici_prod_Ici", "code": "@[simp]\ntheorem Ici_prod_Ici (a : \u03b1) (b : \u03b2) : Ici a \u00d7\u02e2 Ici b = Ici (a, b)", "start": [1806, 1], "end": [1808, 6], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_top", "code": "@[simp]\ntheorem prod_top : s \u00d7\u02e2 (\u22a4 : UpperSet \u03b2) = \u22a4", "start": [1811, 1], "end": [1813, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.top_prod", "code": "@[simp]\ntheorem top_prod : (\u22a4 : UpperSet \u03b1) \u00d7\u02e2 t = \u22a4", "start": [1816, 1], "end": [1818, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.bot_prod_bot", "code": "@[simp]\ntheorem bot_prod_bot : (\u22a5 : UpperSet \u03b1) \u00d7\u02e2 (\u22a5 : UpperSet \u03b2) = \u22a5", "start": [1821, 1], "end": [1823, 21], "kind": "commanddeclaration"}, {"full_name": "UpperSet.sup_prod", "code": "@[simp]\ntheorem sup_prod : (s\u2081 \u2294 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2294 s\u2082 \u00d7\u02e2 t", "start": [1826, 1], "end": [1828, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_sup", "code": "@[simp]\ntheorem prod_sup : s \u00d7\u02e2 (t\u2081 \u2294 t\u2082) = s \u00d7\u02e2 t\u2081 \u2294 s \u00d7\u02e2 t\u2082", "start": [1831, 1], "end": [1833, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.inf_prod", "code": "@[simp]\ntheorem inf_prod : (s\u2081 \u2293 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2293 s\u2082 \u00d7\u02e2 t", "start": [1836, 1], "end": [1838, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_inf", "code": "@[simp]\ntheorem prod_inf : s \u00d7\u02e2 (t\u2081 \u2293 t\u2082) = s \u00d7\u02e2 t\u2081 \u2293 s \u00d7\u02e2 t\u2082", "start": [1841, 1], "end": [1843, 17], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_sup_prod", "code": "theorem prod_sup_prod : s\u2081 \u00d7\u02e2 t\u2081 \u2294 s\u2082 \u00d7\u02e2 t\u2082 = (s\u2081 \u2294 s\u2082) \u00d7\u02e2 (t\u2081 \u2294 t\u2082)", "start": [1846, 1], "end": [1847, 22], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_mono", "code": "@[mono]\ntheorem prod_mono : s\u2081 \u2264 s\u2082 \u2192 t\u2081 \u2264 t\u2082 \u2192 s\u2081 \u00d7\u02e2 t\u2081 \u2264 s\u2082 \u00d7\u02e2 t\u2082", "start": [1852, 1], "end": [1854, 16], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_mono_left", "code": "theorem prod_mono_left : s\u2081 \u2264 s\u2082 \u2192 s\u2081 \u00d7\u02e2 t \u2264 s\u2082 \u00d7\u02e2 t", "start": [1857, 1], "end": [1858, 21], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_mono_right", "code": "theorem prod_mono_right : t\u2081 \u2264 t\u2082 \u2192 s \u00d7\u02e2 t\u2081 \u2264 s \u00d7\u02e2 t\u2082", "start": [1861, 1], "end": [1862, 22], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_self_le_prod_self", "code": "@[simp]\ntheorem prod_self_le_prod_self : s\u2081 \u00d7\u02e2 s\u2081 \u2264 s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 \u2264 s\u2082", "start": [1865, 1], "end": [1867, 29], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_self_lt_prod_self", "code": "@[simp]\ntheorem prod_self_lt_prod_self : s\u2081 \u00d7\u02e2 s\u2081 < s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 < s\u2082", "start": [1870, 1], "end": [1872, 30], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_le_prod_iff", "code": "theorem prod_le_prod_iff : s\u2081 \u00d7\u02e2 t\u2081 \u2264 s\u2082 \u00d7\u02e2 t\u2082 \u2194 s\u2081 \u2264 s\u2082 \u2227 t\u2081 \u2264 t\u2082 \u2228 s\u2082 = \u22a4 \u2228 t\u2082 = \u22a4", "start": [1875, 1], "end": [1876, 40], "kind": "commanddeclaration"}, {"full_name": "UpperSet.prod_eq_top", "code": "@[simp]\ntheorem prod_eq_top : s \u00d7\u02e2 t = \u22a4 \u2194 s = \u22a4 \u2228 t = \u22a4", "start": [1879, 1], "end": [1882, 26], "kind": "commanddeclaration"}, {"full_name": "UpperSet.codisjoint_prod", "code": "@[simp]\ntheorem codisjoint_prod :\n    Codisjoint (s\u2081 \u00d7\u02e2 t\u2081) (s\u2082 \u00d7\u02e2 t\u2082) \u2194 Codisjoint s\u2081 s\u2082 \u2228 Codisjoint t\u2081 t\u2082", "start": [1885, 1], "end": [1888, 55], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod", "code": "def prod : LowerSet (\u03b1 \u00d7 \u03b2) := \u27e8s \u00d7\u02e2 t, s.2.prod t.2\u27e9", "start": [1897, 1], "end": [1898, 54], "kind": "commanddeclaration"}, {"full_name": "LowerSet.instSProd", "code": "instance instSProd : SProd (LowerSet \u03b1) (LowerSet \u03b2) (LowerSet (\u03b1 \u00d7 \u03b2)) where\n  sprod := LowerSet.prod", "start": [1901, 1], "end": [1902, 25], "kind": "commanddeclaration"}, {"full_name": "LowerSet.coe_prod", "code": "@[simp, norm_cast]\ntheorem coe_prod : ((s \u00d7\u02e2 t : LowerSet (\u03b1 \u00d7 \u03b2)) : Set (\u03b1 \u00d7 \u03b2)) = (s : Set \u03b1) \u00d7\u02e2 t", "start": [1904, 1], "end": [1905, 89], "kind": "commanddeclaration"}, {"full_name": "LowerSet.mem_prod", "code": "@[simp]\ntheorem mem_prod {s : LowerSet \u03b1} {t : LowerSet \u03b2} : x \u2208 s \u00d7\u02e2 t \u2194 x.1 \u2208 s \u2227 x.2 \u2208 t", "start": [1908, 1], "end": [1910, 10], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Iic_prod", "code": "theorem Iic_prod (x : \u03b1 \u00d7 \u03b2) : Iic x = Iic x.1 \u00d7\u02e2 Iic x.2", "start": [1913, 1], "end": [1914, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.Ici_prod_Ici", "code": "@[simp]\ntheorem Ici_prod_Ici (a : \u03b1) (b : \u03b2) : Iic a \u00d7\u02e2 Iic b = Iic (a, b)", "start": [1917, 1], "end": [1919, 6], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_bot", "code": "@[simp]\ntheorem prod_bot : s \u00d7\u02e2 (\u22a5 : LowerSet \u03b2) = \u22a5", "start": [1922, 1], "end": [1924, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.bot_prod", "code": "@[simp]\ntheorem bot_prod : (\u22a5 : LowerSet \u03b1) \u00d7\u02e2 t = \u22a5", "start": [1927, 1], "end": [1929, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.top_prod_top", "code": "@[simp]\ntheorem top_prod_top : (\u22a4 : LowerSet \u03b1) \u00d7\u02e2 (\u22a4 : LowerSet \u03b2) = \u22a4", "start": [1932, 1], "end": [1934, 21], "kind": "commanddeclaration"}, {"full_name": "LowerSet.inf_prod", "code": "@[simp]\ntheorem inf_prod : (s\u2081 \u2293 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2293 s\u2082 \u00d7\u02e2 t", "start": [1937, 1], "end": [1939, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_inf", "code": "@[simp]\ntheorem prod_inf : s \u00d7\u02e2 (t\u2081 \u2293 t\u2082) = s \u00d7\u02e2 t\u2081 \u2293 s \u00d7\u02e2 t\u2082", "start": [1942, 1], "end": [1944, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.sup_prod", "code": "@[simp]\ntheorem sup_prod : (s\u2081 \u2294 s\u2082) \u00d7\u02e2 t = s\u2081 \u00d7\u02e2 t \u2294 s\u2082 \u00d7\u02e2 t", "start": [1947, 1], "end": [1949, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_sup", "code": "@[simp]\ntheorem prod_sup : s \u00d7\u02e2 (t\u2081 \u2294 t\u2082) = s \u00d7\u02e2 t\u2081 \u2294 s \u00d7\u02e2 t\u2082", "start": [1952, 1], "end": [1954, 17], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_inf_prod", "code": "theorem prod_inf_prod : s\u2081 \u00d7\u02e2 t\u2081 \u2293 s\u2082 \u00d7\u02e2 t\u2082 = (s\u2081 \u2293 s\u2082) \u00d7\u02e2 (t\u2081 \u2293 t\u2082)", "start": [1957, 1], "end": [1958, 22], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_mono", "code": "theorem prod_mono : s\u2081 \u2264 s\u2082 \u2192 t\u2081 \u2264 t\u2082 \u2192 s\u2081 \u00d7\u02e2 t\u2081 \u2264 s\u2082 \u00d7\u02e2 t\u2082", "start": [1963, 1], "end": [1963, 77], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_mono_left", "code": "theorem prod_mono_left : s\u2081 \u2264 s\u2082 \u2192 s\u2081 \u00d7\u02e2 t \u2264 s\u2082 \u00d7\u02e2 t", "start": [1966, 1], "end": [1966, 75], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_mono_right", "code": "theorem prod_mono_right : t\u2081 \u2264 t\u2082 \u2192 s \u00d7\u02e2 t\u2081 \u2264 s \u00d7\u02e2 t\u2082", "start": [1969, 1], "end": [1969, 77], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_self_le_prod_self", "code": "@[simp]\ntheorem prod_self_le_prod_self : s\u2081 \u00d7\u02e2 s\u2081 \u2264 s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 \u2264 s\u2082", "start": [1972, 1], "end": [1974, 29], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_self_lt_prod_self", "code": "@[simp]\ntheorem prod_self_lt_prod_self : s\u2081 \u00d7\u02e2 s\u2081 < s\u2082 \u00d7\u02e2 s\u2082 \u2194 s\u2081 < s\u2082", "start": [1977, 1], "end": [1979, 30], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_le_prod_iff", "code": "theorem prod_le_prod_iff : s\u2081 \u00d7\u02e2 t\u2081 \u2264 s\u2082 \u00d7\u02e2 t\u2082 \u2194 s\u2081 \u2264 s\u2082 \u2227 t\u2081 \u2264 t\u2082 \u2228 s\u2081 = \u22a5 \u2228 t\u2081 = \u22a5", "start": [1982, 1], "end": [1983, 40], "kind": "commanddeclaration"}, {"full_name": "LowerSet.prod_eq_bot", "code": "@[simp]\ntheorem prod_eq_bot : s \u00d7\u02e2 t = \u22a5 \u2194 s = \u22a5 \u2228 t = \u22a5", "start": [1986, 1], "end": [1989, 26], "kind": "commanddeclaration"}, {"full_name": "LowerSet.disjoint_prod", "code": "@[simp]\ntheorem disjoint_prod : Disjoint (s\u2081 \u00d7\u02e2 t\u2081) (s\u2082 \u00d7\u02e2 t\u2082) \u2194 Disjoint s\u2081 s\u2082 \u2228 Disjoint t\u2081 t\u2082", "start": [1992, 1], "end": [1994, 53], "kind": "commanddeclaration"}, {"full_name": "upperClosure_prod", "code": "@[simp]\ntheorem upperClosure_prod (s : Set \u03b1) (t : Set \u03b2) :\n    upperClosure (s \u00d7\u02e2 t) = upperClosure s \u00d7\u02e2 upperClosure t", "start": [1999, 1], "end": [2003, 50], "kind": "commanddeclaration"}, {"full_name": "lowerClosure_prod", "code": "@[simp]\ntheorem lowerClosure_prod (s : Set \u03b1) (t : Set \u03b2) :\n    lowerClosure (s \u00d7\u02e2 t) = lowerClosure s \u00d7\u02e2 lowerClosure t", "start": [2006, 1], "end": [2010, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousOn.lean", "imports": ["Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhds_bind_nhdsWithin", "code": "@[simp]\ntheorem nhds_bind_nhdsWithin {a : \u03b1} {s : Set \u03b1} : ((\ud835\udcdd a).bind fun x => \ud835\udcdd[s] x) = \ud835\udcdd[s] a", "start": [40, 1], "end": [42, 62], "kind": "commanddeclaration"}, {"full_name": "eventually_nhds_nhdsWithin", "code": "@[simp]\ntheorem eventually_nhds_nhdsWithin {a : \u03b1} {s : Set \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 y in \ud835\udcdd a, \u2200\u1da0 x in \ud835\udcdd[s] y, p x) \u2194 \u2200\u1da0 x in \ud835\udcdd[s] a, p x", "start": [45, 1], "end": [48, 52], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_iff", "code": "theorem eventually_nhdsWithin_iff {a : \u03b1} {s : Set \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in \ud835\udcdd[s] a, p x) \u2194 \u2200\u1da0 x in \ud835\udcdd a, x \u2208 s \u2192 p x", "start": [51, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "frequently_nhdsWithin_iff", "code": "theorem frequently_nhdsWithin_iff {z : \u03b1} {s : Set \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 x in \ud835\udcdd[s] z, p x) \u2194 \u2203\u1da0 x in \ud835\udcdd z, p x \u2227 x \u2208 s", "start": [56, 1], "end": [58, 69], "kind": "commanddeclaration"}, {"full_name": "mem_closure_ne_iff_frequently_within", "code": "theorem mem_closure_ne_iff_frequently_within {z : \u03b1} {s : Set \u03b1} :\n    z \u2208 closure (s \\ {z}) \u2194 \u2203\u1da0 x in \ud835\udcdd[\u2260] z, x \u2208 s", "start": [61, 1], "end": [63, 63], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_nhdsWithin", "code": "@[simp]\ntheorem eventually_nhdsWithin_nhdsWithin {a : \u03b1} {s : Set \u03b1} {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 y in \ud835\udcdd[s] a, \u2200\u1da0 x in \ud835\udcdd[s] y, p x) \u2194 \u2200\u1da0 x in \ud835\udcdd[s] a, p x", "start": [66, 1], "end": [71, 57], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq", "code": "theorem nhdsWithin_eq (a : \u03b1) (s : Set \u03b1) :\n    \ud835\udcdd[s] a = \u2a05 t \u2208 { t : Set \u03b1 | a \u2208 t \u2227 IsOpen t }, \ud835\udcdf (t \u2229 s)", "start": [74, 1], "end": [76, 50], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_univ", "code": "theorem nhdsWithin_univ (a : \u03b1) : \ud835\udcdd[Set.univ] a = \ud835\udcdd a", "start": [79, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_hasBasis", "code": "theorem nhdsWithin_hasBasis {p : \u03b2 \u2192 Prop} {s : \u03b2 \u2192 Set \u03b1} {a : \u03b1} (h : (\ud835\udcdd a).HasBasis p s)\n    (t : Set \u03b1) : (\ud835\udcdd[t] a).HasBasis p fun i => s i \u2229 t", "start": [83, 1], "end": [85, 20], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_basis_open", "code": "theorem nhdsWithin_basis_open (a : \u03b1) (t : Set \u03b1) :\n    (\ud835\udcdd[t] a).HasBasis (fun u => a \u2208 u \u2227 IsOpen u) fun u => u \u2229 t", "start": [88, 1], "end": [90, 45], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin", "code": "theorem mem_nhdsWithin {t : Set \u03b1} {a : \u03b1} {s : Set \u03b1} :\n    t \u2208 \ud835\udcdd[s] a \u2194 \u2203 u, IsOpen u \u2227 a \u2208 u \u2227 u \u2229 s \u2286 t", "start": [93, 1], "end": [95, 82], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_iff_exists_mem_nhds_inter", "code": "theorem mem_nhdsWithin_iff_exists_mem_nhds_inter {t : Set \u03b1} {a : \u03b1} {s : Set \u03b1} :\n    t \u2208 \ud835\udcdd[s] a \u2194 \u2203 u \u2208 \ud835\udcdd a, u \u2229 s \u2286 t", "start": [98, 1], "end": [100, 51], "kind": "commanddeclaration"}, {"full_name": "diff_mem_nhdsWithin_compl", "code": "theorem diff_mem_nhdsWithin_compl {x : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) (t : Set \u03b1) :\n    s \\ t \u2208 \ud835\udcdd[t\u1d9c] x", "start": [103, 1], "end": [105, 36], "kind": "commanddeclaration"}, {"full_name": "diff_mem_nhdsWithin_diff", "code": "theorem diff_mem_nhdsWithin_diff {x : \u03b1} {s t : Set \u03b1} (hs : s \u2208 \ud835\udcdd[t] x) (t' : Set \u03b1) :\n    s \\ t' \u2208 \ud835\udcdd[t \\ t'] x", "start": [108, 1], "end": [111, 48], "kind": "commanddeclaration"}, {"full_name": "nhds_of_nhdsWithin_of_nhds", "code": "theorem nhds_of_nhdsWithin_of_nhds {s t : Set \u03b1} {a : \u03b1} (h1 : s \u2208 \ud835\udcdd a) (h2 : t \u2208 \ud835\udcdd[s] a) :\n    t \u2208 \ud835\udcdd a", "start": [114, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_iff_eventually", "code": "theorem mem_nhdsWithin_iff_eventually {s t : Set \u03b1} {x : \u03b1} :\n    t \u2208 \ud835\udcdd[s] x \u2194 \u2200\u1da0 y in \ud835\udcdd x, y \u2208 s \u2192 y \u2208 t", "start": [120, 1], "end": [122, 27], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_iff_eventuallyEq", "code": "theorem mem_nhdsWithin_iff_eventuallyEq {s t : Set \u03b1} {x : \u03b1} :\n    t \u2208 \ud835\udcdd[s] x \u2194 s =\u1da0[\ud835\udcdd x] (s \u2229 t : Set \u03b1)", "start": [125, 1], "end": [127, 89], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq_iff_eventuallyEq", "code": "theorem nhdsWithin_eq_iff_eventuallyEq {s t : Set \u03b1} {x : \u03b1} : \ud835\udcdd[s] x = \ud835\udcdd[t] x \u2194 s =\u1da0[\ud835\udcdd x] t", "start": [130, 1], "end": [131, 42], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_le_iff", "code": "theorem nhdsWithin_le_iff {s t : Set \u03b1} {x : \u03b1} : \ud835\udcdd[s] x \u2264 \ud835\udcdd[t] x \u2194 t \u2208 \ud835\udcdd[s] x", "start": [134, 1], "end": [135, 90], "kind": "commanddeclaration"}, {"full_name": "preimage_nhdsWithin_coinduced'", "code": "theorem preimage_nhdsWithin_coinduced' {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {t : Set \u03b1} {a : \u03b1} (h : a \u2208 t)\n    (hs : s \u2208 @nhds \u03b2 (.coinduced (fun x : t => \u03c0 x) inferInstance) (\u03c0 a)) :\n    \u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd[t] a", "start": [139, 1], "end": [144, 40], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_of_mem_nhds", "code": "theorem mem_nhdsWithin_of_mem_nhds {s t : Set \u03b1} {a : \u03b1} (h : s \u2208 \ud835\udcdd a) : s \u2208 \ud835\udcdd[t] a", "start": [147, 1], "end": [148, 20], "kind": "commanddeclaration"}, {"full_name": "self_mem_nhdsWithin", "code": "theorem self_mem_nhdsWithin {a : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd[s] a", "start": [151, 1], "end": [152, 42], "kind": "commanddeclaration"}, {"full_name": "eventually_mem_nhdsWithin", "code": "theorem eventually_mem_nhdsWithin {a : \u03b1} {s : Set \u03b1} : \u2200\u1da0 x in \ud835\udcdd[s] a, x \u2208 s", "start": [155, 1], "end": [156, 22], "kind": "commanddeclaration"}, {"full_name": "inter_mem_nhdsWithin", "code": "theorem inter_mem_nhdsWithin (s : Set \u03b1) {t : Set \u03b1} {a : \u03b1} (h : t \u2208 \ud835\udcdd a) : s \u2229 t \u2208 \ud835\udcdd[s] a", "start": [159, 1], "end": [160, 52], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_mono", "code": "theorem nhdsWithin_mono (a : \u03b1) {s t : Set \u03b1} (h : s \u2286 t) : \ud835\udcdd[s] a \u2264 \ud835\udcdd[t] a", "start": [163, 1], "end": [164, 43], "kind": "commanddeclaration"}, {"full_name": "pure_le_nhdsWithin", "code": "theorem pure_le_nhdsWithin {a : \u03b1} {s : Set \u03b1} (ha : a \u2208 s) : pure a \u2264 \ud835\udcdd[s] a", "start": [167, 1], "end": [168, 50], "kind": "commanddeclaration"}, {"full_name": "mem_of_mem_nhdsWithin", "code": "theorem mem_of_mem_nhdsWithin {a : \u03b1} {s t : Set \u03b1} (ha : a \u2208 s) (ht : t \u2208 \ud835\udcdd[s] a) : a \u2208 t", "start": [171, 1], "end": [172, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.self_of_nhdsWithin", "code": "theorem Filter.Eventually.self_of_nhdsWithin {p : \u03b1 \u2192 Prop} {s : Set \u03b1} {x : \u03b1}\n    (h : \u2200\u1da0 y in \ud835\udcdd[s] x, p y) (hx : x \u2208 s) : p x", "start": [175, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_nhdsWithin", "code": "theorem tendsto_const_nhdsWithin {l : Filter \u03b2} {s : Set \u03b1} {a : \u03b1} (ha : a \u2208 s) :\n    Tendsto (fun _ : \u03b2 => a) l (\ud835\udcdd[s] a)", "start": [180, 1], "end": [182, 57], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_restrict''", "code": "theorem nhdsWithin_restrict'' {a : \u03b1} (s : Set \u03b1) {t : Set \u03b1} (h : t \u2208 \ud835\udcdd[s] a) :\n    \ud835\udcdd[s] a = \ud835\udcdd[s \u2229 t] a", "start": [185, 1], "end": [188, 73], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_restrict'", "code": "theorem nhdsWithin_restrict' {a : \u03b1} (s : Set \u03b1) {t : Set \u03b1} (h : t \u2208 \ud835\udcdd a) : \ud835\udcdd[s] a = \ud835\udcdd[s \u2229 t] a", "start": [191, 1], "end": [192, 47], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_restrict", "code": "theorem nhdsWithin_restrict {a : \u03b1} (s : Set \u03b1) {t : Set \u03b1} (h\u2080 : a \u2208 t) (h\u2081 : IsOpen t) :\n    \ud835\udcdd[s] a = \ud835\udcdd[s \u2229 t] a", "start": [195, 1], "end": [197, 49], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_le_of_mem", "code": "theorem nhdsWithin_le_of_mem {a : \u03b1} {s t : Set \u03b1} (h : s \u2208 \ud835\udcdd[t] a) : \ud835\udcdd[t] a \u2264 \ud835\udcdd[s] a", "start": [200, 1], "end": [201, 26], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_le_nhds", "code": "theorem nhdsWithin_le_nhds {a : \u03b1} {s : Set \u03b1} : \ud835\udcdd[s] a \u2264 \ud835\udcdd a", "start": [204, 1], "end": [207, 17], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq_nhdsWithin'", "code": "theorem nhdsWithin_eq_nhdsWithin' {a : \u03b1} {s t u : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) (h\u2082 : t \u2229 s = u \u2229 s) :\n    \ud835\udcdd[t] a = \ud835\udcdd[u] a", "start": [210, 1], "end": [211, 88], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq_nhdsWithin", "code": "theorem nhdsWithin_eq_nhdsWithin {a : \u03b1} {s t u : Set \u03b1} (h\u2080 : a \u2208 s) (h\u2081 : IsOpen s)\n    (h\u2082 : t \u2229 s = u \u2229 s) : \ud835\udcdd[t] a = \ud835\udcdd[u] a", "start": [214, 1], "end": [216, 68], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq_nhds", "code": "@[simp] theorem nhdsWithin_eq_nhds {a : \u03b1} {s : Set \u03b1} : \ud835\udcdd[s] a = \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a", "start": [219, 1], "end": [220, 37], "kind": "commanddeclaration"}, {"full_name": "IsOpen.nhdsWithin_eq", "code": "theorem IsOpen.nhdsWithin_eq {a : \u03b1} {s : Set \u03b1} (h : IsOpen s) (ha : a \u2208 s) : \ud835\udcdd[s] a = \ud835\udcdd a", "start": [223, 1], "end": [224, 40], "kind": "commanddeclaration"}, {"full_name": "preimage_nhds_within_coinduced", "code": "theorem preimage_nhds_within_coinduced {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {t : Set \u03b1} {a : \u03b1} (h : a \u2208 t)\n    (ht : IsOpen t)\n    (hs : s \u2208 @nhds \u03b2 (.coinduced (fun x : t => \u03c0 x) inferInstance) (\u03c0 a)) :\n    \u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd a", "start": [227, 1], "end": [232, 44], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_empty", "code": "@[simp]\ntheorem nhdsWithin_empty (a : \u03b1) : \ud835\udcdd[\u2205] a = \u22a5", "start": [235, 1], "end": [236, 97], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_union", "code": "theorem nhdsWithin_union (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u222a t] a = \ud835\udcdd[s] a \u2294 \ud835\udcdd[t] a", "start": [239, 1], "end": [241, 37], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_biUnion", "code": "theorem nhdsWithin_biUnion {\u03b9} {I : Set \u03b9} (hI : I.Finite) (s : \u03b9 \u2192 Set \u03b1) (a : \u03b1) :\n    \ud835\udcdd[\u22c3 i \u2208 I, s i] a = \u2a06 i \u2208 I, \ud835\udcdd[s i] a", "start": [244, 1], "end": [247, 66], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_sUnion", "code": "theorem nhdsWithin_sUnion {S : Set (Set \u03b1)} (hS : S.Finite) (a : \u03b1) :\n    \ud835\udcdd[\u22c3\u2080 S] a = \u2a06 s \u2208 S, \ud835\udcdd[s] a", "start": [250, 1], "end": [252, 48], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_iUnion", "code": "theorem nhdsWithin_iUnion {\u03b9} [Finite \u03b9] (s : \u03b9 \u2192 Set \u03b1) (a : \u03b1) :\n    \ud835\udcdd[\u22c3 i, s i] a = \u2a06 i, \ud835\udcdd[s i] a", "start": [255, 1], "end": [257, 70], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_inter", "code": "theorem nhdsWithin_inter (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[s] a \u2293 \ud835\udcdd[t] a", "start": [260, 1], "end": [262, 70], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_inter'", "code": "theorem nhdsWithin_inter' (a : \u03b1) (s t : Set \u03b1) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[s] a \u2293 \ud835\udcdf t", "start": [265, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_inter_of_mem", "code": "theorem nhdsWithin_inter_of_mem {a : \u03b1} {s t : Set \u03b1} (h : s \u2208 \ud835\udcdd[t] a) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[t] a", "start": [270, 1], "end": [272, 31], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_inter_of_mem'", "code": "theorem nhdsWithin_inter_of_mem' {a : \u03b1} {s t : Set \u03b1} (h : t \u2208 \ud835\udcdd[s] a) : \ud835\udcdd[s \u2229 t] a = \ud835\udcdd[s] a", "start": [275, 1], "end": [276, 45], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_singleton", "code": "@[simp]\ntheorem nhdsWithin_singleton (a : \u03b1) : \ud835\udcdd[{a}] a = pure a", "start": [279, 1], "end": [281, 72], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_insert", "code": "@[simp]\ntheorem nhdsWithin_insert (a : \u03b1) (s : Set \u03b1) : \ud835\udcdd[insert a s] a = pure a \u2294 \ud835\udcdd[s] a", "start": [284, 1], "end": [286, 65], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_insert", "code": "theorem mem_nhdsWithin_insert {a : \u03b1} {s t : Set \u03b1} : t \u2208 \ud835\udcdd[insert a s] a \u2194 a \u2208 t \u2227 t \u2208 \ud835\udcdd[s] a", "start": [289, 1], "end": [290, 7], "kind": "commanddeclaration"}, {"full_name": "insert_mem_nhdsWithin_insert", "code": "theorem insert_mem_nhdsWithin_insert {a : \u03b1} {s t : Set \u03b1} (h : t \u2208 \ud835\udcdd[s] a) :\n    insert a t \u2208 \ud835\udcdd[insert a s] a", "start": [293, 1], "end": [294, 64], "kind": "commanddeclaration"}, {"full_name": "insert_mem_nhds_iff", "code": "theorem insert_mem_nhds_iff {a : \u03b1} {s : Set \u03b1} : insert a s \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd[\u2260] a", "start": [297, 1], "end": [299, 16], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_compl_singleton_sup_pure", "code": "@[simp]\ntheorem nhdsWithin_compl_singleton_sup_pure (a : \u03b1) : \ud835\udcdd[\u2260] a \u2294 pure a = \ud835\udcdd a", "start": [302, 1], "end": [304, 85], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_prod", "code": "theorem nhdsWithin_prod {\u03b1 : Type*} [TopologicalSpace \u03b1] {\u03b2 : Type*} [TopologicalSpace \u03b2]\n    {s u : Set \u03b1} {t v : Set \u03b2} {a : \u03b1} {b : \u03b2} (hu : u \u2208 \ud835\udcdd[s] a) (hv : v \u2208 \ud835\udcdd[t] b) :\n    u \u00d7\u02e2 v \u2208 \ud835\udcdd[s \u00d7\u02e2 t] (a, b)", "start": [307, 1], "end": [311, 28], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pi_eq'", "code": "theorem nhdsWithin_pi_eq' {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    (hI : I.Finite) (s : \u2200 i, Set (\u03b1 i)) (x : \u2200 i, \u03b1 i) :\n    \ud835\udcdd[pi I s] x = \u2a05 i, comap (fun x => x i) (\ud835\udcdd (x i) \u2293 \u2a05 (_ : i \u2208 I), \ud835\udcdf (s i))", "start": [314, 1], "end": [318, 45], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pi_eq", "code": "theorem nhdsWithin_pi_eq {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    (hI : I.Finite) (s : \u2200 i, Set (\u03b1 i)) (x : \u2200 i, \u03b1 i) :\n    \ud835\udcdd[pi I s] x =\n      (\u2a05 i \u2208 I, comap (fun x => x i) (\ud835\udcdd[s i] x i)) \u2293\n        \u2a05 (i) (_ : i \u2209 I), comap (fun x => x i) (\ud835\udcdd (x i))", "start": [321, 1], "end": [329, 26], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pi_univ_eq", "code": "theorem nhdsWithin_pi_univ_eq {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [Finite \u03b9] [\u2200 i, TopologicalSpace (\u03b1 i)]\n    (s : \u2200 i, Set (\u03b1 i)) (x : \u2200 i, \u03b1 i) : \ud835\udcdd[pi univ s] x = \u2a05 i, comap (fun x => x i) (\ud835\udcdd[s i] x i)", "start": [332, 1], "end": [334, 63], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pi_eq_bot", "code": "theorem nhdsWithin_pi_eq_bot {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    {s : \u2200 i, Set (\u03b1 i)} {x : \u2200 i, \u03b1 i} : \ud835\udcdd[pi I s] x = \u22a5 \u2194 \u2203 i \u2208 I, \ud835\udcdd[s i] x i = \u22a5", "start": [337, 1], "end": [339, 62], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pi_neBot", "code": "theorem nhdsWithin_pi_neBot {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    {s : \u2200 i, Set (\u03b1 i)} {x : \u2200 i, \u03b1 i} : (\ud835\udcdd[pi I s] x).NeBot \u2194 \u2200 i \u2208 I, (\ud835\udcdd[s i] x i).NeBot", "start": [342, 1], "end": [344, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.piecewise_nhdsWithin", "code": "theorem Filter.Tendsto.piecewise_nhdsWithin {f g : \u03b1 \u2192 \u03b2} {t : Set \u03b1} [\u2200 x, Decidable (x \u2208 t)]\n    {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b2} (h\u2080 : Tendsto f (\ud835\udcdd[s \u2229 t] a) l)\n    (h\u2081 : Tendsto g (\ud835\udcdd[s \u2229 t\u1d9c] a) l) : Tendsto (piecewise t f g) (\ud835\udcdd[s] a) l", "start": [347, 1], "end": [350, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.if_nhdsWithin", "code": "theorem Filter.Tendsto.if_nhdsWithin {f g : \u03b1 \u2192 \u03b2} {p : \u03b1 \u2192 Prop} [DecidablePred p] {a : \u03b1}\n    {s : Set \u03b1} {l : Filter \u03b2} (h\u2080 : Tendsto f (\ud835\udcdd[s \u2229 { x | p x }] a) l)\n    (h\u2081 : Tendsto g (\ud835\udcdd[s \u2229 { x | \u00acp x }] a) l) :\n    Tendsto (fun x => if p x then f x else g x) (\ud835\udcdd[s] a) l", "start": [353, 1], "end": [357, 29], "kind": "commanddeclaration"}, {"full_name": "map_nhdsWithin", "code": "theorem map_nhdsWithin (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (s : Set \u03b1) :\n    map f (\ud835\udcdd[s] a) = \u2a05 t \u2208 { t : Set \u03b1 | a \u2208 t \u2227 IsOpen t }, \ud835\udcdf (f '' (t \u2229 s))", "start": [360, 1], "end": [362, 47], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_mono_left", "code": "theorem tendsto_nhdsWithin_mono_left {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s t : Set \u03b1} {l : Filter \u03b2} (hst : s \u2286 t)\n    (h : Tendsto f (\ud835\udcdd[t] a) l) : Tendsto f (\ud835\udcdd[s] a) l", "start": [365, 1], "end": [367, 39], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_mono_right", "code": "theorem tendsto_nhdsWithin_mono_right {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} {s t : Set \u03b1} (hst : s \u2286 t)\n    (h : Tendsto f l (\ud835\udcdd[s] a)) : Tendsto f l (\ud835\udcdd[t] a)", "start": [370, 1], "end": [372, 39], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_of_tendsto_nhds", "code": "theorem tendsto_nhdsWithin_of_tendsto_nhds {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b2}\n    (h : Tendsto f (\ud835\udcdd a) l) : Tendsto f (\ud835\udcdd[s] a) l", "start": [375, 1], "end": [377, 26], "kind": "commanddeclaration"}, {"full_name": "eventually_mem_of_tendsto_nhdsWithin", "code": "theorem eventually_mem_of_tendsto_nhdsWithin {f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b2}\n    (h : Tendsto f l (\ud835\udcdd[s] a)) : \u2200\u1da0 i in l, f i \u2208 s", "start": [380, 1], "end": [384, 45], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_of_tendsto_nhdsWithin", "code": "theorem tendsto_nhds_of_tendsto_nhdsWithin {f : \u03b2 \u2192 \u03b1} {a : \u03b1} {s : Set \u03b1} {l : Filter \u03b2}\n    (h : Tendsto f l (\ud835\udcdd[s] a)) : Tendsto f l (\ud835\udcdd a)", "start": [387, 1], "end": [389, 34], "kind": "commanddeclaration"}, {"full_name": "principal_subtype", "code": "theorem principal_subtype {\u03b1 : Type*} (s : Set \u03b1) (t : Set s) :\n    \ud835\udcdf t = comap (\u2191) (\ud835\udcdf (((\u2191) : s \u2192 \u03b1) '' t))", "start": [393, 1], "end": [395, 66], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_neBot_of_mem", "code": "theorem nhdsWithin_neBot_of_mem {s : Set \u03b1} {x : \u03b1} (hx : x \u2208 s) : NeBot (\ud835\udcdd[s] x)", "start": [398, 1], "end": [399, 58], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_of_nhdsWithin_neBot", "code": "theorem IsClosed.mem_of_nhdsWithin_neBot {s : Set \u03b1} (hs : IsClosed s) {x : \u03b1}\n    (hx : NeBot <| \ud835\udcdd[s] x) : x \u2208 s", "start": [402, 1], "end": [404, 56], "kind": "commanddeclaration"}, {"full_name": "DenseRange.nhdsWithin_neBot", "code": "theorem DenseRange.nhdsWithin_neBot {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1} (h : DenseRange f) (x : \u03b1) :\n    NeBot (\ud835\udcdd[range f] x)", "start": [407, 1], "end": [409, 36], "kind": "commanddeclaration"}, {"full_name": "mem_closure_pi", "code": "theorem mem_closure_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {I : Set \u03b9}\n    {s : \u2200 i, Set (\u03b1 i)} {x : \u2200 i, \u03b1 i} : x \u2208 closure (pi I s) \u2194 \u2200 i \u2208 I, x i \u2208 closure (s i)", "start": [412, 1], "end": [414, 68], "kind": "commanddeclaration"}, {"full_name": "closure_pi_set", "code": "theorem closure_pi_set {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] (I : Set \u03b9)\n    (s : \u2200 i, Set (\u03b1 i)) : closure (pi I s) = pi I fun i => closure (s i)", "start": [417, 1], "end": [419, 34], "kind": "commanddeclaration"}, {"full_name": "dense_pi", "code": "theorem dense_pi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] {s : \u2200 i, Set (\u03b1 i)}\n    (I : Set \u03b9) (hs : \u2200 i \u2208 I, Dense (s i)) : Dense (pi I s)", "start": [422, 1], "end": [425, 13], "kind": "commanddeclaration"}, {"full_name": "eventuallyEq_nhdsWithin_iff", "code": "theorem eventuallyEq_nhdsWithin_iff {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} :\n    f =\u1da0[\ud835\udcdd[s] a] g \u2194 \u2200\u1da0 x in \ud835\udcdd a, x \u2208 s \u2192 f x = g x", "start": [428, 1], "end": [430, 20], "kind": "commanddeclaration"}, {"full_name": "eventuallyEq_nhdsWithin_of_eqOn", "code": "theorem eventuallyEq_nhdsWithin_of_eqOn {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h : EqOn f g s) :\n    f =\u1da0[\ud835\udcdd[s] a] g", "start": [433, 1], "end": [435, 21], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.eventuallyEq_nhdsWithin", "code": "theorem Set.EqOn.eventuallyEq_nhdsWithin {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} (h : EqOn f g s) :\n    f =\u1da0[\ud835\udcdd[s] a] g", "start": [438, 1], "end": [440, 36], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_congr", "code": "theorem tendsto_nhdsWithin_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1} {l : Filter \u03b2}\n    (hfg : \u2200 x \u2208 s, f x = g x) (hf : Tendsto f (\ud835\udcdd[s] a) l) : Tendsto g (\ud835\udcdd[s] a) l", "start": [443, 1], "end": [445, 63], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_of_forall", "code": "theorem eventually_nhdsWithin_of_forall {s : Set \u03b1} {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200 x \u2208 s, p x) :\n    \u2200\u1da0 x in \ud835\udcdd[s] a, p x", "start": [448, 1], "end": [450, 21], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within", "code": "theorem tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within {a : \u03b1} {l : Filter \u03b2} {s : Set \u03b1}\n    (f : \u03b2 \u2192 \u03b1) (h1 : Tendsto f l (\ud835\udcdd a)) (h2 : \u2200\u1da0 x in l, f x \u2208 s) : Tendsto f l (\ud835\udcdd[s] a)", "start": [453, 1], "end": [455, 45], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_iff", "code": "theorem tendsto_nhdsWithin_iff {a : \u03b1} {l : Filter \u03b2} {s : Set \u03b1} {f : \u03b2 \u2192 \u03b1} :\n    Tendsto f l (\ud835\udcdd[s] a) \u2194 Tendsto f l (\ud835\udcdd a) \u2227 \u2200\u1da0 n in l, f n \u2208 s", "start": [458, 1], "end": [461, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_range", "code": "@[simp]\ntheorem tendsto_nhdsWithin_range {a : \u03b1} {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    Tendsto f l (\ud835\udcdd[range f] a) \u2194 Tendsto f l (\ud835\udcdd a)", "start": [464, 1], "end": [468, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.eq_of_nhdsWithin", "code": "theorem Filter.EventuallyEq.eq_of_nhdsWithin {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f =\u1da0[\ud835\udcdd[s] a] g)\n    (hmem : a \u2208 s) : f a = g a", "start": [471, 1], "end": [473, 28], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_of_eventually_nhds", "code": "theorem eventually_nhdsWithin_of_eventually_nhds {\u03b1 : Type*} [TopologicalSpace \u03b1] {s : Set \u03b1}\n    {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in \ud835\udcdd a, p x) : \u2200\u1da0 x in \ud835\udcdd[s] a, p x", "start": [476, 1], "end": [478, 31], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_subtype", "code": "theorem mem_nhdsWithin_subtype {s : Set \u03b1} {a : { x // x \u2208 s }} {t u : Set { x // x \u2208 s }} :\n    t \u2208 \ud835\udcdd[u] a \u2194 t \u2208 comap ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd[(\u2191) '' u] a)", "start": [485, 1], "end": [487, 78], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_subtype", "code": "theorem nhdsWithin_subtype (s : Set \u03b1) (a : { x // x \u2208 s }) (t : Set { x // x \u2208 s }) :\n    \ud835\udcdd[t] a = comap ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd[(\u2191) '' t] a)", "start": [490, 1], "end": [492, 45], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_eq_map_subtype_coe", "code": "theorem nhdsWithin_eq_map_subtype_coe {s : Set \u03b1} {a : \u03b1} (h : a \u2208 s) :\n    \ud835\udcdd[s] a = map ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd \u27e8a, h\u27e9)", "start": [495, 1], "end": [497, 37], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_subtype_iff_nhdsWithin", "code": "theorem mem_nhds_subtype_iff_nhdsWithin {s : Set \u03b1} {a : s} {t : Set s} :\n    t \u2208 \ud835\udcdd a \u2194 (\u2191) '' t \u2208 \ud835\udcdd[s] (a : \u03b1)", "start": [500, 1], "end": [502, 71], "kind": "commanddeclaration"}, {"full_name": "preimage_coe_mem_nhds_subtype", "code": "theorem preimage_coe_mem_nhds_subtype {s t : Set \u03b1} {a : s} : (\u2191) \u207b\u00b9' t \u2208 \ud835\udcdd a \u2194 t \u2208 \ud835\udcdd[s] \u2191a", "start": [505, 1], "end": [506, 39], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhdsWithin_iff_subtype", "code": "theorem tendsto_nhdsWithin_iff_subtype {s : Set \u03b1} {a : \u03b1} (h : a \u2208 s) (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b2) :\n    Tendsto f (\ud835\udcdd[s] a) l \u2194 Tendsto (s.restrict f) (\ud835\udcdd \u27e8a, h\u27e9) l", "start": [509, 1], "end": [511, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt", "code": "def ContinuousWithinAt (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (x : \u03b1) : Prop :=\n  Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd (f x))", "start": [516, 1], "end": [519, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.tendsto", "code": "theorem ContinuousWithinAt.tendsto {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : ContinuousWithinAt f s x) :\n    Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd (f x))", "start": [522, 1], "end": [527, 4], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn", "code": "def ContinuousOn (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  \u2200 x \u2208 s, ContinuousWithinAt f s x", "start": [530, 1], "end": [533, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.continuousWithinAt", "code": "theorem ContinuousOn.continuousWithinAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (hf : ContinuousOn f s)\n    (hx : x \u2208 s) : ContinuousWithinAt f s x", "start": [536, 1], "end": [538, 10], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_univ", "code": "theorem continuousWithinAt_univ (f : \u03b1 \u2192 \u03b2) (x : \u03b1) :\n    ContinuousWithinAt f Set.univ x \u2194 ContinuousAt f x", "start": [541, 1], "end": [543, 57], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_continuousOn_univ", "code": "theorem continuous_iff_continuousOn_univ {f : \u03b1 \u2192 \u03b2} : Continuous f \u2194 ContinuousOn f univ", "start": [546, 1], "end": [548, 21], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_iff_continuousAt_restrict", "code": "theorem continuousWithinAt_iff_continuousAt_restrict (f : \u03b1 \u2192 \u03b2) {x : \u03b1} {s : Set \u03b1} (h : x \u2208 s) :\n    ContinuousWithinAt f s x \u2194 ContinuousAt (s.restrict f) \u27e8x, h\u27e9", "start": [551, 1], "end": [553, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.tendsto_nhdsWithin", "code": "theorem ContinuousWithinAt.tendsto_nhdsWithin {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1} {t : Set \u03b2}\n    (h : ContinuousWithinAt f s x) (ht : MapsTo f s t) : Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd[t] f x)", "start": [556, 1], "end": [558, 86], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.tendsto_nhdsWithin_image", "code": "theorem ContinuousWithinAt.tendsto_nhdsWithin_image {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1}\n    (h : ContinuousWithinAt f s x) : Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd[f '' s] f x)", "start": [561, 1], "end": [563, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.prod_map", "code": "theorem ContinuousWithinAt.prod_map {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1} {y : \u03b2}\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g t y) :\n    ContinuousWithinAt (Prod.map f g) (s \u00d7\u02e2 t) (x, y)", "start": [566, 1], "end": [571, 23], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_prod_of_discrete_left", "code": "theorem continuousWithinAt_prod_of_discrete_left [DiscreteTopology \u03b1]\n    {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u00d7 \u03b2)} {x : \u03b1 \u00d7 \u03b2} :\n    ContinuousWithinAt f s x \u2194 ContinuousWithinAt (f \u27e8x.1, \u00b7\u27e9) {b | (x.1, b) \u2208 s} x.2", "start": [574, 1], "end": [578, 39], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_prod_of_discrete_right", "code": "theorem continuousWithinAt_prod_of_discrete_right [DiscreteTopology \u03b2]\n    {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u00d7 \u03b2)} {x : \u03b1 \u00d7 \u03b2} :\n    ContinuousWithinAt f s x \u2194 ContinuousWithinAt (f \u27e8\u00b7, x.2\u27e9) {a | (a, x.2) \u2208 s} x.1", "start": [580, 1], "end": [584, 39], "kind": "commanddeclaration"}, {"full_name": "continuousAt_prod_of_discrete_left", "code": "theorem continuousAt_prod_of_discrete_left [DiscreteTopology \u03b1] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {x : \u03b1 \u00d7 \u03b2} :\n    ContinuousAt f x \u2194 ContinuousAt (f \u27e8x.1, \u00b7\u27e9) x.2", "start": [586, 1], "end": [588, 86], "kind": "commanddeclaration"}, {"full_name": "continuousAt_prod_of_discrete_right", "code": "theorem continuousAt_prod_of_discrete_right [DiscreteTopology \u03b2] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {x : \u03b1 \u00d7 \u03b2} :\n    ContinuousAt f x \u2194 ContinuousAt (f \u27e8\u00b7, x.2\u27e9) x.1", "start": [590, 1], "end": [592, 87], "kind": "commanddeclaration"}, {"full_name": "continuousOn_prod_of_discrete_left", "code": "theorem continuousOn_prod_of_discrete_left [DiscreteTopology \u03b1] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u00d7 \u03b2)} :\n    ContinuousOn f s \u2194 \u2200 a, ContinuousOn (f \u27e8a, \u00b7\u27e9) {b | (a, b) \u2208 s}", "start": [594, 1], "end": [596, 85], "kind": "commanddeclaration"}, {"full_name": "continuousOn_prod_of_discrete_right", "code": "theorem continuousOn_prod_of_discrete_right [DiscreteTopology \u03b2] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} {s : Set (\u03b1 \u00d7 \u03b2)} :\n    ContinuousOn f s \u2194 \u2200 b, ContinuousOn (f \u27e8\u00b7, b\u27e9) {a | (a, b) \u2208 s}", "start": [598, 1], "end": [600, 100], "kind": "commanddeclaration"}, {"full_name": "continuous_prod_of_discrete_left", "code": "theorem continuous_prod_of_discrete_left [DiscreteTopology \u03b1] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} :\n    Continuous f \u2194 \u2200 a, Continuous (f \u27e8a, \u00b7\u27e9)", "start": [602, 1], "end": [606, 87], "kind": "commanddeclaration"}, {"full_name": "continuous_prod_of_discrete_right", "code": "theorem continuous_prod_of_discrete_right [DiscreteTopology \u03b2] {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} :\n    Continuous f \u2194 \u2200 b, Continuous (f \u27e8\u00b7, b\u27e9)", "start": [608, 1], "end": [610, 88], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_pi", "code": "theorem continuousWithinAt_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    {f : \u03b1 \u2192 \u2200 i, \u03c0 i} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt f s x \u2194 \u2200 i, ContinuousWithinAt (fun y => f y i) s x", "start": [612, 1], "end": [615, 18], "kind": "commanddeclaration"}, {"full_name": "continuousOn_pi", "code": "theorem continuousOn_pi {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    {f : \u03b1 \u2192 \u2200 i, \u03c0 i} {s : Set \u03b1} : ContinuousOn f s \u2194 \u2200 i, ContinuousOn (fun y => f y i) s", "start": [618, 1], "end": [620, 100], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.fin_insertNth", "code": "theorem ContinuousWithinAt.fin_insertNth {n} {\u03c0 : Fin (n + 1) \u2192 Type*}\n    [\u2200 i, TopologicalSpace (\u03c0 i)] (i : Fin (n + 1)) {f : \u03b1 \u2192 \u03c0 i} {a : \u03b1} {s : Set \u03b1}\n    (hf : ContinuousWithinAt f s a) {g : \u03b1 \u2192 \u2200 j : Fin n, \u03c0 (i.succAbove j)}\n    (hg : ContinuousWithinAt g s a) : ContinuousWithinAt (fun a => i.insertNth (f a) (g a)) s a", "start": [623, 1], "end": [627, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.fin_insertNth", "code": "nonrec theorem ContinuousOn.fin_insertNth {n} {\u03c0 : Fin (n + 1) \u2192 Type*}\n    [\u2200 i, TopologicalSpace (\u03c0 i)] (i : Fin (n + 1)) {f : \u03b1 \u2192 \u03c0 i} {s : Set \u03b1}\n    (hf : ContinuousOn f s) {g : \u03b1 \u2192 \u2200 j : Fin n, \u03c0 (i.succAbove j)} (hg : ContinuousOn g s) :\n    ContinuousOn (fun a => i.insertNth (f a) (g a)) s", "start": [630, 1], "end": [634, 38], "kind": "commanddeclaration"}, {"full_name": "continuousOn_iff", "code": "theorem continuousOn_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194\n      \u2200 x \u2208 s, \u2200 t : Set \u03b2, IsOpen t \u2192 f x \u2208 t \u2192 \u2203 u, IsOpen u \u2227 x \u2208 u \u2227 u \u2229 s \u2286 f \u207b\u00b9' t", "start": [637, 1], "end": [640, 80], "kind": "commanddeclaration"}, {"full_name": "continuousOn_iff_continuous_restrict", "code": "theorem continuousOn_iff_continuous_restrict {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 Continuous (s.restrict f)", "start": [643, 1], "end": [649, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.restrict", "code": "alias \u27e8ContinuousOn.restrict, _\u27e9 := continuousOn_iff_continuous_restrict", "start": [653, 1], "end": [653, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ContinuousOn.restrict_mapsTo", "code": "theorem ContinuousOn.restrict_mapsTo {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hf : ContinuousOn f s)\n    (ht : MapsTo f s t) : Continuous (ht.restrict f s t)", "start": [655, 1], "end": [657, 28], "kind": "commanddeclaration"}, {"full_name": "continuousOn_iff'", "code": "theorem continuousOn_iff' {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 \u2200 t : Set \u03b2, IsOpen t \u2192 \u2203 u, IsOpen u \u2227 f \u207b\u00b9' t \u2229 s = u \u2229 s", "start": [659, 1], "end": [668, 78], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.mono_dom", "code": "theorem ContinuousOn.mono_dom {\u03b1 \u03b2 : Type*} {t\u2081 t\u2082 : TopologicalSpace \u03b1} {t\u2083 : TopologicalSpace \u03b2}\n    (h\u2081 : t\u2082 \u2264 t\u2081) {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (h\u2082 : @ContinuousOn \u03b1 \u03b2 t\u2081 t\u2083 f s) :\n    @ContinuousOn \u03b1 \u03b2 t\u2082 t\u2083 f s", "start": [671, 1], "end": [676, 61], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.mono_rng", "code": "theorem ContinuousOn.mono_rng {\u03b1 \u03b2 : Type*} {t\u2081 : TopologicalSpace \u03b1} {t\u2082 t\u2083 : TopologicalSpace \u03b2}\n    (h\u2081 : t\u2082 \u2264 t\u2083) {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (h\u2082 : @ContinuousOn \u03b1 \u03b2 t\u2081 t\u2082 f s) :\n    @ContinuousOn \u03b1 \u03b2 t\u2081 t\u2083 f s", "start": [679, 1], "end": [684, 29], "kind": "commanddeclaration"}, {"full_name": "continuousOn_iff_isClosed", "code": "theorem continuousOn_iff_isClosed {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 \u2200 t : Set \u03b2, IsClosed t \u2192 \u2203 u, IsClosed u \u2227 f \u207b\u00b9' t \u2229 s = u \u2229 s", "start": [687, 1], "end": [693, 87], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.prod_map", "code": "theorem ContinuousOn.prod_map {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g t) : ContinuousOn (Prod.map f g) (s \u00d7\u02e2 t)", "start": [696, 1], "end": [698, 73], "kind": "commanddeclaration"}, {"full_name": "continuous_of_cover_nhds", "code": "theorem continuous_of_cover_nhds {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2} {s : \u03b9 \u2192 Set \u03b1}\n    (hs : \u2200 x : \u03b1, \u2203 i, s i \u2208 \ud835\udcdd x) (hf : \u2200 i, ContinuousOn f (s i)) :\n    Continuous f", "start": [701, 1], "end": [706, 38], "kind": "commanddeclaration"}, {"full_name": "continuousOn_empty", "code": "theorem continuousOn_empty (f : \u03b1 \u2192 \u03b2) : ContinuousOn f \u2205", "start": [709, 1], "end": [709, 81], "kind": "commanddeclaration"}, {"full_name": "continuousOn_singleton", "code": "theorem continuousOn_singleton (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : ContinuousOn f {a}", "start": [712, 1], "end": [715, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.continuousOn", "code": "theorem Set.Subsingleton.continuousOn {s : Set \u03b1} (hs : s.Subsingleton) (f : \u03b1 \u2192 \u03b2) :\n    ContinuousOn f s", "start": [718, 1], "end": [720, 68], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_le_comap", "code": "theorem nhdsWithin_le_comap {x : \u03b1} {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (ctsf : ContinuousWithinAt f s x) :\n    \ud835\udcdd[s] x \u2264 comap f (\ud835\udcdd[f '' s] f x)", "start": [723, 1], "end": [725, 41], "kind": "commanddeclaration"}, {"full_name": "comap_nhdsWithin_range", "code": "@[simp]\ntheorem comap_nhdsWithin_range {\u03b1} (f : \u03b1 \u2192 \u03b2) (y : \u03b2) : comap f (\ud835\udcdd[range f] y) = comap f (\ud835\udcdd y)", "start": [728, 1], "end": [730, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.mono", "code": "theorem ContinuousWithinAt.mono {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} (h : ContinuousWithinAt f t x)\n    (hs : s \u2286 t) : ContinuousWithinAt f s x", "start": [733, 1], "end": [735, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.mono_of_mem", "code": "theorem ContinuousWithinAt.mono_of_mem {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1}\n    (h : ContinuousWithinAt f t x) (hs : t \u2208 \ud835\udcdd[s] x) : ContinuousWithinAt f s x", "start": [738, 1], "end": [740, 40], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_congr_nhds", "code": "theorem continuousWithinAt_congr_nhds {f : \u03b1 \u2192 \u03b2} (h : \ud835\udcdd[s] x = \ud835\udcdd[t] x) :\n    ContinuousWithinAt f s x \u2194 ContinuousWithinAt f t x", "start": [743, 1], "end": [745, 36], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_inter'", "code": "theorem continuousWithinAt_inter' {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} (h : t \u2208 \ud835\udcdd[s] x) :\n    ContinuousWithinAt f (s \u2229 t) x \u2194 ContinuousWithinAt f s x", "start": [747, 1], "end": [749, 55], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_inter", "code": "theorem continuousWithinAt_inter {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} (h : t \u2208 \ud835\udcdd x) :\n    ContinuousWithinAt f (s \u2229 t) x \u2194 ContinuousWithinAt f s x", "start": [752, 1], "end": [754, 54], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_union", "code": "theorem continuousWithinAt_union {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt f (s \u222a t) x \u2194 ContinuousWithinAt f s x \u2227 ContinuousWithinAt f t x", "start": [757, 1], "end": [759, 64], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.union", "code": "theorem ContinuousWithinAt.union {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1} (hs : ContinuousWithinAt f s x)\n    (ht : ContinuousWithinAt f t x) : ContinuousWithinAt f (s \u222a t) x", "start": [762, 1], "end": [764, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.mem_closure_image", "code": "theorem ContinuousWithinAt.mem_closure_image {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1}\n    (h : ContinuousWithinAt f s x) (hx : x \u2208 closure s) : f x \u2208 closure (f '' s)", "start": [767, 1], "end": [770, 94], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.mem_closure", "code": "theorem ContinuousWithinAt.mem_closure {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} {A : Set \u03b2}\n    (h : ContinuousWithinAt f s x) (hx : x \u2208 closure s) (hA : MapsTo f s A) : f x \u2208 closure A", "start": [773, 1], "end": [775, 64], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.closure_of_continuousWithinAt", "code": "theorem Set.MapsTo.closure_of_continuousWithinAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (h : MapsTo f s t) (hc : \u2200 x \u2208 closure s, ContinuousWithinAt f s x) :\n    MapsTo f (closure s) (closure t)", "start": [778, 1], "end": [780, 79], "kind": "commanddeclaration"}, {"full_name": "Set.MapsTo.closure_of_continuousOn", "code": "theorem Set.MapsTo.closure_of_continuousOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (h : MapsTo f s t)\n    (hc : ContinuousOn f (closure s)) : MapsTo f (closure s) (closure t)", "start": [783, 1], "end": [785, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.image_closure", "code": "theorem ContinuousWithinAt.image_closure {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : \u2200 x \u2208 closure s, ContinuousWithinAt f s x) : f '' closure s \u2286 closure (f '' s)", "start": [788, 1], "end": [790, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.image_closure", "code": "theorem ContinuousOn.image_closure {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : ContinuousOn f (closure s)) :\n    f '' closure s \u2286 closure (f '' s)", "start": [793, 1], "end": [795, 77], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_singleton", "code": "@[simp]\ntheorem continuousWithinAt_singleton {f : \u03b1 \u2192 \u03b2} {x : \u03b1} : ContinuousWithinAt f {x} x", "start": [798, 1], "end": [800, 74], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_insert_self", "code": "@[simp]\ntheorem continuousWithinAt_insert_self {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1} :\n    ContinuousWithinAt f (insert x s) x \u2194 ContinuousWithinAt f s x", "start": [803, 1], "end": [807, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.insert_self", "code": "alias \u27e8_, ContinuousWithinAt.insert_self\u27e9 := continuousWithinAt_insert_self", "start": [810, 1], "end": [810, 76], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ContinuousWithinAt.diff_iff", "code": "theorem ContinuousWithinAt.diff_iff {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} {x : \u03b1}\n    (ht : ContinuousWithinAt f t x) : ContinuousWithinAt f (s \\ t) x \u2194 ContinuousWithinAt f s x", "start": [813, 1], "end": [816, 30], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_diff_self", "code": "@[simp]\ntheorem continuousWithinAt_diff_self {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt f (s \\ {x}) x \u2194 ContinuousWithinAt f s x", "start": [819, 1], "end": [822, 40], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_compl_self", "code": "@[simp]\ntheorem continuousWithinAt_compl_self {f : \u03b1 \u2192 \u03b2} {a : \u03b1} :\n    ContinuousWithinAt f {a}\u1d9c a \u2194 ContinuousAt f a", "start": [825, 1], "end": [828, 81], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_update_same", "code": "@[simp]\ntheorem continuousWithinAt_update_same [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} {y : \u03b2} :\n    ContinuousWithinAt (update f x y) s x \u2194 Tendsto f (\ud835\udcdd[s \\ {x}] x) (\ud835\udcdd y)", "start": [831, 1], "end": [839, 42], "kind": "commanddeclaration"}, {"full_name": "continuousAt_update_same", "code": "@[simp]\ntheorem continuousAt_update_same [DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {y : \u03b2} :\n    ContinuousAt (Function.update f x y) x \u2194 Tendsto f (\ud835\udcdd[\u2260] x) (\ud835\udcdd y)", "start": [842, 1], "end": [845, 85], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.continuousOn_image_of_leftInvOn", "code": "theorem IsOpenMap.continuousOn_image_of_leftInvOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (h : IsOpenMap (s.restrict f)) {finv : \u03b2 \u2192 \u03b1} (hleft : LeftInvOn finv f s) :\n    ContinuousOn finv (f '' s)", "start": [848, 1], "end": [854, 100], "kind": "commanddeclaration"}, {"full_name": "IsOpenMap.continuousOn_range_of_leftInverse", "code": "theorem IsOpenMap.continuousOn_range_of_leftInverse {f : \u03b1 \u2192 \u03b2} (hf : IsOpenMap f) {finv : \u03b2 \u2192 \u03b1}\n    (hleft : Function.LeftInverse finv f) : ContinuousOn finv (range f)", "start": [857, 1], "end": [860, 85], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.congr_mono", "code": "theorem ContinuousOn.congr_mono {f g : \u03b1 \u2192 \u03b2} {s s\u2081 : Set \u03b1} (h : ContinuousOn f s)\n    (h' : EqOn g f s\u2081) (h\u2081 : s\u2081 \u2286 s) : ContinuousOn g s\u2081", "start": [863, 1], "end": [870, 49], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.congr", "code": "theorem ContinuousOn.congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : ContinuousOn f s) (h' : EqOn g f s) :\n    ContinuousOn g s", "start": [873, 1], "end": [875, 34], "kind": "commanddeclaration"}, {"full_name": "continuousOn_congr", "code": "theorem continuousOn_congr {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h' : EqOn g f s) :\n    ContinuousOn g s \u2194 ContinuousOn f s", "start": [878, 1], "end": [880, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.continuousWithinAt", "code": "theorem ContinuousAt.continuousWithinAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : ContinuousAt f x) :\n    ContinuousWithinAt f s x", "start": [883, 1], "end": [885, 78], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_iff_continuousAt", "code": "theorem continuousWithinAt_iff_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : s \u2208 \ud835\udcdd x) :\n    ContinuousWithinAt f s x \u2194 ContinuousAt f x", "start": [888, 1], "end": [890, 75], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.continuousAt", "code": "theorem ContinuousWithinAt.continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1}\n    (h : ContinuousWithinAt f s x) (hs : s \u2208 \ud835\udcdd x) : ContinuousAt f x", "start": [893, 1], "end": [895, 48], "kind": "commanddeclaration"}, {"full_name": "IsOpen.continuousOn_iff", "code": "theorem IsOpen.continuousOn_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : IsOpen s) :\n    ContinuousOn f s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 ContinuousAt f a", "start": [898, 1], "end": [900, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.continuousAt", "code": "theorem ContinuousOn.continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : ContinuousOn f s)\n    (hx : s \u2208 \ud835\udcdd x) : ContinuousAt f x", "start": [903, 1], "end": [905, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.continuousOn", "code": "theorem ContinuousAt.continuousOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hcont : \u2200 x \u2208 s, ContinuousAt f x) :\n    ContinuousOn f s", "start": [908, 1], "end": [909, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.comp", "code": "theorem ContinuousWithinAt.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}\n    (hg : ContinuousWithinAt g t (f x)) (hf : ContinuousWithinAt f s x) (h : MapsTo f s t) :\n    ContinuousWithinAt (g \u2218 f) s x", "start": [912, 1], "end": [915, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.comp'", "code": "theorem ContinuousWithinAt.comp' {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} {x : \u03b1}\n    (hg : ContinuousWithinAt g t (f x)) (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (g \u2218 f) (s \u2229 f \u207b\u00b9' t) x", "start": [918, 1], "end": [921, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_continuousWithinAt", "code": "theorem ContinuousAt.comp_continuousWithinAt {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1}\n    (hg : ContinuousAt g (f x)) (hf : ContinuousWithinAt f s x) : ContinuousWithinAt (g \u2218 f) s x", "start": [924, 1], "end": [926, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.comp", "code": "theorem ContinuousOn.comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hg : ContinuousOn g t)\n    (hf : ContinuousOn f s) (h : MapsTo f s t) : ContinuousOn (g \u2218 f) s", "start": [929, 1], "end": [931, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.mono", "code": "theorem ContinuousOn.mono {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b1} (hf : ContinuousOn f s) (h : t \u2286 s) :\n    ContinuousOn f t", "start": [934, 1], "end": [935, 82], "kind": "commanddeclaration"}, {"full_name": "antitone_continuousOn", "code": "theorem antitone_continuousOn {f : \u03b1 \u2192 \u03b2} : Antitone (ContinuousOn f)", "start": [938, 1], "end": [939, 14], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.comp'", "code": "theorem ContinuousOn.comp' {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (hg : ContinuousOn g t)\n    (hf : ContinuousOn f s) : ContinuousOn (g \u2218 f) (s \u2229 f \u207b\u00b9' t)", "start": [942, 1], "end": [944, 69], "kind": "commanddeclaration"}, {"full_name": "Continuous.continuousOn", "code": "theorem Continuous.continuousOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : Continuous f) : ContinuousOn f s", "start": [947, 1], "end": [949, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.continuousWithinAt", "code": "theorem Continuous.continuousWithinAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : Continuous f) :\n    ContinuousWithinAt f s x", "start": [952, 1], "end": [954, 36], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_continuousOn", "code": "theorem Continuous.comp_continuousOn {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hg : Continuous g)\n    (hf : ContinuousOn f s) : ContinuousOn (g \u2218 f) s", "start": [957, 1], "end": [959, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.comp_continuous", "code": "theorem ContinuousOn.comp_continuous {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hg : ContinuousOn g s)\n    (hf : Continuous f) (hs : \u2200 x, f x \u2208 s) : Continuous (g \u2218 f)", "start": [962, 1], "end": [965, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.preimage_mem_nhdsWithin", "code": "theorem ContinuousWithinAt.preimage_mem_nhdsWithin {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1} {t : Set \u03b2}\n    (h : ContinuousWithinAt f s x) (ht : t \u2208 \ud835\udcdd (f x)) : f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "start": [968, 1], "end": [970, 7], "kind": "commanddeclaration"}, {"full_name": "Set.LeftInvOn.map_nhdsWithin_eq", "code": "theorem Set.LeftInvOn.map_nhdsWithin_eq {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {x : \u03b2} {s : Set \u03b2}\n    (h : LeftInvOn f g s) (hx : f (g x) = x) (hf : ContinuousWithinAt f (g '' s) (g x))\n    (hg : ContinuousWithinAt g s x) : map g (\ud835\udcdd[s] x) = \ud835\udcdd[g '' s] g x", "start": [973, 1], "end": [981, 78], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.map_nhds_eq", "code": "theorem Function.LeftInverse.map_nhds_eq {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} {x : \u03b2}\n    (h : Function.LeftInverse f g) (hf : ContinuousWithinAt f (range g) (g x))\n    (hg : ContinuousAt g x) : map g (\ud835\udcdd x) = \ud835\udcdd[range g] g x", "start": [984, 1], "end": [988, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.preimage_mem_nhdsWithin'", "code": "theorem ContinuousWithinAt.preimage_mem_nhdsWithin' {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {s : Set \u03b1} {t : Set \u03b2}\n    (h : ContinuousWithinAt f s x) (ht : t \u2208 \ud835\udcdd[f '' s] f x) : f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "start": [991, 1], "end": [993, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.preimage_mem_nhdsWithin''", "code": "theorem ContinuousWithinAt.preimage_mem_nhdsWithin''\n    {f : \u03b1 \u2192 \u03b2} {x : \u03b1} {y : \u03b2} {s t : Set \u03b2}\n    (h : ContinuousWithinAt f (f \u207b\u00b9' s) x) (ht : t \u2208 \ud835\udcdd[s] y) (hxy : y = f x) :\n    f \u207b\u00b9' t \u2208 \ud835\udcdd[f \u207b\u00b9' s] x", "start": [996, 1], "end": [1001, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.congr_continuousWithinAt", "code": "theorem Filter.EventuallyEq.congr_continuousWithinAt {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1}\n    (h : f =\u1da0[\ud835\udcdd[s] x] g) (hx : f x = g x) : ContinuousWithinAt f s x \u2194 ContinuousWithinAt g s x", "start": [1003, 1], "end": [1005, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.congr_of_eventuallyEq", "code": "theorem ContinuousWithinAt.congr_of_eventuallyEq {f f\u2081 : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1}\n    (h : ContinuousWithinAt f s x) (h\u2081 : f\u2081 =\u1da0[\ud835\udcdd[s] x] f) (hx : f\u2081 x = f x) :\n    ContinuousWithinAt f\u2081 s x", "start": [1008, 1], "end": [1011, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.congr", "code": "theorem ContinuousWithinAt.congr {f f\u2081 : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} (h : ContinuousWithinAt f s x)\n    (h\u2081 : \u2200 y \u2208 s, f\u2081 y = f y) (hx : f\u2081 x = f x) : ContinuousWithinAt f\u2081 s x", "start": [1014, 1], "end": [1016, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.congr_mono", "code": "theorem ContinuousWithinAt.congr_mono {f g : \u03b1 \u2192 \u03b2} {s s\u2081 : Set \u03b1} {x : \u03b1}\n    (h : ContinuousWithinAt f s x) (h' : EqOn g f s\u2081) (h\u2081 : s\u2081 \u2286 s) (hx : g x = f x) :\n    ContinuousWithinAt g s\u2081 x", "start": [1019, 1], "end": [1022, 26], "kind": "commanddeclaration"}, {"full_name": "continuousOn_const", "code": "theorem continuousOn_const {s : Set \u03b1} {c : \u03b2} : ContinuousOn (fun _ => c) s", "start": [1025, 1], "end": [1026, 32], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_const", "code": "theorem continuousWithinAt_const {b : \u03b2} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt (fun _ : \u03b1 => b) s x", "start": [1029, 1], "end": [1031, 38], "kind": "commanddeclaration"}, {"full_name": "continuousOn_id", "code": "theorem continuousOn_id {s : Set \u03b1} : ContinuousOn id s", "start": [1034, 1], "end": [1035, 29], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_id", "code": "theorem continuousWithinAt_id {s : Set \u03b1} {x : \u03b1} : ContinuousWithinAt id s x", "start": [1038, 1], "end": [1039, 35], "kind": "commanddeclaration"}, {"full_name": "continuousOn_open_iff", "code": "theorem continuousOn_open_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : IsOpen s) :\n    ContinuousOn f s \u2194 \u2200 t, IsOpen t \u2192 IsOpen (s \u2229 f \u207b\u00b9' t)", "start": [1042, 1], "end": [1052, 60], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.preimage_open_of_open", "code": "theorem ContinuousOn.preimage_open_of_open {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s \u2229 f \u207b\u00b9' t)", "start": [1055, 1], "end": [1057, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.isOpen_preimage", "code": "theorem ContinuousOn.isOpen_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (h : ContinuousOn f s)\n    (hs : IsOpen s) (hp : f \u207b\u00b9' t \u2286 s) (ht : IsOpen t) : IsOpen (f \u207b\u00b9' t)", "start": [1060, 1], "end": [1063, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.preimage_closed_of_closed", "code": "theorem ContinuousOn.preimage_closed_of_closed {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hs : IsClosed s) (ht : IsClosed t) : IsClosed (s \u2229 f \u207b\u00b9' t)", "start": [1066, 1], "end": [1070, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.preimage_interior_subset_interior_preimage", "code": "theorem ContinuousOn.preimage_interior_subset_interior_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hs : IsOpen s) : s \u2229 f \u207b\u00b9' interior t \u2286 s \u2229 interior (f \u207b\u00b9' t)", "start": [1073, 1], "end": [1079, 73], "kind": "commanddeclaration"}, {"full_name": "continuousOn_of_locally_continuousOn", "code": "theorem continuousOn_of_locally_continuousOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (h : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 ContinuousOn f (s \u2229 t)) : ContinuousOn f s", "start": [1082, 1], "end": [1087, 70], "kind": "commanddeclaration"}, {"full_name": "continuousOn_to_generateFrom_iff", "code": "theorem continuousOn_to_generateFrom_iff {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} :\n    @ContinuousOn \u03b1 \u03b2 _ (.generateFrom T) f s \u2194 \u2200 x \u2208 s, \u2200 t \u2208 T, f x \u2208 t \u2192 f \u207b\u00b9' t \u2208 \ud835\udcdd[s] x", "start": [1091, 1], "end": [1097, 45], "kind": "commanddeclaration"}, {"full_name": "continuousOn_open_of_generateFrom", "code": "theorem continuousOn_open_of_generateFrom {\u03b2 : Type*} {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 t \u2208 T, IsOpen (s \u2229 f \u207b\u00b9' t)) :\n    @ContinuousOn \u03b1 \u03b2 _ (.generateFrom T) f s", "start": [1100, 1], "end": [1104, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.prod", "code": "theorem ContinuousWithinAt.prod {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {x : \u03b1}\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun x => (f x, g x)) s x", "start": [1107, 1], "end": [1110, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.prod", "code": "theorem ContinuousOn.prod {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} {s : Set \u03b1} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) : ContinuousOn (fun x => (f x, g x)) s", "start": [1113, 1], "end": [1115, 46], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousWithinAt_iff", "code": "theorem Inducing.continuousWithinAt_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) {s : Set \u03b1}\n    {x : \u03b1} : ContinuousWithinAt f s x \u2194 ContinuousWithinAt (g \u2218 f) s x", "start": [1118, 1], "end": [1120, 66], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousOn_iff", "code": "theorem Inducing.continuousOn_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Inducing g) {s : Set \u03b1} :\n    ContinuousOn f s \u2194 ContinuousOn (g \u2218 f) s", "start": [1123, 1], "end": [1125, 52], "kind": "commanddeclaration"}, {"full_name": "Embedding.continuousOn_iff", "code": "theorem Embedding.continuousOn_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : Embedding g) {s : Set \u03b1} :\n    ContinuousOn f s \u2194 ContinuousOn (g \u2218 f) s", "start": [1128, 1], "end": [1130, 33], "kind": "commanddeclaration"}, {"full_name": "Embedding.map_nhdsWithin_eq", "code": "theorem Embedding.map_nhdsWithin_eq {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) (s : Set \u03b1) (x : \u03b1) :\n    map f (\ud835\udcdd[s] x) = \ud835\udcdd[f '' s] f x", "start": [1133, 1], "end": [1136, 60], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.map_nhdsWithin_preimage_eq", "code": "theorem OpenEmbedding.map_nhdsWithin_preimage_eq {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) (s : Set \u03b2)\n    (x : \u03b1) : map f (\ud835\udcdd[f \u207b\u00b9' s] x) = \ud835\udcdd[s] f x", "start": [1139, 1], "end": [1143, 31], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_of_not_mem_closure", "code": "theorem continuousWithinAt_of_not_mem_closure {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {x : \u03b1} :\n    x \u2209 closure s \u2192 ContinuousWithinAt f s x", "start": [1146, 1], "end": [1151, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.if'", "code": "theorem ContinuousOn.if' {s : Set \u03b1} {p : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (p a)]\n    (hpf : \u2200 a \u2208 s \u2229 frontier { a | p a },\n      Tendsto f (\ud835\udcdd[s \u2229 { a | p a }] a) (\ud835\udcdd <| if p a then f a else g a))\n    (hpg :\n      \u2200 a \u2208 s \u2229 frontier { a | p a },\n        Tendsto g (\ud835\udcdd[s \u2229 { a | \u00acp a }] a) (\ud835\udcdd <| if p a then f a else g a))\n    (hf : ContinuousOn f <| s \u2229 { a | p a }) (hg : ContinuousOn g <| s \u2229 { a | \u00acp a }) :\n    ContinuousOn (fun a => if p a then f a else g a) s", "start": [1154, 1], "end": [1178, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.piecewise'", "code": "theorem ContinuousOn.piecewise' {s t : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (a \u2208 t)]\n    (hpf : \u2200 a \u2208 s \u2229 frontier t, Tendsto f (\ud835\udcdd[s \u2229 t] a) (\ud835\udcdd (piecewise t f g a)))\n    (hpg : \u2200 a \u2208 s \u2229 frontier t, Tendsto g (\ud835\udcdd[s \u2229 t\u1d9c] a) (\ud835\udcdd (piecewise t f g a)))\n    (hf : ContinuousOn f <| s \u2229 t) (hg : ContinuousOn g <| s \u2229 t\u1d9c) :\n    ContinuousOn (piecewise t f g) s", "start": [1181, 1], "end": [1186, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.if", "code": "theorem ContinuousOn.if {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] {p : \u03b1 \u2192 Prop}\n    [\u2200 a, Decidable (p a)] {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2}\n    (hp : \u2200 a \u2208 s \u2229 frontier { a | p a }, f a = g a)\n    (hf : ContinuousOn f <| s \u2229 closure { a | p a })\n    (hg : ContinuousOn g <| s \u2229 closure { a | \u00acp a }) :\n    ContinuousOn (fun a => if p a then f a else g a) s", "start": [1189, 1], "end": [1207, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.piecewise", "code": "theorem ContinuousOn.piecewise {s t : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (a \u2208 t)]\n    (ht : \u2200 a \u2208 s \u2229 frontier t, f a = g a) (hf : ContinuousOn f <| s \u2229 closure t)\n    (hg : ContinuousOn g <| s \u2229 closure t\u1d9c) : ContinuousOn (piecewise t f g) s", "start": [1210, 1], "end": [1213, 14], "kind": "commanddeclaration"}, {"full_name": "continuous_if'", "code": "theorem continuous_if' {p : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (p a)]\n    (hpf : \u2200 a \u2208 frontier { x | p x }, Tendsto f (\ud835\udcdd[{ x | p x }] a) (\ud835\udcdd <| ite (p a) (f a) (g a)))\n    (hpg : \u2200 a \u2208 frontier { x | p x }, Tendsto g (\ud835\udcdd[{ x | \u00acp x }] a) (\ud835\udcdd <| ite (p a) (f a) (g a)))\n    (hf : ContinuousOn f { x | p x }) (hg : ContinuousOn g { x | \u00acp x }) :\n    Continuous fun a => ite (p a) (f a) (g a)", "start": [1216, 1], "end": [1222, 53], "kind": "commanddeclaration"}, {"full_name": "continuous_if", "code": "theorem continuous_if {p : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (p a)]\n    (hp : \u2200 a \u2208 frontier { x | p x }, f a = g a) (hf : ContinuousOn f (closure { x | p x }))\n    (hg : ContinuousOn g (closure { x | \u00acp x })) :\n    Continuous fun a => if p a then f a else g a", "start": [1225, 1], "end": [1230, 48], "kind": "commanddeclaration"}, {"full_name": "Continuous.if", "code": "theorem Continuous.if {p : \u03b1 \u2192 Prop} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (p a)]\n    (hp : \u2200 a \u2208 frontier { x | p x }, f a = g a) (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun a => if p a then f a else g a", "start": [1233, 1], "end": [1236, 51], "kind": "commanddeclaration"}, {"full_name": "continuous_if_const", "code": "theorem continuous_if_const (p : Prop) {f g : \u03b1 \u2192 \u03b2} [Decidable p] (hf : p \u2192 Continuous f)\n    (hg : \u00acp \u2192 Continuous g) : Continuous fun a => if p then f a else g a", "start": [1239, 1], "end": [1242, 22], "kind": "commanddeclaration"}, {"full_name": "Continuous.if_const", "code": "theorem Continuous.if_const (p : Prop) {f g : \u03b1 \u2192 \u03b2} [Decidable p] (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun a => if p then f a else g a", "start": [1245, 1], "end": [1247, 50], "kind": "commanddeclaration"}, {"full_name": "continuous_piecewise", "code": "theorem continuous_piecewise {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (a \u2208 s)]\n    (hs : \u2200 a \u2208 frontier s, f a = g a) (hf : ContinuousOn f (closure s))\n    (hg : ContinuousOn g (closure s\u1d9c)) : Continuous (piecewise s f g)", "start": [1250, 1], "end": [1253, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.piecewise", "code": "theorem Continuous.piecewise {s : Set \u03b1} {f g : \u03b1 \u2192 \u03b2} [\u2200 a, Decidable (a \u2208 s)]\n    (hs : \u2200 a \u2208 frontier s, f a = g a) (hf : Continuous f) (hg : Continuous g) :\n    Continuous (piecewise s f g)", "start": [1256, 1], "end": [1259, 14], "kind": "commanddeclaration"}, {"full_name": "IsOpen.ite'", "code": "theorem IsOpen.ite' {s s' t : Set \u03b1} (hs : IsOpen s) (hs' : IsOpen s')\n    (ht : \u2200 x \u2208 frontier t, x \u2208 s \u2194 x \u2208 s') : IsOpen (t.ite s s')", "start": [1262, 1], "end": [1268, 38], "kind": "commanddeclaration"}, {"full_name": "IsOpen.ite", "code": "theorem IsOpen.ite {s s' t : Set \u03b1} (hs : IsOpen s) (hs' : IsOpen s')\n    (ht : s \u2229 frontier t = s' \u2229 frontier t) : IsOpen (t.ite s s')", "start": [1271, 1], "end": [1273, 61], "kind": "commanddeclaration"}, {"full_name": "ite_inter_closure_eq_of_inter_frontier_eq", "code": "theorem ite_inter_closure_eq_of_inter_frontier_eq {s s' t : Set \u03b1}\n    (ht : s \u2229 frontier t = s' \u2229 frontier t) : t.ite s s' \u2229 closure t = s \u2229 closure t", "start": [1276, 1], "end": [1279, 48], "kind": "commanddeclaration"}, {"full_name": "ite_inter_closure_compl_eq_of_inter_frontier_eq", "code": "theorem ite_inter_closure_compl_eq_of_inter_frontier_eq {s s' t : Set \u03b1}\n    (ht : s \u2229 frontier t = s' \u2229 frontier t) : t.ite s s' \u2229 closure t\u1d9c = s' \u2229 closure t\u1d9c", "start": [1282, 1], "end": [1285, 32], "kind": "commanddeclaration"}, {"full_name": "continuousOn_piecewise_ite'", "code": "theorem continuousOn_piecewise_ite' {s s' t : Set \u03b1} {f f' : \u03b1 \u2192 \u03b2} [\u2200 x, Decidable (x \u2208 t)]\n    (h : ContinuousOn f (s \u2229 closure t)) (h' : ContinuousOn f' (s' \u2229 closure t\u1d9c))\n    (H : s \u2229 frontier t = s' \u2229 frontier t) (Heq : EqOn f f' (s \u2229 frontier t)) :\n    ContinuousOn (t.piecewise f f') (t.ite s s')", "start": [1288, 1], "end": [1295, 60], "kind": "commanddeclaration"}, {"full_name": "continuousOn_piecewise_ite", "code": "theorem continuousOn_piecewise_ite {s s' t : Set \u03b1} {f f' : \u03b1 \u2192 \u03b2} [\u2200 x, Decidable (x \u2208 t)]\n    (h : ContinuousOn f s) (h' : ContinuousOn f' s') (H : s \u2229 frontier t = s' \u2229 frontier t)\n    (Heq : EqOn f f' (s \u2229 frontier t)) : ContinuousOn (t.piecewise f f') (t.ite s s')", "start": [1298, 1], "end": [1302, 8], "kind": "commanddeclaration"}, {"full_name": "frontier_inter_open_inter", "code": "theorem frontier_inter_open_inter {s t : Set \u03b1} (ht : IsOpen t) :\n    frontier (s \u2229 t) \u2229 t = frontier s \u2229 t", "start": [1305, 1], "end": [1309, 37], "kind": "commanddeclaration"}, {"full_name": "continuousOn_fst", "code": "theorem continuousOn_fst {s : Set (\u03b1 \u00d7 \u03b2)} : ContinuousOn Prod.fst s", "start": [1312, 1], "end": [1313, 30], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_fst", "code": "theorem continuousWithinAt_fst {s : Set (\u03b1 \u00d7 \u03b2)} {p : \u03b1 \u00d7 \u03b2} : ContinuousWithinAt Prod.fst s p", "start": [1316, 1], "end": [1317, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.fst", "code": "theorem ContinuousOn.fst {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {s : Set \u03b1} (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (f x).1) s", "start": [1320, 1], "end": [1322, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.fst", "code": "theorem ContinuousWithinAt.fst {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {s : Set \u03b1} {a : \u03b1} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => (f x).fst) s a", "start": [1325, 1], "end": [1327, 45], "kind": "commanddeclaration"}, {"full_name": "continuousOn_snd", "code": "theorem continuousOn_snd {s : Set (\u03b1 \u00d7 \u03b2)} : ContinuousOn Prod.snd s", "start": [1330, 1], "end": [1331, 30], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_snd", "code": "theorem continuousWithinAt_snd {s : Set (\u03b1 \u00d7 \u03b2)} {p : \u03b1 \u00d7 \u03b2} : ContinuousWithinAt Prod.snd s p", "start": [1334, 1], "end": [1335, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.snd", "code": "theorem ContinuousOn.snd {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {s : Set \u03b1} (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (f x).2) s", "start": [1338, 1], "end": [1340, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.snd", "code": "theorem ContinuousWithinAt.snd {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {s : Set \u03b1} {a : \u03b1} (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => (f x).snd) s a", "start": [1343, 1], "end": [1345, 45], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_prod_iff", "code": "theorem continuousWithinAt_prod_iff {f : \u03b1 \u2192 \u03b2 \u00d7 \u03b3} {s : Set \u03b1} {x : \u03b1} :\n    ContinuousWithinAt f s x \u2194\n      ContinuousWithinAt (Prod.fst \u2218 f) s x \u2227 ContinuousWithinAt (Prod.snd \u2218 f) s x", "start": [1348, 1], "end": [1351, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/SmallSets.lean", "imports": ["Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Order/Filter/Lift.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.smallSets", "code": "def smallSets (l : Filter \u03b1) : Filter (Set \u03b1) :=\n  l.lift' powerset", "start": [35, 1], "end": [37, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_eq_generate", "code": "theorem smallSets_eq_generate {f : Filter \u03b1} : f.smallSets = generate (powerset '' f.sets)", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.smallSets", "code": "theorem HasBasis.smallSets {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : HasBasis l p s) :\n    HasBasis l.smallSets p fun i => \ud835\udcab s i", "start": [45, 1], "end": [47, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_smallSets", "code": "theorem hasBasis_smallSets (l : Filter \u03b1) :\n    HasBasis l.smallSets (fun t : Set \u03b1 => t \u2208 l) powerset", "start": [50, 1], "end": [52, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_smallSets_iff", "code": "theorem tendsto_smallSets_iff {f : \u03b1 \u2192 Set \u03b2} :\n    Tendsto f la lb.smallSets \u2194 \u2200 t \u2208 lb, \u2200\u1da0 x in la, f x \u2286 t", "start": [55, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_smallSets", "code": "theorem eventually_smallSets {p : Set \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 s in l.smallSets, p s) \u2194 \u2203 s \u2208 l, \u2200 t, t \u2286 s \u2192 p t", "start": [63, 1], "end": [66, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_smallSets'", "code": "theorem eventually_smallSets' {p : Set \u03b1 \u2192 Prop} (hp : \u2200 \u2983s t\u2984, s \u2286 t \u2192 p t \u2192 p s) :\n    (\u2200\u1da0 s in l.smallSets, p s) \u2194 \u2203 s \u2208 l, p s", "start": [69, 1], "end": [72, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_smallSets", "code": "theorem frequently_smallSets {p : Set \u03b1 \u2192 Prop} :\n    (\u2203\u1da0 s in l.smallSets, p s) \u2194 \u2200 t \u2208 l, \u2203 s, s \u2286 t \u2227 p s", "start": [75, 1], "end": [77, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.frequently_smallSets_mem", "code": "theorem frequently_smallSets_mem (l : Filter \u03b1) : \u2203\u1da0 s in l.smallSets, s \u2208 l", "start": [80, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.HasAntitoneBasis.tendsto_smallSets", "code": "theorem HasAntitoneBasis.tendsto_smallSets {\u03b9} [Preorder \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (hl : l.HasAntitoneBasis s) : Tendsto s atTop l.smallSets", "start": [84, 1], "end": [86, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.monotone_smallSets", "code": "@[mono]\ntheorem monotone_smallSets : Monotone (@smallSets \u03b1)", "start": [89, 1], "end": [91, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_bot", "code": "@[simp]\ntheorem smallSets_bot : (\u22a5 : Filter \u03b1).smallSets = pure \u2205", "start": [94, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_top", "code": "@[simp]\ntheorem smallSets_top : (\u22a4 : Filter \u03b1).smallSets = \u22a4", "start": [100, 1], "end": [102, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_principal", "code": "@[simp]\ntheorem smallSets_principal (s : Set \u03b1) : (\ud835\udcdf s).smallSets = \ud835\udcdf (\ud835\udcab s)", "start": [105, 1], "end": [107, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_comap", "code": "theorem smallSets_comap (l : Filter \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    (comap f l).smallSets = l.lift' (powerset \u2218 preimage f)", "start": [110, 1], "end": [112, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_smallSets", "code": "theorem comap_smallSets (l : Filter \u03b2) (f : \u03b1 \u2192 Set \u03b2) :\n    comap f l.smallSets = l.lift' (preimage f \u2218 powerset)", "start": [115, 1], "end": [117, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_iInf", "code": "theorem smallSets_iInf {f : \u03b9 \u2192 Filter \u03b1} : (iInf f).smallSets = \u2a05 i, (f i).smallSets", "start": [120, 1], "end": [121, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_inf", "code": "theorem smallSets_inf (l\u2081 l\u2082 : Filter \u03b1) : (l\u2081 \u2293 l\u2082).smallSets = l\u2081.smallSets \u2293 l\u2082.smallSets", "start": [124, 1], "end": [125, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.smallSets_neBot", "code": "instance smallSets_neBot (l : Filter \u03b1) : NeBot l.smallSets := by\n  refine' (lift'_neBot_iff _).2 fun _ _ => powerset_nonempty\n  exact monotone_powerset", "start": [128, 1], "end": [130, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.smallSets_mono", "code": "theorem Tendsto.smallSets_mono {s t : \u03b1 \u2192 Set \u03b2} (ht : Tendsto t la lb.smallSets)\n    (hst : \u2200\u1da0 x in la, s x \u2286 t x) : Tendsto s la lb.smallSets", "start": [133, 1], "end": [136, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.of_smallSets", "code": "theorem Tendsto.of_smallSets {s : \u03b1 \u2192 Set \u03b2} {f : \u03b1 \u2192 \u03b2} (hs : Tendsto s la lb.smallSets)\n    (hf : \u2200\u1da0 x in la, f x \u2208 s x) : Tendsto f la lb", "start": [139, 1], "end": [148, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_smallSets_eventually", "code": "@[simp]\ntheorem eventually_smallSets_eventually {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 s in l.smallSets, \u2200\u1da0 x in l', x \u2208 s \u2192 p x) \u2194 \u2200\u1da0 x in l \u2293 l', p x", "start": [151, 1], "end": [158, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_smallSets_forall", "code": "@[simp]\ntheorem eventually_smallSets_forall {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 s in l.smallSets, \u2200 x \u2208 s, p x) \u2194 \u2200\u1da0 x in l, p x", "start": [161, 1], "end": [164, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.of_smallSets", "code": "alias \u27e8Eventually.of_smallSets, Eventually.smallSets\u27e9 := eventually_smallSets_forall", "start": [167, 1], "end": [167, 85], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Eventually.smallSets", "code": "alias \u27e8Eventually.of_smallSets, Eventually.smallSets\u27e9 := eventually_smallSets_forall", "start": [167, 1], "end": [167, 85], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.eventually_smallSets_subset", "code": "@[simp]\ntheorem eventually_smallSets_subset {s : Set \u03b1} : (\u2200\u1da0 t in l.smallSets, t \u2286 s) \u2194 s \u2208 l", "start": [171, 1], "end": [173, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Subsemiring/Basic.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Algebra/Ring/Prod.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Submonoid/Centralizer.lean", "Mathlib/Algebra/Order/Ring/InjSurj.lean", "Mathlib/Algebra/GroupRingAction/Subobjects.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/Algebra/Ring/Equiv.lean"], "premises": [{"full_name": "AddSubmonoidWithOneClass", "code": "class AddSubmonoidWithOneClass (S R : Type*) [AddMonoidWithOne R]\n  [SetLike S R] extends AddSubmonoidClass S R, OneMemClass S R : Prop", "start": [32, 1], "end": [35, 70], "kind": "commanddeclaration"}, {"full_name": "natCast_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem natCast_mem [AddSubmonoidWithOneClass S R] (n : \u2115) : (n : R) \u2208 s", "start": [40, 1], "end": [42, 55], "kind": "commanddeclaration"}, {"full_name": "ofNat_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\nlemma ofNat_mem [AddSubmonoidWithOneClass S R] (s : S) (n : \u2115) [n.AtLeastTwo] :\n    no_index (OfNat.ofNat n) \u2208 s := by\n  rw [\u2190Nat.cast_eq_ofNat]; exact natCast_mem s n", "start": [45, 1], "end": [48, 49], "kind": "mathlibtacticlemma"}, {"full_name": "AddSubmonoidWithOneClass.toAddMonoidWithOne", "code": "instance (priority := 74) AddSubmonoidWithOneClass.toAddMonoidWithOne\n    [AddSubmonoidWithOneClass S R] : AddMonoidWithOne s :=\n  { AddSubmonoidClass.toAddMonoid s with\n    one := \u27e8_, one_mem s\u27e9\n    natCast := fun n => \u27e8n, natCast_mem s n\u27e9\n    natCast_zero := Subtype.ext Nat.cast_zero\n    natCast_succ := fun _ => Subtype.ext (Nat.cast_succ _) }", "start": [50, 1], "end": [56, 61], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass", "code": "class SubsemiringClass (S : Type*) (R : Type u) [NonAssocSemiring R]\n  [SetLike S R] extends SubmonoidClass S R, AddSubmonoidClass S R : Prop", "start": [65, 1], "end": [68, 73], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.addSubmonoidWithOneClass", "code": "instance (priority := 100) SubsemiringClass.addSubmonoidWithOneClass (S : Type*)\n    (R : Type u) [NonAssocSemiring R] [SetLike S R] [h : SubsemiringClass S R] :\n    AddSubmonoidWithOneClass S R :=\n  { h with }", "start": [72, 1], "end": [75, 13], "kind": "commanddeclaration"}, {"full_name": "coe_nat_mem", "code": "theorem coe_nat_mem (n : \u2115) : (n : R) \u2208 s", "start": [80, 1], "end": [82, 32], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toNonAssocSemiring", "code": "instance (priority := 75) toNonAssocSemiring : NonAssocSemiring s :=\n  Subtype.coe_injective.nonAssocSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl", "start": [88, 1], "end": [91, 34], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.nontrivial", "code": "instance nontrivial [Nontrivial R] : Nontrivial s :=\n  nontrivial_of_ne 0 1 fun H => zero_ne_one (congr_arg Subtype.val H)", "start": [94, 1], "end": [95, 70], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.noZeroDivisors", "code": "instance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s :=\n  Subtype.coe_injective.noZeroDivisors _ rfl fun _ _ => rfl", "start": [98, 1], "end": [99, 60], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.subtype", "code": "def subtype : s \u2192+* R :=\n  { SubmonoidClass.subtype s, AddSubmonoidClass.subtype s with toFun := (\u2191) }", "start": [102, 1], "end": [104, 78], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.coe_subtype", "code": "@[simp]\ntheorem coe_subtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R)", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toSemiring", "code": "instance (priority := 75) toSemiring {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] :\n    Semiring s :=\n  Subtype.coe_injective.semiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl", "start": [113, 1], "end": [117, 34], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] [SetLike S R] [SubsemiringClass S R] (x : s) (n : \u2115) :\n    ((x ^ n : s) : R) = (x : R) ^ n", "start": [120, 1], "end": [125, 24], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toCommSemiring", "code": "instance toCommSemiring {R} [CommSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    CommSemiring s :=\n  Subtype.coe_injective.commSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl", "start": [128, 1], "end": [132, 34], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toOrderedSemiring", "code": "instance toOrderedSemiring {R} [OrderedSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    OrderedSemiring s :=\n  Subtype.coe_injective.orderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [135, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toStrictOrderedSemiring", "code": "instance toStrictOrderedSemiring {R} [StrictOrderedSemiring R] [SetLike S R]\n    [SubsemiringClass S R] : StrictOrderedSemiring s :=\n  Subtype.coe_injective.strictOrderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [142, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toOrderedCommSemiring", "code": "instance toOrderedCommSemiring {R} [OrderedCommSemiring R] [SetLike S R] [SubsemiringClass S R] :\n    OrderedCommSemiring s :=\n  Subtype.coe_injective.orderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [149, 1], "end": [153, 51], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toStrictOrderedCommSemiring", "code": "instance toStrictOrderedCommSemiring {R} [StrictOrderedCommSemiring R] [SetLike S R]\n    [SubsemiringClass S R] : StrictOrderedCommSemiring s :=\n  Subtype.coe_injective.strictOrderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [156, 1], "end": [160, 51], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toLinearOrderedSemiring", "code": "instance toLinearOrderedSemiring {R} [LinearOrderedSemiring R] [SetLike S R]\n    [SubsemiringClass S R] : LinearOrderedSemiring s :=\n  Subtype.coe_injective.linearOrderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [163, 1], "end": [167, 85], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.toLinearOrderedCommSemiring", "code": "instance toLinearOrderedCommSemiring {R} [LinearOrderedCommSemiring R] [SetLike S R]\n    [SubsemiringClass S R] : LinearOrderedCommSemiring s :=\n  Subtype.coe_injective.linearOrderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [170, 1], "end": [174, 85], "kind": "commanddeclaration"}, {"full_name": "SubsemiringClass.instCharZero", "code": "instance instCharZero [CharZero R] : CharZero s :=\n  \u27e8Function.Injective.of_comp (f := Subtype.val) (g := Nat.cast (R := s)) Nat.cast_injective\u27e9", "start": [177, 1], "end": [178, 94], "kind": "commanddeclaration"}, {"full_name": "Subsemiring", "code": "structure Subsemiring (R : Type u) [NonAssocSemiring R] extends Submonoid R, AddSubmonoid R", "start": [186, 1], "end": [188, 92], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_toSubmonoid", "code": "@[simp]\ntheorem mem_toSubmonoid {s : Subsemiring R} {x : R} : x \u2208 s.toSubmonoid \u2194 x \u2208 s", "start": [211, 1], "end": [213, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_carrier", "code": "theorem mem_carrier {s : Subsemiring R} {x : R} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [217, 1], "end": [218, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.ext", "code": "@[ext]\ntheorem ext {S T : Subsemiring R} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [221, 1], "end": [224, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.copy", "code": "protected def copy (S : Subsemiring R) (s : Set R) (hs : s = \u2191S) : Subsemiring R :=\n  { S.toAddSubmonoid.copy s hs, S.toSubmonoid.copy s hs with carrier := s }", "start": [227, 1], "end": [230, 76], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : Subsemiring R) (s : Set R) (hs : s = \u2191S) : (S.copy s hs : Set R) = s", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.copy_eq", "code": "theorem copy_eq (S : Subsemiring R) (s : Set R) (hs : s = \u2191S) : S.copy s hs = S", "start": [238, 1], "end": [239, 27], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toSubmonoid_injective", "code": "theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subsemiring R \u2192 Submonoid R)", "start": [242, 1], "end": [243, 46], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toSubmonoid_strictMono", "code": "@[mono]\ntheorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subsemiring R \u2192 Submonoid R)", "start": [246, 1], "end": [248, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toSubmonoid_mono", "code": "@[mono]\ntheorem toSubmonoid_mono : Monotone (toSubmonoid : Subsemiring R \u2192 Submonoid R)", "start": [251, 1], "end": [253, 34], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toAddSubmonoid_injective", "code": "theorem toAddSubmonoid_injective :\n    Function.Injective (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R)", "start": [256, 1], "end": [258, 46], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toAddSubmonoid_strictMono", "code": "@[mono]\ntheorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R)", "start": [261, 1], "end": [263, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toAddSubmonoid_mono", "code": "@[mono]\ntheorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Subsemiring R \u2192 AddSubmonoid R)", "start": [266, 1], "end": [268, 37], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mk'", "code": "protected def mk' (s : Set R) (sm : Submonoid R) (hm : \u2191sm = s) (sa : AddSubmonoid R)\n    (ha : \u2191sa = s) : Subsemiring R where\n  carrier := s\n  zero_mem' := by exact ha \u25b8 sa.zero_mem\n  one_mem' := by exact hm \u25b8 sm.one_mem\n  add_mem' {x y} := by simpa only [\u2190 ha] using sa.add_mem\n  mul_mem' {x y} := by simpa only [\u2190 hm] using sm.mul_mem", "start": [271, 1], "end": [279, 58], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_mk'", "code": "@[simp]\ntheorem coe_mk' {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubmonoid R} (ha : \u2191sa = s) :\n    (Subsemiring.mk' s sm hm sa ha : Set R) = s", "start": [282, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_mk'", "code": "@[simp]\ntheorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubmonoid R} (ha : \u2191sa = s)\n    {x : R} : x \u2208 Subsemiring.mk' s sm hm sa ha \u2194 x \u2208 s", "start": [288, 1], "end": [291, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mk'_toSubmonoid", "code": "@[simp]\ntheorem mk'_toSubmonoid {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubmonoid R}\n    (ha : \u2191sa = s) : (Subsemiring.mk' s sm hm sa ha).toSubmonoid = sm", "start": [294, 1], "end": [297, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mk'_toAddSubmonoid", "code": "@[simp]\ntheorem mk'_toAddSubmonoid {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubmonoid R}\n    (ha : \u2191sa = s) : (Subsemiring.mk' s sm hm sa ha).toAddSubmonoid = sa", "start": [300, 1], "end": [303, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.one_mem", "code": "protected theorem one_mem : (1 : R) \u2208 s", "start": [312, 1], "end": [314, 12], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.zero_mem", "code": "protected theorem zero_mem : (0 : R) \u2208 s", "start": [317, 1], "end": [319, 13], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mul_mem", "code": "protected theorem mul_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x * y \u2208 s", "start": [322, 1], "end": [324, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.add_mem", "code": "protected theorem add_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x + y \u2208 s", "start": [327, 1], "end": [329, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.list_prod_mem", "code": "nonrec theorem list_prod_mem {R : Type*} [Semiring R] (s : Subsemiring R) {l : List R} :\n    (\u2200 x \u2208 l, x \u2208 s) \u2192 l.prod \u2208 s", "start": [332, 1], "end": [335, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.list_sum_mem", "code": "protected theorem list_sum_mem {l : List R} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s", "start": [338, 1], "end": [340, 15], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.multiset_prod_mem", "code": "protected theorem multiset_prod_mem {R} [CommSemiring R] (s : Subsemiring R) (m : Multiset R) :\n    (\u2200 a \u2208 m, a \u2208 s) \u2192 m.prod \u2208 s", "start": [343, 1], "end": [347, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.multiset_sum_mem", "code": "protected theorem multiset_sum_mem (m : Multiset R) : (\u2200 a \u2208 m, a \u2208 s) \u2192 m.sum \u2208 s", "start": [350, 1], "end": [353, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_mem", "code": "protected theorem prod_mem {R : Type*} [CommSemiring R] (s : Subsemiring R) {\u03b9 : Type*}\n    {t : Finset \u03b9} {f : \u03b9 \u2192 R} (h : \u2200 c \u2208 t, f c \u2208 s) : (\u220f i in t, f i) \u2208 s", "start": [356, 1], "end": [360, 13], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.sum_mem", "code": "protected theorem sum_mem (s : Subsemiring R) {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 R}\n    (h : \u2200 c \u2208 t, f c \u2208 s) : (\u2211 i in t, f i) \u2208 s", "start": [363, 1], "end": [367, 12], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toNonAssocSemiring", "code": "instance toNonAssocSemiring : NonAssocSemiring s :=\n  SubsemiringClass.toNonAssocSemiring _", "start": [370, 1], "end": [373, 40], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : R) = (1 : R)", "start": [376, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = (0 : R)", "start": [381, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : s) : ((x + y : s) : R) = (x + y : R)", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : ((x * y : s) : R) = (x * y : R)", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.nontrivial", "code": "instance nontrivial [Nontrivial R] : Nontrivial s :=\n  nontrivial_of_ne 0 1 fun H => zero_ne_one (congr_arg Subtype.val H)", "start": [396, 1], "end": [397, 70], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.pow_mem", "code": "protected theorem pow_mem {R : Type*} [Semiring R] (s : Subsemiring R) {x : R} (hx : x \u2208 s)\n    (n : \u2115) : x ^ n \u2208 s", "start": [400, 1], "end": [402, 15], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.noZeroDivisors", "code": "instance noZeroDivisors [NoZeroDivisors R] : NoZeroDivisors s where\n  eq_zero_or_eq_zero_of_mul_eq_zero {_ _} h :=\n    (eq_zero_or_eq_zero_of_mul_eq_zero <| Subtype.ext_iff.mp h).imp Subtype.eq Subtype.eq", "start": [405, 1], "end": [407, 90], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toSemiring", "code": "instance toSemiring {R} [Semiring R] (s : Subsemiring R) : Semiring s :=\n  { s.toNonAssocSemiring, s.toSubmonoid.toMonoid with }", "start": [410, 1], "end": [412, 56], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow {R} [Semiring R] (s : Subsemiring R) (x : s) (n : \u2115) :\n    ((x ^ n : s) : R) = (x : R) ^ n", "start": [415, 1], "end": [420, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toCommSemiring", "code": "instance toCommSemiring {R} [CommSemiring R] (s : Subsemiring R) : CommSemiring s :=\n  { s.toSemiring with mul_comm := fun _ _ => Subtype.eq <| mul_comm _ _ }", "start": [423, 1], "end": [425, 74], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.subtype", "code": "def subtype : s \u2192+* R :=\n  { s.toSubmonoid.subtype, s.toAddSubmonoid.subtype with toFun := (\u2191) }", "start": [428, 1], "end": [430, 72], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_subtype", "code": "@[simp]\ntheorem coe_subtype : \u21d1s.subtype = ((\u2191) : s \u2192 R)", "start": [433, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toOrderedSemiring", "code": "instance toOrderedSemiring {R} [OrderedSemiring R] (s : Subsemiring R) : OrderedSemiring s :=\n  Subtype.coe_injective.orderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [438, 1], "end": [441, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toStrictOrderedSemiring", "code": "instance toStrictOrderedSemiring {R} [StrictOrderedSemiring R] (s : Subsemiring R) :\n    StrictOrderedSemiring s :=\n  Subtype.coe_injective.strictOrderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [444, 1], "end": [448, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toOrderedCommSemiring", "code": "instance toOrderedCommSemiring {R} [OrderedCommSemiring R] (s : Subsemiring R) :\n    OrderedCommSemiring s :=\n  Subtype.coe_injective.orderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [451, 1], "end": [455, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toStrictOrderedCommSemiring", "code": "instance toStrictOrderedCommSemiring {R} [StrictOrderedCommSemiring R] (s : Subsemiring R) :\n    StrictOrderedCommSemiring s :=\n  Subtype.coe_injective.strictOrderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [458, 1], "end": [462, 51], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toLinearOrderedSemiring", "code": "instance toLinearOrderedSemiring {R} [LinearOrderedSemiring R] (s : Subsemiring R) :\n    LinearOrderedSemiring s :=\n  Subtype.coe_injective.linearOrderedSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [465, 1], "end": [469, 85], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toLinearOrderedCommSemiring", "code": "instance toLinearOrderedCommSemiring {R} [LinearOrderedCommSemiring R] (s : Subsemiring R) :\n    LinearOrderedCommSemiring s :=\n  Subtype.coe_injective.linearOrderedCommSemiring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [472, 1], "end": [476, 85], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.nsmul_mem", "code": "protected theorem nsmul_mem {x : R} (hx : x \u2208 s) (n : \u2115) : n \u2022 x \u2208 s", "start": [479, 1], "end": [480, 17], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_toSubmonoid", "code": "@[simp]\ntheorem coe_toSubmonoid (s : Subsemiring R) : (s.toSubmonoid : Set R) = s", "start": [483, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_carrier_toSubmonoid", "code": "@[simp]\ntheorem coe_carrier_toSubmonoid (s : Subsemiring R) : (s.toSubmonoid.carrier : Set R) = s", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_toAddSubmonoid", "code": "theorem mem_toAddSubmonoid {s : Subsemiring R} {x : R} : x \u2208 s.toAddSubmonoid \u2194 x \u2208 s", "start": [494, 1], "end": [495, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_toAddSubmonoid", "code": "theorem coe_toAddSubmonoid (s : Subsemiring R) : (s.toAddSubmonoid : Set R) = s", "start": [499, 1], "end": [500, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_top", "code": "@[simp]\ntheorem mem_top (x : R) : x \u2208 (\u22a4 : Subsemiring R)", "start": [507, 1], "end": [509, 17], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : Subsemiring R) : Set R) = Set.univ", "start": [512, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.topEquiv", "code": "@[simps]\ndef topEquiv : (\u22a4 : Subsemiring R) \u2243+* R where\n  toFun r := r\n  invFun r := \u27e8r, Subsemiring.mem_top r\u27e9\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' := (\u22a4 : Subsemiring R).coe_mul\n  map_add' := (\u22a4 : Subsemiring R).coe_add", "start": [517, 1], "end": [525, 42], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap", "code": "def comap (f : R \u2192+* S) (s : Subsemiring S) : Subsemiring R :=\n  { s.toSubmonoid.comap (f : R \u2192* S), s.toAddSubmonoid.comap (f : R \u2192+ S) with carrier := f \u207b\u00b9' s }", "start": [528, 1], "end": [530, 100], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_comap", "code": "@[simp]\ntheorem coe_comap (s : Subsemiring S) (f : R \u2192+* S) : (s.comap f : Set R) = f \u207b\u00b9' s", "start": [533, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_comap", "code": "@[simp]\ntheorem mem_comap {s : Subsemiring S} {f : R \u2192+* S} {x : R} : x \u2208 s.comap f \u2194 f x \u2208 s", "start": [538, 1], "end": [540, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap_comap", "code": "theorem comap_comap (s : Subsemiring T) (g : S \u2192+* T) (f : R \u2192+* S) :\n    (s.comap g).comap f = s.comap (g.comp f)", "start": [543, 1], "end": [545, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map", "code": "def map (f : R \u2192+* S) (s : Subsemiring R) : Subsemiring S :=\n  { s.toSubmonoid.map (f : R \u2192* S), s.toAddSubmonoid.map (f : R \u2192+ S) with carrier := f '' s }", "start": [548, 1], "end": [550, 95], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_map", "code": "@[simp]\ntheorem coe_map (f : R \u2192+* S) (s : Subsemiring R) : (s.map f : Set S) = f '' s", "start": [553, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_map", "code": "@[simp]\ntheorem mem_map {f : R \u2192+* S} {s : Subsemiring R} {y : S} : y \u2208 s.map f \u2194 \u2203 x \u2208 s, f x = y", "start": [558, 1], "end": [562, 7], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_id", "code": "@[simp]\ntheorem map_id : s.map (RingHom.id R) = s", "start": [565, 1], "end": [567, 42], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_map", "code": "theorem map_map (g : S \u2192+* T) (f : R \u2192+* S) : (s.map f).map g = s.map (g.comp f)", "start": [570, 1], "end": [571, 49], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : R \u2192+* S} {s : Subsemiring R} {t : Subsemiring S} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f", "start": [574, 1], "end": [576, 23], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.gc_map_comap", "code": "theorem gc_map_comap (f : R \u2192+* S) : GaloisConnection (map f) (comap f)", "start": [579, 1], "end": [580, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.equivMapOfInjective", "code": "noncomputable def equivMapOfInjective (f : R \u2192+* S) (hf : Function.Injective f) : s \u2243+* s.map f :=\n  { Equiv.Set.image f s hf with\n    map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _)\n    map_add' := fun _ _ => Subtype.ext (f.map_add _ _) }", "start": [583, 1], "end": [587, 57], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_equivMapOfInjective_apply", "code": "@[simp]\ntheorem coe_equivMapOfInjective_apply (f : R \u2192+* S) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x", "start": [590, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeS", "code": "def rangeS : Subsemiring S :=\n  ((\u22a4 : Subsemiring R).map f).copy (Set.range f) Set.image_univ.symm", "start": [602, 1], "end": [604, 69], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_rangeS", "code": "@[simp]\ntheorem coe_rangeS : (f.rangeS : Set S) = Set.range f", "start": [607, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_rangeS", "code": "@[simp]\ntheorem mem_rangeS {f : R \u2192+* S} {y : S} : y \u2208 f.rangeS \u2194 \u2203 x, f x = y", "start": [612, 1], "end": [614, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeS_eq_map", "code": "theorem rangeS_eq_map (f : R \u2192+* S) : f.rangeS = (\u22a4 : Subsemiring R).map f", "start": [617, 1], "end": [619, 7], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_rangeS_self", "code": "theorem mem_rangeS_self (f : R \u2192+* S) (x : R) : f x \u2208 f.rangeS", "start": [622, 1], "end": [623, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_rangeS", "code": "theorem map_rangeS : f.rangeS.map g = (g.comp f).rangeS", "start": [626, 1], "end": [627, 67], "kind": "commanddeclaration"}, {"full_name": "RingHom.fintypeRangeS", "code": "instance fintypeRangeS [Fintype R] [DecidableEq S] (f : R \u2192+* S) : Fintype (rangeS f) :=\n  Set.fintypeRange f", "start": [630, 1], "end": [634, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_bot", "code": "theorem coe_bot : ((\u22a5 : Subsemiring R) : Set R) = Set.range ((\u2191) : \u2115 \u2192 R)", "start": [647, 1], "end": [648, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_bot", "code": "theorem mem_bot {x : R} : x \u2208 (\u22a5 : Subsemiring R) \u2194 \u2203 n : \u2115, \u2191n = x", "start": [651, 1], "end": [652, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_inf", "code": "@[simp]\ntheorem coe_inf (p p' : Subsemiring R) : ((p \u2293 p' : Subsemiring R) : Set R) = (p : Set R) \u2229 p'", "start": [660, 1], "end": [662, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_inf", "code": "@[simp]\ntheorem mem_inf {p p' : Subsemiring R} {x : R} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [665, 1], "end": [667, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subsemiring R)) : ((sInf S : Subsemiring R) : Set R) = \u22c2 s \u2208 S, \u2191s", "start": [676, 1], "end": [678, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_sInf", "code": "theorem mem_sInf {S : Set (Subsemiring R)} {x : R} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [681, 1], "end": [682, 18], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.sInf_toSubmonoid", "code": "@[simp]\ntheorem sInf_toSubmonoid (s : Set (Subsemiring R)) :\n    (sInf s).toSubmonoid = \u2a05 t \u2208 s, Subsemiring.toSubmonoid t", "start": [685, 1], "end": [688, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.sInf_toAddSubmonoid", "code": "@[simp]\ntheorem sInf_toAddSubmonoid (s : Set (Subsemiring R)) :\n    (sInf s).toAddSubmonoid = \u2a05 t \u2208 s, Subsemiring.toAddSubmonoid t", "start": [691, 1], "end": [694, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.eq_top_iff'", "code": "theorem eq_top_iff' (A : Subsemiring R) : A = \u22a4 \u2194 \u2200 x : R, x \u2208 A", "start": [714, 1], "end": [715, 65], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center", "code": "def center (R) [Semiring R] : Subsemiring R :=\n  { Submonoid.center R with\n    carrier := Set.center R\n    zero_mem' := Set.zero_mem_center R\n    add_mem' := Set.add_mem_center }", "start": [720, 1], "end": [725, 37], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_center", "code": "theorem coe_center (R) [Semiring R] : \u2191(center R) = Set.center R", "start": [728, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center_toSubmonoid", "code": "@[simp]\ntheorem center_toSubmonoid (R) [Semiring R] : (center R).toSubmonoid = Submonoid.center R", "start": [732, 1], "end": [734, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_center_iff", "code": "theorem mem_center_iff {R} [Semiring R] {z : R} : z \u2208 center R \u2194 \u2200 g, g * z = z * g", "start": [737, 1], "end": [738, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.decidableMemCenter", "code": "instance decidableMemCenter {R} [Semiring R] [DecidableEq R] [Fintype R] :\n    DecidablePred (\u00b7 \u2208 center R) := fun _ => decidable_of_iff' _ mem_center_iff", "start": [741, 1], "end": [742, 80], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (R) [CommSemiring R] : center R = \u22a4", "start": [745, 1], "end": [747, 47], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.commSemiring", "code": "instance commSemiring {R} [Semiring R] : CommSemiring (center R) :=\n  { Submonoid.center.commMonoid, (center R).toSemiring with }", "start": [750, 1], "end": [752, 62], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.centralizer", "code": "def centralizer {R} [Semiring R] (s : Set R) : Subsemiring R :=\n  { Submonoid.centralizer s with\n    carrier := s.centralizer\n    zero_mem' := Set.zero_mem_centralizer _\n    add_mem' := Set.add_mem_centralizer }", "start": [758, 1], "end": [763, 42], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer {R} [Semiring R] (s : Set R) : (centralizer s : Set R) = s.centralizer", "start": [766, 1], "end": [768, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.centralizer_toSubmonoid", "code": "theorem centralizer_toSubmonoid {R} [Semiring R] (s : Set R) :\n    (centralizer s).toSubmonoid = Submonoid.centralizer s", "start": [771, 1], "end": [773, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {R} [Semiring R] {s : Set R} {z : R} :\n    z \u2208 centralizer s \u2194 \u2200 g \u2208 s, g * z = z * g", "start": [776, 1], "end": [778, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center_le_centralizer", "code": "theorem center_le_centralizer {R} [Semiring R] (s) : center R \u2264 centralizer s", "start": [781, 1], "end": [782, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.centralizer_le", "code": "theorem centralizer_le {R} [Semiring R] (s t : Set R) (h : s \u2286 t) : centralizer t \u2264 centralizer s", "start": [785, 1], "end": [786, 27], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.centralizer_eq_top_iff_subset", "code": "@[simp]\ntheorem centralizer_eq_top_iff_subset {R} [Semiring R] {s : Set R} :\n    centralizer s = \u22a4 \u2194 s \u2286 center R", "start": [789, 1], "end": [792, 59], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.centralizer_univ", "code": "@[simp]\ntheorem centralizer_univ {R} [Semiring R] : centralizer Set.univ = center R", "start": [795, 1], "end": [797, 40], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure", "code": "def closure (s : Set R) : Subsemiring R :=\n  sInf { S | s \u2286 S }", "start": [802, 1], "end": [804, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_closure", "code": "theorem mem_closure {x : R} {s : Set R} : x \u2208 closure s \u2194 \u2200 S : Subsemiring R, s \u2286 S \u2192 x \u2208 S", "start": [807, 1], "end": [808, 11], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.subset_closure", "code": "@[simp, aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_closure {s : Set R} : s \u2286 closure s", "start": [811, 1], "end": [813, 98], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P \u2209 closure s) : P \u2209 s", "start": [816, 1], "end": [817, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_le", "code": "@[simp]\ntheorem closure_le {s : Set R} {t : Subsemiring R} : closure s \u2264 t \u2194 s \u2286 t", "start": [820, 1], "end": [823, 56], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_mono", "code": "theorem closure_mono \u2983s t : Set R\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [826, 1], "end": [829, 52], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_eq_of_le", "code": "theorem closure_eq_of_le {s : Set R} {t : Subsemiring R} (h\u2081 : s \u2286 t) (h\u2082 : t \u2264 closure s) :\n    closure s = t", "start": [832, 1], "end": [834, 35], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_map_equiv", "code": "theorem mem_map_equiv {f : R \u2243+* S} {K : Subsemiring R} {x : S} :\n    x \u2208 K.map (f : R \u2192+* S) \u2194 f.symm x \u2208 K", "start": [837, 1], "end": [839, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_equiv_eq_comap_symm", "code": "theorem map_equiv_eq_comap_symm (f : R \u2243+* S) (K : Subsemiring R) :\n    K.map (f : R \u2192+* S) = K.comap f.symm", "start": [842, 1], "end": [844, 56], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap_equiv_eq_map_symm", "code": "theorem comap_equiv_eq_map_symm (f : R \u2243+* S) (K : Subsemiring S) :\n    K.comap (f : R \u2192+* S) = K.map f.symm", "start": [847, 1], "end": [849, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subsemiringClosure", "code": "def subsemiringClosure (M : Submonoid R) : Subsemiring R :=\n  { AddSubmonoid.closure (M : Set R) with\n    one_mem' := AddSubmonoid.mem_closure.mpr fun _ hy => hy M.one_mem\n    mul_mem' := MulMemClass.mul_mem_add_closure }", "start": [856, 1], "end": [860, 50], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subsemiringClosure_coe", "code": "theorem subsemiringClosure_coe :\n    (M.subsemiringClosure : Set R) = AddSubmonoid.closure (M : Set R)", "start": [863, 1], "end": [865, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subsemiringClosure_toAddSubmonoid", "code": "theorem subsemiringClosure_toAddSubmonoid :\n    M.subsemiringClosure.toAddSubmonoid = AddSubmonoid.closure (M : Set R)", "start": [868, 1], "end": [870, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subsemiringClosure_eq_closure", "code": "theorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R)", "start": [873, 1], "end": [883, 16], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_submonoid_closure", "code": "@[simp]\ntheorem closure_submonoid_closure (s : Set R) : closure \u2191(Submonoid.closure s) = closure s", "start": [890, 1], "end": [895, 44], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_closure_eq", "code": "theorem coe_closure_eq (s : Set R) :\n    (closure s : Set R) = AddSubmonoid.closure (Submonoid.closure s : Set R)", "start": [898, 1], "end": [902, 96], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_closure_iff", "code": "theorem mem_closure_iff {s : Set R} {x} :\n    x \u2208 closure s \u2194 x \u2208 AddSubmonoid.closure (Submonoid.closure s : Set R)", "start": [905, 1], "end": [907, 38], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_addSubmonoid_closure", "code": "@[simp]\ntheorem closure_addSubmonoid_closure {s : Set R} :\n    closure \u2191(AddSubmonoid.closure s) = closure s", "start": [910, 1], "end": [919, 75], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_induction", "code": "@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x)\n    (H0 : p 0) (H1 : p 1) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [922, 1], "end": [929, 59], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_induction'", "code": "@[elab_as_elim]\ntheorem closure_induction' {s : Set R} {p : \u2200 x, x \u2208 closure s \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 s), p x (subset_closure h)) (H0 : p 0 (zero_mem _)) (H1 : p 1 (one_mem _))\n    (Hadd : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x + y) (add_mem hx hy))\n    (Hmul : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x * y) (mul_mem hx hy))\n    {a : R} (ha : a \u2208 closure s) : p a ha", "start": [932, 1], "end": [945, 45], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_induction\u2082", "code": "@[elab_as_elim]\ntheorem closure_induction\u2082 {s : Set R} {p : R \u2192 R \u2192 Prop} {x} {y : R} (hx : x \u2208 closure s)\n    (hy : y \u2208 closure s) (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (H0_left : \u2200 x, p 0 x)\n    (H0_right : \u2200 x, p x 0) (H1_left : \u2200 x, p 1 x) (H1_right : \u2200 x, p x 1)\n    (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)) : p x y", "start": [947, 1], "end": [959, 88], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_closure_iff_exists_list", "code": "theorem mem_closure_iff_exists_list {R} [Semiring R] {s : Set R} {x} :\n    x \u2208 closure s \u2194 \u2203 L : List (List R), (\u2200 t \u2208 L, \u2200 y \u2208 t, y \u2208 s) \u2227 (L.map List.prod).sum = x", "start": [962, 1], "end": [987, 75], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.gi", "code": "protected def gi : GaloisInsertion (@closure R _) (\u2191)\n    where\n  choice s _ := closure s\n  gc _ _ := closure_le\n  le_l_u _ := subset_closure\n  choice_eq _ _ := rfl", "start": [992, 1], "end": [998, 23], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_eq", "code": "theorem closure_eq (s : Subsemiring R) : closure (s : Set R) = s", "start": [1003, 1], "end": [1005, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_empty", "code": "@[simp]\ntheorem closure_empty : closure (\u2205 : Set R) = \u22a5", "start": [1008, 1], "end": [1010, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_univ", "code": "@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = \u22a4", "start": [1013, 1], "end": [1015, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_union", "code": "theorem closure_union (s t : Set R) : closure (s \u222a t) = closure s \u2294 closure t", "start": [1018, 1], "end": [1019, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_iUnion", "code": "theorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set R) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [1022, 1], "end": [1023, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closure_sUnion", "code": "theorem closure_sUnion (s : Set (Set R)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t", "start": [1026, 1], "end": [1027, 31], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_sup", "code": "theorem map_sup (s t : Subsemiring R) (f : R \u2192+* S) : (s \u2294 t).map f = s.map f \u2294 t.map f", "start": [1030, 1], "end": [1031, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_iSup", "code": "theorem map_iSup {\u03b9 : Sort*} (f : R \u2192+* S) (s : \u03b9 \u2192 Subsemiring R) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [1034, 1], "end": [1036, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap_inf", "code": "theorem comap_inf (s t : Subsemiring S) (f : R \u2192+* S) : (s \u2293 t).comap f = s.comap f \u2293 t.comap f", "start": [1039, 1], "end": [1040, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap_iInf", "code": "theorem comap_iInf {\u03b9 : Sort*} (f : R \u2192+* S) (s : \u03b9 \u2192 Subsemiring S) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [1043, 1], "end": [1045, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.map_bot", "code": "@[simp]\ntheorem map_bot (f : R \u2192+* S) : (\u22a5 : Subsemiring R).map f = \u22a5", "start": [1048, 1], "end": [1050, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.comap_top", "code": "@[simp]\ntheorem comap_top (f : R \u2192+* S) : (\u22a4 : Subsemiring S).comap f = \u22a4", "start": [1053, 1], "end": [1055, 25], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod", "code": "def prod (s : Subsemiring R) (t : Subsemiring S) : Subsemiring (R \u00d7 S) :=\n  { s.toSubmonoid.prod t.toSubmonoid, s.toAddSubmonoid.prod t.toAddSubmonoid with\n    carrier := s \u00d7\u02e2 t }", "start": [1058, 1], "end": [1062, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod (s : Subsemiring R) (t : Subsemiring S) :\n    (s.prod t : Set (R \u00d7 S)) = (s : Set R) \u00d7\u02e2 (t : Set S)", "start": [1065, 1], "end": [1068, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_prod", "code": "theorem mem_prod {s : Subsemiring R} {t : Subsemiring S} {p : R \u00d7 S} :\n    p \u2208 s.prod t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [1071, 1], "end": [1073, 10], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_mono", "code": "@[mono]\ntheorem prod_mono \u2983s\u2081 s\u2082 : Subsemiring R\u2984 (hs : s\u2081 \u2264 s\u2082) \u2983t\u2081 t\u2082 : Subsemiring S\u2984 (ht : t\u2081 \u2264 t\u2082) :\n    s\u2081.prod t\u2081 \u2264 s\u2082.prod t\u2082", "start": [1076, 1], "end": [1079, 22], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_mono_right", "code": "theorem prod_mono_right (s : Subsemiring R) : Monotone fun t : Subsemiring S => s.prod t", "start": [1082, 1], "end": [1083, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_mono_left", "code": "theorem prod_mono_left (t : Subsemiring S) : Monotone fun s : Subsemiring R => s.prod t", "start": [1086, 1], "end": [1087, 41], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_top", "code": "theorem prod_top (s : Subsemiring R) : s.prod (\u22a4 : Subsemiring S) = s.comap (RingHom.fst R S)", "start": [1090, 1], "end": [1091, 53], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.top_prod", "code": "theorem top_prod (s : Subsemiring S) : (\u22a4 : Subsemiring R).prod s = s.comap (RingHom.snd R S)", "start": [1094, 1], "end": [1095, 53], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.top_prod_top", "code": "@[simp]\ntheorem top_prod_top : (\u22a4 : Subsemiring R).prod (\u22a4 : Subsemiring S) = \u22a4", "start": [1098, 1], "end": [1100, 36], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prodEquiv", "code": "def prodEquiv (s : Subsemiring R) (t : Subsemiring S) : s.prod t \u2243+* s \u00d7 t :=\n  { Equiv.Set.prod (s : Set R) (t : Set S) with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [1103, 1], "end": [1107, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_iSup_of_directed", "code": "theorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subsemiring R} (hS : Directed (\u00b7 \u2264 \u00b7) S)\n    {x : R} : (x \u2208 \u2a06 i, S i) \u2194 \u2203 i, x \u2208 S i", "start": [1110, 1], "end": [1119, 55], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subsemiring R}\n    (hS : Directed (\u00b7 \u2264 \u00b7) S) : ((\u2a06 i, S i : Subsemiring R) : Set R) = \u22c3 i, \u2191(S i)", "start": [1122, 1], "end": [1124, 53], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mem_sSup_of_directedOn", "code": "theorem mem_sSup_of_directedOn {S : Set (Subsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) {x : R} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "start": [1127, 1], "end": [1131, 17], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.coe_sSup_of_directedOn", "code": "theorem coe_sSup_of_directedOn {S : Set (Subsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) : (\u2191(sSup S) : Set R) = \u22c3 s \u2208 S, \u2191s", "start": [1134, 1], "end": [1136, 59], "kind": "commanddeclaration"}, {"full_name": "RingHom.domRestrict", "code": "def domRestrict (f : R \u2192+* S) (s : \u03c3R) : s \u2192+* S :=\n  f.comp <| SubsemiringClass.subtype s", "start": [1151, 1], "end": [1153, 39], "kind": "commanddeclaration"}, {"full_name": "RingHom.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (f : R \u2192+* S) {s : \u03c3R} (x : s) : f.domRestrict s x = f x", "start": [1156, 1], "end": [1158, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.codRestrict", "code": "def codRestrict (f : R \u2192+* S) (s : \u03c3S) (h : \u2200 x, f x \u2208 s) : R \u2192+* s :=\n  { (f : R \u2192* S).codRestrict s h, (f : R \u2192+ S).codRestrict s h with toFun := fun n => \u27e8f n, h n\u27e9 }", "start": [1161, 1], "end": [1163, 99], "kind": "commanddeclaration"}, {"full_name": "RingHom.restrict", "code": "def restrict (f : R \u2192+* S) (s' : \u03c3R) (s : \u03c3S) (h : \u2200 x \u2208 s', f x \u2208 s) : s' \u2192+* s :=\n  (f.domRestrict s').codRestrict s fun x => h x x.2", "start": [1166, 1], "end": [1168, 52], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_restrict_apply", "code": "@[simp]\ntheorem coe_restrict_apply (f : R \u2192+* S) (s' : \u03c3R) (s : \u03c3S) (h : \u2200 x \u2208 s', f x \u2208 s) (x : s') :\n    (f.restrict s' s h x : S) = f x", "start": [1171, 1], "end": [1174, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.comp_restrict", "code": "@[simp]\ntheorem comp_restrict (f : R \u2192+* S) (s' : \u03c3R) (s : \u03c3S) (h : \u2200 x \u2208 s', f x \u2208 s) :\n    (SubsemiringClass.subtype s).comp (f.restrict s' s h) = f.comp (SubsemiringClass.subtype s')", "start": [1177, 1], "end": [1180, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeSRestrict", "code": "def rangeSRestrict (f : R \u2192+* S) : R \u2192+* f.rangeS :=\n  f.codRestrict (R := R) (S := S) (\u03c3S := Subsemiring S) f.rangeS f.mem_rangeS_self", "start": [1183, 1], "end": [1187, 83], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_rangeSRestrict", "code": "@[simp]\ntheorem coe_rangeSRestrict (f : R \u2192+* S) (x : R) : (f.rangeSRestrict x : S) = f x", "start": [1190, 1], "end": [1192, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeSRestrict_surjective", "code": "theorem rangeSRestrict_surjective (f : R \u2192+* S) : Function.Surjective f.rangeSRestrict", "start": [1195, 1], "end": [1198, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeS_top_iff_surjective", "code": "theorem rangeS_top_iff_surjective {f : R \u2192+* S} :\n    f.rangeS = (\u22a4 : Subsemiring S) \u2194 Function.Surjective f", "start": [1201, 1], "end": [1203, 93], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeS_top_of_surjective", "code": "@[simp]\ntheorem rangeS_top_of_surjective (f : R \u2192+* S) (hf : Function.Surjective f) :\n    f.rangeS = (\u22a4 : Subsemiring S)", "start": [1206, 1], "end": [1210, 33], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqLocusS", "code": "def eqLocusS (f g : R \u2192+* S) : Subsemiring R :=\n  { (f : R \u2192* S).eqLocusM g, (f : R \u2192+ S).eqLocusM g with carrier := { x | f x = g x } }", "start": [1213, 1], "end": [1215, 89], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqLocusS_same", "code": "@[simp]\ntheorem eqLocusS_same (f : R \u2192+* S) : f.eqLocusS f = \u22a4", "start": [1218, 1], "end": [1220, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqOn_sclosure", "code": "theorem eqOn_sclosure {f g : R \u2192+* S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s)", "start": [1223, 1], "end": [1225, 52], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_stop", "code": "theorem eq_of_eqOn_stop {f g : R \u2192+* S} (h : Set.EqOn f g (\u22a4 : Subsemiring R)) : f = g", "start": [1228, 1], "end": [1229, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_sdense", "code": "theorem eq_of_eqOn_sdense {s : Set R} (hs : closure s = \u22a4) {f g : R \u2192+* S} (h : s.EqOn f g) :\n    f = g", "start": [1232, 1], "end": [1234, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.sclosure_preimage_le", "code": "theorem sclosure_preimage_le (f : R \u2192+* S) (s : Set S) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [1237, 1], "end": [1238, 81], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_closureS", "code": "theorem map_closureS (f : R \u2192+* S) (s : Set R) : (closure s).map f = closure (f '' s)", "start": [1241, 1], "end": [1247, 56], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.inclusion", "code": "def inclusion {S T : Subsemiring R} (h : S \u2264 T) : S \u2192+* T :=\n  S.subtype.codRestrict _ fun x => h x.2", "start": [1256, 1], "end": [1258, 41], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.rangeS_subtype", "code": "@[simp]\ntheorem rangeS_subtype (s : Subsemiring R) : s.subtype.rangeS = s", "start": [1261, 1], "end": [1263, 66], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.range_fst", "code": "@[simp]\ntheorem range_fst : (fst R S).rangeS = \u22a4", "start": [1266, 1], "end": [1268, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.range_snd", "code": "@[simp]\ntheorem range_snd : (snd R S).rangeS = \u22a4", "start": [1271, 1], "end": [1273, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.prod_bot_sup_bot_prod", "code": "@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subsemiring R) (t : Subsemiring S) :\n    s.prod \u22a5 \u2294 prod \u22a5 t = s.prod t", "start": [1276, 1], "end": [1283, 97], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.subsemiringCongr", "code": "def subsemiringCongr (h : s = t) : s \u2243+* t :=\n  {\n    Equiv.setCongr <| congr_arg _ h with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [1292, 1], "end": [1298, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverseS", "code": "def ofLeftInverseS {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f) : R \u2243+* f.rangeS :=\n  { f.rangeSRestrict with\n    toFun := fun x => f.rangeSRestrict x\n    invFun := fun x => (g \u2218 f.rangeS.subtype) x\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := RingHom.mem_rangeS.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [1301, 1], "end": [1311, 47], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverseS_apply", "code": "@[simp]\ntheorem ofLeftInverseS_apply {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f) (x : R) :\n    \u2191(ofLeftInverseS h x) = f x", "start": [1314, 1], "end": [1317, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverseS_symm_apply", "code": "@[simp]\ntheorem ofLeftInverseS_symm_apply {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f)\n    (x : f.rangeS) : (ofLeftInverseS h).symm x = g x", "start": [1320, 1], "end": [1323, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.subsemiringMap", "code": "@[simps!]\ndef subsemiringMap (e : R \u2243+* S) (s : Subsemiring R) : s \u2243+* s.map e.toRingHom :=\n  { e.toAddEquiv.addSubmonoidMap s.toAddSubmonoid, e.toMulEquiv.submonoidMap s.toSubmonoid with }", "start": [1326, 1], "end": [1330, 98], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.smul", "code": "instance smul [SMul R' \u03b1] (S : Subsemiring R') : SMul S \u03b1 :=\n  S.toSubmonoid.smul", "start": [1358, 1], "end": [1360, 21], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.smul_def", "code": "theorem smul_def [SMul R' \u03b1] {S : Subsemiring R'} (g : S) (m : \u03b1) : g \u2022 m = (g : R') \u2022 m", "start": [1362, 1], "end": [1363, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.smulCommClass_left", "code": "instance smulCommClass_left [SMul R' \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass R' \u03b1 \u03b2] (S : Subsemiring R') :\n    SMulCommClass S \u03b1 \u03b2 :=\n  S.toSubmonoid.smulCommClass_left", "start": [1366, 1], "end": [1368, 35], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.smulCommClass_right", "code": "instance smulCommClass_right [SMul \u03b1 \u03b2] [SMul R' \u03b2] [SMulCommClass \u03b1 R' \u03b2] (S : Subsemiring R') :\n    SMulCommClass \u03b1 S \u03b2 :=\n  S.toSubmonoid.smulCommClass_right", "start": [1371, 1], "end": [1373, 36], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.isScalarTower", "code": "instance isScalarTower [SMul \u03b1 \u03b2] [SMul R' \u03b1] [SMul R' \u03b2] [IsScalarTower R' \u03b1 \u03b2]\n    (S : Subsemiring R') :\n    IsScalarTower S \u03b1 \u03b2 :=\n  S.toSubmonoid.isScalarTower", "start": [1376, 1], "end": [1380, 30], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.faithfulSMul", "code": "instance faithfulSMul [SMul R' \u03b1] [FaithfulSMul R' \u03b1] (S : Subsemiring R') : FaithfulSMul S \u03b1 :=\n  S.toSubmonoid.faithfulSMul", "start": [1382, 1], "end": [1383, 29], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mulAction", "code": "instance mulAction [MulAction R' \u03b1] (S : Subsemiring R') : MulAction S \u03b1 :=\n  S.toSubmonoid.mulAction", "start": [1393, 1], "end": [1395, 26], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.distribMulAction", "code": "instance distribMulAction [AddMonoid \u03b1] [DistribMulAction R' \u03b1] (S : Subsemiring R') :\n    DistribMulAction S \u03b1 :=\n  S.toSubmonoid.distribMulAction", "start": [1397, 1], "end": [1400, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mulDistribMulAction", "code": "instance mulDistribMulAction [Monoid \u03b1] [MulDistribMulAction R' \u03b1] (S : Subsemiring R') :\n    MulDistribMulAction S \u03b1 :=\n  S.toSubmonoid.mulDistribMulAction", "start": [1402, 1], "end": [1405, 36], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.mulActionWithZero", "code": "instance mulActionWithZero [Zero \u03b1] [MulActionWithZero R' \u03b1] (S : Subsemiring R') :\n    MulActionWithZero S \u03b1 :=\n  MulActionWithZero.compHom _ S.subtype.toMonoidWithZeroHom", "start": [1407, 1], "end": [1410, 60], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.module", "code": "instance module [AddCommMonoid \u03b1] [Module R' \u03b1] (S : Subsemiring R') : Module S \u03b1 :=\n  Module.compHom _ S.subtype", "start": [1413, 1], "end": [1417, 29], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center.smulCommClass_left", "code": "instance center.smulCommClass_left : SMulCommClass (center R') R' R' :=\n  Submonoid.center.smulCommClass_left", "start": [1423, 1], "end": [1425, 38], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.center.smulCommClass_right", "code": "instance center.smulCommClass_right : SMulCommClass R' (center R') R' :=\n  Submonoid.center.smulCommClass_right", "start": [1428, 1], "end": [1430, 39], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.closureCommSemiringOfComm", "code": "def closureCommSemiringOfComm {s : Set R'} (hcomm : \u2200 a \u2208 s, \u2200 b \u2208 s, a * b = b * a) :\n    CommSemiring (closure s) :=\n  { (closure s).toSemiring with\n    mul_comm := fun x y => by\n      ext\n      simp only [Subsemiring.coe_mul]\n      refine'\n        closure_induction\u2082 x.prop y.prop hcomm (fun x => by simp only [zero_mul, mul_zero])\n          (fun x => by simp only [zero_mul, mul_zero]) (fun x => by simp only [one_mul, mul_one])\n          (fun x => by simp only [one_mul, mul_one])\n          (fun x y z h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x y z h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x y z h\u2081 h\u2082 => by rw [mul_assoc, h\u2082, \u2190 mul_assoc, h\u2081, mul_assoc]) fun x y z h\u2081 h\u2082 =>\n          by rw [\u2190 mul_assoc, h\u2081, mul_assoc, h\u2082, \u2190 mul_assoc] }", "start": [1433, 1], "end": [1447, 64], "kind": "commanddeclaration"}, {"full_name": "posSubmonoid", "code": "def posSubmonoid (R : Type*) [StrictOrderedSemiring R] : Submonoid R\n    where\n  carrier := { x | 0 < x }\n  one_mem' := show (0 : R) < 1 from zero_lt_one\n  mul_mem' {x y} (hx : 0 < x) (hy : 0 < y) := mul_pos hx hy", "start": [1456, 1], "end": [1461, 60], "kind": "commanddeclaration"}, {"full_name": "mem_posSubmonoid", "code": "@[simp]\ntheorem mem_posSubmonoid {R : Type*} [StrictOrderedSemiring R] (u : R\u02e3) :\n    \u2191u \u2208 posSubmonoid R \u2194 (0 : R) < u", "start": [1464, 1], "end": [1467, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Cast/Field.lean", "imports": ["Mathlib/Algebra/Order/Ring/CharZero.lean", "Mathlib/Data/Nat/Cast/Order.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "Nat.cast_div", "code": "@[simp]\ntheorem cast_div [DivisionSemiring \u03b1] {m n : \u2115} (n_dvd : n \u2223 m) (n_nonzero : (n : \u03b1) \u2260 0) :\n    ((m / n : \u2115) : \u03b1) = m / n", "start": [29, 1], "end": [36, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_div_div_div_cancel_right", "code": "theorem cast_div_div_div_cancel_right [DivisionSemiring \u03b1] [CharZero \u03b1] {m n d : \u2115}\n    (hn : d \u2223 n) (hm : d \u2223 m) :\n    (\u2191(m / d) : \u03b1) / (\u2191(n / d) : \u03b1) = (m : \u03b1) / n", "start": [39, 1], "end": [45, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_div_le", "code": "theorem cast_div_le {m n : \u2115} : ((m / n : \u2115) : \u03b1) \u2264 m / n", "start": [52, 1], "end": [58, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.inv_pos_of_nat", "code": "theorem inv_pos_of_nat {n : \u2115} : 0 < ((n : \u03b1) + 1)\u207b\u00b9", "start": [61, 1], "end": [62, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.one_div_pos_of_nat", "code": "theorem one_div_pos_of_nat {n : \u2115} : 0 < 1 / ((n : \u03b1) + 1)", "start": [65, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.one_div_le_one_div", "code": "theorem one_div_le_one_div {n m : \u2115} (h : n \u2264 m) : 1 / ((m : \u03b1) + 1) \u2264 1 / ((n : \u03b1) + 1)", "start": [70, 1], "end": [73, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.one_div_lt_one_div", "code": "theorem one_div_lt_one_div {n m : \u2115} (h : n < m) : 1 / ((m : \u03b1) + 1) < 1 / ((n : \u03b1) + 1)", "start": [76, 1], "end": [79, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/ULift.lean", "imports": ["Mathlib/Algebra/Group/ULift.lean", "Mathlib/Algebra/Ring/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ULift.mulZeroClass", "code": "instance mulZeroClass [MulZeroClass \u03b1] : MulZeroClass (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), mul := (\u00b7 * \u00b7), zero_mul := fun _ => (Equiv.ulift).injective (by simp),\n    mul_zero := fun _ => (Equiv.ulift).injective (by simp) }", "start": [29, 1], "end": [31, 61], "kind": "commanddeclaration"}, {"full_name": "ULift.distrib", "code": "instance distrib [Distrib \u03b1] : Distrib (ULift \u03b1) :=\n  { add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7),\n    left_distrib := fun _ _ _ => (Equiv.ulift).injective (by simp [left_distrib]),\n    right_distrib := fun _ _ _ => (Equiv.ulift).injective (by simp [right_distrib]) }", "start": [34, 1], "end": [37, 86], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [NonUnitalNonAssocSemiring \u03b1] :\n    NonUnitalNonAssocSemiring (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), nsmul := AddMonoid.nsmul,\n    zero_add, add_zero, zero_mul, mul_zero, left_distrib, right_distrib,\n    nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _,\n    add_assoc, add_comm }", "start": [40, 1], "end": [46, 26], "kind": "commanddeclaration"}, {"full_name": "ULift.nonAssocSemiring", "code": "instance nonAssocSemiring [NonAssocSemiring \u03b1] : NonAssocSemiring (ULift \u03b1) :=\n  { ULift.addMonoidWithOne with\n      nsmul := AddMonoid.nsmul, natCast := fun n => ULift.up n, add_comm, left_distrib,\n      right_distrib, zero_mul, mul_zero, one_mul, mul_one }", "start": [49, 1], "end": [52, 60], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalSemiring", "code": "instance nonUnitalSemiring [NonUnitalSemiring \u03b1] : NonUnitalSemiring (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), nsmul := AddMonoid.nsmul,\n    add_assoc, zero_add, add_zero, add_comm, left_distrib, right_distrib, zero_mul, mul_zero,\n    mul_assoc, nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _ }", "start": [55, 1], "end": [59, 56], "kind": "commanddeclaration"}, {"full_name": "ULift.semiring", "code": "instance semiring [Semiring \u03b1] : Semiring (ULift \u03b1) :=\n  { ULift.addMonoidWithOne with\n      nsmul := AddMonoid.nsmul,\n      npow := Monoid.npow, natCast := fun n => ULift.up n, add_comm, left_distrib, right_distrib,\n      zero_mul, mul_zero, mul_assoc, one_mul, mul_one, npow_zero := fun _ => Monoid.npow_zero _,\n      npow_succ := fun _ _ => Monoid.npow_succ _ _ }", "start": [62, 1], "end": [67, 53], "kind": "commanddeclaration"}, {"full_name": "ULift.ringEquiv", "code": "def ringEquiv [NonUnitalNonAssocSemiring \u03b1] : ULift \u03b1 \u2243+* \u03b1 where\n  toFun := ULift.down\n  invFun := ULift.up\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n  left_inv := fun _ => rfl\n  right_inv := fun _ => rfl", "start": [70, 1], "end": [77, 28], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [NonUnitalCommSemiring \u03b1] : NonUnitalCommSemiring (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), nsmul := AddMonoid.nsmul, add_assoc,\n    zero_add, add_zero, add_comm, left_distrib, right_distrib, zero_mul, mul_zero, mul_assoc,\n    mul_comm, nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _ }", "start": [80, 1], "end": [84, 56], "kind": "commanddeclaration"}, {"full_name": "ULift.commSemiring", "code": "instance commSemiring [CommSemiring \u03b1] : CommSemiring (ULift \u03b1) :=\n  { ULift.semiring with\n      nsmul := AddMonoid.nsmul, natCast := fun n => ULift.up n, npow := Monoid.npow, mul_comm }", "start": [87, 1], "end": [89, 96], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [NonUnitalNonAssocRing \u03b1] : NonUnitalNonAssocRing (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), sub := Sub.sub, neg := Neg.neg,\n    nsmul := AddMonoid.nsmul, zsmul := SubNegMonoid.zsmul, add_assoc, zero_add, add_zero,\n    add_left_neg, add_comm, left_distrib, right_distrib, zero_mul, mul_zero, sub_eq_add_neg,\n    nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _,\n    zsmul_zero' := SubNegMonoid.zsmul_zero', zsmul_succ' := SubNegMonoid.zsmul_succ',\n    zsmul_neg' := SubNegMonoid.zsmul_neg' }", "start": [92, 1], "end": [99, 44], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalRing", "code": "instance nonUnitalRing [NonUnitalRing \u03b1] : NonUnitalRing (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), sub := Sub.sub, neg := Neg.neg,\n    nsmul := AddMonoid.nsmul, zsmul := SubNegMonoid.zsmul, add_assoc, zero_add, add_zero, add_comm,\n    add_left_neg, left_distrib, right_distrib, zero_mul, mul_zero, mul_assoc, sub_eq_add_neg\n    nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _,\n    zsmul_zero' := SubNegMonoid.zsmul_zero', zsmul_succ' := SubNegMonoid.zsmul_succ',\n    zsmul_neg' := SubNegMonoid.zsmul_neg' }", "start": [102, 1], "end": [109, 44], "kind": "commanddeclaration"}, {"full_name": "ULift.nonAssocRing", "code": "instance nonAssocRing [NonAssocRing \u03b1] : NonAssocRing (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), one := (1 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), sub := Sub.sub,\n    neg := Neg.neg, nsmul := AddMonoid.nsmul, natCast := fun n => ULift.up n,\n    intCast := fun n => ULift.up n, zsmul := SubNegMonoid.zsmul,\n    intCast_ofNat := addGroupWithOne.intCast_ofNat, add_assoc, zero_add,\n    add_zero, add_left_neg, add_comm, left_distrib, right_distrib, zero_mul, mul_zero, one_mul,\n    mul_one, sub_eq_add_neg, nsmul_zero := fun _ => AddMonoid.nsmul_zero _,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _,\n    zsmul_zero' := SubNegMonoid.zsmul_zero', zsmul_succ' := SubNegMonoid.zsmul_succ',\n    zsmul_neg' := SubNegMonoid.zsmul_neg',\n    natCast_zero := AddMonoidWithOne.natCast_zero, natCast_succ := AddMonoidWithOne.natCast_succ,\n    intCast_negSucc := AddGroupWithOne.intCast_negSucc }", "start": [112, 1], "end": [123, 57], "kind": "commanddeclaration"}, {"full_name": "ULift.ring", "code": "instance ring [Ring \u03b1] : Ring (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), one := (1 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), sub := Sub.sub,\n    neg := Neg.neg, nsmul := AddMonoid.nsmul, npow := Monoid.npow, zsmul := SubNegMonoid.zsmul,\n    intCast_ofNat := addGroupWithOne.intCast_ofNat, add_assoc, zero_add, add_zero, add_comm,\n    left_distrib, right_distrib, zero_mul, mul_zero, mul_assoc, one_mul, mul_one, sub_eq_add_neg,\n    add_left_neg, nsmul_zero := fun _ => AddMonoid.nsmul_zero _, natCast := fun n => ULift.up n,\n    intCast := fun n => ULift.up n, nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _,\n    natCast_zero := AddMonoidWithOne.natCast_zero, natCast_succ := AddMonoidWithOne.natCast_succ,\n    npow_zero := fun _ => Monoid.npow_zero _, npow_succ := fun _ _ => Monoid.npow_succ _ _,\n    zsmul_zero' := SubNegMonoid.zsmul_zero', zsmul_succ' := SubNegMonoid.zsmul_succ',\n    zsmul_neg' := SubNegMonoid.zsmul_neg', intCast_negSucc := AddGroupWithOne.intCast_negSucc }", "start": [126, 1], "end": [136, 96], "kind": "commanddeclaration"}, {"full_name": "ULift.nonUnitalCommRing", "code": "instance nonUnitalCommRing [NonUnitalCommRing \u03b1] : NonUnitalCommRing (ULift \u03b1) :=\n  { zero := (0 : ULift \u03b1), add := (\u00b7 + \u00b7), mul := (\u00b7 * \u00b7), sub := Sub.sub, neg := Neg.neg,\n    nsmul := AddMonoid.nsmul, zsmul := SubNegMonoid.zsmul, zero_mul, add_assoc, zero_add, add_zero,\n    mul_zero, left_distrib, right_distrib, add_comm, mul_assoc, mul_comm,\n    nsmul_zero := fun _ => AddMonoid.nsmul_zero _, add_left_neg,\n    nsmul_succ := fun _ _ => AddMonoid.nsmul_succ _ _, sub_eq_add_neg,\n    zsmul_zero' := SubNegMonoid.zsmul_zero',\n    zsmul_succ' := SubNegMonoid.zsmul_succ',\n    zsmul_neg' := SubNegMonoid.zsmul_neg'.. }", "start": [139, 1], "end": [147, 46], "kind": "commanddeclaration"}, {"full_name": "ULift.commRing", "code": "instance commRing [CommRing \u03b1] : CommRing (ULift \u03b1) :=\n  { ULift.ring with mul_comm }", "start": [150, 1], "end": [151, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Hom.lean", "imports": ["Mathlib/Algebra/Module/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddMonoidHom.distribSMul", "code": "instance distribSMul [AddZeroClass A] [AddCommMonoid B] [DistribSMul M B] :\n    DistribSMul M (A \u2192+ B) where\n  smul_add _ _ _ := ext fun _ => smul_add _ _ _", "start": [30, 1], "end": [32, 48], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.distribMulAction", "code": "instance distribMulAction : DistribMulAction R (A \u2192+ B) where\n  smul_zero := smul_zero\n  smul_add := smul_add\n  one_smul _ := ext fun _ => one_smul _ _\n  mul_smul _ _ _ := ext fun _ => mul_smul _ _ _", "start": [38, 1], "end": [42, 48], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_smul", "code": "@[simp] theorem coe_smul (r : R) (f : A \u2192+ B) : \u21d1(r \u2022 f) = r \u2022 \u21d1f", "start": [45, 1], "end": [45, 73], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.smul_apply", "code": "theorem smul_apply (r : R) (f : A \u2192+ B) (x : A) : (r \u2022 f) x = r \u2022 f x", "start": [48, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.smulCommClass", "code": "instance smulCommClass [SMulCommClass R S B] : SMulCommClass R S (A \u2192+ B) :=\n  \u27e8fun _ _ _ => ext fun _ => smul_comm _ _ _\u27e9", "start": [52, 1], "end": [53, 46], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.isScalarTower", "code": "instance isScalarTower [SMul R S] [IsScalarTower R S B] : IsScalarTower R S (A \u2192+ B) :=\n  \u27e8fun _ _ _ => ext fun _ => smul_assoc _ _ _\u27e9", "start": [56, 1], "end": [57, 47], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.isCentralScalar", "code": "instance isCentralScalar [DistribMulAction R\u1d50\u1d52\u1d56 B] [IsCentralScalar R B] :\n    IsCentralScalar R (A \u2192+ B) :=\n  \u27e8fun _ _ => ext fun _ => op_smul_eq_smul _ _\u27e9", "start": [60, 1], "end": [62, 48], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.smulLeft", "code": "@[simps (config := .asFn)]\nprotected def smulLeft [Monoid M] [AddMonoid A] [DistribMulAction M A] (c : M) : A \u2192+ A where\n  toFun := (c \u2022 \u00b7)\n  map_zero' := smul_zero c\n  map_add' := smul_add c", "start": [67, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.smul", "code": "protected def smul [Semiring R] [AddCommMonoid M] [Module R M] : R \u2192+ M \u2192+ M where\n  toFun := .smulLeft\n  map_zero' := AddMonoidHom.ext <| zero_smul _\n  map_add' _ _ := AddMonoidHom.ext <| add_smul _ _", "start": [74, 1], "end": [79, 51], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_smul'", "code": "@[simp] theorem coe_smul' [Semiring R] [AddCommMonoid M] [Module R M] :\n    \u21d1(.smul : R \u2192+ M \u2192+ M) = AddMonoidHom.smulLeft", "start": [81, 1], "end": [82, 58], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.module", "code": "instance module [Semiring R] [AddMonoid A] [AddCommMonoid B] [Module R B] : Module R (A \u2192+ B) :=\n  { add_smul := fun _ _ _=> ext fun _ => add_smul _ _ _\n    zero_smul := fun _ => ext fun _ => zero_smul _ _ }", "start": [84, 1], "end": [86, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Prod.lean", "imports": ["Mathlib/GroupTheory/GroupAction/Prod.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.smulWithZero", "code": "instance smulWithZero [Zero R] [Zero M] [Zero N] [SMulWithZero R M] [SMulWithZero R N] :\n    SMulWithZero R (M \u00d7 N) :=\n  { Prod.smul with\n    smul_zero := fun _ => Prod.ext (smul_zero _) (smul_zero _)\n    zero_smul := fun _ => Prod.ext (zero_smul _ _) (zero_smul _ _) }", "start": [22, 1], "end": [26, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.mulActionWithZero", "code": "instance mulActionWithZero [MonoidWithZero R] [Zero M] [Zero N] [MulActionWithZero R M]\n    [MulActionWithZero R N] : MulActionWithZero R (M \u00d7 N) :=\n  { Prod.mulAction with\n    smul_zero := fun _ => Prod.ext (smul_zero _) (smul_zero _)\n    zero_smul := fun _ => Prod.ext (zero_smul _ _) (zero_smul _ _) }", "start": [29, 1], "end": [33, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.instModule", "code": "instance instModule [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module R N] :\n    Module R (M \u00d7 N) :=\n  { Prod.distribMulAction with\n    add_smul := fun _ _ _ => mk.inj_iff.mpr \u27e8add_smul _ _ _, add_smul _ _ _\u27e9\n    zero_smul := fun _ => mk.inj_iff.mpr \u27e8zero_smul _ _, zero_smul _ _\u27e9 }", "start": [36, 1], "end": [40, 74], "kind": "commanddeclaration"}, {"full_name": "Prod.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors {r : Semiring R} [AddCommMonoid M] [AddCommMonoid N]\n    [Module R M] [Module R N] [NoZeroSMulDivisors R M] [NoZeroSMulDivisors R N] :\n    NoZeroSMulDivisors R (M \u00d7 N) :=\n  { eq_zero_or_eq_zero_of_smul_eq_zero := by intro c \u27e8x, y\u27e9 h\n      exact or_iff_not_imp_left.mpr fun hc =>\n        mk.inj_iff.mpr\n          \u27e8(smul_eq_zero.mp (congr_arg fst h)).resolve_left hc,\n            (smul_eq_zero.mp (congr_arg snd h)).resolve_left hc\u27e9 }", "start": [43, 1], "end": [54, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/Basic.lean", "imports": ["Mathlib/GroupTheory/GroupAction/BigOperators.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/Algebra/Module/LinearMap.lean", "Mathlib/Data/Finset/Preimage.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Set/Finite.lean"], "premises": [{"full_name": "DFinsupp", "code": "structure DFinsupp [\u2200 i, Zero (\u03b2 i)] : Type max u v where mk' ::\n  \n  toFun : \u2200 i, \u03b2 i\n  \n  support' : Trunc { s : Multiset \u03b9 // \u2200 i, i \u2208 s \u2228 toFun i = 0 }", "start": [57, 1], "end": [66, 66], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.funLike", "code": "instance funLike : FunLike (\u03a0\u2080 i, \u03b2 i) \u03b9 \u03b2 :=\n  \u27e8fun f => f.toFun, fun \u27e8f\u2081, s\u2081\u27e9 \u27e8f\u2082, s\u2081\u27e9 \u21a6 fun (h : f\u2081 = f\u2082) \u21a6 by\n    subst h\n    congr\n    apply Subsingleton.elim \u27e9", "start": [85, 1], "end": [89, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : \u03a0\u2080 i, \u03b2 i) : f.toFun = f", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.ext", "code": "@[ext]\ntheorem ext {f g : \u03a0\u2080 i, \u03b2 i} (h : \u2200 i, f i = g i) : f = g", "start": [102, 1], "end": [104, 20], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.ext_iff", "code": "@[deprecated FunLike.ext_iff]\ntheorem ext_iff {f g : \u03a0\u2080 i, \u03b2 i} : f = g \u2194 \u2200 i, f i = g i", "start": [107, 1], "end": [109, 18], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coeFn_injective", "code": "@[deprecated FunLike.coe_injective]\ntheorem coeFn_injective : @Function.Injective (\u03a0\u2080 i, \u03b2 i) (\u2200 i, \u03b2 i) (\u21d1)", "start": [112, 1], "end": [114, 24], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : \u2200 i, \u03b2 i) (s) : \u21d1(\u27e8f, s\u27e9 : \u03a0\u2080 i, \u03b2 i) = f", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zero_apply", "code": "theorem zero_apply (i : \u03b9) : (0 : \u03a0\u2080 i, \u03b2 i) i = 0", "start": [133, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange", "code": "def mapRange (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0) (x : \u03a0\u2080 i, \u03b2\u2081 i) : \u03a0\u2080 i, \u03b2\u2082 i :=\n  \u27e8fun i => f i (x i),\n    x.support'.map fun s => \u27e8s.1, fun i => (s.2 i).imp_right fun h : x i = 0 => by\n      rw [\u2190 hf i, \u2190 h]\u27e9\u27e9", "start": [137, 1], "end": [151, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_apply", "code": "@[simp]\ntheorem mapRange_apply (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0) (g : \u03a0\u2080 i, \u03b2\u2081 i) (i : \u03b9) :\n    mapRange f hf g i = f i (g i)", "start": [154, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_id", "code": "@[simp]\ntheorem mapRange_id (h : \u2200 i, id (0 : \u03b2\u2081 i) = 0 := fun i => rfl) (g : \u03a0\u2080 i : \u03b9, \u03b2\u2081 i) :\n    mapRange (fun i => (id : \u03b2\u2081 i \u2192 \u03b2\u2081 i)) h g = g", "start": [160, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_comp", "code": "theorem mapRange_comp (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (f\u2082 : \u2200 i, \u03b2 i \u2192 \u03b2\u2081 i) (hf : \u2200 i, f i 0 = 0)\n    (hf\u2082 : \u2200 i, f\u2082 i 0 = 0) (h : \u2200 i, (f i \u2218 f\u2082 i) 0 = 0) (g : \u03a0\u2080 i : \u03b9, \u03b2 i) :\n    mapRange (fun i => f i \u2218 f\u2082 i) h g = mapRange f hf (mapRange f\u2082 hf\u2082 g)", "start": [167, 1], "end": [171, 34], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_zero", "code": "@[simp]\ntheorem mapRange_zero (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0) :\n    mapRange f hf (0 : \u03a0\u2080 i, \u03b2\u2081 i) = 0", "start": [174, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zipWith", "code": "def zipWith (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i) (hf : \u2200 i, f i 0 0 = 0) (x : \u03a0\u2080 i, \u03b2\u2081 i) (y : \u03a0\u2080 i, \u03b2\u2082 i) :\n    \u03a0\u2080 i, \u03b2 i :=\n  \u27e8fun i => f i (x i) (y i), by\n    refine' x.support'.bind fun xs => _\n    refine' y.support'.map fun ys => _\n    refine' \u27e8xs + ys, fun i => _\u27e9\n    obtain h1 | (h1 : x i = 0) := xs.prop i\n    \u00b7 left\n      rw [Multiset.mem_add]\n      left\n      exact h1\n    obtain h2 | (h2 : y i = 0) := ys.prop i\n    \u00b7 left\n      rw [Multiset.mem_add]\n      right\n      exact h2\n    right; rw [\u2190 hf, \u2190 h1, \u2190 h2]\u27e9", "start": [181, 1], "end": [199, 34], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zipWith_apply", "code": "@[simp]\ntheorem zipWith_apply (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i) (hf : \u2200 i, f i 0 0 = 0) (g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i)\n    (g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i) (i : \u03b9) : zipWith f hf g\u2081 g\u2082 i = f i (g\u2081 i) (g\u2082 i)", "start": [202, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.piecewise", "code": "def piecewise : \u03a0\u2080 i, \u03b2 i :=\n  zipWith (fun i x y => if i \u2208 s then x else y) (fun _ => ite_self 0) x y", "start": [212, 1], "end": [215, 74], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.piecewise_apply", "code": "theorem piecewise_apply (i : \u03b9) : x.piecewise y s i = if i \u2208 s then x i else y i", "start": [218, 1], "end": [219, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_piecewise", "code": "@[simp, norm_cast]\ntheorem coe_piecewise : \u21d1(x.piecewise y s) = s.piecewise x y", "start": [222, 1], "end": [225, 24], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.add_apply", "code": "theorem add_apply [\u2200 i, AddZeroClass (\u03b2 i)] (g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) :\n    (g\u2081 + g\u2082) i = g\u2081 i + g\u2082 i", "start": [237, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_add", "code": "@[simp]\ntheorem coe_add [\u2200 i, AddZeroClass (\u03b2 i)] (g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2 i) : \u21d1(g\u2081 + g\u2082) = g\u2081 + g\u2082", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addZeroClass", "code": "instance addZeroClass [\u2200 i, AddZeroClass (\u03b2 i)] : AddZeroClass (\u03a0\u2080 i, \u03b2 i) :=\n  FunLike.coe_injective.addZeroClass _ coe_zero coe_add", "start": [247, 1], "end": [248, 56], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.instIsLeftCancelAdd", "code": "instance instIsLeftCancelAdd [\u2200 i, AddZeroClass (\u03b2 i)] [\u2200 i, IsLeftCancelAdd (\u03b2 i)] :\n    IsLeftCancelAdd (\u03a0\u2080 i, \u03b2 i) where\n  add_left_cancel _ _ _ h := ext fun x => add_left_cancel <| FunLike.congr_fun h x", "start": [250, 1], "end": [252, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.instIsRightCancelAdd", "code": "instance instIsRightCancelAdd [\u2200 i, AddZeroClass (\u03b2 i)] [\u2200 i, IsRightCancelAdd (\u03b2 i)] :\n    IsRightCancelAdd (\u03a0\u2080 i, \u03b2 i) where\n  add_right_cancel _ _ _ h := ext fun x => add_right_cancel <| FunLike.congr_fun h x", "start": [254, 1], "end": [256, 85], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.instIsCancelAdd", "code": "instance instIsCancelAdd [\u2200 i, AddZeroClass (\u03b2 i)] [\u2200 i, IsCancelAdd (\u03b2 i)] :\n    IsCancelAdd (\u03a0\u2080 i, \u03b2 i) where", "start": [258, 1], "end": [259, 34], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.hasNatScalar", "code": "instance hasNatScalar [\u2200 i, AddMonoid (\u03b2 i)] : SMul \u2115 (\u03a0\u2080 i, \u03b2 i) :=\n  \u27e8fun c v => v.mapRange (fun _ => (\u00b7 \u2022 \u00b7) c) fun _ => nsmul_zero _\u27e9", "start": [261, 1], "end": [264, 69], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.nsmul_apply", "code": "theorem nsmul_apply [\u2200 i, AddMonoid (\u03b2 i)] (b : \u2115) (v : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : (b \u2022 v) i = b \u2022 v i", "start": [267, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_nsmul", "code": "@[simp]\ntheorem coe_nsmul [\u2200 i, AddMonoid (\u03b2 i)] (b : \u2115) (v : \u03a0\u2080 i, \u03b2 i) : \u21d1(b \u2022 v) = b \u2022 \u21d1v", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coeFnAddMonoidHom", "code": "def coeFnAddMonoidHom [\u2200 i, AddZeroClass (\u03b2 i)] : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u2200 i, \u03b2 i\n    where\n  toFun := (\u21d1)\n  map_zero' := coe_zero\n  map_add' := coe_add", "start": [279, 1], "end": [284, 22], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.evalAddMonoidHom", "code": "def evalAddMonoidHom [\u2200 i, AddZeroClass (\u03b2 i)] (i : \u03b9) : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b2 i :=\n  (Pi.evalAddMonoidHom \u03b2 i).comp coeFnAddMonoidHom", "start": [287, 1], "end": [290, 51], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addCommMonoid", "code": "instance addCommMonoid [\u2200 i, AddCommMonoid (\u03b2 i)] : AddCommMonoid (\u03a0\u2080 i, \u03b2 i) :=\n  FunLike.coe_injective.addCommMonoid _ coe_zero coe_add fun _ _ => coe_nsmul _ _", "start": [293, 1], "end": [294, 82], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_finset_sum", "code": "@[simp]\ntheorem coe_finset_sum {\u03b1} [\u2200 i, AddCommMonoid (\u03b2 i)] (s : Finset \u03b1) (g : \u03b1 \u2192 \u03a0\u2080 i, \u03b2 i) :\n    \u21d1(\u2211 a in s, g a) = \u2211 a in s, \u21d1g a", "start": [296, 1], "end": [299, 50], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.finset_sum_apply", "code": "@[simp]\ntheorem finset_sum_apply {\u03b1} [\u2200 i, AddCommMonoid (\u03b2 i)] (s : Finset \u03b1) (g : \u03b1 \u2192 \u03a0\u2080 i, \u03b2 i) (i : \u03b9) :\n    (\u2211 a in s, g a) i = \u2211 a in s, g a i", "start": [302, 1], "end": [305, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.neg_apply", "code": "theorem neg_apply [\u2200 i, AddGroup (\u03b2 i)] (g : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : (-g) i = -g i", "start": [311, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_neg", "code": "@[simp]\ntheorem coe_neg [\u2200 i, AddGroup (\u03b2 i)] (g : \u03a0\u2080 i, \u03b2 i) : \u21d1(-g) = -g", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sub_apply", "code": "theorem sub_apply [\u2200 i, AddGroup (\u03b2 i)] (g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : (g\u2081 - g\u2082) i = g\u2081 i - g\u2082 i", "start": [323, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_sub", "code": "@[simp]\ntheorem coe_sub [\u2200 i, AddGroup (\u03b2 i)] (g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2 i) : \u21d1(g\u2081 - g\u2082) = g\u2081 - g\u2082", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.hasIntScalar", "code": "instance hasIntScalar [\u2200 i, AddGroup (\u03b2 i)] : SMul \u2124 (\u03a0\u2080 i, \u03b2 i) :=\n  \u27e8fun c v => v.mapRange (fun _ => (\u00b7 \u2022 \u00b7) c) fun _ => zsmul_zero _\u27e9", "start": [332, 1], "end": [335, 69], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zsmul_apply", "code": "theorem zsmul_apply [\u2200 i, AddGroup (\u03b2 i)] (b : \u2124) (v : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : (b \u2022 v) i = b \u2022 v i", "start": [338, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_zsmul", "code": "@[simp]\ntheorem coe_zsmul [\u2200 i, AddGroup (\u03b2 i)] (b : \u2124) (v : \u03a0\u2080 i, \u03b2 i) : \u21d1(b \u2022 v) = b \u2022 \u21d1v", "start": [342, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addCommGroup", "code": "instance addCommGroup [\u2200 i, AddCommGroup (\u03b2 i)] : AddCommGroup (\u03a0\u2080 i, \u03b2 i) :=\n  FunLike.coe_injective.addCommGroup _ coe_zero coe_add coe_neg coe_sub (fun _ _ => coe_nsmul _ _)\n    fun _ _ => coe_zsmul _ _", "start": [351, 1], "end": [353, 29], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.smul_apply", "code": "theorem smul_apply [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] (b : \u03b3)\n    (v : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : (b \u2022 v) i = b \u2022 v i", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_smul", "code": "@[simp]\ntheorem coe_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] (b : \u03b3)\n    (v : \u03a0\u2080 i, \u03b2 i) : \u21d1(b \u2022 v) = b \u2022 \u21d1v", "start": [365, 1], "end": [368, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.smulCommClass", "code": "instance smulCommClass {\u03b4 : Type*} [Monoid \u03b3] [Monoid \u03b4] [\u2200 i, AddMonoid (\u03b2 i)]\n    [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] [\u2200 i, DistribMulAction \u03b4 (\u03b2 i)] [\u2200 i, SMulCommClass \u03b3 \u03b4 (\u03b2 i)] :\n    SMulCommClass \u03b3 \u03b4 (\u03a0\u2080 i, \u03b2 i) where\n  smul_comm r s m := ext fun i => by simp only [smul_apply, smul_comm r s (m i)]", "start": [371, 1], "end": [374, 81], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.isScalarTower", "code": "instance isScalarTower {\u03b4 : Type*} [Monoid \u03b3] [Monoid \u03b4] [\u2200 i, AddMonoid (\u03b2 i)]\n    [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] [\u2200 i, DistribMulAction \u03b4 (\u03b2 i)] [SMul \u03b3 \u03b4]\n    [\u2200 i, IsScalarTower \u03b3 \u03b4 (\u03b2 i)] : IsScalarTower \u03b3 \u03b4 (\u03a0\u2080 i, \u03b2 i) where\n  smul_assoc r s m := ext fun i => by simp only [smul_apply, smul_assoc r s (m i)]", "start": [376, 1], "end": [379, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.isCentralScalar", "code": "instance isCentralScalar [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)]\n    [\u2200 i, DistribMulAction \u03b3\u1d50\u1d52\u1d56 (\u03b2 i)] [\u2200 i, IsCentralScalar \u03b3 (\u03b2 i)] :\n    IsCentralScalar \u03b3 (\u03a0\u2080 i, \u03b2 i) where\n  op_smul_eq_smul r m := ext fun i => by simp only [smul_apply, op_smul_eq_smul r (m i)]", "start": [381, 1], "end": [384, 89], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.distribMulAction", "code": "instance distribMulAction [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] :\n    DistribMulAction \u03b3 (\u03a0\u2080 i, \u03b2 i) :=\n  Function.Injective.distribMulAction coeFnAddMonoidHom FunLike.coe_injective coe_smul", "start": [386, 1], "end": [390, 87], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.module", "code": "instance module [Semiring \u03b3] [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, Module \u03b3 (\u03b2 i)] :\n    Module \u03b3 (\u03a0\u2080 i, \u03b2 i) :=\n  { inferInstanceAs (DistribMulAction \u03b3 (\u03a0\u2080 i, \u03b2 i)) with\n    zero_smul := fun c => ext fun i => by simp only [smul_apply, zero_smul, zero_apply]\n    add_smul := fun c x y => ext fun i => by simp only [add_apply, smul_apply, add_smul] }", "start": [392, 1], "end": [398, 91], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter", "code": "def filter [\u2200 i, Zero (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (x : \u03a0\u2080 i, \u03b2 i) : \u03a0\u2080 i, \u03b2 i :=\n  \u27e8fun i => if p i then x i else 0,\n    x.support'.map fun xs =>\n      \u27e8xs.1, fun i => (xs.prop i).imp_right fun H : x i = 0 => by simp only [H, ite_self]\u27e9\u27e9", "start": [406, 1], "end": [410, 92], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_apply", "code": "@[simp]\ntheorem filter_apply [\u2200 i, Zero (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) :\n    f.filter p i = if p i then f i else 0", "start": [413, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_apply_pos", "code": "theorem filter_apply_pos [\u2200 i, Zero (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p] (f : \u03a0\u2080 i, \u03b2 i) {i : \u03b9}\n    (h : p i) : f.filter p i = f i", "start": [419, 1], "end": [420, 76], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_apply_neg", "code": "theorem filter_apply_neg [\u2200 i, Zero (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p] (f : \u03a0\u2080 i, \u03b2 i) {i : \u03b9}\n    (h : \u00acp i) : f.filter p i = 0", "start": [423, 1], "end": [424, 75], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_pos_add_filter_neg", "code": "theorem filter_pos_add_filter_neg [\u2200 i, AddZeroClass (\u03b2 i)] (f : \u03a0\u2080 i, \u03b2 i) (p : \u03b9 \u2192 Prop)\n    [DecidablePred p] : (f.filter p + f.filter fun i => \u00acp i) = f", "start": [427, 1], "end": [430, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_zero", "code": "@[simp]\ntheorem filter_zero [\u2200 i, Zero (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] :\n    (0 : \u03a0\u2080 i, \u03b2 i).filter p = 0", "start": [433, 1], "end": [437, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_add", "code": "@[simp]\ntheorem filter_add [\u2200 i, AddZeroClass (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (f g : \u03a0\u2080 i, \u03b2 i) :\n    (f + g).filter p = f.filter p + g.filter p", "start": [440, 1], "end": [444, 22], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_smul", "code": "@[simp]\ntheorem filter_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)] (p : \u03b9 \u2192 Prop)\n    [DecidablePred p] (r : \u03b3) (f : \u03a0\u2080 i, \u03b2 i) : (r \u2022 f).filter p = r \u2022 f.filter p", "start": [447, 1], "end": [451, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filterAddMonoidHom", "code": "@[simps]\ndef filterAddMonoidHom [\u2200 i, AddZeroClass (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] :\n    (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03a0\u2080 i, \u03b2 i where\n  toFun := filter p\n  map_zero' := filter_zero p\n  map_add' := filter_add p", "start": [456, 1], "end": [462, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filterLinearMap", "code": "@[simps]\ndef filterLinearMap [Semiring \u03b3] [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, Module \u03b3 (\u03b2 i)] (p : \u03b9 \u2192 Prop)\n    [DecidablePred p] : (\u03a0\u2080 i, \u03b2 i) \u2192\u2097[\u03b3] \u03a0\u2080 i, \u03b2 i\n    where\n  toFun := filter p\n  map_add' := filter_add p\n  map_smul' := filter_smul p", "start": [466, 1], "end": [473, 29], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_neg", "code": "@[simp]\ntheorem filter_neg [\u2200 i, AddGroup (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (f : \u03a0\u2080 i, \u03b2 i) :\n    (-f).filter p = -f.filter p", "start": [479, 1], "end": [482, 37], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_sub", "code": "@[simp]\ntheorem filter_sub [\u2200 i, AddGroup (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (f g : \u03a0\u2080 i, \u03b2 i) :\n    (f - g).filter p = f.filter p - g.filter p", "start": [485, 1], "end": [488, 39], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain", "code": "def subtypeDomain [\u2200 i, Zero (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] (x : \u03a0\u2080 i, \u03b2 i) :\n    \u03a0\u2080 i : Subtype p, \u03b2 i :=\n  \u27e8fun i => x (i : \u03b9),\n    x.support'.map fun xs =>\n      \u27e8(Multiset.filter p xs.1).attach.map fun j => \u27e8j.1, (Multiset.mem_filter.1 j.2).2\u27e9, fun i =>\n        (xs.prop i).imp_left fun H =>\n          Multiset.mem_map.2\n            \u27e8\u27e8i, Multiset.mem_filter.2 \u27e8H, i.2\u27e9\u27e9, Multiset.mem_attach _ _, Subtype.eta _ _\u27e9\u27e9\u27e9", "start": [491, 1], "end": [500, 94], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_zero", "code": "@[simp]\ntheorem subtypeDomain_zero [\u2200 i, Zero (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p] :\n    subtypeDomain p (0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [503, 1], "end": [506, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_apply", "code": "@[simp]\ntheorem subtypeDomain_apply [\u2200 i, Zero (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p] {i : Subtype p}\n    {v : \u03a0\u2080 i, \u03b2 i} : (subtypeDomain p v) i = v i", "start": [509, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_add", "code": "@[simp]\ntheorem subtypeDomain_add [\u2200 i, AddZeroClass (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p]\n    (v v' : \u03a0\u2080 i, \u03b2 i) : (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p", "start": [515, 1], "end": [518, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_smul", "code": "@[simp]\ntheorem subtypeDomain_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)]\n    {p : \u03b9 \u2192 Prop} [DecidablePred p] (r : \u03b3) (f : \u03a0\u2080 i, \u03b2 i) :\n    (r \u2022 f).subtypeDomain p = r \u2022 f.subtypeDomain p", "start": [521, 1], "end": [525, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomainAddMonoidHom", "code": "@[simps]\ndef subtypeDomainAddMonoidHom [\u2200 i, AddZeroClass (\u03b2 i)] (p : \u03b9 \u2192 Prop) [DecidablePred p] :\n    (\u03a0\u2080 i : \u03b9, \u03b2 i) \u2192+ \u03a0\u2080 i : Subtype p, \u03b2 i\n    where\n  toFun := subtypeDomain p\n  map_zero' := subtypeDomain_zero\n  map_add' := subtypeDomain_add", "start": [530, 1], "end": [537, 32], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomainLinearMap", "code": "@[simps]\ndef subtypeDomainLinearMap [Semiring \u03b3] [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, Module \u03b3 (\u03b2 i)]\n    (p : \u03b9 \u2192 Prop) [DecidablePred p] : (\u03a0\u2080 i, \u03b2 i) \u2192\u2097[\u03b3] \u03a0\u2080 i : Subtype p, \u03b2 i\n    where\n  toFun := subtypeDomain p\n  map_add' := subtypeDomain_add\n  map_smul' := subtypeDomain_smul", "start": [541, 1], "end": [548, 34], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_neg", "code": "@[simp]\ntheorem subtypeDomain_neg [\u2200 i, AddGroup (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p] {v : \u03a0\u2080 i, \u03b2 i} :\n    (-v).subtypeDomain p = -v.subtypeDomain p", "start": [554, 1], "end": [557, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_sub", "code": "@[simp]\ntheorem subtypeDomain_sub [\u2200 i, AddGroup (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p]\n    {v v' : \u03a0\u2080 i, \u03b2 i} : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p", "start": [560, 1], "end": [563, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.finite_support", "code": "theorem finite_support (f : \u03a0\u2080 i, \u03b2 i) : Set.Finite { i | f i \u2260 0 }", "start": [574, 1], "end": [578, 64], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk", "code": "def mk (s : Finset \u03b9) (x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 (i : \u03b9)) : \u03a0\u2080 i, \u03b2 i :=\n  \u27e8fun i => if H : i \u2208 s then x \u27e8i, H\u27e9 else 0,\n    Trunc.mk \u27e8s.1, fun i => if H : i \u2208 s then Or.inl H else Or.inr <| dif_neg H\u27e9\u27e9", "start": [581, 1], "end": [585, 82], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_apply", "code": "@[simp]\ntheorem mk_apply : (mk s x : \u2200 i, \u03b2 i) i = if H : i \u2208 s then x \u27e8i, H\u27e9 else 0", "start": [590, 1], "end": [592, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_of_mem", "code": "theorem mk_of_mem (hi : i \u2208 s) : (mk s x : \u2200 i, \u03b2 i) i = x \u27e8i, hi\u27e9", "start": [595, 1], "end": [596, 13], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_of_not_mem", "code": "theorem mk_of_not_mem (hi : i \u2209 s) : (mk s x : \u2200 i, \u03b2 i) i = 0", "start": [599, 1], "end": [600, 13], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_injective", "code": "theorem mk_injective (s : Finset \u03b9) : Function.Injective (@mk \u03b9 \u03b2 _ _ s)", "start": [603, 1], "end": [609, 35], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.unique", "code": "instance unique [\u2200 i, Subsingleton (\u03b2 i)] : Unique (\u03a0\u2080 i, \u03b2 i) :=\n  FunLike.coe_injective.unique", "start": [612, 1], "end": [613, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.uniqueOfIsEmpty", "code": "instance uniqueOfIsEmpty [IsEmpty \u03b9] : Unique (\u03a0\u2080 i, \u03b2 i) :=\n  FunLike.coe_injective.unique", "start": [616, 1], "end": [617, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivFunOnFintype", "code": "@[simps apply]\ndef equivFunOnFintype [Fintype \u03b9] : (\u03a0\u2080 i, \u03b2 i) \u2243 \u2200 i, \u03b2 i\n    where\n  toFun := (\u21d1)\n  invFun f := \u27e8f, Trunc.mk \u27e8Finset.univ.1, fun _ => Or.inl <| Finset.mem_univ_val _\u27e9\u27e9\n  left_inv _ := FunLike.coe_injective rfl\n  right_inv _ := rfl", "start": [620, 1], "end": [628, 21], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivFunOnFintype_symm_coe", "code": "@[simp]\ntheorem equivFunOnFintype_symm_coe [Fintype \u03b9] (f : \u03a0\u2080 i, \u03b2 i) : equivFunOnFintype.symm f = f", "start": [632, 1], "end": [634, 29], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single", "code": "def single (i : \u03b9) (b : \u03b2 i) : \u03a0\u2080 i, \u03b2 i :=\n  \u27e8Pi.single i b,\n    Trunc.mk \u27e8{i}, fun j => (Decidable.eq_or_ne j i).imp (by simp) fun h => Pi.single_eq_of_ne h _\u27e9\u27e9", "start": [637, 1], "end": [641, 101], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_pi_single", "code": "theorem single_eq_pi_single {i b} : \u21d1(single i b : \u03a0\u2080 i, \u03b2 i) = Pi.single i b", "start": [644, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_apply", "code": "@[simp]\ntheorem single_apply {i i' b} :\n    (single i b : \u03a0\u2080 i, \u03b2 i) i' = if h : i = i' then Eq.recOn h b else 0", "start": [648, 1], "end": [652, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_zero", "code": "@[simp]\ntheorem single_zero (i) : (single i 0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [655, 1], "end": [657, 44], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_same", "code": "theorem single_eq_same {i b} : (single i b : \u03a0\u2080 i, \u03b2 i) i = b", "start": [661, 1], "end": [662, 50], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_of_ne", "code": "theorem single_eq_of_ne {i i' b} (h : i \u2260 i') : (single i b : \u03a0\u2080 i, \u03b2 i) i' = 0", "start": [665, 1], "end": [666, 38], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_injective", "code": "theorem single_injective {i} : Function.Injective (single i : \u03b2 i \u2192 \u03a0\u2080 i, \u03b2 i)", "start": [669, 1], "end": [670, 64], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_single_iff", "code": "theorem single_eq_single_iff (i j : \u03b9) (xi : \u03b2 i) (xj : \u03b2 j) :\n    DFinsupp.single i xi = DFinsupp.single j xj \u2194 i = j \u2227 HEq xi xj \u2228 xi = 0 \u2227 xj = 0", "start": [673, 1], "end": [690, 62], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_left_injective", "code": "theorem single_left_injective {b : \u2200 i : \u03b9, \u03b2 i} (h : \u2200 i, b i \u2260 0) :\n    Function.Injective (fun i => single i (b i) : \u03b9 \u2192 \u03a0\u2080 i, \u03b2 i)", "start": [693, 1], "end": [697, 80], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_zero", "code": "@[simp]\ntheorem single_eq_zero {i : \u03b9} {xi : \u03b2 i} : single i xi = 0 \u2194 xi = 0", "start": [700, 1], "end": [703, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_single", "code": "theorem filter_single (p : \u03b9 \u2192 Prop) [DecidablePred p] (i : \u03b9) (x : \u03b2 i) :\n    (single i x).filter p = if p i then single i x else 0", "start": [706, 1], "end": [714, 49], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_single_pos", "code": "@[simp]\ntheorem filter_single_pos {p : \u03b9 \u2192 Prop} [DecidablePred p] (i : \u03b9) (x : \u03b2 i) (h : p i) :\n    (single i x).filter p = single i x", "start": [717, 1], "end": [719, 74], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_single_neg", "code": "@[simp]\ntheorem filter_single_neg {p : \u03b9 \u2192 Prop} [DecidablePred p] (i : \u03b9) (x : \u03b2 i) (h : \u00acp i) :\n    (single i x).filter p = 0", "start": [722, 1], "end": [724, 65], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_eq_of_sigma_eq", "code": "theorem single_eq_of_sigma_eq {i j} {xi : \u03b2 i} {xj : \u03b2 j} (h : (\u27e8i, xi\u27e9 : Sigma \u03b2) = \u27e8j, xj\u27e9) :\n    DFinsupp.single i xi = DFinsupp.single j xj", "start": [727, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivFunOnFintype_single", "code": "@[simp]\ntheorem equivFunOnFintype_single [Fintype \u03b9] (i : \u03b9) (m : \u03b2 i) :\n    (@DFinsupp.equivFunOnFintype \u03b9 \u03b2 _ _) (DFinsupp.single i m) = Pi.single i m", "start": [734, 1], "end": [739, 52], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivFunOnFintype_symm_single", "code": "@[simp]\ntheorem equivFunOnFintype_symm_single [Fintype \u03b9] (i : \u03b9) (m : \u03b2 i) :\n    (@DFinsupp.equivFunOnFintype \u03b9 \u03b2 _ _).symm (Pi.single i m) = DFinsupp.single i m", "start": [742, 1], "end": [746, 64], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase", "code": "def erase (i : \u03b9) (x : \u03a0\u2080 i, \u03b2 i) : \u03a0\u2080 i, \u03b2 i :=\n  \u27e8fun j \u21a6 if j = i then 0 else x.1 j,\n    x.support'.map fun xs \u21a6 \u27e8xs.1, fun j \u21a6 (xs.prop j).imp_right (by simp only [\u00b7, ite_self])\u27e9\u27e9", "start": [749, 1], "end": [752, 96], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_apply", "code": "@[simp]\ntheorem erase_apply {i j : \u03b9} {f : \u03a0\u2080 i, \u03b2 i} : (f.erase i) j = if j = i then 0 else f j", "start": [755, 1], "end": [757, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_same", "code": "theorem erase_same {i : \u03b9} {f : \u03a0\u2080 i, \u03b2 i} : (f.erase i) i = 0", "start": [761, 1], "end": [761, 74], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_ne", "code": "theorem erase_ne {i i' : \u03b9} {f : \u03a0\u2080 i, \u03b2 i} (h : i' \u2260 i) : (f.erase i) i' = f i'", "start": [764, 1], "end": [764, 96], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.piecewise_single_erase", "code": "theorem piecewise_single_erase (x : \u03a0\u2080 i, \u03b2 i) (i : \u03b9)\n    [\u2200 i' : \u03b9, Decidable <| (i' \u2208 ({i} : Set \u03b9))] : (single i (x i)).piecewise (x.erase i) {i} = x", "start": [767, 1], "end": [772, 21], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_eq_sub_single", "code": "theorem erase_eq_sub_single {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, AddGroup (\u03b2 i)] (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) :\n    f.erase i = f - single i (f i)", "start": [775, 1], "end": [780, 63], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_zero", "code": "@[simp]\ntheorem erase_zero (i : \u03b9) : erase i (0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [783, 1], "end": [785, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_ne_eq_erase", "code": "@[simp]\ntheorem filter_ne_eq_erase (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : f.filter (\u00b7 \u2260 i) = f.erase i", "start": [788, 1], "end": [791, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_ne_eq_erase'", "code": "@[simp]\ntheorem filter_ne_eq_erase' (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) : f.filter ((\u00b7 \u2260 \u00b7) i) = f.erase i", "start": [794, 1], "end": [798, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_single", "code": "theorem erase_single (j : \u03b9) (i : \u03b9) (x : \u03b2 i) :\n    (single i x).erase j = if i = j then 0 else single i x", "start": [801, 1], "end": [803, 52], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_single_same", "code": "@[simp]\ntheorem erase_single_same (i : \u03b9) (x : \u03b2 i) : (single i x).erase i = 0", "start": [806, 1], "end": [808, 32], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_single_ne", "code": "@[simp]\ntheorem erase_single_ne {i j : \u03b9} (x : \u03b2 i) (h : i \u2260 j) : (single i x).erase j = single i x", "start": [811, 1], "end": [813, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update", "code": "def update : \u03a0\u2080 i, \u03b2 i :=\n  \u27e8Function.update f i b,\n    f.support'.map fun s =>\n      \u27e8i ::\u2098 s.1, fun j => by\n        rcases eq_or_ne i j with (rfl | hi)\n        \u00b7 simp\n        \u00b7 obtain hj | (hj : f j = 0) := s.prop j\n          \u00b7 exact Or.inl (Multiset.mem_cons_of_mem hj)\n          \u00b7 exact Or.inr ((Function.update_noteq hi.symm b _).trans hj)\u27e9\u27e9", "start": [820, 1], "end": [833, 74], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coe_update", "code": "@[simp]\ntheorem coe_update : (f.update i b : \u2200 i : \u03b9, \u03b2 i) = Function.update f i b", "start": [838, 1], "end": [840, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update_self", "code": "@[simp]\ntheorem update_self : f.update i (f i) = f", "start": [843, 1], "end": [846, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update_eq_erase", "code": "@[simp]\ntheorem update_eq_erase : f.update i 0 = f.erase i", "start": [849, 1], "end": [854, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update_eq_single_add_erase", "code": "theorem update_eq_single_add_erase {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, AddZeroClass (\u03b2 i)] (f : \u03a0\u2080 i, \u03b2 i)\n    (i : \u03b9) (b : \u03b2 i) : f.update i b = single i b + f.erase i", "start": [857, 1], "end": [862, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update_eq_erase_add_single", "code": "theorem update_eq_erase_add_single {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, AddZeroClass (\u03b2 i)] (f : \u03a0\u2080 i, \u03b2 i)\n    (i : \u03b9) (b : \u03b2 i) : f.update i b = f.erase i + single i b", "start": [865, 1], "end": [870, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.update_eq_sub_add_single", "code": "theorem update_eq_sub_add_single {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, AddGroup (\u03b2 i)] (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9)\n    (b : \u03b2 i) : f.update i b = f - single i (f i) + single i b", "start": [873, 1], "end": [875, 65], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_add", "code": "@[simp]\ntheorem single_add (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i) : single i (b\u2081 + b\u2082) = single i b\u2081 + single i b\u2082", "start": [886, 1], "end": [892, 57], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_add", "code": "@[simp]\ntheorem erase_add (i : \u03b9) (f\u2081 f\u2082 : \u03a0\u2080 i, \u03b2 i) : erase i (f\u2081 + f\u2082) = erase i f\u2081 + erase i f\u2082", "start": [895, 1], "end": [897, 38], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.singleAddHom", "code": "@[simps]\ndef singleAddHom (i : \u03b9) : \u03b2 i \u2192+ \u03a0\u2080 i, \u03b2 i\n    where\n  toFun := single i\n  map_zero' := single_zero i\n  map_add' := single_add i", "start": [902, 1], "end": [908, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.eraseAddHom", "code": "@[simps]\ndef eraseAddHom (i : \u03b9) : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03a0\u2080 i, \u03b2 i\n    where\n  toFun := erase i\n  map_zero' := erase_zero i\n  map_add' := erase_add i", "start": [912, 1], "end": [918, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_neg", "code": "@[simp]\ntheorem single_neg {\u03b2 : \u03b9 \u2192 Type v} [\u2200 i, AddGroup (\u03b2 i)] (i : \u03b9) (x : \u03b2 i) :\n    single i (-x) = -single i x", "start": [924, 1], "end": [927, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_sub", "code": "@[simp]\ntheorem single_sub {\u03b2 : \u03b9 \u2192 Type v} [\u2200 i, AddGroup (\u03b2 i)] (i : \u03b9) (x y : \u03b2 i) :\n    single i (x - y) = single i x - single i y", "start": [930, 1], "end": [933, 33], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_neg", "code": "@[simp]\ntheorem erase_neg {\u03b2 : \u03b9 \u2192 Type v} [\u2200 i, AddGroup (\u03b2 i)] (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) :\n    (-f).erase i = -f.erase i", "start": [936, 1], "end": [939, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_sub", "code": "@[simp]\ntheorem erase_sub {\u03b2 : \u03b9 \u2192 Type v} [\u2200 i, AddGroup (\u03b2 i)] (i : \u03b9) (f g : \u03a0\u2080 i, \u03b2 i) :\n    (f - g).erase i = f.erase i - g.erase i", "start": [942, 1], "end": [945, 32], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_add_erase", "code": "theorem single_add_erase (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : single i (f i) + f.erase i = f", "start": [948, 1], "end": [953, 96], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_add_single", "code": "theorem erase_add_single (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : f.erase i + single i (f i) = f", "start": [956, 1], "end": [961, 96], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.induction", "code": "protected theorem induction {p : (\u03a0\u2080 i, \u03b2 i) \u2192 Prop} (f : \u03a0\u2080 i, \u03b2 i) (h0 : p 0)\n    (ha : \u2200 (i b) (f : \u03a0\u2080 i, \u03b2 i), f i = 0 \u2192 b \u2260 0 \u2192 p f \u2192 p (single i b + f)) : p f", "start": [964, 1], "end": [996, 18], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.induction\u2082", "code": "theorem induction\u2082 {p : (\u03a0\u2080 i, \u03b2 i) \u2192 Prop} (f : \u03a0\u2080 i, \u03b2 i) (h0 : p 0)\n    (ha : \u2200 (i b) (f : \u03a0\u2080 i, \u03b2 i), f i = 0 \u2192 b \u2260 0 \u2192 p f \u2192 p (f + single i b)) : p f", "start": [999, 1], "end": [1007, 37], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.add_closure_iUnion_range_single", "code": "@[simp]\ntheorem add_closure_iUnion_range_single :\n    AddSubmonoid.closure (\u22c3 i : \u03b9, Set.range (single i : \u03b2 i \u2192 \u03a0\u2080 i, \u03b2 i)) = \u22a4", "start": [1010, 1], "end": [1018, 87], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addHom_ext", "code": "theorem addHom_ext {\u03b3 : Type w} [AddZeroClass \u03b3] \u2983f g : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b3\u2984\n    (H : \u2200 (i : \u03b9) (y : \u03b2 i), f (single i y) = g (single i y)) : f = g", "start": [1021, 1], "end": [1028, 10], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addHom_ext'", "code": "@[ext]\ntheorem addHom_ext' {\u03b3 : Type w} [AddZeroClass \u03b3] \u2983f g : (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b3\u2984\n    (H : \u2200 x, f.comp (singleAddHom \u03b2 x) = g.comp (singleAddHom \u03b2 x)) : f = g", "start": [1031, 1], "end": [1038, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_add", "code": "@[simp]\ntheorem mk_add [\u2200 i, AddZeroClass (\u03b2 i)] {s : Finset \u03b9} {x y : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i} :\n    mk s (x + y) = mk s x + mk s y", "start": [1043, 1], "end": [1046, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_zero", "code": "@[simp]\ntheorem mk_zero [\u2200 i, Zero (\u03b2 i)] {s : Finset \u03b9} : mk s (0 : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i.1) = 0", "start": [1049, 1], "end": [1051, 58], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_neg", "code": "@[simp]\ntheorem mk_neg [\u2200 i, AddGroup (\u03b2 i)] {s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i.1} :\n    mk s (-x) = -mk s x", "start": [1054, 1], "end": [1057, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_sub", "code": "@[simp]\ntheorem mk_sub [\u2200 i, AddGroup (\u03b2 i)] {s : Finset \u03b9} {x y : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i.1} :\n    mk s (x - y) = mk s x - mk s y", "start": [1060, 1], "end": [1063, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mkAddGroupHom", "code": "def mkAddGroupHom [\u2200 i, AddGroup (\u03b2 i)] (s : Finset \u03b9) : (\u2200 i : (s : Set \u03b9), \u03b2 \u2191i) \u2192+ \u03a0\u2080 i : \u03b9, \u03b2 i\n    where\n  toFun := mk s\n  map_zero' := mk_zero\n  map_add' _ _ := mk_add", "start": [1066, 1], "end": [1072, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mk_smul", "code": "@[simp]\ntheorem mk_smul {s : Finset \u03b9} (c : \u03b3) (x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 (i : \u03b9)) :\n    mk s (c \u2022 x) = c \u2022 mk s x", "start": [1079, 1], "end": [1082, 88], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.single_smul", "code": "@[simp]\ntheorem single_smul {i : \u03b9} (c : \u03b3) (x : \u03b2 i) : single i (c \u2022 x) = c \u2022 single i x", "start": [1085, 1], "end": [1091, 21], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support", "code": "def support (f : \u03a0\u2080 i, \u03b2 i) : Finset \u03b9 :=\n  (f.support'.lift fun xs => (Multiset.toFinset xs.1).filter fun i => f i \u2260 0) <| by\n    rintro \u27e8sx, hx\u27e9 \u27e8sy, hy\u27e9\n    dsimp only [Subtype.coe_mk, toFun_eq_coe] at *\n    ext i; constructor\n    \u00b7 intro H\n      rcases Finset.mem_filter.1 H with \u27e8_, h\u27e9\n      exact Finset.mem_filter.2 \u27e8Multiset.mem_toFinset.2 <| (hy i).resolve_right h, h\u27e9\n    \u00b7 intro H\n      rcases Finset.mem_filter.1 H with \u27e8_, h\u27e9\n      exact Finset.mem_filter.2 \u27e8Multiset.mem_toFinset.2 <| (hx i).resolve_right h, h\u27e9", "start": [1100, 1], "end": [1111, 87], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_mk_subset", "code": "@[simp]\ntheorem support_mk_subset {s : Finset \u03b9} {x : \u2200 i : (\u2191s : Set \u03b9), \u03b2 i.1} : (mk s x).support \u2286 s", "start": [1114, 1], "end": [1116, 63], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_mk'_subset", "code": "@[simp]\ntheorem support_mk'_subset {f : \u2200 i, \u03b2 i} {s : Multiset \u03b9} {h} :\n    (mk' f <| Trunc.mk \u27e8s, h\u27e9).support \u2286 s.toFinset", "start": [1119, 1], "end": [1122, 70], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_support_toFun", "code": "@[simp]\ntheorem mem_support_toFun (f : \u03a0\u2080 i, \u03b2 i) (i) : i \u2208 f.support \u2194 f i \u2260 0", "start": [1125, 1], "end": [1131, 54], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.eq_mk_support", "code": "theorem eq_mk_support (f : \u03a0\u2080 i, \u03b2 i) : f = mk f.support fun i => f i", "start": [1134, 1], "end": [1137, 66], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeSupportEqEquiv", "code": "@[simps]\ndef subtypeSupportEqEquiv (s : Finset \u03b9) :\n    {f : \u03a0\u2080 i, \u03b2 i // f.support = s} \u2243 \u2200 i : s, {x : \u03b2 i // x \u2260 0} where\n  toFun | \u27e8f, hf\u27e9 => fun \u27e8i, hi\u27e9 \u21a6 \u27e8f i, (f.mem_support_toFun i).1 <| hf.symm \u25b8 hi\u27e9\n  invFun f := \u27e8mk s fun i \u21a6 (f i).1, Finset.ext fun i \u21a6 by\n    calc\n      i \u2208 support (mk s fun i \u21a6 (f i).1) \u2194 \u2203 h : i \u2208 s, (f \u27e8i, h\u27e9).1 \u2260 0 := by simp\n      _ \u2194 \u2203 _ : i \u2208 s, True := exists_congr fun h \u21a6 (iff_true _).mpr (f _).2\n      _ \u2194 i \u2208 s := by simp\u27e9\n  left_inv := by\n    rintro \u27e8f, rfl\u27e9\n    ext i\n    simpa using Eq.symm\n  right_inv f := by\n    ext1\n    simp [Subtype.eta]; rfl", "start": [1140, 1], "end": [1158, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaFinsetFunEquiv", "code": "@[simps! apply_fst apply_snd_coe]\ndef sigmaFinsetFunEquiv : (\u03a0\u2080 i, \u03b2 i) \u2243 \u03a3 s : Finset \u03b9, \u2200 i : s, {x : \u03b2 i // x \u2260 0} :=\n  (Equiv.sigmaFiberEquiv DFinsupp.support).symm.trans (.sigmaCongrRight subtypeSupportEqEquiv)", "start": [1160, 1], "end": [1164, 95], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_zero", "code": "@[simp]\ntheorem support_zero : (0 : \u03a0\u2080 i, \u03b2 i).support = \u2205", "start": [1166, 1], "end": [1168, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mem_support_iff", "code": "theorem mem_support_iff {f : \u03a0\u2080 i, \u03b2 i} {i : \u03b9} : i \u2208 f.support \u2194 f i \u2260 0", "start": [1171, 1], "end": [1172, 24], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.not_mem_support_iff", "code": "theorem not_mem_support_iff {f : \u03a0\u2080 i, \u03b2 i} {i : \u03b9} : i \u2209 f.support \u2194 f i = 0", "start": [1175, 1], "end": [1176, 38], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_eq_empty", "code": "@[simp]\ntheorem support_eq_empty {f : \u03a0\u2080 i, \u03b2 i} : f.support = \u2205 \u2194 f = 0", "start": [1179, 1], "end": [1181, 98], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.decidableZero", "code": "instance decidableZero : DecidablePred (Eq (0 : \u03a0\u2080 i, \u03b2 i)) := fun _ =>\n  decidable_of_iff _ <| support_eq_empty.trans eq_comm", "start": [1184, 1], "end": [1185, 55], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_subset_iff", "code": "theorem support_subset_iff {s : Set \u03b9} {f : \u03a0\u2080 i, \u03b2 i} :\n    \u2191f.support \u2286 s \u2194 \u2200 (i) (_ : i \u2209 s), f i = 0", "start": [1190, 1], "end": [1192, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_single_ne_zero", "code": "theorem support_single_ne_zero {i : \u03b9} {b : \u03b2 i} (hb : b \u2260 0) : (single i b).support = {i}", "start": [1195, 1], "end": [1199, 22], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_single_subset", "code": "theorem support_single_subset {i : \u03b9} {b : \u03b2 i} : (single i b).support \u2286 {i}", "start": [1202, 1], "end": [1203, 21], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_def", "code": "theorem mapRange_def [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i}\n    {hf : \u2200 i, f i 0 = 0} {g : \u03a0\u2080 i, \u03b2\u2081 i} :\n    mapRange f hf g = mk g.support fun i => f i.1 (g i.1)", "start": [1210, 1], "end": [1214, 54], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_single", "code": "@[simp]\ntheorem mapRange_single {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i} {hf : \u2200 i, f i 0 = 0} {i : \u03b9} {b : \u03b2\u2081 i} :\n    mapRange f hf (single i b) = single i (f i b)", "start": [1217, 1], "end": [1224, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_mapRange", "code": "theorem support_mapRange {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i} {hf : \u2200 i, f i 0 = 0} {g : \u03a0\u2080 i, \u03b2\u2081 i} :\n    (mapRange f hf g).support \u2286 g.support", "start": [1229, 1], "end": [1230, 68], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.zipWith_def", "code": "theorem zipWith_def {\u03b9 : Type u} {\u03b2 : \u03b9 \u2192 Type v} {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082}\n    [dec : DecidableEq \u03b9] [\u2200 i : \u03b9, Zero (\u03b2 i)] [\u2200 i : \u03b9, Zero (\u03b2\u2081 i)] [\u2200 i : \u03b9, Zero (\u03b2\u2082 i)]\n    [\u2200 (i : \u03b9) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i : \u03b9) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]\n    {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i} {hf : \u2200 i, f i 0 0 = 0} {g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i} {g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i} :\n    zipWith f hf g\u2081 g\u2082 = mk (g\u2081.support \u222a g\u2082.support) fun i => f i.1 (g\u2081 i.1) (g\u2082 i.1)", "start": [1233, 1], "end": [1240, 22], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_zipWith", "code": "theorem support_zipWith {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i} {hf : \u2200 i, f i 0 0 = 0} {g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i}\n    {g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i} : (zipWith f hf g\u2081 g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support", "start": [1243, 1], "end": [1245, 21], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.erase_def", "code": "theorem erase_def (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : f.erase i = mk (f.support.erase i) fun j => f j.1", "start": [1250, 1], "end": [1252, 81], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_erase", "code": "@[simp]\ntheorem support_erase (i : \u03b9) (f : \u03a0\u2080 i, \u03b2 i) : (f.erase i).support = f.support.erase i", "start": [1255, 1], "end": [1261, 57], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_update_ne_zero", "code": "theorem support_update_ne_zero (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) {b : \u03b2 i} (h : b \u2260 0) :\n    support (f.update i b) = insert i f.support", "start": [1264, 1], "end": [1269, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_update", "code": "theorem support_update (f : \u03a0\u2080 i, \u03b2 i) (i : \u03b9) (b : \u03b2 i) [Decidable (b = 0)] :\n    support (f.update i b) = if b = 0 then support (f.erase i) else insert i f.support", "start": [1272, 1], "end": [1278, 39], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.filter_def", "code": "theorem filter_def (f : \u03a0\u2080 i, \u03b2 i) : f.filter p = mk (f.support.filter p) fun i => f i.1", "start": [1285, 1], "end": [1286, 86], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_filter", "code": "@[simp]\ntheorem support_filter (f : \u03a0\u2080 i, \u03b2 i) : (f.filter p).support = f.support.filter p", "start": [1289, 1], "end": [1291, 39], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_def", "code": "theorem subtypeDomain_def (f : \u03a0\u2080 i, \u03b2 i) :\n    f.subtypeDomain p = mk (f.support.subtype p) fun i => f i", "start": [1294, 1], "end": [1296, 68], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_subtypeDomain", "code": "@[simp, nolint simpNF] theorem support_subtypeDomain {f : \u03a0\u2080 i, \u03b2 i} :\n    (subtypeDomain p f).support = f.support.subtype p", "start": [1299, 1], "end": [1303, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_add", "code": "theorem support_add [\u2200 i, AddZeroClass (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    {g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2 i} : (g\u2081 + g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support", "start": [1310, 1], "end": [1312, 18], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_neg", "code": "@[simp]\ntheorem support_neg [\u2200 i, AddGroup (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] {f : \u03a0\u2080 i, \u03b2 i} :\n    support (-f) = support f", "start": [1315, 1], "end": [1317, 47], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_smul", "code": "theorem support_smul {\u03b3 : Type w} [Semiring \u03b3] [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 i, Module \u03b3 (\u03b2 i)]\n    [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)] (b : \u03b3) (v : \u03a0\u2080 i, \u03b2 i) :\n    (b \u2022 v).support \u2286 v.support", "start": [1320, 1], "end": [1323, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain", "code": "noncomputable def comapDomain [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h)\n    (f : \u03a0\u2080 i, \u03b2 i) : \u03a0\u2080 k, \u03b2 (h k) where\n  toFun x := f (h x)\n  support' :=\n    f.support'.map fun s =>\n      \u27e8((Multiset.toFinset s.1).preimage h (hh.injOn _)).val, fun x =>\n        (s.prop (h x)).imp_left fun hx => mem_preimage.mpr <| Multiset.mem_toFinset.mpr hx\u27e9", "start": [1340, 1], "end": [1347, 92], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain_apply", "code": "@[simp]\ntheorem comapDomain_apply [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h) (f : \u03a0\u2080 i, \u03b2 i)\n    (k : \u03ba) : comapDomain h hh f k = f (h k)", "start": [1350, 1], "end": [1353, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain_zero", "code": "@[simp]\ntheorem comapDomain_zero [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h) :\n    comapDomain h hh (0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [1356, 1], "end": [1360, 49], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain_add", "code": "@[simp]\ntheorem comapDomain_add [\u2200 i, AddZeroClass (\u03b2 i)] (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h)\n    (f g : \u03a0\u2080 i, \u03b2 i) : comapDomain h hh (f + g) = comapDomain h hh f + comapDomain h hh g", "start": [1363, 1], "end": [1367, 85], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain_smul", "code": "@[simp]\ntheorem comapDomain_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)]\n    (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h) (r : \u03b3) (f : \u03a0\u2080 i, \u03b2 i) :\n    comapDomain h hh (r \u2022 f) = r \u2022 comapDomain h hh f", "start": [1370, 1], "end": [1375, 68], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain_single", "code": "@[simp]\ntheorem comapDomain_single [DecidableEq \u03ba] [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) (hh : Function.Injective h)\n    (k : \u03ba) (x : \u03b2 (h k)) : comapDomain h hh (single (h k) x) = single k x", "start": [1378, 1], "end": [1385, 68], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'", "code": "def comapDomain' [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) {h' : \u03b9 \u2192 \u03ba} (hh' : Function.LeftInverse h' h)\n    (f : \u03a0\u2080 i, \u03b2 i) : \u03a0\u2080 k, \u03b2 (h k) where\n  toFun x := f (h x)\n  support' :=\n    f.support'.map fun s =>\n      \u27e8Multiset.map h' s.1, fun x =>\n        (s.prop (h x)).imp_left fun hx => Multiset.mem_map.mpr \u27e8_, hx, hh' _\u27e9\u27e9", "start": [1388, 1], "end": [1395, 79], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'_apply", "code": "@[simp]\ntheorem comapDomain'_apply [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) {h' : \u03b9 \u2192 \u03ba}\n    (hh' : Function.LeftInverse h' h) (f : \u03a0\u2080 i, \u03b2 i) (k : \u03ba) : comapDomain' h hh' f k = f (h k)", "start": [1398, 1], "end": [1401, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'_zero", "code": "@[simp]\ntheorem comapDomain'_zero [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9) {h' : \u03b9 \u2192 \u03ba}\n    (hh' : Function.LeftInverse h' h) : comapDomain' h hh' (0 : \u03a0\u2080 i, \u03b2 i) = 0", "start": [1404, 1], "end": [1408, 50], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'_add", "code": "@[simp]\ntheorem comapDomain'_add [\u2200 i, AddZeroClass (\u03b2 i)] (h : \u03ba \u2192 \u03b9) {h' : \u03b9 \u2192 \u03ba}\n    (hh' : Function.LeftInverse h' h) (f g : \u03a0\u2080 i, \u03b2 i) :\n    comapDomain' h hh' (f + g) = comapDomain' h hh' f + comapDomain' h hh' g", "start": [1411, 1], "end": [1416, 88], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'_smul", "code": "@[simp]\ntheorem comapDomain'_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b2 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b2 i)]\n    (h : \u03ba \u2192 \u03b9) {h' : \u03b9 \u2192 \u03ba} (hh' : Function.LeftInverse h' h) (r : \u03b3) (f : \u03a0\u2080 i, \u03b2 i) :\n    comapDomain' h hh' (r \u2022 f) = r \u2022 comapDomain' h hh' f", "start": [1419, 1], "end": [1424, 70], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comapDomain'_single", "code": "@[simp]\ntheorem comapDomain'_single [DecidableEq \u03b9] [DecidableEq \u03ba] [\u2200 i, Zero (\u03b2 i)] (h : \u03ba \u2192 \u03b9)\n    {h' : \u03b9 \u2192 \u03ba} (hh' : Function.LeftInverse h' h) (k : \u03ba) (x : \u03b2 (h k)) :\n    comapDomain' h hh' (single (h k) x) = single k x", "start": [1427, 1], "end": [1435, 79], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivCongrLeft", "code": "@[simps apply]\ndef equivCongrLeft [\u2200 i, Zero (\u03b2 i)] (h : \u03b9 \u2243 \u03ba) : (\u03a0\u2080 i, \u03b2 i) \u2243 \u03a0\u2080 k, \u03b2 (h.symm k)\n    where\n  toFun := comapDomain' h.symm h.right_inv\n  invFun f :=\n    mapRange (fun i => Equiv.cast <| congr_arg \u03b2 <| h.symm_apply_apply i)\n      (fun i => (Equiv.cast_eq_iff_heq _).mpr <| by rw [Equiv.symm_apply_apply])\n      (@comapDomain' _ _ _ _ h _ h.left_inv f)\n  left_inv f := by\n    ext i\n    rw [mapRange_apply, comapDomain'_apply, comapDomain'_apply, Equiv.cast_eq_iff_heq,\n      h.symm_apply_apply]\n  right_inv f := by\n    ext k\n    rw [comapDomain'_apply, mapRange_apply, comapDomain'_apply, Equiv.cast_eq_iff_heq,\n      h.apply_symm_apply]", "start": [1438, 1], "end": [1456, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.hasAdd\u2082", "code": "instance hasAdd\u2082 [\u2200 i j, AddZeroClass (\u03b4 i j)] : Add (\u03a0\u2080 (i : \u03b9) (j : \u03b1 i), \u03b4 i j) :=\n  inferInstance", "start": [1465, 1], "end": [1466, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addZeroClass\u2082", "code": "instance addZeroClass\u2082 [\u2200 i j, AddZeroClass (\u03b4 i j)] : AddZeroClass (\u03a0\u2080 (i : \u03b9) (j : \u03b1 i), \u03b4 i j) :=\n  inferInstance", "start": [1470, 1], "end": [1471, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addMonoid\u2082", "code": "instance addMonoid\u2082 [\u2200 i j, AddMonoid (\u03b4 i j)] : AddMonoid (\u03a0\u2080 (i : \u03b9) (j : \u03b1 i), \u03b4 i j) :=\n  inferInstance", "start": [1475, 1], "end": [1476, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.distribMulAction\u2082", "code": "instance distribMulAction\u2082 [Monoid \u03b3] [\u2200 i j, AddMonoid (\u03b4 i j)]\n    [\u2200 i j, DistribMulAction \u03b3 (\u03b4 i j)] : DistribMulAction \u03b3 (\u03a0\u2080 (i : \u03b9) (j : \u03b1 i), \u03b4 i j) :=\n  @DFinsupp.distribMulAction \u03b9 _ (fun i => \u03a0\u2080 j, \u03b4 i j) _ _ _", "start": [1480, 1], "end": [1482, 62], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry", "code": "def sigmaCurry [\u2200 i j, Zero (\u03b4 i j)] (f : \u03a0\u2080 (i : \u03a3 _, _), \u03b4 i.1 i.2) :\n    \u03a0\u2080 (i) (j), \u03b4 i j where\n  toFun := fun i \u21a6\n  { toFun := fun j \u21a6 f \u27e8i, j\u27e9,\n    support' := f.support'.map (fun \u27e8m, hm\u27e9 \u21a6\n      \u27e8m.filterMap (fun \u27e8i', j'\u27e9 \u21a6 if h : i' = i then some $ h.rec j' else none),\n        fun j \u21a6 (hm \u27e8i, j\u27e9).imp_left (fun h \u21a6 (m.mem_filterMap _).mpr \u27e8\u27e8i, j\u27e9, h, dif_pos rfl\u27e9)\u27e9) }\n  support' := f.support'.map (fun \u27e8m, hm\u27e9 \u21a6\n    \u27e8m.map Sigma.fst, fun i \u21a6 Decidable.or_iff_not_imp_left.mpr (fun h \u21a6 DFinsupp.ext\n      (fun j \u21a6 (hm \u27e8i, j\u27e9).resolve_left (fun H \u21a6 (Multiset.mem_map.not.mp h) \u27e8\u27e8i, j\u27e9, H, rfl\u27e9)))\u27e9)", "start": [1485, 1], "end": [1495, 99], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry_apply", "code": "@[simp]\ntheorem sigmaCurry_apply [\u2200 i j, Zero (\u03b4 i j)] (f : \u03a0\u2080 (i : \u03a3 _, _), \u03b4 i.1 i.2) (i : \u03b9) (j : \u03b1 i) :\n    sigmaCurry f i j = f \u27e8i, j\u27e9", "start": [1497, 1], "end": [1500, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry_zero", "code": "@[simp]\ntheorem sigmaCurry_zero [\u2200 i j, Zero (\u03b4 i j)] :\n    sigmaCurry (0 : \u03a0\u2080 (i : \u03a3 _, _), \u03b4 i.1 i.2) = 0", "start": [1503, 1], "end": [1506, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry_add", "code": "@[simp]\ntheorem sigmaCurry_add [\u2200 i j, AddZeroClass (\u03b4 i j)] (f g : \u03a0\u2080 (i : \u03a3 _, _), \u03b4 i.1 i.2) :\n    sigmaCurry (f + g) = sigmaCurry f + sigmaCurry g", "start": [1509, 1], "end": [1513, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry_smul", "code": "@[simp]\ntheorem sigmaCurry_smul [Monoid \u03b3] [\u2200 i j, AddMonoid (\u03b4 i j)] [\u2200 i j, DistribMulAction \u03b3 (\u03b4 i j)]\n    (r : \u03b3) (f : \u03a0\u2080 (i : \u03a3 _, _), \u03b4 i.1 i.2) :\n    sigmaCurry (r \u2022 f) = r \u2022 sigmaCurry f", "start": [1516, 1], "end": [1521, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurry_single", "code": "@[simp]\ntheorem sigmaCurry_single [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, Zero (\u03b4 i j)]\n    (ij : \u03a3 i, \u03b1 i) (x : \u03b4 ij.1 ij.2) :\n    sigmaCurry (single ij x) = single ij.1 (single ij.2 x : \u03a0\u2080 j, \u03b4 ij.1 j)", "start": [1524, 1], "end": [1539, 14], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry", "code": "def sigmaUncurry [\u2200 i j, Zero (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)]\n    (f : \u03a0\u2080 (i) (j), \u03b4 i j) :\n    \u03a0\u2080 i : \u03a3i, _, \u03b4 i.1 i.2 where\n  toFun i := f i.1 i.2\n  support' := f.support'.map fun s => \u27e8Multiset.bind s.1 fun i =>\n    ((f i).support.map \u27e8Sigma.mk i, sigma_mk_injective\u27e9).val, fun i => by\n      simp_rw [Multiset.mem_bind, map_val, Multiset.mem_map, Function.Embedding.coeFn_mk, \u2190\n        Finset.mem_def, mem_support_toFun]\n      obtain hi | (hi : f i.1 = 0) := s.prop i.1\n      \u00b7 by_cases hi' : f i.1 i.2 = 0\n        \u00b7 exact Or.inr hi'\n        \u00b7 exact Or.inl \u27e8_, hi, i.2, hi', Sigma.eta _\u27e9\n      \u00b7 right\n        rw [hi, zero_apply]\u27e9", "start": [1543, 1], "end": [1559, 29], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry_apply", "code": "@[simp]\ntheorem sigmaUncurry_apply [\u2200 i j, Zero (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)]\n    (f : \u03a0\u2080 (i) (j), \u03b4 i j) (i : \u03b9) (j : \u03b1 i) :\n    sigmaUncurry f \u27e8i, j\u27e9 = f i j", "start": [1563, 1], "end": [1568, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry_zero", "code": "@[simp]\ntheorem sigmaUncurry_zero [\u2200 i j, Zero (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)] :\n    sigmaUncurry (0 : \u03a0\u2080 (i) (j), \u03b4 i j) = 0", "start": [1572, 1], "end": [1576, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry_add", "code": "@[simp]\ntheorem sigmaUncurry_add [\u2200 i j, AddZeroClass (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)]\n    (f g : \u03a0\u2080 (i) (j), \u03b4 i j) :\n    sigmaUncurry (f + g) = sigmaUncurry f + sigmaUncurry g", "start": [1580, 1], "end": [1585, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry_smul", "code": "@[simp]\ntheorem sigmaUncurry_smul [Monoid \u03b3] [\u2200 i j, AddMonoid (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)]\n    [\u2200 i j, DistribMulAction \u03b3 (\u03b4 i j)]\n    (r : \u03b3) (f : \u03a0\u2080 (i) (j), \u03b4 i j) : sigmaUncurry (r \u2022 f) = r \u2022 sigmaUncurry f", "start": [1589, 1], "end": [1594, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaUncurry_single", "code": "@[simp]\ntheorem sigmaUncurry_single [\u2200 i j, Zero (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)]\n    (i) (j : \u03b1 i) (x : \u03b4 i j) :\n    sigmaUncurry (single i (single j x : \u03a0\u2080 j : \u03b1 i, \u03b4 i j)) = single \u27e8i, j\u27e9 (by exact x)", "start": [1597, 1], "end": [1612, 14], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sigmaCurryEquiv", "code": "def sigmaCurryEquiv [\u2200 i j, Zero (\u03b4 i j)]\n    [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j (x : \u03b4 i j), Decidable (x \u2260 0)] :\n    (\u03a0\u2080 i : \u03a3i, _, \u03b4 i.1 i.2) \u2243 \u03a0\u2080 (i) (j), \u03b4 i j\n    where\n  toFun := sigmaCurry\n  invFun := sigmaUncurry\n  left_inv f := by\n    ext \u27e8i, j\u27e9\n    rw [sigmaUncurry_apply, sigmaCurry_apply]\n  right_inv f := by\n    ext i j\n    rw [sigmaCurry_apply, sigmaUncurry_apply]", "start": [1616, 1], "end": [1630, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.extendWith", "code": "def extendWith [\u2200 i, Zero (\u03b1 i)] (a : \u03b1 none) (f : \u03a0\u2080 i, \u03b1 (some i)) : \u03a0\u2080 i, \u03b1 i where\n  toFun := fun i \u21a6 match i with | none => a | some _ => f _\n  support' :=\n    f.support'.map fun s =>\n      \u27e8none ::\u2098 Multiset.map some s.1, fun i =>\n        Option.rec (Or.inl <| Multiset.mem_cons_self _ _)\n          (fun i =>\n            (s.prop i).imp_left fun h => Multiset.mem_cons_of_mem <| Multiset.mem_map_of_mem _ h)\n          i\u27e9", "start": [1637, 1], "end": [1648, 13], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.extendWith_none", "code": "@[simp]\ntheorem extendWith_none [\u2200 i, Zero (\u03b1 i)] (f : \u03a0\u2080 i, \u03b1 (some i)) (a : \u03b1 none) :\n    f.extendWith a none = a", "start": [1651, 1], "end": [1654, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.extendWith_some", "code": "@[simp]\ntheorem extendWith_some [\u2200 i, Zero (\u03b1 i)] (f : \u03a0\u2080 i, \u03b1 (some i)) (a : \u03b1 none) (i : \u03b9) :\n    f.extendWith a (some i) = f i", "start": [1657, 1], "end": [1660, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.extendWith_single_zero", "code": "@[simp]\ntheorem extendWith_single_zero [DecidableEq \u03b9] [\u2200 i, Zero (\u03b1 i)] (i : \u03b9) (x : \u03b1 (some i)) :\n    (single i x).extendWith 0 = single (some i) x", "start": [1663, 1], "end": [1671, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.extendWith_zero", "code": "@[simp]\ntheorem extendWith_zero [DecidableEq \u03b9] [\u2200 i, Zero (\u03b1 i)] (x : \u03b1 none) :\n    (0 : \u03a0\u2080 i, \u03b1 (some i)).extendWith x = single none x", "start": [1674, 1], "end": [1679, 83], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivProdDFinsupp", "code": "@[simps]\nnoncomputable def equivProdDFinsupp [\u2200 i, Zero (\u03b1 i)] : (\u03a0\u2080 i, \u03b1 i) \u2243 \u03b1 none \u00d7 \u03a0\u2080 i, \u03b1 (some i)\n    where\n  toFun f := (f none, comapDomain some (Option.some_injective _) f)\n  invFun f := f.2.extendWith f.1\n  left_inv f := by\n    ext i; cases' i with i\n    \u00b7 rw [extendWith_none]\n    \u00b7 rw [extendWith_some, comapDomain_apply]\n  right_inv x := by\n    dsimp only\n    ext\n    \u00b7 exact extendWith_none x.snd _\n    \u00b7 rw [comapDomain_apply, extendWith_some]", "start": [1682, 1], "end": [1698, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivProdDFinsupp_add", "code": "theorem equivProdDFinsupp_add [\u2200 i, AddZeroClass (\u03b1 i)] (f g : \u03a0\u2080 i, \u03b1 i) :\n    equivProdDFinsupp (f + g) = equivProdDFinsupp f + equivProdDFinsupp g", "start": [1703, 1], "end": [1705, 79], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.equivProdDFinsupp_smul", "code": "theorem equivProdDFinsupp_smul [Monoid \u03b3] [\u2200 i, AddMonoid (\u03b1 i)] [\u2200 i, DistribMulAction \u03b3 (\u03b1 i)]\n    (r : \u03b3) (f : \u03a0\u2080 i, \u03b1 i) : equivProdDFinsupp (r \u2022 f) = r \u2022 equivProdDFinsupp f", "start": [1708, 1], "end": [1710, 81], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod", "code": "@[to_additive \"`sum f g` is the sum of `g i (f i)` over the support of `f`.\"]\ndef prod [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3] (f : \u03a0\u2080 i, \u03b2 i)\n    (g : \u2200 i, \u03b2 i \u2192 \u03b3) : \u03b3 :=\n  \u220f i in f.support, g i (f i)", "start": [1717, 1], "end": [1721, 30], "kind": "commanddeclaration"}, {"full_name": "map_dfinsupp_prod", "code": "@[to_additive (attr := simp)]\ntheorem _root_.map_dfinsupp_prod\n    {R S H : Type*} [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid R] [CommMonoid S] [MonoidHomClass H R S] (h : H) (f : \u03a0\u2080 i, \u03b2 i)\n    (g : \u2200 i, \u03b2 i \u2192 R) : h (f.prod g) = f.prod fun a b => h (g a b)", "start": [1725, 1], "end": [1730, 17], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_mapRange_index", "code": "@[to_additive]\ntheorem prod_mapRange_index {\u03b2\u2081 : \u03b9 \u2192 Type v\u2081} {\u03b2\u2082 : \u03b9 \u2192 Type v\u2082} [\u2200 i, Zero (\u03b2\u2081 i)]\n    [\u2200 i, Zero (\u03b2\u2082 i)] [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i} {hf : \u2200 i, f i 0 = 0} {g : \u03a0\u2080 i, \u03b2\u2081 i} {h : \u2200 i, \u03b2\u2082 i \u2192 \u03b3}\n    (h0 : \u2200 i, h i 0 = 1) : (mapRange f hf g).prod h = g.prod fun i b => h i (f i b)", "start": [1732, 1], "end": [1747, 14], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_zero_index", "code": "@[to_additive]\ntheorem prod_zero_index [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {h : \u2200 i, \u03b2 i \u2192 \u03b3} : (0 : \u03a0\u2080 i, \u03b2 i).prod h = 1", "start": [1751, 1], "end": [1754, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_single_index", "code": "@[to_additive]\ntheorem prod_single_index [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3]\n    {i : \u03b9} {b : \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h_zero : h i 0 = 1) : (single i b).prod h = h i b", "start": [1758, 1], "end": [1765, 8], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_neg_index", "code": "@[to_additive]\ntheorem prod_neg_index [\u2200 i, AddGroup (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3]\n    {g : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h0 : \u2200 i, h i 0 = 1) :\n    (-g).prod h = g.prod fun i b => h i (-b)", "start": [1769, 1], "end": [1773, 25], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_comm", "code": "@[to_additive]\ntheorem prod_comm {\u03b9\u2081 \u03b9\u2082 : Sort _} {\u03b2\u2081 : \u03b9\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b9\u2082 \u2192 Type*} [DecidableEq \u03b9\u2081]\n    [DecidableEq \u03b9\u2082] [\u2200 i, Zero (\u03b2\u2081 i)] [\u2200 i, Zero (\u03b2\u2082 i)] [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)]\n    [\u2200 (i) (x : \u03b2\u2082 i), Decidable (x \u2260 0)] [CommMonoid \u03b3] (f\u2081 : \u03a0\u2080 i, \u03b2\u2081 i) (f\u2082 : \u03a0\u2080 i, \u03b2\u2082 i)\n    (h : \u2200 i, \u03b2\u2081 i \u2192 \u2200 i, \u03b2\u2082 i \u2192 \u03b3) :\n    (f\u2081.prod fun i\u2081 x\u2081 => f\u2082.prod fun i\u2082 x\u2082 => h i\u2081 x\u2081 i\u2082 x\u2082) =\n      f\u2082.prod fun i\u2082 x\u2082 => f\u2081.prod fun i\u2081 x\u2081 => h i\u2081 x\u2081 i\u2082 x\u2082", "start": [1777, 1], "end": [1784, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sum_apply", "code": "@[simp]\ntheorem sum_apply {\u03b9\u2081 : Type u\u2081} [DecidableEq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u2200 i\u2081, Zero (\u03b2\u2081 i\u2081)]\n    [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 i, AddCommMonoid (\u03b2 i)] {f : \u03a0\u2080 i\u2081, \u03b2\u2081 i\u2081}\n    {g : \u2200 i\u2081, \u03b2\u2081 i\u2081 \u2192 \u03a0\u2080 i, \u03b2 i} {i\u2082 : \u03b9} : (f.sum g) i\u2082 = f.sum fun i\u2081 b => g i\u2081 b i\u2082", "start": [1788, 1], "end": [1792, 66], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.support_sum", "code": "theorem support_sum {\u03b9\u2081 : Type u\u2081} [DecidableEq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u2200 i\u2081, Zero (\u03b2\u2081 i\u2081)]\n    [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 i, AddCommMonoid (\u03b2 i)]\n    [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] {f : \u03a0\u2080 i\u2081, \u03b2\u2081 i\u2081} {g : \u2200 i\u2081, \u03b2\u2081 i\u2081 \u2192 \u03a0\u2080 i, \u03b2 i} :\n    (f.sum g).support \u2286 f.support.biUnion fun i => (g i (f i)).support", "start": [1795, 1], "end": [1805, 87], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_one", "code": "@[to_additive (attr := simp)]\ntheorem prod_one [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3]\n    {f : \u03a0\u2080 i, \u03b2 i} : (f.prod fun _ _ => (1 : \u03b3)) = 1", "start": [1808, 1], "end": [1811, 24], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_mul", "code": "@[to_additive (attr := simp)]\ntheorem prod_mul [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3]\n    {f : \u03a0\u2080 i, \u03b2 i} {h\u2081 h\u2082 : \u2200 i, \u03b2 i \u2192 \u03b3} :\n    (f.prod fun i b => h\u2081 i b * h\u2082 i b) = f.prod h\u2081 * f.prod h\u2082", "start": [1815, 1], "end": [1819, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_inv", "code": "@[to_additive (attr := simp)]\ntheorem prod_inv [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommGroup \u03b3]\n    {f : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} : (f.prod fun i b => (h i b)\u207b\u00b9) = (f.prod h)\u207b\u00b9", "start": [1823, 1], "end": [1826, 54], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_eq_one", "code": "@[to_additive]\ntheorem prod_eq_one [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3]\n    {f : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (hyp : \u2200 i, h i (f i) = 1) : f.prod h = 1", "start": [1830, 1], "end": [1833, 38], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.smul_sum", "code": "theorem smul_sum {\u03b1 : Type*} [Monoid \u03b1] [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [AddCommMonoid \u03b3] [DistribMulAction \u03b1 \u03b3] {f : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} {c : \u03b1} :\n    c \u2022 f.sum h = f.sum fun a b => c \u2022 h a b", "start": [1837, 1], "end": [1840, 18], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_add_index", "code": "@[to_additive]\ntheorem prod_add_index [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {f g : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h_zero : \u2200 i, h i 0 = 1)\n    (h_add : \u2200 i b\u2081 b\u2082, h i (b\u2081 + b\u2082) = h i b\u2081 * h i b\u2082) : (f + g).prod h = f.prod h * g.prod h", "start": [1843, 1], "end": [1859, 32], "kind": "commanddeclaration"}, {"full_name": "dfinsupp_prod_mem", "code": "@[to_additive]\ntheorem _root_.dfinsupp_prod_mem [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {S : Type*} [SetLike S \u03b3] [SubmonoidClass S \u03b3]\n    (s : S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192 \u03b3)\n    (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 s) : f.prod g \u2208 s", "start": [1863, 1], "end": [1868, 51], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_eq_prod_fintype", "code": "@[to_additive (attr := simp)]\ntheorem prod_eq_prod_fintype [Fintype \u03b9] [\u2200 i, Zero (\u03b2 i)] [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] (v : \u03a0\u2080 i, \u03b2 i) {f : \u2200 i, \u03b2 i \u2192 \u03b3} (hf : \u2200 i, f i 0 = 1) :\n    v.prod f = \u220f i, f i (DFinsupp.equivFunOnFintype v i)", "start": [1872, 1], "end": [1881, 14], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom", "code": "def sumAddHom [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (\u03c6 : \u2200 i, \u03b2 i \u2192+ \u03b3) :\n    (\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b3 where\n  toFun f :=\n    (f.support'.lift fun s => \u2211 i in Multiset.toFinset s.1, \u03c6 i (f i)) <| by\n      rintro \u27e8sx, hx\u27e9 \u27e8sy, hy\u27e9\n      dsimp only [Subtype.coe_mk, toFun_eq_coe] at *\n      have H1 : sx.toFinset \u2229 sy.toFinset \u2286 sx.toFinset := Finset.inter_subset_left _ _\n      have H2 : sx.toFinset \u2229 sy.toFinset \u2286 sy.toFinset := Finset.inter_subset_right _ _\n      refine'\n        (Finset.sum_subset H1 _).symm.trans\n          ((Finset.sum_congr rfl _).trans (Finset.sum_subset H2 _))\n      \u00b7 intro i H1 H2\n        rw [Finset.mem_inter] at H2\n        simp only [Multiset.mem_toFinset] at H1 H2\n        convert AddMonoidHom.map_zero (\u03c6 i)\n        exact (hy i).resolve_left (mt (And.intro H1) H2)\n      \u00b7 intro i _\n        rfl\n      \u00b7 intro i H1 H2\n        rw [Finset.mem_inter] at H2\n        simp only [Multiset.mem_toFinset] at H1 H2\n        convert AddMonoidHom.map_zero (\u03c6 i)\n        exact (hx i).resolve_left (mt (fun H3 => And.intro H3 H1) H2)\n  map_add' := by\n    rintro \u27e8f, sf, hf\u27e9 \u27e8g, sg, hg\u27e9\n    change (\u2211 i in _, _) = (\u2211 i in _, _) + \u2211 i in _, _\n    simp only [coe_add, coe_mk', Subtype.coe_mk, Pi.add_apply, map_add, Finset.sum_add_distrib]\n    congr 1\n    \u00b7 refine' (Finset.sum_subset _ _).symm\n      \u00b7 intro i\n        simp only [Multiset.mem_toFinset, Multiset.mem_add]\n        exact Or.inl\n      \u00b7 intro i _ H2\n        simp only [Multiset.mem_toFinset, Multiset.mem_add] at H2\n        rw [(hf i).resolve_left H2, AddMonoidHom.map_zero]\n    \u00b7 refine' (Finset.sum_subset _ _).symm\n      \u00b7 intro i\n        simp only [Multiset.mem_toFinset, Multiset.mem_add]\n        exact Or.inr\n      \u00b7 intro i _ H2\n        simp only [Multiset.mem_toFinset, Multiset.mem_add] at H2\n        rw [(hg i).resolve_left H2, AddMonoidHom.map_zero]\n  map_zero' := by\n    simp only [toFun_eq_coe, coe_zero, Pi.zero_apply, map_zero, Finset.sum_const_zero]; rfl", "start": [1885, 1], "end": [1932, 92], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_single", "code": "@[simp]\ntheorem sumAddHom_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (\u03c6 : \u2200 i, \u03b2 i \u2192+ \u03b3) (i)\n    (x : \u03b2 i) : sumAddHom \u03c6 (single i x) = \u03c6 i x", "start": [1935, 1], "end": [1939, 76], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_comp_single", "code": "@[simp]\ntheorem sumAddHom_comp_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) : (sumAddHom f).comp (singleAddHom \u03b2 i) = f i", "start": [1942, 1], "end": [1945, 51], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_apply", "code": "theorem sumAddHom_apply [\u2200 i, AddZeroClass (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [AddCommMonoid \u03b3] (\u03c6 : \u2200 i, \u03b2 i \u2192+ \u03b3) (f : \u03a0\u2080 i, \u03b2 i) : sumAddHom \u03c6 f = f.sum fun x => \u03c6 x", "start": [1948, 1], "end": [1958, 43], "kind": "commanddeclaration"}, {"full_name": "dfinsupp_sumAddHom_mem", "code": "theorem _root_.dfinsupp_sumAddHom_mem [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] {S : Type*}\n    [SetLike S \u03b3] [AddSubmonoidClass S \u03b3] (s : S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 s) : DFinsupp.sumAddHom g f \u2208 s", "start": [1961, 1], "end": [1966, 39], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom", "code": "theorem _root_.AddSubmonoid.iSup_eq_mrange_dfinsupp_sumAddHom\n    [AddCommMonoid \u03b3] (S : \u03b9 \u2192 AddSubmonoid \u03b3) :\n    iSup S = AddMonoidHom.mrange (DFinsupp.sumAddHom fun i => (S i).subtype)", "start": [1969, 1], "end": [1980, 85], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom", "code": "theorem _root_.AddSubmonoid.bsupr_eq_mrange_dfinsupp_sumAddHom (p : \u03b9 \u2192 Prop) [DecidablePred p]\n    [AddCommMonoid \u03b3] (S : \u03b9 \u2192 AddSubmonoid \u03b3) :\n    \u2a06 (i) (_ : p i), S i =\n      AddMonoidHom.mrange ((sumAddHom fun i => (S i).subtype).comp (filterAddMonoidHom _ p))", "start": [1983, 1], "end": [2000, 16], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_iSup_iff_exists_dfinsupp", "code": "theorem _root_.AddSubmonoid.mem_iSup_iff_exists_dfinsupp [AddCommMonoid \u03b3] (S : \u03b9 \u2192 AddSubmonoid \u03b3)\n    (x : \u03b3) : x \u2208 iSup S \u2194 \u2203 f : \u03a0\u2080 i, S i, DFinsupp.sumAddHom (fun i => (S i).subtype) f = x", "start": [2003, 1], "end": [2005, 74], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_iSup_iff_exists_dfinsupp'", "code": "theorem _root_.AddSubmonoid.mem_iSup_iff_exists_dfinsupp' [AddCommMonoid \u03b3] (S : \u03b9 \u2192 AddSubmonoid \u03b3)\n    [\u2200 (i) (x : S i), Decidable (x \u2260 0)] (x : \u03b3) :\n    x \u2208 iSup S \u2194 \u2203 f : \u03a0\u2080 i, S i, (f.sum fun i xi => \u2191xi) = x", "start": [2008, 1], "end": [2014, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_bsupr_iff_exists_dfinsupp", "code": "theorem _root_.AddSubmonoid.mem_bsupr_iff_exists_dfinsupp (p : \u03b9 \u2192 Prop) [DecidablePred p]\n    [AddCommMonoid \u03b3] (S : \u03b9 \u2192 AddSubmonoid \u03b3) (x : \u03b3) :\n    (x \u2208 \u2a06 (i) (_ : p i), S i) \u2194\n      \u2203 f : \u03a0\u2080 i, S i, DFinsupp.sumAddHom (fun i => (S i).subtype) (f.filter p) = x", "start": [2017, 1], "end": [2021, 77], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_comm", "code": "theorem sumAddHom_comm {\u03b9\u2081 \u03b9\u2082 : Sort _} {\u03b2\u2081 : \u03b9\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b9\u2082 \u2192 Type*} {\u03b3 : Type*}\n    [DecidableEq \u03b9\u2081] [DecidableEq \u03b9\u2082] [\u2200 i, AddZeroClass (\u03b2\u2081 i)] [\u2200 i, AddZeroClass (\u03b2\u2082 i)]\n    [AddCommMonoid \u03b3] (f\u2081 : \u03a0\u2080 i, \u03b2\u2081 i) (f\u2082 : \u03a0\u2080 i, \u03b2\u2082 i) (h : \u2200 i j, \u03b2\u2081 i \u2192+ \u03b2\u2082 j \u2192+ \u03b3) :\n    sumAddHom (fun i\u2082 => sumAddHom (fun i\u2081 => h i\u2081 i\u2082) f\u2081) f\u2082 =\n      sumAddHom (fun i\u2081 => sumAddHom (fun i\u2082 => (h i\u2081 i\u2082).flip) f\u2082) f\u2081", "start": [2024, 1], "end": [2032, 24], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.liftAddHom", "code": "@[simps apply symm_apply]\ndef liftAddHom [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] : (\u2200 i, \u03b2 i \u2192+ \u03b3) \u2243+ ((\u03a0\u2080 i, \u03b2 i) \u2192+ \u03b3)\n    where\n  toFun := sumAddHom\n  invFun F i := F.comp (singleAddHom \u03b2 i)\n  left_inv x := by ext; simp\n  right_inv \u03c8 := by ext; simp\n  map_add' F G := by ext; simp", "start": [2035, 1], "end": [2043, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.liftAddHom_singleAddHom", "code": "@[simp, nolint simpNF] theorem liftAddHom_singleAddHom [\u2200 i, AddCommMonoid (\u03b2 i)] :\n    liftAddHom (\u03b2 := \u03b2) (singleAddHom \u03b2) = AddMonoidHom.id (\u03a0\u2080 i, \u03b2 i)", "start": [2051, 1], "end": [2055, 65], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.liftAddHom_apply_single", "code": "theorem liftAddHom_apply_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) (x : \u03b2 i) : liftAddHom (\u03b2 := \u03b2) f (single i x) = f i x", "start": [2058, 1], "end": [2060, 78], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.liftAddHom_comp_single", "code": "theorem liftAddHom_comp_single [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (f : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (i : \u03b9) : (liftAddHom (\u03b2 := \u03b2) f).comp (singleAddHom \u03b2 i) = f i", "start": [2063, 1], "end": [2065, 79], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comp_liftAddHom", "code": "theorem comp_liftAddHom {\u03b4 : Type*} [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] [AddCommMonoid \u03b4]\n    (g : \u03b3 \u2192+ \u03b4) (f : \u2200 i, \u03b2 i \u2192+ \u03b3) :\n    g.comp (liftAddHom (\u03b2 := \u03b2) f) = liftAddHom (\u03b2 := \u03b2) fun a => g.comp (f a)", "start": [2068, 1], "end": [2074, 82], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_zero", "code": "@[simp]\ntheorem sumAddHom_zero [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] :\n    (sumAddHom fun i => (0 : \u03b2 i \u2192+ \u03b3)) = 0", "start": [2077, 1], "end": [2080, 56], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_add", "code": "@[simp]\ntheorem sumAddHom_add [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] (g : \u2200 i, \u03b2 i \u2192+ \u03b3)\n    (h : \u2200 i, \u03b2 i \u2192+ \u03b3) : (sumAddHom fun i => g i + h i) = sumAddHom g + sumAddHom h", "start": [2083, 1], "end": [2086, 36], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sumAddHom_singleAddHom", "code": "@[simp]\ntheorem sumAddHom_singleAddHom [\u2200 i, AddCommMonoid (\u03b2 i)] :\n    sumAddHom (singleAddHom \u03b2) = AddMonoidHom.id _", "start": [2089, 1], "end": [2092, 26], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.comp_sumAddHom", "code": "theorem comp_sumAddHom {\u03b4 : Type*} [\u2200 i, AddZeroClass (\u03b2 i)] [AddCommMonoid \u03b3] [AddCommMonoid \u03b4]\n    (g : \u03b3 \u2192+ \u03b4) (f : \u2200 i, \u03b2 i \u2192+ \u03b3) : g.comp (sumAddHom f) = sumAddHom fun a => g.comp (f a)", "start": [2095, 1], "end": [2097, 22], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sum_sub_index", "code": "theorem sum_sub_index [\u2200 i, AddGroup (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [AddCommGroup \u03b3]\n    {f g : \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h_sub : \u2200 i b\u2081 b\u2082, h i (b\u2081 - b\u2082) = h i b\u2081 - h i b\u2082) :\n    (f - g).sum h = f.sum h - g.sum h", "start": [2100, 1], "end": [2105, 13], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_finset_sum_index", "code": "@[to_additive]\ntheorem prod_finset_sum_index {\u03b3 : Type w} {\u03b1 : Type x} [\u2200 i, AddCommMonoid (\u03b2 i)]\n    [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3] {s : Finset \u03b1} {g : \u03b1 \u2192 \u03a0\u2080 i, \u03b2 i}\n    {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h_zero : \u2200 i, h i 0 = 1)\n    (h_add : \u2200 i b\u2081 b\u2082, h i (b\u2081 + b\u2082) = h i b\u2081 * h i b\u2082) :\n    (\u220f i in s, (g i).prod h) = (\u2211 i in s, g i).prod h", "start": [2108, 1], "end": [2116, 85], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_sum_index", "code": "@[to_additive]\ntheorem prod_sum_index {\u03b9\u2081 : Type u\u2081} [DecidableEq \u03b9\u2081] {\u03b2\u2081 : \u03b9\u2081 \u2192 Type v\u2081} [\u2200 i\u2081, Zero (\u03b2\u2081 i\u2081)]\n    [\u2200 (i) (x : \u03b2\u2081 i), Decidable (x \u2260 0)] [\u2200 i, AddCommMonoid (\u03b2 i)]\n    [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] [CommMonoid \u03b3] {f : \u03a0\u2080 i\u2081, \u03b2\u2081 i\u2081}\n    {g : \u2200 i\u2081, \u03b2\u2081 i\u2081 \u2192 \u03a0\u2080 i, \u03b2 i} {h : \u2200 i, \u03b2 i \u2192 \u03b3} (h_zero : \u2200 i, h i 0 = 1)\n    (h_add : \u2200 i b\u2081 b\u2082, h i (b\u2081 + b\u2082) = h i b\u2081 * h i b\u2082) :\n    (f.sum g).prod h = f.prod fun i b => (g i b).prod h", "start": [2120, 1], "end": [2127, 44], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sum_single", "code": "@[simp]\ntheorem sum_single [\u2200 i, AddCommMonoid (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)] {f : \u03a0\u2080 i, \u03b2 i} :\n    f.sum single = f", "start": [2131, 1], "end": [2136, 13], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.prod_subtypeDomain_index", "code": "@[to_additive]\ntheorem prod_subtypeDomain_index [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    [CommMonoid \u03b3] {v : \u03a0\u2080 i, \u03b2 i} {p : \u03b9 \u2192 Prop} [DecidablePred p] {h : \u2200 i, \u03b2 i \u2192 \u03b3}\n    (hp : \u2200 x \u2208 v.support, p x) : ((v.subtypeDomain p).prod fun i b => h i b) = v.prod h", "start": [2139, 1], "end": [2144, 55], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_sum", "code": "theorem subtypeDomain_sum [\u2200 i, AddCommMonoid (\u03b2 i)] {s : Finset \u03b3} {h : \u03b3 \u2192 \u03a0\u2080 i, \u03b2 i}\n    {p : \u03b9 \u2192 Prop} [DecidablePred p] :\n    (\u2211 c in s, h c).subtypeDomain p = \u2211 c in s, (h c).subtypeDomain p", "start": [2148, 1], "end": [2151, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.subtypeDomain_finsupp_sum", "code": "theorem subtypeDomain_finsupp_sum {\u03b4 : \u03b3 \u2192 Type x} [DecidableEq \u03b3] [\u2200 c, Zero (\u03b4 c)]\n    [\u2200 (c) (x : \u03b4 c), Decidable (x \u2260 0)] [\u2200 i, AddCommMonoid (\u03b2 i)] {p : \u03b9 \u2192 Prop} [DecidablePred p]\n    {s : \u03a0\u2080 c, \u03b4 c} {h : \u2200 c, \u03b4 c \u2192 \u03a0\u2080 i, \u03b2 i} :\n    (s.sum h).subtypeDomain p = s.sum fun c d => (h c d).subtypeDomain p", "start": [2154, 1], "end": [2158, 20], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_add", "code": "theorem mapRange_add (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0)\n    (hf' : \u2200 i x y, f i (x + y) = f i x + f i y) (g\u2081 g\u2082 : \u03a0\u2080 i, \u03b2\u2081 i) :\n    mapRange f hf (g\u2081 + g\u2082) = mapRange f hf g\u2081 + mapRange f hf g\u2082", "start": [2173, 1], "end": [2177, 59], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addMonoidHom", "code": "@[simps apply]\ndef mapRange.addMonoidHom (f : \u2200 i, \u03b2\u2081 i \u2192+ \u03b2\u2082 i) : (\u03a0\u2080 i, \u03b2\u2081 i) \u2192+ \u03a0\u2080 i, \u03b2\u2082 i\n    where\n  toFun := mapRange (fun i x => f i x) fun i => (f i).map_zero\n  map_zero' := mapRange_zero _ _\n  map_add' := mapRange_add _ (fun i => (f i).map_zero) fun i => (f i).map_add", "start": [2180, 1], "end": [2186, 78], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addMonoidHom_id", "code": "@[simp]\ntheorem mapRange.addMonoidHom_id :\n    (mapRange.addMonoidHom fun i => AddMonoidHom.id (\u03b2\u2082 i)) = AddMonoidHom.id _", "start": [2190, 1], "end": [2193, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addMonoidHom_comp", "code": "theorem mapRange.addMonoidHom_comp (f : \u2200 i, \u03b2\u2081 i \u2192+ \u03b2\u2082 i) (f\u2082 : \u2200 i, \u03b2 i \u2192+ \u03b2\u2081 i) :\n    (mapRange.addMonoidHom fun i => (f i).comp (f\u2082 i)) =\n      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f\u2082)", "start": [2196, 1], "end": [2202, 40], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addEquiv", "code": "@[simps apply]\ndef mapRange.addEquiv (e : \u2200 i, \u03b2\u2081 i \u2243+ \u03b2\u2082 i) : (\u03a0\u2080 i, \u03b2\u2081 i) \u2243+ \u03a0\u2080 i, \u03b2\u2082 i :=\n  { mapRange.addMonoidHom fun i =>\n      (e i).toAddMonoidHom with\n    toFun := mapRange (fun i x => e i x) fun i => (e i).map_zero\n    invFun := mapRange (fun i x => (e i).symm x) fun i => (e i).symm.map_zero\n    left_inv := fun x => by\n      rw [\u2190 mapRange_comp] <;>\n        \u00b7 simp_rw [AddEquiv.symm_comp_self]\n          simp\n    right_inv := fun x => by\n      rw [\u2190 mapRange_comp] <;>\n        \u00b7 simp_rw [AddEquiv.self_comp_symm]\n          simp }", "start": [2205, 1], "end": [2219, 17], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addEquiv_refl", "code": "@[simp]\ntheorem mapRange.addEquiv_refl :\n    (mapRange.addEquiv fun i => AddEquiv.refl (\u03b2\u2081 i)) = AddEquiv.refl _", "start": [2223, 1], "end": [2226, 27], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addEquiv_trans", "code": "theorem mapRange.addEquiv_trans (f : \u2200 i, \u03b2 i \u2243+ \u03b2\u2081 i) (f\u2082 : \u2200 i, \u03b2\u2081 i \u2243+ \u03b2\u2082 i) :\n    (mapRange.addEquiv fun i => (f i).trans (f\u2082 i)) =\n      (mapRange.addEquiv f).trans (mapRange.addEquiv f\u2082)", "start": [2229, 1], "end": [2235, 40], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.addEquiv_symm", "code": "@[simp]\ntheorem mapRange.addEquiv_symm (e : \u2200 i, \u03b2\u2081 i \u2243+ \u03b2\u2082 i) :\n    (mapRange.addEquiv e).symm = mapRange.addEquiv fun i => (e i).symm", "start": [2238, 1], "end": [2241, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_dfinsupp_prod", "code": "@[to_additive]\ntheorem coe_dfinsupp_prod [Monoid R] [CommMonoid S] (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192 R \u2192* S) :\n    \u21d1(f.prod g) = f.prod fun a b => \u21d1g a b", "start": [2273, 1], "end": [2276, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.dfinsupp_prod_apply", "code": "@[to_additive (attr := simp)]\ntheorem dfinsupp_prod_apply [Monoid R] [CommMonoid S] (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192 R \u2192* S)\n    (r : R) : (f.prod g) r = f.prod fun a b => (g a b) r", "start": [2280, 1], "end": [2283, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.map_dfinsupp_sumAddHom", "code": "@[simp]\ntheorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [\u2200 i, AddZeroClass (\u03b2 i)]\n    (h : R \u2192+ S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.comp (g i)) f", "start": [2303, 1], "end": [2307, 44], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.dfinsupp_sumAddHom_apply", "code": "@[simp]\ntheorem dfinsupp_sumAddHom_apply [AddZeroClass R] [AddCommMonoid S] [\u2200 i, AddZeroClass (\u03b2 i)]\n    (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ R \u2192+ S) (r : R) :\n    (sumAddHom g f) r = sumAddHom (fun i => (eval r).comp (g i)) f", "start": [2310, 1], "end": [2314, 38], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_dfinsupp_sumAddHom", "code": "theorem coe_dfinsupp_sumAddHom [AddZeroClass R] [AddCommMonoid S] [\u2200 i, AddZeroClass (\u03b2 i)]\n    (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ R \u2192+ S) :\n    \u21d1(sumAddHom g f) = sumAddHom (fun i => (coeFn R S).comp (g i)) f", "start": [2317, 1], "end": [2320, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_dfinsupp_sumAddHom", "code": "@[simp]\ntheorem map_dfinsupp_sumAddHom [NonAssocSemiring R] [NonAssocSemiring S] [\u2200 i, AddZeroClass (\u03b2 i)]\n    (h : R \u2192+* S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f", "start": [2331, 1], "end": [2335, 59], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.map_dfinsupp_sumAddHom", "code": "@[simp]\ntheorem map_dfinsupp_sumAddHom [AddCommMonoid R] [AddCommMonoid S] [\u2200 i, AddZeroClass (\u03b2 i)]\n    (h : R \u2243+ S) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ R) :\n    h (sumAddHom g f) = sumAddHom (fun i => h.toAddMonoidHom.comp (g i)) f", "start": [2346, 1], "end": [2350, 59], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.fintype", "code": "instance DFinsupp.fintype {\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} [DecidableEq \u03b9] [\u2200 i, Zero (\u03c0 i)]\n    [Fintype \u03b9] [\u2200 i, Fintype (\u03c0 i)] : Fintype (\u03a0\u2080 i, \u03c0 i) :=\n  Fintype.ofEquiv (\u2200 i, \u03c0 i) DFinsupp.equivFunOnFintype.symm", "start": [2359, 1], "end": [2361, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.infinite_of_left", "code": "instance DFinsupp.infinite_of_left {\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} [\u2200 i, Nontrivial (\u03c0 i)]\n    [\u2200 i, Zero (\u03c0 i)] [Infinite \u03b9] : Infinite (\u03a0\u2080 i, \u03c0 i) := by\n  letI := Classical.decEq \u03b9; choose m hm using fun i => exists_ne (0 : \u03c0 i);\n    exact Infinite.of_injective _ (DFinsupp.single_left_injective hm)", "start": [2364, 1], "end": [2367, 70], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.infinite_of_exists_right", "code": "theorem DFinsupp.infinite_of_exists_right {\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} (i : \u03b9) [Infinite (\u03c0 i)]\n    [\u2200 i, Zero (\u03c0 i)] : Infinite (\u03a0\u2080 i, \u03c0 i)", "start": [2370, 1], "end": [2375, 81], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.infinite_of_right", "code": "instance DFinsupp.infinite_of_right {\u03b9 : Sort _} {\u03c0 : \u03b9 \u2192 Sort _} [\u2200 i, Infinite (\u03c0 i)]\n    [\u2200 i, Zero (\u03c0 i)] [Nonempty \u03b9] : Infinite (\u03a0\u2080 i, \u03c0 i) :=\n  DFinsupp.infinite_of_exists_right (Classical.arbitrary \u03b9)", "start": [2378, 1], "end": [2381, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Basic.lean", "imports": ["Mathlib/Algebra/Regular/SMul.lean", "Mathlib/Data/Finset/Preimage.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finsupp/Notation.lean", "Mathlib/Data/Rat/BigOperators.lean", "Mathlib/Algebra/Hom/GroupAction.lean", "Mathlib/Data/Set/Countable.lean"], "premises": [{"full_name": "Finsupp.graph", "code": "def graph (f : \u03b1 \u2192\u2080 M) : Finset (\u03b1 \u00d7 M) :=\n  f.support.map \u27e8fun a => Prod.mk a (f a), fun _ _ h => (Prod.mk.inj h).1\u27e9", "start": [64, 1], "end": [67, 75], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mk_mem_graph_iff", "code": "theorem mk_mem_graph_iff {a : \u03b1} {m : M} {f : \u03b1 \u2192\u2080 M} : (a, m) \u2208 f.graph \u2194 f a = m \u2227 m \u2260 0", "start": [70, 1], "end": [76, 23], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_graph_iff", "code": "@[simp]\ntheorem mem_graph_iff {c : \u03b1 \u00d7 M} {f : \u03b1 \u2192\u2080 M} : c \u2208 f.graph \u2194 f c.1 = c.2 \u2227 c.2 \u2260 0", "start": [79, 1], "end": [82, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mk_mem_graph", "code": "theorem mk_mem_graph (f : \u03b1 \u2192\u2080 M) {a : \u03b1} (ha : a \u2208 f.support) : (a, f a) \u2208 f.graph", "start": [85, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.apply_eq_of_mem_graph", "code": "theorem apply_eq_of_mem_graph {a : \u03b1} {m : M} {f : \u03b1 \u2192\u2080 M} (h : (a, m) \u2208 f.graph) : f a = m", "start": [89, 1], "end": [90, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.not_mem_graph_snd_zero", "code": "@[simp 1100] theorem not_mem_graph_snd_zero (a : \u03b1) (f : \u03b1 \u2192\u2080 M) : (a, (0 : M)) \u2209 f.graph", "start": [93, 1], "end": [95, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.image_fst_graph", "code": "@[simp]\ntheorem image_fst_graph [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 M) : f.graph.image Prod.fst = f.support", "start": [98, 1], "end": [100, 97], "kind": "commanddeclaration"}, {"full_name": "Finsupp.graph_injective", "code": "theorem graph_injective (\u03b1 M) [Zero M] : Injective (@graph \u03b1 M _)", "start": [103, 1], "end": [108, 37], "kind": "commanddeclaration"}, {"full_name": "Finsupp.graph_inj", "code": "@[simp]\ntheorem graph_inj {f g : \u03b1 \u2192\u2080 M} : f.graph = g.graph \u2194 f = g", "start": [111, 1], "end": [113, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.graph_zero", "code": "@[simp]\ntheorem graph_zero : graph (0 : \u03b1 \u2192\u2080 M) = \u2205", "start": [116, 1], "end": [117, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.graph_eq_empty", "code": "@[simp]\ntheorem graph_eq_empty {f : \u03b1 \u2192\u2080 M} : f.graph = \u2205 \u2194 f = 0", "start": [120, 1], "end": [122, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.equiv", "code": "@[simps apply]\ndef mapRange.equiv (f : M \u2243 N) (hf : f 0 = 0) (hf' : f.symm 0 = 0) : (\u03b1 \u2192\u2080 M) \u2243 (\u03b1 \u2192\u2080 N)\n    where\n  toFun := (mapRange f hf : (\u03b1 \u2192\u2080 M) \u2192 \u03b1 \u2192\u2080 N)\n  invFun := (mapRange f.symm hf' : (\u03b1 \u2192\u2080 N) \u2192 \u03b1 \u2192\u2080 M)\n  left_inv x := by\n    rw [\u2190 mapRange_comp _ _ _ _] <;> simp_rw [Equiv.symm_comp_self]\n    \u00b7 exact mapRange_id _\n    \u00b7 rfl\n  right_inv x := by\n    rw [\u2190 mapRange_comp _ _ _ _] <;> simp_rw [Equiv.self_comp_symm]\n    \u00b7 exact mapRange_id _\n    \u00b7 rfl", "start": [140, 1], "end": [153, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.equiv_refl", "code": "@[simp]\ntheorem mapRange.equiv_refl : mapRange.equiv (Equiv.refl M) rfl rfl = Equiv.refl (\u03b1 \u2192\u2080 M)", "start": [156, 1], "end": [158, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.equiv_trans", "code": "theorem mapRange.equiv_trans (f : M \u2243 N) (hf : f 0 = 0) (hf') (f\u2082 : N \u2243 P) (hf\u2082 : f\u2082 0 = 0) (hf\u2082') :\n    (mapRange.equiv (f.trans f\u2082) (by rw [Equiv.trans_apply, hf, hf\u2082])\n          (by rw [Equiv.symm_trans_apply, hf\u2082', hf']) :\n        (\u03b1 \u2192\u2080 _) \u2243 _) =\n      (mapRange.equiv f hf hf').trans (mapRange.equiv f\u2082 hf\u2082 hf\u2082')", "start": [161, 1], "end": [166, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.equiv_symm", "code": "@[simp]\ntheorem mapRange.equiv_symm (f : M \u2243 N) (hf hf') :\n    ((mapRange.equiv f hf hf').symm : (\u03b1 \u2192\u2080 _) \u2243 _) = mapRange.equiv f.symm hf' hf", "start": [169, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.zeroHom", "code": "@[simps]\ndef mapRange.zeroHom (f : ZeroHom M N) : ZeroHom (\u03b1 \u2192\u2080 M) (\u03b1 \u2192\u2080 N)\n    where\n  toFun := (mapRange f f.map_zero : (\u03b1 \u2192\u2080 M) \u2192 \u03b1 \u2192\u2080 N)\n  map_zero' := mapRange_zero", "start": [181, 1], "end": [187, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.zeroHom_id", "code": "@[simp]\ntheorem mapRange.zeroHom_id : mapRange.zeroHom (ZeroHom.id M) = ZeroHom.id (\u03b1 \u2192\u2080 M)", "start": [190, 1], "end": [192, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.zeroHom_comp", "code": "theorem mapRange.zeroHom_comp (f : ZeroHom N P) (f\u2082 : ZeroHom M N) :\n    (mapRange.zeroHom (f.comp f\u2082) : ZeroHom (\u03b1 \u2192\u2080 _) _) =\n      (mapRange.zeroHom f).comp (mapRange.zeroHom f\u2082)", "start": [195, 1], "end": [198, 101], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addMonoidHom", "code": "@[simps]\ndef mapRange.addMonoidHom (f : M \u2192+ N) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b1 \u2192\u2080 N\n    where\n  toFun := (mapRange f f.map_zero : (\u03b1 \u2192\u2080 M) \u2192 \u03b1 \u2192\u2080 N)\n  map_zero' := mapRange_zero\n  map_add' a b := by dsimp only; exact mapRange_add f.map_add _ _;", "start": [208, 1], "end": [215, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addMonoidHom_id", "code": "@[simp]\ntheorem mapRange.addMonoidHom_id :\n    mapRange.addMonoidHom (AddMonoidHom.id M) = AddMonoidHom.id (\u03b1 \u2192\u2080 M)", "start": [218, 1], "end": [221, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addMonoidHom_comp", "code": "theorem mapRange.addMonoidHom_comp (f : N \u2192+ P) (f\u2082 : M \u2192+ N) :\n    (mapRange.addMonoidHom (f.comp f\u2082) : (\u03b1 \u2192\u2080 _) \u2192+ _) =\n      (mapRange.addMonoidHom f).comp (mapRange.addMonoidHom f\u2082)", "start": [224, 1], "end": [228, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addMonoidHom_toZeroHom", "code": "@[simp]\ntheorem mapRange.addMonoidHom_toZeroHom (f : M \u2192+ N) :\n    (mapRange.addMonoidHom f).toZeroHom = (mapRange.zeroHom f.toZeroHom : ZeroHom (\u03b1 \u2192\u2080 _) _)", "start": [231, 1], "end": [234, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_multiset_sum", "code": "theorem mapRange_multiset_sum (f : F) (m : Multiset (\u03b1 \u2192\u2080 M)) :\n    mapRange f (map_zero f) m.sum = (m.map fun x => mapRange f (map_zero f) x).sum", "start": [237, 1], "end": [239, 74], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_finset_sum", "code": "theorem mapRange_finset_sum (f : F) (s : Finset \u03b9) (g : \u03b9 \u2192 \u03b1 \u2192\u2080 M) :\n    mapRange f (map_zero f) (\u2211 x in s, g x) = \u2211 x in s, mapRange f (map_zero f) (g x)", "start": [242, 1], "end": [244, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv", "code": "@[simps apply]\ndef mapRange.addEquiv (f : M \u2243+ N) : (\u03b1 \u2192\u2080 M) \u2243+ (\u03b1 \u2192\u2080 N) :=\n  { mapRange.addMonoidHom f.toAddMonoidHom with\n    toFun := (mapRange f f.map_zero : (\u03b1 \u2192\u2080 M) \u2192 \u03b1 \u2192\u2080 N)\n    invFun := (mapRange f.symm f.symm.map_zero : (\u03b1 \u2192\u2080 N) \u2192 \u03b1 \u2192\u2080 M)\n    left_inv := fun x => by\n      rw [\u2190 mapRange_comp _ _ _ _] <;> simp_rw [AddEquiv.symm_comp_self]\n      \u00b7 exact mapRange_id _\n      \u00b7 rfl\n    right_inv := fun x => by\n      rw [\u2190 mapRange_comp _ _ _ _] <;> simp_rw [AddEquiv.self_comp_symm]\n      \u00b7 exact mapRange_id _\n      \u00b7 rfl }", "start": [247, 1], "end": [260, 14], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv_refl", "code": "@[simp]\ntheorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (\u03b1 \u2192\u2080 M)", "start": [263, 1], "end": [265, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv_trans", "code": "theorem mapRange.addEquiv_trans (f : M \u2243+ N) (f\u2082 : N \u2243+ P) :\n    (mapRange.addEquiv (f.trans f\u2082) : (\u03b1 \u2192\u2080 M) \u2243+ (\u03b1 \u2192\u2080 P)) =\n      (mapRange.addEquiv f).trans (mapRange.addEquiv f\u2082)", "start": [268, 1], "end": [271, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv_symm", "code": "@[simp]\ntheorem mapRange.addEquiv_symm (f : M \u2243+ N) :\n    ((mapRange.addEquiv f).symm : (\u03b1 \u2192\u2080 _) \u2243+ _) = mapRange.addEquiv f.symm", "start": [274, 1], "end": [277, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv_toAddMonoidHom", "code": "@[simp]\ntheorem mapRange.addEquiv_toAddMonoidHom (f : M \u2243+ N) :\n    (mapRange.addEquiv f : (\u03b1 \u2192\u2080 _) \u2243+ _).toAddMonoidHom =\n      (mapRange.addMonoidHom f.toAddMonoidHom : (\u03b1 \u2192\u2080 _) \u2192+ _)", "start": [280, 1], "end": [284, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.addEquiv_toEquiv", "code": "@[simp]\ntheorem mapRange.addEquiv_toEquiv (f : M \u2243+ N) :\n    \u2191(mapRange.addEquiv f : (\u03b1 \u2192\u2080 _) \u2243+ _) =\n      (mapRange.equiv (f : M \u2243 N) f.map_zero f.symm.map_zero : (\u03b1 \u2192\u2080 _) \u2243 _)", "start": [287, 1], "end": [291, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain", "code": "def equivMapDomain (f : \u03b1 \u2243 \u03b2) (l : \u03b1 \u2192\u2080 M) : \u03b2 \u2192\u2080 M\n    where\n  support := l.support.map f.toEmbedding\n  toFun a := l (f.symm a)\n  mem_support_toFun a := by simp only [Finset.mem_map_equiv, mem_support_toFun]; rfl", "start": [309, 1], "end": [315, 85], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_apply", "code": "@[simp]\ntheorem equivMapDomain_apply (f : \u03b1 \u2243 \u03b2) (l : \u03b1 \u2192\u2080 M) (b : \u03b2) :\n    equivMapDomain f l b = l (f.symm b)", "start": [318, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_symm_apply", "code": "theorem equivMapDomain_symm_apply (f : \u03b1 \u2243 \u03b2) (l : \u03b2 \u2192\u2080 M) (a : \u03b1) :\n    equivMapDomain f.symm l a = l (f a)", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_refl", "code": "@[simp]\ntheorem equivMapDomain_refl (l : \u03b1 \u2192\u2080 M) : equivMapDomain (Equiv.refl _) l = l", "start": [329, 1], "end": [330, 96], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_refl'", "code": "theorem equivMapDomain_refl' : equivMapDomain (Equiv.refl _) = @id (\u03b1 \u2192\u2080 M)", "start": [333, 1], "end": [333, 93], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_trans", "code": "theorem equivMapDomain_trans (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) (l : \u03b1 \u2192\u2080 M) :\n    equivMapDomain (f.trans g) l = equivMapDomain g (equivMapDomain f l)", "start": [336, 1], "end": [337, 90], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_trans'", "code": "theorem equivMapDomain_trans' (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) :\n    @equivMapDomain _ _ M _ (f.trans g) = equivMapDomain g \u2218 equivMapDomain f", "start": [340, 1], "end": [341, 95], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_single", "code": "@[simp]\ntheorem equivMapDomain_single (f : \u03b1 \u2243 \u03b2) (a : \u03b1) (b : M) :\n    equivMapDomain f (single a b) = single (f a) b", "start": [344, 1], "end": [349, 85], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_zero", "code": "@[simp]\ntheorem equivMapDomain_zero {f : \u03b1 \u2243 \u03b2} : equivMapDomain f (0 : \u03b1 \u2192\u2080 M) = (0 : \u03b2 \u2192\u2080 M)", "start": [352, 1], "end": [354, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivCongrLeft", "code": "def equivCongrLeft (f : \u03b1 \u2243 \u03b2) : (\u03b1 \u2192\u2080 M) \u2243 (\u03b2 \u2192\u2080 M) := by\n  refine' \u27e8equivMapDomain f, equivMapDomain f.symm, fun f => _, fun f => _\u27e9 <;> ext x <;>\n    simp only [equivMapDomain_apply, Equiv.symm_symm, Equiv.symm_apply_apply,\n      Equiv.apply_symm_apply]", "start": [357, 1], "end": [364, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivCongrLeft_apply", "code": "@[simp]\ntheorem equivCongrLeft_apply (f : \u03b1 \u2243 \u03b2) (l : \u03b1 \u2192\u2080 M) : equivCongrLeft f l = equivMapDomain f l", "start": [367, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivCongrLeft_symm", "code": "@[simp]\ntheorem equivCongrLeft_symm (f : \u03b1 \u2243 \u03b2) :\n    (@equivCongrLeft _ _ M _ f).symm = equivCongrLeft f.symm", "start": [372, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_finsupp_prod", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_prod [CommSemiring R] (g : \u03b1 \u2192 M \u2192 \u2115) :\n    (\u2191(f.prod g) : R) = f.prod fun a b => \u2191(g a b)", "start": [388, 1], "end": [391, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_finsupp_sum", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_sum [CommSemiring R] (g : \u03b1 \u2192 M \u2192 \u2115) :\n    (\u2191(f.sum g) : R) = f.sum fun a b => \u2191(g a b)", "start": [394, 1], "end": [397, 19], "kind": "commanddeclaration"}, {"full_name": "Int.cast_finsupp_prod", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_prod [CommRing R] (g : \u03b1 \u2192 M \u2192 \u2124) :\n    (\u2191(f.prod g) : R) = f.prod fun a b => \u2191(g a b)", "start": [404, 1], "end": [407, 20], "kind": "commanddeclaration"}, {"full_name": "Int.cast_finsupp_sum", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_sum [CommRing R] (g : \u03b1 \u2192 M \u2192 \u2124) :\n    (\u2191(f.sum g) : R) = f.sum fun a b => \u2191(g a b)", "start": [410, 1], "end": [413, 19], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_finsupp_sum", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_sum [DivisionRing R] [CharZero R] (g : \u03b1 \u2192 M \u2192 \u211a) :\n    (\u2191(f.sum g) : R) = f.sum fun a b => \u2191(g a b)", "start": [420, 1], "end": [423, 15], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_finsupp_prod", "code": "@[simp, norm_cast]\ntheorem cast_finsupp_prod [Field R] [CharZero R] (g : \u03b1 \u2192 M \u2192 \u211a) :\n    (\u2191(f.prod g) : R) = f.prod fun a b => \u2191(g a b)", "start": [426, 1], "end": [429, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain", "code": "def mapDomain (f : \u03b1 \u2192 \u03b2) (v : \u03b1 \u2192\u2080 M) : \u03b2 \u2192\u2080 M :=\n  v.sum fun a => single (f a)", "start": [445, 1], "end": [449, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_apply", "code": "theorem mapDomain_apply {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) (x : \u03b1 \u2192\u2080 M) (a : \u03b1) :\n    mapDomain f x (f a) = x a", "start": [452, 1], "end": [458, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_notin_range", "code": "theorem mapDomain_notin_range {f : \u03b1 \u2192 \u03b2} (x : \u03b1 \u2192\u2080 M) (a : \u03b2) (h : a \u2209 Set.range f) :\n    mapDomain f x a = 0", "start": [461, 1], "end": [464, 96], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_id", "code": "@[simp]\ntheorem mapDomain_id : mapDomain id v = v", "start": [467, 1], "end": [469, 15], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_comp", "code": "theorem mapDomain_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    mapDomain (g \u2218 f) v = mapDomain g (mapDomain f v)", "start": [472, 1], "end": [480, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_single", "code": "@[simp]\ntheorem mapDomain_single {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : M} : mapDomain f (single a b) = single (f a) b", "start": [483, 1], "end": [485, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_zero", "code": "@[simp]\ntheorem mapDomain_zero {f : \u03b1 \u2192 \u03b2} : mapDomain f (0 : \u03b1 \u2192\u2080 M) = (0 : \u03b2 \u2192\u2080 M)", "start": [488, 1], "end": [490, 17], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_congr", "code": "theorem mapDomain_congr {f g : \u03b1 \u2192 \u03b2} (h : \u2200 x \u2208 v.support, f x = g x) :\n    v.mapDomain f = v.mapDomain g", "start": [493, 1], "end": [495, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_add", "code": "theorem mapDomain_add {f : \u03b1 \u2192 \u03b2} : mapDomain f (v\u2081 + v\u2082) = mapDomain f v\u2081 + mapDomain f v\u2082", "start": [498, 1], "end": [499, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_equiv_apply", "code": "@[simp]\ntheorem mapDomain_equiv_apply {f : \u03b1 \u2243 \u03b2} (x : \u03b1 \u2192\u2080 M) (a : \u03b2) :\n    mapDomain f x a = x (f.symm a)", "start": [502, 1], "end": [506, 40], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain.addMonoidHom", "code": "@[simps]\ndef mapDomain.addMonoidHom (f : \u03b1 \u2192 \u03b2) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b2 \u2192\u2080 M\n    where\n  toFun := mapDomain f\n  map_zero' := mapDomain_zero\n  map_add' _ _ := mapDomain_add", "start": [509, 1], "end": [515, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain.addMonoidHom_id", "code": "@[simp]\ntheorem mapDomain.addMonoidHom_id : mapDomain.addMonoidHom id = AddMonoidHom.id (\u03b1 \u2192\u2080 M)", "start": [518, 1], "end": [520, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain.addMonoidHom_comp", "code": "theorem mapDomain.addMonoidHom_comp (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 \u03b2) :\n    (mapDomain.addMonoidHom (f \u2218 g) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b3 \u2192\u2080 M) =\n      (mapDomain.addMonoidHom f).comp (mapDomain.addMonoidHom g)", "start": [523, 1], "end": [526, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_finset_sum", "code": "theorem mapDomain_finset_sum {f : \u03b1 \u2192 \u03b2} {s : Finset \u03b9} {v : \u03b9 \u2192 \u03b1 \u2192\u2080 M} :\n    mapDomain f (\u2211 i in s, v i) = \u2211 i in s, mapDomain f (v i)", "start": [529, 1], "end": [531, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_sum", "code": "theorem mapDomain_sum [Zero N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 N} {v : \u03b1 \u2192 N \u2192 \u03b1 \u2192\u2080 M} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b)", "start": [534, 1], "end": [536, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_support", "code": "theorem mapDomain_support [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M} :\n    (s.mapDomain f).support \u2286 s.support.image f", "start": [539, 1], "end": [543, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_apply'", "code": "theorem mapDomain_apply' (S : Set \u03b1) {f : \u03b1 \u2192 \u03b2} (x : \u03b1 \u2192\u2080 M) (hS : (x.support : Set \u03b1) \u2286 S)\n    (hf : Set.InjOn f S) {a : \u03b1} (ha : a \u2208 S) : mapDomain f x (f a) = x a", "start": [546, 1], "end": [558, 59], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_support_of_injOn", "code": "theorem mapDomain_support_of_injOn [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (s : \u03b1 \u2192\u2080 M)\n    (hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support", "start": [561, 1], "end": [572, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_support_of_injective", "code": "theorem mapDomain_support_of_injective [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f)\n    (s : \u03b1 \u2192\u2080 M) : (mapDomain f s).support = Finset.image f s.support", "start": [575, 1], "end": [577, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_mapDomain_index", "code": "@[to_additive]\ntheorem prod_mapDomain_index [CommMonoid N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M} {h : \u03b2 \u2192 M \u2192 N}\n    (h_zero : \u2200 b, h b 0 = 1) (h_add : \u2200 b m\u2081 m\u2082, h b (m\u2081 + m\u2082) = h b m\u2081 * h b m\u2082) :\n    (mapDomain f s).prod h = s.prod fun a m => h (f a) m", "start": [580, 1], "end": [584, 92], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_mapDomain_index_addMonoidHom", "code": "@[simp]\ntheorem sum_mapDomain_index_addMonoidHom [AddCommMonoid N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M}\n    (h : \u03b2 \u2192 M \u2192+ N) : ((mapDomain f s).sum fun b m => h b m) = s.sum fun a m => h (f a) m", "start": [590, 1], "end": [596, 81], "kind": "commanddeclaration"}, {"full_name": "Finsupp.embDomain_eq_mapDomain", "code": "theorem embDomain_eq_mapDomain (f : \u03b1 \u21aa \u03b2) (v : \u03b1 \u2192\u2080 M) : embDomain f v = mapDomain f v", "start": [599, 1], "end": [604, 69], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_mapDomain_index_inj", "code": "@[to_additive]\ntheorem prod_mapDomain_index_inj [CommMonoid N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M} {h : \u03b2 \u2192 M \u2192 N}\n    (hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b", "start": [607, 1], "end": [610, 84], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_injective", "code": "theorem mapDomain_injective {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) :\n    Function.Injective (mapDomain f : (\u03b1 \u2192\u2080 M) \u2192 \u03b2 \u2192\u2080 M)", "start": [614, 1], "end": [619, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomainEmbedding", "code": "@[simps]\ndef mapDomainEmbedding {\u03b1 \u03b2 : Type*} (f : \u03b1 \u21aa \u03b2) : (\u03b1 \u2192\u2080 \u2115) \u21aa \u03b2 \u2192\u2080 \u2115 :=\n  \u27e8Finsupp.mapDomain f, Finsupp.mapDomain_injective f.injective\u27e9", "start": [622, 1], "end": [625, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain.addMonoidHom_comp_mapRange", "code": "theorem mapDomain.addMonoidHom_comp_mapRange [AddCommMonoid N] (f : \u03b1 \u2192 \u03b2) (g : M \u2192+ N) :\n    (mapDomain.addMonoidHom f).comp (mapRange.addMonoidHom g) =\n      (mapRange.addMonoidHom g).comp (mapDomain.addMonoidHom f)", "start": [628, 1], "end": [634, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_mapRange", "code": "theorem mapDomain_mapRange [AddCommMonoid N] (f : \u03b1 \u2192 \u03b2) (v : \u03b1 \u2192\u2080 M) (g : M \u2192 N) (h0 : g 0 = 0)\n    (hadd : \u2200 x y, g (x + y) = g x + g y) :\n    mapDomain f (mapRange g h0 v) = mapRange g h0 (mapDomain f v)", "start": [637, 1], "end": [645, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_update_add", "code": "theorem sum_update_add [AddCommMonoid \u03b1] [AddCommMonoid \u03b2] (f : \u03b9 \u2192\u2080 \u03b1) (i : \u03b9) (a : \u03b1)\n    (g : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (hg : \u2200 i, g i 0 = 0)\n    (hgg : \u2200 (j : \u03b9) (a\u2081 a\u2082 : \u03b1), g j (a\u2081 + a\u2082) = g j a\u2081 + g j a\u2082) :\n    (f.update i a).sum g + g i (f i) = f.sum g + g i a", "start": [648, 1], "end": [656, 66], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_injOn", "code": "theorem mapDomain_injOn (S : Set \u03b1) {f : \u03b1 \u2192 \u03b2} (hf : Set.InjOn f S) :\n    Set.InjOn (mapDomain f : (\u03b1 \u2192\u2080 M) \u2192 \u03b2 \u2192\u2080 M) { w | (w.support : Set \u03b1) \u2286 S }", "start": [659, 1], "end": [669, 15], "kind": "commanddeclaration"}, {"full_name": "Finsupp.equivMapDomain_eq_mapDomain", "code": "theorem equivMapDomain_eq_mapDomain {M} [AddCommMonoid M] (f : \u03b1 \u2243 \u03b2) (l : \u03b1 \u2192\u2080 M) :\n    equivMapDomain f l = mapDomain f l", "start": [672, 1], "end": [673, 81], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain", "code": "@[simps support]\ndef comapDomain [Zero M] (f : \u03b1 \u2192 \u03b2) (l : \u03b2 \u2192\u2080 M) (hf : Set.InjOn f (f \u207b\u00b9' \u2191l.support)) : \u03b1 \u2192\u2080 M\n    where\n  support := l.support.preimage f hf\n  toFun a := l (f a)\n  mem_support_toFun := by\n    intro a\n    simp only [Finset.mem_def.symm, Finset.mem_preimage]\n    exact l.mem_support_toFun (f a)", "start": [683, 1], "end": [694, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_apply", "code": "@[simp]\ntheorem comapDomain_apply [Zero M] (f : \u03b1 \u2192 \u03b2) (l : \u03b2 \u2192\u2080 M) (hf : Set.InjOn f (f \u207b\u00b9' \u2191l.support))\n    (a : \u03b1) : comapDomain f l hf a = l (f a)", "start": [697, 1], "end": [700, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_comapDomain", "code": "theorem sum_comapDomain [Zero M] [AddCommMonoid N] (f : \u03b1 \u2192 \u03b2) (l : \u03b2 \u2192\u2080 M) (g : \u03b2 \u2192 M \u2192 N)\n    (hf : Set.BijOn f (f \u207b\u00b9' \u2191l.support) \u2191l.support) :\n    (comapDomain f l hf.injOn).sum (g \u2218 f) = l.sum g", "start": [703, 1], "end": [707, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.eq_zero_of_comapDomain_eq_zero", "code": "theorem eq_zero_of_comapDomain_eq_zero [AddCommMonoid M] (f : \u03b1 \u2192 \u03b2) (l : \u03b2 \u2192\u2080 M)\n    (hf : Set.BijOn f (f \u207b\u00b9' \u2191l.support) \u2191l.support) : comapDomain f l hf.injOn = 0 \u2192 l = 0", "start": [710, 1], "end": [716, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_zero", "code": "@[simp]\ntheorem comapDomain_zero (f : \u03b1 \u2192 \u03b2)\n    (hif : Set.InjOn f (f \u207b\u00b9' \u2191(0 : \u03b2 \u2192\u2080 M).support) := Finset.coe_empty \u25b8 (Set.injOn_empty f)) :\n    comapDomain f (0 : \u03b2 \u2192\u2080 M) hif = (0 : \u03b1 \u2192\u2080 M)", "start": [725, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_single", "code": "@[simp]\ntheorem comapDomain_single (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (m : M)\n    (hif : Set.InjOn f (f \u207b\u00b9' (single (f a) m).support)) :\n    comapDomain f (Finsupp.single (f a) m) hif = Finsupp.single a m", "start": [734, 1], "end": [743, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_add", "code": "theorem comapDomain_add (v\u2081 v\u2082 : \u03b2 \u2192\u2080 M) (hv\u2081 : Set.InjOn f (f \u207b\u00b9' \u2191v\u2081.support))\n    (hv\u2082 : Set.InjOn f (f \u207b\u00b9' \u2191v\u2082.support)) (hv\u2081\u2082 : Set.InjOn f (f \u207b\u00b9' \u2191(v\u2081 + v\u2082).support)) :\n    comapDomain f (v\u2081 + v\u2082) hv\u2081\u2082 = comapDomain f v\u2081 hv\u2081 + comapDomain f v\u2082 hv\u2082", "start": [752, 1], "end": [756, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_add_of_injective", "code": "theorem comapDomain_add_of_injective (hf : Function.Injective f) (v\u2081 v\u2082 : \u03b2 \u2192\u2080 M) :\n    comapDomain f (v\u2081 + v\u2082) (hf.injOn _) =\n      comapDomain f v\u2081 (hf.injOn _) + comapDomain f v\u2082 (hf.injOn _)", "start": [759, 1], "end": [763, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain.addMonoidHom", "code": "@[simps]\ndef comapDomain.addMonoidHom (hf : Function.Injective f) : (\u03b2 \u2192\u2080 M) \u2192+ \u03b1 \u2192\u2080 M\n    where\n  toFun x := comapDomain f x (hf.injOn _)\n  map_zero' := comapDomain_zero f\n  map_add' := comapDomain_add_of_injective hf", "start": [766, 1], "end": [772, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_comapDomain", "code": "theorem mapDomain_comapDomain (hf : Function.Injective f) (l : \u03b2 \u2192\u2080 M)\n    (hl : \u2191l.support \u2286 Set.range f) : mapDomain f (comapDomain f l (hf.injOn _)) = l", "start": [779, 1], "end": [787, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some", "code": "def some [Zero M] (f : Option \u03b1 \u2192\u2080 M) : \u03b1 \u2192\u2080 M :=\n  f.comapDomain Option.some fun _ => by simp", "start": [799, 1], "end": [801, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some_apply", "code": "@[simp]\ntheorem some_apply [Zero M] (f : Option \u03b1 \u2192\u2080 M) (a : \u03b1) : f.some a = f (Option.some a)", "start": [804, 1], "end": [806, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some_zero", "code": "@[simp]\ntheorem some_zero [Zero M] : (0 : Option \u03b1 \u2192\u2080 M).some = 0", "start": [809, 1], "end": [812, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some_add", "code": "@[simp]\ntheorem some_add [AddCommMonoid M] (f g : Option \u03b1 \u2192\u2080 M) : (f + g).some = f.some + g.some", "start": [815, 1], "end": [818, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some_single_none", "code": "@[simp]\ntheorem some_single_none [Zero M] (m : M) : (single none m : Option \u03b1 \u2192\u2080 M).some = 0", "start": [821, 1], "end": [824, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.some_single_some", "code": "@[simp]\ntheorem some_single_some [Zero M] (a : \u03b1) (m : M) :\n    (single (Option.some a) m : Option \u03b1 \u2192\u2080 M).some = single a m", "start": [827, 1], "end": [832, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_option_index", "code": "@[to_additive]\ntheorem prod_option_index [AddCommMonoid M] [CommMonoid N] (f : Option \u03b1 \u2192\u2080 M)\n    (b : Option \u03b1 \u2192 M \u2192 N) (h_zero : \u2200 o, b o 0 = 1)\n    (h_add : \u2200 o m\u2081 m\u2082, b o (m\u2081 + m\u2082) = b o m\u2081 * b o m\u2082) :\n    f.prod b = b none (f none) * f.some.prod fun a => b (Option.some a)", "start": [835, 1], "end": [848, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_option_index_smul", "code": "theorem sum_option_index_smul [Semiring R] [AddCommMonoid M] [Module R M] (f : Option \u03b1 \u2192\u2080 R)\n    (b : Option \u03b1 \u2192 M) :\n    (f.sum fun o r => r \u2022 b o) = f none \u2022 b none + f.some.sum fun a r => r \u2022 b (Option.some a)", "start": [852, 1], "end": [855, 76], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter", "code": "def filter (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192\u2080 M) : \u03b1 \u2192\u2080 M\n    where\n  toFun a :=\n    haveI := Classical.decPred p\n    if p a then f a else 0\n  support :=\n    haveI := Classical.decPred p\n    f.support.filter fun a => p a\n  mem_support_toFun a := by\n    simp only split_ifs with h <;>\n      \u00b7 simp only [h, @mem_filter _ _ (Classical.decPred p), mem_support_iff]\n        tauto", "start": [869, 1], "end": [885, 14], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_apply", "code": "theorem filter_apply (a : \u03b1) [D : Decidable (p a)] : f.filter p a = if p a then f a else 0", "start": [888, 1], "end": [889, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_eq_indicator", "code": "theorem filter_eq_indicator : \u21d1(f.filter p) = Set.indicator { x | p x } f", "start": [892, 1], "end": [893, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_eq_zero_iff", "code": "theorem filter_eq_zero_iff : f.filter p = 0 \u2194 \u2200 x, p x \u2192 f x = 0", "start": [896, 1], "end": [898, 22], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_eq_self_iff", "code": "theorem filter_eq_self_iff : f.filter p = f \u2194 \u2200 x, f x \u2260 0 \u2192 p x", "start": [901, 1], "end": [903, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_apply_pos", "code": "@[simp]\ntheorem filter_apply_pos {a : \u03b1} (h : p a) : f.filter p a = f a", "start": [906, 1], "end": [907, 76], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_apply_neg", "code": "@[simp]\ntheorem filter_apply_neg {a : \u03b1} (h : \u00acp a) : f.filter p a = 0", "start": [910, 1], "end": [911, 75], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_filter", "code": "@[simp]\ntheorem support_filter [D : DecidablePred p] : (f.filter p).support = f.support.filter p", "start": [914, 1], "end": [916, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_zero", "code": "theorem filter_zero : (0 : \u03b1 \u2192\u2080 M).filter p = 0", "start": [919, 1], "end": [920, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_single_of_pos", "code": "@[simp]\ntheorem filter_single_of_pos {a : \u03b1} {b : M} (h : p a) : (single a b).filter p = single a b", "start": [923, 1], "end": [925, 80], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_single_of_neg", "code": "@[simp]\ntheorem filter_single_of_neg {a : \u03b1} {b : M} (h : \u00acp a) : (single a b).filter p = 0", "start": [928, 1], "end": [931, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_filter_index", "code": "@[to_additive]\ntheorem prod_filter_index [CommMonoid N] (g : \u03b1 \u2192 M \u2192 N) :\n    (f.filter p).prod g = \u220f x in (f.filter p).support, g x (f x)", "start": [934, 1], "end": [940, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_filter_mul_prod_filter_not", "code": "@[to_additive (attr := simp)]\ntheorem prod_filter_mul_prod_filter_not [CommMonoid N] (g : \u03b1 \u2192 M \u2192 N) :\n    (f.filter p).prod g * (f.filter fun a => \u00acp a).prod g = f.prod g", "start": [944, 1], "end": [948, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_div_prod_filter", "code": "@[to_additive (attr := simp)]\ntheorem prod_div_prod_filter [CommGroup G] (g : \u03b1 \u2192 M \u2192 G) :\n    f.prod g / (f.filter p).prod g = (f.filter fun a => \u00acp a).prod g", "start": [952, 1], "end": [955, 65], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_pos_add_filter_neg", "code": "theorem filter_pos_add_filter_neg [AddZeroClass M] (f : \u03b1 \u2192\u2080 M) (p : \u03b1 \u2192 Prop) :\n    (f.filter p + f.filter fun a => \u00acp a) = f", "start": [961, 1], "end": [963, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.frange", "code": "def frange (f : \u03b1 \u2192\u2080 M) : Finset M :=\n  haveI := Classical.decEq M\n  Finset.image f f.support", "start": [975, 1], "end": [978, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_frange", "code": "theorem mem_frange {f : \u03b1 \u2192\u2080 M} {y : M} : y \u2208 f.frange \u2194 y \u2260 0 \u2227 \u2203 x, f x = y", "start": [981, 1], "end": [984, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.zero_not_mem_frange", "code": "theorem zero_not_mem_frange {f : \u03b1 \u2192\u2080 M} : (0 : M) \u2209 f.frange", "start": [989, 1], "end": [989, 97], "kind": "commanddeclaration"}, {"full_name": "Finsupp.frange_single", "code": "theorem frange_single {x : \u03b1} {y : M} : frange (single x y) \u2286 {y}", "start": [992, 1], "end": [999, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain", "code": "def subtypeDomain (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192\u2080 M) : Subtype p \u2192\u2080 M\n    where\n  support :=\n    haveI := Classical.decPred p\n    f.support.subtype p\n  toFun := f \u2218 Subtype.val\n  mem_support_toFun a := by simp only [@mem_subtype _ _ (Classical.decPred p), mem_support_iff]; rfl", "start": [1013, 1], "end": [1021, 101], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_subtypeDomain", "code": "@[simp]\ntheorem support_subtypeDomain [D : DecidablePred p] {f : \u03b1 \u2192\u2080 M} :\n    (subtypeDomain p f).support = f.support.subtype p", "start": [1024, 1], "end": [1026, 93], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_apply", "code": "@[simp]\ntheorem subtypeDomain_apply {a : Subtype p} {v : \u03b1 \u2192\u2080 M} : (subtypeDomain p v) a = v a.val", "start": [1029, 1], "end": [1031, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_zero", "code": "@[simp]\ntheorem subtypeDomain_zero : subtypeDomain p (0 : \u03b1 \u2192\u2080 M) = 0", "start": [1034, 1], "end": [1036, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_eq_zero_iff'", "code": "theorem subtypeDomain_eq_zero_iff' {f : \u03b1 \u2192\u2080 M} : f.subtypeDomain p = 0 \u2194 \u2200 x, p x \u2192 f x = 0", "start": [1039, 1], "end": [1041, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_eq_zero_iff", "code": "theorem subtypeDomain_eq_zero_iff {f : \u03b1 \u2192\u2080 M} (hf : \u2200 x \u2208 f.support, p x) :\n    f.subtypeDomain p = 0 \u2194 f = 0", "start": [1044, 1], "end": [1050, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_subtypeDomain_index", "code": "@[to_additive]\ntheorem prod_subtypeDomain_index [CommMonoid N] {v : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 N}\n    (hp : \u2200 x \u2208 v.support, p x) : ((v.subtypeDomain p).prod fun a b => h a b) = v.prod h", "start": [1053, 1], "end": [1057, 101], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_add", "code": "@[simp]\ntheorem subtypeDomain_add {v v' : \u03b1 \u2192\u2080 M} :\n    (v + v').subtypeDomain p = v.subtypeDomain p + v'.subtypeDomain p", "start": [1067, 1], "end": [1070, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomainAddMonoidHom", "code": "def subtypeDomainAddMonoidHom : (\u03b1 \u2192\u2080 M) \u2192+ Subtype p \u2192\u2080 M\n    where\n  toFun := subtypeDomain p\n  map_zero' := subtypeDomain_zero\n  map_add' _ _ := subtypeDomain_add", "start": [1073, 1], "end": [1078, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filterAddHom", "code": "def filterAddHom (p : \u03b1 \u2192 Prop) : (\u03b1 \u2192\u2080 M) \u2192+ \u03b1 \u2192\u2080 M\n    where\n  toFun := filter p\n  map_zero' := filter_zero p\n  map_add' f g := FunLike.coe_injective <| Set.indicator_add { x | p x } f g", "start": [1081, 1], "end": [1086, 77], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_add", "code": "@[simp]\ntheorem filter_add {v v' : \u03b1 \u2192\u2080 M} : (v + v').filter p = v.filter p + v'.filter p", "start": [1089, 1], "end": [1091, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_sum", "code": "theorem subtypeDomain_sum {s : Finset \u03b9} {h : \u03b9 \u2192 \u03b1 \u2192\u2080 M} :\n    (\u2211 c in s, h c).subtypeDomain p = \u2211 c in s, (h c).subtypeDomain p", "start": [1100, 1], "end": [1102, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_finsupp_sum", "code": "theorem subtypeDomain_finsupp_sum [Zero N] {s : \u03b2 \u2192\u2080 N} {h : \u03b2 \u2192 N \u2192 \u03b1 \u2192\u2080 M} :\n    (s.sum h).subtypeDomain p = s.sum fun c d => (h c d).subtypeDomain p", "start": [1105, 1], "end": [1107, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_sum", "code": "theorem filter_sum (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 M) :\n    (\u2211 a in s, f a).filter p = \u2211 a in s, filter p (f a)", "start": [1110, 1], "end": [1112, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_eq_sum", "code": "theorem filter_eq_sum (p : \u03b1 \u2192 Prop) [D : DecidablePred p] (f : \u03b1 \u2192\u2080 M) :\n    f.filter p = \u2211 i in f.support.filter p, single i (f i)", "start": [1115, 1], "end": [1119, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_neg", "code": "@[simp]\ntheorem subtypeDomain_neg : (-v).subtypeDomain p = -v.subtypeDomain p", "start": [1128, 1], "end": [1130, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subtypeDomain_sub", "code": "@[simp]\ntheorem subtypeDomain_sub : (v - v').subtypeDomain p = v.subtypeDomain p - v'.subtypeDomain p", "start": [1133, 1], "end": [1135, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_neg", "code": "@[simp]\ntheorem single_neg (a : \u03b1) (b : G) : single a (-b) = -single a b", "start": [1138, 1], "end": [1140, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_sub", "code": "@[simp]\ntheorem single_sub (a : \u03b1) (b\u2081 b\u2082 : G) : single a (b\u2081 - b\u2082) = single a b\u2081 - single a b\u2082", "start": [1143, 1], "end": [1145, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_neg", "code": "@[simp]\ntheorem erase_neg (a : \u03b1) (f : \u03b1 \u2192\u2080 G) : erase a (-f) = -erase a f", "start": [1148, 1], "end": [1150, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.erase_sub", "code": "@[simp]\ntheorem erase_sub (a : \u03b1) (f\u2081 f\u2082 : \u03b1 \u2192\u2080 G) : erase a (f\u2081 - f\u2082) = erase a f\u2081 - erase a f\u2082", "start": [1153, 1], "end": [1155, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_neg", "code": "@[simp]\ntheorem filter_neg (p : \u03b1 \u2192 Prop) (f : \u03b1 \u2192\u2080 G) : filter p (-f) = -filter p f", "start": [1158, 1], "end": [1160, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_sub", "code": "@[simp]\ntheorem filter_sub (p : \u03b1 \u2192 Prop) (f\u2081 f\u2082 : \u03b1 \u2192\u2080 G) :\n    filter p (f\u2081 - f\u2082) = filter p f\u2081 - filter p f\u2082", "start": [1163, 1], "end": [1166, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_support_multiset_sum", "code": "theorem mem_support_multiset_sum [AddCommMonoid M] {s : Multiset (\u03b1 \u2192\u2080 M)} (a : \u03b1) :\n    a \u2208 s.sum.support \u2192 \u2203 f \u2208 s, a \u2208 (f : \u03b1 \u2192\u2080 M).support", "start": [1173, 1], "end": [1183, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_support_finset_sum", "code": "theorem mem_support_finset_sum [AddCommMonoid M] {s : Finset \u03b9} {h : \u03b9 \u2192 \u03b1 \u2192\u2080 M} (a : \u03b1)\n    (ha : a \u2208 (\u2211 c in s, h c).support) : \u2203 c \u2208 s, a \u2208 (h c).support", "start": [1186, 1], "end": [1190, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.curry", "code": "protected def curry (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) : \u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M :=\n  f.sum fun p c => single p.1 (single p.2 c)", "start": [1200, 1], "end": [1204, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.curry_apply", "code": "@[simp]\ntheorem curry_apply (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) (x : \u03b1) (y : \u03b2) : f.curry x y = f (x, y)", "start": [1207, 1], "end": [1218, 86], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_curry_index", "code": "theorem sum_curry_index (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) (g : \u03b1 \u2192 \u03b2 \u2192 M \u2192 N) (hg\u2080 : \u2200 a b, g a b 0 = 0)\n    (hg\u2081 : \u2200 a b c\u2080 c\u2081, g a b (c\u2080 + c\u2081) = g a b c\u2080 + g a b c\u2081) :\n    (f.curry.sum fun a f => f.sum (g a)) = f.sum fun p c => g p.1 p.2 c", "start": [1221, 1], "end": [1232, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.uncurry", "code": "protected def uncurry (f : \u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M) : \u03b1 \u00d7 \u03b2 \u2192\u2080 M :=\n  f.sum fun a g => g.sum fun b c => single (a, b) c", "start": [1235, 1], "end": [1239, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finsuppProdEquiv", "code": "def finsuppProdEquiv : (\u03b1 \u00d7 \u03b2 \u2192\u2080 M) \u2243 (\u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M)\n    where\n  toFun := Finsupp.curry\n  invFun := Finsupp.uncurry\n  left_inv f := by\n    rw [Finsupp.uncurry, sum_curry_index]\n    \u00b7 simp_rw [Prod.mk.eta, sum_single]\n    \u00b7 intros\n      apply single_zero\n    \u00b7 intros\n      apply single_add\n  right_inv f := by\n    simp only [Finsupp.curry, Finsupp.uncurry, sum_sum_index, sum_zero_index, sum_add_index,\n      sum_single_index, single_zero, single_add, eq_self_iff_true, forall_true_iff,\n      forall\u2083_true_iff, (single_sum _ _ _).symm, sum_single]", "start": [1242, 1], "end": [1258, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_curry", "code": "theorem filter_curry (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) (p : \u03b1 \u2192 Prop) :\n    (f.filter fun a : \u03b1 \u00d7 \u03b2 => p a.1).curry = f.curry.filter p", "start": [1261, 1], "end": [1271, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_curry", "code": "theorem support_curry [DecidableEq \u03b1] (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) :\n    f.curry.support \u2286 f.support.image Prod.fst", "start": [1274, 1], "end": [1278, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumElim", "code": "def sumElim {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) : Sum \u03b1 \u03b2 \u2192\u2080 \u03b3 :=\n  onFinset\n    (by\n      haveI := Classical.decEq \u03b1\n      haveI := Classical.decEq \u03b2\n      exact f.support.map \u27e8_, Sum.inl_injective\u27e9 \u222a g.support.map \u27e8_, Sum.inr_injective\u27e9)\n    (Sum.elim f g) fun ab h => by\n    cases' ab with a b <;>\n    letI := Classical.decEq \u03b1 <;> letI := Classical.decEq \u03b2 <;>\n    simp only [Sum.elim_inl, Sum.elim_inr] at h <;>\n    simpa", "start": [1288, 1], "end": [1300, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_sumElim", "code": "@[simp]\ntheorem coe_sumElim {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) :\n    \u21d1(sumElim f g) = Sum.elim f g", "start": [1303, 1], "end": [1306, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumElim_apply", "code": "theorem sumElim_apply {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) (x : Sum \u03b1 \u03b2) :\n    sumElim f g x = Sum.elim f g x", "start": [1309, 1], "end": [1311, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumElim_inl", "code": "theorem sumElim_inl {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) (x : \u03b1) :\n    sumElim f g (Sum.inl x) = f x", "start": [1314, 1], "end": [1316, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumElim_inr", "code": "theorem sumElim_inr {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : \u03b1 \u2192\u2080 \u03b3) (g : \u03b2 \u2192\u2080 \u03b3) (x : \u03b2) :\n    sumElim f g (Sum.inr x) = g x", "start": [1319, 1], "end": [1321, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppEquivProdFinsupp", "code": "@[simps apply symm_apply]\ndef sumFinsuppEquivProdFinsupp {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] : (Sum \u03b1 \u03b2 \u2192\u2080 \u03b3) \u2243 (\u03b1 \u2192\u2080 \u03b3) \u00d7 (\u03b2 \u2192\u2080 \u03b3)\n    where\n  toFun f :=\n    \u27e8f.comapDomain Sum.inl (Sum.inl_injective.injOn _),\n      f.comapDomain Sum.inr (Sum.inr_injective.injOn _)\u27e9\n  invFun fg := sumElim fg.1 fg.2\n  left_inv f := by\n    ext ab\n    cases' ab with a b <;> simp\n  right_inv fg := by ext <;> simp", "start": [1324, 1], "end": [1337, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.fst_sumFinsuppEquivProdFinsupp", "code": "theorem fst_sumFinsuppEquivProdFinsupp {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : Sum \u03b1 \u03b2 \u2192\u2080 \u03b3) (x : \u03b1) :\n    (sumFinsuppEquivProdFinsupp f).1 x = f (Sum.inl x)", "start": [1340, 1], "end": [1342, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.snd_sumFinsuppEquivProdFinsupp", "code": "theorem snd_sumFinsuppEquivProdFinsupp {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (f : Sum \u03b1 \u03b2 \u2192\u2080 \u03b3) (y : \u03b2) :\n    (sumFinsuppEquivProdFinsupp f).2 y = f (Sum.inr y)", "start": [1345, 1], "end": [1347, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppEquivProdFinsupp_symm_inl", "code": "theorem sumFinsuppEquivProdFinsupp_symm_inl {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (fg : (\u03b1 \u2192\u2080 \u03b3) \u00d7 (\u03b2 \u2192\u2080 \u03b3))\n    (x : \u03b1) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x", "start": [1350, 1], "end": [1352, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppEquivProdFinsupp_symm_inr", "code": "theorem sumFinsuppEquivProdFinsupp_symm_inr {\u03b1 \u03b2 \u03b3 : Type*} [Zero \u03b3] (fg : (\u03b1 \u2192\u2080 \u03b3) \u00d7 (\u03b2 \u2192\u2080 \u03b3))\n    (y : \u03b2) : (sumFinsuppEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y", "start": [1355, 1], "end": [1357, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppAddEquivProdFinsupp", "code": "@[simps! apply symm_apply]\ndef sumFinsuppAddEquivProdFinsupp {\u03b1 \u03b2 : Type*} : (Sum \u03b1 \u03b2 \u2192\u2080 M) \u2243+ (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M) :=\n  { sumFinsuppEquivProdFinsupp with\n    map_add' := by\n      intros\n      ext <;>\n        simp only [Equiv.toFun_as_coe, Prod.fst_add, Prod.snd_add, add_apply,\n          snd_sumFinsuppEquivProdFinsupp, fst_sumFinsuppEquivProdFinsupp] }", "start": [1362, 1], "end": [1372, 76], "kind": "commanddeclaration"}, {"full_name": "Finsupp.fst_sumFinsuppAddEquivProdFinsupp", "code": "theorem fst_sumFinsuppAddEquivProdFinsupp {\u03b1 \u03b2 : Type*} (f : Sum \u03b1 \u03b2 \u2192\u2080 M) (x : \u03b1) :\n    (sumFinsuppAddEquivProdFinsupp f).1 x = f (Sum.inl x)", "start": [1375, 1], "end": [1377, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.snd_sumFinsuppAddEquivProdFinsupp", "code": "theorem snd_sumFinsuppAddEquivProdFinsupp {\u03b1 \u03b2 : Type*} (f : Sum \u03b1 \u03b2 \u2192\u2080 M) (y : \u03b2) :\n    (sumFinsuppAddEquivProdFinsupp f).2 y = f (Sum.inr y)", "start": [1380, 1], "end": [1382, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inl", "code": "theorem sumFinsuppAddEquivProdFinsupp_symm_inl {\u03b1 \u03b2 : Type*} (fg : (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M)) (x : \u03b1) :\n    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inl x) = fg.1 x", "start": [1385, 1], "end": [1387, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppAddEquivProdFinsupp_symm_inr", "code": "theorem sumFinsuppAddEquivProdFinsupp_symm_inr {\u03b1 \u03b2 : Type*} (fg : (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M)) (y : \u03b2) :\n    (sumFinsuppAddEquivProdFinsupp.symm fg) (Sum.inr y) = fg.2 y", "start": [1390, 1], "end": [1392, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_smul", "code": "@[simp]\ntheorem single_smul (a b : \u03b1) (f : \u03b1 \u2192 M) (r : R) : single a r b \u2022 f a = single a (r \u2022 f b) b", "start": [1404, 1], "end": [1406, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapSMul", "code": "def comapSMul : SMul G (\u03b1 \u2192\u2080 M) where smul g := mapDomain ((\u00b7 \u2022 \u00b7) g)", "start": [1415, 1], "end": [1419, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapSMul_def", "code": "theorem comapSMul_def (g : G) (f : \u03b1 \u2192\u2080 M) : g \u2022 f = mapDomain ((\u00b7 \u2022 \u00b7) g) f", "start": [1424, 1], "end": [1425, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapSMul_single", "code": "@[simp]\ntheorem comapSMul_single (g : G) (a : \u03b1) (b : M) : g \u2022 single a b = single (g \u2022 a) b", "start": [1428, 1], "end": [1430, 19], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapMulAction", "code": "def comapMulAction : MulAction G (\u03b1 \u2192\u2080 M)\n    where\n  one_smul f := by rw [comapSMul_def, one_smul_eq_id, mapDomain_id]\n  mul_smul g g' f := by\n    rw [comapSMul_def, comapSMul_def, comapSMul_def, \u2190 comp_smul_left, mapDomain_comp]", "start": [1433, 1], "end": [1438, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDistribMulAction", "code": "def comapDistribMulAction : DistribMulAction G (\u03b1 \u2192\u2080 M)\n    where\n  smul_zero g := by\n    ext a\n    simp only [comapSMul_def]\n    simp\n  smul_add g f f' := by\n    ext\n    simp only [comapSMul_def]\n    simp [mapDomain_add]", "start": [1443, 1], "end": [1453, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapSMul_apply", "code": "@[simp]\ntheorem comapSMul_apply (g : G) (f : \u03b1 \u2192\u2080 M) (a : \u03b1) : (g \u2022 f) a = f (g\u207b\u00b9 \u2022 a)", "start": [1464, 1], "end": [1469, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smulZeroClass", "code": "instance smulZeroClass [Zero M] [SMulZeroClass R M] : SMulZeroClass R (\u03b1 \u2192\u2080 M) where\n  smul a v := v.mapRange ((\u00b7 \u2022 \u00b7) a) (smul_zero _)\n  smul_zero a := by\n    ext\n    apply smul_zero", "start": [1476, 1], "end": [1480, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_smul", "code": "@[simp]\ntheorem coe_smul [Zero M] [SMulZeroClass R M] (b : R) (v : \u03b1 \u2192\u2080 M) : \u21d1(b \u2022 v) = b \u2022 \u21d1v", "start": [1488, 1], "end": [1490, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smul_apply", "code": "theorem smul_apply [Zero M] [SMulZeroClass R M] (b : R) (v : \u03b1 \u2192\u2080 M) (a : \u03b1) :\n    (b \u2022 v) a = b \u2022 v a", "start": [1493, 1], "end": [1495, 6], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.finsupp", "code": "theorem _root_.IsSMulRegular.finsupp [Zero M] [SMulZeroClass R M] {k : R}\n    (hk : IsSMulRegular M k) : IsSMulRegular (\u03b1 \u2192\u2080 M) k", "start": [1498, 1], "end": [1500, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.faithfulSMul", "code": "instance faithfulSMul [Nonempty \u03b1] [Zero M] [SMulZeroClass R M] [FaithfulSMul R M] :\n    FaithfulSMul R (\u03b1 \u2192\u2080 M) where\n  eq_of_smul_eq_smul h :=\n    let \u27e8a\u27e9 := \u2039Nonempty \u03b1\u203a\n    eq_of_smul_eq_smul fun m : M => by simpa using FunLike.congr_fun (h (single a m)) a", "start": [1503, 1], "end": [1507, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.distribSMul", "code": "instance distribSMul [AddZeroClass M] [DistribSMul R M] : DistribSMul R (\u03b1 \u2192\u2080 M) where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_add _ _ _ := ext fun _ => smul_add _ _ _\n  smul_zero _ := ext fun _ => smul_zero _", "start": [1512, 1], "end": [1515, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.distribMulAction", "code": "instance distribMulAction [Monoid R] [AddMonoid M] [DistribMulAction R M] :\n    DistribMulAction R (\u03b1 \u2192\u2080 M) :=\n  { Finsupp.distribSMul _ _ with\n    one_smul := fun x => ext fun y => one_smul R (x y)\n    mul_smul := fun r s x => ext fun y => mul_smul r s (x y) }", "start": [1518, 1], "end": [1522, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.isScalarTower", "code": "instance isScalarTower [Zero M] [SMulZeroClass R M] [SMulZeroClass S M] [SMul R S]\n  [IsScalarTower R S M] : IsScalarTower R S (\u03b1 \u2192\u2080 M) where\n  smul_assoc _ _ _ := ext fun _ => smul_assoc _ _ _", "start": [1525, 1], "end": [1527, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smulCommClass", "code": "instance smulCommClass [Zero M] [SMulZeroClass R M] [SMulZeroClass S M] [SMulCommClass R S M] :\n  SMulCommClass R S (\u03b1 \u2192\u2080 M) where\n  smul_comm _ _ _ := ext fun _ => smul_comm _ _ _", "start": [1529, 1], "end": [1531, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.isCentralScalar", "code": "instance isCentralScalar [Zero M] [SMulZeroClass R M] [SMulZeroClass R\u1d50\u1d52\u1d56 M] [IsCentralScalar R M] :\n  IsCentralScalar R (\u03b1 \u2192\u2080 M) where\n  op_smul_eq_smul _ _ := ext fun _ => op_smul_eq_smul _ _", "start": [1534, 1], "end": [1536, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.module", "code": "instance module [Semiring R] [AddCommMonoid M] [Module R M] : Module R (\u03b1 \u2192\u2080 M) :=\n  { toDistribMulAction := Finsupp.distribMulAction \u03b1 M\n    zero_smul := fun _ => ext fun _ => zero_smul _ _\n    add_smul := fun _ _ _ => ext fun _ => add_smul _ _ _ }", "start": [1539, 1], "end": [1542, 59], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_smul", "code": "theorem support_smul [AddMonoid M] [SMulZeroClass R M] {b : R} {g : \u03b1 \u2192\u2080 M} :\n    (b \u2022 g).support \u2286 g.support", "start": [1547, 1], "end": [1550, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_smul_eq", "code": "@[simp]\ntheorem support_smul_eq [Semiring R] [AddCommMonoid M] [Module R M] [NoZeroSMulDivisors R M] {b : R}\n    (hb : b \u2260 0) {g : \u03b1 \u2192\u2080 M} : (b \u2022 g).support = g.support", "start": [1553, 1], "end": [1556, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.filter_smul", "code": "@[simp]\ntheorem filter_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] {b : R} {v : \u03b1 \u2192\u2080 M} :\n    (b \u2022 v).filter p = b \u2022 v.filter p", "start": [1563, 1], "end": [1566, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapDomain_smul", "code": "theorem mapDomain_smul {_ : Monoid R} [AddCommMonoid M] [DistribMulAction R M] {f : \u03b1 \u2192 \u03b2} (b : R)\n    (v : \u03b1 \u2192\u2080 M) : mapDomain f (b \u2022 v) = b \u2022 mapDomain f v", "start": [1571, 1], "end": [1573, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smul_single", "code": "@[simp]\ntheorem smul_single [Zero M] [SMulZeroClass R M] (c : R) (a : \u03b1) (b : M) :\n    c \u2022 Finsupp.single a b = Finsupp.single a (c \u2022 b)", "start": [1576, 1], "end": [1579, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smul_single'", "code": "theorem smul_single' {_ : Semiring R} (c : R) (a : \u03b1) (b : R) :\n    c \u2022 Finsupp.single a b = Finsupp.single a (c * b)", "start": [1583, 1], "end": [1585, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange_smul", "code": "theorem mapRange_smul {_ : Monoid R} [AddMonoid M] [DistribMulAction R M] [AddMonoid N]\n    [DistribMulAction R N] {f : M \u2192 N} {hf : f 0 = 0} (c : R) (v : \u03b1 \u2192\u2080 M)\n    (hsmul : \u2200 x, f (c \u2022 x) = c \u2022 f x) : mapRange f hf (c \u2022 v) = c \u2022 mapRange f hf v", "start": [1588, 1], "end": [1595, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.smul_single_one", "code": "theorem smul_single_one [Semiring R] (a : \u03b1) (b : R) : b \u2022 single a (1 : R) = single a b", "start": [1598, 1], "end": [1599, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_smul", "code": "theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : \u03b1 \u2192 \u03b2} (r : R)\n    (v : \u03b2 \u2192\u2080 M) (hfv : Set.InjOn f (f \u207b\u00b9' \u2191v.support))\n    (hfrv : Set.InjOn f (f \u207b\u00b9' \u2191(r \u2022 v).support) :=\n      hfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\n    comapDomain f (r \u2022 v) hfrv = r \u2022 comapDomain f v hfv", "start": [1602, 1], "end": [1608, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.comapDomain_smul_of_injective", "code": "theorem comapDomain_smul_of_injective [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (r : R) (v : \u03b2 \u2192\u2080 M) :\n    comapDomain f (r \u2022 v) (hf.injOn _) = r \u2022 comapDomain f v (hf.injOn _)", "start": [1611, 1], "end": [1615, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_smul_index", "code": "theorem sum_smul_index [Semiring R] [AddCommMonoid M] {g : \u03b1 \u2192\u2080 R} {b : R} {h : \u03b1 \u2192 R \u2192 M}\n    (h0 : \u2200 i, h i 0 = 0) : (b \u2022 g).sum h = g.sum fun i a => h i (b * a)", "start": [1620, 1], "end": [1622, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_smul_index'", "code": "theorem sum_smul_index' [AddMonoid M] [DistribSMul R M] [AddCommMonoid N] {g : \u03b1 \u2192\u2080 M} {b : R}\n    {h : \u03b1 \u2192 M \u2192 N} (h0 : \u2200 i, h i 0 = 0) : (b \u2022 g).sum h = g.sum fun i c => h i (b \u2022 c)", "start": [1625, 1], "end": [1627, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_smul_index_addMonoidHom", "code": "theorem sum_smul_index_addMonoidHom [AddMonoid M] [AddCommMonoid N] [DistribSMul R M] {g : \u03b1 \u2192\u2080 M}\n    {b : R} {h : \u03b1 \u2192 M \u2192+ N} : ((b \u2022 g).sum fun a => h a) = g.sum fun i c => h i (b \u2022 c)", "start": [1630, 1], "end": [1633, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors [Semiring R] [AddCommMonoid M] [Module R M] {\u03b9 : Type*}\n    [NoZeroSMulDivisors R M] : NoZeroSMulDivisors R (\u03b9 \u2192\u2080 M) :=\n  \u27e8fun h =>\n    or_iff_not_imp_left.mpr fun hc =>\n      Finsupp.ext fun i => (smul_eq_zero.mp (FunLike.ext_iff.mp h i)).resolve_left hc\u27e9", "start": [1636, 1], "end": [1640, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.DistribMulActionHom.single", "code": "def DistribMulActionHom.single (a : \u03b1) : M \u2192+[R] \u03b1 \u2192\u2080 M :=\n  { singleAddHom a with\n    map_smul' := fun k m => by\n      simp only\n      show singleAddHom a (k \u2022 m) = k \u2022 singleAddHom a m\n      change Finsupp.single a (k \u2022 m) = k \u2022 (Finsupp.single a m)\n      simp only [smul_single] }", "start": [1649, 1], "end": [1659, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.distribMulActionHom_ext", "code": "theorem distribMulActionHom_ext {f g : (\u03b1 \u2192\u2080 M) \u2192+[R] N}\n    (h : \u2200 (a : \u03b1) (m : M), f (single a m) = g (single a m)) : f = g", "start": [1662, 1], "end": [1664, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.distribMulActionHom_ext'", "code": "@[ext]\ntheorem distribMulActionHom_ext' {f g : (\u03b1 \u2192\u2080 M) \u2192+[R] N}\n    (h : \u2200 a : \u03b1, f.comp (DistribMulActionHom.single a) = g.comp (DistribMulActionHom.single a)) :\n    f = g", "start": [1667, 1], "end": [1672, 71], "kind": "commanddeclaration"}, {"full_name": "Finsupp.uniqueOfRight", "code": "instance uniqueOfRight [Subsingleton R] : Unique (\u03b1 \u2192\u2080 R) :=\n  FunLike.coe_injective.unique", "start": [1681, 1], "end": [1683, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.uniqueOfLeft", "code": "instance uniqueOfLeft [IsEmpty \u03b1] : Unique (\u03b1 \u2192\u2080 R) :=\n  FunLike.coe_injective.unique", "start": [1686, 1], "end": [1688, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.restrictSupportEquiv", "code": "def restrictSupportEquiv (s : Set \u03b1) (M : Type*) [AddCommMonoid M] :\n    { f : \u03b1 \u2192\u2080 M // \u2191f.support \u2286 s } \u2243 (s \u2192\u2080 M) where\n  toFun f := subtypeDomain (fun x => x \u2208 s) f.1\n  invFun f :=\n    \u27e8f.embDomain <| Embedding.subtype _, by\n      rw [support_embDomain, Finset.coe_map, Set.image_subset_iff]\n      exact fun x _ => x.2\u27e9\n  left_inv := by\n    rintro \u27e8f, hf\u27e9\n    ext a\n    by_cases h : a \u2208 s\n    \u00b7 lift a to s using h\n      exact embDomain_apply _ _ _\n    rw [embDomain_notin_range, eq_comm, \u2190Finsupp.not_mem_support_iff]\n    \u00b7 exact fun hs => h <| hf hs\n    \u00b7 simp [h]\n  right_inv f := ext <| embDomain_apply _ f", "start": [1693, 1], "end": [1712, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domCongr", "code": "@[simps apply]\nprotected def domCongr [AddCommMonoid M] (e : \u03b1 \u2243 \u03b2) : (\u03b1 \u2192\u2080 M) \u2243+ (\u03b2 \u2192\u2080 M)\n    where\n  toFun := equivMapDomain e\n  invFun := equivMapDomain e.symm\n  left_inv v := by\n    simp only [\u2190 equivMapDomain_trans, Equiv.self_trans_symm]\n    exact equivMapDomain_refl _\n  right_inv := by\n    intro v\n    simp only [\u2190 equivMapDomain_trans, Equiv.symm_trans_self]\n    exact equivMapDomain_refl _\n  map_add' a b := by simp only [equivMapDomain_eq_mapDomain]; exact mapDomain_add", "start": [1715, 1], "end": [1731, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domCongr_refl", "code": "@[simp]\ntheorem domCongr_refl [AddCommMonoid M] :\n    Finsupp.domCongr (Equiv.refl \u03b1) = AddEquiv.refl (\u03b1 \u2192\u2080 M)", "start": [1734, 1], "end": [1737, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domCongr_symm", "code": "@[simp]\ntheorem domCongr_symm [AddCommMonoid M] (e : \u03b1 \u2243 \u03b2) :\n    (Finsupp.domCongr e).symm = (Finsupp.domCongr e.symm : (\u03b2 \u2192\u2080 M) \u2243+ (\u03b1 \u2192\u2080 M))", "start": [1740, 1], "end": [1743, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domCongr_trans", "code": "@[simp]\ntheorem domCongr_trans [AddCommMonoid M] (e : \u03b1 \u2243 \u03b2) (f : \u03b2 \u2243 \u03b3) :\n    (Finsupp.domCongr e).trans (Finsupp.domCongr f) =\n      (Finsupp.domCongr (e.trans f) : (\u03b1 \u2192\u2080 M) \u2243+ _)", "start": [1746, 1], "end": [1750, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.split", "code": "def split (i : \u03b9) : \u03b1s i \u2192\u2080 M :=\n  l.comapDomain (Sigma.mk i) fun _ _ _ _ hx => heq_iff_eq.1 (Sigma.mk.inj_iff.mp hx).2", "start": [1764, 1], "end": [1771, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.split_apply", "code": "theorem split_apply (i : \u03b9) (x : \u03b1s i) : split l i x = l \u27e8i, x\u27e9", "start": [1775, 1], "end": [1777, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.splitSupport", "code": "def splitSupport (l : (\u03a3i, \u03b1s i) \u2192\u2080 M) : Finset \u03b9 :=\n  haveI := Classical.decEq \u03b9\n  l.support.image Sigma.fst", "start": [1780, 1], "end": [1784, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_splitSupport_iff_nonzero", "code": "theorem mem_splitSupport_iff_nonzero (i : \u03b9) : i \u2208 splitSupport l \u2194 split l i \u2260 0", "start": [1787, 1], "end": [1792, 26], "kind": "commanddeclaration"}, {"full_name": "Finsupp.splitComp", "code": "def splitComp [Zero N] (g : \u2200 i, (\u03b1s i \u2192\u2080 M) \u2192 N) (hg : \u2200 i x, x = 0 \u2194 g i x = 0) : \u03b9 \u2192\u2080 N\n    where\n  support := splitSupport l\n  toFun i := g i (split l i)\n  mem_support_toFun := by\n    intro i\n    rw [mem_splitSupport_iff_nonzero, not_iff_not, hg]", "start": [1795, 1], "end": [1805, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigma_support", "code": "theorem sigma_support : l.support = l.splitSupport.sigma fun i => (l.split i).support", "start": [1808, 1], "end": [1812, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigma_sum", "code": "theorem sigma_sum [AddCommMonoid N] (f : (\u03a3i : \u03b9, \u03b1s i) \u2192 M \u2192 N) :\n    l.sum f = \u2211 i in splitSupport l, (split l i).sum fun (a : \u03b1s i) b => f \u27e8i, a\u27e9 b", "start": [1815, 1], "end": [1817, 57], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppEquivPiFinsupp", "code": "noncomputable def sigmaFinsuppEquivPiFinsupp : ((\u03a3j, \u03b9s j) \u2192\u2080 \u03b1) \u2243 \u2200 j, \u03b9s j \u2192\u2080 \u03b1\n    where\n  toFun := split\n  invFun f :=\n    onFinset (Finset.univ.sigma fun j => (f j).support) (fun ji => f ji.1 ji.2) fun g hg =>\n      Finset.mem_sigma.mpr \u27e8Finset.mem_univ _, mem_support_iff.mpr hg\u27e9\n  left_inv f := by\n    ext\n    simp [split]\n  right_inv f := by\n    ext\n    simp [split]", "start": [1822, 1], "end": [1837, 17], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppEquivPiFinsupp_apply", "code": "@[simp]\ntheorem sigmaFinsuppEquivPiFinsupp_apply (f : (\u03a3j, \u03b9s j) \u2192\u2080 \u03b1) (j i) :\n    sigmaFinsuppEquivPiFinsupp f j i = f \u27e8j, i\u27e9", "start": [1840, 1], "end": [1843, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppAddEquivPiFinsupp", "code": "noncomputable def sigmaFinsuppAddEquivPiFinsupp {\u03b1 : Type*} {\u03b9s : \u03b7 \u2192 Type*} [AddMonoid \u03b1] :\n    ((\u03a3j, \u03b9s j) \u2192\u2080 \u03b1) \u2243+ \u2200 j, \u03b9s j \u2192\u2080 \u03b1 :=\n  { sigmaFinsuppEquivPiFinsupp with\n    map_add' := fun f g => by\n      ext\n      simp }", "start": [1846, 1], "end": [1856, 13], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppAddEquivPiFinsupp_apply", "code": "@[simp]\ntheorem sigmaFinsuppAddEquivPiFinsupp_apply {\u03b1 : Type*} {\u03b9s : \u03b7 \u2192 Type*} [AddMonoid \u03b1]\n    (f : (\u03a3j, \u03b9s j) \u2192\u2080 \u03b1) (j i) : sigmaFinsuppAddEquivPiFinsupp f j i = f \u27e8j, i\u27e9", "start": [1859, 1], "end": [1862, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Submodule/Lattice.lean", "imports": ["Mathlib/Algebra/Module/Submodule/Basic.lean", "Mathlib/Algebra/PUnitInstances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.inhabited'", "code": "instance inhabited' : Inhabited (Submodule R M) :=\n  \u27e8\u22a5\u27e9", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.bot_coe", "code": "@[simp]\ntheorem bot_coe : ((\u22a5 : Submodule R M) : Set M) = {0}", "start": [56, 1], "end": [58, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.bot_toAddSubmonoid", "code": "@[simp]\ntheorem bot_toAddSubmonoid : (\u22a5 : Submodule R M).toAddSubmonoid = \u22a5", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_bot", "code": "@[simp]\ntheorem restrictScalars_bot : restrictScalars S (\u22a5 : Submodule R M) = \u22a5", "start": [70, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_bot", "code": "@[simp]\ntheorem mem_bot {x : M} : x \u2208 (\u22a5 : Submodule R M) \u2194 x = 0", "start": [75, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_eq_bot_iff", "code": "@[simp]\ntheorem restrictScalars_eq_bot_iff {p : Submodule R M} : restrictScalars S p = \u22a5 \u2194 p = \u22a5", "start": [82, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.uniqueBot", "code": "instance uniqueBot : Unique (\u22a5 : Submodule R M) :=\n  \u27e8inferInstance, fun x \u21a6 Subtype.ext <| (mem_bot R).1 x.mem\u27e9", "start": [87, 1], "end": [88, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_bot_iff", "code": "protected theorem eq_bot_iff (p : Submodule R M) : p = \u22a5 \u2194 \u2200 x \u2208 p, x = (0 : M)", "start": [95, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.bot_ext", "code": "@[ext high]\nprotected theorem bot_ext (x y : (\u22a5 : Submodule R M)) : x = y", "start": [100, 1], "end": [104, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.ne_bot_iff", "code": "protected theorem ne_bot_iff (p : Submodule R M) : p \u2260 \u22a5 \u2194 \u2203 x \u2208 p, x \u2260 (0 : M)", "start": [107, 1], "end": [108, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.nonzero_mem_of_bot_lt", "code": "theorem nonzero_mem_of_bot_lt {p : Submodule R M} (bot_lt : \u22a5 < p) : \u2203 a : p, a \u2260 0", "start": [111, 1], "end": [113, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_mem_ne_zero_of_ne_bot", "code": "theorem exists_mem_ne_zero_of_ne_bot {p : Submodule R M} (h : p \u2260 \u22a5) : \u2203 b : M, b \u2208 p \u2227 b \u2260 0", "start": [116, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.botEquivPUnit", "code": "@[simps]\ndef botEquivPUnit : (\u22a5 : Submodule R M) \u2243\u2097[R] PUnit.{v+1} where\n  toFun _ := PUnit.unit\n  invFun _ := 0\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := Subsingleton.elim _ _\n  right_inv _ := rfl", "start": [122, 1], "end": [130, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_bot_of_subsingleton", "code": "theorem eq_bot_of_subsingleton (p : Submodule R M) [Subsingleton p] : p = \u22a5", "start": [133, 1], "end": [136, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.top_coe", "code": "@[simp]\ntheorem top_coe : ((\u22a4 : Submodule R M) : Set M) = Set.univ", "start": [149, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.top_toAddSubmonoid", "code": "@[simp]\ntheorem top_toAddSubmonoid : (\u22a4 : Submodule R M).toAddSubmonoid = \u22a4", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_top", "code": "@[simp]\ntheorem mem_top {x : M} : x \u2208 (\u22a4 : Submodule R M)", "start": [159, 1], "end": [161, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_top", "code": "@[simp]\ntheorem restrictScalars_top : restrictScalars S (\u22a4 : Submodule R M) = \u22a4", "start": [168, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_eq_top_iff", "code": "@[simp]\ntheorem restrictScalars_eq_top_iff {p : Submodule R M} : restrictScalars S p = \u22a4 \u2194 p = \u22a4", "start": [175, 1], "end": [177, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_top_iff'", "code": "theorem eq_top_iff' {p : Submodule R M} : p = \u22a4 \u2194 \u2200 x, x \u2208 p", "start": [184, 1], "end": [185, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.topEquiv", "code": "@[simps]\ndef topEquiv : (\u22a4 : Submodule R M) \u2243\u2097[R] M where\n  toFun x := x\n  invFun x := \u27e8x, mem_top\u27e9\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [188, 1], "end": [198, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.sInf_le'", "code": "private theorem sInf_le' {S : Set (Submodule R M)} {p} : p \u2208 S \u2192 sInf S \u2264 p", "start": [212, 1], "end": [213, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_sInf'", "code": "private theorem le_sInf' {S : Set (Submodule R M)} {p} : (\u2200 q \u2208 S, p \u2264 q) \u2192 p \u2264 sInf S", "start": [215, 1], "end": [216, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.completeLattice", "code": "instance completeLattice : CompleteLattice (Submodule R M) :=\n  { (inferInstance : OrderTop (Submodule R M)),\n    (inferInstance : OrderBot (Submodule R M)) with\n    sup := fun a b \u21a6 sInf { x | a \u2264 x \u2227 b \u2264 x }\n    le_sup_left := fun _ _ \u21a6 le_sInf' fun _ \u27e8h, _\u27e9 \u21a6 h\n    le_sup_right := fun _ _ \u21a6 le_sInf' fun _ \u27e8_, h\u27e9 \u21a6 h\n    sup_le := fun _ _ _ h\u2081 h\u2082 \u21a6 sInf_le' \u27e8h\u2081, h\u2082\u27e9\n    inf := (\u00b7 \u2293 \u00b7)\n    le_inf := fun _ _ _ \u21a6 Set.subset_inter\n    inf_le_left := fun _ _ \u21a6 Set.inter_subset_left _ _\n    inf_le_right := fun _ _ \u21a6 Set.inter_subset_right _ _\n    le_sSup := fun _ _ hs \u21a6 le_sInf' fun _ hq \u21a6 by exact hq _ hs\n    sSup_le := fun _ _ hs \u21a6 sInf_le' hs\n    le_sInf := fun _ _ \u21a6 le_sInf'\n    sInf_le := fun _ _ \u21a6 sInf_le' }", "start": [225, 1], "end": [239, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.inf_coe", "code": "@[simp]\ntheorem inf_coe : \u2191(p \u2293 q) = (p \u2229 q : Set M)", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_inf", "code": "@[simp]\ntheorem mem_inf {p q : Submodule R M} {x : M} : x \u2208 p \u2293 q \u2194 x \u2208 p \u2227 x \u2208 q", "start": [247, 1], "end": [249, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.sInf_coe", "code": "@[simp]\ntheorem sInf_coe (P : Set (Submodule R M)) : (\u2191(sInf P) : Set M) = \u22c2 p \u2208 P, \u2191p", "start": [252, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.finset_inf_coe", "code": "@[simp]\ntheorem finset_inf_coe {\u03b9} (s : Finset \u03b9) (p : \u03b9 \u2192 Submodule R M) :\n    (\u2191(s.inf p) : Set M) = \u22c2 i \u2208 s, \u2191(p i)", "start": [257, 1], "end": [264, 9], "kind": "commanddeclaration"}, {"full_name": "Submodule.iInf_coe", "code": "@[simp]\ntheorem iInf_coe {\u03b9} (p : \u03b9 \u2192 Submodule R M) : (\u2191(\u2a05 i, p i) : Set M) = \u22c2 i, \u2191(p i)", "start": [267, 1], "end": [269, 91], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sInf", "code": "@[simp]\ntheorem mem_sInf {S : Set (Submodule R M)} {x : M} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [272, 1], "end": [274, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iInf", "code": "@[simp]\ntheorem mem_iInf {\u03b9} (p : \u03b9 \u2192 Submodule R M) {x} : (x \u2208 \u2a05 i, p i) \u2194 \u2200 i, x \u2208 p i", "start": [277, 1], "end": [279, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_finset_inf", "code": "@[simp]\ntheorem mem_finset_inf {\u03b9} {s : Finset \u03b9} {p : \u03b9 \u2192 Submodule R M} {x : M} :\n    x \u2208 s.inf p \u2194 \u2200 i \u2208 s, x \u2208 p i", "start": [282, 1], "end": [285, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sup_left", "code": "theorem mem_sup_left {S T : Submodule R M} : \u2200 {x : M}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [288, 1], "end": [291, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sup_right", "code": "theorem mem_sup_right {S T : Submodule R M} : \u2200 {x : M}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [294, 1], "end": [297, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.add_mem_sup", "code": "theorem add_mem_sup {S T : Submodule R M} {s t : M} (hs : s \u2208 S) (ht : t \u2208 T) : s + t \u2208 S \u2294 T", "start": [300, 1], "end": [301, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.sub_mem_sup", "code": "theorem sub_mem_sup {R' M' : Type*} [Ring R'] [AddCommGroup M'] [Module R' M']\n    {S T : Submodule R' M'} {s t : M'} (hs : s \u2208 S) (ht : t \u2208 T) : s - t \u2208 S \u2294 T", "start": [304, 1], "end": [307, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_of_mem", "code": "theorem mem_iSup_of_mem {\u03b9 : Sort*} {b : M} {p : \u03b9 \u2192 Submodule R M} (i : \u03b9) (h : b \u2208 p i) :\n    b \u2208 \u2a06 i, p i", "start": [310, 1], "end": [312, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.sum_mem_iSup", "code": "theorem sum_mem_iSup {\u03b9 : Type*} [Fintype \u03b9] {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 Submodule R M}\n    (h : \u2200 i, f i \u2208 p i) : (\u2211 i, f i) \u2208 \u2a06 i, p i", "start": [317, 1], "end": [319, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.sum_mem_biSup", "code": "theorem sum_mem_biSup {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 M} {p : \u03b9 \u2192 Submodule R M}\n    (h : \u2200 i \u2208 s, f i \u2208 p i) : (\u2211 i in s, f i) \u2208 \u2a06 i \u2208 s, p i", "start": [322, 1], "end": [324, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sSup_of_mem", "code": "theorem mem_sSup_of_mem {S : Set (Submodule R M)} {s : Submodule R M} (hs : s \u2208 S) :\n    \u2200 {x : M}, x \u2208 s \u2192 x \u2208 sSup S", "start": [330, 1], "end": [334, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.subsingleton_iff", "code": "@[simp]\ntheorem subsingleton_iff : Subsingleton (Submodule R M) \u2194 Subsingleton M", "start": [339, 1], "end": [344, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.nontrivial_iff", "code": "@[simp]\ntheorem nontrivial_iff : Nontrivial (Submodule R M) \u2194 Nontrivial M", "start": [347, 1], "end": [351, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.unique'", "code": "instance unique' [Subsingleton R] : Unique (Submodule R M) := by\n  haveI := Module.subsingleton R M; infer_instance", "start": [359, 1], "end": [360, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.disjoint_def", "code": "theorem disjoint_def {p p' : Submodule R M} : Disjoint p p' \u2194 \u2200 x \u2208 p, x \u2208 p' \u2192 x = (0 : M)", "start": [370, 1], "end": [371, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.disjoint_def'", "code": "theorem disjoint_def' {p p' : Submodule R M} :\n    Disjoint p p' \u2194 \u2200 x \u2208 p, \u2200 y \u2208 p', x = y \u2192 x = (0 : M)", "start": [374, 1], "end": [377, 87], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_zero_of_coe_mem_of_disjoint", "code": "theorem eq_zero_of_coe_mem_of_disjoint (hpq : Disjoint p q) {a : p} (ha : (a : M) \u2208 q) : a = 0", "start": [380, 1], "end": [381, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_right_iff_eq_zero_of_disjoint", "code": "theorem mem_right_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p} :\n    (x : M) \u2208 p' \u2194 x = 0", "start": [384, 1], "end": [386, 88], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_left_iff_eq_zero_of_disjoint", "code": "theorem mem_left_iff_eq_zero_of_disjoint {p p' : Submodule R M} (h : Disjoint p p') {x : p'} :\n    (x : M) \u2208 p \u2194 x = 0", "start": [389, 1], "end": [391, 87], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toNatSubmodule", "code": "def AddSubmonoid.toNatSubmodule : AddSubmonoid M \u2243o Submodule \u2115 M where\n  toFun S := { S with smul_mem' := fun r s hs \u21a6 show r \u2022 s \u2208 S from nsmul_mem hs _ }\n  invFun := Submodule.toAddSubmonoid\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl", "start": [403, 1], "end": [409, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toNatSubmodule_symm", "code": "@[simp]\ntheorem AddSubmonoid.toNatSubmodule_symm :\n    \u21d1(AddSubmonoid.toNatSubmodule.symm : _ \u2243o AddSubmonoid M) = Submodule.toAddSubmonoid", "start": [412, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.coe_toNatSubmodule", "code": "@[simp]\ntheorem AddSubmonoid.coe_toNatSubmodule (S : AddSubmonoid M) :\n    (AddSubmonoid.toNatSubmodule S : Set M) = S", "start": [418, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.toNatSubmodule_toAddSubmonoid", "code": "@[simp]\ntheorem AddSubmonoid.toNatSubmodule_toAddSubmonoid (S : AddSubmonoid M) :\n    S.toNatSubmodule.toAddSubmonoid = S", "start": [424, 1], "end": [427, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubmonoid_toNatSubmodule", "code": "@[simp]\ntheorem Submodule.toAddSubmonoid_toNatSubmodule (S : Submodule \u2115 M) :\n    AddSubmonoid.toNatSubmodule S.toAddSubmonoid = S", "start": [430, 1], "end": [433, 49], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toIntSubmodule", "code": "def AddSubgroup.toIntSubmodule : AddSubgroup M \u2243o Submodule \u2124 M where\n  toFun S := { S with smul_mem' := fun _ _ hs \u21a6 S.zsmul_mem hs _ }\n  invFun := Submodule.toAddSubgroup\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_rel_iff' := Iff.rfl", "start": [449, 1], "end": [455, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toIntSubmodule_symm", "code": "@[simp]\ntheorem AddSubgroup.toIntSubmodule_symm :\n    \u21d1(AddSubgroup.toIntSubmodule.symm : _ \u2243o AddSubgroup M) = Submodule.toAddSubgroup", "start": [458, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.coe_toIntSubmodule", "code": "@[simp]\ntheorem AddSubgroup.coe_toIntSubmodule (S : AddSubgroup M) :\n    (AddSubgroup.toIntSubmodule S : Set M) = S", "start": [464, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.toIntSubmodule_toAddSubgroup", "code": "@[simp]\ntheorem AddSubgroup.toIntSubmodule_toAddSubgroup (S : AddSubgroup M) :\n    S.toIntSubmodule.toAddSubgroup = S", "start": [470, 1], "end": [473, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.toAddSubgroup_toIntSubmodule", "code": "@[simp]\ntheorem Submodule.toAddSubgroup_toIntSubmodule (S : Submodule \u2124 M) :\n    AddSubgroup.toIntSubmodule S.toAddSubgroup = S", "start": [476, 1], "end": [479, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SuccPred/Basic.lean", "imports": ["Mathlib/Order/Cover.lean", "Mathlib/Order/Iterate.lean", "Mathlib/Order/CompleteLattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SuccOrder", "code": "@[ext]\nclass SuccOrder (\u03b1 : Type*) [Preorder \u03b1] where\n  \n  succ : \u03b1 \u2192 \u03b1\n  \n  le_succ : \u2200 a, a \u2264 succ a\n  \n  max_of_succ_le {a} : succ a \u2264 a \u2192 IsMax a\n  \n  succ_le_of_lt {a b} : a < b \u2192 succ a \u2264 b\n  \n  le_of_lt_succ {a b} : a < succ b \u2192 a \u2264 b", "start": [61, 1], "end": [73, 43], "kind": "commanddeclaration"}, {"full_name": "PredOrder", "code": "@[ext]\nclass PredOrder (\u03b1 : Type*) [Preorder \u03b1] where\n  \n  pred : \u03b1 \u2192 \u03b1\n  \n  pred_le : \u2200 a, pred a \u2264 a\n  \n  min_of_le_pred {a} : a \u2264 pred a \u2192 IsMin a\n  \n  le_pred_of_lt {a b} : a < b \u2192 a \u2264 pred b\n  \n  le_of_pred_lt {a b} : pred a < b \u2192 a \u2264 b", "start": [78, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "SuccOrder.ofSuccLeIffOfLeLtSucc", "code": "def SuccOrder.ofSuccLeIffOfLeLtSucc (succ : \u03b1 \u2192 \u03b1) (hsucc_le_iff : \u2200 {a b}, succ a \u2264 b \u2194 a < b)\n    (hle_of_lt_succ : \u2200 {a b}, a < succ b \u2192 a \u2264 b) : SuccOrder \u03b1 :=\n  { succ\n    le_succ := fun _ => (hsucc_le_iff.1 le_rfl).le\n    max_of_succ_le := fun ha => (lt_irrefl _ <| hsucc_le_iff.1 ha).elim\n    succ_le_of_lt := fun h => hsucc_le_iff.2 h\n    le_of_lt_succ := fun h => hle_of_lt_succ h}", "start": [119, 1], "end": [126, 48], "kind": "commanddeclaration"}, {"full_name": "PredOrder.ofLePredIffOfPredLePred", "code": "def PredOrder.ofLePredIffOfPredLePred (pred : \u03b1 \u2192 \u03b1) (hle_pred_iff : \u2200 {a b}, a \u2264 pred b \u2194 a < b)\n    (hle_of_pred_lt : \u2200 {a b}, pred a < b \u2192 a \u2264 b) : PredOrder \u03b1 :=\n  { pred\n    pred_le := fun _ => (hle_pred_iff.1 le_rfl).le\n    min_of_le_pred := fun ha => (lt_irrefl _ <| hle_pred_iff.1 ha).elim\n    le_pred_of_lt := fun h => hle_pred_iff.2 h\n    le_of_pred_lt := fun h => hle_of_pred_lt h }", "start": [129, 1], "end": [136, 49], "kind": "commanddeclaration"}, {"full_name": "SuccOrder.ofCore", "code": "@[simps]\ndef SuccOrder.ofCore (succ : \u03b1 \u2192 \u03b1) (hn : \u2200 {a}, \u00acIsMax a \u2192 \u2200 b, a < b \u2194 succ a \u2264 b)\n    (hm : \u2200 a, IsMax a \u2192 succ a = a) : SuccOrder \u03b1 :=\n  { succ\n    succ_le_of_lt := fun {a b} =>\n      by_cases (fun h hab => (hm a h).symm \u25b8 hab.le) fun h => (hn h b).mp\n    le_succ := fun a =>\n      by_cases (fun h => (hm a h).symm.le) fun h => le_of_lt <| by simpa using (hn h a).not\n    le_of_lt_succ := fun {a b} hab =>\n      by_cases (fun h => hm b h \u25b8 hab.le) fun h => by simpa [hab] using (hn h a).not\n    max_of_succ_le := fun {a} => not_imp_not.mp fun h => by simpa using (hn h a).not }", "start": [145, 1], "end": [156, 87], "kind": "commanddeclaration"}, {"full_name": "PredOrder.ofCore", "code": "@[simps]\ndef PredOrder.ofCore {\u03b1} [LinearOrder \u03b1] (pred : \u03b1 \u2192 \u03b1)\n    (hn : \u2200 {a}, \u00acIsMin a \u2192 \u2200 b, b \u2264 pred a \u2194 b < a) (hm : \u2200 a, IsMin a \u2192 pred a = a) :\n    PredOrder \u03b1 :=\n  { pred\n    le_pred_of_lt := fun {a b} =>\n      by_cases (fun h hab => (hm b h).symm \u25b8 hab.le) fun h => (hn h a).mpr\n    pred_le := fun a =>\n      by_cases (fun h => (hm a h).le) fun h => le_of_lt <| by simpa using (hn h a).not\n    le_of_pred_lt := fun {a b} hab =>\n      by_cases (fun h => hm a h \u25b8 hab.le) fun h => by simpa [hab] using (hn h b).not\n    min_of_le_pred := fun {a} => not_imp_not.mp fun h => by simpa using (hn h a).not }", "start": [160, 1], "end": [172, 87], "kind": "commanddeclaration"}, {"full_name": "SuccOrder.ofSuccLeIff", "code": "def SuccOrder.ofSuccLeIff (succ : \u03b1 \u2192 \u03b1) (hsucc_le_iff : \u2200 {a b}, succ a \u2264 b \u2194 a < b) :\n    SuccOrder \u03b1 :=\n  { succ\n    le_succ := fun _ => (hsucc_le_iff.1 le_rfl).le\n    max_of_succ_le := fun ha => (lt_irrefl _ <| hsucc_le_iff.1 ha).elim\n    succ_le_of_lt := fun h => hsucc_le_iff.2 h\n    le_of_lt_succ := fun {_ _} h => le_of_not_lt ((not_congr hsucc_le_iff).1 h.not_le) }", "start": [176, 1], "end": [183, 89], "kind": "commanddeclaration"}, {"full_name": "PredOrder.ofLePredIff", "code": "def PredOrder.ofLePredIff (pred : \u03b1 \u2192 \u03b1) (hle_pred_iff : \u2200 {a b}, a \u2264 pred b \u2194 a < b) :\n    PredOrder \u03b1 :=\n  { pred\n    pred_le := fun _ => (hle_pred_iff.1 le_rfl).le\n    min_of_le_pred := fun ha => (lt_irrefl _ <| hle_pred_iff.1 ha).elim\n    le_pred_of_lt := fun h => hle_pred_iff.2 h\n    le_of_pred_lt := fun {_ _} h => le_of_not_lt ((not_congr hle_pred_iff).1 h.not_le) }", "start": [186, 1], "end": [193, 89], "kind": "commanddeclaration"}, {"full_name": "Order.succ", "code": "def succ : \u03b1 \u2192 \u03b1 :=\n  SuccOrder.succ", "start": [207, 1], "end": [210, 17], "kind": "commanddeclaration"}, {"full_name": "Order.le_succ", "code": "theorem le_succ : \u2200 a : \u03b1, a \u2264 succ a", "start": [213, 1], "end": [214, 20], "kind": "commanddeclaration"}, {"full_name": "Order.max_of_succ_le", "code": "theorem max_of_succ_le {a : \u03b1} : succ a \u2264 a \u2192 IsMax a", "start": [217, 1], "end": [218, 27], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_of_lt", "code": "theorem succ_le_of_lt {a b : \u03b1} : a < b \u2192 succ a \u2264 b", "start": [221, 1], "end": [222, 26], "kind": "commanddeclaration"}, {"full_name": "Order.le_of_lt_succ", "code": "theorem le_of_lt_succ {a b : \u03b1} : a < succ b \u2192 a \u2264 b", "start": [225, 1], "end": [226, 26], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_iff_isMax", "code": "@[simp]\ntheorem succ_le_iff_isMax : succ a \u2264 a \u2194 IsMax a", "start": [229, 1], "end": [231, 44], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_iff_not_isMax", "code": "@[simp]\ntheorem lt_succ_iff_not_isMax : a < succ a \u2194 \u00acIsMax a", "start": [234, 1], "end": [236, 88], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_of_not_isMax", "code": "alias \u27e8_, lt_succ_of_not_isMax\u27e9 := lt_succ_iff_not_isMax", "start": [239, 1], "end": [239, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.wcovby_succ", "code": "theorem wcovby_succ (a : \u03b1) : a \u2a7f succ a", "start": [242, 1], "end": [243, 53], "kind": "commanddeclaration"}, {"full_name": "Order.covby_succ_of_not_isMax", "code": "theorem covby_succ_of_not_isMax (h : \u00acIsMax a) : a \u22d6 succ a", "start": [246, 1], "end": [247, 56], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_iff_of_not_isMax", "code": "theorem lt_succ_iff_of_not_isMax (ha : \u00acIsMax a) : b < succ a \u2194 b \u2264 a", "start": [250, 1], "end": [251, 66], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_iff_of_not_isMax", "code": "theorem succ_le_iff_of_not_isMax (ha : \u00acIsMax a) : succ a \u2264 b \u2194 a < b", "start": [254, 1], "end": [255, 54], "kind": "commanddeclaration"}, {"full_name": "Order.succ_lt_succ_of_not_isMax", "code": "lemma succ_lt_succ_of_not_isMax (h : a < b) (hb : \u00ac IsMax b) : succ a < succ b :=\n  (lt_succ_iff_of_not_isMax hb).2 $ succ_le_of_lt h", "start": [258, 1], "end": [259, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Order.succ_lt_succ_iff_of_not_isMax", "code": "theorem succ_lt_succ_iff_of_not_isMax (ha : \u00acIsMax a) (hb : \u00acIsMax b) :\n    succ a < succ b \u2194 a < b", "start": [261, 1], "end": [263, 64], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_succ_iff_of_not_isMax", "code": "theorem succ_le_succ_iff_of_not_isMax (ha : \u00acIsMax a) (hb : \u00acIsMax b) :\n    succ a \u2264 succ b \u2194 a \u2264 b", "start": [266, 1], "end": [268, 64], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_succ", "code": "@[simp, mono]\ntheorem succ_le_succ (h : a \u2264 b) : succ a \u2264 succ b", "start": [271, 1], "end": [277, 90], "kind": "commanddeclaration"}, {"full_name": "Order.succ_mono", "code": "theorem succ_mono : Monotone (succ : \u03b1 \u2192 \u03b1)", "start": [280, 1], "end": [280, 71], "kind": "commanddeclaration"}, {"full_name": "Order.le_succ_iterate", "code": "theorem le_succ_iterate (k : \u2115) (x : \u03b1) : x \u2264 succ^[k] x", "start": [283, 1], "end": [285, 56], "kind": "commanddeclaration"}, {"full_name": "Order.isMax_iterate_succ_of_eq_of_lt", "code": "theorem isMax_iterate_succ_of_eq_of_lt {n m : \u2115} (h_eq : succ^[n] a = succ^[m] a)\n    (h_lt : n < m) : IsMax (succ^[n] a)", "start": [288, 1], "end": [294, 71], "kind": "commanddeclaration"}, {"full_name": "Order.isMax_iterate_succ_of_eq_of_ne", "code": "theorem isMax_iterate_succ_of_eq_of_ne {n m : \u2115} (h_eq : succ^[n] a = succ^[m] a)\n    (h_ne : n \u2260 m) : IsMax (succ^[n] a)", "start": [297, 1], "end": [302, 80], "kind": "commanddeclaration"}, {"full_name": "Order.Iio_succ_of_not_isMax", "code": "theorem Iio_succ_of_not_isMax (ha : \u00acIsMax a) : Iio (succ a) = Iic a", "start": [305, 1], "end": [306, 47], "kind": "commanddeclaration"}, {"full_name": "Order.Ici_succ_of_not_isMax", "code": "theorem Ici_succ_of_not_isMax (ha : \u00acIsMax a) : Ici (succ a) = Ioi a", "start": [309, 1], "end": [310, 47], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_right_of_not_isMax", "code": "theorem Ico_succ_right_of_not_isMax (hb : \u00acIsMax b) : Ico a (succ b) = Icc a b", "start": [313, 1], "end": [314, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_succ_right_of_not_isMax", "code": "theorem Ioo_succ_right_of_not_isMax (hb : \u00acIsMax b) : Ioo a (succ b) = Ioc a b", "start": [317, 1], "end": [318, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_succ_left_of_not_isMax", "code": "theorem Icc_succ_left_of_not_isMax (ha : \u00acIsMax a) : Icc (succ a) b = Ioc a b", "start": [321, 1], "end": [322, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_left_of_not_isMax", "code": "theorem Ico_succ_left_of_not_isMax (ha : \u00acIsMax a) : Ico (succ a) b = Ioo a b", "start": [325, 1], "end": [326, 64], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ", "code": "theorem lt_succ (a : \u03b1) : a < succ a", "start": [333, 1], "end": [334, 38], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_iff", "code": "@[simp]\ntheorem lt_succ_iff : a < succ b \u2194 a \u2264 b", "start": [337, 1], "end": [339, 42], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_iff", "code": "@[simp]\ntheorem succ_le_iff : succ a \u2264 b \u2194 a < b", "start": [342, 1], "end": [344, 42], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_succ_iff", "code": "theorem succ_le_succ_iff : succ a \u2264 succ b \u2194 a \u2264 b", "start": [347, 1], "end": [347, 62], "kind": "commanddeclaration"}, {"full_name": "Order.succ_lt_succ_iff", "code": "theorem succ_lt_succ_iff : succ a < succ b \u2194 a < b", "start": [350, 1], "end": [350, 62], "kind": "commanddeclaration"}, {"full_name": "Order.le_of_succ_le_succ", "code": "alias \u27e8le_of_succ_le_succ, _\u27e9 := succ_le_succ_iff", "start": [353, 1], "end": [353, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.lt_of_succ_lt_succ", "code": "alias \u27e8lt_of_succ_lt_succ, succ_lt_succ\u27e9 := succ_lt_succ_iff", "start": [356, 1], "end": [356, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.succ_lt_succ", "code": "alias \u27e8lt_of_succ_lt_succ, succ_lt_succ\u27e9 := succ_lt_succ_iff", "start": [356, 1], "end": [356, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.succ_strictMono", "code": "theorem succ_strictMono : StrictMono (succ : \u03b1 \u2192 \u03b1)", "start": [360, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "Order.covby_succ", "code": "theorem covby_succ (a : \u03b1) : a \u22d6 succ a", "start": [363, 1], "end": [364, 41], "kind": "commanddeclaration"}, {"full_name": "Order.Iio_succ", "code": "@[simp]\ntheorem Iio_succ (a : \u03b1) : Iio (succ a) = Iic a", "start": [367, 1], "end": [369, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Ici_succ", "code": "@[simp]\ntheorem Ici_succ (a : \u03b1) : Ici (succ a) = Ioi a", "start": [372, 1], "end": [374, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_right", "code": "@[simp]\ntheorem Ico_succ_right (a b : \u03b1) : Ico a (succ b) = Icc a b", "start": [377, 1], "end": [379, 45], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_succ_right", "code": "@[simp]\ntheorem Ioo_succ_right (a b : \u03b1) : Ioo a (succ b) = Ioc a b", "start": [382, 1], "end": [384, 45], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_succ_left", "code": "@[simp]\ntheorem Icc_succ_left (a b : \u03b1) : Icc (succ a) b = Ioc a b", "start": [387, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_left", "code": "@[simp]\ntheorem Ico_succ_left (a b : \u03b1) : Ico (succ a) b = Ioo a b", "start": [392, 1], "end": [394, 44], "kind": "commanddeclaration"}, {"full_name": "Order.succ_eq_iff_isMax", "code": "@[simp]\ntheorem succ_eq_iff_isMax : succ a = a \u2194 IsMax a", "start": [405, 1], "end": [407, 67], "kind": "commanddeclaration"}, {"full_name": "IsMax.succ_eq", "code": "alias \u27e8_, _root_.IsMax.succ_eq\u27e9 := succ_eq_iff_isMax", "start": [410, 1], "end": [410, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.succ_eq_succ_iff_of_not_isMax", "code": "theorem succ_eq_succ_iff_of_not_isMax (ha : \u00acIsMax a) (hb : \u00acIsMax b) :\n    succ a = succ b \u2194 a = b", "start": [413, 1], "end": [416, 41], "kind": "commanddeclaration"}, {"full_name": "Order.le_le_succ_iff", "code": "theorem le_le_succ_iff : a \u2264 b \u2227 b \u2264 succ a \u2194 b = a \u2228 b = succ a", "start": [419, 1], "end": [427, 30], "kind": "commanddeclaration"}, {"full_name": "Covby.succ_eq", "code": "theorem _root_.Covby.succ_eq (h : a \u22d6 b) : succ a = b", "start": [430, 1], "end": [431, 91], "kind": "commanddeclaration"}, {"full_name": "Wcovby.le_succ", "code": "theorem _root_.Wcovby.le_succ (h : a \u2a7f b) : b \u2264 succ a", "start": [434, 1], "end": [437, 20], "kind": "commanddeclaration"}, {"full_name": "Order.le_succ_iff_eq_or_le", "code": "theorem le_succ_iff_eq_or_le : a \u2264 succ b \u2194 a = succ b \u2228 a \u2264 b", "start": [440, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_iff_eq_or_lt_of_not_isMax", "code": "theorem lt_succ_iff_eq_or_lt_of_not_isMax (hb : \u00acIsMax b) : a < succ b \u2194 a = b \u2228 a < b", "start": [446, 1], "end": [447, 54], "kind": "commanddeclaration"}, {"full_name": "Order.Iic_succ", "code": "theorem Iic_succ (a : \u03b1) : Iic (succ a) = insert (succ a) (Iic a)", "start": [450, 1], "end": [451, 36], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_succ_right", "code": "theorem Icc_succ_right (h : a \u2264 succ b) : Icc a (succ b) = insert (succ b) (Icc a b)", "start": [454, 1], "end": [455, 73], "kind": "commanddeclaration"}, {"full_name": "Order.Ioc_succ_right", "code": "theorem Ioc_succ_right (h : a < succ b) : Ioc a (succ b) = insert (succ b) (Ioc a b)", "start": [458, 1], "end": [459, 73], "kind": "commanddeclaration"}, {"full_name": "Order.Iio_succ_eq_insert_of_not_isMax", "code": "theorem Iio_succ_eq_insert_of_not_isMax (h : \u00acIsMax a) : Iio (succ a) = insert a (Iio a)", "start": [462, 1], "end": [463, 51], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_right_eq_insert_of_not_isMax", "code": "theorem Ico_succ_right_eq_insert_of_not_isMax (h\u2081 : a \u2264 b) (h\u2082 : \u00acIsMax b) :\n    Ico a (succ b) = insert b (Ico a b)", "start": [466, 1], "end": [468, 100], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_succ_right_eq_insert_of_not_isMax", "code": "theorem Ioo_succ_right_eq_insert_of_not_isMax (h\u2081 : a < b) (h\u2082 : \u00acIsMax b) :\n    Ioo a (succ b) = insert b (Ioo a b)", "start": [471, 1], "end": [473, 100], "kind": "commanddeclaration"}, {"full_name": "Order.succ_eq_succ_iff", "code": "@[simp]\ntheorem succ_eq_succ_iff : succ a = succ b \u2194 a = b", "start": [480, 1], "end": [482, 60], "kind": "commanddeclaration"}, {"full_name": "Order.succ_injective", "code": "theorem succ_injective : Injective (succ : \u03b1 \u2192 \u03b1)", "start": [485, 1], "end": [485, 83], "kind": "commanddeclaration"}, {"full_name": "Order.succ_ne_succ_iff", "code": "theorem succ_ne_succ_iff : succ a \u2260 succ b \u2194 a \u2260 b", "start": [488, 1], "end": [489, 24], "kind": "commanddeclaration"}, {"full_name": "Order.succ_ne_succ", "code": "alias \u27e8_, succ_ne_succ\u27e9 := succ_ne_succ_iff", "start": [492, 1], "end": [492, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.lt_succ_iff_eq_or_lt", "code": "theorem lt_succ_iff_eq_or_lt : a < succ b \u2194 a = b \u2228 a < b", "start": [495, 1], "end": [496, 36], "kind": "commanddeclaration"}, {"full_name": "Order.succ_eq_iff_covby", "code": "theorem succ_eq_iff_covby : succ a = b \u2194 a \u22d6 b", "start": [499, 1], "end": [502, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Iio_succ_eq_insert", "code": "theorem Iio_succ_eq_insert (a : \u03b1) : Iio (succ a) = insert a (Iio a)", "start": [505, 1], "end": [506, 49], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_succ_right_eq_insert", "code": "theorem Ico_succ_right_eq_insert (h : a \u2264 b) : Ico a (succ b) = insert b (Ico a b)", "start": [509, 1], "end": [510, 57], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_succ_right_eq_insert", "code": "theorem Ioo_succ_right_eq_insert (h : a < b) : Ioo a (succ b) = insert b (Ioo a b)", "start": [513, 1], "end": [514, 57], "kind": "commanddeclaration"}, {"full_name": "Order.succ_top", "code": "@[simp]\ntheorem succ_top : succ (\u22a4 : \u03b1) = \u22a4", "start": [523, 1], "end": [525, 43], "kind": "commanddeclaration"}, {"full_name": "Order.succ_le_iff_eq_top", "code": "theorem succ_le_iff_eq_top : succ a \u2264 a \u2194 a = \u22a4", "start": [529, 1], "end": [530, 43], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_iff_ne_top", "code": "theorem lt_succ_iff_ne_top : a < succ a \u2194 a \u2260 \u22a4", "start": [534, 1], "end": [535, 51], "kind": "commanddeclaration"}, {"full_name": "Order.lt_succ_bot_iff", "code": "theorem lt_succ_bot_iff [NoMaxOrder \u03b1] : a < succ \u22a5 \u2194 a = \u22a5", "start": [545, 1], "end": [545, 95], "kind": "commanddeclaration"}, {"full_name": "Order.le_succ_bot_iff", "code": "theorem le_succ_bot_iff : a \u2264 succ \u22a5 \u2194 a = \u22a5 \u2228 a = succ \u22a5", "start": [548, 1], "end": [549, 49], "kind": "commanddeclaration"}, {"full_name": "Order.bot_lt_succ", "code": "theorem bot_lt_succ (a : \u03b1) : \u22a5 < succ a", "start": [554, 1], "end": [555, 68], "kind": "commanddeclaration"}, {"full_name": "Order.succ_ne_bot", "code": "theorem succ_ne_bot (a : \u03b1) : succ a \u2260 \u22a5", "start": [558, 1], "end": [559, 22], "kind": "commanddeclaration"}, {"full_name": "Order.succ_eq_iInf", "code": "theorem succ_eq_iInf (a : \u03b1) : succ a = \u2a05 (b) (_ : a < b), b", "start": [579, 1], "end": [584, 45], "kind": "commanddeclaration"}, {"full_name": "Order.pred", "code": "def pred : \u03b1 \u2192 \u03b1 :=\n  PredOrder.pred", "start": [595, 1], "end": [598, 17], "kind": "commanddeclaration"}, {"full_name": "Order.pred_le", "code": "theorem pred_le : \u2200 a : \u03b1, pred a \u2264 a", "start": [601, 1], "end": [602, 20], "kind": "commanddeclaration"}, {"full_name": "Order.min_of_le_pred", "code": "theorem min_of_le_pred {a : \u03b1} : a \u2264 pred a \u2192 IsMin a", "start": [605, 1], "end": [606, 27], "kind": "commanddeclaration"}, {"full_name": "Order.le_pred_of_lt", "code": "theorem le_pred_of_lt {a b : \u03b1} : a < b \u2192 a \u2264 pred b", "start": [609, 1], "end": [610, 26], "kind": "commanddeclaration"}, {"full_name": "Order.le_of_pred_lt", "code": "theorem le_of_pred_lt {a b : \u03b1} : pred a < b \u2192 a \u2264 b", "start": [613, 1], "end": [614, 26], "kind": "commanddeclaration"}, {"full_name": "Order.le_pred_iff_isMin", "code": "@[simp]\ntheorem le_pred_iff_isMin : a \u2264 pred a \u2194 IsMin a", "start": [617, 1], "end": [619, 44], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_iff_not_isMin", "code": "@[simp]\ntheorem pred_lt_iff_not_isMin : pred a < a \u2194 \u00acIsMin a", "start": [622, 1], "end": [624, 88], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_of_not_isMin", "code": "alias \u27e8_, pred_lt_of_not_isMin\u27e9 := pred_lt_iff_not_isMin", "start": [627, 1], "end": [627, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.pred_wcovby", "code": "theorem pred_wcovby (a : \u03b1) : pred a \u2a7f a", "start": [630, 1], "end": [631, 53], "kind": "commanddeclaration"}, {"full_name": "Order.pred_covby_of_not_isMin", "code": "theorem pred_covby_of_not_isMin (h : \u00acIsMin a) : pred a \u22d6 a", "start": [634, 1], "end": [635, 56], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_iff_of_not_isMin", "code": "theorem pred_lt_iff_of_not_isMin (ha : \u00acIsMin a) : pred a < b \u2194 a \u2264 b", "start": [638, 1], "end": [639, 54], "kind": "commanddeclaration"}, {"full_name": "Order.le_pred_iff_of_not_isMin", "code": "theorem le_pred_iff_of_not_isMin (ha : \u00acIsMin a) : b \u2264 pred a \u2194 b < a", "start": [642, 1], "end": [643, 66], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_pred_of_not_isMin", "code": "lemma pred_lt_pred_of_not_isMin (h : a < b) (ha : \u00ac IsMin a) : pred a < pred b :=\n  (pred_lt_iff_of_not_isMin ha).2 $ le_pred_of_lt h", "start": [646, 1], "end": [647, 52], "kind": "mathlibtacticlemma"}, {"full_name": "Order.pred_le_pred", "code": "@[simp, mono]\ntheorem pred_le_pred {a b : \u03b1} (h : a \u2264 b) : pred a \u2264 pred b", "start": [649, 1], "end": [651, 22], "kind": "commanddeclaration"}, {"full_name": "Order.pred_mono", "code": "theorem pred_mono : Monotone (pred : \u03b1 \u2192 \u03b1)", "start": [654, 1], "end": [654, 71], "kind": "commanddeclaration"}, {"full_name": "Order.pred_iterate_le", "code": "theorem pred_iterate_le (k : \u2115) (x : \u03b1) : pred^[k] x \u2264 x", "start": [657, 1], "end": [659, 56], "kind": "commanddeclaration"}, {"full_name": "Order.isMin_iterate_pred_of_eq_of_lt", "code": "theorem isMin_iterate_pred_of_eq_of_lt {n m : \u2115} (h_eq : pred^[n] a = pred^[m] a)\n    (h_lt : n < m) : IsMin (pred^[n] a)", "start": [662, 1], "end": [664, 58], "kind": "commanddeclaration"}, {"full_name": "Order.isMin_iterate_pred_of_eq_of_ne", "code": "theorem isMin_iterate_pred_of_eq_of_ne {n m : \u2115} (h_eq : pred^[n] a = pred^[m] a)\n    (h_ne : n \u2260 m) : IsMin (pred^[n] a)", "start": [667, 1], "end": [669, 58], "kind": "commanddeclaration"}, {"full_name": "Order.Ioi_pred_of_not_isMin", "code": "theorem Ioi_pred_of_not_isMin (ha : \u00acIsMin a) : Ioi (pred a) = Ici a", "start": [672, 1], "end": [673, 47], "kind": "commanddeclaration"}, {"full_name": "Order.Iic_pred_of_not_isMin", "code": "theorem Iic_pred_of_not_isMin (ha : \u00acIsMin a) : Iic (pred a) = Iio a", "start": [676, 1], "end": [677, 47], "kind": "commanddeclaration"}, {"full_name": "Order.Ioc_pred_left_of_not_isMin", "code": "theorem Ioc_pred_left_of_not_isMin (ha : \u00acIsMin a) : Ioc (pred a) b = Icc a b", "start": [680, 1], "end": [681, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_pred_left_of_not_isMin", "code": "theorem Ioo_pred_left_of_not_isMin (ha : \u00acIsMin a) : Ioo (pred a) b = Ico a b", "start": [684, 1], "end": [685, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_pred_right_of_not_isMin", "code": "theorem Icc_pred_right_of_not_isMin (ha : \u00acIsMin b) : Icc a (pred b) = Ico a b", "start": [688, 1], "end": [689, 64], "kind": "commanddeclaration"}, {"full_name": "Order.Ioc_pred_right_of_not_isMin", "code": "theorem Ioc_pred_right_of_not_isMin (ha : \u00acIsMin b) : Ioc a (pred b) = Ioo a b", "start": [692, 1], "end": [693, 64], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt", "code": "theorem pred_lt (a : \u03b1) : pred a < a", "start": [700, 1], "end": [701, 38], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_iff", "code": "@[simp]\ntheorem pred_lt_iff : pred a < b \u2194 a \u2264 b", "start": [704, 1], "end": [706, 42], "kind": "commanddeclaration"}, {"full_name": "Order.le_pred_iff", "code": "@[simp]\ntheorem le_pred_iff : a \u2264 pred b \u2194 a < b", "start": [709, 1], "end": [711, 42], "kind": "commanddeclaration"}, {"full_name": "Order.pred_le_pred_iff", "code": "theorem pred_le_pred_iff : pred a \u2264 pred b \u2194 a \u2264 b", "start": [714, 1], "end": [714, 62], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_pred_iff", "code": "theorem pred_lt_pred_iff : pred a < pred b \u2194 a < b", "start": [717, 1], "end": [717, 62], "kind": "commanddeclaration"}, {"full_name": "Order.le_of_pred_le_pred", "code": "alias \u27e8le_of_pred_le_pred, _\u27e9 := pred_le_pred_iff", "start": [720, 1], "end": [720, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.lt_of_pred_lt_pred", "code": "alias \u27e8lt_of_pred_lt_pred, pred_lt_pred\u27e9 := pred_lt_pred_iff", "start": [723, 1], "end": [723, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.pred_lt_pred", "code": "alias \u27e8lt_of_pred_lt_pred, pred_lt_pred\u27e9 := pred_lt_pred_iff", "start": [723, 1], "end": [723, 61], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.pred_strictMono", "code": "theorem pred_strictMono : StrictMono (pred : \u03b1 \u2192 \u03b1)", "start": [727, 1], "end": [727, 79], "kind": "commanddeclaration"}, {"full_name": "Order.pred_covby", "code": "theorem pred_covby (a : \u03b1) : pred a \u22d6 a", "start": [730, 1], "end": [731, 41], "kind": "commanddeclaration"}, {"full_name": "Order.Ioi_pred", "code": "@[simp]\ntheorem Ioi_pred (a : \u03b1) : Ioi (pred a) = Ici a", "start": [734, 1], "end": [736, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Iic_pred", "code": "@[simp]\ntheorem Iic_pred (a : \u03b1) : Iic (pred a) = Iio a", "start": [739, 1], "end": [741, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Ioc_pred_left", "code": "@[simp]\ntheorem Ioc_pred_left (a b : \u03b1) : Ioc (pred a) b = Icc a b", "start": [744, 1], "end": [746, 44], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_pred_left", "code": "@[simp]\ntheorem Ioo_pred_left (a b : \u03b1) : Ioo (pred a) b = Ico a b", "start": [749, 1], "end": [751, 44], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_pred_right", "code": "@[simp]\ntheorem Icc_pred_right (a b : \u03b1) : Icc a (pred b) = Ico a b", "start": [754, 1], "end": [756, 45], "kind": "commanddeclaration"}, {"full_name": "Order.Ioc_pred_right", "code": "@[simp]\ntheorem Ioc_pred_right (a b : \u03b1) : Ioc a (pred b) = Ioo a b", "start": [759, 1], "end": [761, 45], "kind": "commanddeclaration"}, {"full_name": "Order.pred_eq_iff_isMin", "code": "@[simp]\ntheorem pred_eq_iff_isMin : pred a = a \u2194 IsMin a", "start": [772, 1], "end": [774, 67], "kind": "commanddeclaration"}, {"full_name": "IsMin.pred_eq", "code": "alias \u27e8_, _root_.IsMin.pred_eq\u27e9 := pred_eq_iff_isMin", "start": [777, 1], "end": [777, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.pred_le_le_iff", "code": "theorem pred_le_le_iff {a b : \u03b1} : pred a \u2264 b \u2227 b \u2264 a \u2194 b = a \u2228 b = pred a", "start": [780, 1], "end": [786, 30], "kind": "commanddeclaration"}, {"full_name": "Covby.pred_eq", "code": "theorem _root_.Covby.pred_eq {a b : \u03b1} (h : a \u22d6 b) : pred b = a", "start": [789, 1], "end": [790, 92], "kind": "commanddeclaration"}, {"full_name": "Wcovby.pred_le", "code": "theorem _root_.Wcovby.pred_le (h : a \u2a7f b) : pred b \u2264 a", "start": [793, 1], "end": [796, 20], "kind": "commanddeclaration"}, {"full_name": "Order.pred_le_iff_eq_or_le", "code": "theorem pred_le_iff_eq_or_le : pred a \u2264 b \u2194 b = pred a \u2228 a \u2264 b", "start": [799, 1], "end": [802, 65], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_iff_eq_or_lt_of_not_isMin", "code": "theorem pred_lt_iff_eq_or_lt_of_not_isMin (ha : \u00acIsMin a) : pred a < b \u2194 a = b \u2228 a < b", "start": [805, 1], "end": [806, 54], "kind": "commanddeclaration"}, {"full_name": "Order.Ici_pred", "code": "theorem Ici_pred (a : \u03b1) : Ici (pred a) = insert (pred a) (Ici a)", "start": [809, 1], "end": [810, 36], "kind": "commanddeclaration"}, {"full_name": "Order.Ioi_pred_eq_insert_of_not_isMin", "code": "theorem Ioi_pred_eq_insert_of_not_isMin (ha : \u00acIsMin a) : Ioi (pred a) = insert a (Ioi a)", "start": [813, 1], "end": [815, 45], "kind": "commanddeclaration"}, {"full_name": "Order.Icc_pred_left", "code": "theorem Icc_pred_left (h : pred a \u2264 b) : Icc (pred a) b = insert (pred a) (Icc a b)", "start": [818, 1], "end": [819, 73], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_pred_left", "code": "theorem Ico_pred_left (h : pred a < b) : Ico (pred a) b = insert (pred a) (Ico a b)", "start": [822, 1], "end": [823, 73], "kind": "commanddeclaration"}, {"full_name": "Order.pred_eq_pred_iff", "code": "@[simp]\ntheorem pred_eq_pred_iff : pred a = pred b \u2194 a = b", "start": [830, 1], "end": [832, 65], "kind": "commanddeclaration"}, {"full_name": "Order.pred_injective", "code": "theorem pred_injective : Injective (pred : \u03b1 \u2192 \u03b1)", "start": [835, 1], "end": [835, 83], "kind": "commanddeclaration"}, {"full_name": "Order.pred_ne_pred_iff", "code": "theorem pred_ne_pred_iff : pred a \u2260 pred b \u2194 a \u2260 b", "start": [838, 1], "end": [839, 24], "kind": "commanddeclaration"}, {"full_name": "Order.pred_ne_pred", "code": "alias \u27e8_, pred_ne_pred\u27e9 := pred_ne_pred_iff", "start": [842, 1], "end": [842, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.pred_lt_iff_eq_or_lt", "code": "theorem pred_lt_iff_eq_or_lt : pred a < b \u2194 a = b \u2228 a < b", "start": [845, 1], "end": [846, 36], "kind": "commanddeclaration"}, {"full_name": "Order.pred_eq_iff_covby", "code": "theorem pred_eq_iff_covby : pred b = a \u2194 a \u22d6 b", "start": [849, 1], "end": [852, 39], "kind": "commanddeclaration"}, {"full_name": "Order.Ioi_pred_eq_insert", "code": "theorem Ioi_pred_eq_insert (a : \u03b1) : Ioi (pred a) = insert a (Ioi a)", "start": [855, 1], "end": [856, 67], "kind": "commanddeclaration"}, {"full_name": "Order.Ico_pred_right_eq_insert", "code": "theorem Ico_pred_right_eq_insert (h : a \u2264 b) : Ioc (pred a) b = insert a (Ioc a b)", "start": [859, 1], "end": [860, 83], "kind": "commanddeclaration"}, {"full_name": "Order.Ioo_pred_right_eq_insert", "code": "theorem Ioo_pred_right_eq_insert (h : a < b) : Ioo (pred a) b = insert a (Ioo a b)", "start": [863, 1], "end": [864, 83], "kind": "commanddeclaration"}, {"full_name": "Order.pred_bot", "code": "@[simp]\ntheorem pred_bot : pred (\u22a5 : \u03b1) = \u22a5", "start": [873, 1], "end": [875, 20], "kind": "commanddeclaration"}, {"full_name": "Order.le_pred_iff_eq_bot", "code": "theorem le_pred_iff_eq_bot : a \u2264 pred a \u2194 a = \u22a5", "start": [879, 1], "end": [880, 34], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_iff_ne_bot", "code": "theorem pred_lt_iff_ne_bot : pred a < a \u2194 a \u2260 \u22a5", "start": [884, 1], "end": [885, 34], "kind": "commanddeclaration"}, {"full_name": "Order.pred_top_lt_iff", "code": "theorem pred_top_lt_iff [NoMinOrder \u03b1] : pred \u22a4 < a \u2194 a = \u22a4", "start": [895, 1], "end": [896, 33], "kind": "commanddeclaration"}, {"full_name": "Order.pred_top_le_iff", "code": "theorem pred_top_le_iff : pred \u22a4 \u2264 a \u2194 a = \u22a4 \u2228 a = pred \u22a4", "start": [899, 1], "end": [900, 31], "kind": "commanddeclaration"}, {"full_name": "Order.pred_lt_top", "code": "theorem pred_lt_top (a : \u03b1) : pred a < \u22a4", "start": [905, 1], "end": [906, 68], "kind": "commanddeclaration"}, {"full_name": "Order.pred_ne_top", "code": "theorem pred_ne_top (a : \u03b1) : pred a \u2260 \u22a4", "start": [909, 1], "end": [910, 21], "kind": "commanddeclaration"}, {"full_name": "Order.pred_eq_iSup", "code": "theorem pred_eq_iSup (a : \u03b1) : pred a = \u2a06 (b) (_ : b < a), b", "start": [930, 1], "end": [935, 93], "kind": "commanddeclaration"}, {"full_name": "Order.succ_pred_of_not_isMin", "code": "@[simp]\ntheorem succ_pred_of_not_isMin (h : \u00acIsMin a) : succ (pred a) = a", "start": [946, 1], "end": [948, 44], "kind": "commanddeclaration"}, {"full_name": "Order.pred_succ_of_not_isMax", "code": "@[simp]\ntheorem pred_succ_of_not_isMax (h : \u00acIsMax a) : pred (succ a) = a", "start": [951, 1], "end": [953, 44], "kind": "commanddeclaration"}, {"full_name": "Order.succ_pred", "code": "theorem succ_pred [NoMinOrder \u03b1] (a : \u03b1) : succ (pred a) = a", "start": [957, 1], "end": [958, 31], "kind": "commanddeclaration"}, {"full_name": "Order.pred_succ", "code": "theorem pred_succ [NoMaxOrder \u03b1] (a : \u03b1) : pred (succ a) = a", "start": [962, 1], "end": [963, 31], "kind": "commanddeclaration"}, {"full_name": "Order.pred_succ_iterate_of_not_isMax", "code": "theorem pred_succ_iterate_of_not_isMax (i : \u03b1) (n : \u2115) (hin : \u00acIsMax (succ^[n - 1] i)) :\n    pred^[n] (succ^[n] i) = i", "start": [966, 1], "end": [984, 21], "kind": "commanddeclaration"}, {"full_name": "Order.succ_pred_iterate_of_not_isMin", "code": "theorem succ_pred_iterate_of_not_isMin (i : \u03b1) (n : \u2115) (hin : \u00acIsMin (pred^[n - 1] i)) :\n    succ^[n] (pred^[n] i) = i", "start": [987, 1], "end": [989, 52], "kind": "commanddeclaration"}, {"full_name": "WithTop.succ_coe_top", "code": "@[simp]\ntheorem succ_coe_top : succ \u2191(\u22a4 : \u03b1) = (\u22a4 : WithTop \u03b1)", "start": [1062, 1], "end": [1064, 14], "kind": "commanddeclaration"}, {"full_name": "WithTop.succ_coe_of_ne_top", "code": "theorem succ_coe_of_ne_top {a : \u03b1} (h : a \u2260 \u22a4) : succ (\u2191a : WithTop \u03b1) = \u2191(succ a)", "start": [1067, 1], "end": [1068, 12], "kind": "commanddeclaration"}, {"full_name": "WithTop.pred_top", "code": "@[simp]\ntheorem pred_top : pred (\u22a4 : WithTop \u03b1) = \u2191(\u22a4 : \u03b1)", "start": [1103, 1], "end": [1105, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.pred_coe", "code": "@[simp]\ntheorem pred_coe (a : \u03b1) : pred (\u2191a : WithTop \u03b1) = \u2191(pred a)", "start": [1108, 1], "end": [1110, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.pred_untop", "code": "@[simp]\ntheorem pred_untop :\n    \u2200 (a : WithTop \u03b1) (ha : a \u2260 \u22a4),\n      pred (a.untop ha) = (pred a).untop (by induction a using WithTop.recTopCoe <;> simp)", "start": [1113, 1], "end": [1118, 22], "kind": "commanddeclaration"}, {"full_name": "WithTop.succOrderOfNoMaxOrder", "code": "instance succOrderOfNoMaxOrder : SuccOrder (WithTop \u03b1) where\n  succ a :=\n    match a with\n    | \u22a4 => \u22a4\n    | Option.some a => some (succ a)\n  le_succ a := by\n    cases' a with a a\n    \u00b7 exact le_top\n    \u00b7 exact some_le_some.2 (le_succ a)\n  max_of_succ_le {a} ha := by\n    cases a\n    \u00b7 exact isMax_top\n    \u00b7 exact (not_isMax _ <| max_of_succ_le <| some_le_some.1 ha).elim\n  succ_le_of_lt {a b} h := by\n    cases a\n    \u00b7 exact (not_top_lt h).elim\n    cases b\n    \u00b7 exact le_top\n    \u00b7 exact some_le_some.2 (succ_le_of_lt <| some_lt_some.1 h)\n  le_of_lt_succ {a b} h := by\n    cases a\n    \u00b7 exact (not_top_lt h).elim\n    cases b\n    \u00b7 exact le_top\n    \u00b7 exact some_le_some.2 (le_of_lt_succ <| some_lt_some.1 h)", "start": [1129, 1], "end": [1153, 63], "kind": "commanddeclaration"}, {"full_name": "WithTop.succ_coe", "code": "@[simp]\ntheorem succ_coe (a : \u03b1) : succ (\u2191a : WithTop \u03b1) = \u2191(succ a)", "start": [1156, 1], "end": [1158, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.succ_bot", "code": "@[simp]\ntheorem succ_bot : succ (\u22a5 : WithBot \u03b1) = \u2191(\u22a5 : \u03b1)", "start": [1214, 1], "end": [1216, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.succ_coe", "code": "@[simp]\ntheorem succ_coe (a : \u03b1) : succ (\u2191a : WithBot \u03b1) = \u2191(succ a)", "start": [1219, 1], "end": [1221, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.succ_unbot", "code": "@[simp]\ntheorem succ_unbot :\n    \u2200 (a : WithBot \u03b1) (ha : a \u2260 \u22a5),\n      succ (a.unbot ha) = (succ a).unbot (by induction a using WithBot.recBotCoe <;> simp)", "start": [1224, 1], "end": [1229, 22], "kind": "commanddeclaration"}, {"full_name": "WithBot.pred_coe_bot", "code": "@[simp]\ntheorem pred_coe_bot : pred \u2191(\u22a5 : \u03b1) = (\u22a5 : WithBot \u03b1)", "start": [1281, 1], "end": [1283, 14], "kind": "commanddeclaration"}, {"full_name": "WithBot.pred_coe_of_ne_bot", "code": "theorem pred_coe_of_ne_bot {a : \u03b1} (h : a \u2260 \u22a5) : pred (\u2191a : WithBot \u03b1) = \u2191(pred a)", "start": [1286, 1], "end": [1287, 12], "kind": "commanddeclaration"}, {"full_name": "WithBot.predOrderOfNoMinOrder", "code": "instance predOrderOfNoMinOrder : PredOrder (WithBot \u03b1) where\n  pred a :=\n    match a with\n    | \u22a5 => \u22a5\n    | Option.some a => some (pred a)\n  pred_le a := by\n    cases' a with a a\n    \u00b7 exact bot_le\n    \u00b7 exact some_le_some.2 (pred_le a)\n  min_of_le_pred {a} ha := by\n    cases a\n    \u00b7 exact isMin_bot\n    \u00b7 exact (not_isMin _ <| min_of_le_pred <| some_le_some.1 ha).elim\n  le_pred_of_lt {a b} h := by\n    cases b\n    \u00b7 exact (not_lt_bot h).elim\n    cases a\n    \u00b7 exact bot_le\n    \u00b7 exact some_le_some.2 (le_pred_of_lt <| some_lt_some.1 h)\n  le_of_pred_lt {a b} h := by\n    cases b\n    \u00b7 exact (not_lt_bot h).elim\n    cases a\n    \u00b7 exact bot_le\n    \u00b7 exact some_le_some.2 (le_of_pred_lt <| some_lt_some.1 h)", "start": [1313, 1], "end": [1337, 63], "kind": "commanddeclaration"}, {"full_name": "WithBot.pred_coe", "code": "@[simp]\ntheorem pred_coe (a : \u03b1) : pred (\u2191a : WithBot \u03b1) = \u2191(pred a)", "start": [1340, 1], "end": [1342, 6], "kind": "commanddeclaration"}, {"full_name": "IsSuccArchimedean", "code": "class IsSuccArchimedean (\u03b1 : Type*) [Preorder \u03b1] [SuccOrder \u03b1] : Prop where\n  \n  exists_succ_iterate_of_le {a b : \u03b1} (h : a \u2264 b) : \u2203 n, succ^[n] a = b", "start": [1351, 1], "end": [1355, 72], "kind": "commanddeclaration"}, {"full_name": "IsPredArchimedean", "code": "class IsPredArchimedean (\u03b1 : Type*) [Preorder \u03b1] [PredOrder \u03b1] : Prop where\n  \n  exists_pred_iterate_of_le {a b : \u03b1} (h : a \u2264 b) : \u2203 n, pred^[n] b = a", "start": [1358, 1], "end": [1362, 72], "kind": "commanddeclaration"}, {"full_name": "LE.le.exists_succ_iterate", "code": "theorem LE.le.exists_succ_iterate (h : a \u2264 b) : \u2203 n, succ^[n] a = b", "start": [1380, 1], "end": [1381, 30], "kind": "commanddeclaration"}, {"full_name": "exists_succ_iterate_iff_le", "code": "theorem exists_succ_iterate_iff_le : (\u2203 n, succ^[n] a = b) \u2194 a \u2264 b", "start": [1384, 1], "end": [1387, 43], "kind": "commanddeclaration"}, {"full_name": "Succ.rec", "code": "@[elab_as_elim]\ntheorem Succ.rec {P : \u03b1 \u2192 Prop} {m : \u03b1} (h0 : P m) (h1 : \u2200 n, m \u2264 n \u2192 P n \u2192 P (succ n)) \u2983n : \u03b1\u2984\n    (hmn : m \u2264 n) : P n", "start": [1390, 1], "end": [1398, 55], "kind": "commanddeclaration"}, {"full_name": "Succ.rec_iff", "code": "theorem Succ.rec_iff {p : \u03b1 \u2192 Prop} (hsucc : \u2200 a, p a \u2194 p (succ a)) {a b : \u03b1} (h : a \u2264 b) :\n    p a \u2194 p b", "start": [1401, 1], "end": [1404, 84], "kind": "commanddeclaration"}, {"full_name": "LE.le.exists_pred_iterate", "code": "theorem LE.le.exists_pred_iterate (h : a \u2264 b) : \u2203 n, pred^[n] b = a", "start": [1416, 1], "end": [1417, 30], "kind": "commanddeclaration"}, {"full_name": "exists_pred_iterate_iff_le", "code": "theorem exists_pred_iterate_iff_le : (\u2203 n, pred^[n] b = a) \u2194 a \u2264 b", "start": [1420, 1], "end": [1421, 44], "kind": "commanddeclaration"}, {"full_name": "Pred.rec", "code": "@[elab_as_elim]\ntheorem Pred.rec {P : \u03b1 \u2192 Prop} {m : \u03b1} (h0 : P m) (h1 : \u2200 n, n \u2264 m \u2192 P n \u2192 P (pred n)) \u2983n : \u03b1\u2984\n    (hmn : n \u2264 m) : P n", "start": [1424, 1], "end": [1428, 38], "kind": "commanddeclaration"}, {"full_name": "Pred.rec_iff", "code": "theorem Pred.rec_iff {p : \u03b1 \u2192 Prop} (hsucc : \u2200 a, p a \u2194 p (pred a)) {a b : \u03b1} (h : a \u2264 b) :\n    p a \u2194 p b", "start": [1431, 1], "end": [1433, 47], "kind": "commanddeclaration"}, {"full_name": "exists_succ_iterate_or", "code": "theorem exists_succ_iterate_or : (\u2203 n, succ^[n] a = b) \u2228 \u2203 n, succ^[n] b = a", "start": [1448, 1], "end": [1449, 73], "kind": "commanddeclaration"}, {"full_name": "Succ.rec_linear", "code": "theorem Succ.rec_linear {p : \u03b1 \u2192 Prop} (hsucc : \u2200 a, p a \u2194 p (succ a)) (a b : \u03b1) : p a \u2194 p b", "start": [1452, 1], "end": [1453, 80], "kind": "commanddeclaration"}, {"full_name": "exists_pred_iterate_or", "code": "theorem exists_pred_iterate_or : (\u2203 n, pred^[n] b = a) \u2228 \u2203 n, pred^[n] a = b", "start": [1462, 1], "end": [1463, 73], "kind": "commanddeclaration"}, {"full_name": "Pred.rec_linear", "code": "theorem Pred.rec_linear {p : \u03b1 \u2192 Prop} (hsucc : \u2200 a, p a \u2194 p (pred a)) (a b : \u03b1) : p a \u2194 p b", "start": [1466, 1], "end": [1467, 80], "kind": "commanddeclaration"}, {"full_name": "StrictMono.not_bddAbove_range", "code": "lemma StrictMono.not_bddAbove_range [NoMaxOrder \u03b1] [SuccOrder \u03b2] [IsSuccArchimedean \u03b2]\n    (hf : StrictMono f) : \u00ac BddAbove (Set.range f) := by\n  rintro \u27e8m, hm\u27e9\n  have hm' : \u2200 a, f a \u2264 m := \u03bb a \u21a6 hm $ Set.mem_range_self _\n  obtain \u27e8a\u2080\u27e9 := \u2039Nonempty \u03b1\u203a\n  suffices \u2200 b, f a\u2080 \u2264 b \u2192 \u2203 a, b < f a by\n    obtain \u27e8a, ha\u27e9 : \u2203 a, m < f a := this m (hm' a\u2080)\n    exact ha.not_le (hm' a)\n  have h : \u2200 a, \u2203 a', f a < f a' := \u03bb a \u21a6 (exists_gt a).imp (\u03bb a' h \u21a6 hf h)\n  apply Succ.rec\n  \u00b7 exact h a\u2080\n  rintro b _ \u27e8a, hba\u27e9\n  exact (h a).imp (\u03bb a' \u21a6 (succ_le_of_lt hba).trans_lt)", "start": [1477, 1], "end": [1489, 56], "kind": "mathlibtacticlemma"}, {"full_name": "StrictMono.not_bddBelow_range", "code": "lemma StrictMono.not_bddBelow_range [NoMinOrder \u03b1] [PredOrder \u03b2] [IsPredArchimedean \u03b2]\n    (hf : StrictMono f) : \u00ac BddBelow (Set.range f) := hf.dual.not_bddAbove_range", "start": [1491, 1], "end": [1492, 81], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.not_bddAbove_range", "code": "lemma StrictAnti.not_bddAbove_range [NoMinOrder \u03b1] [SuccOrder \u03b2] [IsSuccArchimedean \u03b2]\n    (hf : StrictAnti f) : \u00ac BddAbove (Set.range f) := hf.dual_right.not_bddBelow_range", "start": [1494, 1], "end": [1495, 87], "kind": "mathlibtacticlemma"}, {"full_name": "StrictAnti.not_bddBelow_range", "code": "lemma StrictAnti.not_bddBelow_range [NoMaxOrder \u03b1] [PredOrder \u03b2] [IsPredArchimedean \u03b2]\n    (hf : StrictAnti f) : \u00ac BddBelow (Set.range f) := hf.dual_right.not_bddAbove_range", "start": [1497, 1], "end": [1498, 87], "kind": "mathlibtacticlemma"}, {"full_name": "IsWellOrder.toIsPredArchimedean", "code": "instance (priority := 100) IsWellOrder.toIsPredArchimedean [h : IsWellOrder \u03b1 (\u00b7 < \u00b7)]\n    [PredOrder \u03b1] : IsPredArchimedean \u03b1 :=\n  \u27e8fun {a b} => by\n    refine' WellFounded.fix (C := fun b => a \u2264 b \u2192 \u2203 n, Nat.iterate pred n b = a)\n      h.wf _ b\n    intros b ih hab\n    replace hab := eq_or_lt_of_le hab\n    rcases hab with (rfl | hab)\n    \u00b7 exact \u27e80, rfl\u27e9\n    cases' le_or_lt b (pred b) with hb hb\n    \u00b7 cases (min_of_le_pred hb).not_lt hab\n    dsimp at ih\n    obtain \u27e8k, hk\u27e9 := ih (pred b) hb (le_pred_of_lt hab)\n    refine' \u27e8k + 1, _\u27e9\n    rw [iterate_add_apply, iterate_one, hk]\u27e9", "start": [1506, 1], "end": [1520, 45], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder.toIsSuccArchimedean", "code": "instance (priority := 100) IsWellOrder.toIsSuccArchimedean [h : IsWellOrder \u03b1 (\u00b7 > \u00b7)]\n    [SuccOrder \u03b1] : IsSuccArchimedean \u03b1 :=\n  let h : IsPredArchimedean \u03b1\u1d52\u1d48 := by infer_instance\n  \u27e8h.1\u27e9", "start": [1523, 1], "end": [1526, 8], "kind": "commanddeclaration"}, {"full_name": "Succ.rec_bot", "code": "theorem Succ.rec_bot (p : \u03b1 \u2192 Prop) (hbot : p \u22a5) (hsucc : \u2200 a, p a \u2192 p (succ a)) (a : \u03b1) : p a", "start": [1535, 1], "end": [1536, 58], "kind": "commanddeclaration"}, {"full_name": "Pred.rec_top", "code": "theorem Pred.rec_top (p : \u03b1 \u2192 Prop) (htop : p \u22a4) (hpred : \u2200 a, p a \u2192 p (pred a)) (a : \u03b1) : p a", "start": [1545, 1], "end": [1546, 58], "kind": "commanddeclaration"}, {"full_name": "SuccOrder.forall_ne_bot_iff", "code": "lemma SuccOrder.forall_ne_bot_iff\n    [Nontrivial \u03b1] [PartialOrder \u03b1] [OrderBot \u03b1] [SuccOrder \u03b1] [IsSuccArchimedean \u03b1]\n    (P : \u03b1 \u2192 Prop) :\n    (\u2200 i, i \u2260 \u22a5 \u2192 P i) \u2194 (\u2200 i, P (SuccOrder.succ i)) := by\n  refine' \u27e8fun h i \u21a6 h _ (Order.succ_ne_bot i), fun h i hi \u21a6 _\u27e9\n  obtain \u27e8j, rfl\u27e9 := exists_succ_iterate_of_le (bot_le : \u22a5 \u2264 i)\n  have hj : 0 < j := by apply Nat.pos_of_ne_zero; contrapose! hi; simp [hi]\n  rw [\u2190 Nat.succ_pred_eq_of_pos hj]\n  simp only [Function.iterate_succ', Function.comp_apply]\n  apply h", "start": [1551, 1], "end": [1560, 10], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Order/OrderIsoNat.lean", "imports": ["Mathlib/Logic/Function/Iterate.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Denumerable.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Data/Nat/Lattice.lean"], "premises": [{"full_name": "RelEmbedding.natLT", "code": "def natLT (f : \u2115 \u2192 \u03b1) (H : \u2200 n : \u2115, r (f n) (f (n + 1))) : ((\u00b7 < \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r :=\n  ofMonotone f <| Nat.rel_of_forall_rel_succ_of_lt r H", "start": [36, 1], "end": [38, 55], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_natLT", "code": "@[simp]\ntheorem coe_natLT {f : \u2115 \u2192 \u03b1} {H : \u2200 n : \u2115, r (f n) (f (n + 1))} : \u21d1(natLT f H) = f", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.natGT", "code": "def natGT (f : \u2115 \u2192 \u03b1) (H : \u2200 n : \u2115, r (f (n + 1)) (f n)) : ((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r :=\n  haveI := IsStrictOrder.swap r\n  RelEmbedding.swap (natLT f H)", "start": [46, 1], "end": [49, 32], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.coe_natGT", "code": "@[simp]\ntheorem coe_natGT {f : \u2115 \u2192 \u03b1} {H : \u2200 n : \u2115, r (f (n + 1)) (f n)} : \u21d1(natGT f H) = f", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.exists_not_acc_lt_of_not_acc", "code": "theorem exists_not_acc_lt_of_not_acc {a : \u03b1} {r} (h : \u00acAcc r a) : \u2203 b, \u00acAcc r b \u2227 r b a", "start": [57, 1], "end": [61, 18], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.acc_iff_no_decreasing_seq", "code": "theorem acc_iff_no_decreasing_seq {x} :\n    Acc r x \u2194 IsEmpty { f : ((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r // x \u2208 Set.range f }", "start": [64, 1], "end": [80, 12], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.not_acc_of_decreasing_seq", "code": "theorem not_acc_of_decreasing_seq (f : ((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r) (k : \u2115) : \u00acAcc r (f k)", "start": [83, 1], "end": [85, 22], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.wellFounded_iff_no_descending_seq", "code": "theorem wellFounded_iff_no_descending_seq :\n    WellFounded r \u2194 IsEmpty (((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r)", "start": [88, 1], "end": [95, 63], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.not_wellFounded_of_decreasing_seq", "code": "theorem not_wellFounded_of_decreasing_seq (f : ((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r) : \u00acWellFounded r", "start": [98, 1], "end": [100, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.orderEmbeddingOfSet", "code": "def orderEmbeddingOfSet [DecidablePred (\u00b7 \u2208 s)] : \u2115 \u21aao \u2115 :=\n  (RelEmbedding.orderEmbeddingOfLTEmbedding\n    (RelEmbedding.natLT (Nat.Subtype.ofNat s) fun _ => Nat.Subtype.lt_succ_self _)).trans\n    (OrderEmbedding.subtype s)", "start": [109, 1], "end": [113, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.orderIsoOfNat", "code": "noncomputable def Subtype.orderIsoOfNat : \u2115 \u2243o s := by\n  classical\n  exact\n    RelIso.ofSurjective\n      (RelEmbedding.orderEmbeddingOfLTEmbedding\n        (RelEmbedding.natLT (Nat.Subtype.ofNat s) fun n => Nat.Subtype.lt_succ_self _))\n      Nat.Subtype.ofNat_surjective", "start": [116, 1], "end": [124, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.coe_orderEmbeddingOfSet", "code": "@[simp]\ntheorem coe_orderEmbeddingOfSet [DecidablePred (\u00b7 \u2208 s)] :\n    \u21d1(orderEmbeddingOfSet s) = (\u2191) \u2218 Subtype.ofNat s", "start": [129, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.orderEmbeddingOfSet_apply", "code": "theorem orderEmbeddingOfSet_apply [DecidablePred (\u00b7 \u2208 s)] {n : \u2115} :\n    orderEmbeddingOfSet s n = Subtype.ofNat s n", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.Subtype.orderIsoOfNat_apply", "code": "@[simp]\ntheorem Subtype.orderIsoOfNat_apply [dP : DecidablePred (\u00b7 \u2208 s)] {n : \u2115} :\n    Subtype.orderIsoOfNat s n = Subtype.ofNat s n", "start": [140, 1], "end": [143, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.orderEmbeddingOfSet_range", "code": "theorem orderEmbeddingOfSet_range [DecidablePred (\u00b7 \u2208 s)] :\n    Set.range (Nat.orderEmbeddingOfSet s) = s", "start": [148, 1], "end": [150, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_subseq_of_forall_mem_union", "code": "theorem exists_subseq_of_forall_mem_union {s t : Set \u03b1} (e : \u2115 \u2192 \u03b1) (he : \u2200 n, e n \u2208 s \u222a t) :\n    \u2203 g : \u2115 \u21aao \u2115, (\u2200 n, e (g n) \u2208 s) \u2228 \u2200 n, e (g n) \u2208 t", "start": [153, 1], "end": [161, 94], "kind": "commanddeclaration"}, {"full_name": "exists_increasing_or_nonincreasing_subseq'", "code": "theorem exists_increasing_or_nonincreasing_subseq' (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (f : \u2115 \u2192 \u03b1) :\n    \u2203 g : \u2115 \u21aao \u2115,\n      (\u2200 n : \u2115, r (f (g n)) (f (g (n + 1)))) \u2228 \u2200 m n : \u2115, m < n \u2192 \u00acr (f (g m)) (f (g n))", "start": [166, 1], "end": [198, 65], "kind": "commanddeclaration"}, {"full_name": "exists_increasing_or_nonincreasing_subseq", "code": "theorem exists_increasing_or_nonincreasing_subseq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsTrans \u03b1 r] (f : \u2115 \u2192 \u03b1) :\n    \u2203 g : \u2115 \u21aao \u2115,\n      (\u2200 m n : \u2115, m < n \u2192 r (f (g m)) (f (g n))) \u2228 \u2200 m n : \u2115, m < n \u2192 \u00acr (f (g m)) (f (g n))", "start": [201, 1], "end": [213, 36], "kind": "commanddeclaration"}, {"full_name": "WellFounded.monotone_chain_condition'", "code": "theorem WellFounded.monotone_chain_condition' [Preorder \u03b1] :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 \u2200 a : \u2115 \u2192o \u03b1, \u2203 n, \u2200 m, n \u2264 m \u2192 \u00aca n < a m", "start": [216, 1], "end": [224, 86], "kind": "commanddeclaration"}, {"full_name": "WellFounded.monotone_chain_condition", "code": "theorem WellFounded.monotone_chain_condition [PartialOrder \u03b1] :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 \u2200 a : \u2115 \u2192o \u03b1, \u2203 n, \u2200 m, n \u2264 m \u2192 a n = a m", "start": [227, 1], "end": [233, 18], "kind": "commanddeclaration"}, {"full_name": "monotonicSequenceLimitIndex", "code": "noncomputable def monotonicSequenceLimitIndex [Preorder \u03b1] (a : \u2115 \u2192o \u03b1) : \u2115 :=\n  sInf { n | \u2200 m, n \u2264 m \u2192 a n = a m }", "start": [236, 1], "end": [241, 38], "kind": "commanddeclaration"}, {"full_name": "monotonicSequenceLimit", "code": "noncomputable def monotonicSequenceLimit [Preorder \u03b1] (a : \u2115 \u2192o \u03b1) :=\n  a (monotonicSequenceLimitIndex a)", "start": [244, 1], "end": [247, 36], "kind": "commanddeclaration"}, {"full_name": "WellFounded.iSup_eq_monotonicSequenceLimit", "code": "theorem WellFounded.iSup_eq_monotonicSequenceLimit [CompleteLattice \u03b1]\n    (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) (a : \u2115 \u2192o \u03b1) :\n    iSup a = monotonicSequenceLimit a", "start": [250, 1], "end": [258, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/TFAE.lean", "imports": ["Mathlib/Util/AtomM.lean", "Mathlib/Data/List/TFAE.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.TFAE.getTFAEList", "code": "partial def getTFAEList (t : Expr) : MetaM (Q(List Prop) \u00d7 List Q(Prop)) := do\n  let .app tfae (l : Q(List Prop)) \u2190 whnfR <|\u2190 instantiateMVars t\n    | throwError \"goal must be of the form TFAE [P\u2081, P\u2082, ...]\"\n  unless (\u2190 withNewMCtxDepth <| isDefEq tfae q(TFAE)) do\n    throwError \"goal must be of the form TFAE [P\u2081, P\u2082, ...]\"\n  return (l, \u2190 getExplicitList l)\nwhere\n  \n  getExplicitList (l : Q(List Prop)) : MetaM (List Q(Prop)) := do\n    match l with\n    | ~q([]) => return ([] : List Expr)\n    | ~q($a :: $l') => return (a :: (\u2190 getExplicitList l'))\n    | e => throwError \"{e} must be an explicit list of propositions\"", "start": [81, 1], "end": [95, 69], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.dfs", "code": "partial def dfs (i j : \u2115) (P P' : Q(Prop)) (hP : Q($P)) : StateT (HashSet \u2115) MetaM Q($P') := do\n  if i == j then\n    return hP\n  modify (\u00b7.insert i)\n  for (a, b, h) in hyps do\n    if i == a then\n      if !(\u2190 get).contains b then\n        have Q := atoms[b]!\n        have h : Q($P \u2192 $Q) := h\n        try return \u2190 dfs b j Q P' q($h $hP) catch _ => pure ()\n  failure", "start": [101, 1], "end": [112, 10], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.proveImpl", "code": "def proveImpl (i j : \u2115) (P P' : Q(Prop)) : MetaM Q($P \u2192 $P') := do\n  try\n    withLocalDeclD (\u2190 mkFreshUserName `h) P fun (h : Q($P)) => do\n      mkLambdaFVars #[h] <|\u2190 dfs hyps atoms i j P P' h |>.run' {}\n  catch _ =>\n    throwError \"couldn't prove {P} \u2192 {P'}\"", "start": [114, 1], "end": [120, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.proveChain", "code": "partial def proveChain (i : \u2115) (is : List \u2115) (P : Q(Prop)) (l : Q(List Prop)) :\n    MetaM Q(Chain (\u00b7 \u2192 \u00b7) $P $l) := do\n  match l with\n  | ~q([]) => return q(Chain.nil)\n  | ~q($P' :: $l') =>\n    let i' :: is' := is | unreachable!\n    have cl' : Q(Chain (\u00b7 \u2192 \u00b7) $P' $l') := \u2190 proveChain i' is' q($P') q($l')\n    let p \u2190 proveImpl hyps atoms i i' P P'\n    return q(Chain.cons $p $cl')", "start": [122, 1], "end": [132, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.proveILast'Impl", "code": "partial def proveILast'Impl (i i' : \u2115) (is : List \u2115) (P P' : Q(Prop)) (l : Q(List Prop)) :\n    MetaM Q(ilast' $P' $l \u2192 $P) := do\n  match l with\n  | ~q([]) => proveImpl hyps atoms i' i P' P\n  | ~q($P'' :: $l') =>\n    let i'' :: is' := is | unreachable!\n    proveILast'Impl i i'' is' P P'' l'", "start": [134, 1], "end": [141, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.proveTFAE", "code": "def proveTFAE (is : List \u2115) (l : Q(List Prop)) : MetaM Q(TFAE $l) := do\n  match l with\n  | ~q([]) => return q(tfae_nil)\n  | ~q([$P]) => return q(tfae_singleton $P)\n  | ~q($P :: $P' :: $l') =>\n    let i :: i' :: is' := is | unreachable!\n    let c \u2190 proveChain hyps atoms i (i'::is') P q($P' :: $l')\n    let il \u2190 proveILast'Impl hyps atoms i i' is' P P' l'\n    return q(tfae_of_cycle $c $il)", "start": [143, 1], "end": [152, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.mkTFAEHypName", "code": "def mkTFAEHypName (i j : TSyntax `num) (arr : TSyntax ``impArrow) : MetaM Name := do\n  let arr \u2190 match arr with\n  | `(impArrow| \u2190 ) => pure \"from\"\n  | `(impArrow| \u2192 ) => pure \"to\"\n  | `(impArrow| \u2194 ) => pure \"iff\"\n  | _ => throwErrorAt arr \"expected '\u2190', '\u2192', or '\u2194'\"\n  return String.intercalate \"_\" [\"tfae\", s!\"{i.getNat}\", arr, s!\"{j.getNat}\"]", "start": [156, 1], "end": [163, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.tfaeHaveCore", "code": "def tfaeHaveCore (goal : MVarId) (name : Option (TSyntax `ident)) (i j : TSyntax `num)\n    (arrow : TSyntax ``impArrow) (t : Expr) : TermElabM (MVarId \u00d7 MVarId) :=\n  goal.withContext do\n    let n := (Syntax.getId <$> name).getD <|\u2190 mkTFAEHypName i j arrow\n    let (goal1, t, p) \u2190 do\n      let p \u2190 mkFreshExprMVar t MetavarKind.syntheticOpaque n\n      pure (p.mvarId!, t, p)\n    let (fv, goal2) \u2190 (\u2190 MVarId.assert goal n t p).intro1P\n    if let some stx := name then\n      goal2.withContext do\n        Term.addTermInfo' (isBinder := true) stx (mkFVar fv)\n    pure (goal1, goal2)", "start": [166, 1], "end": [178, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.elabIndex", "code": "def elabIndex (i : TSyntax `num) (maxIndex : \u2115) : TacticM \u2115 := do\n  let i' := i.getNat\n  unless Nat.ble 1 i' && Nat.ble i' maxIndex do\n    throwError \"{i} must be between 1 and {maxIndex}\"\n  return i'", "start": [180, 1], "end": [186, 12], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.TFAE.mkImplType", "code": "def mkImplType (Pi : Q(Prop)) (arr : TSyntax ``impArrow) (Pj : Q(Prop)) : MetaM Q(Prop) := do\n  match arr with\n  | `(impArrow| \u2190 ) => pure q($Pj \u2192 $Pi)\n  | `(impArrow| \u2192 ) => pure q($Pi \u2192 $Pj)\n  | `(impArrow| \u2194 ) => pure q($Pi \u2194 $Pj)\n  | _ => throwErrorAt arr \"expected '\u2190', '\u2192', or '\u2194'\"", "start": [188, 1], "end": [196, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sigma/Lex.lean", "imports": ["Mathlib/Data/Sigma/Basic.lean", "Mathlib/Order/RelClasses.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sigma.Lex", "code": "inductive Lex (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop) : \u2200 _ _ : \u03a3 i, \u03b1 i, Prop\n  | left {i j : \u03b9} (a : \u03b1 i) (b : \u03b1 j) : r i j \u2192 Lex r s \u27e8i, a\u27e9 \u27e8j, b\u27e9\n  | right {i : \u03b9} (a b : \u03b1 i) : s i a b \u2192 Lex r s \u27e8i, a\u27e9 \u27e8i, b\u27e9", "start": [38, 1], "end": [43, 64], "kind": "commanddeclaration"}, {"full_name": "Sigma.lex_iff", "code": "theorem lex_iff : Lex r s a b \u2194 r a.1 b.1 \u2228 \u2203 h : a.1 = b.1, s b.1 (h.rec a.2) b.2", "start": [46, 1], "end": [56, 28], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.decidable", "code": "instance Lex.decidable (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop) [DecidableEq \u03b9]\n    [DecidableRel r] [\u2200 i, DecidableRel (s i)] : DecidableRel (Lex r s) := fun _ _ =>\n  decidable_of_decidable_of_iff lex_iff.symm", "start": [59, 1], "end": [61, 45], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.mono", "code": "theorem Lex.mono (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (hs : \u2200 i a b, s\u2081 i a b \u2192 s\u2082 i a b) {a b : \u03a3 i, \u03b1 i}\n    (h : Lex r\u2081 s\u2081 a b) : Lex r\u2082 s\u2082 a b", "start": [64, 1], "end": [68, 39], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.mono_left", "code": "theorem Lex.mono_left (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) {a b : \u03a3 i, \u03b1 i} (h : Lex r\u2081 s a b) :\n    Lex r\u2082 s a b", "start": [71, 1], "end": [73, 30], "kind": "commanddeclaration"}, {"full_name": "Sigma.Lex.mono_right", "code": "theorem Lex.mono_right (hs : \u2200 i a b, s\u2081 i a b \u2192 s\u2082 i a b) {a b : \u03a3 i, \u03b1 i} (h : Lex r s\u2081 a b) :\n    Lex r s\u2082 a b", "start": [76, 1], "end": [78, 28], "kind": "commanddeclaration"}, {"full_name": "Sigma.lex_swap", "code": "theorem lex_swap : Lex (Function.swap r) s a b \u2194 Lex r (fun i => Function.swap (s i)) b a", "start": [81, 1], "end": [84, 47], "kind": "commanddeclaration"}, {"full_name": "PSigma.lex_iff", "code": "theorem lex_iff {a b : \u03a3' i, \u03b1 i} :\n    Lex r s a b \u2194 r a.1 b.1 \u2228 \u2203 h : a.1 = b.1, s b.1 (h.rec a.2) b.2", "start": [152, 1], "end": [163, 26], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.decidable", "code": "instance Lex.decidable (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop) [DecidableEq \u03b9]\n    [DecidableRel r] [\u2200 i, DecidableRel (s i)] : DecidableRel (Lex r s) := fun _ _ =>\n  decidable_of_decidable_of_iff lex_iff.symm", "start": [166, 1], "end": [168, 45], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.mono", "code": "theorem Lex.mono {r\u2081 r\u2082 : \u03b9 \u2192 \u03b9 \u2192 Prop} {s\u2081 s\u2082 : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop}\n    (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (hs : \u2200 i a b, s\u2081 i a b \u2192 s\u2082 i a b) {a b : \u03a3' i, \u03b1 i}\n    (h : Lex r\u2081 s\u2081 a b) : Lex r\u2082 s\u2082 a b", "start": [171, 1], "end": [176, 37], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.mono_left", "code": "theorem Lex.mono_left {r\u2081 r\u2082 : \u03b9 \u2192 \u03b9 \u2192 Prop} {s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop}\n    (hr : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) {a b : \u03a3' i, \u03b1 i} (h : Lex r\u2081 s a b) : Lex r\u2082 s a b", "start": [179, 1], "end": [181, 30], "kind": "commanddeclaration"}, {"full_name": "PSigma.Lex.mono_right", "code": "theorem Lex.mono_right {r : \u03b9 \u2192 \u03b9 \u2192 Prop} {s\u2081 s\u2082 : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop}\n    (hs : \u2200 i a b, s\u2081 i a b \u2192 s\u2082 i a b) {a b : \u03a3' i, \u03b1 i} (h : Lex r s\u2081 a b) : Lex r s\u2082 a b", "start": [184, 1], "end": [186, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Sigma/Lex.lean", "imports": ["Mathlib/Init/Data/Sigma/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "PSigma.lex_wf", "code": "theorem lex_wf (ha : WellFounded r) (hb : \u2200 x, WellFounded (s x)) : WellFounded (Lex r s)", "start": [30, 1], "end": [32, 78], "kind": "commanddeclaration"}, {"full_name": "PSigma.revLex_wf", "code": "theorem revLex_wf (ha : WellFounded r) (hb : WellFounded s) : WellFounded (RevLex r s)", "start": [49, 1], "end": [50, 89], "kind": "commanddeclaration"}, {"full_name": "PSigma.skipLeft_wf", "code": "theorem skipLeft_wf (\u03b1 : Type u) {\u03b2 : Type v} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} (hb : WellFounded s) :\n    WellFounded (SkipLeft \u03b1 s)", "start": [59, 1], "end": [61, 26], "kind": "commanddeclaration"}, {"full_name": "PSigma.hasWellFounded", "code": "instance hasWellFounded {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [s\u2081 : WellFoundedRelation \u03b1]\n    [s\u2082 : \u2200 a, WellFoundedRelation (\u03b2 a)] : WellFoundedRelation (PSigma \u03b2) where\n  rel := Lex s\u2081.rel fun a => (s\u2082 a).rel\n  wf := lex_wf s\u2081.wf fun a => (s\u2082 a).wf", "start": [68, 1], "end": [71, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Ring/Basic.lean", "imports": ["Mathlib/Data/Rat/Order.lean", "Mathlib/Tactic/NormNum/Inv.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/NormNum/Pow.lean", "Mathlib/Util/AtomM.lean"], "premises": [{"full_name": "Mathlib.Tactic.Ring.instCommSemiringNat", "code": "def instCommSemiringNat : CommSemiring \u2115 := inferInstance", "start": [85, 1], "end": [86, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.s\u2115", "code": "def s\u2115 : Q(CommSemiring \u2115) := q(instCommSemiringNat)", "start": [88, 1], "end": [92, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase", "code": "inductive ExBase : \u2200 {\u03b1 : Q(Type u)}, Q(CommSemiring $\u03b1) \u2192 (e : Q($\u03b1)) \u2192 Type\n  \n  | atom (id : \u2115) : ExBase s\u03b1 e\n  \n  | sum (_ : ExSum s\u03b1 e) : ExBase s\u03b1 e", "start": [99, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd", "code": "inductive ExProd : \u2200 {\u03b1 : Q(Type u)}, Q(CommSemiring $\u03b1) \u2192 (e : Q($\u03b1)) \u2192 Type\n  \n  | const (value : \u211a) (hyp : Option Expr := none) : ExProd s\u03b1 e\n  \n  | mul {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)} {x : Q($\u03b1)} {e : Q(\u2115)} {b : Q($\u03b1)} :\n    ExBase s\u03b1 x \u2192 ExProd s\u2115 e \u2192 ExProd s\u03b1 b \u2192 ExProd s\u03b1 q($x ^ $e * $b)", "start": [117, 1], "end": [129, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum", "code": "inductive ExSum : \u2200 {\u03b1 : Q(Type u)}, Q(CommSemiring $\u03b1) \u2192 (e : Q($\u03b1)) \u2192 Type\n  \n  | zero {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)} : ExSum s\u03b1 q(0 : $\u03b1)\n  \n  | add {\u03b1 : Q(Type u)} {s\u03b1 : Q(CommSemiring $\u03b1)} {a b : Q($\u03b1)} :\n    ExProd s\u03b1 a \u2192 ExSum s\u03b1 b \u2192 ExSum s\u03b1 q($a + $b)", "start": [131, 1], "end": [137, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.eq", "code": "partial def ExBase.eq : ExBase s\u03b1 a \u2192 ExBase s\u03b1 b \u2192 Bool\n  | .atom i, .atom j => i == j\n  | .sum a, .sum b => a.eq b\n  | _, _ => false", "start": [142, 1], "end": [146, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.eq", "code": "@[inherit_doc ExBase.eq]\npartial def ExProd.eq : ExProd s\u03b1 a \u2192 ExProd s\u03b1 b \u2192 Bool\n  | .const i _, .const j _ => i == j\n  | .mul a\u2081 a\u2082 a\u2083, .mul b\u2081 b\u2082 b\u2083 => a\u2081.eq b\u2081 && a\u2082.eq b\u2082 && a\u2083.eq b\u2083\n  | _, _ => false", "start": [148, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.eq", "code": "@[inherit_doc ExBase.eq]\npartial def ExSum.eq : ExSum s\u03b1 a \u2192 ExSum s\u03b1 b \u2192 Bool\n  | .zero, .zero => true\n  | .add a\u2081 a\u2082, .add b\u2081 b\u2082 => a\u2081.eq b\u2081 && a\u2082.eq b\u2082\n  | _, _ => false", "start": [154, 1], "end": [158, 18], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.cmp", "code": "partial def ExBase.cmp : ExBase s\u03b1 a \u2192 ExBase s\u03b1 b \u2192 Ordering\n  | .atom i, .atom j => compare i j\n  | .sum a, .sum b => a.cmp b\n  | .atom .., .sum .. => .lt\n  | .sum .., .atom .. => .gt", "start": [162, 1], "end": [170, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.cmp", "code": "@[inherit_doc ExBase.cmp]\npartial def ExProd.cmp : ExProd s\u03b1 a \u2192 ExProd s\u03b1 b \u2192 Ordering\n  | .const i _, .const j _ => compare i j\n  | .mul a\u2081 a\u2082 a\u2083, .mul b\u2081 b\u2082 b\u2083 => (a\u2081.cmp b\u2081).then (a\u2082.cmp b\u2082) |>.then (a\u2083.cmp b\u2083)\n  | .const _ _, .mul .. => .lt\n  | .mul .., .const _ _ => .gt", "start": [172, 1], "end": [177, 31], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.cmp", "code": "@[inherit_doc ExBase.cmp]\npartial def ExSum.cmp : ExSum s\u03b1 a \u2192 ExSum s\u03b1 b \u2192 Ordering\n  | .zero, .zero => .eq\n  | .add a\u2081 a\u2082, .add b\u2081 b\u2082 => (a\u2081.cmp b\u2081).then (a\u2082.cmp b\u2082)\n  | .zero, .add .. => .lt\n  | .add .., .zero => .gt", "start": [179, 1], "end": [184, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.cast", "code": "partial def ExBase.cast : ExBase s\u03b1 a \u2192 \u03a3 a, ExBase s\u03b2 a\n  | .atom i => \u27e8a, .atom i\u27e9\n  | .sum a => let \u27e8_, vb\u27e9 := a.cast; \u27e8_, .sum vb\u27e9", "start": [193, 1], "end": [196, 50], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.cast", "code": "partial def ExProd.cast : ExProd s\u03b1 a \u2192 \u03a3 a, ExProd s\u03b2 a\n  | .const i h => \u27e8a, .const i h\u27e9\n  | .mul a\u2081 a\u2082 a\u2083 => \u27e8_, .mul a\u2081.cast.2 a\u2082 a\u2083.cast.2\u27e9", "start": [198, 1], "end": [201, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.cast", "code": "partial def ExSum.cast : ExSum s\u03b1 a \u2192 \u03a3 a, ExSum s\u03b2 a\n  | .zero => \u27e8_, .zero\u27e9\n  | .add a\u2081 a\u2082 => \u27e8_, .add a\u2081.cast.2 a\u2082.cast.2\u27e9", "start": [203, 1], "end": [206, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.Result", "code": "structure Result {\u03b1 : Q(Type u)} (E : Q($\u03b1) \u2192 Type) (e : Q($\u03b1)) where\n  \n  expr : Q($\u03b1)\n  \n  val : E expr\n  \n  proof : Q($e = $expr)", "start": [210, 1], "end": [221, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.mkNat", "code": "def ExProd.mkNat (n : \u2115) : (e : Q($\u03b1)) \u00d7 ExProd s\u03b1 e :=\n  let lit : Q(\u2115) := mkRawNatLit n\n  \u27e8q(($lit).rawCast : $\u03b1), .const n none\u27e9", "start": [228, 1], "end": [234, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.mkNegNat", "code": "def ExProd.mkNegNat (_ : Q(Ring $\u03b1)) (n : \u2115) : (e : Q($\u03b1)) \u00d7 ExProd s\u03b1 e :=\n  let lit : Q(\u2115) := mkRawNatLit n\n  \u27e8q((Int.negOfNat $lit).rawCast : $\u03b1), .const (-n) none\u27e9", "start": [236, 1], "end": [242, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.mkRat", "code": "def ExProd.mkRat (_ : Q(DivisionRing $\u03b1)) (q : \u211a) (n : Q(\u2124)) (d : Q(\u2115)) (h : Expr) :\n    (e : Q($\u03b1)) \u00d7 ExProd s\u03b1 e :=\n  \u27e8q(Rat.rawCast $n $d : $\u03b1), .const q h\u27e9", "start": [244, 1], "end": [250, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.toProd", "code": "def ExBase.toProd (va : ExBase s\u03b1 a) (vb : ExProd s\u2115 b) :\n    ExProd s\u03b1 q($a ^ $b * (nat_lit 1).rawCast) := .mul va vb (.const 1 none)", "start": [255, 1], "end": [257, 77], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.toSum", "code": "def ExProd.toSum (v : ExProd s\u03b1 e) : ExSum s\u03b1 q($e + 0) := .add v .zero", "start": [259, 1], "end": [260, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.coeff", "code": "def ExProd.coeff : ExProd s\u03b1 e \u2192 \u211a\n  | .const q _ => q\n  | .mul _ _ v => v.coeff", "start": [262, 1], "end": [265, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.Overlap", "code": "inductive Overlap (e : Q($\u03b1)) where\n  \n  | zero (_ : Q(IsNat $e (nat_lit 0)))\n  \n  | nonzero (_ : Result (ExProd s\u03b1) e)", "start": [268, 1], "end": [278, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_overlap_pf", "code": "theorem add_overlap_pf (x : R) (e) (pq_pf : a + b = c) :\n    x ^ e * a + x ^ e * b = x ^ e * c", "start": [280, 1], "end": [281, 71], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_overlap_pf_zero", "code": "theorem add_overlap_pf_zero (x : R) (e) :\n    IsNat (a + b) (nat_lit 0) \u2192 IsNat (x ^ e * a + x ^ e * b) (nat_lit 0)", "start": [283, 1], "end": [285, 36], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalAddOverlap", "code": "def evalAddOverlap (va : ExProd s\u03b1 a) (vb : ExProd s\u03b1 b) : Option (Overlap s\u03b1 q($a + $b)) :=\n  match va, vb with\n  | .const za ha, .const zb hb => do\n    let ra := Result.ofRawRat za a ha; let rb := Result.ofRawRat zb b hb\n    let res \u2190 NormNum.evalAdd.core q($a + $b) q(HAdd.hAdd) a b ra rb\n    match res with\n    | .isNat _ (.lit (.natVal 0)) p => pure <| .zero p\n    | rc =>\n      let \u27e8zc, hc\u27e9 \u2190 rc.toRatNZ\n      let \u27e8c, pc\u27e9 := rc.toRawEq\n      pure <| .nonzero \u27e8c, .const zc hc, pc\u27e9\n  | .mul (x := a\u2081) (e := a\u2082) va\u2081 va\u2082 va\u2083, .mul vb\u2081 vb\u2082 vb\u2083 => do\n    guard (va\u2081.eq vb\u2081 && va\u2082.eq vb\u2082)\n    match \u2190 evalAddOverlap va\u2083 vb\u2083 with\n    | .zero p => pure <| .zero (q(add_overlap_pf_zero $a\u2081 $a\u2082 $p) : Expr)\n    | .nonzero \u27e8_, vc, p\u27e9 =>\n      pure <| .nonzero \u27e8_, .mul va\u2081 va\u2082 vc, (q(add_overlap_pf $a\u2081 $a\u2082 $p) : Expr)\u27e9\n  | _, _ => none", "start": [287, 1], "end": [310, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_zero_add", "code": "theorem add_pf_zero_add (b : R) : 0 + b = b", "start": [312, 1], "end": [312, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_add_zero", "code": "theorem add_pf_add_zero (a : R) : a + 0 = a", "start": [314, 1], "end": [314, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_add_overlap", "code": "theorem add_pf_add_overlap\n    (_ : a\u2081 + b\u2081 = c\u2081) (_ : a\u2082 + b\u2082 = c\u2082) : (a\u2081 + a\u2082 : R) + (b\u2081 + b\u2082) = c\u2081 + c\u2082", "start": [316, 1], "end": [318, 46], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_add_overlap_zero", "code": "theorem add_pf_add_overlap_zero\n    (h : IsNat (a\u2081 + b\u2081) (nat_lit 0)) (h\u2084 : a\u2082 + b\u2082 = c) : (a\u2081 + a\u2082 : R) + (b\u2081 + b\u2082) = c", "start": [320, 1], "end": [322, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_add_lt", "code": "theorem add_pf_add_lt (a\u2081 : R) (_ : a\u2082 + b = c) : (a\u2081 + a\u2082) + b = a\u2081 + c", "start": [324, 1], "end": [324, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pf_add_gt", "code": "theorem add_pf_add_gt (b\u2081 : R) (_ : a + b\u2082 = c) : a + (b\u2081 + b\u2082) = b\u2081 + c", "start": [326, 1], "end": [327, 35], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalAdd", "code": "partial def evalAdd (va : ExSum s\u03b1 a) (vb : ExSum s\u03b1 b) : Result (ExSum s\u03b1) q($a + $b) :=\n  match va, vb with\n  | .zero, vb => \u27e8b, vb, q(add_pf_zero_add $b)\u27e9\n  | va, .zero => \u27e8a, va, q(add_pf_add_zero $a)\u27e9\n  | .add (a := a\u2081) (b := _a\u2082) va\u2081 va\u2082, .add (a := b\u2081) (b := _b\u2082) vb\u2081 vb\u2082 =>\n    match evalAddOverlap s\u03b1 va\u2081 vb\u2081 with\n    | some (.nonzero \u27e8_, vc\u2081, pc\u2081\u27e9) =>\n      let \u27e8_, vc\u2082, pc\u2082\u27e9 := evalAdd va\u2082 vb\u2082\n      \u27e8_, .add vc\u2081 vc\u2082, q(add_pf_add_overlap $pc\u2081 $pc\u2082)\u27e9\n    | some (.zero pc\u2081) =>\n      let \u27e8c\u2082, vc\u2082, pc\u2082\u27e9 := evalAdd va\u2082 vb\u2082\n      \u27e8c\u2082, vc\u2082, q(add_pf_add_overlap_zero $pc\u2081 $pc\u2082)\u27e9\n    | none =>\n      if let .lt := va\u2081.cmp vb\u2081 then\n        let \u27e8_c, vc, (pc : Q($_a\u2082 + ($b\u2081 + $_b\u2082) = $_c))\u27e9 := evalAdd va\u2082 vb\n        \u27e8_, .add va\u2081 vc, q(add_pf_add_lt $a\u2081 $pc)\u27e9\n      else\n        let \u27e8_c, vc, (pc : Q($a\u2081 + $_a\u2082 + $_b\u2082 = $_c))\u27e9 := evalAdd va vb\u2082\n        \u27e8_, .add vb\u2081 vc, q(add_pf_add_gt $b\u2081 $pc)\u27e9", "start": [329, 1], "end": [355, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.one_mul", "code": "theorem one_mul (a : R) : (nat_lit 1).rawCast * a = a", "start": [357, 1], "end": [357, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_one", "code": "theorem mul_one (a : R) : a * (nat_lit 1).rawCast = a", "start": [359, 1], "end": [359, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_pf_left", "code": "theorem mul_pf_left (a\u2081 : R) (a\u2082) (_ : a\u2083 * b = c) : (a\u2081 ^ a\u2082 * a\u2083 : R) * b = a\u2081 ^ a\u2082 * c", "start": [361, 1], "end": [362, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_pf_right", "code": "theorem mul_pf_right (b\u2081 : R) (b\u2082) (_ : a * b\u2083 = c) : a * (b\u2081 ^ b\u2082 * b\u2083) = b\u2081 ^ b\u2082 * c", "start": [364, 1], "end": [365, 33], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_pp_pf_overlap", "code": "theorem mul_pp_pf_overlap (x : R) (_ : ea + eb = e) (_ : a\u2082 * b\u2082 = c) :\n    (x ^ ea * a\u2082 : R) * (x ^ eb * b\u2082) = x ^ e * c", "start": [367, 1], "end": [369, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalMulProd", "code": "partial def evalMulProd (va : ExProd s\u03b1 a) (vb : ExProd s\u03b1 b) : Result (ExProd s\u03b1) q($a * $b) :=\n  match va, vb with\n  | .const za ha, .const zb hb =>\n    if za = 1 then\n      \u27e8b, .const zb hb, (q(one_mul $b) : Expr)\u27e9\n    else if zb = 1 then\n      \u27e8a, .const za ha, (q(mul_one $a) : Expr)\u27e9\n    else\n      let ra := Result.ofRawRat za a ha; let rb := Result.ofRawRat zb b hb\n      let rc := (NormNum.evalMul.core q($a * $b) q(HMul.hMul) _ _\n          q(CommSemiring.toSemiring) ra rb).get!\n      let \u27e8zc, hc\u27e9 := rc.toRatNZ.get!\n      let \u27e8c, pc\u27e9 :=  rc.toRawEq\n      \u27e8c, .const zc hc, pc\u27e9\n  | .mul (x := a\u2081) (e := a\u2082) va\u2081 va\u2082 va\u2083, .const _ _ =>\n    let \u27e8_, vc, pc\u27e9 := evalMulProd va\u2083 vb\n    \u27e8_, .mul va\u2081 va\u2082 vc, (q(mul_pf_left $a\u2081 $a\u2082 $pc) : Expr)\u27e9\n  | .const _ _, .mul (x := b\u2081) (e := b\u2082) vb\u2081 vb\u2082 vb\u2083 =>\n    let \u27e8_, vc, pc\u27e9 := evalMulProd va vb\u2083\n    \u27e8_, .mul vb\u2081 vb\u2082 vc, (q(mul_pf_right $b\u2081 $b\u2082 $pc) : Expr)\u27e9\n  | .mul (x := xa) (e := ea) vxa vea va\u2082, .mul (x := xb) (e := eb) vxb veb vb\u2082 => Id.run do\n    if vxa.eq vxb then\n      if let some (.nonzero \u27e8_, ve, pe\u27e9) := evalAddOverlap s\u2115 vea veb then\n        let \u27e8_, vc, pc\u27e9 := evalMulProd va\u2082 vb\u2082\n        return \u27e8_, .mul vxa ve vc, (q(mul_pp_pf_overlap $xa $pe $pc) : Expr)\u27e9\n    if let .lt := (vxa.cmp vxb).then (vea.cmp veb) then\n      let \u27e8_, vc, pc\u27e9 := evalMulProd va\u2082 vb\n      \u27e8_, .mul vxa vea vc, (q(mul_pf_left $xa $ea $pc) : Expr)\u27e9\n    else\n      let \u27e8_, vc, pc\u27e9 := evalMulProd va vb\u2082\n      \u27e8_, .mul vxb veb vc, (q(mul_pf_right $xb $eb $pc) : Expr)\u27e9", "start": [371, 1], "end": [411, 65], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_zero", "code": "theorem mul_zero (a : R) : a * 0 = 0", "start": [413, 1], "end": [413, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_add", "code": "theorem mul_add (_ : (a : R) * b\u2081 = c\u2081) (_ : a * b\u2082 = c\u2082) (_ : c\u2081 + 0 + c\u2082 = d) :\n    a * (b\u2081 + b\u2082) = d", "start": [415, 1], "end": [416, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalMul\u2081", "code": "def evalMul\u2081 (va : ExProd s\u03b1 a) (vb : ExSum s\u03b1 b) : Result (ExSum s\u03b1) q($a * $b) :=\n  match vb with\n  | .zero => \u27e8_, .zero, q(mul_zero $a)\u27e9\n  | .add vb\u2081 vb\u2082 =>\n    let \u27e8_, vc\u2081, pc\u2081\u27e9 := evalMulProd s\u03b1 va vb\u2081\n    let \u27e8_, vc\u2082, pc\u2082\u27e9 := evalMul\u2081 va vb\u2082\n    let \u27e8_, vd, pd\u27e9 := evalAdd s\u03b1 vc\u2081.toSum vc\u2082\n    \u27e8_, vd, q(mul_add $pc\u2081 $pc\u2082 $pd)\u27e9", "start": [418, 1], "end": [430, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.zero_mul", "code": "theorem zero_mul (b : R) : 0 * b = 0", "start": [432, 1], "end": [432, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_mul", "code": "theorem add_mul (_ : (a\u2081 : R) * b = c\u2081) (_ : a\u2082 * b = c\u2082) (_ : c\u2081 + c\u2082 = d) :\n    (a\u2081 + a\u2082) * b = d", "start": [434, 1], "end": [435, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalMul", "code": "def evalMul (va : ExSum s\u03b1 a) (vb : ExSum s\u03b1 b) : Result (ExSum s\u03b1) q($a * $b) :=\n  match va with\n  | .zero => \u27e8_, .zero, q(zero_mul $b)\u27e9\n  | .add va\u2081 va\u2082 =>\n    let \u27e8_, vc\u2081, pc\u2081\u27e9 := evalMul\u2081 s\u03b1 va\u2081 vb\n    let \u27e8_, vc\u2082, pc\u2082\u27e9 := evalMul va\u2082 vb\n    let \u27e8_, vd, pd\u27e9 := evalAdd s\u03b1 vc\u2081 vc\u2082\n    \u27e8_, vd, q(add_mul $pc\u2081 $pc\u2082 $pd)\u27e9", "start": [437, 1], "end": [449, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.natCast_nat", "code": "theorem natCast_nat (n) : ((Nat.rawCast n : \u2115) : R) = Nat.rawCast n", "start": [451, 1], "end": [451, 79], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.natCast_mul", "code": "theorem natCast_mul (a\u2082) (_ : ((a\u2081 : \u2115) : R) = b\u2081) (_ : ((a\u2083 : \u2115) : R) = b\u2083) :\n    ((a\u2081 ^ a\u2082 * a\u2083 : \u2115) : R) = b\u2081 ^ a\u2082 * b\u2083", "start": [453, 1], "end": [454, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.natCast_zero", "code": "theorem natCast_zero : ((0 : \u2115) : R) = 0", "start": [456, 1], "end": [456, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.natCast_add", "code": "theorem natCast_add (_ : ((a\u2081 : \u2115) : R) = b\u2081) (_ : ((a\u2082 : \u2115) : R) = b\u2082) :\n    ((a\u2081 + a\u2082 : \u2115) : R) = b\u2081 + b\u2082", "start": [458, 1], "end": [459, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.evalNatCast", "code": "partial def ExBase.evalNatCast (va : ExBase s\u2115 a) : AtomM (Result (ExBase s\u03b1) q($a)) :=\n  match va with\n  | .atom _ => do\n    let a' : Q($\u03b1) := q($a)\n    let i \u2190 addAtom a'\n    pure \u27e8a', ExBase.atom i, (q(Eq.refl $a') : Expr)\u27e9\n  | .sum va => do\n    let \u27e8_, vc, p\u27e9 \u2190 va.evalNatCast\n    pure \u27e8_, .sum vc, p\u27e9", "start": [463, 1], "end": [476, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.evalNatCast", "code": "partial def ExProd.evalNatCast (va : ExProd s\u2115 a) : AtomM (Result (ExProd s\u03b1) q($a)) :=\n  match va with\n  | .const c hc =>\n    have n : Q(\u2115) := a.appArg!\n    pure \u27e8q(Nat.rawCast $n), .const c hc, (q(natCast_nat (R := $\u03b1) $n) : Expr)\u27e9\n  | .mul (e := a\u2082) va\u2081 va\u2082 va\u2083 => do\n    let \u27e8_, vb\u2081, pb\u2081\u27e9 \u2190 va\u2081.evalNatCast\n    let \u27e8_, vb\u2083, pb\u2083\u27e9 \u2190 va\u2083.evalNatCast\n    pure \u27e8_, .mul vb\u2081 va\u2082 vb\u2083, q(natCast_mul $a\u2082 $pb\u2081 $pb\u2083)\u27e9", "start": [478, 1], "end": [491, 61], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.evalNatCast", "code": "partial def ExSum.evalNatCast (va : ExSum s\u2115 a) : AtomM (Result (ExSum s\u03b1) q($a)) :=\n  match va with\n  | .zero => pure \u27e8_, .zero, q(natCast_zero (R := $\u03b1))\u27e9\n  | .add va\u2081 va\u2082 => do\n    let \u27e8_, vb\u2081, pb\u2081\u27e9 \u2190 va\u2081.evalNatCast\n    let \u27e8_, vb\u2082, pb\u2082\u27e9 \u2190 va\u2082.evalNatCast\n    pure \u27e8_, .add vb\u2081 vb\u2082, q(natCast_add $pb\u2081 $pb\u2082)\u27e9", "start": [493, 1], "end": [504, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.smul_nat", "code": "theorem smul_nat (_ : (a * b : \u2115) = c) : a \u2022 b = c", "start": [508, 1], "end": [508, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.smul_eq_cast", "code": "theorem smul_eq_cast (_ : ((a : \u2115) : R) = a') (_ : a' * b = c) : a \u2022 b = c", "start": [510, 1], "end": [510, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalNSMul", "code": "def evalNSMul (va : ExSum s\u2115 a) (vb : ExSum s\u03b1 b) : AtomM (Result (ExSum s\u03b1) q($a \u2022 $b)) := do\n  if \u2190 isDefEq s\u03b1 s\u2115 then\n    let \u27e8_, va'\u27e9 := va.cast\n    have _b : Q(\u2115) := b\n    let \u27e8(_c : Q(\u2115)), vc, (pc : Q($a * $_b = $_c))\u27e9 := evalMul s\u03b1 va' vb\n    pure \u27e8_, vc, (q(smul_nat $pc) : Expr)\u27e9\n  else\n    let \u27e8_, va', pa'\u27e9 \u2190 va.evalNatCast s\u03b1\n    let \u27e8_, vc, pc\u27e9 := evalMul s\u03b1 va' vb\n    pure \u27e8_, vc, (q(smul_eq_cast $pa' $pc) : Expr)\u27e9", "start": [512, 1], "end": [527, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.neg_one_mul", "code": "theorem neg_one_mul {R} [Ring R] {a b : R} (_ : (Int.negOfNat (nat_lit 1)).rawCast * a = b) :\n    -a = b", "start": [529, 1], "end": [530, 49], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.neg_mul", "code": "theorem neg_mul {R} [Ring R] (a\u2081 : R) (a\u2082) {a\u2083 b : R}\n    (_ : -a\u2083 = b) : -(a\u2081 ^ a\u2082 * a\u2083) = a\u2081 ^ a\u2082 * b", "start": [532, 1], "end": [533, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalNegProd", "code": "def evalNegProd (r\u03b1 : Q(Ring $\u03b1)) (va : ExProd s\u03b1 a) : Result (ExProd s\u03b1) q(-$a) :=\n  match va with\n  | .const za ha =>\n    let lit : Q(\u2115) := mkRawNatLit 1\n    let \u27e8m1, _\u27e9 := ExProd.mkNegNat s\u03b1 r\u03b1 1\n    let rm := Result.isNegNat r\u03b1 lit (q(IsInt.of_raw $\u03b1 (.negOfNat $lit)) : Expr)\n    let ra := Result.ofRawRat za a ha\n    let rb := (NormNum.evalMul.core q($m1 * $a) q(HMul.hMul) _ _\n      q(CommSemiring.toSemiring) rm ra).get!\n    let \u27e8zb, hb\u27e9 := rb.toRatNZ.get!\n    let \u27e8b, (pb : Q((Int.negOfNat (nat_lit 1)).rawCast * $a = $b))\u27e9 := rb.toRawEq\n    \u27e8b, .const zb hb, (q(neg_one_mul (R := $\u03b1) $pb) : Expr)\u27e9\n  | .mul (x := a\u2081) (e := a\u2082) va\u2081 va\u2082 va\u2083 =>\n    let \u27e8_, vb, pb\u27e9 := evalNegProd r\u03b1 va\u2083\n    \u27e8_, .mul va\u2081 va\u2082 vb, (q(neg_mul $a\u2081 $a\u2082 $pb) : Expr)\u27e9", "start": [535, 1], "end": [554, 58], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.neg_zero", "code": "theorem neg_zero {R} [Ring R] : -(0 : R) = 0", "start": [556, 1], "end": [556, 56], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.neg_add", "code": "theorem neg_add {R} [Ring R] {a\u2081 a\u2082 b\u2081 b\u2082 : R}\n    (_ : -a\u2081 = b\u2081) (_ : -a\u2082 = b\u2082) : -(a\u2081 + a\u2082) = b\u2081 + b\u2082", "start": [558, 1], "end": [559, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalNeg", "code": "def evalNeg (r\u03b1 : Q(Ring $\u03b1)) (va : ExSum s\u03b1 a) : Result (ExSum s\u03b1) q(-$a) :=\n  match va with\n  | .zero => \u27e8_, .zero, (q(neg_zero (R := $\u03b1)) : Expr)\u27e9\n  | .add va\u2081 va\u2082 =>\n    let \u27e8_, vb\u2081, pb\u2081\u27e9 := evalNegProd s\u03b1 r\u03b1 va\u2081\n    let \u27e8_, vb\u2082, pb\u2082\u27e9 := evalNeg r\u03b1 va\u2082\n    \u27e8_, .add vb\u2081 vb\u2082, (q(neg_add $pb\u2081 $pb\u2082) : Expr)\u27e9", "start": [561, 1], "end": [572, 53], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.sub_pf", "code": "theorem sub_pf {R} [Ring R] {a b c d : R}\n    (_ : -b = c) (_ : a + c = d) : a - b = d", "start": [574, 1], "end": [575, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalSub", "code": "def evalSub (r\u03b1 : Q(Ring $\u03b1)) (va : ExSum s\u03b1 a) (vb : ExSum s\u03b1 b) : Result (ExSum s\u03b1) q($a - $b) :=\n  let \u27e8_c, vc, pc\u27e9 := evalNeg s\u03b1 r\u03b1 vb\n  let \u27e8d, vd, (pd : Q($a + $_c = $d))\u27e9 := evalAdd s\u03b1 va vc\n  \u27e8d, vd, (q(sub_pf $pc $pd) : Expr)\u27e9", "start": [577, 1], "end": [584, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_prod_atom", "code": "theorem pow_prod_atom (a : R) (b) : a ^ b = (a + 0) ^ b * (nat_lit 1).rawCast", "start": [586, 1], "end": [586, 89], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPowProdAtom", "code": "def evalPowProdAtom (va : ExProd s\u03b1 a) (vb : ExProd s\u2115 b) : Result (ExProd s\u03b1) q($a ^ $b) :=\n  \u27e8_, (ExBase.sum va.toSum).toProd vb, q(pow_prod_atom $a $b)\u27e9", "start": [588, 1], "end": [596, 63], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_atom", "code": "theorem pow_atom (a : R) (b) : a ^ b = a ^ b * (nat_lit 1).rawCast + 0", "start": [598, 1], "end": [598, 82], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPowAtom", "code": "def evalPowAtom (va : ExBase s\u03b1 a) (vb : ExProd s\u2115 b) : Result (ExSum s\u03b1) q($a ^ $b) :=\n  \u27e8_, (va.toProd vb).toSum, q(pow_atom $a $b)\u27e9", "start": [600, 1], "end": [607, 47], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.const_pos", "code": "theorem const_pos (n : \u2115) (h : Nat.ble 1 n = true) : 0 < (n.rawCast : \u2115)", "start": [609, 1], "end": [609, 100], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_exp_pos", "code": "theorem mul_exp_pos (n) (h\u2081 : 0 < a\u2081) (h\u2082 : 0 < a\u2082) : 0 < a\u2081 ^ n * a\u2082", "start": [611, 1], "end": [612, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pos_left", "code": "theorem add_pos_left (a\u2082) (h : 0 < a\u2081) : 0 < a\u2081 + a\u2082", "start": [614, 1], "end": [614, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_pos_right", "code": "theorem add_pos_right (a\u2081) (h : 0 < a\u2082) : 0 < a\u2081 + a\u2082", "start": [616, 1], "end": [616, 99], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExBase.evalPos", "code": "partial def ExBase.evalPos (va : ExBase s\u2115 a) : Option Q(0 < $a) :=\n  match va with\n  | .atom _ => none\n  | .sum va => va.evalPos", "start": [620, 1], "end": [628, 26], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.evalPos", "code": "partial def ExProd.evalPos (va : ExProd s\u2115 a) : Option Q(0 < $a) :=\n  match va with\n  | .const _ _ =>\n    have lit : Q(\u2115) := a.appArg!\n    haveI : $a =Q Nat.rawCast $lit := \u27e8\u27e9\n    haveI p : Nat.ble 1 $lit =Q true := \u27e8\u27e9\n    by exact some (q(const_pos $lit $p))\n  | .mul (e := ea\u2081) vxa\u2081 _ va\u2082 => do\n    let pa\u2081 \u2190 vxa\u2081.evalPos\n    let pa\u2082 \u2190 va\u2082.evalPos\n    some q(mul_exp_pos $ea\u2081 $pa\u2081 $pa\u2082)", "start": [630, 1], "end": [646, 39], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.evalPos", "code": "partial def ExSum.evalPos (va : ExSum s\u2115 a) : Option Q(0 < $a) :=\n  match va with\n  | .zero => none\n  | .add (a := a\u2081) (b := a\u2082) va\u2081 va\u2082 => do\n    match va\u2081.evalPos with\n    | some p => some q(add_pos_left $a\u2082 $p)\n    | none => let p \u2190 va\u2082.evalPos; some q(add_pos_right $a\u2081 $p)", "start": [648, 1], "end": [659, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_one", "code": "theorem pow_one (a : R) : a ^ nat_lit 1 = a", "start": [663, 1], "end": [663, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_bit0", "code": "theorem pow_bit0 (_ : (a : R) ^ k = b) (_ : b * b = c) : a ^ (Nat.mul (nat_lit 2) k) = c", "start": [665, 1], "end": [666, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_bit1", "code": "theorem pow_bit1 (_ : (a : R) ^ k = b) (_ : b * b = c) (_ : c * a = d) :\n    a ^ (Nat.add (Nat.mul (nat_lit 2) k) (nat_lit 1)) = d", "start": [668, 1], "end": [670, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPowNat", "code": "partial def evalPowNat (va : ExSum s\u03b1 a) (n : Q(\u2115)) : Result (ExSum s\u03b1) q($a ^ $n) :=\n  let nn := n.natLit!\n  if nn = 1 then\n    \u27e8_, va, (q(pow_one $a) : Expr)\u27e9\n  else\n    let nm := nn >>> 1\n    have m : Q(\u2115) := mkRawNatLit nm\n    if nn &&& 1 = 0 then\n      let \u27e8_, vb, pb\u27e9 := evalPowNat va m\n      let \u27e8_, vc, pc\u27e9 := evalMul s\u03b1 vb vb\n      \u27e8_, vc, (q(pow_bit0 $pb $pc) : Expr)\u27e9\n    else\n      let \u27e8_, vb, pb\u27e9 := evalPowNat va m\n      let \u27e8_, vc, pc\u27e9 := evalMul s\u03b1 vb vb\n      let \u27e8_, vd, pd\u27e9 := evalMul s\u03b1 vc va\n      \u27e8_, vd, (q(pow_bit1 $pb $pc $pd) : Expr)\u27e9", "start": [672, 1], "end": [696, 48], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.one_pow", "code": "theorem one_pow (b : \u2115) : ((nat_lit 1).rawCast : R) ^ b = (nat_lit 1).rawCast", "start": [698, 1], "end": [698, 89], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_pow", "code": "theorem mul_pow (_ : ea\u2081 * b = c\u2081) (_ : a\u2082 ^ b = c\u2082) :\n    (xa\u2081 ^ ea\u2081 * a\u2082 : R) ^ b = xa\u2081 ^ c\u2081 * c\u2082", "start": [700, 1], "end": [701, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPowProd", "code": "def evalPowProd (va : ExProd s\u03b1 a) (vb : ExProd s\u2115 b) : Result (ExProd s\u03b1) q($a ^ $b) :=\n  let res : Option (Result (ExProd s\u03b1) q($a ^ $b)) := do\n    match va, vb with\n    | .const 1, _ => some \u27e8_, va, (q(one_pow (R := $\u03b1) $b) : Expr)\u27e9\n    | .const za ha, .const zb hb =>\n      assert! 0 \u2264 zb\n      let ra := Result.ofRawRat za a ha\n      have lit : Q(\u2115) := b.appArg!\n      let rb := (q(IsNat.of_raw \u2115 $lit) : Expr)\n      let rc \u2190 NormNum.evalPow.core q($a ^ $b) q(HPow.hPow) q($a) q($b) lit rb\n        q(CommSemiring.toSemiring) ra\n      let \u27e8zc, hc\u27e9 \u2190 rc.toRatNZ\n      let \u27e8c, pc\u27e9 := rc.toRawEq\n      some \u27e8c, .const zc hc, pc\u27e9\n    | .mul vxa\u2081 vea\u2081 va\u2082, vb => do\n      let \u27e8_, vc\u2081, pc\u2081\u27e9 := evalMulProd s\u2115 vea\u2081 vb\n      let \u27e8_, vc\u2082, pc\u2082\u27e9 := evalPowProd va\u2082 vb\n      some \u27e8_, .mul vxa\u2081 vc\u2081 vc\u2082, q(mul_pow $pc\u2081 $pc\u2082)\u27e9\n    | _, _ => none\n  res.getD (evalPowProdAtom s\u03b1 va vb)", "start": [703, 1], "end": [730, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExtractCoeff", "code": "structure ExtractCoeff (e : Q(\u2115)) where\n  \n  k : Q(\u2115)\n  \n  e' : Q(\u2115)\n  \n  ve' : ExProd s\u2115 e'\n  \n  p : Q($e = $e' * $k)", "start": [732, 1], "end": [744, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.coeff_one", "code": "theorem coeff_one (k : \u2115) : k.rawCast = (nat_lit 1).rawCast * k", "start": [746, 1], "end": [746, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.coeff_mul", "code": "theorem coeff_mul (a\u2081 a\u2082 : \u2115) (_ : a\u2083 = c\u2082 * k) : a\u2081 ^ a\u2082 * a\u2083 = (a\u2081 ^ a\u2082 * c\u2082) * k", "start": [748, 1], "end": [749, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.extractCoeff", "code": "def extractCoeff (va : ExProd s\u2115 a) : ExtractCoeff a :=\n  match va with\n  | .const _ _ =>\n    have k : Q(\u2115) := a.appArg!\n    \u27e8k, q((nat_lit 1).rawCast), .const 1, (q(coeff_one $k) : Expr)\u27e9\n  | .mul (x := a\u2081) (e := a\u2082) va\u2081 va\u2082 va\u2083 =>\n    let \u27e8k, _, vc, pc\u27e9 := extractCoeff va\u2083\n    \u27e8k, _, .mul va\u2081 va\u2082 vc, q(coeff_mul $a\u2081 $a\u2082 $pc)\u27e9", "start": [751, 1], "end": [764, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_one_cast", "code": "theorem pow_one_cast (a : R) : a ^ (nat_lit 1).rawCast = a", "start": [766, 1], "end": [766, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.zero_pow", "code": "theorem zero_pow (_ : 0 < b) : (0 : R) ^ b = 0", "start": [768, 1], "end": [768, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.single_pow", "code": "theorem single_pow (_ : (a : R) ^ b = c) : (a + 0) ^ b = c + 0", "start": [770, 1], "end": [770, 78], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_nat", "code": "theorem pow_nat (_ : b = c * k) (_ : a ^ c = d) (_ : d ^ k = e) : (a : R) ^ b = e", "start": [772, 1], "end": [773, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPow\u2081", "code": "partial def evalPow\u2081 (va : ExSum s\u03b1 a) (vb : ExProd s\u2115 b) : Result (ExSum s\u03b1) q($a ^ $b) :=\n  match va, vb with\n  | va, .const 1 =>\n    haveI : $b =Q Nat.rawCast (nat_lit 1) := \u27e8\u27e9\n    \u27e8_, va, by exact q(pow_one_cast $a)\u27e9\n  | .zero, vb => match vb.evalPos with\n    | some p => \u27e8_, .zero, q(zero_pow (R := $\u03b1) $p)\u27e9\n    | none => evalPowAtom s\u03b1 (.sum .zero) vb\n  | ExSum.add va .zero, vb => let \u27e8_, vc, pc\u27e9 := evalPowProd s\u03b1 va vb\n    \u27e8_, vc.toSum, q(single_pow $pc)\u27e9\n  | va, vb =>\n    if vb.coeff > 1 then\n      let \u27e8k, _, vc, pc\u27e9 := extractCoeff vb\n      let \u27e8_, vd, pd\u27e9 := evalPow\u2081 va vc\n      let \u27e8_, ve, pe\u27e9 := evalPowNat s\u03b1 vd k\n      \u27e8_, ve, q(pow_nat $pc $pd $pe)\u27e9\n    else evalPowAtom s\u03b1 (.sum va) vb", "start": [775, 1], "end": [801, 37], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_zero", "code": "theorem pow_zero (a : R) : a ^ 0 = (nat_lit 1).rawCast + 0", "start": [803, 1], "end": [803, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_add", "code": "theorem pow_add (_ : a ^ b\u2081 = c\u2081) (_ : a ^ b\u2082 = c\u2082) (_ : c\u2081 * c\u2082 = d) :\n    (a : R) ^ (b\u2081 + b\u2082) = d", "start": [805, 1], "end": [806, 68], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalPow", "code": "def evalPow (va : ExSum s\u03b1 a) (vb : ExSum s\u2115 b) : Result (ExSum s\u03b1) q($a ^ $b) :=\n  match vb with\n  | .zero => \u27e8_, (ExProd.mkNat s\u03b1 1).2.toSum, q(pow_zero $a)\u27e9\n  | .add vb\u2081 vb\u2082 =>\n    let \u27e8_, vc\u2081, pc\u2081\u27e9 := evalPow\u2081 s\u03b1 va vb\u2081\n    let \u27e8_, vc\u2082, pc\u2082\u27e9 := evalPow va vb\u2082\n    let \u27e8_, vd, pd\u27e9 := evalMul s\u03b1 vc\u2081 vc\u2082\n    \u27e8_, vd, q(pow_add $pc\u2081 $pc\u2082 $pd)\u27e9", "start": [808, 1], "end": [820, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.Cache", "code": "structure Cache {\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) :=\n  \n  r\u03b1 : Option Q(Ring $\u03b1)\n  \n  d\u03b1 : Option Q(DivisionRing $\u03b1)\n  \n  cz\u03b1 : Option Q(CharZero $\u03b1)", "start": [822, 1], "end": [829, 30], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mkCache", "code": "def mkCache {\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1)) : MetaM (Cache s\u03b1) :=\n  return {\n    r\u03b1 := (\u2190 trySynthInstanceQ q(Ring $\u03b1)).toOption\n    d\u03b1 := (\u2190 trySynthInstanceQ q(DivisionRing $\u03b1)).toOption\n    cz\u03b1 := (\u2190 trySynthInstanceQ q(CharZero $\u03b1)).toOption }", "start": [831, 1], "end": [836, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.cast_pos", "code": "theorem cast_pos : IsNat (a : R) n \u2192 a = n.rawCast + 0", "start": [838, 1], "end": [839, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.cast_zero", "code": "theorem cast_zero : IsNat (a : R) (nat_lit 0) \u2192 a = 0", "start": [841, 1], "end": [842, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.cast_neg", "code": "theorem cast_neg {R} [Ring R] {a : R} : IsInt a (.negOfNat n) \u2192 a = (Int.negOfNat n).rawCast + 0", "start": [844, 1], "end": [845, 23], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.cast_rat", "code": "theorem cast_rat {R} [DivisionRing R] {a : R} : IsRat a n d \u2192 a = Rat.rawCast n d + 0", "start": [847, 1], "end": [848, 42], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalCast", "code": "def evalCast : NormNum.Result e \u2192 Option (Result (ExSum s\u03b1) e)\n  | .isNat _ (.lit (.natVal 0)) p => do\n    assumeInstancesCommute\n    pure \u27e8_, .zero, q(cast_zero $p)\u27e9\n  | .isNat _ lit p => do\n    assumeInstancesCommute\n    pure \u27e8_, (ExProd.mkNat s\u03b1 lit.natLit!).2.toSum, (q(cast_pos $p) :)\u27e9\n  | .isNegNat r\u03b1 lit p =>\n    pure \u27e8_, (ExProd.mkNegNat _ r\u03b1 lit.natLit!).2.toSum, (q(cast_neg $p) : Expr)\u27e9\n  | .isRat d\u03b1 q n d p =>\n    pure \u27e8_, (ExProd.mkRat s\u03b1 d\u03b1 q n d q(IsRat.den_nz $p)).2.toSum, (q(cast_rat $p) : Expr)\u27e9\n  | _ => none", "start": [850, 1], "end": [868, 14], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.toProd_pf", "code": "theorem toProd_pf (p : (a : R) = a') :\n    a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast", "start": [870, 1], "end": [871, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.atom_pf", "code": "theorem atom_pf (a : R) : a = a ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0", "start": [872, 1], "end": [872, 91], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.atom_pf'", "code": "theorem atom_pf' (p : (a : R) = a') :\n    a = a' ^ (nat_lit 1).rawCast * (nat_lit 1).rawCast + 0", "start": [873, 1], "end": [874, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalAtom", "code": "def evalAtom (e : Q($\u03b1)) : AtomM (Result (ExSum s\u03b1) e) := do\n  let r \u2190 (\u2190 read).evalAtom e\n  have e' : Q($\u03b1) := r.expr\n  let i \u2190 addAtom e'\n  let ve' := (ExBase.atom i (e := e')).toProd (ExProd.mkNat s\u2115 1).2 |>.toSum\n  pure \u27e8_, ve', match r.proof? with\n  | none => (q(atom_pf $e) : Expr)\n  | some (p : Q($e = $e')) => (q(atom_pf' $p) : Expr)\u27e9", "start": [876, 1], "end": [888, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.inv_mul", "code": "theorem inv_mul {R} [DivisionRing R] {a\u2081 a\u2082 a\u2083 b\u2081 b\u2083 c}\n    (_ : (a\u2081\u207b\u00b9 : R) = b\u2081) (_ : (a\u2083\u207b\u00b9 : R) = b\u2083)\n    (_ : b\u2083 * (b\u2081 ^ a\u2082 * (nat_lit 1).rawCast) = c) :\n    (a\u2081 ^ a\u2082 * a\u2083 : R)\u207b\u00b9 = c", "start": [890, 1], "end": [893, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.inv_zero", "code": "nonrec theorem inv_zero {R} [DivisionRing R] : (0 : R)\u207b\u00b9 = 0", "start": [895, 1], "end": [895, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.inv_single", "code": "theorem inv_single {R} [DivisionRing R] {a b : R}\n    (_ : (a : R)\u207b\u00b9 = b) : (a + 0)\u207b\u00b9 = b + 0", "start": [897, 1], "end": [898, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.inv_add", "code": "theorem inv_add (_ : ((a\u2081 : \u2115) : R) = b\u2081) (_ : ((a\u2082 : \u2115) : R) = b\u2082) :\n    ((a\u2081 + a\u2082 : \u2115) : R) = b\u2081 + b\u2082", "start": [900, 1], "end": [901, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalInvAtom", "code": "def evalInvAtom (a : Q($\u03b1)) : AtomM (Result (ExBase s\u03b1) q($a\u207b\u00b9)) := do\n  let a' : Q($\u03b1) := q($a\u207b\u00b9)\n  let i \u2190 addAtom a'\n  pure \u27e8a', ExBase.atom i, (q(Eq.refl $a') : Expr)\u27e9", "start": [906, 1], "end": [910, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.evalInv", "code": "def ExProd.evalInv (cz\u03b1 : Option Q(CharZero $\u03b1)) (va : ExProd s\u03b1 a) :\n    AtomM (Result (ExProd s\u03b1) q($a\u207b\u00b9)) := do\n  match va with\n  | .const c hc =>\n    let ra := Result.ofRawRat c a hc\n    match NormNum.evalInv.core q($a\u207b\u00b9) a ra d\u03b1 cz\u03b1 with\n    | some rc =>\n      let \u27e8zc, hc\u27e9 := rc.toRatNZ.get!\n      let \u27e8c, pc\u27e9 := rc.toRawEq\n      pure \u27e8c, .const zc hc, pc\u27e9\n    | none =>\n      let \u27e8_, vc, pc\u27e9 \u2190 evalInvAtom s\u03b1 d\u03b1 a\n      pure \u27e8_, vc.toProd (ExProd.mkNat s\u2115 1).2, q(toProd_pf $pc)\u27e9\n  | .mul (x := a\u2081) (e := _a\u2082) _va\u2081 va\u2082 va\u2083 => do\n    let \u27e8_b\u2081, vb\u2081, pb\u2081\u27e9 \u2190 evalInvAtom s\u03b1 d\u03b1 a\u2081\n    let \u27e8_b\u2083, vb\u2083, pb\u2083\u27e9 \u2190 va\u2083.evalInv cz\u03b1\n    let \u27e8c, vc, (pc : Q($_b\u2083 * ($_b\u2081 ^ $_a\u2082 * Nat.rawCast 1) = $c))\u27e9 :=\n      evalMulProd s\u03b1 vb\u2083 (vb\u2081.toProd va\u2082)\n    pure \u27e8c, vc, (q(inv_mul $pb\u2081 $pb\u2083 $pc) : Expr)\u27e9", "start": [912, 1], "end": [935, 52], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.evalInv", "code": "def ExSum.evalInv (cz\u03b1 : Option Q(CharZero $\u03b1)) (va : ExSum s\u03b1 a) :\n    AtomM (Result (ExSum s\u03b1) q($a\u207b\u00b9)) :=\n  match va with\n  | ExSum.zero => pure \u27e8_, .zero, (q(inv_zero (R := $\u03b1)) : Expr)\u27e9\n  | ExSum.add va ExSum.zero => do\n    let \u27e8_, vb, pb\u27e9 \u2190 va.evalInv d\u03b1 cz\u03b1\n    pure \u27e8_, vb.toSum, (q(inv_single $pb) : Expr)\u27e9\n  | va => do\n    let \u27e8_, vb, pb\u27e9 \u2190 evalInvAtom s\u03b1 d\u03b1 a\n    pure \u27e8_, vb.toProd (ExProd.mkNat s\u2115 1).2 |>.toSum, q(atom_pf' $pb)\u27e9", "start": [937, 1], "end": [951, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.div_pf", "code": "theorem div_pf {R} [DivisionRing R] {a b c d : R}\n    (_ : b\u207b\u00b9 = c) (_ : a * c = d) : a / b = d", "start": [955, 1], "end": [956, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.evalDiv", "code": "def evalDiv (r\u03b1 : Q(DivisionRing $\u03b1)) (cz\u03b1 : Option Q(CharZero $\u03b1)) (va : ExSum s\u03b1 a)\n    (vb : ExSum s\u03b1 b) : AtomM (Result (ExSum s\u03b1) q($a / $b)) := do\n  let \u27e8_c, vc, pc\u27e9 \u2190 vb.evalInv s\u03b1 r\u03b1 cz\u03b1\n  let \u27e8d, vd, (pd : Q($a * $_c = $d))\u27e9 := evalMul s\u03b1 va vc\n  pure \u27e8d, vd, (q(div_pf $pc $pd) : Expr)\u27e9", "start": [958, 1], "end": [966, 43], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.add_congr", "code": "theorem add_congr (_ : a = a') (_ : b = b')\n    (_ : a' + b' = c) : (a + b : R) = c", "start": [968, 1], "end": [969, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.mul_congr", "code": "theorem mul_congr (_ : a = a') (_ : b = b')\n    (_ : a' * b' = c) : (a * b : R) = c", "start": [971, 1], "end": [972, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.nsmul_congr", "code": "theorem nsmul_congr (_ : (a : \u2115) = a') (_ : b = b')\n    (_ : a' \u2022 b' = c) : (a \u2022 (b : R)) = c", "start": [974, 1], "end": [975, 64], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.pow_congr", "code": "theorem pow_congr (_ : a = a') (_ : b = b')\n    (_ : a' ^ b' = c) : (a ^ b : R) = c", "start": [977, 1], "end": [978, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.neg_congr", "code": "theorem neg_congr {R} [Ring R] {a a' b : R} (_ : a = a')\n    (_ : -a' = b) : (-a : R) = b", "start": [980, 1], "end": [981, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.sub_congr", "code": "theorem sub_congr {R} [Ring R] {a a' b b' c : R} (_ : a = a') (_ : b = b')\n    (_ : a' - b' = c) : (a - b : R) = c", "start": [983, 1], "end": [984, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.inv_congr", "code": "theorem inv_congr {R} [DivisionRing R] {a a' b : R} (_ : a = a')\n    (_ : a'\u207b\u00b9 = b) : (a\u207b\u00b9 : R) = b", "start": [986, 1], "end": [987, 57], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.div_congr", "code": "theorem div_congr {R} [DivisionRing R] {a a' b b' c : R} (_ : a = a') (_ : b = b')\n    (_ : a' / b' = c) : (a / b : R) = c", "start": [989, 1], "end": [990, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.Cache.nat", "code": "def Cache.nat : Cache s\u2115 := { r\u03b1 := none, d\u03b1 := none, cz\u03b1 := some q(inferInstance) }", "start": [992, 1], "end": [993, 85], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.isAtomOrDerivable", "code": "def isAtomOrDerivable {u} {\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1))\n    (c : Cache s\u03b1) (e : Q($\u03b1)) : AtomM (Option (Option (Result (ExSum s\u03b1) e))) := do\n  let els := try\n      pure <| some (evalCast s\u03b1 (\u2190 derive e))\n    catch _ => pure (some none)\n  let .const n _ := (\u2190 withReducible <| whnf e).getAppFn | els\n  match n, c.r\u03b1, c.d\u03b1 with\n  | ``HAdd.hAdd, _, _ | ``Add.add, _, _\n  | ``HMul.hMul, _, _ | ``Mul.mul, _, _\n  | ``HSMul.hSMul, _, _\n  | ``HPow.hPow, _, _ | ``Pow.pow, _, _\n  | ``Neg.neg, some _, _\n  | ``HSub.hSub, some _, _ | ``Sub.sub, some _, _\n  | ``Inv.inv, _, some _\n  | ``HDiv.hDiv, _, some _ | ``Div.div, _, some _ => pure none\n  | _, _, _ => els", "start": [995, 1], "end": [1022, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.eval", "code": "partial def eval {u} {\u03b1 : Q(Type u)} (s\u03b1 : Q(CommSemiring $\u03b1))\n    (c : Cache s\u03b1) (e : Q($\u03b1)) : AtomM (Result (ExSum s\u03b1) e) := Lean.withIncRecDepth do\n  let els := do\n    try evalCast s\u03b1 (\u2190 derive e)\n    catch _ => evalAtom s\u03b1 e\n  let .const n _ := (\u2190 withReducible <| whnf e).getAppFn | els\n  match n, c.r\u03b1, c.d\u03b1 with\n  | ``HAdd.hAdd, _, _ | ``Add.add, _, _ => match e with\n    | ~q($a + $b) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u03b1 c b\n      let \u27e8c, vc, p\u27e9 := evalAdd s\u03b1 va vb\n      pure \u27e8c, vc, (q(add_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | ``HMul.hMul, _, _ | ``Mul.mul, _, _ => match e with\n    | ~q($a * $b) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u03b1 c b\n      let \u27e8c, vc, p\u27e9 := evalMul s\u03b1 va vb\n      pure \u27e8c, vc, (q(mul_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | ``HSMul.hSMul, _, _ => match e with\n    | ~q(($a : \u2115) \u2022 ($b : \u00ab$\u03b1\u00bb)) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u2115 .nat a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u03b1 c b\n      let \u27e8c, vc, p\u27e9 \u2190 evalNSMul s\u03b1 va vb\n      pure \u27e8c, vc, (q(nsmul_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | ``HPow.hPow, _, _ | ``Pow.pow, _, _ => match e with\n    | ~q($a ^ $b) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u2115 .nat b\n      let \u27e8c, vc, p\u27e9 := evalPow s\u03b1 va vb\n      pure \u27e8c, vc, (q(pow_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | ``Neg.neg, some r\u03b1, _ => match e with\n    | ~q(-$a) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8b, vb, p\u27e9 := evalNeg s\u03b1 r\u03b1 va\n      pure \u27e8b, vb, (q(neg_congr $pa $p) : Expr)\u27e9\n  | ``HSub.hSub, some r\u03b1, _ | ``Sub.sub, some r\u03b1, _ => match e with\n    | ~q($a - $b) => do\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u03b1 c b\n      let \u27e8c, vc, p\u27e9 := evalSub s\u03b1 r\u03b1 va vb\n      pure \u27e8c, vc, (q(sub_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | ``Inv.inv, _, some d\u03b1 => match e with\n    | ~q($a\u207b\u00b9) =>\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8b, vb, p\u27e9 \u2190 va.evalInv s\u03b1 d\u03b1 c.cz\u03b1\n      pure \u27e8b, vb, (q(inv_congr $pa $p) : Expr)\u27e9\n  | ``HDiv.hDiv, _, some d\u03b1 | ``Div.div, _, some d\u03b1 => match e with\n    | ~q($a / $b) => do\n      let \u27e8_, va, pa\u27e9 \u2190 eval s\u03b1 c a\n      let \u27e8_, vb, pb\u27e9 \u2190 eval s\u03b1 c b\n      let \u27e8c, vc, p\u27e9 \u2190 evalDiv s\u03b1 d\u03b1 c.cz\u03b1 va vb\n      pure \u27e8c, vc, (q(div_congr $pa $pb $p) : Expr)\u27e9\n    | _ => els\n  | _, _, _ => els", "start": [1024, 1], "end": [1087, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.of_eq", "code": "theorem of_eq (_ : (a : R) = c) (_ : b = c) : a = b", "start": [1091, 1], "end": [1091, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.proveEq", "code": "def proveEq (g : MVarId) : AtomM Unit := do\n  let some (\u03b1, e\u2081, e\u2082) := (\u2190 whnfR <|\u2190 instantiateMVars <|\u2190 g.getType).eq?\n    | throwError \"ring failed: not an equality\"\n  let .sort u \u2190 whnf (\u2190 inferType \u03b1) | unreachable!\n  let v \u2190 try u.dec catch _ => throwError \"not a type{indentExpr \u03b1}\"\n  have \u03b1 : Q(Type v) := \u03b1\n  have e\u2081 : Q($\u03b1) := e\u2081; have e\u2082 : Q($\u03b1) := e\u2082\n  let s\u03b1 \u2190 synthInstanceQ (q(CommSemiring $\u03b1) : Q(Type v))\n  let c \u2190 mkCache s\u03b1\n  profileitM Exception \"ring\" (\u2190 getOptions) do\n    let \u27e8a, va, pa\u27e9 \u2190 eval s\u03b1 c e\u2081\n    let \u27e8b, vb, pb\u27e9 \u2190 eval s\u03b1 c e\u2082\n    unless va.eq vb do\n      let g \u2190 mkFreshExprMVar (\u2190 (\u2190 ringCleanupRef.get) q($a = $b))\n      throwError \"ring failed, ring expressions not equal\\n{g.mvarId!}\"\n    let pb : Q($e\u2082 = $a) := pb\n    g.assign q(of_eq $pa $pb)", "start": [1100, 1], "end": [1117, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/SynthesizeUsing.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "synthesizeUsing", "code": "def synthesizeUsing (type : Expr) (tac : TacticM Unit) : MetaM (List MVarId \u00d7 Expr) := do\n  let m \u2190 mkFreshExprMVar type\n  let goals \u2190 (Term.withoutErrToSorry <| run m.mvarId! tac).run'\n  return (goals, \u2190 instantiateMVars m)", "start": [16, 1], "end": [28, 39], "kind": "commanddeclaration"}, {"full_name": "synthesizeUsing'", "code": "def synthesizeUsing' (type : Expr) (tac : TacticM Unit) : MetaM Expr := do\n  let (goals, e) \u2190 synthesizeUsing type tac\n  unless goals.isEmpty do\n    throwError m!\"synthesizeUsing': unsolved goals\\n{goalsToMessageData goals}\"\n  return e", "start": [30, 1], "end": [41, 11], "kind": "commanddeclaration"}, {"full_name": "synthesizeUsingTactic", "code": "def synthesizeUsingTactic (type : Expr) (tac : Syntax) : MetaM (List MVarId \u00d7 Expr) := do\n  synthesizeUsing type (do evalTactic tac)", "start": [43, 1], "end": [56, 43], "kind": "commanddeclaration"}, {"full_name": "synthesizeUsingTactic'", "code": "def synthesizeUsingTactic' (type : Expr) (tac : Syntax) : MetaM Expr := do\n  synthesizeUsing' type (do evalTactic tac)", "start": [58, 1], "end": [86, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Lemmas.lean", "imports": ["lake-packages/std/Std/Tactic/Simpa.lean", "Mathlib/Init/Data/Int/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/ZeroLEOne.lean", "Mathlib/Algebra/Order/Monoid/Lemmas.lean", "lake-packages/std/Std/Tactic/Lint/Basic.lean", "Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": [{"full_name": "Linarith.lt_irrefl", "code": "theorem lt_irrefl {\u03b1 : Type u} [Preorder \u03b1] {a : \u03b1} : \u00aca < a", "start": [26, 1], "end": [26, 83], "kind": "commanddeclaration"}, {"full_name": "Linarith.eq_of_eq_of_eq", "code": "theorem eq_of_eq_of_eq {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b = 0) : a + b = 0", "start": [28, 1], "end": [29, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.le_of_eq_of_le", "code": "theorem le_of_eq_of_le {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b \u2264 0) : a + b \u2264 0", "start": [31, 1], "end": [32, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.lt_of_eq_of_lt", "code": "theorem lt_of_eq_of_lt {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b < 0) : a + b < 0", "start": [34, 1], "end": [35, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.le_of_le_of_eq", "code": "theorem le_of_le_of_eq {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a \u2264 0) (hb : b = 0) : a + b \u2264 0", "start": [37, 1], "end": [38, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.lt_of_lt_of_eq", "code": "theorem lt_of_lt_of_eq {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a < 0) (hb : b = 0) : a + b < 0", "start": [40, 1], "end": [41, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.mul_neg", "code": "theorem mul_neg {\u03b1} [StrictOrderedRing \u03b1] {a b : \u03b1} (ha : a < 0) (hb : 0 < b) : b * a < 0", "start": [43, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "Linarith.mul_nonpos", "code": "theorem mul_nonpos {\u03b1} [OrderedRing \u03b1] {a b : \u03b1} (ha : a \u2264 0) (hb : 0 < b) : b * a \u2264 0", "start": [47, 1], "end": [49, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.mul_eq", "code": "@[nolint unusedArguments]\ntheorem mul_eq {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (_ : 0 < b) : b * a = 0", "start": [52, 1], "end": [54, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.eq_of_not_lt_of_not_gt", "code": "lemma eq_of_not_lt_of_not_gt {\u03b1} [LinearOrder \u03b1] (a b : \u03b1) (h1 : \u00ac a < b) (h2 : \u00ac b < a) : a = b :=\n  le_antisymm (le_of_not_gt h2) (le_of_not_gt h1)", "start": [56, 1], "end": [57, 50], "kind": "mathlibtacticlemma"}, {"full_name": "Linarith.mul_zero_eq", "code": "@[nolint unusedArguments]\nlemma mul_zero_eq {\u03b1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [Semiring \u03b1] {a b : \u03b1} (_ : R a 0) (h : b = 0) :\n    a * b = 0 := by\n  simp [h]", "start": [60, 1], "end": [63, 11], "kind": "mathlibtacticlemma"}, {"full_name": "Linarith.zero_mul_eq", "code": "@[nolint unusedArguments]\nlemma zero_mul_eq {\u03b1} {R : \u03b1 \u2192 \u03b1 \u2192 Prop} [Semiring \u03b1] {a b : \u03b1} (h : a = 0) (_ : R b 0) :\n    a * b = 0 := by\n  simp [h]", "start": [66, 1], "end": [69, 11], "kind": "mathlibtacticlemma"}, {"full_name": "lt_zero_of_zero_gt", "code": "theorem lt_zero_of_zero_gt [Zero \u03b1] [LT \u03b1] {a : \u03b1} (h : 0 > a) : a < 0", "start": [78, 1], "end": [78, 76], "kind": "commanddeclaration"}, {"full_name": "le_zero_of_zero_ge", "code": "theorem le_zero_of_zero_ge [Zero \u03b1] [LE \u03b1] {a : \u03b1} (h : 0 \u2265 a) : a \u2264 0", "start": [80, 1], "end": [80, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Num/Basic.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Init/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Lean/Linter/Deprecated.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Data/Nat/Bitwise.lean"], "premises": [{"full_name": "PosNum", "code": "inductive PosNum : Type\n  | one : PosNum\n  | bit1 : PosNum \u2192 PosNum\n  | bit0 : PosNum \u2192 PosNum\n  deriving DecidableEq", "start": [24, 1], "end": [31, 23], "kind": "commanddeclaration"}, {"full_name": "Num", "code": "inductive Num : Type\n  | zero : Num\n  | pos : PosNum \u2192 Num\n  deriving DecidableEq", "start": [40, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "ZNum", "code": "inductive ZNum : Type\n  | zero : ZNum\n  | pos : PosNum \u2192 ZNum\n  | neg : PosNum \u2192 ZNum\n  deriving DecidableEq", "start": [59, 1], "end": [67, 23], "kind": "commanddeclaration"}, {"full_name": "PosNum.bit", "code": "def bit (b : Bool) : PosNum \u2192 PosNum :=\n  cond b bit1 bit0", "start": [82, 1], "end": [84, 19], "kind": "commanddeclaration"}, {"full_name": "PosNum.succ", "code": "def succ : PosNum \u2192 PosNum\n  | 1 => bit0 one\n  | bit1 n => bit0 (succ n)\n  | bit0 n => bit1 n", "start": [87, 1], "end": [91, 21], "kind": "commanddeclaration"}, {"full_name": "PosNum.isOne", "code": "def isOne : PosNum \u2192 Bool\n  | 1 => true\n  | _ => false", "start": [94, 1], "end": [97, 15], "kind": "commanddeclaration"}, {"full_name": "PosNum.add", "code": "protected def add : PosNum \u2192 PosNum \u2192 PosNum\n  | 1, b => succ b\n  | a, 1 => succ a\n  | bit0 a, bit0 b => bit0 (PosNum.add a b)\n  | bit1 a, bit1 b => bit0 (succ (PosNum.add a b))\n  | bit0 a, bit1 b => bit1 (PosNum.add a b)\n  | bit1 a, bit0 b => bit1 (PosNum.add a b)", "start": [100, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "PosNum.pred'", "code": "def pred' : PosNum \u2192 Num\n  | 1 => 0\n  | bit0 n => Num.pos (Num.casesOn (pred' n) 1 bit1)\n  | bit1 n => Num.pos (bit0 n)", "start": [113, 1], "end": [117, 31], "kind": "commanddeclaration"}, {"full_name": "PosNum.pred", "code": "def pred (a : PosNum) : PosNum :=\n  Num.casesOn (pred' a) 1 id", "start": [120, 1], "end": [122, 29], "kind": "commanddeclaration"}, {"full_name": "PosNum.size", "code": "def size : PosNum \u2192 PosNum\n  | 1 => 1\n  | bit0 n => succ (size n)\n  | bit1 n => succ (size n)", "start": [125, 1], "end": [129, 28], "kind": "commanddeclaration"}, {"full_name": "PosNum.natSize", "code": "def natSize : PosNum \u2192 Nat\n  | 1 => 1\n  | bit0 n => Nat.succ (natSize n)\n  | bit1 n => Nat.succ (natSize n)", "start": [132, 1], "end": [136, 35], "kind": "commanddeclaration"}, {"full_name": "PosNum.mul", "code": "protected def mul (a : PosNum) : PosNum \u2192 PosNum\n  | 1 => a\n  | bit0 b => bit0 (PosNum.mul a b)\n  | bit1 b => bit0 (PosNum.mul a b) + a", "start": [139, 1], "end": [143, 40], "kind": "commanddeclaration"}, {"full_name": "PosNum.ofNatSucc", "code": "def ofNatSucc : \u2115 \u2192 PosNum\n  | 0 => 1\n  | Nat.succ n => succ (ofNatSucc n)", "start": [149, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "PosNum.ofNat", "code": "def ofNat (n : \u2115) : PosNum :=\n  ofNatSucc (Nat.pred n)", "start": [155, 1], "end": [157, 25], "kind": "commanddeclaration"}, {"full_name": "PosNum.cmp", "code": "def cmp : PosNum \u2192 PosNum \u2192 Ordering\n  | 1, 1 => eq\n  | _, 1 => gt\n  | 1, _ => lt\n  | bit0 a, bit0 b => cmp a b\n  | bit0 a, bit1 b => Ordering.casesOn (cmp a b) lt lt gt\n  | bit1 a, bit0 b => Ordering.casesOn (cmp a b) lt gt gt\n  | bit1 a, bit1 b => cmp a b", "start": [165, 1], "end": [173, 30], "kind": "commanddeclaration"}, {"full_name": "PosNum.decidableLT", "code": "instance decidableLT : @DecidableRel PosNum (\u00b7 < \u00b7)\n  | a, b => by dsimp [LT.lt]; infer_instance", "start": [182, 1], "end": [183, 45], "kind": "commanddeclaration"}, {"full_name": "PosNum.decidableLE", "code": "instance decidableLE : @DecidableRel PosNum (\u00b7 \u2264 \u00b7)\n  | a, b => by dsimp [LE.le]; infer_instance", "start": [186, 1], "end": [187, 45], "kind": "commanddeclaration"}, {"full_name": "castPosNum", "code": "@[deprecated, coe] def castPosNum : PosNum \u2192 \u03b1\n  | 1 => 1\n  | PosNum.bit0 a => bit0 (castPosNum a)\n  | PosNum.bit1 a => bit1 (castPosNum a)", "start": [199, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "castNum", "code": "@[deprecated, coe] def castNum [Zero \u03b1] : Num \u2192 \u03b1\n  | 0 => 0\n  | Num.pos p => castPosNum p", "start": [206, 1], "end": [209, 30], "kind": "commanddeclaration"}, {"full_name": "posNumCoe", "code": "@[deprecated] instance (priority := 900) posNumCoe : CoeHTCT PosNum \u03b1 :=\n  \u27e8castPosNum\u27e9", "start": [213, 1], "end": [214, 15], "kind": "commanddeclaration"}, {"full_name": "numNatCoe", "code": "@[deprecated] instance (priority := 900) numNatCoe [Zero \u03b1] : CoeHTCT Num \u03b1 :=\n  \u27e8castNum\u27e9", "start": [218, 1], "end": [219, 12], "kind": "commanddeclaration"}, {"full_name": "Num.succ'", "code": "def succ' : Num \u2192 PosNum\n  | 0 => 1\n  | pos p => succ p", "start": [236, 1], "end": [239, 20], "kind": "commanddeclaration"}, {"full_name": "Num.succ", "code": "def succ (n : Num) : Num :=\n  pos (succ' n)", "start": [242, 1], "end": [244, 16], "kind": "commanddeclaration"}, {"full_name": "Num.add", "code": "protected def add : Num \u2192 Num \u2192 Num\n  | 0, a => a\n  | b, 0 => b\n  | pos a, pos b => pos (a + b)", "start": [247, 1], "end": [251, 32], "kind": "commanddeclaration"}, {"full_name": "Num.bit0", "code": "protected def bit0 : Num \u2192 Num\n  | 0 => 0\n  | pos n => pos (PosNum.bit0 n)", "start": [257, 1], "end": [260, 33], "kind": "commanddeclaration"}, {"full_name": "Num.bit1", "code": "protected def bit1 : Num \u2192 Num\n  | 0 => 1\n  | pos n => pos (PosNum.bit1 n)", "start": [263, 1], "end": [266, 33], "kind": "commanddeclaration"}, {"full_name": "Num.bit", "code": "def bit (b : Bool) : Num \u2192 Num :=\n  cond b Num.bit1 Num.bit0", "start": [269, 1], "end": [271, 27], "kind": "commanddeclaration"}, {"full_name": "Num.size", "code": "def size : Num \u2192 Num\n  | 0 => 0\n  | pos n => pos (PosNum.size n)", "start": [274, 1], "end": [277, 33], "kind": "commanddeclaration"}, {"full_name": "Num.natSize", "code": "def natSize : Num \u2192 Nat\n  | 0 => 0\n  | pos n => PosNum.natSize n", "start": [280, 1], "end": [283, 30], "kind": "commanddeclaration"}, {"full_name": "Num.mul", "code": "protected def mul : Num \u2192 Num \u2192 Num\n  | 0, _ => 0\n  | _, 0 => 0\n  | pos a, pos b => pos (a * b)", "start": [286, 1], "end": [290, 32], "kind": "commanddeclaration"}, {"full_name": "Num.cmp", "code": "def cmp : Num \u2192 Num \u2192 Ordering\n  | 0, 0 => eq\n  | _, 0 => gt\n  | 0, _ => lt\n  | pos a, pos b => PosNum.cmp a b", "start": [298, 1], "end": [303, 35], "kind": "commanddeclaration"}, {"full_name": "Num.decidableLT", "code": "instance decidableLT : @DecidableRel Num (\u00b7 < \u00b7)\n  | a, b => by dsimp [LT.lt]; infer_instance", "start": [312, 1], "end": [313, 45], "kind": "commanddeclaration"}, {"full_name": "Num.decidableLE", "code": "instance decidableLE : @DecidableRel Num (\u00b7 \u2264 \u00b7)\n  | a, b => by dsimp [LE.le]; infer_instance", "start": [316, 1], "end": [317, 45], "kind": "commanddeclaration"}, {"full_name": "Num.toZNum", "code": "def toZNum : Num \u2192 ZNum\n  | 0 => 0\n  | pos a => ZNum.pos a", "start": [320, 1], "end": [323, 24], "kind": "commanddeclaration"}, {"full_name": "Num.toZNumNeg", "code": "def toZNumNeg : Num \u2192 ZNum\n  | 0 => 0\n  | pos a => ZNum.neg a", "start": [326, 1], "end": [329, 24], "kind": "commanddeclaration"}, {"full_name": "Num.ofNat'", "code": "def ofNat' : \u2115 \u2192 Num :=\n  Nat.binaryRec 0 (fun b _ => cond b Num.bit1 Num.bit0)", "start": [332, 1], "end": [334, 56], "kind": "commanddeclaration"}, {"full_name": "ZNum.zNeg", "code": "def zNeg : ZNum \u2192 ZNum\n  | 0 => 0\n  | pos a => neg a\n  | neg a => pos a", "start": [343, 1], "end": [347, 19], "kind": "commanddeclaration"}, {"full_name": "ZNum.abs", "code": "def abs : ZNum \u2192 Num\n  | 0 => 0\n  | pos a => Num.pos a\n  | neg a => Num.pos a", "start": [353, 1], "end": [357, 23], "kind": "commanddeclaration"}, {"full_name": "ZNum.succ", "code": "def succ : ZNum \u2192 ZNum\n  | 0 => 1\n  | pos a => pos (PosNum.succ a)\n  | neg a => (PosNum.pred' a).toZNumNeg", "start": [360, 1], "end": [364, 40], "kind": "commanddeclaration"}, {"full_name": "ZNum.pred", "code": "def pred : ZNum \u2192 ZNum\n  | 0 => neg 1\n  | pos a => (PosNum.pred' a).toZNum\n  | neg a => neg (PosNum.succ a)", "start": [367, 1], "end": [371, 33], "kind": "commanddeclaration"}, {"full_name": "ZNum.bit0", "code": "protected def bit0 : ZNum \u2192 ZNum\n  | 0 => 0\n  | pos n => pos (PosNum.bit0 n)\n  | neg n => neg (PosNum.bit0 n)", "start": [374, 1], "end": [378, 33], "kind": "commanddeclaration"}, {"full_name": "ZNum.bit1", "code": "protected def bit1 : ZNum \u2192 ZNum\n  | 0 => 1\n  | pos n => pos (PosNum.bit1 n)\n  | neg n => neg (Num.casesOn (pred' n) 1 PosNum.bit1)", "start": [381, 1], "end": [385, 55], "kind": "commanddeclaration"}, {"full_name": "ZNum.bitm1", "code": "protected def bitm1 : ZNum \u2192 ZNum\n  | 0 => neg 1\n  | pos n => pos (Num.casesOn (pred' n) 1 PosNum.bit1)\n  | neg n => neg (PosNum.bit1 n)", "start": [388, 1], "end": [392, 33], "kind": "commanddeclaration"}, {"full_name": "ZNum.ofInt'", "code": "def ofInt' : \u2124 \u2192 ZNum\n  | Int.ofNat n => Num.toZNum (Num.ofNat' n)\n  | Int.negSucc n => Num.toZNumNeg (Num.ofNat' (n + 1))", "start": [395, 1], "end": [398, 56], "kind": "commanddeclaration"}, {"full_name": "PosNum.sub'", "code": "def sub' : PosNum \u2192 PosNum \u2192 ZNum\n  | a, 1 => (pred' a).toZNum\n  | 1, b => (pred' b).toZNumNeg\n  | bit0 a, bit0 b => (sub' a b).bit0\n  | bit0 a, bit1 b => (sub' a b).bitm1\n  | bit1 a, bit0 b => (sub' a b).bit1\n  | bit1 a, bit1 b => (sub' a b).bit0", "start": [407, 1], "end": [414, 38], "kind": "commanddeclaration"}, {"full_name": "PosNum.ofZNum'", "code": "def ofZNum' : ZNum \u2192 Option PosNum\n  | ZNum.pos p => some p\n  | _ => none", "start": [417, 1], "end": [421, 14], "kind": "commanddeclaration"}, {"full_name": "PosNum.ofZNum", "code": "def ofZNum : ZNum \u2192 PosNum\n  | ZNum.pos p => p\n  | _ => 1", "start": [424, 1], "end": [427, 11], "kind": "commanddeclaration"}, {"full_name": "PosNum.sub", "code": "protected def sub (a b : PosNum) : PosNum :=\n  match sub' a b with\n  | ZNum.pos p => p\n  | _ => 1", "start": [430, 1], "end": [434, 11], "kind": "commanddeclaration"}, {"full_name": "Num.ppred", "code": "def ppred : Num \u2192 Option Num\n  | 0 => none\n  | pos p => some p.pred'", "start": [444, 1], "end": [447, 26], "kind": "commanddeclaration"}, {"full_name": "Num.pred", "code": "def pred : Num \u2192 Num\n  | 0 => 0\n  | pos p => p.pred'", "start": [450, 1], "end": [453, 21], "kind": "commanddeclaration"}, {"full_name": "Num.div2", "code": "def div2 : Num \u2192 Num\n  | 0 => 0\n  | 1 => 0\n  | pos (PosNum.bit0 p) => pos p\n  | pos (PosNum.bit1 p) => pos p", "start": [456, 1], "end": [461, 33], "kind": "commanddeclaration"}, {"full_name": "Num.ofZNum'", "code": "def ofZNum' : ZNum \u2192 Option Num\n  | 0 => some 0\n  | ZNum.pos p => some (pos p)\n  | ZNum.neg _ => none", "start": [464, 1], "end": [468, 23], "kind": "commanddeclaration"}, {"full_name": "Num.ofZNum", "code": "def ofZNum : ZNum \u2192 Num\n  | ZNum.pos p => pos p\n  | _ => 0", "start": [471, 1], "end": [474, 11], "kind": "commanddeclaration"}, {"full_name": "Num.sub'", "code": "def sub' : Num \u2192 Num \u2192 ZNum\n  | 0, 0 => 0\n  | pos a, 0 => ZNum.pos a\n  | 0, pos b => ZNum.neg b\n  | pos a, pos b => a.sub' b", "start": [477, 1], "end": [482, 29], "kind": "commanddeclaration"}, {"full_name": "Num.psub", "code": "def psub (a b : Num) : Option Num :=\n  ofZNum' (sub' a b)", "start": [485, 1], "end": [487, 21], "kind": "commanddeclaration"}, {"full_name": "Num.sub", "code": "protected def sub (a b : Num) : Num :=\n  ofZNum (sub' a b)", "start": [490, 1], "end": [492, 20], "kind": "commanddeclaration"}, {"full_name": "ZNum.add", "code": "protected def add : ZNum \u2192 ZNum \u2192 ZNum\n  | 0, a => a\n  | b, 0 => b\n  | pos a, pos b => pos (a + b)\n  | pos a, neg b => sub' a b\n  | neg a, pos b => sub' b a\n  | neg a, neg b => neg (a + b)", "start": [504, 1], "end": [511, 32], "kind": "commanddeclaration"}, {"full_name": "ZNum.mul", "code": "protected def mul : ZNum \u2192 ZNum \u2192 ZNum\n  | 0, _ => 0\n  | _, 0 => 0\n  | pos a, pos b => pos (a * b)\n  | pos a, neg b => neg (a * b)\n  | neg a, pos b => neg (a * b)\n  | neg a, neg b => pos (a * b)", "start": [517, 1], "end": [524, 32], "kind": "commanddeclaration"}, {"full_name": "ZNum.cmp", "code": "def cmp : ZNum \u2192 ZNum \u2192 Ordering\n  | 0, 0 => eq\n  | pos a, pos b => PosNum.cmp a b\n  | neg a, neg b => PosNum.cmp b a\n  | pos _, _ => gt\n  | neg _, _ => lt\n  | _, pos _ => lt\n  | _, neg _ => gt", "start": [532, 1], "end": [540, 19], "kind": "commanddeclaration"}, {"full_name": "ZNum.decidableLT", "code": "instance decidableLT : @DecidableRel ZNum (\u00b7 < \u00b7)\n  | a, b => by dsimp [LT.lt]; infer_instance", "start": [549, 1], "end": [550, 45], "kind": "commanddeclaration"}, {"full_name": "ZNum.decidableLE", "code": "instance decidableLE : @DecidableRel ZNum (\u00b7 \u2264 \u00b7)\n  | a, b => by dsimp [LE.le]; infer_instance", "start": [553, 1], "end": [554, 45], "kind": "commanddeclaration"}, {"full_name": "PosNum.divModAux", "code": "def divModAux (d : PosNum) (q r : Num) : Num \u00d7 Num :=\n  match Num.ofZNum' (Num.sub' r (Num.pos d)) with\n  | some r' => (Num.bit1 q, r')\n  | none => (Num.bit0 q, r)", "start": [561, 1], "end": [565, 28], "kind": "commanddeclaration"}, {"full_name": "PosNum.divMod", "code": "def divMod (d : PosNum) : PosNum \u2192 Num \u00d7 Num\n  | bit0 n =>\n    let (q, r\u2081) := divMod d n\n    divModAux d q (Num.bit0 r\u2081)\n  | bit1 n =>\n    let (q, r\u2081) := divMod d n\n    divModAux d q (Num.bit1 r\u2081)\n  | 1 => divModAux d 0 1", "start": [568, 1], "end": [576, 25], "kind": "commanddeclaration"}, {"full_name": "PosNum.div'", "code": "def div' (n d : PosNum) : Num :=\n  (divMod d n).1", "start": [579, 1], "end": [581, 17], "kind": "commanddeclaration"}, {"full_name": "PosNum.mod'", "code": "def mod' (n d : PosNum) : Num :=\n  (divMod d n).2", "start": [584, 1], "end": [586, 17], "kind": "commanddeclaration"}, {"full_name": "PosNum.sqrtAux1", "code": "private def sqrtAux1 (b : PosNum) (r n : Num) : Num \u00d7 Num :=\n  match Num.ofZNum' (n.sub' (r + Num.pos b)) with\n  | some n' => (r.div2 + Num.pos b, n')\n  | none => (r.div2, n)", "start": [589, 1], "end": [593, 24], "kind": "commanddeclaration"}, {"full_name": "PosNum.sqrtAux", "code": "private def sqrtAux : PosNum \u2192 Num \u2192 Num \u2192 Num\n  | b@(bit0 b') => fun r n => let (r', n') := sqrtAux1 b r n; sqrtAux b' r' n'\n  | b@(bit1 b') => fun r n => let (r', n') := sqrtAux1 b r n; sqrtAux b' r' n'\n  | 1           => fun r n => (sqrtAux1 1 r n).1", "start": [595, 1], "end": [599, 49], "kind": "commanddeclaration"}, {"full_name": "Num.div", "code": "def div : Num \u2192 Num \u2192 Num\n  | 0, _ => 0\n  | _, 0 => 0\n  | pos n, pos d => PosNum.div' n d", "start": [605, 1], "end": [609, 36], "kind": "commanddeclaration"}, {"full_name": "Num.mod", "code": "def mod : Num \u2192 Num \u2192 Num\n  | 0, _ => 0\n  | n, 0 => n\n  | pos n, pos d => PosNum.mod' n d", "start": [612, 1], "end": [616, 36], "kind": "commanddeclaration"}, {"full_name": "Num.gcdAux", "code": "def gcdAux : Nat \u2192 Num \u2192 Num \u2192 Num\n  | 0, _, b => b\n  | Nat.succ _, 0, b => b\n  | Nat.succ n, a, b => gcdAux n (b % a) a", "start": [625, 1], "end": [629, 43], "kind": "commanddeclaration"}, {"full_name": "Num.gcd", "code": "def gcd (a b : Num) : Num :=\n  if a \u2264 b then gcdAux (a.natSize + b.natSize) a b else gcdAux (b.natSize + a.natSize) b a", "start": [632, 1], "end": [634, 91], "kind": "commanddeclaration"}, {"full_name": "ZNum.div", "code": "def div : ZNum \u2192 ZNum \u2192 ZNum\n  | 0, _ => 0\n  | _, 0 => 0\n  | pos n, pos d => Num.toZNum (PosNum.div' n d)\n  | pos n, neg d => Num.toZNumNeg (PosNum.div' n d)\n  | neg n, pos d => neg (PosNum.pred' n / Num.pos d).succ'\n  | neg n, neg d => pos (PosNum.pred' n / Num.pos d).succ'", "start": [641, 1], "end": [648, 59], "kind": "commanddeclaration"}, {"full_name": "ZNum.mod", "code": "def mod : ZNum \u2192 ZNum \u2192 ZNum\n  | 0, _ => 0\n  | pos n, d => Num.toZNum (Num.pos n % d.abs)\n  | neg n, d => d.abs.sub' (PosNum.pred' n % d.abs).succ", "start": [651, 1], "end": [655, 57], "kind": "commanddeclaration"}, {"full_name": "ZNum.gcd", "code": "def gcd (a b : ZNum) : Num :=\n  a.abs.gcd b.abs", "start": [664, 1], "end": [666, 18], "kind": "commanddeclaration"}, {"full_name": "castZNum", "code": "@[deprecated, coe] def castZNum : ZNum \u2192 \u03b1\n  | 0 => 0\n  | ZNum.pos p => p\n  | ZNum.neg p => -p", "start": [676, 1], "end": [680, 21], "kind": "commanddeclaration"}, {"full_name": "znumCoe", "code": "@[deprecated] instance (priority := 900) znumCoe : CoeHTCT ZNum \u03b1 :=\n  \u27e8castZNum\u27e9", "start": [684, 1], "end": [685, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Minimal.lean", "imports": ["Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Order/Antichain.lean", "Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "maximals", "code": "def maximals : Set \u03b1 :=\n  { a \u2208 s | \u2200 \u2983b\u2984, b \u2208 s \u2192 r a b \u2192 r b a }", "start": [34, 1], "end": [36, 43], "kind": "commanddeclaration"}, {"full_name": "minimals", "code": "def minimals : Set \u03b1 :=\n  { a \u2208 s | \u2200 \u2983b\u2984, b \u2208 s \u2192 r b a \u2192 r a b }", "start": [39, 1], "end": [41, 43], "kind": "commanddeclaration"}, {"full_name": "maximals_subset", "code": "theorem maximals_subset : maximals r s \u2286 s", "start": [44, 1], "end": [45, 17], "kind": "commanddeclaration"}, {"full_name": "minimals_subset", "code": "theorem minimals_subset : minimals r s \u2286 s", "start": [48, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "maximals_empty", "code": "@[simp]\ntheorem maximals_empty : maximals r \u2205 = \u2205", "start": [52, 1], "end": [54, 14], "kind": "commanddeclaration"}, {"full_name": "minimals_empty", "code": "@[simp]\ntheorem minimals_empty : minimals r \u2205 = \u2205", "start": [57, 1], "end": [59, 14], "kind": "commanddeclaration"}, {"full_name": "maximals_singleton", "code": "@[simp]\ntheorem maximals_singleton : maximals r {a} = {a}", "start": [62, 1], "end": [68, 18], "kind": "commanddeclaration"}, {"full_name": "minimals_singleton", "code": "@[simp]\ntheorem minimals_singleton : minimals r {a} = {a}", "start": [71, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "maximals_swap", "code": "theorem maximals_swap : maximals (swap r) s = minimals r s", "start": [76, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "minimals_swap", "code": "theorem minimals_swap : minimals (swap r) s = maximals r s", "start": [80, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "eq_of_mem_maximals", "code": "theorem eq_of_mem_maximals (ha : a \u2208 maximals r s) (hb : b \u2208 s) (h : r a b) : a = b", "start": [88, 1], "end": [89, 26], "kind": "commanddeclaration"}, {"full_name": "eq_of_mem_minimals", "code": "theorem eq_of_mem_minimals (ha : a \u2208 minimals r s) (hb : b \u2208 s) (h : r b a) : a = b", "start": [92, 1], "end": [93, 25], "kind": "commanddeclaration"}, {"full_name": "mem_maximals_iff", "code": "theorem mem_maximals_iff : x \u2208 maximals r s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, y \u2208 s \u2192 r x y \u2192 x = y", "start": [96, 1], "end": [99, 33], "kind": "commanddeclaration"}, {"full_name": "mem_maximals_setOf_iff", "code": "theorem mem_maximals_setOf_iff : x \u2208 maximals r (setOf P) \u2194 P x \u2227 \u2200 \u2983y\u2984, P y \u2192 r x y \u2192 x = y", "start": [101, 1], "end": [102, 19], "kind": "commanddeclaration"}, {"full_name": "mem_minimals_iff", "code": "theorem mem_minimals_iff : x \u2208 minimals r s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, y \u2208 s \u2192 r y x \u2192 x = y", "start": [104, 1], "end": [105, 48], "kind": "commanddeclaration"}, {"full_name": "mem_minimals_setOf_iff", "code": "theorem mem_minimals_setOf_iff : x \u2208 minimals r (setOf P) \u2194 P x \u2227 \u2200 \u2983y\u2984, P y \u2192 r y x \u2192 x = y", "start": [107, 1], "end": [108, 19], "kind": "commanddeclaration"}, {"full_name": "mem_minimals_iff_forall_lt_not_mem'", "code": "theorem mem_minimals_iff_forall_lt_not_mem' (rlt : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsNonstrictStrictOrder \u03b1 r rlt] :\n    x \u2208 minimals r s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, rlt y x \u2192 y \u2209 s", "start": [110, 1], "end": [115, 88], "kind": "commanddeclaration"}, {"full_name": "mem_maximals_iff_forall_lt_not_mem'", "code": "theorem mem_maximals_iff_forall_lt_not_mem' (rlt : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsNonstrictStrictOrder \u03b1 r rlt] :\n    x \u2208 maximals r s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, rlt x y \u2192 y \u2209 s", "start": [117, 1], "end": [119, 88], "kind": "commanddeclaration"}, {"full_name": "minimals_eq_minimals_of_subset_of_forall", "code": "theorem minimals_eq_minimals_of_subset_of_forall [IsTrans \u03b1 r] (hts : t \u2286 s)\n    (h : \u2200 x \u2208 s, \u2203 y \u2208 t, r y x) : minimals r s = minimals r t", "start": [121, 1], "end": [128, 75], "kind": "commanddeclaration"}, {"full_name": "maximals_eq_maximals_of_subset_of_forall", "code": "theorem maximals_eq_maximals_of_subset_of_forall [IsTrans \u03b1 r] (hts : t \u2286 s)\n    (h : \u2200 x \u2208 s, \u2203 y \u2208 t, r x y) : maximals r s = maximals r t", "start": [130, 1], "end": [132, 95], "kind": "commanddeclaration"}, {"full_name": "maximals_antichain", "code": "theorem maximals_antichain : IsAntichain r (maximals r s)", "start": [136, 1], "end": [137, 38], "kind": "commanddeclaration"}, {"full_name": "minimals_antichain", "code": "theorem minimals_antichain : IsAntichain r (minimals r s)", "start": [140, 1], "end": [142, 32], "kind": "commanddeclaration"}, {"full_name": "mem_minimals_iff_forall_ssubset_not_mem", "code": "theorem mem_minimals_iff_forall_ssubset_not_mem (s : Set (Set \u03b1)) :\n    x \u2208 minimals (\u00b7 \u2286 \u00b7) s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, y \u2282 x \u2192 y \u2209 s", "start": [147, 1], "end": [149, 46], "kind": "commanddeclaration"}, {"full_name": "mem_minimals_iff_forall_lt_not_mem", "code": "theorem mem_minimals_iff_forall_lt_not_mem [PartialOrder \u03b1] {s : Set \u03b1} :\n    x \u2208 minimals (\u00b7 \u2264 \u00b7) s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, y < x \u2192 y \u2209 s", "start": [151, 1], "end": [153, 46], "kind": "commanddeclaration"}, {"full_name": "mem_maximals_iff_forall_ssubset_not_mem", "code": "theorem mem_maximals_iff_forall_ssubset_not_mem {s : Set (Set \u03b1)} :\n    x \u2208 maximals (\u00b7 \u2286 \u00b7) s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, x \u2282 y \u2192 y \u2209 s", "start": [155, 1], "end": [157, 46], "kind": "commanddeclaration"}, {"full_name": "mem_maximals_iff_forall_lt_not_mem", "code": "theorem mem_maximals_iff_forall_lt_not_mem [PartialOrder \u03b1] {s : Set \u03b1} :\n    x \u2208 maximals (\u00b7 \u2264 \u00b7) s \u2194 x \u2208 s \u2227 \u2200 \u2983y\u2984, x < y \u2192 y \u2209 s", "start": [159, 1], "end": [161, 46], "kind": "commanddeclaration"}, {"full_name": "maximals_of_symm", "code": "theorem maximals_of_symm [IsSymm \u03b1 r] : maximals r s = s", "start": [164, 1], "end": [165, 52], "kind": "commanddeclaration"}, {"full_name": "minimals_of_symm", "code": "theorem minimals_of_symm [IsSymm \u03b1 r] : minimals r s = s", "start": [168, 1], "end": [169, 52], "kind": "commanddeclaration"}, {"full_name": "maximals_eq_minimals", "code": "theorem maximals_eq_minimals [IsSymm \u03b1 r] : maximals r s = minimals r s", "start": [171, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.maximals_eq", "code": "theorem Set.Subsingleton.maximals_eq (h : s.Subsingleton) : maximals r s = s", "start": [178, 1], "end": [180, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.minimals_eq", "code": "theorem Set.Subsingleton.minimals_eq (h : s.Subsingleton) : minimals r s = s", "start": [183, 1], "end": [184, 16], "kind": "commanddeclaration"}, {"full_name": "maximals_mono", "code": "theorem maximals_mono [IsAntisymm \u03b1 r\u2082] (h : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) :\n    maximals r\u2082 s \u2286 maximals r\u2081 s", "start": [187, 1], "end": [192, 15], "kind": "commanddeclaration"}, {"full_name": "minimals_mono", "code": "theorem minimals_mono [IsAntisymm \u03b1 r\u2082] (h : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) :\n    minimals r\u2082 s \u2286 minimals r\u2081 s", "start": [195, 1], "end": [200, 15], "kind": "commanddeclaration"}, {"full_name": "maximals_union", "code": "theorem maximals_union : maximals r (s \u222a t) \u2286 maximals r s \u222a maximals r t", "start": [203, 1], "end": [207, 52], "kind": "commanddeclaration"}, {"full_name": "minimals_union", "code": "theorem minimals_union : minimals r (s \u222a t) \u2286 minimals r s \u222a minimals r t", "start": [210, 1], "end": [211, 17], "kind": "commanddeclaration"}, {"full_name": "maximals_inter_subset", "code": "theorem maximals_inter_subset : maximals r s \u2229 t \u2286 maximals r (s \u2229 t)", "start": [214, 1], "end": [215, 45], "kind": "commanddeclaration"}, {"full_name": "minimals_inter_subset", "code": "theorem minimals_inter_subset : minimals r s \u2229 t \u2286 minimals r (s \u2229 t)", "start": [218, 1], "end": [219, 24], "kind": "commanddeclaration"}, {"full_name": "inter_maximals_subset", "code": "theorem inter_maximals_subset : s \u2229 maximals r t \u2286 maximals r (s \u2229 t)", "start": [222, 1], "end": [223, 45], "kind": "commanddeclaration"}, {"full_name": "inter_minimals_subset", "code": "theorem inter_minimals_subset : s \u2229 minimals r t \u2286 minimals r (s \u2229 t)", "start": [226, 1], "end": [227, 24], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.maximals_eq", "code": "theorem IsAntichain.maximals_eq (h : IsAntichain r s) : maximals r s = s", "start": [230, 1], "end": [234, 17], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.minimals_eq", "code": "theorem IsAntichain.minimals_eq (h : IsAntichain r s) : minimals r s = s", "start": [237, 1], "end": [238, 21], "kind": "commanddeclaration"}, {"full_name": "maximals_idem", "code": "@[simp]\ntheorem maximals_idem : maximals r (maximals r s) = maximals r s", "start": [241, 1], "end": [243, 75], "kind": "commanddeclaration"}, {"full_name": "minimals_idem", "code": "@[simp]\ntheorem minimals_idem : minimals r (minimals r s) = minimals r s", "start": [246, 1], "end": [248, 16], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.max_maximals", "code": "theorem IsAntichain.max_maximals (ht : IsAntichain r t) (h : maximals r s \u2286 t)\n    (hs : \u2200 \u2983a\u2984, a \u2208 t \u2192 \u2203 b \u2208 maximals r s, r b a) : maximals r s = t", "start": [251, 1], "end": [257, 60], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.max_minimals", "code": "theorem IsAntichain.max_minimals (ht : IsAntichain r t) (h : minimals r s \u2286 t)\n    (hs : \u2200 \u2983a\u2984, a \u2208 t \u2192 \u2203 b \u2208 minimals r s, r a b) : minimals r s = t", "start": [260, 1], "end": [266, 50], "kind": "commanddeclaration"}, {"full_name": "IsLeast.mem_minimals", "code": "theorem IsLeast.mem_minimals (h : IsLeast s a) : a \u2208 minimals (\u00b7 \u2264 \u00b7) s", "start": [271, 1], "end": [272, 31], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.mem_maximals", "code": "theorem IsGreatest.mem_maximals (h : IsGreatest s a) : a \u2208 maximals (\u00b7 \u2264 \u00b7) s", "start": [275, 1], "end": [276, 31], "kind": "commanddeclaration"}, {"full_name": "IsLeast.minimals_eq", "code": "theorem IsLeast.minimals_eq (h : IsLeast s a) : minimals (\u00b7 \u2264 \u00b7) s = {a}", "start": [279, 1], "end": [280, 101], "kind": "commanddeclaration"}, {"full_name": "IsGreatest.maximals_eq", "code": "theorem IsGreatest.maximals_eq (h : IsGreatest s a) : maximals (\u00b7 \u2264 \u00b7) s = {a}", "start": [283, 1], "end": [284, 101], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.minimals_upperClosure", "code": "theorem IsAntichain.minimals_upperClosure (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\n    minimals (\u00b7 \u2264 \u00b7) (upperClosure s : Set \u03b1) = s", "start": [287, 1], "end": [293, 14], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.maximals_lowerClosure", "code": "theorem IsAntichain.maximals_lowerClosure (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\n    maximals (\u00b7 \u2264 \u00b7) (lowerClosure s : Set \u03b1) = s", "start": [296, 1], "end": [298, 35], "kind": "commanddeclaration"}, {"full_name": "minimals_image_of_rel_iff_rel", "code": "theorem minimals_image_of_rel_iff_rel (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) :\n    minimals s (f '' x) = f '' (minimals r x)", "start": [305, 1], "end": [313, 81], "kind": "commanddeclaration"}, {"full_name": "maximals_image_of_rel_iff_rel_on", "code": "theorem maximals_image_of_rel_iff_rel_on\n    (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) :\n    maximals s (f '' x) = f '' (maximals r x)", "start": [315, 1], "end": [318, 63], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.minimals_image_eq", "code": "theorem RelEmbedding.minimals_image_eq (f : r \u21aar s) (x : Set \u03b1) :\n    minimals s (f '' x) = f '' (minimals r x)", "start": [320, 1], "end": [322, 59], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.maximals_image_eq", "code": "theorem RelEmbedding.maximals_image_eq (f : r \u21aar s) (x : Set \u03b1) :\n    maximals s (f '' x) = f '' (maximals r x)", "start": [324, 1], "end": [326, 31], "kind": "commanddeclaration"}, {"full_name": "inter_minimals_preimage_inter_eq_of_rel_iff_rel_on", "code": "theorem inter_minimals_preimage_inter_eq_of_rel_iff_rel_on\n    (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) (y : Set \u03b2) :\n    x \u2229 f \u207b\u00b9' (minimals s ((f '' x) \u2229 y)) = minimals r (x \u2229 f \u207b\u00b9' y)", "start": [328, 1], "end": [337, 65], "kind": "commanddeclaration"}, {"full_name": "inter_preimage_minimals_eq_of_rel_iff_rel_on_of_subset", "code": "theorem inter_preimage_minimals_eq_of_rel_iff_rel_on_of_subset\n    (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) (hy : y \u2286 f '' x) :\n    x \u2229 f \u207b\u00b9' (minimals s y) = minimals r (x \u2229 f \u207b\u00b9' y)", "start": [339, 1], "end": [343, 92], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.inter_preimage_minimals_eq", "code": "theorem RelEmbedding.inter_preimage_minimals_eq (f : r \u21aar s) (x : Set \u03b1) (y : Set \u03b2) :\n    x \u2229 f\u207b\u00b9' (minimals s ((f '' x) \u2229 y)) = minimals r (x \u2229 f \u207b\u00b9' y)", "start": [345, 1], "end": [347, 81], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.inter_preimage_minimals_eq_of_subset", "code": "theorem RelEmbedding.inter_preimage_minimals_eq_of_subset (f : r \u21aar s) (h : y \u2286 f '' x) :\n    x \u2229 f \u207b\u00b9' (minimals s y) = minimals r (x \u2229 f \u207b\u00b9' y)", "start": [349, 1], "end": [351, 88], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.minimals_preimage_eq", "code": "theorem RelEmbedding.minimals_preimage_eq (f : r \u21aar s) (y : Set \u03b2) :\n    minimals r (f \u207b\u00b9' y) = f \u207b\u00b9' minimals s (y \u2229 range f)", "start": [353, 1], "end": [355, 91], "kind": "commanddeclaration"}, {"full_name": "inter_maximals_preimage_inter_eq_of_rel_iff_rel_on", "code": "theorem inter_maximals_preimage_inter_eq_of_rel_iff_rel_on\n    (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) (y : Set \u03b2) :\n    x \u2229 f \u207b\u00b9' (maximals s ((f '' x) \u2229 y)) = maximals r (x \u2229 f \u207b\u00b9' y)", "start": [357, 1], "end": [361, 29], "kind": "commanddeclaration"}, {"full_name": "inter_preimage_maximals_eq_of_rel_iff_rel_on_of_subset", "code": "theorem inter_preimage_maximals_eq_of_rel_iff_rel_on_of_subset\n    (hf : \u2200 \u2983a a'\u2984, a \u2208 x \u2192 a' \u2208 x \u2192 (r a a' \u2194 s (f a) (f a'))) (hy : y \u2286 f '' x) :\n    x \u2229 f \u207b\u00b9' (maximals s y) = maximals r (x \u2229 f \u207b\u00b9' y)", "start": [363, 1], "end": [367, 29], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.inter_preimage_maximals_eq", "code": "theorem RelEmbedding.inter_preimage_maximals_eq (f : r \u21aar s) (x : Set \u03b1) (y : Set \u03b2) :\n    x \u2229 f\u207b\u00b9' (maximals s ((f '' x) \u2229 y)) = maximals r (x \u2229 f \u207b\u00b9' y)", "start": [369, 1], "end": [371, 81], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.inter_preimage_maximals_eq_of_subset", "code": "theorem RelEmbedding.inter_preimage_maximals_eq_of_subset (f : r \u21aar s) (h : y \u2286 f '' x) :\n    x \u2229 f \u207b\u00b9' (maximals s y) = maximals r (x \u2229 f \u207b\u00b9' y)", "start": [373, 1], "end": [375, 88], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.maximals_preimage_eq", "code": "theorem RelEmbedding.maximals_preimage_eq (f : r \u21aar s) (y : Set \u03b2) :\n    maximals r (f \u207b\u00b9' y) = f \u207b\u00b9' maximals s (y \u2229 range f)", "start": [377, 1], "end": [379, 91], "kind": "commanddeclaration"}, {"full_name": "maximals_Iic", "code": "@[simp] theorem maximals_Iic (a : \u03b1) : maximals (\u00b7 \u2264 \u00b7) (Iic a) = {a}", "start": [387, 1], "end": [389, 71], "kind": "commanddeclaration"}, {"full_name": "minimals_Ici", "code": "@[simp] theorem minimals_Ici (a : \u03b1) : minimals (\u00b7 \u2264 \u00b7) (Ici a) = {a}", "start": [391, 1], "end": [392, 28], "kind": "commanddeclaration"}, {"full_name": "maximals_Icc", "code": "theorem maximals_Icc (hab : a \u2264 b) : maximals (\u00b7 \u2264 \u00b7) (Icc a b) = {b}", "start": [394, 1], "end": [396, 88], "kind": "commanddeclaration"}, {"full_name": "minimals_Icc", "code": "theorem minimals_Icc (hab : a \u2264 b) : minimals (\u00b7 \u2264 \u00b7) (Icc a b) = {a}", "start": [398, 1], "end": [399, 76], "kind": "commanddeclaration"}, {"full_name": "maximals_Ioc", "code": "theorem maximals_Ioc (hab : a < b) : maximals (\u00b7 \u2264 \u00b7) (Ioc a b) = {b}", "start": [401, 1], "end": [403, 88], "kind": "commanddeclaration"}, {"full_name": "minimals_Ico", "code": "theorem minimals_Ico (hab : a < b) : minimals (\u00b7 \u2264 \u00b7) (Ico a b) = {a}", "start": [405, 1], "end": [406, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/BoolIndicator.lean", "imports": ["Mathlib/Data/Set/Image.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.boolIndicator", "code": "noncomputable def boolIndicator (x : \u03b1) :=\n  @ite _ (x \u2208 s) (Classical.propDecidable _) true false", "start": [22, 1], "end": [24, 56], "kind": "commanddeclaration"}, {"full_name": "Set.mem_iff_boolIndicator", "code": "theorem mem_iff_boolIndicator (x : \u03b1) : x \u2208 s \u2194 s.boolIndicator x = true", "start": [27, 1], "end": [29, 32], "kind": "commanddeclaration"}, {"full_name": "Set.not_mem_iff_boolIndicator", "code": "theorem not_mem_iff_boolIndicator (x : \u03b1) : x \u2209 s \u2194 s.boolIndicator x = false", "start": [32, 1], "end": [34, 32], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_boolIndicator_true", "code": "theorem preimage_boolIndicator_true : s.boolIndicator \u207b\u00b9' {true} = s", "start": [37, 1], "end": [38, 47], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_boolIndicator_false", "code": "theorem preimage_boolIndicator_false : s.boolIndicator \u207b\u00b9' {false} = s\u1d9c", "start": [41, 1], "end": [42, 51], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_boolIndicator_eq_union", "code": "theorem preimage_boolIndicator_eq_union (t : Set Bool) :\n    s.boolIndicator \u207b\u00b9' t = (if true \u2208 t then s else \u2205) \u222a if false \u2208 t then s\u1d9c else \u2205", "start": [47, 1], "end": [51, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_boolIndicator", "code": "theorem preimage_boolIndicator (t : Set Bool) :\n    s.boolIndicator \u207b\u00b9' t = univ \u2228\n      s.boolIndicator \u207b\u00b9' t = s \u2228 s.boolIndicator \u207b\u00b9' t = s\u1d9c \u2228 s.boolIndicator \u207b\u00b9' t = \u2205", "start": [54, 1], "end": [58, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/LocallyFinite.lean", "imports": ["Mathlib/Order/Filter/SmallSets.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyFinite", "code": "def LocallyFinite (f : \u03b9 \u2192 Set X) :=\n  \u2200 x : X, \u2203 t \u2208 \ud835\udcdd x, { i | (f i \u2229 t).Nonempty }.Finite", "start": [25, 1], "end": [28, 56], "kind": "commanddeclaration"}, {"full_name": "locallyFinite_of_finite", "code": "theorem locallyFinite_of_finite [Finite \u03b9] (f : \u03b9 \u2192 Set X) : LocallyFinite f", "start": [31, 1], "end": [32, 31], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.point_finite", "code": "theorem point_finite (hf : LocallyFinite f) (x : X) : { b | x \u2208 f b }.Finite", "start": [37, 1], "end": [39, 54], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.subset", "code": "protected theorem subset (hf : LocallyFinite f) (hg : \u2200 i, g i \u2286 f i) : LocallyFinite g", "start": [42, 1], "end": [44, 83], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.comp_injOn", "code": "theorem comp_injOn {g : \u03b9' \u2192 \u03b9} (hf : LocallyFinite f) (hg : InjOn g { i | (f (g i)).Nonempty }) :\n    LocallyFinite (f \u2218 g)", "start": [47, 1], "end": [51, 55], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.comp_injective", "code": "theorem comp_injective {g : \u03b9' \u2192 \u03b9} (hf : LocallyFinite f) (hg : Injective g) :\n    LocallyFinite (f \u2218 g)", "start": [54, 1], "end": [56, 29], "kind": "commanddeclaration"}, {"full_name": "locallyFinite_iff_smallSets", "code": "theorem _root_.locallyFinite_iff_smallSets :\n    LocallyFinite f \u2194 \u2200 x, \u2200\u1da0 s in (\ud835\udcdd x).smallSets, { i | (f i \u2229 s).Nonempty }.Finite", "start": [59, 1], "end": [63, 71], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.eventually_smallSets", "code": "protected theorem eventually_smallSets (hf : LocallyFinite f) (x : X) :\n    \u2200\u1da0 s in (\ud835\udcdd x).smallSets, { i | (f i \u2229 s).Nonempty }.Finite", "start": [66, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_mem_basis", "code": "theorem exists_mem_basis {\u03b9' : Sort*} (hf : LocallyFinite f) {p : \u03b9' \u2192 Prop} {s : \u03b9' \u2192 Set X}\n    {x : X} (hb : (\ud835\udcdd x).HasBasis p s) : \u2203 i, p i \u2227 { j | (f j \u2229 s i).Nonempty }.Finite", "start": [71, 1], "end": [74, 26], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.nhdsWithin_iUnion", "code": "protected theorem nhdsWithin_iUnion (hf : LocallyFinite f) (a : X) :\n    \ud835\udcdd[\u22c3 i, f i] a = \u2a06 i, \ud835\udcdd[f i] a", "start": [77, 1], "end": [88, 86], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.continuousOn_iUnion'", "code": "theorem continuousOn_iUnion' {g : X \u2192 Y} (hf : LocallyFinite f)\n    (hc : \u2200 i x, x \u2208 closure (f i) \u2192 ContinuousWithinAt g (f i) x) :\n    ContinuousOn g (\u22c3 i, f i)", "start": [91, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.continuousOn_iUnion", "code": "theorem continuousOn_iUnion {g : X \u2192 Y} (hf : LocallyFinite f) (h_cl : \u2200 i, IsClosed (f i))\n    (h_cont : \u2200 i, ContinuousOn g (f i)) : ContinuousOn g (\u22c3 i, f i)", "start": [104, 1], "end": [106, 80], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.continuous'", "code": "protected theorem continuous' {g : X \u2192 Y} (hf : LocallyFinite f) (h_cov : \u22c3 i, f i = univ)\n    (hc : \u2200 i x, x \u2208 closure (f i) \u2192 ContinuousWithinAt g (f i) x) :\n    Continuous g", "start": [109, 1], "end": [112, 75], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.continuous", "code": "protected theorem continuous {g : X \u2192 Y} (hf : LocallyFinite f) (h_cov : \u22c3 i, f i = univ)\n    (h_cl : \u2200 i, IsClosed (f i)) (h_cont : \u2200 i, ContinuousOn g (f i)) :\n    Continuous g", "start": [115, 1], "end": [118, 83], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.closure", "code": "protected theorem closure (hf : LocallyFinite f) : LocallyFinite fun i => closure (f i)", "start": [121, 1], "end": [126, 49], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.closure_iUnion", "code": "theorem closure_iUnion (h : LocallyFinite f) : closure (\u22c3 i, f i) = \u22c3 i, closure (f i)", "start": [129, 1], "end": [131, 92], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.isClosed_iUnion", "code": "theorem isClosed_iUnion (hf : LocallyFinite f) (hc : \u2200 i, IsClosed (f i)) :\n    IsClosed (\u22c3 i, f i)", "start": [134, 1], "end": [136, 78], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.iInter_compl_mem_nhds", "code": "theorem iInter_compl_mem_nhds (hf : LocallyFinite f) (hc : \u2200 i, IsClosed (f i)) (x : X) :\n    (\u22c2 (i) (_ : x \u2209 f i), (f i)\u1d9c) \u2208 \ud835\udcdd x", "start": [139, 1], "end": [146, 80], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_forall_eventually_eq_prod", "code": "theorem exists_forall_eventually_eq_prod {\u03c0 : X \u2192 Sort*} {f : \u2115 \u2192 \u2200 x : X, \u03c0 x}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x \u2260 f n x }) :\n    \u2203 F : \u2200 x : X, \u03c0 x, \u2200 x, \u2200\u1da0 p : \u2115 \u00d7 X in atTop \u00d7\u02e2 \ud835\udcdd x, f p.1 p.2 = F p.2", "start": [149, 1], "end": [170, 80], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_forall_eventually_atTop_eventually_eq'", "code": "theorem exists_forall_eventually_atTop_eventually_eq' {\u03c0 : X \u2192 Sort*} {f : \u2115 \u2192 \u2200 x : X, \u03c0 x}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x \u2260 f n x }) :\n    \u2203 F : \u2200 x : X, \u03c0 x, \u2200 x, \u2200\u1da0 n : \u2115 in atTop, \u2200\u1da0 y : X in \ud835\udcdd x, f n y = F y", "start": [173, 1], "end": [180, 70], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_forall_eventually_atTop_eventuallyEq", "code": "theorem exists_forall_eventually_atTop_eventuallyEq {f : \u2115 \u2192 X \u2192 \u03b1}\n    (hf : LocallyFinite fun n => { x | f (n + 1) x \u2260 f n x }) :\n    \u2203 F : X \u2192 \u03b1, \u2200 x, \u2200\u1da0 n : \u2115 in atTop, f n =\u1da0[\ud835\udcdd x] F", "start": [183, 1], "end": [190, 51], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.preimage_continuous", "code": "theorem preimage_continuous {g : Y \u2192 X} (hf : LocallyFinite f) (hg : Continuous g) :\n    LocallyFinite (g \u207b\u00b9' f \u00b7)", "start": [193, 1], "end": [196, 71], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.prod_right", "code": "theorem prod_right (hf : LocallyFinite f) (g : \u03b9 \u2192 Set Y) : LocallyFinite (fun i \u21a6 f i \u00d7\u02e2 g i)", "start": [199, 1], "end": [200, 86], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.prod_left", "code": "theorem prod_left {g : \u03b9 \u2192 Set Y} (hg : LocallyFinite g) (f : \u03b9 \u2192 Set X) :\n    LocallyFinite (fun i \u21a6 f i \u00d7\u02e2 g i)", "start": [202, 1], "end": [204, 86], "kind": "commanddeclaration"}, {"full_name": "Equiv.locallyFinite_comp_iff", "code": "@[simp]\ntheorem Equiv.locallyFinite_comp_iff (e : \u03b9' \u2243 \u03b9) : LocallyFinite (f \u2218 e) \u2194 LocallyFinite f", "start": [208, 1], "end": [211, 43], "kind": "commanddeclaration"}, {"full_name": "locallyFinite_sum", "code": "theorem locallyFinite_sum {f : Sum \u03b9 \u03b9' \u2192 Set X} :\n    LocallyFinite f \u2194 LocallyFinite (f \u2218 Sum.inl) \u2227 LocallyFinite (f \u2218 Sum.inr)", "start": [214, 1], "end": [217, 48], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.sum_elim", "code": "theorem LocallyFinite.sum_elim {g : \u03b9' \u2192 Set X} (hf : LocallyFinite f) (hg : LocallyFinite g) :\n    LocallyFinite (Sum.elim f g)", "start": [220, 1], "end": [222, 33], "kind": "commanddeclaration"}, {"full_name": "locallyFinite_option", "code": "theorem locallyFinite_option {f : Option \u03b9 \u2192 Set X} :\n    LocallyFinite f \u2194 LocallyFinite (f \u2218 some)", "start": [225, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.option_elim'", "code": "theorem LocallyFinite.option_elim' (hf : LocallyFinite f) (s : Set X) :\n    LocallyFinite (Option.elim' s f)", "start": [232, 1], "end": [234, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Accumulate.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Accumulate", "code": "def Accumulate [LE \u03b1] (s : \u03b1 \u2192 Set \u03b2) (x : \u03b1) : Set \u03b2 :=\n  \u22c3 y \u2264 x, s y", "start": [21, 1], "end": [23, 15], "kind": "commanddeclaration"}, {"full_name": "Set.accumulate_def", "code": "theorem accumulate_def [LE \u03b1] {x : \u03b1} : Accumulate s x = \u22c3 y \u2264 x, s y", "start": [26, 1], "end": [27, 6], "kind": "commanddeclaration"}, {"full_name": "Set.mem_accumulate", "code": "@[simp]\ntheorem mem_accumulate [LE \u03b1] {x : \u03b1} {z : \u03b2} : z \u2208 Accumulate s x \u2194 \u2203 y \u2264 x, z \u2208 s y", "start": [30, 1], "end": [32, 53], "kind": "commanddeclaration"}, {"full_name": "Set.subset_accumulate", "code": "theorem subset_accumulate [Preorder \u03b1] {x : \u03b1} : s x \u2286 Accumulate s x", "start": [35, 1], "end": [35, 101], "kind": "commanddeclaration"}, {"full_name": "Set.accumulate_subset_iUnion", "code": "theorem accumulate_subset_iUnion [Preorder \u03b1] (x : \u03b1) : Accumulate s x \u2286 \u22c3 i, s i", "start": [38, 1], "end": [39, 74], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_accumulate", "code": "theorem monotone_accumulate [Preorder \u03b1] : Monotone (Accumulate s)", "start": [41, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "Set.biUnion_accumulate", "code": "theorem biUnion_accumulate [Preorder \u03b1] (x : \u03b1) : \u22c3 y \u2264 x, Accumulate s y = \u22c3 y \u2264 x, s y", "start": [45, 1], "end": [48, 52], "kind": "commanddeclaration"}, {"full_name": "Set.iUnion_accumulate", "code": "theorem iUnion_accumulate [Preorder \u03b1] : \u22c3 x, Accumulate s x = \u22c3 x, s x", "start": [51, 1], "end": [56, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Bornology/Basic.lean", "imports": ["Mathlib/Order/Filter/Cofinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bornology", "code": "class Bornology (\u03b1 : Type*) where\n  \n  cobounded' : Filter \u03b1\n  \n  le_cofinite' : cobounded' \u2264 cofinite", "start": [46, 1], "end": [56, 39], "kind": "commanddeclaration"}, {"full_name": "Bornology.cobounded", "code": "def Bornology.cobounded (\u03b1 : Type*) [Bornology \u03b1] : Filter \u03b1 := Bornology.cobounded'", "start": [63, 1], "end": [64, 85], "kind": "commanddeclaration"}, {"full_name": "Bornology.Simps.cobounded", "code": "alias Bornology.Simps.cobounded := Bornology.cobounded", "start": [67, 1], "end": [67, 55], "kind": "stdtacticaliasalias"}, {"full_name": "Bornology.le_cofinite", "code": "lemma Bornology.le_cofinite (\u03b1 : Type*) [Bornology \u03b1] : cobounded \u03b1 \u2264 cofinite :=\nBornology.le_cofinite'", "start": [69, 1], "end": [70, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Bornology.ext", "code": "@[ext]\nlemma Bornology.ext (t t' : Bornology \u03b1)\n    (h_cobounded : @Bornology.cobounded \u03b1 t = @Bornology.cobounded \u03b1 t') :\n    t = t' := by\n  cases t\n  cases t'\n  congr", "start": [75, 1], "end": [81, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Bornology.ext_iff", "code": "lemma Bornology.ext_iff (t t' : Bornology \u03b1) :\n    t = t' \u2194 @Bornology.cobounded \u03b1 t = @Bornology.cobounded \u03b1 t' :=\n\u27e8congrArg _, Bornology.ext _ _\u27e9", "start": [84, 1], "end": [86, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Bornology.ofBounded", "code": "@[simps]\ndef Bornology.ofBounded {\u03b1 : Type*} (B : Set (Set \u03b1))\n    (empty_mem : \u2205 \u2208 B)\n    (subset_mem : \u2200 s\u2081 (_ : s\u2081 \u2208 B) s\u2082, s\u2082 \u2286 s\u2081 \u2192 s\u2082 \u2208 B)\n    (union_mem : \u2200 s\u2081 (_ : s\u2081 \u2208 B) s\u2082 (_ : s\u2082 \u2208 B), s\u2081 \u222a s\u2082 \u2208 B)\n    (singleton_mem : \u2200 x, {x} \u2208 B) : Bornology \u03b1\n    where\n  cobounded' :=\n    { sets := { s : Set \u03b1 | s\u1d9c \u2208 B }\n      univ_sets := by rwa [\u2190 compl_univ] at empty_mem\n      sets_of_superset := fun hx hy => subset_mem _ hx _ (compl_subset_compl.mpr hy)\n      inter_sets := fun hx hy => by simpa [compl_inter] using union_mem _ hx _ hy }\n  le_cofinite' := by\n    rw [le_cofinite_iff_compl_singleton_mem]\n    intro x\n    change {x}\u1d9c\u1d9c \u2208 B\n    rw [compl_compl]\n    exact singleton_mem x", "start": [89, 1], "end": [108, 26], "kind": "commanddeclaration"}, {"full_name": "Bornology.ofBounded'", "code": "@[simps!]\ndef Bornology.ofBounded' {\u03b1 : Type*} (B : Set (Set \u03b1))\n    (empty_mem : \u2205 \u2208 B)\n    (subset_mem : \u2200 s\u2081 (_ : s\u2081 \u2208 B) s\u2082, s\u2082 \u2286 s\u2081 \u2192 s\u2082 \u2208 B)\n    (union_mem : \u2200 s\u2081 (_ : s\u2081 \u2208 B) s\u2082 (_ : s\u2082 \u2208 B), s\u2081 \u222a s\u2082 \u2208 B)\n    (sUnion_univ : \u22c3\u2080 B = univ) :\n    Bornology \u03b1 :=\n  Bornology.ofBounded B empty_mem subset_mem union_mem fun x => by\n    rw [sUnion_eq_univ_iff] at sUnion_univ\n    rcases sUnion_univ x with \u27e8s, hs, hxs\u27e9\n    exact subset_mem s hs {x} (singleton_subset_iff.mpr hxs)", "start": [112, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsCobounded", "code": "def IsCobounded (s : Set \u03b1) : Prop :=\n  s \u2208 cobounded \u03b1", "start": [133, 1], "end": [136, 18], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded", "code": "def IsBounded (s : Set \u03b1) : Prop :=\n  IsCobounded s\u1d9c", "start": [139, 1], "end": [141, 17], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_def", "code": "theorem isCobounded_def {s : Set \u03b1} : IsCobounded s \u2194 s \u2208 cobounded \u03b1", "start": [144, 1], "end": [145, 10], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_def", "code": "theorem isBounded_def {s : Set \u03b1} : IsBounded s \u2194 s\u1d9c \u2208 cobounded \u03b1", "start": [148, 1], "end": [149, 10], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_compl_iff", "code": "@[simp]\ntheorem isBounded_compl_iff : IsBounded s\u1d9c \u2194 IsCobounded s", "start": [152, 1], "end": [154, 51], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_compl_iff", "code": "@[simp]\ntheorem isCobounded_compl_iff : IsCobounded s\u1d9c \u2194 IsBounded s", "start": [157, 1], "end": [159, 10], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.of_compl", "code": "alias \u27e8IsBounded.of_compl, IsCobounded.compl\u27e9 := isBounded_compl_iff", "start": [162, 1], "end": [162, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsCobounded.compl", "code": "alias \u27e8IsBounded.of_compl, IsCobounded.compl\u27e9 := isBounded_compl_iff", "start": [162, 1], "end": [162, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsCobounded.of_compl", "code": "alias \u27e8IsCobounded.of_compl, IsBounded.compl\u27e9 := isCobounded_compl_iff", "start": [166, 1], "end": [166, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsBounded.compl", "code": "alias \u27e8IsCobounded.of_compl, IsBounded.compl\u27e9 := isCobounded_compl_iff", "start": [166, 1], "end": [166, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.isBounded_empty", "code": "@[simp]\ntheorem isBounded_empty : IsBounded (\u2205 : Set \u03b1)", "start": [170, 1], "end": [173, 17], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_singleton", "code": "@[simp]\ntheorem isBounded_singleton : IsBounded ({x} : Set \u03b1)", "start": [176, 1], "end": [179, 62], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_iff_forall_mem", "code": "theorem isBounded_iff_forall_mem : IsBounded s \u2194 \u2200 x \u2208 s, IsBounded s", "start": [182, 1], "end": [185, 38], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_univ", "code": "@[simp]\ntheorem isCobounded_univ : IsCobounded (univ : Set \u03b1)", "start": [187, 1], "end": [189, 11], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_inter", "code": "@[simp]\ntheorem isCobounded_inter : IsCobounded (s \u2229 t) \u2194 IsCobounded s \u2227 IsCobounded t", "start": [192, 1], "end": [194, 16], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsCobounded.inter", "code": "theorem IsCobounded.inter (hs : IsCobounded s) (ht : IsCobounded t) : IsCobounded (s \u2229 t)", "start": [197, 1], "end": [198, 31], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_union", "code": "@[simp]\ntheorem isBounded_union : IsBounded (s \u222a t) \u2194 IsBounded s \u2227 IsBounded t", "start": [201, 1], "end": [203, 70], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.union", "code": "theorem IsBounded.union (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s \u222a t)", "start": [206, 1], "end": [207, 29], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsCobounded.superset", "code": "theorem IsCobounded.superset (hs : IsCobounded s) (ht : s \u2286 t) : IsCobounded t", "start": [210, 1], "end": [211, 24], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.subset", "code": "theorem IsBounded.subset (ht : IsBounded t) (hs : s \u2286 t) : IsBounded s", "start": [214, 1], "end": [215, 42], "kind": "commanddeclaration"}, {"full_name": "Bornology.sUnion_bounded_univ", "code": "@[simp]\ntheorem sUnion_bounded_univ : \u22c3\u2080 { s : Set \u03b1 | IsBounded s } = univ", "start": [218, 1], "end": [220, 76], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.insert", "code": "theorem IsBounded.insert (h : IsBounded s) (x : \u03b1) : IsBounded (insert x s)", "start": [223, 1], "end": [224, 30], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_insert", "code": "@[simp]\ntheorem isBounded_insert : IsBounded (insert x s) \u2194 IsBounded s", "start": [226, 1], "end": [228, 56], "kind": "commanddeclaration"}, {"full_name": "Bornology.comap_cobounded_le_iff", "code": "theorem comap_cobounded_le_iff [Bornology \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    (cobounded \u03b2).comap f \u2264 cobounded \u03b1 \u2194 \u2200 \u2983s\u2984, IsBounded s \u2192 IsBounded (f '' s)", "start": [230, 1], "end": [237, 96], "kind": "commanddeclaration"}, {"full_name": "Bornology.ext_iff'", "code": "theorem ext_iff' {t t' : Bornology \u03b1} :\n    t = t' \u2194 \u2200 s, s \u2208 @cobounded \u03b1 t \u2194 s \u2208 @cobounded \u03b1 t'", "start": [242, 1], "end": [244, 47], "kind": "commanddeclaration"}, {"full_name": "Bornology.ext_iff_isBounded", "code": "theorem ext_iff_isBounded {t t' : Bornology \u03b1} :\n    t = t' \u2194 \u2200 s, @IsBounded \u03b1 t s \u2194 @IsBounded \u03b1 t' s", "start": [247, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_ofBounded_iff", "code": "theorem isCobounded_ofBounded_iff (B : Set (Set \u03b1)) {empty_mem subset_mem union_mem sUnion_univ} :\n    @IsCobounded _ (ofBounded B empty_mem subset_mem union_mem sUnion_univ) s \u2194 s\u1d9c \u2208 B", "start": [254, 1], "end": [256, 10], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_ofBounded_iff", "code": "theorem isBounded_ofBounded_iff (B : Set (Set \u03b1)) {empty_mem subset_mem union_mem sUnion_univ} :\n    @IsBounded _ (ofBounded B empty_mem subset_mem union_mem sUnion_univ) s \u2194 s \u2208 B", "start": [259, 1], "end": [262, 60], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_biInter", "code": "theorem isCobounded_biInter {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (hs : s.Finite) :\n    IsCobounded (\u22c2 i \u2208 s, f i) \u2194 \u2200 i \u2208 s, IsCobounded (f i)", "start": [268, 1], "end": [270, 17], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_biInter_finset", "code": "@[simp]\ntheorem isCobounded_biInter_finset (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    IsCobounded (\u22c2 i \u2208 s, f i) \u2194 \u2200 i \u2208 s, IsCobounded (f i)", "start": [273, 1], "end": [276, 23], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_iInter", "code": "@[simp]\ntheorem isCobounded_iInter [Finite \u03b9] {f : \u03b9 \u2192 Set \u03b1} :\n    IsCobounded (\u22c2 i, f i) \u2194 \u2200 i, IsCobounded (f i)", "start": [279, 1], "end": [282, 13], "kind": "commanddeclaration"}, {"full_name": "Bornology.isCobounded_sInter", "code": "theorem isCobounded_sInter {S : Set (Set \u03b1)} (hs : S.Finite) :\n    IsCobounded (\u22c2\u2080 S) \u2194 \u2200 s \u2208 S, IsCobounded s", "start": [285, 1], "end": [287, 16], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_biUnion", "code": "theorem isBounded_biUnion {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (hs : s.Finite) :\n    IsBounded (\u22c3 i \u2208 s, f i) \u2194 \u2200 i \u2208 s, IsBounded (f i)", "start": [290, 1], "end": [292, 76], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_biUnion_finset", "code": "theorem isBounded_biUnion_finset (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    IsBounded (\u22c3 i \u2208 s, f i) \u2194 \u2200 i \u2208 s, IsBounded (f i)", "start": [295, 1], "end": [297, 35], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_sUnion", "code": "theorem isBounded_sUnion {S : Set (Set \u03b1)} (hs : S.Finite) :\n    IsBounded (\u22c3\u2080 S) \u2194 \u2200 s \u2208 S, IsBounded s", "start": [300, 1], "end": [301, 95], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_iUnion", "code": "@[simp]\ntheorem isBounded_iUnion [Finite \u03b9] {s : \u03b9 \u2192 Set \u03b1} : IsBounded (\u22c3 i, s i) \u2194 \u2200 i, IsBounded (s i)", "start": [304, 1], "end": [306, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.disjoint_cobounded_iff", "code": "theorem Filter.HasBasis.disjoint_cobounded_iff [Bornology \u03b1] {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set \u03b1} {l : Filter \u03b1} (h : l.HasBasis p s) :\n    Disjoint l (cobounded \u03b1) \u2194 \u2203 i, p i \u2227 IsBounded (s i)", "start": [313, 1], "end": [316, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isBounded", "code": "theorem Set.Finite.isBounded [Bornology \u03b1] {s : Set \u03b1} (hs : s.Finite) : IsBounded s", "start": [318, 1], "end": [319, 48], "kind": "commanddeclaration"}, {"full_name": "Bornology.cofinite", "code": "@[reducible]\ndef Bornology.cofinite : Bornology \u03b1 where\n  cobounded' := Filter.cofinite\n  le_cofinite' := le_rfl", "start": [325, 1], "end": [329, 25], "kind": "commanddeclaration"}, {"full_name": "BoundedSpace", "code": "class BoundedSpace (\u03b1 : Type*) [Bornology \u03b1] : Prop where\n  \n  bounded_univ : Bornology.IsBounded (univ : Set \u03b1)", "start": [332, 1], "end": [335, 52], "kind": "commanddeclaration"}, {"full_name": "BoundedSpace.of_finite", "code": "instance (priority := 100) BoundedSpace.of_finite {\u03b1 : Type*} [Bornology \u03b1] [Finite \u03b1] :\n    BoundedSpace \u03b1 where\n  bounded_univ := (toFinite _).isBounded", "start": [338, 1], "end": [341, 41], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_univ", "code": "theorem isBounded_univ : IsBounded (univ : Set \u03b1) \u2194 BoundedSpace \u03b1", "start": [347, 1], "end": [348, 31], "kind": "commanddeclaration"}, {"full_name": "Bornology.cobounded_eq_bot_iff", "code": "theorem cobounded_eq_bot_iff : cobounded \u03b1 = \u22a5 \u2194 BoundedSpace \u03b1", "start": [351, 1], "end": [352, 70], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.all", "code": "theorem IsBounded.all (s : Set \u03b1) : IsBounded s", "start": [357, 1], "end": [358, 49], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsCobounded.all", "code": "theorem IsCobounded.all (s : Set \u03b1) : IsCobounded s", "start": [361, 1], "end": [362, 35], "kind": "commanddeclaration"}, {"full_name": "Bornology.cobounded_eq_bot", "code": "@[simp]\ntheorem cobounded_eq_bot : cobounded \u03b1 = \u22a5", "start": [367, 1], "end": [369, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Bases.lean", "imports": ["Mathlib/Topology/ContinuousOn.lean", "Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSpace.IsTopologicalBasis", "code": "structure IsTopologicalBasis (s : Set (Set \u03b1)) : Prop where\n  \n  exists_subset_inter : \u2200 t\u2081 \u2208 s, \u2200 t\u2082 \u2208 s, \u2200 x \u2208 t\u2081 \u2229 t\u2082, \u2203 t\u2083 \u2208 s, x \u2208 t\u2083 \u2227 t\u2083 \u2286 t\u2081 \u2229 t\u2082\n  \n  sUnion_eq : \u22c3\u2080 s = univ\n  \n  eq_generateFrom : t = generateFrom s", "start": [68, 1], "end": [77, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.insert_empty", "code": "theorem IsTopologicalBasis.insert_empty {s : Set (Set \u03b1)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (insert \u2205 s)", "start": [80, 1], "end": [93, 24], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.diff_empty", "code": "theorem IsTopologicalBasis.diff_empty {s : Set (Set \u03b1)} (h : IsTopologicalBasis s) :\n    IsTopologicalBasis (s \\ {\u2205})", "start": [96, 1], "end": [106, 30], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isTopologicalBasis_of_subbasis", "code": "theorem isTopologicalBasis_of_subbasis {s : Set (Set \u03b1)} (hs : t = generateFrom s) :\n    IsTopologicalBasis ((fun f => \u22c2\u2080 f) '' { f : Set (Set \u03b1) | f.Finite \u2227 f \u2286 s })", "start": [109, 1], "end": [122, 70], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isTopologicalBasis_of_open_of_nhds", "code": "theorem isTopologicalBasis_of_open_of_nhds {s : Set (Set \u03b1)} (h_open : \u2200 u \u2208 s, IsOpen u)\n    (h_nhds : \u2200 (a : \u03b1) (u : Set \u03b1), a \u2208 u \u2192 IsOpen u \u2192 \u2203 v \u2208 s, a \u2208 v \u2227 v \u2286 u) :\n    IsTopologicalBasis s", "start": [125, 1], "end": [139, 63], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.mem_nhds_iff", "code": "theorem IsTopologicalBasis.mem_nhds_iff {a : \u03b1} {s : Set \u03b1} {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) : s \u2208 \ud835\udcdd a \u2194 \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s", "start": [142, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.isOpen_iff", "code": "theorem IsTopologicalBasis.isOpen_iff {s : Set \u03b1} {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) :\n    IsOpen s \u2194 \u2200 a \u2208 s, \u2203 t \u2208 b, a \u2208 t \u2227 t \u2286 s", "start": [157, 1], "end": [158, 97], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.nhds_hasBasis", "code": "theorem IsTopologicalBasis.nhds_hasBasis {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) {a : \u03b1} :\n    (\ud835\udcdd a).HasBasis (fun t : Set \u03b1 => t \u2208 b \u2227 a \u2208 t) fun t => t", "start": [161, 1], "end": [163, 63], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.isOpen", "code": "protected theorem IsTopologicalBasis.isOpen {s : Set \u03b1} {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) (hs : s \u2208 b) : IsOpen s", "start": [166, 1], "end": [169, 20], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.mem_nhds", "code": "protected theorem IsTopologicalBasis.mem_nhds {a : \u03b1} {s : Set \u03b1} {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) (hs : s \u2208 b) (ha : a \u2208 s) : s \u2208 \ud835\udcdd a", "start": [172, 1], "end": [174, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.exists_subset_of_mem_open", "code": "theorem IsTopologicalBasis.exists_subset_of_mem_open {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b)\n    {a : \u03b1} {u : Set \u03b1} (au : a \u2208 u) (ou : IsOpen u) : \u2203 v \u2208 b, a \u2208 v \u2227 v \u2286 u", "start": [177, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.open_eq_sUnion'", "code": "theorem IsTopologicalBasis.open_eq_sUnion' {B : Set (Set \u03b1)} (hB : IsTopologicalBasis B) {u : Set \u03b1}\n    (ou : IsOpen u) : u = \u22c3\u2080 { s \u2208 B | s \u2286 u }", "start": [182, 1], "end": [189, 38], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.open_eq_sUnion", "code": "theorem IsTopologicalBasis.open_eq_sUnion {B : Set (Set \u03b1)} (hB : IsTopologicalBasis B) {u : Set \u03b1}\n    (ou : IsOpen u) : \u2203 S, S \u2286 B \u2227 u = \u22c3\u2080 S", "start": [193, 1], "end": [195, 61], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.open_iff_eq_sUnion", "code": "theorem IsTopologicalBasis.open_iff_eq_sUnion {B : Set (Set \u03b1)} (hB : IsTopologicalBasis B)\n    {u : Set \u03b1} : IsOpen u \u2194 \u2203 S, S \u2286 B \u2227 u = \u22c3\u2080 S", "start": [199, 1], "end": [201, 100], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.open_eq_iUnion", "code": "theorem IsTopologicalBasis.open_eq_iUnion {B : Set (Set \u03b1)} (hB : IsTopologicalBasis B) {u : Set \u03b1}\n    (ou : IsOpen u) : \u2203 (\u03b2 : Type u) (f : \u03b2 \u2192 Set \u03b1), (u = \u22c3 i, f i) \u2227 \u2200 i, f i \u2208 B", "start": [204, 1], "end": [208, 56], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.subset_of_forall_subset", "code": "lemma IsTopologicalBasis.subset_of_forall_subset {t : Set \u03b1} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (h : \u2200 U \u2208 B, U \u2286 s \u2192 U \u2286 t) : s \u2286 t := by\n  rw [hB.open_eq_sUnion' hs]; simpa [sUnion_subset_iff]", "start": [211, 1], "end": [213, 56], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.eq_of_forall_subset_iff", "code": "lemma IsTopologicalBasis.eq_of_forall_subset_iff {t : Set \u03b1} (hB : IsTopologicalBasis B)\n    (hs : IsOpen s) (ht : IsOpen t) (h : \u2200 U \u2208 B, U \u2286 s \u2194 U \u2286 t) : s = t := by\n  rw [hB.open_eq_sUnion' hs, hB.open_eq_sUnion' ht]\n  exact congr_arg _ (Set.ext \u03bb U \u21a6 and_congr_right $ h _)", "start": [215, 1], "end": [218, 58], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.mem_closure_iff", "code": "theorem IsTopologicalBasis.mem_closure_iff {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) {s : Set \u03b1}\n    {a : \u03b1} : a \u2208 closure s \u2194 \u2200 o \u2208 b, a \u2208 o \u2192 (o \u2229 s).Nonempty", "start": [220, 1], "end": [223, 81], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.dense_iff", "code": "theorem IsTopologicalBasis.dense_iff {b : Set (Set \u03b1)} (hb : IsTopologicalBasis b) {s : Set \u03b1} :\n    Dense s \u2194 \u2200 o \u2208 b, Set.Nonempty o \u2192 (o \u2229 s).Nonempty", "start": [226, 1], "end": [230, 79], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.isOpenMap_iff", "code": "theorem IsTopologicalBasis.isOpenMap_iff {\u03b2} [TopologicalSpace \u03b2] {B : Set (Set \u03b1)}\n    (hB : IsTopologicalBasis B) {f : \u03b1 \u2192 \u03b2} : IsOpenMap f \u2194 \u2200 s \u2208 B, IsOpen (f '' s)", "start": [233, 1], "end": [237, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.exists_nonempty_subset", "code": "theorem IsTopologicalBasis.exists_nonempty_subset {B : Set (Set \u03b1)} (hb : IsTopologicalBasis B)\n    {u : Set \u03b1} (hu : u.Nonempty) (ou : IsOpen u) : \u2203 v \u2208 B, Set.Nonempty v \u2227 v \u2286 u", "start": [240, 1], "end": [244, 23], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isTopologicalBasis_opens", "code": "theorem isTopologicalBasis_opens : IsTopologicalBasis { U : Set \u03b1 | IsOpen U }", "start": [247, 1], "end": [248, 59], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.prod", "code": "protected theorem IsTopologicalBasis.prod {\u03b2} [TopologicalSpace \u03b2] {B\u2081 : Set (Set \u03b1)}\n    {B\u2082 : Set (Set \u03b2)} (h\u2081 : IsTopologicalBasis B\u2081) (h\u2082 : IsTopologicalBasis B\u2082) :\n    IsTopologicalBasis (image2 (\u00b7 \u00d7\u02e2 \u00b7) B\u2081 B\u2082)", "start": [251, 1], "end": [260, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.inducing", "code": "protected theorem IsTopologicalBasis.inducing {\u03b2} [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {T : Set (Set \u03b2)}\n    (hf : Inducing f) (h : IsTopologicalBasis T) : IsTopologicalBasis ((preimage f) '' T)", "start": [263, 1], "end": [274, 93], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isTopologicalBasis_of_cover", "code": "theorem isTopologicalBasis_of_cover {\u03b9} {U : \u03b9 \u2192 Set \u03b1} (Uo : \u2200 i, IsOpen (U i))\n    (Uc : \u22c3 i, U i = univ) {b : \u2200 i, Set (Set (U i))} (hb : \u2200 i, IsTopologicalBasis (b i)) :\n    IsTopologicalBasis (\u22c3 i : \u03b9, image ((\u2191) : U i \u2192 \u03b1) '' b i)", "start": [277, 1], "end": [290, 30], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.continuous", "code": "protected theorem IsTopologicalBasis.continuous {\u03b2 : Type*} [TopologicalSpace \u03b2] {B : Set (Set \u03b2)}\n    (hB : IsTopologicalBasis B) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 s \u2208 B, IsOpen (f \u207b\u00b9' s)) : Continuous f", "start": [293, 1], "end": [295, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SeparableSpace", "code": "@[mk_iff] class SeparableSpace : Prop where\n  \n  exists_countable_dense : \u2203 s : Set \u03b1, s.Countable \u2227 Dense s", "start": [300, 1], "end": [315, 62], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.exists_countable_dense", "code": "theorem exists_countable_dense [SeparableSpace \u03b1] : \u2203 s : Set \u03b1, s.Countable \u2227 Dense s", "start": [318, 1], "end": [319, 40], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.exists_dense_seq", "code": "theorem exists_dense_seq [SeparableSpace \u03b1] [Nonempty \u03b1] : \u2203 u : \u2115 \u2192 \u03b1, DenseRange u", "start": [322, 1], "end": [331, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.denseSeq", "code": "def denseSeq [SeparableSpace \u03b1] [Nonempty \u03b1] : \u2115 \u2192 \u03b1 :=\n  Classical.choose (exists_dense_seq \u03b1)", "start": [334, 1], "end": [339, 40], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.denseRange_denseSeq", "code": "@[simp]\ntheorem denseRange_denseSeq [SeparableSpace \u03b1] [Nonempty \u03b1] : DenseRange (denseSeq \u03b1)", "start": [342, 1], "end": [345, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Countable.to_separableSpace", "code": "instance (priority := 100) Countable.to_separableSpace [Countable \u03b1] : SeparableSpace \u03b1 where\n  exists_countable_dense := \u27e8Set.univ, Set.countable_univ, dense_univ\u27e9", "start": [350, 1], "end": [351, 71], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SeparableSpace.of_denseRange", "code": "theorem SeparableSpace.of_denseRange {\u03b9 : Sort _} [Countable \u03b9] (u : \u03b9 \u2192 \u03b1) (hu : DenseRange u) :\n    SeparableSpace \u03b1", "start": [354, 1], "end": [358, 37], "kind": "commanddeclaration"}, {"full_name": "DenseRange.separableSpace'", "code": "alias _root_.DenseRange.separableSpace' := SeparableSpace.of_denseRange", "start": [361, 1], "end": [361, 72], "kind": "stdtacticaliasalias"}, {"full_name": "DenseRange.separableSpace", "code": "protected theorem _root_.DenseRange.separableSpace [SeparableSpace \u03b1] [TopologicalSpace \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (h : DenseRange f) (h' : Continuous f) : SeparableSpace \u03b2", "start": [363, 1], "end": [368, 64], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.separableSpace", "code": "theorem _root_.QuotientMap.separableSpace [SeparableSpace \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : QuotientMap f) : SeparableSpace \u03b2", "start": [371, 1], "end": [373, 56], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.separableSpace_iff_countable", "code": "theorem separableSpace_iff_countable [DiscreteTopology \u03b1] : SeparableSpace \u03b1 \u2194 Countable \u03b1", "start": [406, 1], "end": [408, 48], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.countable_of_isOpen", "code": "theorem _root_.Set.PairwiseDisjoint.countable_of_isOpen [SeparableSpace \u03b1] {\u03b9 : Type*}\n    {s : \u03b9 \u2192 Set \u03b1} {a : Set \u03b9} (h : a.PairwiseDisjoint s) (ha : \u2200 i \u2208 a, IsOpen (s i))\n    (h'a : \u2200 i \u2208 a, (s i).Nonempty) : a.Countable", "start": [410, 1], "end": [423, 51], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.countable_of_nonempty_interior", "code": "theorem _root_.Set.PairwiseDisjoint.countable_of_nonempty_interior [SeparableSpace \u03b1] {\u03b9 : Type*}\n    {s : \u03b9 \u2192 Set \u03b1} {a : Set \u03b9} (h : a.PairwiseDisjoint s)\n    (ha : \u2200 i \u2208 a, (interior (s i)).Nonempty) : a.Countable", "start": [426, 1], "end": [430, 88], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable", "code": "def IsSeparable (s : Set \u03b1) :=\n  \u2203 c : Set \u03b1, c.Countable \u2227 s \u2286 closure c", "start": [433, 1], "end": [439, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.mono", "code": "theorem IsSeparable.mono {s u : Set \u03b1} (hs : IsSeparable s) (hu : u \u2286 s) : IsSeparable u", "start": [442, 1], "end": [444, 34], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.union", "code": "theorem IsSeparable.union {s u : Set \u03b1} (hs : IsSeparable s) (hu : IsSeparable u) :\n    IsSeparable (s \u222a u)", "start": [447, 1], "end": [454, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.closure", "code": "theorem IsSeparable.closure {s : Set \u03b1} (hs : IsSeparable s) : IsSeparable (closure s)", "start": [457, 1], "end": [459, 53], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isSeparable_iUnion", "code": "theorem isSeparable_iUnion {\u03b9 : Type*} [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (hs : \u2200 i, IsSeparable (s i)) : IsSeparable (\u22c3 i, s i)", "start": [462, 1], "end": [466, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isSeparable_pi", "code": "lemma isSeparable_pi {\u03b9 : Type*} [Fintype \u03b9] {\u03b1 : \u2200 (_ : \u03b9), Type*} {s : \u2200 i, Set (\u03b1 i)}\n    [\u2200 i, TopologicalSpace (\u03b1 i)] (h : \u2200 i, IsSeparable (s i)) :\n    IsSeparable {f : \u2200 i, \u03b1 i | \u2200 i, f i \u2208 s i} := by\n  choose c c_count hc using h\n  refine \u27e8{f | \u2200 i, f i \u2208 c i}, countable_pi c_count, ?_\u27e9\n  simp_rw [\u2190 mem_univ_pi]\n  dsimp\n  rw [closure_pi_set]\n  exact Set.pi_mono (fun i _ \u21a6 hc i)", "start": [469, 1], "end": [477, 37], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.IsSeparable.prod", "code": "lemma IsSeparable.prod {\u03b2 : Type*} [TopologicalSpace \u03b2]\n    {s : Set \u03b1} {t : Set \u03b2} (hs : IsSeparable s) (ht : IsSeparable t) :\n    IsSeparable (s \u00d7\u02e2 t) := by\n  rcases hs with \u27e8cs, cs_count, hcs\u27e9\n  rcases ht with \u27e8ct, ct_count, hct\u27e9\n  refine \u27e8cs \u00d7\u02e2 ct, cs_count.prod ct_count, ?_\u27e9\n  rw [closure_prod_eq]\n  exact Set.prod_mono hcs hct", "start": [479, 1], "end": [486, 30], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Countable.isSeparable", "code": "theorem _root_.Set.Countable.isSeparable {s : Set \u03b1} (hs : s.Countable) : IsSeparable s", "start": [488, 1], "end": [489, 26], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isSeparable", "code": "theorem _root_.Set.Finite.isSeparable {s : Set \u03b1} (hs : s.Finite) : IsSeparable s", "start": [492, 1], "end": [493, 27], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isSeparable_univ_iff", "code": "theorem isSeparable_univ_iff : IsSeparable (univ : Set \u03b1) \u2194 SeparableSpace \u03b1", "start": [496, 1], "end": [502, 73], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isSeparable_of_separableSpace", "code": "theorem isSeparable_of_separableSpace [h : SeparableSpace \u03b1] (s : Set \u03b1) : IsSeparable s", "start": [505, 1], "end": [506, 62], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.image", "code": "theorem IsSeparable.image {\u03b2 : Type*} [TopologicalSpace \u03b2] {s : Set \u03b1} (hs : IsSeparable s)\n    {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) : IsSeparable (f '' s)", "start": [509, 1], "end": [514, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isSeparable_of_separableSpace_subtype", "code": "theorem isSeparable_of_separableSpace_subtype (s : Set \u03b1) [SeparableSpace s] : IsSeparable s", "start": [517, 1], "end": [520, 64], "kind": "commanddeclaration"}, {"full_name": "isTopologicalBasis_pi", "code": "theorem isTopologicalBasis_pi {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (X i)]\n    {T : \u2200 i, Set (Set (X i))} (cond : \u2200 i, IsTopologicalBasis (T i)) :\n    IsTopologicalBasis { S | \u2203 (U : \u2200 i, Set (X i)) (F : Finset \u03b9),\n      (\u2200 i, i \u2208 F \u2192 U i \u2208 T i) \u2227 S = (F : Set \u03b9).pi U }", "start": [527, 1], "end": [543, 101], "kind": "commanddeclaration"}, {"full_name": "isTopologicalBasis_iInf", "code": "theorem isTopologicalBasis_iInf {\u03b2 : Type*} {\u03b9 : Type*} {X : \u03b9 \u2192 Type*}\n    [t : \u2200 i, TopologicalSpace (X i)] {T : \u2200 i, Set (Set (X i))}\n    (cond : \u2200 i, IsTopologicalBasis (T i)) (f : \u2200 i, \u03b2 \u2192 X i) :\n    @IsTopologicalBasis \u03b2 (\u2a05 i, induced (f i) (t i))\n      { S | \u2203 (U : \u2200 i, Set (X i)) (F : Finset \u03b9),\n        (\u2200 i, i \u2208 F \u2192 U i \u2208 T i) \u2227 S = \u22c2 (i) (_ : i \u2208 F), f i \u207b\u00b9' U i }", "start": [546, 1], "end": [563, 8], "kind": "commanddeclaration"}, {"full_name": "isTopologicalBasis_singletons", "code": "theorem isTopologicalBasis_singletons (\u03b1 : Type*) [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] :\n    IsTopologicalBasis { s | \u2203 x : \u03b1, (s : Set \u03b1) = {x} }", "start": [566, 1], "end": [569, 64], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_countable_dense_subset", "code": "theorem Dense.exists_countable_dense_subset {\u03b1 : Type*} [TopologicalSpace \u03b1] {s : Set \u03b1}\n    [SeparableSpace s] (hs : Dense s) : \u2203 t, t \u2286 s \u2227 t.Countable \u2227 Dense t", "start": [575, 1], "end": [579, 62], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_countable_dense_subset_bot_top", "code": "theorem Dense.exists_countable_dense_subset_bot_top {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [PartialOrder \u03b1] {s : Set \u03b1} [SeparableSpace s] (hs : Dense s) :\n    \u2203 t, t \u2286 s \u2227 t.Countable \u2227 Dense t \u2227 (\u2200 x, IsBot x \u2192 x \u2208 s \u2192 x \u2208 t) \u2227\n      \u2200 x, IsTop x \u2192 x \u2208 s \u2192 x \u2208 t", "start": [583, 1], "end": [597, 48], "kind": "commanddeclaration"}, {"full_name": "separableSpace_univ", "code": "instance separableSpace_univ {\u03b1 : Type*} [TopologicalSpace \u03b1] [SeparableSpace \u03b1] :\n    SeparableSpace (univ : Set \u03b1) :=\n  (Equiv.Set.univ \u03b1).symm.surjective.denseRange.separableSpace (continuous_id.subtype_mk _)", "start": [600, 1], "end": [602, 92], "kind": "commanddeclaration"}, {"full_name": "exists_countable_dense_bot_top", "code": "theorem exists_countable_dense_bot_top (\u03b1 : Type*) [TopologicalSpace \u03b1] [SeparableSpace \u03b1]\n    [PartialOrder \u03b1] :\n    \u2203 s : Set \u03b1, s.Countable \u2227 Dense s \u2227 (\u2200 x, IsBot x \u2192 x \u2208 s) \u2227 \u2200 x, IsTop x \u2192 x \u2208 s", "start": [605, 1], "end": [612, 63], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.FirstCountableTopology", "code": "class FirstCountableTopology : Prop where\n  \n  nhds_generated_countable : \u2200 a : \u03b1, (\ud835\udcdd a).IsCountablyGenerated", "start": [621, 1], "end": [625, 65], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.FirstCountableTopology.tendsto_subseq", "code": "theorem tendsto_subseq [FirstCountableTopology \u03b1] {u : \u2115 \u2192 \u03b1} {x : \u03b1}\n    (hx : MapClusterPt x atTop u) : \u2203 \u03c8 : \u2115 \u2192 \u2115, StrictMono \u03c8 \u2227 Tendsto (u \u2218 \u03c8) atTop (\ud835\udcdd x)", "start": [634, 1], "end": [638, 29], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isCountablyGenerated_nhdsWithin", "code": "instance isCountablyGenerated_nhdsWithin (x : \u03b1) [IsCountablyGenerated (\ud835\udcdd x)] (s : Set \u03b1) :\n    IsCountablyGenerated (\ud835\udcdd[s] x) :=\n  Inf.isCountablyGenerated _ _", "start": [657, 1], "end": [659, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SecondCountableTopology", "code": "class SecondCountableTopology : Prop where\n  \n  is_open_generated_countable : \u2203 b : Set (Set \u03b1), b.Countable \u2227 t = TopologicalSpace.generateFrom b", "start": [664, 1], "end": [667, 101], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.secondCountableTopology", "code": "protected theorem IsTopologicalBasis.secondCountableTopology {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) (hc : b.Countable) : SecondCountableTopology \u03b1", "start": [672, 1], "end": [674, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SecondCountableTopology.mk'", "code": "lemma SecondCountableTopology.mk' {b : Set (Set \u03b1)} (hc : b.Countable) :\n    @SecondCountableTopology \u03b1 (generateFrom b) :=\n  @SecondCountableTopology.mk \u03b1 (generateFrom b) \u27e8b, hc, rfl\u27e9", "start": [677, 1], "end": [679, 62], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.exists_countable_basis", "code": "theorem exists_countable_basis [SecondCountableTopology \u03b1] :\n    \u2203 b : Set (Set \u03b1), b.Countable \u2227 \u2205 \u2209 b \u2227 IsTopologicalBasis b", "start": [683, 1], "end": [687, 85], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.countableBasis", "code": "def countableBasis [SecondCountableTopology \u03b1] : Set (Set \u03b1) :=\n  (exists_countable_basis \u03b1).choose", "start": [690, 1], "end": [692, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.countable_countableBasis", "code": "theorem countable_countableBasis [SecondCountableTopology \u03b1] : (countableBasis \u03b1).Countable", "start": [695, 1], "end": [696, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.encodableCountableBasis", "code": "instance encodableCountableBasis [SecondCountableTopology \u03b1] : Encodable (countableBasis \u03b1) :=\n  (countable_countableBasis \u03b1).toEncodable", "start": [699, 1], "end": [700, 43], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.empty_nmem_countableBasis", "code": "theorem empty_nmem_countableBasis [SecondCountableTopology \u03b1] : \u2205 \u2209 countableBasis \u03b1", "start": [703, 1], "end": [704, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isBasis_countableBasis", "code": "theorem isBasis_countableBasis [SecondCountableTopology \u03b1] :\n    IsTopologicalBasis (countableBasis \u03b1)", "start": [707, 1], "end": [709, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.eq_generateFrom_countableBasis", "code": "theorem eq_generateFrom_countableBasis [SecondCountableTopology \u03b1] :\n    \u2039TopologicalSpace \u03b1\u203a = generateFrom (countableBasis \u03b1)", "start": [712, 1], "end": [714, 45], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isOpen_of_mem_countableBasis", "code": "theorem isOpen_of_mem_countableBasis [SecondCountableTopology \u03b1] {s : Set \u03b1}\n    (hs : s \u2208 countableBasis \u03b1) : IsOpen s", "start": [719, 1], "end": [721, 39], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.nonempty_of_mem_countableBasis", "code": "theorem nonempty_of_mem_countableBasis [SecondCountableTopology \u03b1] {s : Set \u03b1}\n    (hs : s \u2208 countableBasis \u03b1) : s.Nonempty", "start": [724, 1], "end": [726, 84], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SecondCountableTopology.to_firstCountableTopology", "code": "instance (priority := 100) SecondCountableTopology.to_firstCountableTopology\n    [SecondCountableTopology \u03b1] : FirstCountableTopology \u03b1 :=\n  \u27e8fun _ => HasCountableBasis.isCountablyGenerated <|\n      \u27e8(isBasis_countableBasis \u03b1).nhds_hasBasis,\n        (countable_countableBasis \u03b1).mono <| inter_subset_left _ _\u27e9\u27e9", "start": [732, 1], "end": [736, 69], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.secondCountableTopology_induced", "code": "theorem secondCountableTopology_induced (\u03b2) [t : TopologicalSpace \u03b2] [SecondCountableTopology \u03b2]\n    (f : \u03b1 \u2192 \u03b2) : @SecondCountableTopology \u03b1 (t.induced f)", "start": [739, 1], "end": [746, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Subtype.secondCountableTopology", "code": "instance Subtype.secondCountableTopology (s : Set \u03b1) [SecondCountableTopology \u03b1] :\n    SecondCountableTopology s :=\n  secondCountableTopology_induced s \u03b1 (\u2191)", "start": [751, 1], "end": [753, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.secondCountableTopology_iInf", "code": "lemma secondCountableTopology_iInf {\u03b9} [Countable \u03b9] {t : \u03b9 \u2192 TopologicalSpace \u03b1}\n    (ht : \u2200 i, @SecondCountableTopology \u03b1 (t i)) : @SecondCountableTopology \u03b1 (\u2a05 i, t i) := by\n  rw [funext fun i => @eq_generateFrom_countableBasis \u03b1 (t i) (ht i), \u2190 generateFrom_iUnion]\n  exact SecondCountableTopology.mk' <|\n    countable_iUnion fun i => @countable_countableBasis _ (t i) (ht i)", "start": [756, 1], "end": [760, 71], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalSpace.SecondCountableTopology.to_separableSpace", "code": "instance (priority := 100) SecondCountableTopology.to_separableSpace [SecondCountableTopology \u03b1] :\n    SeparableSpace \u03b1 := by\n  choose p hp using fun s : countableBasis \u03b1 => nonempty_of_mem_countableBasis s.2\n  exact\n    \u27e8\u27e8range p, countable_range _,\n        (isBasis_countableBasis \u03b1).dense_iff.2 fun o ho _ => \u27e8p \u27e8o, ho\u27e9, hp _, mem_range_self _\u27e9\u27e9\u27e9", "start": [773, 1], "end": [778, 99], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.secondCountableTopology_of_countable_cover", "code": "theorem secondCountableTopology_of_countable_cover {\u03b9} [Encodable \u03b9] {U : \u03b9 \u2192 Set \u03b1}\n    [\u2200 i, SecondCountableTopology (U i)] (Uo : \u2200 i, IsOpen (U i)) (hc : \u22c3 i, U i = univ) :\n    SecondCountableTopology \u03b1", "start": [781, 1], "end": [788, 96], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isOpen_iUnion_countable", "code": "theorem isOpen_iUnion_countable [SecondCountableTopology \u03b1] {\u03b9} (s : \u03b9 \u2192 Set \u03b1)\n    (H : \u2200 i, IsOpen (s i)) : \u2203 T : Set \u03b9, T.Countable \u2227 \u22c3 i \u2208 T, s i = \u22c3 i, s i", "start": [791, 1], "end": [802, 64], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.isOpen_sUnion_countable", "code": "theorem isOpen_sUnion_countable [SecondCountableTopology \u03b1] (S : Set (Set \u03b1))\n    (H : \u2200 s \u2208 S, IsOpen s) : \u2203 T : Set (Set \u03b1), T.Countable \u2227 T \u2286 S \u2227 \u22c3\u2080 T = \u22c3\u2080 S", "start": [805, 1], "end": [809, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.countable_cover_nhds", "code": "theorem countable_cover_nhds [SecondCountableTopology \u03b1] {f : \u03b1 \u2192 Set \u03b1} (hf : \u2200 x, f x \u2208 \ud835\udcdd x) :\n    \u2203 s : Set \u03b1, s.Countable \u2227 \u22c3 x \u2208 s, f x = univ", "start": [812, 1], "end": [822, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.countable_cover_nhdsWithin", "code": "theorem countable_cover_nhdsWithin [SecondCountableTopology \u03b1] {f : \u03b1 \u2192 Set \u03b1} {s : Set \u03b1}\n    (hf : \u2200 x \u2208 s, f x \u2208 \ud835\udcdd[s] x) : \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, f x", "start": [826, 1], "end": [832, 20], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.sigma", "code": "theorem IsTopologicalBasis.sigma {s : \u2200 i : \u03b9, Set (Set (E i))}\n    (hs : \u2200 i, IsTopologicalBasis (s i)) :\n    IsTopologicalBasis (\u22c3 i : \u03b9, (fun u => (Sigma.mk i '' u : Set (\u03a3i, E i))) '' s i)", "start": [839, 1], "end": [855, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.sum", "code": "theorem IsTopologicalBasis.sum {s : Set (Set \u03b1)} (hs : IsTopologicalBasis s) {t : Set (Set \u03b2)}\n    (ht : IsTopologicalBasis t) :\n    IsTopologicalBasis ((fun u => Sum.inl '' u) '' s \u222a (fun u => Sum.inr '' u) '' t)", "start": [872, 1], "end": [889, 31], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.quotientMap", "code": "theorem IsTopologicalBasis.quotientMap {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h' : QuotientMap \u03c0) (h : IsOpenMap \u03c0) : IsTopologicalBasis (Set.image \u03c0 '' V)", "start": [909, 1], "end": [922, 64], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.secondCountableTopology", "code": "theorem _root_.QuotientMap.secondCountableTopology [SecondCountableTopology X] (h' : QuotientMap \u03c0)\n    (h : IsOpenMap \u03c0) : SecondCountableTopology Y where", "start": [925, 1], "end": [931, 54], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.quotient", "code": "theorem IsTopologicalBasis.quotient {V : Set (Set X)} (hV : IsTopologicalBasis V)\n    (h : IsOpenMap (Quotient.mk' : X \u2192 Quotient S)) :\n    IsTopologicalBasis (Set.image (Quotient.mk' : X \u2192 Quotient S) '' V)", "start": [936, 1], "end": [940, 44], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.Quotient.secondCountableTopology", "code": "theorem Quotient.secondCountableTopology [SecondCountableTopology X]\n    (h : IsOpenMap (Quotient.mk' : X \u2192 Quotient S)) : SecondCountableTopology (Quotient S)", "start": [943, 1], "end": [946, 53], "kind": "commanddeclaration"}, {"full_name": "Inducing.secondCountableTopology", "code": "protected theorem Inducing.secondCountableTopology [SecondCountableTopology \u03b2] (hf : Inducing f) :\n    SecondCountableTopology \u03b1", "start": [957, 1], "end": [960, 46], "kind": "commanddeclaration"}, {"full_name": "Embedding.secondCountableTopology", "code": "protected theorem Embedding.secondCountableTopology [SecondCountableTopology \u03b2] (hf : Embedding f) :\n    SecondCountableTopology \u03b1", "start": [963, 1], "end": [965, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Closure.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Data/SetLike/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Hom/Basic.lean", "Mathlib/Order/GaloisConnection.lean"], "premises": [{"full_name": "ClosureOperator", "code": "structure ClosureOperator [Preorder \u03b1] extends \u03b1 \u2192o \u03b1 where\n  \n  le_closure' : \u2200 x, x \u2264 toFun x\n  \n  idempotent' : \u2200 x, toFun (toFun x) = toFun x", "start": [58, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.id", "code": "@[simps!]\ndef id : ClosureOperator \u03b1 where\n  toOrderHom := OrderHom.id\n  le_closure' _ := le_rfl\n  idempotent' _ := rfl", "start": [80, 1], "end": [85, 23], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.ext", "code": "@[ext]\ntheorem ext : \u2200 c\u2081 c\u2082 : ClosureOperator \u03b1, (c\u2081 : \u03b1 \u2192 \u03b1) = (c\u2082 : \u03b1 \u2192 \u03b1) \u2192 c\u2081 = c\u2082", "start": [94, 1], "end": [97, 10], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mk'", "code": "@[simps]\ndef mk' (f : \u03b1 \u2192 \u03b1) (hf\u2081 : Monotone f) (hf\u2082 : \u2200 x, x \u2264 f x) (hf\u2083 : \u2200 x, f (f x) \u2264 f x) :\n    ClosureOperator \u03b1 where\n  toFun := f\n  monotone' := hf\u2081\n  le_closure' := hf\u2082\n  idempotent' x := (hf\u2083 x).antisymm (hf\u2081 (hf\u2082 x))", "start": [100, 1], "end": [107, 50], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mk\u2082", "code": "@[simps]\ndef mk\u2082 (f : \u03b1 \u2192 \u03b1) (hf : \u2200 x, x \u2264 f x) (hmin : \u2200 \u2983x y\u2984, x \u2264 f y \u2192 f x \u2264 f y) : ClosureOperator \u03b1\n    where\n  toFun := f\n  monotone' _ y hxy := hmin (hxy.trans (hf y))\n  le_closure' := hf\n  idempotent' _ := (hmin le_rfl).antisymm (hf _)", "start": [111, 1], "end": [119, 49], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mk\u2083", "code": "@[simps!]\ndef mk\u2083 (f : \u03b1 \u2192 \u03b1) (p : \u03b1 \u2192 Prop) (hf : \u2200 x, x \u2264 f x) (hfp : \u2200 x, p (f x))\n    (hmin : \u2200 \u2983x y\u2984, x \u2264 y \u2192 p y \u2192 f x \u2264 y) : ClosureOperator \u03b1 :=\n  mk\u2082 f hf fun _ y hxy => hmin hxy (hfp y)", "start": [123, 1], "end": [129, 43], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_mem_mk\u2083", "code": "theorem closure_mem_mk\u2083 {f : \u03b1 \u2192 \u03b1} {p : \u03b1 \u2192 Prop} {hf : \u2200 x, x \u2264 f x} {hfp : \u2200 x, p (f x)}\n    {hmin : \u2200 \u2983x y\u2984, x \u2264 y \u2192 p y \u2192 f x \u2264 y} (x : \u03b1) : p (mk\u2083 f p hf hfp hmin x)", "start": [133, 1], "end": [137, 8], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_le_mk\u2083_iff", "code": "theorem closure_le_mk\u2083_iff {f : \u03b1 \u2192 \u03b1} {p : \u03b1 \u2192 Prop} {hf : \u2200 x, x \u2264 f x} {hfp : \u2200 x, p (f x)}\n    {hmin : \u2200 \u2983x y\u2984, x \u2264 y \u2192 p y \u2192 f x \u2264 y} {x y : \u03b1} (hxy : x \u2264 y) (hy : p y) :\n    mk\u2083 f p hf hfp hmin x \u2264 y", "start": [140, 1], "end": [145, 14], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.monotone", "code": "@[mono]\ntheorem monotone : Monotone c", "start": [148, 1], "end": [150, 14], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.le_closure", "code": "theorem le_closure (x : \u03b1) : x \u2264 c x", "start": [153, 1], "end": [156, 18], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.idempotent", "code": "@[simp]\ntheorem idempotent (x : \u03b1) : c (c x) = c x", "start": [159, 1], "end": [161, 18], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.le_closure_iff", "code": "theorem le_closure_iff (x y : \u03b1) : x \u2264 c y \u2194 c x \u2264 c y", "start": [164, 1], "end": [165, 78], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closed", "code": "def closed : Set \u03b1 := {x | c x = x}", "start": [168, 1], "end": [169, 36], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mem_closed_iff", "code": "theorem mem_closed_iff (x : \u03b1) : x \u2208 c.closed \u2194 c x = x", "start": [172, 1], "end": [173, 10], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mem_closed_iff_closure_le", "code": "theorem mem_closed_iff_closure_le (x : \u03b1) : x \u2208 c.closed \u2194 c x \u2264 x", "start": [176, 1], "end": [177, 51], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_eq_self_of_mem_closed", "code": "theorem closure_eq_self_of_mem_closed {x : \u03b1} (h : x \u2208 c.closed) : c x = x", "start": [180, 1], "end": [181, 4], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_is_closed", "code": "@[simp]\ntheorem closure_is_closed (x : \u03b1) : c x \u2208 c.closed", "start": [184, 1], "end": [186, 17], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closed_eq_range_close", "code": "theorem closed_eq_range_close : c.closed = Set.range c", "start": [189, 1], "end": [194, 26], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.toClosed", "code": "def toClosed (x : \u03b1) : c.closed :=\n  \u27e8c x, c.closure_is_closed x\u27e9", "start": [197, 1], "end": [199, 31], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_le_closed_iff_le", "code": "@[simp]\ntheorem closure_le_closed_iff_le (x : \u03b1) {y : \u03b1} (hy : c.closed y) : c x \u2264 y \u2194 x \u2264 y", "start": [202, 1], "end": [204, 62], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.eq_mk\u2083_closed", "code": "theorem eq_mk\u2083_closed (c : ClosureOperator \u03b1) :\n    c =\n      mk\u2083 c c.closed c.le_closure c.closure_is_closed fun x y hxy hy =>\n        (c.closure_le_closed_iff_le x hy).2 hxy", "start": [207, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.mem_mk\u2083_closed", "code": "@[simp] theorem mem_mk\u2083_closed {f : \u03b1 \u2192 \u03b1} {p : \u03b1 \u2192 Prop} {hf hfp hmin} {x : \u03b1} :\n  x \u2208 (mk\u2083 f p hf hfp hmin).closed \u2194 p x", "start": [217, 1], "end": [222, 14], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_top", "code": "@[simp]\ntheorem closure_top : c \u22a4 = \u22a4", "start": [233, 1], "end": [235, 35], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.top_mem_closed", "code": "theorem top_mem_closed : \u22a4 \u2208 c.closed", "start": [238, 1], "end": [239, 16], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_inf_le", "code": "theorem closure_inf_le [SemilatticeInf \u03b1] (c : ClosureOperator \u03b1) (x y : \u03b1) :\n    c (x \u2293 y) \u2264 c x \u2293 c y", "start": [244, 1], "end": [246, 28], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_sup_closure_le", "code": "theorem closure_sup_closure_le (x y : \u03b1) : c x \u2294 c y \u2264 c (x \u2294 y)", "start": [253, 1], "end": [254, 28], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_sup_closure_left", "code": "theorem closure_sup_closure_left (x y : \u03b1) : c (c x \u2294 y) = c (x \u2294 y)", "start": [257, 1], "end": [260, 55], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_sup_closure_right", "code": "theorem closure_sup_closure_right (x y : \u03b1) : c (x \u2294 c y) = c (x \u2294 y)", "start": [263, 1], "end": [264, 61], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_sup_closure", "code": "theorem closure_sup_closure (x y : \u03b1) : c (c x \u2294 c y) = c (x \u2294 y)", "start": [267, 1], "end": [268, 59], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_iSup_closure", "code": "@[simp]\ntheorem closure_iSup_closure (f : \u03b9 \u2192 \u03b1) : c (\u2a06 i, c (f i)) = c (\u2a06 i, f i)", "start": [277, 1], "end": [280, 52], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.closure_iSup\u2082_closure", "code": "@[simp]\ntheorem closure_iSup\u2082_closure (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    c (\u2a06 (i) (j), c (f i j)) = c (\u2a06 (i) (j), f i j)", "start": [283, 1], "end": [287, 55], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint", "code": "structure LowerAdjoint [Preorder \u03b1] [Preorder \u03b2] (u : \u03b2 \u2192 \u03b1) where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  gc' : GaloisConnection toFun u", "start": [299, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.id", "code": "@[simps]\nprotected def id [Preorder \u03b1] : LowerAdjoint (id : \u03b1 \u2192 \u03b1) where\n  toFun x := x\n  gc' := GaloisConnection.id", "start": [313, 1], "end": [317, 29], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.gc", "code": "theorem gc : GaloisConnection l u", "start": [332, 1], "end": [333, 8], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.ext", "code": "@[ext]\ntheorem ext : \u2200 l\u2081 l\u2082 : LowerAdjoint u, (l\u2081 : \u03b1 \u2192 \u03b2) = (l\u2082 : \u03b1 \u2192 \u03b2) \u2192 l\u2081 = l\u2082", "start": [336, 1], "end": [339, 10], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.monotone", "code": "@[mono]\ntheorem monotone : Monotone (u \u2218 l)", "start": [342, 1], "end": [344, 39], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.le_closure", "code": "theorem le_closure (x : \u03b1) : x \u2264 u (l x)", "start": [347, 1], "end": [350, 16], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closureOperator", "code": "@[simps]\ndef closureOperator : ClosureOperator \u03b1 where\n  toFun x := u (l x)\n  monotone' := l.monotone\n  le_closure' := l.le_closure\n  idempotent' x := l.gc.u_l_u_eq_u (l x)", "start": [359, 1], "end": [366, 41], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.idempotent", "code": "theorem idempotent (x : \u03b1) : u (l (u (l x))) = u (l x)", "start": [370, 1], "end": [371, 33], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.le_closure_iff", "code": "theorem le_closure_iff (x y : \u03b1) : x \u2264 u (l y) \u2194 u (l x) \u2264 u (l y)", "start": [374, 1], "end": [375, 39], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closed", "code": "def closed : Set \u03b1 := {x | u (l x) = x}", "start": [384, 1], "end": [385, 40], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.mem_closed_iff", "code": "theorem mem_closed_iff (x : \u03b1) : x \u2208 l.closed \u2194 u (l x) = x", "start": [388, 1], "end": [389, 10], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_eq_self_of_mem_closed", "code": "theorem closure_eq_self_of_mem_closed {x : \u03b1} (h : x \u2208 l.closed) : u (l x) = x", "start": [392, 1], "end": [393, 4], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.mem_closed_iff_closure_le", "code": "theorem mem_closed_iff_closure_le (x : \u03b1) : x \u2208 l.closed \u2194 u (l x) \u2264 x", "start": [402, 1], "end": [403, 48], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_is_closed", "code": "@[simp, nolint simpNF] theorem closure_is_closed (x : \u03b1) : u (l x) \u2208 l.closed", "start": [406, 1], "end": [408, 17], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closed_eq_range_close", "code": "theorem closed_eq_range_close : l.closed = Set.range (u \u2218 l)", "start": [411, 1], "end": [413, 42], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.toClosed", "code": "def toClosed (x : \u03b1) : l.closed :=\n  \u27e8u (l x), l.closure_is_closed x\u27e9", "start": [416, 1], "end": [418, 35], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_le_closed_iff_le", "code": "@[simp]\ntheorem closure_le_closed_iff_le (x : \u03b1) {y : \u03b1} (hy : l.closed y) : u (l x) \u2264 y \u2194 x \u2264 y", "start": [421, 1], "end": [423, 50], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_top", "code": "theorem closure_top [PartialOrder \u03b1] [OrderTop \u03b1] [Preorder \u03b2] {u : \u03b2 \u2192 \u03b1} (l : LowerAdjoint u) :\n    u (l \u22a4) = \u22a4", "start": [428, 1], "end": [430, 32], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_inf_le", "code": "theorem closure_inf_le [SemilatticeInf \u03b1] [Preorder \u03b2] {u : \u03b2 \u2192 \u03b1} (l : LowerAdjoint u) (x y : \u03b1) :\n    u (l (x \u2293 y)) \u2264 u (l x) \u2293 u (l y)", "start": [433, 1], "end": [435, 39], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_sup_closure_le", "code": "theorem closure_sup_closure_le (x y : \u03b1) : u (l x) \u2294 u (l y) \u2264 u (l (x \u2294 y))", "start": [442, 1], "end": [443, 47], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_sup_closure_left", "code": "theorem closure_sup_closure_left (x y : \u03b1) : u (l (u (l x) \u2294 y)) = u (l (x \u2294 y))", "start": [446, 1], "end": [447, 49], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_sup_closure_right", "code": "theorem closure_sup_closure_right (x y : \u03b1) : u (l (x \u2294 u (l y))) = u (l (x \u2294 y))", "start": [450, 1], "end": [451, 50], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_sup_closure", "code": "theorem closure_sup_closure (x y : \u03b1) : u (l (u (l x) \u2294 u (l y))) = u (l (x \u2294 y))", "start": [454, 1], "end": [455, 44], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_iSup_closure", "code": "theorem closure_iSup_closure (f : \u03b9 \u2192 \u03b1) : u (l (\u2a06 i, u (l (f i)))) = u (l (\u2a06 i, f i))", "start": [464, 1], "end": [465, 43], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_iSup\u2082_closure", "code": "theorem closure_iSup\u2082_closure (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    u (l <| \u2a06 (i) (j), u (l <| f i j)) = u (l <| \u2a06 (i) (j), f i j)", "start": [468, 1], "end": [470, 44], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.subset_closure", "code": "theorem subset_closure (s : Set \u03b2) : s \u2286 l s", "start": [480, 1], "end": [481, 17], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set \u03b2} {P : \u03b2} (hP : P \u2209 l s) : P \u2209 s", "start": [484, 1], "end": [485, 28], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.le_iff_subset", "code": "theorem le_iff_subset (s : Set \u03b2) (S : \u03b1) : l s \u2264 S \u2194 s \u2286 S", "start": [488, 1], "end": [489, 11], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.mem_iff", "code": "theorem mem_iff (s : Set \u03b2) (x : \u03b2) : x \u2208 l s \u2194 \u2200 S : \u03b1, s \u2286 S \u2192 x \u2208 S", "start": [492, 1], "end": [494, 50], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.eq_of_le", "code": "theorem eq_of_le {s : Set \u03b2} {S : \u03b1} (h\u2081 : s \u2286 S) (h\u2082 : S \u2264 l s) : l s = S", "start": [497, 1], "end": [498, 43], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_union_closure_subset", "code": "theorem closure_union_closure_subset (x y : \u03b1) : (l x : Set \u03b2) \u222a l y \u2286 l (x \u222a y)", "start": [501, 1], "end": [502, 31], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_union_closure_left", "code": "@[simp]\ntheorem closure_union_closure_left (x y : \u03b1) : l (l x \u222a y) = l (x \u222a y)", "start": [505, 1], "end": [507, 57], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_union_closure_right", "code": "@[simp]\ntheorem closure_union_closure_right (x y : \u03b1) : l (x \u222a l y) = l (x \u222a y)", "start": [510, 1], "end": [512, 58], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_union_closure", "code": "theorem closure_union_closure (x y : \u03b1) : l (l x \u222a l y) = l (x \u222a y)", "start": [515, 1], "end": [516, 63], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_iUnion_closure", "code": "@[simp]\ntheorem closure_iUnion_closure (f : \u03b9 \u2192 \u03b1) : l (\u22c3 i, l (f i)) = l (\u22c3 i, f i)", "start": [519, 1], "end": [521, 52], "kind": "commanddeclaration"}, {"full_name": "LowerAdjoint.closure_iUnion\u2082_closure", "code": "@[simp]\ntheorem closure_iUnion\u2082_closure (f : \u2200 i, \u03ba i \u2192 \u03b1) :\n    l (\u22c3 (i) (j), l (f i j)) = l (\u22c3 (i) (j), f i j)", "start": [526, 1], "end": [529, 53], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.lowerAdjoint", "code": "@[simps]\ndef GaloisConnection.lowerAdjoint [Preorder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gc : GaloisConnection l u) : LowerAdjoint u\n    where\n  toFun := l\n  gc' := gc", "start": [538, 1], "end": [544, 12], "kind": "commanddeclaration"}, {"full_name": "GaloisConnection.closureOperator", "code": "@[simps!]\ndef GaloisConnection.closureOperator [PartialOrder \u03b1] [Preorder \u03b2] {l : \u03b1 \u2192 \u03b2} {u : \u03b2 \u2192 \u03b1}\n    (gc : GaloisConnection l u) : ClosureOperator \u03b1 :=\n  gc.lowerAdjoint.closureOperator", "start": [548, 1], "end": [553, 34], "kind": "commanddeclaration"}, {"full_name": "ClosureOperator.gi", "code": "def _root_.ClosureOperator.gi [PartialOrder \u03b1] (c : ClosureOperator \u03b1) :\n    GaloisInsertion c.toClosed (\u2191) where\n  choice x hx := \u27e8x, hx.antisymm (c.le_closure x)\u27e9\n  gc _ y := c.closure_le_closed_iff_le _ y.2\n  le_l_u _ := c.le_closure _\n  choice_eq x hx := le_antisymm (c.le_closure x) hx", "start": [557, 1], "end": [563, 52], "kind": "commanddeclaration"}, {"full_name": "closureOperator_gi_self", "code": "@[simp]\ntheorem closureOperator_gi_self [PartialOrder \u03b1] (c : ClosureOperator \u03b1) :\n    c.gi.gc.closureOperator = c", "start": [566, 1], "end": [573, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Pairwise.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.pairwiseDisjoint_range_singleton", "code": "theorem Finset.pairwiseDisjoint_range_singleton :\n    (Set.range (singleton : \u03b1 \u2192 Finset \u03b1)).PairwiseDisjoint id", "start": [27, 1], "end": [30, 50], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.elim_finset", "code": "theorem PairwiseDisjoint.elim_finset {s : Set \u03b9} {f : \u03b9 \u2192 Finset \u03b1} (hs : s.PairwiseDisjoint f)\n    {i j : \u03b9} (hi : i \u2208 s) (hj : j \u2208 s) (a : \u03b1) (hai : a \u2208 f i) (haj : a \u2208 f j) : i = j", "start": [35, 1], "end": [37, 58], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.image_finset_of_le", "code": "theorem PairwiseDisjoint.image_finset_of_le [DecidableEq \u03b9] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : (s : Set \u03b9).PairwiseDisjoint f) {g : \u03b9 \u2192 \u03b9} (hf : \u2200 a, f (g a) \u2264 f a) :\n    (s.image g : Set \u03b9).PairwiseDisjoint f", "start": [44, 1], "end": [48, 26], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.attach", "code": "theorem PairwiseDisjoint.attach (hs : (s : Set \u03b9).PairwiseDisjoint f) :\n    (s.attach : Set { x // x \u2208 s }).PairwiseDisjoint (f \u2218 Subtype.val)", "start": [51, 1], "end": [53, 39], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.biUnion_finset", "code": "theorem PairwiseDisjoint.biUnion_finset {s : Set \u03b9'} {g : \u03b9' \u2192 Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.PairwiseDisjoint fun i' : \u03b9' => (g i').sup f)\n    (hg : \u2200 i \u2208 s, (g i : Set \u03b9).PairwiseDisjoint f) : (\u22c3 i \u2208 s, \u2191(g i)).PairwiseDisjoint f", "start": [60, 1], "end": [71, 87], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_of_coe_toFinset_pairwise", "code": "theorem pairwise_of_coe_toFinset_pairwise (hl : (l.toFinset : Set \u03b1).Pairwise r) (hn : l.Nodup) :\n    l.Pairwise r", "start": [80, 1], "end": [83, 39], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_iff_coe_toFinset_pairwise", "code": "theorem pairwise_iff_coe_toFinset_pairwise (hn : l.Nodup) (hs : Symmetric r) :\n    (l.toFinset : Set \u03b1).Pairwise r \u2194 l.Pairwise r", "start": [86, 1], "end": [89, 37], "kind": "commanddeclaration"}, {"full_name": "List.pairwise_disjoint_of_coe_toFinset_pairwiseDisjoint", "code": "theorem pairwise_disjoint_of_coe_toFinset_pairwiseDisjoint {\u03b1 \u03b9} [SemilatticeInf \u03b1] [OrderBot \u03b1]\n    [DecidableEq \u03b9] {l : List \u03b9} {f : \u03b9 \u2192 \u03b1} (hl : (l.toFinset : Set \u03b9).PairwiseDisjoint f)\n    (hn : l.Nodup) : l.Pairwise (_root_.Disjoint on f)", "start": [92, 1], "end": [95, 42], "kind": "commanddeclaration"}, {"full_name": "List.pairwiseDisjoint_iff_coe_toFinset_pairwise_disjoint", "code": "theorem pairwiseDisjoint_iff_coe_toFinset_pairwise_disjoint {\u03b1 \u03b9} [SemilatticeInf \u03b1] [OrderBot \u03b1]\n    [DecidableEq \u03b9] {l : List \u03b9} {f : \u03b9 \u2192 \u03b1} (hn : l.Nodup) :\n    (l.toFinset : Set \u03b9).PairwiseDisjoint f \u2194 l.Pairwise (_root_.Disjoint on f)", "start": [98, 1], "end": [101, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Control/Lawful.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StateT.mk", "code": "protected def mk (f : \u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)) : StateT \u03c3 m \u03b1 := f", "start": [75, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "StateT.run_mk", "code": "@[simp]\ntheorem run_mk (f : \u03c3 \u2192 m (\u03b1 \u00d7 \u03c3)) (st : \u03c3) : StateT.run (StateT.mk f) st = f st", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_mk", "code": "@[simp]\ntheorem run_mk (x : m (Except \u03b5 \u03b1)) : ExceptT.run (ExceptT.mk x) = x", "start": [112, 1], "end": [114, 6], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_monadLift", "code": "@[simp]\ntheorem run_monadLift {n} [MonadLiftT n m] (x : n \u03b1) :\n    (monadLift x : ExceptT \u03b5 m \u03b1).run = Except.ok <$> (monadLift x : m \u03b1)", "start": [125, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "ExceptT.run_monadMap", "code": "@[simp]\ntheorem run_monadMap {n} [MonadFunctorT n m] (f : \u2200 {\u03b1}, n \u03b1 \u2192 n \u03b1) :\n    (monadMap (@f) x : ExceptT \u03b5 m \u03b1).run = monadMap (@f) x.run", "start": [131, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "ReaderT.mk", "code": "protected def mk (f : \u03c3 \u2192 m \u03b1) : ReaderT \u03c3 m \u03b1 := f", "start": [163, 1], "end": [163, 52], "kind": "commanddeclaration"}, {"full_name": "ReaderT.run_mk", "code": "@[simp]\ntheorem run_mk (f : \u03c3 \u2192 m \u03b1) (r : \u03c3) : ReaderT.run (ReaderT.mk f) r = f r", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "OptionT.ext", "code": "theorem ext {x x' : OptionT m \u03b1} (h : x.run = x'.run) : x = x'", "start": [192, 1], "end": [193, 4], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_mk", "code": "@[simp]\ntheorem run_mk (x : m (Option \u03b1)) : OptionT.run (OptionT.mk x) = x", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_pure", "code": "@[simp]\ntheorem run_pure (a) : (pure a : OptionT m \u03b1).run = pure (some a)", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_bind", "code": "@[simp]\ntheorem run_bind (f : \u03b1 \u2192 OptionT m \u03b2) :\n    (x >>= f).run = x.run >>= fun\n                              | some a => OptionT.run (f a)\n                              | none   => pure none", "start": [208, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_map", "code": "@[simp]\ntheorem run_map (f : \u03b1 \u2192 \u03b2) [LawfulMonad m] : (f <$> x).run = Option.map f <$> x.run", "start": [216, 1], "end": [223, 54], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_monadLift", "code": "@[simp]\ntheorem run_monadLift {n} [MonadLiftT n m] (x : n \u03b1) :\n    (monadLift x : OptionT m \u03b1).run = (monadLift x : m \u03b1) >>= fun a => pure (some a)", "start": [226, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "OptionT.run_monadMap", "code": "@[simp]\ntheorem run_monadMap {n} [MonadFunctorT n m] (f : \u2200 {\u03b1}, n \u03b1 \u2192 n \u03b1) :\n    (monadMap (@f) x : OptionT m \u03b1).run = monadMap (@f) x.run", "start": [232, 1], "end": [235, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Subring/Basic.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/RingTheory/Subsemiring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SubringClass", "code": "class SubringClass (S : Type*) (R : Type u) [Ring R] [SetLike S R] extends\n  SubsemiringClass S R, NegMemClass S R : Prop", "start": [75, 1], "end": [78, 47], "kind": "commanddeclaration"}, {"full_name": "SubringClass.addSubgroupClass", "code": "instance (priority := 100) SubringClass.addSubgroupClass (S : Type*) (R : Type u)\n    [SetLike S R] [Ring R] [h : SubringClass S R] : AddSubgroupClass S R :=\n  { h with }", "start": [82, 1], "end": [84, 13], "kind": "commanddeclaration"}, {"full_name": "coe_int_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem coe_int_mem (n : \u2124) : (n : R) \u2208 s", "start": [89, 1], "end": [90, 92], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toHasIntCast", "code": "instance (priority := 75) toHasIntCast : IntCast s :=\n  \u27e8fun n => \u27e8n, coe_int_mem s n\u27e9\u27e9", "start": [95, 1], "end": [96, 34], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toRing", "code": "instance (priority := 75) toRing : Ring s :=\n  Subtype.coe_injective.ring (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) fun _ => rfl", "start": [100, 1], "end": [103, 100], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toCommRing", "code": "instance (priority := 75) toCommRing {R} [CommRing R] [SetLike S R] [SubringClass S R] :\n    CommRing s :=\n  Subtype.coe_injective.commRing (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) fun _ => rfl", "start": [107, 1], "end": [111, 100], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toOrderedRing", "code": "instance (priority := 75) toOrderedRing {R} [OrderedRing R] [SetLike S R] [SubringClass S R] :\n    OrderedRing s :=\n  Subtype.coe_injective.orderedRing (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) fun _ => rfl", "start": [121, 1], "end": [125, 100], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toOrderedCommRing", "code": "instance (priority := 75) toOrderedCommRing {R} [OrderedCommRing R] [SetLike S R]\n    [SubringClass S R] : OrderedCommRing s :=\n  Subtype.coe_injective.orderedCommRing (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) fun _ => rfl", "start": [129, 1], "end": [133, 100], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toLinearOrderedRing", "code": "instance (priority := 75) toLinearOrderedRing {R} [LinearOrderedRing R] [SetLike S R]\n    [SubringClass S R] : LinearOrderedRing s :=\n  Subtype.coe_injective.linearOrderedRing (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [137, 1], "end": [142, 66], "kind": "commanddeclaration"}, {"full_name": "SubringClass.toLinearOrderedCommRing", "code": "instance (priority := 75) toLinearOrderedCommRing {R} [LinearOrderedCommRing R] [SetLike S R]\n    [SubringClass S R] : LinearOrderedCommRing s :=\n  Subtype.coe_injective.linearOrderedCommRing (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [146, 1], "end": [151, 66], "kind": "commanddeclaration"}, {"full_name": "SubringClass.subtype", "code": "def subtype (s : S) : s \u2192+* R :=\n  { SubmonoidClass.subtype s, AddSubgroupClass.subtype s with\n    toFun := (\u2191) }", "start": [154, 1], "end": [157, 19], "kind": "commanddeclaration"}, {"full_name": "SubringClass.coeSubtype", "code": "@[simp]\ntheorem coeSubtype : (subtype s : s \u2192 R) = ((\u2191) : s \u2192 R)", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "SubringClass.coe_natCast", "code": "@[simp, norm_cast]\ntheorem coe_natCast (n : \u2115) : ((n : s) : R) = n", "start": [165, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "SubringClass.coe_intCast", "code": "@[simp, norm_cast]\ntheorem coe_intCast (n : \u2124) : ((n : s) : R) = n", "start": [170, 1], "end": [172, 28], "kind": "commanddeclaration"}, {"full_name": "Subring", "code": "structure Subring (R : Type u) [Ring R] extends Subsemiring R, AddSubgroup R", "start": [181, 1], "end": [184, 77], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_toSubsemiring", "code": "@[simp]\ntheorem mem_toSubsemiring {s : Subring R} {x : R} : x \u2208 s.toSubsemiring \u2194 x \u2208 s", "start": [210, 1], "end": [211, 91], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_carrier", "code": "theorem mem_carrier {s : Subring R} {x : R} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [213, 1], "end": [214, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_mk", "code": "@[simp]\ntheorem mem_mk {S : Subsemiring R} {x : R} (h) : x \u2208 (\u27e8S, h\u27e9 : Subring R) \u2194 x \u2208 S", "start": [217, 1], "end": [218, 93], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_set_mk", "code": "@[simp] theorem coe_set_mk (S : Subsemiring R) (h) : ((\u27e8S, h\u27e9 : Subring R) : Set R) = S", "start": [221, 1], "end": [221, 95], "kind": "commanddeclaration"}, {"full_name": "Subring.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk {S S' : Subsemiring R} (h\u2081 h\u2082) :\n    (\u27e8S, h\u2081\u27e9 : Subring R) \u2264 (\u27e8S', h\u2082\u27e9 : Subring R) \u2194 S \u2264 S'", "start": [224, 1], "end": [227, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.ext", "code": "@[ext]\ntheorem ext {S T : Subring R} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [230, 1], "end": [233, 16], "kind": "commanddeclaration"}, {"full_name": "Subring.copy", "code": "protected def copy (S : Subring R) (s : Set R) (hs : s = \u2191S) : Subring R :=\n  { S.toSubsemiring.copy s hs with\n    carrier := s\n    neg_mem' := hs.symm \u25b8 S.neg_mem' }", "start": [236, 1], "end": [241, 39], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : Subring R) (s : Set R) (hs : s = \u2191S) : (S.copy s hs : Set R) = s", "start": [244, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.copy_eq", "code": "theorem copy_eq (S : Subring R) (s : Set R) (hs : s = \u2191S) : S.copy s hs = S", "start": [249, 1], "end": [250, 27], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubsemiring_injective", "code": "theorem toSubsemiring_injective : Function.Injective (toSubsemiring : Subring R \u2192 Subsemiring R)", "start": [253, 1], "end": [254, 46], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubsemiring_strictMono", "code": "@[mono]\ntheorem toSubsemiring_strictMono : StrictMono (toSubsemiring : Subring R \u2192 Subsemiring R)", "start": [257, 1], "end": [259, 16], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubsemiring_mono", "code": "@[mono]\ntheorem toSubsemiring_mono : Monotone (toSubsemiring : Subring R \u2192 Subsemiring R)", "start": [262, 1], "end": [264, 36], "kind": "commanddeclaration"}, {"full_name": "Subring.toAddSubgroup_injective", "code": "theorem toAddSubgroup_injective : Function.Injective (toAddSubgroup : Subring R \u2192 AddSubgroup R)", "start": [267, 1], "end": [268, 46], "kind": "commanddeclaration"}, {"full_name": "Subring.toAddSubgroup_strictMono", "code": "@[mono]\ntheorem toAddSubgroup_strictMono : StrictMono (toAddSubgroup : Subring R \u2192 AddSubgroup R)", "start": [271, 1], "end": [273, 16], "kind": "commanddeclaration"}, {"full_name": "Subring.toAddSubgroup_mono", "code": "@[mono]\ntheorem toAddSubgroup_mono : Monotone (toAddSubgroup : Subring R \u2192 AddSubgroup R)", "start": [276, 1], "end": [278, 36], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubmonoid_injective", "code": "theorem toSubmonoid_injective : Function.Injective (fun s : Subring R => s.toSubmonoid)", "start": [281, 1], "end": [282, 46], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubmonoid_strictMono", "code": "@[mono]\ntheorem toSubmonoid_strictMono : StrictMono (fun s : Subring R => s.toSubmonoid)", "start": [285, 1], "end": [286, 98], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubmonoid_mono", "code": "@[mono]\ntheorem toSubmonoid_mono : Monotone (fun s : Subring R => s.toSubmonoid)", "start": [289, 1], "end": [291, 34], "kind": "commanddeclaration"}, {"full_name": "Subring.mk'", "code": "protected def mk' (s : Set R) (sm : Submonoid R) (sa : AddSubgroup R) (hm : \u2191sm = s)\n    (ha : \u2191sa = s) : Subring R :=\n  { sm.copy s hm.symm, sa.copy s ha.symm with }", "start": [294, 1], "end": [298, 48], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_mk'", "code": "@[simp]\ntheorem coe_mk' {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubgroup R} (ha : \u2191sa = s) :\n    (Subring.mk' s sm sa hm ha : Set R) = s", "start": [301, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_mk'", "code": "@[simp]\ntheorem mem_mk' {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubgroup R} (ha : \u2191sa = s)\n    {x : R} : x \u2208 Subring.mk' s sm sa hm ha \u2194 x \u2208 s", "start": [307, 1], "end": [310, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.mk'_toSubmonoid", "code": "@[simp]\ntheorem mk'_toSubmonoid {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubgroup R}\n    (ha : \u2191sa = s) : (Subring.mk' s sm sa hm ha).toSubmonoid = sm", "start": [313, 1], "end": [316, 32], "kind": "commanddeclaration"}, {"full_name": "Subring.mk'_toAddSubgroup", "code": "@[simp]\ntheorem mk'_toAddSubgroup {s : Set R} {sm : Submonoid R} (hm : \u2191sm = s) {sa : AddSubgroup R}\n    (ha : \u2191sa = s) : (Subring.mk' s sm sa hm ha).toAddSubgroup = sa", "start": [319, 1], "end": [322, 32], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.toSubring", "code": "def Subsemiring.toSubring (s : Subsemiring R) (hneg : (-1 : R) \u2208 s) : Subring R where\n  toSubsemiring := s\n  neg_mem' h := by\n    rw [\u2190 neg_one_mul]\n    exact mul_mem hneg h", "start": [327, 1], "end": [332, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.one_mem", "code": "protected theorem one_mem : (1 : R) \u2208 s", "start": [339, 1], "end": [341, 12], "kind": "commanddeclaration"}, {"full_name": "Subring.zero_mem", "code": "protected theorem zero_mem : (0 : R) \u2208 s", "start": [344, 1], "end": [346, 13], "kind": "commanddeclaration"}, {"full_name": "Subring.mul_mem", "code": "protected theorem mul_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x * y \u2208 s", "start": [349, 1], "end": [351, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.add_mem", "code": "protected theorem add_mem {x y : R} : x \u2208 s \u2192 y \u2208 s \u2192 x + y \u2208 s", "start": [354, 1], "end": [356, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.neg_mem", "code": "protected theorem neg_mem {x : R} : x \u2208 s \u2192 -x \u2208 s", "start": [359, 1], "end": [361, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.sub_mem", "code": "protected theorem sub_mem {x y : R} (hx : x \u2208 s) (hy : y \u2208 s) : x - y \u2208 s", "start": [364, 1], "end": [366, 16], "kind": "commanddeclaration"}, {"full_name": "Subring.list_prod_mem", "code": "protected theorem list_prod_mem {l : List R} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.prod \u2208 s", "start": [369, 1], "end": [371, 16], "kind": "commanddeclaration"}, {"full_name": "Subring.list_sum_mem", "code": "protected theorem list_sum_mem {l : List R} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s", "start": [374, 1], "end": [376, 15], "kind": "commanddeclaration"}, {"full_name": "Subring.multiset_prod_mem", "code": "protected theorem multiset_prod_mem {R} [CommRing R] (s : Subring R) (m : Multiset R) :\n    (\u2200 a \u2208 m, a \u2208 s) \u2192 m.prod \u2208 s", "start": [379, 1], "end": [382, 22], "kind": "commanddeclaration"}, {"full_name": "Subring.multiset_sum_mem", "code": "protected theorem multiset_sum_mem {R} [Ring R] (s : Subring R) (m : Multiset R) :\n    (\u2200 a \u2208 m, a \u2208 s) \u2192 m.sum \u2208 s", "start": [385, 1], "end": [389, 21], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_mem", "code": "protected theorem prod_mem {R : Type*} [CommRing R] (s : Subring R) {\u03b9 : Type*} {t : Finset \u03b9}\n    {f : \u03b9 \u2192 R} (h : \u2200 c \u2208 t, f c \u2208 s) : (\u220f i in t, f i) \u2208 s", "start": [392, 1], "end": [396, 13], "kind": "commanddeclaration"}, {"full_name": "Subring.sum_mem", "code": "protected theorem sum_mem {R : Type*} [Ring R] (s : Subring R) {\u03b9 : Type*} {t : Finset \u03b9}\n    {f : \u03b9 \u2192 R} (h : \u2200 c \u2208 t, f c \u2208 s) : (\u2211 i in t, f i) \u2208 s", "start": [399, 1], "end": [403, 12], "kind": "commanddeclaration"}, {"full_name": "Subring.toRing", "code": "instance toRing : Ring s := SubringClass.toRing s", "start": [406, 1], "end": [407, 50], "kind": "commanddeclaration"}, {"full_name": "Subring.zsmul_mem", "code": "protected theorem zsmul_mem {x : R} (hx : x \u2208 s) (n : \u2124) : n \u2022 x \u2208 s", "start": [410, 1], "end": [411, 17], "kind": "commanddeclaration"}, {"full_name": "Subring.pow_mem", "code": "protected theorem pow_mem {x : R} (hx : x \u2208 s) (n : \u2115) : x ^ n \u2208 s", "start": [414, 1], "end": [415, 15], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : s) : (\u2191(x + y) : R) = \u2191x + \u2191y", "start": [418, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (x : s) : (\u2191(-x) : R) = -\u2191x", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (\u2191(x * y) : R) = \u2191x * \u2191y", "start": [428, 1], "end": [430, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : R) = 0", "start": [433, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : R) = 1", "start": [438, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : s) (n : \u2115) : \u2191(x ^ n) = (x : R) ^ n", "start": [443, 1], "end": [445, 29], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_eq_zero_iff", "code": "theorem coe_eq_zero_iff {x : s} : (x : R) = 0 \u2194 x = 0", "start": [450, 1], "end": [451, 87], "kind": "commanddeclaration"}, {"full_name": "Subring.toCommRing", "code": "instance toCommRing {R} [CommRing R] (s : Subring R) : CommRing s :=\n  SubringClass.toCommRing s", "start": [454, 1], "end": [456, 28], "kind": "commanddeclaration"}, {"full_name": "Subring.toOrderedRing", "code": "instance toOrderedRing {R} [OrderedRing R] (s : Subring R) : OrderedRing s :=\n  SubringClass.toOrderedRing s", "start": [471, 1], "end": [473, 31], "kind": "commanddeclaration"}, {"full_name": "Subring.toOrderedCommRing", "code": "instance toOrderedCommRing {R} [OrderedCommRing R] (s : Subring R) : OrderedCommRing s :=\n  SubringClass.toOrderedCommRing s", "start": [476, 1], "end": [478, 35], "kind": "commanddeclaration"}, {"full_name": "Subring.toLinearOrderedRing", "code": "instance toLinearOrderedRing {R} [LinearOrderedRing R] (s : Subring R) : LinearOrderedRing s :=\n  SubringClass.toLinearOrderedRing s", "start": [481, 1], "end": [483, 37], "kind": "commanddeclaration"}, {"full_name": "Subring.toLinearOrderedCommRing", "code": "instance toLinearOrderedCommRing {R} [LinearOrderedCommRing R] (s : Subring R) :\n    LinearOrderedCommRing s :=\n  SubringClass.toLinearOrderedCommRing s", "start": [486, 1], "end": [489, 41], "kind": "commanddeclaration"}, {"full_name": "Subring.subtype", "code": "def subtype (s : Subring R) : s \u2192+* R :=\n  { s.toSubmonoid.subtype, s.toAddSubgroup.subtype with toFun := (\u2191) }", "start": [492, 1], "end": [494, 71], "kind": "commanddeclaration"}, {"full_name": "Subring.coeSubtype", "code": "@[simp]\ntheorem coeSubtype : \u21d1s.subtype = ((\u2191) : s \u2192 R)", "start": [497, 1], "end": [499, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_natCast", "code": "@[norm_cast] theorem coe_natCast : \u2200 n : \u2115, ((n : s) : R) = n", "start": [502, 1], "end": [504, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_intCast", "code": "@[norm_cast] theorem coe_intCast : \u2200 n : \u2124, ((n : s) : R) = n", "start": [507, 1], "end": [509, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_toSubsemiring", "code": "@[simp]\ntheorem coe_toSubsemiring (s : Subring R) : (s.toSubsemiring : Set R) = s", "start": [515, 1], "end": [517, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_toSubmonoid", "code": "@[simp, nolint simpNF] theorem mem_toSubmonoid {s : Subring R} {x : R} : x \u2208 s.toSubmonoid \u2194 x \u2208 s", "start": [519, 1], "end": [521, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_toSubmonoid", "code": "@[simp]\ntheorem coe_toSubmonoid (s : Subring R) : (s.toSubmonoid : Set R) = s", "start": [524, 1], "end": [526, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_toAddSubgroup", "code": "@[simp, nolint simpNF] theorem mem_toAddSubgroup {s : Subring R} {x : R} : x \u2208 s.toAddSubgroup \u2194 x \u2208 s", "start": [529, 1], "end": [531, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_toAddSubgroup", "code": "@[simp]\ntheorem coe_toAddSubgroup (s : Subring R) : (s.toAddSubgroup : Set R) = s", "start": [534, 1], "end": [536, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_top", "code": "@[simp]\ntheorem mem_top (x : R) : x \u2208 (\u22a4 : Subring R)", "start": [546, 1], "end": [548, 17], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : Subring R) : Set R) = Set.univ", "start": [551, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.topEquiv", "code": "@[simps!]\ndef topEquiv : (\u22a4 : Subring R) \u2243+* R :=\n  Subsemiring.topEquiv", "start": [556, 1], "end": [559, 23], "kind": "commanddeclaration"}, {"full_name": "Subring.comap", "code": "def comap {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) (s : Subring S) : Subring R :=\n  { s.toSubmonoid.comap (f : R \u2192* S), s.toAddSubgroup.comap (f : R \u2192+ S) with\n    carrier := f \u207b\u00b9' s.carrier }", "start": [565, 1], "end": [568, 33], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_comap", "code": "@[simp]\ntheorem coe_comap (s : Subring S) (f : R \u2192+* S) : (s.comap f : Set R) = f \u207b\u00b9' s", "start": [571, 1], "end": [573, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_comap", "code": "@[simp]\ntheorem mem_comap {s : Subring S} {f : R \u2192+* S} {x : R} : x \u2208 s.comap f \u2194 f x \u2208 s", "start": [576, 1], "end": [578, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.comap_comap", "code": "theorem comap_comap (s : Subring T) (g : S \u2192+* T) (f : R \u2192+* S) :\n    (s.comap g).comap f = s.comap (g.comp f)", "start": [581, 1], "end": [583, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.map", "code": "def map {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) (s : Subring R) : Subring S :=\n  { s.toSubmonoid.map (f : R \u2192* S), s.toAddSubgroup.map (f : R \u2192+ S) with\n    carrier := f '' s.carrier }", "start": [589, 1], "end": [592, 32], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_map", "code": "@[simp]\ntheorem coe_map (f : R \u2192+* S) (s : Subring R) : (s.map f : Set S) = f '' s", "start": [595, 1], "end": [597, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_map", "code": "@[simp]\ntheorem mem_map {f : R \u2192+* S} {s : Subring R} {y : S} : y \u2208 s.map f \u2194 \u2203 x \u2208 s, f x = y", "start": [600, 1], "end": [602, 40], "kind": "commanddeclaration"}, {"full_name": "Subring.map_id", "code": "@[simp]\ntheorem map_id : s.map (RingHom.id R) = s", "start": [605, 1], "end": [607, 42], "kind": "commanddeclaration"}, {"full_name": "Subring.map_map", "code": "theorem map_map (g : S \u2192+* T) (f : R \u2192+* S) : (s.map f).map g = s.map (g.comp f)", "start": [610, 1], "end": [611, 49], "kind": "commanddeclaration"}, {"full_name": "Subring.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : R \u2192+* S} {s : Subring R} {t : Subring S} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f", "start": [614, 1], "end": [616, 23], "kind": "commanddeclaration"}, {"full_name": "Subring.gc_map_comap", "code": "theorem gc_map_comap (f : R \u2192+* S) : GaloisConnection (map f) (comap f)", "start": [619, 1], "end": [620, 22], "kind": "commanddeclaration"}, {"full_name": "Subring.equivMapOfInjective", "code": "noncomputable def equivMapOfInjective (f : R \u2192+* S) (hf : Function.Injective f) : s \u2243+* s.map f :=\n  { Equiv.Set.image f s hf with\n    map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _)\n    map_add' := fun _ _ => Subtype.ext (f.map_add _ _) }", "start": [623, 1], "end": [627, 57], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_equivMapOfInjective_apply", "code": "@[simp]\ntheorem coe_equivMapOfInjective_apply (f : R \u2192+* S) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x", "start": [630, 1], "end": [633, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.range", "code": "def range {R : Type u} {S : Type v} [Ring R] [Ring S] (f : R \u2192+* S) : Subring S :=\n  ((\u22a4 : Subring R).map f).copy (Set.range f) Set.image_univ.symm", "start": [645, 1], "end": [647, 65], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_range", "code": "@[simp]\ntheorem coe_range : (f.range : Set S) = Set.range f", "start": [650, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_range", "code": "@[simp]\ntheorem mem_range {f : R \u2192+* S} {y : S} : y \u2208 f.range \u2194 \u2203 x, f x = y", "start": [655, 1], "end": [657, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.range_eq_map", "code": "theorem range_eq_map (f : R \u2192+* S) : f.range = Subring.map f \u22a4", "start": [660, 1], "end": [662, 7], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_range_self", "code": "theorem mem_range_self (f : R \u2192+* S) (x : R) : f x \u2208 f.range", "start": [665, 1], "end": [666, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_range", "code": "theorem map_range : f.range.map g = (g.comp f).range", "start": [669, 1], "end": [670, 62], "kind": "commanddeclaration"}, {"full_name": "RingHom.fintypeRange", "code": "instance fintypeRange [Fintype R] [DecidableEq S] (f : R \u2192+* S) : Fintype (range f) :=\n  Set.fintypeRange f", "start": [673, 1], "end": [677, 21], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_bot", "code": "theorem coe_bot : ((\u22a5 : Subring R) : Set R) = Set.range ((\u2191) : \u2124 \u2192 R)", "start": [693, 1], "end": [694, 40], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_bot", "code": "theorem mem_bot {x : R} : x \u2208 (\u22a5 : Subring R) \u2194 \u2203 n : \u2124, \u2191n = x", "start": [697, 1], "end": [698, 20], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_inf", "code": "@[simp]\ntheorem coe_inf (p p' : Subring R) : ((p \u2293 p' : Subring R) : Set R) = (p : Set R) \u2229 p'", "start": [709, 1], "end": [711, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_inf", "code": "@[simp]\ntheorem mem_inf {p p' : Subring R} {x : R} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [714, 1], "end": [716, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subring R)) : ((sInf S : Subring R) : Set R) = \u22c2 s \u2208 S, \u2191s", "start": [724, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_sInf", "code": "theorem mem_sInf {S : Set (Subring R)} {x : R} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [729, 1], "end": [730, 18], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subring R} : (\u2191(\u2a05 i, S i) : Set R) = \u22c2 i, S i", "start": [733, 1], "end": [735, 48], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subring R} {x : R} : (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [738, 1], "end": [739, 51], "kind": "commanddeclaration"}, {"full_name": "Subring.sInf_toSubmonoid", "code": "@[simp]\ntheorem sInf_toSubmonoid (s : Set (Subring R)) :\n    (sInf s).toSubmonoid = \u2a05 t \u2208 s, t.toSubmonoid", "start": [742, 1], "end": [745, 22], "kind": "commanddeclaration"}, {"full_name": "Subring.sInf_toAddSubgroup", "code": "@[simp]\ntheorem sInf_toAddSubgroup (s : Set (Subring R)) :\n    (sInf s).toAddSubgroup = \u2a05 t \u2208 s, Subring.toAddSubgroup t", "start": [748, 1], "end": [751, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.eq_top_iff'", "code": "theorem eq_top_iff' (A : Subring R) : A = \u22a4 \u2194 \u2200 x : R, x \u2208 A", "start": [769, 1], "end": [770, 65], "kind": "commanddeclaration"}, {"full_name": "Subring.center", "code": "def center : Subring R :=\n  { Subsemiring.center R with\n    carrier := Set.center R\n    neg_mem' := Set.neg_mem_center }", "start": [780, 1], "end": [784, 37], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_center", "code": "theorem coe_center : \u2191(center R) = Set.center R", "start": [787, 1], "end": [788, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.center_toSubsemiring", "code": "@[simp]\ntheorem center_toSubsemiring : (center R).toSubsemiring = Subsemiring.center R", "start": [791, 1], "end": [793, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_center_iff", "code": "theorem mem_center_iff {z : R} : z \u2208 center R \u2194 \u2200 g, g * z = z * g", "start": [798, 1], "end": [799, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.decidableMemCenter", "code": "instance decidableMemCenter [DecidableEq R] [Fintype R] : DecidablePred (\u00b7 \u2208 center R) := fun _ =>\n  decidable_of_iff' _ mem_center_iff", "start": [802, 1], "end": [803, 37], "kind": "commanddeclaration"}, {"full_name": "Subring.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (R) [CommRing R] : center R = \u22a4", "start": [806, 1], "end": [808, 47], "kind": "commanddeclaration"}, {"full_name": "Subring.center.coe_inv", "code": "@[simp]\ntheorem center.coe_inv (a : center K) : ((a\u207b\u00b9 : center K) : K) = (a : K)\u207b\u00b9", "start": [829, 1], "end": [831, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.center.coe_div", "code": "@[simp]\ntheorem center.coe_div (a b : center K) : ((a / b : center K) : K) = (a : K) / (b : K)", "start": [834, 1], "end": [836, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer", "code": "def centralizer (s : Set R) : Subring R :=\n  { Subsemiring.centralizer s with neg_mem' := Set.neg_mem_centralizer }", "start": [843, 1], "end": [845, 73], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set R) : (centralizer s : Set R) = s.centralizer", "start": [848, 1], "end": [850, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer_toSubmonoid", "code": "theorem centralizer_toSubmonoid (s : Set R) :\n    (centralizer s).toSubmonoid = Submonoid.centralizer s", "start": [853, 1], "end": [855, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer_toSubsemiring", "code": "theorem centralizer_toSubsemiring (s : Set R) :\n    (centralizer s).toSubsemiring = Subsemiring.centralizer s", "start": [858, 1], "end": [860, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {s : Set R} {z : R} : z \u2208 centralizer s \u2194 \u2200 g \u2208 s, g * z = z * g", "start": [863, 1], "end": [864, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.center_le_centralizer", "code": "theorem center_le_centralizer (s) : center R \u2264 centralizer s", "start": [867, 1], "end": [868, 30], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer_le", "code": "theorem centralizer_le (s t : Set R) (h : s \u2286 t) : centralizer t \u2264 centralizer s", "start": [871, 1], "end": [872, 27], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer_eq_top_iff_subset", "code": "@[simp]\ntheorem centralizer_eq_top_iff_subset {s : Set R} : centralizer s = \u22a4 \u2194 s \u2286 center R", "start": [875, 1], "end": [877, 59], "kind": "commanddeclaration"}, {"full_name": "Subring.centralizer_univ", "code": "@[simp]\ntheorem centralizer_univ : centralizer Set.univ = center R", "start": [880, 1], "end": [882, 40], "kind": "commanddeclaration"}, {"full_name": "Subring.closure", "code": "def closure (s : Set R) : Subring R :=\n  sInf { S | s \u2286 S }", "start": [890, 1], "end": [892, 21], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_closure", "code": "theorem mem_closure {x : R} {s : Set R} : x \u2208 closure s \u2194 \u2200 S : Subring R, s \u2286 S \u2192 x \u2208 S", "start": [895, 1], "end": [896, 11], "kind": "commanddeclaration"}, {"full_name": "Subring.subset_closure", "code": "@[simp, aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_closure {s : Set R} : s \u2286 closure s", "start": [899, 1], "end": [901, 98], "kind": "commanddeclaration"}, {"full_name": "Subring.not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P \u2209 closure s) : P \u2209 s", "start": [904, 1], "end": [905, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_le", "code": "@[simp]\ntheorem closure_le {s : Set R} {t : Subring R} : closure s \u2264 t \u2194 s \u2286 t", "start": [908, 1], "end": [911, 56], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_mono", "code": "theorem closure_mono \u2983s t : Set R\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [914, 1], "end": [917, 52], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_eq_of_le", "code": "theorem closure_eq_of_le {s : Set R} {t : Subring R} (h\u2081 : s \u2286 t) (h\u2082 : t \u2264 closure s) :\n    closure s = t", "start": [920, 1], "end": [922, 35], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_induction", "code": "@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : R \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x)\n    (H0 : p 0) (H1 : p 1) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (Hneg : \u2200 x : R, p x \u2192 p (-x))\n    (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [925, 1], "end": [932, 68], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_induction'", "code": "@[elab_as_elim]\ntheorem closure_induction' {s : Set R} {p : \u2200 x, x \u2208 closure s \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 s), p x (subset_closure h)) (H0 : p 0 (zero_mem _)) (H1 : p 1 (one_mem _))\n    (Hadd : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x + y) (add_mem hx hy))\n    (Hneg : \u2200 x hx, p x hx \u2192 p (-x) (neg_mem hx))\n    (Hmul : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x * y) (mul_mem hx hy))\n    {a : R} (ha : a \u2208 closure s) : p a ha", "start": [935, 1], "end": [949, 45], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_induction\u2082", "code": "@[elab_as_elim]\ntheorem closure_induction\u2082 {s : Set R} {p : R \u2192 R \u2192 Prop} {a b : R} (ha : a \u2208 closure s)\n    (hb : b \u2208 closure s) (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y) (H0_left : \u2200 x, p 0 x)\n    (H0_right : \u2200 x, p x 0) (H1_left : \u2200 x, p 1 x) (H1_right : \u2200 x, p x 1)\n    (Hneg_left : \u2200 x y, p x y \u2192 p (-x) y) (Hneg_right : \u2200 x y, p x y \u2192 p x (-y))\n    (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hmul_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 * x\u2082) y)\n    (Hmul_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 * y\u2082)) : p a b", "start": [951, 1], "end": [966, 68], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_closure_iff", "code": "theorem mem_closure_iff {s : Set R} {x} :\n    x \u2208 closure s \u2194 x \u2208 AddSubgroup.closure (Submonoid.closure s : Set R)", "start": [969, 1], "end": [996, 76], "kind": "commanddeclaration"}, {"full_name": "Subring.closureCommRingOfComm", "code": "def closureCommRingOfComm {s : Set R} (hcomm : \u2200 a \u2208 s, \u2200 b \u2208 s, a * b = b * a) :\n    CommRing (closure s) :=\n  { (closure s).toRing with\n    mul_comm := fun x y => by\n      ext\n      simp only [Subring.coe_mul]\n      refine'\n        closure_induction\u2082 x.prop y.prop hcomm (fun x => by simp only [mul_zero, zero_mul])\n          (fun x => by simp only [mul_zero, zero_mul]) (fun x => by simp only [mul_one, one_mul])\n          (fun x => by simp only [mul_one, one_mul])\n          (fun x y hxy => by simp only [mul_neg, neg_mul, hxy])\n          (fun x y hxy => by simp only [mul_neg, neg_mul, hxy])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by simp only [add_mul, mul_add, h\u2081, h\u2082])\n          (fun x\u2081 x\u2082 y h\u2081 h\u2082 => by rw [\u2190 mul_assoc, \u2190 h\u2081, mul_assoc x\u2081 y x\u2082, \u2190 h\u2082, mul_assoc])\n          fun x\u2081 x\u2082 y h\u2081 h\u2082 => by rw [\u2190 mul_assoc, h\u2081, mul_assoc, h\u2082, \u2190 mul_assoc] }", "start": [999, 1], "end": [1015, 85], "kind": "commanddeclaration"}, {"full_name": "Subring.exists_list_of_mem_closure", "code": "theorem exists_list_of_mem_closure {s : Set R} {x : R} (h : x \u2208 closure s) :\n    \u2203 L : List (List R), (\u2200 t \u2208 L, \u2200 y \u2208 t, y \u2208 s \u2228 y = (-1 : R)) \u2227 (L.map List.prod).sum = x", "start": [1018, 1], "end": [1034, 82], "kind": "commanddeclaration"}, {"full_name": "Subring.gi", "code": "protected def gi : GaloisInsertion (@closure R _) (\u2191) where\n  choice s _ := closure s\n  gc _s _t := closure_le\n  le_l_u _s := subset_closure\n  choice_eq _s _h := rfl", "start": [1039, 1], "end": [1044, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_eq", "code": "theorem closure_eq (s : Subring R) : closure (s : Set R) = s", "start": [1049, 1], "end": [1051, 26], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_empty", "code": "@[simp]\ntheorem closure_empty : closure (\u2205 : Set R) = \u22a5", "start": [1054, 1], "end": [1056, 26], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_univ", "code": "@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = \u22a4", "start": [1059, 1], "end": [1061, 30], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_union", "code": "theorem closure_union (s t : Set R) : closure (s \u222a t) = closure s \u2294 closure t", "start": [1064, 1], "end": [1065, 26], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_iUnion", "code": "theorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set R) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [1068, 1], "end": [1069, 27], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_sUnion", "code": "theorem closure_sUnion (s : Set (Set R)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t", "start": [1072, 1], "end": [1073, 27], "kind": "commanddeclaration"}, {"full_name": "Subring.map_sup", "code": "theorem map_sup (s t : Subring R) (f : R \u2192+* S) : (s \u2294 t).map f = s.map f \u2294 t.map f", "start": [1076, 1], "end": [1077, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.map_iSup", "code": "theorem map_iSup {\u03b9 : Sort*} (f : R \u2192+* S) (s : \u03b9 \u2192 Subring R) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [1080, 1], "end": [1082, 26], "kind": "commanddeclaration"}, {"full_name": "Subring.comap_inf", "code": "theorem comap_inf (s t : Subring S) (f : R \u2192+* S) : (s \u2293 t).comap f = s.comap f \u2293 t.comap f", "start": [1085, 1], "end": [1086, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.comap_iInf", "code": "theorem comap_iInf {\u03b9 : Sort*} (f : R \u2192+* S) (s : \u03b9 \u2192 Subring S) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [1089, 1], "end": [1091, 26], "kind": "commanddeclaration"}, {"full_name": "Subring.map_bot", "code": "@[simp]\ntheorem map_bot (f : R \u2192+* S) : (\u22a5 : Subring R).map f = \u22a5", "start": [1094, 1], "end": [1096, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.comap_top", "code": "@[simp]\ntheorem comap_top (f : R \u2192+* S) : (\u22a4 : Subring S).comap f = \u22a4", "start": [1099, 1], "end": [1101, 25], "kind": "commanddeclaration"}, {"full_name": "Subring.prod", "code": "def prod (s : Subring R) (t : Subring S) : Subring (R \u00d7 S) :=\n  { s.toSubmonoid.prod t.toSubmonoid, s.toAddSubgroup.prod t.toAddSubgroup with carrier := s \u00d7\u02e2 t }", "start": [1104, 1], "end": [1107, 100], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod (s : Subring R) (t : Subring S) :\n    (s.prod t : Set (R \u00d7 S)) = (s : Set R) \u00d7\u02e2 (t : Set S)", "start": [1110, 1], "end": [1113, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_prod", "code": "theorem mem_prod {s : Subring R} {t : Subring S} {p : R \u00d7 S} : p \u2208 s.prod t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t", "start": [1116, 1], "end": [1117, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_mono", "code": "@[mono]\ntheorem prod_mono \u2983s\u2081 s\u2082 : Subring R\u2984 (hs : s\u2081 \u2264 s\u2082) \u2983t\u2081 t\u2082 : Subring S\u2984 (ht : t\u2081 \u2264 t\u2082) :\n    s\u2081.prod t\u2081 \u2264 s\u2082.prod t\u2082", "start": [1120, 1], "end": [1123, 22], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_mono_right", "code": "theorem prod_mono_right (s : Subring R) : Monotone fun t : Subring S => s.prod t", "start": [1126, 1], "end": [1127, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_mono_left", "code": "theorem prod_mono_left (t : Subring S) : Monotone fun s : Subring R => s.prod t", "start": [1130, 1], "end": [1131, 27], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_top", "code": "theorem prod_top (s : Subring R) : s.prod (\u22a4 : Subring S) = s.comap (RingHom.fst R S)", "start": [1134, 1], "end": [1135, 53], "kind": "commanddeclaration"}, {"full_name": "Subring.top_prod", "code": "theorem top_prod (s : Subring S) : (\u22a4 : Subring R).prod s = s.comap (RingHom.snd R S)", "start": [1138, 1], "end": [1139, 53], "kind": "commanddeclaration"}, {"full_name": "Subring.top_prod_top", "code": "@[simp]\ntheorem top_prod_top : (\u22a4 : Subring R).prod (\u22a4 : Subring S) = \u22a4", "start": [1142, 1], "end": [1144, 36], "kind": "commanddeclaration"}, {"full_name": "Subring.prodEquiv", "code": "def prodEquiv (s : Subring R) (t : Subring S) : s.prod t \u2243+* s \u00d7 t :=\n  { Equiv.Set.prod (s : Set R) (t : Set S) with\n    map_mul' := fun _x _y => rfl\n    map_add' := fun _x _y => rfl }", "start": [1147, 1], "end": [1151, 35], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_iSup_of_directed", "code": "theorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subring R} (hS : Directed (\u00b7 \u2264 \u00b7) S)\n    {x : R} : (x \u2208 \u2a06 i, S i) \u2194 \u2203 i, x \u2208 S i", "start": [1154, 1], "end": [1165, 55], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subring R} (hS : Directed (\u00b7 \u2264 \u00b7) S) :\n    ((\u2a06 i, S i : Subring R) : Set R) = \u22c3 i, \u2191(S i)", "start": [1168, 1], "end": [1170, 53], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_sSup_of_directedOn", "code": "theorem mem_sSup_of_directedOn {S : Set (Subring R)} (Sne : S.Nonempty) (hS : DirectedOn (\u00b7 \u2264 \u00b7) S)\n    {x : R} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "start": [1173, 1], "end": [1177, 17], "kind": "commanddeclaration"}, {"full_name": "Subring.coe_sSup_of_directedOn", "code": "theorem coe_sSup_of_directedOn {S : Set (Subring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) : (\u2191(sSup S) : Set R) = \u22c3 s \u2208 S, \u2191s", "start": [1180, 1], "end": [1182, 59], "kind": "commanddeclaration"}, {"full_name": "Subring.mem_map_equiv", "code": "theorem mem_map_equiv {f : R \u2243+* S} {K : Subring R} {x : S} :\n    x \u2208 K.map (f : R \u2192+* S) \u2194 f.symm x \u2208 K", "start": [1185, 1], "end": [1187, 51], "kind": "commanddeclaration"}, {"full_name": "Subring.map_equiv_eq_comap_symm", "code": "theorem map_equiv_eq_comap_symm (f : R \u2243+* S) (K : Subring R) :\n    K.map (f : R \u2192+* S) = K.comap f.symm", "start": [1190, 1], "end": [1192, 56], "kind": "commanddeclaration"}, {"full_name": "Subring.comap_equiv_eq_map_symm", "code": "theorem comap_equiv_eq_map_symm (f : R \u2243+* S) (K : Subring S) :\n    K.comap (f : R \u2192+* S) = K.map f.symm", "start": [1195, 1], "end": [1197, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeRestrict", "code": "def rangeRestrict (f : R \u2192+* S) : R \u2192+* f.range :=\n  f.codRestrict f.range fun x => \u27e8x, rfl\u27e9", "start": [1208, 1], "end": [1212, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_rangeRestrict", "code": "@[simp]\ntheorem coe_rangeRestrict (f : R \u2192+* S) (x : R) : (f.rangeRestrict x : S) = f x", "start": [1215, 1], "end": [1217, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeRestrict_surjective", "code": "theorem rangeRestrict_surjective (f : R \u2192+* S) : Function.Surjective f.rangeRestrict", "start": [1220, 1], "end": [1223, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.range_top_iff_surjective", "code": "theorem range_top_iff_surjective {f : R \u2192+* S} :\n    f.range = (\u22a4 : Subring S) \u2194 Function.Surjective f", "start": [1226, 1], "end": [1228, 92], "kind": "commanddeclaration"}, {"full_name": "RingHom.range_top_of_surjective", "code": "@[simp]\ntheorem range_top_of_surjective (f : R \u2192+* S) (hf : Function.Surjective f) :\n    f.range = (\u22a4 : Subring S)", "start": [1231, 1], "end": [1235, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqLocus", "code": "def eqLocus (f g : R \u2192+* S) : Subring R :=\n  { (f : R \u2192* S).eqLocusM g, (f : R \u2192+ S).eqLocus g with carrier := { x | f x = g x } }", "start": [1238, 1], "end": [1241, 88], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqLocus_same", "code": "@[simp]\ntheorem eqLocus_same (f : R \u2192+* S) : f.eqLocus f = \u22a4", "start": [1244, 1], "end": [1246, 42], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqOn_set_closure", "code": "theorem eqOn_set_closure {f g : R \u2192+* S} {s : Set R} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s)", "start": [1249, 1], "end": [1252, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_set_top", "code": "theorem eq_of_eqOn_set_top {f g : R \u2192+* S} (h : Set.EqOn f g (\u22a4 : Subring R)) : f = g", "start": [1255, 1], "end": [1256, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_set_dense", "code": "theorem eq_of_eqOn_set_dense {s : Set R} (hs : closure s = \u22a4) {f g : R \u2192+* S} (h : s.EqOn f g) :\n    f = g", "start": [1259, 1], "end": [1261, 48], "kind": "commanddeclaration"}, {"full_name": "RingHom.closure_preimage_le", "code": "theorem closure_preimage_le (f : R \u2192+* S) (s : Set S) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [1264, 1], "end": [1265, 81], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_closure", "code": "theorem map_closure (f : R \u2192+* S) (s : Set R) : (closure s).map f = closure (f '' s)", "start": [1268, 1], "end": [1274, 56], "kind": "commanddeclaration"}, {"full_name": "Subring.inclusion", "code": "def inclusion {S T : Subring R} (h : S \u2264 T) : S \u2192+* T :=\n  S.subtype.codRestrict _ fun x => h x.2", "start": [1283, 1], "end": [1285, 41], "kind": "commanddeclaration"}, {"full_name": "Subring.range_subtype", "code": "@[simp]\ntheorem range_subtype (s : Subring R) : s.subtype.range = s", "start": [1288, 1], "end": [1290, 66], "kind": "commanddeclaration"}, {"full_name": "Subring.range_fst", "code": "theorem range_fst : (fst R S).rangeS = \u22a4", "start": [1294, 1], "end": [1295, 60], "kind": "commanddeclaration"}, {"full_name": "Subring.range_snd", "code": "theorem range_snd : (snd R S).rangeS = \u22a4", "start": [1299, 1], "end": [1300, 60], "kind": "commanddeclaration"}, {"full_name": "Subring.prod_bot_sup_bot_prod", "code": "@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) : s.prod \u22a5 \u2294 prod \u22a5 t = s.prod t", "start": [1303, 1], "end": [1309, 97], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.subringCongr", "code": "def subringCongr (h : s = t) : s \u2243+* t :=\n  { Equiv.setCongr <| congr_arg _ h with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [1318, 1], "end": [1323, 33], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse", "code": "def ofLeftInverse {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f) : R \u2243+* f.range :=\n  { f.rangeRestrict with\n    toFun := fun x => f.rangeRestrict x\n    invFun := fun x => (g \u2218 f.range.subtype) x\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := RingHom.mem_range.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [1326, 1], "end": [1336, 47], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse_apply", "code": "@[simp]\ntheorem ofLeftInverse_apply {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f) (x : R) :\n    \u2191(ofLeftInverse h x) = f x", "start": [1339, 1], "end": [1342, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.ofLeftInverse_symm_apply", "code": "@[simp]\ntheorem ofLeftInverse_symm_apply {g : S \u2192 R} {f : R \u2192+* S} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x", "start": [1345, 1], "end": [1348, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.subringMap", "code": "@[simps!]\ndef subringMap (e : R \u2243+* S) : s \u2243+* s.map e.toRingHom :=\n  e.subsemiringMap s.toSubsemiring", "start": [1351, 1], "end": [1355, 35], "kind": "commanddeclaration"}, {"full_name": "Subring.InClosure.recOn", "code": "@[elab_as_elim]\nprotected theorem InClosure.recOn {C : R \u2192 Prop} {x : R} (hx : x \u2208 closure s) (h1 : C 1)\n    (hneg1 : C (-1)) (hs : \u2200 z \u2208 s, \u2200 n, C n \u2192 C (z * n)) (ha : \u2200 {x y}, C x \u2192 C y \u2192 C (x + y)) :\n    C x", "start": [1372, 1], "end": [1416, 84], "kind": "commanddeclaration"}, {"full_name": "Subring.closure_preimage_le", "code": "theorem closure_preimage_le (f : R \u2192+* S) (s : Set S) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [1419, 1], "end": [1420, 81], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.int_mul_mem", "code": "theorem AddSubgroup.int_mul_mem {G : AddSubgroup R} (k : \u2124) {g : R} (h : g \u2208 G) :\n    (k : R) * g \u2208 G", "start": [1425, 1], "end": [1428, 7], "kind": "commanddeclaration"}, {"full_name": "Subring.smul_def", "code": "theorem smul_def [SMul R \u03b1] {S : Subring R} (g : S) (m : \u03b1) : g \u2022 m = (g : R) \u2022 m", "start": [1453, 1], "end": [1454, 6], "kind": "commanddeclaration"}, {"full_name": "Subring.smulCommClass_left", "code": "instance smulCommClass_left [SMul R \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass R \u03b1 \u03b2] (S : Subring R) :\n    SMulCommClass S \u03b1 \u03b2 :=\n  inferInstanceAs (SMulCommClass S.toSubsemiring \u03b1 \u03b2)", "start": [1458, 1], "end": [1460, 54], "kind": "commanddeclaration"}, {"full_name": "Subring.smulCommClass_right", "code": "instance smulCommClass_right [SMul \u03b1 \u03b2] [SMul R \u03b2] [SMulCommClass \u03b1 R \u03b2] (S : Subring R) :\n    SMulCommClass \u03b1 S \u03b2 :=\n  inferInstanceAs (SMulCommClass \u03b1 S.toSubsemiring \u03b2)", "start": [1464, 1], "end": [1466, 54], "kind": "commanddeclaration"}, {"full_name": "Subring.center.smulCommClass_left", "code": "instance center.smulCommClass_left : SMulCommClass (center R) R R :=\n  Subsemiring.center.smulCommClass_left", "start": [1514, 1], "end": [1516, 40], "kind": "commanddeclaration"}, {"full_name": "Subring.center.smulCommClass_right", "code": "instance center.smulCommClass_right : SMulCommClass R (center R) R :=\n  Subsemiring.center.smulCommClass_right", "start": [1519, 1], "end": [1521, 41], "kind": "commanddeclaration"}, {"full_name": "Units.posSubgroup", "code": "def Units.posSubgroup (R : Type*) [LinearOrderedSemiring R] : Subgroup R\u02e3 :=\n  { (posSubmonoid R).comap (Units.coeHom R) with\n    carrier := { x | (0 : R) < x }\n    inv_mem' := Units.inv_pos.mpr }", "start": [1530, 1], "end": [1534, 36], "kind": "commanddeclaration"}, {"full_name": "Units.mem_posSubgroup", "code": "@[simp]\ntheorem Units.mem_posSubgroup {R : Type*} [LinearOrderedSemiring R] (u : R\u02e3) :\n    u \u2208 Units.posSubgroup R \u2194 (0 : R) < u", "start": [1537, 1], "end": [1540, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/CharZero/Lemmas.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Data/Nat/Cast/Field.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.castEmbedding", "code": "@[simps]\ndef castEmbedding : \u2115 \u21aa R :=\n  \u27e8Nat.cast, cast_injective\u27e9", "start": [29, 1], "end": [32, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_pow_eq_one", "code": "@[simp]\ntheorem cast_pow_eq_one {R : Type*} [Semiring R] [CharZero R] (q : \u2115) (n : \u2115) (hn : n \u2260 0) :\n    (q : R) ^ n = 1 \u2194 q = 1", "start": [36, 1], "end": [40, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_div_charZero", "code": "@[simp, norm_cast]\ntheorem cast_div_charZero {k : Type*} [DivisionSemiring k] [CharZero k] {m n : \u2115} (n_dvd : n \u2223 m) :\n    ((m / n : \u2115) : k) = m / n", "start": [43, 1], "end": [48, 45], "kind": "commanddeclaration"}, {"full_name": "CharZero.NeZero.two", "code": "instance CharZero.NeZero.two : NeZero (2 : M) :=\n  \u27e8by\n    have : ((2 : \u2115) : M) \u2260 0 := Nat.cast_ne_zero.2 (by decide)\n    rwa [Nat.cast_two] at this\u27e9", "start": [57, 1], "end": [60, 32], "kind": "commanddeclaration"}, {"full_name": "add_self_eq_zero", "code": "@[simp]\ntheorem add_self_eq_zero {a : R} : a + a = 0 \u2194 a = 0", "start": [69, 1], "end": [71, 71], "kind": "commanddeclaration"}, {"full_name": "bit0_eq_zero", "code": "@[simp]\ntheorem bit0_eq_zero {a : R} : bit0 a = 0 \u2194 a = 0", "start": [76, 1], "end": [78, 19], "kind": "commanddeclaration"}, {"full_name": "zero_eq_bit0", "code": "@[simp]\ntheorem zero_eq_bit0 {a : R} : 0 = bit0 a \u2194 a = 0", "start": [81, 1], "end": [84, 21], "kind": "commanddeclaration"}, {"full_name": "bit0_ne_zero", "code": "theorem bit0_ne_zero : bit0 a \u2260 0 \u2194 a \u2260 0", "start": [87, 1], "end": [88, 19], "kind": "commanddeclaration"}, {"full_name": "zero_ne_bit0", "code": "theorem zero_ne_bit0 : 0 \u2260 bit0 a \u2194 a \u2260 0", "start": [91, 1], "end": [92, 19], "kind": "commanddeclaration"}, {"full_name": "neg_eq_self_iff", "code": "theorem neg_eq_self_iff {a : R} : -a = a \u2194 a = 0", "start": [101, 1], "end": [102, 48], "kind": "commanddeclaration"}, {"full_name": "eq_neg_self_iff", "code": "theorem eq_neg_self_iff {a : R} : a = -a \u2194 a = 0", "start": [105, 1], "end": [106, 48], "kind": "commanddeclaration"}, {"full_name": "nat_mul_inj", "code": "theorem nat_mul_inj {n : \u2115} {a b : R} (h : (n : R) * a = (n : R) * b) : n = 0 \u2228 a = b", "start": [109, 1], "end": [111, 19], "kind": "commanddeclaration"}, {"full_name": "nat_mul_inj'", "code": "theorem nat_mul_inj' {n : \u2115} {a b : R} (h : (n : R) * a = (n : R) * b) (w : n \u2260 0) : a = b", "start": [114, 1], "end": [115, 32], "kind": "commanddeclaration"}, {"full_name": "bit0_injective", "code": "theorem bit0_injective : Function.Injective (bit0 : R \u2192 R)", "start": [120, 1], "end": [124, 19], "kind": "commanddeclaration"}, {"full_name": "bit1_injective", "code": "theorem bit1_injective : Function.Injective (bit1 : R \u2192 R)", "start": [127, 1], "end": [129, 25], "kind": "commanddeclaration"}, {"full_name": "bit0_eq_bit0", "code": "@[simp]\ntheorem bit0_eq_bit0 {a b : R} : bit0 a = bit0 b \u2194 a = b", "start": [132, 1], "end": [134, 24], "kind": "commanddeclaration"}, {"full_name": "bit1_eq_bit1", "code": "@[simp]\ntheorem bit1_eq_bit1 {a b : R} : bit1 a = bit1 b \u2194 a = b", "start": [137, 1], "end": [139, 24], "kind": "commanddeclaration"}, {"full_name": "bit1_eq_one", "code": "@[simp]\ntheorem bit1_eq_one {a : R} : bit1 a = 1 \u2194 a = 0", "start": [142, 1], "end": [144, 51], "kind": "commanddeclaration"}, {"full_name": "one_eq_bit1", "code": "@[simp]\ntheorem one_eq_bit1 {a : R} : 1 = bit1 a \u2194 a = 0", "start": [147, 1], "end": [150, 20], "kind": "commanddeclaration"}, {"full_name": "half_add_self", "code": "@[simp]\ntheorem half_add_self (a : R) : (a + a) / 2 = a", "start": [159, 1], "end": [160, 99], "kind": "commanddeclaration"}, {"full_name": "add_halves'", "code": "@[simp]\ntheorem add_halves' (a : R) : a / 2 + a / 2 = a", "start": [163, 1], "end": [164, 84], "kind": "commanddeclaration"}, {"full_name": "sub_half", "code": "theorem sub_half (a : R) : a - a / 2 = a / 2", "start": [167, 1], "end": [167, 87], "kind": "commanddeclaration"}, {"full_name": "half_sub", "code": "theorem half_sub (a : R) : a / 2 - a = -(a / 2)", "start": [170, 1], "end": [170, 79], "kind": "commanddeclaration"}, {"full_name": "RingHom.charZero", "code": "theorem RingHom.charZero (\u03d5 : R \u2192+* S) [hS : CharZero S] : CharZero R", "start": [197, 1], "end": [198, 87], "kind": "commanddeclaration"}, {"full_name": "RingHom.charZero_iff", "code": "theorem RingHom.charZero_iff {\u03d5 : R \u2192+* S} (h\u03d5 : Function.Injective \u03d5) : CharZero R \u2194 CharZero S", "start": [201, 1], "end": [204, 26], "kind": "commanddeclaration"}, {"full_name": "RingHom.injective_nat", "code": "theorem RingHom.injective_nat (f : \u2115 \u2192+* R) [CharZero R] : Function.Injective f", "start": [207, 1], "end": [208, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/ULift.lean", "imports": ["Mathlib/Algebra/Ring/ULift.lean", "Mathlib/Algebra/Module/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ULift.smulLeft", "code": "@[to_additive]\ninstance smulLeft [SMul R M] : SMul (ULift R) M :=\n  \u27e8fun s x => s.down \u2022 x\u27e9", "start": [28, 1], "end": [30, 26], "kind": "commanddeclaration"}, {"full_name": "ULift.smul_def", "code": "@[to_additive (attr := simp)]\ntheorem smul_def [SMul R M] (s : ULift R) (x : M) : s \u2022 x = s.down \u2022 x", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.isScalarTower", "code": "instance isScalarTower [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower (ULift R) M N :=\n  \u27e8fun x y z => show (x.down \u2022 y) \u2022 z = x.down \u2022 y \u2022 z from smul_assoc _ _ _\u27e9", "start": [40, 1], "end": [42, 78], "kind": "commanddeclaration"}, {"full_name": "ULift.isScalarTower'", "code": "instance isScalarTower' [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower R (ULift M) N :=\n  \u27e8fun x y z => show (x \u2022 y.down) \u2022 z = x \u2022 y.down \u2022 z from smul_assoc _ _ _\u27e9", "start": [45, 1], "end": [47, 78], "kind": "commanddeclaration"}, {"full_name": "ULift.isScalarTower''", "code": "instance isScalarTower'' [SMul R M] [SMul M N] [SMul R N] [IsScalarTower R M N] :\n    IsScalarTower R M (ULift N) :=\n  \u27e8fun x y z => show up ((x \u2022 y) \u2022 z.down) = \u27e8x \u2022 y \u2022 z.down\u27e9 by rw [smul_assoc]\u27e9", "start": [50, 1], "end": [52, 82], "kind": "commanddeclaration"}, {"full_name": "ULift.mulAction", "code": "@[to_additive]\ninstance mulAction [Monoid R] [MulAction R M] : MulAction (ULift R) M where\n  smul := (\u00b7 \u2022 \u00b7)\n  mul_smul _ _ := mul_smul _ _\n  one_smul := one_smul _", "start": [59, 1], "end": [63, 25], "kind": "commanddeclaration"}, {"full_name": "ULift.mulAction'", "code": "@[to_additive]\ninstance mulAction' [Monoid R] [MulAction R M] : MulAction R (ULift M) where\n  smul := (\u00b7 \u2022 \u00b7)\n  mul_smul := fun _ _ _ => congr_arg ULift.up <| mul_smul _ _ _\n  one_smul := fun _ => congr_arg ULift.up <| one_smul _ _", "start": [67, 1], "end": [71, 58], "kind": "commanddeclaration"}, {"full_name": "ULift.smulZeroClass", "code": "instance smulZeroClass [Zero M] [SMulZeroClass R M] : SMulZeroClass (ULift R) M :=\n  { ULift.smulLeft with smul_zero := fun _ => smul_zero _ }", "start": [75, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "ULift.smulZeroClass'", "code": "instance smulZeroClass' [Zero M] [SMulZeroClass R M] : SMulZeroClass R (ULift M) where\n  smul_zero c := by { ext; simp [smul_zero] }", "start": [79, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "ULift.distribSmul", "code": "instance distribSmul [AddZeroClass M] [DistribSMul R M] : DistribSMul (ULift R) M where\n  smul_add _ := smul_add _", "start": [83, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "ULift.distribSmul'", "code": "instance distribSmul' [AddZeroClass M] [DistribSMul R M] : DistribSMul R (ULift M) where\n  smul_add c f g := by\n    ext\n    simp [smul_add]", "start": [87, 1], "end": [90, 20], "kind": "commanddeclaration"}, {"full_name": "ULift.distribMulAction", "code": "instance distribMulAction [Monoid R] [AddMonoid M] [DistribMulAction R M] :\n    DistribMulAction (ULift R) M :=\n  { ULift.mulAction, ULift.distribSmul with }", "start": [93, 1], "end": [95, 46], "kind": "commanddeclaration"}, {"full_name": "ULift.distribMulAction'", "code": "instance distribMulAction' [Monoid R] [AddMonoid M] [DistribMulAction R M] :\n    DistribMulAction R (ULift M) :=\n  { ULift.mulAction', ULift.distribSmul' with }", "start": [98, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "ULift.mulDistribMulAction", "code": "instance mulDistribMulAction [Monoid R] [Monoid M] [MulDistribMulAction R M] :\n    MulDistribMulAction (ULift R) M where\n  smul_one _ := smul_one _\n  smul_mul _ := smul_mul' _", "start": [103, 1], "end": [106, 28], "kind": "commanddeclaration"}, {"full_name": "ULift.mulDistribMulAction'", "code": "instance mulDistribMulAction' [Monoid R] [Monoid M] [MulDistribMulAction R M] :\n    MulDistribMulAction R (ULift M) :=\n  { ULift.mulAction' with\n    smul_one := fun _ => by\n      ext\n      simp [smul_one]\n    smul_mul := fun _ _ _ => by\n      ext\n      simp [smul_mul'] }", "start": [109, 1], "end": [117, 25], "kind": "commanddeclaration"}, {"full_name": "ULift.smulWithZero", "code": "instance smulWithZero [Zero R] [Zero M] [SMulWithZero R M] : SMulWithZero (ULift R) M :=\n  { ULift.smulLeft with\n    smul_zero := fun _ => smul_zero _\n    zero_smul := zero_smul _ }", "start": [120, 1], "end": [123, 31], "kind": "commanddeclaration"}, {"full_name": "ULift.smulWithZero'", "code": "instance smulWithZero' [Zero R] [Zero M] [SMulWithZero R M] : SMulWithZero R (ULift M)\n    where\n  smul_zero _ := ULift.ext _ _ <| smul_zero _\n  zero_smul _ := ULift.ext _ _ <| zero_smul _ _", "start": [126, 1], "end": [129, 48], "kind": "commanddeclaration"}, {"full_name": "ULift.mulActionWithZero", "code": "instance mulActionWithZero [MonoidWithZero R] [Zero M] [MulActionWithZero R M] :\n    MulActionWithZero (ULift R) M :=\n  { ULift.smulWithZero with\n    one_smul := one_smul _\n    mul_smul := mul_smul }", "start": [132, 1], "end": [137, 27], "kind": "commanddeclaration"}, {"full_name": "ULift.mulActionWithZero'", "code": "instance mulActionWithZero' [MonoidWithZero R] [Zero M] [MulActionWithZero R M] :\n    MulActionWithZero R (ULift M) :=\n  { ULift.smulWithZero' with\n    one_smul := one_smul _\n    mul_smul := mul_smul }", "start": [140, 1], "end": [144, 27], "kind": "commanddeclaration"}, {"full_name": "ULift.module", "code": "instance module [Semiring R] [AddCommMonoid M] [Module R M] : Module (ULift R) M :=\n  { ULift.smulWithZero with\n    add_smul := fun _ _ => add_smul _ _\n    smul_add := smul_add\n    one_smul := one_smul _\n    mul_smul := mul_smul }", "start": [147, 1], "end": [152, 27], "kind": "commanddeclaration"}, {"full_name": "ULift.module'", "code": "instance module' [Semiring R] [AddCommMonoid M] [Module R M] : Module R (ULift M) :=\n  { ULift.smulWithZero' with\n    add_smul := fun _ _ _ => ULift.ext _ _ <| add_smul _ _ _\n    one_smul := one_smul _\n    mul_smul := mul_smul\n    smul_add := smul_add }", "start": [155, 1], "end": [160, 27], "kind": "commanddeclaration"}, {"full_name": "ULift.moduleEquiv", "code": "@[simps apply symm_apply]\ndef moduleEquiv [Semiring R] [AddCommMonoid M] [Module R M] : ULift.{w} M \u2243\u2097[R] M where\n  toFun := ULift.down\n  invFun := ULift.up\n  map_smul' _ _ := rfl\n  __ := AddEquiv.ulift", "start": [163, 1], "end": [171, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Basic.lean", "imports": ["Mathlib/Algebra/Module/Submodule/Lattice.lean", "Mathlib/Data/Finsupp/Basic.lean", "Mathlib/Data/DFinsupp/Basic.lean", "Mathlib/Algebra/Module/Prod.lean", "Mathlib/Algebra/Module/LinearMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/Algebra/Module/Hom.lean"], "premises": [{"full_name": "Finsupp.smul_sum", "code": "theorem smul_sum {\u03b1 : Type*} {\u03b2 : Type*} {R : Type*} {M : Type*} [Zero \u03b2] [AddCommMonoid M]\n    [DistribSMul R M] {v : \u03b1 \u2192\u2080 \u03b2} {c : R} {h : \u03b1 \u2192 \u03b2 \u2192 M} :\n    c \u2022 v.sum h = v.sum fun a b => c \u2022 h a b", "start": [75, 1], "end": [78, 18], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_smul_index_linearMap'", "code": "@[simp]\ntheorem sum_smul_index_linearMap' {\u03b1 : Type*} {R : Type*} {M : Type*} {M\u2082 : Type*} [Semiring R]\n    [AddCommMonoid M] [Module R M] [AddCommMonoid M\u2082] [Module R M\u2082] {v : \u03b1 \u2192\u2080 M} {c : R}\n    {h : \u03b1 \u2192 M \u2192\u2097[R] M\u2082} : ((c \u2022 v).sum fun a => h a) = c \u2022 v.sum fun a => h a", "start": [81, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.linearEquivFunOnFinite", "code": "@[simps apply]\nnoncomputable def linearEquivFunOnFinite : (\u03b1 \u2192\u2080 M) \u2243\u2097[R] \u03b1 \u2192 M :=\n  { equivFunOnFinite with\n    toFun := (\u21d1)\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [95, 1], "end": [102, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.linearEquivFunOnFinite_single", "code": "@[simp]\ntheorem linearEquivFunOnFinite_single [DecidableEq \u03b1] (x : \u03b1) (m : M) :\n    (linearEquivFunOnFinite R M \u03b1) (single x m) = Pi.single x m", "start": [105, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.linearEquivFunOnFinite_symm_single", "code": "@[simp]\ntheorem linearEquivFunOnFinite_symm_single [DecidableEq \u03b1] (x : \u03b1) (m : M) :\n    (linearEquivFunOnFinite R M \u03b1).symm (Pi.single x m) = single x m", "start": [111, 1], "end": [114, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.linearEquivFunOnFinite_symm_coe", "code": "@[simp]\ntheorem linearEquivFunOnFinite_symm_coe (f : \u03b1 \u2192\u2080 M) : (linearEquivFunOnFinite R M \u03b1).symm f = f", "start": [117, 1], "end": [119, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.LinearEquiv.finsuppUnique", "code": "noncomputable def LinearEquiv.finsuppUnique (\u03b1 : Type*) [Unique \u03b1] : (\u03b1 \u2192\u2080 M) \u2243\u2097[R] M :=\n  { Finsupp.equivFunOnFinite.trans (Equiv.funUnique \u03b1 M) with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [122, 1], "end": [127, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.LinearEquiv.finsuppUnique_apply", "code": "@[simp]\ntheorem LinearEquiv.finsuppUnique_apply (\u03b1 : Type*) [Unique \u03b1] (f : \u03b1 \u2192\u2080 M) :\n    LinearEquiv.finsuppUnique R M \u03b1 f = f default", "start": [132, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.LinearEquiv.finsuppUnique_symm_apply", "code": "@[simp]\ntheorem LinearEquiv.finsuppUnique_symm_apply {\u03b1 : Type*} [Unique \u03b1] (m : M) :\n    (LinearEquiv.finsuppUnique R M \u03b1).symm m = Finsupp.single default m", "start": [138, 1], "end": [142, 39], "kind": "commanddeclaration"}, {"full_name": "pi_eq_sum_univ", "code": "theorem pi_eq_sum_univ {\u03b9 : Type*} [Fintype \u03b9] [DecidableEq \u03b9] {R : Type*} [Semiring R]\n    (x : \u03b9 \u2192 R) : x = \u2211 i, (x i) \u2022 fun j => if i = j then (1 : R) else 0", "start": [147, 1], "end": [151, 7], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict", "code": "def domRestrict (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : Submodule R M) : p \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082 :=\n  f.comp p.subtype", "start": [174, 1], "end": [177, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict_apply", "code": "@[simp]\ntheorem domRestrict_apply (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : Submodule R M) (x : p) :\n    f.domRestrict p x = f x", "start": [180, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.codRestrict", "code": "def codRestrict (p : Submodule R\u2082 M\u2082) (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (h : \u2200 c, f c \u2208 p) : M \u2192\u209b\u2097[\u03c3\u2081\u2082] p := by\n  refine' { toFun := fun c => \u27e8f c, h c\u27e9.. } <;> intros <;> apply SetCoe.ext <;> simp", "start": [186, 1], "end": [189, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.codRestrict_apply", "code": "@[simp]\ntheorem codRestrict_apply (p : Submodule R\u2082 M\u2082) (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {h} (x : M) :\n    (codRestrict p f h x : M\u2082) = f x", "start": [192, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_codRestrict", "code": "@[simp]\ntheorem comp_codRestrict (p : Submodule R\u2083 M\u2083) (h : \u2200 b, g b \u2208 p) :\n    ((codRestrict p g h).comp f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] p) = codRestrict p (g.comp f) fun _ => h _", "start": [198, 1], "end": [201, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.subtype_comp_codRestrict", "code": "@[simp]\ntheorem subtype_comp_codRestrict (p : Submodule R\u2082 M\u2082) (h : \u2200 b, f b \u2208 p) :\n    p.subtype.comp (codRestrict p f h) = f", "start": [204, 1], "end": [207, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrict", "code": "def restrict (f : M \u2192\u2097[R] M\u2081) {p : Submodule R M} {q : Submodule R M\u2081} (hf : \u2200 x \u2208 p, f x \u2208 q) :\n    p \u2192\u2097[R] q :=\n  (f.domRestrict p).codRestrict q <| SetLike.forall.2 hf", "start": [210, 1], "end": [213, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrict_coe_apply", "code": "@[simp]\ntheorem restrict_coe_apply (f : M \u2192\u2097[R] M\u2081) {p : Submodule R M} {q : Submodule R M\u2081}\n    (hf : \u2200 x \u2208 p, f x \u2208 q) (x : p) : \u2191(f.restrict hf x) = f x", "start": [216, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrict_apply", "code": "theorem restrict_apply {f : M \u2192\u2097[R] M\u2081} {p : Submodule R M} {q : Submodule R M\u2081}\n    (hf : \u2200 x \u2208 p, f x \u2208 q) (x : p) : f.restrict hf x = \u27e8f x, hf x.1 x.2\u27e9", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.subtype_comp_restrict", "code": "theorem subtype_comp_restrict {f : M \u2192\u2097[R] M\u2081} {p : Submodule R M} {q : Submodule R M\u2081}\n    (hf : \u2200 x \u2208 p, f x \u2208 q) : q.subtype.comp (f.restrict hf) = f.domRestrict p", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrict_eq_codRestrict_domRestrict", "code": "theorem restrict_eq_codRestrict_domRestrict {f : M \u2192\u2097[R] M\u2081} {p : Submodule R M}\n    {q : Submodule R M\u2081} (hf : \u2200 x \u2208 p, f x \u2208 q) :\n    f.restrict hf = (f.domRestrict p).codRestrict q fun x => hf x.1 x.2", "start": [232, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.restrict_eq_domRestrict_codRestrict", "code": "theorem restrict_eq_domRestrict_codRestrict {f : M \u2192\u2097[R] M\u2081} {p : Submodule R M}\n    {q : Submodule R M\u2081} (hf : \u2200 x, f x \u2208 q) :\n    (f.restrict fun x _ => hf x) = (f.codRestrict q hf).domRestrict p", "start": [238, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.uniqueOfLeft", "code": "instance uniqueOfLeft [Subsingleton M] : Unique (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :=\n  { inferInstanceAs (Inhabited (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) with\n    uniq := fun f => ext fun x => by rw [Subsingleton.elim x 0, map_zero, map_zero] }", "start": [244, 1], "end": [246, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.uniqueOfRight", "code": "instance uniqueOfRight [Subsingleton M\u2082] : Unique (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :=\n  coe_injective.unique", "start": [249, 1], "end": [250, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.evalAddMonoidHom", "code": "def evalAddMonoidHom (a : M) : (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) \u2192+ M\u2082 where\n  toFun f := f a\n  map_add' f g := LinearMap.add_apply f g a\n  map_zero' := rfl", "start": [253, 1], "end": [257, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAddMonoidHom'", "code": "def toAddMonoidHom' : (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) \u2192+ M \u2192+ M\u2082 where\n  toFun := toAddMonoidHom\n  map_zero' := by ext; rfl\n  map_add' := by intros; ext; rfl", "start": [260, 1], "end": [264, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sum_apply", "code": "theorem sum_apply (t : Finset \u03b9) (f : \u03b9 \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (b : M) :\n    (\u2211 d in t, f d) b = \u2211 d in t, f d b", "start": [267, 1], "end": [269, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smulRight", "code": "def smulRight (f : M\u2081 \u2192\u2097[R] S) (x : M) : M\u2081 \u2192\u2097[R] M where\n  toFun b := f b \u2022 x\n  map_add' x y := by dsimp only; rw [f.map_add, add_smul]\n  map_smul' b y := by dsimp; rw [map_smul, smul_assoc]", "start": [276, 1], "end": [281, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_smulRight", "code": "@[simp]\ntheorem coe_smulRight (f : M\u2081 \u2192\u2097[R] S) (x : M) : (smulRight f x : M\u2081 \u2192 M) = fun c => f c \u2022 x", "start": [284, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smulRight_apply", "code": "theorem smulRight_apply (f : M\u2081 \u2192\u2097[R] S) (x : M) (c : M\u2081) : smulRight f x c = f c \u2022 x", "start": [289, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coeFn_sum", "code": "@[simp, norm_cast]\ntheorem coeFn_sum {\u03b9 : Type*} (t : Finset \u03b9) (f : \u03b9 \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n    \u21d1(\u2211 i in t, f i) = \u2211 i in t, (f i : M \u2192 M\u2082)", "start": [299, 1], "end": [306, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.submodule_pow_eq_zero_of_pow_eq_zero", "code": "theorem submodule_pow_eq_zero_of_pow_eq_zero {N : Submodule R M} {g : Module.End R N}\n    {G : Module.End R M} (h : G.comp N.subtype = N.subtype.comp g) {k : \u2115} (hG : G ^ k = 0) :\n    g ^ k = 0", "start": [309, 1], "end": [315, 17], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_apply_mem_of_forall_mem", "code": "theorem pow_apply_mem_of_forall_mem {p : Submodule R M} (n : \u2115) (h : \u2200 x \u2208 p, f' x \u2208 p) (x : M)\n    (hx : x \u2208 p) : (f' ^ n) x \u2208 p", "start": [322, 1], "end": [326, 97], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_restrict", "code": "theorem pow_restrict {p : Submodule R M} (n : \u2115) (h : \u2200 x \u2208 p, f' x \u2208 p)\n    (h' := pow_apply_mem_of_forall_mem n h) :\n    (f'.restrict h) ^ n = (HPow.hPow f' n).restrict h'", "start": [329, 1], "end": [334, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_apply_eq_sum_univ", "code": "theorem pi_apply_eq_sum_univ [Fintype \u03b9] [DecidableEq \u03b9] (f : (\u03b9 \u2192 R) \u2192\u2097[R] M) (x : \u03b9 \u2192 R) :\n    f x = \u2211 i, x i \u2022 f fun j => if i = j then 1 else 0", "start": [339, 1], "end": [345, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply\u2097'", "code": "@[simps]\ndef apply\u2097' : M \u2192+ (M \u2192\u2097[R] M\u2082) \u2192\u2097[S] M\u2082 where\n  toFun v :=\n    { toFun := fun f => f v\n      map_add' := fun f g => f.add_apply g v\n      map_smul' := fun x f => f.smul_apply x v }\n  map_zero' := LinearMap.ext fun f => f.map_zero\n  map_add' _ _ := LinearMap.ext fun f => f.map_add _ _", "start": [358, 1], "end": [368, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ringLmapEquivSelf", "code": "@[simps]\ndef ringLmapEquivSelf [Module S M] [SMulCommClass R S M] : (R \u2192\u2097[R] M) \u2243\u2097[S] M :=\n  { apply\u2097' S (1 : R) with\n    toFun := fun f => f 1\n    invFun := smulRight (1 : R \u2192\u2097[R] R)\n    left_inv := fun f => by\n      ext\n      simp only [coe_smulRight, one_apply, smul_eq_mul, \u2190 map_smul f, mul_one]\n    right_inv := fun x => by simp }", "start": [375, 1], "end": [391, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compRight", "code": "def compRight (f : M\u2082 \u2192\u2097[R] M\u2083) : (M \u2192\u2097[R] M\u2082) \u2192\u2097[R] M \u2192\u2097[R] M\u2083 where\n  toFun := f.comp\n  map_add' _ _ := LinearMap.ext fun _ => map_add f _ _\n  map_smul' _ _ := LinearMap.ext fun _ => map_smul f _ _", "start": [406, 1], "end": [411, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compRight_apply", "code": "@[simp]\ntheorem compRight_apply (f : M\u2082 \u2192\u2097[R] M\u2083) (g : M \u2192\u2097[R] M\u2082) : compRight f g = f.comp g", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply\u2097", "code": "@[simps]\ndef apply\u2097 : M \u2192\u2097[R] (M \u2192\u2097[R] M\u2082) \u2192\u2097[R] M\u2082 :=\n  { apply\u2097' R with\n    toFun := fun v => { apply\u2097' R v with toFun := fun f => f v }\n    map_smul' := fun _ _ => LinearMap.ext fun f => map_smul f _ _ }", "start": [419, 1], "end": [427, 68], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict'", "code": "def domRestrict' (p : Submodule R M) : (M \u2192\u2097[R] M\u2082) \u2192\u2097[R] p \u2192\u2097[R] M\u2082 where\n  toFun \u03c6 := \u03c6.domRestrict p\n  map_add' := by simp [LinearMap.ext_iff]\n  map_smul' := by simp [LinearMap.ext_iff]", "start": [430, 1], "end": [434, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict'_apply", "code": "@[simp]\ntheorem domRestrict'_apply (f : M \u2192\u2097[R] M\u2082) (p : Submodule R M) (x : p) :\n    domRestrict' p f x = f x", "start": [437, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smulRight\u2097", "code": "def smulRight\u2097 : (M\u2082 \u2192\u2097[R] R) \u2192\u2097[R] M \u2192\u2097[R] M\u2082 \u2192\u2097[R] M where\n  toFun f :=\n    { toFun := LinearMap.smulRight f\n      map_add' := fun m m' => by\n        ext\n        apply smul_add\n      map_smul' := fun c m => by\n        ext\n        apply smul_comm }\n  map_add' f f' := by\n    ext\n    apply add_smul\n  map_smul' c f := by\n    ext\n    apply mul_smul", "start": [443, 1], "end": [460, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.smulRight\u2097_apply", "code": "@[simp]\ntheorem smulRight\u2097_apply (f : M\u2082 \u2192\u2097[R] R) (x : M) (c : M\u2082) :\n    (smulRight\u2097 : (M\u2082 \u2192\u2097[R] R) \u2192\u2097[R] M \u2192\u2097[R] M\u2082 \u2192\u2097[R] M) f x c = f c \u2022 x", "start": [463, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "addMonoidHomLequivNat", "code": "@[simps]\ndef addMonoidHomLequivNat {A B : Type*} (R : Type*) [Semiring R] [AddCommMonoid A]\n    [AddCommMonoid B] [Module R B] : (A \u2192+ B) \u2243\u2097[R] A \u2192\u2097[\u2115] B\n    where\n  toFun := AddMonoidHom.toNatLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' := by intros; ext; rfl\n  map_smul' := by intros; ext; rfl\n  left_inv := by intro f; ext; rfl\n  right_inv := by intro f; ext; rfl", "start": [473, 1], "end": [485, 36], "kind": "commanddeclaration"}, {"full_name": "addMonoidHomLequivInt", "code": "@[simps]\ndef addMonoidHomLequivInt {A B : Type*} (R : Type*) [Semiring R] [AddCommGroup A] [AddCommGroup B]\n    [Module R B] : (A \u2192+ B) \u2243\u2097[R] A \u2192\u2097[\u2124] B\n    where\n  toFun := AddMonoidHom.toIntLinearMap\n  invFun := LinearMap.toAddMonoidHom\n  map_add' := by intros; ext; rfl\n  map_smul' := by intros; ext; rfl\n  left_inv := by intro f; ext; rfl\n  right_inv := by intro f; ext; rfl", "start": [488, 1], "end": [500, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.ofLe", "code": "def ofLe (h : p \u2264 p') : p \u2192\u2097[R] p' :=\n  p.subtype.codRestrict p' fun \u27e8_, hx\u27e9 => h hx", "start": [525, 1], "end": [528, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_ofLe", "code": "@[simp]\ntheorem coe_ofLe (h : p \u2264 p') (x : p) : (ofLe h x : M) = x", "start": [531, 1], "end": [533, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.ofLe_apply", "code": "theorem ofLe_apply (h : p \u2264 p') (x : p) : ofLe h x = \u27e8x, h x.2\u27e9", "start": [536, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.ofLe_injective", "code": "theorem ofLe_injective (h : p \u2264 p') : Function.Injective (ofLe h)", "start": [540, 1], "end": [541, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.subtype_comp_ofLe", "code": "theorem subtype_comp_ofLe (p q : Submodule R M) (h : p \u2264 q) :\n    q.subtype.comp (ofLe h) = p.subtype", "start": [546, 1], "end": [549, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.map", "code": "def map (f : F) (p : Submodule R M) : Submodule R\u2082 M\u2082 :=\n  { p.toAddSubmonoid.map f with\n    carrier := f '' p\n    smul_mem' := by\n      rintro c x \u27e8y, hy, rfl\u27e9\n      obtain \u27e8a, rfl\u27e9 := \u03c3\u2081\u2082.surjective c\n      exact \u27e8_, p.smul_mem a hy, map_smul\u209b\u2097 f _ _\u27e9 }", "start": [556, 1], "end": [563, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_coe", "code": "@[simp]\ntheorem map_coe (f : F) (p : Submodule R M) : (map f p : Set M\u2082) = f '' p", "start": [566, 1], "end": [568, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_toAddSubmonoid", "code": "theorem map_toAddSubmonoid (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : Submodule R M) :\n    (p.map f).toAddSubmonoid = p.toAddSubmonoid.map (f : M \u2192+ M\u2082)", "start": [571, 1], "end": [573, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_toAddSubmonoid'", "code": "theorem map_toAddSubmonoid' (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (p : Submodule R M) :\n    (p.map f).toAddSubmonoid = p.toAddSubmonoid.map f", "start": [576, 1], "end": [578, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toIntLinearMap_map", "code": "@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_map {A A\u2082 : Type*} [AddCommGroup A] [AddCommGroup A\u2082]\n    (f : A \u2192+ A\u2082) (s : AddSubgroup A) :\n    (AddSubgroup.toIntSubmodule s).map f.toIntLinearMap =\n      AddSubgroup.toIntSubmodule (s.map f)", "start": [581, 1], "end": [585, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.coe_toAdditive_map", "code": "@[simp]\ntheorem _root_.MonoidHom.coe_toAdditive_map {G G\u2082 : Type*} [Group G] [Group G\u2082] (f : G \u2192* G\u2082)\n    (s : Subgroup G) :\n    s.toAddSubgroup.map (MonoidHom.toAdditive f) = Subgroup.toAddSubgroup (s.map f)", "start": [587, 1], "end": [590, 91], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toMultiplicative_map", "code": "@[simp]\ntheorem _root_.AddMonoidHom.coe_toMultiplicative_map {G G\u2082 : Type*} [AddGroup G] [AddGroup G\u2082]\n    (f : G \u2192+ G\u2082) (s : AddSubgroup G) :\n    s.toSubgroup.map (AddMonoidHom.toMultiplicative f) = AddSubgroup.toSubgroup (s.map f)", "start": [592, 1], "end": [595, 97], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_map", "code": "@[simp]\ntheorem mem_map {f : F} {p : Submodule R M} {x : M\u2082} : x \u2208 map f p \u2194 \u2203 y, y \u2208 p \u2227 f y = x", "start": [597, 1], "end": [599, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_map_of_mem", "code": "theorem mem_map_of_mem {f : F} {p : Submodule R M} {r} (h : r \u2208 p) : f r \u2208 map f p", "start": [602, 1], "end": [603, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.apply_coe_mem_map", "code": "theorem apply_coe_mem_map (f : F) {p : Submodule R M} (r : p) : f r \u2208 map f p", "start": [606, 1], "end": [607, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_id", "code": "@[simp]\ntheorem map_id : map (LinearMap.id : M \u2192\u2097[R] M) p = p", "start": [610, 1], "end": [612, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comp", "code": "theorem map_comp [RingHomSurjective \u03c3\u2082\u2083] [RingHomSurjective \u03c3\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)\n    (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (p : Submodule R M) : map (g.comp f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) p = map g (map f p)", "start": [615, 1], "end": [617, 96], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_mono", "code": "theorem map_mono {f : F} {p p' : Submodule R M} : p \u2264 p' \u2192 map f p \u2264 map f p'", "start": [620, 1], "end": [621, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_zero", "code": "@[simp]\ntheorem map_zero : map (0 : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) p = \u22a5", "start": [624, 1], "end": [627, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_add_le", "code": "theorem map_add_le (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : map (f + g) p \u2264 map f p \u2294 map g p", "start": [630, 1], "end": [632, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inf_le", "code": "theorem map_inf_le (f : F) {p q : Submodule R M} :\n    (p \u2293 q).map f \u2264 p.map f \u2293 q.map f", "start": [635, 1], "end": [637, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inf", "code": "theorem map_inf (f : F) {p q : Submodule R M} (hf : Injective f) :\n    (p \u2293 q).map f = p.map f \u2293 q.map f", "start": [639, 1], "end": [641, 46], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_map_nonempty", "code": "theorem range_map_nonempty (N : Submodule R M) :\n    (Set.range (fun \u03d5 => Submodule.map \u03d5 N : (M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) \u2192 Submodule R\u2082 M\u2082)).Nonempty", "start": [643, 1], "end": [645, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.equivMapOfInjective", "code": "noncomputable def equivMapOfInjective (f : F) (i : Injective f) (p : Submodule R M) :\n    p \u2243\u209b\u2097[\u03c3\u2081\u2082] p.map f :=\n  { Equiv.Set.image f p i with\n    map_add' := by\n      intros\n      simp only [coe_add, map_add, Equiv.toFun_as_coe, Equiv.Set.image_apply]\n      rfl\n    map_smul' := by\n      intros\n      simp only [coe_smul_of_tower, map_smul\u209b\u2097, Equiv.toFun_as_coe, Equiv.Set.image_apply]\n      rfl }", "start": [654, 1], "end": [667, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_equivMapOfInjective_apply", "code": "@[simp]\ntheorem coe_equivMapOfInjective_apply (f : F) (i : Injective f) (p : Submodule R M) (x : p) :\n    (equivMapOfInjective f i p x : M\u2082) = f x", "start": [670, 1], "end": [673, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap", "code": "def comap (f : F) (p : Submodule R\u2082 M\u2082) : Submodule R M :=\n  { p.toAddSubmonoid.comap f with\n    carrier := f \u207b\u00b9' p\n    smul_mem' := fun a x h => by simp [p.smul_mem (\u03c3\u2081\u2082 a) h] }", "start": [676, 1], "end": [680, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_coe", "code": "@[simp]\ntheorem comap_coe (f : F) (p : Submodule R\u2082 M\u2082) : (comap f p : Set M) = f \u207b\u00b9' p", "start": [683, 1], "end": [685, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.AddMonoidHom.coe_toIntLinearMap_comap", "code": "@[simp]\ntheorem AddMonoidHom.coe_toIntLinearMap_comap {A A\u2082 : Type*} [AddCommGroup A] [AddCommGroup A\u2082]\n    (f : A \u2192+ A\u2082) (s : AddSubgroup A\u2082) :\n    (AddSubgroup.toIntSubmodule s).comap f.toIntLinearMap =\n      AddSubgroup.toIntSubmodule (s.comap f)", "start": [688, 1], "end": [692, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_comap", "code": "@[simp]\ntheorem mem_comap {f : F} {p : Submodule R\u2082 M\u2082} : x \u2208 comap f p \u2194 f x \u2208 p", "start": [694, 1], "end": [696, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_id", "code": "@[simp]\ntheorem comap_id : comap (LinearMap.id : M \u2192\u2097[R] M) p = p", "start": [699, 1], "end": [701, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_comp", "code": "theorem comap_comp (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083) (p : Submodule R\u2083 M\u2083) :\n    comap (g.comp f : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) p = comap f (comap g p)", "start": [704, 1], "end": [706, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_mono", "code": "theorem comap_mono {f : F} {q q' : Submodule R\u2082 M\u2082} : q \u2264 q' \u2192 comap f q \u2264 comap f q'", "start": [709, 1], "end": [710, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_comap_pow_of_le_comap", "code": "theorem le_comap_pow_of_le_comap (p : Submodule R M) {f : M \u2192\u2097[R] M} (h : p \u2264 p.comap f) (k : \u2115) :\n    p \u2264 p.comap (f ^ k)", "start": [713, 1], "end": [717, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : F} {p : Submodule R M} {q : Submodule R\u2082 M\u2082} :\n    map f p \u2264 q \u2194 p \u2264 comap f q", "start": [724, 1], "end": [726, 19], "kind": "commanddeclaration"}, {"full_name": "Submodule.gc_map_comap", "code": "theorem gc_map_comap (f : F) : GaloisConnection (map f) (comap f)", "start": [729, 1], "end": [730, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_bot", "code": "@[simp]\ntheorem map_bot (f : F) : map f \u22a5 = \u22a5", "start": [733, 1], "end": [735, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_sup", "code": "@[simp]\ntheorem map_sup (f : F) : map f (p \u2294 p') = map f p \u2294 map f p'", "start": [738, 1], "end": [740, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_iSup", "code": "@[simp]\ntheorem map_iSup {\u03b9 : Sort*} (f : F) (p : \u03b9 \u2192 Submodule R M) :\n    map f (\u2a06 i, p i) = \u2a06 i, map f (p i)", "start": [743, 1], "end": [746, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_top", "code": "@[simp]\ntheorem comap_top (f : F) : comap f \u22a4 = \u22a4", "start": [751, 1], "end": [753, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_inf", "code": "@[simp]\ntheorem comap_inf (f : F) : comap f (q \u2293 q') = comap f q \u2293 comap f q'", "start": [756, 1], "end": [758, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_iInf", "code": "@[simp]\ntheorem comap_iInf [RingHomSurjective \u03c3\u2081\u2082] {\u03b9 : Sort*} (f : F) (p : \u03b9 \u2192 Submodule R\u2082 M\u2082) :\n    comap f (\u2a05 i, p i) = \u2a05 i, comap f (p i)", "start": [761, 1], "end": [764, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_zero", "code": "@[simp]\ntheorem comap_zero : comap (0 : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) q = \u22a4", "start": [767, 1], "end": [769, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comap_le", "code": "theorem map_comap_le [RingHomSurjective \u03c3\u2081\u2082] (f : F) (q : Submodule R\u2082 M\u2082) :\n    map f (comap f q) \u2264 q", "start": [772, 1], "end": [774, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_comap_map", "code": "theorem le_comap_map [RingHomSurjective \u03c3\u2081\u2082] (f : F) (p : Submodule R M) : p \u2264 comap f (map f p)", "start": [777, 1], "end": [778, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.giMapComap", "code": "def giMapComap : GaloisInsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisInsertion fun S x hx => by\n    rcases hf x with \u27e8y, rfl\u27e9\n    simp only [mem_map, mem_comap]\n    exact \u27e8y, hx, rfl\u27e9", "start": [787, 1], "end": [792, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comap_eq_of_surjective", "code": "theorem map_comap_eq_of_surjective (p : Submodule R\u2082 M\u2082) : (p.comap f).map f = p", "start": [795, 1], "end": [796, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_surjective_of_surjective", "code": "theorem map_surjective_of_surjective : Function.Surjective (map f)", "start": [799, 1], "end": [800, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_injective_of_surjective", "code": "theorem comap_injective_of_surjective : Function.Injective (comap f)", "start": [803, 1], "end": [804, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_sup_comap_of_surjective", "code": "theorem map_sup_comap_of_surjective (p q : Submodule R\u2082 M\u2082) :\n    (p.comap f \u2294 q.comap f).map f = p \u2294 q", "start": [807, 1], "end": [809, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_iSup_comap_of_sujective", "code": "theorem map_iSup_comap_of_sujective {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R\u2082 M\u2082) :\n    (\u2a06 i, (S i).comap f).map f = iSup S", "start": [812, 1], "end": [814, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inf_comap_of_surjective", "code": "theorem map_inf_comap_of_surjective (p q : Submodule R\u2082 M\u2082) :\n    (p.comap f \u2293 q.comap f).map f = p \u2293 q", "start": [817, 1], "end": [819, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_iInf_comap_of_surjective", "code": "theorem map_iInf_comap_of_surjective {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R\u2082 M\u2082) :\n    (\u2a05 i, (S i).comap f).map f = iInf S", "start": [822, 1], "end": [824, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_le_comap_iff_of_surjective", "code": "theorem comap_le_comap_iff_of_surjective (p q : Submodule R\u2082 M\u2082) : p.comap f \u2264 q.comap f \u2194 p \u2264 q", "start": [827, 1], "end": [828, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_strictMono_of_surjective", "code": "theorem comap_strictMono_of_surjective : StrictMono (comap f)", "start": [831, 1], "end": [832, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.gciMapComap", "code": "def gciMapComap : GaloisCoinsertion (map f) (comap f) :=\n  (gc_map_comap f).toGaloisCoinsertion fun S x => by\n    simp [mem_comap, mem_map, forall_exists_index, and_imp]\n    intro y hy hxy\n    rw [hf.eq_iff] at hxy\n    rwa [\u2190 hxy]", "start": [841, 1], "end": [847, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_map_eq_of_injective", "code": "theorem comap_map_eq_of_injective (p : Submodule R M) : (p.map f).comap f = p", "start": [850, 1], "end": [851, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_surjective_of_injective", "code": "theorem comap_surjective_of_injective : Function.Surjective (comap f)", "start": [854, 1], "end": [855, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_injective_of_injective", "code": "theorem map_injective_of_injective : Function.Injective (map f)", "start": [858, 1], "end": [859, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_inf_map_of_injective", "code": "theorem comap_inf_map_of_injective (p q : Submodule R M) : (p.map f \u2293 q.map f).comap f = p \u2293 q", "start": [862, 1], "end": [863, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_iInf_map_of_injective", "code": "theorem comap_iInf_map_of_injective {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R M) :\n    (\u2a05 i, (S i).map f).comap f = iInf S", "start": [866, 1], "end": [868, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_sup_map_of_injective", "code": "theorem comap_sup_map_of_injective (p q : Submodule R M) : (p.map f \u2294 q.map f).comap f = p \u2294 q", "start": [871, 1], "end": [872, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_iSup_map_of_injective", "code": "theorem comap_iSup_map_of_injective {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R M) :\n    (\u2a06 i, (S i).map f).comap f = iSup S", "start": [875, 1], "end": [877, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_le_map_iff_of_injective", "code": "theorem map_le_map_iff_of_injective (p q : Submodule R M) : p.map f \u2264 q.map f \u2194 p \u2264 q", "start": [880, 1], "end": [881, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_strictMono_of_injective", "code": "theorem map_strictMono_of_injective : StrictMono (map f)", "start": [884, 1], "end": [885, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.orderIsoMapComap", "code": "@[simps symm_apply apply]\ndef orderIsoMapComap (f : F) : Submodule R M \u2243o Submodule R\u2082 M\u2082 where\n  toFun := map f\n  invFun := comap f\n  left_inv := comap_map_eq_of_injective (EquivLike.injective f)\n  right_inv := map_comap_eq_of_surjective (EquivLike.surjective f)\n  map_rel_iff' := map_le_map_iff_of_injective (EquivLike.injective f) _ _", "start": [896, 1], "end": [903, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inf_eq_map_inf_comap", "code": "theorem map_inf_eq_map_inf_comap [RingHomSurjective \u03c3\u2081\u2082] {f : F} {p : Submodule R M}\n    {p' : Submodule R\u2082 M\u2082} : map f p \u2293 p' = map f (p \u2293 comap f p')", "start": [911, 1], "end": [914, 73], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comap_subtype", "code": "theorem map_comap_subtype : map p.subtype (comap p.subtype p') = p \u2293 p'", "start": [917, 1], "end": [918, 98], "kind": "commanddeclaration"}, {"full_name": "Submodule.eq_zero_of_bot_submodule", "code": "theorem eq_zero_of_bot_submodule : \u2200 b : (\u22a5 : Submodule R M), b = 0", "start": [921, 1], "end": [922, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iInf_invariant", "code": "theorem _root_.LinearMap.iInf_invariant {\u03c3 : R \u2192+* R} [RingHomSurjective \u03c3] {\u03b9 : Sort*}\n    (f : M \u2192\u209b\u2097[\u03c3] M) {p : \u03b9 \u2192 Submodule R M} (hf : \u2200 i, \u2200 v \u2208 p i, f v \u2208 p i) :\n    \u2200 v \u2208 iInf p, f v \u2208 iInf p", "start": [925, 1], "end": [934, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_coe", "code": "theorem neg_coe : -(p : Set M) = p", "start": [945, 1], "end": [946, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_neg", "code": "@[simp]\nprotected theorem map_neg (f : M \u2192\u2097[R] M\u2082) : map (-f) p = map f p", "start": [949, 1], "end": [953, 86], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_smul", "code": "theorem comap_smul (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V\u2082) (a : K) (h : a \u2260 0) :\n    p.comap (a \u2022 f) = p.comap f", "start": [966, 1], "end": [968, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_smul", "code": "protected theorem map_smul (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V) (a : K) (h : a \u2260 0) :\n    p.map (a \u2022 f) = p.map f", "start": [971, 1], "end": [974, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_smul'", "code": "theorem comap_smul' (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V\u2082) (a : K) :\n    p.comap (a \u2022 f) = \u2a05 _ : a \u2260 0, p.comap f", "start": [977, 1], "end": [979, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_smul'", "code": "theorem map_smul' (f : V \u2192\u2097[K] V\u2082) (p : Submodule K V) (a : K) :\n    p.map (a \u2022 f) = \u2a06 _ : a \u2260 0, map f p", "start": [982, 1], "end": [984, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_finsupp_sum", "code": "theorem coe_finsupp_sum (t : \u03b9 \u2192\u2080 \u03b3) (g : \u03b9 \u2192 \u03b3 \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n    \u21d1(t.sum g) = t.sum fun i d => g i d", "start": [1010, 1], "end": [1011, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.finsupp_sum_apply", "code": "@[simp]\ntheorem finsupp_sum_apply (t : \u03b9 \u2192\u2080 \u03b3) (g : \u03b9 \u2192 \u03b3 \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (b : M) :\n    (t.sum g) b = t.sum fun i d => g i d b", "start": [1014, 1], "end": [1017, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_dfinsupp_sum", "code": "theorem coe_dfinsupp_sum (t : \u03a0\u2080 i, \u03b3 i) (g : \u2200 i, \u03b3 i \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n    \u21d1(t.sum g) = t.sum fun i d => g i d", "start": [1034, 1], "end": [1035, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.dfinsupp_sum_apply", "code": "@[simp]\ntheorem dfinsupp_sum_apply (t : \u03a0\u2080 i, \u03b3 i) (g : \u2200 i, \u03b3 i \u2192 M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (b : M) :\n    (t.sum g) b = t.sum fun i d => g i d b", "start": [1038, 1], "end": [1041, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_dfinsupp_sumAddHom", "code": "@[simp]\ntheorem map_dfinsupp_sumAddHom (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {t : \u03a0\u2080 i, \u03b3 i} {g : \u2200 i, \u03b3 i \u2192+ M} :\n    f (sumAddHom g t) = sumAddHom (fun i => f.toAddMonoidHom.comp (g i)) t", "start": [1050, 1], "end": [1053, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_codRestrict", "code": "theorem map_codRestrict [RingHomSurjective \u03c3\u2082\u2081] (p : Submodule R M) (f : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) (h p') :\n    Submodule.map (codRestrict p f h) p' = comap p.subtype (p'.map f)", "start": [1064, 1], "end": [1066, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comap_codRestrict", "code": "theorem comap_codRestrict (p : Submodule R M) (f : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) (hf p') :\n    Submodule.comap (codRestrict p f hf) p' = Submodule.comap f (map p.subtype p')", "start": [1069, 1], "end": [1071, 92], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range", "code": "def range [RingHomSurjective \u03c4\u2081\u2082] (f : F) : Submodule R\u2082 M\u2082 :=\n  (map f \u22a4).copy (Set.range f) Set.image_univ.symm", "start": [1078, 1], "end": [1081, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_coe", "code": "theorem range_coe [RingHomSurjective \u03c4\u2081\u2082] (f : F) : (range f : Set M\u2082) = Set.range f", "start": [1084, 1], "end": [1085, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_toAddSubmonoid", "code": "theorem range_toAddSubmonoid [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    f.range.toAddSubmonoid = AddMonoidHom.mrange f", "start": [1088, 1], "end": [1090, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_range", "code": "@[simp]\ntheorem mem_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {x} : x \u2208 range f \u2194 \u2203 y, f y = x", "start": [1093, 1], "end": [1095, 10], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_eq_map", "code": "theorem range_eq_map [RingHomSurjective \u03c4\u2081\u2082] (f : F) : range f = map f \u22a4", "start": [1098, 1], "end": [1100, 7], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_range_self", "code": "theorem mem_range_self [RingHomSurjective \u03c4\u2081\u2082] (f : F) (x : M) : f x \u2208 range f", "start": [1103, 1], "end": [1104, 11], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_id", "code": "@[simp]\ntheorem range_id : range (LinearMap.id : M \u2192\u2097[R] M) = \u22a4", "start": [1107, 1], "end": [1109, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_comp", "code": "theorem range_comp [RingHomSurjective \u03c4\u2081\u2082] [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083]\n    (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = map g (range f)", "start": [1112, 1], "end": [1114, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_comp_le_range", "code": "theorem range_comp_le_range [RingHomSurjective \u03c4\u2082\u2083] [RingHomSurjective \u03c4\u2081\u2083] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082)\n    (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) : range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) \u2264 range g", "start": [1117, 1], "end": [1119, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_eq_top", "code": "theorem range_eq_top [RingHomSurjective \u03c4\u2081\u2082] {f : F} : range f = \u22a4 \u2194 Surjective f", "start": [1122, 1], "end": [1123, 70], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_le_iff_comap", "code": "theorem range_le_iff_comap [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R\u2082 M\u2082} :\n    range f \u2264 p \u2194 comap f p = \u22a4", "start": [1126, 1], "end": [1127, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_le_range", "code": "theorem map_le_range [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R M} : map f p \u2264 range f", "start": [1130, 1], "end": [1131, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_neg", "code": "@[simp]\ntheorem range_neg {R : Type*} {R\u2082 : Type*} {M : Type*} {M\u2082 : Type*} [Semiring R] [Ring R\u2082]\n    [AddCommMonoid M] [AddCommGroup M\u2082] [Module R M] [Module R\u2082 M\u2082] {\u03c4\u2081\u2082 : R \u2192+* R\u2082}\n    [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : LinearMap.range (-f) = LinearMap.range f", "start": [1134, 1], "end": [1139, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_domRestrict_le_range", "code": "lemma range_domRestrict_le_range [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (S : Submodule R M) :\n    LinearMap.range (f.domRestrict S) \u2264 LinearMap.range f := by\n  rintro x \u27e8\u27e8y, hy\u27e9, rfl\u27e9\n  exact LinearMap.mem_range_self f y", "start": [1142, 1], "end": [1145, 37], "kind": "mathlibtacticlemma"}, {"full_name": "AddMonoidHom.coe_toIntLinearMap_range", "code": "@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_range {M M\u2082 : Type*} [AddCommGroup M]\n    [AddCommGroup M\u2082] (f : M \u2192+ M\u2082) :\n    LinearMap.range f.toIntLinearMap = AddSubgroup.toIntSubmodule f.range", "start": [1147, 1], "end": [1150, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqLocus", "code": "def eqLocus (f g : F) : Submodule R M :=\n  { (f : M \u2192+ M\u2082).eqLocusM g with\n    carrier := { x | f x = g x }\n    smul_mem' := fun {r} {x} (hx : _ = _) => show _ = _ by\n      simpa only [map_smul\u209b\u2097] using congr_arg ((\u00b7 \u2022 \u00b7) (\u03c4\u2081\u2082 r)) hx }", "start": [1152, 1], "end": [1157, 69], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_eqLocus", "code": "@[simp]\ntheorem mem_eqLocus {x : M} {f g : F} : x \u2208 eqLocus f g \u2194 f x = g x", "start": [1160, 1], "end": [1162, 10], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqLocus_toAddSubmonoid", "code": "theorem eqLocus_toAddSubmonoid (f g : F) :\n    (eqLocus f g).toAddSubmonoid = (f : M \u2192+ M\u2082).eqLocusM g", "start": [1165, 1], "end": [1167, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqLocus_eq_top", "code": "@[simp]\ntheorem eqLocus_eq_top {f g : F} : eqLocus f g = \u22a4 \u2194 f = g", "start": [1170, 1], "end": [1172, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqLocus_same", "code": "@[simp]\ntheorem eqLocus_same (f : F) : eqLocus f f = \u22a4", "start": [1174, 1], "end": [1175, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.le_eqLocus", "code": "theorem le_eqLocus {f g : F} {S : Submodule R M} : S \u2264 eqLocus f g \u2194 Set.EqOn f g S", "start": [1178, 1], "end": [1178, 95], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqOn_sup", "code": "theorem eqOn_sup {f g : F} {S T : Submodule R M} (hS : Set.EqOn f g S) (hT : Set.EqOn f g T) :\n    Set.EqOn f g \u2191(S \u2294 T)", "start": [1180, 1], "end": [1183, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_on_codisjoint", "code": "theorem ext_on_codisjoint {f g : F} {S T : Submodule R M} (hST : Codisjoint S T)\n    (hS : Set.EqOn f g S) (hT : Set.EqOn f g T) : f = g", "start": [1185, 1], "end": [1187, 70], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterateRange", "code": "@[simps]\ndef iterateRange (f : M \u2192\u2097[R] M) : \u2115 \u2192o (Submodule R M)\u1d52\u1d48 where\n  toFun n := LinearMap.range (f ^ n)\n  monotone' n m w x h := by\n    obtain \u27e8c, rfl\u27e9 := le_iff_exists_add.mp w\n    rw [LinearMap.mem_range] at h\n    obtain \u27e8m, rfl\u27e9 := h\n    rw [LinearMap.mem_range]\n    use (f ^ c) m\n    rw [pow_add, LinearMap.mul_apply]", "start": [1191, 1], "end": [1202, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rangeRestrict", "code": "@[reducible]\ndef rangeRestrict [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : M \u2192\u209b\u2097[\u03c4\u2081\u2082] LinearMap.range f :=\n  f.codRestrict (LinearMap.range f) (LinearMap.mem_range_self f)", "start": [1205, 1], "end": [1210, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.fintypeRange", "code": "instance fintypeRange [Fintype M] [DecidableEq M\u2082] [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    Fintype (range f) :=\n  Set.fintypeRange f", "start": [1213, 1], "end": [1218, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker", "code": "def ker (f : F) : Submodule R M :=\n  comap f \u22a5", "start": [1223, 1], "end": [1226, 12], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_ker", "code": "@[simp]\ntheorem mem_ker {f : F} {y} : y \u2208 ker f \u2194 f y = 0", "start": [1229, 1], "end": [1231, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_id", "code": "@[simp]\ntheorem ker_id : ker (LinearMap.id : M \u2192\u2097[R] M) = \u22a5", "start": [1234, 1], "end": [1236, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_coe_ker", "code": "@[simp]\ntheorem map_coe_ker (f : F) (x : ker f) : f x = 0", "start": [1239, 1], "end": [1241, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_toAddSubmonoid", "code": "theorem ker_toAddSubmonoid (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.ker.toAddSubmonoid = (AddMonoidHom.mker f)", "start": [1244, 1], "end": [1245, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_ker_subtype", "code": "theorem comp_ker_subtype (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.comp f.ker.subtype = 0", "start": [1248, 1], "end": [1249, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_comp", "code": "theorem ker_comp (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) :\n    ker (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = comap f (ker g)", "start": [1252, 1], "end": [1254, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_le_ker_comp", "code": "theorem ker_le_ker_comp (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) :\n    ker f \u2264 ker (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083)", "start": [1257, 1], "end": [1258, 88], "kind": "commanddeclaration"}, {"full_name": "LinearMap.disjoint_ker", "code": "theorem disjoint_ker {f : F} {p : Submodule R M} : Disjoint p (ker f) \u2194 \u2200 x \u2208 p, f x = 0 \u2192 x = 0", "start": [1261, 1], "end": [1262, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot'", "code": "theorem ker_eq_bot' {f : F} : ker f = \u22a5 \u2194 \u2200 m, f m = 0 \u2192 m = 0", "start": [1265, 1], "end": [1266, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot_of_inverse", "code": "theorem ker_eq_bot_of_inverse {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [RingHomInvPair \u03c4\u2081\u2082 \u03c4\u2082\u2081] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082}\n    {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M} (h : (g.comp f : M \u2192\u2097[R] M) = id) : ker f = \u22a5", "start": [1269, 1], "end": [1271, 91], "kind": "commanddeclaration"}, {"full_name": "LinearMap.le_ker_iff_map", "code": "theorem le_ker_iff_map [RingHomSurjective \u03c4\u2081\u2082] {f : F} {p : Submodule R M} :\n    p \u2264 ker f \u2194 map f p = \u22a5", "start": [1274, 1], "end": [1275, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_codRestrict", "code": "theorem ker_codRestrict {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} (p : Submodule R M) (f : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M) (hf) :\n    ker (codRestrict p f hf) = ker f", "start": [1278, 1], "end": [1279, 95], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_codRestrict", "code": "theorem range_codRestrict {\u03c4\u2082\u2081 : R\u2082 \u2192+* R} [RingHomSurjective \u03c4\u2082\u2081] (p : Submodule R M)\n    (f : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M) (hf) :\n    range (codRestrict p f hf) = comap p.subtype (LinearMap.range f)", "start": [1282, 1], "end": [1285, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_restrict", "code": "theorem ker_restrict [AddCommMonoid M\u2081] [Module R M\u2081] {p : Submodule R M} {q : Submodule R M\u2081}\n    {f : M \u2192\u2097[R] M\u2081} (hf : \u2200 x : M, x \u2208 p \u2192 f x \u2208 q) :\n    ker (f.restrict hf) = LinearMap.ker (f.domRestrict p)", "start": [1288, 1], "end": [1291, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comap_eq", "code": "theorem _root_.Submodule.map_comap_eq [RingHomSurjective \u03c4\u2081\u2082] (f : F) (q : Submodule R\u2082 M\u2082) :\n    map f (comap f q) = range f \u2293 q", "start": [1294, 1], "end": [1297, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_comap_eq_self", "code": "theorem _root_.Submodule.map_comap_eq_self [RingHomSurjective \u03c4\u2081\u2082] {f : F} {q : Submodule R\u2082 M\u2082}\n    (h : q \u2264 range f) : map f (comap f q) = q", "start": [1300, 1], "end": [1301, 95], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_zero", "code": "@[simp]\ntheorem ker_zero : ker (0 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) = \u22a4", "start": [1304, 1], "end": [1306, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_zero", "code": "@[simp]\ntheorem range_zero [RingHomSurjective \u03c4\u2081\u2082] : range (0 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) = \u22a5", "start": [1309, 1], "end": [1311, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_top", "code": "theorem ker_eq_top {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} : ker f = \u22a4 \u2194 f = 0", "start": [1314, 1], "end": [1315, 84], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.coe_toIntLinearMap_ker", "code": "@[simp]\ntheorem _root_.AddMonoidHom.coe_toIntLinearMap_ker {M M\u2082 : Type*} [AddCommGroup M] [AddCommGroup M\u2082]\n    (f : M \u2192+ M\u2082) : LinearMap.ker f.toIntLinearMap = AddSubgroup.toIntSubmodule f.ker", "start": [1318, 1], "end": [1320, 93], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_le_bot_iff", "code": "theorem range_le_bot_iff (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : range f \u2264 \u22a5 \u2194 f = 0", "start": [1326, 1], "end": [1327, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_eq_bot", "code": "theorem range_eq_bot {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} : range f = \u22a5 \u2194 f = 0", "start": [1330, 1], "end": [1331, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_le_ker_iff", "code": "theorem range_le_ker_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} :\n    range f \u2264 ker g \u2194 (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = 0", "start": [1334, 1], "end": [1337, 87], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comap_le_comap_iff", "code": "theorem comap_le_comap_iff {f : F} (hf : range f = \u22a4) {p p'} : comap f p \u2264 comap f p' \u2194 p \u2264 p'", "start": [1340, 1], "end": [1341, 90], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comap_injective", "code": "theorem comap_injective {f : F} (hf : range f = \u22a4) : Injective (comap f)", "start": [1344, 1], "end": [1345, 96], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot_of_injective", "code": "theorem ker_eq_bot_of_injective {f : F} (hf : Injective f) : ker f = \u22a5", "start": [1350, 1], "end": [1357, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iterateKer", "code": "@[simps]\ndef iterateKer (f : M \u2192\u2097[R] M) : \u2115 \u2192o Submodule R M where\n  toFun n := ker (f ^ n)\n  monotone' n m w x h := by\n    obtain \u27e8c, rfl\u27e9 := le_iff_exists_add.mp w\n    rw [LinearMap.mem_ker] at h\n    rw [LinearMap.mem_ker, add_comm, pow_add, LinearMap.mul_apply, h, LinearMap.map_zero]", "start": [1360, 1], "end": [1368, 90], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_toAddSubgroup", "code": "theorem range_toAddSubgroup [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    (range f).toAddSubgroup = f.toAddMonoidHom.range", "start": [1385, 1], "end": [1387, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_toAddSubgroup", "code": "theorem ker_toAddSubgroup (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : (ker f).toAddSubgroup = f.toAddMonoidHom.ker", "start": [1390, 1], "end": [1391, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqLocus_eq_ker_sub", "code": "theorem eqLocus_eq_ker_sub (f g : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : eqLocus f g = ker (f - g)", "start": [1394, 1], "end": [1395, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sub_mem_ker_iff", "code": "theorem sub_mem_ker_iff {x y} : x - y \u2208 ker f \u2194 f x = f y", "start": [1398, 1], "end": [1398, 99], "kind": "commanddeclaration"}, {"full_name": "LinearMap.disjoint_ker'", "code": "theorem disjoint_ker' {p : Submodule R M} :\n    Disjoint p (ker f) \u2194 \u2200 x \u2208 p, \u2200 y \u2208 p, f x = f y \u2192 x = y", "start": [1401, 1], "end": [1405, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injOn_of_disjoint_ker", "code": "theorem injOn_of_disjoint_ker {p : Submodule R M} {s : Set M} (h : s \u2286 p)\n    (hd : Disjoint p (ker f)) : Set.InjOn f s", "start": [1408, 1], "end": [1410, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMapClass.ker_eq_bot", "code": "theorem _root_.LinearMapClass.ker_eq_bot : ker f = \u22a5 \u2194 Injective f", "start": [1415, 1], "end": [1416, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot", "code": "theorem ker_eq_bot {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} : ker f = \u22a5 \u2194 Injective f", "start": [1421, 1], "end": [1422, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_le_iff", "code": "theorem ker_le_iff [RingHomSurjective \u03c4\u2081\u2082] {p : Submodule R M} :\n    ker f \u2264 p \u2194 \u2203 y \u2208 range f, f \u207b\u00b9' {y} \u2286 p", "start": [1425, 1], "end": [1443, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.injective_domRestrict_iff", "code": "@[simp] lemma injective_domRestrict_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {S : Submodule R M} :\n    Injective (f.domRestrict S) \u2194 S \u2293 LinearMap.ker f = \u22a5 := by\n  rw [\u2190 LinearMap.ker_eq_bot]\n  refine \u27e8fun h \u21a6 le_bot_iff.1 ?_, fun h \u21a6 le_bot_iff.1 ?_\u27e9\n  \u00b7 intro x \u27e8hx, h'x\u27e9\n    have : \u27e8x, hx\u27e9 \u2208 LinearMap.ker (LinearMap.domRestrict f S) := by simpa using h'x\n    rw [h] at this\n    simpa using this\n  \u00b7 rintro \u27e8x, hx\u27e9 h'x\n    have : x \u2208 S \u2293 LinearMap.ker f := \u27e8hx, h'x\u27e9\n    rw [h] at this\n    simpa using this", "start": [1446, 1], "end": [1457, 21], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.ker_smul", "code": "theorem ker_smul (f : V \u2192\u2097[K] V\u2082) (a : K) (h : a \u2260 0) : ker (a \u2022 f) = ker f", "start": [1467, 1], "end": [1468, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_smul'", "code": "theorem ker_smul' (f : V \u2192\u2097[K] V\u2082) (a : K) : ker (a \u2022 f) = \u2a05 _ : a \u2260 0, ker f", "start": [1471, 1], "end": [1472, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_smul", "code": "theorem range_smul (f : V \u2192\u2097[K] V\u2082) (a : K) (h : a \u2260 0) : range (a \u2022 f) = range f", "start": [1475, 1], "end": [1476, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_smul'", "code": "theorem range_smul' (f : V \u2192\u2097[K] V\u2082) (a : K) :\n    range (a \u2022 f) = \u2a06 _ : a \u2260 0, range f", "start": [1479, 1], "end": [1481, 60], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.isLinearMap_add", "code": "theorem isLinearMap_add [Semiring R] [AddCommMonoid M] [Module R M] :\n    IsLinearMap R fun x : M \u00d7 M => x.1 + x.2", "start": [1490, 1], "end": [1497, 20], "kind": "commanddeclaration"}, {"full_name": "IsLinearMap.isLinearMap_sub", "code": "theorem isLinearMap_sub {R M : Type*} [Semiring R] [AddCommGroup M] [Module R M] :\n    IsLinearMap R fun x : M \u00d7 M => x.1 - x.2", "start": [1500, 1], "end": [1508, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_top", "code": "@[simp]\ntheorem map_top [RingHomSurjective \u03c4\u2081\u2082] (f : F) : map f \u22a4 = range f", "start": [1529, 1], "end": [1531, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_bot", "code": "@[simp]\ntheorem comap_bot (f : F) : comap f \u22a5 = ker f", "start": [1534, 1], "end": [1536, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_subtype", "code": "@[simp]\ntheorem ker_subtype : ker p.subtype = \u22a5", "start": [1539, 1], "end": [1541, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_subtype", "code": "@[simp]\ntheorem range_subtype : range p.subtype = p", "start": [1544, 1], "end": [1545, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_subtype_le", "code": "theorem map_subtype_le (p' : Submodule R p) : map p.subtype p' \u2264 p", "start": [1548, 1], "end": [1549, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_subtype_top", "code": "theorem map_subtype_top : map p.subtype (\u22a4 : Submodule R p) = p", "start": [1552, 1], "end": [1555, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_subtype_eq_top", "code": "@[simp]\ntheorem comap_subtype_eq_top {p p' : Submodule R M} : comap p.subtype p' = \u22a4 \u2194 p \u2264 p'", "start": [1558, 1], "end": [1560, 80], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_subtype_self", "code": "@[simp]\ntheorem comap_subtype_self : comap p.subtype p = \u22a4", "start": [1563, 1], "end": [1565, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_ofLe", "code": "@[simp]\ntheorem ker_ofLe (p p' : Submodule R M) (h : p \u2264 p') : ker (ofLe h) = \u22a5", "start": [1568, 1], "end": [1570, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_ofLe", "code": "theorem range_ofLe (p q : Submodule R M) (h : p \u2264 q) : range (ofLe h) = comap q.subtype p", "start": [1573, 1], "end": [1574, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_subtype_range_ofLe", "code": "@[simp]\ntheorem map_subtype_range_ofLe {p p' : Submodule R M} (h : p \u2264 p') :\n    map p'.subtype (range $ ofLe h) = p", "start": [1577, 1], "end": [1579, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.disjoint_iff_comap_eq_bot", "code": "theorem disjoint_iff_comap_eq_bot {p q : Submodule R M} : Disjoint p q \u2194 comap p.subtype q = \u22a5", "start": [1582, 1], "end": [1584, 46], "kind": "commanddeclaration"}, {"full_name": "Submodule.MapSubtype.relIso", "code": "def MapSubtype.relIso : Submodule R p \u2243o { p' : Submodule R M // p' \u2264 p } where\n  toFun p' := \u27e8map p.subtype p', map_subtype_le p _\u27e9\n  invFun q := comap p.subtype q\n  left_inv p' := comap_map_eq_of_injective (by exact Subtype.val_injective) p'\n  right_inv := fun \u27e8q, hq\u27e9 => Subtype.ext_val <| by simp [map_comap_subtype p, inf_of_le_right hq]\n  map_rel_iff' {p\u2081 p\u2082} := Subtype.coe_le_coe.symm.trans $ by\n    dsimp\n    rw [map_le_iff_le_comap,\n      comap_map_eq_of_injective (show Injective p.subtype from Subtype.coe_injective) p\u2082]", "start": [1587, 1], "end": [1596, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.MapSubtype.orderEmbedding", "code": "def MapSubtype.orderEmbedding : Submodule R p \u21aao Submodule R M :=\n  (RelIso.toRelEmbedding <| MapSubtype.relIso p).trans $\n    Subtype.relEmbedding (X := Submodule R M) (fun p p' \u21a6 p \u2264 p') _", "start": [1599, 1], "end": [1603, 68], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_subtype_embedding_eq", "code": "@[simp]\ntheorem map_subtype_embedding_eq (p' : Submodule R p) :\n    MapSubtype.orderEmbedding p p' = map p.subtype p'", "start": [1606, 1], "end": [1609, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_eq_bot_of_cancel", "code": "theorem ker_eq_bot_of_cancel {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082}\n    (h : \u2200 u v : ker f \u2192\u2097[R] M, f.comp u = f.comp v \u2192 u = v) : ker f = \u22a5", "start": [1630, 1], "end": [1636, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_comp_of_range_eq_top", "code": "theorem range_comp_of_range_eq_top [RingHomSurjective \u03c4\u2081\u2082] [RingHomSurjective \u03c4\u2082\u2083]\n    [RingHomSurjective \u03c4\u2081\u2083] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) (hf : range f = \u22a4) :\n    range (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = range g", "start": [1639, 1], "end": [1641, 92], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_comp_of_ker_eq_bot", "code": "theorem ker_comp_of_ker_eq_bot (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} (hg : ker g = \u22a5) :\n    ker (g.comp f : M \u2192\u209b\u2097[\u03c4\u2081\u2083] M\u2083) = ker f", "start": [1644, 1], "end": [1645, 88], "kind": "commanddeclaration"}, {"full_name": "LinearMap.submoduleImage", "code": "def submoduleImage {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    (\u03d5 : O \u2192\u2097[R] M') (N : Submodule R M) : Submodule R M' :=\n  (N.comap O.subtype).map \u03d5", "start": [1650, 1], "end": [1654, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_submoduleImage", "code": "@[simp]\ntheorem mem_submoduleImage {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {\u03d5 : O \u2192\u2097[R] M'} {N : Submodule R M} {x : M'} :\n    x \u2208 \u03d5.submoduleImage N \u2194 \u2203 (y : _) (yO : y \u2208 O) (_ : y \u2208 N), \u03d5 \u27e8y, yO\u27e9 = x", "start": [1657, 1], "end": [1665, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_submoduleImage_of_le", "code": "theorem mem_submoduleImage_of_le {M' : Type*} [AddCommMonoid M'] [Module R M'] {O : Submodule R M}\n    {\u03d5 : O \u2192\u2097[R] M'} {N : Submodule R M} (hNO : N \u2264 O) {x : M'} :\n    x \u2208 \u03d5.submoduleImage N \u2194 \u2203 (y : _) (yN : y \u2208 N), \u03d5 \u27e8y, hNO yN\u27e9 = x", "start": [1668, 1], "end": [1675, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.submoduleImage_apply_ofLe", "code": "theorem submoduleImage_apply_ofLe {M' : Type*} [AddCommGroup M'] [Module R M'] {O : Submodule R M}\n    (\u03d5 : O \u2192\u2097[R] M') (N : Submodule R M) (hNO : N \u2264 O) :\n    \u03d5.submoduleImage N = range (\u03d5.comp (Submodule.ofLe hNO))", "start": [1678, 1], "end": [1681, 56], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_rangeRestrict", "code": "@[simp]\ntheorem LinearMap.range_rangeRestrict [Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M]\n    [Module R M\u2082] (f : M \u2192\u2097[R] M\u2082) : range f.rangeRestrict = \u22a4", "start": [1690, 1], "end": [1692, 98], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_rangeRestrict", "code": "@[simp]\ntheorem LinearMap.ker_rangeRestrict [Semiring R] [AddCommMonoid M] [AddCommMonoid M\u2082] [Module R M]\n    [Module R M\u2082] (f : M \u2192\u2097[R] M\u2082) : ker f.rangeRestrict = ker f", "start": [1695, 1], "end": [1698, 34], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.zero_symm", "code": "@[simp]\ntheorem zero_symm : (0 : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082).symm = 0", "start": [1734, 1], "end": [1736, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = 0", "start": [1739, 1], "end": [1741, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.zero_apply", "code": "theorem zero_apply (x : M) : (0 : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) x = 0", "start": [1744, 1], "end": [1745, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.uniqueOfSubsingleton", "code": "instance uniqueOfSubsingleton [Subsingleton R] [Subsingleton R\u2082] : Unique (M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) := by\n  haveI := Module.subsingleton R M\n  haveI := Module.subsingleton R\u2082 M\u2082\n  infer_instance", "start": [1756, 1], "end": [1759, 17], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_eq_comap", "code": "theorem map_eq_comap {p : Submodule R M} :\n    (p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : Submodule R\u2082 M\u2082) = p.comap (e.symm : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M)", "start": [1780, 1], "end": [1782, 57], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.submoduleMap", "code": "def submoduleMap (p : Submodule R M) : p \u2243\u209b\u2097[\u03c3\u2081\u2082] \u21a5(p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : Submodule R\u2082 M\u2082) :=\n  { ((e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082).domRestrict p).codRestrict (p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) fun x =>\n      \u27e8x, by\n        simp only [LinearMap.domRestrict_apply, eq_self_iff_true, and_true_iff, SetLike.coe_mem,\n          SetLike.mem_coe]\u27e9 with\n    invFun := fun y =>\n      \u27e8(e.symm : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2081] M) y, by\n        rcases y with \u27e8y', hy\u27e9\n        rw [Submodule.mem_map] at hy\n        rcases hy with \u27e8x, hx, hxy\u27e9\n        subst hxy\n        simp only [symm_apply_apply, Submodule.coe_mk, coe_coe, hx]\u27e9\n    left_inv := fun x => by\n      simp only [LinearMap.domRestrict_apply, LinearMap.codRestrict_apply, LinearMap.toFun_eq_coe,\n        LinearEquiv.coe_coe, LinearEquiv.symm_apply_apply, SetLike.eta]\n    right_inv := fun y => by\n      apply SetCoe.ext\n      simp only [LinearMap.domRestrict_apply, LinearMap.codRestrict_apply, LinearMap.toFun_eq_coe,\n        LinearEquiv.coe_coe, LinearEquiv.apply_symm_apply] }", "start": [1785, 1], "end": [1809, 61], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.submoduleMap_apply", "code": "@[simp]\ntheorem submoduleMap_apply (p : Submodule R M) (x : p) : \u2191(e.submoduleMap p x) = e x", "start": [1813, 1], "end": [1815, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.submoduleMap_symm_apply", "code": "@[simp]\ntheorem submoduleMap_symm_apply (p : Submodule R M)\n    (x : (p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : Submodule R\u2082 M\u2082)) : \u2191((e.submoduleMap p).symm x) = e.symm x", "start": [1818, 1], "end": [1821, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_dfinsupp_sumAddHom", "code": "@[simp]\ntheorem map_dfinsupp_sumAddHom [\u2200 i, AddZeroClass (\u03b3 i)] (f : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (t : \u03a0\u2080 i, \u03b3 i)\n    (g : \u2200 i, \u03b3 i \u2192+ M) :\n    f (sumAddHom g t) = sumAddHom (fun i => f.toAddEquiv.toAddMonoidHom.comp (g i)) t", "start": [1852, 1], "end": [1856, 42], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.curry", "code": "protected def curry : (V \u00d7 V\u2082 \u2192 R) \u2243\u2097[R] V \u2192 V\u2082 \u2192 R :=\n  { Equiv.curry _ _ _ with\n    map_add' := fun _ _ => by\n      ext\n      rfl\n    map_smul' := fun _ _ => by\n      ext\n      rfl }", "start": [1869, 1], "end": [1878, 12], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_curry", "code": "@[simp]\ntheorem coe_curry : \u21d1(LinearEquiv.curry R V V\u2082) = curry", "start": [1881, 1], "end": [1883, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_curry_symm", "code": "@[simp]\ntheorem coe_curry_symm : \u21d1(LinearEquiv.curry R V V\u2082).symm = uncurry", "start": [1886, 1], "end": [1888, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofEq", "code": "def ofEq (h : p = q) : p \u2243\u2097[R] q :=\n  { Equiv.Set.ofEq (congr_arg _ h) with\n    map_smul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [1917, 1], "end": [1921, 33], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_ofEq_apply", "code": "@[simp]\ntheorem coe_ofEq_apply (h : p = q) (x : p) : (ofEq p q h x : M) = x", "start": [1926, 1], "end": [1928, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofEq_symm", "code": "@[simp]\ntheorem ofEq_symm (h : p = q) : (ofEq p q h).symm = ofEq q p h.symm", "start": [1931, 1], "end": [1933, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofEq_rfl", "code": "@[simp]\ntheorem ofEq_rfl : ofEq p p rfl = LinearEquiv.refl R p", "start": [1936, 1], "end": [1937, 70], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodules", "code": "def ofSubmodules (p : Submodule R M) (q : Submodule R\u2082 M\u2082) (h : p.map (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = q) :\n    p \u2243\u209b\u2097[\u03c3\u2081\u2082] q :=\n  (e.submoduleMap p).trans (LinearEquiv.ofEq _ _ h)", "start": [1940, 1], "end": [1944, 52], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodules_apply", "code": "@[simp]\ntheorem ofSubmodules_apply {p : Submodule R M} {q : Submodule R\u2082 M\u2082} (h : p.map \u2191e = q) (x : p) :\n    \u2191(e.ofSubmodules p q h x) = e x", "start": [1947, 1], "end": [1950, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodules_symm_apply", "code": "@[simp]\ntheorem ofSubmodules_symm_apply {p : Submodule R M} {q : Submodule R\u2082 M\u2082} (h : p.map \u2191e = q)\n    (x : q) : \u2191((e.ofSubmodules p q h).symm x) = e.symm x", "start": [1953, 1], "end": [1956, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodule'", "code": "def ofSubmodule' [Module R M] [Module R\u2082 M\u2082] (f : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (U : Submodule R\u2082 M\u2082) :\n    U.comap (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) \u2243\u209b\u2097[\u03c3\u2081\u2082] U :=\n  (f.symm.ofSubmodules _ _ f.symm.map_eq_comap).symm", "start": [1959, 1], "end": [1965, 53], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodule'_toLinearMap", "code": "theorem ofSubmodule'_toLinearMap [Module R M] [Module R\u2082 M\u2082] (f : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082)\n    (U : Submodule R\u2082 M\u2082) :\n    (f.ofSubmodule' U).toLinearMap = (f.toLinearMap.domRestrict _).codRestrict _ Subtype.prop", "start": [1968, 1], "end": [1972, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodule'_apply", "code": "@[simp]\ntheorem ofSubmodule'_apply [Module R M] [Module R\u2082 M\u2082] (f : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (U : Submodule R\u2082 M\u2082)\n    (x : U.comap (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082)) : (f.ofSubmodule' U x : M\u2082) = f (x : M)", "start": [1975, 1], "end": [1978, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofSubmodule'_symm_apply", "code": "@[simp]\ntheorem ofSubmodule'_symm_apply [Module R M] [Module R\u2082 M\u2082] (f : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082)\n    (U : Submodule R\u2082 M\u2082) (x : U) : ((f.ofSubmodule' U).symm x : M) = f.symm (x : M\u2082)", "start": [1981, 1], "end": [1984, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofTop", "code": "def ofTop (h : p = \u22a4) : p \u2243\u2097[R] M :=\n  { p.subtype with\n    invFun := fun x => \u27e8x, h.symm \u25b8 trivial\u27e9\n    left_inv := fun _ => rfl\n    right_inv := fun _ => rfl }", "start": [1989, 1], "end": [1994, 32], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofTop_apply", "code": "@[simp]\ntheorem ofTop_apply {h} (x : p) : ofTop p h x = x", "start": [1997, 1], "end": [1999, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_ofTop_symm_apply", "code": "@[simp]\ntheorem coe_ofTop_symm_apply {h} (x : M) : ((ofTop p h).symm x : M) = x", "start": [2002, 1], "end": [2004, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofTop_symm_apply", "code": "theorem ofTop_symm_apply {h} (x : M) : (ofTop p h).symm x = \u27e8x, h.symm \u25b8 trivial\u27e9", "start": [2007, 1], "end": [2008, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLinear", "code": "def ofLinear (h\u2081 : f.comp g = LinearMap.id) (h\u2082 : g.comp f = LinearMap.id) : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082 :=\n  { f with\n    invFun := g\n    left_inv := LinearMap.ext_iff.1 h\u2082\n    right_inv := LinearMap.ext_iff.1 h\u2081 }", "start": [2011, 1], "end": [2016, 42], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLinear_apply", "code": "@[simp]\ntheorem ofLinear_apply {h\u2081 h\u2082} (x : M) : (ofLinear f g h\u2081 h\u2082 : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082) x = f x", "start": [2019, 1], "end": [2021, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLinear_symm_apply", "code": "@[simp]\ntheorem ofLinear_symm_apply {h\u2081 h\u2082} (x : M\u2082) : (ofLinear f g h\u2081 h\u2082 : M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082).symm x = g x", "start": [2024, 1], "end": [2026, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.range", "code": "@[simp]\nprotected theorem range : LinearMap.range (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = \u22a4", "start": [2029, 1], "end": [2031, 48], "kind": "commanddeclaration"}, {"full_name": "LinearEquivClass.range", "code": "@[simp]\nprotected theorem _root_.LinearEquivClass.range [Module R M] [Module R\u2082 M\u2082] {F : Type*}\n    [SemilinearEquivClass F \u03c3\u2081\u2082 M M\u2082] (e : F) : LinearMap.range e = \u22a4", "start": [2034, 1], "end": [2037, 52], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.eq_bot_of_equiv", "code": "theorem eq_bot_of_equiv [Module R\u2082 M\u2082] (e : p \u2243\u209b\u2097[\u03c3\u2081\u2082] (\u22a5 : Submodule R\u2082 M\u2082)) : p = \u22a5", "start": [2040, 1], "end": [2043, 43], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ker", "code": "@[simp]\nprotected theorem ker : LinearMap.ker (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = \u22a5", "start": [2046, 1], "end": [2048, 56], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.range_comp", "code": "@[simp]\ntheorem range_comp [RingHomSurjective \u03c3\u2082\u2083] [RingHomSurjective \u03c3\u2081\u2083] :\n    LinearMap.range (h.comp (e : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) = LinearMap.range h", "start": [2052, 1], "end": [2055, 49], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ker_comp", "code": "@[simp]\ntheorem ker_comp (l : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) :\n    LinearMap.ker (((e'' : M\u2082 \u2192\u209b\u2097[\u03c3\u2082\u2083] M\u2083).comp l : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) : M \u2192\u209b\u2097[\u03c3\u2081\u2083] M\u2083) =\n    LinearMap.ker l", "start": [2058, 1], "end": [2062, 45], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLeftInverse", "code": "def ofLeftInverse [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {g : M\u2082 \u2192 M}\n    (h : Function.LeftInverse g f) : M \u2243\u209b\u2097[\u03c3\u2081\u2082] (LinearMap.range f) :=\n  { LinearMap.rangeRestrict f with\n    toFun := LinearMap.rangeRestrict f\n    invFun := g \u2218 (LinearMap.range f).subtype\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := LinearMap.mem_range.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [2067, 1], "end": [2081, 47], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLeftInverse_apply", "code": "@[simp]\ntheorem ofLeftInverse_apply [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n    (h : Function.LeftInverse g f) (x : M) : \u2191(ofLeftInverse h x) = f x", "start": [2084, 1], "end": [2087, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofLeftInverse_symm_apply", "code": "@[simp]\ntheorem ofLeftInverse_symm_apply [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082]\n    (h : Function.LeftInverse g f) (x : LinearMap.range f) : (ofLeftInverse h).symm x = g x", "start": [2090, 1], "end": [2093, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInjective", "code": "noncomputable def ofInjective [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] (h : Injective f) :\n    M \u2243\u209b\u2097[\u03c3\u2081\u2082] LinearMap.range f :=\n  ofLeftInverse <| Classical.choose_spec h.hasLeftInverse", "start": [2098, 1], "end": [2102, 58], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofInjective_apply", "code": "@[simp]\ntheorem ofInjective_apply [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {h : Injective f}\n    (x : M) : \u2191(ofInjective f h x) = f x", "start": [2105, 1], "end": [2108, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofBijective", "code": "noncomputable def ofBijective [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] (hf : Bijective f) :\n    M \u2243\u209b\u2097[\u03c3\u2081\u2082] M\u2082 :=\n  (ofInjective f hf.injective).trans (ofTop _ <| LinearMap.range_eq_top.2 hf.surjective)", "start": [2111, 1], "end": [2114, 89], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.ofBijective_apply", "code": "@[simp]\ntheorem ofBijective_apply [RingHomInvPair \u03c3\u2081\u2082 \u03c3\u2082\u2081] [RingHomInvPair \u03c3\u2082\u2081 \u03c3\u2081\u2082] {hf} (x : M) :\n    ofBijective f hf x = f x", "start": [2117, 1], "end": [2120, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_neg", "code": "theorem map_neg (a : M) : e (-a) = -e a", "start": [2148, 1], "end": [2149, 26], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.map_sub", "code": "theorem map_sub (a b : M) : e (a - b) = e a - e b", "start": [2153, 1], "end": [2154, 28], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.neg", "code": "def neg : M \u2243\u2097[R] M :=\n  { Equiv.neg M, (-LinearMap.id : M \u2192\u2097[R] M) with }", "start": [2163, 1], "end": [2165, 52], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_neg", "code": "@[simp]\ntheorem coe_neg : \u21d1(neg R : M \u2243\u2097[R] M) = -id", "start": [2170, 1], "end": [2172, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.neg_apply", "code": "theorem neg_apply (x : M) : neg R x = -x", "start": [2175, 1], "end": [2175, 52], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_neg", "code": "@[simp]\ntheorem symm_neg : (neg R : M \u2243\u2097[R] M).symm = neg R", "start": [2178, 1], "end": [2180, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.smulOfUnit", "code": "def smulOfUnit (a : R\u02e3) : M \u2243\u2097[R] M :=\n  DistribMulAction.toLinearEquiv R M a", "start": [2193, 1], "end": [2195, 39], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.arrowCongr", "code": "def arrowCongr {R M\u2081 M\u2082 M\u2082\u2081 M\u2082\u2082 : Sort _} [CommSemiring R] [AddCommMonoid M\u2081] [AddCommMonoid M\u2082]\n    [AddCommMonoid M\u2082\u2081] [AddCommMonoid M\u2082\u2082] [Module R M\u2081] [Module R M\u2082] [Module R M\u2082\u2081]\n    [Module R M\u2082\u2082] (e\u2081 : M\u2081 \u2243\u2097[R] M\u2082) (e\u2082 : M\u2082\u2081 \u2243\u2097[R] M\u2082\u2082) : (M\u2081 \u2192\u2097[R] M\u2082\u2081) \u2243\u2097[R] M\u2082 \u2192\u2097[R] M\u2082\u2082\n    where\n  toFun := fun f : M\u2081 \u2192\u2097[R] M\u2082\u2081 => (e\u2082 : M\u2082\u2081 \u2192\u2097[R] M\u2082\u2082).comp <| f.comp (e\u2081.symm : M\u2082 \u2192\u2097[R] M\u2081)\n  invFun f := (e\u2082.symm : M\u2082\u2082 \u2192\u2097[R] M\u2082\u2081).comp <| f.comp (e\u2081 : M\u2081 \u2192\u2097[R] M\u2082)\n  left_inv f := by\n    ext x\n    simp only [symm_apply_apply, Function.comp_apply, coe_comp, coe_coe]\n  right_inv f := by\n    ext x\n    simp only [Function.comp_apply, apply_symm_apply, coe_comp, coe_coe]\n  map_add' f g := by\n    ext x\n    simp only [map_add, add_apply, Function.comp_apply, coe_comp, coe_coe]\n  map_smul' c f := by\n    ext x\n    simp only [smul_apply, Function.comp_apply, coe_comp, map_smul\u209b\u2097 e\u2082, coe_coe]", "start": [2198, 1], "end": [2217, 82], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.arrowCongr_apply", "code": "@[simp]\ntheorem arrowCongr_apply {R M\u2081 M\u2082 M\u2082\u2081 M\u2082\u2082 : Sort _} [CommSemiring R] [AddCommMonoid M\u2081]\n    [AddCommMonoid M\u2082] [AddCommMonoid M\u2082\u2081] [AddCommMonoid M\u2082\u2082] [Module R M\u2081] [Module R M\u2082]\n    [Module R M\u2082\u2081] [Module R M\u2082\u2082] (e\u2081 : M\u2081 \u2243\u2097[R] M\u2082) (e\u2082 : M\u2082\u2081 \u2243\u2097[R] M\u2082\u2082) (f : M\u2081 \u2192\u2097[R] M\u2082\u2081)\n    (x : M\u2082) : arrowCongr e\u2081 e\u2082 f x = e\u2082 (f (e\u2081.symm x))", "start": [2220, 1], "end": [2225, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.arrowCongr_symm_apply", "code": "@[simp]\ntheorem arrowCongr_symm_apply {R M\u2081 M\u2082 M\u2082\u2081 M\u2082\u2082 : Sort _} [CommSemiring R] [AddCommMonoid M\u2081]\n    [AddCommMonoid M\u2082] [AddCommMonoid M\u2082\u2081] [AddCommMonoid M\u2082\u2082] [Module R M\u2081] [Module R M\u2082]\n    [Module R M\u2082\u2081] [Module R M\u2082\u2082] (e\u2081 : M\u2081 \u2243\u2097[R] M\u2082) (e\u2082 : M\u2082\u2081 \u2243\u2097[R] M\u2082\u2082) (f : M\u2082 \u2192\u2097[R] M\u2082\u2082)\n    (x : M\u2081) : (arrowCongr e\u2081 e\u2082).symm f x = e\u2082.symm (f (e\u2081 x))", "start": [2228, 1], "end": [2233, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.arrowCongr_comp", "code": "theorem arrowCongr_comp {N N\u2082 N\u2083 : Sort _} [AddCommMonoid N] [AddCommMonoid N\u2082] [AddCommMonoid N\u2083]\n    [Module R N] [Module R N\u2082] [Module R N\u2083] (e\u2081 : M \u2243\u2097[R] N) (e\u2082 : M\u2082 \u2243\u2097[R] N\u2082) (e\u2083 : M\u2083 \u2243\u2097[R] N\u2083)\n    (f : M \u2192\u2097[R] M\u2082) (g : M\u2082 \u2192\u2097[R] M\u2083) :\n    arrowCongr e\u2081 e\u2083 (g.comp f) = (arrowCongr e\u2082 e\u2083 g).comp (arrowCongr e\u2081 e\u2082 f)", "start": [2236, 1], "end": [2241, 71], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.arrowCongr_trans", "code": "theorem arrowCongr_trans {M\u2081 M\u2082 M\u2083 N\u2081 N\u2082 N\u2083 : Sort _} [AddCommMonoid M\u2081] [Module R M\u2081]\n    [AddCommMonoid M\u2082] [Module R M\u2082] [AddCommMonoid M\u2083] [Module R M\u2083] [AddCommMonoid N\u2081]\n    [Module R N\u2081] [AddCommMonoid N\u2082] [Module R N\u2082] [AddCommMonoid N\u2083] [Module R N\u2083]\n    (e\u2081 : M\u2081 \u2243\u2097[R] M\u2082) (e\u2082 : N\u2081 \u2243\u2097[R] N\u2082) (e\u2083 : M\u2082 \u2243\u2097[R] M\u2083) (e\u2084 : N\u2082 \u2243\u2097[R] N\u2083) :\n    (arrowCongr e\u2081 e\u2082).trans (arrowCongr e\u2083 e\u2084) = arrowCongr (e\u2081.trans e\u2083) (e\u2082.trans e\u2084)", "start": [2244, 1], "end": [2249, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.congrRight", "code": "def congrRight (f : M\u2082 \u2243\u2097[R] M\u2083) : (M \u2192\u2097[R] M\u2082) \u2243\u2097[R] M \u2192\u2097[R] M\u2083 :=\n  arrowCongr (LinearEquiv.refl R M) f", "start": [2252, 1], "end": [2255, 38], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj", "code": "def conj (e : M \u2243\u2097[R] M\u2082) : Module.End R M \u2243\u2097[R] Module.End R M\u2082 :=\n  arrowCongr e e", "start": [2258, 1], "end": [2261, 17], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj_apply", "code": "theorem conj_apply (e : M \u2243\u2097[R] M\u2082) (f : Module.End R M) :\n    e.conj f = ((\u2191e : M \u2192\u2097[R] M\u2082).comp f).comp (e.symm : M\u2082 \u2192\u2097[R] M)", "start": [2264, 1], "end": [2266, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj_apply_apply", "code": "theorem conj_apply_apply (e : M \u2243\u2097[R] M\u2082) (f : Module.End R M) (x : M\u2082) :\n    e.conj f x = e (f (e.symm x))", "start": [2269, 1], "end": [2271, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.symm_conj_apply", "code": "theorem symm_conj_apply (e : M \u2243\u2097[R] M\u2082) (f : Module.End R M\u2082) :\n    e.symm.conj f = ((\u2191e.symm : M\u2082 \u2192\u2097[R] M).comp f).comp (e : M \u2192\u2097[R] M\u2082)", "start": [2274, 1], "end": [2276, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj_comp", "code": "theorem conj_comp (e : M \u2243\u2097[R] M\u2082) (f g : Module.End R M) :\n    e.conj (g.comp f) = (e.conj g).comp (e.conj f)", "start": [2279, 1], "end": [2281, 28], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj_trans", "code": "theorem conj_trans (e\u2081 : M \u2243\u2097[R] M\u2082) (e\u2082 : M\u2082 \u2243\u2097[R] M\u2083) :\n    e\u2081.conj.trans e\u2082.conj = (e\u2081.trans e\u2082).conj", "start": [2284, 1], "end": [2287, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.conj_id", "code": "@[simp]\ntheorem conj_id (e : M \u2243\u2097[R] M\u2082) : e.conj LinearMap.id = LinearMap.id", "start": [2290, 1], "end": [2293, 20], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.smulOfNeZero", "code": "@[simps!]\ndef smulOfNeZero (a : K) (ha : a \u2260 0) : M \u2243\u2097[K] M :=\n  smulOfUnit <| Units.mk0 a ha", "start": [2308, 1], "end": [2311, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.equivSubtypeMap", "code": "def equivSubtypeMap (p : Submodule R M) (q : Submodule R p) : q \u2243\u2097[R] q.map p.subtype :=\n  { (p.subtype.domRestrict q).codRestrict _ (by rintro \u27e8x, hx\u27e9; exact \u27e8x, hx, rfl\u27e9) with\n    invFun := by\n      rintro \u27e8x, hx\u27e9\n      refine' \u27e8\u27e8x, _\u27e9, _\u27e9 <;> rcases hx with \u27e8\u27e8_, h\u27e9, _, rfl\u27e9 <;> assumption\n    left_inv := fun \u27e8\u27e8_, _\u27e9, _\u27e9 => rfl\n    right_inv := fun \u27e8x, \u27e8_, h\u27e9, _, rfl\u27e9 => by ext; rfl }", "start": [2324, 1], "end": [2332, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.equivSubtypeMap_apply", "code": "@[simp]\ntheorem equivSubtypeMap_apply {p : Submodule R M} {q : Submodule R p} (x : q) :\n    (p.equivSubtypeMap q x : M) = p.subtype.domRestrict q x", "start": [2335, 1], "end": [2338, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.equivSubtypeMap_symm_apply", "code": "@[simp]\ntheorem equivSubtypeMap_symm_apply {p : Submodule R M} {q : Submodule R p} (x : q.map p.subtype) :\n    ((p.equivSubtypeMap q).symm x : M) = x", "start": [2341, 1], "end": [2345, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.comapSubtypeEquivOfLe", "code": "@[simps symm_apply]\ndef comapSubtypeEquivOfLe {p q : Submodule R M} (hpq : p \u2264 q) : comap q.subtype p \u2243\u2097[R] p where\n  toFun x := \u27e8x, x.2\u27e9\n  invFun x := \u27e8\u27e8x, hpq x.2\u27e9, x.2\u27e9\n  left_inv x := by simp only [coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  right_inv x := by simp only [Subtype.coe_mk, SetLike.eta, LinearEquiv.coe_coe]\n  map_add' x y := rfl\n  map_smul' c x := rfl", "start": [2348, 1], "end": [2357, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.comapSubtypeEquivOfLe_apply_coe", "code": "@[simp]\ntheorem comapSubtypeEquivOfLe_apply_coe {p q : Submodule R M} (hpq : p \u2264 q)\n    (x : comap q.subtype p) :\n    (comapSubtypeEquivOfLe hpq x : M) = (x : M)", "start": [2363, 1], "end": [2367, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_map_equiv", "code": "@[simp high]\ntheorem mem_map_equiv {e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {x : M\u2082} :\n    x \u2208 p.map (e : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) \u2194 e.symm x \u2208 p", "start": [2391, 1], "end": [2398, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_equiv_eq_comap_symm", "code": "theorem map_equiv_eq_comap_symm (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (K : Submodule R M) :\n    K.map (e : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) = K.comap (e.symm : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M)", "start": [2401, 1], "end": [2403, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_equiv_eq_map_symm", "code": "theorem comap_equiv_eq_map_symm (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (K : Submodule R\u2082 M\u2082) :\n    K.comap (e : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) = K.map (e.symm : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2081] M)", "start": [2406, 1], "end": [2408, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_symm_eq_iff", "code": "theorem map_symm_eq_iff (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {K : Submodule R\u2082 M\u2082} :\n    K.map e.symm = p \u2194 p.map e = K", "start": [2413, 1], "end": [2421, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.orderIsoMapComap_apply'", "code": "theorem orderIsoMapComap_apply' (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (p : Submodule R M) :\n    orderIsoMapComap e p = comap e.symm p", "start": [2424, 1], "end": [2426, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.orderIsoMapComap_symm_apply'", "code": "theorem orderIsoMapComap_symm_apply' (e : M \u2243\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (p : Submodule R\u2082 M\u2082) :\n    (orderIsoMapComap e).symm p = map e.symm p", "start": [2429, 1], "end": [2431, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.inf_comap_le_comap_add", "code": "theorem inf_comap_le_comap_add (f\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) :\n    comap f\u2081 q \u2293 comap f\u2082 q \u2264 comap (f\u2081 + f\u2082) q", "start": [2434, 1], "end": [2440, 26], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_le_comap_smul", "code": "theorem comap_le_comap_smul (f\u2097 : N \u2192\u2097[R] N\u2082) (c : R) : comap f\u2097 q\u2097 \u2264 comap (c \u2022 f\u2097) q\u2097", "start": [2461, 1], "end": [2466, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.compatibleMaps", "code": "def compatibleMaps : Submodule R (N \u2192\u2097[R] N\u2082) where\n  carrier := { f\u2097 | p\u2097 \u2264 comap f\u2097 q\u2097 }\n  zero_mem' := by\n    change p\u2097 \u2264 comap (0 : N \u2192\u2097[R] N\u2082) q\u2097\n    rw [comap_zero]\n    refine' le_top\n  add_mem' {f\u2081 f\u2082} h\u2081 h\u2082 := by\n    apply le_trans _ (inf_comap_le_comap_add q\u2097 f\u2081 f\u2082)\n    rw [le_inf_iff]\n    exact \u27e8h\u2081, h\u2082\u27e9\n  smul_mem' c f\u2097 h := by\n    dsimp at h\n    exact le_trans h (comap_le_comap_smul q\u2097 f\u2097 c)", "start": [2469, 1], "end": [2483, 51], "kind": "commanddeclaration"}, {"full_name": "Equiv.toLinearEquiv", "code": "def toLinearEquiv (e : M \u2243 M\u2082) (h : IsLinearMap R (e : M \u2192 M\u2082)) : M \u2243\u2097[R] M\u2082 :=\n  { e, h.mk' e with }", "start": [2492, 1], "end": [2494, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft", "code": "def funLeft (f : m \u2192 n) : (n \u2192 M) \u2192\u2097[R] m \u2192 M where\n  toFun := (\u00b7 \u2218 f)\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [2507, 1], "end": [2512, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft_apply", "code": "@[simp]\ntheorem funLeft_apply (f : m \u2192 n) (g : n \u2192 M) (i : m) : funLeft R M f g i = g (f i)", "start": [2515, 1], "end": [2517, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft_id", "code": "@[simp]\ntheorem funLeft_id (g : n \u2192 M) : funLeft R M _root_.id g = g", "start": [2520, 1], "end": [2522, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft_comp", "code": "theorem funLeft_comp (f\u2081 : n \u2192 p) (f\u2082 : m \u2192 n) :\n    funLeft R M (f\u2081 \u2218 f\u2082) = (funLeft R M f\u2082).comp (funLeft R M f\u2081)", "start": [2525, 1], "end": [2527, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft_surjective_of_injective", "code": "theorem funLeft_surjective_of_injective (f : m \u2192 n) (hf : Injective f) :\n    Surjective (funLeft R M f)", "start": [2530, 1], "end": [2540, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.funLeft_injective_of_surjective", "code": "theorem funLeft_injective_of_surjective (f : m \u2192 n) (hf : Surjective f) :\n    Injective (funLeft R M f)", "start": [2543, 1], "end": [2548, 65], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funCongrLeft", "code": "def funCongrLeft (e : m \u2243 n) : (n \u2192 M) \u2243\u2097[R] m \u2192 M :=\n  LinearEquiv.ofLinear (funLeft R M e) (funLeft R M e.symm)\n    (LinearMap.ext fun x =>\n      funext fun i => by rw [id_apply, \u2190 funLeft_comp, Equiv.symm_comp_self, LinearMap.funLeft_id])\n    (LinearMap.ext fun x =>\n      funext fun i => by rw [id_apply, \u2190 funLeft_comp, Equiv.self_comp_symm, LinearMap.funLeft_id])", "start": [2557, 1], "end": [2564, 100], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funCongrLeft_apply", "code": "@[simp]\ntheorem funCongrLeft_apply (e : m \u2243 n) (x : n \u2192 M) : funCongrLeft R M e x = funLeft R M e x", "start": [2567, 1], "end": [2569, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funCongrLeft_id", "code": "@[simp]\ntheorem funCongrLeft_id : funCongrLeft R M (Equiv.refl n) = LinearEquiv.refl R (n \u2192 M)", "start": [2572, 1], "end": [2574, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funCongrLeft_comp", "code": "@[simp]\ntheorem funCongrLeft_comp (e\u2081 : m \u2243 n) (e\u2082 : n \u2243 p) :\n    funCongrLeft R M (Equiv.trans e\u2081 e\u2082) =\n      LinearEquiv.trans (funCongrLeft R M e\u2082) (funCongrLeft R M e\u2081)", "start": [2577, 1], "end": [2581, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funCongrLeft_symm", "code": "@[simp]\ntheorem funCongrLeft_symm (e : m \u2243 n) : (funCongrLeft R M e).symm = funCongrLeft R M e.symm", "start": [2584, 1], "end": [2586, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/SuccPred.lean", "imports": ["Mathlib/Data/Fin/Basic.lean", "Mathlib/Order/SuccPred/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.succ_eq_succ", "code": "@[simp]\ntheorem succ_eq_succ : Order.succ = succ", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_eq_pred", "code": "@[simp]\ntheorem pred_eq_pred : Order.pred = pred", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_iterate", "code": "theorem succ_iterate (a : \u2115) : \u2200 n, succ^[n] a = a + n", "start": [55, 1], "end": [59, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_iterate", "code": "theorem pred_iterate (a : \u2115) : \u2200 n, pred^[n] a = a - n", "start": [62, 1], "end": [66, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.forall_ne_zero_iff", "code": "lemma forall_ne_zero_iff (P : \u2115 \u2192 Prop) :\n    (\u2200 i, i \u2260 0 \u2192 P i) \u2194 (\u2200 i, P (i + 1)) :=\n  SuccOrder.forall_ne_bot_iff P", "start": [75, 1], "end": [77, 32], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.covby_iff_succ_eq", "code": "protected theorem covby_iff_succ_eq {m n : \u2115} : m \u22d6 n \u2194 m + 1 = n", "start": [82, 1], "end": [83, 25], "kind": "commanddeclaration"}, {"full_name": "Fin.coe_covby_iff", "code": "@[simp, norm_cast]\ntheorem Fin.coe_covby_iff {n : \u2115} {a b : Fin n} : (a : \u2115) \u22d6 b \u2194 a \u22d6 b", "start": [88, 1], "end": [90, 89], "kind": "commanddeclaration"}, {"full_name": "Covby.coe_fin", "code": "alias \u27e8_, Covby.coe_fin\u27e9 := Fin.coe_covby_iff", "start": [93, 1], "end": [93, 46], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Algebra/Order/Sub/WithTop.lean", "imports": ["Mathlib/Algebra/Order/Monoid/WithTop.lean", "Mathlib/Algebra/Order/Sub/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithTop.sub", "code": "protected def sub : \u2200 _ _ : WithTop \u03b1, WithTop \u03b1\n  | _, \u22a4 => 0\n  | \u22a4, (x : \u03b1) => \u22a4\n  | (x : \u03b1), (y : \u03b1) => (x - y : \u03b1)", "start": [24, 1], "end": [28, 36], "kind": "commanddeclaration"}, {"full_name": "WithTop.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub {a b : \u03b1} : (\u2191(a - b) : WithTop \u03b1) = \u2191a - \u2191b", "start": [34, 1], "end": [36, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.top_sub_coe", "code": "@[simp]\ntheorem top_sub_coe {a : \u03b1} : (\u22a4 : WithTop \u03b1) - a = \u22a4", "start": [39, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.sub_top", "code": "@[simp]\ntheorem sub_top {a : WithTop \u03b1} : a - \u22a4 = 0", "start": [44, 1], "end": [45, 66], "kind": "commanddeclaration"}, {"full_name": "WithTop.sub_eq_top_iff", "code": "@[simp] theorem sub_eq_top_iff {a b : WithTop \u03b1} : a - b = \u22a4 \u2194 a = \u22a4 \u2227 b \u2260 \u22a4", "start": [48, 1], "end": [51, 14], "kind": "commanddeclaration"}, {"full_name": "WithTop.map_sub", "code": "theorem map_sub [Sub \u03b2] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : \u2200 x y, f (x - y) = f x - f y) (h\u2080 : f 0 = 0) :\n    \u2200 x y : WithTop \u03b1, (x - y).map f = x.map f - y.map f", "start": [54, 1], "end": [58, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/MulOpposite.lean", "imports": ["Mathlib/Algebra/Group/Opposite.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submonoid.op", "code": "@[to_additive (attr := simps) \"Pull an additive submonoid back to an opposite submonoid along\n`AddOpposite.unop`\"]\nprotected def op {M : Type*} [MulOneClass M] (x : Submonoid M) : Submonoid (MulOpposite M) where\n  carrier := MulOpposite.unop \u207b\u00b9' x.1\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _", "start": [20, 1], "end": [26, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.unop", "code": "@[to_additive (attr := simps) \"Pull an opposite additive submonoid back to a submonoid along\n`AddOpposite.op`\"]\nprotected def unop {M : Type*} [MulOneClass M] (x : Submonoid (MulOpposite M)) : Submonoid M where\n  carrier := MulOpposite.op \u207b\u00b9' x.1\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _", "start": [28, 1], "end": [34, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.opEquiv", "code": "@[to_additive (attr := simps) \"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `G\u1d50\u1d52\u1d56`.\"]\ndef opEquiv : Submonoid M \u2243 Submonoid M\u1d50\u1d52\u1d56 where\n  toFun := Submonoid.op\n  invFun := Submonoid.unop\n  left_inv _ := SetLike.coe_injective rfl\n  right_inv _ := SetLike.coe_injective rfl", "start": [36, 1], "end": [43, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.equivOp", "code": "@[to_additive (attr := simps!) \"Bijection between an additive submonoid `H` and its opposite.\"]\ndef equivOp (H : Submonoid M) : H \u2243 H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl", "start": [45, 1], "end": [48, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/Actions.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.smul_def", "code": "@[to_additive]\ntheorem smul_def [MulAction G \u03b1] {S : Subgroup G} (g : S) (m : \u03b1) : g \u2022 m = (g : G) \u2022 m", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smulCommClass_left", "code": "@[to_additive]\ninstance smulCommClass_left [MulAction G \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass G \u03b1 \u03b2] (S : Subgroup G) :\n    SMulCommClass S \u03b1 \u03b2 :=\n  S.toSubmonoid.smulCommClass_left", "start": [38, 1], "end": [41, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smulCommClass_right", "code": "@[to_additive]\ninstance smulCommClass_right [SMul \u03b1 \u03b2] [MulAction G \u03b2] [SMulCommClass \u03b1 G \u03b2] (S : Subgroup G) :\n    SMulCommClass \u03b1 S \u03b2 :=\n  S.toSubmonoid.smulCommClass_right", "start": [45, 1], "end": [48, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center.smulCommClass_left", "code": "instance center.smulCommClass_left : SMulCommClass (center G) G G :=\n  Submonoid.center.smulCommClass_left", "start": [68, 1], "end": [70, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center.smulCommClass_right", "code": "instance center.smulCommClass_right : SMulCommClass G (center G) G :=\n  Submonoid.center.smulCommClass_right", "start": [73, 1], "end": [75, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.zpowers", "code": "def zpowers (g : G) : Subgroup G :=\n  Subgroup.copy (zpowersHom G g).range (Set.range ((\u00b7 ^ \u00b7) g : \u2124 \u2192 G)) rfl", "start": [27, 1], "end": [29, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_zpowers", "code": "theorem mem_zpowers (g : G) : g \u2208 zpowers g", "start": [32, 1], "end": [33, 18], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_zpowers", "code": "theorem coe_zpowers (g : G) : \u2191(zpowers g) = Set.range (g ^ \u00b7 : \u2124 \u2192 G)", "start": [36, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_eq_closure", "code": "theorem zpowers_eq_closure (g : G) : zpowers g = closure {g}", "start": [40, 1], "end": [42, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.range_zpowersHom", "code": "theorem range_zpowersHom (g : G) : (zpowersHom G g).range = zpowers g", "start": [45, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_zpowers_iff", "code": "theorem mem_zpowers_iff {g h : G} : h \u2208 zpowers g \u2194 \u2203 k : \u2124, g ^ k = h", "start": [49, 1], "end": [50, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpow_mem_zpowers", "code": "theorem zpow_mem_zpowers (g : G) (k : \u2124) : g ^ k \u2208 zpowers g", "start": [53, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.npow_mem_zpowers", "code": "theorem npow_mem_zpowers (g : G) (k : \u2115) : g ^ k \u2208 zpowers g", "start": [57, 1], "end": [58, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.forall_zpowers", "code": "theorem forall_zpowers {x : G} {p : zpowers x \u2192 Prop} : (\u2200 g, p g) \u2194 \u2200 m : \u2124, p \u27e8x ^ m, m, rfl\u27e9", "start": [61, 1], "end": [62, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_zpowers", "code": "theorem exists_zpowers {x : G} {p : zpowers x \u2192 Prop} : (\u2203 g, p g) \u2194 \u2203 m : \u2124, p \u27e8x ^ m, m, rfl\u27e9", "start": [65, 1], "end": [66, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.forall_mem_zpowers", "code": "theorem forall_mem_zpowers {x : G} {p : G \u2192 Prop} : (\u2200 g \u2208 zpowers x, p g) \u2194 \u2200 m : \u2124, p (x ^ m)", "start": [69, 1], "end": [70, 23], "kind": "commanddeclaration"}, {"full_name": "Subgroup.exists_mem_zpowers", "code": "theorem exists_mem_zpowers {x : G} {p : G \u2192 Prop} : (\u2203 g \u2208 zpowers x, p g) \u2194 \u2203 m : \u2124, p (x ^ m)", "start": [73, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.zmultiples", "code": "def zmultiples (a : A) : AddSubgroup A :=\n  AddSubgroup.copy (zmultiplesHom A a).range (Set.range ((\u00b7 \u2022 a) : \u2124 \u2192 A)) rfl", "start": [84, 1], "end": [86, 79], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.range_zmultiplesHom", "code": "@[simp]\ntheorem range_zmultiplesHom (a : A) : (zmultiplesHom A a).range = zmultiples a", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.int_cast_mul_mem_zmultiples", "code": "@[simp]\ntheorem int_cast_mul_mem_zmultiples : \u2191(k : \u2124) * r \u2208 zmultiples r", "start": [137, 1], "end": [139, 61], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.int_cast_mem_zmultiples_one", "code": "@[simp]\ntheorem int_cast_mem_zmultiples_one : \u2191(k : \u2124) \u2208 zmultiples (1 : R)", "start": [142, 1], "end": [144, 37], "kind": "commanddeclaration"}, {"full_name": "Int.range_castAddHom", "code": "@[simp] lemma Int.range_castAddHom {A : Type*} [AddGroupWithOne A] :\n    (Int.castAddHom A).range = AddSubgroup.zmultiples 1 := by\n  ext a\n  simp_rw [AddMonoidHom.mem_range, Int.coe_castAddHom, AddSubgroup.mem_zmultiples_iff, zsmul_one]", "start": [151, 1], "end": [154, 98], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.map_zpowers", "code": "@[to_additive (attr := simp) map_zmultiples]\ntheorem MonoidHom.map_zpowers (f : G \u2192* N) (x : G) :\n    (Subgroup.zpowers x).map f = Subgroup.zpowers (f x)", "start": [156, 1], "end": [159, 100], "kind": "commanddeclaration"}, {"full_name": "Int.mem_zmultiples_iff", "code": "theorem Int.mem_zmultiples_iff {a b : \u2124} : b \u2208 AddSubgroup.zmultiples a \u2194 a \u2223 b", "start": [163, 1], "end": [164, 65], "kind": "commanddeclaration"}, {"full_name": "ofMul_image_zpowers_eq_zmultiples_ofMul", "code": "theorem ofMul_image_zpowers_eq_zmultiples_ofMul {x : G} :\n    Additive.ofMul '' (Subgroup.zpowers x : Set G) = AddSubgroup.zmultiples (Additive.ofMul x)", "start": [167, 1], "end": [177, 21], "kind": "commanddeclaration"}, {"full_name": "ofAdd_image_zmultiples_eq_zpowers_ofAdd", "code": "theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\n    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\n      Subgroup.zpowers (Multiplicative.ofAdd x)", "start": [180, 1], "end": [185, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_isCommutative", "code": "@[to_additive zmultiples_isCommutative]\ninstance zpowers_isCommutative (g : G) : (zpowers g).IsCommutative :=\n  \u27e8\u27e8fun \u27e8_, _, h\u2081\u27e9 \u27e8_, _, h\u2082\u27e9 => by\n      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, \u2190 h\u2081, \u2190 h\u2082,\n        zpow_mul_comm]\u27e9\u27e9", "start": [192, 1], "end": [196, 25], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_le", "code": "@[to_additive (attr := simp) zmultiples_le]\ntheorem zpowers_le {g : G} {H : Subgroup G} : zpowers g \u2264 H \u2194 g \u2208 H", "start": [200, 1], "end": [202, 81], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_le_of_mem", "code": "alias \u27e8_, zpowers_le_of_mem\u27e9 := zpowers_le", "start": [206, 1], "end": [206, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AddSubgroup.zmultiples_le_of_mem", "code": "alias \u27e8_, _root_.AddSubgroup.zmultiples_le_of_mem\u27e9 := AddSubgroup.zmultiples_le", "start": [209, 1], "end": [209, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Subgroup.zpowers_eq_bot", "code": "@[to_additive (attr := simp) zmultiples_eq_bot]\ntheorem zpowers_eq_bot {g : G} : zpowers g = \u22a5 \u2194 g = 1", "start": [214, 1], "end": [215, 98], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_ne_bot", "code": "@[to_additive zmultiples_ne_bot]\ntheorem zpowers_ne_bot : zpowers g \u2260 \u22a5 \u2194 g \u2260 1", "start": [219, 1], "end": [221, 21], "kind": "commanddeclaration"}, {"full_name": "Subgroup.zpowers_one_eq_bot", "code": "@[to_additive (attr := simp) zmultiples_zero_eq_bot]\ntheorem zpowers_one_eq_bot : Subgroup.zpowers (1 : G) = \u22a5", "start": [225, 1], "end": [227, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.centralizer_closure", "code": "@[to_additive]\ntheorem centralizer_closure (S : Set G) :\n    centralizer (closure S : Set G) = \u2a05 g \u2208 S, centralizer (zpowers g : Set G)", "start": [231, 1], "end": [238, 94], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center_eq_iInf", "code": "@[to_additive]\ntheorem center_eq_iInf (S : Set G) (hS : closure S = \u22a4) :\n    center G = \u2a05 g \u2208 S, centralizer (zpowers g)", "start": [242, 1], "end": [245, 64], "kind": "commanddeclaration"}, {"full_name": "Subgroup.center_eq_infi'", "code": "@[to_additive]\ntheorem center_eq_infi' (S : Set G) (hS : closure S = \u22a4) :\n    center G = \u2a05 g : S, centralizer (zpowers (g : G))", "start": [249, 1], "end": [252, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/WellFoundedSet.lean", "imports": ["Mathlib/Init/Data/Sigma/Lex.lean", "Mathlib/Data/Sigma/Lex.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Order/OrderIsoNat.lean", "Mathlib/Order/Antichain.lean", "Mathlib/Order/WellFounded.lean"], "premises": [{"full_name": "Set.WellFoundedOn", "code": "def WellFoundedOn (s : Set \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop :=\n  WellFounded fun a b : s => r a b", "start": [57, 1], "end": [59, 35], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_empty", "code": "@[simp]\ntheorem wellFoundedOn_empty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : WellFoundedOn \u2205 r", "start": [62, 1], "end": [64, 27], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_iff", "code": "theorem wellFoundedOn_iff :\n    s.WellFoundedOn r \u2194 WellFounded fun a b : \u03b1 => r a b \u2227 a \u2208 s \u2227 b \u2208 s", "start": [75, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_univ", "code": "@[simp]\ntheorem wellFoundedOn_univ : (univ : Set \u03b1).WellFoundedOn r \u2194 WellFounded r", "start": [90, 1], "end": [92, 27], "kind": "commanddeclaration"}, {"full_name": "WellFounded.wellFoundedOn", "code": "theorem _root_.WellFounded.wellFoundedOn : WellFounded r \u2192 s.WellFoundedOn r", "start": [95, 1], "end": [96, 16], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_range", "code": "@[simp]\ntheorem wellFoundedOn_range : (range f).WellFoundedOn r \u2194 WellFounded (r on f)", "start": [99, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_image", "code": "@[simp]\ntheorem wellFoundedOn_image {s : Set \u03b2} : (f '' s).WellFoundedOn r \u2194 s.WellFoundedOn (r on f)", "start": [110, 1], "end": [112, 49], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.induction", "code": "protected theorem induction (hs : s.WellFoundedOn r) (hx : x \u2208 s) {P : \u03b1 \u2192 Prop}\n    (hP : \u2200 y \u2208 s, (\u2200 z \u2208 s, r z y \u2192 P z) \u2192 P y) : P x", "start": [117, 1], "end": [122, 30], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.mono", "code": "protected theorem mono (h : t.WellFoundedOn r') (hle : r \u2264 r') (hst : s \u2286 t) :\n    s.WellFoundedOn r", "start": [125, 1], "end": [128, 76], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.mono'", "code": "theorem mono' (h : \u2200 (a) (_ : a \u2208 s) (b) (_ : b \u2208 s), r' a b \u2192 r a b) :\n    s.WellFoundedOn r \u2192 s.WellFoundedOn r'", "start": [131, 1], "end": [133, 43], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.subset", "code": "theorem subset (h : t.WellFoundedOn r) (hst : s \u2286 t) : s.WellFoundedOn r", "start": [136, 1], "end": [137, 20], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.acc_iff_wellFoundedOn", "code": "theorem acc_iff_wellFoundedOn {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {a : \u03b1} :\n    TFAE [Acc r a,\n      WellFoundedOn { b | ReflTransGen r b a } r,\n      WellFoundedOn { b | TransGen r b a } r]", "start": [143, 1], "end": [160, 14], "kind": "commanddeclaration"}, {"full_name": "Set.IsStrictOrder.subset", "code": "instance IsStrictOrder.subset : IsStrictOrder \u03b1 fun a b : \u03b1 => r a b \u2227 a \u2208 s \u2227 b \u2208 s where\n  toIsIrrefl := \u27e8fun a con => irrefl_of r a con.1\u27e9\n  toIsTrans := \u27e8fun _ _ _ ab bc => \u27e8trans_of r ab.1 bc.1, ab.2.1, bc.2.2\u27e9\u27e9", "start": [171, 1], "end": [173, 75], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_iff_no_descending_seq", "code": "theorem wellFoundedOn_iff_no_descending_seq :\n    s.WellFoundedOn r \u2194 \u2200 f : ((\u00b7 > \u00b7) : \u2115 \u2192 \u2115 \u2192 Prop) \u21aar r, \u00ac\u2200 n, f n \u2208 s", "start": [176, 1], "end": [187, 45], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.union", "code": "theorem WellFoundedOn.union (hs : s.WellFoundedOn r) (ht : t.WellFoundedOn r) :\n    (s \u222a t).WellFoundedOn r", "start": [190, 1], "end": [195, 82], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_union", "code": "@[simp]\ntheorem wellFoundedOn_union : (s \u222a t).WellFoundedOn r \u2194 s.WellFoundedOn r \u2227 t.WellFoundedOn r", "start": [198, 1], "end": [201, 19], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf", "code": "def IsWf (s : Set \u03b1) : Prop :=\n  WellFoundedOn s (\u00b7 < \u00b7)", "start": [214, 1], "end": [216, 26], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_empty", "code": "@[simp]\ntheorem isWf_empty : IsWf (\u2205 : Set \u03b1)", "start": [219, 1], "end": [221, 27], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_univ_iff", "code": "theorem isWf_univ_iff : IsWf (univ : Set \u03b1) \u2194 WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [224, 1], "end": [225, 33], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.mono", "code": "theorem IsWf.mono (h : IsWf t) (st : s \u2286 t) : IsWf s", "start": [228, 1], "end": [228, 68], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.union", "code": "protected nonrec theorem IsWf.union (hs : IsWf s) (ht : IsWf t) : IsWf (s \u222a t)", "start": [237, 1], "end": [237, 94], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_union", "code": "@[simp] theorem isWf_union : IsWf (s \u222a t) \u2194 IsWf s \u2227 IsWf t", "start": [240, 1], "end": [240, 83], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_iff_no_descending_seq", "code": "theorem isWf_iff_no_descending_seq :\n    IsWf s \u2194 \u2200 f : \u2115 \u2192 \u03b1, StrictAnti f \u2192 \u00ac\u2200 n, f (OrderDual.toDual n) \u2208 s", "start": [249, 1], "end": [252, 99], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn", "code": "def PartiallyWellOrderedOn (s : Set \u03b1) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Prop :=\n  \u2200 f : \u2115 \u2192 \u03b1, (\u2200 n, f n \u2208 s) \u2192 \u2203 m n : \u2115, m < n \u2227 r (f m) (f n)", "start": [266, 1], "end": [269, 65], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.mono", "code": "theorem PartiallyWellOrderedOn.mono (ht : t.PartiallyWellOrderedOn r) (h : s \u2286 t) :\n    s.PartiallyWellOrderedOn r", "start": [276, 1], "end": [277, 70], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_empty", "code": "@[simp]\ntheorem partiallyWellOrderedOn_empty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : PartiallyWellOrderedOn \u2205 r", "start": [280, 1], "end": [282, 13], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.union", "code": "theorem PartiallyWellOrderedOn.union (hs : s.PartiallyWellOrderedOn r)\n    (ht : t.PartiallyWellOrderedOn r) : (s \u222a t).PartiallyWellOrderedOn r", "start": [285, 1], "end": [292, 43], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_union", "code": "@[simp]\ntheorem partiallyWellOrderedOn_union :\n    (s \u222a t).PartiallyWellOrderedOn r \u2194 s.PartiallyWellOrderedOn r \u2227 t.PartiallyWellOrderedOn r", "start": [295, 1], "end": [299, 19], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.image_of_monotone_on", "code": "theorem PartiallyWellOrderedOn.image_of_monotone_on (hs : s.PartiallyWellOrderedOn r)\n    (hf : \u2200 a\u2081 \u2208 s, \u2200 a\u2082 \u2208 s, r a\u2081 a\u2082 \u2192 r' (f a\u2081) (f a\u2082)) : (f '' s).PartiallyWellOrderedOn r'", "start": [302, 1], "end": [308, 48], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.finite_of_partiallyWellOrderedOn", "code": "theorem _root_.IsAntichain.finite_of_partiallyWellOrderedOn (ha : IsAntichain r s)\n    (hp : s.PartiallyWellOrderedOn r) : s.Finite", "start": [311, 1], "end": [316, 61], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.partiallyWellOrderedOn", "code": "protected theorem Finite.partiallyWellOrderedOn (hs : s.Finite) : s.PartiallyWellOrderedOn r", "start": [323, 1], "end": [326, 43], "kind": "commanddeclaration"}, {"full_name": "IsAntichain.partiallyWellOrderedOn_iff", "code": "theorem _root_.IsAntichain.partiallyWellOrderedOn_iff (hs : IsAntichain r s) :\n    s.PartiallyWellOrderedOn r \u2194 s.Finite", "start": [329, 1], "end": [331, 71], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_singleton", "code": "@[simp]\ntheorem partiallyWellOrderedOn_singleton (a : \u03b1) : PartiallyWellOrderedOn {a} r", "start": [334, 1], "end": [336, 46], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.partiallyWellOrderedOn", "code": "@[nontriviality]\ntheorem Subsingleton.partiallyWellOrderedOn (hs : s.Subsingleton) : PartiallyWellOrderedOn s r", "start": [339, 1], "end": [341, 35], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_insert", "code": "@[simp]\ntheorem partiallyWellOrderedOn_insert :\n    PartiallyWellOrderedOn (insert a s) r \u2194 PartiallyWellOrderedOn s r", "start": [343, 1], "end": [347, 52], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.insert", "code": "protected theorem PartiallyWellOrderedOn.insert (h : PartiallyWellOrderedOn s r) (a : \u03b1) :\n    PartiallyWellOrderedOn (insert a s) r", "start": [350, 1], "end": [352, 36], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_iff_finite_antichains", "code": "theorem partiallyWellOrderedOn_iff_finite_antichains [IsSymm \u03b1 r] :\n    s.PartiallyWellOrderedOn r \u2194 \u2200 t, t \u2286 s \u2192 IsAntichain r t \u2192 t.Finite", "start": [355, 1], "end": [372, 28], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.exists_monotone_subseq", "code": "theorem PartiallyWellOrderedOn.exists_monotone_subseq (h : s.PartiallyWellOrderedOn r) (f : \u2115 \u2192 \u03b1)\n    (hf : \u2200 n, f n \u2208 s) : \u2203 g : \u2115 \u21aao \u2115, \u2200 m n : \u2115, m \u2264 n \u2192 r (f (g m)) (f (g n))", "start": [377, 1], "end": [385, 25], "kind": "commanddeclaration"}, {"full_name": "Set.partiallyWellOrderedOn_iff_exists_monotone_subseq", "code": "theorem partiallyWellOrderedOn_iff_exists_monotone_subseq :\n    s.PartiallyWellOrderedOn r \u2194\n      \u2200 f : \u2115 \u2192 \u03b1, (\u2200 n, f n \u2208 s) \u2192 \u2203 g : \u2115 \u21aao \u2115, \u2200 m n : \u2115, m \u2264 n \u2192 r (f (g m)) (f (g n))", "start": [388, 1], "end": [394, 70], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.prod", "code": "protected theorem PartiallyWellOrderedOn.prod {t : Set \u03b2} (hs : PartiallyWellOrderedOn s r)\n    (ht : PartiallyWellOrderedOn t r') :\n    PartiallyWellOrderedOn (s \u00d7\u02e2 t) fun x y : \u03b1 \u00d7 \u03b2 => r x.1 y.1 \u2227 r' x.2 y.2", "start": [397, 1], "end": [403, 60], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.wellFoundedOn", "code": "theorem PartiallyWellOrderedOn.wellFoundedOn [IsPreorder \u03b1 r] (h : s.PartiallyWellOrderedOn r) :\n    s.WellFoundedOn fun a b => r a b \u2227 \u00acr b a", "start": [408, 1], "end": [419, 41], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo", "code": "def IsPwo (s : Set \u03b1) : Prop :=\n  PartiallyWellOrderedOn s (\u00b7 \u2264 \u00b7)", "start": [428, 1], "end": [431, 35], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.mono", "code": "nonrec theorem IsPwo.mono (ht : t.IsPwo) : s \u2286 t \u2192 s.IsPwo", "start": [434, 1], "end": [434, 70], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.exists_monotone_subseq", "code": "nonrec theorem IsPwo.exists_monotone_subseq (h : s.IsPwo) (f : \u2115 \u2192 \u03b1) (hf : \u2200 n, f n \u2208 s) :\n    \u2203 g : \u2115 \u21aao \u2115, Monotone (f \u2218 g)", "start": [437, 1], "end": [439, 32], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_iff_exists_monotone_subseq", "code": "theorem isPwo_iff_exists_monotone_subseq :\n    s.IsPwo \u2194 \u2200 f : \u2115 \u2192 \u03b1, (\u2200 n, f n \u2208 s) \u2192 \u2203 g : \u2115 \u21aao \u2115, Monotone (f \u2218 g)", "start": [442, 1], "end": [444, 52], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.isWf", "code": "protected theorem IsPwo.isWf (h : s.IsPwo) : s.IsWf", "start": [447, 1], "end": [448, 56], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.prod", "code": "nonrec theorem IsPwo.prod {t : Set \u03b2} (hs : s.IsPwo) (ht : t.IsPwo) : IsPwo (s \u00d7\u02e2 t)", "start": [451, 1], "end": [452, 13], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.image_of_monotoneOn", "code": "theorem IsPwo.image_of_monotoneOn (hs : s.IsPwo) {f : \u03b1 \u2192 \u03b2} (hf : MonotoneOn f s) :\n    IsPwo (f '' s)", "start": [455, 1], "end": [457, 29], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.image_of_monotone", "code": "theorem IsPwo.image_of_monotone (hs : s.IsPwo) {f : \u03b1 \u2192 \u03b2} (hf : Monotone f) : IsPwo (f '' s)", "start": [460, 1], "end": [461, 44], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.union", "code": "protected nonrec theorem IsPwo.union (hs : IsPwo s) (ht : IsPwo t) : IsPwo (s \u222a t)", "start": [464, 1], "end": [465, 14], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_union", "code": "@[simp]\ntheorem isPwo_union : IsPwo (s \u222a t) \u2194 IsPwo s \u2227 IsPwo t", "start": [468, 1], "end": [470, 31], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isPwo", "code": "protected theorem Finite.isPwo (hs : s.Finite) : IsPwo s", "start": [473, 1], "end": [473, 86], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_of_finite", "code": "@[simp] theorem isPwo_of_finite [Finite \u03b1] : s.IsPwo", "start": [476, 1], "end": [476, 73], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_singleton", "code": "@[simp] theorem isPwo_singleton (a : \u03b1) : IsPwo ({a} : Set \u03b1)", "start": [479, 1], "end": [479, 92], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_empty", "code": "@[simp] theorem isPwo_empty : IsPwo (\u2205 : Set \u03b1)", "start": [482, 1], "end": [482, 70], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isPwo", "code": "protected theorem Subsingleton.isPwo (hs : s.Subsingleton) : IsPwo s", "start": [485, 1], "end": [485, 88], "kind": "commanddeclaration"}, {"full_name": "Set.isPwo_insert", "code": "@[simp]\ntheorem isPwo_insert {a} : IsPwo (insert a s) \u2194 IsPwo s", "start": [488, 1], "end": [490, 76], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.insert", "code": "protected theorem IsPwo.insert (h : IsPwo s) (a : \u03b1) : IsPwo (insert a s)", "start": [493, 1], "end": [494, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isWf", "code": "protected theorem Finite.isWf (hs : s.Finite) : IsWf s", "start": [497, 1], "end": [497, 72], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_singleton", "code": "@[simp] theorem isWf_singleton {a : \u03b1} : IsWf ({a} : Set \u03b1)", "start": [500, 1], "end": [500, 89], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isWf", "code": "protected theorem Subsingleton.isWf (hs : s.Subsingleton) : IsWf s", "start": [503, 1], "end": [503, 84], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_insert", "code": "@[simp]\ntheorem isWf_insert {a} : IsWf (insert a s) \u2194 IsWf s", "start": [506, 1], "end": [508, 74], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.insert", "code": "protected theorem IsWf.insert (h : IsWf s) (a : \u03b1) : IsWf (insert a s)", "start": [511, 1], "end": [512, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.wellFoundedOn", "code": "protected theorem Finite.wellFoundedOn (hs : s.Finite) : s.WellFoundedOn r", "start": [521, 1], "end": [523, 10], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_singleton", "code": "@[simp]\ntheorem wellFoundedOn_singleton : WellFoundedOn ({a} : Set \u03b1) r", "start": [526, 1], "end": [528, 37], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.wellFoundedOn", "code": "protected theorem Subsingleton.wellFoundedOn (hs : s.Subsingleton) : s.WellFoundedOn r", "start": [531, 1], "end": [532, 26], "kind": "commanddeclaration"}, {"full_name": "Set.wellFoundedOn_insert", "code": "@[simp]\ntheorem wellFoundedOn_insert : WellFoundedOn (insert a s) r \u2194 WellFoundedOn s r", "start": [535, 1], "end": [537, 92], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.insert", "code": "protected theorem WellFoundedOn.insert (h : WellFoundedOn s r) (a : \u03b1) :\n    WellFoundedOn (insert a s) r", "start": [540, 1], "end": [542, 27], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.isPwo", "code": "protected theorem IsWf.isPwo (hs : s.IsWf) : s.IsPwo", "start": [551, 1], "end": [556, 39], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_iff_isPwo", "code": "theorem isWf_iff_isPwo : s.IsWf \u2194 s.IsPwo", "start": [559, 1], "end": [561, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.partiallyWellOrderedOn", "code": "@[simp]\nprotected theorem partiallyWellOrderedOn [IsRefl \u03b1 r] (s : Finset \u03b1) :\n    (s : Set \u03b1).PartiallyWellOrderedOn r", "start": [572, 1], "end": [575, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.isPwo", "code": "@[simp]\nprotected theorem isPwo [Preorder \u03b1] (s : Finset \u03b1) : Set.IsPwo (\u2191s : Set \u03b1)", "start": [578, 1], "end": [580, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.isWf", "code": "@[simp]\nprotected theorem isWf [Preorder \u03b1] (s : Finset \u03b1) : Set.IsWf (\u2191s : Set \u03b1)", "start": [583, 1], "end": [585, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.wellFoundedOn", "code": "@[simp]\nprotected theorem wellFoundedOn [IsStrictOrder \u03b1 r] (s : Finset \u03b1) :\n    Set.WellFoundedOn (\u2191s : Set \u03b1) r", "start": [588, 1], "end": [592, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.wellFoundedOn_sup", "code": "theorem wellFoundedOn_sup [IsStrictOrder \u03b1 r] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (s.sup f).WellFoundedOn r \u2194 \u2200 i \u2208 s, (f i).WellFoundedOn r", "start": [595, 1], "end": [597, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.partiallyWellOrderedOn_sup", "code": "theorem partiallyWellOrderedOn_sup (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (s.sup f).PartiallyWellOrderedOn r \u2194 \u2200 i \u2208 s, (f i).PartiallyWellOrderedOn r", "start": [600, 1], "end": [602, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.isWf_sup", "code": "theorem isWf_sup [Preorder \u03b1] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (s.sup f).IsWf \u2194 \u2200 i \u2208 s, (f i).IsWf", "start": [605, 1], "end": [607, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.isPwo_sup", "code": "theorem isPwo_sup [Preorder \u03b1] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (s.sup f).IsPwo \u2194 \u2200 i \u2208 s, (f i).IsPwo", "start": [610, 1], "end": [612, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.wellFoundedOn_bUnion", "code": "@[simp]\ntheorem wellFoundedOn_bUnion [IsStrictOrder \u03b1 r] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i \u2208 s, f i).WellFoundedOn r \u2194 \u2200 i \u2208 s, (f i).WellFoundedOn r", "start": [615, 1], "end": [618, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.partiallyWellOrderedOn_bUnion", "code": "@[simp]\ntheorem partiallyWellOrderedOn_bUnion (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i \u2208 s, f i).PartiallyWellOrderedOn r \u2194 \u2200 i \u2208 s, (f i).PartiallyWellOrderedOn r", "start": [621, 1], "end": [624, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.isWf_bUnion", "code": "@[simp]\ntheorem isWf_bUnion [Preorder \u03b1] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i \u2208 s, f i).IsWf \u2194 \u2200 i \u2208 s, (f i).IsWf", "start": [627, 1], "end": [630, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.isPwo_bUnion", "code": "@[simp]\ntheorem isPwo_bUnion [Preorder \u03b1] (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} :\n    (\u22c3 i \u2208 s, f i).IsPwo \u2194 \u2200 i \u2208 s, (f i).IsPwo", "start": [633, 1], "end": [636, 34], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.min", "code": "noncomputable nonrec def IsWf.min (hs : IsWf s) (hn : s.Nonempty) : \u03b1 :=\n  hs.min univ (nonempty_iff_univ_nonempty.1 hn.to_subtype)", "start": [647, 1], "end": [649, 59], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.min_mem", "code": "theorem IsWf.min_mem (hs : IsWf s) (hn : s.Nonempty) : hs.min hn \u2208 s", "start": [652, 1], "end": [653, 75], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.not_lt_min", "code": "nonrec theorem IsWf.not_lt_min (hs : IsWf s) (hn : s.Nonempty) (ha : a \u2208 s) : \u00aca < hs.min hn", "start": [656, 1], "end": [657, 91], "kind": "commanddeclaration"}, {"full_name": "Set.isWf_min_singleton", "code": "@[simp]\ntheorem isWf_min_singleton (a) {hs : IsWf ({a} : Set \u03b1)} {hn : ({a} : Set \u03b1).Nonempty} :\n    hs.min hn = a", "start": [660, 1], "end": [663, 43], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.min_le", "code": "theorem IsWf.min_le (hs : s.IsWf) (hn : s.Nonempty) (ha : a \u2208 s) : hs.min hn \u2264 a", "start": [672, 1], "end": [673, 37], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.le_min_iff", "code": "theorem IsWf.le_min_iff (hs : s.IsWf) (hn : s.Nonempty) : a \u2264 hs.min hn \u2194 \u2200 b, b \u2208 s \u2192 a \u2264 b", "start": [676, 1], "end": [677, 79], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.min_le_min_of_subset", "code": "theorem IsWf.min_le_min_of_subset {hs : s.IsWf} {hsn : s.Nonempty} {ht : t.IsWf} {htn : t.Nonempty}\n    (hst : s \u2286 t) : ht.min htn \u2264 hs.min hsn", "start": [680, 1], "end": [682, 62], "kind": "commanddeclaration"}, {"full_name": "Set.IsWf.min_union", "code": "theorem IsWf.min_union (hs : s.IsWf) (hsn : s.Nonempty) (ht : t.IsWf) (htn : t.Nonempty) :\n    (hs.union ht).min (union_nonempty.2 (Or.intro_left _ hsn)) =\n      Min.min (hs.min hsn) (ht.min htn)", "start": [685, 1], "end": [692, 32], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.IsBadSeq", "code": "def IsBadSeq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) (f : \u2115 \u2192 \u03b1) : Prop :=\n  (\u2200 n, f n \u2208 s) \u2227 \u2200 m n : \u2115, m < n \u2192 \u00acr (f m) (f n)", "start": [705, 1], "end": [709, 53], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.iff_forall_not_isBadSeq", "code": "theorem iff_forall_not_isBadSeq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : Set \u03b1) :\n    s.PartiallyWellOrderedOn r \u2194 \u2200 f, \u00acIsBadSeq r s f", "start": [712, 1], "end": [714, 44], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.IsMinBadSeq", "code": "def IsMinBadSeq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (rk : \u03b1 \u2192 \u2115) (s : Set \u03b1) (n : \u2115) (f : \u2115 \u2192 \u03b1) : Prop :=\n  \u2200 g : \u2115 \u2192 \u03b1, (\u2200 m : \u2115, m < n \u2192 f m = g m) \u2192 rk (g n) < rk (f n) \u2192 \u00acIsBadSeq r s g", "start": [717, 1], "end": [720, 84], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.minBadSeqOfBadSeq", "code": "noncomputable def minBadSeqOfBadSeq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (rk : \u03b1 \u2192 \u2115) (s : Set \u03b1) (n : \u2115) (f : \u2115 \u2192 \u03b1)\n    (hf : IsBadSeq r s f) :\n    { g : \u2115 \u2192 \u03b1 // (\u2200 m : \u2115, m < n \u2192 f m = g m) \u2227 IsBadSeq r s g \u2227 IsMinBadSeq r rk s n g } := by\n  classical\n    have h : \u2203 (k : \u2115) (g : \u2115 \u2192 \u03b1), (\u2200 m, m < n \u2192 f m = g m) \u2227 IsBadSeq r s g \u2227 rk (g n) = k :=\n      \u27e8_, f, fun _ _ => rfl, hf, rfl\u27e9\n    obtain \u27e8h1, h2, h3\u27e9 := Classical.choose_spec (Nat.find_spec h)\n    refine' \u27e8Classical.choose (Nat.find_spec h), h1, by convert h2, fun g hg1 hg2 con => _\u27e9\n    refine' Nat.find_min h _ \u27e8g, fun m mn => (h1 m mn).trans (hg1 m mn), con, rfl\u27e9\n    rwa [\u2190 h3]", "start": [723, 1], "end": [735, 15], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.exists_min_bad_of_exists_bad", "code": "theorem exists_min_bad_of_exists_bad (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (rk : \u03b1 \u2192 \u2115) (s : Set \u03b1) :\n    (\u2203 f, IsBadSeq r s f) \u2192 \u2203 f, IsBadSeq r s f \u2227 \u2200 n, IsMinBadSeq r rk s n f", "start": [738, 1], "end": [758, 35], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.iff_not_exists_isMinBadSeq", "code": "theorem iff_not_exists_isMinBadSeq (rk : \u03b1 \u2192 \u2115) {s : Set \u03b1} :\n    s.PartiallyWellOrderedOn r \u2194 \u00ac\u2203 f, IsBadSeq r s f \u2227 \u2200 n, IsMinBadSeq r rk s n f", "start": [761, 1], "end": [767, 19], "kind": "commanddeclaration"}, {"full_name": "Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall\u2082", "code": "theorem partiallyWellOrderedOn_sublistForall\u2082 (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsRefl \u03b1 r] [IsTrans \u03b1 r]\n    {s : Set \u03b1} (h : s.PartiallyWellOrderedOn r) :\n    { l : List \u03b1 | \u2200 x, x \u2208 l \u2192 x \u2208 s }.PartiallyWellOrderedOn (List.SublistForall\u2082 r)", "start": [770, 1], "end": [810, 64], "kind": "commanddeclaration"}, {"full_name": "WellFounded.isWf", "code": "theorem WellFounded.isWf [LT \u03b1] (h : WellFounded ((\u00b7 < \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) (s : Set \u03b1) : s.IsWf", "start": [815, 1], "end": [816, 45], "kind": "commanddeclaration"}, {"full_name": "Pi.isPwo", "code": "theorem Pi.isPwo {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, LinearOrder (\u03b1 i)] [\u2200 i, IsWellOrder (\u03b1 i) (\u00b7 < \u00b7)]\n    [Finite \u03b9] (s : Set (\u2200 i, \u03b1 i)) : s.IsPwo", "start": [819, 1], "end": [841, 52], "kind": "commanddeclaration"}, {"full_name": "WellFounded.prod_lex_of_wellFoundedOn_fiber", "code": "theorem WellFounded.prod_lex_of_wellFoundedOn_fiber (h\u03b1 : WellFounded (r\u03b1 on f))\n    (h\u03b2 : \u2200 a, (f \u207b\u00b9' {a}).WellFoundedOn (r\u03b2 on g)) :\n    WellFounded (Prod.Lex r\u03b1 r\u03b2 on fun c => (f c, g c))", "start": [847, 1], "end": [858, 72], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.prod_lex_of_wellFoundedOn_fiber", "code": "theorem Set.WellFoundedOn.prod_lex_of_wellFoundedOn_fiber (h\u03b1 : s.WellFoundedOn (r\u03b1 on f))\n    (h\u03b2 : \u2200 a, (s \u2229 f \u207b\u00b9' {a}).WellFoundedOn (r\u03b2 on g)) :\n    s.WellFoundedOn (Prod.Lex r\u03b1 r\u03b2 on fun c => (f c, g c))", "start": [861, 1], "end": [867, 13], "kind": "commanddeclaration"}, {"full_name": "WellFounded.sigma_lex_of_wellFoundedOn_fiber", "code": "theorem WellFounded.sigma_lex_of_wellFoundedOn_fiber (h\u03b9 : WellFounded (r\u03b9 on f))\n    (h\u03c0 : \u2200 i, (f \u207b\u00b9' {i}).WellFoundedOn (r\u03c0 i on g i)) :\n    WellFounded (Sigma.Lex r\u03b9 r\u03c0 on fun c => \u27e8f c, g (f c) c\u27e9)", "start": [876, 1], "end": [893, 16], "kind": "commanddeclaration"}, {"full_name": "Set.WellFoundedOn.sigma_lex_of_wellFoundedOn_fiber", "code": "theorem Set.WellFoundedOn.sigma_lex_of_wellFoundedOn_fiber (h\u03b9 : s.WellFoundedOn (r\u03b9 on f))\n    (h\u03c0 : \u2200 i, (s \u2229 f \u207b\u00b9' {i}).WellFoundedOn (r\u03c0 i on g i)) :\n    s.WellFoundedOn (Sigma.Lex r\u03b9 r\u03c0 on fun c => \u27e8f c, g (f c) c\u27e9)", "start": [896, 1], "end": [905, 13], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Datatypes.lean", "imports": ["Mathlib/Tactic/Linarith/Lemmas.lean", "Mathlib/Util/SynthesizeUsing.lean", "Mathlib/Tactic/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Linarith.linarithTraceProofs", "code": "def linarithTraceProofs {\u03b1} [ToMessageData \u03b1] (s : \u03b1) (l : List Expr) : MetaM Unit := do\n  trace[linarith] \"{s}\"\n  trace[linarith] (\u2190 l.mapM fun e => do instantiateMVars (\u2190 inferType e))", "start": [26, 1], "end": [32, 74], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp", "code": "@[reducible]\ndef Linexp : Type := List (Nat \u00d7 Int)", "start": [36, 1], "end": [45, 38], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.add", "code": "partial def add : Linexp \u2192 Linexp \u2192 Linexp\n| [], a => a\n| a, [] => a\n| (a@(n1,z1)::t1), (b@(n2,z2)::t2) =>\n  if n1 < n2 then b::add (a::t1) t2\n  else if n2 < n1 then a::add t1 (b::t2)\n  else\n    let sum := z1 + z2\n    if sum = 0 then add t1 t2 else (n1, sum)::add t1 t2", "start": [48, 1], "end": [60, 56], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.scale", "code": "def scale (c : Int) (l : Linexp) : Linexp :=\n  if c = 0 then []\n  else if c = 1 then l\n  else l.map $ fun \u27e8n, z\u27e9 => (n, z*c)", "start": [62, 1], "end": [66, 38], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.get", "code": "def get (n : Nat) : Linexp \u2192 Option Int\n  | [] => none\n  | ((a, b)::t) =>\n    if a < n then none\n    else if a = n then some b\n    else get n t", "start": [68, 1], "end": [78, 17], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.contains", "code": "def contains (n : Nat) : Linexp \u2192 Bool := Option.isSome \u2218 get n", "start": [80, 1], "end": [83, 64], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.zfind", "code": "def zfind (n : Nat) (l : Linexp) : Int :=\n  match l.get n with\n  | none => 0\n  | some v => v", "start": [85, 1], "end": [91, 16], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.vars", "code": "def vars (l : Linexp) : List Nat :=\n  l.map Prod.fst", "start": [93, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "Linarith.Linexp.cmp", "code": "def cmp : Linexp \u2192 Linexp \u2192 Ordering\n  | [], [] => Ordering.eq\n  | [], _ => Ordering.lt\n  | _, [] => Ordering.gt\n  | ((n1,z1)::t1), ((n2,z2)::t2) =>\n    if n1 < n2 then Ordering.lt\n    else if n2 < n1 then Ordering.gt\n    else if z1 < z2 then Ordering.lt\n    else if z2 < z1 then Ordering.gt\n    else cmp t1 t2", "start": [97, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "Linarith.Ineq", "code": "inductive Ineq : Type\n  | eq | le | lt\nderiving DecidableEq, Inhabited, Repr", "start": [115, 1], "end": [119, 38], "kind": "commanddeclaration"}, {"full_name": "Linarith.Ineq.max", "code": "def max : Ineq \u2192 Ineq \u2192 Ineq\n  | lt, _ => lt\n  | _, lt => lt\n  | le, _ => le\n  | _, le => le\n  | eq, eq => eq", "start": [123, 1], "end": [132, 17], "kind": "commanddeclaration"}, {"full_name": "Linarith.Ineq.cmp", "code": "def cmp : Ineq \u2192 Ineq \u2192 Ordering\n  | eq, eq => Ordering.eq\n  | eq, _ => Ordering.lt\n  | le, le => Ordering.eq\n  | le, lt => Ordering.lt\n  | lt, lt => Ordering.eq\n  | _, _ => Ordering.gt", "start": [134, 1], "end": [141, 24], "kind": "commanddeclaration"}, {"full_name": "Linarith.Ineq.toString", "code": "def toString : Ineq \u2192 String\n  | eq => \"=\"\n  | le => \"\u2264\"\n  | lt => \"<\"", "start": [143, 1], "end": [147, 14], "kind": "commanddeclaration"}, {"full_name": "Linarith.Ineq.toConstMulName", "code": "def toConstMulName : Ineq \u2192 Name\n  | lt => ``mul_neg\n  | le => ``mul_nonpos\n  | eq => ``mul_eq", "start": [149, 1], "end": [153, 19], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp", "code": "structure Comp : Type where\n  \n  str : Ineq\n  \n  coeffs : Linexp\nderiving Inhabited, Repr", "start": [163, 1], "end": [176, 25], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.vars", "code": "def Comp.vars : Comp \u2192 List Nat := Linexp.vars \u2218 Comp.coeffs", "start": [178, 1], "end": [179, 61], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.coeffOf", "code": "def Comp.coeffOf (c : Comp) (a : Nat) : Int :=\n  c.coeffs.zfind a", "start": [181, 1], "end": [183, 19], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.scale", "code": "def Comp.scale (c : Comp) (n : Nat) : Comp :=\n  { c with coeffs := c.coeffs.scale n }", "start": [185, 1], "end": [187, 40], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.add", "code": "def Comp.add (c1 c2 : Comp) : Comp :=\n  \u27e8c1.str.max c2.str, c1.coeffs.add c2.coeffs\u27e9", "start": [189, 1], "end": [195, 47], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.cmp", "code": "def Comp.cmp : Comp \u2192 Comp \u2192 Ordering\n  | \u27e8str1, coeffs1\u27e9, \u27e8str2, coeffs2\u27e9 =>\n    match str1.cmp str2 with\n    | Ordering.lt => Ordering.lt\n    | Ordering.gt => Ordering.gt\n    | Ordering.eq => coeffs1.cmp coeffs2", "start": [197, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.isContr", "code": "def Comp.isContr (c : Comp) : Bool := c.coeffs.isEmpty && c.str = Ineq.lt", "start": [205, 1], "end": [209, 74], "kind": "commanddeclaration"}, {"full_name": "Linarith.Comp.ToFormat", "code": "instance Comp.ToFormat : ToFormat Comp :=\n  \u27e8fun p => format p.coeffs ++ toString p.str ++ \"0\"\u27e9", "start": [211, 1], "end": [212, 54], "kind": "commanddeclaration"}, {"full_name": "Linarith.Preprocessor", "code": "structure Preprocessor : Type where\n  \n  name : String\n  \n  transform : Expr \u2192 MetaM (List Expr)", "start": [219, 1], "end": [229, 39], "kind": "commanddeclaration"}, {"full_name": "Linarith.GlobalPreprocessor", "code": "structure GlobalPreprocessor : Type where\n  \n  name : String\n  \n  transform : List Expr \u2192 MetaM (List Expr)", "start": [231, 1], "end": [241, 44], "kind": "commanddeclaration"}, {"full_name": "Linarith.Branch", "code": "def Branch : Type := MVarId \u00d7 List Expr", "start": [243, 1], "end": [249, 40], "kind": "commanddeclaration"}, {"full_name": "Linarith.GlobalBranchingPreprocessor", "code": "structure GlobalBranchingPreprocessor : Type where\n  \n  name : String\n  \n  transform : MVarId \u2192 List Expr \u2192 MetaM (List Branch)", "start": [251, 1], "end": [263, 55], "kind": "commanddeclaration"}, {"full_name": "Linarith.Preprocessor.globalize", "code": "def Preprocessor.globalize (pp : Preprocessor) : GlobalPreprocessor where\n  name := pp.name\n  transform := List.foldrM (fun e ret => do return (\u2190 pp.transform e) ++ ret) []", "start": [265, 1], "end": [270, 81], "kind": "commanddeclaration"}, {"full_name": "Linarith.GlobalPreprocessor.branching", "code": "def GlobalPreprocessor.branching (pp : GlobalPreprocessor) : GlobalBranchingPreprocessor where\n  name := pp.name\n  transform := fun g l => do return [\u27e8g, \u2190 pp.transform l\u27e9]", "start": [272, 1], "end": [277, 60], "kind": "commanddeclaration"}, {"full_name": "Linarith.GlobalBranchingPreprocessor.process", "code": "def GlobalBranchingPreprocessor.process (pp : GlobalBranchingPreprocessor)\n    (g : MVarId) (l : List Expr) : MetaM (List Branch) := g.withContext do\n  let branches \u2190 pp.transform g l\n  if branches.length > 1 then\n    trace[linarith] \"Preprocessing: {pp.name} has branched, with branches:\"\n  for \u27e8goal, hyps\u27e9 in branches do\n    goal.withContext do\n      linarithTraceProofs m!\"Preprocessing: {pp.name}\" hyps\n  return branches", "start": [279, 1], "end": [291, 18], "kind": "commanddeclaration"}, {"full_name": "Linarith.PreprocessorToGlobalBranchingPreprocessor", "code": "instance PreprocessorToGlobalBranchingPreprocessor :\n    Coe Preprocessor GlobalBranchingPreprocessor :=\n  \u27e8GlobalPreprocessor.branching \u2218 Preprocessor.globalize\u27e9", "start": [293, 1], "end": [295, 58], "kind": "commanddeclaration"}, {"full_name": "Linarith.GlobalPreprocessorToGlobalBranchingPreprocessor", "code": "instance GlobalPreprocessorToGlobalBranchingPreprocessor :\n    Coe GlobalPreprocessor GlobalBranchingPreprocessor :=\n  \u27e8GlobalPreprocessor.branching\u27e9", "start": [297, 1], "end": [299, 33], "kind": "commanddeclaration"}, {"full_name": "Linarith.CertificateOracle", "code": "def CertificateOracle : Type :=\n  List Comp \u2192 Nat \u2192 MetaM (Std.HashMap Nat Nat)", "start": [301, 1], "end": [313, 48], "kind": "commanddeclaration"}, {"full_name": "Linarith.LinarithConfig", "code": "structure LinarithConfig : Type where\n  \n  discharger : TacticM Unit := do evalTactic (\u2190`(tactic| ring1))\n  \n  exfalso : Bool := true\n  \n  transparency : TransparencyMode := .reducible\n  \n  splitHypotheses : Bool := true\n  \n  splitNe : Bool := false\n  \n  preprocessors : Option (List GlobalBranchingPreprocessor) := none\n  \n  oracle : Option CertificateOracle := none", "start": [317, 1], "end": [339, 44], "kind": "commanddeclaration"}, {"full_name": "Linarith.LinarithConfig.updateReducibility", "code": "def LinarithConfig.updateReducibility (cfg : LinarithConfig) (reduce_default : Bool) :\n    LinarithConfig :=\n  if reduce_default then\n    { cfg with transparency := .default, discharger := do evalTactic (\u2190`(tactic| ring1!)) }\n  else cfg", "start": [341, 1], "end": [350, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.getRelSides", "code": "def getRelSides (e : Expr) : MetaM (Expr \u00d7 Expr) := do\n  let e \u2190 instantiateMVars e\n  match e.getAppFnArgs with\n  | (``LT.lt, #[_, _, a, b]) => return (a, b)\n  | (``LE.le, #[_, _, a, b]) => return (a, b)\n  | (``Eq, #[_, a, b]) => return (a, b)\n  | (``GE.ge, #[_, _, a, b]) => return (a, b)\n  | (``GT.gt, #[_, _, a, b]) => return (a, b)\n  | _ => throwError \"Not a comparison (getRelSides) : {e}\"", "start": [358, 1], "end": [372, 59], "kind": "commanddeclaration"}, {"full_name": "Linarith.parseCompAndExpr", "code": "def parseCompAndExpr (e : Expr) : MetaM (Ineq \u00d7 Expr) := do\n  let e \u2190 instantiateMVars e\n  match e.getAppFnArgs with\n  | (``LT.lt, #[_, _, e, z]) => if z.zero? then return (Ineq.lt, e) else throwNotZero z\n  | (``LE.le, #[_, _, e, z]) => if z.zero? then return (Ineq.le, e) else throwNotZero z\n  | (``Eq, #[_, e, z]) => if z.zero? then return (Ineq.eq, e) else throwNotZero z\n  | _ => throwError \"invalid comparison: {e}\"\n  where \n  throwNotZero (z : Expr) := throwError \"invalid comparison, rhs not zero: {z}\"", "start": [374, 1], "end": [386, 80], "kind": "commanddeclaration"}, {"full_name": "Linarith.mkSingleCompZeroOf", "code": "def mkSingleCompZeroOf (c : Nat) (h : Expr) : MetaM (Ineq \u00d7 Expr) := do\n  let tp \u2190 inferType h\n  let (iq, e) \u2190 parseCompAndExpr tp\n  if c = 0 then do\n    let e' \u2190 mkAppM ``zero_mul #[e]\n    return (Ineq.eq, e')\n  else if c = 1 then return (iq, h)\n  else do\n    let tp \u2190 inferType (\u2190 getRelSides (\u2190 inferType h)).2\n    let cpos \u2190 mkAppM ``GT.gt #[(\u2190 tp.ofNat c), (\u2190 tp.ofNat 0)]\n    let ex \u2190 synthesizeUsingTactic' cpos (\u2190 `(tactic| norm_num))\n    let e' \u2190 mkAppM iq.toConstMulName #[h, ex]\n    return (iq, e')", "start": [388, 1], "end": [406, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Tree.lean", "imports": ["Mathlib/Init/Data/Ordering/Basic.lean", "Mathlib/Order/Basic.lean", "Mathlib/Util/CompileInductive.lean", "lake-packages/lean4/src/lean/Init.lean", "lake-packages/std/Std/Data/RBMap.lean", "Mathlib/Data/Num/Basic.lean"], "premises": [{"full_name": "Tree", "code": "inductive Tree.{u} (\u03b1 : Type u) : Type u\n  | nil : Tree \u03b1\n  | node : \u03b1 \u2192 Tree \u03b1 \u2192 Tree \u03b1 \u2192 Tree \u03b1\n  deriving DecidableEq, Repr", "start": [31, 1], "end": [35, 29], "kind": "commanddeclaration"}, {"full_name": "Tree.ofRBNode", "code": "def ofRBNode : RBNode \u03b1 \u2192 Tree \u03b1\n  | RBNode.nil => nil\n  | RBNode.node _color l key r => node key (ofRBNode l) (ofRBNode r)", "start": [52, 1], "end": [55, 69], "kind": "commanddeclaration"}, {"full_name": "Tree.indexOf", "code": "def indexOf (lt : \u03b1 \u2192 \u03b1 \u2192 Prop) [DecidableRel lt] (x : \u03b1) : Tree \u03b1 \u2192 Option PosNum\n  | nil => none\n  | node a t\u2081 t\u2082 =>\n    match cmpUsing lt x a with\n    | Ordering.lt => PosNum.bit0 <$> indexOf lt x t\u2081\n    | Ordering.eq => some PosNum.one\n    | Ordering.gt => PosNum.bit1 <$> indexOf lt x t\u2082", "start": [58, 1], "end": [68, 53], "kind": "commanddeclaration"}, {"full_name": "Tree.get", "code": "def get : PosNum \u2192 Tree \u03b1 \u2192 Option \u03b1\n  | _, nil => none\n  | PosNum.one, node a _t\u2081 _t\u2082 => some a\n  | PosNum.bit0 n, node _a t\u2081 _t\u2082 => t\u2081.get n\n  | PosNum.bit1 n, node _a _t\u2081 t\u2082 => t\u2082.get n", "start": [71, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "Tree.getOrElse", "code": "def getOrElse (n : PosNum) (t : Tree \u03b1) (v : \u03b1) : \u03b1 :=\n  (t.get n).getD v", "start": [83, 1], "end": [86, 19], "kind": "commanddeclaration"}, {"full_name": "Tree.map", "code": "def map {\u03b2} (f : \u03b1 \u2192 \u03b2) : Tree \u03b1 \u2192 Tree \u03b2\n  | nil => nil\n  | node a l r => node (f a) (map f l) (map f r)", "start": [89, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "Tree.numNodes", "code": "@[simp]\ndef numNodes : Tree \u03b1 \u2192 \u2115\n  | nil => 0\n  | node _ a b => a.numNodes + b.numNodes + 1", "start": [96, 1], "end": [100, 46], "kind": "commanddeclaration"}, {"full_name": "Tree.numLeaves", "code": "@[simp]\ndef numLeaves : Tree \u03b1 \u2192 \u2115\n  | nil => 1\n  | node _ a b => a.numLeaves + b.numLeaves", "start": [103, 1], "end": [107, 44], "kind": "commanddeclaration"}, {"full_name": "Tree.height", "code": "@[simp]\ndef height : Tree \u03b1 \u2192 \u2115\n  | nil => 0\n  | node _ a b => max a.height b.height + 1", "start": [110, 1], "end": [114, 44], "kind": "commanddeclaration"}, {"full_name": "Tree.numLeaves_eq_numNodes_succ", "code": "theorem numLeaves_eq_numNodes_succ (x : Tree \u03b1) : x.numLeaves = x.numNodes + 1", "start": [117, 1], "end": [118, 75], "kind": "commanddeclaration"}, {"full_name": "Tree.numLeaves_pos", "code": "theorem numLeaves_pos (x : Tree \u03b1) : 0 < x.numLeaves", "start": [121, 1], "end": [123, 32], "kind": "commanddeclaration"}, {"full_name": "Tree.height_le_numNodes", "code": "theorem height_le_numNodes : \u2200 x : Tree \u03b1, x.height \u2264 x.numNodes", "start": [126, 1], "end": [131, 73], "kind": "commanddeclaration"}, {"full_name": "Tree.left", "code": "@[simp]\ndef left : Tree \u03b1 \u2192 Tree \u03b1\n  | nil => nil\n  | node _ l _r => l", "start": [134, 1], "end": [138, 21], "kind": "commanddeclaration"}, {"full_name": "Tree.right", "code": "@[simp]\ndef right : Tree \u03b1 \u2192 Tree \u03b1\n  | nil => nil\n  | node _ _l r => r", "start": [141, 1], "end": [145, 21], "kind": "commanddeclaration"}, {"full_name": "Tree.unitRecOn", "code": "@[elab_as_elim]\ndef unitRecOn {motive : Tree Unit \u2192 Sort*} (t : Tree Unit) (base : motive nil)\n    (ind : \u2200 x y, motive x \u2192 motive y \u2192 motive (x \u25b3 y)) : motive t :=\n    t.recOn base fun _u => ind", "start": [154, 1], "end": [159, 31], "kind": "commanddeclaration"}, {"full_name": "Tree.left_node_right_eq_self", "code": "theorem left_node_right_eq_self : \u2200 {x : Tree Unit} (_hx : x \u2260 nil), x.left \u25b3 x.right = x", "start": [162, 1], "end": [164, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Align.lean", "imports": ["Mathlib/Tactic/Relation/Symm.lean", "Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Relation/Trans.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Init/Logic.lean"], "premises": []}
{"path": "Mathlib/Topology/Irreducible.lean", "imports": ["Mathlib/Order/Minimal.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPreirreducible", "code": "def IsPreirreducible (s : Set \u03b1) : Prop :=\n  \u2200 u v : Set \u03b1, IsOpen u \u2192 IsOpen v \u2192 (s \u2229 u).Nonempty \u2192 (s \u2229 v).Nonempty \u2192 (s \u2229 (u \u2229 v)).Nonempty", "start": [37, 1], "end": [39, 100], "kind": "commanddeclaration"}, {"full_name": "IsIrreducible", "code": "def IsIrreducible (s : Set \u03b1) : Prop :=\n  s.Nonempty \u2227 IsPreirreducible s", "start": [42, 1], "end": [45, 34], "kind": "commanddeclaration"}, {"full_name": "IsIrreducible.nonempty", "code": "theorem IsIrreducible.nonempty {s : Set \u03b1} (h : IsIrreducible s) : s.Nonempty", "start": [48, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "IsIrreducible.isPreirreducible", "code": "theorem IsIrreducible.isPreirreducible {s : Set \u03b1} (h : IsIrreducible s) : IsPreirreducible s", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "isPreirreducible_empty", "code": "theorem isPreirreducible_empty : IsPreirreducible (\u2205 : Set \u03b1)", "start": [56, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isPreirreducible", "code": "theorem Set.Subsingleton.isPreirreducible {s : Set \u03b1} (hs : s.Subsingleton) : IsPreirreducible s", "start": [60, 1], "end": [61, 80], "kind": "commanddeclaration"}, {"full_name": "isPreirreducible_singleton", "code": "theorem isPreirreducible_singleton {x} : IsPreirreducible ({x} : Set \u03b1)", "start": [65, 1], "end": [66, 42], "kind": "commanddeclaration"}, {"full_name": "isIrreducible_singleton", "code": "theorem isIrreducible_singleton {x} : IsIrreducible ({x} : Set \u03b1)", "start": [68, 1], "end": [69, 53], "kind": "commanddeclaration"}, {"full_name": "isPreirreducible_iff_closure", "code": "theorem isPreirreducible_iff_closure {s : Set \u03b1} :\n    IsPreirreducible (closure s) \u2194 IsPreirreducible s", "start": [72, 1], "end": [76, 33], "kind": "commanddeclaration"}, {"full_name": "isIrreducible_iff_closure", "code": "theorem isIrreducible_iff_closure {s : Set \u03b1} : IsIrreducible (closure s) \u2194 IsIrreducible s", "start": [79, 1], "end": [80, 62], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.closure", "code": "protected alias \u27e8_, IsPreirreducible.closure\u27e9 := isPreirreducible_iff_closure", "start": [83, 1], "end": [83, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsIrreducible.closure", "code": "protected alias \u27e8_, IsIrreducible.closure\u27e9 := isIrreducible_iff_closure", "start": [86, 1], "end": [86, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "exists_preirreducible", "code": "theorem exists_preirreducible (s : Set \u03b1) (H : IsPreirreducible s) :\n    \u2203 t : Set \u03b1, IsPreirreducible t \u2227 s \u2286 t \u2227 \u2200 u, IsPreirreducible u \u2192 t \u2286 u \u2192 u = t", "start": [89, 1], "end": [106, 46], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponents", "code": "def irreducibleComponents (\u03b1 : Type*) [TopologicalSpace \u03b1] : Set (Set \u03b1) :=\n  maximals (\u00b7 \u2264 \u00b7) { s : Set \u03b1 | IsIrreducible s }", "start": [109, 1], "end": [111, 51], "kind": "commanddeclaration"}, {"full_name": "isClosed_of_mem_irreducibleComponents", "code": "theorem isClosed_of_mem_irreducibleComponents (s) (H : s \u2208 irreducibleComponents \u03b1) :\n    IsClosed s", "start": [114, 1], "end": [117, 65], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponents_eq_maximals_closed", "code": "theorem irreducibleComponents_eq_maximals_closed (\u03b1 : Type*) [TopologicalSpace \u03b1] :\n    irreducibleComponents \u03b1 = maximals (\u00b7 \u2264 \u00b7) { s : Set \u03b1 | IsClosed s \u2227 IsIrreducible s }", "start": [120, 1], "end": [129, 39], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponent", "code": "def irreducibleComponent (x : \u03b1) : Set \u03b1 :=\n  Classical.choose (exists_preirreducible {x} isPreirreducible_singleton)", "start": [132, 1], "end": [134, 74], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponent_property", "code": "theorem irreducibleComponent_property (x : \u03b1) :\n    IsPreirreducible (irreducibleComponent x) \u2227\n      {x} \u2286 irreducibleComponent x \u2227\n        \u2200 u, IsPreirreducible u \u2192 irreducibleComponent x \u2286 u \u2192 u = irreducibleComponent x", "start": [137, 1], "end": [141, 79], "kind": "commanddeclaration"}, {"full_name": "mem_irreducibleComponent", "code": "theorem mem_irreducibleComponent {x : \u03b1} : x \u2208 irreducibleComponent x", "start": [144, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "isIrreducible_irreducibleComponent", "code": "theorem isIrreducible_irreducibleComponent {x : \u03b1} : IsIrreducible (irreducibleComponent x)", "start": [148, 1], "end": [149, 71], "kind": "commanddeclaration"}, {"full_name": "eq_irreducibleComponent", "code": "theorem eq_irreducibleComponent {x : \u03b1} {s : Set \u03b1} :\n    IsPreirreducible s \u2192 irreducibleComponent x \u2286 s \u2192 s = irreducibleComponent x", "start": [152, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponent_mem_irreducibleComponents", "code": "theorem irreducibleComponent_mem_irreducibleComponents (x : \u03b1) :\n    irreducibleComponent x \u2208 irreducibleComponents \u03b1", "start": [157, 1], "end": [159, 92], "kind": "commanddeclaration"}, {"full_name": "isClosed_irreducibleComponent", "code": "theorem isClosed_irreducibleComponent {x : \u03b1} : IsClosed (irreducibleComponent x)", "start": [162, 1], "end": [163, 93], "kind": "commanddeclaration"}, {"full_name": "PreirreducibleSpace", "code": "class PreirreducibleSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  isPreirreducible_univ : IsPreirreducible (univ : Set \u03b1)", "start": [166, 1], "end": [169, 58], "kind": "commanddeclaration"}, {"full_name": "IrreducibleSpace", "code": "class IrreducibleSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] extends PreirreducibleSpace \u03b1 : Prop where\n  toNonempty : Nonempty \u03b1", "start": [172, 1], "end": [175, 26], "kind": "commanddeclaration"}, {"full_name": "IrreducibleSpace.isIrreducible_univ", "code": "theorem IrreducibleSpace.isIrreducible_univ (\u03b1 : Type*) [TopologicalSpace \u03b1] [IrreducibleSpace \u03b1] :\n    IsIrreducible (univ : Set \u03b1)", "start": [181, 1], "end": [183, 61], "kind": "commanddeclaration"}, {"full_name": "irreducibleSpace_def", "code": "theorem irreducibleSpace_def (\u03b1 : Type*) [TopologicalSpace \u03b1] :\n    IrreducibleSpace \u03b1 \u2194 IsIrreducible (\u22a4 : Set \u03b1)", "start": [186, 1], "end": [190, 18], "kind": "commanddeclaration"}, {"full_name": "nonempty_preirreducible_inter", "code": "theorem nonempty_preirreducible_inter [PreirreducibleSpace \u03b1] {s t : Set \u03b1} :\n    IsOpen s \u2192 IsOpen t \u2192 s.Nonempty \u2192 t.Nonempty \u2192 (s \u2229 t).Nonempty", "start": [193, 1], "end": [196, 57], "kind": "commanddeclaration"}, {"full_name": "IsOpen.dense", "code": "protected theorem IsOpen.dense [PreirreducibleSpace \u03b1] {s : Set \u03b1} (ho : IsOpen s)\n    (hne : s.Nonempty) : Dense s", "start": [199, 1], "end": [202, 90], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.image", "code": "theorem IsPreirreducible.image {s : Set \u03b1} (H : IsPreirreducible s) (f : \u03b1 \u2192 \u03b2)\n    (hf : ContinuousOn f s) : IsPreirreducible (f '' s)", "start": [205, 1], "end": [220, 13], "kind": "commanddeclaration"}, {"full_name": "IsIrreducible.image", "code": "theorem IsIrreducible.image {s : Set \u03b1} (H : IsIrreducible s) (f : \u03b1 \u2192 \u03b2) (hf : ContinuousOn f s) :\n    IsIrreducible (f '' s)", "start": [223, 1], "end": [225, 54], "kind": "commanddeclaration"}, {"full_name": "Subtype.preirreducibleSpace", "code": "theorem Subtype.preirreducibleSpace {s : Set \u03b1} (h : IsPreirreducible s) :\n    PreirreducibleSpace s where", "start": [228, 1], "end": [233, 51], "kind": "commanddeclaration"}, {"full_name": "Subtype.irreducibleSpace", "code": "theorem Subtype.irreducibleSpace {s : Set \u03b1} (h : IsIrreducible s) : IrreducibleSpace s where", "start": [236, 1], "end": [239, 38], "kind": "commanddeclaration"}, {"full_name": "isIrreducible_iff_sInter", "code": "theorem isIrreducible_iff_sInter {s : Set \u03b1} :\n    IsIrreducible s \u2194\n      \u2200 (U : Finset (Set \u03b1)), (\u2200 u \u2208 U, IsOpen u) \u2192 (\u2200 u \u2208 U, (s \u2229 u).Nonempty) \u2192\n        (s \u2229 \u22c2\u2080 \u2191U).Nonempty", "start": [251, 1], "end": [268, 29], "kind": "commanddeclaration"}, {"full_name": "isPreirreducible_iff_closed_union_closed", "code": "theorem isPreirreducible_iff_closed_union_closed {s : Set \u03b1} :\n    IsPreirreducible s \u2194\n      \u2200 z\u2081 z\u2082 : Set \u03b1, IsClosed z\u2081 \u2192 IsClosed z\u2082 \u2192 s \u2286 z\u2081 \u222a z\u2082 \u2192 s \u2286 z\u2081 \u2228 s \u2286 z\u2082", "start": [271, 1], "end": [280, 40], "kind": "commanddeclaration"}, {"full_name": "isIrreducible_iff_sUnion_closed", "code": "theorem isIrreducible_iff_sUnion_closed {s : Set \u03b1} :\n    IsIrreducible s \u2194\n      \u2200 Z : Finset (Set \u03b1), (\u2200 z \u2208 Z, IsClosed z) \u2192 (s \u2286 \u22c3\u2080 \u2191Z) \u2192 \u2203 z \u2208 Z, s \u2286 z", "start": [283, 1], "end": [295, 70], "kind": "commanddeclaration"}, {"full_name": "subset_closure_inter_of_isPreirreducible_of_isOpen", "code": "theorem subset_closure_inter_of_isPreirreducible_of_isOpen {S U : Set \u03b1} (hS : IsPreirreducible S)\n    (hU : IsOpen U) (h : (S \u2229 U).Nonempty) : S \u2286 closure (S \u2229 U)", "start": [298, 1], "end": [304, 37], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.subset_irreducible", "code": "theorem IsPreirreducible.subset_irreducible {S U Z : Set \u03b1} (hZ : IsPreirreducible Z)\n    (hU : U.Nonempty) (hU' : IsOpen U) (h\u2081 : U \u2286 S) (h\u2082 : S \u2286 Z) : IsIrreducible S", "start": [307, 1], "end": [322, 29], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.open_subset", "code": "theorem IsPreirreducible.open_subset {Z U : Set \u03b1} (hZ : IsPreirreducible Z) (hU : IsOpen U)\n    (hU' : U \u2286 Z) : IsPreirreducible U", "start": [325, 1], "end": [328, 53], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.interior", "code": "theorem IsPreirreducible.interior {Z : Set \u03b1} (hZ : IsPreirreducible Z) :\n    IsPreirreducible (interior Z)", "start": [331, 1], "end": [333, 49], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.preimage", "code": "theorem IsPreirreducible.preimage {Z : Set \u03b1} (hZ : IsPreirreducible Z) {f : \u03b2 \u2192 \u03b1}\n    (hf : OpenEmbedding f) : IsPreirreducible (f \u207b\u00b9' Z)", "start": [336, 1], "end": [343, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Clopen.lean", "imports": ["Mathlib/Data/Set/BoolIndicator.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsClopen", "code": "def IsClopen (s : Set \u03b1) : Prop :=\n  IsOpen s \u2227 IsClosed s", "start": [26, 1], "end": [28, 24], "kind": "commanddeclaration"}, {"full_name": "IsClopen.isOpen", "code": "protected theorem IsClopen.isOpen (hs : IsClopen s) : IsOpen s", "start": [31, 1], "end": [31, 71], "kind": "commanddeclaration"}, {"full_name": "IsClopen.isClosed", "code": "protected theorem IsClopen.isClosed (hs : IsClopen s) : IsClosed s", "start": [34, 1], "end": [34, 75], "kind": "commanddeclaration"}, {"full_name": "isClopen_iff_frontier_eq_empty", "code": "theorem isClopen_iff_frontier_eq_empty {s : Set \u03b1} : IsClopen s \u2194 frontier s = \u2205", "start": [37, 1], "end": [41, 55], "kind": "commanddeclaration"}, {"full_name": "IsClopen.frontier_eq", "code": "alias \u27e8IsClopen.frontier_eq, _\u27e9 := isClopen_iff_frontier_eq_empty", "start": [44, 1], "end": [44, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsClopen.union", "code": "theorem IsClopen.union {s t : Set \u03b1} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u222a t)", "start": [47, 1], "end": [48, 37], "kind": "commanddeclaration"}, {"full_name": "IsClopen.inter", "code": "theorem IsClopen.inter {s t : Set \u03b1} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u2229 t)", "start": [51, 1], "end": [52, 37], "kind": "commanddeclaration"}, {"full_name": "isClopen_empty", "code": "@[simp] theorem isClopen_empty : IsClopen (\u2205 : Set \u03b1)", "start": [55, 1], "end": [55, 88], "kind": "commanddeclaration"}, {"full_name": "isClopen_univ", "code": "@[simp] theorem isClopen_univ : IsClopen (univ : Set \u03b1)", "start": [58, 1], "end": [58, 88], "kind": "commanddeclaration"}, {"full_name": "IsClopen.compl", "code": "theorem IsClopen.compl {s : Set \u03b1} (hs : IsClopen s) : IsClopen s\u1d9c", "start": [61, 1], "end": [62, 43], "kind": "commanddeclaration"}, {"full_name": "isClopen_compl_iff", "code": "@[simp]\ntheorem isClopen_compl_iff {s : Set \u03b1} : IsClopen s\u1d9c \u2194 IsClopen s", "start": [65, 1], "end": [67, 62], "kind": "commanddeclaration"}, {"full_name": "IsClopen.diff", "code": "theorem IsClopen.diff {s t : Set \u03b1} (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \\ t)", "start": [70, 1], "end": [71, 20], "kind": "commanddeclaration"}, {"full_name": "IsClopen.prod", "code": "theorem IsClopen.prod {s : Set \u03b1} {t : Set \u03b2} (hs : IsClopen s) (ht : IsClopen t) :\n    IsClopen (s \u00d7\u02e2 t)", "start": [74, 1], "end": [76, 35], "kind": "commanddeclaration"}, {"full_name": "isClopen_iUnion_of_finite", "code": "theorem isClopen_iUnion_of_finite {\u03b2 : Type*} [Finite \u03b2] {s : \u03b2 \u2192 Set \u03b1} (h : \u2200 i, IsClopen (s i)) :\n    IsClopen (\u22c3 i, s i)", "start": [79, 1], "end": [81, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isClopen_biUnion", "code": "theorem Set.Finite.isClopen_biUnion {\u03b2 : Type*} {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (hs : s.Finite)\n    (h : \u2200 i \u2208 s, IsClopen <| f i) : IsClopen (\u22c3 i \u2208 s, f i)", "start": [84, 1], "end": [86, 86], "kind": "commanddeclaration"}, {"full_name": "isClopen_biUnion_finset", "code": "theorem isClopen_biUnion_finset {\u03b2 : Type*} {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1}\n    (h : \u2200 i \u2208 s, IsClopen <| f i) : IsClopen (\u22c3 i \u2208 s, f i)", "start": [89, 1], "end": [91, 36], "kind": "commanddeclaration"}, {"full_name": "isClopen_iInter_of_finite", "code": "theorem isClopen_iInter_of_finite {\u03b2 : Type*} [Finite \u03b2] {s : \u03b2 \u2192 Set \u03b1} (h : \u2200 i, IsClopen (s i)) :\n    IsClopen (\u22c2 i, s i)", "start": [94, 1], "end": [96, 83], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isClopen_biInter", "code": "theorem Set.Finite.isClopen_biInter {\u03b2 : Type*} {s : Set \u03b2} (hs : s.Finite) {f : \u03b2 \u2192 Set \u03b1}\n    (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c2 i \u2208 s, f i)", "start": [99, 1], "end": [101, 86], "kind": "commanddeclaration"}, {"full_name": "isClopen_biInter_finset", "code": "theorem isClopen_biInter_finset {\u03b2 : Type*} {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1}\n    (h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c2 i \u2208 s, f i)", "start": [104, 1], "end": [106, 36], "kind": "commanddeclaration"}, {"full_name": "IsClopen.preimage", "code": "theorem IsClopen.preimage {s : Set \u03b2} (h : IsClopen s) {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) :\n    IsClopen (f \u207b\u00b9' s)", "start": [109, 1], "end": [111, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.preimage_clopen_of_clopen", "code": "theorem ContinuousOn.preimage_clopen_of_clopen {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2}\n    (hf : ContinuousOn f s) (hs : IsClopen s) (ht : IsClopen t) : IsClopen (s \u2229 f \u207b\u00b9' t)", "start": [114, 1], "end": [117, 57], "kind": "commanddeclaration"}, {"full_name": "isClopen_inter_of_disjoint_cover_clopen", "code": "theorem isClopen_inter_of_disjoint_cover_clopen {Z a b : Set \u03b1} (h : IsClopen Z) (cover : Z \u2286 a \u222a b)\n    (ha : IsOpen a) (hb : IsOpen b) (hab : Disjoint a b) : IsClopen (Z \u2229 a)", "start": [120, 1], "end": [128, 67], "kind": "commanddeclaration"}, {"full_name": "isClopen_discrete", "code": "@[simp]\ntheorem isClopen_discrete [DiscreteTopology \u03b1] (x : Set \u03b1) : IsClopen x", "start": [131, 1], "end": [133, 43], "kind": "commanddeclaration"}, {"full_name": "isClopen_range_inl", "code": "theorem isClopen_range_inl : IsClopen (range (Sum.inl : \u03b1 \u2192 \u03b1 \u2295 \u03b2))", "start": [137, 1], "end": [138, 41], "kind": "commanddeclaration"}, {"full_name": "isClopen_range_inr", "code": "theorem isClopen_range_inr : IsClopen (range (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2))", "start": [141, 1], "end": [142, 41], "kind": "commanddeclaration"}, {"full_name": "isClopen_range_sigmaMk", "code": "theorem isClopen_range_sigmaMk {\u03b9 : Type*} {\u03c3 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c3 i)] {i : \u03b9} :\n    IsClopen (Set.range (@Sigma.mk \u03b9 \u03c3 i))", "start": [144, 1], "end": [146, 75], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.isClopen_preimage", "code": "protected theorem QuotientMap.isClopen_preimage {f : \u03b1 \u2192 \u03b2} (hf : QuotientMap f) {s : Set \u03b2} :\n    IsClopen (f \u207b\u00b9' s) \u2194 IsClopen s", "start": [149, 1], "end": [151, 52], "kind": "commanddeclaration"}, {"full_name": "continuous_boolIndicator_iff_clopen", "code": "theorem continuous_boolIndicator_iff_clopen (U : Set X) :\n    Continuous U.boolIndicator \u2194 IsClopen U", "start": [156, 1], "end": [164, 64], "kind": "commanddeclaration"}, {"full_name": "continuousOn_boolIndicator_iff_clopen", "code": "theorem continuousOn_boolIndicator_iff_clopen (s U : Set X) :\n    ContinuousOn U.boolIndicator s \u2194 IsClopen (((\u2191) : s \u2192 X) \u207b\u00b9' U)", "start": [167, 1], "end": [170, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SuccPred/Relation.lean", "imports": ["Mathlib/Order/SuccPred/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "reflTransGen_of_succ_of_le", "code": "theorem reflTransGen_of_succ_of_le (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ico n m, r i (succ i))\n    (hnm : n \u2264 m) : ReflTransGen r n m", "start": [24, 1], "end": [35, 36], "kind": "commanddeclaration"}, {"full_name": "reflTransGen_of_succ_of_ge", "code": "theorem reflTransGen_of_succ_of_ge (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ico m n, r (succ i) i)\n    (hmn : m \u2264 n) : ReflTransGen r n m", "start": [38, 1], "end": [43, 50], "kind": "commanddeclaration"}, {"full_name": "transGen_of_succ_of_lt", "code": "theorem transGen_of_succ_of_lt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ico n m, r i (succ i))\n    (hnm : n < m) : TransGen r n m", "start": [46, 1], "end": [51, 12], "kind": "commanddeclaration"}, {"full_name": "transGen_of_succ_of_gt", "code": "theorem transGen_of_succ_of_gt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ico m n, r (succ i) i)\n    (hmn : m < n) : TransGen r n m", "start": [54, 1], "end": [59, 11], "kind": "commanddeclaration"}, {"full_name": "reflTransGen_of_succ", "code": "theorem reflTransGen_of_succ (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h1 : \u2200 i \u2208 Ico n m, r i (succ i))\n    (h2 : \u2200 i \u2208 Ico m n, r (succ i) i) : ReflTransGen r n m", "start": [68, 1], "end": [72, 91], "kind": "commanddeclaration"}, {"full_name": "transGen_of_succ_of_ne", "code": "theorem transGen_of_succ_of_ne (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h1 : \u2200 i \u2208 Ico n m, r i (succ i))\n    (h2 : \u2200 i \u2208 Ico m n, r (succ i) i) (hnm : n \u2260 m) : TransGen r n m", "start": [75, 1], "end": [79, 92], "kind": "commanddeclaration"}, {"full_name": "transGen_of_succ_of_reflexive", "code": "theorem transGen_of_succ_of_reflexive (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (hr : Reflexive r)\n    (h1 : \u2200 i \u2208 Ico n m, r i (succ i)) (h2 : \u2200 i \u2208 Ico m n, r (succ i) i) : TransGen r n m", "start": [82, 1], "end": [87, 48], "kind": "commanddeclaration"}, {"full_name": "reflTransGen_of_pred_of_ge", "code": "theorem reflTransGen_of_pred_of_ge (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ioc m n, r i (pred i))\n    (hnm : m \u2264 n) : ReflTransGen r n m", "start": [96, 1], "end": [100, 81], "kind": "commanddeclaration"}, {"full_name": "reflTransGen_of_pred_of_le", "code": "theorem reflTransGen_of_pred_of_le (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ioc n m, r (pred i) i)\n    (hmn : n \u2264 m) : ReflTransGen r n m", "start": [103, 1], "end": [107, 81], "kind": "commanddeclaration"}, {"full_name": "transGen_of_pred_of_gt", "code": "theorem transGen_of_pred_of_gt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ioc m n, r i (pred i))\n    (hnm : m < n) : TransGen r n m", "start": [110, 1], "end": [114, 77], "kind": "commanddeclaration"}, {"full_name": "transGen_of_pred_of_lt", "code": "theorem transGen_of_pred_of_lt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h : \u2200 i \u2208 Ioc n m, r (pred i) i)\n    (hmn : n < m) : TransGen r n m", "start": [117, 1], "end": [121, 77], "kind": "commanddeclaration"}, {"full_name": "reflTransGen_of_pred", "code": "theorem reflTransGen_of_pred (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h1 : \u2200 i \u2208 Ioc m n, r i (pred i))\n    (h2 : \u2200 i \u2208 Ioc n m, r (pred i) i) : ReflTransGen r n m", "start": [130, 1], "end": [135, 22], "kind": "commanddeclaration"}, {"full_name": "transGen_of_pred_of_ne", "code": "theorem transGen_of_pred_of_ne (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (h1 : \u2200 i \u2208 Ioc m n, r i (pred i))\n    (h2 : \u2200 i \u2208 Ioc n m, r (pred i) i) (hnm : n \u2260 m) : TransGen r n m", "start": [138, 1], "end": [143, 40], "kind": "commanddeclaration"}, {"full_name": "transGen_of_pred_of_reflexive", "code": "theorem transGen_of_pred_of_reflexive (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {n m : \u03b1} (hr : Reflexive r)\n    (h1 : \u2200 i \u2208 Ioc m n, r i (pred i)) (h2 : \u2200 i \u2208 Ioc n m, r (pred i) i) : TransGen r n m", "start": [146, 1], "end": [151, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Compactness/Compact.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/Topology/Bornology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Accumulate.lean", "Mathlib/Topology/LocallyFinite.lean"], "premises": [{"full_name": "IsCompact", "code": "def IsCompact (s : Set \u03b1) :=\n  \u2200 \u2983f\u2984 [NeBot f], f \u2264 \ud835\udcdf s \u2192 \u2203 a \u2208 s, ClusterPt a f", "start": [38, 1], "end": [41, 52], "kind": "commanddeclaration"}, {"full_name": "IsCompact.compl_mem_sets", "code": "theorem IsCompact.compl_mem_sets (hs : IsCompact s) {f : Filter \u03b1} (hf : \u2200 a \u2208 s, s\u1d9c \u2208 \ud835\udcdd a \u2293 f) :\n    s\u1d9c \u2208 f", "start": [44, 1], "end": [50, 30], "kind": "commanddeclaration"}, {"full_name": "IsCompact.compl_mem_sets_of_nhdsWithin", "code": "theorem IsCompact.compl_mem_sets_of_nhdsWithin (hs : IsCompact s) {f : Filter \u03b1}\n    (hf : \u2200 a \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] a, t\u1d9c \u2208 f) : s\u1d9c \u2208 f", "start": [53, 1], "end": [62, 19], "kind": "commanddeclaration"}, {"full_name": "IsCompact.induction_on", "code": "@[elab_as_elim]\ntheorem IsCompact.induction_on {s : Set \u03b1} (hs : IsCompact s) {p : Set \u03b1 \u2192 Prop} (he : p \u2205)\n    (hmono : \u2200 \u2983s t\u2984, s \u2286 t \u2192 p t \u2192 p s) (hunion : \u2200 \u2983s t\u2984, p s \u2192 p t \u2192 p (s \u222a t))\n    (hnhds : \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, p t) : p s", "start": [65, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "IsCompact.inter_right", "code": "theorem IsCompact.inter_right (hs : IsCompact s) (ht : IsClosed t) : IsCompact (s \u2229 t)", "start": [80, 1], "end": [87, 29], "kind": "commanddeclaration"}, {"full_name": "IsCompact.inter_left", "code": "theorem IsCompact.inter_left (ht : IsCompact t) (hs : IsClosed s) : IsCompact (s \u2229 t)", "start": [90, 1], "end": [92, 37], "kind": "commanddeclaration"}, {"full_name": "IsCompact.diff", "code": "theorem IsCompact.diff (hs : IsCompact s) (ht : IsOpen t) : IsCompact (s \\ t)", "start": [95, 1], "end": [97, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompact.of_isClosed_subset", "code": "theorem IsCompact.of_isClosed_subset (hs : IsCompact s) (ht : IsClosed t) (h : t \u2286 s) :\n    IsCompact t", "start": [100, 1], "end": [103, 54], "kind": "commanddeclaration"}, {"full_name": "IsCompact.image_of_continuousOn", "code": "theorem IsCompact.image_of_continuousOn {f : \u03b1 \u2192 \u03b2} (hs : IsCompact s) (hf : ContinuousOn f s) :\n    IsCompact (f '' s)", "start": [106, 1], "end": [118, 19], "kind": "commanddeclaration"}, {"full_name": "IsCompact.image", "code": "theorem IsCompact.image {f : \u03b1 \u2192 \u03b2} (hs : IsCompact s) (hf : Continuous f) : IsCompact (f '' s)", "start": [121, 1], "end": [122, 43], "kind": "commanddeclaration"}, {"full_name": "IsCompact.adherence_nhdset", "code": "theorem IsCompact.adherence_nhdset {f : Filter \u03b1} (hs : IsCompact s) (hf\u2082 : f \u2264 \ud835\udcdf s)\n    (ht\u2081 : IsOpen t) (ht\u2082 : \u2200 a \u2208 s, ClusterPt a f \u2192 a \u2208 t) : t \u2208 f", "start": [125, 1], "end": [133, 18], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_ultrafilter_le_nhds", "code": "theorem isCompact_iff_ultrafilter_le_nhds :\n    IsCompact s \u2194 \u2200 f : Ultrafilter \u03b1, \u2191f \u2264 \ud835\udcdf s \u2192 \u2203 a \u2208 s, \u2191f \u2264 \ud835\udcdd a", "start": [136, 1], "end": [141, 42], "kind": "commanddeclaration"}, {"full_name": "IsCompact.ultrafilter_le_nhds", "code": "alias \u27e8IsCompact.ultrafilter_le_nhds, _\u27e9 := isCompact_iff_ultrafilter_le_nhds", "start": [144, 1], "end": [144, 78], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsCompact.elim_directed_cover", "code": "theorem IsCompact.elim_directed_cover {\u03b9 : Type v} [h\u03b9 : Nonempty \u03b9] (hs : IsCompact s)\n    (U : \u03b9 \u2192 Set \u03b1) (hUo : \u2200 i, IsOpen (U i)) (hsU : s \u2286 \u22c3 i, U i) (hdU : Directed (\u00b7 \u2286 \u00b7) U) :\n    \u2203 i, s \u2286 U i", "start": [147, 1], "end": [159, 87], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_finite_subcover", "code": "theorem IsCompact.elim_finite_subcover {\u03b9 : Type v} (hs : IsCompact s) (U : \u03b9 \u2192 Set \u03b1)\n    (hUo : \u2200 i, IsOpen (U i)) (hsU : s \u2286 \u22c3 i, U i) : \u2203 t : Finset \u03b9, s \u2286 \u22c3 i \u2208 t, U i", "start": [162, 1], "end": [166, 99], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_nhds_subcover'", "code": "theorem IsCompact.elim_nhds_subcover' (hs : IsCompact s) (U : \u2200 x \u2208 s, Set \u03b1)\n    (hU : \u2200 x (hx : x \u2208 s), U x \u2039x \u2208 s\u203a \u2208 \ud835\udcdd x) : \u2203 t : Finset s, s \u2286 \u22c3 x \u2208 t, U (x : s) x.2", "start": [169, 1], "end": [173, 69], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_nhds_subcover", "code": "theorem IsCompact.elim_nhds_subcover (hs : IsCompact s) (U : \u03b1 \u2192 Set \u03b1) (hU : \u2200 x \u2208 s, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset \u03b1, (\u2200 x \u2208 t, x \u2208 s) \u2227 s \u2286 \u22c3 x \u2208 t, U x", "start": [176, 1], "end": [182, 46], "kind": "commanddeclaration"}, {"full_name": "IsCompact.disjoint_nhdsSet_left", "code": "theorem IsCompact.disjoint_nhdsSet_left {l : Filter \u03b1} (hs : IsCompact s) :\n    Disjoint (\ud835\udcdd\u02e2 s) l \u2194 \u2200 x \u2208 s, Disjoint (\ud835\udcdd x) l", "start": [185, 1], "end": [196, 37], "kind": "commanddeclaration"}, {"full_name": "IsCompact.disjoint_nhdsSet_right", "code": "theorem IsCompact.disjoint_nhdsSet_right {l : Filter \u03b1} (hs : IsCompact s) :\n    Disjoint l (\ud835\udcdd\u02e2 s) \u2194 \u2200 x \u2208 s, Disjoint l (\ud835\udcdd x)", "start": [199, 1], "end": [203, 60], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_directed_family_closed", "code": "theorem IsCompact.elim_directed_family_closed {\u03b9 : Type v} [h\u03b9 : Nonempty \u03b9] (hs : IsCompact s)\n    (Z : \u03b9 \u2192 Set \u03b1) (hZc : \u2200 i, IsClosed (Z i)) (hsZ : (s \u2229 \u22c2 i, Z i) = \u2205)\n    (hdZ : Directed (\u00b7 \u2287 \u00b7) Z) : \u2203 i : \u03b9, s \u2229 Z i = \u2205", "start": [207, 1], "end": [220, 81], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_finite_subfamily_closed", "code": "theorem IsCompact.elim_finite_subfamily_closed {s : Set \u03b1} {\u03b9 : Type v} (hs : IsCompact s)\n    (Z : \u03b9 \u2192 Set \u03b1) (hZc : \u2200 i, IsClosed (Z i)) (hsZ : (s \u2229 \u22c2 i, Z i) = \u2205) :\n    \u2203 t : Finset \u03b9, (s \u2229 \u22c2 i \u2208 t, Z i) = \u2205", "start": [224, 1], "end": [230, 101], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.finite_nonempty_inter_compact", "code": "theorem LocallyFinite.finite_nonempty_inter_compact {\u03b9 : Type*} {f : \u03b9 \u2192 Set \u03b1}\n    (hf : LocallyFinite f) {s : Set \u03b1} (hs : IsCompact s) : { i | (f i \u2229 s).Nonempty }.Finite", "start": [233, 1], "end": [242, 39], "kind": "commanddeclaration"}, {"full_name": "IsCompact.inter_iInter_nonempty", "code": "theorem IsCompact.inter_iInter_nonempty {s : Set \u03b1} {\u03b9 : Type v} (hs : IsCompact s) (Z : \u03b9 \u2192 Set \u03b1)\n    (hZc : \u2200 i, IsClosed (Z i)) (hsZ : \u2200 t : Finset \u03b9, (s \u2229 \u22c2 i \u2208 t, Z i).Nonempty) :\n    (s \u2229 \u22c2 i, Z i).Nonempty", "start": [245, 1], "end": [251, 72], "kind": "commanddeclaration"}, {"full_name": "IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed", "code": "theorem IsCompact.nonempty_iInter_of_directed_nonempty_compact_closed {\u03b9 : Type v} [h\u03b9 : Nonempty \u03b9]\n    (Z : \u03b9 \u2192 Set \u03b1) (hZd : Directed (\u00b7 \u2287 \u00b7) Z) (hZn : \u2200 i, (Z i).Nonempty)\n    (hZc : \u2200 i, IsCompact (Z i)) (hZcl : \u2200 i, IsClosed (Z i)) : (\u22c2 i, Z i).Nonempty", "start": [254, 1], "end": [268, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompact.nonempty_iInter_of_sequence_nonempty_compact_closed", "code": "theorem IsCompact.nonempty_iInter_of_sequence_nonempty_compact_closed (Z : \u2115 \u2192 Set \u03b1)\n    (hZd : \u2200 i, Z (i + 1) \u2286 Z i) (hZn : \u2200 i, (Z i).Nonempty) (hZ0 : IsCompact (Z 0))\n    (hZcl : \u2200 i, IsClosed (Z i)) : (\u22c2 i, Z i).Nonempty", "start": [271, 1], "end": [280, 83], "kind": "commanddeclaration"}, {"full_name": "IsCompact.elim_finite_subcover_image", "code": "theorem IsCompact.elim_finite_subcover_image {b : Set \u03b9} {c : \u03b9 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc\u2081 : \u2200 i \u2208 b, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i \u2208 b, c i) :\n    \u2203 b', b' \u2286 b \u2227 Set.Finite b' \u2227 s \u2286 \u22c3 i \u2208 b', c i", "start": [283, 1], "end": [291, 24], "kind": "commanddeclaration"}, {"full_name": "isCompact_of_finite_subcover", "code": "theorem isCompact_of_finite_subcover\n    (h : \u2200 {\u03b9 : Type u} (U : \u03b9 \u2192 Set \u03b1), (\u2200 i, IsOpen (U i)) \u2192 (s \u2286 \u22c3 i, U i) \u2192\n      \u2203 t : Finset \u03b9, s \u2286 \u22c3 i \u2208 t, U i) :\n    IsCompact s", "start": [294, 1], "end": [307, 27], "kind": "commanddeclaration"}, {"full_name": "isCompact_of_finite_subfamily_closed", "code": "theorem isCompact_of_finite_subfamily_closed\n    (h : \u2200 {\u03b9 : Type u} (Z : \u03b9 \u2192 Set \u03b1), (\u2200 i, IsClosed (Z i)) \u2192 (s \u2229 \u22c2 i, Z i) = \u2205 \u2192\n      \u2203 t : Finset \u03b9, (s \u2229 \u22c2 i \u2208 t, Z i) = \u2205) :\n    IsCompact s", "start": [311, 1], "end": [321, 73], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_finite_subcover", "code": "theorem isCompact_iff_finite_subcover :\n    IsCompact s \u2194 \u2200 {\u03b9 : Type u} (U : \u03b9 \u2192 Set \u03b1),\n      (\u2200 i, IsOpen (U i)) \u2192 (s \u2286 \u22c3 i, U i) \u2192 \u2203 t : Finset \u03b9, s \u2286 \u22c3 i \u2208 t, U i", "start": [324, 1], "end": [329, 68], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_finite_subfamily_closed", "code": "theorem isCompact_iff_finite_subfamily_closed :\n    IsCompact s \u2194 \u2200 {\u03b9 : Type u} (Z : \u03b9 \u2192 Set \u03b1),\n      (\u2200 i, IsClosed (Z i)) \u2192 (s \u2229 \u22c2 i, Z i) = \u2205 \u2192 \u2203 t : Finset \u03b9, (s \u2229 \u22c2 i \u2208 t, Z i) = \u2205", "start": [332, 1], "end": [338, 84], "kind": "commanddeclaration"}, {"full_name": "IsCompact.mem_nhdsSet_prod_of_forall", "code": "theorem IsCompact.mem_nhdsSet_prod_of_forall {K : Set \u03b1} {l : Filter \u03b2} {s : Set (\u03b1 \u00d7 \u03b2)}\n    (hK : IsCompact K) (hs : \u2200 x \u2208 K, s \u2208 \ud835\udcdd x \u00d7\u02e2 l) : s \u2208 (\ud835\udcdd\u02e2 K) \u00d7\u02e2 l", "start": [341, 1], "end": [352, 58], "kind": "commanddeclaration"}, {"full_name": "IsCompact.nhdsSet_prod_eq_biSup", "code": "theorem IsCompact.nhdsSet_prod_eq_biSup {K : Set \u03b1} (hK : IsCompact K) (l : Filter \u03b2) :\n    (\ud835\udcdd\u02e2 K) \u00d7\u02e2 l = \u2a06 x \u2208 K, \ud835\udcdd x \u00d7\u02e2 l", "start": [354, 1], "end": [357, 64], "kind": "commanddeclaration"}, {"full_name": "IsCompact.prod_nhdsSet_eq_biSup", "code": "theorem IsCompact.prod_nhdsSet_eq_biSup {K : Set \u03b2} (hK : IsCompact K) (l : Filter \u03b1) :\n    l \u00d7\u02e2 (\ud835\udcdd\u02e2 K) = \u2a06 y \u2208 K, l \u00d7\u02e2 \ud835\udcdd y", "start": [359, 1], "end": [361, 69], "kind": "commanddeclaration"}, {"full_name": "IsCompact.mem_prod_nhdsSet_of_forall", "code": "theorem IsCompact.mem_prod_nhdsSet_of_forall {K : Set \u03b2} {l : Filter \u03b1} {s : Set (\u03b1 \u00d7 \u03b2)}\n    (hK : IsCompact K) (hs : \u2200 y \u2208 K, s \u2208 l \u00d7\u02e2 \ud835\udcdd y) : s \u2208 l \u00d7\u02e2 \ud835\udcdd\u02e2 K", "start": [363, 1], "end": [368, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.eventually_forall_of_forall_eventually", "code": "theorem IsCompact.eventually_forall_of_forall_eventually {x\u2080 : \u03b1} {K : Set \u03b2} (hK : IsCompact K)\n    {P : \u03b1 \u2192 \u03b2 \u2192 Prop} (hP : \u2200 y \u2208 K, \u2200\u1da0 z : \u03b1 \u00d7 \u03b2 in \ud835\udcdd (x\u2080, y), P z.1 z.2) :\n    \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 y \u2208 K, P x y", "start": [370, 1], "end": [381, 50], "kind": "commanddeclaration"}, {"full_name": "isCompact_empty", "code": "@[simp]\ntheorem isCompact_empty : IsCompact (\u2205 : Set \u03b1)", "start": [384, 1], "end": [386, 67], "kind": "commanddeclaration"}, {"full_name": "isCompact_singleton", "code": "@[simp]\ntheorem isCompact_singleton {a : \u03b1} : IsCompact ({a} : Set \u03b1)", "start": [389, 1], "end": [392, 80], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isCompact", "code": "theorem Set.Subsingleton.isCompact {s : Set \u03b1} (hs : s.Subsingleton) : IsCompact s", "start": [395, 1], "end": [396, 76], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isCompact_biUnion", "code": "theorem Set.Finite.isCompact_biUnion {s : Set \u03b9} {f : \u03b9 \u2192 Set \u03b1} (hs : s.Finite)\n    (hf : \u2200 i \u2208 s, IsCompact (f i)) : IsCompact (\u22c3 i \u2208 s, f i)", "start": [400, 1], "end": [406, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.isCompact_biUnion", "code": "theorem Finset.isCompact_biUnion (s : Finset \u03b9) {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i \u2208 s, IsCompact (f i)) :\n    IsCompact (\u22c3 i \u2208 s, f i)", "start": [409, 1], "end": [411, 38], "kind": "commanddeclaration"}, {"full_name": "isCompact_accumulate", "code": "theorem isCompact_accumulate {K : \u2115 \u2192 Set \u03b1} (hK : \u2200 n, IsCompact (K n)) (n : \u2115) :\n    IsCompact (Accumulate K n)", "start": [414, 1], "end": [416, 54], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isCompact_sUnion", "code": "theorem Set.Finite.isCompact_sUnion {S : Set (Set \u03b1)} (hf : S.Finite) (hc : \u2200 s \u2208 S, IsCompact s) :\n    IsCompact (\u22c3\u2080 S)", "start": [420, 1], "end": [422, 56], "kind": "commanddeclaration"}, {"full_name": "isCompact_iUnion", "code": "theorem isCompact_iUnion {\u03b9 : Sort*} {f : \u03b9 \u2192 Set \u03b1} [Finite \u03b9] (h : \u2200 i, IsCompact (f i)) :\n    IsCompact (\u22c3 i, f i)", "start": [425, 1], "end": [427, 60], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isCompact", "code": "theorem Set.Finite.isCompact (hs : s.Finite) : IsCompact s", "start": [430, 1], "end": [431, 79], "kind": "commanddeclaration"}, {"full_name": "IsCompact.finite_of_discrete", "code": "theorem IsCompact.finite_of_discrete [DiscreteTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s) :\n    s.Finite", "start": [434, 1], "end": [439, 34], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_finite", "code": "theorem isCompact_iff_finite [DiscreteTopology \u03b1] {s : Set \u03b1} : IsCompact s \u2194 s.Finite", "start": [442, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.union", "code": "theorem IsCompact.union (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s \u222a t)", "start": [446, 1], "end": [447, 82], "kind": "commanddeclaration"}, {"full_name": "IsCompact.insert", "code": "protected theorem IsCompact.insert (hs : IsCompact s) (a) : IsCompact (insert a s)", "start": [450, 1], "end": [451, 31], "kind": "commanddeclaration"}, {"full_name": "exists_subset_nhds_of_isCompact'", "code": "theorem exists_subset_nhds_of_isCompact' {\u03b9 : Type*} [Nonempty \u03b9] {V : \u03b9 \u2192 Set \u03b1}\n    (hV : Directed (\u00b7 \u2287 \u00b7) V) (hV_cpct : \u2200 i, IsCompact (V i)) (hV_closed : \u2200 i, IsClosed (V i))\n    {U : Set \u03b1} (hU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x) : \u2203 i, V i \u2286 U", "start": [455, 1], "end": [475, 16], "kind": "commanddeclaration"}, {"full_name": "isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis", "code": "theorem isCompact_open_iff_eq_finite_iUnion_of_isTopologicalBasis (b : \u03b9 \u2192 Set \u03b1)\n    (hb : IsTopologicalBasis (Set.range b)) (hb' : \u2200 i, IsCompact (b i)) (U : Set \u03b1) :\n    IsCompact U \u2227 IsOpen U \u2194 \u2203 s : Set \u03b9, s.Finite \u2227 U = \u22c3 i \u2208 s, b i", "start": [478, 1], "end": [505, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact", "code": "def cocompact (\u03b1 : Type*) [TopologicalSpace \u03b1] : Filter \u03b1 :=\n  \u2a05 (s : Set \u03b1) (_ : IsCompact s), \ud835\udcdf s\u1d9c", "start": [510, 1], "end": [512, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_cocompact", "code": "theorem hasBasis_cocompact : (cocompact \u03b1).HasBasis IsCompact compl", "start": [515, 1], "end": [520, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_cocompact", "code": "theorem mem_cocompact : s \u2208 cocompact \u03b1 \u2194 \u2203 t, IsCompact t \u2227 t\u1d9c \u2286 s", "start": [523, 1], "end": [524, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_cocompact'", "code": "theorem mem_cocompact' : s \u2208 cocompact \u03b1 \u2194 \u2203 t, IsCompact t \u2227 s\u1d9c \u2286 t", "start": [527, 1], "end": [528, 90], "kind": "commanddeclaration"}, {"full_name": "IsCompact.compl_mem_cocompact", "code": "theorem _root_.IsCompact.compl_mem_cocompact (hs : IsCompact s) : s\u1d9c \u2208 Filter.cocompact \u03b1", "start": [531, 1], "end": [532, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact_le_cofinite", "code": "theorem cocompact_le_cofinite : cocompact \u03b1 \u2264 cofinite", "start": [535, 1], "end": [536, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact_eq_cofinite", "code": "theorem cocompact_eq_cofinite (\u03b1 : Type*) [TopologicalSpace \u03b1] [DiscreteTopology \u03b1] :\n    cocompact \u03b1 = cofinite", "start": [539, 1], "end": [541, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.cocompact_eq", "code": "@[simp] theorem _root_.Nat.cocompact_eq : cocompact \u2115 = atTop", "start": [544, 1], "end": [545, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isCompact_insert_range_of_cocompact", "code": "theorem Tendsto.isCompact_insert_range_of_cocompact {f : \u03b1 \u2192 \u03b2} {b}\n    (hf : Tendsto f (cocompact \u03b1) (\ud835\udcdd b)) (hfc : Continuous f) : IsCompact (insert b (range f))", "start": [548, 1], "end": [562, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isCompact_insert_range_of_cofinite", "code": "theorem Tendsto.isCompact_insert_range_of_cofinite {f : \u03b9 \u2192 \u03b1} {a} (hf : Tendsto f cofinite (\ud835\udcdd a)) :\n    IsCompact (insert a (range f))", "start": [565, 1], "end": [569, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.isCompact_insert_range", "code": "theorem Tendsto.isCompact_insert_range {f : \u2115 \u2192 \u03b1} {a} (hf : Tendsto f atTop (\ud835\udcdd a)) :\n    IsCompact (insert a (range f))", "start": [572, 1], "end": [574, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.coclosedCompact", "code": "def coclosedCompact (\u03b1 : Type*) [TopologicalSpace \u03b1] : Filter \u03b1 :=\n  \u2a05 (s : Set \u03b1) (_ : IsClosed s) (_ : IsCompact s), \ud835\udcdf s\u1d9c", "start": [577, 1], "end": [580, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.hasBasis_coclosedCompact", "code": "theorem hasBasis_coclosedCompact :\n    (Filter.coclosedCompact \u03b1).HasBasis (fun s => IsClosed s \u2227 IsCompact s) compl", "start": [583, 1], "end": [589, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_coclosedCompact", "code": "theorem mem_coclosedCompact : s \u2208 coclosedCompact \u03b1 \u2194 \u2203 t, IsClosed t \u2227 IsCompact t \u2227 t\u1d9c \u2286 s", "start": [592, 1], "end": [593, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_coclosed_compact'", "code": "theorem mem_coclosed_compact' : s \u2208 coclosedCompact \u03b1 \u2194 \u2203 t, IsClosed t \u2227 IsCompact t \u2227 s\u1d9c \u2286 t", "start": [596, 1], "end": [597, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact_le_coclosedCompact", "code": "theorem cocompact_le_coclosedCompact : cocompact \u03b1 \u2264 coclosedCompact \u03b1", "start": [600, 1], "end": [601, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompact.compl_mem_coclosedCompact_of_isClosed", "code": "theorem IsCompact.compl_mem_coclosedCompact_of_isClosed (hs : IsCompact s) (hs' : IsClosed s) :\n    s\u1d9c \u2208 Filter.coclosedCompact \u03b1", "start": [606, 1], "end": [608, 48], "kind": "commanddeclaration"}, {"full_name": "Bornology.inCompact", "code": "def inCompact : Bornology \u03b1 where\n  cobounded' := Filter.cocompact \u03b1\n  le_cofinite' := Filter.cocompact_le_cofinite", "start": [615, 1], "end": [620, 47], "kind": "commanddeclaration"}, {"full_name": "Bornology.inCompact.isBounded_iff", "code": "theorem inCompact.isBounded_iff : @IsBounded _ (inCompact \u03b1) s \u2194 \u2203 t, IsCompact t \u2227 s \u2286 t", "start": [625, 1], "end": [628, 7], "kind": "commanddeclaration"}, {"full_name": "IsCompact.nhdsSet_prod_eq", "code": "theorem IsCompact.nhdsSet_prod_eq {s : Set \u03b1} {t : Set \u03b2} (hs : IsCompact s) (ht : IsCompact t) :\n    \ud835\udcdd\u02e2 (s \u00d7\u02e2 t) = \ud835\udcdd\u02e2 s \u00d7\u02e2 \ud835\udcdd\u02e2 t", "start": [639, 1], "end": [646, 18], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_prod_le", "code": "theorem nhdsSet_prod_le (s : Set \u03b1) (t : Set \u03b2) : \ud835\udcdd\u02e2 (s \u00d7\u02e2 t) \u2264 \ud835\udcdd\u02e2 s \u00d7\u02e2 \ud835\udcdd\u02e2 t", "start": [648, 1], "end": [652, 54], "kind": "commanddeclaration"}, {"full_name": "generalized_tube_lemma", "code": "theorem generalized_tube_lemma {s : Set \u03b1} (hs : IsCompact s) {t : Set \u03b2} (ht : IsCompact t)\n    {n : Set (\u03b1 \u00d7 \u03b2)} (hn : IsOpen n) (hp : s \u00d7\u02e2 t \u2286 n) :\n    \u2203 (u : Set \u03b1) (v : Set \u03b2), IsOpen u \u2227 IsOpen v \u2227 s \u2286 u \u2227 t \u2286 v \u2227 u \u00d7\u02e2 v \u2286 n", "start": [654, 1], "end": [664, 39], "kind": "commanddeclaration"}, {"full_name": "CompactSpace", "code": "class CompactSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  isCompact_univ : IsCompact (univ : Set \u03b1)", "start": [667, 1], "end": [671, 44], "kind": "commanddeclaration"}, {"full_name": "Subsingleton.compactSpace", "code": "instance (priority := 10) Subsingleton.compactSpace [Subsingleton \u03b1] : CompactSpace \u03b1 :=\n  \u27e8subsingleton_univ.isCompact\u27e9", "start": [675, 1], "end": [676, 32], "kind": "commanddeclaration"}, {"full_name": "isCompact_univ_iff", "code": "theorem isCompact_univ_iff : IsCompact (univ : Set \u03b1) \u2194 CompactSpace \u03b1", "start": [679, 1], "end": [680, 31], "kind": "commanddeclaration"}, {"full_name": "isCompact_univ", "code": "theorem isCompact_univ [h : CompactSpace \u03b1] : IsCompact (univ : Set \u03b1)", "start": [683, 1], "end": [684, 19], "kind": "commanddeclaration"}, {"full_name": "cluster_point_of_compact", "code": "theorem cluster_point_of_compact [CompactSpace \u03b1] (f : Filter \u03b1) [NeBot f] : \u2203 x, ClusterPt x f", "start": [687, 1], "end": [688, 58], "kind": "commanddeclaration"}, {"full_name": "CompactSpace.elim_nhds_subcover", "code": "theorem CompactSpace.elim_nhds_subcover [CompactSpace \u03b1] (U : \u03b1 \u2192 Set \u03b1) (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset \u03b1, \u22c3 x \u2208 t, U x = \u22a4", "start": [691, 1], "end": [694, 26], "kind": "commanddeclaration"}, {"full_name": "compactSpace_of_finite_subfamily_closed", "code": "theorem compactSpace_of_finite_subfamily_closed\n    (h : \u2200 {\u03b9 : Type u} (Z : \u03b9 \u2192 Set \u03b1), (\u2200 i, IsClosed (Z i)) \u2192 \u22c2 i, Z i = \u2205 \u2192\n      \u2203 t : Finset \u03b9, \u22c2 i \u2208 t, Z i = \u2205) :\n    CompactSpace \u03b1 where", "start": [697, 1], "end": [702, 20], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isCompact", "code": "theorem IsClosed.isCompact [CompactSpace \u03b1] {s : Set \u03b1} (h : IsClosed s) : IsCompact s", "start": [705, 1], "end": [706, 54], "kind": "commanddeclaration"}, {"full_name": "NoncompactSpace", "code": "class NoncompactSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  noncompact_univ : \u00acIsCompact (univ : Set \u03b1)", "start": [709, 1], "end": [712, 46], "kind": "commanddeclaration"}, {"full_name": "noncompact_univ", "code": "lemma noncompact_univ (\u03b1 : Type*) [TopologicalSpace \u03b1] [NoncompactSpace \u03b1] :\n    \u00acIsCompact (univ : Set \u03b1) :=\n  NoncompactSpace.noncompact_univ", "start": [716, 1], "end": [718, 34], "kind": "mathlibtacticlemma"}, {"full_name": "IsCompact.ne_univ", "code": "theorem IsCompact.ne_univ [NoncompactSpace \u03b1] {s : Set \u03b1} (hs : IsCompact s) : s \u2260 univ", "start": [720, 1], "end": [721, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact_eq_bot", "code": "@[simp]\ntheorem Filter.cocompact_eq_bot [CompactSpace \u03b1] : Filter.cocompact \u03b1 = \u22a5", "start": [729, 1], "end": [731, 86], "kind": "commanddeclaration"}, {"full_name": "noncompactSpace_of_neBot", "code": "theorem noncompactSpace_of_neBot (_ : NeBot (Filter.cocompact \u03b1)) : NoncompactSpace \u03b1", "start": [737, 1], "end": [738, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.cocompact_neBot_iff", "code": "theorem Filter.cocompact_neBot_iff : NeBot (Filter.cocompact \u03b1) \u2194 NoncompactSpace \u03b1", "start": [741, 1], "end": [742, 53], "kind": "commanddeclaration"}, {"full_name": "not_compactSpace_iff", "code": "theorem not_compactSpace_iff : \u00acCompactSpace \u03b1 \u2194 NoncompactSpace \u03b1", "start": [745, 1], "end": [746, 58], "kind": "commanddeclaration"}, {"full_name": "finite_of_compact_of_discrete", "code": "theorem finite_of_compact_of_discrete [CompactSpace \u03b1] [DiscreteTopology \u03b1] : Finite \u03b1", "start": [753, 1], "end": [755, 61], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_ne_neBot", "code": "theorem exists_nhds_ne_neBot (\u03b1 : Type*) [TopologicalSpace \u03b1] [CompactSpace \u03b1] [Infinite \u03b1] :\n    \u2203 z : \u03b1, (\ud835\udcdd[\u2260] z).NeBot", "start": [758, 1], "end": [763, 71], "kind": "commanddeclaration"}, {"full_name": "finite_cover_nhds_interior", "code": "theorem finite_cover_nhds_interior [CompactSpace \u03b1] {U : \u03b1 \u2192 Set \u03b1} (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset \u03b1, \u22c3 x \u2208 t, interior (U x) = univ", "start": [766, 1], "end": [770, 28], "kind": "commanddeclaration"}, {"full_name": "finite_cover_nhds", "code": "theorem finite_cover_nhds [CompactSpace \u03b1] {U : \u03b1 \u2192 Set \u03b1} (hU : \u2200 x, U x \u2208 \ud835\udcdd x) :\n    \u2203 t : Finset \u03b1, \u22c3 x \u2208 t, U x = univ", "start": [773, 1], "end": [776, 92], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.finite_nonempty_of_compact", "code": "theorem LocallyFinite.finite_nonempty_of_compact {\u03b9 : Type*} [CompactSpace \u03b1] {f : \u03b9 \u2192 Set \u03b1}\n    (hf : LocallyFinite f) : { i | (f i).Nonempty }.Finite", "start": [779, 1], "end": [783, 80], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.finite_of_compact", "code": "theorem LocallyFinite.finite_of_compact {\u03b9 : Type*} [CompactSpace \u03b1] {f : \u03b9 \u2192 Set \u03b1}\n    (hf : LocallyFinite f) (hne : \u2200 i, (f i).Nonempty) : (univ : Set \u03b9).Finite", "start": [786, 1], "end": [790, 55], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.fintypeOfCompact", "code": "noncomputable def LocallyFinite.fintypeOfCompact {\u03b9 : Type*} [CompactSpace \u03b1] {f : \u03b9 \u2192 Set \u03b1}\n    (hf : LocallyFinite f) (hne : \u2200 i, (f i).Nonempty) : Fintype \u03b9 :=\n  fintypeOfFiniteUniv (hf.finite_of_compact hne)", "start": [793, 1], "end": [797, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_cocompact_le", "code": "theorem Filter.comap_cocompact_le {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) :\n    (Filter.cocompact \u03b2).comap f \u2264 Filter.cocompact \u03b1", "start": [800, 1], "end": [808, 40], "kind": "commanddeclaration"}, {"full_name": "isCompact_range", "code": "theorem isCompact_range [CompactSpace \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) : IsCompact (range f)", "start": [811, 1], "end": [812, 51], "kind": "commanddeclaration"}, {"full_name": "isCompact_diagonal", "code": "theorem isCompact_diagonal [CompactSpace \u03b1] : IsCompact (diagonal \u03b1)", "start": [815, 1], "end": [816, 72], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_snd_of_compactSpace", "code": "theorem isClosedMap_snd_of_compactSpace {X : Type*} [TopologicalSpace X] [CompactSpace X]\n    {Y : Type*} [TopologicalSpace Y] : IsClosedMap (Prod.snd : X \u00d7 Y \u2192 Y)", "start": [820, 1], "end": [831, 33], "kind": "commanddeclaration"}, {"full_name": "exists_subset_nhds_of_compactSpace", "code": "theorem exists_subset_nhds_of_compactSpace [CompactSpace \u03b1] {\u03b9 : Type*} [Nonempty \u03b9]\n    {V : \u03b9 \u2192 Set \u03b1} (hV : Directed (\u00b7 \u2287 \u00b7) V) (hV_closed : \u2200 i, IsClosed (V i)) {U : Set \u03b1}\n    (hU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x) : \u2203 i, V i \u2286 U", "start": [834, 1], "end": [837, 86], "kind": "commanddeclaration"}, {"full_name": "Inducing.isCompact_iff", "code": "theorem Inducing.isCompact_iff {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) {s : Set \u03b1} :\n    IsCompact s \u2194 IsCompact (f '' s)", "start": [840, 1], "end": [847, 44], "kind": "commanddeclaration"}, {"full_name": "Embedding.isCompact_iff", "code": "theorem Embedding.isCompact_iff {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) :\n    IsCompact s \u2194 IsCompact (f '' s)", "start": [850, 1], "end": [853, 68], "kind": "commanddeclaration"}, {"full_name": "Inducing.isCompact_preimage", "code": "theorem Inducing.isCompact_preimage {f : \u03b1 \u2192 \u03b2} (hf : Inducing f) (hf' : IsClosed (range f))\n    {K : Set \u03b2} (hK : IsCompact K) : IsCompact (f \u207b\u00b9' K)", "start": [856, 1], "end": [860, 56], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.isCompact_preimage", "code": "theorem ClosedEmbedding.isCompact_preimage {f : \u03b1 \u2192 \u03b2} (hf : ClosedEmbedding f)\n    {K : Set \u03b2} (hK : IsCompact K) : IsCompact (f \u207b\u00b9' K)", "start": [862, 1], "end": [865, 56], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.tendsto_cocompact", "code": "theorem ClosedEmbedding.tendsto_cocompact {f : \u03b1 \u2192 \u03b2} (hf : ClosedEmbedding f) :\n    Tendsto f (Filter.cocompact \u03b1) (Filter.cocompact \u03b2)", "start": [868, 1], "end": [873, 51], "kind": "commanddeclaration"}, {"full_name": "Subtype.isCompact_iff", "code": "theorem Subtype.isCompact_iff {p : \u03b1 \u2192 Prop} {s : Set { a // p a }} :\n    IsCompact s \u2194 IsCompact ((\u2191) '' s : Set \u03b1)", "start": [876, 1], "end": [879, 38], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_isCompact_univ", "code": "theorem isCompact_iff_isCompact_univ {s : Set \u03b1} : IsCompact s \u2194 IsCompact (univ : Set s)", "start": [882, 1], "end": [883, 60], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_compactSpace", "code": "theorem isCompact_iff_compactSpace {s : Set \u03b1} : IsCompact s \u2194 CompactSpace s", "start": [886, 1], "end": [887, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.finite", "code": "theorem IsCompact.finite {s : Set \u03b1} (hs : IsCompact s) (hs' : DiscreteTopology s) : s.Finite", "start": [890, 1], "end": [891, 96], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_ne_inf_principal_neBot", "code": "theorem exists_nhds_ne_inf_principal_neBot {s : Set \u03b1} (hs : IsCompact s) (hs' : s.Infinite) :\n    \u2203 z \u2208 s, (\ud835\udcdd[\u2260] z \u2293 \ud835\udcdf s).NeBot", "start": [894, 1], "end": [898, 62], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.noncompactSpace", "code": "protected theorem ClosedEmbedding.noncompactSpace [NoncompactSpace \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : ClosedEmbedding f) : NoncompactSpace \u03b2", "start": [901, 1], "end": [903, 54], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.compactSpace", "code": "protected theorem ClosedEmbedding.compactSpace [h : CompactSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : ClosedEmbedding f) : CompactSpace \u03b1", "start": [906, 1], "end": [908, 85], "kind": "commanddeclaration"}, {"full_name": "IsCompact.prod", "code": "theorem IsCompact.prod {s : Set \u03b1} {t : Set \u03b2} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s \u00d7\u02e2 t)", "start": [911, 1], "end": [922, 40], "kind": "commanddeclaration"}, {"full_name": "Finite.compactSpace", "code": "instance (priority := 100) Finite.compactSpace [Finite \u03b1] : CompactSpace \u03b1 where\n  isCompact_univ := finite_univ.isCompact", "start": [925, 1], "end": [927, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod_cocompact", "code": "theorem Filter.coprod_cocompact :\n    (Filter.cocompact \u03b1).coprod (Filter.cocompact \u03b2) = Filter.cocompact (\u03b1 \u00d7 \u03b2)", "start": [946, 1], "end": [969, 57], "kind": "commanddeclaration"}, {"full_name": "Prod.noncompactSpace_iff", "code": "theorem Prod.noncompactSpace_iff :\n    NoncompactSpace (\u03b1 \u00d7 \u03b2) \u2194 NoncompactSpace \u03b1 \u2227 Nonempty \u03b2 \u2228 Nonempty \u03b1 \u2227 NoncompactSpace \u03b2", "start": [972, 1], "end": [974, 90], "kind": "commanddeclaration"}, {"full_name": "Prod.noncompactSpace_left", "code": "instance (priority := 100) Prod.noncompactSpace_left [NoncompactSpace \u03b1] [Nonempty \u03b2] :\n    NoncompactSpace (\u03b1 \u00d7 \u03b2) :=\n  Prod.noncompactSpace_iff.2 (Or.inl \u27e8\u2039_\u203a, \u2039_\u203a\u27e9)", "start": [978, 1], "end": [980, 49], "kind": "commanddeclaration"}, {"full_name": "Prod.noncompactSpace_right", "code": "instance (priority := 100) Prod.noncompactSpace_right [Nonempty \u03b1] [NoncompactSpace \u03b2] :\n    NoncompactSpace (\u03b1 \u00d7 \u03b2) :=\n  Prod.noncompactSpace_iff.2 (Or.inr \u27e8\u2039_\u203a, \u2039_\u203a\u27e9)", "start": [984, 1], "end": [986, 49], "kind": "commanddeclaration"}, {"full_name": "isCompact_pi_infinite", "code": "theorem isCompact_pi_infinite {s : \u2200 i, Set (\u03c0 i)} :\n    (\u2200 i, IsCompact (s i)) \u2192 IsCompact { x : \u2200 i, \u03c0 i | \u2200 i, x i \u2208 s i }", "start": [993, 1], "end": [1003, 66], "kind": "commanddeclaration"}, {"full_name": "isCompact_univ_pi", "code": "theorem isCompact_univ_pi {s : \u2200 i, Set (\u03c0 i)} (h : \u2200 i, IsCompact (s i)) :\n    IsCompact (pi univ s)", "start": [1006, 1], "end": [1010, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.compactSpace", "code": "instance Pi.compactSpace [\u2200 i, CompactSpace (\u03c0 i)] : CompactSpace (\u2200 i, \u03c0 i) :=\n  \u27e8by rw [\u2190 pi_univ univ]; exact isCompact_univ_pi fun i => isCompact_univ\u27e9", "start": [1013, 1], "end": [1014, 76], "kind": "commanddeclaration"}, {"full_name": "Function.compactSpace", "code": "instance Function.compactSpace [CompactSpace \u03b2] : CompactSpace (\u03b9 \u2192 \u03b2) :=\n  Pi.compactSpace", "start": [1017, 1], "end": [1018, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.coprod\u1d62_cocompact", "code": "theorem Filter.coprod\u1d62_cocompact {\u03b4 : Type*} {\u03ba : \u03b4 \u2192 Type*} [\u2200 d, TopologicalSpace (\u03ba d)] :\n    (Filter.coprod\u1d62 fun d => Filter.cocompact (\u03ba d)) = Filter.cocompact (\u2200 d, \u03ba d)", "start": [1021, 1], "end": [1029, 73], "kind": "commanddeclaration"}, {"full_name": "Quot.compactSpace", "code": "instance Quot.compactSpace {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [CompactSpace \u03b1] : CompactSpace (Quot r) :=\n  \u27e8by\n    rw [\u2190 range_quot_mk]\n    exact isCompact_range continuous_quot_mk\u27e9", "start": [1035, 1], "end": [1038, 46], "kind": "commanddeclaration"}, {"full_name": "Quotient.compactSpace", "code": "instance Quotient.compactSpace {s : Setoid \u03b1} [CompactSpace \u03b1] : CompactSpace (Quotient s) :=\n  Quot.compactSpace", "start": [1041, 1], "end": [1042, 20], "kind": "commanddeclaration"}, {"full_name": "IsClosed.exists_minimal_nonempty_closed_subset", "code": "theorem IsClosed.exists_minimal_nonempty_closed_subset [CompactSpace \u03b1] {S : Set \u03b1}\n    (hS : IsClosed S) (hne : S.Nonempty) :\n    \u2203 V : Set \u03b1, V \u2286 S \u2227 V.Nonempty \u2227 IsClosed V \u2227\n      \u2200 V' : Set \u03b1, V' \u2286 V \u2192 V'.Nonempty \u2192 IsClosed V' \u2192 V' = V", "start": [1045, 1], "end": [1081, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/Order.lean", "imports": ["Mathlib/Data/Finset/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Directed.finset_le", "code": "theorem Directed.finset_le {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsTrans \u03b1 r] {\u03b9} [h\u03b9 : Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1}\n    (D : Directed r f) (s : Finset \u03b9) : \u2203 z, \u2200 i \u2208 s, r (f i) (f z)", "start": [19, 1], "end": [26, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.exists_le", "code": "theorem Finset.exists_le [Nonempty \u03b1] [Preorder \u03b1] [IsDirected \u03b1 (\u00b7 \u2264 \u00b7)] (s : Finset \u03b1) :\n    \u2203 M, \u2200 i \u2208 s, i \u2264 M", "start": [29, 1], "end": [31, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SupClosed.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Order/UpperLower/Basic.lean", "Mathlib/Order/Closure.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SupClosed", "code": "def SupClosed (s : Set \u03b1) : Prop := \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2294 b \u2208 s", "start": [38, 1], "end": [39, 76], "kind": "commanddeclaration"}, {"full_name": "supClosed_empty", "code": "@[simp] lemma supClosed_empty : SupClosed (\u2205 : Set \u03b1) := by simp [SupClosed]", "start": [41, 1], "end": [41, 77], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_singleton", "code": "@[simp] lemma supClosed_singleton : SupClosed ({a} : Set \u03b1) := by simp [SupClosed]", "start": [42, 1], "end": [42, 83], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_univ", "code": "@[simp] lemma supClosed_univ : SupClosed (univ : Set \u03b1) := by simp [SupClosed]", "start": [44, 1], "end": [44, 79], "kind": "mathlibtacticlemma"}, {"full_name": "SupClosed.inter", "code": "lemma SupClosed.inter (hs : SupClosed s) (ht : SupClosed t) : SupClosed (s \u2229 t) :=\n\u03bb _a ha _b hb \u21a6 \u27e8hs ha.1 hb.1, ht ha.2 hb.2\u27e9", "start": [45, 1], "end": [46, 45], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_sInter", "code": "lemma supClosed_sInter (hS : \u2200 s \u2208 S, SupClosed s) : SupClosed (\u22c2\u2080 S) :=\n\u03bb _a ha _b hb _s hs \u21a6 hS _ hs (ha _ hs) (hb _ hs)", "start": [48, 1], "end": [49, 50], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_iInter", "code": "lemma supClosed_iInter (hf : \u2200 i, SupClosed (f i)) : SupClosed (\u22c2 i, f i) :=\nsupClosed_sInter $ forall_range_iff.2 hf", "start": [51, 1], "end": [52, 41], "kind": "mathlibtacticlemma"}, {"full_name": "SupClosed.directedOn", "code": "lemma SupClosed.directedOn (hs : SupClosed s) : DirectedOn (\u00b7 \u2264 \u00b7) s :=\n\u03bb _a ha _b hb \u21a6 \u27e8_, hs ha hb, le_sup_left, le_sup_right\u27e9", "start": [54, 1], "end": [55, 57], "kind": "mathlibtacticlemma"}, {"full_name": "IsUpperSet.supClosed", "code": "lemma IsUpperSet.supClosed (hs : IsUpperSet s) : SupClosed s := fun _a _ _b \u21a6 hs le_sup_right", "start": [57, 1], "end": [57, 94], "kind": "mathlibtacticlemma"}, {"full_name": "SupClosed.finsetSup'_mem", "code": "lemma SupClosed.finsetSup'_mem (hs : SupClosed s) (ht : t.Nonempty) :\n    (\u2200 i \u2208 t, f i \u2208 s) \u2192 t.sup' ht f \u2208 s :=\n  sup'_induction _ _ hs", "start": [65, 1], "end": [67, 24], "kind": "mathlibtacticlemma"}, {"full_name": "SupClosed.finsetSup_mem", "code": "lemma SupClosed.finsetSup_mem [OrderBot \u03b1] (hs : SupClosed s) (ht : t.Nonempty) :\n    (\u2200 i \u2208 t, f i \u2208 s) \u2192 t.sup f \u2208 s :=\n  sup'_eq_sup ht f \u25b8 hs.finsetSup'_mem ht", "start": [69, 1], "end": [71, 42], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed", "code": "def InfClosed (s : Set \u03b1) : Prop := \u2200 \u2983a\u2984, a \u2208 s \u2192 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2293 b \u2208 s", "start": [84, 1], "end": [85, 76], "kind": "commanddeclaration"}, {"full_name": "infClosed_empty", "code": "@[simp] lemma infClosed_empty : InfClosed (\u2205 : Set \u03b1) := by simp [InfClosed]", "start": [87, 1], "end": [87, 77], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_singleton", "code": "@[simp] lemma infClosed_singleton : InfClosed ({a} : Set \u03b1) := by simp [InfClosed]", "start": [88, 1], "end": [88, 83], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_univ", "code": "@[simp] lemma infClosed_univ : InfClosed (univ : Set \u03b1) := by simp [InfClosed]", "start": [90, 1], "end": [90, 79], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.inter", "code": "lemma InfClosed.inter (hs : InfClosed s) (ht : InfClosed t) : InfClosed (s \u2229 t) :=\n\u03bb _a ha _b hb \u21a6 \u27e8hs ha.1 hb.1, ht ha.2 hb.2\u27e9", "start": [91, 1], "end": [92, 45], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_sInter", "code": "lemma infClosed_sInter (hS : \u2200 s \u2208 S, InfClosed s) : InfClosed (\u22c2\u2080 S) :=\n\u03bb _a ha _b hb _s hs \u21a6 hS _ hs (ha _ hs) (hb _ hs)", "start": [94, 1], "end": [95, 50], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_iInter", "code": "lemma infClosed_iInter (hf : \u2200 i, InfClosed (f i)) : InfClosed (\u22c2 i, f i) :=\ninfClosed_sInter $ forall_range_iff.2 hf", "start": [97, 1], "end": [98, 41], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.codirectedOn", "code": "lemma InfClosed.codirectedOn (hs : InfClosed s) : DirectedOn (\u00b7 \u2265 \u00b7) s :=\n\u03bb _a ha _b hb \u21a6 \u27e8_, hs ha hb, inf_le_left, inf_le_right\u27e9", "start": [100, 1], "end": [101, 57], "kind": "mathlibtacticlemma"}, {"full_name": "IsLowerSet.infClosed", "code": "lemma IsLowerSet.infClosed (hs : IsLowerSet s) :  InfClosed s := \u03bb _a _ _b \u21a6 hs inf_le_right", "start": [103, 1], "end": [103, 93], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.finsetInf'_mem", "code": "lemma InfClosed.finsetInf'_mem (hs : InfClosed s) (ht : t.Nonempty) :\n    (\u2200 i \u2208 t, f i \u2208 s) \u2192 t.inf' ht f \u2208 s :=\n  inf'_induction _ _ hs", "start": [111, 1], "end": [113, 24], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.finsetInf_mem", "code": "lemma InfClosed.finsetInf_mem [OrderTop \u03b1] (hs : InfClosed s) (ht : t.Nonempty) :\n    (\u2200 i \u2208 t, f i \u2208 s) \u2192 t.inf f \u2208 s :=\n  inf'_eq_inf ht f \u25b8 hs.finsetInf'_mem ht", "start": [115, 1], "end": [117, 42], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_preimage_toDual", "code": "@[simp] lemma supClosed_preimage_toDual {s : Set \u03b1\u1d52\u1d48} : SupClosed (toDual \u207b\u00b9' s) \u2194 InfClosed s :=\nIff.rfl", "start": [128, 1], "end": [129, 8], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_preimage_toDual", "code": "@[simp] lemma infClosed_preimage_toDual {s : Set \u03b1\u1d52\u1d48} : InfClosed (toDual \u207b\u00b9' s) \u2194 SupClosed s :=\nIff.rfl", "start": [131, 1], "end": [132, 8], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_preimage_ofDual", "code": "@[simp] lemma supClosed_preimage_ofDual {s : Set \u03b1} : SupClosed (ofDual \u207b\u00b9' s) \u2194 InfClosed s :=\nIff.rfl", "start": [134, 1], "end": [135, 8], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_preimage_ofDual", "code": "@[simp] lemma infClosed_preimage_ofDual {s : Set \u03b1} : InfClosed (ofDual \u207b\u00b9' s) \u2194 SupClosed s :=\nIff.rfl", "start": [137, 1], "end": [138, 8], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.dual", "code": "alias \u27e8_, InfClosed.dual\u27e9 := supClosed_preimage_ofDual", "start": [140, 1], "end": [140, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SupClosed.dual", "code": "alias \u27e8_, SupClosed.dual\u27e9 := infClosed_preimage_ofDual", "start": [141, 1], "end": [141, 55], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LinearOrder.supClosed", "code": "@[simp] protected lemma LinearOrder.supClosed (s : Set \u03b1) : SupClosed s :=\n\u03bb a ha b hb \u21a6 by cases le_total a b <;> simp [*]", "start": [148, 1], "end": [149, 49], "kind": "mathlibtacticlemma"}, {"full_name": "LinearOrder.infClosed", "code": "@[simp] protected lemma LinearOrder.infClosed (s : Set \u03b1) : InfClosed s :=\n\u03bb a ha b hb \u21a6 by cases le_total a b <;> simp [*]", "start": [151, 1], "end": [152, 49], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure", "code": "def supClosure : ClosureOperator (Set \u03b1) := ClosureOperator.mk\u2083\n  (\u03bb s \u21a6 {a | \u2203 (t : Finset \u03b1) (ht : t.Nonempty), \u2191t \u2286 s \u2227 t.sup' ht id = a})\n  SupClosed\n  (\u03bb s a ha \u21a6 \u27e8{a}, singleton_nonempty _, by simpa\u27e9)\n  (by\n    classical\n    rintro s _ \u27e8t, ht, hts, rfl\u27e9 _ \u27e8u, hu, hus, rfl\u27e9\n    refine' \u27e8_, ht.mono $ subset_union_left _ _, _, sup'_union ht hu _\u27e9\n    rw [coe_union]\n    exact Set.union_subset hts hus)\n  (by rintro s\u2081 s\u2082 hs h\u2082 _ \u27e8t, ht, hts, rfl\u27e9; exact h\u2082.finsetSup'_mem ht \u03bb i hi \u21a6 hs $ hts hi)", "start": [161, 1], "end": [172, 95], "kind": "commanddeclaration"}, {"full_name": "subset_supClosure", "code": "@[simp] lemma subset_supClosure {s : Set \u03b1} : s \u2286 supClosure s := supClosure.le_closure _", "start": [174, 1], "end": [174, 90], "kind": "mathlibtacticlemma"}, {"full_name": "supClosed_supClosure", "code": "@[simp] lemma supClosed_supClosure {s : Set \u03b1} : SupClosed (supClosure s) :=\nClosureOperator.closure_mem_mk\u2083 _", "start": [176, 1], "end": [177, 34], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure_mono", "code": "lemma supClosure_mono : Monotone (supClosure : Set \u03b1 \u2192 Set \u03b1) := supClosure.monotone", "start": [179, 1], "end": [179, 85], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure_eq_self", "code": "@[simp] lemma supClosure_eq_self : supClosure s = s \u2194 SupClosed s := ClosureOperator.mem_mk\u2083_closed", "start": [181, 1], "end": [181, 100], "kind": "mathlibtacticlemma"}, {"full_name": "SupClosed.supClosure_eq", "code": "alias \u27e8_, SupClosed.supClosure_eq\u27e9 := supClosure_eq_self", "start": [183, 1], "end": [183, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "supClosure_idem", "code": "lemma supClosure_idem (s : Set \u03b1) : supClosure (supClosure s) = supClosure s :=\nsupClosure.idempotent _", "start": [185, 1], "end": [186, 24], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure_empty", "code": "@[simp] lemma supClosure_empty : supClosure (\u2205 : Set \u03b1) = \u2205 := by simp", "start": [188, 1], "end": [188, 71], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure_singleton", "code": "@[simp] lemma supClosure_singleton : supClosure {a} = {a} := by simp", "start": [189, 1], "end": [189, 69], "kind": "mathlibtacticlemma"}, {"full_name": "supClosure_univ", "code": "@[simp] lemma supClosure_univ : supClosure (Set.univ : Set \u03b1) = Set.univ := by simp", "start": [190, 1], "end": [190, 84], "kind": "mathlibtacticlemma"}, {"full_name": "upperBounds_supClosure", "code": "@[simp] lemma upperBounds_supClosure (s : Set \u03b1) : upperBounds (supClosure s) = upperBounds s :=\n(upperBounds_mono_set subset_supClosure).antisymm $ by\n  rintro a ha _ \u27e8t, ht, hts, rfl\u27e9\n  exact sup'_le _ _ \u03bb b hb \u21a6 ha $ hts hb", "start": [192, 1], "end": [195, 41], "kind": "mathlibtacticlemma"}, {"full_name": "isLUB_supClosure", "code": "@[simp] lemma isLUB_supClosure : IsLUB (supClosure s) a \u2194 IsLUB s a := by simp [IsLUB]", "start": [197, 1], "end": [197, 87], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure", "code": "def infClosure : ClosureOperator (Set \u03b1) := ClosureOperator.mk\u2083\n  (\u03bb s \u21a6 {a | \u2203 (t : Finset \u03b1) (ht : t.Nonempty), \u2191t \u2286 s \u2227 t.inf' ht id = a})\n  InfClosed\n  (\u03bb s a ha \u21a6 \u27e8{a}, singleton_nonempty _, by simpa\u27e9)\n  (by\n    classical\n    rintro s _ \u27e8t, ht, hts, rfl\u27e9 _ \u27e8u, hu, hus, rfl\u27e9\n    refine' \u27e8_, ht.mono $ subset_union_left _ _, _, inf'_union ht hu _\u27e9\n    rw [coe_union]\n    exact Set.union_subset hts hus)\n  (by rintro s\u2081 s\u2082 hs h\u2082 _ \u27e8t, ht, hts, rfl\u27e9; exact h\u2082.finsetInf'_mem ht \u03bb i hi \u21a6 hs $ hts hi)", "start": [204, 1], "end": [215, 95], "kind": "commanddeclaration"}, {"full_name": "subset_infClosure", "code": "@[simp] lemma subset_infClosure {s : Set \u03b1} : s \u2286 infClosure s := infClosure.le_closure _", "start": [217, 1], "end": [217, 90], "kind": "mathlibtacticlemma"}, {"full_name": "infClosed_infClosure", "code": "@[simp] lemma infClosed_infClosure {s : Set \u03b1} : InfClosed (infClosure s) :=\nClosureOperator.closure_mem_mk\u2083 _", "start": [219, 1], "end": [220, 34], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure_mono", "code": "lemma infClosure_mono : Monotone (infClosure : Set \u03b1 \u2192 Set \u03b1) := infClosure.monotone", "start": [222, 1], "end": [222, 85], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure_eq_self", "code": "@[simp] lemma infClosure_eq_self : infClosure s = s \u2194 InfClosed s := ClosureOperator.mem_mk\u2083_closed", "start": [224, 1], "end": [224, 100], "kind": "mathlibtacticlemma"}, {"full_name": "InfClosed.infClosure_eq", "code": "alias \u27e8_, InfClosed.infClosure_eq\u27e9 := infClosure_eq_self", "start": [226, 1], "end": [226, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "infClosure_idem", "code": "lemma infClosure_idem (s : Set \u03b1) : infClosure (infClosure s) = infClosure s :=\ninfClosure.idempotent _", "start": [228, 1], "end": [229, 24], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure_empty", "code": "@[simp] lemma infClosure_empty : infClosure (\u2205 : Set \u03b1) = \u2205 := by simp", "start": [231, 1], "end": [231, 71], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure_singleton", "code": "@[simp] lemma infClosure_singleton : infClosure {a} = {a} := by simp", "start": [232, 1], "end": [232, 69], "kind": "mathlibtacticlemma"}, {"full_name": "infClosure_univ", "code": "@[simp] lemma infClosure_univ : infClosure (Set.univ : Set \u03b1) = Set.univ := by simp", "start": [233, 1], "end": [233, 84], "kind": "mathlibtacticlemma"}, {"full_name": "lowerBounds_infClosure", "code": "@[simp] lemma lowerBounds_infClosure (s : Set \u03b1) : lowerBounds (infClosure s) = lowerBounds s :=\n(lowerBounds_mono_set subset_infClosure).antisymm $ by\n  rintro a ha _ \u27e8t, ht, hts, rfl\u27e9\n  exact le_inf' _ _ \u03bb b hb \u21a6 ha $ hts hb", "start": [235, 1], "end": [238, 41], "kind": "mathlibtacticlemma"}, {"full_name": "isGLB_infClosure", "code": "@[simp] lemma isGLB_infClosure : IsGLB (infClosure s) a \u2194 IsGLB s a := by simp [IsGLB]", "start": [240, 1], "end": [240, 87], "kind": "mathlibtacticlemma"}, {"full_name": "SemilatticeSup.toCompleteSemilatticeSup", "code": "def SemilatticeSup.toCompleteSemilatticeSup [SemilatticeSup \u03b1] (sSup : Set \u03b1 \u2192 \u03b1)\n    (h : \u2200 s, SupClosed s \u2192 IsLUB s (sSup s)) : CompleteSemilatticeSup \u03b1 where\n  sSup := fun s => sSup (supClosure s)\n  le_sSup s a ha := (h _ supClosed_supClosure).1 $ subset_supClosure ha\n  sSup_le s a ha := (isLUB_le_iff $ h _ supClosed_supClosure).2 $ by rwa [upperBounds_supClosure]", "start": [244, 1], "end": [250, 98], "kind": "commanddeclaration"}, {"full_name": "SemilatticeInf.toCompleteSemilatticeInf", "code": "def SemilatticeInf.toCompleteSemilatticeInf [SemilatticeInf \u03b1] (sInf : Set \u03b1 \u2192 \u03b1)\n    (h : \u2200 s, InfClosed s \u2192 IsGLB s (sInf s)) : CompleteSemilatticeInf \u03b1 where\n  sInf := fun s => sInf (infClosure s)\n  sInf_le s a ha := (h _ infClosed_infClosure).1 $ subset_infClosure ha\n  le_sInf s a ha := (le_isGLB_iff $ h _ infClosed_infClosure).2 $ by rwa [lowerBounds_infClosure]", "start": [252, 1], "end": [258, 98], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SupIndep.lean", "imports": ["Mathlib/Data/Finset/Powerset.lean", "Mathlib/Data/Finset/Sigma.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finset/Pairwise.lean", "Mathlib/Data/Fintype/Basic.lean"], "premises": [{"full_name": "Finset.SupIndep", "code": "def SupIndep (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) : Prop :=\n  \u2200 \u2983t\u2984, t \u2286 s \u2192 \u2200 \u2983i\u2984, i \u2208 s \u2192 i \u2209 t \u2192 Disjoint (f i) (t.sup f)", "start": [55, 1], "end": [58, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.subset", "code": "theorem SupIndep.subset (ht : t.SupIndep f) (h : s \u2286 t) : s.SupIndep f", "start": [71, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_empty", "code": "theorem supIndep_empty (f : \u03b9 \u2192 \u03b1) : (\u2205 : Finset \u03b9).SupIndep f", "start": [75, 1], "end": [76, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_singleton", "code": "theorem supIndep_singleton (i : \u03b9) (f : \u03b9 \u2192 \u03b1) : ({i} : Finset \u03b9).SupIndep f", "start": [79, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.pairwiseDisjoint", "code": "theorem SupIndep.pairwiseDisjoint (hs : s.SupIndep f) : (s : Set \u03b9).PairwiseDisjoint f", "start": [85, 1], "end": [87, 88], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.le_sup_iff", "code": "theorem SupIndep.le_sup_iff (hs : s.SupIndep f) (hts : t \u2286 s) (hi : i \u2208 s) (hf : \u2200 i, f i \u2260 \u22a5) :\n    f i \u2264 t.sup f \u2194 i \u2208 t", "start": [90, 1], "end": [94, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_iff_disjoint_erase", "code": "theorem supIndep_iff_disjoint_erase [DecidableEq \u03b9] :\n    s.SupIndep f \u2194 \u2200 i \u2208 s, Disjoint (f i) ((s.erase i).sup f)", "start": [97, 1], "end": [101, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.image", "code": "theorem SupIndep.image [DecidableEq \u03b9] {s : Finset \u03b9'} {g : \u03b9' \u2192 \u03b9} (hs : s.SupIndep (f \u2218 g)) :\n    (s.image g).SupIndep f", "start": [104, 1], "end": [115, 95], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_map", "code": "theorem supIndep_map {s : Finset \u03b9'} {g : \u03b9' \u21aa \u03b9} : (s.map g).SupIndep f \u2194 s.SupIndep (f \u2218 g)", "start": [118, 1], "end": [124, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_pair", "code": "@[simp]\ntheorem supIndep_pair [DecidableEq \u03b9] {i j : \u03b9} (hij : i \u2260 j) :\n    ({i, j} : Finset \u03b9).SupIndep f \u2194 Disjoint (f i) (f j)", "start": [127, 1], "end": [146, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_univ_bool", "code": "theorem supIndep_univ_bool (f : Bool \u2192 \u03b1) :\n    (Finset.univ : Finset Bool).SupIndep f \u2194 Disjoint (f false) (f true)", "start": [149, 1], "end": [152, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_univ_fin_two", "code": "@[simp]\ntheorem supIndep_univ_fin_two (f : Fin 2 \u2192 \u03b1) :\n    (Finset.univ : Finset (Fin 2)).SupIndep f \u2194 Disjoint (f 0) (f 1)", "start": [155, 1], "end": [159, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.attach", "code": "theorem SupIndep.attach (hs : s.SupIndep f) : s.attach.SupIndep fun a => f a", "start": [162, 1], "end": [170, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_attach", "code": "@[simp, nolint simpNF]\ntheorem supIndep_attach : (s.attach.SupIndep fun a => f a) \u2194 s.SupIndep f", "start": [183, 1], "end": [192, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_iff_pairwiseDisjoint", "code": "theorem supIndep_iff_pairwiseDisjoint : s.SupIndep f \u2194 (s : Set \u03b9).PairwiseDisjoint f", "start": [201, 1], "end": [203, 94], "kind": "commanddeclaration"}, {"full_name": "Finset.sup_indep.pairwise_disjoint", "code": "alias \u27e8sup_indep.pairwise_disjoint, _root_.Set.PairwiseDisjoint.supIndep\u27e9 :=\n  supIndep_iff_pairwiseDisjoint", "start": [206, 1], "end": [207, 32], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.PairwiseDisjoint.supIndep", "code": "alias \u27e8sup_indep.pairwise_disjoint, _root_.Set.PairwiseDisjoint.supIndep\u27e9 :=\n  supIndep_iff_pairwiseDisjoint", "start": [206, 1], "end": [207, 32], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.SupIndep.sup", "code": "theorem SupIndep.sup [DecidableEq \u03b9] {s : Finset \u03b9'} {g : \u03b9' \u2192 Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.SupIndep fun i => (g i).sup f) (hg : \u2200 i' \u2208 s, (g i').SupIndep f) :\n    (s.sup g).SupIndep f", "start": [210, 1], "end": [216, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.biUnion", "code": "theorem SupIndep.biUnion [DecidableEq \u03b9] {s : Finset \u03b9'} {g : \u03b9' \u2192 Finset \u03b9} {f : \u03b9 \u2192 \u03b1}\n    (hs : s.SupIndep fun i => (g i).sup f) (hg : \u2200 i' \u2208 s, (g i').SupIndep f) :\n    (s.biUnion g).SupIndep f", "start": [219, 1], "end": [224, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.sigma", "code": "theorem SupIndep.sigma {\u03b2 : \u03b9 \u2192 Type*} {s : Finset \u03b9} {g : \u2200 i, Finset (\u03b2 i)} {f : Sigma \u03b2 \u2192 \u03b1}\n    (hs : s.SupIndep fun i => (g i).sup fun b => f \u27e8i, b\u27e9)\n    (hg : \u2200 i \u2208 s, (g i).SupIndep fun b => f \u27e8i, b\u27e9) : (s.sigma g).SupIndep f", "start": [227, 1], "end": [241, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.SupIndep.product", "code": "theorem SupIndep.product {s : Finset \u03b9} {t : Finset \u03b9'} {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1}\n    (hs : s.SupIndep fun i => t.sup fun i' => f (i, i'))\n    (ht : t.SupIndep fun i' => s.sup fun i => f (i, i')) : (s \u00d7\u02e2 t).SupIndep f", "start": [244, 1], "end": [259, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.supIndep_product_iff", "code": "theorem supIndep_product_iff {s : Finset \u03b9} {t : Finset \u03b9'} {f : \u03b9 \u00d7 \u03b9' \u2192 \u03b1} :\n    (s.product t).SupIndep f \u2194 (s.SupIndep fun i => t.sup fun i' => f (i, i'))\n      \u2227 t.SupIndep fun i' => s.sup fun i => f (i, i')", "start": [262, 1], "end": [271, 90], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.SetIndependent", "code": "def SetIndependent (s : Set \u03b1) : Prop :=\n  \u2200 \u2983a\u2984, a \u2208 s \u2192 Disjoint a (sSup (s \\ {a}))", "start": [287, 1], "end": [290, 45], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.setIndependent_empty", "code": "@[simp]\ntheorem setIndependent_empty : SetIndependent (\u2205 : Set \u03b1)", "start": [295, 1], "end": [297, 32], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.SetIndependent.mono", "code": "theorem SetIndependent.mono {t : Set \u03b1} (hst : t \u2286 s) : SetIndependent t", "start": [300, 1], "end": [301, 70], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.SetIndependent.pairwiseDisjoint", "code": "theorem SetIndependent.pairwiseDisjoint : s.PairwiseDisjoint id", "start": [304, 1], "end": [306, 62], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.setIndependent_pair", "code": "theorem setIndependent_pair {a b : \u03b1} (hab : a \u2260 b) :\n    SetIndependent ({a, b} : Set \u03b1) \u2194 Disjoint a b", "start": [309, 1], "end": [318, 33], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.SetIndependent.disjoint_sSup", "code": "theorem SetIndependent.disjoint_sSup {x : \u03b1} {y : Set \u03b1} (hx : x \u2208 s) (hy : y \u2286 s) (hxy : x \u2209 y) :\n    Disjoint x (sSup y)", "start": [321, 1], "end": [327, 13], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent", "code": "def Independent {\u03b9 : Sort*} {\u03b1 : Type*} [CompleteLattice \u03b1] (t : \u03b9 \u2192 \u03b1) : Prop :=\n  \u2200 i : \u03b9, Disjoint (t i) (\u2a06 (j) (_ : j \u2260 i), t j)", "start": [330, 1], "end": [340, 51], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.setIndependent_iff", "code": "theorem setIndependent_iff {\u03b1 : Type*} [CompleteLattice \u03b1] (s : Set \u03b1) :\n    SetIndependent s \u2194 Independent ((\u2191) : s \u2192 \u03b1)", "start": [343, 1], "end": [347, 32], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_def", "code": "theorem independent_def : Independent t \u2194 \u2200 i : \u03b9, Disjoint (t i) (\u2a06 (j) (_ : j \u2260 i), t j)", "start": [352, 1], "end": [353, 10], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_def'", "code": "theorem independent_def' : Independent t \u2194 \u2200 i, Disjoint (t i) (sSup (t '' { j | j \u2260 i }))", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_def''", "code": "theorem independent_def'' :\n    Independent t \u2194 \u2200 i, Disjoint (t i) (sSup { a | \u2203 (j : _) (_ : j \u2260 i), t j = a })", "start": [361, 1], "end": [364, 8], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_empty", "code": "@[simp]\ntheorem independent_empty (t : Empty \u2192 \u03b1) : Independent t", "start": [367, 1], "end": [369, 7], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_pempty", "code": "@[simp]\ntheorem independent_pempty (t : PEmpty \u2192 \u03b1) : Independent t", "start": [372, 1], "end": [374, 7], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.pairwiseDisjoint", "code": "theorem Independent.pairwiseDisjoint : Pairwise (Disjoint on t)", "start": [377, 1], "end": [379, 50], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.mono", "code": "theorem Independent.mono {s t : \u03b9 \u2192 \u03b1} (hs : Independent s) (hst : t \u2264 s) : Independent t", "start": [382, 1], "end": [383, 62], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.comp", "code": "theorem Independent.comp {\u03b9 \u03b9' : Sort*} {t : \u03b9 \u2192 \u03b1} {f : \u03b9' \u2192 \u03b9} (ht : Independent t)\n    (hf : Injective f) : Independent (t \u2218 f)", "start": [386, 1], "end": [392, 32], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.comp'", "code": "theorem Independent.comp' {\u03b9 \u03b9' : Sort*} {t : \u03b9 \u2192 \u03b1} {f : \u03b9' \u2192 \u03b9} (ht : Independent <| t \u2218 f)\n    (hf : Surjective f) : Independent t", "start": [395, 1], "end": [400, 75], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.setIndependent_range", "code": "theorem Independent.setIndependent_range (ht : Independent t) : SetIndependent <| range t", "start": [403, 1], "end": [406, 39], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.injective", "code": "theorem Independent.injective (ht : Independent t) (h_ne_bot : \u2200 i, t i \u2260 \u22a5) : Injective t", "start": [409, 1], "end": [419, 52], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_pair", "code": "theorem independent_pair {i j : \u03b9} (hij : i \u2260 j) (huniv : \u2200 k, k = i \u2228 k = j) :\n    Independent t \u2194 Disjoint (t i) (t j)", "start": [422, 1], "end": [431, 38], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.map_orderIso", "code": "theorem Independent.map_orderIso {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*} [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) {a : \u03b9 \u2192 \u03b1} (ha : Independent a) : Independent (f \u2218 a)", "start": [434, 1], "end": [438, 74], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_map_orderIso_iff", "code": "@[simp]\ntheorem independent_map_orderIso_iff {\u03b9 : Sort*} {\u03b1 \u03b2 : Type*} [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] (f : \u03b1 \u2243o \u03b2) {a : \u03b9 \u2192 \u03b1} : Independent (f \u2218 a) \u2194 Independent a", "start": [441, 1], "end": [447, 31], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.disjoint_biSup", "code": "theorem Independent.disjoint_biSup {\u03b9 : Type*} {\u03b1 : Type*} [CompleteLattice \u03b1] {t : \u03b9 \u2192 \u03b1}\n    (ht : Independent t) {x : \u03b9} {y : Set \u03b9} (hx : x \u2209 y) : Disjoint (t x) (\u2a06 i \u2208 y, t i)", "start": [450, 1], "end": [454, 87], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_iff_supIndep", "code": "theorem CompleteLattice.independent_iff_supIndep [CompleteLattice \u03b1] {s : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} :\n    CompleteLattice.Independent (f \u2218 ((\u2191) : s \u2192 \u03b9)) \u2194 s.SupIndep f", "start": [459, 1], "end": [468, 42], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.supIndep", "code": "alias \u27e8CompleteLattice.Independent.supIndep, Finset.SupIndep.independent\u27e9 :=\n  CompleteLattice.independent_iff_supIndep", "start": [471, 1], "end": [472, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.SupIndep.independent", "code": "alias \u27e8CompleteLattice.Independent.supIndep, Finset.SupIndep.independent\u27e9 :=\n  CompleteLattice.independent_iff_supIndep", "start": [471, 1], "end": [472, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "CompleteLattice.independent_iff_supIndep_univ", "code": "theorem CompleteLattice.independent_iff_supIndep_univ [CompleteLattice \u03b1] [Fintype \u03b9] {f : \u03b9 \u2192 \u03b1} :\n    CompleteLattice.Independent f \u2194 Finset.univ.SupIndep f", "start": [476, 1], "end": [480, 95], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.sup_indep_univ", "code": "alias \u27e8CompleteLattice.Independent.sup_indep_univ, Finset.SupIndep.independent_of_univ\u27e9 :=\n  CompleteLattice.independent_iff_supIndep_univ", "start": [483, 1], "end": [484, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.SupIndep.independent_of_univ", "code": "alias \u27e8CompleteLattice.Independent.sup_indep_univ, Finset.SupIndep.independent_of_univ\u27e9 :=\n  CompleteLattice.independent_iff_supIndep_univ", "start": [483, 1], "end": [484, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "CompleteLattice.setIndependent_iff_pairwiseDisjoint", "code": "theorem setIndependent_iff_pairwiseDisjoint {s : Set \u03b1} :\n    SetIndependent s \u2194 s.PairwiseDisjoint id", "start": [494, 1], "end": [497, 64], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.setIndependent", "code": "alias \u27e8_, _root_.Set.PairwiseDisjoint.setIndependent\u27e9 := setIndependent_iff_pairwiseDisjoint", "start": [500, 1], "end": [500, 93], "kind": "stdtacticaliasaliaslr"}, {"full_name": "CompleteLattice.independent_iff_pairwiseDisjoint", "code": "theorem independent_iff_pairwiseDisjoint {f : \u03b9 \u2192 \u03b1} : Independent f \u2194 Pairwise (Disjoint on f)", "start": [503, 1], "end": [505, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finite/Set.lean", "imports": ["Mathlib/Data/Fintype/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finite.Set.finite_of_finite_image", "code": "theorem Finite.Set.finite_of_finite_image (s : Set \u03b1) {f : \u03b1 \u2192 \u03b2} (h : s.InjOn f)\n    [Finite (f '' s)] : Finite s", "start": [27, 1], "end": [29, 71], "kind": "commanddeclaration"}, {"full_name": "Finite.of_injective_finite_range", "code": "theorem Finite.of_injective_finite_range {f : \u03b9 \u2192 \u03b1} (hf : Function.Injective f)\n    [Finite (range f)] : Finite \u03b9", "start": [32, 1], "end": [34, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Ring/RingNF.lean", "imports": ["Mathlib/Util/Qq.lean", "Mathlib/Tactic/Ring/Basic.lean", "Mathlib/Tactic/Conv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Ring.ExBase.isAtom", "code": "def ExBase.isAtom : ExBase s\u03b1 a \u2192 Bool\n  | .atom _ => true\n  | _ => false", "start": [31, 1], "end": [34, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExProd.isAtom", "code": "def ExProd.isAtom : ExProd s\u03b1 a \u2192 Bool\n  | .mul va\u2081 (.const 1 _) (.const 1 _) => va\u2081.isAtom\n  | _ => false", "start": [36, 1], "end": [39, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Ring.ExSum.isAtom", "code": "def ExSum.isAtom : ExSum s\u03b1 a \u2192 Bool\n  | .add va\u2081 va\u2082 => match va\u2082 with | .zero => va\u2081.isAtom\n    | _ => false\n  | _ => false", "start": [41, 1], "end": [46, 15], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.RingMode", "code": "inductive RingMode where\n  \n  | SOP\n  \n  | raw\n  deriving Inhabited, BEq, Repr", "start": [53, 1], "end": [59, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.Config", "code": "structure Config where\n  \n  red := TransparencyMode.reducible\n  \n  recursive := true\n  \n  mode := RingMode.SOP\n  deriving Inhabited, BEq, Repr", "start": [61, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.Context", "code": "structure Context where\n  \n  ctx : Simp.Context\n  \n  simp : Simp.Result \u2192 SimpM Simp.Result", "start": [74, 1], "end": [80, 41], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.M", "code": "abbrev M := ReaderT Context AtomM", "start": [82, 1], "end": [85, 34], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.rewrite", "code": "def rewrite (parent : Expr) (root := true) : M Simp.Result :=\n  fun nctx rctx s \u21a6 do\n    let pre e :=\n      try\n        guard <| root || parent != e let e \u2190 withReducible <| whnf e\n        guard e.isApp let \u27e8u, \u03b1, e\u27e9 \u2190 inferTypeQ' e\n        let s\u03b1 \u2190 synthInstanceQ (q(CommSemiring $\u03b1) : Q(Type u))\n        let c \u2190 mkCache s\u03b1\n        let \u27e8a, _, pa\u27e9 \u2190 match \u2190 isAtomOrDerivable s\u03b1 c e rctx s with\n        | none => eval s\u03b1 c e rctx s | some none => failure | some (some r) => pure r let r \u2190 nctx.simp { expr := a, proof? := pa }\n        if \u2190 withReducible <| isDefEq r.expr e then return .done { expr := r.expr }\n        pure (.done r)\n      catch _ => pure <| .visit { expr := e }\n    let post := (Simp.postDefault \u00b7 fun _ \u21a6 none)\n    (\u00b7.1) <$> Simp.main parent nctx.ctx (methods := { pre, post })", "start": [87, 1], "end": [111, 67], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.add_assoc_rev", "code": "theorem add_assoc_rev (a b c : R) : a + (b + c) = a + b + c", "start": [115, 1], "end": [115, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.mul_assoc_rev", "code": "theorem mul_assoc_rev (a b c : R) : a * (b * c) = a * b * c", "start": [116, 1], "end": [116, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.mul_neg", "code": "theorem mul_neg {R} [Ring R] (a b : R) : a * -b = -(a * b)", "start": [117, 1], "end": [117, 70], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.add_neg", "code": "theorem add_neg {R} [Ring R] (a b : R) : a + -b = a - b", "start": [118, 1], "end": [118, 84], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.nat_rawCast_0", "code": "theorem nat_rawCast_0 : (Nat.rawCast 0 : R) = 0", "start": [119, 1], "end": [119, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.nat_rawCast_1", "code": "theorem nat_rawCast_1 : (Nat.rawCast 1 : R) = 1", "start": [120, 1], "end": [120, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.nat_rawCast_2", "code": "theorem nat_rawCast_2 [Nat.AtLeastTwo n] : (Nat.rawCast n : R) = OfNat.ofNat n", "start": [121, 1], "end": [121, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.int_rawCast_1", "code": "theorem int_rawCast_1 {R} [Ring R] : (Int.rawCast (.negOfNat 1) : R) = -1", "start": [122, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.int_rawCast_2", "code": "theorem int_rawCast_2 {R} [Ring R] [Nat.AtLeastTwo n] :\n    (Int.rawCast (.negOfNat n) : R) = -OfNat.ofNat n", "start": [124, 1], "end": [126, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.rat_rawCast_2", "code": "theorem rat_rawCast_2 {R} [DivisionRing R] : (Rat.rawCast n d : R) = n / d", "start": [127, 1], "end": [127, 86], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.M.run", "code": "partial def M.run\n    (s : IO.Ref AtomM.State) (cfg : RingNF.Config) (x : M \u03b1) : MetaM \u03b1 := do\n  let ctx := {\n    simpTheorems := #[\u2190 Elab.Tactic.simpOnlyBuiltins.foldlM (\u00b7.addConst \u00b7) {}]\n    congrTheorems := \u2190 getSimpCongrTheorems }\n  let simp \u2190 match cfg.mode with\n  | .raw => pure pure\n  | .SOP =>\n    let thms : SimpTheorems := {}\n    let thms \u2190 [``add_zero, ``add_assoc_rev, ``_root_.mul_one, ``mul_assoc_rev,\n      ``_root_.pow_one, ``mul_neg, ``add_neg].foldlM (\u00b7.addConst \u00b7) thms\n    let thms \u2190 [``nat_rawCast_0, ``nat_rawCast_1, ``nat_rawCast_2, ``int_rawCast_1, ``int_rawCast_2,\n      ``rat_rawCast_2].foldlM (\u00b7.addConst \u00b7 (post := false)) thms\n    let ctx' := { ctx with simpTheorems := #[thms] }\n    pure fun r' : Simp.Result \u21a6 do\n      Simp.mkEqTrans r' (\u2190 Simp.main r'.expr ctx' (methods := Simp.DefaultMethods.methods)).1\n  let nctx := { ctx, simp }\n  let rec\n    \n    rctx := { red := cfg.red, evalAtom },\n    \n    evalAtom := if cfg.recursive\n      then fun e \u21a6 rewrite e false nctx rctx s\n      else fun e \u21a6 pure { expr := e }\n  x nctx rctx s", "start": [129, 1], "end": [162, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.ringNFTarget", "code": "def ringNFTarget (s : IO.Ref AtomM.State) (cfg : Config) : TacticM Unit := withMainContext do\n  let goal \u2190 getMainGoal\n  let tgt \u2190 instantiateMVars (\u2190 goal.getType)\n  let r \u2190 M.run s cfg <| rewrite tgt\n  if r.expr.consumeMData.isConstOf ``True then\n    goal.assign (\u2190 mkOfEqTrue (\u2190 r.getProof))\n    replaceMainGoal []\n  else\n    replaceMainGoal [\u2190 applySimpResultToTarget goal tgt r]", "start": [170, 1], "end": [179, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.ringNFLocalDecl", "code": "def ringNFLocalDecl (s : IO.Ref AtomM.State) (cfg : Config) (fvarId : FVarId) :\n    TacticM Unit := withMainContext do\n  let tgt \u2190 instantiateMVars (\u2190 fvarId.getType)\n  let goal \u2190 getMainGoal\n  let myres \u2190 M.run s cfg <| rewrite tgt\n  match \u2190 applySimpResultToLocalDecl goal fvarId myres false with\n  | none => replaceMainGoal []\n  | some (_, newGoal) => replaceMainGoal [newGoal]", "start": [181, 1], "end": [189, 51], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.RingNF.elabRingNFConv", "code": "@[tactic ringNFConv] def elabRingNFConv : Tactic := fun stx \u21a6 match stx with\n  | `(conv| ring_nf $[!%$tk]? $(_cfg)?) => withMainContext do\n    let mut cfg \u2190 elabConfig stx[2]\n    if tk.isSome then cfg := { cfg with red := .default }\n    let s \u2190 IO.mkRef {}\n    Conv.applySimpResult (\u2190 M.run s cfg <| rewrite (\u2190 instantiateMVars (\u2190 Conv.getLhs)))\n  | _ => Elab.throwUnsupportedSyntax", "start": [229, 1], "end": [236, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/Order.lean", "imports": ["Mathlib/Order/Hom/Basic.lean", "Mathlib/Logic/Function/Iterate.lean", "Mathlib/Order/GaloisConnection.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderHom.coe_sup", "code": "@[simp] lemma coe_sup [SemilatticeSup \u03b2] (f g : \u03b1 \u2192o \u03b2) :\n  ((f \u2294 g : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = (f : \u03b1 \u2192 \u03b2) \u2294 g := rfl", "start": [41, 1], "end": [42, 54], "kind": "mathlibtacticlemma"}, {"full_name": "OrderHom.coe_inf", "code": "@[simp] lemma coe_inf [SemilatticeInf \u03b2] (f g : \u03b1 \u2192o \u03b2) :\n  ((f \u2293 g : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = (f : \u03b1 \u2192 \u03b2) \u2293 g := rfl", "start": [56, 1], "end": [57, 54], "kind": "mathlibtacticlemma"}, {"full_name": "OrderHom.lattice", "code": "instance lattice [Lattice \u03b2] : Lattice (\u03b1 \u2192o \u03b2) :=\n  { (_ : SemilatticeSup (\u03b1 \u2192o \u03b2)), (_ : SemilatticeInf (\u03b1 \u2192o \u03b2)) with }", "start": [63, 1], "end": [64, 72], "kind": "commanddeclaration"}, {"full_name": "OrderHom.orderBot", "code": "instance orderBot [Preorder \u03b2] [OrderBot \u03b2] : OrderBot (\u03b1 \u2192o \u03b2) where\n  bot := \u22a5\n  bot_le _ _ := bot_le", "start": [70, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.instTopOrderHom", "code": "@[simps]\ninstance instTopOrderHom [Preorder \u03b2] [OrderTop \u03b2] : Top (\u03b1 \u2192o \u03b2) where\n  top := const \u03b1 \u22a4", "start": [74, 1], "end": [76, 19], "kind": "commanddeclaration"}, {"full_name": "OrderHom.orderTop", "code": "instance orderTop [Preorder \u03b2] [OrderTop \u03b2] : OrderTop (\u03b1 \u2192o \u03b2) where\n  top := \u22a4\n  le_top _ _ := le_top", "start": [78, 1], "end": [80, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.sInf_apply", "code": "@[simp]\ntheorem sInf_apply [CompleteLattice \u03b2] (s : Set (\u03b1 \u2192o \u03b2)) (x : \u03b1) :\n    sInf s x = \u2a05 f \u2208 s, (f : _) x", "start": [85, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.iInf_apply", "code": "theorem iInf_apply {\u03b9 : Sort*} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) (x : \u03b1) :\n    (\u2a05 i, f i) x = \u2a05 i, f i x", "start": [91, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) :\n    ((\u2a05 i, f i : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = \u2a05 i, (f i : \u03b1 \u2192 \u03b2)", "start": [96, 1], "end": [99, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHom.sSup_apply", "code": "@[simp]\ntheorem sSup_apply [CompleteLattice \u03b2] (s : Set (\u03b1 \u2192o \u03b2)) (x : \u03b1) :\n    sSup s x = \u2a06 f \u2208 s, (f : _) x", "start": [105, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "OrderHom.iSup_apply", "code": "theorem iSup_apply {\u03b9 : Sort*} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) (x : \u03b1) :\n    (\u2a06 i, f i) x = \u2a06 i, f i x", "start": [111, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "OrderHom.coe_iSup", "code": "@[simp, norm_cast]\ntheorem coe_iSup {\u03b9 : Sort*} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) :\n    ((\u2a06 i, f i : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = \u2a06 i, (f i : \u03b1 \u2192 \u03b2)", "start": [116, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHom.iterate_sup_le_sup_iff", "code": "theorem iterate_sup_le_sup_iff {\u03b1 : Type*} [SemilatticeSup \u03b1] (f : \u03b1 \u2192o \u03b1) :\n    (\u2200 n\u2081 n\u2082 a\u2081 a\u2082, f^[n\u2081 + n\u2082] (a\u2081 \u2294 a\u2082) \u2264 f^[n\u2081] a\u2081 \u2294 f^[n\u2082] a\u2082) \u2194\n      \u2200 a\u2081 a\u2082, f (a\u2081 \u2294 a\u2082) \u2264 f a\u2081 \u2294 a\u2082", "start": [133, 1], "end": [154, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Part.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "Mathlib/Data/Set/Basic.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Part", "code": "structure Part.{u} (\u03b1 : Type u) : Type u where\n  \n  Dom : Prop\n  \n  get : Dom \u2192 \u03b1", "start": [49, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Part.toOption", "code": "def toOption (o : Part \u03b1) [Decidable o.Dom] : Option \u03b1 :=\n  if h : Dom o then some (o.get h) else none", "start": [63, 1], "end": [65, 45], "kind": "commanddeclaration"}, {"full_name": "Part.toOption_isSome", "code": "@[simp] lemma toOption_isSome (o : Part \u03b1) [Decidable o.Dom] : o.toOption.isSome \u2194 o.Dom := by\n  by_cases h : o.Dom <;> simp [h, toOption]", "start": [68, 1], "end": [69, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Part.toOption_isNone", "code": "@[simp] lemma toOption_isNone (o : Part \u03b1) [Decidable o.Dom] : o.toOption.isNone \u2194 \u00aco.Dom := by\n  by_cases h : o.Dom <;> simp [h, toOption]", "start": [72, 1], "end": [73, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Part.ext'", "code": "theorem ext' : \u2200 {o p : Part \u03b1} (_ : o.Dom \u2194 p.Dom) (_ : \u2200 h\u2081 h\u2082, o.get h\u2081 = p.get h\u2082), o = p", "start": [76, 1], "end": [80, 57], "kind": "commanddeclaration"}, {"full_name": "Part.eta", "code": "@[simp]\ntheorem eta : \u2200 o : Part \u03b1, (\u27e8o.Dom, fun h => o.get h\u27e9 : Part \u03b1) = o", "start": [83, 1], "end": [86, 18], "kind": "commanddeclaration"}, {"full_name": "Part.Mem", "code": "protected def Mem (a : \u03b1) (o : Part \u03b1) : Prop :=\n  \u2203 h, o.get h = a", "start": [89, 1], "end": [91, 19], "kind": "commanddeclaration"}, {"full_name": "Part.mem_eq", "code": "theorem mem_eq (a : \u03b1) (o : Part \u03b1) : (a \u2208 o) = \u2203 h, o.get h = a", "start": [97, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Part.dom_iff_mem", "code": "theorem dom_iff_mem : \u2200 {o : Part \u03b1}, o.Dom \u2194 \u2203 y, y \u2208 o", "start": [101, 1], "end": [102, 61], "kind": "commanddeclaration"}, {"full_name": "Part.get_mem", "code": "theorem get_mem {o : Part \u03b1} (h) : get o h \u2208 o", "start": [105, 1], "end": [106, 11], "kind": "commanddeclaration"}, {"full_name": "Part.mem_mk_iff", "code": "@[simp]\ntheorem mem_mk_iff {p : Prop} {o : p \u2192 \u03b1} {a : \u03b1} : a \u2208 Part.mk p o \u2194 \u2203 h, o h = a", "start": [109, 1], "end": [111, 10], "kind": "commanddeclaration"}, {"full_name": "Part.ext", "code": "@[ext]\ntheorem ext {o p : Part \u03b1} (H : \u2200 a, a \u2208 o \u2194 a \u2208 p) : o = p", "start": [114, 1], "end": [118, 27], "kind": "commanddeclaration"}, {"full_name": "Part.none", "code": "def none : Part \u03b1 :=\n  \u27e8False, False.rec\u27e9", "start": [121, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "Part.not_mem_none", "code": "@[simp]\ntheorem not_mem_none (a : \u03b1) : a \u2209 @none \u03b1", "start": [129, 1], "end": [130, 61], "kind": "commanddeclaration"}, {"full_name": "Part.some", "code": "def some (a : \u03b1) : Part \u03b1 :=\n  \u27e8True, fun _ => a\u27e9", "start": [133, 1], "end": [136, 21], "kind": "commanddeclaration"}, {"full_name": "Part.some_dom", "code": "@[simp]\ntheorem some_dom (a : \u03b1) : (some a).Dom", "start": [139, 1], "end": [141, 10], "kind": "commanddeclaration"}, {"full_name": "Part.mem_unique", "code": "theorem mem_unique : \u2200 {a b : \u03b1} {o : Part \u03b1}, a \u2208 o \u2192 b \u2208 o \u2192 a = b", "start": [144, 1], "end": [145, 44], "kind": "commanddeclaration"}, {"full_name": "Part.Mem.left_unique", "code": "theorem Mem.left_unique : Relator.LeftUnique ((\u00b7 \u2208 \u00b7) : \u03b1 \u2192 Part \u03b1 \u2192 Prop)", "start": [148, 1], "end": [149, 13], "kind": "commanddeclaration"}, {"full_name": "Part.get_eq_of_mem", "code": "theorem get_eq_of_mem {o : Part \u03b1} {a} (h : a \u2208 o) (h') : get o h' = a", "start": [152, 1], "end": [153, 24], "kind": "commanddeclaration"}, {"full_name": "Part.subsingleton", "code": "protected theorem subsingleton (o : Part \u03b1) : Set.Subsingleton { a | a \u2208 o }", "start": [156, 1], "end": [157, 19], "kind": "commanddeclaration"}, {"full_name": "Part.get_some", "code": "@[simp]\ntheorem get_some {a : \u03b1} (ha : (some a).Dom) : get (some a) ha = a", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "Part.mem_some", "code": "theorem mem_some (a : \u03b1) : a \u2208 some a", "start": [165, 1], "end": [166, 17], "kind": "commanddeclaration"}, {"full_name": "Part.mem_some_iff", "code": "@[simp]\ntheorem mem_some_iff {a b} : b \u2208 (some a : Part \u03b1) \u2194 b = a", "start": [169, 1], "end": [171, 53], "kind": "commanddeclaration"}, {"full_name": "Part.eq_some_iff", "code": "theorem eq_some_iff {a : \u03b1} {o : Part \u03b1} : o = some a \u2194 a \u2208 o", "start": [174, 1], "end": [175, 91], "kind": "commanddeclaration"}, {"full_name": "Part.eq_none_iff", "code": "theorem eq_none_iff {o : Part \u03b1} : o = none \u2194 \u2200 a, a \u2209 o", "start": [178, 1], "end": [179, 60], "kind": "commanddeclaration"}, {"full_name": "Part.eq_none_iff'", "code": "theorem eq_none_iff' {o : Part \u03b1} : o = none \u2194 \u00aco.Dom", "start": [182, 1], "end": [183, 70], "kind": "commanddeclaration"}, {"full_name": "Part.not_none_dom", "code": "@[simp]\ntheorem not_none_dom : \u00ac(none : Part \u03b1).Dom", "start": [186, 1], "end": [188, 5], "kind": "commanddeclaration"}, {"full_name": "Part.some_ne_none", "code": "@[simp]\ntheorem some_ne_none (x : \u03b1) : some x \u2260 none", "start": [191, 1], "end": [194, 40], "kind": "commanddeclaration"}, {"full_name": "Part.none_ne_some", "code": "@[simp]\ntheorem none_ne_some (x : \u03b1) : none \u2260 some x", "start": [197, 1], "end": [199, 24], "kind": "commanddeclaration"}, {"full_name": "Part.ne_none_iff", "code": "theorem ne_none_iff {o : Part \u03b1} : o \u2260 none \u2194 \u2203 x, o = some x", "start": [202, 1], "end": [207, 23], "kind": "commanddeclaration"}, {"full_name": "Part.eq_none_or_eq_some", "code": "theorem eq_none_or_eq_some (o : Part \u03b1) : o = none \u2228 \u2203 x, o = some x", "start": [210, 1], "end": [211, 38], "kind": "commanddeclaration"}, {"full_name": "Part.some_injective", "code": "theorem some_injective : Injective (@Part.some \u03b1)", "start": [214, 1], "end": [215, 50], "kind": "commanddeclaration"}, {"full_name": "Part.some_inj", "code": "@[simp]\ntheorem some_inj {a b : \u03b1} : Part.some a = some b \u2194 a = b", "start": [218, 1], "end": [220, 24], "kind": "commanddeclaration"}, {"full_name": "Part.some_get", "code": "@[simp]\ntheorem some_get {a : Part \u03b1} (ha : a.Dom) : Part.some (Part.get a ha) = a", "start": [223, 1], "end": [225, 36], "kind": "commanddeclaration"}, {"full_name": "Part.get_eq_iff_eq_some", "code": "theorem get_eq_iff_eq_some {a : Part \u03b1} {ha : a.Dom} {b : \u03b1} : a.get ha = b \u2194 a = some b", "start": [228, 1], "end": [229, 52], "kind": "commanddeclaration"}, {"full_name": "Part.get_eq_get_of_eq", "code": "theorem get_eq_get_of_eq (a : Part \u03b1) (ha : a.Dom) {b : Part \u03b1} (h : a = b) :\n    a.get ha = b.get (h \u25b8 ha)", "start": [232, 1], "end": [234, 8], "kind": "commanddeclaration"}, {"full_name": "Part.get_eq_iff_mem", "code": "theorem get_eq_iff_mem {o : Part \u03b1} {a : \u03b1} (h : o.Dom) : o.get h = a \u2194 a \u2208 o", "start": [237, 1], "end": [238, 37], "kind": "commanddeclaration"}, {"full_name": "Part.eq_get_iff_mem", "code": "theorem eq_get_iff_mem {o : Part \u03b1} {a : \u03b1} (h : o.Dom) : a = o.get h \u2194 a \u2208 o", "start": [241, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "Part.none_toOption", "code": "@[simp]\ntheorem none_toOption [Decidable (@none \u03b1).Dom] : (none : Part \u03b1).toOption = Option.none", "start": [245, 1], "end": [247, 13], "kind": "commanddeclaration"}, {"full_name": "Part.some_toOption", "code": "@[simp]\ntheorem some_toOption (a : \u03b1) [Decidable (some a).Dom] : (some a).toOption = Option.some a", "start": [250, 1], "end": [252, 18], "kind": "commanddeclaration"}, {"full_name": "Part.noneDecidable", "code": "instance noneDecidable : Decidable (@none \u03b1).Dom :=\n  instDecidableFalse", "start": [255, 1], "end": [256, 21], "kind": "commanddeclaration"}, {"full_name": "Part.someDecidable", "code": "instance someDecidable (a : \u03b1) : Decidable (some a).Dom :=\n  instDecidableTrue", "start": [259, 1], "end": [260, 20], "kind": "commanddeclaration"}, {"full_name": "Part.getOrElse", "code": "def getOrElse (a : Part \u03b1) [Decidable a.Dom] (d : \u03b1) :=\n  if ha : a.Dom then a.get ha else d", "start": [263, 1], "end": [266, 37], "kind": "commanddeclaration"}, {"full_name": "Part.getOrElse_of_dom", "code": "theorem getOrElse_of_dom (a : Part \u03b1) (h : a.Dom) [Decidable a.Dom] (d : \u03b1) :\n    getOrElse a d = a.get h", "start": [269, 1], "end": [271, 12], "kind": "commanddeclaration"}, {"full_name": "Part.getOrElse_of_not_dom", "code": "theorem getOrElse_of_not_dom (a : Part \u03b1) (h : \u00aca.Dom) [Decidable a.Dom] (d : \u03b1) :\n    getOrElse a d = d", "start": [274, 1], "end": [276, 12], "kind": "commanddeclaration"}, {"full_name": "Part.getOrElse_none", "code": "@[simp]\ntheorem getOrElse_none (d : \u03b1) [Decidable (none : Part \u03b1).Dom] : getOrElse none d = d", "start": [279, 1], "end": [281, 43], "kind": "commanddeclaration"}, {"full_name": "Part.getOrElse_some", "code": "@[simp]\ntheorem getOrElse_some (a : \u03b1) (d : \u03b1) [Decidable (some a).Dom] : getOrElse (some a) d = a", "start": [284, 1], "end": [286, 43], "kind": "commanddeclaration"}, {"full_name": "Part.mem_toOption", "code": "theorem mem_toOption {o : Part \u03b1} [Decidable o.Dom] {a : \u03b1} : a \u2208 toOption o \u2194 a \u2208 o", "start": [290, 1], "end": [294, 26], "kind": "commanddeclaration"}, {"full_name": "Part.toOption_eq_some_iff", "code": "@[simp]\ntheorem toOption_eq_some_iff {o : Part \u03b1} [Decidable o.Dom] {a : \u03b1} :\n    toOption o = Option.some a \u2194 a \u2208 o", "start": [298, 1], "end": [301, 41], "kind": "commanddeclaration"}, {"full_name": "Part.Dom.toOption", "code": "protected theorem Dom.toOption {o : Part \u03b1} [Decidable o.Dom] (h : o.Dom) : o.toOption = o.get h", "start": [303, 1], "end": [304, 12], "kind": "commanddeclaration"}, {"full_name": "Part.toOption_eq_none_iff", "code": "theorem toOption_eq_none_iff {a : Part \u03b1} [Decidable a.Dom] : a.toOption = Option.none \u2194 \u00aca.Dom", "start": [307, 1], "end": [308, 54], "kind": "commanddeclaration"}, {"full_name": "Part.elim_toOption", "code": "theorem elim_toOption {\u03b1 \u03b2 : Type*} (a : Part \u03b1) [Decidable a.Dom] (b : \u03b2) (f : \u03b1 \u2192 \u03b2) :\n    a.toOption.elim b f = if h : a.Dom then f (a.get h) else b", "start": [313, 1], "end": [319, 8], "kind": "commanddeclaration"}, {"full_name": "Part.ofOption", "code": "@[coe]\ndef ofOption : Option \u03b1 \u2192 Part \u03b1\n  | Option.none => none\n  | Option.some a => some a", "start": [322, 1], "end": [326, 28], "kind": "commanddeclaration"}, {"full_name": "Part.mem_ofOption", "code": "@[simp]\ntheorem mem_ofOption {a : \u03b1} : \u2200 {o : Option \u03b1}, a \u2208 ofOption o \u2194 a \u2208 o", "start": [329, 1], "end": [332, 99], "kind": "commanddeclaration"}, {"full_name": "Part.ofOption_dom", "code": "@[simp]\ntheorem ofOption_dom {\u03b1} : \u2200 o : Option \u03b1, (ofOption o).Dom \u2194 o.isSome", "start": [335, 1], "end": [338, 40], "kind": "commanddeclaration"}, {"full_name": "Part.ofOption_eq_get", "code": "theorem ofOption_eq_get {\u03b1} (o : Option \u03b1) : ofOption o = \u27e8_, @Option.get _ o\u27e9", "start": [341, 1], "end": [345, 10], "kind": "commanddeclaration"}, {"full_name": "Part.mem_coe", "code": "theorem mem_coe {a : \u03b1} {o : Option \u03b1} : a \u2208 (o : Part \u03b1) \u2194 a \u2208 o", "start": [351, 1], "end": [352, 15], "kind": "commanddeclaration"}, {"full_name": "Part.coe_none", "code": "@[simp]\ntheorem coe_none : (@Option.none \u03b1 : Part \u03b1) = none", "start": [355, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "Part.coe_some", "code": "@[simp]\ntheorem coe_some (a : \u03b1) : (Option.some a : Part \u03b1) = some a", "start": [360, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "Part.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {P : Part \u03b1 \u2192 Prop} (a : Part \u03b1) (hnone : P none)\n    (hsome : \u2200 a : \u03b1, P (some a)) : P a", "start": [365, 1], "end": [369, 36], "kind": "commanddeclaration"}, {"full_name": "Part.ofOptionDecidable", "code": "instance ofOptionDecidable : \u2200 o : Option \u03b1, Decidable (ofOption o).Dom\n  | Option.none => Part.noneDecidable\n  | Option.some a => Part.someDecidable a", "start": [372, 1], "end": [374, 42], "kind": "commanddeclaration"}, {"full_name": "Part.to_ofOption", "code": "@[simp]\ntheorem to_ofOption (o : Option \u03b1) : toOption (ofOption o) = o", "start": [377, 1], "end": [378, 85], "kind": "commanddeclaration"}, {"full_name": "Part.of_toOption", "code": "@[simp]\ntheorem of_toOption (o : Part \u03b1) [Decidable o.Dom] : ofOption (toOption o) = o", "start": [381, 1], "end": [383, 47], "kind": "commanddeclaration"}, {"full_name": "Part.equivOption", "code": "noncomputable def equivOption : Part \u03b1 \u2243 Option \u03b1 :=\n  haveI := Classical.dec\n  \u27e8fun o => toOption o, ofOption, fun o => of_toOption o, fun o =>\n    Eq.trans (by dsimp; congr) (to_ofOption o)\u27e9", "start": [386, 1], "end": [390, 48], "kind": "commanddeclaration"}, {"full_name": "Part.le_total_of_le_of_le", "code": "theorem le_total_of_le_of_le {x y : Part \u03b1} (z : Part \u03b1) (hx : x \u2264 z) (hy : y \u2264 z) :\n    x \u2264 y \u2228 y \u2264 x", "start": [407, 1], "end": [417, 11], "kind": "commanddeclaration"}, {"full_name": "Part.assert", "code": "def assert (p : Prop) (f : p \u2192 Part \u03b1) : Part \u03b1 :=\n  \u27e8\u2203 h : p, (f h).Dom, fun ha => (f ha.fst).get ha.snd\u27e9", "start": [420, 1], "end": [423, 56], "kind": "commanddeclaration"}, {"full_name": "Part.bind", "code": "protected def bind (f : Part \u03b1) (g : \u03b1 \u2192 Part \u03b2) : Part \u03b2 :=\n  assert (Dom f) fun b => g (f.get b)", "start": [426, 1], "end": [429, 38], "kind": "commanddeclaration"}, {"full_name": "Part.map", "code": "@[simps]\ndef map (f : \u03b1 \u2192 \u03b2) (o : Part \u03b1) : Part \u03b2 :=\n  \u27e8o.Dom, f \u2218 o.get\u27e9", "start": [432, 1], "end": [435, 21], "kind": "commanddeclaration"}, {"full_name": "Part.mem_map", "code": "theorem mem_map (f : \u03b1 \u2192 \u03b2) {o : Part \u03b1} : \u2200 {a}, a \u2208 o \u2192 f a \u2208 map f o", "start": [440, 1], "end": [441, 28], "kind": "commanddeclaration"}, {"full_name": "Part.mem_map_iff", "code": "@[simp]\ntheorem mem_map_iff (f : \u03b1 \u2192 \u03b2) {o : Part \u03b1} {b} : b \u2208 map f o \u2194 \u2203 a \u2208 o, f a = b", "start": [444, 1], "end": [448, 42], "kind": "commanddeclaration"}, {"full_name": "Part.map_none", "code": "@[simp]\ntheorem map_none (f : \u03b1 \u2192 \u03b2) : map f none = none", "start": [451, 1], "end": [453, 33], "kind": "commanddeclaration"}, {"full_name": "Part.map_some", "code": "@[simp]\ntheorem map_some (f : \u03b1 \u2192 \u03b2) (a : \u03b1) : map f (some a) = some (f a)", "start": [456, 1], "end": [458, 43], "kind": "commanddeclaration"}, {"full_name": "Part.mem_assert", "code": "theorem mem_assert {p : Prop} {f : p \u2192 Part \u03b1} : \u2200 {a} (h : p), a \u2208 f h \u2192 a \u2208 assert p f", "start": [461, 1], "end": [462, 36], "kind": "commanddeclaration"}, {"full_name": "Part.mem_assert_iff", "code": "@[simp]\ntheorem mem_assert_iff {p : Prop} {f : p \u2192 Part \u03b1} {a} : a \u2208 assert p f \u2194 \u2203 h : p, a \u2208 f h", "start": [465, 1], "end": [469, 34], "kind": "commanddeclaration"}, {"full_name": "Part.assert_pos", "code": "theorem assert_pos {p : Prop} {f : p \u2192 Part \u03b1} (h : p) : assert p f = f h", "start": [472, 1], "end": [478, 10], "kind": "commanddeclaration"}, {"full_name": "Part.assert_neg", "code": "theorem assert_neg {p : Prop} {f : p \u2192 Part \u03b1} (h : \u00acp) : assert p f = none", "start": [481, 1], "end": [486, 14], "kind": "commanddeclaration"}, {"full_name": "Part.mem_bind", "code": "theorem mem_bind {f : Part \u03b1} {g : \u03b1 \u2192 Part \u03b2} : \u2200 {a b}, a \u2208 f \u2192 b \u2208 g a \u2192 b \u2208 f.bind g", "start": [489, 1], "end": [490, 48], "kind": "commanddeclaration"}, {"full_name": "Part.mem_bind_iff", "code": "@[simp]\ntheorem mem_bind_iff {f : Part \u03b1} {g : \u03b1 \u2192 Part \u03b2} {b} : b \u2208 f.bind g \u2194 \u2203 a \u2208 f, b \u2208 g a", "start": [493, 1], "end": [497, 39], "kind": "commanddeclaration"}, {"full_name": "Part.Dom.bind", "code": "protected theorem Dom.bind {o : Part \u03b1} (h : o.Dom) (f : \u03b1 \u2192 Part \u03b2) : o.bind f = f (o.get h)", "start": [500, 1], "end": [505, 30], "kind": "commanddeclaration"}, {"full_name": "Part.Dom.of_bind", "code": "theorem Dom.of_bind {f : \u03b1 \u2192 Part \u03b2} {a : Part \u03b1} (h : (a.bind f).Dom) : a.Dom", "start": [508, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "Part.bind_none", "code": "@[simp]\ntheorem bind_none (f : \u03b1 \u2192 Part \u03b2) : none.bind f = none", "start": [512, 1], "end": [514, 33], "kind": "commanddeclaration"}, {"full_name": "Part.bind_some", "code": "@[simp]\ntheorem bind_some (a : \u03b1) (f : \u03b1 \u2192 Part \u03b2) : (some a).bind f = f a", "start": [517, 1], "end": [519, 17], "kind": "commanddeclaration"}, {"full_name": "Part.bind_of_mem", "code": "theorem bind_of_mem {o : Part \u03b1} {a : \u03b1} (h : a \u2208 o) (f : \u03b1 \u2192 Part \u03b2) : o.bind f = f a", "start": [522, 1], "end": [523, 34], "kind": "commanddeclaration"}, {"full_name": "Part.bind_some_eq_map", "code": "theorem bind_some_eq_map (f : \u03b1 \u2192 \u03b2) (x : Part \u03b1) : x.bind (some \u2218 f) = map f x", "start": [526, 1], "end": [527, 27], "kind": "commanddeclaration"}, {"full_name": "Part.bind_toOption", "code": "theorem bind_toOption (f : \u03b1 \u2192 Part \u03b2) (o : Part \u03b1) [Decidable o.Dom] [\u2200 a, Decidable (f a).Dom]\n    [Decidable (o.bind f).Dom] :\n    (o.bind f).toOption = o.toOption.elim Option.none fun a => (f a).toOption", "start": [530, 1], "end": [537, 61], "kind": "commanddeclaration"}, {"full_name": "Part.bind_assoc", "code": "theorem bind_assoc {\u03b3} (f : Part \u03b1) (g : \u03b1 \u2192 Part \u03b2) (k : \u03b2 \u2192 Part \u03b3) :\n    (f.bind g).bind k = f.bind fun x => (g x).bind k", "start": [540, 1], "end": [545, 59], "kind": "commanddeclaration"}, {"full_name": "Part.bind_map", "code": "@[simp]\ntheorem bind_map {\u03b3} (f : \u03b1 \u2192 \u03b2) (x) (g : \u03b2 \u2192 Part \u03b3) :\n    (map f x).bind g = x.bind fun y => g (f y)", "start": [548, 1], "end": [550, 95], "kind": "commanddeclaration"}, {"full_name": "Part.map_bind", "code": "@[simp]\ntheorem map_bind {\u03b3} (f : \u03b1 \u2192 Part \u03b2) (x : Part \u03b1) (g : \u03b2 \u2192 \u03b3) :\n    map g (x.bind f) = x.bind fun y => map g (f y)", "start": [553, 1], "end": [556, 63], "kind": "commanddeclaration"}, {"full_name": "Part.map_map", "code": "theorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (o : Part \u03b1) : map g (map f o) = map (g \u2218 f) o", "start": [559, 1], "end": [560, 55], "kind": "commanddeclaration"}, {"full_name": "Part.map_id'", "code": "theorem map_id' {f : \u03b1 \u2192 \u03b1} (H : \u2200 x : \u03b1, f x = x) (o) : map f o = o", "start": [589, 1], "end": [590, 49], "kind": "commanddeclaration"}, {"full_name": "Part.bind_some_right", "code": "@[simp]\ntheorem bind_some_right (x : Part \u03b1) : x.bind some = x", "start": [593, 1], "end": [595, 41], "kind": "commanddeclaration"}, {"full_name": "Part.pure_eq_some", "code": "@[simp]\ntheorem pure_eq_some (a : \u03b1) : pure a = some a", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "Part.ret_eq_some", "code": "@[simp]\ntheorem ret_eq_some (a : \u03b1) : (return a : Part \u03b1) = some a", "start": [603, 1], "end": [605, 6], "kind": "commanddeclaration"}, {"full_name": "Part.map_eq_map", "code": "@[simp]\ntheorem map_eq_map {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (o : Part \u03b1) : f <$> o = map f o", "start": [608, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "Part.bind_eq_bind", "code": "@[simp]\ntheorem bind_eq_bind {\u03b1 \u03b2} (f : Part \u03b1) (g : \u03b1 \u2192 Part \u03b2) : f >>= g = f.bind g", "start": [613, 1], "end": [615, 6], "kind": "commanddeclaration"}, {"full_name": "Part.bind_le", "code": "theorem bind_le {\u03b1} (x : Part \u03b1) (f : \u03b1 \u2192 Part \u03b2) (y : Part \u03b2) :\n    x >>= f \u2264 y \u2194 \u2200 a, a \u2208 x \u2192 f a \u2264 y", "start": [618, 1], "end": [628, 22], "kind": "commanddeclaration"}, {"full_name": "Part.restrict", "code": "def restrict (p : Prop) (o : Part \u03b1) (H : p \u2192 o.Dom) : Part \u03b1 :=\n  \u27e8p, fun h => o.get (H h)\u27e9", "start": [635, 1], "end": [638, 28], "kind": "commanddeclaration"}, {"full_name": "Part.mem_restrict", "code": "@[simp]\ntheorem mem_restrict (p : Prop) (o : Part \u03b1) (h : p \u2192 o.Dom) (a : \u03b1) :\n    a \u2208 restrict p o h \u2194 p \u2227 a \u2208 o", "start": [641, 1], "end": [647, 37], "kind": "commanddeclaration"}, {"full_name": "Part.unwrap", "code": "unsafe def unwrap (o : Part \u03b1) : \u03b1 :=\n  o.get lcProof", "start": [650, 1], "end": [652, 16], "kind": "commanddeclaration"}, {"full_name": "Part.assert_defined", "code": "theorem assert_defined {p : Prop} {f : p \u2192 Part \u03b1} : \u2200 h : p, (f h).Dom \u2192 (assert p f).Dom", "start": [655, 1], "end": [656, 15], "kind": "commanddeclaration"}, {"full_name": "Part.bind_defined", "code": "theorem bind_defined {f : Part \u03b1} {g : \u03b1 \u2192 Part \u03b2} :\n    \u2200 h : f.Dom, (g (f.get h)).Dom \u2192 (f.bind g).Dom", "start": [659, 1], "end": [661, 17], "kind": "commanddeclaration"}, {"full_name": "Part.bind_dom", "code": "@[simp]\ntheorem bind_dom {f : Part \u03b1} {g : \u03b1 \u2192 Part \u03b2} : (f.bind g).Dom \u2194 \u2203 h : f.Dom, (g (f.get h)).Dom", "start": [664, 1], "end": [666, 10], "kind": "commanddeclaration"}, {"full_name": "Part.mul_def", "code": "theorem mul_def [Mul \u03b1] (a b : Part \u03b1) : a * b = bind a fun y \u21a6 map (y * \u00b7) b", "start": [701, 1], "end": [701, 85], "kind": "commanddeclaration"}, {"full_name": "Part.one_def", "code": "theorem one_def [One \u03b1] : (1 : Part \u03b1) = some 1", "start": [702, 1], "end": [702, 55], "kind": "commanddeclaration"}, {"full_name": "Part.inv_def", "code": "theorem inv_def [Inv \u03b1] (a : Part \u03b1) : a\u207b\u00b9 = Part.map (\u00b7 \u207b\u00b9) a", "start": [703, 1], "end": [703, 70], "kind": "commanddeclaration"}, {"full_name": "Part.div_def", "code": "theorem div_def [Div \u03b1] (a b : Part \u03b1) : a / b = bind a fun y => map (y / \u00b7) b", "start": [704, 1], "end": [704, 86], "kind": "commanddeclaration"}, {"full_name": "Part.mod_def", "code": "theorem mod_def [Mod \u03b1] (a b : Part \u03b1) : a % b = bind a fun y => map (y % \u00b7) b", "start": [705, 1], "end": [705, 86], "kind": "commanddeclaration"}, {"full_name": "Part.append_def", "code": "theorem append_def [Append \u03b1] (a b : Part \u03b1) : a ++ b = bind a fun y => map (y ++ \u00b7) b", "start": [706, 1], "end": [706, 94], "kind": "commanddeclaration"}, {"full_name": "Part.inter_def", "code": "theorem inter_def [Inter \u03b1] (a b : Part \u03b1) : a \u2229 b = bind a fun y => map (y \u2229 \u00b7) b", "start": [707, 1], "end": [707, 90], "kind": "commanddeclaration"}, {"full_name": "Part.union_def", "code": "theorem union_def [Union \u03b1] (a b : Part \u03b1) : a \u222a b = bind a fun y => map (y \u222a \u00b7) b", "start": [708, 1], "end": [708, 90], "kind": "commanddeclaration"}, {"full_name": "Part.sdiff_def", "code": "theorem sdiff_def [SDiff \u03b1] (a b : Part \u03b1) : a \\ b = bind a fun y => map (y \\ \u00b7) b", "start": [709, 1], "end": [709, 90], "kind": "commanddeclaration"}, {"full_name": "Part.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one [One \u03b1] : (1 : \u03b1) \u2208 (1 : Part \u03b1)", "start": [713, 1], "end": [715, 17], "kind": "commanddeclaration"}, {"full_name": "Part.mul_mem_mul", "code": "@[to_additive]\ntheorem mul_mem_mul [Mul \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma * mb \u2208 a * b", "start": [719, 1], "end": [721, 69], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_mul_dom", "code": "@[to_additive]\ntheorem left_dom_of_mul_dom [Mul \u03b1] {a b : Part \u03b1} (hab : Dom (a * b)) : a.Dom", "start": [725, 1], "end": [726, 88], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_mul_dom", "code": "@[to_additive]\ntheorem right_dom_of_mul_dom [Mul \u03b1] {a b : Part \u03b1} (hab : Dom (a * b)) : b.Dom", "start": [730, 1], "end": [731, 89], "kind": "commanddeclaration"}, {"full_name": "Part.mul_get_eq", "code": "@[to_additive (attr := simp)]\ntheorem mul_get_eq [Mul \u03b1] (a b : Part \u03b1) (hab : Dom (a * b)) :\n    (a * b).get hab = a.get (left_dom_of_mul_dom hab) * b.get (right_dom_of_mul_dom hab)", "start": [735, 1], "end": [737, 96], "kind": "commanddeclaration"}, {"full_name": "Part.some_mul_some", "code": "@[to_additive]\ntheorem some_mul_some [Mul \u03b1] (a b : \u03b1) : some a * some b = some (a * b)", "start": [741, 1], "end": [742, 94], "kind": "commanddeclaration"}, {"full_name": "Part.inv_mem_inv", "code": "@[to_additive]\ntheorem inv_mem_inv [Inv \u03b1] (a : Part \u03b1) (ma : \u03b1) (ha : ma \u2208 a) : ma\u207b\u00b9 \u2208 a\u207b\u00b9", "start": [746, 1], "end": [748, 27], "kind": "commanddeclaration"}, {"full_name": "Part.inv_some", "code": "@[to_additive]\ntheorem inv_some [Inv \u03b1] (a : \u03b1) : (some a)\u207b\u00b9 = some a\u207b\u00b9", "start": [752, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "Part.div_mem_div", "code": "@[to_additive]\ntheorem div_mem_div [Div \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma / mb \u2208 a / b", "start": [758, 1], "end": [760, 48], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_div_dom", "code": "@[to_additive]\ntheorem left_dom_of_div_dom [Div \u03b1] {a b : Part \u03b1} (hab : Dom (a / b)) : a.Dom", "start": [764, 1], "end": [765, 88], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_div_dom", "code": "@[to_additive]\ntheorem right_dom_of_div_dom [Div \u03b1] {a b : Part \u03b1} (hab : Dom (a / b)) : b.Dom", "start": [769, 1], "end": [770, 89], "kind": "commanddeclaration"}, {"full_name": "Part.div_get_eq", "code": "@[to_additive (attr := simp)]\ntheorem div_get_eq [Div \u03b1] (a b : Part \u03b1) (hab : Dom (a / b)) :\n    (a / b).get hab = a.get (left_dom_of_div_dom hab) / b.get (right_dom_of_div_dom hab)", "start": [774, 1], "end": [777, 27], "kind": "commanddeclaration"}, {"full_name": "Part.some_div_some", "code": "@[to_additive]\ntheorem some_div_some [Div \u03b1] (a b : \u03b1) : some a / some b = some (a / b)", "start": [781, 1], "end": [782, 94], "kind": "commanddeclaration"}, {"full_name": "Part.mod_mem_mod", "code": "theorem mod_mem_mod [Mod \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma % mb \u2208 a % b", "start": [786, 1], "end": [787, 48], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_mod_dom", "code": "theorem left_dom_of_mod_dom [Mod \u03b1] {a b : Part \u03b1} (hab : Dom (a % b)) : a.Dom", "start": [790, 1], "end": [790, 88], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_mod_dom", "code": "theorem right_dom_of_mod_dom [Mod \u03b1] {a b : Part \u03b1} (hab : Dom (a % b)) : b.Dom", "start": [793, 1], "end": [793, 89], "kind": "commanddeclaration"}, {"full_name": "Part.mod_get_eq", "code": "@[simp]\ntheorem mod_get_eq [Mod \u03b1] (a b : Part \u03b1) (hab : Dom (a % b)) :\n    (a % b).get hab = a.get (left_dom_of_mod_dom hab) % b.get (right_dom_of_mod_dom hab)", "start": [796, 1], "end": [799, 27], "kind": "commanddeclaration"}, {"full_name": "Part.some_mod_some", "code": "theorem some_mod_some [Mod \u03b1] (a b : \u03b1) : some a % some b = some (a % b)", "start": [802, 1], "end": [802, 94], "kind": "commanddeclaration"}, {"full_name": "Part.append_mem_append", "code": "theorem append_mem_append [Append \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma ++ mb \u2208 a ++ b", "start": [805, 1], "end": [806, 53], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_append_dom", "code": "theorem left_dom_of_append_dom [Append \u03b1] {a b : Part \u03b1} (hab : Dom (a ++ b)) : a.Dom", "start": [809, 1], "end": [809, 95], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_append_dom", "code": "theorem right_dom_of_append_dom [Append \u03b1] {a b : Part \u03b1} (hab : Dom (a ++ b)) : b.Dom", "start": [812, 1], "end": [812, 96], "kind": "commanddeclaration"}, {"full_name": "Part.append_get_eq", "code": "@[simp]\ntheorem append_get_eq [Append \u03b1] (a b : Part \u03b1) (hab : Dom (a ++ b)) :\n    (a ++ b).get hab = a.get (left_dom_of_append_dom hab) ++ b.get (right_dom_of_append_dom hab)", "start": [815, 1], "end": [818, 30], "kind": "commanddeclaration"}, {"full_name": "Part.some_append_some", "code": "theorem some_append_some [Append \u03b1] (a b : \u03b1) : some a ++ some b = some (a ++ b)", "start": [821, 1], "end": [822, 23], "kind": "commanddeclaration"}, {"full_name": "Part.inter_mem_inter", "code": "theorem inter_mem_inter [Inter \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma \u2229 mb \u2208 a \u2229 b", "start": [825, 1], "end": [826, 50], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_inter_dom", "code": "theorem left_dom_of_inter_dom [Inter \u03b1] {a b : Part \u03b1} (hab : Dom (a \u2229 b)) : a.Dom", "start": [829, 1], "end": [829, 92], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_inter_dom", "code": "theorem right_dom_of_inter_dom [Inter \u03b1] {a b : Part \u03b1} (hab : Dom (a \u2229 b)) : b.Dom", "start": [832, 1], "end": [832, 93], "kind": "commanddeclaration"}, {"full_name": "Part.inter_get_eq", "code": "@[simp]\ntheorem inter_get_eq [Inter \u03b1] (a b : Part \u03b1) (hab : Dom (a \u2229 b)) :\n    (a \u2229 b).get hab = a.get (left_dom_of_inter_dom hab) \u2229 b.get (right_dom_of_inter_dom hab)", "start": [835, 1], "end": [838, 29], "kind": "commanddeclaration"}, {"full_name": "Part.some_inter_some", "code": "theorem some_inter_some [Inter \u03b1] (a b : \u03b1) : some a \u2229 some b = some (a \u2229 b)", "start": [841, 1], "end": [842, 22], "kind": "commanddeclaration"}, {"full_name": "Part.union_mem_union", "code": "theorem union_mem_union [Union \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma \u222a mb \u2208 a \u222a b", "start": [845, 1], "end": [846, 50], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_union_dom", "code": "theorem left_dom_of_union_dom [Union \u03b1] {a b : Part \u03b1} (hab : Dom (a \u222a b)) : a.Dom", "start": [849, 1], "end": [849, 92], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_union_dom", "code": "theorem right_dom_of_union_dom [Union \u03b1] {a b : Part \u03b1} (hab : Dom (a \u222a b)) : b.Dom", "start": [852, 1], "end": [852, 93], "kind": "commanddeclaration"}, {"full_name": "Part.union_get_eq", "code": "@[simp]\ntheorem union_get_eq [Union \u03b1] (a b : Part \u03b1) (hab : Dom (a \u222a b)) :\n    (a \u222a b).get hab = a.get (left_dom_of_union_dom hab) \u222a b.get (right_dom_of_union_dom hab)", "start": [855, 1], "end": [858, 29], "kind": "commanddeclaration"}, {"full_name": "Part.some_union_some", "code": "theorem some_union_some [Union \u03b1] (a b : \u03b1) : some a \u222a some b = some (a \u222a b)", "start": [861, 1], "end": [861, 100], "kind": "commanddeclaration"}, {"full_name": "Part.sdiff_mem_sdiff", "code": "theorem sdiff_mem_sdiff [SDiff \u03b1] (a b : Part \u03b1) (ma mb : \u03b1) (ha : ma \u2208 a) (hb : mb \u2208 b) :\n    ma \\ mb \u2208 a \\ b", "start": [864, 1], "end": [865, 50], "kind": "commanddeclaration"}, {"full_name": "Part.left_dom_of_sdiff_dom", "code": "theorem left_dom_of_sdiff_dom [SDiff \u03b1] {a b : Part \u03b1} (hab : Dom (a \\ b)) : a.Dom", "start": [868, 1], "end": [868, 92], "kind": "commanddeclaration"}, {"full_name": "Part.right_dom_of_sdiff_dom", "code": "theorem right_dom_of_sdiff_dom [SDiff \u03b1] {a b : Part \u03b1} (hab : Dom (a \\ b)) : b.Dom", "start": [871, 1], "end": [871, 93], "kind": "commanddeclaration"}, {"full_name": "Part.sdiff_get_eq", "code": "@[simp]\ntheorem sdiff_get_eq [SDiff \u03b1] (a b : Part \u03b1) (hab : Dom (a \\ b)) :\n    (a \\ b).get hab = a.get (left_dom_of_sdiff_dom hab) \\ b.get (right_dom_of_sdiff_dom hab)", "start": [874, 1], "end": [877, 29], "kind": "commanddeclaration"}, {"full_name": "Part.some_sdiff_some", "code": "theorem some_sdiff_some [SDiff \u03b1] (a b : \u03b1) : some a \\ some b = some (a \\ b)", "start": [880, 1], "end": [880, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Control/Monad/Basic.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "Mathlib/Init/Control/Lawful.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "map_eq_bind_pure_comp", "code": "@[monad_norm]\ntheorem map_eq_bind_pure_comp (m : Type u \u2192 Type v) [Monad m] [LawfulMonad m]\n    (f : \u03b1 \u2192 \u03b2) (x : m \u03b1) : f <$> x = x >>= pure \u2218 f", "start": [45, 1], "end": [48, 28], "kind": "commanddeclaration"}, {"full_name": "StateT.eval", "code": "def StateT.eval {m : Type u \u2192 Type v} [Functor m] (cmd : StateT \u03c3 m \u03b1) (s : \u03c3) : m \u03b1 :=\n  Prod.fst <$> cmd.run s", "start": [51, 1], "end": [53, 25], "kind": "commanddeclaration"}, {"full_name": "StateT.equiv", "code": "def StateT.equiv {m\u2081 : Type u\u2080 \u2192 Type v\u2080} {m\u2082 : Type u\u2081 \u2192 Type v\u2081}\n    (F : (\u03c3\u2081 \u2192 m\u2081 (\u03b1\u2081 \u00d7 \u03c3\u2081)) \u2243 (\u03c3\u2082 \u2192 m\u2082 (\u03b1\u2082 \u00d7 \u03c3\u2082))) : StateT \u03c3\u2081 m\u2081 \u03b1\u2081 \u2243 StateT \u03c3\u2082 m\u2082 \u03b1\u2082 :=\n  F", "start": [56, 1], "end": [60, 4], "kind": "commanddeclaration"}, {"full_name": "ReaderT.equiv", "code": "def ReaderT.equiv {m\u2081 : Type u\u2080 \u2192 Type v\u2080} {m\u2082 : Type u\u2081 \u2192 Type v\u2081}\n    (F : (\u03c1\u2081 \u2192 m\u2081 \u03b1\u2081) \u2243 (\u03c1\u2082 \u2192 m\u2082 \u03b1\u2082)) : ReaderT \u03c1\u2081 m\u2081 \u03b1\u2081 \u2243 ReaderT \u03c1\u2082 m\u2082 \u03b1\u2082 :=\n  F", "start": [63, 1], "end": [67, 4], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Basic.lean", "imports": ["Mathlib/Algebra/Ring/Aut.lean", "Mathlib/LinearAlgebra/Basic.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/ULift.lean", "Mathlib/Algebra/Module/ULift.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Algebra/PUnitInstances.lean", "Mathlib/Data/Rat/Order.lean"], "premises": [{"full_name": "Algebra", "code": "class Algebra (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] extends SMul R A,\n  R \u2192+* A where\n  commutes' : \u2200 r x, toRingHom r * x = x * toRingHom r\n  smul_def' : \u2200 r x, r \u2022 x = toRingHom r * x", "start": [111, 1], "end": [119, 45], "kind": "commanddeclaration"}, {"full_name": "algebraMap", "code": "def algebraMap (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192+* A :=\n  Algebra.toRingHom", "start": [124, 1], "end": [126, 20], "kind": "commanddeclaration"}, {"full_name": "Algebra.cast", "code": "@[coe] def Algebra.cast {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] : R \u2192 A :=\n  algebraMap R A", "start": [129, 1], "end": [131, 17], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coeHTCT", "code": "scoped instance coeHTCT (R A : Type*) [CommSemiring R] [Semiring A] [Algebra R A] :\n    CoeHTCT R A :=\n  \u27e8Algebra.cast\u27e9", "start": [135, 1], "end": [137, 17], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : (\u2191(0 : R) : A) = 0", "start": [144, 1], "end": [146, 28], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : (\u2191(1 : R) : A) = 1", "start": [149, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_add", "code": "@[norm_cast]\ntheorem coe_add (a b : R) : (\u2191(a + b : R) : A) = \u2191a + \u2191b", "start": [154, 1], "end": [156, 31], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_mul", "code": "@[norm_cast]\ntheorem coe_mul (a b : R) : (\u2191(a * b : R) : A) = \u2191a * \u2191b", "start": [159, 1], "end": [161, 31], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_pow", "code": "@[norm_cast]\ntheorem coe_pow (a : R) (n : \u2115) : (\u2191(a ^ n : R) : A) = (a : A) ^ n", "start": [164, 1], "end": [166, 31], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_neg", "code": "@[norm_cast]\ntheorem coe_neg (x : R) : (\u2191(-x : R) : A) = -\u2191x", "start": [175, 1], "end": [177, 29], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod {\u03b9 : Type*} {s : Finset \u03b9} (a : \u03b9 \u2192 R) :\n    (\u2191(\u220f i : \u03b9 in s, a i : R) : A) = \u220f i : \u03b9 in s, (\u2191(a i) : A)", "start": [189, 1], "end": [192, 32], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_sum", "code": "@[norm_cast]\ntheorem coe_sum {\u03b9 : Type*} {s : Finset \u03b9} (a : \u03b9 \u2192 R) :\n    \u2191(\u2211 i : \u03b9 in s, a i) = \u2211 i : \u03b9 in s, (\u2191(a i) : A)", "start": [196, 1], "end": [199, 31], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_inj", "code": "@[norm_cast, simp]\ntheorem coe_inj {a b : R} : (\u2191a : A) = \u2191b \u2194 a = b", "start": [210, 1], "end": [212, 36], "kind": "commanddeclaration"}, {"full_name": "algebraMap.lift_map_eq_zero_iff", "code": "@[norm_cast, simp]\ntheorem lift_map_eq_zero_iff (a : R) : (\u2191a : A) = 0 \u2194 a = 0", "start": [215, 1], "end": [217, 47], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_inv", "code": "@[norm_cast]\ntheorem coe_inv (r : R) : \u2191r\u207b\u00b9 = ((\u2191r)\u207b\u00b9 : A)", "start": [226, 1], "end": [228, 30], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_div", "code": "@[norm_cast]\ntheorem coe_div (r s : R) : \u2191(r / s) = (\u2191r / \u2191s : A)", "start": [231, 1], "end": [233, 32], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_zpow", "code": "@[norm_cast]\ntheorem coe_zpow (r : R) (z : \u2124) : \u2191(r ^ z) = (r : A) ^ z", "start": [236, 1], "end": [238, 33], "kind": "commanddeclaration"}, {"full_name": "algebraMap.coe_ratCast", "code": "@[norm_cast]\ntheorem coe_ratCast (q : \u211a) : \u2191(q : R) = (q : A)", "start": [248, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "RingHom.toAlgebra'", "code": "def RingHom.toAlgebra' {R S} [CommSemiring R] [Semiring S] (i : R \u2192+* S)\n    (h : \u2200 c x, i c * x = x * i c) : Algebra R S where\n  smul c x := i c * x\n  commutes' := h\n  smul_def' _ _ := rfl\n  toRingHom := i", "start": [257, 1], "end": [263, 17], "kind": "commanddeclaration"}, {"full_name": "RingHom.toAlgebra", "code": "def RingHom.toAlgebra {R S} [CommSemiring R] [CommSemiring S] (i : R \u2192+* S) : Algebra R S :=\n  i.toAlgebra' fun _ => mul_comm _", "start": [266, 1], "end": [268, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.algebraMap_toAlgebra", "code": "theorem RingHom.algebraMap_toAlgebra {R S} [CommSemiring R] [CommSemiring S] (i : R \u2192+* S) :\n    @algebraMap R S _ _ i.toAlgebra = i", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofModule'", "code": "@[reducible]\ndef ofModule' [CommSemiring R] [Semiring A] [Module R A]\n    (h\u2081 : \u2200 (r : R) (x : A), r \u2022 (1 : A) * x = r \u2022 x)\n    (h\u2082 : \u2200 (r : R) (x : A), x * r \u2022 (1 : A) = r \u2022 x) : Algebra R A where\n  toFun r := r \u2022 (1 : A)\n  map_one' := one_smul _ _\n  map_mul' r\u2081 r\u2082 := by simp only [h\u2081, mul_smul]\n  map_zero' := zero_smul _ _\n  map_add' r\u2081 r\u2082 := add_smul r\u2081 r\u2082 1\n  commutes' r x := by simp [h\u2081, h\u2082]\n  smul_def' r x := by simp [h\u2081]", "start": [280, 1], "end": [295, 32], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofModule", "code": "@[reducible]\ndef ofModule [CommSemiring R] [Semiring A] [Module R A]\n    (h\u2081 : \u2200 (r : R) (x y : A), r \u2022 x * y = r \u2022 (x * y))\n    (h\u2082 : \u2200 (r : R) (x y : A), x * r \u2022 y = r \u2022 (x * y)) : Algebra R A :=\n  ofModule' (fun r x => by rw [h\u2081, one_mul]) fun r x => by rw [h\u2082, mul_one]", "start": [298, 1], "end": [307, 76], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebra_ext", "code": "@[ext]\ntheorem algebra_ext {R : Type*} [CommSemiring R] {A : Type*} [Semiring A] (P Q : Algebra R A)\n    (h : \u2200 r : R, (haveI := P; algebraMap R A r) = haveI := Q; algebraMap R A r) :\n    P = Q", "start": [318, 1], "end": [331, 8], "kind": "commanddeclaration"}, {"full_name": "Algebra.toModule", "code": "instance (priority := 200) toModule : Module R A where\n  one_smul _ := by simp [smul_def']\n  mul_smul := by simp [smul_def', mul_assoc]\n  smul_add := by simp [smul_def', mul_add]\n  smul_zero := by simp [smul_def']\n  add_smul := by simp [smul_def', add_mul]\n  zero_smul := by simp [smul_def']", "start": [335, 1], "end": [341, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_def", "code": "theorem smul_def (r : R) (x : A) : r \u2022 x = algebraMap R A r * x", "start": [347, 1], "end": [348, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_eq_smul_one", "code": "theorem algebraMap_eq_smul_one (r : R) : algebraMap R A r = r \u2022 (1 : A)", "start": [351, 1], "end": [354, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_eq_smul_one'", "code": "theorem algebraMap_eq_smul_one' : \u21d1(algebraMap R A) = fun r => r \u2022 (1 : A)", "start": [357, 1], "end": [358, 32], "kind": "commanddeclaration"}, {"full_name": "Algebra.commutes", "code": "theorem commutes (r : R) (x : A) : algebraMap R A r * x = x * algebraMap R A r", "start": [361, 1], "end": [363, 24], "kind": "commanddeclaration"}, {"full_name": "Algebra.left_comm", "code": "theorem left_comm (x : A) (r : R) (y : A) :\n    x * (algebraMap R A r * y) = algebraMap R A r * (x * y)", "start": [366, 1], "end": [369, 42], "kind": "commanddeclaration"}, {"full_name": "Algebra.right_comm", "code": "theorem right_comm (x : A) (r : R) (y : A) : x * algebraMap R A r * y = x * y * algebraMap R A r", "start": [372, 1], "end": [374, 43], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.right", "code": "instance _root_.IsScalarTower.right : IsScalarTower R A A :=\n  \u27e8fun x y z => by rw [smul_eq_mul, smul_eq_mul, smul_def, smul_def, mul_assoc]\u27e9", "start": [377, 1], "end": [378, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.mul_smul_comm", "code": "@[simp]\nprotected theorem mul_smul_comm (s : R) (x y : A) : x * s \u2022 y = s \u2022 (x * y)", "start": [384, 1], "end": [388, 37], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_mul_assoc", "code": "@[simp]\nprotected theorem smul_mul_assoc (r : R) (x y : A) : r \u2022 x * y = r \u2022 (x * y)", "start": [391, 1], "end": [395, 23], "kind": "commanddeclaration"}, {"full_name": "smul_algebraMap", "code": "@[simp]\ntheorem _root_.smul_algebraMap {\u03b1 : Type*} [Monoid \u03b1] [MulDistribMulAction \u03b1 A]\n    [SMulCommClass \u03b1 R A] (a : \u03b1) (r : R) : a \u2022 algebraMap R A r = algebraMap R A r", "start": [398, 1], "end": [401, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.linearMap", "code": "protected def linearMap : R \u2192\u2097[R] A :=\n  { algebraMap R A with map_smul' := fun x y => by simp [Algebra.smul_def] }", "start": [419, 1], "end": [423, 77], "kind": "commanddeclaration"}, {"full_name": "Algebra.linearMap_apply", "code": "@[simp]\ntheorem linearMap_apply (r : R) : Algebra.linearMap R A r = algebraMap R A r", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_linearMap", "code": "theorem coe_linearMap : \u21d1(Algebra.linearMap R A) = algebraMap R A", "start": [431, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.id", "code": "instance id : Algebra R R :=\n  (RingHom.id R).toAlgebra", "start": [435, 1], "end": [436, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.id.map_eq_id", "code": "@[simp]\ntheorem map_eq_id : algebraMap R R = RingHom.id _", "start": [443, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.id.map_eq_self", "code": "theorem map_eq_self (x : R) : algebraMap R R x = x", "start": [448, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.id.smul_eq_mul", "code": "@[simp]\ntheorem smul_eq_mul (x y : R) : x \u2022 y = x * y", "start": [452, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "PUnit.algebra", "code": "instance _root_.PUnit.algebra : Algebra R PUnit.{v + 1} where\n  toFun _ := PUnit.unit\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  commutes' _ _ := rfl\n  smul_def' _ _ := rfl", "start": [461, 1], "end": [468, 23], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_pUnit", "code": "@[simp]\ntheorem algebraMap_pUnit (r : R) : algebraMap R PUnit r = PUnit.unit", "start": [471, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.algebra", "code": "instance _root_.ULift.algebra : Algebra R (ULift A) :=\n  { ULift.module',\n    (ULift.ringEquiv : ULift A \u2243+* A).symm.toRingHom.comp (algebraMap R A) with\n    toFun := fun r => ULift.up (algebraMap R A r)\n    commutes' := fun r x => ULift.down_injective <| Algebra.commutes r x.down\n    smul_def' := fun r x => ULift.down_injective <| Algebra.smul_def' r x.down }", "start": [480, 1], "end": [485, 81], "kind": "commanddeclaration"}, {"full_name": "ULift.algebraMap_eq", "code": "theorem _root_.ULift.algebraMap_eq (r : R) :\n    algebraMap R (ULift A) r = ULift.up (algebraMap R A r)", "start": [488, 1], "end": [490, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.down_algebraMap", "code": "@[simp]\ntheorem _root_.ULift.down_algebraMap (r : R) : (algebraMap R (ULift A) r).down = algebraMap R A r", "start": [493, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofSubsemiring", "code": "instance ofSubsemiring (S : Subsemiring R) : Algebra S A where\n  toRingHom := (algebraMap R A).comp S.subtype\n  smul := (\u00b7 \u2022 \u00b7)\n  commutes' r x := Algebra.commutes (r : R) x\n  smul_def' r x := Algebra.smul_def (r : R) x", "start": [500, 1], "end": [505, 46], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_ofSubsemiring", "code": "theorem algebraMap_ofSubsemiring (S : Subsemiring R) :\n    (algebraMap S R : S \u2192+* R) = Subsemiring.subtype S", "start": [508, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_algebraMap_ofSubsemiring", "code": "theorem coe_algebraMap_ofSubsemiring (S : Subsemiring R) : (algebraMap S R : S \u2192 R) = Subtype.val", "start": [513, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_ofSubsemiring_apply", "code": "theorem algebraMap_ofSubsemiring_apply (S : Subsemiring R) (x : S) : algebraMap S R x = x", "start": [517, 1], "end": [518, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofSubring", "code": "instance ofSubring {R A : Type*} [CommRing R] [Ring A] [Algebra R A] (S : Subring R) :\n    Algebra S A where toRingHom := (algebraMap R A).comp S.subtype\n  smul := (\u00b7 \u2022 \u00b7)\n  commutes' r x := Algebra.commutes (r : R) x\n  smul_def' r x := Algebra.smul_def (r : R) x", "start": [521, 1], "end": [527, 46], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_ofSubring", "code": "theorem algebraMap_ofSubring {R : Type*} [CommRing R] (S : Subring R) :\n    (algebraMap S R : S \u2192+* R) = Subring.subtype S", "start": [530, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_algebraMap_ofSubring", "code": "theorem coe_algebraMap_ofSubring {R : Type*} [CommRing R] (S : Subring R) :\n    (algebraMap S R : S \u2192 R) = Subtype.val", "start": [535, 1], "end": [537, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMap_ofSubring_apply", "code": "theorem algebraMap_ofSubring_apply {R : Type*} [CommRing R] (S : Subring R) (x : S) :\n    algebraMap S R x = x", "start": [540, 1], "end": [542, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.algebraMapSubmonoid", "code": "def algebraMapSubmonoid (S : Type*) [Semiring S] [Algebra R S] (M : Submonoid R) : Submonoid S :=\n  M.map (algebraMap R S)", "start": [545, 1], "end": [548, 25], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_algebraMapSubmonoid_of_mem", "code": "theorem mem_algebraMapSubmonoid_of_mem {S : Type*} [Semiring S] [Algebra R S] {M : Submonoid R}\n    (x : M) : algebraMap R S x \u2208 algebraMapSubmonoid S M", "start": [551, 1], "end": [553, 44], "kind": "commanddeclaration"}, {"full_name": "Algebra.mul_sub_algebraMap_commutes", "code": "theorem mul_sub_algebraMap_commutes [Ring A] [Algebra R A] (x : A) (r : R) :\n    x * (x - algebraMap R A r) = (x - algebraMap R A r) * x", "start": [562, 1], "end": [563, 100], "kind": "commanddeclaration"}, {"full_name": "Algebra.mul_sub_algebraMap_pow_commutes", "code": "theorem mul_sub_algebraMap_pow_commutes [Ring A] [Algebra R A] (x : A) (r : R) (n : \u2115) :\n    x * (x - algebraMap R A r) ^ n = (x - algebraMap R A r) ^ n * x", "start": [566, 1], "end": [570, 88], "kind": "commanddeclaration"}, {"full_name": "Algebra.semiringToRing", "code": "@[reducible]\ndef semiringToRing [Semiring A] [Algebra R A] : Ring A :=\n  { Module.addCommMonoidToAddCommGroup R, (inferInstance : Semiring A) with\n    intCast := fun z => algebraMap R A z\n    intCast_ofNat := fun z => by simp only [Int.cast_ofNat, map_natCast]\n    intCast_negSucc := fun z => by simp }", "start": [581, 1], "end": [588, 42], "kind": "commanddeclaration"}, {"full_name": "Module.End.instAlgebra", "code": "instance End.instAlgebra : Algebra R (Module.End S M) :=\n  Algebra.ofModule smul_mul_assoc fun r f g => (smul_comm r f g).symm", "start": [603, 1], "end": [604, 70], "kind": "commanddeclaration"}, {"full_name": "Module.algebraMap_end_eq_smul_id", "code": "theorem algebraMap_end_eq_smul_id (a : R) : algebraMap R (End S M) a = a \u2022 LinearMap.id", "start": [609, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "Module.algebraMap_end_apply", "code": "@[simp]\ntheorem algebraMap_end_apply (a : R) (m : M) : algebraMap R (End S M) a m = a \u2022 m", "start": [612, 1], "end": [614, 6], "kind": "commanddeclaration"}, {"full_name": "Module.ker_algebraMap_end", "code": "@[simp]\ntheorem ker_algebraMap_end (K : Type u) (V : Type v) [Field K] [AddCommGroup V] [Module K V] (a : K)\n    (ha : a \u2260 0) : LinearMap.ker ((algebraMap K (End K V)) a) = \u22a5", "start": [617, 1], "end": [620, 28], "kind": "commanddeclaration"}, {"full_name": "Module.End_algebraMap_isUnit_inv_apply_eq_iff", "code": "theorem End_algebraMap_isUnit_inv_apply_eq_iff {x : R}\n    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :\n    (\u2191(h.unit\u207b\u00b9) : Module.End S M) m = m' \u2194 m = x \u2022 m'", "start": [627, 1], "end": [635, 14], "kind": "commanddeclaration"}, {"full_name": "Module.End_algebraMap_isUnit_inv_apply_eq_iff'", "code": "theorem End_algebraMap_isUnit_inv_apply_eq_iff' {x : R}\n    (h : IsUnit (algebraMap R (Module.End S M) x)) (m m' : M) :\n    m' = (\u2191h.unit\u207b\u00b9 : Module.End S M) m \u2194 m = x \u2022 m'", "start": [638, 1], "end": [646, 14], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_algebraMap_mul", "code": "theorem map_algebraMap_mul (f : A \u2192\u2097[R] B) (a : A) (r : R) :\n    f (algebraMap R A r * a) = algebraMap R B r * f a", "start": [658, 1], "end": [662, 56], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_mul_algebraMap", "code": "theorem map_mul_algebraMap (f : A \u2192\u2097[R] B) (a : A) (r : R) :\n    f (a * algebraMap R A r) = f a * algebraMap R B r", "start": [665, 1], "end": [667, 66], "kind": "commanddeclaration"}, {"full_name": "algebraNat", "code": "instance (priority := 99) algebraNat : Algebra \u2115 R where\n  commutes' := Nat.cast_commute\n  smul_def' _ _ := nsmul_eq_mul _ _\n  toRingHom := Nat.castRingHom R", "start": [679, 1], "end": [683, 33], "kind": "commanddeclaration"}, {"full_name": "nat_algebra_subsingleton", "code": "instance nat_algebra_subsingleton : Subsingleton (Algebra \u2115 R) :=\n  \u27e8fun P Q => by ext; simp\u27e9", "start": [686, 1], "end": [687, 28], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_rat_algebraMap", "code": "@[simp]\ntheorem map_rat_algebraMap [Semiring R] [Semiring S] [Algebra \u211a R] [Algebra \u211a S] (f : R \u2192+* S)\n    (r : \u211a) : f (algebraMap \u211a R r) = algebraMap \u211a S r", "start": [698, 1], "end": [701, 85], "kind": "commanddeclaration"}, {"full_name": "algebraRat", "code": "instance algebraRat {\u03b1} [DivisionRing \u03b1] [CharZero \u03b1] : Algebra \u211a \u03b1 where\n  smul := (\u00b7 \u2022 \u00b7)\n  smul_def' := DivisionRing.qsmul_eq_mul'\n  toRingHom := Rat.castHom \u03b1\n  commutes' := Rat.cast_commute", "start": [708, 1], "end": [712, 32], "kind": "commanddeclaration"}, {"full_name": "algebraMap_rat_rat", "code": "@[simp] theorem algebraMap_rat_rat : algebraMap \u211a \u211a = RingHom.id \u211a", "start": [719, 1], "end": [719, 74], "kind": "commanddeclaration"}, {"full_name": "algebra_rat_subsingleton", "code": "instance algebra_rat_subsingleton {\u03b1} [Semiring \u03b1] : Subsingleton (Algebra \u211a \u03b1) :=\n  \u27e8fun x y => Algebra.algebra_ext x y <| RingHom.congr_fun <| Subsingleton.elim _ _\u27e9", "start": [722, 1], "end": [723, 85], "kind": "commanddeclaration"}, {"full_name": "algebraInt", "code": "instance (priority := 99) algebraInt : Algebra \u2124 R where\n  commutes' := Int.cast_commute\n  smul_def' _ _ := zsmul_eq_mul _ _\n  toRingHom := Int.castRingHom R", "start": [735, 1], "end": [739, 33], "kind": "commanddeclaration"}, {"full_name": "algebraMap_int_eq", "code": "@[simp]\ntheorem algebraMap_int_eq : algebraMap \u2124 R = Int.castRingHom R", "start": [742, 1], "end": [745, 6], "kind": "commanddeclaration"}, {"full_name": "int_algebra_subsingleton", "code": "instance int_algebra_subsingleton : Subsingleton (Algebra \u2124 R) :=\n  \u27e8fun P Q => Algebra.algebra_ext P Q <| RingHom.congr_fun <| Subsingleton.elim _ _\u27e9", "start": [750, 1], "end": [751, 85], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.of_algebraMap_injective", "code": "theorem of_algebraMap_injective [CommSemiring R] [Semiring A] [Algebra R A] [NoZeroDivisors A]\n    (h : Function.Injective (algebraMap R A)) : NoZeroSMulDivisors R A", "start": [762, 1], "end": [770, 45], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.algebraMap_injective", "code": "theorem algebraMap_injective [CommRing R] [Ring A] [Nontrivial A] [Algebra R A]\n    [NoZeroSMulDivisors R A] : Function.Injective (algebraMap R A)", "start": [775, 1], "end": [780, 50], "kind": "commanddeclaration"}, {"full_name": "NeZero.of_noZeroSMulDivisors", "code": "theorem _root_.NeZero.of_noZeroSMulDivisors (n : \u2115) [CommRing R] [NeZero (n : R)] [Ring A]\n    [Nontrivial A] [Algebra R A] [NoZeroSMulDivisors R A] : NeZero (n : A)", "start": [783, 1], "end": [787, 48], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.iff_algebraMap_injective", "code": "theorem iff_algebraMap_injective [CommRing R] [Ring A] [IsDomain A] [Algebra R A] :\n    NoZeroSMulDivisors R A \u2194 Function.Injective (algebraMap R A)", "start": [792, 1], "end": [794, 101], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_nat", "code": "instance (priority := 100) CharZero.noZeroSMulDivisors_nat [Semiring R] [NoZeroDivisors R]\n    [CharZero R] : NoZeroSMulDivisors \u2115 R :=\n  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap \u2115 R).injective_nat", "start": [798, 1], "end": [800, 79], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.CharZero.noZeroSMulDivisors_int", "code": "instance (priority := 100) CharZero.noZeroSMulDivisors_int [Ring R] [NoZeroDivisors R]\n    [CharZero R] : NoZeroSMulDivisors \u2124 R :=\n  NoZeroSMulDivisors.of_algebraMap_injective <| (algebraMap \u2124 R).injective_int", "start": [804, 1], "end": [806, 79], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.Algebra.noZeroSMulDivisors", "code": "instance (priority := 100) Algebra.noZeroSMulDivisors [Nontrivial A] [NoZeroDivisors A] :\n    NoZeroSMulDivisors R A :=\n  NoZeroSMulDivisors.of_algebraMap_injective (algebraMap R A).injective", "start": [814, 1], "end": [816, 72], "kind": "commanddeclaration"}, {"full_name": "algebra_compatible_smul", "code": "theorem algebra_compatible_smul (r : R) (m : M) : r \u2022 m = (algebraMap R A) r \u2022 m", "start": [830, 1], "end": [831, 73], "kind": "commanddeclaration"}, {"full_name": "algebraMap_smul", "code": "@[simp]\ntheorem algebraMap_smul (r : R) (m : M) : (algebraMap R A) r \u2022 m = r \u2022 m", "start": [834, 1], "end": [836, 39], "kind": "commanddeclaration"}, {"full_name": "intCast_smul", "code": "theorem intCast_smul {k V : Type*} [CommRing k] [AddCommGroup V] [Module k V] (r : \u2124) (x : V) :\n    (r : k) \u2022 x = r \u2022 x", "start": [839, 1], "end": [841, 24], "kind": "commanddeclaration"}, {"full_name": "NoZeroSMulDivisors.trans", "code": "theorem NoZeroSMulDivisors.trans (R A M : Type*) [CommRing R] [Ring A] [IsDomain A] [Algebra R A]\n    [AddCommGroup M] [Module R M] [Module A M] [IsScalarTower R A M] [NoZeroSMulDivisors R A]\n    [NoZeroSMulDivisors A M] : NoZeroSMulDivisors R M", "start": [844, 1], "end": [855, 12], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.to_smulCommClass", "code": "instance (priority := 100) IsScalarTower.to_smulCommClass : SMulCommClass R A M :=\n  \u27e8fun r a m => by\n    rw [algebra_compatible_smul A r (a \u2022 m), smul_smul, Algebra.commutes, mul_smul, \u2190\n      algebra_compatible_smul]\u27e9", "start": [861, 1], "end": [864, 32], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.to_smulCommClass'", "code": "instance (priority := 100) IsScalarTower.to_smulCommClass' : SMulCommClass A R M :=\n  SMulCommClass.symm _ _ _", "start": [868, 1], "end": [869, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.to_smulCommClass", "code": "instance (priority := 200) Algebra.to_smulCommClass {R A} [CommSemiring R] [Semiring A]\n    [Algebra R A] : SMulCommClass R A A :=\n  IsScalarTower.to_smulCommClass", "start": [873, 1], "end": [875, 33], "kind": "commanddeclaration"}, {"full_name": "smul_algebra_smul_comm", "code": "theorem smul_algebra_smul_comm (r : R) (a : A) (m : M) : a \u2022 r \u2022 m = r \u2022 a \u2022 m", "start": [878, 1], "end": [879, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ltoFun", "code": "def ltoFun (R : Type u) (M : Type v) (A : Type w) [CommSemiring R] [AddCommMonoid M] [Module R M]\n    [CommSemiring A] [Algebra R A] : (M \u2192\u2097[R] A) \u2192\u2097[A] M \u2192 A where\n  toFun f := f.toFun\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [890, 1], "end": [896, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_restrictScalars", "code": "@[simp]\ntheorem LinearMap.ker_restrictScalars (f : M \u2192\u2097[S] N) :\n    LinearMap.ker (f.restrictScalars R) = f.ker.restrictScalars R", "start": [913, 1], "end": [916, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/FixedPoints/Basic.lean", "imports": ["Mathlib/Logic/Function/Iterate.lean", "Mathlib/GroupTheory/Perm/Basic.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.IsFixedPt", "code": "def IsFixedPt (f : \u03b1 \u2192 \u03b1) (x : \u03b1) :=\n  f x = x", "start": [38, 1], "end": [40, 10], "kind": "commanddeclaration"}, {"full_name": "Function.isFixedPt_id", "code": "theorem isFixedPt_id (x : \u03b1) : IsFixedPt id x", "start": [43, 1], "end": [45, 12], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.decidable", "code": "instance decidable [h : DecidableEq \u03b1] {f : \u03b1 \u2192 \u03b1} {x : \u03b1} : Decidable (IsFixedPt f x) :=\n  h (f x) x", "start": [50, 1], "end": [51, 12], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.eq", "code": "protected theorem eq (hf : IsFixedPt f x) : f x = x", "start": [53, 1], "end": [55, 5], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.comp", "code": "protected theorem comp (hf : IsFixedPt f x) (hg : IsFixedPt g x) : IsFixedPt (f \u2218 g) x", "start": [58, 1], "end": [62, 16], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.iterate", "code": "protected theorem iterate (hf : IsFixedPt f x) (n : \u2115) : IsFixedPt f^[n] x", "start": [65, 1], "end": [67, 21], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.left_of_comp", "code": "theorem left_of_comp (hfg : IsFixedPt (f \u2218 g) x) (hg : IsFixedPt g x) : IsFixedPt f x", "start": [70, 1], "end": [74, 17], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.to_leftInverse", "code": "theorem to_leftInverse (hf : IsFixedPt f x) (h : LeftInverse g f) : IsFixedPt g x", "start": [77, 1], "end": [82, 17], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.map", "code": "protected theorem map {x : \u03b1} (hx : IsFixedPt fa x) {g : \u03b1 \u2192 \u03b2} (h : Semiconj g fa fb) :\n    IsFixedPt fb (g x)", "start": [85, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.apply", "code": "protected theorem apply {x : \u03b1} (hx : IsFixedPt f x) : IsFixedPt f (f x)", "start": [94, 1], "end": [94, 90], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.preimage_iterate", "code": "theorem preimage_iterate {s : Set \u03b1} (h : IsFixedPt (Set.preimage f) s) (n : \u2115) :\n    IsFixedPt (Set.preimage f^[n]) s", "start": [97, 1], "end": [100, 20], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.equiv_symm", "code": "protected theorem equiv_symm (h : IsFixedPt e x) : IsFixedPt e.symm x", "start": [103, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.perm_inv", "code": "protected theorem perm_inv (h : IsFixedPt e x) : IsFixedPt (\u21d1e\u207b\u00b9) x", "start": [107, 1], "end": [108, 15], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.perm_pow", "code": "protected theorem perm_pow (h : IsFixedPt e x) (n : \u2115) : IsFixedPt (\u21d1(e ^ n)) x", "start": [111, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.perm_zpow", "code": "protected theorem perm_zpow (h : IsFixedPt e x) : \u2200 n : \u2124, IsFixedPt (\u21d1(e ^ n)) x", "start": [116, 1], "end": [118, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.isFixedPt_apply_iff", "code": "@[simp]\ntheorem Injective.isFixedPt_apply_iff (hf : Injective f) {x : \u03b1} :\n    IsFixedPt f (f x) \u2194 IsFixedPt f x", "start": [123, 1], "end": [126, 38], "kind": "commanddeclaration"}, {"full_name": "Function.fixedPoints", "code": "def fixedPoints (f : \u03b1 \u2192 \u03b1) : Set \u03b1 :=\n  { x : \u03b1 | IsFixedPt f x }", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "Function.fixedPoints.decidable", "code": "instance fixedPoints.decidable [DecidableEq \u03b1] (f : \u03b1 \u2192 \u03b1) (x : \u03b1) :\n    Decidable (x \u2208 fixedPoints f) :=\n  IsFixedPt.decidable", "start": [134, 1], "end": [136, 22], "kind": "commanddeclaration"}, {"full_name": "Function.mem_fixedPoints", "code": "@[simp]\ntheorem mem_fixedPoints : x \u2208 fixedPoints f \u2194 IsFixedPt f x", "start": [139, 1], "end": [141, 10], "kind": "commanddeclaration"}, {"full_name": "Function.mem_fixedPoints_iff", "code": "theorem mem_fixedPoints_iff {\u03b1 : Type*} {f : \u03b1 \u2192 \u03b1} {x : \u03b1} : x \u2208 fixedPoints f \u2194 f x = x", "start": [144, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "Function.fixedPoints_id", "code": "@[simp]\ntheorem fixedPoints_id : fixedPoints (@id \u03b1) = Set.univ", "start": [148, 1], "end": [150, 49], "kind": "commanddeclaration"}, {"full_name": "Function.fixedPoints_subset_range", "code": "theorem fixedPoints_subset_range : fixedPoints f \u2286 Set.range f", "start": [153, 1], "end": [153, 86], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_fixedPoints", "code": "theorem Semiconj.mapsTo_fixedPoints {g : \u03b1 \u2192 \u03b2} (h : Semiconj g fa fb) :\n    Set.MapsTo g (fixedPoints fa) (fixedPoints fb)", "start": [156, 1], "end": [159, 75], "kind": "commanddeclaration"}, {"full_name": "Function.invOn_fixedPoints_comp", "code": "theorem invOn_fixedPoints_comp (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    Set.InvOn f g (fixedPoints <| f \u2218 g) (fixedPoints <| g \u2218 f)", "start": [162, 1], "end": [166, 29], "kind": "commanddeclaration"}, {"full_name": "Function.mapsTo_fixedPoints_comp", "code": "theorem mapsTo_fixedPoints_comp (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    Set.MapsTo f (fixedPoints <| g \u2218 f) (fixedPoints <| f \u2218 g)", "start": [169, 1], "end": [171, 98], "kind": "commanddeclaration"}, {"full_name": "Function.bijOn_fixedPoints_comp", "code": "theorem bijOn_fixedPoints_comp (f : \u03b1 \u2192 \u03b2) (g : \u03b2 \u2192 \u03b1) :\n    Set.BijOn g (fixedPoints <| f \u2218 g) (fixedPoints <| g \u2218 f)", "start": [174, 1], "end": [178, 97], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.invOn_fixedPoints_comp", "code": "theorem Commute.invOn_fixedPoints_comp (h : Commute f g) :\n    Set.InvOn f g (fixedPoints <| f \u2218 g) (fixedPoints <| f \u2218 g)", "start": [181, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.left_bijOn_fixedPoints_comp", "code": "theorem Commute.left_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn f (fixedPoints <| f \u2218 g) (fixedPoints <| f \u2218 g)", "start": [188, 1], "end": [192, 58], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.right_bijOn_fixedPoints_comp", "code": "theorem Commute.right_bijOn_fixedPoints_comp (h : Commute f g) :\n    Set.BijOn g (fixedPoints <| f \u2218 g) (fixedPoints <| f \u2218 g)", "start": [195, 1], "end": [199, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ENat/Basic.lean", "imports": ["Mathlib/Algebra/Order/Ring/WithTop.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Sub/WithTop.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Data/Nat/SuccPred.lean"], "premises": [{"full_name": "ENat", "code": "def ENat : Type :=\n  WithTop \u2115\nderiving Zero,\n  CanonicallyOrderedCommSemiring, Nontrivial,\n  LinearOrder, Bot, Top, CanonicallyLinearOrderedAddCommMonoid, Sub,\n  LinearOrderedAddCommMonoidWithTop, WellFoundedRelation, Inhabited", "start": [28, 1], "end": [35, 68], "kind": "commanddeclaration"}, {"full_name": "ENat.some_eq_coe", "code": "@[simp] theorem some_eq_coe : (WithTop.some : \u2115 \u2192 \u2115\u221e) = Nat.cast", "start": [58, 1], "end": [60, 72], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_zero", "code": "theorem coe_zero : ((0 : \u2115) : \u2115\u221e) = 0", "start": [64, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_one", "code": "theorem coe_one : ((1 : \u2115) : \u2115\u221e) = 1", "start": [70, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_add", "code": "theorem coe_add (m n : \u2115) : \u2191(m + n) = (m + n : \u2115\u221e)", "start": [76, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (m n : \u2115) : \u2191(m - n) = (m - n : \u2115\u221e)", "start": [80, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_mul", "code": "theorem coe_mul (m n : \u2115) : \u2191(m * n) = (m * n : \u2115\u221e)", "start": [87, 1], "end": [88, 18], "kind": "commanddeclaration"}, {"full_name": "ENat.canLift", "code": "instance canLift : CanLift \u2115\u221e \u2115 (\u2191) fun n => n \u2260 \u22a4 :=\n  WithTop.canLift", "start": [91, 1], "end": [92, 18], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat", "code": "def toNat : MonoidWithZeroHom \u2115\u221e \u2115\n    where\n  toFun := WithTop.untop' 0\n  map_one' := rfl\n  map_zero' := rfl\n  map_mul' := WithTop.untop'_zero_mul", "start": [99, 1], "end": [105, 38], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat_coe", "code": "@[simp]\ntheorem toNat_coe (n : \u2115) : toNat n = n", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat_top", "code": "@[simp]\ntheorem toNat_top : toNat \u22a4 = 0", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.recTopCoe", "code": "@[elab_as_elim]\ndef recTopCoe {C : \u2115\u221e \u2192 Sort*} (h\u2081 : C \u22a4) (h\u2082 : \u2200 a : \u2115, C a) : \u2200 n : \u2115\u221e, C n\n  | none => h\u2081\n  | Option.some a => h\u2082 a", "start": [119, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "ENat.recTopCoe_top", "code": "@[simp]\ntheorem recTopCoe_top {C : \u2115\u221e \u2192 Sort*} (d : C \u22a4) (f : \u2200 a : \u2115, C a) :\n    @recTopCoe C d f \u22a4 = d", "start": [126, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.recTopCoe_coe", "code": "@[simp]\ntheorem recTopCoe_coe {C : \u2115\u221e \u2192 Sort*} (d : C \u22a4) (f : \u2200 a : \u2115, C a) (x : \u2115) :\n    @recTopCoe C d f \u2191x = f x", "start": [132, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.top_ne_coe", "code": "@[simp]\ntheorem top_ne_coe (a : \u2115) : \u22a4 \u2260 (a : \u2115\u221e)", "start": [138, 1], "end": [140, 7], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_ne_top", "code": "@[simp]\ntheorem coe_ne_top (a : \u2115) : (a : \u2115\u221e) \u2260 \u22a4", "start": [143, 1], "end": [145, 7], "kind": "commanddeclaration"}, {"full_name": "ENat.top_sub_coe", "code": "@[simp]\ntheorem top_sub_coe (a : \u2115) : (\u22a4 : \u2115\u221e) - a = \u22a4", "start": [148, 1], "end": [150, 22], "kind": "commanddeclaration"}, {"full_name": "ENat.sub_top", "code": "theorem sub_top (a : \u2115\u221e) : a - \u22a4 = 0", "start": [153, 1], "end": [154, 18], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_toNat_eq_self", "code": "@[simp]\ntheorem coe_toNat_eq_self : ENat.toNat (n : \u2115\u221e) = n \u2194 n \u2260 \u22a4", "start": [156, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "ENat.coe_toNat", "code": "alias \u27e8_, coe_toNat\u27e9 := coe_toNat_eq_self", "start": [161, 1], "end": [161, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ENat.coe_toNat_le_self", "code": "theorem coe_toNat_le_self (n : \u2115\u221e) : \u2191(toNat n) \u2264 n", "start": [164, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat_add", "code": "theorem toNat_add {m n : \u2115\u221e} (hm : m \u2260 \u22a4) (hn : n \u2260 \u22a4) : toNat (m + n) = toNat m + toNat n", "start": [168, 1], "end": [171, 6], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat_sub", "code": "theorem toNat_sub {n : \u2115\u221e} (hn : n \u2260 \u22a4) (m : \u2115\u221e) : toNat (m - n) = toNat m - toNat n", "start": [174, 1], "end": [178, 52], "kind": "commanddeclaration"}, {"full_name": "ENat.toNat_eq_iff", "code": "theorem toNat_eq_iff {m : \u2115\u221e} {n : \u2115} (hn : n \u2260 0) : toNat m = n \u2194 m = n", "start": [181, 1], "end": [182, 54], "kind": "commanddeclaration"}, {"full_name": "ENat.succ_def", "code": "@[simp]\ntheorem succ_def (m : \u2115\u221e) : Order.succ m = m + 1", "start": [185, 1], "end": [186, 71], "kind": "commanddeclaration"}, {"full_name": "ENat.add_one_le_of_lt", "code": "theorem add_one_le_of_lt (h : m < n) : m + 1 \u2264 n", "start": [189, 1], "end": [190, 37], "kind": "commanddeclaration"}, {"full_name": "ENat.add_one_le_iff", "code": "theorem add_one_le_iff (hm : m \u2260 \u22a4) : m + 1 \u2264 n \u2194 m < n", "start": [193, 1], "end": [194, 77], "kind": "commanddeclaration"}, {"full_name": "ENat.one_le_iff_pos", "code": "theorem one_le_iff_pos : 1 \u2264 n \u2194 0 < n", "start": [197, 1], "end": [198, 37], "kind": "commanddeclaration"}, {"full_name": "ENat.one_le_iff_ne_zero", "code": "theorem one_le_iff_ne_zero : 1 \u2264 n \u2194 n \u2260 0", "start": [201, 1], "end": [202, 39], "kind": "commanddeclaration"}, {"full_name": "ENat.le_of_lt_add_one", "code": "theorem le_of_lt_add_one (h : m < n + 1) : m \u2264 n", "start": [205, 1], "end": [206, 45], "kind": "commanddeclaration"}, {"full_name": "ENat.le_coe_iff", "code": "theorem le_coe_iff {n : \u2115\u221e} {k : \u2115} : n \u2264 \u2191k \u2194 \u2203 (n\u2080 : \u2115), n = n\u2080 \u2227 n\u2080 \u2264 k", "start": [209, 1], "end": [210, 21], "kind": "commanddeclaration"}, {"full_name": "ENat.nat_induction", "code": "@[elab_as_elim]\ntheorem nat_induction {P : \u2115\u221e \u2192 Prop} (a : \u2115\u221e) (h0 : P 0) (hsuc : \u2200 n : \u2115, P n \u2192 P n.succ)\n    (htop : (\u2200 n : \u2115, P n) \u2192 P \u22a4) : P a", "start": [212, 1], "end": [218, 14], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Actions.lean", "Mathlib/GroupTheory/Submonoid/MulOpposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.op", "code": "@[to_additive (attr := simps)\n\"Pull an additive subgroup back to an opposite additive subgroup along `AddOpposite.unop`\"]\nprotected def op (H : Subgroup G) : Subgroup G\u1d50\u1d52\u1d56 where\n  carrier := MulOpposite.unop \u207b\u00b9' (H : Set G)\n  one_mem' := H.one_mem\n  mul_mem' ha hb := H.mul_mem hb ha\n  inv_mem' := H.inv_mem", "start": [24, 1], "end": [31, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.unop", "code": "@[to_additive (attr := simps)\n\"Pull an opposite additive subgroup back to an additive subgroup along `AddOpposite.op`\"]\nprotected def unop (H : Subgroup G\u1d50\u1d52\u1d56) : Subgroup G where\n  carrier := MulOpposite.op \u207b\u00b9' (H : Set G\u1d50\u1d52\u1d56)\n  one_mem' := H.one_mem\n  mul_mem' := fun ha hb => H.mul_mem hb ha\n  inv_mem' := H.inv_mem", "start": [33, 1], "end": [40, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.op_toSubmonoid", "code": "@[to_additive (attr := simp, nolint simpNF)] lemma op_toSubmonoid (H : Subgroup G) :\n    H.op.toSubmonoid = H.toSubmonoid.op :=\n  rfl", "start": [42, 1], "end": [44, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Subgroup.unop_toSubmonoid", "code": "@[to_additive (attr := simp, nolint simpNF)] lemma unop_toSubmonoid (H : Subgroup G\u1d50\u1d52\u1d56) :\n    H.unop.toSubmonoid = H.toSubmonoid.unop :=\n  rfl", "start": [46, 1], "end": [48, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Subgroup.opEquiv", "code": "@[to_additive (attr := simps) \"An additive subgroup `H` of `G` determines an additive subgroup\n`H.op` of the opposite additive group `G\u1d43\u1d52\u1d56`.\"]\ndef opEquiv : Subgroup G \u2243 Subgroup G\u1d50\u1d52\u1d56 where\n  toFun := Subgroup.op\n  invFun := Subgroup.unop\n  left_inv _ := SetLike.coe_injective rfl\n  right_inv _ := SetLike.coe_injective rfl", "start": [50, 1], "end": [57, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.equivOp", "code": "@[to_additive (attr := simps!) \"Bijection between an additive subgroup `H` and its opposite.\"]\ndef equivOp (H : Subgroup G) : H \u2243 H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl", "start": [61, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_opposite_mul", "code": "@[to_additive]\ntheorem smul_opposite_mul {H : Subgroup G} (x g : G) (h : H.op) :\n    h \u2022 (g * x) = g * h \u2022 x", "start": [77, 1], "end": [80, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "imports": ["Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "Mathlib/GroupTheory/GroupAction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ConjAct", "code": "def ConjAct : Type _ :=\n  G", "start": [39, 1], "end": [41, 4], "kind": "commanddeclaration"}, {"full_name": "ConjAct.card", "code": "@[simp]\ntheorem card [Fintype G] : Fintype.card (ConjAct G) = Fintype.card G", "start": [58, 1], "end": [60, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct", "code": "def ofConjAct : ConjAct G \u2243* G where\n  toFun := id\n  invFun := id\n  left_inv := fun _ => rfl\n  right_inv := fun _ => rfl\n  map_mul' := fun _ _ => rfl", "start": [70, 1], "end": [76, 29], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct", "code": "def toConjAct : G \u2243* ConjAct G :=\n  ofConjAct.symm", "start": [79, 1], "end": [81, 17], "kind": "commanddeclaration"}, {"full_name": "ConjAct.rec", "code": "protected def rec {C : ConjAct G \u2192 Sort*} (h : \u2200 g, C (toConjAct g)) : \u2200 g, C g :=\n  h", "start": [84, 1], "end": [86, 4], "kind": "commanddeclaration"}, {"full_name": "ConjAct.forall", "code": "@[simp]\ntheorem \u00abforall\u00bb (p : ConjAct G \u2192 Prop) : (\u2200 x : ConjAct G, p x) \u2194 \u2200 x : G, p (toConjAct x)", "start": [89, 1], "end": [91, 13], "kind": "commanddeclaration"}, {"full_name": "ConjAct.of_mul_symm_eq", "code": "@[simp]\ntheorem of_mul_symm_eq : (@ofConjAct G _).symm = toConjAct", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.to_mul_symm_eq", "code": "@[simp]\ntheorem to_mul_symm_eq : (@toConjAct G _).symm = ofConjAct", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct_ofConjAct", "code": "@[simp]\ntheorem toConjAct_ofConjAct (x : ConjAct G) : toConjAct (ofConjAct x) = x", "start": [104, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct_toConjAct", "code": "@[simp]\ntheorem ofConjAct_toConjAct (x : G) : ofConjAct (toConjAct x) = x", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct_one", "code": "theorem ofConjAct_one : ofConjAct (1 : ConjAct G) = 1", "start": [115, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct_one", "code": "theorem toConjAct_one : toConjAct (1 : G) = 1", "start": [120, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct_inv", "code": "@[simp]\ntheorem ofConjAct_inv (x : ConjAct G) : ofConjAct x\u207b\u00b9 = (ofConjAct x)\u207b\u00b9", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct_inv", "code": "@[simp]\ntheorem toConjAct_inv (x : G) : toConjAct x\u207b\u00b9 = (toConjAct x)\u207b\u00b9", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct_mul", "code": "theorem ofConjAct_mul (x y : ConjAct G) : ofConjAct (x * y) = ofConjAct x * ofConjAct y", "start": [135, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct_mul", "code": "theorem toConjAct_mul (x y : G) : toConjAct (x * y) = toConjAct x * toConjAct y", "start": [140, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smul_def", "code": "theorem smul_def (g : ConjAct G) (h : G) : g \u2022 h = ofConjAct g * h * (ofConjAct g)\u207b\u00b9", "start": [146, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.unitsScalar", "code": "instance unitsScalar : SMul (ConjAct M\u02e3) M where smul g h := ofConjAct g * h * \u2191(ofConjAct g)\u207b\u00b9", "start": [158, 1], "end": [158, 96], "kind": "commanddeclaration"}, {"full_name": "ConjAct.units_smul_def", "code": "theorem units_smul_def (g : ConjAct M\u02e3) (h : M) : g \u2022 h = ofConjAct g * h * \u2191(ofConjAct g)\u207b\u00b9", "start": [161, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.unitsMulDistribMulAction", "code": "instance unitsMulDistribMulAction : MulDistribMulAction (ConjAct M\u02e3) M where\n  one_smul := by simp only [units_smul_def, ofConjAct_one, Units.val_one, one_mul, inv_one,\n    mul_one, forall_const]\n  mul_smul := by\n    simp only [units_smul_def]\n    simp only [map_mul, Units.val_mul, mul_assoc, mul_inv_rev, forall_const, \u00abforall\u00bb]\n  smul_mul := by\n    simp only [units_smul_def]\n    simp only [mul_assoc, Units.inv_mul_cancel_left, forall_const, \u00abforall\u00bb]\n  smul_one := by simp [units_smul_def, mul_one, Units.mul_inv, \u00abforall\u00bb, forall_const]", "start": [167, 1], "end": [176, 87], "kind": "commanddeclaration"}, {"full_name": "ConjAct.unitsSMulCommClass", "code": "instance unitsSMulCommClass [SMul \u03b1 M] [SMulCommClass \u03b1 M M] [IsScalarTower \u03b1 M M] :\n    SMulCommClass \u03b1 (ConjAct M\u02e3) M where\n  smul_comm a um m := by rw [units_smul_def, units_smul_def, mul_smul_comm, smul_mul_assoc]", "start": [180, 1], "end": [182, 92], "kind": "commanddeclaration"}, {"full_name": "ConjAct.unitsSMulCommClass'", "code": "instance unitsSMulCommClass' [SMul \u03b1 M] [SMulCommClass M \u03b1 M] [IsScalarTower \u03b1 M M] :\n    SMulCommClass (ConjAct M\u02e3) \u03b1 M :=\n  haveI : SMulCommClass \u03b1 M M := SMulCommClass.symm _ _ _\n  SMulCommClass.symm _ _ _", "start": [185, 1], "end": [188, 27], "kind": "commanddeclaration"}, {"full_name": "ConjAct.unitsMulSemiringAction", "code": "instance unitsMulSemiringAction : MulSemiringAction (ConjAct R\u02e3) R :=\n  { ConjAct.unitsMulDistribMulAction with\n    smul_zero := by\n      simp only [units_smul_def, mul_zero, zero_mul, \u00abforall\u00bb, forall_const]\n    smul_add := by\n      simp only [units_smul_def]\n      simp only [mul_add, add_mul, forall_const, \u00abforall\u00bb] }", "start": [199, 1], "end": [205, 61], "kind": "commanddeclaration"}, {"full_name": "ConjAct.ofConjAct_zero", "code": "theorem ofConjAct_zero : ofConjAct (0 : ConjAct G\u2080) = 0", "start": [217, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.toConjAct_zero", "code": "theorem toConjAct_zero : toConjAct (0 : G\u2080) = 0", "start": [222, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.mulAction\u2080", "code": "instance mulAction\u2080 : MulAction (ConjAct G\u2080) G\u2080 where\n  one_smul := by\n    simp only [smul_def]\n    simp only [map_one, one_mul, inv_one, mul_one, forall_const]\n  mul_smul := by\n    simp only [smul_def]\n    simp only [map_mul, mul_assoc, mul_inv_rev, forall_const, \u00abforall\u00bb]", "start": [228, 1], "end": [234, 72], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smulCommClass\u2080", "code": "instance smulCommClass\u2080 [SMul \u03b1 G\u2080] [SMulCommClass \u03b1 G\u2080 G\u2080] [IsScalarTower \u03b1 G\u2080 G\u2080] :\n    SMulCommClass \u03b1 (ConjAct G\u2080) G\u2080 where\n  smul_comm a ug g := by rw [smul_def, smul_def, mul_smul_comm, smul_mul_assoc]", "start": [237, 1], "end": [239, 80], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smulCommClass\u2080'", "code": "instance smulCommClass\u2080' [SMul \u03b1 G\u2080] [SMulCommClass G\u2080 \u03b1 G\u2080] [IsScalarTower \u03b1 G\u2080 G\u2080] :\n    SMulCommClass (ConjAct G\u2080) \u03b1 G\u2080 :=\n  haveI := SMulCommClass.symm G\u2080 \u03b1 G\u2080\n  SMulCommClass.symm _ _ _", "start": [242, 1], "end": [245, 27], "kind": "commanddeclaration"}, {"full_name": "ConjAct.distribMulAction\u2080", "code": "instance distribMulAction\u2080 : DistribMulAction (ConjAct K) K :=\n  { ConjAct.mulAction\u2080 with\n    smul_zero := by\n      simp only [smul_def]\n      simp only [mul_zero, zero_mul, \u00abforall\u00bb, forall_const]\n    smul_add := by\n      simp only [smul_def]\n      simp only [mul_add, add_mul, forall_const, \u00abforall\u00bb] }", "start": [256, 1], "end": [263, 61], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smulCommClass", "code": "instance smulCommClass [SMul \u03b1 G] [SMulCommClass \u03b1 G G] [IsScalarTower \u03b1 G G] :\n    SMulCommClass \u03b1 (ConjAct G) G where\n  smul_comm a ug g := by rw [smul_def, smul_def, mul_smul_comm, smul_mul_assoc]", "start": [284, 1], "end": [286, 80], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smulCommClass'", "code": "instance smulCommClass' [SMul \u03b1 G] [SMulCommClass G \u03b1 G] [IsScalarTower \u03b1 G G] :\n    SMulCommClass (ConjAct G) \u03b1 G :=\n  haveI := SMulCommClass.symm G \u03b1 G\n  SMulCommClass.symm _ _ _", "start": [289, 1], "end": [292, 27], "kind": "commanddeclaration"}, {"full_name": "ConjAct.smul_eq_mulAut_conj", "code": "theorem smul_eq_mulAut_conj (g : ConjAct G) (h : G) : g \u2022 h = MulAut.conj (ofConjAct g) h", "start": [295, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.fixedPoints_eq_center", "code": "theorem fixedPoints_eq_center : fixedPoints (ConjAct G) G = center G", "start": [299, 1], "end": [302, 57], "kind": "commanddeclaration"}, {"full_name": "ConjAct.mem_orbit_conjAct", "code": "@[simp]\ntheorem mem_orbit_conjAct {g h : G} : g \u2208 orbit (ConjAct G) h \u2194 IsConj g h", "start": [305, 1], "end": [307, 51], "kind": "commanddeclaration"}, {"full_name": "ConjAct.orbitRel_conjAct", "code": "theorem orbitRel_conjAct : (orbitRel (ConjAct G) G).Rel = IsConj", "start": [310, 1], "end": [311, 63], "kind": "commanddeclaration"}, {"full_name": "ConjAct.orbit_eq_carrier_conjClasses", "code": "theorem orbit_eq_carrier_conjClasses [Group G] (g : G) :\n    orbit (ConjAct G) g = (ConjClasses.mk g).carrier", "start": [314, 1], "end": [317, 93], "kind": "commanddeclaration"}, {"full_name": "ConjAct.stabilizer_eq_centralizer", "code": "theorem stabilizer_eq_centralizer (g : G) :\n    stabilizer (ConjAct G) g = centralizer (zpowers (toConjAct g) : Set (ConjAct G))", "start": [319, 1], "end": [322, 52], "kind": "commanddeclaration"}, {"full_name": "ConjAct.Subgroup.conjAction", "code": "instance Subgroup.conjAction {H : Subgroup G} [hH : H.Normal] : SMul (ConjAct G) H :=\n  \u27e8fun g h => \u27e8g \u2022 (h : G), hH.conj_mem h.1 h.2 (ofConjAct g)\u27e9\u27e9", "start": [325, 1], "end": [328, 64], "kind": "commanddeclaration"}, {"full_name": "ConjAct.Subgroup.val_conj_smul", "code": "theorem Subgroup.val_conj_smul {H : Subgroup G} [H.Normal] (g : ConjAct G) (h : H) :\n    \u2191(g \u2022 h) = g \u2022 (h : G)", "start": [331, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "ConjAct.Subgroup.conjMulDistribMulAction", "code": "instance Subgroup.conjMulDistribMulAction {H : Subgroup G} [H.Normal] :\n    MulDistribMulAction (ConjAct G) H :=\n  Subtype.coe_injective.mulDistribMulAction H.subtype Subgroup.val_conj_smul", "start": [336, 1], "end": [338, 77], "kind": "commanddeclaration"}, {"full_name": "MulAut.conjNormal", "code": "def _root_.MulAut.conjNormal {H : Subgroup G} [H.Normal] : G \u2192* MulAut H :=\n  (MulDistribMulAction.toMulAut (ConjAct G) H).comp toConjAct.toMonoidHom", "start": [341, 1], "end": [343, 74], "kind": "commanddeclaration"}, {"full_name": "MulAut.conjNormal_apply", "code": "@[simp]\ntheorem _root_.MulAut.conjNormal_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    \u2191(MulAut.conjNormal g h) = g * h * g\u207b\u00b9", "start": [346, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.conjNormal_symm_apply", "code": "@[simp]\ntheorem _root_.MulAut.conjNormal_symm_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    \u2191((MulAut.conjNormal g).symm h) = g\u207b\u00b9 * h * g", "start": [352, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "MulAut.conjNormal_inv_apply", "code": "@[simp]\ntheorem _root_.MulAut.conjNormal_inv_apply {H : Subgroup G} [H.Normal] (g : G) (h : H) :\n    \u2191((MulAut.conjNormal g)\u207b\u00b9 h) = g\u207b\u00b9 * h * g", "start": [360, 1], "end": [363, 35], "kind": "commanddeclaration"}, {"full_name": "MulAut.conjNormal_val", "code": "theorem _root_.MulAut.conjNormal_val {H : Subgroup G} [H.Normal] {h : H} :\n    MulAut.conjNormal \u2191h = MulAut.conj h", "start": [366, 1], "end": [368, 28], "kind": "commanddeclaration"}, {"full_name": "ConjAct.normal_of_characteristic_of_normal", "code": "instance normal_of_characteristic_of_normal {H : Subgroup G} [hH : H.Normal] {K : Subgroup H}\n    [h : K.Characteristic] : (K.map H.subtype).Normal :=\n  \u27e8fun a ha b => by\n    obtain \u27e8a, ha, rfl\u27e9 := ha\n    exact K.apply_coe_mem_map H.subtype\n      \u27e8_, (SetLike.ext_iff.mp (h.fixed (MulAut.conjNormal b)) a).mpr ha\u27e9\u27e9", "start": [371, 1], "end": [376, 74], "kind": "commanddeclaration"}, {"full_name": "unitsCentralizerEquiv", "code": "@[simps! apply_coe_val symm_apply_val_coe]\ndef unitsCentralizerEquiv (x : M\u02e3) :\n    (Submonoid.centralizer ({\u2191x} : Set M))\u02e3 \u2243* MulAction.stabilizer (ConjAct M\u02e3) x :=\n  MulEquiv.symm\n  { toFun := MonoidHom.toHomUnits <|\n      { toFun := fun u \u21a6 \u27e8\u2191(ConjAct.ofConjAct u.1 : M\u02e3), by\n          rintro x \u27e8rfl\u27e9\n          have : (u : ConjAct M\u02e3) \u2022 x = x := u.2\n          rwa [ConjAct.smul_def, mul_inv_eq_iff_eq_mul, Units.ext_iff, eq_comm] at this\u27e9,\n        map_one' := rfl,\n        map_mul' := fun a b \u21a6 rfl }\n    invFun := fun u \u21a6\n      \u27e8ConjAct.toConjAct (Units.map (Submonoid.centralizer ({\u2191x} : Set M)).subtype u), by\n      change _ \u2022 _ = _\n      simp only [ConjAct.smul_def, ConjAct.ofConjAct_toConjAct, mul_inv_eq_iff_eq_mul]\n      exact Units.ext <| (u.1.2 x <| Set.mem_singleton _).symm\u27e9\n    left_inv := fun _ \u21a6 by ext; rfl\n    right_inv := fun _ \u21a6 by ext; rfl\n    map_mul' := map_mul _ }", "start": [385, 1], "end": [405, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/Pointwise.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Order/WellFoundedSet.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submonoid.mul_subset", "code": "@[to_additive]\ntheorem mul_subset {S : Submonoid M} (hs : s \u2286 S) (ht : t \u2286 S) : s * t \u2286 S", "start": [59, 1], "end": [62, 44], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mul_subset_closure", "code": "@[to_additive]\ntheorem mul_subset_closure (hs : s \u2286 u) (ht : t \u2286 u) : s * t \u2286 Submonoid.closure u", "start": [66, 1], "end": [68, 99], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_mul_self_eq", "code": "@[to_additive]\ntheorem coe_mul_self_eq (s : Submonoid M) : (s : Set M) * s = s", "start": [72, 1], "end": [77, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_mul_le", "code": "@[to_additive]\ntheorem closure_mul_le (S T : Set M) : closure (S * T) \u2264 closure S \u2294 closure T", "start": [81, 1], "end": [85, 60], "kind": "commanddeclaration"}, {"full_name": "Submonoid.sup_eq_closure_mul", "code": "@[to_additive]\ntheorem sup_eq_closure_mul (H K : Submonoid M) : H \u2294 K = closure ((H : Set M) * (K : Set M))", "start": [89, 1], "end": [94, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pow_smul_mem_closure_smul", "code": "@[to_additive]\ntheorem pow_smul_mem_closure_smul {N : Type*} [CommMonoid N] [MulAction M N] [IsScalarTower M N N]\n    (r : M) (s : Set N) {x : N} (hx : x \u2208 closure s) : \u2203 n : \u2115, r ^ n \u2022 x \u2208 closure (r \u2022 s)", "start": [98, 1], "end": [108, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv", "code": "@[to_additive \" The additive submonoid with every element negated. \"]\nprotected def inv : Inv (Submonoid G) where\n  inv S :=\n    { carrier := (S : Set G)\u207b\u00b9\n      mul_mem' := fun ha hb => by rw [mem_inv, mul_inv_rev]; exact mul_mem hb ha\n      one_mem' := mem_inv.2 <| by rw [inv_one]; exact S.one_mem' }", "start": [114, 1], "end": [120, 67], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_inv", "code": "@[to_additive (attr := simp)]\ntheorem coe_inv (S : Submonoid G) : \u2191S\u207b\u00b9 = (S : Set G)\u207b\u00b9", "start": [126, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_inv", "code": "@[to_additive (attr := simp)]\ntheorem mem_inv {g : G} {S : Submonoid G} : g \u2208 S\u207b\u00b9 \u2194 g\u207b\u00b9 \u2208 S", "start": [132, 1], "end": [134, 10], "kind": "commanddeclaration"}, {"full_name": "Submonoid.involutiveInv", "code": "@[to_additive \"Inversion is involutive on additive submonoids.\"]\ndef involutiveInv : InvolutiveInv (Submonoid G) :=\n  SetLike.coe_injective.involutiveInv _ fun _ => rfl", "start": [138, 1], "end": [141, 53], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_le_inv", "code": "@[to_additive (attr := simp)]\ntheorem inv_le_inv (S T : Submonoid G) : S\u207b\u00b9 \u2264 T\u207b\u00b9 \u2194 S \u2264 T", "start": [145, 1], "end": [147, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_le", "code": "@[to_additive]\ntheorem inv_le (S T : Submonoid G) : S\u207b\u00b9 \u2264 T \u2194 S \u2264 T\u207b\u00b9", "start": [151, 1], "end": [153, 51], "kind": "commanddeclaration"}, {"full_name": "Submonoid.invOrderIso", "code": "@[to_additive (attr := simps!) \"Pointwise negation of additive submonoids as an order isomorphism\"]\ndef invOrderIso : Submonoid G \u2243o Submonoid G where\n  toEquiv := Equiv.inv _\n  map_rel_iff' := inv_le_inv _ _", "start": [157, 1], "end": [161, 33], "kind": "commanddeclaration"}, {"full_name": "Submonoid.closure_inv", "code": "@[to_additive]\ntheorem closure_inv (s : Set G) : closure s\u207b\u00b9 = (closure s)\u207b\u00b9", "start": [165, 1], "end": [171, 25], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_inf", "code": "@[to_additive (attr := simp)]\ntheorem inv_inf (S T : Submonoid G) : (S \u2293 T)\u207b\u00b9 = S\u207b\u00b9 \u2293 T\u207b\u00b9", "start": [175, 1], "end": [177, 38], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_sup", "code": "@[to_additive (attr := simp)]\ntheorem inv_sup (S T : Submonoid G) : (S \u2294 T)\u207b\u00b9 = S\u207b\u00b9 \u2294 T\u207b\u00b9", "start": [181, 1], "end": [183, 57], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_bot", "code": "@[to_additive (attr := simp)]\ntheorem inv_bot : (\u22a5 : Submonoid G)\u207b\u00b9 = \u22a5", "start": [187, 1], "end": [189, 78], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_top", "code": "@[to_additive (attr := simp)]\ntheorem inv_top : (\u22a4 : Submonoid G)\u207b\u00b9 = \u22a4", "start": [193, 1], "end": [195, 40], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_iInf", "code": "@[to_additive (attr := simp)]\ntheorem inv_iInf {\u03b9 : Sort*} (S : \u03b9 \u2192 Submonoid G) : (\u2a05 i, S i)\u207b\u00b9 = \u2a05 i, (S i)\u207b\u00b9", "start": [199, 1], "end": [201, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.inv_iSup", "code": "@[to_additive (attr := simp)]\ntheorem inv_iSup {\u03b9 : Sort*} (S : \u03b9 \u2192 Submonoid G) : (\u2a06 i, S i)\u207b\u00b9 = \u2a06 i, (S i)\u207b\u00b9", "start": [205, 1], "end": [207, 56], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwiseMulAction", "code": "protected def pointwiseMulAction : MulAction \u03b1 (Submonoid M) where\n  smul a S := S.map (MulDistribMulAction.toMonoidEnd _ M a)\n  one_smul S := by\n    change S.map _ = S\n    simpa only [map_one] using S.map_id\n  mul_smul a\u2081 a\u2082 S :=\n    (congr_arg (fun f : Monoid.End M => S.map f) (MonoidHom.map_mul _ _ _)).trans\n      (S.map_map _ _).symm", "start": [220, 1], "end": [230, 27], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : Submonoid M) : \u2191(a \u2022 S) = a \u2022 (S : Set M)", "start": [235, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (m : M) (a : \u03b1) (S : Submonoid M) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S", "start": [240, 1], "end": [241, 52], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_smul_pointwise_iff_exists", "code": "theorem mem_smul_pointwise_iff_exists (m : M) (a : \u03b1) (S : Submonoid M) :\n    m \u2208 a \u2022 S \u2194 \u2203 s : M, s \u2208 S \u2227 a \u2022 s = m", "start": [244, 1], "end": [246, 47], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_bot", "code": "@[simp]\ntheorem smul_bot (a : \u03b1) : a \u2022 (\u22a5 : Submonoid M) = \u22a5", "start": [249, 1], "end": [251, 12], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_sup", "code": "theorem smul_sup (a : \u03b1) (S T : Submonoid M) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T", "start": [254, 1], "end": [255, 16], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_closure", "code": "theorem smul_closure (a : \u03b1) (s : Set M) : a \u2022 closure s = closure (a \u2022 s)", "start": [258, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwise_isCentralScalar", "code": "lemma pointwise_isCentralScalar [MulDistribMulAction \u03b1\u1d50\u1d52\u1d56 M] [IsCentralScalar \u03b1 M] :\n    IsCentralScalar \u03b1 (Submonoid M) :=\n  \u27e8fun _ S => (congr_arg fun f : Monoid.End M => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _\u27e9", "start": [262, 1], "end": [264, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Submonoid.smul_mem_pointwise_smul_iff", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : \u03b1} {S : Submonoid M} {x : M} : a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [275, 1], "end": [277, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_pointwise_smul_iff_inv_smul_mem", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem {a : \u03b1} {S : Submonoid M} {x : M} :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [280, 1], "end": [282, 32], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_inv_pointwise_smul_iff", "code": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : Submonoid M} {x : M} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [285, 1], "end": [286, 23], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwise_smul_le_pointwise_smul_iff", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : \u03b1} {S T : Submonoid M} : a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [289, 1], "end": [291, 31], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwise_smul_subset_iff", "code": "theorem pointwise_smul_subset_iff {a : \u03b1} {S T : Submonoid M} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [294, 1], "end": [295, 22], "kind": "commanddeclaration"}, {"full_name": "Submonoid.subset_pointwise_smul_iff", "code": "theorem subset_pointwise_smul_iff {a : \u03b1} {S T : Submonoid M} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [298, 1], "end": [299, 22], "kind": "commanddeclaration"}, {"full_name": "Submonoid.smul_mem_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Submonoid M) (x : M) :\n    a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [308, 1], "end": [311, 42], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_pointwise_smul_iff_inv_smul_mem\u2080", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Submonoid M) (x : M) :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [314, 1], "end": [316, 50], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_inv_pointwise_smul_iff\u2080", "code": "theorem mem_inv_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Submonoid M) (x : M) :\n    x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [319, 1], "end": [321, 41], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwise_smul_le_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Submonoid M} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [324, 1], "end": [327, 35], "kind": "commanddeclaration"}, {"full_name": "Submonoid.pointwise_smul_le_iff\u2080", "code": "theorem pointwise_smul_le_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Submonoid M} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [330, 1], "end": [331, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.le_pointwise_smul_iff\u2080", "code": "theorem le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Submonoid M} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [334, 1], "end": [335, 26], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_closure_inv", "code": "@[to_additive]\ntheorem mem_closure_inv {G : Type*} [Group G] (S : Set G) (x : G) :\n    x \u2208 Submonoid.closure S\u207b\u00b9 \u2194 x\u207b\u00b9 \u2208 Submonoid.closure S", "start": [340, 1], "end": [342, 90], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwiseMulAction", "code": "protected def pointwiseMulAction : MulAction \u03b1 (AddSubmonoid A) where\n  smul a S := S.map (DistribMulAction.toAddMonoidEnd _ A a)\n  one_smul S :=\n    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_one _)).trans S.map_id\n  mul_smul _ _ S :=\n    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_mul _ _ _)).trans\n      (S.map_map _ _).symm", "start": [354, 1], "end": [363, 27], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : AddSubmonoid A) : \u2191(a \u2022 S) = a \u2022 (S : Set A)", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (m : A) (a : \u03b1) (S : AddSubmonoid A) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S", "start": [373, 1], "end": [374, 52], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_smul_pointwise_iff_exists", "code": "theorem mem_smul_pointwise_iff_exists (m : A) (a : \u03b1) (S : AddSubmonoid A) :\n    m \u2208 a \u2022 S \u2194 \u2203 s : A, s \u2208 S \u2227 a \u2022 s = m", "start": [377, 1], "end": [379, 47], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.smul_bot", "code": "@[simp]\ntheorem smul_bot (a : \u03b1) : a \u2022 (\u22a5 : AddSubmonoid A) = \u22a5", "start": [382, 1], "end": [384, 12], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.smul_sup", "code": "theorem smul_sup (a : \u03b1) (S T : AddSubmonoid A) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T", "start": [387, 1], "end": [388, 16], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.smul_closure", "code": "@[simp]\ntheorem smul_closure (a : \u03b1) (s : Set A) : a \u2022 closure s = closure (a \u2022 s)", "start": [391, 1], "end": [393, 32], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwise_isCentralScalar", "code": "lemma pointwise_isCentralScalar [DistribMulAction \u03b1\u1d50\u1d52\u1d56 A] [IsCentralScalar \u03b1 A] :\n    IsCentralScalar \u03b1 (AddSubmonoid A) :=\n  \u27e8fun _ S =>\n    (congr_arg fun f : AddMonoid.End A => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _\u27e9", "start": [396, 1], "end": [399, 93], "kind": "mathlibtacticlemma"}, {"full_name": "AddSubmonoid.smul_mem_pointwise_smul_iff", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : \u03b1} {S : AddSubmonoid A} {x : A} : a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [410, 1], "end": [412, 24], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem {a : \u03b1} {S : AddSubmonoid A} {x : A} :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [415, 1], "end": [417, 32], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_inv_pointwise_smul_iff", "code": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : AddSubmonoid A} {x : A} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [420, 1], "end": [421, 23], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwise_smul_le_pointwise_smul_iff", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : \u03b1} {S T : AddSubmonoid A} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [424, 1], "end": [427, 31], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwise_smul_le_iff", "code": "theorem pointwise_smul_le_iff {a : \u03b1} {S T : AddSubmonoid A} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [430, 1], "end": [431, 22], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.le_pointwise_smul_iff", "code": "theorem le_pointwise_smul_iff {a : \u03b1} {S T : AddSubmonoid A} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [434, 1], "end": [435, 22], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.smul_mem_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubmonoid A) (x : A) :\n    a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [444, 1], "end": [447, 42], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_pointwise_smul_iff_inv_smul_mem\u2080", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubmonoid A) (x : A) :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [450, 1], "end": [452, 50], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_inv_pointwise_smul_iff\u2080", "code": "theorem mem_inv_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubmonoid A) (x : A) :\n    x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [455, 1], "end": [457, 41], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwise_smul_le_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubmonoid A} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [460, 1], "end": [463, 35], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pointwise_smul_le_iff\u2080", "code": "theorem pointwise_smul_le_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubmonoid A} :\n    a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [466, 1], "end": [468, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.le_pointwise_smul_iff\u2080", "code": "theorem le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubmonoid A} :\n    S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [471, 1], "end": [473, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.one", "code": "protected def one : One (AddSubmonoid R) :=\n  \u27e8AddMonoidHom.mrange (Nat.castAddMonoidHom R)\u27e9", "start": [491, 1], "end": [494, 49], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.one_eq_mrange", "code": "theorem one_eq_mrange : (1 : AddSubmonoid R) = AddMonoidHom.mrange (Nat.castAddMonoidHom R)", "start": [497, 1], "end": [498, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.natCast_mem_one", "code": "theorem natCast_mem_one (n : \u2115) : (n : R) \u2208 (1 : AddSubmonoid R)", "start": [501, 1], "end": [502, 11], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mem_one", "code": "@[simp]\ntheorem mem_one {x : R} : x \u2208 (1 : AddSubmonoid R) \u2194 \u2203 n : \u2115, \u2191n = x", "start": [505, 1], "end": [507, 10], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.one_eq_closure", "code": "theorem one_eq_closure : (1 : AddSubmonoid R) = closure {1}", "start": [510, 1], "end": [514, 7], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.one_eq_closure_one_set", "code": "theorem one_eq_closure_one_set : (1 : AddSubmonoid R) = closure 1", "start": [517, 1], "end": [518, 17], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul", "code": "protected def mul : Mul (AddSubmonoid R) :=\n  \u27e8fun M N => \u2a06 s : M, N.map (AddMonoidHom.mul s.1)\u27e9", "start": [527, 1], "end": [530, 53], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_mem_mul", "code": "theorem mul_mem_mul {M N : AddSubmonoid R} {m n : R} (hm : m \u2208 M) (hn : n \u2208 N) : m * n \u2208 M * N", "start": [533, 1], "end": [534, 50], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_le", "code": "theorem mul_le {M N P : AddSubmonoid R} : M * N \u2264 P \u2194 \u2200 m \u2208 M, \u2200 n \u2208 N, m * n \u2208 P", "start": [537, 1], "end": [539, 74], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_induction_on", "code": "@[elab_as_elim]\nprotected theorem mul_induction_on {M N : AddSubmonoid R} {C : R \u2192 Prop} {r : R} (hr : r \u2208 M * N)\n    (hm : \u2200 m \u2208 M, \u2200 n \u2208 N, C (m * n)) (ha : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) : C r", "start": [542, 1], "end": [546, 75], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.closure_mul_closure", "code": "theorem closure_mul_closure (S T : Set R) : closure S * closure T = closure (S * T)", "start": [551, 1], "end": [562, 62], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_eq_closure_mul_set", "code": "theorem mul_eq_closure_mul_set (M N : AddSubmonoid R) :\n    M * N = closure ((M : Set R) * (N : Set R))", "start": [565, 1], "end": [567, 53], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_bot", "code": "@[simp]\ntheorem mul_bot (S : AddSubmonoid R) : S * \u22a5 = \u22a5", "start": [570, 1], "end": [573, 57], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.bot_mul", "code": "@[simp]\ntheorem bot_mul (S : AddSubmonoid R) : \u22a5 * S = \u22a5", "start": [576, 1], "end": [579, 57], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_le_mul", "code": "@[mono]\ntheorem mul_le_mul {M N P Q : AddSubmonoid R} (hmp : M \u2264 P) (hnq : N \u2264 Q) : M * N \u2264 P * Q", "start": [582, 1], "end": [584, 60], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_le_mul_left", "code": "theorem mul_le_mul_left {M N P : AddSubmonoid R} (h : M \u2264 N) : M * P \u2264 N * P", "start": [587, 1], "end": [588, 27], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_le_mul_right", "code": "theorem mul_le_mul_right {M N P : AddSubmonoid R} (h : N \u2264 P) : M * N \u2264 M * P", "start": [591, 1], "end": [592, 27], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mul_subset_mul", "code": "theorem mul_subset_mul {M N : AddSubmonoid R} :\n    (\u2191M : Set R) * (\u2191N : Set R) \u2286 (\u2191(M * N) : Set R)", "start": [595, 1], "end": [598, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.hasDistribNeg", "code": "protected def hasDistribNeg : HasDistribNeg (AddSubmonoid R) :=\n  { AddSubmonoid.involutiveNeg with\n    neg_mul := fun x y => by\n      refine'\n          le_antisymm (mul_le.2 fun m hm n hn => _)\n            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>\n        simp only [AddSubmonoid.mem_neg, \u2190 neg_mul] at *\n      \u00b7 exact mul_mem_mul hm hn\n      \u00b7 exact mul_mem_mul (neg_mem_neg.2 hm) hn\n    mul_neg := fun x y => by\n      refine'\n          le_antisymm (mul_le.2 fun m hm n hn => _)\n            ((AddSubmonoid.neg_le _ _).2 <| mul_le.2 fun m hm n hn => _) <;>\n        simp only [AddSubmonoid.mem_neg, \u2190 mul_neg] at *\n      \u00b7 exact mul_mem_mul hm hn\n      \u00b7 exact mul_mem_mul hm (neg_mem_neg.2 hn) }", "start": [607, 1], "end": [625, 50], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.mulOneClass", "code": "protected def mulOneClass : MulOneClass (AddSubmonoid R) where\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  one_mul M := by rw [one_eq_closure_one_set, \u2190 closure_eq M, closure_mul_closure, one_mul]\n  mul_one M := by rw [one_eq_closure_one_set, \u2190 closure_eq M, closure_mul_closure, mul_one]", "start": [636, 1], "end": [641, 92], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.semigroup", "code": "protected def semigroup : Semigroup (AddSubmonoid R) where\n  mul := (\u00b7 * \u00b7)\n  mul_assoc M N P :=\n    le_antisymm\n      (mul_le.2 fun _mn hmn p hp =>\n        suffices M * N \u2264 (M * (N * P)).comap (AddMonoidHom.mulRight p) from this hmn\n        mul_le.2 fun m hm n hn =>\n          show m * n * p \u2208 M * (N * P) from\n            (mul_assoc m n p).symm \u25b8 mul_mem_mul hm (mul_mem_mul hn hp))\n      (mul_le.2 fun m hm _np hnp =>\n        suffices N * P \u2264 (M * N * P).comap (AddMonoidHom.mulLeft m) from this hnp\n        mul_le.2 fun n hn p hp =>\n          show m * (n * p) \u2208 M * N * P from mul_assoc m n p \u25b8 mul_mem_mul (mul_mem_mul hm hn) hp)", "start": [650, 1], "end": [663, 98], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.monoid", "code": "protected def monoid : Monoid (AddSubmonoid R) :=\n  { AddSubmonoid.semigroup, AddSubmonoid.mulOneClass with }", "start": [671, 1], "end": [673, 60], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.closure_pow", "code": "theorem closure_pow (s : Set R) : \u2200 n : \u2115, closure s ^ n = closure (s ^ n)", "start": [676, 1], "end": [678, 78], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pow_eq_closure_pow_set", "code": "theorem pow_eq_closure_pow_set (s : AddSubmonoid R) (n : \u2115) : s ^ n = closure ((s : Set R) ^ n)", "start": [681, 1], "end": [682, 36], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.pow_subset_pow", "code": "theorem pow_subset_pow {s : AddSubmonoid R} {n : \u2115} : (\u2191s : Set R) ^ n \u2286 \u2191(s ^ n)", "start": [685, 1], "end": [686, 53], "kind": "commanddeclaration"}, {"full_name": "Set.IsPwo.submonoid_closure", "code": "@[to_additive]\ntheorem submonoid_closure (hpos : \u2200 x : \u03b1, x \u2208 s \u2192 1 \u2264 x) (h : s.IsPwo) :\n    IsPwo (Submonoid.closure s : Set \u03b1)", "start": [697, 1], "end": [702, 80], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Quotient.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Common.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HasQuotient", "code": "class HasQuotient (A : outParam <| Type u) (B : Type v) where\n  \n  quotient' : B \u2192 Type max u v", "start": [41, 1], "end": [49, 31], "kind": "commanddeclaration"}, {"full_name": "HasQuotient.Quotient", "code": "@[reducible]\ndef HasQuotient.Quotient (A : outParam <| Type u) {B : Type v}\n    [HasQuotient A B] (b : B) : Type max u v :=\n  HasQuotient.quotient' b", "start": [53, 1], "end": [63, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Elimination.lean", "imports": ["Mathlib/Tactic/Linarith/Datatypes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Linarith.CompSource", "code": "inductive CompSource : Type\n  | assump : Nat \u2192 CompSource\n  | add : CompSource \u2192 CompSource \u2192 CompSource\n  | scale : Nat \u2192 CompSource \u2192 CompSource\nderiving Inhabited", "start": [42, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "Linarith.CompSource.flatten", "code": "def CompSource.flatten : CompSource \u2192 HashMap Nat Nat\n  | (CompSource.assump n) => HashMap.empty.insert n 1\n  | (CompSource.add c1 c2) =>\n      (CompSource.flatten c1).mergeWith (fun _ b b' => b + b') (CompSource.flatten c2)\n  | (CompSource.scale n c) => (CompSource.flatten c).mapVal (fun _ v => v * n)", "start": [54, 1], "end": [66, 79], "kind": "commanddeclaration"}, {"full_name": "Linarith.CompSource.toString", "code": "def CompSource.toString : CompSource \u2192 String\n  | (CompSource.assump e) => ToString.toString e\n  | (CompSource.add c1 c2) => CompSource.toString c1 ++ \" + \" ++ CompSource.toString c2\n  | (CompSource.scale n c) => ToString.toString n ++ \" * \" ++ CompSource.toString c", "start": [68, 1], "end": [72, 84], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp", "code": "structure PComp : Type where\n  \n  c : Comp\n  \n  src : CompSource\n  \n  history : RBSet \u2115 Ord.compare\n  \n  effective : RBSet \u2115 Ord.compare\n  \n  implicit : RBSet \u2115 Ord.compare\n  \n  vars : RBSet \u2115 Ord.compare", "start": [77, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.maybeMinimal", "code": "def PComp.maybeMinimal (c : PComp) (elimedGE : \u2115) : Bool :=\n  c.history.size \u2264 1 + ((c.implicit.filter (\u00b7 \u2265 elimedGE)).union c.effective).size", "start": [119, 1], "end": [141, 83], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.cmp", "code": "def PComp.cmp (p1 p2 : PComp) : Ordering := p1.c.cmp p2.c", "start": [143, 1], "end": [147, 58], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.scale", "code": "def PComp.scale (c : PComp) (n : \u2115) : PComp :=\n  { c with c := c.c.scale n, src := c.src.scale n }", "start": [149, 1], "end": [151, 52], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.add", "code": "def PComp.add (c1 c2 : PComp) (elimVar : \u2115) : PComp :=\n  let c := c1.c.add c2.c\n  let src := c1.src.add c2.src\n  let history := c1.history.union c2.history\n  let vars := c1.vars.union c2.vars\n  let effective := (c1.effective.union c2.effective).insert elimVar\n  let implicit := (vars.sdiff (.ofList c.vars _)).sdiff effective\n  \u27e8c, src, history, effective, implicit, vars\u27e9", "start": [153, 1], "end": [179, 47], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.assump", "code": "def PComp.assump (c : Comp) (n : \u2115) : PComp where\n  c := c\n  src := CompSource.assump n\n  history := RBSet.empty.insert n\n  effective := .empty\n  implicit := .empty\n  vars := .ofList c.vars _", "start": [181, 1], "end": [193, 27], "kind": "commanddeclaration"}, {"full_name": "Linarith.PCompSet", "code": "abbrev PCompSet := RBSet PComp PComp.cmp", "start": [201, 1], "end": [202, 41], "kind": "commanddeclaration"}, {"full_name": "Linarith.elimVar", "code": "def elimVar (c1 c2 : Comp) (a : \u2115) : Option (\u2115 \u00d7 \u2115) :=\n  let v1 := c1.coeffOf a\n  let v2 := c2.coeffOf a\n  if v1 * v2 < 0 then\n    let vlcm := Nat.lcm v1.natAbs v2.natAbs\n    some \u27e8vlcm / v1.natAbs, vlcm / v2.natAbs\u27e9\n  else none", "start": [206, 1], "end": [214, 12], "kind": "commanddeclaration"}, {"full_name": "Linarith.pelimVar", "code": "def pelimVar (p1 p2 : PComp) (a : \u2115) : Option PComp := do\n  let (n1, n2) \u2190 elimVar p1.c p2.c a\n  return (p1.scale n1).add (p2.scale n2) a", "start": [216, 1], "end": [223, 43], "kind": "commanddeclaration"}, {"full_name": "Linarith.PComp.isContr", "code": "def PComp.isContr (p : PComp) : Bool := p.c.isContr", "start": [225, 1], "end": [228, 52], "kind": "commanddeclaration"}, {"full_name": "Linarith.elimWithSet", "code": "def elimWithSet (a : \u2115) (p : PComp) (comps : PCompSet) : PCompSet :=\n  comps.foldl (fun s pc =>\n  match pelimVar p pc a with\n  | some pc => if pc.maybeMinimal a then s.insert pc else s\n  | none => s) RBSet.empty", "start": [230, 1], "end": [238, 27], "kind": "commanddeclaration"}, {"full_name": "Linarith.LinarithData", "code": "structure LinarithData : Type where\n  \n  maxVar : \u2115\n  \n  comps : PCompSet", "start": [240, 1], "end": [252, 19], "kind": "commanddeclaration"}, {"full_name": "Linarith.LinarithM", "code": "@[reducible] def LinarithM : Type \u2192 Type :=\n  StateT LinarithData (ExceptT PComp Id)", "start": [254, 1], "end": [259, 41], "kind": "commanddeclaration"}, {"full_name": "Linarith.getMaxVar", "code": "def getMaxVar : LinarithM \u2115 :=\n  LinarithData.maxVar <$> get", "start": [261, 1], "end": [263, 30], "kind": "commanddeclaration"}, {"full_name": "Linarith.getPCompSet", "code": "def getPCompSet : LinarithM PCompSet :=\n  LinarithData.comps <$> get", "start": [265, 1], "end": [267, 29], "kind": "commanddeclaration"}, {"full_name": "Linarith.validate", "code": "def validate : LinarithM Unit := do\n  match (\u2190 getPCompSet).toList.find? (fun p : PComp => p.isContr) with\n  | none => return ()\n  | some c => throw c", "start": [269, 1], "end": [273, 22], "kind": "commanddeclaration"}, {"full_name": "Linarith.update", "code": "def update (maxVar : \u2115) (comps : PCompSet) : LinarithM Unit := do\n  StateT.set \u27e8maxVar, comps\u27e9\n  validate", "start": [275, 1], "end": [281, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.splitSetByVarSign", "code": "def splitSetByVarSign (a : \u2115) (comps : PCompSet) : PCompSet \u00d7 PCompSet \u00d7 PCompSet :=\n  comps.foldl (fun \u27e8pos, neg, notPresent\u27e9 pc =>\n    let n := pc.c.coeffOf a\n    if n > 0 then \u27e8pos.insert pc, neg, notPresent\u27e9\n    else if n < 0 then \u27e8pos, neg.insert pc, notPresent\u27e9\n    else \u27e8pos, neg, notPresent.insert pc\u27e9)\n    \u27e8RBSet.empty, RBSet.empty, RBSet.empty\u27e9", "start": [283, 1], "end": [297, 44], "kind": "commanddeclaration"}, {"full_name": "Linarith.elimVarM", "code": "def elimVarM (a : \u2115) : LinarithM Unit := do\n  let vs \u2190 getMaxVar\n  if (a \u2264 vs) then (do\n    let \u27e8pos, neg, notPresent\u27e9 := splitSetByVarSign a (\u2190 getPCompSet)\n    update (vs - 1) (pos.foldl (fun s p => s.union (elimWithSet a p neg)) notPresent))\n  else\n    pure ()", "start": [299, 1], "end": [309, 12], "kind": "commanddeclaration"}, {"full_name": "Linarith.elimAllVarsM", "code": "def elimAllVarsM : LinarithM Unit := do\n  for i in (List.range ((\u2190 getMaxVar) + 1)).reverse do\n    elimVarM i", "start": [311, 1], "end": [317, 15], "kind": "commanddeclaration"}, {"full_name": "Linarith.mkLinarithData", "code": "def mkLinarithData (hyps : List Comp) (maxVar : \u2115) : LinarithData :=\n  \u27e8maxVar, .ofList (hyps.enum.map $ fun \u27e8n, cmp\u27e9 => PComp.assump cmp n) _\u27e9", "start": [319, 1], "end": [324, 75], "kind": "commanddeclaration"}, {"full_name": "Linarith.FourierMotzkin.produceCertificate", "code": "def FourierMotzkin.produceCertificate : CertificateOracle :=\n  fun hyps maxVar => match ExceptT.run\n      (StateT.run (do validate; elimAllVarsM : LinarithM Unit) (mkLinarithData hyps maxVar)) with\n  | (Except.ok _) => failure\n  | (Except.error contr) => return contr.src.flatten", "start": [326, 1], "end": [336, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Parsing.lean", "imports": ["lake-packages/std/Std/Data/RBMap/Basic.lean", "Mathlib/Tactic/Linarith/Datatypes.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.findDefeq", "code": "def List.findDefeq (red : TransparencyMode) (m : List (Expr \u00d7 v)) (e : Expr) : MetaM v := do\n  if let some (_, n) \u2190 m.findM? $ fun \u27e8e', _\u27e9 => withTransparency red (isDefEq e e') then\n    return n\n  else\n    failure", "start": [39, 1], "end": [48, 12], "kind": "commanddeclaration"}, {"full_name": "Linarith.Map", "code": "abbrev Map (\u03b1 \u03b2) [Ord \u03b1] := RBMap \u03b1 \u03b2 Ord.compare", "start": [61, 1], "end": [62, 50], "kind": "commanddeclaration"}, {"full_name": "Linarith.Monom", "code": "@[reducible] def Monom : Type := Map \u2115 \u2115", "start": [66, 1], "end": [67, 41], "kind": "commanddeclaration"}, {"full_name": "Linarith.Monom.one", "code": "def Monom.one : Monom := RBMap.empty", "start": [69, 1], "end": [70, 37], "kind": "commanddeclaration"}, {"full_name": "Linarith.Monom.lt", "code": "def Monom.lt : Monom \u2192 Monom \u2192 Bool :=\n  fun a b =>\n    ((a.keys : List \u2115) < b.keys) ||\n      (((a.keys : List \u2115) = b.keys) && ((a.values : List \u2115) < b.values))", "start": [72, 1], "end": [76, 73], "kind": "commanddeclaration"}, {"full_name": "Linarith.Sum", "code": "@[reducible] def Sum : Type := Map Monom \u2124", "start": [81, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "Linarith.Sum.one", "code": "def Sum.one : Sum := RBMap.empty.insert Monom.one 1", "start": [84, 1], "end": [85, 52], "kind": "commanddeclaration"}, {"full_name": "Linarith.Sum.scaleByMonom", "code": "def Sum.scaleByMonom (s : Sum) (m : Monom) : Sum :=\n  s.foldr (fun m' coeff sm => sm.insert (m + m') coeff) RBMap.empty", "start": [87, 1], "end": [89, 68], "kind": "commanddeclaration"}, {"full_name": "Linarith.Sum.mul", "code": "def Sum.mul (s1 s2 : Sum) : Sum :=\n  s1.foldr (fun mn coeff sm => sm + ((s2.scaleByMonom mn).mapVal (fun _ v => v * coeff)))\n    RBMap.empty", "start": [91, 1], "end": [94, 16], "kind": "commanddeclaration"}, {"full_name": "Linarith.Sum.pow", "code": "def Sum.pow (s : Sum) : \u2115 \u2192 Sum\n  | 0     => Sum.one\n  | (k+1) => s.mul (s.pow k)", "start": [96, 1], "end": [99, 29], "kind": "commanddeclaration"}, {"full_name": "Linarith.SumOfMonom", "code": "def SumOfMonom (m : Monom) : Sum :=\n  RBMap.empty.insert m 1", "start": [101, 1], "end": [103, 25], "kind": "commanddeclaration"}, {"full_name": "Linarith.one", "code": "def one : Monom := RBMap.empty", "start": [105, 1], "end": [106, 31], "kind": "commanddeclaration"}, {"full_name": "Linarith.scalar", "code": "def scalar (z : \u2124) : Sum :=\n  RBMap.empty.insert one z", "start": [108, 1], "end": [110, 27], "kind": "commanddeclaration"}, {"full_name": "Linarith.var", "code": "def var (n : \u2115) : Sum :=\n  RBMap.empty.insert (RBMap.empty.insert n 1) 1", "start": [112, 1], "end": [114, 48], "kind": "commanddeclaration"}, {"full_name": "Linarith.ExprMap", "code": "abbrev ExprMap := List (Expr \u00d7 \u2115)", "start": [121, 1], "end": [127, 34], "kind": "commanddeclaration"}, {"full_name": "Linarith.linearFormOfAtom", "code": "def linearFormOfAtom (red : TransparencyMode) (m : ExprMap) (e : Expr) : MetaM (ExprMap \u00d7 Sum) := do\n  try\n    let k \u2190 m.findDefeq red e\n    return (m, var k)\n  catch _ =>\n    let n := m.length + 1\n    return ((e, n)::m, var n)", "start": [129, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "Linarith.linearFormOfExpr", "code": "partial def linearFormOfExpr (red : TransparencyMode) (m : ExprMap) (e : Expr) :\n    MetaM (ExprMap \u00d7 Sum) :=\n  match e.numeral? with\n  | some 0 => return \u27e8m, RBMap.empty\u27e9\n  | some (n+1) => return \u27e8m, scalar (n+1)\u27e9\n  | none =>\n  match e.getAppFnArgs with\n  | (``HMul.hMul, #[_, _, _, _, e1, e2]) => do\n    let (m1, comp1) \u2190 linearFormOfExpr red m e1\n    let (m2, comp2) \u2190 linearFormOfExpr red m1 e2\n    return (m2, comp1.mul comp2)\n  | (``HAdd.hAdd, #[_, _, _, _, e1, e2]) => do\n    let (m1, comp1) \u2190 linearFormOfExpr red m e1\n    let (m2, comp2) \u2190 linearFormOfExpr red m1 e2\n    return (m2, comp1 + comp2)\n  | (``HSub.hSub, #[_, _, _, _, e1, e2]) => do\n    let (m1, comp1) \u2190 linearFormOfExpr red m e1\n    let (m2, comp2) \u2190 linearFormOfExpr red m1 e2\n    return (m2, comp1 + comp2.mapVal (fun _ v => -v))\n  | (``Neg.neg, #[_, _, e]) => do\n    let (m1, comp) \u2190 linearFormOfExpr red m e\n    return (m1, comp.mapVal (fun _ v => -v))\n  | (``HPow.hPow, #[_, _, _, _, a, n]) => do\n    match n.numeral? with\n    | some n => do\n      let (m1, comp) \u2190 linearFormOfExpr red m a\n      return (m1, comp.pow n)\n    | none => linearFormOfAtom red m e\n  | _ => linearFormOfAtom red m e", "start": [142, 1], "end": [181, 34], "kind": "commanddeclaration"}, {"full_name": "Linarith.elimMonom", "code": "def elimMonom (s : Sum) (m : Map Monom \u2115) : Map Monom \u2115 \u00d7 Map \u2115 \u2124 :=\n  s.foldr (\u03bb mn coeff \u27e8map, out\u27e9 =>\n    match map.find? mn with\n    | some n => \u27e8map, out.insert n coeff\u27e9\n    | none =>\n      let n := map.size\n      \u27e8map.insert mn n, out.insert n coeff\u27e9)\n    (m, RBMap.empty)", "start": [183, 1], "end": [198, 21], "kind": "commanddeclaration"}, {"full_name": "Linarith.toComp", "code": "def toComp (red : TransparencyMode) (e : Expr) (e_map : ExprMap) (monom_map : Map Monom \u2115) :\n    MetaM (Comp \u00d7 ExprMap \u00d7 Map Monom \u2115) := do\n  let (iq, e) \u2190 parseCompAndExpr e\n  let (m', comp') \u2190 linearFormOfExpr red e_map e\n  let \u27e8nm, mm'\u27e9 := elimMonom comp' monom_map\n  return \u27e8\u27e8iq, mm'.toList.reverse\u27e9, m', nm\u27e9", "start": [200, 1], "end": [213, 44], "kind": "commanddeclaration"}, {"full_name": "Linarith.toCompFold", "code": "def toCompFold (red : TransparencyMode) : ExprMap \u2192 List Expr \u2192 Map Monom \u2115 \u2192\n    MetaM (List Comp \u00d7 ExprMap \u00d7 Map Monom \u2115)\n| m, [],     mm => return ([], m, mm)\n| m, (h::t), mm => do\n    let (c, m', mm') \u2190 toComp red h m mm\n    let (l, mp, mm') \u2190 toCompFold red m' t mm'\n    return (c::l, mp, mm')", "start": [215, 1], "end": [225, 27], "kind": "commanddeclaration"}, {"full_name": "Linarith.linearFormsAndMaxVar", "code": "def linearFormsAndMaxVar (red : TransparencyMode) (pfs : List Expr) :\n    MetaM (List Comp \u00d7 \u2115) := do\n  let pftps \u2190 (pfs.mapM inferType)\n  let (l, _, map) \u2190 toCompFold red [] pftps RBMap.empty\n  trace[linarith.detail] \"monomial map: {map.toList.map fun \u27e8k,v\u27e9 => (k.toList, v)}\"\n  return (l, map.size - 1)", "start": [227, 1], "end": [239, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Lean/Exception.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "successIfFail", "code": "def successIfFail [MonadError M] [Monad M] (m : M \u03b1) : M Exception := do\n  match \u2190 tryCatch (m *> pure none) (pure \u2218 some) with\n  | none => throwError \"Expected an exception.\"\n  | some ex => return ex", "start": [12, 1], "end": [18, 25], "kind": "commanddeclaration"}, {"full_name": "Lean.Exception.isFailedToSynthesize", "code": "def isFailedToSynthesize (e : Exception) : IO Bool := do\n  pure <| (\u2190 e.toMessageData.toString).startsWith \"failed to synthesize\"", "start": [24, 1], "end": [31, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CancelDenoms/Core.lean", "imports": ["Mathlib/Util/SynthesizeUsing.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Tree.lean", "Mathlib/Util/Qq.lean", "Mathlib/Tactic/NormNum/Core.lean"], "premises": [{"full_name": "CancelDenoms.mul_subst", "code": "theorem mul_subst {\u03b1} [CommRing \u03b1] {n1 n2 k e1 e2 t1 t2 : \u03b1}\n    (h1 : n1 * e1 = t1) (h2 : n2 * e2 = t2) (h3 : n1 * n2 = k) : k * (e1 * e2) = t1 * t2", "start": [39, 1], "end": [42, 50], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.div_subst", "code": "theorem div_subst {\u03b1} [Field \u03b1] {n1 n2 k e1 e2 t1 : \u03b1}\n    (h1 : n1 * e1 = t1) (h2 : n2 / e2 = 1) (h3 : n1 * n2 = k) : k * (e1 / e2) = t1", "start": [45, 1], "end": [47, 82], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancel_factors_eq_div", "code": "theorem cancel_factors_eq_div {\u03b1} [Field \u03b1] {n e e' : \u03b1}\n    (h : n * e = e') (h2 : n \u2260 0) : e = e' / n", "start": [50, 1], "end": [52, 48], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.add_subst", "code": "theorem add_subst {\u03b1} [Ring \u03b1] {n e1 e2 t1 t2 : \u03b1} (h1 : n * e1 = t1) (h2 : n * e2 = t2) :\n    n * (e1 + e2) = t1 + t2", "start": [55, 1], "end": [56, 57], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.sub_subst", "code": "theorem sub_subst {\u03b1} [Ring \u03b1] {n e1 e2 t1 t2 : \u03b1} (h1 : n * e1 = t1) (h2 : n * e2 = t2) :\n    n * (e1 - e2) = t1 - t2", "start": [59, 1], "end": [60, 73], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.neg_subst", "code": "theorem neg_subst {\u03b1} [Ring \u03b1] {n e t : \u03b1} (h1 : n * e = t) : n * -e = -t", "start": [63, 1], "end": [63, 89], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.pow_subst", "code": "theorem pow_subst {\u03b1} [CommRing \u03b1] {n e1 t1 k l : \u03b1} {e2 : \u2115}\n    (h1 : n * e1 = t1) (h2 : l * n ^ e2 = k) : k * (e1 ^ e2) = l * t1 ^ e2", "start": [66, 1], "end": [68, 36], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.inv_subst", "code": "theorem inv_subst {\u03b1} [Field \u03b1] {n k e : \u03b1} (h2 : e \u2260 0) (h3 : n * e = k) :\n    k * (e \u207b\u00b9) = n", "start": [70, 1], "end": [71, 72], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancel_factors_lt", "code": "theorem cancel_factors_lt {\u03b1} [LinearOrderedField \u03b1] {a b ad bd a' b' gcd : \u03b1}\n    (ha : ad * a = a') (hb : bd * b = b') (had : 0 < ad) (hbd : 0 < bd) (hgcd : 0 < gcd) :\n    (a < b) = (1 / gcd * (bd * a') < 1 / gcd * (ad * b'))", "start": [73, 1], "end": [78, 29], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancel_factors_le", "code": "theorem cancel_factors_le {\u03b1} [LinearOrderedField \u03b1] {a b ad bd a' b' gcd : \u03b1}\n    (ha : ad * a = a') (hb : bd * b = b') (had : 0 < ad) (hbd : 0 < bd) (hgcd : 0 < gcd) :\n    (a \u2264 b) = (1 / gcd * (bd * a') \u2264 1 / gcd * (ad * b'))", "start": [81, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancel_factors_eq", "code": "theorem cancel_factors_eq {\u03b1} [Field \u03b1] {a b ad bd a' b' gcd : \u03b1} (ha : ad * a = a')\n    (hb : bd * b = b') (had : ad \u2260 0) (hbd : bd \u2260 0) (hgcd : gcd \u2260 0) :\n    (a = b) = (1 / gcd * (bd * a') = 1 / gcd * (ad * b'))", "start": [89, 1], "end": [102, 25], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancel_factors_ne", "code": "theorem cancel_factors_ne {\u03b1} [Field \u03b1] {a b ad bd a' b' gcd : \u03b1} (ha : ad * a = a')\n    (hb : bd * b = b') (had : ad \u2260 0) (hbd : bd \u2260 0) (hgcd : gcd \u2260 0) :\n    (a \u2260 b) = (1 / gcd * (bd * a') \u2260 1 / gcd * (ad * b'))", "start": [105, 1], "end": [109, 69], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.findCancelFactor", "code": "partial def findCancelFactor (e : Expr) : \u2115 \u00d7 Tree \u2115 :=\n  match e.getAppFnArgs with\n  | (``HAdd.hAdd, #[_, _, _, _, e1, e2]) | (``HSub.hSub, #[_, _, _, _, e1, e2]) =>\n    let (v1, t1) := findCancelFactor e1\n    let (v2, t2) := findCancelFactor e2\n    let lcm := v1.lcm v2\n    (lcm, .node lcm t1 t2)\n  | (``HMul.hMul, #[_, _, _, _, e1, e2]) =>\n    let (v1, t1) := findCancelFactor e1\n    let (v2, t2) := findCancelFactor e2\n    let pd := v1 * v2\n    (pd, .node pd t1 t2)\n  | (``HDiv.hDiv, #[_, _, _, _, e1, e2]) =>\n    match e2.nat? with\n    | some q =>\n      let (v1, t1) := findCancelFactor e1\n      let n := v1 * q\n      (n, .node n t1 <| .node q .nil .nil)\n    | none => (1, .node 1 .nil .nil)\n  | (``Neg.neg, #[_, _, e]) => findCancelFactor e\n  | (``HPow.hPow, #[_, \u2115, _, _, e1, e2]) =>\n    match e2.nat? with\n    | some k =>\n      let (v1, t1) := findCancelFactor e1\n      let n := v1 ^ k\n      (n, .node n t1 <| .node k .nil .nil)\n    | none => (1, .node 1 .nil .nil)\n  | (``Inv.inv, #[_, _, e]) =>\n    match e.nat? with\n    | some q => (q, .node q .nil <| .node q .nil .nil)\n    | none => (1, .node 1 .nil .nil)\n  | _ => (1, .node 1 .nil .nil)", "start": [113, 1], "end": [150, 32], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.synthesizeUsingNormNum", "code": "def synthesizeUsingNormNum (type : Expr) : MetaM Expr := do\n  try\n    synthesizeUsingTactic' type (\u2190 `(tactic| norm_num))\n  catch e =>\n    throwError \"Could not prove {type} using norm_num. {e.toMessageData}\"", "start": [152, 1], "end": [156, 74], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.mkProdPrf", "code": "partial def mkProdPrf (\u03b1 : Q(Type u)) (s\u03b1 : Q(Field $\u03b1)) (v : \u2115) (t : Tree \u2115)\n    (e : Q($\u03b1)) : MetaM Expr := do\n  let amwo \u2190 synthInstanceQ q(AddMonoidWithOne $\u03b1)\n  trace[CancelDenoms] \"mkProdPrf {e} {v}\"\n  match t, e with\n  | .node _ lhs rhs, ~q($e1 + $e2) => do\n    let v1 \u2190 mkProdPrf \u03b1 s\u03b1 v lhs e1\n    let v2 \u2190 mkProdPrf \u03b1 s\u03b1 v rhs e2\n    mkAppM ``CancelDenoms.add_subst #[v1, v2]\n  | .node _ lhs rhs, ~q($e1 - $e2) => do\n    let v1 \u2190 mkProdPrf \u03b1 s\u03b1 v lhs e1\n    let v2 \u2190 mkProdPrf \u03b1 s\u03b1 v rhs e2\n    mkAppM ``CancelDenoms.sub_subst #[v1, v2]\n  | .node _ lhs@(.node ln _ _) rhs, ~q($e1 * $e2) => do\n    trace[CancelDenoms] \"recursing into mul\"\n    let v1 \u2190 mkProdPrf \u03b1 s\u03b1 ln lhs e1\n    let v2 \u2190 mkProdPrf \u03b1 s\u03b1 (v / ln) rhs e2\n    have ln' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit ln).1\n    have vln' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit (v/ln)).1\n    have v' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit v).1\n    let ntp : Q(Prop) := q($ln' * $vln' = $v')\n    let npf \u2190 synthesizeUsingNormNum ntp\n    mkAppM ``CancelDenoms.mul_subst #[v1, v2, npf]\n  | .node _ lhs (.node rn _ _), ~q($e1 / $e2) => do\n    let v1 \u2190 mkProdPrf \u03b1 s\u03b1 (v / rn) lhs e1\n    have rn' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit rn).1\n    have vrn' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit <| v / rn).1\n    have v' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit <| v).1\n    let ntp : Q(Prop) := q($rn' / $e2 = 1)\n    let npf \u2190 synthesizeUsingNormNum ntp\n    let ntp2 : Q(Prop) := q($vrn' * $rn' = $v')\n    let npf2 \u2190 synthesizeUsingNormNum ntp2\n    mkAppM ``CancelDenoms.div_subst #[v1, npf, npf2]\n  | t, ~q(-$e) => do\n    let v \u2190 mkProdPrf \u03b1 s\u03b1 v t e\n    mkAppM ``CancelDenoms.neg_subst #[v]\n  | .node _ lhs@(.node k1 _ _) (.node k2 .nil .nil), ~q($e1 ^ $e2) => do\n    let v1 \u2190 mkProdPrf \u03b1 s\u03b1 k1 lhs e1\n    have l := v / (k1 ^ k2)\n    have k1' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit k1).1\n    have v' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit v).1\n    have l' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit l).1\n    let ntp : Q(Prop) := q($l' * $k1' ^ $e2 = $v')\n    let npf \u2190 synthesizeUsingNormNum ntp\n    mkAppM ``CancelDenoms.pow_subst #[v1, npf]\n  | .node _ .nil (.node rn _ _), ~q($e \u207b\u00b9) => do\n    have rn' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit rn).1\n    have vrn' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit <| v / rn).1\n    have v' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit <| v).1\n    let ntp : Q(Prop) := q($rn' \u2260 0)\n    let npf \u2190 synthesizeUsingNormNum ntp\n    let ntp2 : Q(Prop) := q($vrn' * $rn' = $v')\n    let npf2 \u2190 synthesizeUsingNormNum ntp2\n    mkAppM ``CancelDenoms.inv_subst #[npf, npf2]\n  | _, _ => do\n    have v' := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit <| v).1\n    let e' \u2190 mkAppM ``HMul.hMul #[v', e]\n    mkEqRefl e'", "start": [158, 1], "end": [221, 16], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.deriveThms", "code": "def deriveThms : List Name :=\n  [``div_div_eq_mul_div, ``div_neg]", "start": [223, 1], "end": [226, 36], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.derive_trans", "code": "theorem derive_trans [Mul \u03b1] {a b c d : \u03b1} (h : a = b) (h' : c * b = d) : c * a = d", "start": [228, 1], "end": [229, 94], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.derive", "code": "def derive (e : Expr) : MetaM (\u2115 \u00d7 Expr) := do\n  trace[CancelDenoms] \"e = {e}\"\n  let eSimp \u2190 simpOnlyNames (config := Simp.neutralConfig) deriveThms e\n  trace[CancelDenoms] \"e simplified = {eSimp.expr}\"\n  let (n, t) := findCancelFactor eSimp.expr\n  let \u27e8u, tp, e\u27e9 \u2190 inferTypeQ' eSimp.expr\n  let stp \u2190 synthInstance q(Field $tp)\n  try\n    let pf \u2190 mkProdPrf tp stp n t eSimp.expr\n    trace[CancelDenoms] \"pf : {\u2190 inferType pf}\"\n    let pf' \u2190\n      if let some pfSimp := eSimp.proof? then\n        mkAppM ``derive_trans #[pfSimp, pf]\n      else\n        pure pf\n    return (n, pf')\n  catch E => do\n    throwError \"CancelDenoms.derive failed to normalize {e}.\\n{E.toMessageData}\"", "start": [231, 1], "end": [252, 81], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.findCompLemma", "code": "def findCompLemma (e : Expr) : Option (Expr \u00d7 Expr \u00d7 Name \u00d7 Bool) :=\n  match e.getAppFnArgs with\n  | (``LT.lt, #[_, _, a, b]) => (a, b, ``cancel_factors_lt, true)\n  | (``LE.le, #[_, _, a, b]) => (a, b, ``cancel_factors_le, true)\n  | (``Eq, #[_, a, b]) => (a, b, ``cancel_factors_eq, false)\n  | (``Ne, #[_, a, b]) => (a, b, ``cancel_factors_ne, false)\n  | (``GE.ge, #[_, _, a, b]) => (b, a, ``cancel_factors_le, true)\n  | (``GT.gt, #[_, _, a, b]) => (b, a, ``cancel_factors_lt, true)\n  | _ => none", "start": [254, 1], "end": [269, 14], "kind": "commanddeclaration"}, {"full_name": "CancelDenoms.cancelDenominatorsInType", "code": "def cancelDenominatorsInType (h : Expr) : MetaM (Expr \u00d7 Expr) := do\n  let some (lhs, rhs, lem, ord) := findCompLemma h | throwError \"cannot kill factors\"\n  let (al, lhs_p) \u2190 derive lhs\n  let \u27e8u, \u03b1, _\u27e9 \u2190 inferTypeQ' lhs\n  let amwo \u2190 synthInstanceQ q(AddMonoidWithOne $\u03b1)\n  let (ar, rhs_p) \u2190 derive rhs\n  let gcd := al.gcd ar\n  have al := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit al).1\n  have ar := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit ar).1\n  have gcd := (\u2190 mkOfNat \u03b1 amwo <| mkRawNatLit gcd).1\n  let (al_cond, ar_cond, gcd_cond) \u2190 if ord then do\n      let _ \u2190 synthInstanceQ q(LinearOrderedField $\u03b1)\n      let al_pos : Q(Prop) := q(0 < $al)\n      let ar_pos : Q(Prop) := q(0 < $ar)\n      let gcd_pos : Q(Prop) := q(0 < $gcd)\n      pure (al_pos, ar_pos, gcd_pos)\n    else do\n      let _ \u2190 synthInstanceQ q(Field $\u03b1)\n      let al_ne : Q(Prop) := q($al \u2260 0)\n      let ar_ne : Q(Prop) := q($ar \u2260 0)\n      let gcd_ne : Q(Prop) := q($gcd \u2260 0)\n      pure (al_ne, ar_ne, gcd_ne)\n  let al_cond \u2190 synthesizeUsingNormNum al_cond\n  let ar_cond \u2190 synthesizeUsingNormNum ar_cond\n  let gcd_cond \u2190 synthesizeUsingNormNum gcd_cond\n  let pf \u2190 mkAppM lem #[lhs_p, rhs_p, al_cond, ar_cond, gcd_cond]\n  let pf_tp \u2190 inferType pf\n  return ((findCompLemma pf_tp).elim default (Prod.fst \u2218 Prod.snd), pf)", "start": [271, 1], "end": [304, 72], "kind": "commanddeclaration"}, {"full_name": "cancelDenominatorsAt", "code": "def cancelDenominatorsAt (fvar : FVarId) : TacticM Unit := do\n  let t \u2190 instantiateMVars (\u2190 fvar.getDecl).type\n  let (new, eqPrf) \u2190 CancelDenoms.cancelDenominatorsInType t\n  liftMetaTactic' fun g => do\n    let res \u2190 g.replaceLocalDecl fvar new eqPrf\n    return res.mvarId", "start": [328, 1], "end": [333, 22], "kind": "commanddeclaration"}, {"full_name": "cancelDenominatorsTarget", "code": "def cancelDenominatorsTarget : TacticM Unit := do\n  let (new, eqPrf) \u2190 CancelDenoms.cancelDenominatorsInType (\u2190 getMainTarget)\n  liftMetaTactic' fun g => g.replaceTargetEq new eqPrf", "start": [335, 1], "end": [337, 55], "kind": "commanddeclaration"}, {"full_name": "cancelDenominators", "code": "def cancelDenominators (loc : Location) : TacticM Unit := do\n  withLocation loc cancelDenominatorsAt cancelDenominatorsTarget\n    (\u03bb _ => throwError \"Failed to cancel any denominators\")", "start": [339, 1], "end": [341, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/HashMap.lean", "imports": ["lake-packages/std/Std/Data/RBMap.lean", "lake-packages/std/Std/Data/HashMap.lean", "Mathlib/Init/Align.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Std.HashMap.keys", "code": "def keys (m : HashMap \u03b1 \u03b2) : List \u03b1 :=\n  m.fold (fun ks k _ => k :: ks) []", "start": [31, 1], "end": [33, 36], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.values", "code": "def values (m : HashMap \u03b1 \u03b2) : List \u03b2 :=\n  m.fold (fun vs _ v => v :: vs) []", "start": [35, 1], "end": [37, 36], "kind": "commanddeclaration"}, {"full_name": "Std.HashMap.consVal", "code": "def consVal (self : HashMap \u03b1 (List \u03b2)) (a : \u03b1) (b : \u03b2) : HashMap \u03b1 (List \u03b2) :=\n  match self.find? a with\n  | none => self.insert a [b]\n  | some L => self.insert a (b::L)", "start": [39, 1], "end": [43, 35], "kind": "commanddeclaration"}, {"full_name": "Std.RBSet.insertList", "code": "def insertList {cmp} (m : RBSet \u03b1 cmp) (L : List \u03b1) : RBSet \u03b1 cmp :=\n  L.foldl (fun m a => m.insert a) m", "start": [49, 1], "end": [51, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Zify.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Tactic/Basic.lean", "Mathlib/Tactic/NormCast.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Zify.mkZifyContext", "code": "def mkZifyContext (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar \",\")) :\n    TacticM MkSimpContextResult := do\n  let args := simpArgs.map (\u00b7.getElems) |>.getD #[]\n  mkSimpContext\n    (\u2190 `(tactic| simp (config := {decide := false}) only [zify_simps, push_cast, $args,*])) false", "start": [67, 1], "end": [72, 98], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Zify.applySimpResultToProp'", "code": "def applySimpResultToProp' (proof : Expr) (prop : Expr) (r : Simp.Result) : MetaM (Expr \u00d7 Expr) :=\n  do\n  match r.proof? with\n  | some eqProof => return (\u2190 mkExpectedTypeHint (\u2190 mkEqMP eqProof proof) r.expr, r.expr)\n  | none =>\n    if r.expr != prop then\n      return (\u2190 mkExpectedTypeHint proof r.expr, r.expr)\n    else\n      return (proof, r.expr)", "start": [74, 1], "end": [84, 29], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Zify.zifyProof", "code": "def zifyProof (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar \",\"))\n    (proof : Expr) (prop : Expr) : TacticM (Expr \u00d7 Expr) := do\n  let ctx_result \u2190 mkZifyContext simpArgs\n  let (r, _) \u2190 simp prop ctx_result.ctx\n  applySimpResultToProp' proof prop r", "start": [86, 1], "end": [91, 38], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Zify.nat_cast_eq", "code": "@[zify_simps] lemma nat_cast_eq (a b : \u2115) : a = b \u2194 (a : \u2124) = (b : \u2124) := Int.ofNat_inj.symm", "start": [93, 1], "end": [93, 92], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Zify.nat_cast_le", "code": "@[zify_simps] lemma nat_cast_le (a b : \u2115) : a \u2264 b \u2194 (a : \u2124) \u2264 (b : \u2124) := Int.ofNat_le.symm", "start": [94, 1], "end": [94, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Zify.nat_cast_lt", "code": "@[zify_simps] lemma nat_cast_lt (a b : \u2115) : a < b \u2194 (a : \u2124) < (b : \u2124) := Int.ofNat_lt.symm", "start": [95, 1], "end": [95, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Zify.nat_cast_ne", "code": "@[zify_simps] lemma nat_cast_ne (a b : \u2115) : a \u2260 b \u2194 (a : \u2124) \u2260 (b : \u2124) := by\n  simp only [ne_eq, Int.cast_eq_cast_iff_Nat]", "start": [96, 1], "end": [97, 46], "kind": "mathlibtacticlemma"}, {"full_name": "Mathlib.Tactic.Zify.nat_cast_dvd", "code": "@[zify_simps] lemma nat_cast_dvd (a b : \u2115) : a \u2223 b \u2194 (a : \u2124) \u2223 (b : \u2124) := Int.ofNat_dvd.symm", "start": [98, 1], "end": [98, 93], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Connected/Basic.lean", "imports": ["Mathlib/Order/SuccPred/Relation.lean", "Mathlib/Topology/Clopen.lean", "Mathlib/Topology/Irreducible.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsPreconnected", "code": "def IsPreconnected (s : Set \u03b1) : Prop :=\n  \u2200 u v : Set \u03b1, IsOpen u \u2192 IsOpen v \u2192 s \u2286 u \u222a v \u2192 (s \u2229 u).Nonempty \u2192 (s \u2229 v).Nonempty \u2192\n    (s \u2229 (u \u2229 v)).Nonempty", "start": [50, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "IsConnected", "code": "def IsConnected (s : Set \u03b1) : Prop :=\n  s.Nonempty \u2227 IsPreconnected s", "start": [56, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "IsConnected.nonempty", "code": "theorem IsConnected.nonempty {s : Set \u03b1} (h : IsConnected s) : s.Nonempty", "start": [61, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "IsConnected.isPreconnected", "code": "theorem IsConnected.isPreconnected {s : Set \u03b1} (h : IsConnected s) : IsPreconnected s", "start": [65, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.isPreconnected", "code": "theorem IsPreirreducible.isPreconnected {s : Set \u03b1} (H : IsPreirreducible s) : IsPreconnected s", "start": [69, 1], "end": [70, 33], "kind": "commanddeclaration"}, {"full_name": "IsIrreducible.isConnected", "code": "theorem IsIrreducible.isConnected {s : Set \u03b1} (H : IsIrreducible s) : IsConnected s", "start": [73, 1], "end": [74, 50], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_empty", "code": "theorem isPreconnected_empty : IsPreconnected (\u2205 : Set \u03b1)", "start": [77, 1], "end": [78, 40], "kind": "commanddeclaration"}, {"full_name": "isConnected_singleton", "code": "theorem isConnected_singleton {x} : IsConnected ({x} : Set \u03b1)", "start": [81, 1], "end": [82, 38], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_singleton", "code": "theorem isPreconnected_singleton {x} : IsPreconnected ({x} : Set \u03b1)", "start": [85, 1], "end": [86, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.isPreconnected", "code": "theorem Set.Subsingleton.isPreconnected {s : Set \u03b1} (hs : s.Subsingleton) : IsPreconnected s", "start": [89, 1], "end": [90, 73], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_of_forall", "code": "theorem isPreconnected_of_forall {s : Set \u03b1} (x : \u03b1)\n    (H : \u2200 y \u2208 s, \u2203 t, t \u2286 s \u2227 x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t) : IsPreconnected s", "start": [93, 1], "end": [110, 53], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_of_forall_pair", "code": "theorem isPreconnected_of_forall_pair {s : Set \u03b1}\n    (H : \u2200 x \u2208 s, \u2200 y \u2208 s, \u2203 t, t \u2286 s \u2227 x \u2208 t \u2227 y \u2208 t \u2227 IsPreconnected t) :\n    IsPreconnected s", "start": [113, 1], "end": [119, 78], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_sUnion", "code": "theorem isPreconnected_sUnion (x : \u03b1) (c : Set (Set \u03b1)) (H1 : \u2200 s \u2208 c, x \u2208 s)\n    (H2 : \u2200 s \u2208 c, IsPreconnected s) : IsPreconnected (\u22c3\u2080 c)", "start": [122, 1], "end": [127, 59], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_iUnion", "code": "theorem isPreconnected_iUnion {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} (h\u2081 : (\u22c2 i, s i).Nonempty)\n    (h\u2082 : \u2200 i, IsPreconnected (s i)) : IsPreconnected (\u22c3 i, s i)", "start": [130, 1], "end": [132, 82], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.union", "code": "theorem IsPreconnected.union (x : \u03b1) {s t : Set \u03b1} (H1 : x \u2208 s) (H2 : x \u2208 t) (H3 : IsPreconnected s)\n    (H4 : IsPreconnected t) : IsPreconnected (s \u222a t)", "start": [135, 1], "end": [138, 49], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.union'", "code": "theorem IsPreconnected.union' {s t : Set \u03b1} (H : (s \u2229 t).Nonempty) (hs : IsPreconnected s)\n    (ht : IsPreconnected t) : IsPreconnected (s \u222a t)", "start": [141, 1], "end": [144, 30], "kind": "commanddeclaration"}, {"full_name": "IsConnected.union", "code": "theorem IsConnected.union {s t : Set \u03b1} (H : (s \u2229 t).Nonempty) (Hs : IsConnected s)\n    (Ht : IsConnected t) : IsConnected (s \u222a t)", "start": [147, 1], "end": [152, 22], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.sUnion_directed", "code": "theorem IsPreconnected.sUnion_directed {S : Set (Set \u03b1)} (K : DirectedOn (\u00b7 \u2286 \u00b7) S)\n    (H : \u2200 s \u2208 S, IsPreconnected s) : IsPreconnected (\u22c3\u2080 S)", "start": [155, 1], "end": [163, 23], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.biUnion_of_reflTransGen", "code": "theorem IsPreconnected.biUnion_of_reflTransGen {\u03b9 : Type*} {t : Set \u03b9} {s : \u03b9 \u2192 Set \u03b1}\n    (H : \u2200 i \u2208 t, IsPreconnected (s i))\n    (K : \u2200 i, i \u2208 t \u2192 \u2200 j, j \u2208 t \u2192 ReflTransGen (fun i j => (s i \u2229 s j).Nonempty \u2227 i \u2208 t) i j) :\n    IsPreconnected (\u22c3 n \u2208 t, s n)", "start": [166, 1], "end": [194, 29], "kind": "commanddeclaration"}, {"full_name": "IsConnected.biUnion_of_reflTransGen", "code": "theorem IsConnected.biUnion_of_reflTransGen {\u03b9 : Type*} {t : Set \u03b9} {s : \u03b9 \u2192 Set \u03b1}\n    (ht : t.Nonempty) (H : \u2200 i \u2208 t, IsConnected (s i))\n    (K : \u2200 i, i \u2208 t \u2192 \u2200 j, j \u2208 t \u2192 ReflTransGen (fun i j : \u03b9 => (s i \u2229 s j).Nonempty \u2227 i \u2208 t) i j) :\n    IsConnected (\u22c3 n \u2208 t, s n)", "start": [197, 1], "end": [204, 84], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.iUnion_of_reflTransGen", "code": "theorem IsPreconnected.iUnion_of_reflTransGen {\u03b9 : Type*} {s : \u03b9 \u2192 Set \u03b1}\n    (H : \u2200 i, IsPreconnected (s i))\n    (K : \u2200 i j, ReflTransGen (fun i j : \u03b9 => (s i \u2229 s j).Nonempty) i j) :\n    IsPreconnected (\u22c3 n, s n)", "start": [207, 1], "end": [216, 33], "kind": "commanddeclaration"}, {"full_name": "IsConnected.iUnion_of_reflTransGen", "code": "theorem IsConnected.iUnion_of_reflTransGen {\u03b9 : Type*} [Nonempty \u03b9] {s : \u03b9 \u2192 Set \u03b1}\n    (H : \u2200 i, IsConnected (s i))\n    (K : \u2200 i j, ReflTransGen (fun i j : \u03b9 => (s i \u2229 s j).Nonempty) i j) : IsConnected (\u22c3 n, s n)", "start": [219, 1], "end": [223, 77], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.iUnion_of_chain", "code": "theorem IsPreconnected.iUnion_of_chain {s : \u03b2 \u2192 Set \u03b1} (H : \u2200 n, IsPreconnected (s n))\n    (K : \u2200 n, (s n \u2229 s (succ n)).Nonempty) : IsPreconnected (\u22c3 n, s n)", "start": [232, 1], "end": [239, 16], "kind": "commanddeclaration"}, {"full_name": "IsConnected.iUnion_of_chain", "code": "theorem IsConnected.iUnion_of_chain [Nonempty \u03b2] {s : \u03b2 \u2192 Set \u03b1} (H : \u2200 n, IsConnected (s n))\n    (K : \u2200 n, (s n \u2229 s (succ n)).Nonempty) : IsConnected (\u22c3 n, s n)", "start": [242, 1], "end": [249, 16], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.biUnion_of_chain", "code": "theorem IsPreconnected.biUnion_of_chain {s : \u03b2 \u2192 Set \u03b1} {t : Set \u03b2} (ht : OrdConnected t)\n    (H : \u2200 n \u2208 t, IsPreconnected (s n))\n    (K : \u2200 n : \u03b2, n \u2208 t \u2192 succ n \u2208 t \u2192 (s n \u2229 s (succ n)).Nonempty) :\n    IsPreconnected (\u22c3 n \u2208 t, s n)", "start": [252, 1], "end": [266, 59], "kind": "commanddeclaration"}, {"full_name": "IsConnected.biUnion_of_chain", "code": "theorem IsConnected.biUnion_of_chain {s : \u03b2 \u2192 Set \u03b1} {t : Set \u03b2} (hnt : t.Nonempty)\n    (ht : OrdConnected t) (H : \u2200 n \u2208 t, IsConnected (s n))\n    (K : \u2200 n : \u03b2, n \u2208 t \u2192 succ n \u2208 t \u2192 (s n \u2229 s (succ n)).Nonempty) : IsConnected (\u22c3 n \u2208 t, s n)", "start": [269, 1], "end": [275, 80], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_closure", "code": "protected theorem IsPreconnected.subset_closure {s : Set \u03b1} {t : Set \u03b1} (H : IsPreconnected s)\n    (Kst : s \u2286 t) (Ktcs : t \u2286 closure s) : IsPreconnected t", "start": [280, 1], "end": [288, 21], "kind": "commanddeclaration"}, {"full_name": "IsConnected.subset_closure", "code": "protected theorem IsConnected.subset_closure {s : Set \u03b1} {t : Set \u03b1} (H : IsConnected s)\n    (Kst : s \u2286 t) (Ktcs : t \u2286 closure s) : IsConnected t", "start": [291, 1], "end": [295, 77], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.closure", "code": "protected theorem IsPreconnected.closure {s : Set \u03b1} (H : IsPreconnected s) :\n    IsPreconnected (closure s)", "start": [298, 1], "end": [301, 60], "kind": "commanddeclaration"}, {"full_name": "IsConnected.closure", "code": "protected theorem IsConnected.closure {s : Set \u03b1} (H : IsConnected s) : IsConnected (closure s)", "start": [304, 1], "end": [306, 60], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.image", "code": "protected theorem IsPreconnected.image [TopologicalSpace \u03b2] {s : Set \u03b1} (H : IsPreconnected s)\n    (f : \u03b1 \u2192 \u03b2) (hf : ContinuousOn f s) : IsPreconnected (f '' s)", "start": [309, 1], "end": [328, 48], "kind": "commanddeclaration"}, {"full_name": "IsConnected.image", "code": "protected theorem IsConnected.image [TopologicalSpace \u03b2] {s : Set \u03b1} (H : IsConnected s) (f : \u03b1 \u2192 \u03b2)\n    (hf : ContinuousOn f s) : IsConnected (f '' s)", "start": [331, 1], "end": [334, 67], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_closed_iff", "code": "theorem isPreconnected_closed_iff {s : Set \u03b1} :\n    IsPreconnected s \u2194 \u2200 t t', IsClosed t \u2192 IsClosed t' \u2192\n      s \u2286 t \u222a t' \u2192 (s \u2229 t).Nonempty \u2192 (s \u2229 t').Nonempty \u2192 (s \u2229 (t \u2229 t')).Nonempty", "start": [337, 1], "end": [357, 61], "kind": "commanddeclaration"}, {"full_name": "Inducing.isPreconnected_image", "code": "theorem Inducing.isPreconnected_image [TopologicalSpace \u03b2] {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2}\n    (hf : Inducing f) : IsPreconnected (f '' s) \u2194 IsPreconnected s", "start": [360, 1], "end": [369, 23], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.preimage_of_open_map", "code": "theorem IsPreconnected.preimage_of_open_map [TopologicalSpace \u03b2] {s : Set \u03b2} (hs : IsPreconnected s)\n    {f : \u03b1 \u2192 \u03b2} (hinj : Function.Injective f) (hf : IsOpenMap f) (hsf : s \u2286 range f) :\n    IsPreconnected (f \u207b\u00b9' s)", "start": [374, 1], "end": [383, 50], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.preimage_of_closed_map", "code": "theorem IsPreconnected.preimage_of_closed_map [TopologicalSpace \u03b2] {s : Set \u03b2}\n    (hs : IsPreconnected s) {f : \u03b1 \u2192 \u03b2} (hinj : Function.Injective f) (hf : IsClosedMap f)\n    (hsf : s \u2286 range f) : IsPreconnected (f \u207b\u00b9' s)", "start": [386, 1], "end": [396, 52], "kind": "commanddeclaration"}, {"full_name": "IsConnected.preimage_of_openMap", "code": "theorem IsConnected.preimage_of_openMap [TopologicalSpace \u03b2] {s : Set \u03b2} (hs : IsConnected s)\n    {f : \u03b1 \u2192 \u03b2} (hinj : Function.Injective f) (hf : IsOpenMap f) (hsf : s \u2286 range f) :\n    IsConnected (f \u207b\u00b9' s)", "start": [399, 1], "end": [402, 82], "kind": "commanddeclaration"}, {"full_name": "IsConnected.preimage_of_closedMap", "code": "theorem IsConnected.preimage_of_closedMap [TopologicalSpace \u03b2] {s : Set \u03b2} (hs : IsConnected s)\n    {f : \u03b1 \u2192 \u03b2} (hinj : Function.Injective f) (hf : IsClosedMap f) (hsf : s \u2286 range f) :\n    IsConnected (f \u207b\u00b9' s)", "start": [405, 1], "end": [408, 84], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_or_subset", "code": "theorem IsPreconnected.subset_or_subset (hu : IsOpen u) (hv : IsOpen v) (huv : Disjoint u v)\n    (hsuv : s \u2286 u \u222a v) (hs : IsPreconnected s) : s \u2286 u \u2228 s \u2286 v", "start": [411, 1], "end": [419, 74], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_left_of_subset_union", "code": "theorem IsPreconnected.subset_left_of_subset_union (hu : IsOpen u) (hv : IsOpen v)\n    (huv : Disjoint u v) (hsuv : s \u2286 u \u222a v) (hsu : (s \u2229 u).Nonempty) (hs : IsPreconnected s) :\n    s \u2286 u", "start": [422, 1], "end": [430, 39], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_right_of_subset_union", "code": "theorem IsPreconnected.subset_right_of_subset_union (hu : IsOpen u) (hv : IsOpen v)\n    (huv : Disjoint u v) (hsuv : s \u2286 u \u222a v) (hsv : (s \u2229 v).Nonempty) (hs : IsPreconnected s) :\n    s \u2286 v", "start": [433, 1], "end": [436, 76], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_clopen", "code": "theorem IsPreconnected.subset_clopen {s t : Set \u03b1} (hs : IsPreconnected s) (ht : IsClopen t)\n    (hne : (s \u2229 t).Nonempty) : s \u2286 t", "start": [440, 1], "end": [443, 94], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_of_closure_inter_subset", "code": "theorem IsPreconnected.subset_of_closure_inter_subset (hs : IsPreconnected s) (hu : IsOpen u)\n    (h'u : (s \u2229 u).Nonempty) (h : closure u \u2229 s \u2286 u) : s \u2286 u", "start": [446, 1], "end": [458, 78], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.prod", "code": "theorem IsPreconnected.prod [TopologicalSpace \u03b2] {s : Set \u03b1} {t : Set \u03b2} (hs : IsPreconnected s)\n    (ht : IsPreconnected t) : IsPreconnected (s \u00d7\u02e2 t)", "start": [461, 1], "end": [469, 88], "kind": "commanddeclaration"}, {"full_name": "IsConnected.prod", "code": "theorem IsConnected.prod [TopologicalSpace \u03b2] {s : Set \u03b1} {t : Set \u03b2} (hs : IsConnected s)\n    (ht : IsConnected t) : IsConnected (s \u00d7\u02e2 t)", "start": [472, 1], "end": [474, 35], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_univ_pi", "code": "theorem isPreconnected_univ_pi [\u2200 i, TopologicalSpace (\u03c0 i)] {s : \u2200 i, Set (\u03c0 i)}\n    (hs : \u2200 i, IsPreconnected (s i)) : IsPreconnected (pi univ s)", "start": [477, 1], "end": [497, 41], "kind": "commanddeclaration"}, {"full_name": "isConnected_univ_pi", "code": "@[simp]\ntheorem isConnected_univ_pi [\u2200 i, TopologicalSpace (\u03c0 i)] {s : \u2200 i, Set (\u03c0 i)} :\n    IsConnected (pi univ s) \u2194 \u2200 i, IsConnected (s i)", "start": [500, 1], "end": [506, 53], "kind": "commanddeclaration"}, {"full_name": "Sigma.isConnected_iff", "code": "theorem Sigma.isConnected_iff [\u2200 i, TopologicalSpace (\u03c0 i)] {s : Set (\u03a3i, \u03c0 i)} :\n    IsConnected s \u2194 \u2203 i t, IsConnected t \u2227 s = Sigma.mk i '' t", "start": [509, 1], "end": [518, 53], "kind": "commanddeclaration"}, {"full_name": "Sigma.isPreconnected_iff", "code": "theorem Sigma.isPreconnected_iff [h\u03b9 : Nonempty \u03b9] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    {s : Set (\u03a3i, \u03c0 i)} : IsPreconnected s \u2194 \u2203 i t, IsPreconnected t \u2227 s = Sigma.mk i '' t", "start": [521, 1], "end": [529, 53], "kind": "commanddeclaration"}, {"full_name": "Sum.isConnected_iff", "code": "theorem Sum.isConnected_iff [TopologicalSpace \u03b2] {s : Set (Sum \u03b1 \u03b2)} :\n    IsConnected s \u2194\n      (\u2203 t, IsConnected t \u2227 s = Sum.inl '' t) \u2228 \u2203 t, IsConnected t \u2227 s = Sum.inr '' t", "start": [532, 1], "end": [549, 51], "kind": "commanddeclaration"}, {"full_name": "Sum.isPreconnected_iff", "code": "theorem Sum.isPreconnected_iff [TopologicalSpace \u03b2] {s : Set (Sum \u03b1 \u03b2)} :\n    IsPreconnected s \u2194\n      (\u2203 t, IsPreconnected t \u2227 s = Sum.inl '' t) \u2228 \u2203 t, IsPreconnected t \u2227 s = Sum.inr '' t", "start": [552, 1], "end": [563, 51], "kind": "commanddeclaration"}, {"full_name": "connectedComponent", "code": "def connectedComponent (x : \u03b1) : Set \u03b1 :=\n  \u22c3\u2080 { s : Set \u03b1 | IsPreconnected s \u2227 x \u2208 s }", "start": [566, 1], "end": [569, 46], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn", "code": "def connectedComponentIn (F : Set \u03b1) (x : \u03b1) : Set \u03b1 :=\n  if h : x \u2208 F then (\u2191) '' connectedComponent (\u27e8x, h\u27e9 : F) else \u2205", "start": [572, 1], "end": [577, 66], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_eq_image", "code": "theorem connectedComponentIn_eq_image {F : Set \u03b1} {x : \u03b1} (h : x \u2208 F) :\n    connectedComponentIn F x = (\u2191) '' connectedComponent (\u27e8x, h\u27e9 : F)", "start": [580, 1], "end": [582, 12], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_eq_empty", "code": "theorem connectedComponentIn_eq_empty {F : Set \u03b1} {x : \u03b1} (h : x \u2209 F) :\n    connectedComponentIn F x = \u2205", "start": [585, 1], "end": [587, 12], "kind": "commanddeclaration"}, {"full_name": "mem_connectedComponent", "code": "theorem mem_connectedComponent {x : \u03b1} : x \u2208 connectedComponent x", "start": [590, 1], "end": [591, 82], "kind": "commanddeclaration"}, {"full_name": "mem_connectedComponentIn", "code": "theorem mem_connectedComponentIn {x : \u03b1} {F : Set \u03b1} (hx : x \u2208 F) : x \u2208 connectedComponentIn F x", "start": [594, 1], "end": [595, 73], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_nonempty", "code": "theorem connectedComponent_nonempty {x : \u03b1} : (connectedComponent x).Nonempty", "start": [598, 1], "end": [599, 30], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_nonempty_iff", "code": "theorem connectedComponentIn_nonempty_iff {x : \u03b1} {F : Set \u03b1} :\n    (connectedComponentIn F x).Nonempty \u2194 x \u2208 F", "start": [602, 1], "end": [605, 54], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_subset", "code": "theorem connectedComponentIn_subset (F : Set \u03b1) (x : \u03b1) : connectedComponentIn F x \u2286 F", "start": [608, 1], "end": [610, 21], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_connectedComponent", "code": "theorem isPreconnected_connectedComponent {x : \u03b1} : IsPreconnected (connectedComponent x)", "start": [613, 1], "end": [614, 67], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_connectedComponentIn", "code": "theorem isPreconnected_connectedComponentIn {x : \u03b1} {F : Set \u03b1} :\n    IsPreconnected (connectedComponentIn F x)", "start": [617, 1], "end": [621, 31], "kind": "commanddeclaration"}, {"full_name": "isConnected_connectedComponent", "code": "theorem isConnected_connectedComponent {x : \u03b1} : IsConnected (connectedComponent x)", "start": [624, 1], "end": [625, 67], "kind": "commanddeclaration"}, {"full_name": "isConnected_connectedComponentIn_iff", "code": "theorem isConnected_connectedComponentIn_iff {x : \u03b1} {F : Set \u03b1} :\n    IsConnected (connectedComponentIn F x) \u2194 x \u2208 F", "start": [628, 1], "end": [631, 18], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_connectedComponent", "code": "theorem IsPreconnected.subset_connectedComponent {x : \u03b1} {s : Set \u03b1} (H1 : IsPreconnected s)\n    (H2 : x \u2208 s) : s \u2286 connectedComponent x", "start": [634, 1], "end": [635, 90], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subset_connectedComponentIn", "code": "theorem IsPreconnected.subset_connectedComponentIn {x : \u03b1} {F : Set \u03b1} (hs : IsPreconnected s)\n    (hxs : x \u2208 s) (hsF : s \u2286 F) : s \u2286 connectedComponentIn F x", "start": [638, 1], "end": [649, 57], "kind": "commanddeclaration"}, {"full_name": "IsConnected.subset_connectedComponent", "code": "theorem IsConnected.subset_connectedComponent {x : \u03b1} {s : Set \u03b1} (H1 : IsConnected s)\n    (H2 : x \u2208 s) : s \u2286 connectedComponent x", "start": [652, 1], "end": [654, 36], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.connectedComponentIn", "code": "theorem IsPreconnected.connectedComponentIn {x : \u03b1} {F : Set \u03b1} (h : IsPreconnected F)\n    (hx : x \u2208 F) : connectedComponentIn F x = F", "start": [657, 1], "end": [659, 91], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_eq", "code": "theorem connectedComponent_eq {x y : \u03b1} (h : y \u2208 connectedComponent x) :\n    connectedComponent x = connectedComponent y", "start": [662, 1], "end": [667, 71], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_eq_iff_mem", "code": "theorem connectedComponent_eq_iff_mem {x y : \u03b1} :\n    connectedComponent x = connectedComponent y \u2194 x \u2208 connectedComponent y", "start": [670, 1], "end": [672, 81], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_eq", "code": "theorem connectedComponentIn_eq {x y : \u03b1} {F : Set \u03b1} (h : y \u2208 connectedComponentIn F x) :\n    connectedComponentIn F x = connectedComponentIn F y", "start": [675, 1], "end": [680, 72], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_univ", "code": "theorem connectedComponentIn_univ (x : \u03b1) : connectedComponentIn univ x = connectedComponent x", "start": [683, 1], "end": [688, 21], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_disjoint", "code": "theorem connectedComponent_disjoint {x y : \u03b1} (h : connectedComponent x \u2260 connectedComponent y) :\n    Disjoint (connectedComponent x) (connectedComponent y)", "start": [691, 1], "end": [694, 73], "kind": "commanddeclaration"}, {"full_name": "isClosed_connectedComponent", "code": "theorem isClosed_connectedComponent {x : \u03b1} : IsClosed (connectedComponent x)", "start": [697, 1], "end": [700, 44], "kind": "commanddeclaration"}, {"full_name": "Continuous.image_connectedComponent_subset", "code": "theorem Continuous.image_connectedComponent_subset [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) (a : \u03b1) : f '' connectedComponent a \u2286 connectedComponent (f a)", "start": [703, 1], "end": [706, 84], "kind": "commanddeclaration"}, {"full_name": "Continuous.mapsTo_connectedComponent", "code": "theorem Continuous.mapsTo_connectedComponent [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Continuous f)\n    (a : \u03b1) : MapsTo f (connectedComponent a) (connectedComponent (f a))", "start": [709, 1], "end": [711, 51], "kind": "commanddeclaration"}, {"full_name": "irreducibleComponent_subset_connectedComponent", "code": "theorem irreducibleComponent_subset_connectedComponent {x : \u03b1} :\n    irreducibleComponent x \u2286 connectedComponent x", "start": [714, 1], "end": [716, 100], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_mono", "code": "@[mono]\ntheorem connectedComponentIn_mono (x : \u03b1) {F G : Set \u03b1} (h : F \u2286 G) :\n    connectedComponentIn F x \u2286 connectedComponentIn G x", "start": [720, 1], "end": [728, 29], "kind": "commanddeclaration"}, {"full_name": "PreconnectedSpace", "code": "class PreconnectedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  isPreconnected_univ : IsPreconnected (univ : Set \u03b1)", "start": [731, 1], "end": [734, 54], "kind": "commanddeclaration"}, {"full_name": "ConnectedSpace", "code": "class ConnectedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1] extends PreconnectedSpace \u03b1 : Prop where\n  \n  toNonempty : Nonempty \u03b1", "start": [739, 1], "end": [742, 26], "kind": "commanddeclaration"}, {"full_name": "isConnected_univ", "code": "theorem isConnected_univ [ConnectedSpace \u03b1] : IsConnected (univ : Set \u03b1)", "start": [748, 1], "end": [749, 39], "kind": "commanddeclaration"}, {"full_name": "preconnectedSpace_iff_univ", "code": "lemma preconnectedSpace_iff_univ : PreconnectedSpace \u03b1 \u2194 IsPreconnected (univ : Set \u03b1) :=\n  \u27e8fun h \u21a6 h.1, fun h \u21a6 \u27e8h\u27e9\u27e9", "start": [752, 1], "end": [753, 29], "kind": "mathlibtacticlemma"}, {"full_name": "connectedSpace_iff_univ", "code": "lemma connectedSpace_iff_univ : ConnectedSpace \u03b1 \u2194 IsConnected (univ : Set \u03b1) :=\n  \u27e8fun h \u21a6 \u27e8univ_nonempty, h.1.1\u27e9,\n   fun h \u21a6 ConnectedSpace.mk (toPreconnectedSpace := \u27e8h.2\u27e9) \u27e8h.1.some\u27e9\u27e9", "start": [755, 1], "end": [757, 72], "kind": "mathlibtacticlemma"}, {"full_name": "isPreconnected_range", "code": "theorem isPreconnected_range [TopologicalSpace \u03b2] [PreconnectedSpace \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) : IsPreconnected (range f)", "start": [759, 1], "end": [761, 65], "kind": "commanddeclaration"}, {"full_name": "isConnected_range", "code": "theorem isConnected_range [TopologicalSpace \u03b2] [ConnectedSpace \u03b1] {f : \u03b1 \u2192 \u03b2} (h : Continuous f) :\n    IsConnected (range f)", "start": [764, 1], "end": [766, 45], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.connectedSpace", "code": "theorem Function.Surjective.connectedSpace [ConnectedSpace \u03b1] [TopologicalSpace \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) (hf' : Continuous f) : ConnectedSpace \u03b2", "start": [769, 1], "end": [772, 30], "kind": "commanddeclaration"}, {"full_name": "Quotient.instConnectedSpace", "code": "instance Quotient.instConnectedSpace {s : Setoid \u03b1} [ConnectedSpace \u03b1] :\n    ConnectedSpace (Quotient s) :=\n  (surjective_quotient_mk' _).connectedSpace continuous_coinduced_rng", "start": [774, 1], "end": [776, 70], "kind": "commanddeclaration"}, {"full_name": "DenseRange.preconnectedSpace", "code": "theorem DenseRange.preconnectedSpace [TopologicalSpace \u03b2] [PreconnectedSpace \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : DenseRange f) (hc : Continuous f) : PreconnectedSpace \u03b2", "start": [778, 1], "end": [780, 54], "kind": "commanddeclaration"}, {"full_name": "connectedSpace_iff_connectedComponent", "code": "theorem connectedSpace_iff_connectedComponent :\n    ConnectedSpace \u03b1 \u2194 \u2203 x : \u03b1, connectedComponent x = univ", "start": [783, 1], "end": [792, 16], "kind": "commanddeclaration"}, {"full_name": "preconnectedSpace_iff_connectedComponent", "code": "theorem preconnectedSpace_iff_connectedComponent :\n    PreconnectedSpace \u03b1 \u2194 \u2200 x : \u03b1, connectedComponent x = univ", "start": [795, 1], "end": [803, 89], "kind": "commanddeclaration"}, {"full_name": "PreconnectedSpace.connectedComponent_eq_univ", "code": "@[simp]\ntheorem PreconnectedSpace.connectedComponent_eq_univ {X : Type*} [TopologicalSpace X]\n    [h : PreconnectedSpace X] (x : X) : connectedComponent x = univ", "start": [806, 1], "end": [809, 50], "kind": "commanddeclaration"}, {"full_name": "PreirreducibleSpace.preconnectedSpace", "code": "instance (priority := 100) PreirreducibleSpace.preconnectedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1]\n    [PreirreducibleSpace \u03b1] : PreconnectedSpace \u03b1 :=\n  \u27e8isPreirreducible_univ.isPreconnected\u27e9", "start": [829, 1], "end": [831, 41], "kind": "commanddeclaration"}, {"full_name": "IrreducibleSpace.connectedSpace", "code": "instance (priority := 100) IrreducibleSpace.connectedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1]\n    [IrreducibleSpace \u03b1] : ConnectedSpace \u03b1 where toNonempty := IrreducibleSpace.toNonempty", "start": [835, 1], "end": [836, 92], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_lift_sigma", "code": "theorem Continuous.exists_lift_sigma [ConnectedSpace \u03b1] [\u2200 i, TopologicalSpace (\u03c0 i)]\n    {f : \u03b1 \u2192 \u03a3 i, \u03c0 i} (hf : Continuous f) :\n    \u2203 (i : \u03b9) (g : \u03b1 \u2192 \u03c0 i), Continuous g \u2227 f = Sigma.mk i \u2218 g", "start": [839, 1], "end": [850, 49], "kind": "commanddeclaration"}, {"full_name": "nonempty_inter", "code": "theorem nonempty_inter [PreconnectedSpace \u03b1] {s t : Set \u03b1} :\n    IsOpen s \u2192 IsOpen t \u2192 s \u222a t = univ \u2192 s.Nonempty \u2192 t.Nonempty \u2192 (s \u2229 t).Nonempty", "start": [852, 1], "end": [854, 98], "kind": "commanddeclaration"}, {"full_name": "isClopen_iff", "code": "theorem isClopen_iff [PreconnectedSpace \u03b1] {s : Set \u03b1} : IsClopen s \u2194 s = \u2205 \u2228 s = univ", "start": [857, 1], "end": [867, 75], "kind": "commanddeclaration"}, {"full_name": "IsClopen.eq_univ", "code": "theorem IsClopen.eq_univ [PreconnectedSpace \u03b1] {s : Set \u03b1} (h' : IsClopen s) (h : s.Nonempty) :\n    s = univ", "start": [870, 1], "end": [872, 47], "kind": "commanddeclaration"}, {"full_name": "subsingleton_of_disjoint_isClopen", "code": "lemma subsingleton_of_disjoint_isClopen\n    (h_clopen : \u2200 i, IsClopen (s i)) :\n    Subsingleton \u03b9 := by\n  replace h_nonempty : \u2200 i, s i \u2260 \u2205 := by intro i; rw [\u2190 nonempty_iff_ne_empty]; exact h_nonempty i\n  rw [\u2190 not_nontrivial_iff_subsingleton]\n  by_contra contra\n  obtain \u27e8i, j, h_ne\u27e9 := contra\n  replace h_ne : s i \u2229 s j = \u2205 := by\n    simpa only [\u2190 bot_eq_empty, eq_bot_iff, \u2190 inf_eq_inter, \u2190 disjoint_iff_inf_le] using h_disj h_ne\n  cases' isClopen_iff.mp (h_clopen i) with hi hi\n  \u00b7 exact h_nonempty i hi\n  \u00b7 rw [hi, univ_inter] at h_ne\n    exact h_nonempty j h_ne", "start": [880, 1], "end": [894, 28], "kind": "mathlibtacticlemma"}, {"full_name": "subsingleton_of_disjoint_isOpen_iUnion_eq_univ", "code": "lemma subsingleton_of_disjoint_isOpen_iUnion_eq_univ\n    (h_open : \u2200 i, IsOpen (s i)) (h_Union : \u22c3 i, s i = univ) :\n    Subsingleton \u03b9 := by\n  refine' subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i \u21a6 \u27e8h_open i, _\u27e9)\n  rw [\u2190 isOpen_compl_iff, compl_eq_univ_diff, \u2190 h_Union, iUnion_diff]\n  refine' isOpen_iUnion (fun j \u21a6 _)\n  rcases eq_or_ne i j with rfl | h_ne\n  \u00b7 simp\n  \u00b7 simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_open j", "start": [896, 1], "end": [906, 65], "kind": "mathlibtacticlemma"}, {"full_name": "subsingleton_of_disjoint_isClosed_iUnion_eq_univ", "code": "lemma subsingleton_of_disjoint_isClosed_iUnion_eq_univ [Finite \u03b9]\n    (h_closed : \u2200 i, IsClosed (s i)) (h_Union : \u22c3 i, s i = univ) :\n    Subsingleton \u03b9 := by\n  refine' subsingleton_of_disjoint_isClopen h_nonempty h_disj (fun i \u21a6 \u27e8_, h_closed i\u27e9)\n  rw [\u2190 isClosed_compl_iff, compl_eq_univ_diff, \u2190 h_Union, iUnion_diff]\n  refine' isClosed_iUnion_of_finite (fun j \u21a6 _)\n  rcases eq_or_ne i j with rfl | h_ne\n  \u00b7 simp\n  \u00b7 simpa only [(h_disj h_ne.symm).sdiff_eq_left] using h_closed j", "start": [908, 1], "end": [918, 67], "kind": "mathlibtacticlemma"}, {"full_name": "frontier_eq_empty_iff", "code": "theorem frontier_eq_empty_iff [PreconnectedSpace \u03b1] {s : Set \u03b1} :\n    frontier s = \u2205 \u2194 s = \u2205 \u2228 s = univ", "start": [922, 1], "end": [924, 57], "kind": "commanddeclaration"}, {"full_name": "nonempty_frontier_iff", "code": "theorem nonempty_frontier_iff [PreconnectedSpace \u03b1] {s : Set \u03b1} :\n    (frontier s).Nonempty \u2194 s.Nonempty \u2227 s \u2260 univ", "start": [927, 1], "end": [929, 75], "kind": "commanddeclaration"}, {"full_name": "Subtype.preconnectedSpace", "code": "theorem Subtype.preconnectedSpace {s : Set \u03b1} (h : IsPreconnected s) : PreconnectedSpace s where", "start": [932, 1], "end": [934, 85], "kind": "commanddeclaration"}, {"full_name": "Subtype.connectedSpace", "code": "theorem Subtype.connectedSpace {s : Set \u03b1} (h : IsConnected s) : ConnectedSpace s where", "start": [937, 1], "end": [939, 38], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_iff_preconnectedSpace", "code": "theorem isPreconnected_iff_preconnectedSpace {s : Set \u03b1} : IsPreconnected s \u2194 PreconnectedSpace s", "start": [942, 1], "end": [944, 93], "kind": "commanddeclaration"}, {"full_name": "isConnected_iff_connectedSpace", "code": "theorem isConnected_iff_connectedSpace {s : Set \u03b1} : IsConnected s \u2194 ConnectedSpace s", "start": [947, 1], "end": [949, 77], "kind": "commanddeclaration"}, {"full_name": "PreconnectedSpace.induction\u2082'", "code": "lemma PreconnectedSpace.induction\u2082' [PreconnectedSpace \u03b1] (P : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 x, \u2200\u1da0 y in \ud835\udcdd x, P x y \u2227 P y x) (h' : Transitive P) (x y : \u03b1) :\n    P x y := by\n  let u := {z | P x z}\n  have A : IsOpen u := by\n    apply isOpen_iff_mem_nhds.2 (fun z hz \u21a6 ?_)\n    filter_upwards [h z] with t ht\n    exact h' hz ht.1\n  have B : IsClosed u := by\n    apply isClosed_iff_nhds.2 (fun z hz \u21a6 ?_)\n    rcases hz _ (h z) with \u27e8t, ht, h't\u27e9\n    exact h' h't ht.2\n  have C : u.Nonempty := \u27e8x, (mem_of_mem_nhds (h x)).1\u27e9\n  have D : u = Set.univ := IsClopen.eq_univ \u27e8A, B\u27e9 C\n  show y \u2208 u\n  simp [D]", "start": [952, 1], "end": [970, 11], "kind": "mathlibtacticlemma"}, {"full_name": "PreconnectedSpace.induction\u2082", "code": "lemma PreconnectedSpace.induction\u2082 [PreconnectedSpace \u03b1] (P : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 x, \u2200\u1da0 y in \ud835\udcdd x, P x y) (h' : Transitive P) (h'' : Symmetric P) (x y : \u03b1) :\n    P x y := by\n  refine PreconnectedSpace.induction\u2082' P (fun z \u21a6 ?_) h' x y\n  filter_upwards [h z] with a ha\n  refine \u27e8ha, h'' ha\u27e9", "start": [972, 1], "end": [980, 22], "kind": "mathlibtacticlemma"}, {"full_name": "IsPreconnected.induction\u2082'", "code": "lemma IsPreconnected.induction\u2082' {s : Set \u03b1} (hs : IsPreconnected s) (P : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 x \u2208 s, \u2200\u1da0 y in \ud835\udcdd[s] x, P x y \u2227 P y x)\n    (h' : \u2200 x y z, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 P x y \u2192 P y z \u2192 P x z)\n    {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) : P x y := by\n  let Q : s \u2192 s \u2192 Prop := fun a b \u21a6 P a b\n  show Q \u27e8x, hx\u27e9 \u27e8y, hy\u27e9\n  have : PreconnectedSpace s := Subtype.preconnectedSpace hs\n  apply PreconnectedSpace.induction\u2082'\n  \u00b7 rintro \u27e8x, hx\u27e9\n    have Z := h x hx\n    rwa [nhdsWithin_eq_map_subtype_coe] at Z\n  \u00b7 rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 \u27e8c, hc\u27e9 hab hbc\n    exact h' a b c ha hb hc  hab hbc", "start": [982, 1], "end": [997, 37], "kind": "mathlibtacticlemma"}, {"full_name": "IsPreconnected.induction\u2082", "code": "lemma IsPreconnected.induction\u2082 {s : Set \u03b1} (hs : IsPreconnected s) (P : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (h : \u2200 x \u2208 s, \u2200\u1da0 y in \ud835\udcdd[s] x, P x y)\n    (h' : \u2200 x y z, x \u2208 s \u2192 y \u2208 s \u2192 z \u2208 s \u2192 P x y \u2192 P y z \u2192 P x z)\n    (h'' : \u2200 x y, x \u2208 s \u2192 y \u2208 s \u2192 P x y \u2192 P y x)\n    {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s) : P x y := by\n  apply hs.induction\u2082' P (fun z hz \u21a6 ?_) h' hx hy\n  filter_upwards [h z hz, self_mem_nhdsWithin] with a ha h'a\n  exact \u27e8ha, h'' z a hz h'a ha\u27e9", "start": [999, 1], "end": [1009, 32], "kind": "mathlibtacticlemma"}, {"full_name": "isPreconnected_iff_subset_of_disjoint", "code": "theorem isPreconnected_iff_subset_of_disjoint {s : Set \u03b1} :\n    IsPreconnected s \u2194\n      \u2200 u v, IsOpen u \u2192 IsOpen v \u2192 s \u2286 u \u222a v \u2192 s \u2229 (u \u2229 v) = \u2205 \u2192 s \u2286 u \u2228 s \u2286 v", "start": [1011, 1], "end": [1036, 35], "kind": "commanddeclaration"}, {"full_name": "isConnected_iff_sUnion_disjoint_open", "code": "theorem isConnected_iff_sUnion_disjoint_open {s : Set \u03b1} :\n    IsConnected s \u2194\n      \u2200 U : Finset (Set \u03b1), (\u2200 u v : Set \u03b1, u \u2208 U \u2192 v \u2208 U \u2192 (s \u2229 (u \u2229 v)).Nonempty \u2192 u = v) \u2192\n        (\u2200 u \u2208 U, IsOpen u) \u2192 (s \u2286 \u22c3\u2080 \u2191U) \u2192 \u2203 u \u2208 U, s \u2286 u", "start": [1039, 1], "end": [1060, 49], "kind": "commanddeclaration"}, {"full_name": "disjoint_or_subset_of_clopen", "code": "theorem disjoint_or_subset_of_clopen {s t : Set \u03b1} (hs : IsPreconnected s) (ht : IsClopen t) :\n    Disjoint s t \u2228 s \u2286 t", "start": [1065, 1], "end": [1068, 68], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_iff_subset_of_disjoint_closed", "code": "theorem isPreconnected_iff_subset_of_disjoint_closed :\n    IsPreconnected s \u2194\n      \u2200 u v, IsClosed u \u2192 IsClosed v \u2192 s \u2286 u \u222a v \u2192 s \u2229 (u \u2229 v) = \u2205 \u2192 s \u2286 u \u2228 s \u2286 v", "start": [1071, 1], "end": [1099, 35], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_iff_subset_of_fully_disjoint_closed", "code": "theorem isPreconnected_iff_subset_of_fully_disjoint_closed {s : Set \u03b1} (hs : IsClosed s) :\n    IsPreconnected s \u2194\n      \u2200 u v, IsClosed u \u2192 IsClosed v \u2192 s \u2286 u \u222a v \u2192 Disjoint u v \u2192 s \u2286 u \u2228 s \u2286 v", "start": [1102, 1], "end": [1116, 79], "kind": "commanddeclaration"}, {"full_name": "IsClopen.connectedComponent_subset", "code": "theorem IsClopen.connectedComponent_subset {x} (hs : IsClopen s) (hx : x \u2208 s) :\n    connectedComponent x \u2286 s", "start": [1120, 1], "end": [1122, 85], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_subset_iInter_clopen", "code": "theorem connectedComponent_subset_iInter_clopen {x : \u03b1} :\n    connectedComponent x \u2286 \u22c2 Z : { Z : Set \u03b1 // IsClopen Z \u2227 x \u2208 Z }, Z", "start": [1125, 1], "end": [1129, 63], "kind": "commanddeclaration"}, {"full_name": "IsClopen.biUnion_connectedComponent_eq", "code": "theorem IsClopen.biUnion_connectedComponent_eq {Z : Set \u03b1} (h : IsClopen Z) :\n    \u22c3 x \u2208 Z, connectedComponent x = Z", "start": [1132, 1], "end": [1136, 48], "kind": "commanddeclaration"}, {"full_name": "preimage_connectedComponent_connected", "code": "theorem preimage_connectedComponent_connected [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (connected_fibers : \u2200 t : \u03b2, IsConnected (f \u207b\u00b9' {t}))\n    (hcl : \u2200 T : Set \u03b2, IsClosed T \u2194 IsClosed (f \u207b\u00b9' T)) (t : \u03b2) :\n    IsConnected (f \u207b\u00b9' connectedComponent t)", "start": [1139, 1], "end": [1215, 26], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.preimage_connectedComponent", "code": "theorem QuotientMap.preimage_connectedComponent [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : QuotientMap f) (h_fibers : \u2200 y : \u03b2, IsConnected (f \u207b\u00b9' {y})) (a : \u03b1) :\n    f \u207b\u00b9' connectedComponent (f a) = connectedComponent a", "start": [1218, 1], "end": [1223, 48], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.image_connectedComponent", "code": "theorem QuotientMap.image_connectedComponent [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : QuotientMap f)\n    (h_fibers : \u2200 y : \u03b2, IsConnected (f \u207b\u00b9' {y})) (a : \u03b1) :\n    f '' connectedComponent a = connectedComponent (f a)", "start": [1226, 1], "end": [1229, 84], "kind": "commanddeclaration"}, {"full_name": "connectedComponentSetoid", "code": "def connectedComponentSetoid (\u03b1 : Type*) [TopologicalSpace \u03b1] : Setoid \u03b1 :=\n  \u27e8fun x y => connectedComponent x = connectedComponent y,\n    \u27e8fun x => by trivial, fun h1 => h1.symm, fun h1 h2 => h1.trans h2\u27e9\u27e9", "start": [1235, 1], "end": [1238, 72], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents", "code": "def ConnectedComponents (\u03b1 : Type u) [TopologicalSpace \u03b1] :=\n  Quotient (connectedComponentSetoid \u03b1)", "start": [1241, 1], "end": [1243, 40], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.mk", "code": "def mk : \u03b1 \u2192 ConnectedComponents \u03b1 := Quotient.mk''", "start": [1248, 1], "end": [1249, 52], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.coe_eq_coe", "code": "@[simp]\ntheorem coe_eq_coe {x y : \u03b1} :\n    (x : ConnectedComponents \u03b1) = y \u2194 connectedComponent x = connectedComponent y", "start": [1253, 1], "end": [1256, 16], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.coe_ne_coe", "code": "theorem coe_ne_coe {x y : \u03b1} :\n    (x : ConnectedComponents \u03b1) \u2260 y \u2194 connectedComponent x \u2260 connectedComponent y", "start": [1259, 1], "end": [1261, 17], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.coe_eq_coe'", "code": "theorem coe_eq_coe' {x y : \u03b1} : (x : ConnectedComponents \u03b1) = y \u2194 x \u2208 connectedComponent y", "start": [1264, 1], "end": [1265, 49], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.surjective_coe", "code": "theorem surjective_coe : Surjective (mk : \u03b1 \u2192 ConnectedComponents \u03b1)", "start": [1274, 1], "end": [1275, 23], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.quotientMap_coe", "code": "theorem quotientMap_coe : QuotientMap (mk : \u03b1 \u2192 ConnectedComponents \u03b1)", "start": [1278, 1], "end": [1279, 22], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.continuous_coe", "code": "@[continuity]\ntheorem continuous_coe : Continuous (mk : \u03b1 \u2192 ConnectedComponents \u03b1)", "start": [1282, 1], "end": [1284, 29], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.range_coe", "code": "@[simp]\ntheorem range_coe : range (mk : \u03b1 \u2192 ConnectedComponents \u03b1) = univ", "start": [1287, 1], "end": [1289, 26], "kind": "commanddeclaration"}, {"full_name": "connectedComponents_preimage_singleton", "code": "theorem connectedComponents_preimage_singleton {x : \u03b1} :\n    (\u2191) \u207b\u00b9' ({\u2191x} : Set (ConnectedComponents \u03b1)) = connectedComponent x", "start": [1294, 1], "end": [1299, 72], "kind": "commanddeclaration"}, {"full_name": "connectedComponents_preimage_image", "code": "theorem connectedComponents_preimage_image (U : Set \u03b1) :\n    (\u2191) \u207b\u00b9' ((\u2191) '' U : Set (ConnectedComponents \u03b1)) = \u22c3 x \u2208 U, connectedComponent x", "start": [1302, 1], "end": [1306, 88], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_of_forall_constant", "code": "theorem isPreconnected_of_forall_constant {s : Set \u03b1}\n    (hs : \u2200 f : \u03b1 \u2192 Bool, ContinuousOn f s \u2192 \u2200 x \u2208 s, \u2200 y \u2208 s, f x = f y) : IsPreconnected s", "start": [1313, 1], "end": [1328, 32], "kind": "commanddeclaration"}, {"full_name": "preconnectedSpace_of_forall_constant", "code": "theorem preconnectedSpace_of_forall_constant\n    (hs : \u2200 f : \u03b1 \u2192 Bool, Continuous f \u2192 \u2200 x y, f x = f y) : PreconnectedSpace \u03b1", "start": [1331, 1], "end": [1335, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Compactness/LocallyCompact.lean", "imports": ["Mathlib/Topology/Compactness/Compact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WeaklyLocallyCompactSpace", "code": "class WeaklyLocallyCompactSpace (X : Type*) [TopologicalSpace X] : Prop where\n  \n  exists_compact_mem_nhds (x : X) : \u2203 s, IsCompact s \u2227 s \u2208 \ud835\udcdd x", "start": [22, 1], "end": [26, 63], "kind": "commanddeclaration"}, {"full_name": "exists_compact_superset", "code": "theorem exists_compact_superset [WeaklyLocallyCompactSpace X] {K : Set X} (hK : IsCompact K) :\n    \u2203 K', IsCompact K' \u2227 K \u2286 interior K'", "start": [48, 1], "end": [55, 92], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_cocompact", "code": "theorem disjoint_nhds_cocompact [WeaklyLocallyCompactSpace X] (x : X) :\n    Disjoint (\ud835\udcdd x) (cocompact X)", "start": [58, 1], "end": [63, 77], "kind": "commanddeclaration"}, {"full_name": "LocallyCompactSpace", "code": "class LocallyCompactSpace (X : Type*) [TopologicalSpace X] : Prop where\n  \n  local_compact_nhds : \u2200 (x : X), \u2200 n \u2208 \ud835\udcdd x, \u2203 s \u2208 \ud835\udcdd x, s \u2286 n \u2227 IsCompact s", "start": [65, 1], "end": [76, 76], "kind": "commanddeclaration"}, {"full_name": "compact_basis_nhds", "code": "theorem compact_basis_nhds [LocallyCompactSpace X] (x : X) :\n    (\ud835\udcdd x).HasBasis (fun s => s \u2208 \ud835\udcdd x \u2227 IsCompact s) fun s => s", "start": [79, 1], "end": [81, 93], "kind": "commanddeclaration"}, {"full_name": "local_compact_nhds", "code": "theorem local_compact_nhds [LocallyCompactSpace X] {x : X} {n : Set X} (h : n \u2208 \ud835\udcdd x) :\n    \u2203 s \u2208 \ud835\udcdd x, s \u2286 n \u2227 IsCompact s", "start": [84, 1], "end": [86, 47], "kind": "commanddeclaration"}, {"full_name": "locallyCompactSpace_of_hasBasis", "code": "theorem locallyCompactSpace_of_hasBasis {\u03b9 : X \u2192 Type*} {p : \u2200 x, \u03b9 x \u2192 Prop}\n    {s : \u2200 x, \u03b9 x \u2192 Set X} (h : \u2200 x, (\ud835\udcdd x).HasBasis (p x) (s x))\n    (hc : \u2200 x i, p x i \u2192 IsCompact (s x i)) : LocallyCompactSpace X", "start": [89, 1], "end": [94, 49], "kind": "commanddeclaration"}, {"full_name": "Prod.locallyCompactSpace", "code": "instance Prod.locallyCompactSpace (X : Type*) (Y : Type*) [TopologicalSpace X]\n    [TopologicalSpace Y] [LocallyCompactSpace X] [LocallyCompactSpace Y] :\n    LocallyCompactSpace (X \u00d7 Y) :=\n  have := fun x : X \u00d7 Y => (compact_basis_nhds x.1).prod_nhds' (compact_basis_nhds x.2)\n  locallyCompactSpace_of_hasBasis this fun _ _ \u27e8\u27e8_, h\u2081\u27e9, _, h\u2082\u27e9 => h\u2081.prod h\u2082", "start": [97, 1], "end": [101, 78], "kind": "commanddeclaration"}, {"full_name": "Pi.locallyCompactSpace_of_finite", "code": "instance Pi.locallyCompactSpace_of_finite [Finite \u03b9] : LocallyCompactSpace (\u2200 i, X i) :=\n  \u27e8fun t n hn => by\n    rw [nhds_pi, Filter.mem_pi] at hn\n    obtain \u27e8s, -, n', hn', hsub\u27e9 := hn\n    choose n'' hn'' hsub' hc using fun i =>\n      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)\n    refine' \u27e8(Set.univ : Set \u03b9).pi n'', _, subset_trans (fun _ h => _) hsub, isCompact_univ_pi hc\u27e9\n    \u00b7 exact (set_pi_mem_nhds_iff (@Set.finite_univ \u03b9 _) _).mpr fun i _ => hn'' i\n    \u00b7 exact fun i _ => hsub' i (h i trivial)\u27e9", "start": [108, 1], "end": [118, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.locallyCompactSpace", "code": "instance Pi.locallyCompactSpace [\u2200 i, CompactSpace (X i)] : LocallyCompactSpace (\u2200 i, X i) :=\n  \u27e8fun t n hn => by\n    rw [nhds_pi, Filter.mem_pi] at hn\n    obtain \u27e8s, hs, n', hn', hsub\u27e9 := hn\n    choose n'' hn'' hsub' hc using fun i =>\n      LocallyCompactSpace.local_compact_nhds (t i) (n' i) (hn' i)\n    refine' \u27e8s.pi n'', _, subset_trans (fun _ => _) hsub, _\u27e9\n    \u00b7 exact (set_pi_mem_nhds_iff hs _).mpr fun i _ => hn'' i\n    \u00b7 exact forall\u2082_imp fun i _ hi' => hsub' i hi'\n    \u00b7 rw [\u2190 Set.univ_pi_ite]\n      refine' isCompact_univ_pi fun i => _\n      by_cases h : i \u2208 s\n      \u00b7 rw [if_pos h]\n        exact hc i\n      \u00b7 rw [if_neg h]\n        exact CompactSpace.isCompact_univ\u27e9", "start": [121, 1], "end": [137, 43], "kind": "commanddeclaration"}, {"full_name": "Function.locallyCompactSpace_of_finite", "code": "instance Function.locallyCompactSpace_of_finite [Finite \u03b9] [LocallyCompactSpace Y] :\n    LocallyCompactSpace (\u03b9 \u2192 Y) :=\n  Pi.locallyCompactSpace_of_finite", "start": [140, 1], "end": [142, 35], "kind": "commanddeclaration"}, {"full_name": "Function.locallyCompactSpace", "code": "instance Function.locallyCompactSpace [LocallyCompactSpace Y] [CompactSpace Y] :\n    LocallyCompactSpace (\u03b9 \u2192 Y) :=\n  Pi.locallyCompactSpace", "start": [145, 1], "end": [147, 25], "kind": "commanddeclaration"}, {"full_name": "exists_compact_subset", "code": "theorem exists_compact_subset [LocallyCompactSpace X] {x : X} {U : Set X} (hU : IsOpen U)\n    (hx : x \u2208 U) : \u2203 K : Set X, IsCompact K \u2227 x \u2208 interior K \u2227 K \u2286 U", "start": [152, 1], "end": [157, 55], "kind": "commanddeclaration"}, {"full_name": "exists_compact_between", "code": "theorem exists_compact_between [hX : LocallyCompactSpace X] {K U : Set X} (hK : IsCompact K)\n    (hU : IsOpen U) (h_KU : K \u2286 U) : \u2203 L, IsCompact L \u2227 K \u2286 interior L \u2227 L \u2286 U", "start": [165, 1], "end": [176, 48], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.locallyCompactSpace", "code": "protected theorem ClosedEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X \u2192 Y}\n    (hf : ClosedEmbedding f) : LocallyCompactSpace X", "start": [179, 1], "end": [185, 80], "kind": "commanddeclaration"}, {"full_name": "IsClosed.locallyCompactSpace", "code": "protected theorem IsClosed.locallyCompactSpace [LocallyCompactSpace X] {s : Set X}\n    (hs : IsClosed s) : LocallyCompactSpace s", "start": [188, 1], "end": [190, 55], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.locallyCompactSpace", "code": "protected theorem OpenEmbedding.locallyCompactSpace [LocallyCompactSpace Y] {f : X \u2192 Y}\n    (hf : OpenEmbedding f) : LocallyCompactSpace X", "start": [193, 1], "end": [203, 15], "kind": "commanddeclaration"}, {"full_name": "IsOpen.locallyCompactSpace", "code": "protected theorem IsOpen.locallyCompactSpace [LocallyCompactSpace X] {s : Set X} (hs : IsOpen s) :\n    LocallyCompactSpace s", "start": [206, 1], "end": [208, 51], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.le_nhds_lim", "code": "nonrec theorem Ultrafilter.le_nhds_lim [CompactSpace X] (F : Ultrafilter X) : \u2191F \u2264 \ud835\udcdd F.lim", "start": [211, 1], "end": [213, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CompactlyGenerated.lean", "imports": ["Mathlib/Data/Finite/Set.lean", "Mathlib/Order/SupIndep.lean", "Mathlib/Order/Atoms.lean", "Mathlib/Data/Set/Intervals/OrderIso.lean", "Mathlib/Order/SupClosed.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Order/RelIso/Set.lean", "Mathlib/Order/OrderIsoNat.lean", "Mathlib/Order/Zorn.lean", "Mathlib/Data/Finset/Order.lean"], "premises": [{"full_name": "CompleteLattice.IsSupClosedCompact", "code": "def IsSupClosedCompact : Prop :=\n  \u2200 (s : Set \u03b1) (_ : s.Nonempty), SupClosed s \u2192 sSup s \u2208 s", "start": [62, 1], "end": [65, 59], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsSupFiniteCompact", "code": "def IsSupFiniteCompact : Prop :=\n  \u2200 s : Set \u03b1, \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 sSup s = t.sup id", "start": [68, 1], "end": [71, 58], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsCompactElement", "code": "def IsCompactElement {\u03b1 : Type*} [CompleteLattice \u03b1] (k : \u03b1) :=\n  \u2200 s : Set \u03b1, k \u2264 sSup s \u2192 \u2203 t : Finset \u03b1, \u2191t \u2286 s \u2227 k \u2264 t.sup id", "start": [74, 1], "end": [78, 66], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isCompactElement_iff", "code": "theorem isCompactElement_iff.{u} {\u03b1 : Type u} [CompleteLattice \u03b1] (k : \u03b1) :\n    CompleteLattice.IsCompactElement k \u2194\n      \u2200 (\u03b9 : Type u) (s : \u03b9 \u2192 \u03b1), k \u2264 iSup s \u2192 \u2203 t : Finset \u03b9, k \u2264 t.sup s", "start": [81, 1], "end": [103, 95], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isCompactElement_iff_le_of_directed_sSup_le", "code": "theorem isCompactElement_iff_le_of_directed_sSup_le (k : \u03b1) :\n    IsCompactElement k \u2194\n      \u2200 s : Set \u03b1, s.Nonempty \u2192 DirectedOn (\u00b7 \u2264 \u00b7) s \u2192 k \u2264 sSup s \u2192 \u2203 x : \u03b1, x \u2208 s \u2227 k \u2264 x", "start": [106, 1], "end": [148, 36], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsCompactElement.exists_finset_of_le_iSup", "code": "theorem IsCompactElement.exists_finset_of_le_iSup {k : \u03b1} (hk : IsCompactElement k) {\u03b9 : Type*}\n    (f : \u03b9 \u2192 \u03b1) (h : k \u2264 \u2a06 i, f i) : \u2203 s : Finset \u03b9, k \u2264 \u2a06 i \u2208 s, f i", "start": [151, 1], "end": [168, 18], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsCompactElement.directed_sSup_lt_of_lt", "code": "theorem IsCompactElement.directed_sSup_lt_of_lt {\u03b1 : Type*} [CompleteLattice \u03b1] {k : \u03b1}\n    (hk : IsCompactElement k) {s : Set \u03b1} (hemp : s.Nonempty) (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s)\n    (hbelow : \u2200 x \u2208 s, x < k) : sSup s < k", "start": [171, 1], "end": [182, 37], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.finset_sup_compact_of_compact", "code": "theorem finset_sup_compact_of_compact {\u03b1 \u03b2 : Type*} [CompleteLattice \u03b1] {f : \u03b2 \u2192 \u03b1} (s : Finset \u03b2)\n    (h : \u2200 x \u2208 s, IsCompactElement (f x)) : IsCompactElement (s.sup f)", "start": [185, 1], "end": [198, 29], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.WellFounded.isSupFiniteCompact", "code": "theorem WellFounded.isSupFiniteCompact (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) :\n    IsSupFiniteCompact \u03b1", "start": [201, 1], "end": [211, 27], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsSupFiniteCompact.isSupClosedCompact", "code": "theorem IsSupFiniteCompact.isSupClosedCompact (h : IsSupFiniteCompact \u03b1) :\n    IsSupClosedCompact \u03b1", "start": [214, 1], "end": [223, 34], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsSupClosedCompact.wellFounded", "code": "theorem IsSupClosedCompact.wellFounded (h : IsSupClosedCompact \u03b1) :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [226, 1], "end": [244, 32], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isSupFiniteCompact_iff_all_elements_compact", "code": "theorem isSupFiniteCompact_iff_all_elements_compact :\n    IsSupFiniteCompact \u03b1 \u2194 \u2200 k : \u03b1, IsCompactElement k", "start": [247, 1], "end": [259, 25], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.wellFounded_characterisations", "code": "theorem wellFounded_characterisations : List.TFAE\n    [WellFounded (( \u00b7 > \u00b7 ) : \u03b1 \u2192 \u03b1 \u2192 Prop),\n      IsSupFiniteCompact \u03b1, IsSupClosedCompact \u03b1, \u2200 k : \u03b1, IsCompactElement k]", "start": [263, 1], "end": [274, 14], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.wellFounded_iff_isSupFiniteCompact", "code": "theorem wellFounded_iff_isSupFiniteCompact :\n    WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop) \u2194 IsSupFiniteCompact \u03b1", "start": [277, 1], "end": [279, 44], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isSupFiniteCompact_iff_isSupClosedCompact", "code": "theorem isSupFiniteCompact_iff_isSupClosedCompact : IsSupFiniteCompact \u03b1 \u2194 IsSupClosedCompact \u03b1", "start": [282, 1], "end": [283, 44], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isSupClosedCompact_iff_wellFounded", "code": "theorem isSupClosedCompact_iff_wellFounded :\n    IsSupClosedCompact \u03b1 \u2194 WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)", "start": [286, 1], "end": [288, 44], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.IsSupFiniteCompact.wellFounded", "code": "alias \u27e8_, IsSupFiniteCompact.wellFounded\u27e9 := wellFounded_iff_isSupFiniteCompact", "start": [291, 1], "end": [291, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "CompleteLattice.IsSupClosedCompact.isSupFiniteCompact", "code": "alias \u27e8_, IsSupClosedCompact.isSupFiniteCompact\u27e9 := isSupFiniteCompact_iff_isSupClosedCompact", "start": [294, 1], "end": [294, 94], "kind": "stdtacticaliasaliaslr"}, {"full_name": "WellFounded.isSupClosedCompact", "code": "alias \u27e8_, _root_.WellFounded.isSupClosedCompact\u27e9 := isSupClosedCompact_iff_wellFounded", "start": [297, 1], "end": [297, 87], "kind": "stdtacticaliasaliaslr"}, {"full_name": "CompleteLattice.WellFounded.finite_of_setIndependent", "code": "theorem WellFounded.finite_of_setIndependent (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) {s : Set \u03b1}\n    (hs : SetIndependent s) : s.Finite", "start": [302, 1], "end": [317, 26], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.WellFounded.finite_of_independent", "code": "theorem WellFounded.finite_of_independent (hwf : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) {\u03b9 : Type*}\n    {t : \u03b9 \u2192 \u03b1} (ht : Independent t) (h_ne_bot : \u2200 i, t i \u2260 \u22a5) : Finite \u03b9", "start": [320, 1], "end": [323, 59], "kind": "commanddeclaration"}, {"full_name": "IsCompactlyGenerated", "code": "class IsCompactlyGenerated (\u03b1 : Type*) [CompleteLattice \u03b1] : Prop where\n  \n  exists_sSup_eq : \u2200 x : \u03b1, \u2203 s : Set \u03b1, (\u2200 x \u2208 s, CompleteLattice.IsCompactElement x) \u2227 sSup s = x", "start": [328, 1], "end": [333, 100], "kind": "commanddeclaration"}, {"full_name": "sSup_compact_le_eq", "code": "@[simp]\ntheorem sSup_compact_le_eq (b) :\n    sSup { c : \u03b1 | CompleteLattice.IsCompactElement c \u2227 c \u2264 b } = b", "start": [340, 1], "end": [344, 96], "kind": "commanddeclaration"}, {"full_name": "sSup_compact_eq_top", "code": "@[simp]\ntheorem sSup_compact_eq_top : sSup { a : \u03b1 | CompleteLattice.IsCompactElement a } = \u22a4", "start": [347, 1], "end": [350, 35], "kind": "commanddeclaration"}, {"full_name": "le_iff_compact_le_imp", "code": "theorem le_iff_compact_le_imp {a b : \u03b1} :\n    a \u2264 b \u2194 \u2200 c : \u03b1, CompleteLattice.IsCompactElement c \u2192 c \u2264 a \u2192 c \u2264 b", "start": [353, 1], "end": [357, 58], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.inf_sSup_eq", "code": "theorem DirectedOn.inf_sSup_eq (h : DirectedOn (\u00b7 \u2264 \u00b7) s) : a \u2293 sSup s = \u2a06 b \u2208 s, a \u2293 b", "start": [360, 1], "end": [374, 25], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.sSup_inf_eq", "code": "protected theorem DirectedOn.sSup_inf_eq (h : DirectedOn (\u00b7 \u2264 \u00b7) s) : sSup s \u2293 a = \u2a06 b \u2208 s, b \u2293 a", "start": [377, 1], "end": [379, 48], "kind": "commanddeclaration"}, {"full_name": "Directed.inf_iSup_eq", "code": "protected theorem Directed.inf_iSup_eq (h : Directed (\u00b7 \u2264 \u00b7) f) : (a \u2293 \u2a06 i, f i) = \u2a06 i, a \u2293 f i", "start": [382, 1], "end": [383, 59], "kind": "commanddeclaration"}, {"full_name": "Directed.iSup_inf_eq", "code": "protected theorem Directed.iSup_inf_eq (h : Directed (\u00b7 \u2264 \u00b7) f) : (\u2a06 i, f i) \u2293 a = \u2a06 i, f i \u2293 a", "start": [386, 1], "end": [387, 59], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.disjoint_sSup_right", "code": "protected theorem DirectedOn.disjoint_sSup_right (h : DirectedOn (\u00b7 \u2264 \u00b7) s) :\n    Disjoint a (sSup s) \u2194 \u2200 \u2983b\u2984, b \u2208 s \u2192 Disjoint a b", "start": [390, 1], "end": [392, 53], "kind": "commanddeclaration"}, {"full_name": "DirectedOn.disjoint_sSup_left", "code": "protected theorem DirectedOn.disjoint_sSup_left (h : DirectedOn (\u00b7 \u2264 \u00b7) s) :\n    Disjoint (sSup s) a \u2194 \u2200 \u2983b\u2984, b \u2208 s \u2192 Disjoint b a", "start": [395, 1], "end": [397, 53], "kind": "commanddeclaration"}, {"full_name": "Directed.disjoint_iSup_right", "code": "protected theorem Directed.disjoint_iSup_right (h : Directed (\u00b7 \u2264 \u00b7) f) :\n    Disjoint a (\u2a06 i, f i) \u2194 \u2200 i, Disjoint a (f i)", "start": [400, 1], "end": [402, 53], "kind": "commanddeclaration"}, {"full_name": "Directed.disjoint_iSup_left", "code": "protected theorem Directed.disjoint_iSup_left (h : Directed (\u00b7 \u2264 \u00b7) f) :\n    Disjoint (\u2a06 i, f i) a \u2194 \u2200 i, Disjoint (f i) a", "start": [405, 1], "end": [407, 53], "kind": "commanddeclaration"}, {"full_name": "inf_sSup_eq_iSup_inf_sup_finset", "code": "theorem inf_sSup_eq_iSup_inf_sup_finset :\n    a \u2293 sSup s = \u2a06 (t : Finset \u03b1) (_ : \u2191t \u2286 s), a \u2293 t.sup id", "start": [410, 1], "end": [422, 92], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.setIndependent_iff_finite", "code": "theorem CompleteLattice.setIndependent_iff_finite {s : Set \u03b1} :\n    CompleteLattice.SetIndependent s \u2194\n      \u2200 t : Finset \u03b1, \u2191t \u2286 s \u2192 CompleteLattice.SetIndependent (\u2191t : Set \u03b1)", "start": [425, 1], "end": [438, 63], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.setIndependent_iUnion_of_directed", "code": "theorem CompleteLattice.setIndependent_iUnion_of_directed {\u03b7 : Type*} {s : \u03b7 \u2192 Set \u03b1}\n    (hs : Directed (\u00b7 \u2286 \u00b7) s) (h : \u2200 i, CompleteLattice.SetIndependent (s i)) :\n    CompleteLattice.SetIndependent (\u22c3 i, s i)", "start": [441, 1], "end": [453, 17], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_sUnion_of_directed", "code": "theorem CompleteLattice.independent_sUnion_of_directed {s : Set (Set \u03b1)} (hs : DirectedOn (\u00b7 \u2286 \u00b7) s)\n    (h : \u2200 a \u2208 s, CompleteLattice.SetIndependent a) : CompleteLattice.SetIndependent (\u22c3\u2080 s)", "start": [456, 1], "end": [459, 93], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.isCompactlyGenerated_of_wellFounded", "code": "theorem isCompactlyGenerated_of_wellFounded (h : WellFounded ((\u00b7 > \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)) :\n    IsCompactlyGenerated \u03b1", "start": [466, 1], "end": [470, 59], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Iic_coatomic_of_compact_element", "code": "theorem Iic_coatomic_of_compact_element {k : \u03b1} (h : IsCompactElement k) :\n    IsCoatomic (Set.Iic k)", "start": [473, 1], "end": [493, 48], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.coatomic_of_top_compact", "code": "theorem coatomic_of_top_compact (h : IsCompactElement (\u22a4 : \u03b1)) : IsCoatomic \u03b1", "start": [496, 1], "end": [497, 81], "kind": "commanddeclaration"}, {"full_name": "isAtomic_of_complementedLattice", "code": "instance (priority := 100) isAtomic_of_complementedLattice [ComplementedLattice \u03b1] : IsAtomic \u03b1 :=\n  \u27e8fun b => by\n    by_cases h : { c : \u03b1 | CompleteLattice.IsCompactElement c \u2227 c \u2264 b } \u2286 {\u22a5}\n    \u00b7 left\n      rw [\u2190 sSup_compact_le_eq b, sSup_eq_bot]\n      exact h\n    \u00b7 rcases Set.not_subset.1 h with \u27e8c, \u27e8hc, hcb\u27e9, hcbot\u27e9\n      right\n      have hc' := CompleteLattice.Iic_coatomic_of_compact_element hc\n      rw [\u2190 isAtomic_iff_isCoatomic] at hc'\n      haveI := hc'\n      obtain con | \u27e8a, ha, hac\u27e9 := eq_bot_or_exists_atom_le (\u27e8c, le_refl c\u27e9 : Set.Iic c)\n      \u00b7 exfalso\n        apply hcbot\n        simp only [Subtype.ext_iff, Set.Iic.coe_bot, Subtype.coe_mk] at con\n        exact con\n      rw [\u2190 Subtype.coe_le_coe, Subtype.coe_mk] at hac\n      exact \u27e8a, ha.of_isAtom_coe_Iic, hac.trans hcb\u27e9\u27e9", "start": [506, 1], "end": [523, 54], "kind": "commanddeclaration"}, {"full_name": "isAtomistic_of_complementedLattice", "code": "instance (priority := 100) isAtomistic_of_complementedLattice [ComplementedLattice \u03b1] :\n    IsAtomistic \u03b1 :=\n  \u27e8fun b =>\n    \u27e8{ a | IsAtom a \u2227 a \u2264 b }, by\n      symm\n      have hle : sSup { a : \u03b1 | IsAtom a \u2227 a \u2264 b } \u2264 b := sSup_le fun _ => And.right\n      apply (lt_or_eq_of_le hle).resolve_left _\n      intro con\n      obtain \u27e8c, hc\u27e9 := exists_isCompl (\u27e8sSup { a : \u03b1 | IsAtom a \u2227 a \u2264 b }, hle\u27e9 : Set.Iic b)\n      obtain rfl | \u27e8a, ha, hac\u27e9 := eq_bot_or_exists_atom_le c\n      \u00b7 exact ne_of_lt con (Subtype.ext_iff.1 (eq_top_of_isCompl_bot hc))\n      \u00b7 apply ha.1\n        rw [eq_bot_iff]\n        apply le_trans (le_inf _ hac) hc.disjoint.le_bot\n        rw [\u2190 Subtype.coe_le_coe, Subtype.coe_mk]\n        exact le_sSup \u27e8ha.of_isAtom_coe_Iic, a.2\u27e9, fun _ => And.left\u27e9\u27e9", "start": [526, 1], "end": [542, 71], "kind": "commanddeclaration"}, {"full_name": "exists_setIndependent_isCompl_sSup_atoms", "code": "theorem exists_setIndependent_isCompl_sSup_atoms (h : sSup { a : \u03b1 | IsAtom a } = \u22a4) (b : \u03b1) :\n    \u2203 s : Set \u03b1, CompleteLattice.SetIndependent s \u2227\n    IsCompl b (sSup s) \u2227 \u2200 \u2983a\u2984, a \u2208 s \u2192 IsAtom a", "start": [550, 1], "end": [604, 15], "kind": "commanddeclaration"}, {"full_name": "exists_setIndependent_of_sSup_atoms_eq_top", "code": "theorem exists_setIndependent_of_sSup_atoms_eq_top (h : sSup { a : \u03b1 | IsAtom a } = \u22a4) :\n    \u2203 s : Set \u03b1, CompleteLattice.SetIndependent s \u2227 sSup s = \u22a4 \u2227 \u2200 \u2983a\u2984, a \u2208 s \u2192 IsAtom a", "start": [607, 1], "end": [610, 56], "kind": "commanddeclaration"}, {"full_name": "complementedLattice_of_sSup_atoms_eq_top", "code": "theorem complementedLattice_of_sSup_atoms_eq_top (h : sSup { a : \u03b1 | IsAtom a } = \u22a4) :\n    ComplementedLattice \u03b1", "start": [613, 1], "end": [618, 21], "kind": "commanddeclaration"}, {"full_name": "complementedLattice_of_isAtomistic", "code": "theorem complementedLattice_of_isAtomistic [IsAtomistic \u03b1] : ComplementedLattice \u03b1", "start": [621, 1], "end": [623, 61], "kind": "commanddeclaration"}, {"full_name": "complementedLattice_iff_isAtomistic", "code": "theorem complementedLattice_iff_isAtomistic : ComplementedLattice \u03b1 \u2194 IsAtomistic \u03b1", "start": [626, 1], "end": [629, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Ring.lean", "imports": ["Mathlib/Tactic/Ring/RingNF.lean", "Mathlib/Tactic/Ring/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Order/OmegaCompletePartialOrder.lean", "imports": ["Mathlib/Control/Monad/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Part.lean", "Mathlib/Data/Nat/Order/Basic.lean", "Mathlib/Order/Chain.lean", "Mathlib/Order/Hom/Order.lean"], "premises": [{"full_name": "OrderHom.bind", "code": "@[simps]\ndef bind {\u03b2 \u03b3} (f : \u03b1 \u2192o Part \u03b2) (g : \u03b1 \u2192o \u03b2 \u2192 Part \u03b3) : \u03b1 \u2192o Part \u03b3 where\n  toFun x := f x >>= g x\n  monotone' := by\n    intro x y h a\n    simp only [and_imp, exists_prop, Part.bind_eq_bind, Part.mem_bind_iff, exists_imp]\n    intro b hb ha\n    refine' \u27e8b, f.monotone h _ hb, g.monotone h _ _ ha\u27e9", "start": [70, 1], "end": [78, 56], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain", "code": "def Chain (\u03b1 : Type u) [Preorder \u03b1] :=\n  \u2115 \u2192o \u03b1", "start": [86, 1], "end": [90, 9], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.isChain_range", "code": "lemma isChain_range : IsChain (\u00b7 \u2264 \u00b7) (Set.range c) := Monotone.isChain_range (OrderHomClass.mono c)", "start": [113, 1], "end": [113, 101], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.Chain.directed", "code": "lemma directed : Directed (\u00b7 \u2264 \u00b7) c := directedOn_range.2 c.isChain_range.directedOn", "start": [115, 1], "end": [115, 85], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.Chain.map", "code": "def map : Chain \u03b2 :=\n  f.comp c", "start": [117, 1], "end": [121, 11], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.map_coe", "code": "@[simp] theorem map_coe : \u21d1(map c f) = f \u2218 c", "start": [124, 1], "end": [124, 52], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.mem_map", "code": "theorem mem_map (x : \u03b1) : x \u2208 c \u2192 f x \u2208 Chain.map c f", "start": [129, 1], "end": [130, 34], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.exists_of_mem_map", "code": "theorem exists_of_mem_map {b : \u03b2} : b \u2208 c.map f \u2192 \u2203 a, a \u2208 c \u2227 f a = b", "start": [133, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.mem_map_iff", "code": "@[simp]\ntheorem mem_map_iff {b : \u03b2} : b \u2208 c.map f \u2194 \u2203 a, a \u2208 c \u2227 f a = b", "start": [137, 1], "end": [142, 25], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.map_id", "code": "@[simp]\ntheorem map_id : c.map OrderHom.id = c", "start": [145, 1], "end": [147, 21], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.map_comp", "code": "theorem map_comp : (c.map f).map g = c.map (g.comp f)", "start": [150, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.map_le_map", "code": "@[mono]\ntheorem map_le_map {g : \u03b1 \u2192o \u03b2} (h : f \u2264 g) : c.map f \u2264 c.map g", "start": [154, 1], "end": [156, 60], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.zip", "code": "def zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : Chain (\u03b1 \u00d7 \u03b2) :=\n  OrderHom.prod c\u2080 c\u2081", "start": [159, 1], "end": [164, 22], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Chain.zip_coe", "code": "@[simp] theorem zip_coe (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) (n : \u2115) : c\u2080.zip c\u2081 n = (c\u2080 n, c\u2081 n)", "start": [167, 1], "end": [167, 98], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder", "code": "class OmegaCompletePartialOrder (\u03b1 : Type*) extends PartialOrder \u03b1 where\n  \n  \u03c9Sup : Chain \u03b1 \u2192 \u03b1\n  \n  le_\u03c9Sup : \u2200 c : Chain \u03b1, \u2200 i, c i \u2264 \u03c9Sup c\n  \n  \u03c9Sup_le : \u2200 (c : Chain \u03b1) (x), (\u2200 i, c i \u2264 x) \u2192 \u03c9Sup c \u2264 x", "start": [178, 1], "end": [190, 61], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.lift", "code": "@[reducible]\nprotected def lift [PartialOrder \u03b2] (f : \u03b2 \u2192o \u03b1) (\u03c9Sup\u2080 : Chain \u03b2 \u2192 \u03b2)\n    (h : \u2200 x y, f x \u2264 f y \u2192 x \u2264 y) (h' : \u2200 c, f (\u03c9Sup\u2080 c) = \u03c9Sup (c.map f)) :\n    OmegaCompletePartialOrder \u03b2 where\n  \u03c9Sup := \u03c9Sup\u2080\n  \u03c9Sup_le c x hx := h _ _ (by rw [h']; apply \u03c9Sup_le; intro i; apply f.monotone (hx i))\n  le_\u03c9Sup c i := h _ _ (by rw [h']; apply le_\u03c9Sup (c.map f))", "start": [199, 1], "end": [208, 61], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.le_\u03c9Sup_of_le", "code": "theorem le_\u03c9Sup_of_le {c : Chain \u03b1} {x : \u03b1} (i : \u2115) (h : x \u2264 c i) : x \u2264 \u03c9Sup c", "start": [211, 1], "end": [212, 27], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.\u03c9Sup_total", "code": "theorem \u03c9Sup_total {c : Chain \u03b1} {x : \u03b1} (h : \u2200 i, c i \u2264 x \u2228 x \u2264 c i) : \u03c9Sup c \u2264 x \u2228 x \u2264 \u03c9Sup c", "start": [215, 1], "end": [222, 38], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.\u03c9Sup_le_\u03c9Sup_of_le", "code": "@[mono]\ntheorem \u03c9Sup_le_\u03c9Sup_of_le {c\u2080 c\u2081 : Chain \u03b1} (h : c\u2080 \u2264 c\u2081) : \u03c9Sup c\u2080 \u2264 \u03c9Sup c\u2081", "start": [225, 1], "end": [229, 35], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.\u03c9Sup_le_iff", "code": "theorem \u03c9Sup_le_iff (c : Chain \u03b1) (x : \u03b1) : \u03c9Sup c \u2264 x \u2194 \u2200 i, c i \u2264 x", "start": [232, 1], "end": [237, 24], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.isLUB_range_\u03c9Sup", "code": "lemma isLUB_range_\u03c9Sup (c : Chain \u03b1) : IsLUB (Set.range c) (\u03c9Sup c) := by\n  constructor\n  \u00b7 simp only [upperBounds, Set.mem_range, forall_exists_index, forall_apply_eq_imp_iff,\n      Set.mem_setOf_eq]\n    exact fun a \u21a6 le_\u03c9Sup c a\n  \u00b7 simp only [lowerBounds, upperBounds, Set.mem_range, forall_exists_index,\n      forall_apply_eq_imp_iff, Set.mem_setOf_eq]\n    exact fun \u2983a\u2984 a_1 \u21a6 \u03c9Sup_le c a a_1", "start": [240, 1], "end": [247, 40], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.\u03c9Sup_eq_of_isLUB", "code": "lemma \u03c9Sup_eq_of_isLUB {c : Chain \u03b1} {a : \u03b1} (h : IsLUB (Set.range c) a) : a = \u03c9Sup c := by\n  rw [le_antisymm_iff]\n  simp only [IsLUB, IsLeast, upperBounds, lowerBounds, Set.mem_range, forall_exists_index,\n    forall_apply_eq_imp_iff, Set.mem_setOf_eq] at h\n  constructor\n  \u00b7 apply h.2\n    exact fun a \u21a6 le_\u03c9Sup c a\n  \u00b7 rw [\u03c9Sup_le_iff]\n    apply h.1", "start": [249, 1], "end": [257, 14], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.subtype", "code": "def subtype {\u03b1 : Type*} [OmegaCompletePartialOrder \u03b1] (p : \u03b1 \u2192 Prop)\n    (hp : \u2200 c : Chain \u03b1, (\u2200 i \u2208 c, p i) \u2192 p (\u03c9Sup c)) : OmegaCompletePartialOrder (Subtype p) :=\n  OmegaCompletePartialOrder.lift (OrderHom.Subtype.val p)\n    (fun c => \u27e8\u03c9Sup _, hp (c.map (OrderHom.Subtype.val p)) fun _ \u27e8n, q\u27e9 => q.symm \u25b8 (c n).2\u27e9)\n    (fun _ _ h => h) (fun _ => rfl)", "start": [259, 1], "end": [265, 36], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Continuous", "code": "def Continuous (f : \u03b1 \u2192o \u03b2) : Prop :=\n  \u2200 c : Chain \u03b1, f (\u03c9Sup c) = \u03c9Sup (c.map f)", "start": [275, 1], "end": [282, 45], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Continuous'", "code": "def Continuous' (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2203 hf : Monotone f, Continuous \u27e8f, hf\u27e9", "start": [285, 1], "end": [287, 40], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.isLUB_of_scottContinuous", "code": "lemma isLUB_of_scottContinuous {c : Chain \u03b1} {f : \u03b1 \u2192 \u03b2} (hf : ScottContinuous f) :\n    IsLUB (Set.range (Chain.map c \u27e8f, (ScottContinuous.monotone hf)\u27e9)) (f (\u03c9Sup c)) := by\n  simp only [map_coe, OrderHom.coe_mk]\n  rw [(Set.range_comp f \u2191c)]\n  exact hf (Set.range_nonempty \u2191c) (IsChain.directedOn (isChain_range c)) (isLUB_range_\u03c9Sup c)", "start": [290, 1], "end": [294, 95], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.ScottContinuous.continuous'", "code": "lemma ScottContinuous.continuous' {f : \u03b1 \u2192 \u03b2} (hf : ScottContinuous f) : Continuous' f := by\n  constructor\n  intro c\n  rw [\u2190 (\u03c9Sup_eq_of_isLUB (isLUB_of_scottContinuous hf))]\n  simp only [OrderHom.coe_mk]", "start": [296, 1], "end": [300, 30], "kind": "mathlibtacticlemma"}, {"full_name": "OmegaCompletePartialOrder.Continuous'.to_monotone", "code": "theorem Continuous'.to_monotone {f : \u03b1 \u2192 \u03b2} (hf : Continuous' f) : Monotone f", "start": [302, 1], "end": [303, 9], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Continuous.of_bundled", "code": "theorem Continuous.of_bundled (f : \u03b1 \u2192 \u03b2) (hf : Monotone f) (hf' : Continuous \u27e8f, hf\u27e9) :\n    Continuous' f", "start": [306, 1], "end": [308, 12], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Continuous.of_bundled'", "code": "theorem Continuous.of_bundled' (f : \u03b1 \u2192o \u03b2) (hf' : Continuous f) : Continuous' f", "start": [311, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.Continuous'.to_bundled", "code": "theorem Continuous'.to_bundled (f : \u03b1 \u2192 \u03b2) (hf : Continuous' f) : Continuous \u27e8f, hf.to_monotone\u27e9", "start": [315, 1], "end": [316, 9], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.continuous'_coe", "code": "@[simp, norm_cast]\ntheorem continuous'_coe : \u2200 {f : \u03b1 \u2192o \u03b2}, Continuous' f \u2194 Continuous f", "start": [319, 1], "end": [321, 55], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.continuous_id", "code": "theorem continuous_id : Continuous (@OrderHom.id \u03b1 _)", "start": [326, 1], "end": [326, 88], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.continuous_comp", "code": "theorem continuous_comp (hfc : Continuous f) (hgc : Continuous g) : Continuous (g.comp f)", "start": [329, 1], "end": [331, 32], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.id_continuous'", "code": "theorem id_continuous' : Continuous' (@id \u03b1)", "start": [334, 1], "end": [335, 30], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.continuous_const", "code": "theorem continuous_const (x : \u03b2) : Continuous (OrderHom.const \u03b1 x)", "start": [338, 1], "end": [339, 96], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.const_continuous'", "code": "theorem const_continuous' (x : \u03b2) : Continuous' (Function.const \u03b1 x)", "start": [342, 1], "end": [343, 67], "kind": "commanddeclaration"}, {"full_name": "Part.eq_of_chain", "code": "theorem eq_of_chain {c : Chain (Part \u03b1)} {a b : \u03b1} (ha : some a \u2208 c) (hb : some b \u2208 c) : a = b", "start": [356, 1], "end": [362, 73], "kind": "commanddeclaration"}, {"full_name": "Part.\u03c9Sup", "code": "protected noncomputable def \u03c9Sup (c : Chain (Part \u03b1)) : Part \u03b1 :=\n  if h : \u2203 a, some a \u2208 c then some (Classical.choose h) else none", "start": [369, 1], "end": [371, 66], "kind": "commanddeclaration"}, {"full_name": "Part.\u03c9Sup_eq_some", "code": "theorem \u03c9Sup_eq_some {c : Chain (Part \u03b1)} {a : \u03b1} (h : some a \u2208 c) : Part.\u03c9Sup c = some a", "start": [374, 1], "end": [379, 49], "kind": "commanddeclaration"}, {"full_name": "Part.\u03c9Sup_eq_none", "code": "theorem \u03c9Sup_eq_none {c : Chain (Part \u03b1)} (h : \u00ac\u2203 a, some a \u2208 c) : Part.\u03c9Sup c = none", "start": [382, 1], "end": [383, 12], "kind": "commanddeclaration"}, {"full_name": "Part.mem_chain_of_mem_\u03c9Sup", "code": "theorem mem_chain_of_mem_\u03c9Sup {c : Chain (Part \u03b1)} {a : \u03b1} (h : a \u2208 Part.\u03c9Sup c) : some a \u2208 c", "start": [386, 1], "end": [392, 23], "kind": "commanddeclaration"}, {"full_name": "Part.omegaCompletePartialOrder", "code": "noncomputable instance omegaCompletePartialOrder :\n    OmegaCompletePartialOrder (Part \u03b1) where\n  \u03c9Sup := Part.\u03c9Sup\n  le_\u03c9Sup c i := by\n    intro x hx\n    rw [\u2190 eq_some_iff] at hx \u22a2\n    rw [\u03c9Sup_eq_some, \u2190 hx]\n    rw [\u2190 hx]\n    exact \u27e8i, rfl\u27e9\n  \u03c9Sup_le := by\n    rintro c x hx a ha\n    replace ha := mem_chain_of_mem_\u03c9Sup ha\n    cases' ha with i ha\n    apply hx i\n    rw [\u2190 ha]\n    apply mem_some", "start": [395, 1], "end": [410, 19], "kind": "commanddeclaration"}, {"full_name": "Part.mem_\u03c9Sup", "code": "theorem mem_\u03c9Sup (x : \u03b1) (c : Chain (Part \u03b1)) : x \u2208 \u03c9Sup c \u2194 some x \u2208 c", "start": [415, 1], "end": [431, 9], "kind": "commanddeclaration"}, {"full_name": "Pi.OmegaCompletePartialOrder.flip\u2081_continuous'", "code": "theorem flip\u2081_continuous' (f : \u2200 x : \u03b1, \u03b3 \u2192 \u03b2 x) (a : \u03b1) (hf : Continuous' fun x y => f y x) :\n    Continuous' (f a)", "start": [458, 1], "end": [460, 101], "kind": "commanddeclaration"}, {"full_name": "Pi.OmegaCompletePartialOrder.flip\u2082_continuous'", "code": "theorem flip\u2082_continuous' (f : \u03b3 \u2192 \u2200 x, \u03b2 x) (hf : \u2200 x, Continuous' fun g => f g x) :\n    Continuous' f", "start": [463, 1], "end": [466, 53], "kind": "commanddeclaration"}, {"full_name": "Prod.\u03c9Sup", "code": "@[simps]\nprotected def \u03c9Sup (c : Chain (\u03b1 \u00d7 \u03b2)) : \u03b1 \u00d7 \u03b2 :=\n  (\u03c9Sup (c.map OrderHom.fst), \u03c9Sup (c.map OrderHom.snd))", "start": [482, 1], "end": [485, 57], "kind": "commanddeclaration"}, {"full_name": "Prod.\u03c9Sup_zip", "code": "theorem \u03c9Sup_zip (c\u2080 : Chain \u03b1) (c\u2081 : Chain \u03b2) : \u03c9Sup (c\u2080.zip c\u2081) = (\u03c9Sup c\u2080, \u03c9Sup c\u2081)", "start": [496, 1], "end": [498, 33], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.sSup_continuous", "code": "theorem sSup_continuous (s : Set <| \u03b1 \u2192o \u03b2) (hs : \u2200 f \u2208 s, Continuous f) : Continuous (sSup s)", "start": [520, 1], "end": [526, 61], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.iSup_continuous", "code": "theorem iSup_continuous {\u03b9 : Sort*} {f : \u03b9 \u2192 \u03b1 \u2192o \u03b2} (h : \u2200 i, Continuous (f i)) :\n    Continuous (\u2a06 i, f i)", "start": [529, 1], "end": [531, 48], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.sSup_continuous'", "code": "theorem sSup_continuous' (s : Set (\u03b1 \u2192 \u03b2)) (hc : \u2200 f \u2208 s, Continuous' f) :\n    Continuous' (sSup s)", "start": [534, 1], "end": [540, 67], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.sup_continuous", "code": "theorem sup_continuous {f g : \u03b1 \u2192o \u03b2} (hf : Continuous f) (hg : Continuous g) :\n    Continuous (f \u2294 g)", "start": [543, 1], "end": [546, 42], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.top_continuous", "code": "theorem top_continuous : Continuous (\u22a4 : \u03b1 \u2192o \u03b2)", "start": [549, 1], "end": [552, 61], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.bot_continuous", "code": "theorem bot_continuous : Continuous (\u22a5 : \u03b1 \u2192o \u03b2)", "start": [555, 1], "end": [557, 46], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.inf_continuous", "code": "theorem inf_continuous (f g : \u03b1 \u2192o \u03b2) (hf : Continuous f) (hg : Continuous g) :\n    Continuous (f \u2293 g)", "start": [566, 1], "end": [572, 53], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.inf_continuous'", "code": "theorem inf_continuous' {f g : \u03b1 \u2192 \u03b2} (hf : Continuous' f) (hg : Continuous' g) :\n    Continuous' (f \u2293 g)", "start": [575, 1], "end": [577, 40], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.OrderHom.\u03c9Sup", "code": "@[simps]\nprotected def \u03c9Sup (c : Chain (\u03b1 \u2192o \u03b2)) : \u03b1 \u2192o \u03b2 where\n  toFun a := \u03c9Sup (c.map (OrderHom.apply a))\n  monotone' _ _ h := \u03c9Sup_le_\u03c9Sup_of_le ((Chain.map_le_map _) fun a => a.monotone h)", "start": [592, 1], "end": [596, 85], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.OrderHom.omegaCompletePartialOrder", "code": "@[simps! \u03c9Sup_coe]\ninstance omegaCompletePartialOrder : OmegaCompletePartialOrder (\u03b1 \u2192o \u03b2) :=\n  OmegaCompletePartialOrder.lift OrderHom.coeFnHom OrderHom.\u03c9Sup (fun _ _ h => h) fun _ => rfl", "start": [600, 1], "end": [602, 95], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom", "code": "structure ContinuousHom extends OrderHom \u03b1 \u03b2 where\n  \n  cont : Continuous toOrderHom", "start": [612, 1], "end": [617, 31], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.toOrderHom_eq_coe", "code": "theorem toOrderHom_eq_coe (f : \u03b1 \u2192\ud835\udc84 \u03b2) : f.1 = f", "start": [640, 1], "end": [640, 56], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.coe_mk", "code": "@[simp] theorem coe_mk (f : \u03b1 \u2192o \u03b2) (hf : Continuous f) : \u21d1(mk f hf) = f", "start": [642, 1], "end": [642, 80], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.coe_toOrderHom", "code": "@[simp] theorem coe_toOrderHom (f : \u03b1 \u2192\ud835\udc84 \u03b2) : \u21d1f.1 = f", "start": [643, 1], "end": [643, 62], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.Simps.apply", "code": "def Simps.apply (h : \u03b1 \u2192\ud835\udc84 \u03b2) : \u03b1 \u2192 \u03b2 :=\n  h", "start": [645, 1], "end": [649, 4], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.congr_fun", "code": "theorem congr_fun {f g : \u03b1 \u2192\ud835\udc84 \u03b2} (h : f = g) (x : \u03b1) : f x = g x", "start": [653, 1], "end": [654, 24], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.congr_arg", "code": "theorem congr_arg (f : \u03b1 \u2192\ud835\udc84 \u03b2) {x y : \u03b1} (h : x = y) : f x = f y", "start": [657, 1], "end": [658, 23], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.monotone", "code": "protected theorem monotone (f : \u03b1 \u2192\ud835\udc84 \u03b2) : Monotone f", "start": [661, 1], "end": [662, 14], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.apply_mono", "code": "@[mono]\ntheorem apply_mono {f g : \u03b1 \u2192\ud835\udc84 \u03b2} {x y : \u03b1} (h\u2081 : f \u2264 g) (h\u2082 : x \u2264 y) : f x \u2264 g y", "start": [665, 1], "end": [667, 57], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.ite_continuous'", "code": "theorem ite_continuous' {p : Prop} [hp : Decidable p] (f g : \u03b1 \u2192 \u03b2) (hf : Continuous' f)\n    (hg : Continuous' g) : Continuous' fun x => if p then f x else g x", "start": [670, 1], "end": [672, 25], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.\u03c9Sup_bind", "code": "theorem \u03c9Sup_bind {\u03b2 \u03b3 : Type v} (c : Chain \u03b1) (f : \u03b1 \u2192o Part \u03b2) (g : \u03b1 \u2192o \u03b2 \u2192 Part \u03b3) :\n    \u03c9Sup (c.map (f.bind g)) = \u03c9Sup (c.map f) >>= \u03c9Sup (c.map g)", "start": [675, 1], "end": [700, 38], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.bind_continuous'", "code": "theorem bind_continuous' {\u03b2 \u03b3 : Type v} (f : \u03b1 \u2192 Part \u03b2) (g : \u03b1 \u2192 \u03b2 \u2192 Part \u03b3) :\n    Continuous' f \u2192 Continuous' g \u2192 Continuous' fun x => f x >>= g x", "start": [703, 1], "end": [707, 54], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.map_continuous'", "code": "theorem map_continuous' {\u03b2 \u03b3 : Type v} (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192 Part \u03b2) (hg : Continuous' g) :\n    Continuous' fun x => f <$> g x", "start": [710, 1], "end": [712, 92], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.seq_continuous'", "code": "theorem seq_continuous' {\u03b2 \u03b3 : Type v} (f : \u03b1 \u2192 Part (\u03b2 \u2192 \u03b3)) (g : \u03b1 \u2192 Part \u03b2) (hf : Continuous' f)\n    (hg : Continuous' g) : Continuous' fun x => f x <*> g x", "start": [715, 1], "end": [721, 31], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.continuous", "code": "theorem continuous (F : \u03b1 \u2192\ud835\udc84 \u03b2) (C : Chain \u03b1) : F (\u03c9Sup C) = \u03c9Sup (C.map F)", "start": [724, 1], "end": [725, 25], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.copy", "code": "@[simps!]\ndef copy (f : \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192\ud835\udc84 \u03b2) (h : f = g) : \u03b1 \u2192\ud835\udc84 \u03b2 where\n  toOrderHom := g.1.copy f h\n  cont := by rw [OrderHom.copy_eq]; exact g.cont", "start": [728, 1], "end": [734, 49], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.id", "code": "@[simps!]\ndef id : \u03b1 \u2192\ud835\udc84 \u03b1 := \u27e8OrderHom.id, continuous_id\u27e9", "start": [741, 1], "end": [743, 48], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.comp", "code": "@[simps!]\ndef comp (f : \u03b2 \u2192\ud835\udc84 \u03b3) (g : \u03b1 \u2192\ud835\udc84 \u03b2) : \u03b1 \u2192\ud835\udc84 \u03b3 := \u27e8.comp f.1 g.1, continuous_comp _ _ g.cont f.cont\u27e9", "start": [747, 1], "end": [749, 98], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.ext", "code": "@[ext]\nprotected theorem ext (f g : \u03b1 \u2192\ud835\udc84 \u03b2) (h : \u2200 x, f x = g x) : f = g", "start": [753, 1], "end": [754, 87], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.coe_inj", "code": "protected theorem coe_inj (f g : \u03b1 \u2192\ud835\udc84 \u03b2) (h : (f : \u03b1 \u2192 \u03b2) = g) : f = g", "start": [757, 1], "end": [758, 17], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : \u03b2 \u2192\ud835\udc84 \u03b3) : f.comp id = f", "start": [761, 1], "end": [762, 52], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : \u03b2 \u2192\ud835\udc84 \u03b3) : id.comp f = f", "start": [765, 1], "end": [766, 52], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : \u03b3 \u2192\ud835\udc84 \u03c6) (g : \u03b2 \u2192\ud835\udc84 \u03b3) (h : \u03b1 \u2192\ud835\udc84 \u03b2) : f.comp (g.comp h) = (f.comp g).comp h", "start": [769, 1], "end": [771, 6], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.coe_apply", "code": "@[simp]\ntheorem coe_apply (a : \u03b1) (f : \u03b1 \u2192\ud835\udc84 \u03b2) : (f : \u03b1 \u2192o \u03b2) a = f a", "start": [774, 1], "end": [776, 6], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.const", "code": "@[simps!]\ndef const (x : \u03b2) : \u03b1 \u2192\ud835\udc84 \u03b2 := \u27e8.const _ x, continuous_const x\u27e9", "start": [779, 1], "end": [781, 63], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.toMono", "code": "@[simps]\ndef toMono : (\u03b1 \u2192\ud835\udc84 \u03b2) \u2192o \u03b1 \u2192o \u03b2 where\n  toFun f := f\n  monotone' _ _ h := h", "start": [788, 1], "end": [792, 23], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge", "code": "@[simp]\ntheorem forall_forall_merge (c\u2080 : Chain (\u03b1 \u2192\ud835\udc84 \u03b2)) (c\u2081 : Chain \u03b1) (z : \u03b2) :\n    (\u2200 i j : \u2115, (c\u2080 i) (c\u2081 j) \u2264 z) \u2194 \u2200 i : \u2115, (c\u2080 i) (c\u2081 i) \u2264 z", "start": [796, 1], "end": [812, 24], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.forall_forall_merge'", "code": "@[simp]\ntheorem forall_forall_merge' (c\u2080 : Chain (\u03b1 \u2192\ud835\udc84 \u03b2)) (c\u2081 : Chain \u03b1) (z : \u03b2) :\n    (\u2200 j i : \u2115, (c\u2080 i) (c\u2081 j) \u2264 z) \u2194 \u2200 i : \u2115, (c\u2080 i) (c\u2081 i) \u2264 z", "start": [815, 1], "end": [818, 40], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.\u03c9Sup", "code": "@[simps!]\nprotected def \u03c9Sup (c : Chain (\u03b1 \u2192\ud835\udc84 \u03b2)) : \u03b1 \u2192\ud835\udc84 \u03b2 :=\n  .mk (\u03c9Sup <| c.map toMono) <| fun c' \u21a6 by\n    apply eq_of_forall_ge_iff; intro z\n    simp only [\u03c9Sup_le_iff, (c _).continuous, Chain.map_coe, OrderHom.apply_coe, toMono_coe,\n      OrderHom.omegaCompletePartialOrder_\u03c9Sup_coe, forall_forall_merge, OrderHomClass.coe_coe,\n      forall_forall_merge', (\u00b7 \u2218 \u00b7), Function.eval]", "start": [821, 1], "end": [829, 52], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.Prod.apply", "code": "@[simps]\ndef apply : (\u03b1 \u2192\ud835\udc84 \u03b2) \u00d7 \u03b1 \u2192\ud835\udc84 \u03b2 where\n  toFun f := f.1 f.2\n  monotone' x y h := by\n    dsimp\n    trans y.fst x.snd <;> [apply h.1; apply y.1.monotone h.2]\n  cont := by\n    intro c\n    apply le_antisymm\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      dsimp\n      rw [(c _).fst.continuous]\n      apply \u03c9Sup_le\n      intro j\n      apply le_\u03c9Sup_of_le (max i j)\n      apply apply_mono\n      exact monotone_fst (OrderHom.mono _ (le_max_left _ _))\n      exact monotone_snd (OrderHom.mono _ (le_max_right _ _))\n    \u00b7 apply \u03c9Sup_le\n      intro i\n      apply le_\u03c9Sup_of_le i\n      dsimp\n      apply OrderHom.mono _\n      apply le_\u03c9Sup_of_le i\n      rfl", "start": [840, 1], "end": [866, 10], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.\u03c9Sup_def", "code": "theorem \u03c9Sup_def (c : Chain (\u03b1 \u2192\ud835\udc84 \u03b2)) (x : \u03b1) : \u03c9Sup c x = ContinuousHom.\u03c9Sup c x", "start": [872, 1], "end": [873, 6], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.\u03c9Sup_apply_\u03c9Sup", "code": "theorem \u03c9Sup_apply_\u03c9Sup (c\u2080 : Chain (\u03b1 \u2192\ud835\udc84 \u03b2)) (c\u2081 : Chain \u03b1) :\n    \u03c9Sup c\u2080 (\u03c9Sup c\u2081) = Prod.apply (\u03c9Sup (c\u2080.zip c\u2081))", "start": [876, 1], "end": [877, 99], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.flip", "code": "@[simps]\ndef flip {\u03b1 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192\ud835\udc84 \u03b3) : \u03b2 \u2192\ud835\udc84 \u03b1 \u2192 \u03b3 where\n  toFun x y := f y x\n  monotone' x y h a := (f a).monotone h\n  cont := by intro _; ext x; change f _ _ = _; rw [(f _).continuous]; rfl", "start": [880, 1], "end": [885, 74], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.bind", "code": "@[simps! apply] noncomputable def bind {\u03b2 \u03b3 : Type v} (f : \u03b1 \u2192\ud835\udc84 Part \u03b2) (g : \u03b1 \u2192\ud835\udc84 \u03b2 \u2192 Part \u03b3) : \u03b1 \u2192\ud835\udc84 Part \u03b3 :=\n  .mk (OrderHom.bind f g.toOrderHom) fun c => by\n    rw [\u03c9Sup_bind, \u2190 f.continuous, g.toOrderHom_eq_coe, \u2190 g.continuous]\n    rfl", "start": [889, 1], "end": [894, 8], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.map", "code": "@[simps! apply] noncomputable def map {\u03b2 \u03b3 : Type v} (f : \u03b2 \u2192 \u03b3) (g : \u03b1 \u2192\ud835\udc84 Part \u03b2) : \u03b1 \u2192\ud835\udc84 Part \u03b3 :=\n  .copy (fun x => f <$> g x) (bind g (const (pure \u2218 f))) <| by\n    ext1\n    simp only [map_eq_bind_pure_comp, bind, coe_mk, OrderHom.bind_coe, coe_apply, coe_toOrderHom,\n      const_apply]", "start": [898, 1], "end": [904, 19], "kind": "commanddeclaration"}, {"full_name": "OmegaCompletePartialOrder.ContinuousHom.seq", "code": "@[simps! apply] noncomputable def seq {\u03b2 \u03b3 : Type v} (f : \u03b1 \u2192\ud835\udc84 Part (\u03b2 \u2192 \u03b3)) (g : \u03b1 \u2192\ud835\udc84 Part \u03b2) : \u03b1 \u2192\ud835\udc84 Part \u03b3 :=\n  .copy (fun x => f x <*> g x) (bind f <| flip <| _root_.flip map g) <| by\n      ext\n      simp only [seq_eq_bind_map, Part.bind_eq_bind, Part.mem_bind_iff, flip_apply, _root_.flip,\n        map_apply, bind_apply]", "start": [908, 1], "end": [914, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Hom.lean", "imports": ["Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgHom", "code": "structure AlgHom (R : Type u) (A : Type v) (B : Type w) [CommSemiring R] [Semiring A] [Semiring B]\n  [Algebra R A] [Algebra R B] extends RingHom A B where\n  commutes' : \u2200 r : R, toFun (algebraMap R A r) = algebraMap R B r", "start": [32, 1], "end": [36, 67], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass", "code": "class AlgHomClass (F : Type*) (R : outParam (Type*)) (A : outParam (Type*))\n  (B : outParam (Type*)) [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A]\n  [Algebra R B] extends RingHomClass F A B where\n  commutes : \u2200 (f : F) (r : R), f (algebraMap R A r) = algebraMap R B r", "start": [48, 1], "end": [53, 72], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.linearMapClass", "code": "instance (priority := 100) linearMapClass [AlgHomClass F R A B] : LinearMapClass F R A B :=\n  { \u2039AlgHomClass F R A B\u203a with\n    map_smul\u209b\u2097 := fun f r x => by\n      simp only [Algebra.smul_def, map_mul, commutes, RingHom.id_apply] }", "start": [68, 1], "end": [71, 74], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.toAlgHom", "code": "@[coe]\ndef toAlgHom {F : Type*} [AlgHomClass F R A B] (f : F) : A \u2192\u2090[R] B :=\n  { (f : A \u2192+* B) with\n      toFun := f\n      commutes' := AlgHomClass.commutes f }", "start": [75, 1], "end": [81, 44], "kind": "commanddeclaration"}, {"full_name": "AlgHomClass.coeTC", "code": "instance coeTC {F : Type*} [AlgHomClass F R A B] : CoeTC F (A \u2192\u2090[R] B) :=\n  \u27e8AlgHomClass.toAlgHom\u27e9", "start": [83, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "AlgHom.algHomClass", "code": "instance algHomClass : AlgHomClass (A \u2192\u2090[R] B) R A B where\n  coe f := f.toFun\n  coe_injective' f g h := by\n    rcases f with \u27e8\u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _, _\u27e9, _\u27e9\n    rcases g with \u27e8\u27e8\u27e8\u27e8_, _\u27e9, _\u27e9, _, _\u27e9, _\u27e9\n    congr\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  commutes f := f.commutes'", "start": [103, 1], "end": [113, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Simps.apply", "code": "def Simps.apply {R : Type u} {\u03b1 : Type v} {\u03b2 : Type w} [CommSemiring R]\n    [Semiring \u03b1] [Semiring \u03b2] [Algebra R \u03b1] [Algebra R \u03b2] (f : \u03b1 \u2192\u2090[R] \u03b2) : \u03b1 \u2192 \u03b2 := f", "start": [116, 1], "end": [118, 87], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_coe", "code": "@[simp]\nprotected theorem coe_coe {F : Type*} [AlgHomClass F R A B] (f : F) : \u21d1(f : A \u2192\u2090[R] B) = f", "start": [122, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : A \u2192\u2090[R] B) : f.toFun = f", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coeOutRingHom", "code": "instance coeOutRingHom : CoeOut (A \u2192\u2090[R] B) (A \u2192+* B) :=\n  \u27e8AlgHom.toRingHom\u27e9", "start": [134, 1], "end": [135, 21], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toMonoidHom'", "code": "@[coe]\ndef toMonoidHom' (f : A \u2192\u2090[R] B) : A \u2192* B := (f : A \u2192+* B)", "start": [139, 1], "end": [140, 59], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coeOutMonoidHom", "code": "instance coeOutMonoidHom : CoeOut (A \u2192\u2090[R] B) (A \u2192* B) :=\n  \u27e8AlgHom.toMonoidHom'\u27e9", "start": [142, 1], "end": [143, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toAddMonoidHom'", "code": "@[coe]\ndef toAddMonoidHom' (f : A \u2192\u2090[R] B) : A \u2192+ B := (f : A \u2192+* B)", "start": [147, 1], "end": [148, 62], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coeOutAddMonoidHom", "code": "instance coeOutAddMonoidHom : CoeOut (A \u2192\u2090[R] B) (A \u2192+ B) :=\n  \u27e8AlgHom.toAddMonoidHom'\u27e9", "start": [150, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_mk", "code": "@[simp]\ntheorem coe_mk {f : A \u2192+* B} (h) : ((\u27e8f, h\u27e9 : A \u2192\u2090[R] B) : A \u2192 B) = f", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_mks", "code": "@[norm_cast]\ntheorem coe_mks {f : A \u2192 B} (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) : \u21d1(\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085\u27e9 : A \u2192\u2090[R] B) = f", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_ringHom_mk", "code": "@[simp, norm_cast]\ntheorem coe_ringHom_mk {f : A \u2192+* B} (h) : ((\u27e8f, h\u27e9 : A \u2192\u2090[R] B) : A \u2192+* B) = f", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_eq_coe", "code": "@[simp]\ntheorem toRingHom_eq_coe (f : A \u2192\u2090[R] B) : f.toRingHom = f", "start": [171, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_toRingHom", "code": "@[simp, norm_cast]\ntheorem coe_toRingHom (f : A \u2192\u2090[R] B) : \u21d1(f : A \u2192+* B) = f", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_toMonoidHom", "code": "@[simp, norm_cast]\ntheorem coe_toMonoidHom (f : A \u2192\u2090[R] B) : \u21d1(f : A \u2192* B) = f", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_toAddMonoidHom", "code": "@[simp, norm_cast]\ntheorem coe_toAddMonoidHom (f : A \u2192\u2090[R] B) : \u21d1(f : A \u2192+ B) = f", "start": [186, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_fn_injective", "code": "theorem coe_fn_injective : @Function.Injective (A \u2192\u2090[R] B) (A \u2192 B) (\u2191)", "start": [193, 1], "end": [194, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_fn_inj", "code": "theorem coe_fn_inj {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} : (\u03c6\u2081 : A \u2192 B) = \u03c6\u2082 \u2194 \u03c6\u2081 = \u03c6\u2082", "start": [197, 1], "end": [198, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_ringHom_injective", "code": "theorem coe_ringHom_injective : Function.Injective ((\u2191) : (A \u2192\u2090[R] B) \u2192 A \u2192+* B)", "start": [201, 1], "end": [202, 98], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_monoidHom_injective", "code": "theorem coe_monoidHom_injective : Function.Injective ((\u2191) : (A \u2192\u2090[R] B) \u2192 A \u2192* B)", "start": [205, 1], "end": [206, 61], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_addMonoidHom_injective", "code": "theorem coe_addMonoidHom_injective : Function.Injective ((\u2191) : (A \u2192\u2090[R] B) \u2192 A \u2192+ B)", "start": [209, 1], "end": [210, 64], "kind": "commanddeclaration"}, {"full_name": "AlgHom.congr_fun", "code": "protected theorem congr_fun {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} (H : \u03c6\u2081 = \u03c6\u2082) (x : A) : \u03c6\u2081 x = \u03c6\u2082 x", "start": [213, 1], "end": [214, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.congr_arg", "code": "protected theorem congr_arg (\u03c6 : A \u2192\u2090[R] B) {x y : A} (h : x = y) : \u03c6 x = \u03c6 y", "start": [217, 1], "end": [218, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ext", "code": "@[ext]\ntheorem ext {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} (H : \u2200 x, \u03c6\u2081 x = \u03c6\u2082 x) : \u03c6\u2081 = \u03c6\u2082", "start": [221, 1], "end": [223, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ext_iff", "code": "theorem ext_iff {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} : \u03c6\u2081 = \u03c6\u2082 \u2194 \u2200 x, \u03c6\u2081 x = \u03c6\u2082 x", "start": [226, 1], "end": [227, 18], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mk_coe", "code": "@[simp]\ntheorem mk_coe {f : A \u2192\u2090[R] B} (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) : (\u27e8\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082\u27e9, h\u2083, h\u2084\u27e9, h\u2085\u27e9 : A \u2192\u2090[R] B) = f", "start": [230, 1], "end": [232, 19], "kind": "commanddeclaration"}, {"full_name": "AlgHom.commutes", "code": "@[simp]\ntheorem commutes (r : R) : \u03c6 (algebraMap R A r) = algebraMap R B r", "start": [235, 1], "end": [237, 16], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_algebraMap", "code": "theorem comp_algebraMap : (\u03c6 : A \u2192+* B).comp (algebraMap R A) = algebraMap R B", "start": [240, 1], "end": [241, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_add", "code": "protected theorem map_add (r s : A) : \u03c6 (r + s) = \u03c6 r + \u03c6 s", "start": [244, 1], "end": [245, 16], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_zero", "code": "protected theorem map_zero : \u03c6 0 = 0", "start": [248, 1], "end": [249, 13], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_mul", "code": "protected theorem map_mul (x y) : \u03c6 (x * y) = \u03c6 x * \u03c6 y", "start": [252, 1], "end": [253, 16], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_one", "code": "protected theorem map_one : \u03c6 1 = 1", "start": [256, 1], "end": [257, 12], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_pow", "code": "protected theorem map_pow (x : A) (n : \u2115) : \u03c6 (x ^ n) = \u03c6 x ^ n", "start": [260, 1], "end": [261, 16], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_smul", "code": "protected theorem map_smul (r : R) (x : A) : \u03c6 (r \u2022 x) = r \u2022 \u03c6 x", "start": [265, 1], "end": [266, 17], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_sum", "code": "protected theorem map_sum {\u03b9 : Type*} (f : \u03b9 \u2192 A) (s : Finset \u03b9) :\n    \u03c6 (\u2211 x in s, f x) = \u2211 x in s, \u03c6 (f x)", "start": [269, 1], "end": [271, 16], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_finsupp_sum", "code": "protected theorem map_finsupp_sum {\u03b1 : Type*} [Zero \u03b1] {\u03b9 : Type*} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A) :\n    \u03c6 (f.sum g) = f.sum fun i a => \u03c6 (g i a)", "start": [274, 1], "end": [276, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_bit0", "code": "protected theorem map_bit0 (x) : \u03c6 (bit0 x) = bit0 (\u03c6 x)", "start": [280, 1], "end": [281, 15], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_bit1", "code": "protected theorem map_bit1 (x) : \u03c6 (bit1 x) = bit1 (\u03c6 x)", "start": [285, 1], "end": [286, 15], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mk'", "code": "def mk' (f : A \u2192+* B) (h : \u2200 (c : R) (x), f (c \u2022 x) = c \u2022 f x) : A \u2192\u2090[R] B :=\n  { f with\n    toFun := f\n    commutes' := fun c => by simp only [Algebra.algebraMap_eq_smul_one, h, f.map_one] }", "start": [289, 1], "end": [293, 88], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : A \u2192+* B) (h : \u2200 (c : R) (x), f (c \u2022 x) = c \u2022 f x) : \u21d1(mk' f h) = f", "start": [296, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.id", "code": "protected def id : A \u2192\u2090[R] A :=\n  { RingHom.id A with commutes' := fun _ => rfl }", "start": [305, 1], "end": [307, 50], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(AlgHom.id R A) = id", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.id_toRingHom", "code": "@[simp]\ntheorem id_toRingHom : (AlgHom.id R A : A \u2192+* A) = RingHom.id _", "start": [315, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.id_apply", "code": "theorem id_apply (p : A) : AlgHom.id R A p = p", "start": [322, 1], "end": [323, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp", "code": "def comp (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B) : A \u2192\u2090[R] C :=\n  { \u03c6\u2081.toRingHom.comp \u2191\u03c6\u2082 with\n    commutes' := fun r : R => by rw [\u2190 \u03c6\u2081.commutes, \u2190 \u03c6\u2082.commutes]; rfl }", "start": [326, 1], "end": [329, 74], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B) : \u21d1(\u03c6\u2081.comp \u03c6\u2082) = \u03c6\u2081 \u2218 \u03c6\u2082", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_apply", "code": "theorem comp_apply (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B) (p : A) : \u03c6\u2081.comp \u03c6\u2082 p = \u03c6\u2081 (\u03c6\u2082 p)", "start": [337, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_toRingHom", "code": "theorem comp_toRingHom (\u03c6\u2081 : B \u2192\u2090[R] C) (\u03c6\u2082 : A \u2192\u2090[R] B) :\n    (\u03c6\u2081.comp \u03c6\u2082 : A \u2192+* C) = (\u03c6\u2081 : B \u2192+* C).comp \u2191\u03c6\u2082", "start": [341, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_id", "code": "@[simp]\ntheorem comp_id : \u03c6.comp (AlgHom.id R A) = \u03c6", "start": [346, 1], "end": [348, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.id_comp", "code": "@[simp]\ntheorem id_comp : (AlgHom.id R B).comp \u03c6 = \u03c6", "start": [351, 1], "end": [353, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_assoc", "code": "theorem comp_assoc (\u03c6\u2081 : C \u2192\u2090[R] D) (\u03c6\u2082 : B \u2192\u2090[R] C) (\u03c6\u2083 : A \u2192\u2090[R] B) :\n    (\u03c6\u2081.comp \u03c6\u2082).comp \u03c6\u2083 = \u03c6\u2081.comp (\u03c6\u2082.comp \u03c6\u2083)", "start": [356, 1], "end": [358, 20], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap", "code": "def toLinearMap : A \u2192\u2097[R] B where\n  toFun := \u03c6\n  map_add' := map_add _\n  map_smul' := map_smul _", "start": [361, 1], "end": [365, 26], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_apply", "code": "@[simp]\ntheorem toLinearMap_apply (p : A) : \u03c6.toLinearMap p = \u03c6 p", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_injective", "code": "theorem toLinearMap_injective :\n    Function.Injective (toLinearMap : _ \u2192 A \u2192\u2097[R] B)", "start": [373, 1], "end": [375, 31], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_toLinearMap", "code": "@[simp]\ntheorem comp_toLinearMap (f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C) :\n    (g.comp f).toLinearMap = g.toLinearMap.comp f.toLinearMap", "start": [378, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_id", "code": "@[simp]\ntheorem toLinearMap_id : toLinearMap (AlgHom.id R A) = LinearMap.id", "start": [384, 1], "end": [386, 29], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ofLinearMap", "code": "@[simps]\ndef ofLinearMap (f : A \u2192\u2097[R] B) (map_one : f 1 = 1) (map_mul : \u2200 x y, f (x * y) = f x * f y) :\n    A \u2192\u2090[R] B :=\n  { f.toAddMonoidHom with\n    toFun := f\n    map_one' := map_one\n    map_mul' := map_mul\n    commutes' := fun c => by simp only [Algebra.algebraMap_eq_smul_one, f.map_smul, map_one] }", "start": [389, 1], "end": [397, 95], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ofLinearMap_toLinearMap", "code": "@[simp]\ntheorem ofLinearMap_toLinearMap (map_one) (map_mul) :\n    ofLinearMap \u03c6.toLinearMap map_one map_mul = \u03c6", "start": [400, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_ofLinearMap", "code": "@[simp]\ntheorem toLinearMap_ofLinearMap (f : A \u2192\u2097[R] B) (map_one) (map_mul) :\n    toLinearMap (ofLinearMap f map_one map_mul) = f", "start": [407, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.ofLinearMap_id", "code": "@[simp]\ntheorem ofLinearMap_id (map_one) (map_mul) :\n    ofLinearMap LinearMap.id map_one map_mul = AlgHom.id R A", "start": [414, 1], "end": [417, 19], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_smul_of_tower", "code": "theorem map_smul_of_tower {R'} [SMul R' A] [SMul R' B] [LinearMap.CompatibleSMul A B R' R] (r : R')\n    (x : A) : \u03c6 (r \u2022 x) = r \u2022 \u03c6 x", "start": [420, 1], "end": [422, 38], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_list_prod", "code": "theorem map_list_prod (s : List A) : \u03c6 s.prod = (s.map \u03c6).prod", "start": [425, 1], "end": [426, 30], "kind": "commanddeclaration"}, {"full_name": "AlgHom.End", "code": "@[simps (config := .lemmasOnly) toSemigroup_toMul_mul toOne_one]\ninstance End : Monoid (A \u2192\u2090[R] A) where\n  mul := comp\n  mul_assoc \u03d5 \u03c8 \u03c7 := rfl\n  one := AlgHom.id R A\n  one_mul \u03d5 := ext fun x => rfl\n  mul_one \u03d5 := ext fun x => rfl", "start": [429, 1], "end": [435, 32], "kind": "commanddeclaration"}, {"full_name": "AlgHom.one_apply", "code": "@[simp]\ntheorem one_apply (x : A) : (1 : A \u2192\u2090[R] A) x = x", "start": [438, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mul_apply", "code": "@[simp]\ntheorem mul_apply (\u03c6 \u03c8 : A \u2192\u2090[R] A) (x : A) : (\u03c6 * \u03c8) x = \u03c6 (\u03c8 x)", "start": [443, 1], "end": [445, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.algebraMap_eq_apply", "code": "theorem algebraMap_eq_apply (f : A \u2192\u2090[R] B) {y : R} {x : A} (h : algebraMap R A y = x) :\n    algebraMap R B y = f x", "start": [448, 1], "end": [450, 26], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_multiset_prod", "code": "protected theorem map_multiset_prod (s : Multiset A) : \u03c6 s.prod = (s.map \u03c6).prod", "start": [461, 1], "end": [462, 24], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_prod", "code": "protected theorem map_prod {\u03b9 : Type*} (f : \u03b9 \u2192 A) (s : Finset \u03b9) :\n    \u03c6 (\u220f x in s, f x) = \u220f x in s, \u03c6 (f x)", "start": [465, 1], "end": [467, 17], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_finsupp_prod", "code": "protected theorem map_finsupp_prod {\u03b1 : Type*} [Zero \u03b1] {\u03b9 : Type*} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A) :\n    \u03c6 (f.prod g) = f.prod fun i a => \u03c6 (g i a)", "start": [470, 1], "end": [472, 25], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_neg", "code": "protected theorem map_neg (x) : \u03c6 (-x) = -\u03c6 x", "start": [483, 1], "end": [484, 14], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_sub", "code": "protected theorem map_sub (x y) : \u03c6 (x - y) = \u03c6 x - \u03c6 y", "start": [487, 1], "end": [488, 16], "kind": "commanddeclaration"}, {"full_name": "RingHom.toNatAlgHom", "code": "def toNatAlgHom [Semiring R] [Semiring S] (f : R \u2192+* S) : R \u2192\u2090[\u2115] S :=\n  { f with\n    toFun := f\n    commutes' := fun n => by simp }", "start": [499, 1], "end": [503, 36], "kind": "commanddeclaration"}, {"full_name": "RingHom.toIntAlgHom", "code": "def toIntAlgHom [Ring R] [Ring S] [Algebra \u2124 R] [Algebra \u2124 S] (f : R \u2192+* S) : R \u2192\u2090[\u2124] S :=\n  { f with commutes' := fun n => by simp }", "start": [506, 1], "end": [508, 43], "kind": "commanddeclaration"}, {"full_name": "RingHom.toRatAlgHom", "code": "def toRatAlgHom [Ring R] [Ring S] [Algebra \u211a R] [Algebra \u211a S] (f : R \u2192+* S) : R \u2192\u2090[\u211a] S :=\n  { f with commutes' := f.map_rat_algebraMap }", "start": [511, 1], "end": [514, 47], "kind": "commanddeclaration"}, {"full_name": "RingHom.toRatAlgHom_toRingHom", "code": "@[simp]\ntheorem toRatAlgHom_toRingHom [Ring R] [Ring S] [Algebra \u211a R] [Algebra \u211a S] (f : R \u2192+* S) :\n    \u2191f.toRatAlgHom = f", "start": [517, 1], "end": [520, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_toRatAlgHom", "code": "@[simp]\ntheorem AlgHom.toRingHom_toRatAlgHom [Ring R] [Ring S] [Algebra \u211a R] [Algebra \u211a S]\n    (f : R \u2192\u2090[\u211a] S) : (f : R \u2192+* S).toRatAlgHom = f", "start": [529, 1], "end": [532, 27], "kind": "commanddeclaration"}, {"full_name": "RingHom.equivRatAlgHom", "code": "@[simps]\ndef RingHom.equivRatAlgHom [Ring R] [Ring S] [Algebra \u211a R] [Algebra \u211a S] : (R \u2192+* S) \u2243 (R \u2192\u2090[\u211a] S)\n    where\n  toFun := RingHom.toRatAlgHom\n  invFun := AlgHom.toRingHom\n  left_inv f := RingHom.toRatAlgHom_toRingHom f\n  right_inv f := AlgHom.toRingHom_toRatAlgHom f", "start": [535, 1], "end": [542, 48], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofId", "code": "def ofId : R \u2192\u2090[R] A :=\n  { algebraMap R A with commutes' := fun _ => rfl }", "start": [553, 1], "end": [555, 52], "kind": "commanddeclaration"}, {"full_name": "Algebra.ofId_apply", "code": "theorem ofId_apply (r) : ofId R A r = algebraMap R A r", "start": [560, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toAlgHom", "code": "@[simps]\ndef toAlgHom (m : M) : A \u2192\u2090[R] A :=\n  { MulSemiringAction.toRingHom _ _ m with\n    toFun := fun a => m \u2022 a\n    commutes' := smul_algebraMap _ }", "start": [572, 1], "end": [580, 37], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toAlgHom_injective", "code": "theorem toAlgHom_injective [FaithfulSMul M A] :\n    Function.Injective (MulSemiringAction.toAlgHom R A : M \u2192 A \u2192\u2090[R] A)", "start": [583, 1], "end": [585, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/DFinsupp/Encodable.lean", "imports": ["Mathlib/Logic/Equiv/List.lean", "Mathlib/Data/DFinsupp/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Finsupp/ToDFinsupp.lean", "imports": ["Mathlib/Data/Finsupp/Basic.lean", "Mathlib/Data/DFinsupp/Basic.lean", "Mathlib/Algebra/Module/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.toDFinsupp", "code": "def Finsupp.toDFinsupp [Zero M] (f : \u03b9 \u2192\u2080 M) : \u03a0\u2080 _ : \u03b9, M where\n  toFun := f\n  support' :=\n    Trunc.mk\n      \u27e8f.support.1, fun i => (Classical.em (f i = 0)).symm.imp_left Finsupp.mem_support_iff.mpr\u27e9", "start": [70, 1], "end": [75, 97], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_coe", "code": "@[simp]\ntheorem Finsupp.toDFinsupp_coe [Zero M] (f : \u03b9 \u2192\u2080 M) : \u21d1f.toDFinsupp = f", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_single", "code": "@[simp]\ntheorem Finsupp.toDFinsupp_single (i : \u03b9) (m : M) :\n    (Finsupp.single i m).toDFinsupp = DFinsupp.single i m", "start": [87, 1], "end": [91, 53], "kind": "commanddeclaration"}, {"full_name": "toDFinsupp_support", "code": "@[simp]\ntheorem toDFinsupp_support (f : \u03b9 \u2192\u2080 M) : f.toDFinsupp.support = f.support", "start": [96, 1], "end": [99, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp", "code": "def DFinsupp.toFinsupp (f : \u03a0\u2080 _ : \u03b9, M) : \u03b9 \u2192\u2080 M :=\n  \u27e8f.support, f, fun i => by simp only [DFinsupp.mem_support_iff]\u27e9", "start": [102, 1], "end": [108, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_coe", "code": "@[simp]\ntheorem DFinsupp.toFinsupp_coe (f : \u03a0\u2080 _ : \u03b9, M) : \u21d1f.toFinsupp = f", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_support", "code": "@[simp]\ntheorem DFinsupp.toFinsupp_support (f : \u03a0\u2080 _ : \u03b9, M) : f.toFinsupp.support = f.support", "start": [116, 1], "end": [119, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_single", "code": "@[simp]\ntheorem DFinsupp.toFinsupp_single (i : \u03b9) (m : M) :\n    (DFinsupp.single i m : \u03a0\u2080 _ : \u03b9, M).toFinsupp = Finsupp.single i m", "start": [122, 1], "end": [126, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_toFinsupp", "code": "@[simp]\ntheorem Finsupp.toDFinsupp_toFinsupp (f : \u03b9 \u2192\u2080 M) : f.toDFinsupp.toFinsupp = f", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_toDFinsupp", "code": "@[simp]\ntheorem DFinsupp.toFinsupp_toDFinsupp (f : \u03a0\u2080 _ : \u03b9, M) : f.toFinsupp.toDFinsupp = f", "start": [134, 1], "end": [136, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_zero", "code": "@[simp]\ntheorem toDFinsupp_zero [Zero M] : (0 : \u03b9 \u2192\u2080 M).toDFinsupp = 0", "start": [150, 1], "end": [152, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_add", "code": "@[simp]\ntheorem toDFinsupp_add [AddZeroClass M] (f g : \u03b9 \u2192\u2080 M) :\n    (f + g).toDFinsupp = f.toDFinsupp + g.toDFinsupp", "start": [155, 1], "end": [158, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_neg", "code": "@[simp]\ntheorem toDFinsupp_neg [AddGroup M] (f : \u03b9 \u2192\u2080 M) : (-f).toDFinsupp = -f.toDFinsupp", "start": [161, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_sub", "code": "@[simp]\ntheorem toDFinsupp_sub [AddGroup M] (f g : \u03b9 \u2192\u2080 M) :\n    (f - g).toDFinsupp = f.toDFinsupp - g.toDFinsupp", "start": [166, 1], "end": [169, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toDFinsupp_smul", "code": "@[simp]\ntheorem toDFinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] (r : R) (f : \u03b9 \u2192\u2080 M) :\n    (r \u2022 f).toDFinsupp = r \u2022 f.toDFinsupp", "start": [172, 1], "end": [175, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_zero", "code": "@[simp]\ntheorem toFinsupp_zero [Zero M] [\u2200 m : M, Decidable (m \u2260 0)] : toFinsupp 0 = (0 : \u03b9 \u2192\u2080 M)", "start": [184, 1], "end": [186, 28], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_add", "code": "@[simp]\ntheorem toFinsupp_add [AddZeroClass M] [\u2200 m : M, Decidable (m \u2260 0)] (f g : \u03a0\u2080 _ : \u03b9, M) :\n    (toFinsupp (f + g) : \u03b9 \u2192\u2080 M) = toFinsupp f + toFinsupp g", "start": [189, 1], "end": [192, 48], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_neg", "code": "@[simp]\ntheorem toFinsupp_neg [AddGroup M] [\u2200 m : M, Decidable (m \u2260 0)] (f : \u03a0\u2080 _ : \u03b9, M) :\n    (toFinsupp (-f) : \u03b9 \u2192\u2080 M) = -toFinsupp f", "start": [195, 1], "end": [198, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_sub", "code": "@[simp]\ntheorem toFinsupp_sub [AddGroup M] [\u2200 m : M, Decidable (m \u2260 0)] (f g : \u03a0\u2080 _ : \u03b9, M) :\n    (toFinsupp (f - g) : \u03b9 \u2192\u2080 M) = toFinsupp f - toFinsupp g", "start": [201, 1], "end": [204, 48], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.toFinsupp_smul", "code": "@[simp]\ntheorem toFinsupp_smul [Monoid R] [AddMonoid M] [DistribMulAction R M] [\u2200 m : M, Decidable (m \u2260 0)]\n    (r : R) (f : \u03a0\u2080 _ : \u03b9, M) : (toFinsupp (r \u2022 f) : \u03b9 \u2192\u2080 M) = r \u2022 toFinsupp f", "start": [207, 1], "end": [210, 49], "kind": "commanddeclaration"}, {"full_name": "finsuppEquivDFinsupp", "code": "@[simps (config := { fullyApplied := false })]\ndef finsuppEquivDFinsupp [DecidableEq \u03b9] [Zero M] [\u2200 m : M, Decidable (m \u2260 0)] :\n    (\u03b9 \u2192\u2080 M) \u2243 \u03a0\u2080 _ : \u03b9, M where\n  toFun := Finsupp.toDFinsupp\n  invFun := DFinsupp.toFinsupp\n  left_inv := Finsupp.toDFinsupp_toFinsupp\n  right_inv := DFinsupp.toFinsupp_toDFinsupp", "start": [222, 1], "end": [229, 45], "kind": "commanddeclaration"}, {"full_name": "finsuppAddEquivDFinsupp", "code": "@[simps (config := { fullyApplied := false })]\ndef finsuppAddEquivDFinsupp [DecidableEq \u03b9] [AddZeroClass M] [\u2200 m : M, Decidable (m \u2260 0)] :\n    (\u03b9 \u2192\u2080 M) \u2243+ \u03a0\u2080 _ : \u03b9, M :=\n  { finsuppEquivDFinsupp with\n    toFun := Finsupp.toDFinsupp\n    invFun := DFinsupp.toFinsupp\n    map_add' := Finsupp.toDFinsupp_add }", "start": [232, 1], "end": [240, 41], "kind": "commanddeclaration"}, {"full_name": "finsuppLequivDFinsupp", "code": "def finsuppLequivDFinsupp [DecidableEq \u03b9] [Semiring R] [AddCommMonoid M]\n    [\u2200 m : M, Decidable (m \u2260 0)] [Module R M] : (\u03b9 \u2192\u2080 M) \u2243\u2097[R] \u03a0\u2080 _ : \u03b9, M :=\n  { finsuppEquivDFinsupp with\n    toFun := Finsupp.toDFinsupp\n    invFun := DFinsupp.toFinsupp\n    map_smul' := Finsupp.toDFinsupp_smul\n    map_add' := Finsupp.toDFinsupp_add }", "start": [245, 1], "end": [255, 41], "kind": "commanddeclaration"}, {"full_name": "finsuppLequivDFinsupp_apply_apply", "code": "@[simp]\ntheorem finsuppLequivDFinsupp_apply_apply [DecidableEq \u03b9] [Semiring R] [AddCommMonoid M]\n    [\u2200 m : M, Decidable (m \u2260 0)] [Module R M] :\n      (\u2191(finsuppLequivDFinsupp (M := M) R) : (\u03b9 \u2192\u2080 M) \u2192 _) = Finsupp.toDFinsupp", "start": [259, 1], "end": [263, 45], "kind": "commanddeclaration"}, {"full_name": "finsuppLequivDFinsupp_symm_apply", "code": "@[simp]\ntheorem finsuppLequivDFinsupp_symm_apply [DecidableEq \u03b9] [Semiring R] [AddCommMonoid M]\n    [\u2200 m : M, Decidable (m \u2260 0)] [Module R M] :\n    \u2191(LinearEquiv.symm (finsuppLequivDFinsupp (\u03b9 := \u03b9) (M := M) R)) = DFinsupp.toFinsupp", "start": [265, 1], "end": [269, 6], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp", "code": "def sigmaFinsuppEquivDFinsupp [Zero N] : ((\u03a3i, \u03b7 i) \u2192\u2080 N) \u2243 \u03a0\u2080 i, \u03b7 i \u2192\u2080 N where\n  toFun f := \u27e8split f, Trunc.mk \u27e8(splitSupport f : Finset \u03b9).val, fun i => by\n          rw [\u2190 Finset.mem_def, mem_splitSupport_iff_nonzero]\n          exact (em _).symm\u27e9\u27e9\n  invFun f := by\n    haveI := Classical.decEq \u03b9\n    haveI := fun i => Classical.decEq (\u03b7 i \u2192\u2080 N)\n    refine'\n      onFinset (Finset.sigma f.support fun j => (f j).support) (fun ji => f ji.1 ji.2) fun g hg =>\n        Finset.mem_sigma.mpr \u27e8_, mem_support_iff.mpr hg\u27e9\n    simp only [Ne.def, DFinsupp.mem_support_toFun]\n    intro h\n    dsimp at hg\n    rw [h] at hg\n    simp only [coe_zero, Pi.zero_apply, not_true] at hg\n  left_inv f := by ext; simp [split]\n  right_inv f := by ext; simp [split]", "start": [281, 1], "end": [298, 38], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_apply", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_apply [Zero N] (f : (\u03a3i, \u03b7 i) \u2192\u2080 N) :\n    (sigmaFinsuppEquivDFinsupp f : \u2200 i, \u03b7 i \u2192\u2080 N) = Finsupp.split f", "start": [301, 1], "end": [304, 6], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_symm_apply", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_symm_apply [Zero N] (f : \u03a0\u2080 i, \u03b7 i \u2192\u2080 N) (s : \u03a3i, \u03b7 i) :\n    (sigmaFinsuppEquivDFinsupp.symm f : (\u03a3i, \u03b7 i) \u2192\u2080 N) s = f s.1 s.2", "start": [307, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_support", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_support [DecidableEq \u03b9] [Zero N]\n    [\u2200 (i : \u03b9) (x : \u03b7 i \u2192\u2080 N), Decidable (x \u2260 0)] (f : (\u03a3i, \u03b7 i) \u2192\u2080 N) :\n    (sigmaFinsuppEquivDFinsupp f).support = Finsupp.splitSupport f", "start": [313, 1], "end": [319, 56], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_single", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_single [DecidableEq \u03b9] [Zero N] (a : \u03a3i, \u03b7 i) (n : N) :\n    sigmaFinsuppEquivDFinsupp (Finsupp.single a n) =\n      @DFinsupp.single _ (fun i => \u03b7 i \u2192\u2080 N) _ _ a.1 (Finsupp.single a.2 n)", "start": [322, 1], "end": [333, 48], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_add", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_add [AddZeroClass N] (f g : (\u03a3i, \u03b7 i) \u2192\u2080 N) :\n    sigmaFinsuppEquivDFinsupp (f + g) =\n      (sigmaFinsuppEquivDFinsupp f + sigmaFinsuppEquivDFinsupp g : \u03a0\u2080 i : \u03b9, \u03b7 i \u2192\u2080 N)", "start": [339, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppAddEquivDFinsupp", "code": "@[simps]\ndef sigmaFinsuppAddEquivDFinsupp [AddZeroClass N] : ((\u03a3i, \u03b7 i) \u2192\u2080 N) \u2243+ \u03a0\u2080 i, \u03b7 i \u2192\u2080 N :=\n  { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add }", "start": [347, 1], "end": [353, 48], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppEquivDFinsupp_smul", "code": "@[simp]\ntheorem sigmaFinsuppEquivDFinsupp_smul {R} [Monoid R] [AddMonoid N] [DistribMulAction R N] (r : R)\n    (f : (\u03a3i, \u03b7 i) \u2192\u2080 N) :\n    sigmaFinsuppEquivDFinsupp (r \u2022 f) =\n      @SMul.smul R (\u03a0\u2080 i, \u03b7 i \u2192\u2080 N) MulAction.toSMul r (sigmaFinsuppEquivDFinsupp f)", "start": [359, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "sigmaFinsuppLequivDFinsupp", "code": "@[simps]\ndef sigmaFinsuppLequivDFinsupp [AddCommMonoid N] [Module R N] :\n    ((\u03a3i, \u03b7 i) \u2192\u2080 N) \u2243\u2097[R] \u03a0\u2080 i, \u03b7 i \u2192\u2080 N :=\n    { sigmaFinsuppEquivDFinsupp with\n    toFun := sigmaFinsuppEquivDFinsupp\n    invFun := sigmaFinsuppEquivDFinsupp.symm\n    map_add' := sigmaFinsuppEquivDFinsupp_add\n    map_smul' := sigmaFinsuppEquivDFinsupp_smul }", "start": [370, 1], "end": [381, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/FixedPoints.lean", "imports": ["Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/Order/Hom/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "OrderHom.lfp", "code": "def lfp : (\u03b1 \u2192o \u03b1) \u2192o \u03b1 where\n  toFun f := sInf { a | f a \u2264 a }\n  monotone' _ _ hle := sInf_le_sInf fun a ha => (hle a).trans ha", "start": [45, 1], "end": [48, 65], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp", "code": "def gfp : (\u03b1 \u2192o \u03b1) \u2192o \u03b1 where\n  toFun f := sSup { a | a \u2264 f a }\n  monotone' _ _ hle := sSup_le_sSup fun a ha => le_trans ha (hle a)", "start": [51, 1], "end": [54, 68], "kind": "commanddeclaration"}, {"full_name": "OrderHom.lfp_le", "code": "theorem lfp_le {a : \u03b1} (h : f a \u2264 a) : lfp f \u2264 a", "start": [57, 1], "end": [58, 12], "kind": "commanddeclaration"}, {"full_name": "OrderHom.lfp_le_fixed", "code": "theorem lfp_le_fixed {a : \u03b1} (h : f a = a) : lfp f \u2264 a", "start": [61, 1], "end": [62, 16], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_lfp", "code": "theorem le_lfp {a : \u03b1} (h : \u2200 b, f b \u2264 b \u2192 a \u2264 b) : a \u2264 lfp f", "start": [65, 1], "end": [66, 12], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_le_lfp", "code": "theorem map_le_lfp {a : \u03b1} (ha : a \u2264 lfp f) : f a \u2264 lfp f", "start": [72, 1], "end": [73, 66], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_lfp", "code": "@[simp]\ntheorem map_lfp : f (lfp f) = lfp f", "start": [76, 1], "end": [79, 37], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isFixedPt_lfp", "code": "theorem isFixedPt_lfp : IsFixedPt f (lfp f)", "start": [82, 1], "end": [83, 12], "kind": "commanddeclaration"}, {"full_name": "OrderHom.lfp_le_map", "code": "theorem lfp_le_map {a : \u03b1} (ha : lfp f \u2264 a) : lfp f \u2264 f a", "start": [86, 1], "end": [89, 25], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isLeast_lfp_le", "code": "theorem isLeast_lfp_le : IsLeast { a | f a \u2264 a } (lfp f)", "start": [92, 1], "end": [93, 36], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isLeast_lfp", "code": "theorem isLeast_lfp : IsLeast (fixedPoints f) (lfp f)", "start": [96, 1], "end": [97, 45], "kind": "commanddeclaration"}, {"full_name": "OrderHom.lfp_induction", "code": "theorem lfp_induction {p : \u03b1 \u2192 Prop} (step : \u2200 a, p a \u2192 a \u2264 lfp f \u2192 p (f a))\n    (hSup : \u2200 s, (\u2200 a \u2208 s, p a) \u2192 p (sSup s)) : p (lfp f)", "start": [100, 1], "end": [107, 46], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_gfp", "code": "theorem le_gfp {a : \u03b1} (h : a \u2264 f a) : a \u2264 gfp f", "start": [110, 1], "end": [111, 12], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp_le", "code": "theorem gfp_le {a : \u03b1} (h : \u2200 b, b \u2264 f b \u2192 b \u2264 a) : gfp f \u2264 a", "start": [114, 1], "end": [115, 12], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isFixedPt_gfp", "code": "theorem isFixedPt_gfp : IsFixedPt f (gfp f)", "start": [118, 1], "end": [119, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_gfp", "code": "@[simp]\ntheorem map_gfp : f (gfp f) = gfp f", "start": [122, 1], "end": [124, 17], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_le_gfp", "code": "theorem map_le_gfp {a : \u03b1} (ha : a \u2264 gfp f) : f a \u2264 gfp f", "start": [127, 1], "end": [128, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp_le_map", "code": "theorem gfp_le_map {a : \u03b1} (ha : gfp f \u2264 a) : gfp f \u2264 f a", "start": [131, 1], "end": [132, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isGreatest_gfp_le", "code": "theorem isGreatest_gfp_le : IsGreatest { a | a \u2264 f a } (gfp f)", "start": [135, 1], "end": [136, 24], "kind": "commanddeclaration"}, {"full_name": "OrderHom.isGreatest_gfp", "code": "theorem isGreatest_gfp : IsGreatest (fixedPoints f) (gfp f)", "start": [139, 1], "end": [140, 21], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp_induction", "code": "theorem gfp_induction {p : \u03b1 \u2192 Prop} (step : \u2200 a, p a \u2192 gfp f \u2264 a \u2192 p (f a))\n    (hInf : \u2200 s, (\u2200 a \u2208 s, p a) \u2192 p (sInf s)) : p (gfp f)", "start": [143, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_lfp_comp", "code": "theorem map_lfp_comp : f (lfp (g.comp f)) = lfp (f.comp g)", "start": [155, 1], "end": [157, 49], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_gfp_comp", "code": "theorem map_gfp_comp : f (gfp (g.comp f)) = gfp (f.comp g)", "start": [160, 1], "end": [161, 40], "kind": "commanddeclaration"}, {"full_name": "OrderHom.lfp_lfp", "code": "theorem lfp_lfp (h : \u03b1 \u2192o \u03b1 \u2192o \u03b1) : lfp (lfp.comp h) = lfp h.onDiag", "start": [165, 1], "end": [173, 16], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp_gfp", "code": "theorem gfp_gfp (h : \u03b1 \u2192o \u03b1 \u2192o \u03b1) : gfp (gfp.comp h) = gfp h.onDiag", "start": [176, 1], "end": [178, 22], "kind": "commanddeclaration"}, {"full_name": "OrderHom.gfp_const_inf_le", "code": "theorem gfp_const_inf_le (x : \u03b1) : gfp (const \u03b1 x \u2293 f) \u2264 x", "start": [187, 1], "end": [188, 46], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prevFixed", "code": "def prevFixed (x : \u03b1) (hx : f x \u2264 x) : fixedPoints f :=\n  \u27e8gfp (const \u03b1 x \u2293 f),\n    calc\n      f (gfp (const \u03b1 x \u2293 f)) = x \u2293 f (gfp (const \u03b1 x \u2293 f)) :=\n        Eq.symm <| inf_of_le_right <| (f.mono <| f.gfp_const_inf_le x).trans hx\n      _ = gfp (const \u03b1 x \u2293 f) := (const \u03b1 x \u2293 f).map_gfp\n      \u27e9", "start": [191, 1], "end": [200, 8], "kind": "commanddeclaration"}, {"full_name": "OrderHom.nextFixed", "code": "def nextFixed (x : \u03b1) (hx : x \u2264 f x) : fixedPoints f :=\n  { f.dual.prevFixed x hx with val := lfp (const \u03b1 x \u2294 f) }", "start": [203, 1], "end": [207, 60], "kind": "commanddeclaration"}, {"full_name": "OrderHom.prevFixed_le", "code": "theorem prevFixed_le {x : \u03b1} (hx : f x \u2264 x) : \u2191(f.prevFixed x hx) \u2264 x", "start": [210, 1], "end": [211, 23], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_nextFixed", "code": "theorem le_nextFixed {x : \u03b1} (hx : x \u2264 f x) : x \u2264 f.nextFixed x hx", "start": [214, 1], "end": [215, 25], "kind": "commanddeclaration"}, {"full_name": "OrderHom.nextFixed_le", "code": "theorem nextFixed_le {x : \u03b1} (hx : x \u2264 f x) {y : fixedPoints f} (h : x \u2264 y) :\n    f.nextFixed x hx \u2264 y", "start": [218, 1], "end": [220, 54], "kind": "commanddeclaration"}, {"full_name": "OrderHom.nextFixed_le_iff", "code": "@[simp]\ntheorem nextFixed_le_iff {x : \u03b1} (hx : x \u2264 f x) {y : fixedPoints f} :\n    f.nextFixed x hx \u2264 y \u2194 x \u2264 y", "start": [223, 1], "end": [226, 60], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_prevFixed_iff", "code": "@[simp]\ntheorem le_prevFixed_iff {x : \u03b1} (hx : f x \u2264 x) {y : fixedPoints f} :\n    y \u2264 f.prevFixed x hx \u2194 \u2191y \u2264 x", "start": [229, 1], "end": [232, 29], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_prevFixed", "code": "theorem le_prevFixed {x : \u03b1} (hx : f x \u2264 x) {y : fixedPoints f} (h : \u2191y \u2264 x) :\n    y \u2264 f.prevFixed x hx", "start": [235, 1], "end": [237, 30], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_map_sup_fixedPoints", "code": "theorem le_map_sup_fixedPoints (x y : fixedPoints f) : (x \u2294 y : \u03b1) \u2264 f (x \u2294 y)", "start": [240, 1], "end": [243, 43], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_inf_fixedPoints_le", "code": "theorem map_inf_fixedPoints_le (x y : fixedPoints f) : f (x \u2293 y) \u2264 x.val \u2293 y.val", "start": [247, 1], "end": [248, 36], "kind": "commanddeclaration"}, {"full_name": "OrderHom.le_map_sSup_subset_fixedPoints", "code": "theorem le_map_sSup_subset_fixedPoints (A : Set \u03b1) (hA : A \u2286 fixedPoints f) :\n    sSup A \u2264 f (sSup A)", "start": [251, 1], "end": [253, 53], "kind": "commanddeclaration"}, {"full_name": "OrderHom.map_sInf_subset_fixedPoints_le", "code": "theorem map_sInf_subset_fixedPoints_le (A : Set \u03b1) (hA : A \u2286 fixedPoints f) :\n    f (sInf A) \u2264 sInf A", "start": [256, 1], "end": [258, 53], "kind": "commanddeclaration"}, {"full_name": "fixedPoints.completeLattice", "code": "instance completeLattice : CompleteLattice (fixedPoints f) where\n  __ := inferInstanceAs (SemilatticeInf (fixedPoints f))\n  __ := inferInstanceAs (SemilatticeSup (fixedPoints f))\n  __ := inferInstanceAs (CompleteSemilatticeInf (fixedPoints f))\n  __ := inferInstanceAs (CompleteSemilatticeSup (fixedPoints f))\n  top := \u27e8gfp f, f.isFixedPt_gfp\u27e9\n  bot := \u27e8lfp f, f.isFixedPt_lfp\u27e9\n  le_top x := f.le_gfp x.2.ge\n  bot_le x := f.lfp_le x.2.le", "start": [307, 1], "end": [316, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ENat/Lattice.lean", "imports": ["Mathlib/Data/Nat/Lattice.lean", "Mathlib/Data/ENat/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ENat.iSup_coe_eq_top", "code": "lemma iSup_coe_eq_top : \u2a06 i, (f i : \u2115\u221e) = \u22a4 \u2194 \u00ac BddAbove (range f) := WithTop.iSup_coe_eq_top", "start": [30, 1], "end": [30, 94], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.iSup_coe_ne_top", "code": "lemma iSup_coe_ne_top : \u2a06 i, (f i : \u2115\u221e) \u2260 \u22a4 \u2194 BddAbove (range f) := iSup_coe_eq_top.not_left", "start": [31, 1], "end": [31, 93], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.iSup_coe_lt_top", "code": "lemma iSup_coe_lt_top : \u2a06 i, (f i : \u2115\u221e) < \u22a4 \u2194 BddAbove (range f) := WithTop.iSup_coe_lt_top", "start": [32, 1], "end": [32, 92], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.iInf_coe_eq_top", "code": "lemma iInf_coe_eq_top : \u2a05 i, (f i : \u2115\u221e) = \u22a4 \u2194 IsEmpty \u03b9 := WithTop.iInf_coe_eq_top", "start": [33, 1], "end": [33, 83], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.iInf_coe_ne_top", "code": "lemma iInf_coe_ne_top : \u2a05 i, (f i : \u2115\u221e) \u2260 \u22a4 \u2194 Nonempty \u03b9 := by\n  rw [Ne.def, iInf_coe_eq_top, not_isEmpty_iff]", "start": [34, 1], "end": [35, 48], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.iInf_coe_lt_top", "code": "lemma iInf_coe_lt_top : \u2a05 i, (f i : \u2115\u221e) < \u22a4 \u2194 Nonempty \u03b9 := WithTop.iInf_coe_lt_top", "start": [36, 1], "end": [36, 84], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.coe_sSup", "code": "lemma coe_sSup : BddAbove s \u2192 \u2191(sSup s) = \u2a06 a \u2208 s, (a : \u2115\u221e) := WithTop.coe_sSup", "start": [38, 1], "end": [38, 80], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.coe_sInf", "code": "lemma coe_sInf : s.Nonempty \u2192 \u2191(sInf s) = \u2a05 a \u2208 s, (a : \u2115\u221e) := WithTop.coe_sInf", "start": [39, 1], "end": [39, 80], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.coe_iSup", "code": "lemma coe_iSup : BddAbove (range f) \u2192 \u2191(\u2a06 i, f i) = \u2a06 i, (f i : \u2115\u221e) := WithTop.coe_iSup _", "start": [40, 1], "end": [40, 90], "kind": "mathlibtacticlemma"}, {"full_name": "ENat.coe_iInf", "code": "@[norm_cast] lemma coe_iInf [Nonempty \u03b9] : \u2191(\u2a05 i, f i) = \u2a05 i, (f i : \u2115\u221e) := WithTop.coe_iInf _", "start": [41, 1], "end": [41, 95], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/GroupTheory/Congruence.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "Mathlib/GroupTheory/Submonoid/Operations.lean", "Mathlib/Algebra/Group/Prod.lean", "Mathlib/Data/Setoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddCon", "code": "structure AddCon [Add M] extends Setoid M where\n  \n  add' : \u2200 {w x y z}, r w x \u2192 r y z \u2192 r (w + y) (x + z)", "start": [58, 1], "end": [62, 56], "kind": "commanddeclaration"}, {"full_name": "Con", "code": "@[to_additive AddCon]\nstructure Con [Mul M] extends Setoid M where\n  \n  mul' : \u2200 {w x y z}, r w x \u2192 r y z \u2192 r (w * y) (x * z)", "start": [65, 1], "end": [70, 56], "kind": "commanddeclaration"}, {"full_name": "AddConGen.Rel", "code": "inductive AddConGen.Rel [Add M] (r : M \u2192 M \u2192 Prop) : M \u2192 M \u2192 Prop\n  | of : \u2200 x y, r x y \u2192 AddConGen.Rel r x y\n  | refl : \u2200 x, AddConGen.Rel r x x\n  | symm : \u2200 {x y}, AddConGen.Rel r x y \u2192 AddConGen.Rel r y x\n  | trans : \u2200 {x y z}, AddConGen.Rel r x y \u2192 AddConGen.Rel r y z \u2192 AddConGen.Rel r x z\n  | add : \u2200 {w x y z}, AddConGen.Rel r w x \u2192 AddConGen.Rel r y z \u2192 AddConGen.Rel r (w + y) (x + z)", "start": [81, 1], "end": [88, 99], "kind": "commanddeclaration"}, {"full_name": "ConGen.Rel", "code": "@[to_additive AddConGen.Rel]\ninductive ConGen.Rel [Mul M] (r : M \u2192 M \u2192 Prop) : M \u2192 M \u2192 Prop\n  | of : \u2200 x y, r x y \u2192 ConGen.Rel r x y\n  | refl : \u2200 x, ConGen.Rel r x x\n  | symm : \u2200 {x y}, ConGen.Rel r x y \u2192 ConGen.Rel r y x\n  | trans : \u2200 {x y z}, ConGen.Rel r x y \u2192 ConGen.Rel r y z \u2192 ConGen.Rel r x z\n  | mul : \u2200 {w x y z}, ConGen.Rel r w x \u2192 ConGen.Rel r y z \u2192 ConGen.Rel r (w * y) (x * z)", "start": [91, 1], "end": [99, 90], "kind": "commanddeclaration"}, {"full_name": "conGen", "code": "@[to_additive addConGen \"The inductively defined smallest additive congruence relation containing\na given binary relation.\"]\ndef conGen [Mul M] (r : M \u2192 M \u2192 Prop) : Con M :=\n  \u27e8\u27e8ConGen.Rel r, \u27e8ConGen.Rel.refl, ConGen.Rel.symm, ConGen.Rel.trans\u27e9\u27e9, ConGen.Rel.mul\u27e9", "start": [102, 1], "end": [107, 89], "kind": "commanddeclaration"}, {"full_name": "Con.rel_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem rel_eq_coe (c : Con M) : c.r = c", "start": [132, 1], "end": [134, 6], "kind": "commanddeclaration"}, {"full_name": "Con.refl", "code": "@[to_additive \"Additive congruence relations are reflexive.\"]\nprotected theorem refl (x) : c x x", "start": [138, 1], "end": [141, 21], "kind": "commanddeclaration"}, {"full_name": "Con.symm", "code": "@[to_additive \"Additive congruence relations are symmetric.\"]\nprotected theorem symm {x y} : c x y \u2192 c y x", "start": [145, 1], "end": [147, 65], "kind": "commanddeclaration"}, {"full_name": "Con.trans", "code": "@[to_additive \"Additive congruence relations are transitive.\"]\nprotected theorem trans {x y z} : c x y \u2192 c y z \u2192 c x z", "start": [151, 1], "end": [153, 77], "kind": "commanddeclaration"}, {"full_name": "Con.mul", "code": "@[to_additive \"Additive congruence relations preserve addition.\"]\nprotected theorem mul {w x y z} : c w x \u2192 c y z \u2192 c (w * y) (x * z)", "start": [157, 1], "end": [159, 78], "kind": "commanddeclaration"}, {"full_name": "Con.rel_mk", "code": "@[to_additive (attr := simp)]\ntheorem rel_mk {s : Setoid M} {h a b} : Con.mk s h a b \u2194 r a b", "start": [163, 1], "end": [165, 10], "kind": "commanddeclaration"}, {"full_name": "Con.ext'", "code": "@[to_additive \"The map sending an additive congruence relation to its underlying binary relation\nis injective.\"]\ntheorem ext' {c d : Con M} (H : c.r = d.r) : c = d", "start": [178, 1], "end": [185, 8], "kind": "commanddeclaration"}, {"full_name": "Con.ext", "code": "@[to_additive (attr := ext) \"Extensionality rule for additive congruence relations.\"]\ntheorem ext {c d : Con M} (H : \u2200 x y, c x y \u2194 d x y) : c = d", "start": [189, 1], "end": [192, 26], "kind": "commanddeclaration"}, {"full_name": "Con.toSetoid_inj", "code": "@[to_additive \"The map sending an additive congruence relation to its underlying equivalence\nrelation is injective.\"]\ntheorem toSetoid_inj {c d : Con M} (H : c.toSetoid = d.toSetoid) : c = d", "start": [196, 1], "end": [200, 21], "kind": "commanddeclaration"}, {"full_name": "Con.ext_iff", "code": "@[to_additive \"Iff version of extensionality rule for additive congruence relations.\"]\ntheorem ext_iff {c d : Con M} : (\u2200 x y, c x y \u2194 d x y) \u2194 c = d", "start": [204, 1], "end": [207, 34], "kind": "commanddeclaration"}, {"full_name": "Con.ext'_iff", "code": "@[to_additive \"Two additive congruence relations are equal iff their underlying binary relations\nare equal.\"]\ntheorem ext'_iff {c d : Con M} : c.r = d.r \u2194 c = d", "start": [211, 1], "end": [215, 27], "kind": "commanddeclaration"}, {"full_name": "Con.mulKer", "code": "@[to_additive \"The kernel of an addition-preserving function as an additive congruence relation.\"]\ndef mulKer (f : M \u2192 P) (h : \u2200 x y, f (x * y) = f x * f y) : Con M\n    where\n  toSetoid := Setoid.ker f\n  mul' h1 h2 := by\n    dsimp [Setoid.ker, onFun] at *\n    rw [h, h1, h2, h]", "start": [219, 1], "end": [226, 22], "kind": "commanddeclaration"}, {"full_name": "Con.prod", "code": "@[to_additive prod \"Given types with additions `M, N`, the product of two congruence relations\n`c` on `M` and `d` on `N`: `(x\u2081, x\u2082), (y\u2081, y\u2082) \u2208 M \u00d7 N` are related by `c.prod d` iff `x\u2081`\nis related to `y\u2081` by `c` and `x\u2082` is related to `y\u2082` by `d`.\"]\nprotected def prod (c : Con M) (d : Con N) : Con (M \u00d7 N) :=\n  { c.toSetoid.prod d.toSetoid with\n    mul' := fun h1 h2 => \u27e8c.mul h1.1 h2.1, d.mul h1.2 h2.2\u27e9 }", "start": [230, 1], "end": [238, 62], "kind": "commanddeclaration"}, {"full_name": "Con.pi", "code": "@[to_additive \"The product of an indexed collection of additive congruence relations.\"]\ndef pi {\u03b9 : Type*} {f : \u03b9 \u2192 Type*} [\u2200 i, Mul (f i)] (C : \u2200 i, Con (f i)) : Con (\u2200 i, f i) :=\n  { @piSetoid _ _ fun i => (C i).toSetoid with\n    mul' := fun h1 h2 i => (C i).mul (h1 i) (h2 i) }", "start": [242, 1], "end": [246, 53], "kind": "commanddeclaration"}, {"full_name": "Con.Quotient", "code": "@[to_additive \"Defining the quotient by an additive congruence relation of a type with\nan addition.\"]\nprotected def Quotient :=\n  Quotient c.toSetoid", "start": [253, 1], "end": [257, 22], "kind": "commanddeclaration"}, {"full_name": "Con.toQuotient", "code": "@[to_additive (attr := coe) \"The morphism into the quotient by an additive congruence relation\"]\ndef toQuotient : M \u2192 c.Quotient :=\n  Quotient.mk''", "start": [264, 1], "end": [267, 16], "kind": "commanddeclaration"}, {"full_name": "Con.quot_mk_eq_coe", "code": "@[to_additive (attr := simp)]\ntheorem quot_mk_eq_coe {M : Type*} [Mul M] (c : Con M) (x : M) : Quot.mk c x = (x : c.Quotient)", "start": [286, 1], "end": [288, 6], "kind": "commanddeclaration"}, {"full_name": "Con.liftOn", "code": "@[to_additive \"The function on the quotient by a congruence relation `c`\ninduced by a function that is constant on `c`'s equivalence classes.\"]\nprotected def liftOn {\u03b2} {c : Con M} (q : c.Quotient) (f : M \u2192 \u03b2) (h : \u2200 a b, c a b \u2192 f a = f b) :\n    \u03b2 :=\n  Quotient.liftOn' q f h", "start": [293, 1], "end": [299, 25], "kind": "commanddeclaration"}, {"full_name": "Con.liftOn\u2082", "code": "@[to_additive \"The binary function on the quotient by a congruence relation `c`\ninduced by a binary function that is constant on `c`'s equivalence classes.\"]\nprotected def liftOn\u2082 {\u03b2} {c : Con M} (q r : c.Quotient) (f : M \u2192 M \u2192 \u03b2)\n    (h : \u2200 a\u2081 a\u2082 b\u2081 b\u2082, c a\u2081 b\u2081 \u2192 c a\u2082 b\u2082 \u2192 f a\u2081 a\u2082 = f b\u2081 b\u2082) : \u03b2 :=\n  Quotient.liftOn\u2082' q r f h", "start": [304, 1], "end": [310, 28], "kind": "commanddeclaration"}, {"full_name": "Con.hrecOn\u2082", "code": "@[to_additive \"A version of `Quotient.hrecOn\u2082'` for quotients by `AddCon`.\"]\nprotected def hrecOn\u2082 {cM : Con M} {cN : Con N} {\u03c6 : cM.Quotient \u2192 cN.Quotient \u2192 Sort*}\n    (a : cM.Quotient) (b : cN.Quotient) (f : \u2200 (x : M) (y : N), \u03c6 x y)\n    (h : \u2200 x y x' y', cM x x' \u2192 cN y y' \u2192 HEq (f x y) (f x' y')) : \u03c6 a b :=\n  Quotient.hrecOn\u2082' a b f h", "start": [314, 1], "end": [319, 28], "kind": "commanddeclaration"}, {"full_name": "Con.hrec_on\u2082_coe", "code": "@[to_additive (attr := simp)]\ntheorem hrec_on\u2082_coe {cM : Con M} {cN : Con N} {\u03c6 : cM.Quotient \u2192 cN.Quotient \u2192 Sort*} (a : M)\n    (b : N) (f : \u2200 (x : M) (y : N), \u03c6 x y)\n    (h : \u2200 x y x' y', cM x x' \u2192 cN y y' \u2192 HEq (f x y) (f x' y')) :\n    Con.hrecOn\u2082 (\u2191a) (\u2191b) f h = f a b", "start": [323, 1], "end": [328, 6], "kind": "commanddeclaration"}, {"full_name": "Con.induction_on", "code": "@[to_additive (attr := elab_as_elim) \"The inductive principle used to prove propositions about\nthe elements of a quotient by an additive congruence relation.\"]\nprotected theorem induction_on {C : c.Quotient \u2192 Prop} (q : c.Quotient) (H : \u2200 x : M, C x) : C q", "start": [334, 1], "end": [339, 28], "kind": "commanddeclaration"}, {"full_name": "Con.induction_on\u2082", "code": "@[to_additive (attr := elab_as_elim) \"A version of `AddCon.induction_on` for predicates which take\ntwo arguments.\"]\nprotected theorem induction_on\u2082 {d : Con N} {C : c.Quotient \u2192 d.Quotient \u2192 Prop} (p : c.Quotient)\n    (q : d.Quotient) (H : \u2200 (x : M) (y : N), C x y) : C p q", "start": [343, 1], "end": [348, 31], "kind": "commanddeclaration"}, {"full_name": "Con.eq", "code": "@[to_additive (attr := simp) \"Two elements are related by an additive congruence relation `c` iff\nthey are represented by the same element of the quotient by `c`.\"]\nprotected theorem eq {a b : M} : (a : c.Quotient) = (b : c.Quotient) \u2194 c a b", "start": [354, 1], "end": [359, 16], "kind": "commanddeclaration"}, {"full_name": "Con.hasMul", "code": "@[to_additive \"The addition induced on the quotient by an additive congruence relation on a type\nwith an addition.\"]\ninstance hasMul : Mul c.Quotient :=\n  \u27e8Quotient.map\u2082' (\u00b7 * \u00b7) fun _ _ h1 _ _ h2 => c.mul h1 h2\u27e9", "start": [363, 1], "end": [368, 60], "kind": "commanddeclaration"}, {"full_name": "Con.mul_ker_mk_eq", "code": "@[to_additive (attr := simp) \"The kernel of the quotient map induced by an additive congruence\nrelation `c` equals `c`.\"]\ntheorem mul_ker_mk_eq : (mulKer ((\u2191) : M \u2192 c.Quotient) fun _ _ => rfl) = c", "start": [372, 1], "end": [376, 31], "kind": "commanddeclaration"}, {"full_name": "Con.coe_mul", "code": "@[to_additive (attr := simp) \"The coercion to the quotient of an additive congruence relation\ncommutes with addition (by definition).\"]\ntheorem coe_mul (x y : M) : (\u2191(x * y) : c.Quotient) = \u2191x * \u2191y", "start": [382, 1], "end": [387, 6], "kind": "commanddeclaration"}, {"full_name": "Con.liftOn_coe", "code": "@[to_additive (attr := simp) \"Definition of the function on the quotient by an additive congruence\nrelation `c` induced by a function that is constant on `c`'s equivalence classes.\"]\nprotected theorem liftOn_coe {\u03b2} (c : Con M) (f : M \u2192 \u03b2) (h : \u2200 a b, c a b \u2192 f a = f b) (x : M) :\n    Con.liftOn (x : c.Quotient) f h = f x", "start": [391, 1], "end": [397, 6], "kind": "commanddeclaration"}, {"full_name": "Con.congr", "code": "@[to_additive \"Makes an additive isomorphism of quotients by two additive congruence relations,\ngiven that the relations are equal.\"]\nprotected def congr {c d : Con M} (h : c = d) : c.Quotient \u2243* d.Quotient :=\n  { Quotient.congr (Equiv.refl M) <| by apply ext_iff.2 h with\n    map_mul' := fun x y => by rcases x with \u27e8\u27e9; rcases y with \u27e8\u27e9; rfl }", "start": [401, 1], "end": [407, 72], "kind": "commanddeclaration"}, {"full_name": "Con.le_def", "code": "@[to_additive \"Definition of `\u2264` for additive congruence relations.\"]\ntheorem le_def {c d : Con M} : c \u2264 d \u2194 \u2200 {x y}, c x y \u2192 d x y", "start": [419, 1], "end": [422, 10], "kind": "commanddeclaration"}, {"full_name": "Con.sInf_toSetoid", "code": "@[to_additive \"The infimum of a set of additive congruence relations is the same as the infimum of\nthe set's image under the map to the underlying equivalence relation.\"]\ntheorem sInf_toSetoid (S : Set (Con M)) : (sInf S).toSetoid = sInf (toSetoid '' S)", "start": [436, 1], "end": [442, 97], "kind": "commanddeclaration"}, {"full_name": "Con.sInf_def", "code": "@[to_additive \"The infimum of a set of additive congruence relations is the same as the infimum\nof the set's image under the map to the underlying binary relation.\"]\ntheorem sInf_def (S : Set (Con M)) :\n    \u21d1(sInf S) = sInf (@Set.image (Con M) (M \u2192 M \u2192 Prop) (\u2191) S)", "start": [446, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "Con.inf_def", "code": "@[to_additive \"The infimum of two additive congruence relations equals the infimum of the\nunderlying binary operations.\"]\ntheorem inf_def {c d : Con M} : (c \u2293 d).r = c.r \u2293 d.r", "start": [485, 1], "end": [490, 6], "kind": "commanddeclaration"}, {"full_name": "Con.inf_iff_and", "code": "@[to_additive \"Definition of the infimum of two additive congruence relations.\"]\ntheorem inf_iff_and {c d : Con M} {x y} : (c \u2293 d) x y \u2194 c x y \u2227 d x y", "start": [494, 1], "end": [497, 10], "kind": "commanddeclaration"}, {"full_name": "Con.conGen_eq", "code": "@[to_additive addConGen_eq \"The inductively defined smallest additive congruence relation\ncontaining a binary relation `r` equals the infimum of the set of additive congruence relations\ncontaining `r`.\"]\ntheorem conGen_eq (r : M \u2192 M \u2192 Prop) : conGen r = sInf { s : Con M | \u2200 x y, r x y \u2192 s x y }", "start": [501, 1], "end": [516, 28], "kind": "commanddeclaration"}, {"full_name": "Con.conGen_le", "code": "@[to_additive addConGen_le \"The smallest additive congruence relation containing a binary\nrelation `r` is contained in any additive congruence relation containing `r`.\"]\ntheorem conGen_le {r : M \u2192 M \u2192 Prop} {c : Con M} (h : \u2200 x y, r x y \u2192 @Setoid.r _ c.toSetoid x y) :\n    conGen r \u2264 c", "start": [520, 1], "end": [525, 55], "kind": "commanddeclaration"}, {"full_name": "Con.conGen_mono", "code": "@[to_additive addConGen_mono \"Given binary relations `r, s` with `r` contained in `s`, the\nsmallest additive congruence relation containing `s` contains the smallest additive congruence\nrelation containing `r`.\"]\ntheorem conGen_mono {r s : M \u2192 M \u2192 Prop} (h : \u2200 x y, r x y \u2192 s x y) : conGen r \u2264 conGen s", "start": [529, 1], "end": [535, 56], "kind": "commanddeclaration"}, {"full_name": "Con.conGen_of_con", "code": "@[to_additive (attr := simp) addConGen_of_addCon \"Additive congruence relations equal the smallest\nadditive congruence relation in which they are contained.\"]\ntheorem conGen_of_con (c : Con M) : conGen c = c", "start": [539, 1], "end": [543, 77], "kind": "commanddeclaration"}, {"full_name": "Con.conGen_idem", "code": "@[to_additive addConGen_idem \"The map sending a binary relation to the smallest additive\ncongruence relation in which it is contained is idempotent.\"]\ntheorem conGen_idem (r : M \u2192 M \u2192 Prop) : conGen (conGen r) = conGen r", "start": [549, 1], "end": [554, 18], "kind": "commanddeclaration"}, {"full_name": "Con.sup_eq_conGen", "code": "@[to_additive sup_eq_addConGen \"The supremum of additive congruence relations `c, d` equals the\nsmallest additive congruence relation containing the binary relation '`x` is related to `y`\nby `c` or `d`'.\"]\ntheorem sup_eq_conGen (c d : Con M) : c \u2294 d = conGen fun x y => c x y \u2228 d x y", "start": [558, 1], "end": [566, 43], "kind": "commanddeclaration"}, {"full_name": "Con.sup_def", "code": "@[to_additive \"The supremum of two additive congruence relations equals the smallest additive\ncongruence relation containing the supremum of the underlying binary operations.\"]\ntheorem sup_def {c d : Con M} : c \u2294 d = conGen (c.r \u2294 d.r)", "start": [570, 1], "end": [574, 89], "kind": "commanddeclaration"}, {"full_name": "Con.sSup_eq_conGen", "code": "@[to_additive sSup_eq_addConGen \"The supremum of a set of additive congruence relations `S` equals\nthe smallest additive congruence relation containing the binary relation 'there exists `c \u2208 S`\nsuch that `x` is related to `y` by `c`'.\"]\ntheorem sSup_eq_conGen (S : Set (Con M)) :\n    sSup S = conGen fun x y => \u2203 c : Con M, c \u2208 S \u2227 c x y", "start": [578, 1], "end": [589, 83], "kind": "commanddeclaration"}, {"full_name": "Con.sSup_def", "code": "@[to_additive \"The supremum of a set of additive congruence relations is the same as the smallest\nadditive congruence relation containing the supremum of the set's image under the map to the\nunderlying binary relation.\"]\ntheorem sSup_def {S : Set (Con M)} :\n    sSup S = conGen (sSup (@Set.image (Con M) (M \u2192 M \u2192 Prop) ((\u21d1) : Con M \u2192 M \u2192 M \u2192 Prop) S))", "start": [593, 1], "end": [602, 76], "kind": "commanddeclaration"}, {"full_name": "Con.gi", "code": "@[to_additive \"There is a Galois insertion of additive congruence relations on a type with\nan addition `M` into binary relations on `M`.\"]\nprotected def gi : @GaloisInsertion (M \u2192 M \u2192 Prop) (Con M) _ _ conGen FunLike.coe\n    where\n  choice r _ := conGen r\n  gc _ c := \u27e8fun H _ _ h => H <| ConGen.Rel.of _ _ h, @fun H => conGen_of_con c \u25b8 conGen_mono H\u27e9\n  le_l_u x := (conGen_of_con x).symm \u25b8 le_refl x\n  choice_eq _ _ := rfl", "start": [608, 1], "end": [617, 23], "kind": "commanddeclaration"}, {"full_name": "Con.mapGen", "code": "@[to_additive \"Given a function `f`, the smallest additive congruence relation containing the\nbinary relation on `f`'s image defined by '`x \u2248 y` iff the elements of `f\u207b\u00b9(x)` are related to the\nelements of `f\u207b\u00b9(y)` by an additive congruence relation `c`.'\"]\ndef mapGen (f : M \u2192 N) : Con N :=\n  conGen fun x y => \u2203 a b, f a = x \u2227 f b = y \u2227 c a b", "start": [623, 1], "end": [630, 53], "kind": "commanddeclaration"}, {"full_name": "Con.mapOfSurjective", "code": "@[to_additive \"Given a surjective addition-preserving function `f` whose kernel is contained in\nan additive congruence relation `c`, the additive congruence relation on `f`'s codomain defined\nby '`x \u2248 y` iff the elements of `f\u207b\u00b9(x)` are related to the elements of `f\u207b\u00b9(y)` by `c`.'\"]\ndef mapOfSurjective (f : M \u2192 N) (H : \u2200 x y, f (x * y) = f x * f y) (h : mulKer f H \u2264 c)\n    (hf : Surjective f) : Con N :=\n  { c.toSetoid.mapOfSurjective f h hf with\n    mul' := fun h\u2081 h\u2082 => by\n      rcases h\u2081 with \u27e8a, b, rfl, rfl, h1\u27e9\n      rcases h\u2082 with \u27e8p, q, rfl, rfl, h2\u27e9\n      exact \u27e8a * p, b * q, by rw [H], by rw [H], c.mul h1 h2\u27e9 }", "start": [634, 1], "end": [646, 64], "kind": "commanddeclaration"}, {"full_name": "Con.mapOfSurjective_eq_mapGen", "code": "@[to_additive \"A specialization of 'the smallest additive congruence relation containing\nan additive congruence relation `c` equals `c`'.\"]\ntheorem mapOfSurjective_eq_mapGen {c : Con M} {f : M \u2192 N} (H : \u2200 x y, f (x * y) = f x * f y)\n    (h : mulKer f H \u2264 c) (hf : Surjective f) : c.mapGen f = c.mapOfSurjective f H h hf", "start": [650, 1], "end": [656, 57], "kind": "commanddeclaration"}, {"full_name": "Con.comap", "code": "@[to_additive \"Given types with additions `M, N` and an additive congruence relation `c` on `N`,\nan addition-preserving map `f : M \u2192 N` induces an additive congruence relation on `f`'s domain\ndefined by '`x \u2248 y` iff `f(x)` is related to `f(y)` by `c`.' \"]\ndef comap (f : M \u2192 N) (H : \u2200 x y, f (x * y) = f x * f y) (c : Con N) : Con M :=\n  { c.toSetoid.comap f with\n    mul' := @fun w x y z h1 h2 => show c (f (w * y)) (f (x * z)) by rw [H, H]; exact c.mul h1 h2 }", "start": [660, 1], "end": [668, 99], "kind": "commanddeclaration"}, {"full_name": "Con.comap_rel", "code": "@[to_additive (attr := simp)]\ntheorem comap_rel {f : M \u2192 N} (H : \u2200 x y, f (x * y) = f x * f y) {c : Con N} {x y : M} :\n    comap f H c x y \u2194 c (f x) (f y)", "start": [672, 1], "end": [675, 10], "kind": "commanddeclaration"}, {"full_name": "Con.correspondence", "code": "@[to_additive \"Given an additive congruence relation `c` on a type `M` with an addition,\nthe order-preserving bijection between the set of additive congruence relations containing `c` and\nthe additive congruence relations on the quotient of `M` by `c`.\"]\ndef correspondence : { d // c \u2264 d } \u2243o Con c.Quotient\n    where\n  toFun d :=\n    d.1.mapOfSurjective (\u2191) _ (by rw [mul_ker_mk_eq]; exact d.2) <| @exists_rep _ c.toSetoid\n  invFun d :=\n    \u27e8comap ((\u2191) : M \u2192 c.Quotient) (fun x y => rfl) d, fun x y h =>\n      show d x y by rw [c.eq.2 h]; exact d.refl _\u27e9\n  left_inv d :=\n    by exact\n      Subtype.ext_iff_val.2 <|\n        ext fun x y =>\n          \u27e8fun h =>\n            let \u27e8a, b, hx, hy, H\u27e9 := h\n            d.1.trans (d.1.symm <| d.2 <| c.eq.1 hx) <| d.1.trans H <| d.2 <| c.eq.1 hy,\n            fun h => \u27e8_, _, rfl, rfl, h\u27e9\u27e9\n  right_inv d :=\n    by exact\n      ext fun x y =>\n        \u27e8fun h =>\n          let \u27e8_, _, hx, hy, H\u27e9 := h\n          hx \u25b8 hy \u25b8 H,\n          Con.induction_on\u2082 x y fun w z h => \u27e8w, z, rfl, rfl, h\u27e9\u27e9\n  map_rel_iff' := @fun s t => by\n    constructor\n    \u00b7 intros h x y hs\n      rcases h \u27e8x, y, rfl, rfl, hs\u27e9 with \u27e8a, b, hx, hy, ht\u27e9\n      exact t.1.trans (t.1.symm <| t.2 <| eq_rel.1 hx) (t.1.trans ht (t.2 <| eq_rel.1 hy))\n    \u00b7 intros h _ _ hs\n      rcases hs with \u27e8a, b, hx, hy, Hs\u27e9\n      exact \u27e8a, b, hx, hy, h Hs\u27e9", "start": [683, 1], "end": [720, 33], "kind": "commanddeclaration"}, {"full_name": "Con.mulOneClass", "code": "@[to_additive \"The quotient of an `AddMonoid` by an additive congruence relation is\nan `AddMonoid`.\"]\ninstance mulOneClass : MulOneClass c.Quotient where\n  one := ((1 : M) : c.Quotient)\n  mul_one x := Quotient.inductionOn' x fun _ => congr_arg ((\u2191) : M \u2192 c.Quotient) <| mul_one _\n  one_mul x := Quotient.inductionOn' x fun _ => congr_arg ((\u2191) : M \u2192 c.Quotient) <| one_mul _", "start": [732, 1], "end": [738, 94], "kind": "commanddeclaration"}, {"full_name": "Con.coe_one", "code": "@[to_additive (attr := simp) \"The 0 of the quotient of an `AddMonoid` by an additive congruence\nrelation is the equivalence class of the `AddMonoid`'s 0.\"]\ntheorem coe_one : ((1 : M) : c.Quotient) = 1", "start": [744, 1], "end": [749, 6], "kind": "commanddeclaration"}, {"full_name": "Con.submonoid", "code": "@[to_additive (attr := coe) \"The `AddSubmonoid` of `M \u00d7 M` defined by an additive congruence\nrelation on an `AddMonoid` `M`.\"]\nprotected def submonoid : Submonoid (M \u00d7 M)\n    where\n  carrier := { x | c x.1 x.2 }\n  one_mem' := c.iseqv.1 1\n  mul_mem' := c.mul", "start": [756, 1], "end": [763, 20], "kind": "commanddeclaration"}, {"full_name": "Con.ofSubmonoid", "code": "@[to_additive \"The additive congruence relation on an `AddMonoid` `M` from\nan `add_submonoid` of `M \u00d7 M` for which membership is an equivalence relation.\"]\ndef ofSubmonoid (N : Submonoid (M \u00d7 M)) (H : Equivalence fun x y => (x, y) \u2208 N) : Con M\n    where\n  r x y := (x, y) \u2208 N\n  iseqv := H\n  mul' := N.mul_mem", "start": [769, 1], "end": [777, 20], "kind": "commanddeclaration"}, {"full_name": "Con.toSubmonoid", "code": "@[to_additive \"Coercion from a congruence relation `c` on an `AddMonoid` `M`\nto the `add_submonoid` of `M \u00d7 M` whose elements are `(x, y)` such that `x`\nis related to `y` by `c`.\"]\ninstance toSubmonoid : Coe (Con M) (Submonoid (M \u00d7 M)) :=\n  \u27e8fun c => c.submonoid\u27e9", "start": [781, 1], "end": [787, 25], "kind": "commanddeclaration"}, {"full_name": "Con.mem_coe", "code": "@[to_additive]\ntheorem mem_coe {c : Con M} {x y} : (x, y) \u2208 (\u2191c : Submonoid (M \u00d7 M)) \u2194 (x, y) \u2208 c", "start": [791, 1], "end": [793, 10], "kind": "commanddeclaration"}, {"full_name": "Con.to_submonoid_inj", "code": "@[to_additive]\ntheorem to_submonoid_inj (c d : Con M) (H : (c : Submonoid (M \u00d7 M)) = d) : c = d", "start": [797, 1], "end": [799, 76], "kind": "commanddeclaration"}, {"full_name": "Con.le_iff", "code": "@[to_additive]\ntheorem le_iff {c d : Con M} : c \u2264 d \u2194 (c : Submonoid (M \u00d7 M)) \u2264 d", "start": [803, 1], "end": [805, 67], "kind": "commanddeclaration"}, {"full_name": "Con.ker", "code": "@[to_additive \"The kernel of an `AddMonoid` homomorphism as an additive congruence relation.\"]\ndef ker (f : M \u2192* P) : Con M :=\n  mulKer f (map_mul f)", "start": [809, 1], "end": [812, 23], "kind": "commanddeclaration"}, {"full_name": "Con.ker_rel", "code": "@[to_additive (attr := simp) \"The definition of the additive congruence relation defined by an\n`AddMonoid` homomorphism's kernel.\"]\ntheorem ker_rel (f : M \u2192* P) {x y} : ker f x y \u2194 f x = f y", "start": [816, 1], "end": [820, 10], "kind": "commanddeclaration"}, {"full_name": "Con.Quotient.inhabited", "code": "@[to_additive \"There exists an element of the quotient of an `AddMonoid` by a congruence relation\n(namely 0).\"]\ninstance Quotient.inhabited : Inhabited c.Quotient :=\n  \u27e8((1 : M) : c.Quotient)\u27e9", "start": [824, 1], "end": [828, 27], "kind": "commanddeclaration"}, {"full_name": "Con.mk'", "code": "@[to_additive \"The natural homomorphism from an `AddMonoid` to its quotient by an additive\ncongruence relation.\"]\ndef mk' : M \u2192* c.Quotient :=\n  { toFun := (\u2191)\n    map_one' := rfl\n    map_mul' := fun _ _ => rfl }", "start": [834, 1], "end": [840, 33], "kind": "commanddeclaration"}, {"full_name": "Con.mk'_ker", "code": "@[to_additive (attr := simp) \"The kernel of the natural homomorphism from an `AddMonoid` to its\nquotient by an additive congruence relation `c` equals `c`.\"]\ntheorem mk'_ker : ker c.mk' = c", "start": [846, 1], "end": [851, 22], "kind": "commanddeclaration"}, {"full_name": "Con.mk'_surjective", "code": "@[to_additive \"The natural homomorphism from an `AddMonoid` to its quotient by a congruence\nrelation is surjective.\"]\ntheorem mk'_surjective : Surjective c.mk'", "start": [857, 1], "end": [862, 36], "kind": "commanddeclaration"}, {"full_name": "Con.coe_mk'", "code": "@[to_additive (attr := simp)]\ntheorem coe_mk' : (c.mk' : M \u2192 c.Quotient) = ((\u2191) : M \u2192 c.Quotient)", "start": [866, 1], "end": [868, 6], "kind": "commanddeclaration"}, {"full_name": "Con.mrange_mk'", "code": "@[to_additive (attr := simp)]\ntheorem mrange_mk' : MonoidHom.mrange c.mk' = \u22a4", "start": [872, 1], "end": [875, 55], "kind": "commanddeclaration"}, {"full_name": "Con.ker_apply", "code": "@[to_additive]\ntheorem ker_apply {f : M \u2192* P} {x y} : ker f x y \u2194 f x = f y", "start": [880, 1], "end": [881, 72], "kind": "commanddeclaration"}, {"full_name": "Con.comap_eq", "code": "@[to_additive \"Given an `AddMonoid` homomorphism `f : N \u2192 M` and an additive congruence relation\n`c` on `M`, the additive congruence relation induced on `N` by `f` equals the kernel of `c`'s\nquotient homomorphism composed with `f`.\"]\ntheorem comap_eq {f : N \u2192* M} : comap f f.map_mul c = ker (c.mk'.comp f)", "start": [885, 1], "end": [892, 68], "kind": "commanddeclaration"}, {"full_name": "Con.lift", "code": "@[to_additive \"The homomorphism on the quotient of an `AddMonoid` by an additive congruence\nrelation `c` induced by a homomorphism constant on `c`'s equivalence classes.\"]\ndef lift (H : c \u2264 ker f) : c.Quotient \u2192* P\n    where\n  toFun x := (Con.liftOn x f) fun _ _ h => H h\n  map_one' := by rw [\u2190 f.map_one]; rfl\n  map_mul' x y := Con.induction_on\u2082 x y fun m n => by\n    dsimp only [\u2190 coe_mul, Con.liftOn_coe]\n    rw [map_mul]", "start": [898, 1], "end": [908, 17], "kind": "commanddeclaration"}, {"full_name": "Con.lift_mk'", "code": "@[to_additive \"The diagram describing the universal property for quotients of `AddMonoid`s\ncommutes.\"]\ntheorem lift_mk' (H : c \u2264 ker f) (x) : c.lift f H (c.mk' x) = f x", "start": [914, 1], "end": [918, 6], "kind": "commanddeclaration"}, {"full_name": "Con.lift_coe", "code": "@[to_additive (attr := simp) \"The diagram describing the universal property for quotients of\n`AddMonoid`s commutes.\"]\ntheorem lift_coe (H : c \u2264 ker f) (x : M) : c.lift f H x = f x", "start": [922, 1], "end": [926, 6], "kind": "commanddeclaration"}, {"full_name": "Con.lift_comp_mk'", "code": "@[to_additive (attr := simp) \"The diagram describing the universal property for quotients of\n`AddMonoid`s commutes.\"]\ntheorem lift_comp_mk' (H : c \u2264 ker f) : (c.lift f H).comp c.mk' = f", "start": [930, 1], "end": [933, 83], "kind": "commanddeclaration"}, {"full_name": "Con.lift_apply_mk'", "code": "@[to_additive (attr := simp) \"Given a homomorphism `f` from the quotient of an `AddMonoid` by an\nadditive congruence relation, `f` equals the homomorphism on the quotient induced by `f` composed\nwith the natural map from the `AddMonoid` to the quotient.\"]\ntheorem lift_apply_mk' (f : c.Quotient \u2192* P) :\n    (c.lift (f.comp c.mk') fun x y h => show f \u2191x = f \u2191y by rw [c.eq.2 h]) = f", "start": [937, 1], "end": [945, 31], "kind": "commanddeclaration"}, {"full_name": "Con.lift_funext", "code": "@[to_additive \"Homomorphisms on the quotient of an `AddMonoid` by an additive congruence relation\nare equal if they are equal on elements that are coercions from the `AddMonoid`.\"]\ntheorem lift_funext (f g : c.Quotient \u2192* P) (h : \u2200 a : M, f a = g a) : f = g", "start": [949, 1], "end": [956, 28], "kind": "commanddeclaration"}, {"full_name": "Con.lift_unique", "code": "@[to_additive \"The uniqueness part of the universal property for quotients of `AddMonoid`s.\"]\ntheorem lift_unique (H : c \u2264 ker f) (g : c.Quotient \u2192* P) (Hg : g.comp c.mk' = f) :\n    g = c.lift f H", "start": [960, 1], "end": [966, 8], "kind": "commanddeclaration"}, {"full_name": "Con.lift_range", "code": "@[to_additive \"Given an additive congruence relation `c` on an `AddMonoid` and a homomorphism `f`\nconstant on `c`'s equivalence classes, `f` has the same image as the homomorphism that `f` induces\non the quotient.\"]\ntheorem lift_range (H : c \u2264 ker f) : MonoidHom.mrange (c.lift f H) = MonoidHom.mrange f", "start": [970, 1], "end": [977, 87], "kind": "commanddeclaration"}, {"full_name": "Con.lift_surjective_of_surjective", "code": "@[to_additive \"Surjective `AddMonoid` homomorphisms constant on an additive congruence\nrelation `c`'s equivalence classes induce a surjective homomorphism on `c`'s quotient.\"]\ntheorem lift_surjective_of_surjective (h : c \u2264 ker f) (hf : Surjective f) :\n    Surjective (c.lift f h)", "start": [981, 1], "end": [987, 65], "kind": "commanddeclaration"}, {"full_name": "Con.ker_eq_lift_of_injective", "code": "@[to_additive \"Given an `AddMonoid` homomorphism `f` from `M` to `P`, the kernel of `f`\nis the unique additive congruence relation on `M` whose induced map from the quotient of `M`\nto `P` is injective.\"]\ntheorem ker_eq_lift_of_injective (H : c \u2264 ker f) (h : Injective (c.lift f H)) : ker f = c", "start": [993, 1], "end": [999, 56], "kind": "commanddeclaration"}, {"full_name": "Con.kerLift", "code": "@[to_additive \"The homomorphism induced on the quotient of an `AddMonoid` by the kernel\nof an `AddMonoid` homomorphism.\"]\ndef kerLift : (ker f).Quotient \u2192* P :=\n  ((ker f).lift f) fun _ _ => id", "start": [1005, 1], "end": [1009, 33], "kind": "commanddeclaration"}, {"full_name": "Con.kerLift_mk", "code": "@[to_additive (attr := simp) \"The diagram described by the universal property for quotients\nof `AddMonoid`s, when the additive congruence relation is the kernel of the homomorphism,\ncommutes.\"]\ntheorem kerLift_mk (x : M) : kerLift f x = f x", "start": [1015, 1], "end": [1021, 6], "kind": "commanddeclaration"}, {"full_name": "Con.kerLift_range_eq", "code": "@[to_additive (attr := simp) \"Given an `AddMonoid` homomorphism `f`, the induced homomorphism\non the quotient by `f`'s kernel has the same image as `f`.\"]\ntheorem kerLift_range_eq : MonoidHom.mrange (kerLift f) = MonoidHom.mrange f", "start": [1025, 1], "end": [1030, 27], "kind": "commanddeclaration"}, {"full_name": "Con.kerLift_injective", "code": "@[to_additive \"An `AddMonoid` homomorphism `f` induces an injective homomorphism on the quotient\nby `f`'s kernel.\"]\ntheorem kerLift_injective (f : M \u2192* P) : Injective (kerLift f)", "start": [1034, 1], "end": [1038, 53], "kind": "commanddeclaration"}, {"full_name": "Con.map", "code": "@[to_additive \"Given additive congruence relations `c, d` on an `AddMonoid` such that `d`\ncontains `c`, `d`'s quotient map induces a homomorphism from the quotient by `c` to the quotient\nby `d`.\"]\ndef map (c d : Con M) (h : c \u2264 d) : c.Quotient \u2192* d.Quotient :=\n  (c.lift d.mk') fun x y hc => show (ker d.mk') x y from (mk'_ker d).symm \u25b8 h hc", "start": [1042, 1], "end": [1048, 81], "kind": "commanddeclaration"}, {"full_name": "Con.map_apply", "code": "@[to_additive \"Given additive congruence relations `c, d` on an `AddMonoid` such that `d`\ncontains `c`, the definition of the homomorphism from the quotient by `c` to the quotient by `d`\ninduced by `d`'s quotient map.\"]\ntheorem map_apply {c d : Con M} (h : c \u2264 d) (x) :\n    c.map d h x = c.lift d.mk' (fun _ _ hc => d.eq.2 <| h hc) x", "start": [1052, 1], "end": [1060, 6], "kind": "commanddeclaration"}, {"full_name": "Con.quotientKerEquivRange", "code": "@[to_additive \"The first isomorphism theorem for `AddMonoid`s.\"]\nnoncomputable def quotientKerEquivRange (f : M \u2192* P) : (ker f).Quotient \u2243* MonoidHom.mrange f :=\n  { Equiv.ofBijective\n        ((@MulEquiv.toMonoidHom (MonoidHom.mrange (kerLift f)) _ _ _ <|\n              MulEquiv.submonoidCongr kerLift_range_eq).comp\n          (kerLift f).mrangeRestrict) <|\n      ((Equiv.bijective (@MulEquiv.toEquiv (MonoidHom.mrange (kerLift f)) _ _ _ <|\n          MulEquiv.submonoidCongr kerLift_range_eq)).comp\n        \u27e8fun x y h =>\n          kerLift_injective f <| by rcases x with \u27e8\u27e9; rcases y with \u27e8\u27e9; injections,\n          fun \u27e8w, z, hz\u27e9 => \u27e8z, by rcases hz with \u27e8\u27e9; rfl\u27e9\u27e9) with\n    map_mul' := MonoidHom.map_mul _ }", "start": [1066, 1], "end": [1078, 38], "kind": "commanddeclaration"}, {"full_name": "Con.quotientKerEquivOfRightInverse", "code": "@[to_additive (attr := simps)\n  \"The first isomorphism theorem for `AddMonoid`s in the case of a homomorphism\n  with right inverse.\"]\ndef quotientKerEquivOfRightInverse (f : M \u2192* P) (g : P \u2192 M) (hf : Function.RightInverse g f) :\n    (ker f).Quotient \u2243* P :=\n  { kerLift f with\n    toFun := kerLift f\n    invFun := (\u2191) \u2218 g\n    left_inv := fun x => kerLift_injective _ (by rw [Function.comp_apply, kerLift_mk, hf])\n    right_inv := fun x => by conv_rhs => rw [\u2190 hf x]; rfl }", "start": [1082, 1], "end": [1092, 60], "kind": "commanddeclaration"}, {"full_name": "Con.quotientKerEquivOfSurjective", "code": "@[to_additive \"The first isomorphism theorem for `AddMonoid`s in the case of a surjective\nhomomorphism.\n\nFor a `computable` version, see `AddCon.quotientKerEquivOfRightInverse`.\n\"]\nnoncomputable def quotientKerEquivOfSurjective (f : M \u2192* P) (hf : Surjective f) :\n    (ker f).Quotient \u2243* P :=\n  quotientKerEquivOfRightInverse _ _ hf.hasRightInverse.choose_spec", "start": [1100, 1], "end": [1111, 68], "kind": "commanddeclaration"}, {"full_name": "Con.comapQuotientEquiv", "code": "@[to_additive \"The second isomorphism theorem for `AddMonoid`s.\"]\nnoncomputable def comapQuotientEquiv (f : N \u2192* M) :\n    (comap f f.map_mul c).Quotient \u2243* MonoidHom.mrange (c.mk'.comp f) :=\n  (Con.congr comap_eq).trans <| quotientKerEquivRange <| c.mk'.comp f", "start": [1115, 1], "end": [1119, 70], "kind": "commanddeclaration"}, {"full_name": "Con.quotientQuotientEquivQuotient", "code": "@[to_additive \"The third isomorphism theorem for `AddMonoid`s.\"]\ndef quotientQuotientEquivQuotient (c d : Con M) (h : c \u2264 d) :\n    (ker (c.map d h)).Quotient \u2243* d.Quotient :=\n  { Setoid.quotientQuotientEquivQuotient c.toSetoid d.toSetoid h with\n    map_mul' := fun x y =>\n      Con.induction_on\u2082 x y fun w z =>\n        Con.induction_on\u2082 w z fun a b =>\n          show _ = d.mk' a * d.mk' b by rw [\u2190 d.mk'.map_mul]; rfl }", "start": [1123, 1], "end": [1131, 68], "kind": "commanddeclaration"}, {"full_name": "Con.pow", "code": "@[to_additive \"Additive congruence relations preserve natural scaling.\"]\nprotected theorem pow {M : Type*} [Monoid M] (c : Con M) :\n    \u2200 (n : \u2115) {w x}, c w x \u2192 c (w ^ n) (x ^ n)", "start": [1139, 1], "end": [1144, 77], "kind": "commanddeclaration"}, {"full_name": "Con.one", "code": "@[to_additive]\ninstance one [MulOneClass M] (c : Con M) : One c.Quotient where\n  one := Quotient.mk'' (1 : M)", "start": [1148, 1], "end": [1154, 31], "kind": "commanddeclaration"}, {"full_name": "Con.smul", "code": "@[to_additive]\ntheorem smul {\u03b1 M : Type*} [MulOneClass M] [SMul \u03b1 M] [IsScalarTower \u03b1 M M] (c : Con M) (a : \u03b1)\n    {w x : M} (h : c w x) : c (a \u2022 w) (a \u2022 x)", "start": [1157, 1], "end": [1160, 70], "kind": "commanddeclaration"}, {"full_name": "AddCon.Quotient.nsmul", "code": "instance _root_.AddCon.Quotient.nsmul {M : Type*} [AddMonoid M] (c : AddCon M) :\n    SMul \u2115 c.Quotient where\n  smul n := (Quotient.map' ((\u00b7 \u2022 \u00b7) n)) fun _ _ => c.nsmul n", "start": [1164, 1], "end": [1166, 61], "kind": "commanddeclaration"}, {"full_name": "Con.semigroup", "code": "@[to_additive \"The quotient of an `AddSemigroup` by an additive congruence relation is\nan `AddSemigroup`.\"]\ninstance semigroup {M : Type*} [Semigroup M] (c : Con M) : Semigroup c.Quotient :=\n  { (Function.Surjective.semigroup _ Quotient.surjective_Quotient_mk'' fun _ _ => rfl :\n      Semigroup c.Quotient) with\n    \n    toMul := Con.hasMul _ }", "start": [1173, 1], "end": [1182, 28], "kind": "commanddeclaration"}, {"full_name": "Con.commSemigroup", "code": "@[to_additive \"The quotient of an `AddCommSemigroup` by an additive congruence relation is\nan `AddCommSemigroup`.\"]\ninstance commSemigroup {M : Type*} [CommSemigroup M] (c : Con M) : CommSemigroup c.Quotient :=\n  { (Function.Surjective.commSemigroup _ Quotient.surjective_Quotient_mk'' fun _ _ => rfl :\n      CommSemigroup c.Quotient) with\n    \n    toSemigroup := Con.semigroup _ }", "start": [1186, 1], "end": [1195, 37], "kind": "commanddeclaration"}, {"full_name": "Con.monoid", "code": "@[to_additive \"The quotient of an `AddMonoid` by an additive congruence relation is\nan `AddMonoid`.\"]\ninstance monoid {M : Type*} [Monoid M] (c : Con M) : Monoid c.Quotient :=\n  { (Function.Surjective.monoid _ Quotient.surjective_Quotient_mk'' rfl\n      (fun _ _ => rfl) fun _ _ => rfl : Monoid c.Quotient) with\n    \n    toSemigroup := Con.semigroup _\n    toOne := Con.one _ }", "start": [1199, 1], "end": [1209, 25], "kind": "commanddeclaration"}, {"full_name": "Con.commMonoid", "code": "@[to_additive \"The quotient of an `AddCommMonoid` by an additive congruence\nrelation is an `AddCommMonoid`.\"]\ninstance commMonoid {M : Type*} [CommMonoid M] (c : Con M) : CommMonoid c.Quotient :=\n  { (Function.Surjective.commMonoid _ Quotient.surjective_Quotient_mk'' rfl\n      (fun _ _ => rfl) fun _ _ => rfl : CommMonoid c.Quotient) with\n    \n    toMonoid := Con.monoid _ }", "start": [1213, 1], "end": [1222, 31], "kind": "commanddeclaration"}, {"full_name": "Con.map_of_mul_left_rel_one", "code": "@[to_additive \"Sometimes, an additive group is defined as a quotient of a monoid\n  by an additive congruence relation.\n  Usually, the inverse operation is defined as `Setoid.map f _` for some `f`.\n  This lemma allows to avoid code duplication in the definition of the inverse operation:\n  instead of proving both `\u2200 x y, c x y \u2192 c (f x) (f y)` (to define the operation)\n  and `\u2200 x, c (f x + x) 0` (to prove the group laws), one can only prove the latter.\"]\ntheorem map_of_mul_left_rel_one [Monoid M] (c : Con M)\n    (f : M \u2192 M) (hf : \u2200 x, c (f x * x) 1) {x y} (h : c x y) : c (f x) (f y)", "start": [1226, 1], "end": [1246, 33], "kind": "commanddeclaration"}, {"full_name": "Con.inv", "code": "@[to_additive \"Additive congruence relations preserve negation.\"]\nprotected theorem inv {x y} (h : c x y) : c x\u207b\u00b9 y\u207b\u00b9", "start": [1254, 1], "end": [1257, 87], "kind": "commanddeclaration"}, {"full_name": "Con.div", "code": "@[to_additive \"Additive congruence relations preserve subtraction.\"]\nprotected theorem div : \u2200 {w x y z}, c w x \u2192 c y z \u2192 c (w / y) (x / z)", "start": [1261, 1], "end": [1264, 56], "kind": "commanddeclaration"}, {"full_name": "Con.zpow", "code": "@[to_additive \"Additive congruence relations preserve integer scaling.\"]\nprotected theorem zpow : \u2200 (n : \u2124) {w x}, c w x \u2192 c (w ^ n) (x ^ n)", "start": [1268, 1], "end": [1272, 83], "kind": "commanddeclaration"}, {"full_name": "Con.hasInv", "code": "@[to_additive \"The negation induced on the quotient by an additive congruence relation on a type\nwith a negation.\"]\ninstance hasInv : Inv c.Quotient :=\n  \u27e8(Quotient.map' Inv.inv) fun _ _ => c.inv\u27e9", "start": [1276, 1], "end": [1281, 45], "kind": "commanddeclaration"}, {"full_name": "Con.hasDiv", "code": "@[to_additive \"The subtraction induced on the quotient by an additive congruence relation on a type\nwith a subtraction.\"]\ninstance hasDiv : Div c.Quotient :=\n  \u27e8(Quotient.map\u2082' (\u00b7 / \u00b7)) fun _ _ h\u2081 _ _ h\u2082 => c.div h\u2081 h\u2082\u27e9", "start": [1285, 1], "end": [1290, 62], "kind": "commanddeclaration"}, {"full_name": "AddCon.Quotient.zsmul", "code": "instance _root_.AddCon.Quotient.zsmul {M : Type*} [AddGroup M] (c : AddCon M) :\n    SMul \u2124 c.Quotient :=\n  \u27e8fun z => (Quotient.map' ((\u00b7 \u2022 \u00b7) z)) fun _ _ => c.zsmul z\u27e9", "start": [1294, 1], "end": [1298, 62], "kind": "commanddeclaration"}, {"full_name": "Con.zpowinst", "code": "@[to_additive existing AddCon.Quotient.zsmul]\ninstance zpowinst : Pow c.Quotient \u2124 :=\n  \u27e8fun x z => Quotient.map' (fun x => x ^ z) (fun _ _ h => c.zpow z h) x\u27e9", "start": [1301, 1], "end": [1305, 74], "kind": "commanddeclaration"}, {"full_name": "Con.group", "code": "@[to_additive \"The quotient of an `AddGroup` by an additive congruence relation is\nan `AddGroup`.\"]\ninstance group : Group c.Quotient :=\n  { (Function.Surjective.group Quotient.mk''\n      Quotient.surjective_Quotient_mk'' rfl (fun _ _ => rfl) (fun _ => rfl)\n        (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl : Group c.Quotient) with\n    toMonoid := Con.monoid _\n    toInv := Con.hasInv _\n    toDiv := Con.hasDiv _ }", "start": [1308, 1], "end": [1317, 28], "kind": "commanddeclaration"}, {"full_name": "Con.liftOnUnits", "code": "@[to_additive]\ndef liftOnUnits (u : Units c.Quotient) (f : \u2200 x y : M, c (x * y) 1 \u2192 c (y * x) 1 \u2192 \u03b1)\n    (Hf : \u2200 x y hxy hyx x' y' hxy' hyx',\n      c x x' \u2192 c y y' \u2192 f x y hxy hyx = f x' y' hxy' hyx') : \u03b1 := by\n  refine'\n    @Con.hrecOn\u2082 M M _ _ c c (fun x y => x * y = 1 \u2192 y * x = 1 \u2192 \u03b1) (u : c.Quotient)\n      (\u2191u\u207b\u00b9 : c.Quotient)\n      (fun (x y : M) (hxy : (x * y : c.Quotient) = 1) (hyx : (y * x : c.Quotient) = 1) =>\n        f x y (c.eq.1 hxy) (c.eq.1 hyx))\n      (fun x y x' y' hx hy => _) u.3 u.4\n  refine' Function.hfunext _ _\n  rw [c.eq.2 hx, c.eq.2 hy]\n  \u00b7 rintro Hxy Hxy' -\n    refine' Function.hfunext _ _\n    \u00b7 rw [c.eq.2 hx, c.eq.2 hy]\n    \u00b7 rintro Hyx Hyx' -\n      exact heq_of_eq (Hf _ _ _ _ _ _ _ _ hx hy)", "start": [1327, 1], "end": [1347, 49], "kind": "commanddeclaration"}, {"full_name": "Con.liftOnUnits_mk", "code": "@[to_additive (attr := simp)]\ntheorem liftOnUnits_mk (f : \u2200 x y : M, c (x * y) 1 \u2192 c (y * x) 1 \u2192 \u03b1)\n    (Hf : \u2200 x y hxy hyx x' y' hxy' hyx', c x x' \u2192 c y y' \u2192 f x y hxy hyx = f x' y' hxy' hyx')\n    (x y : M) (hxy hyx) :\n    liftOnUnits \u27e8(x : c.Quotient), y, hxy, hyx\u27e9 f Hf = f x y (c.eq.1 hxy) (c.eq.1 hyx)", "start": [1357, 1], "end": [1362, 6], "kind": "commanddeclaration"}, {"full_name": "Con.induction_on_units", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on_units {p : Units c.Quotient \u2192 Prop} (u : Units c.Quotient)\n    (H : \u2200 (x y : M) (hxy : c (x * y) 1) (hyx : c (y * x) 1), p \u27e8x, y, c.eq.2 hxy, c.eq.2 hyx\u27e9) :\n    p u", "start": [1366, 1], "end": [1371, 38], "kind": "commanddeclaration"}, {"full_name": "Con.instSMul", "code": "@[to_additive]\ninstance instSMul {\u03b1 M : Type*} [MulOneClass M] [SMul \u03b1 M] [IsScalarTower \u03b1 M M] (c : Con M) :\n    SMul \u03b1 c.Quotient where\n  smul a := (Quotient.map' ((\u00b7 \u2022 \u00b7) a)) fun _ _ => c.smul a", "start": [1379, 1], "end": [1382, 60], "kind": "commanddeclaration"}, {"full_name": "Con.coe_smul", "code": "@[to_additive]\ntheorem coe_smul {\u03b1 M : Type*} [MulOneClass M] [SMul \u03b1 M] [IsScalarTower \u03b1 M M] (c : Con M)\n    (a : \u03b1) (x : M) : (\u2191(a \u2022 x) : c.Quotient) = a \u2022 (x : c.Quotient)", "start": [1386, 1], "end": [1389, 6], "kind": "commanddeclaration"}, {"full_name": "Con.mulAction", "code": "@[to_additive]\ninstance mulAction {\u03b1 M : Type*} [Monoid \u03b1] [MulOneClass M] [MulAction \u03b1 M] [IsScalarTower \u03b1 M M]\n    (c : Con M) : MulAction \u03b1 c.Quotient where\n  one_smul := Quotient.ind' fun _ => congr_arg Quotient.mk'' <| one_smul _ _\n  mul_smul _ _ := Quotient.ind' fun _ => congr_arg Quotient.mk'' <| mul_smul _ _ _", "start": [1393, 1], "end": [1397, 83], "kind": "commanddeclaration"}, {"full_name": "Con.mulDistribMulAction", "code": "instance mulDistribMulAction {\u03b1 M : Type*} [Monoid \u03b1] [Monoid M] [MulDistribMulAction \u03b1 M]\n    [IsScalarTower \u03b1 M M] (c : Con M) : MulDistribMulAction \u03b1 c.Quotient :=\n  { smul_one := fun _ => congr_arg Quotient.mk'' <| smul_one _\n    smul_mul := fun _ => Quotient.ind\u2082' fun _ _ => congr_arg Quotient.mk'' <| smul_mul' _ _ _ }", "start": [1401, 1], "end": [1404, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Pointwise.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "inv_coe_set", "code": "@[to_additive (attr := simp)]\ntheorem inv_coe_set [InvolutiveInv G] [SetLike S G] [InvMemClass S G] {H : S} : (H : Set G)\u207b\u00b9 = H", "start": [36, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inv_subset_closure", "code": "@[to_additive (attr := simp)]\ntheorem inv_subset_closure (S : Set G) : S\u207b\u00b9 \u2286 closure S", "start": [46, 1], "end": [49, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_toSubmonoid", "code": "@[to_additive]\ntheorem closure_toSubmonoid (S : Set G) :\n    (closure S).toSubmonoid = Submonoid.closure (S \u222a S\u207b\u00b9)", "start": [53, 1], "end": [62, 100], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction_left", "code": "@[to_additive \"For additive subgroups generated by a single element, see the simpler\n`zsmul_induction_left`.\"]\ntheorem closure_induction_left {p : G \u2192 Prop} {x : G} (h : x \u2208 closure s) (H1 : p 1)\n    (Hmul : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x * y)) (Hinv : \u2200 x \u2208 s, \u2200 (y), p y \u2192 p (x\u207b\u00b9 * y)) : p x", "start": [66, 1], "end": [73, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction_right", "code": "@[to_additive \"For additive subgroups generated by a single element, see the simpler\n`zsmul_induction_right`.\"]\ntheorem closure_induction_right {p : G \u2192 Prop} {x : G} (h : x \u2208 closure s) (H1 : p 1)\n    (Hmul : \u2200 (x), \u2200 y \u2208 s, p x \u2192 p (x * y)) (Hinv : \u2200 (x), \u2200 y \u2208 s, p x \u2192 p (x * y\u207b\u00b9)) : p x", "start": [77, 1], "end": [84, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_inv", "code": "@[to_additive (attr := simp)]\ntheorem closure_inv (s : Set G) : closure s\u207b\u00b9 = closure s", "start": [88, 1], "end": [90, 73], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_induction''", "code": "@[to_additive \"An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `k` and their negation, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `k`.\"]\ntheorem closure_induction'' {p : G \u2192 Prop} {x} (h : x \u2208 closure s) (Hk : \u2200 x \u2208 s, p x)\n    (Hk_inv : \u2200 x \u2208 s, p x\u207b\u00b9) (H1 : p 1) (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [94, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.iSup_induction", "code": "@[to_additive (attr := elab_as_elim) \" An induction principle for elements of `\u2a06 i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {\u03b9 : Sort*} (S : \u03b9 \u2192 Subgroup G) {C : G \u2192 Prop} {x : G} (hx : x \u2208 \u2a06 i, S i)\n    (hp : \u2200 (i), \u2200 x \u2208 S i, C x) (h1 : C 1) (hmul : \u2200 x y, C x \u2192 C y \u2192 C (x * y)) : C x", "start": [107, 1], "end": [120, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.iSup_induction'", "code": "@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubgroup.iSup_induction`. \"]\ntheorem iSup_induction' {\u03b9 : Sort*} (S : \u03b9 \u2192 Subgroup G) {C : \u2200 x, (x \u2208 \u2a06 i, S i) \u2192 Prop}\n    (hp : \u2200 (i), \u2200 x (hx : x \u2208 S i), C x (mem_iSup_of_mem i hx)) (h1 : C 1 (one_mem _))\n    (hmul : \u2200 x y hx hy, C x hx \u2192 C y hy \u2192 C (x * y) (mul_mem \u2039_\u203a \u2039_\u203a)) {x : G}\n    (hx : x \u2208 \u2a06 i, S i) : C x hx", "start": [124, 1], "end": [135, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.closure_mul_le", "code": "@[to_additive]\ntheorem closure_mul_le (S T : Set G) : closure (S * T) \u2264 closure S \u2294 closure T", "start": [139, 1], "end": [143, 60], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sup_eq_closure_mul", "code": "@[to_additive]\ntheorem sup_eq_closure_mul (H K : Subgroup G) : H \u2294 K = closure ((H : Set G) * (K : Set G))", "start": [147, 1], "end": [152, 67], "kind": "commanddeclaration"}, {"full_name": "Subgroup.set_mul_normal_comm", "code": "@[to_additive]\ntheorem set_mul_normal_comm (s : Set G) (N : Subgroup G) [hN : N.Normal] :\n    s * (N : Set G) = (N : Set G) * s", "start": [156, 1], "end": [162, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_normal", "code": "@[to_additive \"The carrier of `H \u2294 N` is just `\u2191H + \u2191N` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem mul_normal (H N : Subgroup G) [hN : N.Normal] : (\u2191(H \u2294 N) : Set G) = H * N", "start": [164, 1], "end": [180, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normal_mul", "code": "@[to_additive \"The carrier of `N \u2294 H` is just `\u2191N + \u2191H` (pointwise set addition)\nwhen `N` is normal.\"]\ntheorem normal_mul (N H : Subgroup G) [N.Normal] : (\u2191(N \u2294 H) : Set G) = N * H", "start": [184, 1], "end": [188, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mul_inf_assoc", "code": "@[to_additive]\ntheorem mul_inf_assoc (A B C : Subgroup G) (h : A \u2264 C) :\n    (A : Set G) * \u2191(B \u2293 C) = (A : Set G) * (B : Set G) \u2293 C", "start": [193, 1], "end": [205, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.inf_mul_assoc", "code": "@[to_additive]\ntheorem inf_mul_assoc (A B C : Subgroup G) (h : C \u2264 A) :\n    ((A \u2293 B : Subgroup G) : Set G) * C = (A : Set G) \u2293 \u2191B * \u2191C", "start": [210, 1], "end": [222, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.sup_normal", "code": "@[to_additive]\ninstance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H \u2294 K).Normal where\n  conj_mem n hmem g := by\n    rw [\u2190 SetLike.mem_coe, normal_mul] at hmem \u22a2\n    rcases hmem with \u27e8h, k, hh, hk, rfl\u27e9\n    refine \u27e8g * h * g\u207b\u00b9, g * k * g\u207b\u00b9, hH.conj_mem h hh g, hK.conj_mem k hk g, ?_\u27e9\n    simp only [mul_assoc, inv_mul_cancel_left]", "start": [226, 1], "end": [232, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_opposite_image_mul_preimage'", "code": "@[to_additive]\ntheorem smul_opposite_image_mul_preimage' (g : G) (h : G\u1d50\u1d52\u1d56) (s : Set G) :\n    (fun y => h \u2022 y) '' ((g * \u00b7) \u207b\u00b9' s) = (g * \u00b7) \u207b\u00b9' ((fun y => h \u2022 y) '' s)", "start": [236, 1], "end": [239, 38], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_opposite_image_mul_preimage", "code": "@[to_additive]\ntheorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : H.op) (s : Set G) :\n    (fun y => h \u2022 y) '' ((g * \u00b7) \u207b\u00b9' s) = (g * \u00b7) \u207b\u00b9' ((fun y => h \u2022 y) '' s)", "start": [242, 1], "end": [245, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwiseMulAction", "code": "protected def pointwiseMulAction : MulAction \u03b1 (Subgroup G) where\n  smul a S := S.map (MulDistribMulAction.toMonoidEnd _ _ a)\n  one_smul S := by\n    change S.map _ = S\n    simpa only [map_one] using S.map_id\n  mul_smul a\u2081 a\u2082 S :=\n    (congr_arg (fun f : Monoid.End G => S.map f) (MonoidHom.map_mul _ _ _)).trans\n      (S.map_map _ _).symm", "start": [256, 1], "end": [266, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_def", "code": "theorem pointwise_smul_def {a : \u03b1} (S : Subgroup G) :\n    a \u2022 S = S.map (MulDistribMulAction.toMonoidEnd _ _ a)", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : Subgroup G) : \u2191(a \u2022 S) = a \u2022 (S : Set G)", "start": [276, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_toSubmonoid", "code": "@[simp]\ntheorem pointwise_smul_toSubmonoid (a : \u03b1) (S : Subgroup G) :\n    (a \u2022 S).toSubmonoid = a \u2022 S.toSubmonoid", "start": [281, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (m : G) (a : \u03b1) (S : Subgroup G) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S", "start": [287, 1], "end": [288, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_smul_pointwise_iff_exists", "code": "theorem mem_smul_pointwise_iff_exists (m : G) (a : \u03b1) (S : Subgroup G) :\n    m \u2208 a \u2022 S \u2194 \u2203 s : G, s \u2208 S \u2227 a \u2022 s = m", "start": [291, 1], "end": [293, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_bot", "code": "@[simp]\ntheorem smul_bot (a : \u03b1) : a \u2022 (\u22a5 : Subgroup G) = \u22a5", "start": [296, 1], "end": [298, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_sup", "code": "theorem smul_sup (a : \u03b1) (S T : Subgroup G) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T", "start": [301, 1], "end": [302, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_closure", "code": "theorem smul_closure (a : \u03b1) (s : Set G) : a \u2022 closure s = closure (a \u2022 s)", "start": [305, 1], "end": [306, 28], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_isCentralScalar", "code": "instance pointwise_isCentralScalar [MulDistribMulAction \u03b1\u1d50\u1d52\u1d56 G] [IsCentralScalar \u03b1 G] :\n    IsCentralScalar \u03b1 (Subgroup G) :=\n  \u27e8fun _ S => (congr_arg fun f => S.map f) <| MonoidHom.ext <| op_smul_eq_smul _\u27e9", "start": [309, 1], "end": [311, 82], "kind": "commanddeclaration"}, {"full_name": "Subgroup.conj_smul_le_of_le", "code": "theorem conj_smul_le_of_le {P H : Subgroup G} (hP : P \u2264 H) (h : H) :\n    MulAut.conj (h : G) \u2022 P \u2264 H", "start": [314, 1], "end": [317, 58], "kind": "commanddeclaration"}, {"full_name": "Subgroup.conj_smul_subgroupOf", "code": "theorem conj_smul_subgroupOf {P H : Subgroup G} (hP : P \u2264 H) (h : H) :\n    MulAut.conj h \u2022 P.subgroupOf H = (MulAut.conj (h : G) \u2022 P).subgroupOf H", "start": [320, 1], "end": [326, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_mem_pointwise_smul_iff", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : \u03b1} {S : Subgroup G} {x : G} : a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [335, 1], "end": [337, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_pointwise_smul_iff_inv_smul_mem", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem {a : \u03b1} {S : Subgroup G} {x : G} :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [340, 1], "end": [342, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_inv_pointwise_smul_iff", "code": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : Subgroup G} {x : G} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [345, 1], "end": [346, 23], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_le_pointwise_smul_iff", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : \u03b1} {S T : Subgroup G} : a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [349, 1], "end": [351, 31], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_subset_iff", "code": "theorem pointwise_smul_subset_iff {a : \u03b1} {S T : Subgroup G} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [354, 1], "end": [355, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subset_pointwise_smul_iff", "code": "theorem subset_pointwise_smul_iff {a : \u03b1} {S T : Subgroup G} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [358, 1], "end": [359, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_inf", "code": "@[simp]\ntheorem smul_inf (a : \u03b1) (S T : Subgroup G) : a \u2022 (S \u2293 T) = a \u2022 S \u2293 a \u2022 T", "start": [362, 1], "end": [364, 62], "kind": "commanddeclaration"}, {"full_name": "Subgroup.equivSMul", "code": "@[simps!]\ndef equivSMul (a : \u03b1) (H : Subgroup G) : H \u2243* (a \u2022 H : Subgroup G) :=\n  (MulDistribMulAction.toMulEquiv G a).subgroupMap H", "start": [367, 1], "end": [370, 53], "kind": "commanddeclaration"}, {"full_name": "Subgroup.subgroup_mul_singleton", "code": "theorem subgroup_mul_singleton {H : Subgroup G} {h : G} (hh : h \u2208 H) : (H : Set G) * {h} = H", "start": [373, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.singleton_mul_subgroup", "code": "theorem singleton_mul_subgroup {H : Subgroup G} {h : G} (hh : h \u2208 H) : {h} * (H : Set G) = H", "start": [378, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.Normal.conjAct", "code": "theorem Normal.conjAct {G : Type*} [Group G] {H : Subgroup G} (hH : H.Normal) (g : ConjAct G) :\n    g \u2022 H = H", "start": [383, 1], "end": [387, 78], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_normal", "code": "@[simp]\ntheorem smul_normal (g : G) (H : Subgroup G) [h : Normal H] : MulAut.conj g \u2022 H = H", "start": [390, 1], "end": [392, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.smul_mem_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Subgroup G) (x : G) :\n    a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [401, 1], "end": [404, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_pointwise_smul_iff_inv_smul_mem\u2080", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Subgroup G) (x : G) :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [407, 1], "end": [409, 50], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_inv_pointwise_smul_iff\u2080", "code": "theorem mem_inv_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : Subgroup G) (x : G) :\n    x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [412, 1], "end": [414, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_le_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Subgroup G} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [417, 1], "end": [420, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pointwise_smul_le_iff\u2080", "code": "theorem pointwise_smul_le_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Subgroup G} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [423, 1], "end": [424, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_pointwise_smul_iff\u2080", "code": "theorem le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : Subgroup G} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [427, 1], "end": [428, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwiseMulAction", "code": "protected def pointwiseMulAction : MulAction \u03b1 (AddSubgroup A) where\n  smul a S := S.map (DistribMulAction.toAddMonoidEnd _ _ a)\n  one_smul S := by\n    change S.map _ = S\n    simpa only [map_one] using S.map_id\n  mul_smul _ _ S :=\n    (congr_arg (fun f : AddMonoid.End A => S.map f) (MonoidHom.map_mul _ _ _)).trans\n      (S.map_map _ _).symm", "start": [441, 1], "end": [451, 27], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : AddSubgroup A) : \u2191(a \u2022 S) = a \u2022 (S : Set A)", "start": [456, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_smul_toAddSubmonoid", "code": "@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : \u03b1) (S : AddSubgroup A) :\n    (a \u2022 S).toAddSubmonoid = a \u2022 S.toAddSubmonoid", "start": [461, 1], "end": [464, 6], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (m : A) (a : \u03b1) (S : AddSubgroup A) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S", "start": [467, 1], "end": [468, 52], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.mem_smul_pointwise_iff_exists", "code": "theorem mem_smul_pointwise_iff_exists (m : A) (a : \u03b1) (S : AddSubgroup A) :\n    m \u2208 a \u2022 S \u2194 \u2203 s : A, s \u2208 S \u2227 a \u2022 s = m", "start": [471, 1], "end": [473, 47], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_isCentralScalar", "code": "instance pointwise_isCentralScalar [DistribMulAction \u03b1\u1d50\u1d52\u1d56 A] [IsCentralScalar \u03b1 A] :\n    IsCentralScalar \u03b1 (AddSubgroup A) :=\n  \u27e8fun _ S => (congr_arg fun f => S.map f) <| AddMonoidHom.ext <| op_smul_eq_smul _\u27e9", "start": [476, 1], "end": [478, 85], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.smul_mem_pointwise_smul_iff", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff {a : \u03b1} {S : AddSubgroup A} {x : A} : a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [489, 1], "end": [491, 24], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem {a : \u03b1} {S : AddSubgroup A} {x : A} :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [494, 1], "end": [496, 32], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.mem_inv_pointwise_smul_iff", "code": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : AddSubgroup A} {x : A} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [499, 1], "end": [500, 23], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_smul_le_pointwise_smul_iff", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff {a : \u03b1} {S T : AddSubgroup A} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [503, 1], "end": [506, 31], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_smul_le_iff", "code": "theorem pointwise_smul_le_iff {a : \u03b1} {S T : AddSubgroup A} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [509, 1], "end": [510, 22], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.le_pointwise_smul_iff", "code": "theorem le_pointwise_smul_iff {a : \u03b1} {S T : AddSubgroup A} : S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [513, 1], "end": [514, 22], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.smul_mem_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem smul_mem_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubgroup A) (x : A) :\n    a \u2022 x \u2208 a \u2022 S \u2194 x \u2208 S", "start": [525, 1], "end": [528, 42], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.mem_pointwise_smul_iff_inv_smul_mem\u2080", "code": "theorem mem_pointwise_smul_iff_inv_smul_mem\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubgroup A) (x : A) :\n    x \u2208 a \u2022 S \u2194 a\u207b\u00b9 \u2022 x \u2208 S", "start": [531, 1], "end": [533, 50], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.mem_inv_pointwise_smul_iff\u2080", "code": "theorem mem_inv_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) (S : AddSubgroup A) (x : A) :\n    x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S", "start": [536, 1], "end": [538, 41], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_smul_le_pointwise_smul_iff\u2080", "code": "@[simp]\ntheorem pointwise_smul_le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubgroup A} :\n    a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T", "start": [541, 1], "end": [544, 35], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.pointwise_smul_le_iff\u2080", "code": "theorem pointwise_smul_le_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubgroup A} :\n    a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T", "start": [547, 1], "end": [549, 26], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.le_pointwise_smul_iff\u2080", "code": "theorem le_pointwise_smul_iff\u2080 {a : \u03b1} (ha : a \u2260 0) {S T : AddSubgroup A} :\n    S \u2264 a \u2022 T \u2194 a\u207b\u00b9 \u2022 S \u2264 T", "start": [552, 1], "end": [554, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Subgroup/Finite.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Data/Set/Finite.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subgroup.list_prod_mem", "code": "@[to_additive \"Sum of a list of elements in an `AddSubgroup` is in the `AddSubgroup`.\"]\nprotected theorem list_prod_mem {l : List G} : (\u2200 x \u2208 l, x \u2208 K) \u2192 l.prod \u2208 K", "start": [48, 1], "end": [51, 16], "kind": "commanddeclaration"}, {"full_name": "Subgroup.multiset_prod_mem", "code": "@[to_additive \"Sum of a multiset of elements in an `AddSubgroup` of an `AddCommGroup` is in\n the `AddSubgroup`.\"]\nprotected theorem multiset_prod_mem {G} [CommGroup G] (K : Subgroup G) (g : Multiset G) :\n    (\u2200 a \u2208 g, a \u2208 K) \u2192 g.prod \u2208 K", "start": [55, 1], "end": [60, 22], "kind": "commanddeclaration"}, {"full_name": "Subgroup.multiset_noncommProd_mem", "code": "@[to_additive]\ntheorem multiset_noncommProd_mem (K : Subgroup G) (g : Multiset G) (comm) :\n    (\u2200 a \u2208 g, a \u2208 K) \u2192 g.noncommProd comm \u2208 K", "start": [64, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.prod_mem", "code": "@[to_additive \"Sum of elements in an `AddSubgroup` of an `AddCommGroup` indexed by a `Finset`\n is in the `AddSubgroup`.\"]\nprotected theorem prod_mem {G : Type*} [CommGroup G] (K : Subgroup G) {\u03b9 : Type*} {t : Finset \u03b9}\n    {f : \u03b9 \u2192 G} (h : \u2200 c \u2208 t, f c \u2208 K) : (\u220f c in t, f c) \u2208 K", "start": [71, 1], "end": [77, 13], "kind": "commanddeclaration"}, {"full_name": "Subgroup.noncommProd_mem", "code": "@[to_additive]\ntheorem noncommProd_mem (K : Subgroup G) {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 G} (comm) :\n    (\u2200 c \u2208 t, f c \u2208 K) \u2192 t.noncommProd f comm \u2208 K", "start": [81, 1], "end": [84, 41], "kind": "commanddeclaration"}, {"full_name": "Subgroup.val_list_prod", "code": "@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_list_prod (l : List H) : (l.prod : G) = (l.map Subtype.val).prod", "start": [89, 1], "end": [91, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.val_multiset_prod", "code": "@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_multiset_prod {G} [CommGroup G] (H : Subgroup G) (m : Multiset H) :\n    (m.prod : G) = (m.map Subtype.val).prod", "start": [96, 1], "end": [99, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.val_finset_prod", "code": "@[to_additive (attr := simp 1100, norm_cast)]\ntheorem val_finset_prod {\u03b9 G} [CommGroup G] (H : Subgroup G) (f : \u03b9 \u2192 H) (s : Finset \u03b9) :\n    \u2191(\u220f i in s, f i) = (\u220f i in s, f i : G)", "start": [104, 1], "end": [107, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fintypeBot", "code": "@[to_additive]\ninstance fintypeBot : Fintype (\u22a5 : Subgroup G) :=\n  \u27e8{1}, by\n    rintro \u27e8x, \u27e8hx\u27e9\u27e9\n    exact Finset.mem_singleton_self _\u27e9", "start": [111, 1], "end": [115, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_bot", "code": "@[to_additive] theorem card_bot {_ : Fintype (\u22a5 : Subgroup G)} : Fintype.card (\u22a5 : Subgroup G) = 1", "start": [121, 1], "end": [124, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_top", "code": "@[to_additive]\ntheorem card_top [Fintype G] : Fintype.card (\u22a4 : Subgroup G) = Fintype.card G", "start": [128, 1], "end": [131, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_top_of_card_eq", "code": "@[to_additive]\ntheorem eq_top_of_card_eq [Fintype H] [Fintype G] (h : Fintype.card H = Fintype.card G) :\n    H = \u22a4", "start": [133, 1], "end": [139, 8], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_eq_iff_eq_top", "code": "@[to_additive (attr := simp)]\ntheorem card_eq_iff_eq_top [Fintype H] [Fintype G] : Fintype.card H = Fintype.card G \u2194 H = \u22a4", "start": [143, 1], "end": [145, 77], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_top_of_le_card", "code": "@[to_additive]\ntheorem eq_top_of_le_card [Fintype H] [Fintype G] (h : Fintype.card G \u2264 Fintype.card H) : H = \u22a4", "start": [147, 1], "end": [150, 85], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_bot_of_card_le", "code": "@[to_additive]\ntheorem eq_bot_of_card_le [Fintype H] (h : Fintype.card H \u2264 1) : H = \u22a5", "start": [154, 1], "end": [157, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_bot_of_card_eq", "code": "@[to_additive]\ntheorem eq_bot_of_card_eq [Fintype H] (h : Fintype.card H = 1) : H = \u22a5", "start": [161, 1], "end": [163, 35], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_le_one_iff_eq_bot", "code": "@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H \u2264 1 \u2194 H = \u22a5", "start": [167, 1], "end": [172, 26], "kind": "commanddeclaration"}, {"full_name": "Subgroup.eq_bot_iff_card", "code": "@[to_additive] lemma eq_bot_iff_card [Fintype H] : H = \u22a5 \u2194 Fintype.card H = 1 :=\n  \u27e8by rintro rfl;  exact card_bot, eq_bot_of_card_eq _\u27e9", "start": [176, 1], "end": [177, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Subgroup.one_lt_card_iff_ne_bot", "code": "@[to_additive one_lt_card_iff_ne_bot]\ntheorem one_lt_card_iff_ne_bot [Fintype H] : 1 < Fintype.card H \u2194 H \u2260 \u22a5", "start": [179, 1], "end": [181, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_le_card_group", "code": "@[to_additive]\ntheorem card_le_card_group [Fintype G] [Fintype H] : Fintype.card H \u2264 Fintype.card G", "start": [185, 1], "end": [187, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_mem_of_mulSingle_mem_aux", "code": "@[to_additive]\ntheorem pi_mem_of_mulSingle_mem_aux [DecidableEq \u03b7] (I : Finset \u03b7) {H : Subgroup (\u2200 i, f i)}\n    (x : \u2200 i, f i) (h1 : \u2200 i, i \u2209 I \u2192 x i = 1) (h2 : \u2200 i, i \u2208 I \u2192 Pi.mulSingle i (x i) \u2208 H) :\n    x \u2208 H", "start": [199, 1], "end": [231, 11], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_mem_of_mulSingle_mem", "code": "@[to_additive]\ntheorem pi_mem_of_mulSingle_mem [Finite \u03b7] [DecidableEq \u03b7] {H : Subgroup (\u2200 i, f i)} (x : \u2200 i, f i)\n    (h : \u2200 i, Pi.mulSingle i (x i) \u2208 H) : x \u2208 H", "start": [235, 1], "end": [239, 75], "kind": "commanddeclaration"}, {"full_name": "Subgroup.pi_le_iff", "code": "@[to_additive \"For finite index types, the `Subgroup.pi` is generated by the embeddings of the\n additive groups.\"]\ntheorem pi_le_iff [DecidableEq \u03b7] [Finite \u03b7] {H : \u2200 i, Subgroup (f i)} {J : Subgroup (\u2200 i, f i)} :\n    pi univ H \u2264 J \u2194 \u2200 i : \u03b7, map (MonoidHom.single f i) (H i) \u2264 J", "start": [243, 1], "end": [252, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.mem_normalizer_fintype", "code": "theorem mem_normalizer_fintype {S : Set G} [Finite S] {x : G} (h : \u2200 n, n \u2208 S \u2192 x * n * x\u207b\u00b9 \u2208 S) :\n    x \u2208 Subgroup.setNormalizer S", "start": [264, 1], "end": [275, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.decidableMemRange", "code": "@[to_additive]\ninstance decidableMemRange (f : G \u2192* N) [Fintype G] [DecidableEq N] : DecidablePred (\u00b7 \u2208 f.range) :=\n  fun _ => Fintype.decidableExistsFintype", "start": [288, 1], "end": [290, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fintypeMrange", "code": "@[to_additive \"The range of a finite additive monoid under an additive monoid homomorphism is\n finite.\n\nNote: this instance can form a diamond with `Subtype.fintype` or `Subgroup.fintype` in the presence\nof `Fintype N`.\"]\ninstance fintypeMrange {M N : Type*} [Monoid M] [Monoid N] [Fintype M] [DecidableEq N]\n    (f : M \u2192* N) : Fintype (mrange f) :=\n  Set.fintypeRange f", "start": [296, 1], "end": [306, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.fintypeRange", "code": "@[to_additive \"The range of a finite additive group under an additive group homomorphism is finite.\n\nNote: this instance can form a diamond with `Subtype.fintype` or `Subgroup.fintype` in the\n presence of `Fintype N`.\"]\ninstance fintypeRange [Fintype G] [DecidableEq N] (f : G \u2192* N) : Fintype (range f) :=\n  Set.fintypeRange f", "start": [310, 1], "end": [319, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Coset.lean", "imports": ["Mathlib/Algebra/Quotient.lean", "Mathlib/GroupTheory/Subgroup/MulOpposite.lean", "Mathlib/GroupTheory/GroupAction/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Prod.lean"], "premises": [{"full_name": "leftCoset", "code": "@[to_additive leftAddCoset \"The left coset `a+s` for an element `a : \u03b1` and a subset `s : set \u03b1`\"]\ndef leftCoset [Mul \u03b1] (a : \u03b1) (s : Set \u03b1) : Set \u03b1 :=\n  (fun x => a * x) '' s", "start": [46, 1], "end": [49, 24], "kind": "commanddeclaration"}, {"full_name": "rightCoset", "code": "@[to_additive rightAddCoset\n      \"The right coset `s+a` for an element `a : \u03b1` and a subset `s : set \u03b1`\"]\ndef rightCoset [Mul \u03b1] (s : Set \u03b1) (a : \u03b1) : Set \u03b1 :=\n  (fun x => x * a) '' s", "start": [53, 1], "end": [57, 24], "kind": "commanddeclaration"}, {"full_name": "mem_leftCoset", "code": "@[to_additive mem_leftAddCoset]\ntheorem mem_leftCoset {s : Set \u03b1} {x : \u03b1} (a : \u03b1) (hxS : x \u2208 s) : a * x \u2208 a *l s", "start": [79, 1], "end": [81, 44], "kind": "commanddeclaration"}, {"full_name": "mem_rightCoset", "code": "@[to_additive mem_rightAddCoset]\ntheorem mem_rightCoset {s : Set \u03b1} {x : \u03b1} (a : \u03b1) (hxS : x \u2208 s) : x * a \u2208 s *r a", "start": [85, 1], "end": [87, 44], "kind": "commanddeclaration"}, {"full_name": "LeftCosetEquivalence", "code": "@[to_additive LeftAddCosetEquivalence \"Equality of two left cosets `a + s` and `b + s`.\"]\ndef LeftCosetEquivalence (s : Set \u03b1) (a b : \u03b1) :=\n  a *l s = b *l s", "start": [91, 1], "end": [94, 18], "kind": "commanddeclaration"}, {"full_name": "leftCosetEquivalence_rel", "code": "@[to_additive leftAddCosetEquivalence_rel]\ntheorem leftCosetEquivalence_rel (s : Set \u03b1) : Equivalence (LeftCosetEquivalence s)", "start": [98, 1], "end": [100, 77], "kind": "commanddeclaration"}, {"full_name": "RightCosetEquivalence", "code": "@[to_additive RightAddCosetEquivalence \"Equality of two right cosets `s + a` and `s + b`.\"]\ndef RightCosetEquivalence (s : Set \u03b1) (a b : \u03b1) :=\n  s *r a = s *r b", "start": [104, 1], "end": [107, 18], "kind": "commanddeclaration"}, {"full_name": "rightCosetEquivalence_rel", "code": "@[to_additive rightAddCosetEquivalence_rel]\ntheorem rightCosetEquivalence_rel (s : Set \u03b1) : Equivalence (RightCosetEquivalence s)", "start": [111, 1], "end": [113, 79], "kind": "commanddeclaration"}, {"full_name": "leftCoset_assoc", "code": "@[to_additive (attr := simp) leftAddCoset_assoc]\ntheorem leftCoset_assoc (s : Set \u03b1) (a b : \u03b1) : a *l (b *l s) = a * b *l s", "start": [123, 1], "end": [125, 82], "kind": "commanddeclaration"}, {"full_name": "rightCoset_assoc", "code": "@[to_additive (attr := simp) rightAddCoset_assoc]\ntheorem rightCoset_assoc (s : Set \u03b1) (a b : \u03b1) : s *r a *r b = s *r (a * b)", "start": [129, 1], "end": [131, 82], "kind": "commanddeclaration"}, {"full_name": "leftCoset_rightCoset", "code": "@[to_additive leftAddCoset_rightAddCoset]\ntheorem leftCoset_rightCoset (s : Set \u03b1) (a b : \u03b1) : a *l s *r b = a *l (s *r b)", "start": [135, 1], "end": [137, 82], "kind": "commanddeclaration"}, {"full_name": "one_leftCoset", "code": "@[to_additive (attr := simp) zero_leftAddCoset]\ntheorem one_leftCoset : 1 *l s = s", "start": [147, 1], "end": [149, 33], "kind": "commanddeclaration"}, {"full_name": "rightCoset_one", "code": "@[to_additive (attr := simp) rightAddCoset_zero]\ntheorem rightCoset_one : s *r 1 = s", "start": [153, 1], "end": [155, 34], "kind": "commanddeclaration"}, {"full_name": "mem_own_leftCoset", "code": "@[to_additive mem_own_leftAddCoset]\ntheorem mem_own_leftCoset (a : \u03b1) : a \u2208 a *l s", "start": [167, 1], "end": [170, 38], "kind": "commanddeclaration"}, {"full_name": "mem_own_rightCoset", "code": "@[to_additive mem_own_rightAddCoset]\ntheorem mem_own_rightCoset (a : \u03b1) : a \u2208 (s : Set \u03b1) *r a", "start": [174, 1], "end": [177, 39], "kind": "commanddeclaration"}, {"full_name": "mem_leftCoset_leftCoset", "code": "@[to_additive mem_leftAddCoset_leftAddCoset]\ntheorem mem_leftCoset_leftCoset {a : \u03b1} (ha : a *l s = s) : a \u2208 s", "start": [181, 1], "end": [183, 60], "kind": "commanddeclaration"}, {"full_name": "mem_rightCoset_rightCoset", "code": "@[to_additive mem_rightAddCoset_rightAddCoset]\ntheorem mem_rightCoset_rightCoset {a : \u03b1} (ha : (s : Set \u03b1) *r a = s) : a \u2208 s", "start": [187, 1], "end": [189, 61], "kind": "commanddeclaration"}, {"full_name": "mem_leftCoset_iff", "code": "@[to_additive mem_leftAddCoset_iff]\ntheorem mem_leftCoset_iff (a : \u03b1) : x \u2208 a *l s \u2194 a\u207b\u00b9 * x \u2208 s", "start": [199, 1], "end": [201, 86], "kind": "commanddeclaration"}, {"full_name": "mem_rightCoset_iff", "code": "@[to_additive mem_rightAddCoset_iff]\ntheorem mem_rightCoset_iff (a : \u03b1) : x \u2208 s *r a \u2194 x * a\u207b\u00b9 \u2208 s", "start": [205, 1], "end": [207, 86], "kind": "commanddeclaration"}, {"full_name": "leftCoset_mem_leftCoset", "code": "@[to_additive leftAddCoset_mem_leftAddCoset]\ntheorem leftCoset_mem_leftCoset {a : \u03b1} (ha : a \u2208 s) : a *l s = s", "start": [219, 1], "end": [221, 77], "kind": "commanddeclaration"}, {"full_name": "rightCoset_mem_rightCoset", "code": "@[to_additive rightAddCoset_mem_rightAddCoset]\ntheorem rightCoset_mem_rightCoset {a : \u03b1} (ha : a \u2208 s) : (s : Set \u03b1) *r a = s", "start": [225, 1], "end": [227, 85], "kind": "commanddeclaration"}, {"full_name": "orbit_subgroup_eq_rightCoset", "code": "@[to_additive]\ntheorem orbit_subgroup_eq_rightCoset (a : \u03b1) : MulAction.orbit s a = s *r a", "start": [231, 1], "end": [233, 78], "kind": "commanddeclaration"}, {"full_name": "orbit_subgroup_eq_self_of_mem", "code": "@[to_additive]\ntheorem orbit_subgroup_eq_self_of_mem {a : \u03b1} (ha : a \u2208 s) : MulAction.orbit s a = s", "start": [237, 1], "end": [239, 76], "kind": "commanddeclaration"}, {"full_name": "orbit_subgroup_one_eq_self", "code": "@[to_additive]\ntheorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : \u03b1) = s", "start": [243, 1], "end": [245, 44], "kind": "commanddeclaration"}, {"full_name": "eq_cosets_of_normal", "code": "@[to_additive eq_addCosets_of_normal]\ntheorem eq_cosets_of_normal (N : s.Normal) (g : \u03b1) : g *l s = s *r g", "start": [249, 1], "end": [251, 88], "kind": "commanddeclaration"}, {"full_name": "normal_of_eq_cosets", "code": "@[to_additive normal_of_eq_addCosets]\ntheorem normal_of_eq_cosets (h : \u2200 g : \u03b1, g *l s = s *r g) : s.Normal", "start": [255, 1], "end": [258, 96], "kind": "commanddeclaration"}, {"full_name": "normal_iff_eq_cosets", "code": "@[to_additive normal_iff_eq_addCosets]\ntheorem normal_iff_eq_cosets : s.Normal \u2194 \u2200 g : \u03b1, g *l s = s *r g", "start": [262, 1], "end": [264, 54], "kind": "commanddeclaration"}, {"full_name": "leftCoset_eq_iff", "code": "@[to_additive leftAddCoset_eq_iff]\ntheorem leftCoset_eq_iff {x y : \u03b1} : leftCoset x s = leftCoset y s \u2194 x\u207b\u00b9 * y \u2208 s", "start": [268, 1], "end": [280, 34], "kind": "commanddeclaration"}, {"full_name": "rightCoset_eq_iff", "code": "@[to_additive rightAddCoset_eq_iff]\ntheorem rightCoset_eq_iff {x y : \u03b1} : rightCoset (\u2191s) x = rightCoset s y \u2194 y * x\u207b\u00b9 \u2208 s", "start": [284, 1], "end": [296, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.leftRel", "code": "@[to_additive \"The equivalence relation corresponding to the partition of a group by left cosets\n of a subgroup.\"]\ndef leftRel : Setoid \u03b1 :=\n  MulAction.orbitRel s.op \u03b1", "start": [309, 1], "end": [314, 28], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.leftRel_apply", "code": "@[to_additive]\ntheorem leftRel_apply {x y : \u03b1} : @Setoid.r _ (leftRel s) x y \u2194 x\u207b\u00b9 * y \u2208 s", "start": [320, 1], "end": [327, 63], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.leftRel_eq", "code": "@[to_additive]\ntheorem leftRel_eq : @Setoid.r _ (leftRel s) = fun x y => x\u207b\u00b9 * y \u2208 s", "start": [333, 1], "end": [337, 24], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.leftRel_r_eq_leftCosetEquivalence", "code": "theorem leftRel_r_eq_leftCosetEquivalence :\n    @Setoid.r _ (QuotientGroup.leftRel s) = LeftCosetEquivalence s", "start": [341, 1], "end": [345, 34], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.leftRelDecidable", "code": "@[to_additive]\ninstance leftRelDecidable [DecidablePred (\u00b7 \u2208 s)] : DecidableRel (leftRel s).r := fun x y => by\n  rw [leftRel_eq]\n  exact \u2039DecidablePred (\u00b7 \u2208 s)\u203a _", "start": [348, 1], "end": [351, 34], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.instHasQuotientSubgroup", "code": "@[to_additive \"`\u03b1 \u29f8 s` is the quotient type representing the left cosets of `s`.  If `s` is a normal\n subgroup, `\u03b1 \u29f8 s` is a group\"]\ninstance instHasQuotientSubgroup : HasQuotient \u03b1 (Subgroup \u03b1) :=\n  \u27e8fun s => Quotient (leftRel s)\u27e9", "start": [355, 1], "end": [360, 34], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rightRel", "code": "@[to_additive \"The equivalence relation corresponding to the partition of a group by right cosets\n of a subgroup.\"]\ndef rightRel : Setoid \u03b1 :=\n  MulAction.orbitRel s \u03b1", "start": [362, 1], "end": [367, 25], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rightRel_apply", "code": "@[to_additive]\ntheorem rightRel_apply {x y : \u03b1} : @Setoid.r _ (rightRel s) x y \u2194 y * x\u207b\u00b9 \u2208 s", "start": [373, 1], "end": [378, 63], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rightRel_eq", "code": "@[to_additive]\ntheorem rightRel_eq : @Setoid.r _ (rightRel s) = fun x y => y * x\u207b\u00b9 \u2208 s", "start": [384, 1], "end": [388, 25], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rightRel_r_eq_rightCosetEquivalence", "code": "theorem rightRel_r_eq_rightCosetEquivalence :\n    @Setoid.r _ (QuotientGroup.rightRel s) = RightCosetEquivalence s", "start": [392, 1], "end": [396, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rightRelDecidable", "code": "@[to_additive]\ninstance rightRelDecidable [DecidablePred (\u00b7 \u2208 s)] : DecidableRel (rightRel s).r := fun x y => by\n  rw [rightRel_eq]\n  exact \u2039DecidablePred (\u00b7 \u2208 s)\u203a _", "start": [399, 1], "end": [402, 34], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientRightRelEquivQuotientLeftRel", "code": "@[to_additive \"Right cosets are in bijection with left cosets.\"]\ndef quotientRightRelEquivQuotientLeftRel : Quotient (QuotientGroup.rightRel s) \u2243 \u03b1 \u29f8 s\n    where\n  toFun :=\n    Quotient.map' (fun g => g\u207b\u00b9) fun a b => by\n      rw [leftRel_apply, rightRel_apply]\n      exact fun h => (congr_arg (\u00b7 \u2208 s) (by simp [mul_assoc])).mp (s.inv_mem h)\n      invFun :=\n    Quotient.map' (fun g => g\u207b\u00b9) fun a b => by\n      rw [leftRel_apply, rightRel_apply]\n      exact fun h => (congr_arg (\u00b7 \u2208 s) (by simp [mul_assoc])).mp (s.inv_mem h)\n      left_inv g :=\n    Quotient.inductionOn' g fun g =>\n      Quotient.sound'\n        (by\n          simp only [inv_inv]\n          exact Quotient.exact' rfl)\n  right_inv g :=\n    Quotient.inductionOn' g fun g =>\n      Quotient.sound'\n        (by\n          simp only [inv_inv]\n          exact Quotient.exact' rfl)", "start": [406, 1], "end": [431, 37], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.fintypeQuotientRightRel", "code": "@[to_additive]\ninstance fintypeQuotientRightRel [Fintype (\u03b1 \u29f8 s)] :\n    Fintype (Quotient (QuotientGroup.rightRel s)) :=\n  Fintype.ofEquiv (\u03b1 \u29f8 s) (QuotientGroup.quotientRightRelEquivQuotientLeftRel s).symm", "start": [435, 1], "end": [438, 86], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.card_quotient_rightRel", "code": "@[to_additive]\ntheorem card_quotient_rightRel [Fintype (\u03b1 \u29f8 s)] :\n    Fintype.card (Quotient (QuotientGroup.rightRel s)) = Fintype.card (\u03b1 \u29f8 s)", "start": [442, 1], "end": [445, 83], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.fintype", "code": "@[to_additive]\ninstance fintype [Fintype \u03b1] (s : Subgroup \u03b1) [DecidableRel (leftRel s).r] : Fintype (\u03b1 \u29f8 s) :=\n  Quotient.fintype (leftRel s)", "start": [455, 1], "end": [457, 31], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk", "code": "@[to_additive (attr := coe) \"The canonical map from an `AddGroup` `\u03b1` to the quotient `\u03b1 \u29f8 s`.\"]\nabbrev mk (a : \u03b1) : \u03b1 \u29f8 s :=\n  Quotient.mk'' a", "start": [461, 1], "end": [464, 18], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_surjective", "code": "@[to_additive]\ntheorem mk_surjective : Function.Surjective <| @mk _ _ s", "start": [468, 1], "end": [470, 36], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.range_mk", "code": "@[to_additive (attr := simp)]\nlemma range_mk : range (QuotientGroup.mk (s := s)) = univ := range_iff_surjective.mpr mk_surjective", "start": [474, 1], "end": [475, 100], "kind": "mathlibtacticlemma"}, {"full_name": "QuotientGroup.induction_on", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on {C : \u03b1 \u29f8 s \u2192 Prop} (x : \u03b1 \u29f8 s) (H : \u2200 z, C (QuotientGroup.mk z)) : C x", "start": [477, 1], "end": [479, 28], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.induction_on'", "code": "@[to_additive (attr := elab_as_elim)]\ntheorem induction_on' {C : \u03b1 \u29f8 s \u2192 Prop} (x : \u03b1 \u29f8 s) (H : \u2200 z : \u03b1, C z) : C x", "start": [487, 1], "end": [489, 28], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotient_liftOn_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotient_liftOn_mk {\u03b2} (f : \u03b1 \u2192 \u03b2) (h) (x : \u03b1) : Quotient.liftOn' (x : \u03b1 \u29f8 s) f h = f x", "start": [493, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.forall_mk", "code": "@[to_additive]\ntheorem forall_mk {C : \u03b1 \u29f8 s \u2192 Prop} : (\u2200 x : \u03b1 \u29f8 s, C x) \u2194 \u2200 x : \u03b1, C x", "start": [499, 1], "end": [501, 23], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.exists_mk", "code": "@[to_additive]\ntheorem exists_mk {C : \u03b1 \u29f8 s \u2192 Prop} : (\u2203 x : \u03b1 \u29f8 s, C x) \u2194 \u2203 x : \u03b1, C x", "start": [505, 1], "end": [507, 23], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.eq", "code": "@[to_additive]\nprotected theorem eq {a b : \u03b1} : (a : \u03b1 \u29f8 s) = b \u2194 a\u207b\u00b9 * b \u2208 s", "start": [515, 1], "end": [519, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.eq'", "code": "@[to_additive]\ntheorem eq' {a b : \u03b1} : (mk a : \u03b1 \u29f8 s) = mk b \u2194 a\u207b\u00b9 * b \u2208 s", "start": [523, 1], "end": [525, 19], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.out_eq'", "code": "@[to_additive] theorem out_eq' (a : \u03b1 \u29f8 s) : mk a.out' = a", "start": [529, 1], "end": [531, 21], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_out'_eq_mul", "code": "@[to_additive QuotientAddGroup.mk_out'_eq_mul]\ntheorem mk_out'_eq_mul (g : \u03b1) : \u2203 h : s, (mk g : \u03b1 \u29f8 s).out' = g * h", "start": [540, 1], "end": [542, 81], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_mul_of_mem", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul_of_mem (a : \u03b1) (hb : b \u2208 s) : (mk (a * b) : \u03b1 \u29f8 s) = mk a", "start": [548, 1], "end": [550, 62], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.eq_class_eq_leftCoset", "code": "@[to_additive]\ntheorem eq_class_eq_leftCoset (s : Subgroup \u03b1) (g : \u03b1) :\n    { x : \u03b1 | (x : \u03b1 \u29f8 s) = g } = leftCoset g s", "start": [554, 1], "end": [558, 89], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.preimage_image_mk", "code": "@[to_additive]\ntheorem preimage_image_mk (N : Subgroup \u03b1) (s : Set \u03b1) :\n    mk \u207b\u00b9' ((mk : \u03b1 \u2192 \u03b1 \u29f8 N) '' s) = \u22c3 x : N, (\u00b7 * (x : \u03b1)) \u207b\u00b9' s", "start": [562, 1], "end": [570, 39], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.preimage_image_mk_eq_iUnion_image", "code": "@[to_additive]\ntheorem preimage_image_mk_eq_iUnion_image (N : Subgroup \u03b1) (s : Set \u03b1) :\n    mk \u207b\u00b9' ((mk : \u03b1 \u2192 \u03b1 \u29f8 N) '' s) = \u22c3 x : N, (\u00b7 * (x : \u03b1)) '' s", "start": [574, 1], "end": [578, 33], "kind": "commanddeclaration"}, {"full_name": "Subgroup.leftCosetEquivSubgroup", "code": "@[to_additive \"The natural bijection between the cosets `g + s` and `s`.\"]\ndef leftCosetEquivSubgroup (g : \u03b1) : leftCoset g s \u2243 s :=\n  \u27e8fun x => \u27e8g\u207b\u00b9 * x.1, (mem_leftCoset_iff _).1 x.2\u27e9, fun x => \u27e8g * x.1, x.1, x.2, rfl\u27e9,\n    fun \u27e8x, hx\u27e9 => Subtype.eq <| by simp, fun \u27e8g, hg\u27e9 => Subtype.eq <| by simp\u27e9", "start": [588, 1], "end": [592, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rightCosetEquivSubgroup", "code": "@[to_additive \"The natural bijection between the cosets `s + g` and `s`.\"]\ndef rightCosetEquivSubgroup (g : \u03b1) : rightCoset (\u2191s) g \u2243 s :=\n  \u27e8fun x => \u27e8x.1 * g\u207b\u00b9, (mem_rightCoset_iff _).1 x.2\u27e9, fun x => \u27e8x.1 * g, x.1, x.2, rfl\u27e9,\n    fun \u27e8x, hx\u27e9 => Subtype.eq <| by simp, fun \u27e8g, hg\u27e9 => Subtype.eq <| by simp\u27e9", "start": [596, 1], "end": [600, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.groupEquivQuotientProdSubgroup", "code": "@[to_additive addGroupEquivQuotientProdAddSubgroup\n  \"A (non-canonical) bijection between an add_group `\u03b1` and the product `(\u03b1/s) \u00d7 s`\"]\nnoncomputable def groupEquivQuotientProdSubgroup : \u03b1 \u2243 (\u03b1 \u29f8 s) \u00d7 s :=\n  calc\n    \u03b1 \u2243 \u03a3L : \u03b1 \u29f8 s, { x : \u03b1 // (x : \u03b1 \u29f8 s) = L } := (Equiv.sigmaFiberEquiv QuotientGroup.mk).symm\n    _ \u2243 \u03a3L : \u03b1 \u29f8 s, leftCoset (Quotient.out' L) s :=\n      Equiv.sigmaCongrRight fun L => by\n        rw [\u2190 eq_class_eq_leftCoset]\n        show\n          (_root_.Subtype fun x : \u03b1 => Quotient.mk'' x = L) \u2243\n            _root_.Subtype fun x : \u03b1 => Quotient.mk'' x = Quotient.mk'' _\n        simp [-Quotient.eq'']\n        rfl\n    _ \u2243 \u03a3 _L : \u03b1 \u29f8 s, s := Equiv.sigmaCongrRight fun L => leftCosetEquivSubgroup _\n    _ \u2243 (\u03b1 \u29f8 s) \u00d7 s := Equiv.sigmaEquivProd _ _", "start": [604, 1], "end": [619, 48], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivOfEq", "code": "@[to_additive \"If two subgroups `M` and `N` of `G` are equal, their quotients are in bijection.\"]\ndef quotientEquivOfEq (h : s = t) : \u03b1 \u29f8 s \u2243 \u03b1 \u29f8 t\n    where\n  toFun := Quotient.map' id fun _a _b h' => h \u25b8 h'\n  invFun := Quotient.map' id fun _a _b h' => h.symm \u25b8 h'\n  left_inv q := induction_on' q fun _g => rfl\n  right_inv q := induction_on' q fun _g => rfl", "start": [625, 1], "end": [632, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivOfEq_mk", "code": "theorem quotientEquivOfEq_mk (h : s = t) (a : \u03b1) :\n    quotientEquivOfEq h (QuotientGroup.mk a) = QuotientGroup.mk a", "start": [636, 1], "end": [638, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivProdOfLE'", "code": "@[to_additive (attr := simps)\n  \"If `H \u2264 K`, then `G/H \u2243 G/K \u00d7 K/H` constructively, using the provided right inverse\n  of the quotient map `G \u2192 G/K`. The classical version is `AddSubgroup.quotientEquivSumOfLE`.\"]\ndef quotientEquivProdOfLE' (h_le : s \u2264 t) (f : \u03b1 \u29f8 t \u2192 \u03b1)\n    (hf : Function.RightInverse f QuotientGroup.mk) : \u03b1 \u29f8 s \u2243 (\u03b1 \u29f8 t) \u00d7 t \u29f8 s.subgroupOf t\n    where\n  toFun a :=\n    \u27e8a.map' id fun b c h => leftRel_apply.mpr (h_le (leftRel_apply.mp h)),\n      a.map' (fun g : \u03b1 => \u27e8(f (Quotient.mk'' g))\u207b\u00b9 * g, leftRel_apply.mp (Quotient.exact' (hf g))\u27e9)\n        fun b c h => by\n        rw [leftRel_apply]\n        change ((f b)\u207b\u00b9 * b)\u207b\u00b9 * ((f c)\u207b\u00b9 * c) \u2208 s\n        have key : f b = f c :=\n          congr_arg f (Quotient.sound' (leftRel_apply.mpr (h_le (leftRel_apply.mp h))))\n        rwa [key, mul_inv_rev, inv_inv, mul_assoc, mul_inv_cancel_left, \u2190 leftRel_apply]\u27e9\n  invFun a := by\n    refine a.2.map' (fun (b : { x // x \u2208 t}) => f a.1 * b) fun b c h => by\n      rw [leftRel_apply] at h \u22a2\n      change (f a.1 * b)\u207b\u00b9 * (f a.1 * c) \u2208 s\n      rwa [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n  left_inv := by\n    refine' Quotient.ind' fun a => _\n    simp_rw [Quotient.map'_mk'', id.def, mul_inv_cancel_left]\n  right_inv := by\n    refine' Prod.rec _\n    refine' Quotient.ind' fun a => _\n    refine' Quotient.ind' fun b => _\n    have key : Quotient.mk'' (f (Quotient.mk'' a) * b) = Quotient.mk'' a :=\n      (QuotientGroup.mk_mul_of_mem (f a) b.2).trans (hf a)\n    simp_rw [Quotient.map'_mk'', id.def, key, inv_mul_cancel_left]", "start": [641, 1], "end": [672, 67], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientEquivProdOfLE", "code": "@[to_additive (attr := simps!) \"If `H \u2264 K`, then `G/H \u2243 G/K \u00d7 K/H` nonconstructively. The\n constructive version is `quotientEquivProdOfLE'`.\"]\nnoncomputable def quotientEquivProdOfLE (h_le : s \u2264 t) : \u03b1 \u29f8 s \u2243 (\u03b1 \u29f8 t) \u00d7 t \u29f8 s.subgroupOf t :=\n  quotientEquivProdOfLE' h_le Quotient.out' Quotient.out_eq'", "start": [676, 1], "end": [681, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientSubgroupOfEmbeddingOfLE", "code": "@[to_additive \"If `s \u2264 t`, then there is an embedding\n `s \u29f8 H.addSubgroupOf s \u21aa t \u29f8 H.addSubgroupOf t`.\"]\ndef quotientSubgroupOfEmbeddingOfLE (H : Subgroup \u03b1) (h : s \u2264 t) :\n    s \u29f8 H.subgroupOf s \u21aa t \u29f8 H.subgroupOf t\n    where\n  toFun :=\n    Quotient.map' (inclusion h) fun a b => by\n      simp_rw [leftRel_eq]\n      exact id\n  inj' :=\n    Quotient.ind\u2082' <| by\n      intro a b h\n      simpa only [Quotient.map'_mk'', eq'] using h", "start": [685, 1], "end": [698, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientSubgroupOfEmbeddingOfLE_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfEmbeddingOfLE_apply_mk (H : Subgroup \u03b1) (h : s \u2264 t) (g : s) :\n    quotientSubgroupOfEmbeddingOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk (inclusion h g) : (fun _ => { x // x \u2208 t } \u29f8 subgroupOf H t) \u2191g)", "start": [703, 1], "end": [707, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientSubgroupOfMapOfLE", "code": "@[to_additive \"If `s \u2264 t`, then there is a map `H \u29f8 s.addSubgroupOf H \u2192 H \u29f8 t.addSubgroupOf H`.\"]\ndef quotientSubgroupOfMapOfLE (H : Subgroup \u03b1) (h : s \u2264 t) :\n    H \u29f8 s.subgroupOf H \u2192 H \u29f8 t.subgroupOf H :=\n  Quotient.map' id fun a b => by\n    simp_rw [leftRel_eq]\n    apply h", "start": [711, 1], "end": [717, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientSubgroupOfMapOfLE_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientSubgroupOfMapOfLE_apply_mk (H : Subgroup \u03b1) (h : s \u2264 t) (g : H) :\n    quotientSubgroupOfMapOfLE H h (QuotientGroup.mk g) =\n      (QuotientGroup.mk g : { x // x \u2208 H } \u29f8 subgroupOf t H)", "start": [722, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientMapOfLE", "code": "@[to_additive \"If `s \u2264 t`, then there is a map `\u03b1 \u29f8 s \u2192 \u03b1 \u29f8 t`.\"]\ndef quotientMapOfLE (h : s \u2264 t) : \u03b1 \u29f8 s \u2192 \u03b1 \u29f8 t :=\n  Quotient.map' id fun a b => by\n    simp_rw [leftRel_eq]\n    apply h", "start": [730, 1], "end": [735, 12], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientMapOfLE_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientMapOfLE_apply_mk (h : s \u2264 t) (g : \u03b1) :\n    quotientMapOfLE h (QuotientGroup.mk g) = QuotientGroup.mk g", "start": [739, 1], "end": [742, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientiInfSubgroupOfEmbedding", "code": "@[to_additive (attr := simps) \"The natural embedding\n `H \u29f8 (\u2a05 i, f i).addSubgroupOf H) \u21aa \u03a0 i, H \u29f8 (f i).addSubgroupOf H`.\"]\ndef quotientiInfSubgroupOfEmbedding {\u03b9 : Type*} (f : \u03b9 \u2192 Subgroup \u03b1) (H : Subgroup \u03b1) :\n    H \u29f8 (\u2a05 i, f i).subgroupOf H \u21aa \u2200 i, H \u29f8 (f i).subgroupOf H\n    where\n  toFun q i := quotientSubgroupOfMapOfLE H (iInf_le f i) q\n  inj' :=\n    Quotient.ind\u2082' <| by\n      simp_rw [funext_iff, quotientSubgroupOfMapOfLE_apply_mk, eq', mem_subgroupOf, mem_iInf,\n        imp_self, forall_const]", "start": [746, 1], "end": [756, 32], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientiInfSubgroupOfEmbedding_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientiInfSubgroupOfEmbedding_apply_mk {\u03b9 : Type*} (f : \u03b9 \u2192 Subgroup \u03b1) (H : Subgroup \u03b1)\n    (g : H) (i : \u03b9) :\n    quotientiInfSubgroupOfEmbedding f H (QuotientGroup.mk g) i =\n      (QuotientGroup.mk g : { x // x \u2208 H } \u29f8 subgroupOf (f i) H)", "start": [761, 1], "end": [766, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientiInfEmbedding", "code": "@[to_additive (attr := simps) \"The natural embedding `\u03b1 \u29f8 (\u2a05 i, f i) \u21aa \u03a0 i, \u03b1 \u29f8 f i`.\"]\ndef quotientiInfEmbedding {\u03b9 : Type*} (f : \u03b9 \u2192 Subgroup \u03b1) : (\u03b1 \u29f8 \u2a05 i, f i) \u21aa \u2200 i, \u03b1 \u29f8 f i\n    where\n  toFun q i := quotientMapOfLE (iInf_le f i) q\n  inj' :=\n    Quotient.ind\u2082' <| by\n      simp_rw [funext_iff, quotientMapOfLE_apply_mk, eq', mem_iInf, imp_self, forall_const]", "start": [770, 1], "end": [777, 92], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientiInfEmbedding_apply_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientiInfEmbedding_apply_mk {\u03b9 : Type*} (f : \u03b9 \u2192 Subgroup \u03b1) (g : \u03b1) (i : \u03b9) :\n    quotientiInfEmbedding f (QuotientGroup.mk g) i = QuotientGroup.mk g", "start": [781, 1], "end": [784, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_eq_card_quotient_mul_card_subgroup", "code": "@[to_additive]\ntheorem card_eq_card_quotient_mul_card_subgroup [Fintype \u03b1] (s : Subgroup \u03b1) [Fintype s]\n    [DecidablePred fun a => a \u2208 s] : Fintype.card \u03b1 = Fintype.card (\u03b1 \u29f8 s) * Fintype.card s", "start": [788, 1], "end": [791, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_subgroup_dvd_card", "code": "@[to_additive \"**Lagrange's Theorem**: The order of an additive subgroup divides the order of its\n ambient additive group.\"]\ntheorem card_subgroup_dvd_card [Fintype \u03b1] (s : Subgroup \u03b1) [Fintype s] :\n    Fintype.card s \u2223 Fintype.card \u03b1", "start": [795, 1], "end": [800, 78], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_quotient_dvd_card", "code": "@[to_additive]\ntheorem card_quotient_dvd_card [Fintype \u03b1] (s : Subgroup \u03b1) [DecidablePred (\u00b7 \u2208 s)] :\n    Fintype.card (\u03b1 \u29f8 s) \u2223 Fintype.card \u03b1", "start": [804, 1], "end": [807, 69], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_dvd_of_injective", "code": "@[to_additive]\ntheorem card_dvd_of_injective [Fintype \u03b1] [Fintype H] (f : \u03b1 \u2192* H) (hf : Function.Injective f) :\n    card \u03b1 \u2223 card H", "start": [815, 1], "end": [820, 45], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_dvd_of_le", "code": "@[to_additive]\ntheorem card_dvd_of_le {H K : Subgroup \u03b1} [Fintype H] [Fintype K] (hHK : H \u2264 K) : card H \u2223 card K", "start": [824, 1], "end": [826, 66], "kind": "commanddeclaration"}, {"full_name": "Subgroup.card_comap_dvd_of_injective", "code": "@[to_additive]\ntheorem card_comap_dvd_of_injective (K : Subgroup H) [Fintype K] (f : \u03b1 \u2192* H) [Fintype (K.comap f)]\n    (hf : Function.Injective f) : Fintype.card (K.comap f) \u2223 Fintype.card K", "start": [830, 1], "end": [838, 62], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.preimageMkEquivSubgroupProdSet", "code": "@[to_additive preimageMkEquivAddSubgroupProdSet\n\"If `s` is a subgroup of the additive group `\u03b1`, and `t` is a subset of `\u03b1 \u29f8 s`, then\n there is a (typically non-canonical) bijection between the preimage of `t` in `\u03b1` and the product\n `s \u00d7 t`.\"]\nnoncomputable def preimageMkEquivSubgroupProdSet (s : Subgroup \u03b1) (t : Set (\u03b1 \u29f8 s)) :\n    QuotientGroup.mk \u207b\u00b9' t \u2243 s \u00d7 t\n    where\n  toFun a :=\n    \u27e8\u27e8((Quotient.out' (QuotientGroup.mk a)) : \u03b1)\u207b\u00b9 * a,\n        leftRel_apply.mp (@Quotient.exact' _ (leftRel s) _ _ <| Quotient.out_eq' _)\u27e9,\n      \u27e8QuotientGroup.mk a, a.2\u27e9\u27e9\n  invFun a :=\n    \u27e8Quotient.out' a.2.1 * a.1.1,\n      show QuotientGroup.mk _ \u2208 t by\n        rw [mk_mul_of_mem _ a.1.2, out_eq']\n        exact a.2.2\u27e9\n  left_inv := fun \u27e8a, ha\u27e9 => Subtype.eq <| show _ * _ = a by simp\n  right_inv := fun \u27e8\u27e8a, ha\u27e9, \u27e8x, hx\u27e9\u27e9 => by ext <;> simp [ha]", "start": [848, 1], "end": [867, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Verification.lean", "imports": ["Mathlib/Tactic/Linarith/Parsing.lean", "Mathlib/Util/Qq.lean", "Mathlib/Tactic/Linarith/Elimination.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Qq.ofNatQ", "code": "def ofNatQ (\u03b1 : Q(Type $u)) (_ : Q(Semiring $\u03b1)) (n : \u2115) : Q($\u03b1) :=\n  match n with\n  | 0 => q(0 : $\u03b1)\n  | 1 => q(1 : $\u03b1)\n  | k+2 =>\n    have lit : Q(\u2115) := mkRawNatLit n\n    have k : Q(\u2115) := mkRawNatLit k\n    haveI : $lit =Q $k + 2 := \u27e8\u27e9\n    by exact q(OfNat.ofNat $lit)", "start": [29, 1], "end": [38, 33], "kind": "commanddeclaration"}, {"full_name": "Linarith.mulExpr'", "code": "def mulExpr' (n : \u2115) {\u03b1 : Q(Type $u)} (inst : Q(Semiring $\u03b1)) (e : Q($\u03b1)) : Q($\u03b1) :=\n  if n = 1 then e else\n    let n := ofNatQ \u03b1 inst n\n    q($n * $e)", "start": [49, 1], "end": [53, 15], "kind": "commanddeclaration"}, {"full_name": "Linarith.mulExpr", "code": "def mulExpr (n : \u2115) (e : Expr) : MetaM Expr := do\n  let \u27e8_, \u03b1, e\u27e9 \u2190 inferTypeQ' e\n  let inst : Q(Semiring $\u03b1) \u2190 synthInstanceQ q(Semiring $\u03b1)\n  return mulExpr' n inst e", "start": [55, 1], "end": [62, 27], "kind": "commanddeclaration"}, {"full_name": "Linarith.addExprs'", "code": "def addExprs' {\u03b1 : Q(Type $u)} (_inst : Q(AddMonoid $\u03b1)) : List Q($\u03b1) \u2192 Q($\u03b1)\n  | []   => q(0)\n  | h::t => go h t\n    where\n    \n    go (p : Q($\u03b1)) : List Q($\u03b1) \u2192 Q($\u03b1)\n    | [] => p\n    | [q] => q($p + $q)\n    | q::t => go q($p + $q) t", "start": [64, 1], "end": [73, 30], "kind": "commanddeclaration"}, {"full_name": "Linarith.addExprs", "code": "def addExprs : List Expr \u2192 MetaM Expr\n  | [] => return q(0) | L@(h::_) => do\n    let \u27e8_, \u03b1, _\u27e9 \u2190 inferTypeQ' h\n    let inst : Q(AddMonoid $\u03b1) \u2190 synthInstanceQ q(AddMonoid $\u03b1)\n    return addExprs' inst L", "start": [75, 1], "end": [82, 28], "kind": "commanddeclaration"}, {"full_name": "Linarith.addIneq", "code": "def addIneq : Ineq \u2192 Ineq \u2192 (Name \u00d7 Ineq)\n  | eq, eq => (``Linarith.eq_of_eq_of_eq, eq)\n  | eq, le => (``Linarith.le_of_eq_of_le, le)\n  | eq, lt => (``Linarith.lt_of_eq_of_lt, lt)\n  | le, eq => (``Linarith.le_of_le_of_eq, le)\n  | le, le => (``add_nonpos, le)\n  | le, lt => (``add_lt_of_le_of_neg, lt)\n  | lt, eq => (``Linarith.lt_of_lt_of_eq, lt)\n  | lt, le => (``add_lt_of_neg_of_le, lt)\n  | lt, lt => (``Left.add_neg, lt)", "start": [84, 1], "end": [98, 35], "kind": "commanddeclaration"}, {"full_name": "Linarith.mkLTZeroProof", "code": "def mkLTZeroProof : List (Expr \u00d7 \u2115) \u2192 MetaM Expr\n  | [] => throwError \"no linear hypotheses found\"\n  | [(h, c)] => do\n      let (_, t) \u2190 mkSingleCompZeroOf c h\n      return t\n  | ((h, c)::t) => do\n      let (iq, h') \u2190 mkSingleCompZeroOf c h\n      let (_, t) \u2190 t.foldlM (\u03bb pr ce => step pr.1 pr.2 ce.1 ce.2) (iq, h')\n      return t\n  where\n    \n    step (c : Ineq) (pf npf : Expr) (coeff : \u2115) : MetaM (Ineq \u00d7 Expr) := do\n      let (iq, h') \u2190 mkSingleCompZeroOf coeff npf\n      let (nm, niq) := addIneq c iq\n      return (niq, \u2190mkAppM nm #[pf, h'])", "start": [100, 1], "end": [123, 41], "kind": "commanddeclaration"}, {"full_name": "Linarith.leftOfIneqProof", "code": "def leftOfIneqProof (prf : Expr) : MetaM Expr := do\n  let (t, _) \u2190 getRelSides (\u2190 inferType prf)\n  return t", "start": [125, 1], "end": [128, 11], "kind": "commanddeclaration"}, {"full_name": "Linarith.typeOfIneqProof", "code": "def typeOfIneqProof (prf : Expr) : MetaM Expr := do\n  inferType (\u2190 leftOfIneqProof prf)", "start": [130, 1], "end": [132, 36], "kind": "commanddeclaration"}, {"full_name": "Linarith.mkNegOneLtZeroProof", "code": "def mkNegOneLtZeroProof (tp : Expr) : MetaM Expr := do\n  let zero_lt_one \u2190 mkAppOptM ``zero_lt_one #[tp, none, none, none, none, none]\n  mkAppM `neg_neg_of_pos #[zero_lt_one]", "start": [134, 1], "end": [140, 40], "kind": "commanddeclaration"}, {"full_name": "Linarith.addNegEqProofs", "code": "def addNegEqProofs : List Expr \u2192 MetaM (List Expr)\n  | [] => return []\n  | (h::tl) => do\n    let (iq, t) \u2190 parseCompAndExpr (\u2190 inferType h)\n    match iq with\n    | Ineq.eq => do\n      let nep := mkAppN (\u2190 mkAppM `Iff.mpr #[\u2190 mkAppOptM ``neg_eq_zero #[none, none, t]]) #[h]\n      let tl \u2190 addNegEqProofs tl\n      return h::nep::tl\n    | _ => return h :: (\u2190 addNegEqProofs tl)", "start": [142, 1], "end": [155, 45], "kind": "commanddeclaration"}, {"full_name": "Linarith.proveEqZeroUsing", "code": "def proveEqZeroUsing (tac : TacticM Unit) (e : Expr) : MetaM Expr := do\n  let \u27e8u, \u03b1, e\u27e9 \u2190 inferTypeQ' e\n  let _h : Q(Zero $\u03b1) \u2190 synthInstanceQ q(Zero $\u03b1)\n  synthesizeUsing' q($e = 0) tac", "start": [157, 1], "end": [163, 33], "kind": "commanddeclaration"}, {"full_name": "Linarith.proveFalseByLinarith", "code": "def proveFalseByLinarith (cfg : LinarithConfig) : MVarId \u2192 List Expr \u2192 MetaM Expr\n  | _, [] => throwError \"no args to linarith\"\n  | g, l@(h::_) => do\n      trace[linarith.detail] \"Beginning work in `proveFalseByLinarith`.\"\n      let l' \u2190 addNegEqProofs l\n      trace[linarith.detail] \"... finished `addNegEqProofs`.\"\n      let inputs := (\u2190 mkNegOneLtZeroProof (\u2190 typeOfIneqProof h))::l'.reverse\n      trace[linarith.detail] \"... finished `mkNegOneLtZeroProof`.\"\n      trace[linarith.detail] (\u2190 inputs.mapM inferType)\n      let (comps, max_var) \u2190 linearFormsAndMaxVar cfg.transparency inputs\n      trace[linarith.detail] \"... finished `linearFormsAndMaxVar`.\"\n      trace[linarith.detail] \"{comps}\"\n      let oracle := cfg.oracle.getD FourierMotzkin.produceCertificate\n      let certificate : Std.HashMap Nat Nat \u2190 try\n        oracle comps max_var\n      catch e =>\n        trace[linarith] e.toMessageData\n        throwError \"linarith failed to find a contradiction\"\n      trace[linarith] \"linarith has found a contradiction: {certificate.toList}\"\n      let enum_inputs := inputs.enum\n      let zip := enum_inputs.filterMap fun \u27e8n, e\u27e9 => (certificate.find? n).map (e, \u00b7)\n      let mls \u2190 zip.mapM fun \u27e8e, n\u27e9 => do mulExpr n (\u2190 leftOfIneqProof e)\n      let sm \u2190 addExprs mls\n      trace[linarith] \"The expression\\n  {sm}\\nshould be both 0 and negative\"\n      let sm_eq_zero \u2190 proveEqZeroUsing cfg.discharger sm\n      let sm_lt_zero \u2190 mkLTZeroProof zip\n      let pftp \u2190 inferType sm_lt_zero\n      let \u27e8_, nep, _\u27e9 \u2190 g.rewrite pftp sm_eq_zero\n      let pf' \u2190 mkAppM ``Eq.mp #[nep, sm_lt_zero]\n      mkAppM ``Linarith.lt_irrefl #[pf']", "start": [167, 1], "end": [229, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Preprocessing.lean", "imports": ["Mathlib/Tactic/Linarith/Datatypes.lean", "Mathlib/Tactic/Zify.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/HashMap.lean", "Mathlib/Tactic/CancelDenoms/Core.lean", "lake-packages/std/Std/Data/RBMap/Basic.lean", "Mathlib/Lean/Exception.lean"], "premises": [{"full_name": "Linarith.splitConjunctions", "code": "partial def splitConjunctions : Preprocessor where\n  name := \"split conjunctions\"\n  transform := aux\nwhere\n  \n  aux (proof : Expr) : MetaM (List Expr) := do\n    match (\u2190 instantiateMVars (\u2190 inferType proof)).getAppFnArgs with\n    | (``And, #[_, _]) =>\n      pure ((\u2190 aux (\u2190 mkAppM ``And.left #[proof])) ++\n        (\u2190 aux (\u2190 mkAppM ``And.right #[proof])))\n    | _ => pure [proof]", "start": [38, 1], "end": [49, 24], "kind": "commanddeclaration"}, {"full_name": "Linarith.filterComparisons", "code": "partial def filterComparisons : Preprocessor where\n  name := \"filter terms that are not proofs of comparisons\"\n  transform h := do\n    let tp \u2190 whnfR (\u2190 instantiateMVars (\u2190 inferType h))\n    if (\u2190 isProp tp) && (\u2190 aux tp) then pure [h]\n    else pure []\nwhere\n  \n  aux (e : Expr) : MetaM Bool := do\n  match e.getAppFnArgs with\n  | (``Eq, _) | (``LE.le, _) | (``LT.lt, _) => pure true\n  | (``Not, #[e]) => match (\u2190 whnfR e).getAppFnArgs with\n    | (``LE.le, _) | (``LT.lt, _) => pure true\n    | _ => pure false\n  | _ => pure false", "start": [51, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "Linarith.flipNegatedComparison", "code": "def flipNegatedComparison (prf : Expr) (e : Expr) : MetaM Expr :=\n  match e.getAppFnArgs with\n  | (``LE.le, #[_, _, _, _]) => mkAppM ``lt_of_not_ge #[prf]\n  | (``LT.lt, #[_, _, _, _]) => mkAppM ``le_of_not_gt #[prf]\n  | _ => throwError \"Not a comparison (flipNegatedComparison): {e}\"", "start": [72, 1], "end": [81, 68], "kind": "commanddeclaration"}, {"full_name": "Linarith.removeNegations", "code": "def removeNegations : Preprocessor where\n  name := \"replace negations of comparisons\"\n  transform h := do\n    let t : Q(Prop) \u2190 whnfR (\u2190 inferType h)\n    match t with\n    | ~q(\u00ac $p) =>\n      trace[linarith] \"removing negation in {h}\"\n      return [\u2190 flipNegatedComparison h (\u2190 whnfR p)]\n    | _        => return [h]", "start": [83, 1], "end": [95, 29], "kind": "commanddeclaration"}, {"full_name": "Linarith.isNatProp", "code": "partial def isNatProp (e : Expr) : Bool :=\n  match e.getAppFnArgs with\n  | (``Eq, #[.const ``Nat [], _, _]) => true\n  | (``LE.le, #[.const ``Nat [], _, _, _]) => true\n  | (``LT.lt, #[.const ``Nat [], _, _, _]) => true\n  | (``GE.ge, #[.const ``Nat [], _, _, _]) => true\n  | (``GT.gt, #[.const ``Nat [], _, _, _]) => true\n  | (``Not, #[e]) => isNatProp e\n  | _ => false", "start": [103, 1], "end": [115, 15], "kind": "commanddeclaration"}, {"full_name": "Linarith.isNatIntCoe", "code": "def isNatIntCoe (e : Expr) : Option Expr :=\n  match e.getAppFnArgs with\n  | (``Nat.cast, #[.const ``Int [], _, n]) => some n\n  | _ => none", "start": [117, 1], "end": [121, 14], "kind": "commanddeclaration"}, {"full_name": "Linarith.getNatComparisons", "code": "partial def getNatComparisons (e : Expr) : List Expr :=\n  match isNatIntCoe e with\n  | some n => [n]\n  | none => match e.getAppFnArgs with\n    | (``HAdd.hAdd, #[_, _, _, _, a, b]) => getNatComparisons a ++ getNatComparisons b\n    | (``HMul.hMul, #[_, _, _, _, a, b]) => getNatComparisons a ++ getNatComparisons b\n    | _ => []", "start": [123, 1], "end": [132, 14], "kind": "commanddeclaration"}, {"full_name": "Linarith.mk_coe_nat_nonneg_prf", "code": "def mk_coe_nat_nonneg_prf (e : Expr) : MetaM Expr :=\n  mkAppM ``Int.coe_nat_nonneg #[e]", "start": [134, 1], "end": [136, 35], "kind": "commanddeclaration"}, {"full_name": "Linarith.Expr.compare", "code": "def Expr.compare (a b : Expr) : Ordering :=\n  if Expr.lt a b then .lt else if a.equal b then .eq else .gt", "start": [140, 1], "end": [143, 62], "kind": "commanddeclaration"}, {"full_name": "Linarith.natToInt", "code": "def natToInt : GlobalBranchingPreprocessor where\n  name := \"move nats to ints\"\n  transform g l := do\n    let l \u2190 l.mapM $ fun h => do\n      let t \u2190 whnfR (\u2190 instantiateMVars (\u2190 inferType h))\n      if isNatProp t then\n        let (some (h', t'), _) \u2190 Term.TermElabM.run' (run_for g (zifyProof none h t))\n          | throwError \"zifyProof failed on {h}\"\n        if \u2190 filterComparisons.aux t' then\n          pure h'\n        else\n          pure h\n      else\n        pure h\n    let nonnegs \u2190 l.foldlM (init := \u2205) fun (es : RBSet Expr Expr.compare) h => do\n      try\n        let (a, b) \u2190 getRelSides (\u2190 inferType h)\n        pure <| (es.insertList (getNatComparisons a)).insertList (getNatComparisons b)\n      catch _ => pure es\n    pure [(g, ((\u2190 nonnegs.toList.mapM mk_coe_nat_nonneg_prf) ++ l : List Expr))]", "start": [145, 1], "end": [174, 81], "kind": "commanddeclaration"}, {"full_name": "Linarith.isStrictIntComparison", "code": "def isStrictIntComparison (e : Expr) : Bool :=\n  match e.getAppFnArgs with\n  | (``LT.lt, #[.const ``Int [], _, _, _]) => true\n  | (``GT.gt, #[.const ``Int [], _, _, _]) => true\n  | (``Not, #[e]) => match e.getAppFnArgs with\n    | (``LE.le, #[.const ``Int [], _, _, _]) => true\n    | (``GE.ge, #[.const ``Int [], _, _, _]) => true\n    | _ => false\n  | _ => false", "start": [180, 1], "end": [192, 15], "kind": "commanddeclaration"}, {"full_name": "Linarith.mkNonstrictIntProof", "code": "def mkNonstrictIntProof (pf : Expr) : MetaM Expr := do\n  match (\u2190 inferType pf).getAppFnArgs with\n  | (``LT.lt, #[_, _, a, b]) =>\n    return mkApp (\u2190 mkAppM ``Iff.mpr #[\u2190 mkAppOptM ``Int.add_one_le_iff #[a, b]]) pf\n  | (``GT.gt, #[_, _, a, b]) =>\n    return mkApp (\u2190 mkAppM ``Iff.mpr #[\u2190 mkAppOptM ``Int.add_one_le_iff #[b, a]]) pf\n  | (``Not, #[P]) => match P.getAppFnArgs with\n    | (``LE.le, #[_, _, a, b]) =>\n      return mkApp (\u2190 mkAppM ``Iff.mpr #[\u2190 mkAppOptM ``Int.add_one_le_iff #[b, a]])\n        (\u2190 mkAppM ``lt_of_not_ge #[pf])\n    | (``GE.ge, #[_, _, a, b]) =>\n      return mkApp (\u2190 mkAppM ``Iff.mpr #[\u2190 mkAppOptM ``Int.add_one_le_iff #[a, b]])\n        (\u2190 mkAppM ``lt_of_not_ge #[pf])\n    | _ => throwError \"mkNonstrictIntProof failed: proof is not an inequality\"\n  | _ => throwError \"mkNonstrictIntProof failed: proof is not an inequality\"", "start": [194, 1], "end": [213, 77], "kind": "commanddeclaration"}, {"full_name": "Linarith.strengthenStrictInt", "code": "def strengthenStrictInt : Preprocessor where\n  name := \"strengthen strict inequalities over int\"\n  transform h := do\n    if isStrictIntComparison (\u2190 inferType h) then\n      return [\u2190 mkNonstrictIntProof h]\n    else\n      return [h]", "start": [216, 1], "end": [224, 17], "kind": "commanddeclaration"}, {"full_name": "Linarith.rearrangeComparison", "code": "partial def rearrangeComparison (e : Expr) : MetaM Expr := do\n  aux e (\u2190 instantiateMVars (\u2190 inferType e))\nwhere\n  \n  aux (proof e : Expr) : MetaM Expr :=\n    match e.getAppFnArgs with\n    | (``LE.le, #[_, _, a, b]) => match a.getAppFnArgs, b.getAppFnArgs with\n      | _, (``OfNat.ofNat, #[_, .lit (.natVal 0), _]) => return proof\n      | (``OfNat.ofNat, #[_, .lit (.natVal 0), _]), _ => mkAppM ``neg_nonpos_of_nonneg #[proof]\n      | _, _                                          => mkAppM ``sub_nonpos_of_le #[proof]\n    | (``LT.lt, #[_, _, a, b]) => match a.getAppFnArgs, b.getAppFnArgs with\n      | _, (``OfNat.ofNat, #[_, .lit (.natVal 0), _]) => return proof\n      | (``OfNat.ofNat, #[_, .lit (.natVal 0), _]), _ => mkAppM ``neg_neg_of_pos #[proof]\n      | _, _                                          => mkAppM ``sub_neg_of_lt #[proof]\n    | (``Eq, #[_, a, b]) => match a.getAppFnArgs, b.getAppFnArgs with\n      | _, (``OfNat.ofNat, #[_, .lit (.natVal 0), _]) => return proof\n      | (``OfNat.ofNat, #[_, .lit (.natVal 0), _]), _ => mkAppM ``Eq.symm #[proof]\n      | _, _                                          => mkAppM ``sub_eq_zero_of_eq #[proof]\n    | (``GT.gt, #[_, _, a, b]) => match a.getAppFnArgs, b.getAppFnArgs with\n      | _, (``OfNat.ofNat, #[_, .lit (.natVal 0), _]) => mkAppM ``neg_neg_of_pos #[proof]\n      | (``OfNat.ofNat, #[_, .lit (.natVal 0), _]), _ => mkAppM ``lt_zero_of_zero_gt #[proof]\n      | _, _                                          => mkAppM ``sub_neg_of_lt #[proof]\n    | (``GE.ge, #[_, _, a, b]) => match a.getAppFnArgs, b.getAppFnArgs with\n      | _, (``OfNat.ofNat, #[_, .lit (.natVal 0), _]) => mkAppM ``neg_nonpos_of_nonneg #[proof]\n      | (``OfNat.ofNat, #[_, .lit (.natVal 0), _]), _ => mkAppM ``le_zero_of_zero_ge #[proof]\n      | _, _                                          => mkAppM ``sub_nonpos_of_le #[proof]\n    | (``Not, #[a]) => do\n      let nproof \u2190 flipNegatedComparison proof a\n      aux nproof (\u2190 inferType nproof)\n    | a => throwError \"couldn't rearrange comparison {a}\"", "start": [230, 1], "end": [263, 58], "kind": "commanddeclaration"}, {"full_name": "Linarith.compWithZero", "code": "def compWithZero : Preprocessor where\n  name := \"make comparisons with zero\"\n  transform e := try\n    pure [\u2190 rearrangeComparison e]\n  catch e =>\n    if \u2190 e.isFailedToSynthesize then\n      pure []\n    else\n      throw e", "start": [265, 1], "end": [277, 14], "kind": "commanddeclaration"}, {"full_name": "Linarith.without_one_mul", "code": "theorem without_one_mul [MulOneClass M] {a b : M} (h : 1 * a = b) : a = b", "start": [283, 1], "end": [283, 99], "kind": "commanddeclaration"}, {"full_name": "Linarith.normalizeDenominatorsLHS", "code": "def normalizeDenominatorsLHS (h lhs : Expr) : MetaM Expr := do\n  let mut (v, lhs') \u2190 CancelDenoms.derive lhs\n  if v = 1 then\n    lhs' \u2190 mkAppM ``without_one_mul #[lhs']\n  let (_, h'') \u2190 mkSingleCompZeroOf v h\n  try\n    h''.rewriteType lhs'\n  catch e =>\n    dbg_trace\n      s!\"Error in Linarith.normalizeDenominatorsLHS: {\u2190 e.toMessageData.toString}\"\n    throw e", "start": [285, 1], "end": [301, 12], "kind": "commanddeclaration"}, {"full_name": "Linarith.cancelDenoms", "code": "def cancelDenoms : Preprocessor where\n  name := \"cancel denominators\"\n  transform := fun pf => (do\n      let (_, lhs) \u2190 parseCompAndExpr (\u2190 inferType pf)\n      guard $ lhs.containsConst (fun n => n = ``HDiv.hDiv || n = ``Div.div)\n      pure [\u2190 normalizeDenominatorsLHS pf lhs])\n    <|> return [pf]", "start": [303, 1], "end": [313, 20], "kind": "commanddeclaration"}, {"full_name": "Linarith.findSquares", "code": "partial def findSquares (s : HashSet (Expr \u00d7 Bool)) (e : Expr) : MetaM (HashSet (Expr \u00d7 Bool)) :=\n  match e.getAppFnArgs with\n  | (``HPow.hPow, #[_, _, _, _, a, b]) => match b.numeral? with\n    | some 2 => do\n      let s \u2190 findSquares s a\n      return (s.insert (a, true))\n    | _ => e.foldlM findSquares s\n  | (``HMul.hMul, #[_, _, _, _, a, b]) => if a.equal b then do\n      let s \u2190 findSquares s a\n      return (s.insert (a, false))\n    else\n      e.foldlM findSquares s\n  | _ => e.foldlM findSquares s", "start": [317, 1], "end": [334, 32], "kind": "commanddeclaration"}, {"full_name": "Linarith.nlinarithExtras", "code": "def nlinarithExtras : GlobalPreprocessor where\n  name := \"nonlinear arithmetic extras\"\n  transform ls := do\n    let s \u2190 ls.foldrM (fun h s' => do findSquares s' (\u2190 instantiateMVars (\u2190 inferType h)))\n      HashSet.empty\n    let new_es \u2190 s.foldM (fun new_es (\u27e8e, is_sq\u27e9 : Expr \u00d7 Bool) =>\n      ((do\n        let p \u2190 mkAppM (if is_sq then ``sq_nonneg else ``mul_self_nonneg) #[e]\n        pure $ p::new_es) <|> pure new_es)) ([] : List Expr)\n    let new_es \u2190 compWithZero.globalize.transform new_es\n    trace[linarith] \"nlinarith preprocessing found squares\"\n    trace[linarith] \"{s.toList}\"\n    linarithTraceProofs \"so we added proofs\" new_es\n    let with_comps \u2190 (new_es ++ ls).mapM (fun e => do\n      let tp \u2190 inferType e\n      try\n        let \u27e8ine, _\u27e9 \u2190 parseCompAndExpr tp\n        pure (ine, e)\n      catch _ => pure (Ineq.lt, e))\n    let products \u2190 with_comps.mapDiagM $ fun (\u27e8posa, a\u27e9 : Ineq \u00d7 Expr) \u27e8posb, b\u27e9 =>\n      try\n        (some <$> match posa, posb with\n          | Ineq.eq, _ => mkAppM ``zero_mul_eq #[a, b]\n          | _, Ineq.eq => mkAppM ``mul_zero_eq #[a, b]\n          | Ineq.lt, Ineq.lt => mkAppM ``mul_pos_of_neg_of_neg #[a, b]\n          | Ineq.lt, Ineq.le => do\n              let a \u2190 mkAppM ``le_of_lt #[a]\n              mkAppM ``mul_nonneg_of_nonpos_of_nonpos #[a, b]\n          | Ineq.le, Ineq.lt => do\n              let b \u2190 mkAppM ``le_of_lt #[b]\n              mkAppM ``mul_nonneg_of_nonpos_of_nonpos #[a, b]\n          | Ineq.le, Ineq.le => mkAppM ``mul_nonneg_of_nonpos_of_nonpos #[a, b])\n      catch _ => pure none\n    let products \u2190 compWithZero.globalize.transform products.reduceOption\n    return (new_es ++ ls ++ products)", "start": [336, 1], "end": [379, 38], "kind": "commanddeclaration"}, {"full_name": "Linarith.removeNe_aux", "code": "partial def removeNe_aux : MVarId \u2192 List Expr \u2192 MetaM (List Branch) := fun g hs => do\n  let some (e, \u03b1, a, b) \u2190 hs.findSomeM? (fun e : Expr => do\n    let some (\u03b1, a, b) := (\u2190 inferType e).ne?' | return none\n    return some (e, \u03b1, a, b)) | return [(g, hs)]\n  let [ng1, ng2] \u2190 g.apply (\u2190 mkAppOptM ``Or.elim #[none, none, \u2190 g.getType,\n      \u2190 mkAppOptM ``lt_or_gt_of_ne #[\u03b1, none, a, b, e]]) | failure\n  let do_goal : MVarId \u2192 MetaM (List Branch) := fun g => do\n    let (f, h) \u2190 g.intro1\n    h.withContext do\n      let ls \u2190 removeNe_aux h $ hs.removeAll [e]\n      return ls.map (fun b : Branch => (b.1, (.fvar f)::b.2))\n  return ((\u2190 do_goal ng1) ++ (\u2190 do_goal ng2))", "start": [384, 1], "end": [400, 46], "kind": "commanddeclaration"}, {"full_name": "Linarith.removeNe", "code": "def removeNe : GlobalBranchingPreprocessor where\n  name := \"removeNe\"\n  transform := removeNe_aux", "start": [402, 1], "end": [409, 28], "kind": "commanddeclaration"}, {"full_name": "Linarith.defaultPreprocessors", "code": "def defaultPreprocessors : List GlobalBranchingPreprocessor :=\n  [filterComparisons, removeNegations, natToInt, strengthenStrictInt,\n    compWithZero, cancelDenoms]", "start": [413, 1], "end": [418, 32], "kind": "commanddeclaration"}, {"full_name": "Linarith.preprocess", "code": "def preprocess (pps : List GlobalBranchingPreprocessor) (g : MVarId) (l : List Expr) :\n    MetaM (List Branch) :=\n  pps.foldlM (fun ls pp => return (\u2190 ls.mapM fun (g, l) => do pp.process g l).join) [(g, l)]", "start": [420, 1], "end": [429, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/NatAntidiagonal.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/List/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.Nat.antidiagonal", "code": "def antidiagonal (n : \u2115) : List (\u2115 \u00d7 \u2115) :=\n  (range (n + 1)).map fun i \u21a6 (i, n - i)", "start": [31, 1], "end": [33, 41], "kind": "commanddeclaration"}, {"full_name": "List.Nat.mem_antidiagonal", "code": "@[simp]\ntheorem mem_antidiagonal {n : \u2115} {x : \u2115 \u00d7 \u2115} : x \u2208 antidiagonal n \u2194 x.1 + x.2 = n", "start": [36, 1], "end": [47, 63], "kind": "commanddeclaration"}, {"full_name": "List.Nat.length_antidiagonal", "code": "@[simp]\ntheorem length_antidiagonal (n : \u2115) : (antidiagonal n).length = n + 1", "start": [50, 1], "end": [53, 46], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonal_zero", "code": "@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = [(0, 0)]", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "List.Nat.nodup_antidiagonal", "code": "theorem nodup_antidiagonal (n : \u2115) : Nodup (antidiagonal n)", "start": [62, 1], "end": [64, 99], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonal_succ", "code": "@[simp]\ntheorem antidiagonal_succ {n : \u2115} :\n    antidiagonal (n + 1) = (0, n + 1) :: (antidiagonal n).map (Prod.map Nat.succ id)", "start": [67, 1], "end": [73, 12], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonal_succ'", "code": "theorem antidiagonal_succ' {n : \u2115} :\n    antidiagonal (n + 1) = (antidiagonal n).map (Prod.map id Nat.succ) ++ [(n + 1, 0)]", "start": [76, 1], "end": [82, 92], "kind": "commanddeclaration"}, {"full_name": "List.Nat.antidiagonal_succ_succ'", "code": "theorem antidiagonal_succ_succ' {n : \u2115} :\n    antidiagonal (n + 2) =\n      (0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)]", "start": [85, 1], "end": [92, 7], "kind": "commanddeclaration"}, {"full_name": "List.Nat.map_swap_antidiagonal", "code": "theorem map_swap_antidiagonal {n : \u2115} :\n    (antidiagonal n).map Prod.swap = (antidiagonal n).reverse", "start": [95, 1], "end": [100, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Bitwise.lean", "imports": ["Mathlib/Data/List/Basic.lean", "Mathlib/Tactic/Set.lean", "Mathlib/Data/Nat/Size.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.bitwise_zero_left", "code": "@[simp]\nlemma bitwise_zero_left (m : Nat) : bitwise f 0 m = if f false true then m else 0 :=\n  rfl", "start": [47, 1], "end": [49, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bitwise_zero_right", "code": "@[simp]\nlemma bitwise_zero_right (n : Nat) : bitwise f n 0 = if f true false then n else 0 := by\n  unfold bitwise\n  simp only [ite_self, decide_False, Nat.zero_div, ite_true, ite_eq_right_iff]\n  rintro \u27e8\u27e9\n  split_ifs <;> rfl", "start": [52, 1], "end": [57, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bitwise_zero", "code": "lemma bitwise_zero : bitwise f 0 0 = 0 := by\n  simp only [bitwise_zero_right, ite_self]", "start": [60, 1], "end": [61, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bitwise_of_ne_zero", "code": "@[simp]\nlemma bitwise_of_ne_zero {n m : Nat} (hn : n \u2260 0) (hm : m \u2260 0) :\n    bitwise f n m = bit (f (bodd n) (bodd m)) (bitwise f (n / 2) (m / 2)) := by\n  conv_lhs => unfold bitwise\n  have mod_two_iff_bod x : (x % 2 = 1 : Bool) = bodd x := by\n    simp [mod_two_of_bodd, cond]; cases bodd x <;> rfl\n  simp only [hn, hm, mod_two_iff_bod, ite_false, bit, bit1, bit0, Bool.cond_eq_ite]\n  split_ifs <;> rfl", "start": [64, 1], "end": [71, 20], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.binaryRec_of_ne_zero", "code": "theorem binaryRec_of_ne_zero {C : Nat \u2192 Sort*} (z : C 0) (f : \u2200 b n, C n \u2192 C (bit b n)) {n}\n    (h : n \u2260 0) :\n    binaryRec z f n = bit_decomp n \u25b8 f (bodd n) (div2 n) (binaryRec z f (div2 n))", "start": [73, 1], "end": [79, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.bitwise_bit", "code": "@[simp]\nlemma bitwise_bit {f : Bool \u2192 Bool \u2192 Bool} (h : f false false = false := by rfl) (a m b n) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by\n  conv_lhs => unfold bitwise\n  simp only [bit, bit1, bit0, Bool.cond_eq_ite]\n  have h1 x :     (x + x) % 2 = 0 := by rw [\u2190 two_mul, mul_comm]; apply mul_mod_left\n  have h2 x : (x + x + 1) % 2 = 1 := by rw [\u2190 two_mul, add_comm]; apply add_mul_mod_self_left\n  have h3 x :     (x + x) / 2 = x := by rw [\u2190 two_mul, mul_comm]; apply mul_div_left _ zero_lt_two\n  have h4 x : (x + x + 1) / 2 = x := by rw [\u2190 two_mul, add_comm]; simp [add_mul_div_left]\n  cases a <;> cases b <;> simp [h1, h2, h3, h4] <;> split_ifs <;> simp_all", "start": [81, 1], "end": [90, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bit_mod_two", "code": "lemma bit_mod_two (a : Bool) (x : \u2115) :\n    bit a x % 2 = if a then 1 else 0 := by\n  simp [bit, bit0, bit1, Bool.cond_eq_ite, \u2190mul_two]\n  split_ifs <;> simp [Nat.add_mod]", "start": [93, 1], "end": [96, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bit_mod_two_eq_zero_iff", "code": "@[simp]\nlemma bit_mod_two_eq_zero_iff (a x) :\n    bit a x % 2 = 0 \u2194 !a := by\n  rw [bit_mod_two]; split_ifs <;> simp_all", "start": [98, 1], "end": [101, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bit_mod_two_eq_one_iff", "code": "@[simp]\nlemma bit_mod_two_eq_one_iff (a x) :\n    bit a x % 2 = 1 \u2194 a := by\n  rw [bit_mod_two]; split_ifs <;> simp_all", "start": [103, 1], "end": [106, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.lor_bit", "code": "@[simp]\ntheorem lor_bit : \u2200 a m b n, bit a m ||| bit b n = bit (a || b) (m ||| n)", "start": [108, 1], "end": [110, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.land_bit", "code": "@[simp]\ntheorem land_bit : \u2200 a m b n, bit a m &&& bit b n = bit (a && b) (m &&& n)", "start": [113, 1], "end": [115, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.ldiff_bit", "code": "@[simp]\ntheorem ldiff_bit : \u2200 a m b n, ldiff (bit a m) (bit b n) = bit (a && not b) (ldiff m n)", "start": [118, 1], "end": [120, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_bit", "code": "@[simp]\ntheorem xor_bit : \u2200 a m b n, bit a m ^^^ bit b n = bit (bne a b) (m ^^^ n)", "start": [123, 1], "end": [125, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_bitwise", "code": "@[simp]\ntheorem testBit_bitwise {f : Bool \u2192 Bool \u2192 Bool} (h : f false false = false) (m n k) :\n    testBit (bitwise f m n) k = f (testBit m k) (testBit n k)", "start": [128, 1], "end": [136, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_lor", "code": "@[simp]\ntheorem testBit_lor : \u2200 m n k, testBit (m ||| n) k = (testBit m k || testBit n k)", "start": [139, 1], "end": [141, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_land", "code": "@[simp]\ntheorem testBit_land : \u2200 m n k, testBit (m &&& n) k = (testBit m k && testBit n k)", "start": [144, 1], "end": [146, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_ldiff", "code": "@[simp]\ntheorem testBit_ldiff : \u2200 m n k, testBit (ldiff m n) k = (testBit m k && not (testBit n k))", "start": [149, 1], "end": [151, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_xor", "code": "@[simp]\ntheorem testBit_xor : \u2200 m n k, testBit (m ^^^ n) k = bne (testBit m k) (testBit n k)", "start": [154, 1], "end": [156, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_false", "code": "@[simp]\ntheorem bit_false : bit false = bit0", "start": [161, 1], "end": [163, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_true", "code": "@[simp]\ntheorem bit_true : bit true = bit1", "start": [166, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_eq_zero", "code": "@[simp]\ntheorem bit_eq_zero {n : \u2115} {b : Bool} : n.bit b = 0 \u2194 n = 0 \u2227 b = false", "start": [171, 1], "end": [173, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.bit_ne_zero_iff", "code": "theorem bit_ne_zero_iff {n : \u2115} {b : Bool} : n.bit b \u2260 0 \u2194 n = 0 \u2192 b = true", "start": [176, 1], "end": [177, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.bitwise_bit'", "code": "lemma bitwise_bit' {f : Bool \u2192 Bool \u2192 Bool} (a : Bool) (m : Nat) (b : Bool) (n : Nat)\n    (ham : m = 0 \u2192 a = true) (hbn : n = 0 \u2192 b = true) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by\n  conv_lhs => unfold bitwise\n  rw [\u2190bit_ne_zero_iff] at ham hbn\n  simp only [ham, hbn, bit_mod_two_eq_one_iff, Bool.decide_coe, \u2190 div2_val, div2_bit, ne_eq,\n    ite_false]\n  conv_rhs => simp only [bit, bit1, bit0, Bool.cond_eq_ite]\n  split_ifs with hf <;> rfl", "start": [179, 1], "end": [190, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.bitwise_eq_binaryRec", "code": "lemma bitwise_eq_binaryRec (f : Bool \u2192 Bool \u2192 Bool) :\n    bitwise f =\n    binaryRec (fun n => cond (f false true) n 0) fun a m Ia =>\n      binaryRec (cond (f true false) (bit a m) 0) fun b n _ => bit (f a b) (Ia n) := by\n  funext x y\n  induction x using binaryRec' generalizing y with\n  | z => simp only [bitwise_zero_left, binaryRec_zero, Bool.cond_eq_ite]\n  | f xb x hxb ih =>\n    rw [\u2190bit_ne_zero_iff] at hxb\n    simp_rw [binaryRec_of_ne_zero _ _ hxb, bodd_bit, div2_bit, eq_rec_constant]\n    induction y using binaryRec' with\n    | z => simp only [bitwise_zero_right, binaryRec_zero, Bool.cond_eq_ite]\n    | f yb y hyb =>\n      rw [\u2190bit_ne_zero_iff] at hyb\n      simp_rw [binaryRec_of_ne_zero _ _ hyb, bitwise_of_ne_zero hxb hyb, bodd_bit, \u2190div2_val,\n        div2_bit, eq_rec_constant, ih]", "start": [192, 1], "end": [207, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.zero_of_testBit_eq_false", "code": "theorem zero_of_testBit_eq_false {n : \u2115} (h : \u2200 i, testBit n i = false) : n = 0", "start": [209, 1], "end": [213, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_testBit", "code": "@[simp]\ntheorem zero_testBit (i : \u2115) : testBit 0 i = false", "start": [216, 1], "end": [218, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_eq_inth", "code": "theorem testBit_eq_inth (n i : \u2115) : n.testBit i = n.bits.getI i", "start": [221, 1], "end": [227, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_of_testBit_eq", "code": "theorem eq_of_testBit_eq {n m : \u2115} (h : \u2200 i, testBit n i = testBit m i) : n = m", "start": [230, 1], "end": [240, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_most_significant_bit", "code": "theorem exists_most_significant_bit {n : \u2115} (h : n \u2260 0) :\n    \u2203 i, testBit n i = true \u2227 \u2200 j, i < j \u2192 testBit n j = false", "start": [243, 1], "end": [258, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_testBit", "code": "theorem lt_of_testBit {n m : \u2115} (i : \u2115) (hn : testBit n i = false) (hm : testBit m i = true)\n    (hnm : \u2200 j, i < j \u2192 testBit n j = testBit m j) : n < m", "start": [261, 1], "end": [289, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_two_pow_self", "code": "@[simp]\ntheorem testBit_two_pow_self (n : \u2115) : testBit (2 ^ n) n = true", "start": [292, 1], "end": [294, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_two_pow_of_ne", "code": "theorem testBit_two_pow_of_ne {n m : \u2115} (hm : n \u2260 m) : testBit (2 ^ n) m = false", "start": [297, 1], "end": [306, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.testBit_two_pow", "code": "theorem testBit_two_pow (n m : \u2115) : testBit (2 ^ n) m = (n = m)", "start": [309, 1], "end": [314, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.bitwise_swap", "code": "theorem bitwise_swap {f : Bool \u2192 Bool \u2192 Bool} :\n    bitwise (Function.swap f) = Function.swap (bitwise f)", "start": [317, 1], "end": [326, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.bitwise_comm", "code": "theorem bitwise_comm {f : Bool \u2192 Bool \u2192 Bool} (hf : \u2200 b b', f b b' = f b' b) (n m : \u2115) :\n    bitwise f n m = bitwise f m n", "start": [329, 1], "end": [336, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.lor_comm", "code": "theorem lor_comm (n m : \u2115) : n ||| m = m ||| n", "start": [339, 1], "end": [340, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.land_comm", "code": "theorem land_comm (n m : \u2115) : n &&& m = m &&& n", "start": [343, 1], "end": [344, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_comm", "code": "theorem xor_comm (n m : \u2115) : n ^^^ m = m ^^^ n", "start": [347, 1], "end": [348, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_xor", "code": "@[simp]\ntheorem zero_xor (n : \u2115) : 0 ^^^ n = n", "start": [351, 1], "end": [353, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_zero", "code": "@[simp]\ntheorem xor_zero (n : \u2115) : n ^^^ 0 = n", "start": [356, 1], "end": [357, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_land", "code": "@[simp]\ntheorem zero_land (n : \u2115) : 0 &&& n = 0", "start": [360, 1], "end": [362, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.land_zero", "code": "@[simp]\ntheorem land_zero (n : \u2115) : n &&& 0 = 0", "start": [365, 1], "end": [367, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lor", "code": "@[simp]\ntheorem zero_lor (n : \u2115) : 0 ||| n = n", "start": [370, 1], "end": [372, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.lor_zero", "code": "@[simp]\ntheorem lor_zero (n : \u2115) : n ||| 0 = n", "start": [375, 1], "end": [377, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_assoc", "code": "theorem xor_assoc (n m k : \u2115) : (n ^^^ m) ^^^ k = n ^^^ (m ^^^ k)", "start": [393, 1], "end": [393, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.land_assoc", "code": "theorem land_assoc (n m k : \u2115) : (n &&& m) &&& k = n &&& (m &&& k)", "start": [396, 1], "end": [396, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.lor_assoc", "code": "theorem lor_assoc (n m k : \u2115) : (n ||| m) ||| k = n ||| (m ||| k)", "start": [399, 1], "end": [399, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_self", "code": "@[simp]\ntheorem xor_self (n : \u2115) : n ^^^ n = 0", "start": [402, 1], "end": [404, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.lxor_cancel_right", "code": "theorem lxor_cancel_right (n m : \u2115) : (m ^^^ n) ^^^ n = m", "start": [408, 1], "end": [409, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_cancel_left", "code": "theorem xor_cancel_left (n m : \u2115) : n ^^^ (n ^^^ m) = m", "start": [412, 1], "end": [413, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_right_injective", "code": "theorem xor_right_injective {n : \u2115} : Function.Injective (HXor.hXor n : \u2115 \u2192 \u2115)", "start": [416, 1], "end": [417, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_left_injective", "code": "theorem xor_left_injective {n : \u2115} : Function.Injective fun m => m ^^^ n", "start": [420, 1], "end": [422, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_right_inj", "code": "@[simp]\ntheorem xor_right_inj {n m m' : \u2115} : n ^^^ m = n ^^^ m' \u2194 m = m'", "start": [425, 1], "end": [427, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_left_inj", "code": "@[simp]\ntheorem xor_left_inj {n m m' : \u2115} : m ^^^ n = m' ^^^ n \u2194 m = m'", "start": [430, 1], "end": [432, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_eq_zero", "code": "@[simp]\ntheorem xor_eq_zero {n m : \u2115} : n ^^^ m = 0 \u2194 n = m", "start": [435, 1], "end": [437, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_ne_zero", "code": "theorem xor_ne_zero {n m : \u2115} : n ^^^ m \u2260 0 \u2194 n \u2260 m", "start": [440, 1], "end": [441, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.xor_trichotomy", "code": "theorem xor_trichotomy {a b c : \u2115} (h : a \u2260 b ^^^ c) :\n    b ^^^ c < a \u2228 a ^^^ c < b \u2228 a ^^^ b < c", "start": [444, 1], "end": [481, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_xor_cases", "code": "theorem lt_xor_cases {a b c : \u2115} (h : a < b ^^^ c) : a ^^^ c < b \u2228 a ^^^ b < c", "start": [484, 1], "end": [485, 70], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Int/Bitwise.lean", "imports": ["Mathlib/Init/Data/Nat/Bitwise.lean", "Mathlib/Init/Data/Int/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.div2", "code": "def div2 : \u2124 \u2192 \u2124\n  | (n : \u2115) => n.div2\n  | -[n +1] => negSucc n.div2", "start": [22, 1], "end": [25, 30], "kind": "commanddeclaration"}, {"full_name": "Int.bodd", "code": "def bodd : \u2124 \u2192 Bool\n  | (n : \u2115) => n.bodd\n  | -[n +1] => not (n.bodd)", "start": [28, 1], "end": [31, 28], "kind": "commanddeclaration"}, {"full_name": "Int.bit", "code": "def bit (b : Bool) : \u2124 \u2192 \u2124 :=\n  cond b bit1 bit0", "start": [36, 1], "end": [39, 19], "kind": "commanddeclaration"}, {"full_name": "Int.testBit", "code": "def testBit : \u2124 \u2192 \u2115 \u2192 Bool\n  | (m : \u2115), n => Nat.testBit m n\n  | -[m +1], n => !(Nat.testBit m n)", "start": [42, 1], "end": [45, 37], "kind": "commanddeclaration"}, {"full_name": "Int.natBitwise", "code": "def natBitwise (f : Bool \u2192 Bool \u2192 Bool) (m n : \u2115) : \u2124 :=\n  cond (f false false) -[ Nat.bitwise (fun x y => not (f x y)) m n +1] (Nat.bitwise f m n)", "start": [48, 1], "end": [50, 91], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise", "code": "def bitwise (f : Bool \u2192 Bool \u2192 Bool) : \u2124 \u2192 \u2124 \u2192 \u2124\n  | (m : \u2115), (n : \u2115) => natBitwise f m n\n  | (m : \u2115), -[n +1] => natBitwise (fun x y => f x (not y)) m n\n  | -[m +1], (n : \u2115) => natBitwise (fun x y => f (not x) y) m n\n  | -[m +1], -[n +1] => natBitwise (fun x y => f (not x) (not y)) m n", "start": [53, 1], "end": [59, 70], "kind": "commanddeclaration"}, {"full_name": "Int.lnot", "code": "def lnot : \u2124 \u2192 \u2124\n  | (m : \u2115) => -[m +1]\n  | -[m +1] => m", "start": [62, 1], "end": [65, 17], "kind": "commanddeclaration"}, {"full_name": "Int.lor", "code": "def lor : \u2124 \u2192 \u2124 \u2192 \u2124\n  | (m : \u2115), (n : \u2115) => m ||| n\n  | (m : \u2115), -[n +1] => -[Nat.ldiff n m +1]\n  | -[m +1], (n : \u2115) => -[Nat.ldiff m n +1]\n  | -[m +1], -[n +1] => -[m &&& n +1]", "start": [68, 1], "end": [73, 38], "kind": "commanddeclaration"}, {"full_name": "Int.land", "code": "def land : \u2124 \u2192 \u2124 \u2192 \u2124\n  | (m : \u2115), (n : \u2115) => m &&& n\n  | (m : \u2115), -[n +1] => Nat.ldiff m n\n  | -[m +1], (n : \u2115) => Nat.ldiff n m\n  | -[m +1], -[n +1] => -[m ||| n +1]", "start": [76, 1], "end": [81, 38], "kind": "commanddeclaration"}, {"full_name": "Int.ldiff", "code": "def ldiff : \u2124 \u2192 \u2124 \u2192 \u2124\n  | (m : \u2115), (n : \u2115) => Nat.ldiff m n\n  | (m : \u2115), -[n +1] => m &&& n\n  | -[m +1], (n : \u2115) => -[m ||| n +1]\n  | -[m +1], -[n +1] => Nat.ldiff n m", "start": [85, 1], "end": [92, 38], "kind": "commanddeclaration"}, {"full_name": "Int.xor", "code": "protected def xor : \u2124 \u2192 \u2124 \u2192 \u2124\n  | (m : \u2115), (n : \u2115) => (m ^^^ n)\n  | (m : \u2115), -[n +1] => -[(m ^^^ n) +1]\n  | -[m +1], (n : \u2115) => -[(m ^^^ n) +1]\n  | -[m +1], -[n +1] => (m ^^^ n)", "start": [96, 1], "end": [101, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/GCD/Basic.lean", "imports": ["Mathlib/Algebra/GroupWithZero/Divisibility.lean", "Mathlib/Tactic/NthRewrite.lean", "Mathlib/Data/Nat/Order/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/GroupPower/Basic.lean"], "premises": [{"full_name": "Nat.gcd_greatest", "code": "theorem gcd_greatest {a b d : \u2115} (hda : d \u2223 a) (hdb : d \u2223 b) (hd : \u2200 e : \u2115, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) :\n    d = a.gcd b", "start": [28, 1], "end": [30, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_mul_right_right", "code": "@[simp]\ntheorem gcd_add_mul_right_right (m n k : \u2115) : gcd m (n + k * m) = gcd m n", "start": [34, 1], "end": [36, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_mul_left_right", "code": "@[simp]\ntheorem gcd_add_mul_left_right (m n k : \u2115) : gcd m (n + m * k) = gcd m n", "start": [39, 1], "end": [41, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_right_add_right", "code": "@[simp]\ntheorem gcd_mul_right_add_right (m n k : \u2115) : gcd m (k * m + n) = gcd m n", "start": [44, 1], "end": [45, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_left_add_right", "code": "@[simp]\ntheorem gcd_mul_left_add_right (m n k : \u2115) : gcd m (m * k + n) = gcd m n", "start": [48, 1], "end": [49, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_mul_right_left", "code": "@[simp]\ntheorem gcd_add_mul_right_left (m n k : \u2115) : gcd (m + k * n) n = gcd m n", "start": [52, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_mul_left_left", "code": "@[simp]\ntheorem gcd_add_mul_left_left (m n k : \u2115) : gcd (m + n * k) n = gcd m n", "start": [57, 1], "end": [59, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_right_add_left", "code": "@[simp]\ntheorem gcd_mul_right_add_left (m n k : \u2115) : gcd (k * n + m) n = gcd m n", "start": [62, 1], "end": [64, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_left_add_left", "code": "@[simp]\ntheorem gcd_mul_left_add_left (m n k : \u2115) : gcd (n * k + m) n = gcd m n", "start": [67, 1], "end": [69, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_self_right", "code": "@[simp]\ntheorem gcd_add_self_right (m n : \u2115) : gcd m (n + m) = gcd m n", "start": [73, 1], "end": [75, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_add_self_left", "code": "@[simp]\ntheorem gcd_add_self_left (m n : \u2115) : gcd (m + n) n = gcd m n", "start": [78, 1], "end": [80, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_self_add_left", "code": "@[simp]\ntheorem gcd_self_add_left (m n : \u2115) : gcd (m + n) m = gcd n m", "start": [83, 1], "end": [84, 101], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_self_add_right", "code": "@[simp]\ntheorem gcd_self_add_right (m n : \u2115) : gcd m (m + n) = gcd m n", "start": [87, 1], "end": [89, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_sub_self_left", "code": "@[simp]\ntheorem gcd_sub_self_left {m n : \u2115} (h : m \u2264 n) : gcd (n - m) m = gcd n m", "start": [93, 1], "end": [97, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_sub_self_right", "code": "@[simp]\ntheorem gcd_sub_self_right {m n : \u2115} (h : m \u2264 n) : gcd m (n - m) = gcd m n", "start": [99, 1], "end": [101, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_self_sub_left", "code": "@[simp]\ntheorem gcd_self_sub_left {m n : \u2115} (h : m \u2264 n) : gcd (n - m) n = gcd m n", "start": [103, 1], "end": [110, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_self_sub_right", "code": "@[simp]\ntheorem gcd_self_sub_right {m n : \u2115} (h : m \u2264 n) : gcd n (n - m) = gcd n m", "start": [112, 1], "end": [114, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_dvd_mul", "code": "theorem lcm_dvd_mul (m n : \u2115) : lcm m n \u2223 m * n", "start": [118, 1], "end": [119, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_dvd_iff", "code": "theorem lcm_dvd_iff {m n k : \u2115} : lcm m n \u2223 k \u2194 m \u2223 k \u2227 n \u2223 k", "start": [122, 1], "end": [123, 90], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_pos", "code": "theorem lcm_pos {m n : \u2115} : 0 < m \u2192 0 < n \u2192 0 < m.lcm n", "start": [126, 1], "end": [128, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_mul_left", "code": "theorem lcm_mul_left {m n k : \u2115} : (m * n).lcm (m * k) = m * n.lcm k", "start": [131, 1], "end": [135, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.lcm_mul_right", "code": "theorem lcm_mul_right {m n k : \u2115} : (m * n).lcm (k * n) = m.lcm k * n", "start": [137, 1], "end": [138, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.lcm_eq_mul", "code": "theorem Coprime.lcm_eq_mul {m n : \u2115} (h : Coprime m n) : lcm m n = m * n", "start": [148, 1], "end": [149, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.symmetric", "code": "theorem Coprime.symmetric : Symmetric Coprime", "start": [152, 1], "end": [152, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.dvd_mul_right", "code": "theorem Coprime.dvd_mul_right {m n k : \u2115} (H : Coprime k n) : k \u2223 m * n \u2194 k \u2223 m", "start": [155, 1], "end": [156, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.dvd_mul_left", "code": "theorem Coprime.dvd_mul_left {m n k : \u2115} (H : Coprime k m) : k \u2223 m * n \u2194 k \u2223 n", "start": [159, 1], "end": [160, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_self_right", "code": "@[simp]\ntheorem coprime_add_self_right {m n : \u2115} : Coprime m (n + m) \u2194 Coprime m n", "start": [163, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_self_add_right", "code": "@[simp]\ntheorem coprime_self_add_right {m n : \u2115} : Coprime m (m + n) \u2194 Coprime m n", "start": [168, 1], "end": [170, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_self_left", "code": "@[simp]\ntheorem coprime_add_self_left {m n : \u2115} : Coprime (m + n) n \u2194 Coprime m n", "start": [173, 1], "end": [175, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_self_add_left", "code": "@[simp]\ntheorem coprime_self_add_left {m n : \u2115} : Coprime (m + n) m \u2194 Coprime n m", "start": [178, 1], "end": [180, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_mul_right_right", "code": "@[simp]\ntheorem coprime_add_mul_right_right (m n k : \u2115) : Coprime m (n + k * m) \u2194 Coprime m n", "start": [183, 1], "end": [185, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_mul_left_right", "code": "@[simp]\ntheorem coprime_add_mul_left_right (m n k : \u2115) : Coprime m (n + m * k) \u2194 Coprime m n", "start": [188, 1], "end": [190, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_right_add_right", "code": "@[simp]\ntheorem coprime_mul_right_add_right (m n k : \u2115) : Coprime m (k * m + n) \u2194 Coprime m n", "start": [193, 1], "end": [195, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_left_add_right", "code": "@[simp]\ntheorem coprime_mul_left_add_right (m n k : \u2115) : Coprime m (m * k + n) \u2194 Coprime m n", "start": [198, 1], "end": [200, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_mul_right_left", "code": "@[simp]\ntheorem coprime_add_mul_right_left (m n k : \u2115) : Coprime (m + k * n) n \u2194 Coprime m n", "start": [203, 1], "end": [205, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_add_mul_left_left", "code": "@[simp]\ntheorem coprime_add_mul_left_left (m n k : \u2115) : Coprime (m + n * k) n \u2194 Coprime m n", "start": [208, 1], "end": [210, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_right_add_left", "code": "@[simp]\ntheorem coprime_mul_right_add_left (m n k : \u2115) : Coprime (k * n + m) n \u2194 Coprime m n", "start": [213, 1], "end": [215, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_mul_left_add_left", "code": "@[simp]\ntheorem coprime_mul_left_add_left (m n k : \u2115) : Coprime (n * k + m) n \u2194 Coprime m n", "start": [218, 1], "end": [220, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_sub_self_left", "code": "@[simp]\ntheorem coprime_sub_self_left {m n : \u2115} (h : m \u2264 n) : Coprime (n - m) m \u2194 Coprime n m", "start": [223, 1], "end": [225, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_sub_self_right", "code": "@[simp]\ntheorem coprime_sub_self_right {m n : \u2115} (h : m \u2264 n) : Coprime m (n - m) \u2194 Coprime m n", "start": [227, 1], "end": [229, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_self_sub_left", "code": "@[simp]\ntheorem coprime_self_sub_left {m n : \u2115} (h : m \u2264 n) : Coprime (n - m) n \u2194 Coprime m n", "start": [231, 1], "end": [233, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_self_sub_right", "code": "@[simp]\ntheorem coprime_self_sub_right {m n : \u2115} (h : m \u2264 n) : Coprime n (n - m) \u2194 Coprime n m", "start": [235, 1], "end": [237, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_pow_left_iff", "code": "@[simp]\ntheorem coprime_pow_left_iff {n : \u2115} (hn : 0 < n) (a b : \u2115) :\n    Nat.Coprime (a ^ n) b \u2194 Nat.Coprime a b", "start": [239, 1], "end": [244, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_pow_right_iff", "code": "@[simp]\ntheorem coprime_pow_right_iff {n : \u2115} (hn : 0 < n) (a b : \u2115) :\n    Nat.Coprime a (b ^ n) \u2194 Nat.Coprime a b", "start": [247, 1], "end": [250, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.not_coprime_zero_zero", "code": "theorem not_coprime_zero_zero : \u00acCoprime 0 0", "start": [253, 1], "end": [253, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_left_iff", "code": "theorem coprime_one_left_iff (n : \u2115) : Coprime 1 n \u2194 True", "start": [256, 1], "end": [256, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_one_right_iff", "code": "theorem coprime_one_right_iff (n : \u2115) : Coprime n 1 \u2194 True", "start": [259, 1], "end": [259, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_mul_of_coprime_of_dvd", "code": "theorem gcd_mul_of_coprime_of_dvd {a b c : \u2115} (hac : Coprime a c) (b_dvd_c : b \u2223 c) :\n    gcd (a * b) c = b", "start": [262, 1], "end": [267, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.eq_of_mul_eq_zero", "code": "theorem Coprime.eq_of_mul_eq_zero {m n : \u2115} (h : m.Coprime n) (hmn : m * n = 0) :\n    m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0", "start": [270, 1], "end": [274, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.prodDvdAndDvdOfDvdProd", "code": "def prodDvdAndDvdOfDvdProd {m n k : \u2115} (H : k \u2223 m * n) :\n    { d : { m' // m' \u2223 m } \u00d7 { n' // n' \u2223 n } // k = d.1 * d.2 } := by\n  cases h0 : gcd k m\n  case zero =>\n    obtain rfl : k = 0 := eq_zero_of_gcd_eq_zero_left h0\n    obtain rfl : m = 0 := eq_zero_of_gcd_eq_zero_right h0\n    exact \u27e8\u27e8\u27e80, dvd_refl 0\u27e9, \u27e8n, dvd_refl n\u27e9\u27e9, (zero_mul n).symm\u27e9\n  case succ tmp =>\n    have hpos : 0 < gcd k m := h0.symm \u25b8 Nat.zero_lt_succ _; clear h0 tmp\n    have hd : gcd k m * (k / gcd k m) = k := Nat.mul_div_cancel' (gcd_dvd_left k m)\n    refine' \u27e8\u27e8\u27e8gcd k m, gcd_dvd_right k m\u27e9, \u27e8k / gcd k m, _\u27e9\u27e9, hd.symm\u27e9\n    apply Nat.dvd_of_mul_dvd_mul_left hpos\n    rw [hd, \u2190 gcd_mul_right]\n    exact dvd_gcd (dvd_mul_right _ _) H", "start": [277, 1], "end": [294, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_mul", "code": "theorem dvd_mul {x m n : \u2115} : x \u2223 m * n \u2194 \u2203 y z, y \u2223 m \u2227 z \u2223 n \u2227 y * z = x", "start": [297, 1], "end": [303, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_dvd_pow_iff", "code": "theorem pow_dvd_pow_iff {a b n : \u2115} (n0 : 0 < n) : a ^ n \u2223 b ^ n \u2194 a \u2223 b", "start": [306, 1], "end": [315, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_one_of_dvd_coprimes", "code": "theorem eq_one_of_dvd_coprimes {a b k : \u2115} (h_ab_coprime : Coprime a b) (hka : k \u2223 a)\n    (hkb : k \u2223 b) : k = 1", "start": [318, 1], "end": [324, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.Coprime.mul_add_mul_ne_mul", "code": "theorem Coprime.mul_add_mul_ne_mul {m n a b : \u2115} (cop : Coprime m n) (ha : a \u2260 0) (hb : b \u2260 0) :\n    a * m + b * n \u2260 m * n", "start": [327, 1], "end": [340, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Connected/TotallyDisconnected.lean", "imports": ["Mathlib/Topology/Connected/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsTotallyDisconnected", "code": "def IsTotallyDisconnected (s : Set \u03b1) : Prop :=\n  \u2200 t, t \u2286 s \u2192 IsPreconnected t \u2192 t.Subsingleton", "start": [30, 1], "end": [33, 49], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_empty", "code": "theorem isTotallyDisconnected_empty : IsTotallyDisconnected (\u2205 : Set \u03b1)", "start": [36, 1], "end": [37, 17], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_singleton", "code": "theorem isTotallyDisconnected_singleton {x} : IsTotallyDisconnected ({x} : Set \u03b1)", "start": [40, 1], "end": [41, 33], "kind": "commanddeclaration"}, {"full_name": "TotallyDisconnectedSpace", "code": "class TotallyDisconnectedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  isTotallyDisconnected_univ : IsTotallyDisconnected (univ : Set \u03b1)", "start": [44, 1], "end": [47, 68], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.subsingleton", "code": "theorem IsPreconnected.subsingleton [TotallyDisconnectedSpace \u03b1] {s : Set \u03b1}\n    (h : IsPreconnected s) : s.Subsingleton", "start": [50, 1], "end": [52, 74], "kind": "commanddeclaration"}, {"full_name": "Pi.totallyDisconnectedSpace", "code": "instance Pi.totallyDisconnectedSpace {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type*}\n    [\u2200 a, TopologicalSpace (\u03b2 a)] [\u2200 a, TotallyDisconnectedSpace (\u03b2 a)] :\n    TotallyDisconnectedSpace (\u2200 a : \u03b1, \u03b2 a) :=\n  \u27e8fun t _ h2 =>\n    have this : \u2200 a, IsPreconnected ((fun x : \u2200 a, \u03b2 a => x a) '' t) := fun a =>\n      h2.image (fun x => x a) (continuous_apply a).continuousOn\n    fun x x_in y y_in => funext fun a => (this a).subsingleton \u27e8x, x_in, rfl\u27e9 \u27e8y, y_in, rfl\u27e9\u27e9", "start": [55, 1], "end": [61, 94], "kind": "commanddeclaration"}, {"full_name": "Prod.totallyDisconnectedSpace", "code": "instance Prod.totallyDisconnectedSpace [TopologicalSpace \u03b2] [TotallyDisconnectedSpace \u03b1]\n    [TotallyDisconnectedSpace \u03b2] : TotallyDisconnectedSpace (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun t _ h2 =>\n    have H1 : IsPreconnected (Prod.fst '' t) := h2.image Prod.fst continuous_fst.continuousOn\n    have H2 : IsPreconnected (Prod.snd '' t) := h2.image Prod.snd continuous_snd.continuousOn\n    fun x hx y hy =>\n    Prod.ext (H1.subsingleton \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9)\n      (H2.subsingleton \u27e8x, hx, rfl\u27e9 \u27e8y, hy, rfl\u27e9)\u27e9", "start": [64, 1], "end": [71, 51], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_of_clopen_set", "code": "theorem isTotallyDisconnected_of_clopen_set {X : Type*} [TopologicalSpace X]\n    (hX : Pairwise fun x y => \u2203 (U : Set X), IsClopen U \u2227 x \u2208 U \u2227 y \u2209 U) :\n    IsTotallyDisconnected (Set.univ : Set X)", "start": [90, 1], "end": [103, 34], "kind": "commanddeclaration"}, {"full_name": "totallyDisconnectedSpace_iff_connectedComponent_subsingleton", "code": "theorem totallyDisconnectedSpace_iff_connectedComponent_subsingleton :\n    TotallyDisconnectedSpace \u03b1 \u2194 \u2200 x : \u03b1, (connectedComponent x).Subsingleton", "start": [106, 1], "end": [118, 57], "kind": "commanddeclaration"}, {"full_name": "totallyDisconnectedSpace_iff_connectedComponent_singleton", "code": "theorem totallyDisconnectedSpace_iff_connectedComponent_singleton :\n    TotallyDisconnectedSpace \u03b1 \u2194 \u2200 x : \u03b1, connectedComponent x = {x}", "start": [122, 1], "end": [128, 31], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_eq_singleton", "code": "@[simp] theorem connectedComponent_eq_singleton [TotallyDisconnectedSpace \u03b1] (x : \u03b1) :\n    connectedComponent x = {x}", "start": [132, 1], "end": [134, 68], "kind": "commanddeclaration"}, {"full_name": "Continuous.image_connectedComponent_eq_singleton", "code": "@[simp]\ntheorem Continuous.image_connectedComponent_eq_singleton {\u03b2 : Type*} [TopologicalSpace \u03b2]\n    [TotallyDisconnectedSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Continuous f) (a : \u03b1) :\n    f '' connectedComponent a = {f a}", "start": [137, 1], "end": [143, 76], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_of_totallyDisconnectedSpace", "code": "theorem isTotallyDisconnected_of_totallyDisconnectedSpace [TotallyDisconnectedSpace \u03b1] (s : Set \u03b1) :\n    IsTotallyDisconnected s", "start": [146, 1], "end": [148, 73], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_of_image", "code": "theorem isTotallyDisconnected_of_image [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : ContinuousOn f s)\n    (hf' : Injective f) (h : IsTotallyDisconnected (f '' s)) : IsTotallyDisconnected s", "start": [151, 1], "end": [156, 32], "kind": "commanddeclaration"}, {"full_name": "Embedding.isTotallyDisconnected", "code": "theorem Embedding.isTotallyDisconnected [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Embedding f)\n    {s : Set \u03b1} (h : IsTotallyDisconnected (f '' s)) : IsTotallyDisconnected s", "start": [159, 1], "end": [161, 69], "kind": "commanddeclaration"}, {"full_name": "Subtype.totallyDisconnectedSpace", "code": "instance Subtype.totallyDisconnectedSpace {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [TopologicalSpace \u03b1]\n    [TotallyDisconnectedSpace \u03b1] : TotallyDisconnectedSpace (Subtype p) :=\n  \u27e8embedding_subtype_val.isTotallyDisconnected\n      (isTotallyDisconnected_of_totallyDisconnectedSpace _)\u27e9", "start": [164, 1], "end": [167, 61], "kind": "commanddeclaration"}, {"full_name": "IsTotallySeparated", "code": "def IsTotallySeparated (s : Set \u03b1) : Prop :=\n  \u2200 x \u2208 s, \u2200 y \u2208 s, x \u2260 y \u2192\n    \u2203 u v : Set \u03b1, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 s \u2286 u \u222a v \u2227 Disjoint u v", "start": [175, 1], "end": [179, 82], "kind": "commanddeclaration"}, {"full_name": "isTotallySeparated_empty", "code": "theorem isTotallySeparated_empty : IsTotallySeparated (\u2205 : Set \u03b1)", "start": [182, 1], "end": [182, 89], "kind": "commanddeclaration"}, {"full_name": "isTotallySeparated_singleton", "code": "theorem isTotallySeparated_singleton {x} : IsTotallySeparated ({x} : Set \u03b1)", "start": [185, 1], "end": [186, 78], "kind": "commanddeclaration"}, {"full_name": "isTotallyDisconnected_of_isTotallySeparated", "code": "theorem isTotallyDisconnected_of_isTotallySeparated {s : Set \u03b1} (H : IsTotallySeparated s) :\n    IsTotallyDisconnected s", "start": [189, 1], "end": [198, 33], "kind": "commanddeclaration"}, {"full_name": "IsTotallySeparated.isTotallyDisconnected", "code": "alias IsTotallySeparated.isTotallyDisconnected := isTotallyDisconnected_of_isTotallySeparated", "start": [201, 1], "end": [201, 94], "kind": "stdtacticaliasalias"}, {"full_name": "TotallySeparatedSpace", "code": "class TotallySeparatedSpace (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  isTotallySeparated_univ : IsTotallySeparated (univ : Set \u03b1)", "start": [204, 1], "end": [208, 62], "kind": "commanddeclaration"}, {"full_name": "TotallySeparatedSpace.totallyDisconnectedSpace", "code": "instance (priority := 100) TotallySeparatedSpace.totallyDisconnectedSpace (\u03b1 : Type u)\n    [TopologicalSpace \u03b1] [TotallySeparatedSpace \u03b1] : TotallyDisconnectedSpace \u03b1 :=\n  \u27e8TotallySeparatedSpace.isTotallySeparated_univ.isTotallyDisconnected\u27e9", "start": [212, 1], "end": [214, 72], "kind": "commanddeclaration"}, {"full_name": "TotallySeparatedSpace.of_discrete", "code": "instance (priority := 100) TotallySeparatedSpace.of_discrete (\u03b1 : Type*) [TopologicalSpace \u03b1]\n    [DiscreteTopology \u03b1] : TotallySeparatedSpace \u03b1 :=\n  \u27e8fun _ _ b _ h => \u27e8{b}\u1d9c, {b}, isOpen_discrete _, isOpen_discrete _, h, rfl,\n    (compl_union_self _).symm.subset, disjoint_compl_left\u27e9\u27e9", "start": [219, 1], "end": [222, 60], "kind": "commanddeclaration"}, {"full_name": "exists_clopen_of_totally_separated", "code": "theorem exists_clopen_of_totally_separated {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [TotallySeparatedSpace \u03b1] {x y : \u03b1} (hxy : x \u2260 y) :\n    \u2203 U : Set \u03b1, IsClopen U \u2227 x \u2208 U \u2227 y \u2208 U\u1d9c", "start": [225, 1], "end": [233, 35], "kind": "commanddeclaration"}, {"full_name": "Continuous.image_eq_of_connectedComponent_eq", "code": "theorem Continuous.image_eq_of_connectedComponent_eq (h : Continuous f) (a b : \u03b1)\n    (hab : connectedComponent a = connectedComponent b) : f a = f b", "start": [241, 1], "end": [245, 60], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsLift", "code": "def Continuous.connectedComponentsLift (h : Continuous f) : ConnectedComponents \u03b1 \u2192 \u03b2 := fun x =>\n  Quotient.liftOn' x f h.image_eq_of_connectedComponent_eq", "start": [248, 1], "end": [252, 59], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsLift_continuous", "code": "@[continuity]\ntheorem Continuous.connectedComponentsLift_continuous (h : Continuous f) :\n    Continuous h.connectedComponentsLift", "start": [255, 1], "end": [258, 71], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsLift_apply_coe", "code": "@[simp]\ntheorem Continuous.connectedComponentsLift_apply_coe (h : Continuous f) (x : \u03b1) :\n    h.connectedComponentsLift x = f x", "start": [261, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsLift_comp_coe", "code": "@[simp]\ntheorem Continuous.connectedComponentsLift_comp_coe (h : Continuous f) :\n    h.connectedComponentsLift \u2218 (\u2191) = f", "start": [267, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "connectedComponents_lift_unique'", "code": "theorem connectedComponents_lift_unique' {\u03b2 : Sort*} {g\u2081 g\u2082 : ConnectedComponents \u03b1 \u2192 \u03b2}\n    (hg : g\u2081 \u2218 ((\u2191) : \u03b1 \u2192 ConnectedComponents \u03b1) = g\u2082 \u2218 (\u2191)) : g\u2081 = g\u2082", "start": [273, 1], "end": [275, 61], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsLift_unique", "code": "theorem Continuous.connectedComponentsLift_unique (h : Continuous f) (g : ConnectedComponents \u03b1 \u2192 \u03b2)\n    (hg : g \u2218 (\u2191) = f) : g = h.connectedComponentsLift", "start": [278, 1], "end": [280, 87], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.totallyDisconnectedSpace", "code": "instance ConnectedComponents.totallyDisconnectedSpace :\n    TotallyDisconnectedSpace (ConnectedComponents \u03b1) := by\n  rw [totallyDisconnectedSpace_iff_connectedComponent_singleton]\n  refine' ConnectedComponents.surjective_coe.forall.2 fun x => _\n  rw [\u2190 ConnectedComponents.quotientMap_coe.image_connectedComponent, \u2190\n    connectedComponents_preimage_singleton, image_preimage_eq _ ConnectedComponents.surjective_coe]\n  refine' ConnectedComponents.surjective_coe.forall.2 fun y => _\n  rw [connectedComponents_preimage_singleton]\n  exact isConnected_connectedComponent", "start": [284, 1], "end": [292, 39], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsMap", "code": "def Continuous.connectedComponentsMap {\u03b2 : Type*} [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) : ConnectedComponents \u03b1 \u2192 ConnectedComponents \u03b2 :=\n  Continuous.connectedComponentsLift (ConnectedComponents.continuous_coe.comp h)", "start": [295, 1], "end": [298, 81], "kind": "commanddeclaration"}, {"full_name": "Continuous.connectedComponentsMap_continuous", "code": "theorem Continuous.connectedComponentsMap_continuous {\u03b2 : Type*} [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) : Continuous h.connectedComponentsMap", "start": [301, 1], "end": [303, 92], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.constant", "code": "theorem IsPreconnected.constant {Y : Type*} [TopologicalSpace Y] [DiscreteTopology Y] {s : Set \u03b1}\n    (hs : IsPreconnected s) {f : \u03b1 \u2192 Y} (hf : ContinuousOn f s) {x y : \u03b1} (hx : x \u2208 s)\n    (hy : y \u2208 s) : f x = f y", "start": [306, 1], "end": [311, 79], "kind": "commanddeclaration"}, {"full_name": "PreconnectedSpace.constant", "code": "theorem PreconnectedSpace.constant {Y : Type*} [TopologicalSpace Y] [DiscreteTopology Y]\n    (hp : PreconnectedSpace \u03b1) {f : \u03b1 \u2192 Y} (hf : Continuous f) {x y : \u03b1} : f x = f y", "start": [314, 1], "end": [317, 94], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.constant_of_mapsTo", "code": "theorem IsPreconnected.constant_of_mapsTo [TopologicalSpace \u03b2] {S : Set \u03b1} (hS : IsPreconnected S)\n    {T : Set \u03b2} [DiscreteTopology T] {f : \u03b1 \u2192 \u03b2} (hc : ContinuousOn f S) (hTm : MapsTo f S T)\n    {x y : \u03b1} (hx : x \u2208 S) (hy : y \u2208 S) : f x = f y", "start": [320, 1], "end": [327, 85], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.eqOn_const_of_mapsTo", "code": "theorem IsPreconnected.eqOn_const_of_mapsTo [TopologicalSpace \u03b2] {S : Set \u03b1} (hS : IsPreconnected S)\n    {T : Set \u03b2} [DiscreteTopology T] {f : \u03b1 \u2192 \u03b2} (hc : ContinuousOn f S) (hTm : MapsTo f S T)\n    (hne : T.Nonempty) : \u2203 y \u2208 T, EqOn f (const \u03b1 y) S", "start": [330, 1], "end": [337, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Connected/LocallyConnected.lean", "imports": ["Mathlib/Topology/Connected/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyConnectedSpace", "code": "class LocallyConnectedSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  open_connected_basis : \u2200 x, (\ud835\udcdd x).HasBasis (fun s : Set \u03b1 => IsOpen s \u2227 x \u2208 s \u2227 IsConnected s) id", "start": [26, 1], "end": [32, 100], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_iff_open_connected_basis", "code": "theorem locallyConnectedSpace_iff_open_connected_basis :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 x, (\ud835\udcdd x).HasBasis (fun s : Set \u03b1 => IsOpen s \u2227 x \u2208 s \u2227 IsConnected s) id", "start": [35, 1], "end": [38, 78], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_iff_open_connected_subsets", "code": "theorem locallyConnectedSpace_iff_open_connected_subsets :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 x, \u2200 U \u2208 \ud835\udcdd x, \u2203 V : Set \u03b1, V \u2286 U \u2227 IsOpen V \u2227 x \u2208 V \u2227 IsConnected V", "start": [42, 1], "end": [53, 87], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.toLocallyConnectedSpace", "code": "instance (priority := 100) DiscreteTopology.toLocallyConnectedSpace (\u03b1) [TopologicalSpace \u03b1]\n    [DiscreteTopology \u03b1] : LocallyConnectedSpace \u03b1 :=\n  locallyConnectedSpace_iff_open_connected_subsets.2 fun x _U hU =>\n    \u27e8{x}, singleton_subset_iff.2 <| mem_of_mem_nhds hU, isOpen_discrete _, rfl,\n      isConnected_singleton\u27e9", "start": [56, 1], "end": [61, 29], "kind": "commanddeclaration"}, {"full_name": "connectedComponentIn_mem_nhds", "code": "theorem connectedComponentIn_mem_nhds [LocallyConnectedSpace \u03b1] {F : Set \u03b1} {x : \u03b1} (h : F \u2208 \ud835\udcdd x) :\n    connectedComponentIn F x \u2208 \ud835\udcdd x", "start": [64, 1], "end": [68, 95], "kind": "commanddeclaration"}, {"full_name": "IsOpen.connectedComponentIn", "code": "protected theorem IsOpen.connectedComponentIn [LocallyConnectedSpace \u03b1] {F : Set \u03b1} {x : \u03b1}\n    (hF : IsOpen F) : IsOpen (connectedComponentIn F x)", "start": [71, 1], "end": [76, 90], "kind": "commanddeclaration"}, {"full_name": "isOpen_connectedComponent", "code": "theorem isOpen_connectedComponent [LocallyConnectedSpace \u03b1] {x : \u03b1} :\n    IsOpen (connectedComponent x)", "start": [79, 1], "end": [82, 41], "kind": "commanddeclaration"}, {"full_name": "isClopen_connectedComponent", "code": "theorem isClopen_connectedComponent [LocallyConnectedSpace \u03b1] {x : \u03b1} :\n    IsClopen (connectedComponent x)", "start": [85, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_iff_connectedComponentIn_open", "code": "theorem locallyConnectedSpace_iff_connectedComponentIn_open :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 F : Set \u03b1, IsOpen F \u2192 \u2200 x \u2208 F, IsOpen (connectedComponentIn F x)", "start": [90, 1], "end": [102, 45], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_iff_connected_subsets", "code": "theorem locallyConnectedSpace_iff_connected_subsets :\n    LocallyConnectedSpace \u03b1 \u2194 \u2200 (x : \u03b1), \u2200 U \u2208 \ud835\udcdd x, \u2203 V \u2208 \ud835\udcdd x, IsPreconnected V \u2227 V \u2286 U", "start": [105, 1], "end": [116, 96], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_iff_connected_basis", "code": "theorem locallyConnectedSpace_iff_connected_basis :\n    LocallyConnectedSpace \u03b1 \u2194\n      \u2200 x, (\ud835\udcdd x).HasBasis (fun s : Set \u03b1 => s \u2208 \ud835\udcdd x \u2227 IsPreconnected s) id", "start": [119, 1], "end": [123, 60], "kind": "commanddeclaration"}, {"full_name": "locallyConnectedSpace_of_connected_bases", "code": "theorem locallyConnectedSpace_of_connected_bases {\u03b9 : Type*} (b : \u03b1 \u2192 \u03b9 \u2192 Set \u03b1) (p : \u03b1 \u2192 \u03b9 \u2192 Prop)\n    (hbasis : \u2200 x, (\ud835\udcdd x).HasBasis (p x) (b x))\n    (hconnected : \u2200 x i, p x i \u2192 IsPreconnected (b x i)) : LocallyConnectedSpace \u03b1", "start": [126, 1], "end": [133, 100], "kind": "commanddeclaration"}, {"full_name": "OpenEmbedding.locallyConnectedSpace", "code": "theorem OpenEmbedding.locallyConnectedSpace [LocallyConnectedSpace \u03b1] [TopologicalSpace \u03b2]\n    {f : \u03b2 \u2192 \u03b1} (h : OpenEmbedding f) : LocallyConnectedSpace \u03b2", "start": [136, 1], "end": [143, 59], "kind": "commanddeclaration"}, {"full_name": "IsOpen.locallyConnectedSpace", "code": "theorem IsOpen.locallyConnectedSpace [LocallyConnectedSpace \u03b1] {U : Set \u03b1} (hU : IsOpen U) :\n    LocallyConnectedSpace U", "start": [145, 1], "end": [147, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Inseparable.lean", "imports": ["Mathlib/Tactic/TFAE.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Specializes", "code": "def Specializes (x y : X) : Prop := \ud835\udcdd x \u2264 \ud835\udcdd y", "start": [48, 1], "end": [61, 46], "kind": "commanddeclaration"}, {"full_name": "specializes_TFAE", "code": "theorem specializes_TFAE (x y : X) :\n    TFAE [x \u2933 y,\n      pure x \u2264 \ud835\udcdd y,\n      \u2200 s : Set X , IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s,\n      \u2200 s : Set X , IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s,\n      y \u2208 closure ({ x } : Set X),\n      closure ({ y } : Set X) \u2286 closure { x },\n      ClusterPt y (pure x)]", "start": [67, 1], "end": [94, 14], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_nhds", "code": "theorem specializes_iff_nhds : x \u2933 y \u2194 \ud835\udcdd x \u2264 \ud835\udcdd y", "start": [97, 1], "end": [98, 10], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_pure", "code": "theorem specializes_iff_pure : x \u2933 y \u2194 pure x \u2264 \ud835\udcdd y", "start": [101, 1], "end": [102, 33], "kind": "commanddeclaration"}, {"full_name": "Specializes.nhds_le_nhds", "code": "alias \u27e8Specializes.nhds_le_nhds, _\u27e9 := specializes_iff_nhds", "start": [105, 1], "end": [105, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Specializes.pure_le_nhds", "code": "alias \u27e8Specializes.pure_le_nhds, _\u27e9 := specializes_iff_pure", "start": [108, 1], "end": [108, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ker_nhds_eq_specializes", "code": "theorem ker_nhds_eq_specializes : (\ud835\udcdd x).ker = {y | y \u2933 x}", "start": [111, 1], "end": [112, 43], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_forall_open", "code": "theorem specializes_iff_forall_open : x \u2933 y \u2194 \u2200 s : Set X, IsOpen s \u2192 y \u2208 s \u2192 x \u2208 s", "start": [114, 1], "end": [115, 33], "kind": "commanddeclaration"}, {"full_name": "Specializes.mem_open", "code": "theorem Specializes.mem_open (h : x \u2933 y) (hs : IsOpen s) (hy : y \u2208 s) : x \u2208 s", "start": [118, 1], "end": [119, 42], "kind": "commanddeclaration"}, {"full_name": "IsOpen.not_specializes", "code": "theorem IsOpen.not_specializes (hs : IsOpen s) (hx : x \u2209 s) (hy : y \u2208 s) : \u00acx \u2933 y", "start": [122, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_forall_closed", "code": "theorem specializes_iff_forall_closed : x \u2933 y \u2194 \u2200 s : Set X, IsClosed s \u2192 x \u2208 s \u2192 y \u2208 s", "start": [126, 1], "end": [127, 33], "kind": "commanddeclaration"}, {"full_name": "Specializes.mem_closed", "code": "theorem Specializes.mem_closed (h : x \u2933 y) (hs : IsClosed s) (hx : x \u2208 s) : y \u2208 s", "start": [130, 1], "end": [131, 44], "kind": "commanddeclaration"}, {"full_name": "IsClosed.not_specializes", "code": "theorem IsClosed.not_specializes (hs : IsClosed s) (hx : x \u2208 s) (hy : y \u2209 s) : \u00acx \u2933 y", "start": [134, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_mem_closure", "code": "theorem specializes_iff_mem_closure : x \u2933 y \u2194 y \u2208 closure ({x} : Set X)", "start": [138, 1], "end": [139, 33], "kind": "commanddeclaration"}, {"full_name": "Specializes.mem_closure", "code": "alias \u27e8Specializes.mem_closure, _\u27e9 := specializes_iff_mem_closure", "start": [142, 1], "end": [142, 66], "kind": "stdtacticaliasaliaslr"}, {"full_name": "specializes_iff_closure_subset", "code": "theorem specializes_iff_closure_subset : x \u2933 y \u2194 closure ({y} : Set X) \u2286 closure {x}", "start": [145, 1], "end": [146, 33], "kind": "commanddeclaration"}, {"full_name": "Specializes.closure_subset", "code": "alias \u27e8Specializes.closure_subset, _\u27e9 := specializes_iff_closure_subset", "start": [149, 1], "end": [149, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "specializes_iff_clusterPt", "code": "theorem specializes_iff_clusterPt : x \u2933 y \u2194 ClusterPt y (pure x)", "start": [153, 1], "end": [154, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.specializes_iff", "code": "theorem Filter.HasBasis.specializes_iff {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set X}\n    (h : (\ud835\udcdd y).HasBasis p s) : x \u2933 y \u2194 \u2200 i, p i \u2192 x \u2208 s i", "start": [156, 1], "end": [158, 38], "kind": "commanddeclaration"}, {"full_name": "specializes_rfl", "code": "theorem specializes_rfl : x \u2933 x", "start": [161, 1], "end": [161, 42], "kind": "commanddeclaration"}, {"full_name": "specializes_refl", "code": "@[refl]\ntheorem specializes_refl (x : X) : x \u2933 x", "start": [164, 1], "end": [166, 18], "kind": "commanddeclaration"}, {"full_name": "Specializes.trans", "code": "@[trans]\ntheorem Specializes.trans : x \u2933 y \u2192 y \u2933 z \u2192 x \u2933 z", "start": [169, 1], "end": [171, 11], "kind": "commanddeclaration"}, {"full_name": "specializes_of_eq", "code": "theorem specializes_of_eq (e : x = y) : x \u2933 y", "start": [174, 1], "end": [175, 25], "kind": "commanddeclaration"}, {"full_name": "specializes_of_nhdsWithin", "code": "theorem specializes_of_nhdsWithin (h\u2081 : \ud835\udcdd[s] x \u2264 \ud835\udcdd[s] y) (h\u2082 : x \u2208 s) : x \u2933 y", "start": [178, 1], "end": [183, 29], "kind": "commanddeclaration"}, {"full_name": "Specializes.map_of_continuousAt", "code": "theorem Specializes.map_of_continuousAt (h : x \u2933 y) (hy : ContinuousAt f y) : f x \u2933 f y", "start": [186, 1], "end": [188, 73], "kind": "commanddeclaration"}, {"full_name": "Specializes.map", "code": "theorem Specializes.map (h : x \u2933 y) (hf : Continuous f) : f x \u2933 f y", "start": [191, 1], "end": [192, 40], "kind": "commanddeclaration"}, {"full_name": "Inducing.specializes_iff", "code": "theorem Inducing.specializes_iff (hf : Inducing f) : f x \u2933 f y \u2194 x \u2933 y", "start": [195, 1], "end": [197, 18], "kind": "commanddeclaration"}, {"full_name": "subtype_specializes_iff", "code": "theorem subtype_specializes_iff {p : X \u2192 Prop} (x y : Subtype p) : x \u2933 y \u2194 (x : X) \u2933 y", "start": [200, 1], "end": [201, 44], "kind": "commanddeclaration"}, {"full_name": "specializes_prod", "code": "@[simp]\ntheorem specializes_prod {x\u2081 x\u2082 : X} {y\u2081 y\u2082 : Y} : (x\u2081, y\u2081) \u2933 (x\u2082, y\u2082) \u2194 x\u2081 \u2933 x\u2082 \u2227 y\u2081 \u2933 y\u2082", "start": [204, 1], "end": [206, 54], "kind": "commanddeclaration"}, {"full_name": "Specializes.prod", "code": "theorem Specializes.prod {x\u2081 x\u2082 : X} {y\u2081 y\u2082 : Y} (hx : x\u2081 \u2933 x\u2082) (hy : y\u2081 \u2933 y\u2082) :\n    (x\u2081, y\u2081) \u2933 (x\u2082, y\u2082)", "start": [209, 1], "end": [211, 30], "kind": "commanddeclaration"}, {"full_name": "specializes_pi", "code": "@[simp]\ntheorem specializes_pi {f g : \u2200 i, \u03c0 i} : f \u2933 g \u2194 \u2200 i, f i \u2933 g i", "start": [214, 1], "end": [216, 45], "kind": "commanddeclaration"}, {"full_name": "not_specializes_iff_exists_open", "code": "theorem not_specializes_iff_exists_open : \u00acx \u2933 y \u2194 \u2203 S : Set X, IsOpen S \u2227 y \u2208 S \u2227 x \u2209 S", "start": [219, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "not_specializes_iff_exists_closed", "code": "theorem not_specializes_iff_exists_closed : \u00acx \u2933 y \u2194 \u2203 S : Set X, IsClosed S \u2227 x \u2208 S \u2227 y \u2209 S", "start": [225, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "specializationPreorder", "code": "def specializationPreorder : Preorder X :=\n  { Preorder.lift (OrderDual.toDual \u2218 \ud835\udcdd) with\n    le := fun x y => y \u2933 x\n    lt := fun x y => y \u2933 x \u2227 \u00acx \u2933 y }", "start": [233, 1], "end": [237, 38], "kind": "commanddeclaration"}, {"full_name": "Continuous.specialization_monotone", "code": "theorem Continuous.specialization_monotone (hf : Continuous f) :\n    @Monotone _ _ (specializationPreorder X) (specializationPreorder Y) f", "start": [242, 1], "end": [245, 99], "kind": "commanddeclaration"}, {"full_name": "Inseparable", "code": "def Inseparable (x y : X) : Prop :=\n  \ud835\udcdd x = \ud835\udcdd y", "start": [252, 1], "end": [262, 12], "kind": "commanddeclaration"}, {"full_name": "inseparable_def", "code": "theorem inseparable_def : (x ~\u1d62 y) \u2194 \ud835\udcdd x = \ud835\udcdd y", "start": [267, 1], "end": [268, 10], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_specializes_and", "code": "theorem inseparable_iff_specializes_and : (x ~\u1d62 y) \u2194 x \u2933 y \u2227 y \u2933 x", "start": [271, 1], "end": [272, 18], "kind": "commanddeclaration"}, {"full_name": "Inseparable.specializes", "code": "theorem Inseparable.specializes (h : x ~\u1d62 y) : x \u2933 y", "start": [275, 1], "end": [275, 61], "kind": "commanddeclaration"}, {"full_name": "Inseparable.specializes'", "code": "theorem Inseparable.specializes' (h : x ~\u1d62 y) : y \u2933 x", "start": [278, 1], "end": [278, 62], "kind": "commanddeclaration"}, {"full_name": "Specializes.antisymm", "code": "theorem Specializes.antisymm (h\u2081 : x \u2933 y) (h\u2082 : y \u2933 x) : x ~\u1d62 y", "start": [281, 1], "end": [282, 20], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_forall_open", "code": "theorem inseparable_iff_forall_open : (x ~\u1d62 y) \u2194 \u2200 s : Set X, IsOpen s \u2192 (x \u2208 s \u2194 y \u2208 s)", "start": [285, 1], "end": [287, 14], "kind": "commanddeclaration"}, {"full_name": "not_inseparable_iff_exists_open", "code": "theorem not_inseparable_iff_exists_open :\n    \u00ac(x ~\u1d62 y) \u2194 \u2203 s : Set X, IsOpen s \u2227 Xor' (x \u2208 s) (y \u2208 s)", "start": [290, 1], "end": [292, 59], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_forall_closed", "code": "theorem inseparable_iff_forall_closed : (x ~\u1d62 y) \u2194 \u2200 s : Set X, IsClosed s \u2192 (x \u2208 s \u2194 y \u2208 s)", "start": [295, 1], "end": [297, 13], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_mem_closure", "code": "theorem inseparable_iff_mem_closure :\n    (x ~\u1d62 y) \u2194 x \u2208 closure ({y} : Set X) \u2227 y \u2208 closure ({x} : Set X)", "start": [300, 1], "end": [302, 96], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_closure_eq", "code": "theorem inseparable_iff_closure_eq : (x ~\u1d62 y) \u2194 closure ({x} : Set X) = closure {y}", "start": [305, 1], "end": [307, 13], "kind": "commanddeclaration"}, {"full_name": "inseparable_of_nhdsWithin_eq", "code": "theorem inseparable_of_nhdsWithin_eq (hx : x \u2208 s) (hy : y \u2208 s) (h : \ud835\udcdd[s] x = \ud835\udcdd[s] y) : x ~\u1d62 y", "start": [310, 1], "end": [311, 83], "kind": "commanddeclaration"}, {"full_name": "Inducing.inseparable_iff", "code": "theorem Inducing.inseparable_iff (hf : Inducing f) : (f x ~\u1d62 f y) \u2194 (x ~\u1d62 y)", "start": [314, 1], "end": [315, 66], "kind": "commanddeclaration"}, {"full_name": "subtype_inseparable_iff", "code": "theorem subtype_inseparable_iff {p : X \u2192 Prop} (x y : Subtype p) : (x ~\u1d62 y) \u2194 ((x : X) ~\u1d62 y)", "start": [318, 1], "end": [319, 44], "kind": "commanddeclaration"}, {"full_name": "inseparable_prod", "code": "@[simp] theorem inseparable_prod {x\u2081 x\u2082 : X} {y\u2081 y\u2082 : Y} :\n    ((x\u2081, y\u2081) ~\u1d62 (x\u2082, y\u2082)) \u2194 (x\u2081 ~\u1d62 x\u2082) \u2227 (y\u2081 ~\u1d62 y\u2082)", "start": [322, 1], "end": [324, 53], "kind": "commanddeclaration"}, {"full_name": "Inseparable.prod", "code": "theorem Inseparable.prod {x\u2081 x\u2082 : X} {y\u2081 y\u2082 : Y} (hx : x\u2081 ~\u1d62 x\u2082) (hy : y\u2081 ~\u1d62 y\u2082) :\n    (x\u2081, y\u2081) ~\u1d62 (x\u2082, y\u2082)", "start": [327, 1], "end": [329, 30], "kind": "commanddeclaration"}, {"full_name": "inseparable_pi", "code": "@[simp]\ntheorem inseparable_pi {f g : \u2200 i, \u03c0 i} : (f ~\u1d62 g) \u2194 \u2200 i, f i ~\u1d62 g i", "start": [332, 1], "end": [334, 55], "kind": "commanddeclaration"}, {"full_name": "Inseparable.refl", "code": "@[refl]\ntheorem refl (x : X) : x ~\u1d62 x", "start": [339, 1], "end": [341, 16], "kind": "commanddeclaration"}, {"full_name": "Inseparable.rfl", "code": "theorem rfl : x ~\u1d62 x", "start": [344, 1], "end": [345, 9], "kind": "commanddeclaration"}, {"full_name": "Inseparable.of_eq", "code": "theorem of_eq (e : x = y) : Inseparable x y", "start": [348, 1], "end": [349, 13], "kind": "commanddeclaration"}, {"full_name": "Inseparable.symm", "code": "@[symm]\nnonrec theorem symm (h : x ~\u1d62 y) : y ~\u1d62 x", "start": [352, 1], "end": [353, 52], "kind": "commanddeclaration"}, {"full_name": "Inseparable.trans", "code": "@[trans]\nnonrec theorem trans (h\u2081 : x ~\u1d62 y) (h\u2082 : y ~\u1d62 z) : x ~\u1d62 z", "start": [356, 1], "end": [357, 73], "kind": "commanddeclaration"}, {"full_name": "Inseparable.nhds_eq", "code": "theorem nhds_eq (h : x ~\u1d62 y) : \ud835\udcdd x = \ud835\udcdd y", "start": [360, 1], "end": [360, 46], "kind": "commanddeclaration"}, {"full_name": "Inseparable.mem_open_iff", "code": "theorem mem_open_iff (h : x ~\u1d62 y) (hs : IsOpen s) : x \u2208 s \u2194 y \u2208 s", "start": [363, 1], "end": [364, 39], "kind": "commanddeclaration"}, {"full_name": "Inseparable.mem_closed_iff", "code": "theorem mem_closed_iff (h : x ~\u1d62 y) (hs : IsClosed s) : x \u2208 s \u2194 y \u2208 s", "start": [367, 1], "end": [368, 41], "kind": "commanddeclaration"}, {"full_name": "Inseparable.map_of_continuousAt", "code": "theorem map_of_continuousAt (h : x ~\u1d62 y) (hx : ContinuousAt f x) (hy : ContinuousAt f y) :\n    f x ~\u1d62 f y", "start": [371, 1], "end": [373, 90], "kind": "commanddeclaration"}, {"full_name": "Inseparable.map", "code": "theorem map (h : x ~\u1d62 y) (hf : Continuous f) : f x ~\u1d62 f y", "start": [376, 1], "end": [377, 56], "kind": "commanddeclaration"}, {"full_name": "IsClosed.not_inseparable", "code": "theorem IsClosed.not_inseparable (hs : IsClosed s) (hx : x \u2208 s) (hy : y \u2209 s) : \u00ac(x ~\u1d62 y)", "start": [382, 1], "end": [383, 35], "kind": "commanddeclaration"}, {"full_name": "IsOpen.not_inseparable", "code": "theorem IsOpen.not_inseparable (hs : IsOpen s) (hx : x \u2208 s) (hy : y \u2209 s) : \u00ac(x ~\u1d62 y)", "start": [386, 1], "end": [387, 33], "kind": "commanddeclaration"}, {"full_name": "inseparableSetoid", "code": "def inseparableSetoid : Setoid X := { Setoid.comap \ud835\udcdd \u22a5 with r := Inseparable }", "start": [399, 1], "end": [400, 79], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient", "code": "def SeparationQuotient := Quotient (inseparableSetoid X)", "start": [403, 1], "end": [405, 57], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.mk", "code": "def mk : X \u2192 SeparationQuotient X := Quotient.mk''", "start": [415, 1], "end": [416, 51], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.quotientMap_mk", "code": "theorem quotientMap_mk : QuotientMap (mk : X \u2192 SeparationQuotient X)", "start": [419, 1], "end": [420, 22], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuous_mk", "code": "theorem continuous_mk : Continuous (mk : X \u2192 SeparationQuotient X)", "start": [423, 1], "end": [424, 21], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.mk_eq_mk", "code": "@[simp]\ntheorem mk_eq_mk : mk x = mk y \u2194 (x ~\u1d62 y)", "start": [427, 1], "end": [429, 16], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.surjective_mk", "code": "theorem surjective_mk : Surjective (mk : X \u2192 SeparationQuotient X)", "start": [432, 1], "end": [433, 23], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.range_mk", "code": "@[simp]\ntheorem range_mk : range (mk : X \u2192 SeparationQuotient X) = univ", "start": [436, 1], "end": [438, 25], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.preimage_image_mk_open", "code": "theorem preimage_image_mk_open (hs : IsOpen s) : mk \u207b\u00b9' (mk '' s) = s", "start": [450, 1], "end": [453, 49], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.isOpenMap_mk", "code": "theorem isOpenMap_mk : IsOpenMap (mk : X \u2192 SeparationQuotient X)", "start": [456, 1], "end": [457, 73], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.preimage_image_mk_closed", "code": "theorem preimage_image_mk_closed (hs : IsClosed s) : mk \u207b\u00b9' (mk '' s) = s", "start": [460, 1], "end": [463, 51], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.inducing_mk", "code": "theorem inducing_mk : Inducing (mk : X \u2192 SeparationQuotient X)", "start": [466, 1], "end": [468, 63], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.isClosedMap_mk", "code": "theorem isClosedMap_mk : IsClosedMap (mk : X \u2192 SeparationQuotient X)", "start": [471, 1], "end": [472, 67], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.comap_mk_nhds_mk", "code": "@[simp]\ntheorem comap_mk_nhds_mk : comap mk (\ud835\udcdd (mk x)) = \ud835\udcdd x", "start": [475, 1], "end": [477, 37], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.comap_mk_nhdsSet_image", "code": "@[simp]\ntheorem comap_mk_nhdsSet_image : comap mk (\ud835\udcdd\u02e2 (mk '' s)) = \ud835\udcdd\u02e2 s", "start": [480, 1], "end": [482, 40], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.map_mk_nhds", "code": "theorem map_mk_nhds : map mk (\ud835\udcdd x) = \ud835\udcdd (mk x)", "start": [485, 1], "end": [486, 65], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.map_mk_nhdsSet", "code": "theorem map_mk_nhdsSet : map mk (\ud835\udcdd\u02e2 s) = \ud835\udcdd\u02e2 (mk '' s)", "start": [489, 1], "end": [490, 71], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.comap_mk_nhdsSet", "code": "theorem comap_mk_nhdsSet : comap mk (\ud835\udcdd\u02e2 t) = \ud835\udcdd\u02e2 (mk \u207b\u00b9' t)", "start": [493, 1], "end": [494, 79], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.preimage_mk_closure", "code": "theorem preimage_mk_closure : mk \u207b\u00b9' closure t = closure (mk \u207b\u00b9' t)", "start": [497, 1], "end": [498, 68], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.preimage_mk_interior", "code": "theorem preimage_mk_interior : mk \u207b\u00b9' interior t = interior (mk \u207b\u00b9' t)", "start": [501, 1], "end": [502, 70], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.preimage_mk_frontier", "code": "theorem preimage_mk_frontier : mk \u207b\u00b9' frontier t = frontier (mk \u207b\u00b9' t)", "start": [505, 1], "end": [506, 70], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.image_mk_closure", "code": "theorem image_mk_closure : mk '' closure s = closure (mk '' s)", "start": [509, 1], "end": [511, 42], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.map_prod_map_mk_nhds", "code": "theorem map_prod_map_mk_nhds (x : X) (y : Y) : map (Prod.map mk mk) (\ud835\udcdd (x, y)) = \ud835\udcdd (mk x, mk y)", "start": [514, 1], "end": [515, 83], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.map_mk_nhdsWithin_preimage", "code": "theorem map_mk_nhdsWithin_preimage (s : Set (SeparationQuotient X)) (x : X) :\n    map mk (\ud835\udcdd[mk \u207b\u00b9' s] x) = \ud835\udcdd[s] mk x", "start": [518, 1], "end": [520, 80], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.lift", "code": "def lift (f : X \u2192 \u03b1) (hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y) : SeparationQuotient X \u2192 \u03b1 := fun x =>\n  Quotient.liftOn' x f hf", "start": [523, 1], "end": [526, 26], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.lift_mk", "code": "@[simp]\ntheorem lift_mk {f : X \u2192 \u03b1} (hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y) (x : X) : lift f hf (mk x) = f x", "start": [529, 1], "end": [531, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.lift_comp_mk", "code": "@[simp]\ntheorem lift_comp_mk {f : X \u2192 \u03b1} (hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y) : lift f hf \u2218 mk = f", "start": [534, 1], "end": [536, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.tendsto_lift_nhds_mk", "code": "@[simp]\ntheorem tendsto_lift_nhds_mk {f : X \u2192 \u03b1} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y} {x : X} {l : Filter \u03b1} :\n    Tendsto (lift f hf) (\ud835\udcdd <| mk x) l \u2194 Tendsto f (\ud835\udcdd x) l", "start": [539, 1], "end": [542, 60], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.tendsto_lift_nhdsWithin_mk", "code": "@[simp]\ntheorem tendsto_lift_nhdsWithin_mk {f : X \u2192 \u03b1} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y} {x : X}\n    {s : Set (SeparationQuotient X)} {l : Filter \u03b1} :\n    Tendsto (lift f hf) (\ud835\udcdd[s] mk x) l \u2194 Tendsto f (\ud835\udcdd[mk \u207b\u00b9' s] x) l", "start": [545, 1], "end": [549, 75], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousAt_lift", "code": "@[simp]\ntheorem continuousAt_lift {f : X \u2192 Y} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y} {x : X} :\n    ContinuousAt (lift f hf) (mk x) \u2194 ContinuousAt f x", "start": [552, 1], "end": [555, 23], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousWithinAt_lift", "code": "@[simp]\ntheorem continuousWithinAt_lift {f : X \u2192 Y} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y}\n    {s : Set (SeparationQuotient X)} {x : X} :\n    ContinuousWithinAt (lift f hf) s (mk x) \u2194 ContinuousWithinAt f (mk \u207b\u00b9' s) x", "start": [558, 1], "end": [562, 29], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousOn_lift", "code": "@[simp]\ntheorem continuousOn_lift {f : X \u2192 Y} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y}\n    {s : Set (SeparationQuotient X)} : ContinuousOn (lift f hf) s \u2194 ContinuousOn f (mk \u207b\u00b9' s)", "start": [565, 1], "end": [568, 88], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuous_lift", "code": "@[simp]\ntheorem continuous_lift {f : X \u2192 Y} {hf : \u2200 x y, (x ~\u1d62 y) \u2192 f x = f y} :\n    Continuous (lift f hf) \u2194 Continuous f", "start": [571, 1], "end": [574, 81], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.lift\u2082", "code": "def lift\u2082 (f : X \u2192 Y \u2192 \u03b1) (hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d) :\n    SeparationQuotient X \u2192 SeparationQuotient Y \u2192 \u03b1 := fun x y => Quotient.liftOn\u2082' x y f hf", "start": [577, 1], "end": [580, 93], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.lift\u2082_mk", "code": "@[simp]\ntheorem lift\u2082_mk {f : X \u2192 Y \u2192 \u03b1} (hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d) (x : X)\n    (y : Y) : lift\u2082 f hf (mk x) (mk y) = f x y", "start": [583, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.tendsto_lift\u2082_nhds", "code": "@[simp]\ntheorem tendsto_lift\u2082_nhds {f : X \u2192 Y \u2192 \u03b1} {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d}\n    {x : X} {y : Y} {l : Filter \u03b1} :\n    Tendsto (uncurry <| lift\u2082 f hf) (\ud835\udcdd (mk x, mk y)) l \u2194 Tendsto (uncurry f) (\ud835\udcdd (x, y)) l", "start": [589, 1], "end": [594, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.tendsto_lift\u2082_nhdsWithin", "code": "@[simp] theorem tendsto_lift\u2082_nhdsWithin {f : X \u2192 Y \u2192 \u03b1}\n    {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d} {x : X} {y : Y}\n    {s : Set (SeparationQuotient X \u00d7 SeparationQuotient Y)} {l : Filter \u03b1} :\n    Tendsto (uncurry <| lift\u2082 f hf) (\ud835\udcdd[s] (mk x, mk y)) l \u2194\n      Tendsto (uncurry f) (\ud835\udcdd[Prod.map mk mk \u207b\u00b9' s] (x, y)) l", "start": [597, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousAt_lift\u2082", "code": "@[simp]\ntheorem continuousAt_lift\u2082 {f : X \u2192 Y \u2192 Z} {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d}\n    {x : X} {y : Y} :\n    ContinuousAt (uncurry <| lift\u2082 f hf) (mk x, mk y) \u2194 ContinuousAt (uncurry f) (x, y)", "start": [606, 1], "end": [610, 21], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousWithinAt_lift\u2082", "code": "@[simp] theorem continuousWithinAt_lift\u2082 {f : X \u2192 Y \u2192 Z}\n    {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d}\n    {s : Set (SeparationQuotient X \u00d7 SeparationQuotient Y)} {x : X} {y : Y} :\n    ContinuousWithinAt (uncurry <| lift\u2082 f hf) s (mk x, mk y) \u2194\n      ContinuousWithinAt (uncurry f) (Prod.map mk mk \u207b\u00b9' s) (x, y)", "start": [613, 1], "end": [618, 27], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuousOn_lift\u2082", "code": "@[simp]\ntheorem continuousOn_lift\u2082 {f : X \u2192 Y \u2192 Z} {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d}\n    {s : Set (SeparationQuotient X \u00d7 SeparationQuotient Y)} :\n    ContinuousOn (uncurry <| lift\u2082 f hf) s \u2194 ContinuousOn (uncurry f) (Prod.map mk mk \u207b\u00b9' s)", "start": [621, 1], "end": [627, 6], "kind": "commanddeclaration"}, {"full_name": "SeparationQuotient.continuous_lift\u2082", "code": "@[simp]\ntheorem continuous_lift\u2082 {f : X \u2192 Y \u2192 Z} {hf : \u2200 a b c d, (a ~\u1d62 c) \u2192 (b ~\u1d62 d) \u2192 f a b = f c d} :\n    Continuous (uncurry <| lift\u2082 f hf) \u2194 Continuous (uncurry f)", "start": [630, 1], "end": [633, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Compactness/SigmaCompact.lean", "imports": ["Mathlib/Topology/Compactness/LocallyCompact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSigmaCompact", "code": "def IsSigmaCompact (s : Set \u03b1) : Prop :=\n  \u2203 K : \u2115 \u2192 Set \u03b1, (\u2200 n, IsCompact (K n)) \u2227 \u22c3 n, K n = s", "start": [23, 1], "end": [25, 57], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isSigmaCompact", "code": "lemma IsCompact.isSigmaCompact {s : Set \u03b1} (hs : IsCompact s) : IsSigmaCompact s :=\n  \u27e8fun _ => s, fun _ => hs, iUnion_const _\u27e9", "start": [27, 1], "end": [29, 44], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_empty", "code": "@[simp]\nlemma isSigmaCompact_empty : IsSigmaCompact (\u2205 : Set \u03b1) :=\n  IsCompact.isSigmaCompact isCompact_empty", "start": [31, 1], "end": [34, 43], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_iUnion_of_isCompact", "code": "lemma isSigmaCompact_iUnion_of_isCompact {\u03b9 : Type*} [h\u03b9 : Countable \u03b9] (s : \u03b9 \u2192 Set \u03b1)\n    (hcomp : \u2200 i, IsCompact (s i)) : IsSigmaCompact (\u22c3 i, s i) := by\n  rcases isEmpty_or_nonempty \u03b9\n  \u00b7 simp only [iUnion_of_empty, isSigmaCompact_empty]\n  \u00b7 obtain \u27e8f, hf\u27e9 := countable_iff_exists_surjective.mp h\u03b9\n    exact \u27e8s \u2218 f, fun n \u21a6 hcomp (f n), Function.Surjective.iUnion_comp hf _\u27e9", "start": [36, 1], "end": [43, 77], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_sUnion_of_isCompact", "code": "lemma isSigmaCompact_sUnion_of_isCompact {S : Set (Set \u03b1)} (hc : Set.Countable S)\n    (hcomp : \u2200 (s : Set \u03b1), s \u2208 S \u2192 IsCompact s) : IsSigmaCompact (\u22c3\u2080 S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  rw [sUnion_eq_iUnion]\n  apply isSigmaCompact_iUnion_of_isCompact _ (fun \u27e8s, hs\u27e9 \u21a6 hcomp s hs)", "start": [45, 1], "end": [50, 72], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_iUnion", "code": "lemma isSigmaCompact_iUnion {\u03b9 : Type*} [Countable \u03b9] (s : \u03b9 \u2192 Set \u03b1)\n    (hcomp : \u2200 i, IsSigmaCompact (s i)) : IsSigmaCompact (\u22c3 i, s i) := by\n  choose K hcomp hcov using fun i \u21a6 hcomp i\n  have := calc\n    \u22c3 i, s i\n    _ = \u22c3 i, \u22c3 n, (K i n) := by simp_rw [hcov]\n    _ = \u22c3 (i) (n : \u2115), (K.uncurry \u27e8i, n\u27e9) := by rw [Function.uncurry_def]\n    _ = \u22c3 x, K.uncurry x := by rw [\u2190 iUnion_prod']\n  rw [this]\n  exact isSigmaCompact_iUnion_of_isCompact K.uncurry fun x \u21a6 (hcomp x.1 x.2)", "start": [52, 1], "end": [64, 77], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_sUnion", "code": "lemma isSigmaCompact_sUnion (S : Set (Set \u03b1)) (hc : Set.Countable S)\n    (hcomp : \u2200 s : S, IsSigmaCompact s (\u03b1 := \u03b1)) : IsSigmaCompact (\u22c3\u2080 S) := by\n  have : Countable S := countable_coe_iff.mpr hc\n  apply sUnion_eq_iUnion.symm \u25b8 isSigmaCompact_iUnion _ hcomp", "start": [66, 1], "end": [70, 62], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_biUnion", "code": "lemma isSigmaCompact_biUnion {\u03b9 : Type*} {s : Set \u03b9} {S : \u03b9 \u2192 Set \u03b1} (hc : Set.Countable s)\n    (hcomp : \u2200 (i : \u03b9), i \u2208 s \u2192 IsSigmaCompact (S i)) :\n    IsSigmaCompact (\u22c3 (i : \u03b9) (_ : i \u2208 s), S i) := by\n  have : Countable \u2191s := countable_coe_iff.mpr hc\n  rw [biUnion_eq_iUnion]\n  exact isSigmaCompact_iUnion _ (fun \u27e8i', hi'\u27e9 \u21a6 hcomp i' hi')", "start": [72, 1], "end": [78, 63], "kind": "mathlibtacticlemma"}, {"full_name": "IsSigmaCompact.of_isClosed_subset", "code": "lemma IsSigmaCompact.of_isClosed_subset {s t : Set \u03b1} (ht : IsSigmaCompact t)\n    (hs : IsClosed s) (h : s \u2286 t) : IsSigmaCompact s := by\n  rcases ht with \u27e8K, hcompact, hcov\u27e9\n  refine \u27e8(fun n \u21a6 s \u2229 (K n)), fun n \u21a6 (hcompact n).inter_left hs, ?_\u27e9\n  rw [\u2190 inter_iUnion, hcov]\n  exact inter_eq_left.mpr h", "start": [80, 1], "end": [86, 28], "kind": "mathlibtacticlemma"}, {"full_name": "IsSigmaCompact.image_of_continuousOn", "code": "lemma IsSigmaCompact.image_of_continuousOn {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : IsSigmaCompact s)\n    (hf : ContinuousOn f s) : IsSigmaCompact (f '' s) := by\n  rcases hs with \u27e8K, hcompact, hcov\u27e9\n  refine \u27e8fun n \u21a6 f '' K n, ?_, hcov.symm \u25b8 image_iUnion.symm\u27e9\n  exact fun n \u21a6 (hcompact n).image_of_continuousOn (hf.mono (hcov.symm \u25b8 subset_iUnion K n))", "start": [88, 1], "end": [93, 93], "kind": "mathlibtacticlemma"}, {"full_name": "IsSigmaCompact.image", "code": "lemma IsSigmaCompact.image {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) {s : Set \u03b1} (hs : IsSigmaCompact s) :\n    IsSigmaCompact (f '' s) := hs.image_of_continuousOn hf.continuousOn", "start": [95, 1], "end": [97, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Inducing.isSigmaCompact_iff", "code": "lemma Inducing.isSigmaCompact_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : Inducing f) : IsSigmaCompact s \u2194 IsSigmaCompact (f '' s) := by\n  constructor\n  \u00b7 exact fun h \u21a6 h.image hf.continuous\n  \u00b7 rintro \u27e8L, hcomp, hcov\u27e9\n    refine \u27e8fun n \u21a6 f \u207b\u00b9' (L n) \u2229 s, ?_, ?_\u27e9\n    \u00b7 intro n\n      have : f '' (f \u207b\u00b9' (L n) \u2229 s) = L n := by\n        rw [image_preimage_inter, inter_eq_left.mpr]\n        exact (subset_iUnion _ n).trans hcov.le\n      apply hf.isCompact_iff.mpr (this.symm \u25b8 (hcomp n))\n    \u00b7 calc \u22c3 n, f \u207b\u00b9' L n \u2229 s\n        _ = f \u207b\u00b9' (\u22c3 n, L n) \u2229 s  := by rw [preimage_iUnion, iUnion_inter]\n        _ = f \u207b\u00b9' (f '' s) \u2229 s := by rw [hcov]\n        _ = s := inter_eq_right.mpr (subset_preimage_image _ _)", "start": [99, 1], "end": [118, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Embedding.isSigmaCompact_iff", "code": "lemma Embedding.isSigmaCompact_iff {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : Embedding f) : IsSigmaCompact s \u2194 IsSigmaCompact (f '' s) :=\n  hf.toInducing.isSigmaCompact_iff", "start": [120, 1], "end": [124, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Subtype.isSigmaCompact_iff", "code": "lemma Subtype.isSigmaCompact_iff {p : \u03b1 \u2192 Prop} {s : Set { a // p a }} :\n    IsSigmaCompact s \u2194 IsSigmaCompact ((\u2191) '' s : Set \u03b1) :=\n  embedding_subtype_val.isSigmaCompact_iff", "start": [126, 1], "end": [129, 43], "kind": "mathlibtacticlemma"}, {"full_name": "SigmaCompactSpace", "code": "class SigmaCompactSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] : Prop where\n  \n  isSigmaCompact_univ : IsSigmaCompact (univ : Set \u03b1)", "start": [131, 1], "end": [136, 54], "kind": "commanddeclaration"}, {"full_name": "isSigmaCompact_univ_iff", "code": "lemma isSigmaCompact_univ_iff : IsSigmaCompact (univ : Set \u03b1) \u2194 SigmaCompactSpace \u03b1 :=\n  \u27e8fun h => \u27e8h\u27e9, fun h => h.1\u27e9", "start": [139, 1], "end": [141, 31], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_univ", "code": "lemma isSigmaCompact_univ [h : SigmaCompactSpace \u03b1] : IsSigmaCompact (univ : Set \u03b1) :=\n  isSigmaCompact_univ_iff.mpr h", "start": [143, 1], "end": [145, 32], "kind": "mathlibtacticlemma"}, {"full_name": "SigmaCompactSpace_iff_exists_compact_covering", "code": "lemma SigmaCompactSpace_iff_exists_compact_covering :\n    SigmaCompactSpace \u03b1 \u2194 \u2203 K : \u2115 \u2192 Set \u03b1, (\u2200 n, IsCompact (K n)) \u2227 \u22c3 n, K n = univ := by\n  rw [\u2190 isSigmaCompact_univ_iff, IsSigmaCompact]", "start": [147, 1], "end": [151, 49], "kind": "mathlibtacticlemma"}, {"full_name": "SigmaCompactSpace.exists_compact_covering", "code": "lemma SigmaCompactSpace.exists_compact_covering [h : SigmaCompactSpace \u03b1] :\n    \u2203 K : \u2115 \u2192 Set \u03b1, (\u2200 n, IsCompact (K n)) \u2227 \u22c3 n, K n = univ :=\n  SigmaCompactSpace_iff_exists_compact_covering.mp h", "start": [153, 1], "end": [155, 53], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_range", "code": "lemma isSigmaCompact_range {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) [SigmaCompactSpace \u03b1] :\n    IsSigmaCompact (range f) :=\n  image_univ \u25b8 isSigmaCompact_univ.image hf", "start": [157, 1], "end": [160, 44], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_iff_isSigmaCompact_univ", "code": "lemma isSigmaCompact_iff_isSigmaCompact_univ {s : Set \u03b1} :\n    IsSigmaCompact s \u2194 IsSigmaCompact (univ : Set s) := by\n  rw [Subtype.isSigmaCompact_iff, image_univ, Subtype.range_coe]", "start": [162, 1], "end": [165, 65], "kind": "mathlibtacticlemma"}, {"full_name": "isSigmaCompact_iff_sigmaCompactSpace", "code": "lemma isSigmaCompact_iff_sigmaCompactSpace {s : Set \u03b1} :\n    IsSigmaCompact s \u2194 SigmaCompactSpace s :=\n  isSigmaCompact_iff_isSigmaCompact_univ.trans isSigmaCompact_univ_iff", "start": [167, 1], "end": [169, 71], "kind": "mathlibtacticlemma"}, {"full_name": "CompactSpace.sigma_compact", "code": "instance (priority := 200) CompactSpace.sigma_compact [CompactSpace \u03b1] : SigmaCompactSpace \u03b1 :=\n  \u27e8\u27e8fun _ => univ, fun _ => isCompact_univ, iUnion_const _\u27e9\u27e9", "start": [172, 1], "end": [173, 61], "kind": "commanddeclaration"}, {"full_name": "SigmaCompactSpace.of_countable", "code": "theorem SigmaCompactSpace.of_countable (S : Set (Set \u03b1)) (Hc : S.Countable)\n    (Hcomp : \u2200 s \u2208 S, IsCompact s) (HU : \u22c3\u2080 S = univ) : SigmaCompactSpace \u03b1", "start": [176, 1], "end": [178, 79], "kind": "commanddeclaration"}, {"full_name": "sigmaCompactSpace_of_locally_compact_second_countable", "code": "instance (priority := 100) sigmaCompactSpace_of_locally_compact_second_countable\n    [LocallyCompactSpace \u03b1] [SecondCountableTopology \u03b1] : SigmaCompactSpace \u03b1 := by\n  choose K hKc hxK using fun x : \u03b1 => exists_compact_mem_nhds x\n  rcases countable_cover_nhds hxK with \u27e8s, hsc, hsU\u27e9\n  refine' SigmaCompactSpace.of_countable _ (hsc.image K) (ball_image_iff.2 fun x _ => hKc x) _\n  rwa [sUnion_image]", "start": [182, 1], "end": [187, 21], "kind": "commanddeclaration"}, {"full_name": "compactCovering", "code": "def compactCovering : \u2115 \u2192 Set \u03b1 :=\n  Accumulate exists_compact_covering.choose", "start": [196, 1], "end": [198, 44], "kind": "commanddeclaration"}, {"full_name": "isCompact_compactCovering", "code": "theorem isCompact_compactCovering (n : \u2115) : IsCompact (compactCovering \u03b1 n)", "start": [201, 1], "end": [202, 93], "kind": "commanddeclaration"}, {"full_name": "iUnion_compactCovering", "code": "theorem iUnion_compactCovering : \u22c3 n, compactCovering \u03b1 n = univ", "start": [205, 1], "end": [207, 76], "kind": "commanddeclaration"}, {"full_name": "compactCovering_subset", "code": "@[mono]\ntheorem compactCovering_subset \u2983m n : \u2115\u2984 (h : m \u2264 n) : compactCovering \u03b1 m \u2286 compactCovering \u03b1 n", "start": [210, 1], "end": [212, 24], "kind": "commanddeclaration"}, {"full_name": "exists_mem_compactCovering", "code": "theorem exists_mem_compactCovering (x : \u03b1) : \u2203 n, x \u2208 compactCovering \u03b1 n", "start": [217, 1], "end": [218, 53], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.sigmaCompactSpace", "code": "protected theorem ClosedEmbedding.sigmaCompactSpace {e : \u03b2 \u2192 \u03b1} (he : ClosedEmbedding e) :\n    SigmaCompactSpace \u03b2", "start": [257, 1], "end": [261, 70], "kind": "commanddeclaration"}, {"full_name": "IsClosed.sigmaCompactSpace", "code": "theorem IsClosed.sigmaCompactSpace {s : Set \u03b1} (hs : IsClosed s) : SigmaCompactSpace s", "start": [265, 1], "end": [266, 53], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.countable_univ", "code": "protected theorem LocallyFinite.countable_univ {\u03b9 : Type*} {f : \u03b9 \u2192 Set \u03b1} (hf : LocallyFinite f)\n    (hne : \u2200 i, (f i).Nonempty) : (univ : Set \u03b9).Countable", "start": [271, 1], "end": [279, 36], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.encodable", "code": "protected noncomputable def LocallyFinite.encodable {\u03b9 : Type*} {f : \u03b9 \u2192 Set \u03b1}\n    (hf : LocallyFinite f) (hne : \u2200 i, (f i).Nonempty) : Encodable \u03b9 :=\n  @Encodable.ofEquiv _ _ (hf.countable_univ hne).toEncodable (Equiv.Set.univ _).symm", "start": [282, 1], "end": [286, 85], "kind": "commanddeclaration"}, {"full_name": "countable_cover_nhdsWithin_of_sigma_compact", "code": "theorem countable_cover_nhdsWithin_of_sigma_compact {f : \u03b1 \u2192 Set \u03b1} {s : Set \u03b1} (hs : IsClosed s)\n    (hf : \u2200 x \u2208 s, f x \u2208 \ud835\udcdd[s] x) : \u2203 (t : _) (_ : t \u2286 s), t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, f x", "start": [289, 1], "end": [302, 43], "kind": "commanddeclaration"}, {"full_name": "countable_cover_nhds_of_sigma_compact", "code": "theorem countable_cover_nhds_of_sigma_compact {f : \u03b1 \u2192 Set \u03b1} (hf : \u2200 x, f x \u2208 \ud835\udcdd x) :\n    \u2203 s : Set \u03b1, s.Countable \u2227 \u22c3 x \u2208 s, f x = univ", "start": [305, 1], "end": [313, 40], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion", "code": "structure CompactExhaustion (X : Type*) [TopologicalSpace X] where\n  \n  toFun : \u2115 \u2192 Set X\n  \n  isCompact' : \u2200 n, IsCompact (toFun n)\n  \n  subset_interior_succ' : \u2200 n, toFun n \u2286 interior (toFun (n + 1))\n  \n  iUnion_eq' : \u22c3 n, toFun n = univ", "start": [319, 1], "end": [335, 35], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe : K.toFun = K", "start": [348, 1], "end": [349, 42], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.isCompact", "code": "protected theorem isCompact (n : \u2115) : IsCompact (K n)", "start": [351, 1], "end": [352, 17], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.subset_interior_succ", "code": "theorem subset_interior_succ (n : \u2115) : K n \u2286 interior (K (n + 1))", "start": [355, 1], "end": [356, 28], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.subset", "code": "@[mono]\nprotected theorem subset \u2983m n : \u2115\u2984 (h : m \u2264 n) : K m \u2286 K n", "start": [359, 1], "end": [361, 25], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.subset_succ", "code": "theorem subset_succ (n : \u2115) : K n \u2286 K (n + 1)", "start": [364, 1], "end": [364, 68], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.subset_interior", "code": "theorem subset_interior \u2983m n : \u2115\u2984 (h : m < n) : K m \u2286 interior (K n)", "start": [367, 1], "end": [368, 73], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.iUnion_eq", "code": "theorem iUnion_eq : \u22c3 n, K n = univ", "start": [371, 1], "end": [372, 15], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.exists_mem", "code": "theorem exists_mem (x : \u03b1) : \u2203 n, x \u2208 K n", "start": [375, 1], "end": [376, 37], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.find", "code": "protected noncomputable def find (x : \u03b1) : \u2115 :=\n  Nat.find (K.exists_mem x)", "start": [379, 1], "end": [381, 28], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.mem_find", "code": "theorem mem_find (x : \u03b1) : x \u2208 K (K.find x)", "start": [384, 1], "end": [385, 33], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.mem_iff_find_le", "code": "theorem mem_iff_find_le {x : \u03b1} {n : \u2115} : x \u2208 K n \u2194 K.find x \u2264 n", "start": [388, 1], "end": [389, 83], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.shiftr", "code": "def shiftr : CompactExhaustion \u03b1 where\n  toFun n := Nat.casesOn n \u2205 K\n  isCompact' n := Nat.casesOn n isCompact_empty K.isCompact\n  subset_interior_succ' n := Nat.casesOn n (empty_subset _) K.subset_interior_succ\n  iUnion_eq' := iUnion_eq_univ_iff.2 fun x => \u27e8K.find x + 1, K.mem_find x\u27e9", "start": [392, 1], "end": [397, 75], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.find_shiftr", "code": "@[simp]\ntheorem find_shiftr (x : \u03b1) : K.shiftr.find x = K.find x + 1", "start": [400, 1], "end": [402, 43], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.mem_diff_shiftr_find", "code": "theorem mem_diff_shiftr_find (x : \u03b1) : x \u2208 K.shiftr (K.find x + 1) \\ K.shiftr (K.find x)", "start": [405, 1], "end": [407, 91], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.choice", "code": "noncomputable def choice (X : Type*) [TopologicalSpace X] [WeaklyLocallyCompactSpace X]\n    [SigmaCompactSpace X] : CompactExhaustion X := by\n  apply Classical.choice\n  let K : \u2115 \u2192 { s : Set X // IsCompact s } := fun n =>\n    Nat.recOn n \u27e8\u2205, isCompact_empty\u27e9 fun n s =>\n      \u27e8(exists_compact_superset s.2).choose \u222a compactCovering X n,\n        (exists_compact_superset s.2).choose_spec.1.union (isCompact_compactCovering _ _)\u27e9\n  refine' \u27e8\u27e8fun n => (K n).1, fun n => (K n).2, fun n => _, _\u27e9\u27e9\n  \u00b7 exact Subset.trans (exists_compact_superset (K n).2).choose_spec.2\n      (interior_mono <| subset_union_left _ _)\n  \u00b7 refine' univ_subset_iff.1 (iUnion_compactCovering X \u25b8 _)\n    exact iUnion_mono' fun n => \u27e8n + 1, subset_union_right _ _\u27e9", "start": [410, 1], "end": [424, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Opposite.lean", "imports": ["Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Opposite", "code": "structure Opposite :=\n  \n  unop : \u03b1", "start": [29, 1], "end": [37, 11], "kind": "commanddeclaration"}, {"full_name": "Opposite.op", "code": "def op (x : \u03b1) : \u03b1\u1d52\u1d56 := \u27e8x\u27e9", "start": [50, 1], "end": [53, 28], "kind": "commanddeclaration"}, {"full_name": "Opposite.op_injective", "code": "theorem op_injective : Function.Injective (op : \u03b1 \u2192 \u03b1\u1d52\u1d56)", "start": [56, 1], "end": [56, 95], "kind": "commanddeclaration"}, {"full_name": "Opposite.unop_injective", "code": "theorem unop_injective : Function.Injective (unop : \u03b1\u1d52\u1d56 \u2192 \u03b1)", "start": [59, 1], "end": [59, 86], "kind": "commanddeclaration"}, {"full_name": "Opposite.op_unop", "code": "@[simp]\ntheorem op_unop (x : \u03b1\u1d52\u1d56) : op (unop x) = x", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Opposite.unop_op", "code": "@[simp]\ntheorem unop_op (x : \u03b1) : unop (op x) = x", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Opposite.op_inj_iff", "code": "@[simp]\ntheorem op_inj_iff (x y : \u03b1) : op x = op y \u2194 x = y", "start": [74, 1], "end": [76, 22], "kind": "commanddeclaration"}, {"full_name": "Opposite.unop_inj_iff", "code": "@[simp]\ntheorem unop_inj_iff (x y : \u03b1\u1d52\u1d56) : unop x = unop y \u2194 x = y", "start": [79, 1], "end": [81, 24], "kind": "commanddeclaration"}, {"full_name": "Opposite.equivToOpposite", "code": "def equivToOpposite : \u03b1 \u2243 \u03b1\u1d52\u1d56 where\n  toFun := op\n  invFun := unop\n  left_inv := unop_op\n  right_inv := op_unop", "start": [84, 1], "end": [89, 23], "kind": "commanddeclaration"}, {"full_name": "Opposite.equivToOpposite_coe", "code": "@[simp]\ntheorem equivToOpposite_coe : (equivToOpposite : \u03b1 \u2192 \u03b1\u1d52\u1d56) = op", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Opposite.equivToOpposite_symm_coe", "code": "@[simp]\ntheorem equivToOpposite_symm_coe : (equivToOpposite.symm : \u03b1\u1d52\u1d56 \u2192 \u03b1) = unop", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "Opposite.op_eq_iff_eq_unop", "code": "theorem op_eq_iff_eq_unop {x : \u03b1} {y} : op x = y \u2194 x = unop y", "start": [102, 1], "end": [103, 45], "kind": "commanddeclaration"}, {"full_name": "Opposite.unop_eq_iff_eq_op", "code": "theorem unop_eq_iff_eq_op {x} {y : \u03b1} : unop x = y \u2194 x = op y", "start": [106, 1], "end": [107, 50], "kind": "commanddeclaration"}, {"full_name": "Opposite.rec'", "code": "@[simp, eliminator]\nprotected def rec' {F : \u03b1\u1d52\u1d56 \u2192 Sort v} (h : \u2200 X, F (op X)) : \u2200 X, F X := fun X => h (unop X)", "start": [113, 1], "end": [117, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/BilinearMap.lean", "imports": ["Mathlib/LinearAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.mk\u2082'\u209b\u2097", "code": "def mk\u2082'\u209b\u2097 (f : M \u2192 N \u2192 P) (H1 : \u2200 m\u2081 m\u2082 n, f (m\u2081 + m\u2082) n = f m\u2081 n + f m\u2082 n)\n    (H2 : \u2200 (c : R) (m n), f (c \u2022 m) n = \u03c1\u2081\u2082 c \u2022 f m n)\n    (H3 : \u2200 m n\u2081 n\u2082, f m (n\u2081 + n\u2082) = f m n\u2081 + f m n\u2082)\n    (H4 : \u2200 (c : S) (m n), f m (c \u2022 n) = \u03c3\u2081\u2082 c \u2022 f m n) : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P\n    where\n  toFun m :=\n    { toFun := f m\n      map_add' := H3 m\n      map_smul' := fun c => H4 c m }\n  map_add' m\u2081 m\u2082 := LinearMap.ext <| H1 m\u2081 m\u2082\n  map_smul' c m := LinearMap.ext <| H2 c m", "start": [74, 1], "end": [86, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk\u2082'\u209b\u2097_apply", "code": "@[simp]\ntheorem mk\u2082'\u209b\u2097_apply (f : M \u2192 N \u2192 P) {H1 H2 H3 H4} (m : M) (n : N) :\n    (mk\u2082'\u209b\u2097 \u03c1\u2081\u2082 \u03c3\u2081\u2082 f H1 H2 H3 H4 : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) m n = f m n", "start": [91, 1], "end": [93, 80], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk\u2082'", "code": "def mk\u2082' (f : M \u2192 N \u2192 P\u2097) (H1 : \u2200 m\u2081 m\u2082 n, f (m\u2081 + m\u2082) n = f m\u2081 n + f m\u2082 n)\n    (H2 : \u2200 (c : R) (m n), f (c \u2022 m) n = c \u2022 f m n)\n    (H3 : \u2200 m n\u2081 n\u2082, f m (n\u2081 + n\u2082) = f m n\u2081 + f m n\u2082)\n    (H4 : \u2200 (c : S) (m n), f m (c \u2022 n) = c \u2022 f m n) : M \u2192\u2097[R] N \u2192\u2097[S] P\u2097 :=\n  mk\u2082'\u209b\u2097 (RingHom.id R) (RingHom.id S) f H1 H2 H3 H4", "start": [98, 1], "end": [104, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk\u2082'_apply", "code": "@[simp]\ntheorem mk\u2082'_apply (f : M \u2192 N \u2192 P\u2097) {H1 H2 H3 H4} (m : M) (n : N) :\n    (mk\u2082' R S f H1 H2 H3 H4 : M \u2192\u2097[R] N \u2192\u2097[S] P\u2097) m n = f m n", "start": [109, 1], "end": [111, 69], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext\u2082", "code": "theorem ext\u2082 {f g : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} (H : \u2200 m n, f m n = g m n) : f = g", "start": [114, 1], "end": [115, 54], "kind": "commanddeclaration"}, {"full_name": "LinearMap.congr_fun\u2082", "code": "theorem congr_fun\u2082 {f g : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} (h : f = g) (x y) : f x y = g x y", "start": [118, 1], "end": [119, 50], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_iff\u2082", "code": "theorem ext_iff\u2082 {f g : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} : f = g \u2194 \u2200 m n, f m n = g m n", "start": [122, 1], "end": [123, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.flip", "code": "def flip (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) : N \u2192\u209b\u2097[\u03c3\u2081\u2082] M \u2192\u209b\u2097[\u03c1\u2081\u2082] P :=\n  mk\u2082'\u209b\u2097 \u03c3\u2081\u2082 \u03c1\u2081\u2082 (fun n m => f m n) (fun n\u2081 n\u2082 m => (f m).map_add _ _)\n    (fun c n  m  => (f m).map_smul\u209b\u2097 _ _)\n    (fun n m\u2081 m\u2082 => by simp only [map_add, add_apply])\n    (fun c n  m  => by simp only [map_smul\u209b\u2097, smul_apply])", "start": [129, 1], "end": [135, 59], "kind": "commanddeclaration"}, {"full_name": "LinearMap.flip_apply", "code": "@[simp]\ntheorem flip_apply (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (m : M) (n : N) : flip f n m = f m n", "start": [140, 1], "end": [141, 93], "kind": "commanddeclaration"}, {"full_name": "LinearMap.flip_flip", "code": "@[simp]\ntheorem flip_flip (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) : f.flip.flip = f", "start": [146, 1], "end": [148, 79], "kind": "commanddeclaration"}, {"full_name": "LinearMap.flip_inj", "code": "theorem flip_inj {f g : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} (H : flip f = flip g) : f = g", "start": [153, 1], "end": [154, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_zero\u2082", "code": "theorem map_zero\u2082 (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (y) : f 0 y = 0", "start": [157, 1], "end": [158, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_neg\u2082", "code": "theorem map_neg\u2082 (f : M' \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P') (x y) : f (-x) y = -f x y", "start": [161, 1], "end": [162, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_sub\u2082", "code": "theorem map_sub\u2082 (f : M' \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P') (x y z) : f (x - y) z = f x z - f y z", "start": [165, 1], "end": [166, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_add\u2082", "code": "theorem map_add\u2082 (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (x\u2081 x\u2082 y) : f (x\u2081 + x\u2082) y = f x\u2081 y + f x\u2082 y", "start": [169, 1], "end": [170, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul\u2082", "code": "theorem map_smul\u2082 (f : M\u2082 \u2192\u2097[R] N\u2082 \u2192\u209b\u2097[\u03c3\u2081\u2082] P\u2082) (r : R) (x y) : f (r \u2022 x) y = r \u2022 f x y", "start": [173, 1], "end": [174, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_smul\u209b\u2097\u2082", "code": "theorem map_smul\u209b\u2097\u2082 (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (r : R) (x y) : f (r \u2022 x) y = \u03c1\u2081\u2082 r \u2022 f x y", "start": [177, 1], "end": [178, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_sum\u2082", "code": "theorem map_sum\u2082 {\u03b9 : Type*} (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (t : Finset \u03b9) (x : \u03b9 \u2192 M) (y) :\n    f (\u2211 i in t, x i) y = \u2211 i in t, f (x i) y", "start": [181, 1], "end": [183, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict\u2082", "code": "def domRestrict\u2082 (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (q : Submodule S N) : M \u2192\u209b\u2097[\u03c1\u2081\u2082] q \u2192\u209b\u2097[\u03c3\u2081\u2082] P\n    where\n  toFun m := (f m).domRestrict q\n  map_add' m\u2081 m\u2082 := LinearMap.ext fun _ => by simp only [map_add, domRestrict_apply, add_apply]\n  map_smul' c m :=\n    LinearMap.ext fun _ => by simp only [f.map_smul\u209b\u2097, domRestrict_apply, smul_apply]", "start": [186, 1], "end": [192, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict\u2082_apply", "code": "theorem domRestrict\u2082_apply (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (q : Submodule S N) (x : M) (y : q) :\n    f.domRestrict\u2082 q x y = f x y", "start": [195, 1], "end": [196, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict\u2081\u2082", "code": "def domRestrict\u2081\u2082 (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (p : Submodule R M) (q : Submodule S N) :\n    p \u2192\u209b\u2097[\u03c1\u2081\u2082] q \u2192\u209b\u2097[\u03c3\u2081\u2082] P :=\n  (f.domRestrict p).domRestrict\u2082 q", "start": [199, 1], "end": [202, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.domRestrict\u2081\u2082_apply", "code": "theorem domRestrict\u2081\u2082_apply (f : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P) (p : Submodule R M) (q : Submodule S N)\n    (x : p) (y : q) : f.domRestrict\u2081\u2082 p q x y = f x y", "start": [205, 1], "end": [206, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk\u2082", "code": "def mk\u2082 (f : M \u2192 N\u2097 \u2192 P\u2097) (H1 : \u2200 m\u2081 m\u2082 n, f (m\u2081 + m\u2082) n = f m\u2081 n + f m\u2082 n)\n    (H2 : \u2200 (c : R) (m n), f (c \u2022 m) n = c \u2022 f m n)\n    (H3 : \u2200 m n\u2081 n\u2082, f m (n\u2081 + n\u2082) = f m n\u2081 + f m n\u2082)\n    (H4 : \u2200 (c : R) (m n), f m (c \u2022 n) = c \u2022 f m n) : M \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097 :=\n  mk\u2082' R R f H1 H2 H3 H4", "start": [239, 1], "end": [246, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mk\u2082_apply", "code": "@[simp]\ntheorem mk\u2082_apply (f : M \u2192 N\u2097 \u2192 P\u2097) {H1 H2 H3 H4} (m : M) (n : N\u2097) :\n    (mk\u2082 R f H1 H2 H3 H4 : M \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) m n = f m n", "start": [249, 1], "end": [251, 67], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lflip", "code": "def lflip : (M \u2192\u209b\u2097[\u03c3\u2081\u2083] N \u2192\u209b\u2097[\u03c3\u2082\u2083] P) \u2192\u2097[R\u2083] N \u2192\u209b\u2097[\u03c3\u2082\u2083] M \u2192\u209b\u2097[\u03c3\u2081\u2083] P\n    where\n  toFun := flip\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [256, 1], "end": [262, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lflip_apply", "code": "@[simp]\ntheorem lflip_apply (m : M) (n : N) : lflip f n m = f m n", "start": [267, 1], "end": [268, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lcomp", "code": "def lcomp (f : M \u2192\u2097[R] N\u2097) : (N\u2097 \u2192\u2097[R] P\u2097) \u2192\u2097[R] M \u2192\u2097[R] P\u2097 :=\n  flip <| LinearMap.comp (flip id) f", "start": [273, 1], "end": [275, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lcomp_apply", "code": "@[simp]\ntheorem lcomp_apply (f : M \u2192\u2097[R] N\u2097) (g : N\u2097 \u2192\u2097[R] P\u2097) (x : M) : lcomp _ _ f g x = g (f x)", "start": [280, 1], "end": [281, 98], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lcomp_apply'", "code": "theorem lcomp_apply' (f : M \u2192\u2097[R] N\u2097) (g : N\u2097 \u2192\u2097[R] P\u2097) : lcomp R P\u2097 f g = g \u2218\u2097 f", "start": [284, 1], "end": [284, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lcomp\u209b\u2097", "code": "def lcomp\u209b\u2097 (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N) : (N \u2192\u209b\u2097[\u03c3\u2082\u2083] P) \u2192\u2097[R\u2083] M \u2192\u209b\u2097[\u03c3\u2081\u2083] P :=\n  flip <| LinearMap.comp (flip id) f", "start": [289, 1], "end": [292, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lcomp\u209b\u2097_apply", "code": "@[simp]\ntheorem lcomp\u209b\u2097_apply (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N) (g : N \u2192\u209b\u2097[\u03c3\u2082\u2083] P) (x : M) :\n    lcomp\u209b\u2097 P \u03c3\u2082\u2083 f g x = g (f x)", "start": [297, 1], "end": [299, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.llcomp", "code": "def llcomp : (N\u2097 \u2192\u2097[R] P\u2097) \u2192\u2097[R] (M \u2192\u2097[R] N\u2097) \u2192\u2097[R] M \u2192\u2097[R] P\u2097 :=\n  flip\n    { toFun := lcomp R P\u2097\n      map_add' := fun _f _f' => ext\u2082 fun g _x => g.map_add _ _\n      map_smul' := fun (_c : R) _f => ext\u2082 fun g _x => g.map_smul _ _ }", "start": [304, 1], "end": [309, 72], "kind": "commanddeclaration"}, {"full_name": "LinearMap.llcomp_apply", "code": "@[simp]\ntheorem llcomp_apply (f : N\u2097 \u2192\u2097[R] P\u2097) (g : M \u2192\u2097[R] N\u2097) (x : M) :\n    llcomp R M N\u2097 P\u2097 f g x = f (g x)", "start": [316, 1], "end": [318, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.llcomp_apply'", "code": "theorem llcomp_apply' (f : N\u2097 \u2192\u2097[R] P\u2097) (g : M \u2192\u2097[R] N\u2097) : llcomp R M N\u2097 P\u2097 f g = f \u2218\u2097 g", "start": [321, 1], "end": [321, 96], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2082", "code": "def compl\u2082 (g : Q \u2192\u209b\u2097[\u03c3\u2084\u2082] N) : M \u2192\u209b\u2097[\u03c3\u2081\u2083] Q \u2192\u209b\u2097[\u03c3\u2084\u2083] P :=\n  (lcomp\u209b\u2097 _ _ g).comp f", "start": [326, 1], "end": [329, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2082_apply", "code": "@[simp]\ntheorem compl\u2082_apply (g : Q \u2192\u209b\u2097[\u03c3\u2084\u2082] N) (m : M) (q : Q) : f.compl\u2082 g m q = f m (g q)", "start": [332, 1], "end": [333, 92], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2082_id", "code": "@[simp]\ntheorem compl\u2082_id : f.compl\u2082 LinearMap.id = f", "start": [336, 1], "end": [339, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2081\u2082", "code": "def compl\u2081\u2082 (f : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : Q\u2097 \u2192\u2097[R] M\u2097) (g' : Q\u2097' \u2192\u2097[R] N\u2097) :\n    Q\u2097 \u2192\u2097[R] Q\u2097' \u2192\u2097[R] P\u2097 :=\n  (f.comp g).compl\u2082 g'", "start": [342, 1], "end": [346, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2081\u2082_apply", "code": "@[simp]\ntheorem compl\u2081\u2082_apply (f : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : Q\u2097 \u2192\u2097[R] M\u2097) (g' : Q\u2097' \u2192\u2097[R] N\u2097) (x : Q\u2097)\n    (y : Q\u2097') : f.compl\u2081\u2082 g g' x y = f (g x) (g' y)", "start": [349, 1], "end": [351, 59], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2081\u2082_id_id", "code": "@[simp]\ntheorem compl\u2081\u2082_id_id (f : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) : f.compl\u2081\u2082 LinearMap.id LinearMap.id = f", "start": [354, 1], "end": [357, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compl\u2081\u2082_inj", "code": "theorem compl\u2081\u2082_inj {f\u2081 f\u2082 : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097} {g : Q\u2097 \u2192\u2097[R] M\u2097} {g' : Q\u2097' \u2192\u2097[R] N\u2097}\n    (h\u2097 : Function.Surjective g) (h\u1d63 : Function.Surjective g') :\n    f\u2081.compl\u2081\u2082 g g' = f\u2082.compl\u2081\u2082 g g' \u2194 f\u2081 = f\u2082", "start": [360, 1], "end": [372, 17], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compr\u2082", "code": "def compr\u2082 (f : M \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : P\u2097 \u2192\u2097[R] Q\u2097) : M \u2192\u2097[R] N\u2097 \u2192\u2097[R] Q\u2097 :=\n  llcomp R N\u2097 P\u2097 Q\u2097 g \u2218\u2097 f", "start": [375, 1], "end": [378, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compr\u2082_apply", "code": "@[simp]\ntheorem compr\u2082_apply (f : M \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : P\u2097 \u2192\u2097[R] Q\u2097) (m : M) (n : N\u2097) :\n    f.compr\u2082 g m n = g (f m n)", "start": [381, 1], "end": [383, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsmul", "code": "def lsmul : R \u2192\u2097[R] M \u2192\u2097[R] M :=\n  mk\u2082 R (\u00b7 \u2022 \u00b7) add_smul (fun _ _ _ => mul_smul _ _ _) smul_add fun r s m => by\n    simp only [smul_smul, smul_eq_mul, mul_comm]", "start": [388, 1], "end": [391, 49], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsmul_apply", "code": "@[simp]\ntheorem lsmul_apply (r : R) (m : M) : lsmul R M r m = r \u2022 m", "start": [396, 1], "end": [397, 67], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictBilinear", "code": "abbrev _root_.Submodule.restrictBilinear (p : Submodule R M) (f : M \u2192\u2097[R] M \u2192\u2097[R] R) :\n    p \u2192\u2097[R] p \u2192\u2097[R] R :=\n  f.compl\u2081\u2082 p.subtype p.subtype", "start": [400, 1], "end": [403, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsmul_injective", "code": "theorem lsmul_injective [NoZeroSMulDivisors R M] {x : R} (hx : x \u2260 0) :\n    Function.Injective (lsmul R M x)", "start": [421, 1], "end": [423, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_lsmul", "code": "theorem ker_lsmul [NoZeroSMulDivisors R M] {a : R} (ha : a \u2260 0) :\n    LinearMap.ker (LinearMap.lsmul R M a) = \u22a5", "start": [426, 1], "end": [428, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Span.lean", "imports": ["Mathlib/Order/OmegaCompletePartialOrder.lean", "Mathlib/LinearAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Order/CompactlyGenerated.lean"], "premises": [{"full_name": "Submodule.span", "code": "def span (s : Set M) : Submodule R M :=\n  sInf { p | s \u2286 p }", "start": [48, 1], "end": [50, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span", "code": "theorem mem_span : x \u2208 span R s \u2194 \u2200 p : Submodule R M, s \u2286 p \u2192 x \u2208 p", "start": [57, 1], "end": [58, 14], "kind": "commanddeclaration"}, {"full_name": "Submodule.subset_span", "code": "@[aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_span : s \u2286 span R s", "start": [61, 1], "end": [62, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_le", "code": "theorem span_le {p} : span R s \u2264 p \u2194 s \u2286 p", "start": [65, 1], "end": [66, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_mono", "code": "theorem span_mono (h : s \u2286 t) : span R s \u2264 span R t", "start": [69, 1], "end": [70, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_monotone", "code": "theorem span_monotone : Monotone (span R : Set M \u2192 Submodule R M)", "start": [73, 1], "end": [73, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_eq_of_le", "code": "theorem span_eq_of_le (h\u2081 : s \u2286 p) (h\u2082 : p \u2264 span R s) : span R s = p", "start": [76, 1], "end": [77, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_eq", "code": "theorem span_eq : span R (p : Set M) = p", "start": [80, 1], "end": [81, 46], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_eq_span", "code": "theorem span_eq_span (hs : s \u2286 span R t) (ht : t \u2286 span R s) : span R s = span R t", "start": [84, 1], "end": [85, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_coe_eq_restrictScalars", "code": "@[simp]\ntheorem span_coe_eq_restrictScalars [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] :\n    span S (p : Set M) = p.restrictScalars S", "start": [88, 1], "end": [92, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_span", "code": "theorem map_span [RingHomSurjective \u03c3\u2081\u2082] (f : F) (s : Set M) :\n    (span R s).map f = span R\u2082 (f '' s)", "start": [95, 1], "end": [99, 78], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_span", "code": "alias _root_.LinearMap.map_span := Submodule.map_span", "start": [102, 1], "end": [102, 54], "kind": "stdtacticaliasalias"}, {"full_name": "Submodule.map_span_le", "code": "theorem map_span_le [RingHomSurjective \u03c3\u2081\u2082] (f : F) (s : Set M) (N : Submodule R\u2082 M\u2082) :\n    map f (span R s) \u2264 N \u2194 \u2200 m \u2208 s, f m \u2208 N", "start": [105, 1], "end": [108, 16], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_span_le", "code": "alias _root_.LinearMap.map_span_le := Submodule.map_span_le", "start": [111, 1], "end": [111, 60], "kind": "stdtacticaliasalias"}, {"full_name": "Submodule.span_insert_zero", "code": "@[simp]\ntheorem span_insert_zero : span R (insert (0 : M) s) = span R s", "start": [114, 1], "end": [118, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_preimage_le", "code": "theorem span_preimage_le (f : F) (s : Set M\u2082) :\n    span R (f \u207b\u00b9' s) \u2264 (span R\u2082 s).comap f", "start": [122, 1], "end": [125, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.span_preimage_le", "code": "alias _root_.LinearMap.span_preimage_le := Submodule.span_preimage_le", "start": [128, 1], "end": [128, 70], "kind": "stdtacticaliasalias"}, {"full_name": "Submodule.closure_subset_span", "code": "theorem closure_subset_span {s : Set M} : (AddSubmonoid.closure s : Set M) \u2286 span R s", "start": [131, 1], "end": [132, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.closure_le_toAddSubmonoid_span", "code": "theorem closure_le_toAddSubmonoid_span {s : Set M} :\n    AddSubmonoid.closure s \u2264 (span R s).toAddSubmonoid", "start": [135, 1], "end": [137, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_closure", "code": "@[simp]\ntheorem span_closure {s : Set M} : span R (AddSubmonoid.closure s : Set M) = span R s", "start": [140, 1], "end": [142, 88], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_induction", "code": "@[elab_as_elim]\ntheorem span_induction {p : M \u2192 Prop} (h : x \u2208 span R s) (Hs : \u2200 x \u2208 s, p x) (H0 : p 0)\n    (H1 : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (H2 : \u2200 (a : R) (x), p x \u2192 p (a \u2022 x)) : p x", "start": [145, 1], "end": [151, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_induction\u2082", "code": "theorem span_induction\u2082 {p : M \u2192 M \u2192 Prop} {a b : M} (ha : a \u2208 Submodule.span R s)\n    (hb : b \u2208 Submodule.span R s) (Hs : \u2200 x \u2208 s, \u2200 y \u2208 s, p x y)\n    (H0_left : \u2200 y, p 0 y) (H0_right : \u2200 x, p x 0)\n    (Hadd_left : \u2200 x\u2081 x\u2082 y, p x\u2081 y \u2192 p x\u2082 y \u2192 p (x\u2081 + x\u2082) y)\n    (Hadd_right : \u2200 x y\u2081 y\u2082, p x y\u2081 \u2192 p x y\u2082 \u2192 p x (y\u2081 + y\u2082))\n    (Hsmul_left : \u2200 (r : R) x y, p x y \u2192 p (r \u2022 x) y)\n    (Hsmul_right : \u2200 (r : R) x y, p x y \u2192 p x (r \u2022 y)) : p a b", "start": [154, 1], "end": [166, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_induction'", "code": "theorem span_induction' {p : \u2200 x, x \u2208 span R s \u2192 Prop}\n    (Hs : \u2200 (x) (h : x \u2208 s), p x (subset_span h))\n    (H0 : p 0 (Submodule.zero_mem _))\n    (H1 : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a))\n    (H2 : \u2200 (a : R) (x hx), p x hx \u2192 p (a \u2022 x) (Submodule.smul_mem _ _ \u2039_\u203a)) {x}\n    (hx : x \u2208 span R s) : p x hx", "start": [168, 1], "end": [181, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_span_coe_preimage", "code": "@[simp]\ntheorem span_span_coe_preimage : span R (((\u2191) : span R s \u2192 M) \u207b\u00b9' s) = \u22a4", "start": [184, 1], "end": [191, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_nat_eq_addSubmonoid_closure", "code": "theorem span_nat_eq_addSubmonoid_closure (s : Set M) :\n    (span \u2115 s).toAddSubmonoid = AddSubmonoid.closure s", "start": [194, 1], "end": [200, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_nat_eq", "code": "@[simp]\ntheorem span_nat_eq (s : AddSubmonoid M) : (span \u2115 (s : Set M)).toAddSubmonoid = s", "start": [203, 1], "end": [205, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_int_eq_addSubgroup_closure", "code": "theorem span_int_eq_addSubgroup_closure {M : Type*} [AddCommGroup M] (s : Set M) :\n    (span \u2124 s).toAddSubgroup = AddSubgroup.closure s", "start": [208, 1], "end": [213, 86], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_int_eq", "code": "@[simp]\ntheorem span_int_eq {M : Type*} [AddCommGroup M] (s : AddSubgroup M) :\n    (span \u2124 (s : Set M)).toAddSubgroup = s", "start": [216, 1], "end": [218, 100], "kind": "commanddeclaration"}, {"full_name": "Submodule.gi", "code": "protected def gi : GaloisInsertion (@span R M _ _ _) (\u2191)\n    where\n  choice s _ := span R s\n  gc _ _ := span_le\n  le_l_u _ := subset_span\n  choice_eq _ _ := rfl", "start": [225, 1], "end": [231, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_empty", "code": "@[simp]\ntheorem span_empty : span R (\u2205 : Set M) = \u22a5", "start": [236, 1], "end": [238, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_univ", "code": "@[simp]\ntheorem span_univ : span R (univ : Set M) = \u22a4", "start": [241, 1], "end": [243, 50], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_union", "code": "theorem span_union (s t : Set M) : span R (s \u222a t) = span R s \u2294 span R t", "start": [246, 1], "end": [247, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_iUnion", "code": "theorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set M) : span R (\u22c3 i, s i) = \u2a06 i, span R (s i)", "start": [250, 1], "end": [251, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_iUnion\u2082", "code": "theorem span_iUnion\u2082 {\u03b9} {\u03ba : \u03b9 \u2192 Sort*} (s : \u2200 i, \u03ba i \u2192 Set M) :\n    span R (\u22c3 (i) (j), s i j) = \u2a06 (i) (j), span R (s i j)", "start": [256, 1], "end": [258, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_attach_biUnion", "code": "theorem span_attach_biUnion [DecidableEq M] {\u03b1 : Type*} (s : Finset \u03b1) (f : s \u2192 Finset M) :\n    span R (s.attach.biUnion f : Set M) = \u2a06 x, span R (f x)", "start": [261, 1], "end": [262, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_span", "code": "theorem sup_span : p \u2294 span R s = span R (p \u222a s)", "start": [265, 1], "end": [265, 92], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_sup", "code": "theorem span_sup : span R s \u2294 p = span R (s \u222a p)", "start": [268, 1], "end": [268, 92], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_eq_iSup_of_singleton_spans", "code": "theorem span_eq_iSup_of_singleton_spans (s : Set M) : span R s = \u2a06 x \u2208 s, R \u2219 x", "start": [277, 1], "end": [278, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_range_eq_iSup", "code": "theorem span_range_eq_iSup {\u03b9 : Type*} {v : \u03b9 \u2192 M} : span R (range v) = \u2a06 i, R \u2219 v i", "start": [281, 1], "end": [282, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_smul_le", "code": "theorem span_smul_le (s : Set M) (r : R) : span R (r \u2022 s) \u2264 span R s", "start": [285, 1], "end": [288, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.subset_span_trans", "code": "theorem subset_span_trans {U V W : Set M} (hUV : U \u2286 Submodule.span R V)\n    (hVW : V \u2286 Submodule.span R W) : U \u2286 Submodule.span R W", "start": [291, 1], "end": [293, 45], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_smul_eq_of_isUnit", "code": "theorem span_smul_eq_of_isUnit (s : Set M) (r : R) (hr : IsUnit r) : span R (r \u2022 s) = span R s", "start": [296, 1], "end": [304, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_iSup_of_directed", "code": "@[simp]\ntheorem coe_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M)\n    (H : Directed (\u00b7 \u2264 \u00b7) S) : ((iSup S : Submodule R M) : Set M) = \u22c3 i, S i", "start": [307, 1], "end": [318, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_of_directed", "code": "@[simp]\ntheorem mem_iSup_of_directed {\u03b9} [Nonempty \u03b9] (S : \u03b9 \u2192 Submodule R M) (H : Directed (\u00b7 \u2264 \u00b7) S) {x} :\n    x \u2208 iSup S \u2194 \u2203 i, x \u2208 S i", "start": [321, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sSup_of_directed", "code": "theorem mem_sSup_of_directed {s : Set (Submodule R M)} {z} (hs : s.Nonempty)\n    (hdir : DirectedOn (\u00b7 \u2264 \u00b7) s) : z \u2208 sSup s \u2194 \u2203 y \u2208 s, z \u2208 y", "start": [328, 1], "end": [332, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_iSup_of_chain", "code": "@[norm_cast, simp]\ntheorem coe_iSup_of_chain (a : \u2115 \u2192o Submodule R M) : (\u2191(\u2a06 k, a k) : Set M) = \u22c3 k, (a k : Set M)", "start": [335, 1], "end": [337, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_scott_continuous", "code": "theorem coe_scott_continuous :\n    OmegaCompletePartialOrder.Continuous' ((\u2191) : Submodule R M \u2192 Set M)", "start": [340, 1], "end": [344, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_of_chain", "code": "@[simp]\ntheorem mem_iSup_of_chain (a : \u2115 \u2192o Submodule R M) (m : M) : (m \u2208 \u2a06 k, a k) \u2194 \u2203 k, m \u2208 a k", "start": [347, 1], "end": [349, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sup", "code": "theorem mem_sup : x \u2208 p \u2294 p' \u2194 \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x", "start": [356, 1], "end": [370, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sup'", "code": "theorem mem_sup' : x \u2208 p \u2294 p' \u2194 \u2203 (y : p) (z : p'), (y : M) + z = x", "start": [373, 1], "end": [374, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_add_eq_of_codisjoint", "code": "lemma exists_add_eq_of_codisjoint (h : Codisjoint p p') (x : M) :\n    \u2203 y \u2208 p, \u2203 z \u2208 p', y + z = x := by\n  suffices x \u2208 p \u2294 p' by exact Submodule.mem_sup.mp this\n  simpa only [h.eq_top] using Submodule.mem_top", "start": [377, 1], "end": [380, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Submodule.coe_sup", "code": "theorem coe_sup : \u2191(p \u2294 p') = (p + p' : Set M)", "start": [384, 1], "end": [387, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_toAddSubmonoid", "code": "theorem sup_toAddSubmonoid : (p \u2294 p').toAddSubmonoid = p.toAddSubmonoid \u2294 p'.toAddSubmonoid", "start": [390, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_toAddSubgroup", "code": "theorem sup_toAddSubgroup {R M : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    (p p' : Submodule R M) : (p \u2294 p').toAddSubgroup = p.toAddSubgroup \u2294 p'.toAddSubgroup", "start": [396, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_singleton_self", "code": "theorem mem_span_singleton_self (x : M) : x \u2208 R \u2219 x", "start": [405, 1], "end": [406, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.nontrivial_span_singleton", "code": "theorem nontrivial_span_singleton {x : M} (h : x \u2260 0) : Nontrivial (R \u2219 x)", "start": [409, 1], "end": [414, 15], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_singleton", "code": "theorem mem_span_singleton {y : M} : (x \u2208 R \u2219 y) \u2194 \u2203 a : R, a \u2022 y = x", "start": [417, 1], "end": [427, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_span_singleton_iff", "code": "theorem le_span_singleton_iff {s : Submodule R M} {v\u2080 : M} :\n    (s \u2264 R \u2219 v\u2080) \u2194 \u2200 v \u2208 s, \u2203 r : R, r \u2022 v\u2080 = v", "start": [430, 1], "end": [431, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_eq_top_iff", "code": "theorem span_singleton_eq_top_iff (x : M) : (R \u2219 x) = \u22a4 \u2194 \u2200 v, \u2203 r : R, r \u2022 x = v", "start": [436, 1], "end": [438, 8], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_zero_singleton", "code": "@[simp]\ntheorem span_zero_singleton : (R \u2219 (0 : M)) = \u22a5", "start": [441, 1], "end": [444, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_eq_range", "code": "theorem span_singleton_eq_range (y : M) : \u2191(R \u2219 y) = range ((\u00b7 \u2022 y) : R \u2192 M)", "start": [447, 1], "end": [448, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_smul_le", "code": "theorem span_singleton_smul_le {S} [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]\n    (r : S) (x : M) : (R \u2219 r \u2022 x) \u2264 R \u2219 x", "start": [451, 1], "end": [454, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_group_smul_eq", "code": "theorem span_singleton_group_smul_eq {G} [Group G] [SMul G R] [MulAction G M] [IsScalarTower G R M]\n    (g : G) (x : M) : (R \u2219 g \u2022 x) = R \u2219 x", "start": [457, 1], "end": [461, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_smul_eq", "code": "theorem span_singleton_smul_eq {r : R} (hr : IsUnit r) (x : M) : (R \u2219 r \u2022 x) = R \u2219 x", "start": [466, 1], "end": [469, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.disjoint_span_singleton", "code": "theorem disjoint_span_singleton {K E : Type*} [DivisionRing K] [AddCommGroup E] [Module K E]\n    {s : Submodule K E} {x : E} : Disjoint s (K \u2219 x) \u2194 x \u2208 s \u2192 x = 0", "start": [472, 1], "end": [480, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.disjoint_span_singleton'", "code": "theorem disjoint_span_singleton' {K E : Type*} [DivisionRing K] [AddCommGroup E] [Module K E]\n    {p : Submodule K E} {x : E} (x0 : x \u2260 0) : Disjoint p (K \u2219 x) \u2194 x \u2209 p", "start": [483, 1], "end": [485, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_singleton_trans", "code": "theorem mem_span_singleton_trans {x y z : M} (hxy : x \u2208 R \u2219 y) (hyz : y \u2208 R \u2219 z) : x \u2208 R \u2219 z", "start": [488, 1], "end": [490, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_insert", "code": "theorem span_insert (x) (s : Set M) : span R (insert x s) = (R \u2219 x) \u2294 span R s", "start": [493, 1], "end": [494, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_insert_eq_span", "code": "theorem span_insert_eq_span (h : x \u2208 span R s) : span R (insert x s) = span R s", "start": [497, 1], "end": [498, 96], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_span", "code": "theorem span_span : span R (span R s : Set M) = span R s", "start": [501, 1], "end": [502, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_insert", "code": "theorem mem_span_insert {y} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, \u2203 z \u2208 span R s, x = a \u2022 y + z", "start": [505, 1], "end": [507, 68], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_pair", "code": "theorem mem_span_pair {x y z : M} :\n    z \u2208 span R ({x, y} : Set M) \u2194 \u2203 a b : R, a \u2022 x + b \u2022 y = z", "start": [510, 1], "end": [512, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_le_restrictScalars", "code": "theorem span_le_restrictScalars [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span R s \u2264 (span S s).restrictScalars R", "start": [517, 1], "end": [520, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_subset_span", "code": "@[simp]\ntheorem span_subset_span [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    \u2191(span R s) \u2286 (span S s : Set M)", "start": [523, 1], "end": [527, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_span_of_tower", "code": "theorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\n    span S (span R s : Set M) = span S s", "start": [530, 1], "end": [534, 76], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_eq_bot", "code": "theorem span_eq_bot : span R (s : Set M) = \u22a5 \u2194 \u2200 x \u2208 s, (x : M) = 0", "start": [539, 1], "end": [542, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_eq_bot", "code": "@[simp]\ntheorem span_singleton_eq_bot : (R \u2219 x) = \u22a5 \u2194 x = 0", "start": [545, 1], "end": [547, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_zero", "code": "@[simp]\ntheorem span_zero : span R (0 : Set M) = \u22a5", "start": [550, 1], "end": [551, 94], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_le_iff_mem", "code": "@[simp]\ntheorem span_singleton_le_iff_mem (m : M) (p : Submodule R M) : (R \u2219 m) \u2264 p \u2194 m \u2208 p", "start": [554, 1], "end": [556, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_singleton_eq_span_singleton", "code": "theorem span_singleton_eq_span_singleton {R M : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] {x y : M} : ((R \u2219 x) = R \u2219 y) \u2194 \u2203 z : R\u02e3, z \u2022 x = y", "start": [559, 1], "end": [572, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_image", "code": "@[simp]\ntheorem span_image [RingHomSurjective \u03c3\u2081\u2082] (f : F) :\n    span R\u2082 (f '' s) = map f (span R s)", "start": [575, 1], "end": [578, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.apply_mem_span_image_of_mem_span", "code": "theorem apply_mem_span_image_of_mem_span [RingHomSurjective \u03c3\u2081\u2082] (f : F) {x : M}\n    {s : Set M} (h : x \u2208 Submodule.span R s) : f x \u2208 Submodule.span R\u2082 (f '' s)", "start": [581, 1], "end": [584, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.apply_mem_span_image_iff_mem_span", "code": "theorem apply_mem_span_image_iff_mem_span [RingHomSurjective \u03c3\u2081\u2082] {f : F} {x : M}\n    {s : Set M} (hf : Function.Injective f) :\n    f x \u2208 Submodule.span R\u2082 (f '' s) \u2194 x \u2208 Submodule.span R s", "start": [587, 1], "end": [590, 91], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_subtype_span_singleton", "code": "@[simp]\ntheorem map_subtype_span_singleton {p : Submodule R M} (x : p) :\n    map p.subtype (R \u2219 x) = R \u2219 (x : M)", "start": [592, 1], "end": [594, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.not_mem_span_of_apply_not_mem_span_image", "code": "theorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective \u03c3\u2081\u2082] (f : F) {x : M}\n    {s : Set M} (h : f x \u2209 Submodule.span R\u2082 (f '' s)) : x \u2209 Submodule.span R s", "start": [597, 1], "end": [600, 45], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_span", "code": "theorem iSup_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Set M) : \u2a06 i, span R (p i) = span R (\u22c3 i, p i)", "start": [603, 1], "end": [605, 83], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_eq_span", "code": "theorem iSup_eq_span {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) : \u2a06 i, p i = span R (\u22c3 i, \u2191(p i))", "start": [608, 1], "end": [609, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_toAddSubmonoid", "code": "theorem iSup_toAddSubmonoid {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) :\n    (\u2a06 i, p i).toAddSubmonoid = \u2a06 i, (p i).toAddSubmonoid", "start": [612, 1], "end": [629, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_induction", "code": "@[elab_as_elim]\ntheorem iSup_induction {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) {C : M \u2192 Prop} {x : M}\n    (hx : x \u2208 \u2a06 i, p i) (hp : \u2200 (i), \u2200 x \u2208 p i, C x) (h0 : C 0)\n    (hadd : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) : C x", "start": [632, 1], "end": [640, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_induction'", "code": "@[elab_as_elim]\ntheorem iSup_induction' {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) {C : \u2200 x, (x \u2208 \u2a06 i, p i) \u2192 Prop}\n    (hp : \u2200 (i) (x) (hx : x \u2208 p i), C x (mem_iSup_of_mem i hx)) (h0 : C 0 (zero_mem _))\n    (hadd : \u2200 x y hx hy, C x hx \u2192 C y hy \u2192 C (x + y) (add_mem \u2039_\u203a \u2039_\u203a)) {x : M}\n    (hx : x \u2208 \u2a06 i, p i) : C x hx", "start": [643, 1], "end": [655, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.singleton_span_isCompactElement", "code": "theorem singleton_span_isCompactElement (x : M) :\n    CompleteLattice.IsCompactElement (span R {x} : Submodule R M)", "start": [658, 1], "end": [664, 67], "kind": "commanddeclaration"}, {"full_name": "Submodule.finset_span_isCompactElement", "code": "theorem finset_span_isCompactElement (S : Finset M) :\n    CompleteLattice.IsCompactElement (span R S : Submodule R M)", "start": [667, 1], "end": [674, 97], "kind": "commanddeclaration"}, {"full_name": "Submodule.finite_span_isCompactElement", "code": "theorem finite_span_isCompactElement (S : Set M) (h : S.Finite) :\n    CompleteLattice.IsCompactElement (span R S : Submodule R M)", "start": [677, 1], "end": [680, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.submodule_eq_sSup_le_nonzero_spans", "code": "theorem submodule_eq_sSup_le_nonzero_spans (p : Submodule R M) :\n    p = sSup { T : Submodule R M | \u2203 (m : M) (_ : m \u2208 p) (_ : m \u2260 0), T = span R {m} }", "start": [691, 1], "end": [703, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.lt_sup_iff_not_mem", "code": "theorem lt_sup_iff_not_mem {I : Submodule R M} {a : M} : (I < I \u2294 R \u2219 a) \u2194 a \u2209 I", "start": [706, 1], "end": [706, 92], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup", "code": "theorem mem_iSup {\u03b9 : Sort*} (p : \u03b9 \u2192 Submodule R M) {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2200 N, (\u2200 i, p i \u2264 N) \u2192 m \u2208 N", "start": [709, 1], "end": [712, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sSup", "code": "theorem mem_sSup {s : Set (Submodule R M)} {m : M} :\n    (m \u2208 sSup s) \u2194 \u2200 N, (\u2200 p \u2208 s, p \u2264 N) \u2192 m \u2208 N", "start": [715, 1], "end": [717, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_finite_of_mem_span", "code": "theorem mem_span_finite_of_mem_span {S : Set M} {x : M} (hx : x \u2208 span R S) :\n    \u2203 T : Finset M, \u2191T \u2286 S \u2227 x \u2208 span R (T : Set M)", "start": [721, 1], "end": [740, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod", "code": "def prod : Submodule R (M \u00d7 M') :=\n  { p.toAddSubmonoid.prod q\u2081.toAddSubmonoid with\n    carrier := p \u00d7\u02e2 q\u2081\n    smul_mem' := by rintro a \u27e8x, y\u27e9 \u27e8hx, hy\u27e9; exact \u27e8smul_mem _ a hx, smul_mem _ a hy\u27e9 }", "start": [747, 1], "end": [751, 89], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_coe", "code": "@[simp]\ntheorem prod_coe : (prod p q\u2081 : Set (M \u00d7 M')) = (p : Set M) \u00d7\u02e2 (q\u2081 : Set M')", "start": [754, 1], "end": [756, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_prod", "code": "@[simp]\ntheorem mem_prod {p : Submodule R M} {q : Submodule R M'} {x : M \u00d7 M'} :\n    x \u2208 prod p q \u2194 x.1 \u2208 p \u2227 x.2 \u2208 q", "start": [759, 1], "end": [762, 15], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_prod_le", "code": "theorem span_prod_le (s : Set M) (t : Set M') : span R (s \u00d7\u02e2 t) \u2264 prod (span R s) (span R t)", "start": [765, 1], "end": [766, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_top", "code": "@[simp]\ntheorem prod_top : (prod \u22a4 \u22a4 : Submodule R (M \u00d7 M')) = \u22a4", "start": [769, 1], "end": [770, 73], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_bot", "code": "@[simp]\ntheorem prod_bot : (prod \u22a5 \u22a5 : Submodule R (M \u00d7 M')) = \u22a5", "start": [773, 1], "end": [774, 98], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_mono", "code": "nonrec theorem prod_mono {p p' : Submodule R M} {q q' : Submodule R M'} :\n    p \u2264 p' \u2192 q \u2264 q' \u2192 prod p q \u2264 prod p' q'", "start": [778, 1], "end": [780, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_inf_prod", "code": "@[simp]\ntheorem prod_inf_prod : prod p q\u2081 \u2293 prod p' q\u2081' = prod (p \u2293 p') (q\u2081 \u2293 q\u2081')", "start": [783, 1], "end": [785, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_sup_prod", "code": "@[simp]\ntheorem prod_sup_prod : prod p q\u2081 \u2294 prod p' q\u2081' = prod (p \u2294 p') (q\u2081 \u2294 q\u2081')", "start": [788, 1], "end": [795, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_neg", "code": "@[simp]\ntheorem span_neg (s : Set M) : span R (-s) = span R s", "start": [804, 1], "end": [809, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_insert'", "code": "theorem mem_span_insert' {x y} {s : Set M} :\n    x \u2208 span R (insert y s) \u2194 \u2203 a : R, x + a \u2022 y \u2208 span R s", "start": [812, 1], "end": [818, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_map_eq", "code": "theorem comap_map_eq (f : F) (p : Submodule R M) : comap f (map f p) = p \u2294 LinearMap.ker f", "start": [842, 1], "end": [845, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_map_eq_self", "code": "theorem comap_map_eq_self {f : F} {p : Submodule R M} (h : LinearMap.ker f \u2264 p) :\n    comap f (map f p) = p", "start": [848, 1], "end": [849, 78], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_domRestrict_eq_range_iff", "code": "lemma _root_.LinearMap.range_domRestrict_eq_range_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {S : Submodule R M} :\n    LinearMap.range (f.domRestrict S) = LinearMap.range f \u2194 S \u2294 (LinearMap.ker f) = \u22a4 := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [eq_top_iff]\n    intro x _\n    have : f x \u2208 LinearMap.range f := LinearMap.mem_range_self f x\n    rw [\u2190 h] at this\n    obtain \u27e8y, hy\u27e9 : \u2203 y : S, f.domRestrict S y = f x := this\n    have : (y : M) + (x - y) \u2208 S \u2294 (LinearMap.ker f) := Submodule.add_mem_sup y.2 (by simp [\u2190 hy])\n    simpa using this\n  \u00b7 refine le_antisymm (LinearMap.range_domRestrict_le_range f S) ?_\n    rintro x \u27e8y, rfl\u27e9\n    obtain \u27e8s, hs, t, ht, rfl\u27e9 : \u2203 s, s \u2208 S \u2227 \u2203 t, t \u2208 LinearMap.ker f \u2227 s + t = y :=\n      Submodule.mem_sup.1 (by simp [h])\n    exact \u27e8\u27e8s, hs\u27e9, by simp [LinearMap.mem_ker.1 ht]\u27e9", "start": [852, 1], "end": [866, 54], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.surjective_domRestrict_iff", "code": "@[simp] lemma _root_.LinearMap.surjective_domRestrict_iff\n    {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {S : Submodule R M} (hf : Surjective f) :\n    Surjective (f.domRestrict S) \u2194 S \u2294 LinearMap.ker f = \u22a4 := by\n  rw [\u2190 LinearMap.range_eq_top] at hf \u22a2\n  rw [\u2190 hf]\n  exact LinearMap.range_domRestrict_eq_range_iff", "start": [868, 1], "end": [873, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Submodule.wcovby_span_singleton_sup", "code": "theorem wcovby_span_singleton_sup (x : V) (p : Submodule K V) : Wcovby p ((K \u2219 x) \u2294 p)", "start": [881, 1], "end": [891, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.covby_span_singleton_sup", "code": "theorem covby_span_singleton_sup {x : V} {p : Submodule K V} (h : x \u2209 p) : Covby p ((K \u2219 x) \u2294 p)", "start": [893, 1], "end": [895, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_le_map_iff", "code": "protected theorem map_le_map_iff (f : F) {p p'} : map f p \u2264 map f p' \u2194 p \u2264 p' \u2294 ker f", "start": [917, 1], "end": [918, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_le_map_iff'", "code": "theorem map_le_map_iff' {f : F} (hf : ker f = \u22a5) {p p'} : map f p \u2264 map f p' \u2194 p \u2264 p'", "start": [921, 1], "end": [922, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_injective", "code": "theorem map_injective {f : F} (hf : ker f = \u22a5) : Injective (map f)", "start": [925, 1], "end": [926, 90], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_eq_top_iff", "code": "theorem map_eq_top_iff {f : F} (hf : range f = \u22a4) {p : Submodule R M} :\n    p.map f = \u22a4 \u2194 p \u2294 LinearMap.ker f = \u22a4", "start": [929, 1], "end": [931, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSpanSingleton", "code": "@[simps!]\ndef toSpanSingleton (x : M) : R \u2192\u2097[R] M :=\n  LinearMap.id.smulRight x", "start": [940, 1], "end": [944, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.span_singleton_eq_range", "code": "theorem span_singleton_eq_range (x : M) : (R \u2219 x) = range (toSpanSingleton R M x)", "start": [947, 1], "end": [951, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSpanSingleton_one", "code": "theorem toSpanSingleton_one (x : M) : toSpanSingleton R M x 1 = x", "start": [955, 1], "end": [956, 15], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toSpanSingleton_zero", "code": "@[simp]\ntheorem toSpanSingleton_zero : toSpanSingleton R M 0 = 0", "start": [959, 1], "end": [962, 7], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqOn_span_iff", "code": "theorem eqOn_span_iff {s : Set M} {f g : F} : Set.EqOn f g (span R s) \u2194 Set.EqOn f g s", "start": [975, 1], "end": [977, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqOn_span'", "code": "theorem eqOn_span' {s : Set M} {f g : F} (H : Set.EqOn f g s) :\n    Set.EqOn f g (span R s : Set M)", "start": [979, 1], "end": [985, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eqOn_span", "code": "theorem eqOn_span {s : Set M} {f g : F} (H : Set.EqOn f g s) \u2983x\u2984 (h : x \u2208 span R s) :\n    f x = g x", "start": [988, 1], "end": [993, 17], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_on", "code": "theorem ext_on {s : Set M} {f g : F} (hv : span R s = \u22a4) (h : Set.EqOn f g s) : f = g", "start": [996, 1], "end": [999, 60], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ext_on_range", "code": "theorem ext_on_range {\u03b9 : Type*} {v : \u03b9 \u2192 M} {f g : F} (hv : span R (Set.range v) = \u22a4)\n    (h : \u2200 i, f (v i) = g (v i)) : f = g", "start": [1002, 1], "end": [1006, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_toSpanSingleton", "code": "theorem ker_toSpanSingleton {x : M} (h : x \u2260 0) : LinearMap.ker (toSpanSingleton R M x) = \u22a5", "start": [1016, 1], "end": [1017, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.span_singleton_sup_ker_eq_top", "code": "theorem span_singleton_sup_ker_eq_top (f : V \u2192\u2097[K] K) {x : V} (hx : f x \u2260 0) :\n    (K \u2219 x) \u2294 ker f = \u22a4", "start": [1026, 1], "end": [1031, 49], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toSpanNonzeroSingleton", "code": "noncomputable\ndef toSpanNonzeroSingleton : R \u2243\u2097[R] R \u2219 x :=\n  LinearEquiv.trans\n    (LinearEquiv.ofInjective (LinearMap.toSpanSingleton R M x)\n      (ker_eq_bot.1 <| ker_toSpanSingleton R M h))\n    (LinearEquiv.ofEq (range $ toSpanSingleton R M x) (R \u2219 x) (span_singleton_eq_range R M x).symm)", "start": [1045, 1], "end": [1052, 100], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.toSpanNonzeroSingleton_one", "code": "theorem toSpanNonzeroSingleton_one :\n    LinearEquiv.toSpanNonzeroSingleton R M x h 1 =\n      (\u27e8x, Submodule.mem_span_singleton_self x\u27e9 : R \u2219 x)", "start": [1055, 1], "end": [1060, 51], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coord", "code": "noncomputable\nabbrev coord : (R \u2219 x) \u2243\u2097[R] R :=\n  (toSpanNonzeroSingleton R M x h).symm", "start": [1063, 1], "end": [1067, 40], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coord_self", "code": "theorem coord_self : (coord R M x h) (\u27e8x, Submodule.mem_span_singleton_self x\u27e9 : R \u2219 x) = 1", "start": [1070, 1], "end": [1071, 74], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coord_apply_smul", "code": "theorem coord_apply_smul (y : Submodule.span R ({x} : Set M)) : coord R M x h y \u2022 x = y", "start": [1074, 1], "end": [1075, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Prod.lean", "imports": ["Mathlib/Algebra/Algebra/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.algebra", "code": "instance algebra : Algebra R (A \u00d7 B) :=\n  { Prod.instModule,\n    RingHom.prod (algebraMap R A) (algebraMap R B) with\n    commutes' := by\n      rintro r \u27e8a, b\u27e9\n      dsimp\n      rw [commutes r a, commutes r b]\n    smul_def' := by\n      rintro r \u27e8a, b\u27e9\n      dsimp\n      rw [Algebra.smul_def r a, Algebra.smul_def r b] }", "start": [35, 1], "end": [45, 56], "kind": "commanddeclaration"}, {"full_name": "Prod.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (r : R) : algebraMap R (A \u00d7 B) r = (algebraMap R A r, algebraMap R B r)", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.fst", "code": "def fst : A \u00d7 B \u2192\u2090[R] A :=\n  { RingHom.fst A B with commutes' := fun _r => rfl }", "start": [61, 1], "end": [63, 54], "kind": "commanddeclaration"}, {"full_name": "AlgHom.snd", "code": "def snd : A \u00d7 B \u2192\u2090[R] B :=\n  { RingHom.snd A B with commutes' := fun _r => rfl }", "start": [66, 1], "end": [68, 54], "kind": "commanddeclaration"}, {"full_name": "AlgHom.prod", "code": "@[simps!]\ndef prod (f : A \u2192\u2090[R] B) (g : A \u2192\u2090[R] C) : A \u2192\u2090[R] B \u00d7 C :=\n  { f.toRingHom.prod g.toRingHom with\n    commutes' := fun r => by\n      simp only [toRingHom_eq_coe, RingHom.toFun_eq_coe, RingHom.prod_apply, coe_toRingHom,\n        commutes, Prod.algebraMap_apply] }", "start": [73, 1], "end": [79, 43], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_prod", "code": "theorem coe_prod (f : A \u2192\u2090[R] B) (g : A \u2192\u2090[R] C) : \u21d1(f.prod g) = Pi.prod f g", "start": [82, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.fst_prod", "code": "@[simp]\ntheorem fst_prod (f : A \u2192\u2090[R] B) (g : A \u2192\u2090[R] C) : (fst R B C).comp (prod f g) = f", "start": [86, 1], "end": [87, 98], "kind": "commanddeclaration"}, {"full_name": "AlgHom.snd_prod", "code": "@[simp]\ntheorem snd_prod (f : A \u2192\u2090[R] B) (g : A \u2192\u2090[R] C) : (snd R B C).comp (prod f g) = g", "start": [90, 1], "end": [91, 98], "kind": "commanddeclaration"}, {"full_name": "AlgHom.prod_fst_snd", "code": "@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1", "start": [94, 1], "end": [96, 40], "kind": "commanddeclaration"}, {"full_name": "AlgHom.prodEquiv", "code": "@[simps]\ndef prodEquiv : (A \u2192\u2090[R] B) \u00d7 (A \u2192\u2090[R] C) \u2243 (A \u2192\u2090[R] B \u00d7 C)\n    where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl", "start": [99, 1], "end": [107, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/PartialSups.lean", "imports": ["Mathlib/Data/Finset/Lattice.lean", "Mathlib/Order/ConditionallyCompleteLattice/Finset.lean", "Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "partialSups", "code": "def partialSups (f : \u2115 \u2192 \u03b1) : \u2115 \u2192o \u03b1 :=\n  \u27e8@Nat.rec (fun _ => \u03b1) (f 0) fun (n : \u2115) (a : \u03b1) => a \u2294 f (n + 1),\n    monotone_nat_of_le_succ fun _ => le_sup_left\u27e9", "start": [45, 1], "end": [48, 50], "kind": "commanddeclaration"}, {"full_name": "partialSups_zero", "code": "@[simp]\ntheorem partialSups_zero (f : \u2115 \u2192 \u03b1) : partialSups f 0 = f 0", "start": [51, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "partialSups_succ", "code": "@[simp]\ntheorem partialSups_succ (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    partialSups f (n + 1) = partialSups f n \u2294 f (n + 1)", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "le_partialSups_of_le", "code": "theorem le_partialSups_of_le (f : \u2115 \u2192 \u03b1) {m n : \u2115} (h : m \u2264 n) : f m \u2264 partialSups f n", "start": [62, 1], "end": [67, 37], "kind": "commanddeclaration"}, {"full_name": "le_partialSups", "code": "theorem le_partialSups (f : \u2115 \u2192 \u03b1) : f \u2264 partialSups f", "start": [70, 1], "end": [70, 98], "kind": "commanddeclaration"}, {"full_name": "partialSups_le", "code": "theorem partialSups_le (f : \u2115 \u2192 \u03b1) (n : \u2115) (a : \u03b1) (w : \u2200 m, m \u2264 n \u2192 f m \u2264 a) :\n    partialSups f n \u2264 a", "start": [73, 1], "end": [77, 78], "kind": "commanddeclaration"}, {"full_name": "bddAbove_range_partialSups", "code": "@[simp]\ntheorem bddAbove_range_partialSups {f : \u2115 \u2192 \u03b1} :\n    BddAbove (Set.range (partialSups f)) \u2194 BddAbove (Set.range f)", "start": [80, 1], "end": [89, 67], "kind": "commanddeclaration"}, {"full_name": "Monotone.partialSups_eq", "code": "theorem Monotone.partialSups_eq {f : \u2115 \u2192 \u03b1} (hf : Monotone f) : (partialSups f : \u2115 \u2192 \u03b1) = f", "start": [92, 1], "end": [96, 67], "kind": "commanddeclaration"}, {"full_name": "partialSups_mono", "code": "theorem partialSups_mono : Monotone (partialSups : (\u2115 \u2192 \u03b1) \u2192 \u2115 \u2192o \u03b1)", "start": [99, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "partialSups_apply_mono", "code": "theorem partialSups_apply_mono (f : \u2115 \u2192 \u03b1) : Monotone (partialSups f)", "start": [106, 1], "end": [107, 94], "kind": "commanddeclaration"}, {"full_name": "partialSups.gi", "code": "def partialSups.gi : GaloisInsertion (partialSups : (\u2115 \u2192 \u03b1) \u2192 \u2115 \u2192o \u03b1) (\u2191) where\n  choice f h :=\n    \u27e8f, by convert (partialSups f).monotone using 1; exact (le_partialSups f).antisymm h\u27e9\n  gc f g := by\n    refine' \u27e8(le_partialSups f).trans, fun h => _\u27e9\n    convert partialSups_mono h\n    exact OrderHom.ext _ _ g.monotone.partialSups_eq.symm\n  le_l_u f := le_partialSups f\n  choice_eq f h := OrderHom.ext _ _ ((le_partialSups f).antisymm h)", "start": [109, 1], "end": [119, 68], "kind": "commanddeclaration"}, {"full_name": "partialSups_eq_sup'_range", "code": "theorem partialSups_eq_sup'_range (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    partialSups f n = (Finset.range (n + 1)).sup' \u27e8n, Finset.self_mem_range_succ n\u27e9 f", "start": [122, 1], "end": [128, 42], "kind": "commanddeclaration"}, {"full_name": "partialSups_eq_sup_range", "code": "theorem partialSups_eq_sup_range [SemilatticeSup \u03b1] [OrderBot \u03b1] (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    partialSups f n = (Finset.range (n + 1)).sup f", "start": [133, 1], "end": [138, 60], "kind": "commanddeclaration"}, {"full_name": "partialSups_disjoint_of_disjoint", "code": "theorem partialSups_disjoint_of_disjoint [DistribLattice \u03b1] [OrderBot \u03b1] (f : \u2115 \u2192 \u03b1)\n    (h : Pairwise (Disjoint on f)) {m n : \u2115} (hmn : m < n) : Disjoint (partialSups f m) (f n)", "start": [143, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "partialSups_eq_ciSup_Iic", "code": "theorem partialSups_eq_ciSup_Iic (f : \u2115 \u2192 \u03b1) (n : \u2115) : partialSups f n = \u2a06 i : Set.Iic n, f i", "start": [155, 1], "end": [158, 76], "kind": "commanddeclaration"}, {"full_name": "ciSup_partialSups_eq", "code": "@[simp]\ntheorem ciSup_partialSups_eq {f : \u2115 \u2192 \u03b1} (h : BddAbove (Set.range f)) :\n    \u2a06 n, partialSups f n = \u2a06 n, f n", "start": [161, 1], "end": [167, 37], "kind": "commanddeclaration"}, {"full_name": "partialSups_eq_biSup", "code": "theorem partialSups_eq_biSup (f : \u2115 \u2192 \u03b1) (n : \u2115) : partialSups f n = \u2a06 i \u2264 n, f i", "start": [176, 1], "end": [177, 63], "kind": "commanddeclaration"}, {"full_name": "iSup_partialSups_eq", "code": "theorem iSup_partialSups_eq (f : \u2115 \u2192 \u03b1) : \u2a06 n, partialSups f n = \u2a06 n, f n", "start": [181, 1], "end": [182, 46], "kind": "commanddeclaration"}, {"full_name": "iSup_le_iSup_of_partialSups_le_partialSups", "code": "theorem iSup_le_iSup_of_partialSups_le_partialSups {f g : \u2115 \u2192 \u03b1}\n    (h : partialSups f \u2264 partialSups g) : \u2a06 n, f n \u2264 \u2a06 n, g n", "start": [185, 1], "end": [188, 20], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_iSup_of_partialSups_eq_partialSups", "code": "theorem iSup_eq_iSup_of_partialSups_eq_partialSups {f g : \u2115 \u2192 \u03b1}\n    (h : partialSups f = partialSups g) : \u2a06 n, f n = \u2a06 n, g n", "start": [191, 1], "end": [193, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Pi.lean", "imports": ["Mathlib/LinearAlgebra/Basic.lean", "Mathlib/Logic/Equiv/Fin.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.pi", "code": "def pi (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) : M\u2082 \u2192\u2097[R] (i : \u03b9) \u2192 \u03c6 i :=\n  { Pi.addHom fun i => (f i).toAddHom with\n    toFun := fun c i => f i c\n    map_smul' := fun _ _ => funext fun i => (f i).map_smul _ _ }", "start": [47, 1], "end": [52, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_apply", "code": "@[simp]\ntheorem pi_apply (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) (c : M\u2082) (i : \u03b9) : pi f c i = f i c", "start": [55, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_pi", "code": "theorem ker_pi (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) : ker (pi f) = \u2a05 i : \u03b9, ker (f i)", "start": [60, 1], "end": [61, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_eq_zero", "code": "theorem pi_eq_zero (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) : pi f = 0 \u2194 \u2200 i, f i = 0", "start": [64, 1], "end": [66, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_zero", "code": "theorem pi_zero : pi (fun i => 0 : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) = 0", "start": [69, 1], "end": [69, 78], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_comp", "code": "theorem pi_comp (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) (g : M\u2083 \u2192\u2097[R] M\u2082) :\n    (pi f).comp g = pi fun i => (f i).comp g", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj", "code": "def proj (i : \u03b9) : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i where\n  toFun := Function.eval i\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [77, 1], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_proj", "code": "@[simp]\ntheorem coe_proj (i : \u03b9) : \u21d1(proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) = Function.eval i", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj_apply", "code": "theorem proj_apply (i : \u03b9) (b : (i : \u03b9) \u2192 \u03c6 i) : (proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) b = b i", "start": [92, 1], "end": [93, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj_pi", "code": "theorem proj_pi (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) (i : \u03b9) : (proj i).comp (pi f) = f i", "start": [96, 1], "end": [97, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iInf_ker_proj", "code": "theorem iInf_ker_proj : (\u2a05 i, ker (proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) :\n    Submodule R ((i : \u03b9) \u2192 \u03c6 i)) = \u22a5", "start": [100, 1], "end": [105, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compLeft", "code": "@[simps]\nprotected def compLeft (f : M\u2082 \u2192\u2097[R] M\u2083) (I : Type*) : (I \u2192 M\u2082) \u2192\u2097[R] I \u2192 M\u2083 :=\n  { f.toAddMonoidHom.compLeft I with\n    toFun := fun h => f \u2218 h\n    map_smul' := fun c h => by\n      ext x\n      exact f.map_smul' c (h x) }", "start": [108, 1], "end": [116, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.apply_single", "code": "theorem apply_single [AddCommMonoid M] [Module R M] [DecidableEq \u03b9] (f : (i : \u03b9) \u2192 \u03c6 i \u2192\u2097[R] M)\n    (i j : \u03b9) (x : \u03c6 i) : f j (Pi.single i x j) = (Pi.single i (f i x) : \u03b9 \u2192 M) j", "start": [119, 1], "end": [121, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.single", "code": "def single [DecidableEq \u03b9] (i : \u03b9) : \u03c6 i \u2192\u2097[R] (i : \u03b9) \u2192 \u03c6 i :=\n  { AddMonoidHom.single \u03c6 i with\n    toFun := Pi.single i\n    map_smul' := Pi.single_smul i }", "start": [124, 1], "end": [128, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_single", "code": "@[simp]\ntheorem coe_single [DecidableEq \u03b9] (i : \u03b9) : \u21d1(single i : \u03c6 i \u2192\u2097[R] (i : \u03b9) \u2192 \u03c6 i) = Pi.single i", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsum", "code": "@[simps symm_apply]\ndef lsum (S) [AddCommMonoid M] [Module R M] [Fintype \u03b9] [DecidableEq \u03b9] [Semiring S] [Module S M]\n    [SMulCommClass R S M] : ((i : \u03b9) \u2192 \u03c6 i \u2192\u2097[R] M) \u2243\u2097[S] ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] M where\n  toFun f := \u2211 i : \u03b9, (f i).comp (proj i)\n  invFun f i := f.comp (single i)\n  map_add' f g := by simp only [Pi.add_apply, add_comp, Finset.sum_add_distrib]\n  map_smul' c f := by simp only [Pi.smul_apply, smul_comp, Finset.smul_sum, RingHom.id_apply]\n  left_inv f := by\n    ext i x\n    simp [apply_single]\n  right_inv f := by\n    ext x\n    suffices f (\u2211 j, Pi.single j (x j)) = f x by simpa [apply_single]\n    rw [Finset.univ_sum_single]", "start": [138, 1], "end": [153, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsum_apply", "code": "@[simp]\ntheorem lsum_apply (S) [AddCommMonoid M] [Module R M] [Fintype \u03b9] [DecidableEq \u03b9] [Semiring S]\n    [Module S M] [SMulCommClass R S M] (f : (i : \u03b9) \u2192 \u03c6 i \u2192\u2097[R] M) :\n    lsum R \u03c6 S f = \u2211 i : \u03b9, (f i).comp (proj i)", "start": [157, 1], "end": [160, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lsum_single", "code": "@[simp high]\ntheorem lsum_single {\u03b9 R : Type*} [Fintype \u03b9] [DecidableEq \u03b9] [CommRing R] {M : \u03b9 \u2192 Type*}\n    [(i : \u03b9) \u2192 AddCommGroup (M i)] [(i : \u03b9) \u2192 Module R (M i)] :\n    LinearMap.lsum R M R LinearMap.single = LinearMap.id", "start": [163, 1], "end": [167, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_ext", "code": "theorem pi_ext (h : \u2200 i x, f (Pi.single i x) = g (Pi.single i x)) : f = g", "start": [176, 1], "end": [177, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_ext_iff", "code": "theorem pi_ext_iff : f = g \u2194 \u2200 i x, f (Pi.single i x) = g (Pi.single i x)", "start": [180, 1], "end": [181, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_ext'", "code": "@[ext]\ntheorem pi_ext' (h : \u2200 i, f.comp (single i) = g.comp (single i)) : f = g", "start": [184, 1], "end": [189, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pi_ext'_iff", "code": "theorem pi_ext'_iff : f = g \u2194 \u2200 i, f.comp (single i) = g.comp (single i)", "start": [192, 1], "end": [193, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iInfKerProjEquiv", "code": "def iInfKerProjEquiv {I J : Set \u03b9} [DecidablePred fun i => i \u2208 I] (hd : Disjoint I J)\n    (hu : Set.univ \u2286 I \u222a J) :\n    (\u2a05 i \u2208 J, ker (proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) :\n    Submodule R ((i : \u03b9) \u2192 \u03c6 i)) \u2243\u2097[R] (i : I) \u2192 \u03c6 i := by\n  refine'\n    LinearEquiv.ofLinear (pi fun i => (proj (i : \u03b9)).comp (Submodule.subtype _))\n      (codRestrict _ (pi fun i => if h : i \u2208 I then proj (\u27e8i, h\u27e9 : I) else 0) _) _ _\n  \u00b7 intro b\n    simp only [mem_iInf, mem_ker, funext_iff, proj_apply, pi_apply]\n    intro j hjJ\n    have : j \u2209 I := fun hjI => hd.le_bot \u27e8hjI, hjJ\u27e9\n    rw [dif_neg this, zero_apply]\n  \u00b7 simp only [pi_comp, comp_assoc, subtype_comp_codRestrict, proj_pi, Subtype.coe_prop]\n    ext b \u27e8j, hj\u27e9\n    simp only [dif_pos, Function.comp_apply, Function.eval_apply, LinearMap.codRestrict_apply,\n      LinearMap.coe_comp, LinearMap.coe_proj, LinearMap.pi_apply, Submodule.subtype_apply,\n      Subtype.coe_prop]\n    rfl\n  \u00b7 ext1 \u27e8b, hb\u27e9\n    apply Subtype.ext\n    ext j\n    have hb : \u2200 i \u2208 J, b i = 0 := by\n      simpa only [mem_iInf, mem_ker, proj_apply] using (mem_iInf _).1 hb\n    simp only [comp_apply, pi_apply, id_apply, proj_apply, subtype_apply, codRestrict_apply]\n    split_ifs with h\n    \u00b7 rfl\n    \u00b7 exact (hb _ <| (hu trivial).resolve_left h).symm", "start": [202, 1], "end": [230, 55], "kind": "commanddeclaration"}, {"full_name": "LinearMap.diag", "code": "def diag (i j : \u03b9) : \u03c6 i \u2192\u2097[R] \u03c6 j :=\n  @Function.update \u03b9 (fun j => \u03c6 i \u2192\u2097[R] \u03c6 j) _ 0 i id j", "start": [239, 1], "end": [241, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.update_apply", "code": "theorem update_apply (f : (i : \u03b9) \u2192 M\u2082 \u2192\u2097[R] \u03c6 i) (c : M\u2082) (i j : \u03b9) (b : M\u2082 \u2192\u2097[R] \u03c6 i) :\n    (update f i b j) c = update (fun i => f i c) i (b c) j", "start": [244, 1], "end": [248, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.pi", "code": "def pi (I : Set \u03b9) (p : (i : \u03b9) \u2192 Submodule R (\u03c6 i)) : Submodule R ((i : \u03b9) \u2192 \u03c6 i) where\n  carrier := Set.pi I fun i => p i\n  zero_mem' i _ := (p i).zero_mem\n  add_mem' {_ _} hx hy i hi := (p i).add_mem (hx i hi) (hy i hi)\n  smul_mem' c _ hx i hi := (p i).smul_mem c (hx i hi)", "start": [261, 1], "end": [268, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_pi", "code": "@[simp]\ntheorem mem_pi : x \u2208 pi I p \u2194 \u2200 i \u2208 I, x i \u2208 p i", "start": [273, 1], "end": [275, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_pi", "code": "@[simp, norm_cast]\ntheorem coe_pi : (pi I p : Set ((i : \u03b9) \u2192 \u03c6 i)) = Set.pi I fun i => p i", "start": [278, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.pi_empty", "code": "@[simp]\ntheorem pi_empty (p : (i : \u03b9) \u2192 Submodule R (\u03c6 i)) : pi \u2205 p = \u22a4", "start": [283, 1], "end": [285, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.pi_top", "code": "@[simp]\ntheorem pi_top (s : Set \u03b9) : (pi s fun i : \u03b9 => (\u22a4 : Submodule R (\u03c6 i))) = \u22a4", "start": [288, 1], "end": [290, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.pi_mono", "code": "theorem pi_mono {s : Set \u03b9} (h : \u2200 i \u2208 s, p i \u2264 q i) : pi s p \u2264 pi s q", "start": [293, 1], "end": [294, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.biInf_comap_proj", "code": "theorem biInf_comap_proj :\n    \u2a05 i \u2208 I, comap (proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) (p i) = pi I p", "start": [297, 1], "end": [300, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.iInf_comap_proj", "code": "theorem iInf_comap_proj :\n    \u2a05 i, comap (proj i : ((i : \u03b9) \u2192 \u03c6 i) \u2192\u2097[R] \u03c6 i) (p i) = pi Set.univ p", "start": [303, 1], "end": [306, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_map_single", "code": "theorem iSup_map_single [DecidableEq \u03b9] [Finite \u03b9] :\n    \u2a06 i, map (LinearMap.single i : \u03c6 i \u2192\u2097[R] (i : \u03b9) \u2192 \u03c6 i) (p i) = pi Set.univ p", "start": [309, 1], "end": [317, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_comap_single_pi", "code": "theorem le_comap_single_pi [DecidableEq \u03b9] (p : (i : \u03b9) \u2192 Submodule R (\u03c6 i)) {i} :\n    p i \u2264 Submodule.comap (LinearMap.single i : \u03c6 i \u2192\u2097[R] _) (Submodule.pi Set.univ p)", "start": [320, 1], "end": [328, 25], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrRight", "code": "def piCongrRight (e : (i : \u03b9) \u2192 \u03c6 i \u2243\u2097[R] \u03c8 i) : ((i : \u03b9) \u2192 \u03c6 i) \u2243\u2097[R] (i : \u03b9) \u2192 \u03c8 i :=\n  { AddEquiv.piCongrRight fun j => (e j).toAddEquiv with\n    toFun := fun f i => e i (f i)\n    invFun := fun f i => (e i).symm (f i)\n    map_smul' := fun c f => by ext; simp }", "start": [343, 1], "end": [350, 43], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrRight_apply", "code": "@[simp]\ntheorem piCongrRight_apply (e : (i : \u03b9) \u2192 \u03c6 i \u2243\u2097[R] \u03c8 i) (f i) :\n    piCongrRight e f i = e i (f i)", "start": [353, 1], "end": [355, 42], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrRight_refl", "code": "@[simp]\ntheorem piCongrRight_refl : (piCongrRight fun j => refl R (\u03c6 j)) = refl _ _", "start": [358, 1], "end": [360, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrRight_symm", "code": "@[simp]\ntheorem piCongrRight_symm (e : (i : \u03b9) \u2192 \u03c6 i \u2243\u2097[R] \u03c8 i) :\n    (piCongrRight e).symm = piCongrRight fun i => (e i).symm", "start": [363, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrRight_trans", "code": "@[simp]\ntheorem piCongrRight_trans (e : (i : \u03b9) \u2192 \u03c6 i \u2243\u2097[R] \u03c8 i) (f : (i : \u03b9) \u2192 \u03c8 i \u2243\u2097[R] \u03c7 i) :\n    (piCongrRight e).trans (piCongrRight f) = piCongrRight fun i => (e i).trans (f i)", "start": [369, 1], "end": [372, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrLeft'", "code": "@[simps (config := { simpRhs := true })]\ndef piCongrLeft' (e : \u03b9 \u2243 \u03b9') : ((i' : \u03b9) \u2192 \u03c6 i') \u2243\u2097[R] (i : \u03b9') \u2192 \u03c6 <| e.symm i :=\n  { Equiv.piCongrLeft' \u03c6 e with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [377, 1], "end": [384, 34], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piCongrLeft", "code": "def piCongrLeft (e : \u03b9' \u2243 \u03b9) : ((i' : \u03b9') \u2192 \u03c6 (e i')) \u2243\u2097[R] (i : \u03b9) \u2192 \u03c6 i :=\n  (piCongrLeft' R \u03c6 e.symm).symm", "start": [387, 1], "end": [392, 33], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piOptionEquivProd", "code": "def piOptionEquivProd {\u03b9 : Type*} {M : Option \u03b9 \u2192 Type*} [(i : Option \u03b9) \u2192 AddCommGroup (M i)]\n    [(i : Option \u03b9) \u2192 Module R (M i)] :\n    ((i : Option \u03b9) \u2192 M i) \u2243\u2097[R] M none \u00d7 ((i : \u03b9) \u2192 M (some i)) :=\n  { Equiv.piOptionEquivProd with\n    map_add' := by simp [Function.funext_iff]\n    map_smul' := by simp [Function.funext_iff] }", "start": [395, 1], "end": [401, 49], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piRing", "code": "def piRing : ((\u03b9 \u2192 R) \u2192\u2097[R] M) \u2243\u2097[S] \u03b9 \u2192 M :=\n  (LinearMap.lsum R (fun _ : \u03b9 => R) S).symm.trans\n    (piCongrRight fun _ => LinearMap.ringLmapEquivSelf R S M)", "start": [407, 1], "end": [416, 62], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piRing_apply", "code": "@[simp]\ntheorem piRing_apply (f : (\u03b9 \u2192 R) \u2192\u2097[R] M) (i : \u03b9) : piRing R M \u03b9 S f i = f (Pi.single i 1)", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piRing_symm_apply", "code": "@[simp]\ntheorem piRing_symm_apply (f : \u03b9 \u2192 M) (g : \u03b9 \u2192 R) : (piRing R M \u03b9 S).symm f g = \u2211 i, g i \u2022 f i", "start": [426, 1], "end": [428, 38], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.sumArrowLequivProdArrow", "code": "def sumArrowLequivProdArrow (\u03b1 \u03b2 R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M] :\n    (Sum \u03b1 \u03b2 \u2192 M) \u2243\u2097[R] (\u03b1 \u2192 M) \u00d7 (\u03b2 \u2192 M) :=\n  { Equiv.sumArrowEquivProdArrow \u03b1 \u03b2\n      M with\n    map_add' := by\n      intro f g\n      ext <;> rfl\n    map_smul' := by\n      intro r f\n      ext <;> rfl }", "start": [432, 1], "end": [443, 20], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.sumArrowLequivProdArrow_apply_fst", "code": "@[simp]\ntheorem sumArrowLequivProdArrow_apply_fst {\u03b1 \u03b2} (f : Sum \u03b1 \u03b2 \u2192 M) (a : \u03b1) :\n    (sumArrowLequivProdArrow \u03b1 \u03b2 R M f).1 a = f (Sum.inl a)", "start": [446, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.sumArrowLequivProdArrow_apply_snd", "code": "@[simp]\ntheorem sumArrowLequivProdArrow_apply_snd {\u03b1 \u03b2} (f : Sum \u03b1 \u03b2 \u2192 M) (b : \u03b2) :\n    (sumArrowLequivProdArrow \u03b1 \u03b2 R M f).2 b = f (Sum.inr b)", "start": [452, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.sumArrowLequivProdArrow_symm_apply_inl", "code": "@[simp]\ntheorem sumArrowLequivProdArrow_symm_apply_inl {\u03b1 \u03b2} (f : \u03b1 \u2192 M) (g : \u03b2 \u2192 M) (a : \u03b1) :\n    ((sumArrowLequivProdArrow \u03b1 \u03b2 R M).symm (f, g)) (Sum.inl a) = f a", "start": [458, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.sumArrowLequivProdArrow_symm_apply_inr", "code": "@[simp]\ntheorem sumArrowLequivProdArrow_symm_apply_inr {\u03b1 \u03b2} (f : \u03b1 \u2192 M) (g : \u03b2 \u2192 M) (b : \u03b2) :\n    ((sumArrowLequivProdArrow \u03b1 \u03b2 R M).symm (f, g)) (Sum.inr b) = g b", "start": [464, 1], "end": [467, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funUnique", "code": "@[simps (config :=\n      { simpRhs := true\n        fullyApplied := false }) symm_apply]\ndef funUnique (\u03b9 R M : Type*) [Unique \u03b9] [Semiring R] [AddCommMonoid M] [Module R M] :\n    (\u03b9 \u2192 M) \u2243\u2097[R] M :=\n  { Equiv.funUnique \u03b9 M with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [470, 1], "end": [478, 34], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.funUnique_apply", "code": "@[simp]\ntheorem funUnique_apply (\u03b9 R M : Type*) [Unique \u03b9] [Semiring R] [AddCommMonoid M] [Module R M] :\n    (funUnique \u03b9 R M : (\u03b9 \u2192 M) \u2192 M) = eval default", "start": [482, 1], "end": [484, 58], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piFinTwo", "code": "@[simps (config :=\n      { simpRhs := true\n        fullyApplied := false }) symm_apply]\ndef piFinTwo (M : Fin 2 \u2192 Type v)\n    [(i : Fin 2) \u2192 AddCommMonoid (M i)] [(i : Fin 2) \u2192 Module R (M i)] :\n    ((i : Fin 2) \u2192 M i) \u2243\u2097[R] M 0 \u00d7 M 1 :=\n  { piFinTwoEquiv M with\n    map_add' := fun _ _ => rfl\n    map_smul' := fun _ _ => rfl }", "start": [489, 1], "end": [498, 34], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.piFinTwo_apply", "code": "@[simp]\ntheorem piFinTwo_apply (M : Fin 2 \u2192 Type v)\n    [(i : Fin 2) \u2192 AddCommMonoid (M i)] [(i : Fin 2) \u2192 Module R (M i)] :\n    (piFinTwo R M : ((i : Fin 2) \u2192 M i) \u2192 M 0 \u00d7 M 1) = fun f => (f 0, f 1)", "start": [502, 1], "end": [505, 82], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.finTwoArrow", "code": "@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 \u2192 M) \u2243\u2097[R] M \u00d7 M :=\n  { finTwoArrowEquiv M, piFinTwo R fun _ => M with }", "start": [508, 1], "end": [511, 53], "kind": "commanddeclaration"}, {"full_name": "Function.ExtendByZero.linearMap", "code": "@[simps]\nnoncomputable def Function.ExtendByZero.linearMap : (\u03b9 \u2192 R) \u2192\u2097[R] \u03b7 \u2192 R :=\n  { Function.ExtendByZero.hom R s with\n    toFun := fun f => Function.extend s f 0\n    map_smul' := fun r f => by simpa using Function.extend_smul r s f 0 }", "start": [520, 1], "end": [525, 74], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecEmpty", "code": "def LinearMap.vecEmpty : M \u2192\u2097[R] Fin 0 \u2192 M\u2083 where\n  toFun _ := Matrix.vecEmpty\n  map_add' _ _ := Subsingleton.elim _ _\n  map_smul' _ _ := Subsingleton.elim _ _", "start": [552, 1], "end": [556, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecEmpty_apply", "code": "@[simp]\ntheorem LinearMap.vecEmpty_apply (m : M) : (LinearMap.vecEmpty : M \u2192\u2097[R] Fin 0 \u2192 M\u2083) m = ![]", "start": [559, 1], "end": [561, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecCons", "code": "def LinearMap.vecCons {n} (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] Fin n \u2192 M\u2082) : M \u2192\u2097[R] Fin n.succ \u2192 M\u2082 where\n  toFun m := Matrix.vecCons (f m) (g m)\n  map_add' x y := by\n    simp only []\n    rw [f.map_add, g.map_add, Matrix.cons_add_cons (f x)]\n  map_smul' c x := by\n    simp only []\n    rw [f.map_smul, g.map_smul, RingHom.id_apply, Matrix.smul_cons c (f x)]", "start": [564, 1], "end": [573, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecCons_apply", "code": "@[simp]\ntheorem LinearMap.vecCons_apply {n} (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] Fin n \u2192 M\u2082) (m : M) :\n    f.vecCons g m = Matrix.vecCons (f m) (g m)", "start": [576, 1], "end": [579, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecEmpty\u2082", "code": "@[simps]\ndef LinearMap.vecEmpty\u2082 : M \u2192\u2097[R] M\u2082 \u2192\u2097[R] Fin 0 \u2192 M\u2083 where\n  toFun _ := LinearMap.vecEmpty\n  map_add' _ _ := LinearMap.ext fun _ => Subsingleton.elim _ _\n  map_smul' _ _ := LinearMap.ext fun _ => Subsingleton.elim _ _", "start": [590, 1], "end": [595, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.vecCons\u2082", "code": "@[simps]\ndef LinearMap.vecCons\u2082 {n} (f : M \u2192\u2097[R] M\u2082 \u2192\u2097[R] M\u2083) (g : M \u2192\u2097[R] M\u2082 \u2192\u2097[R] Fin n \u2192 M\u2083) :\n    M \u2192\u2097[R] M\u2082 \u2192\u2097[R] Fin n.succ \u2192 M\u2083 where\n  toFun m := LinearMap.vecCons (f m) (g m)\n  map_add' x y :=\n    LinearMap.ext fun z => by\n      simp only [f.map_add, g.map_add, LinearMap.add_apply, LinearMap.vecCons_apply,\n        Matrix.cons_add_cons (f x z)]\n  map_smul' r x := LinearMap.ext fun z => by simp [Matrix.smul_cons r (f x z)]", "start": [598, 1], "end": [608, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Encodable.lean", "imports": ["Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/Data/DFinsupp/Encodable.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Logic/Small/Basic.lean", "imports": ["Mathlib/Logic/Equiv/Set.lean", "Mathlib/Tactic/PPWithUniv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Small", "code": "@[mk_iff, pp_with_univ]\nclass Small (\u03b1 : Type v) : Prop where\n  \n  equiv_small : \u2203 S : Type w, Nonempty (\u03b1 \u2243 S)", "start": [28, 1], "end": [33, 47], "kind": "commanddeclaration"}, {"full_name": "Small.mk'", "code": "theorem Small.mk' {\u03b1 : Type v} {S : Type w} (e : \u03b1 \u2243 S) : Small.{w} \u03b1", "start": [36, 1], "end": [39, 13], "kind": "commanddeclaration"}, {"full_name": "Shrink", "code": "def Shrink (\u03b1 : Type v) [Small.{w} \u03b1] : Type w :=\n  Classical.choose (@Small.equiv_small \u03b1 _)", "start": [42, 1], "end": [45, 44], "kind": "commanddeclaration"}, {"full_name": "equivShrink", "code": "noncomputable def equivShrink (\u03b1 : Type v) [Small.{w} \u03b1] : \u03b1 \u2243 Shrink \u03b1 :=\n  Nonempty.some (Classical.choose_spec (@Small.equiv_small \u03b1 _))", "start": [48, 1], "end": [51, 65], "kind": "commanddeclaration"}, {"full_name": "Shrink.ext", "code": "@[ext]\ntheorem Shrink.ext {\u03b1 : Type v} [Small.{w} \u03b1] {x y : Shrink \u03b1}\n    (w : (equivShrink _).symm x = (equivShrink _).symm y) : x = y", "start": [54, 1], "end": [57, 16], "kind": "commanddeclaration"}, {"full_name": "Shrink.rec", "code": "@[eliminator]\nprotected noncomputable def Shrink.rec [Small.{w} \u03b1] {F : Shrink \u03b1 \u2192 Sort v}\n    (h : \u2200 X, F (equivShrink _ X)) : \u2200 X, F X :=\n  fun X => ((equivShrink _).apply_symm_apply X) \u25b8 (h _)", "start": [62, 1], "end": [65, 56], "kind": "commanddeclaration"}, {"full_name": "small_self", "code": "instance (priority := 101) small_self (\u03b1 : Type v) : Small.{v} \u03b1 :=\n  Small.mk' <| Equiv.refl \u03b1", "start": [68, 1], "end": [69, 28], "kind": "commanddeclaration"}, {"full_name": "small_map", "code": "theorem small_map {\u03b1 : Type*} {\u03b2 : Type*} [h\u03b2 : Small.{w} \u03b2] (e : \u03b1 \u2243 \u03b2) : Small.{w} \u03b1", "start": [72, 1], "end": [74, 24], "kind": "commanddeclaration"}, {"full_name": "small_lift", "code": "theorem small_lift (\u03b1 : Type u) [h\u03b1 : Small.{v} \u03b1] : Small.{max v w} \u03b1", "start": [77, 1], "end": [79, 46], "kind": "commanddeclaration"}, {"full_name": "small_max", "code": "instance (priority := 100) small_max (\u03b1 : Type v) : Small.{max w v} \u03b1 :=\n  small_lift.{v, w} \u03b1", "start": [82, 1], "end": [83, 22], "kind": "commanddeclaration"}, {"full_name": "small_ulift", "code": "instance small_ulift (\u03b1 : Type u) [Small.{v} \u03b1] : Small.{v} (ULift.{w} \u03b1) :=\n  small_map Equiv.ulift", "start": [86, 1], "end": [87, 24], "kind": "commanddeclaration"}, {"full_name": "small_type", "code": "theorem small_type : Small.{max (u + 1) v} (Type u)", "start": [90, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "small_congr", "code": "theorem small_congr {\u03b1 : Type*} {\u03b2 : Type*} (e : \u03b1 \u2243 \u03b2) : Small.{w} \u03b1 \u2194 Small.{w} \u03b2", "start": [98, 1], "end": [99, 66], "kind": "commanddeclaration"}, {"full_name": "small_subtype", "code": "instance small_subtype (\u03b1 : Type v) [Small.{w} \u03b1] (P : \u03b1 \u2192 Prop) : Small.{w} { x // P x } :=\n  small_map (equivShrink \u03b1).subtypeEquivOfSubtype'", "start": [102, 1], "end": [103, 51], "kind": "commanddeclaration"}, {"full_name": "small_of_injective", "code": "theorem small_of_injective {\u03b1 : Type v} {\u03b2 : Type w} [Small.{u} \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) : Small.{u} \u03b1", "start": [106, 1], "end": [108, 37], "kind": "commanddeclaration"}, {"full_name": "small_of_surjective", "code": "theorem small_of_surjective {\u03b1 : Type v} {\u03b2 : Type w} [Small.{u} \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Surjective f) : Small.{u} \u03b2", "start": [111, 1], "end": [113, 53], "kind": "commanddeclaration"}, {"full_name": "small_subset", "code": "theorem small_subset {\u03b1 : Type v} {s t : Set \u03b1} (hts : t \u2286 s) [Small.{u} s] : Small.{u} t", "start": [116, 1], "end": [118, 78], "kind": "commanddeclaration"}, {"full_name": "small_subsingleton", "code": "instance (priority := 100) small_subsingleton (\u03b1 : Type v) [Subsingleton \u03b1] : Small.{w} \u03b1 := by\n  rcases isEmpty_or_nonempty \u03b1 with \u27e8\u27e9 <;> skip\n  \u00b7 apply small_map (Equiv.equivPEmpty \u03b1)\n  \u00b7 apply small_map Equiv.punitOfNonemptyOfSubsingleton", "start": [121, 1], "end": [124, 56], "kind": "commanddeclaration"}, {"full_name": "small_of_injective_of_exists", "code": "theorem small_of_injective_of_exists {\u03b1 : Type v} {\u03b2 : Type w} {\u03b3 : Type v'} [Small.{u} \u03b1]\n    (f : \u03b1 \u2192 \u03b3) {g : \u03b2 \u2192 \u03b3} (hg : Function.Injective g) (h : \u2200 b : \u03b2, \u2203 a : \u03b1, f a = g b) :\n    Small.{u} \u03b2", "start": [127, 1], "end": [138, 19], "kind": "commanddeclaration"}, {"full_name": "small_Pi", "code": "instance small_Pi {\u03b1} (\u03b2 : \u03b1 \u2192 Type*) [Small.{w} \u03b1] [\u2200 a, Small.{w} (\u03b2 a)] :\n    Small.{w} (\u2200 a, \u03b2 a) :=\n  \u27e8\u27e8\u2200 a' : Shrink \u03b1, Shrink (\u03b2 ((equivShrink \u03b1).symm a')),\n      \u27e8Equiv.piCongr (equivShrink \u03b1) fun a => by simpa using equivShrink (\u03b2 a)\u27e9\u27e9\u27e9", "start": [146, 1], "end": [149, 82], "kind": "commanddeclaration"}, {"full_name": "small_sigma", "code": "instance small_sigma {\u03b1} (\u03b2 : \u03b1 \u2192 Type*) [Small.{w} \u03b1] [\u2200 a, Small.{w} (\u03b2 a)] :\n    Small.{w} (\u03a3a, \u03b2 a) :=\n  \u27e8\u27e8\u03a3a' : Shrink \u03b1, Shrink (\u03b2 ((equivShrink \u03b1).symm a')),\n      \u27e8Equiv.sigmaCongr (equivShrink \u03b1) fun a => by simpa using equivShrink (\u03b2 a)\u27e9\u27e9\u27e9", "start": [152, 1], "end": [155, 85], "kind": "commanddeclaration"}, {"full_name": "small_prod", "code": "instance small_prod {\u03b1 \u03b2} [Small.{w} \u03b1] [Small.{w} \u03b2] : Small.{w} (\u03b1 \u00d7 \u03b2) :=\n  \u27e8\u27e8Shrink \u03b1 \u00d7 Shrink \u03b2, \u27e8Equiv.prodCongr (equivShrink \u03b1) (equivShrink \u03b2)\u27e9\u27e9\u27e9", "start": [158, 1], "end": [159, 77], "kind": "commanddeclaration"}, {"full_name": "small_sum", "code": "instance small_sum {\u03b1 \u03b2} [Small.{w} \u03b1] [Small.{w} \u03b2] : Small.{w} (Sum \u03b1 \u03b2) :=\n  \u27e8\u27e8Sum (Shrink \u03b1) (Shrink \u03b2), \u27e8Equiv.sumCongr (equivShrink \u03b1) (equivShrink \u03b2)\u27e9\u27e9\u27e9", "start": [162, 1], "end": [163, 82], "kind": "commanddeclaration"}, {"full_name": "small_set", "code": "instance small_set {\u03b1} [Small.{w} \u03b1] : Small.{w} (Set \u03b1) :=\n  \u27e8\u27e8Set (Shrink \u03b1), \u27e8Equiv.Set.congr (equivShrink \u03b1)\u27e9\u27e9\u27e9", "start": [166, 1], "end": [167, 56], "kind": "commanddeclaration"}, {"full_name": "small_range", "code": "instance small_range {\u03b1 : Type v} {\u03b2 : Type w} (f : \u03b1 \u2192 \u03b2) [Small.{u} \u03b1] :\n    Small.{u} (Set.range f) :=\n  small_of_surjective Set.surjective_onto_range", "start": [170, 1], "end": [172, 48], "kind": "commanddeclaration"}, {"full_name": "small_image", "code": "instance small_image {\u03b1 : Type v} {\u03b2 : Type w} (f : \u03b1 \u2192 \u03b2) (S : Set \u03b1) [Small.{u} S] :\n    Small.{u} (f '' S) :=\n  small_of_surjective Set.surjective_onto_image", "start": [175, 1], "end": [177, 48], "kind": "commanddeclaration"}, {"full_name": "not_small_type", "code": "theorem not_small_type : \u00acSmall.{u} (Type max u v)", "start": [180, 1], "end": [185, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/SchroederBernstein.lean", "imports": ["Mathlib/Order/FixedPoints.lean", "Mathlib/Order/Zorn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Embedding.schroeder_bernstein", "code": "theorem schroeder_bernstein {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1} (hf : Function.Injective f)\n    (hg : Function.Injective g) : \u2203 h : \u03b1 \u2192 \u03b2, Bijective h", "start": [44, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.antisymm", "code": "theorem antisymm : (\u03b1 \u21aa \u03b2) \u2192 (\u03b2 \u21aa \u03b1) \u2192 Nonempty (\u03b1 \u2243 \u03b2)", "start": [78, 1], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.sets", "code": "@[reducible]\nprivate def sets :=\n  { s : Set (\u2200 i, \u03b2 i) | \u2200 x \u2208 s, \u2200 y \u2208 s, \u2200 (i), (x : \u2200 i, \u03b2 i) i = y i \u2192 x = y }", "start": [92, 1], "end": [95, 83], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.min_injective", "code": "theorem min_injective [I : Nonempty \u03b9] : \u2203 i, Nonempty (\u2200 j, \u03b2 i \u21aa \u03b2 j)", "start": [97, 1], "end": [131, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.total", "code": "theorem total (\u03b1 : Type u) (\u03b2 : Type v) : Nonempty (\u03b1 \u21aa \u03b2) \u2228 Nonempty (\u03b2 \u21aa \u03b1)", "start": [136, 1], "end": [148, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/PartENat.lean", "imports": ["Mathlib/Algebra/Hom/Equiv/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Part.lean", "Mathlib/Data/ENat/Lattice.lean", "Mathlib/Tactic/NormNum.lean"], "premises": [{"full_name": "PartENat", "code": "def PartENat : Type :=\n  Part \u2115", "start": [57, 1], "end": [59, 9], "kind": "commanddeclaration"}, {"full_name": "PartENat.some", "code": "@[coe]\ndef some : \u2115 \u2192 PartENat :=\n  Part.some", "start": [64, 1], "end": [69, 12], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_some", "code": "@[simp]\ntheorem dom_some (x : \u2115) : (some x).Dom", "start": [87, 1], "end": [89, 10], "kind": "commanddeclaration"}, {"full_name": "PartENat.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid PartENat where\n  add := (\u00b7 + \u00b7)\n  zero := 0\n  add_comm x y := Part.ext' and_comm fun _ _ => add_comm _ _\n  zero_add x := Part.ext' (true_and_iff _) fun _ _ => zero_add _\n  add_zero x := Part.ext' (and_true_iff _) fun _ _ => add_zero _\n  add_assoc x y z := Part.ext' and_assoc fun _ _ => add_assoc _ _ _", "start": [92, 1], "end": [98, 68], "kind": "commanddeclaration"}, {"full_name": "PartENat.some_eq_natCast", "code": "theorem some_eq_natCast (n : \u2115) : some n = n", "start": [107, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.natCast_inj", "code": "@[simp, norm_cast]\ntheorem natCast_inj {x y : \u2115} : (x : PartENat) = y \u2194 x = y", "start": [111, 1], "end": [113, 16], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_natCast", "code": "@[simp]\ntheorem dom_natCast (x : \u2115) : (x : PartENat).Dom", "start": [116, 1], "end": [118, 10], "kind": "commanddeclaration"}, {"full_name": "PartENat.le_def", "code": "theorem le_def (x y : PartENat) :\n    x \u2264 y \u2194 \u2203 h : y.Dom \u2192 x.Dom, \u2200 hy : y.Dom, x.get (h hy) \u2264 y.get hy", "start": [136, 1], "end": [138, 10], "kind": "commanddeclaration"}, {"full_name": "PartENat.casesOn'", "code": "@[elab_as_elim]\nprotected theorem casesOn' {P : PartENat \u2192 Prop} :\n    \u2200 a : PartENat, P \u22a4 \u2192 (\u2200 n : \u2115, P (some n)) \u2192 P a", "start": [141, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "PartENat.casesOn", "code": "@[elab_as_elim]\nprotected theorem casesOn {P : PartENat \u2192 Prop} : \u2200 a : PartENat, P \u22a4 \u2192 (\u2200 n : \u2115, P n) \u2192 P a", "start": [147, 1], "end": [149, 26], "kind": "commanddeclaration"}, {"full_name": "PartENat.top_add", "code": "theorem top_add (x : PartENat) : \u22a4 + x = \u22a4", "start": [153, 1], "end": [154, 51], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_top", "code": "theorem add_top (x : PartENat) : x + \u22a4 = \u22a4", "start": [158, 1], "end": [158, 72], "kind": "commanddeclaration"}, {"full_name": "PartENat.natCast_get", "code": "@[simp]\ntheorem natCast_get {x : PartENat} (h : x.Dom) : (x.get h : PartENat) = x", "start": [161, 1], "end": [163, 57], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_natCast'", "code": "@[simp, norm_cast]\ntheorem get_natCast' (x : \u2115) (h : (x : PartENat).Dom) : get (x : PartENat) h = x", "start": [166, 1], "end": [168, 34], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_natCast", "code": "theorem get_natCast {x : \u2115} : get (x : PartENat) (dom_natCast x) = x", "start": [171, 1], "end": [172, 19], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_add_get", "code": "theorem coe_add_get {x : \u2115} {y : PartENat} (h : ((x : PartENat) + y).Dom) :\n    get ((x : PartENat) + y) h = x + get y h.2", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_add", "code": "@[simp]\ntheorem get_add {x y : PartENat} (h : (x + y).Dom) : get (x + y) h = x.get h.1 + y.get h.2", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_zero", "code": "@[simp]\ntheorem get_zero (h : (0 : PartENat).Dom) : (0 : PartENat).get h = 0", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_one", "code": "@[simp]\ntheorem get_one (h : (1 : PartENat).Dom) : (1 : PartENat).get h = 1", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_eq_iff_eq_some", "code": "nonrec theorem get_eq_iff_eq_some {a : PartENat} {ha : a.Dom} {b : \u2115} : a.get ha = b \u2194 a = some b", "start": [195, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_eq_iff_eq_coe", "code": "theorem get_eq_iff_eq_coe {a : PartENat} {ha : a.Dom} {b : \u2115} : a.get ha = b \u2194 a = b", "start": [199, 1], "end": [201, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_of_le_of_dom", "code": "theorem dom_of_le_of_dom {x y : PartENat} : x \u2264 y \u2192 y.Dom \u2192 x.Dom", "start": [204, 1], "end": [204, 85], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_of_le_some", "code": "theorem dom_of_le_some {x : PartENat} {y : \u2115} (h : x \u2264 some y) : x.Dom", "start": [207, 1], "end": [208, 29], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_of_le_natCast", "code": "theorem dom_of_le_natCast {x : PartENat} {y : \u2115} (h : x \u2264 y) : x.Dom", "start": [211, 1], "end": [212, 25], "kind": "commanddeclaration"}, {"full_name": "PartENat.decidableLe", "code": "instance decidableLe (x y : PartENat) [Decidable x.Dom] [Decidable y.Dom] : Decidable (x \u2264 y) :=\n  if hx : x.Dom then\n    decidable_of_decidable_of_iff (by rw [le_def])\n  else\n    if hy : y.Dom then isFalse fun h => hx <| dom_of_le_of_dom h hy\n    else isTrue \u27e8fun h => (hy h).elim, fun h => (hy h).elim\u27e9", "start": [215, 1], "end": [220, 61], "kind": "commanddeclaration"}, {"full_name": "PartENat.natCast_AddMonoidHom", "code": "def natCast_AddMonoidHom : \u2115 \u2192+ PartENat where\n  toFun := some\n  map_zero' := Nat.cast_zero\n  map_add' := Nat.cast_add", "start": [223, 1], "end": [227, 27], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_coeHom", "code": "@[simp]\ntheorem coe_coeHom : natCast_AddMonoidHom = some", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.partialOrder", "code": "instance partialOrder : PartialOrder PartENat where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl _ := \u27e8id, fun _ => le_rfl\u27e9\n  le_trans := fun _ _ _ \u27e8hxy\u2081, hxy\u2082\u27e9 \u27e8hyz\u2081, hyz\u2082\u27e9 =>\n    \u27e8hxy\u2081 \u2218 hyz\u2081, fun _ => le_trans (hxy\u2082 _) (hyz\u2082 _)\u27e9\n  lt_iff_le_not_le _ _ := Iff.rfl\n  le_antisymm := fun _ _ \u27e8hxy\u2081, hxy\u2082\u27e9 \u27e8hyx\u2081, hyx\u2082\u27e9 =>\n    Part.ext' \u27e8hyx\u2081, hxy\u2081\u27e9 fun _ _ => le_antisymm (hxy\u2082 _) (hyx\u2082 _)", "start": [235, 1], "end": [242, 68], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_def", "code": "theorem lt_def (x y : PartENat) : x < y \u2194 \u2203 hx : x.Dom, \u2200 hy : y.Dom, x.get hx < y.get hy", "start": [244, 1], "end": [262, 86], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_le_coe", "code": "@[simp, norm_cast]\ntheorem coe_le_coe {x y : \u2115} : (x : PartENat) \u2264 y \u2194 x \u2264 y", "start": [265, 1], "end": [267, 75], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_lt_coe", "code": "@[simp, norm_cast]\ntheorem coe_lt_coe {x y : \u2115} : (x : PartENat) < y \u2194 x < y", "start": [270, 1], "end": [272, 66], "kind": "commanddeclaration"}, {"full_name": "PartENat.get_le_get", "code": "@[simp]\ntheorem get_le_get {x y : PartENat} {hx : x.Dom} {hy : y.Dom} : x.get hx \u2264 y.get hy \u2194 x \u2264 y", "start": [275, 1], "end": [279, 48], "kind": "commanddeclaration"}, {"full_name": "PartENat.le_coe_iff", "code": "theorem le_coe_iff (x : PartENat) (n : \u2115) : x \u2264 n \u2194 \u2203 h : x.Dom, x.get h \u2264 n", "start": [282, 1], "end": [284, 61], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_coe_iff", "code": "theorem lt_coe_iff (x : PartENat) (n : \u2115) : x < n \u2194 \u2203 h : x.Dom, x.get h < n", "start": [287, 1], "end": [288, 69], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_le_iff", "code": "theorem coe_le_iff (n : \u2115) (x : PartENat) : (n : PartENat) \u2264 x \u2194 \u2200 h : x.Dom, n \u2264 x.get h", "start": [291, 1], "end": [294, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_lt_iff", "code": "theorem coe_lt_iff (n : \u2115) (x : PartENat) : (n : PartENat) < x \u2194 \u2200 h : x.Dom, n < x.get h", "start": [297, 1], "end": [300, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.NeZero.one", "code": "instance NeZero.one : NeZero (1 : PartENat) :=\n  \u27e8natCast_inj.not.mpr (by decide)\u27e9", "start": [303, 1], "end": [304, 36], "kind": "commanddeclaration"}, {"full_name": "PartENat.semilatticeSup", "code": "instance semilatticeSup : SemilatticeSup PartENat :=\n  { PartENat.partialOrder with\n    sup := (\u00b7 \u2294 \u00b7)\n    le_sup_left := fun _ _ => \u27e8And.left, fun _ => le_sup_left\u27e9\n    le_sup_right := fun _ _ => \u27e8And.right, fun _ => le_sup_right\u27e9\n    sup_le := fun _ _ _ \u27e8hx\u2081, hx\u2082\u27e9 \u27e8hy\u2081, hy\u2082\u27e9 =>\n      \u27e8fun hz => \u27e8hx\u2081 hz, hy\u2081 hz\u27e9, fun _ => sup_le (hx\u2082 _) (hy\u2082 _)\u27e9 }", "start": [307, 1], "end": [313, 70], "kind": "commanddeclaration"}, {"full_name": "PartENat.orderBot", "code": "instance orderBot : OrderBot PartENat where\n  bot := \u22a5\n  bot_le _ := \u27e8fun _ => trivial, fun _ => Nat.zero_le _\u27e9", "start": [316, 1], "end": [318, 57], "kind": "commanddeclaration"}, {"full_name": "PartENat.orderTop", "code": "instance orderTop : OrderTop PartENat where\n  top := \u22a4\n  le_top _ := \u27e8fun h => False.elim h, fun hy => False.elim hy\u27e9", "start": [321, 1], "end": [323, 63], "kind": "commanddeclaration"}, {"full_name": "PartENat.eq_zero_iff", "code": "nonrec theorem eq_zero_iff {x : PartENat} : x = 0 \u2194 x \u2264 0", "start": [326, 1], "end": [327, 13], "kind": "commanddeclaration"}, {"full_name": "PartENat.ne_zero_iff", "code": "theorem ne_zero_iff {x : PartENat} : x \u2260 0 \u2194 \u22a5 < x", "start": [330, 1], "end": [331, 25], "kind": "commanddeclaration"}, {"full_name": "PartENat.dom_of_lt", "code": "theorem dom_of_lt {x y : PartENat} : x < y \u2192 x.Dom", "start": [334, 1], "end": [335, 57], "kind": "commanddeclaration"}, {"full_name": "PartENat.top_eq_none", "code": "theorem top_eq_none : (\u22a4 : PartENat) = Part.none", "start": [338, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.natCast_lt_top", "code": "@[simp]\ntheorem natCast_lt_top (x : \u2115) : (x : PartENat) < \u22a4", "start": [342, 1], "end": [344, 97], "kind": "commanddeclaration"}, {"full_name": "PartENat.natCast_ne_top", "code": "@[simp]\ntheorem natCast_ne_top (x : \u2115) : (x : PartENat) \u2260 \u22a4", "start": [347, 1], "end": [349, 30], "kind": "commanddeclaration"}, {"full_name": "PartENat.not_isMax_natCast", "code": "theorem not_isMax_natCast (x : \u2115) : \u00acIsMax (x : PartENat)", "start": [352, 1], "end": [353, 37], "kind": "commanddeclaration"}, {"full_name": "PartENat.ne_top_iff", "code": "theorem ne_top_iff {x : PartENat} : x \u2260 \u22a4 \u2194 \u2203 n : \u2115, x = n", "start": [356, 1], "end": [357, 56], "kind": "commanddeclaration"}, {"full_name": "PartENat.ne_top_iff_dom", "code": "theorem ne_top_iff_dom {x : PartENat} : x \u2260 \u22a4 \u2194 x.Dom", "start": [360, 1], "end": [361, 56], "kind": "commanddeclaration"}, {"full_name": "PartENat.not_dom_iff_eq_top", "code": "theorem not_dom_iff_eq_top {x : PartENat} : \u00acx.Dom \u2194 x = \u22a4", "start": [364, 1], "end": [365, 35], "kind": "commanddeclaration"}, {"full_name": "PartENat.ne_top_of_lt", "code": "theorem ne_top_of_lt {x y : PartENat} (h : x < y) : x \u2260 \u22a4", "start": [368, 1], "end": [369, 38], "kind": "commanddeclaration"}, {"full_name": "PartENat.eq_top_iff_forall_lt", "code": "theorem eq_top_iff_forall_lt (x : PartENat) : x = \u22a4 \u2194 \u2200 n : \u2115, (n : PartENat) < x", "start": [372, 1], "end": [379, 24], "kind": "commanddeclaration"}, {"full_name": "PartENat.eq_top_iff_forall_le", "code": "theorem eq_top_iff_forall_le (x : PartENat) : x = \u22a4 \u2194 \u2200 n : \u2115, (n : PartENat) \u2264 x", "start": [382, 1], "end": [384, 97], "kind": "commanddeclaration"}, {"full_name": "PartENat.pos_iff_one_le", "code": "theorem pos_iff_one_le {x : PartENat} : 0 < x \u2194 1 \u2264 x", "start": [387, 1], "end": [392, 10], "kind": "commanddeclaration"}, {"full_name": "PartENat.isTotal", "code": "instance isTotal : IsTotal PartENat (\u00b7 \u2264 \u00b7) where\n  total x y :=\n    PartENat.casesOn (P := fun z => z \u2264 y \u2228 y \u2264 z) x (Or.inr le_top)\n      (PartENat.casesOn y (fun _ => Or.inl le_top) fun x y =>\n        (le_total x y).elim (Or.inr \u2218 coe_le_coe.2) (Or.inl \u2218 coe_le_coe.2))", "start": [395, 1], "end": [399, 77], "kind": "commanddeclaration"}, {"full_name": "PartENat.linearOrder", "code": "noncomputable instance linearOrder : LinearOrder PartENat :=\n  { PartENat.partialOrder with\n    le_total := IsTotal.total\n    decidableLE := Classical.decRel _\n    max := (\u00b7 \u2294 \u00b7)\n    max_def := fun a b => by\n      change (fun a b => a \u2294 b) a b = _\n      rw [@sup_eq_maxDefault PartENat _ (id _) _]\n      rfl }", "start": [401, 1], "end": [410, 12], "kind": "commanddeclaration"}, {"full_name": "PartENat.boundedOrder", "code": "instance boundedOrder : BoundedOrder PartENat :=\n  { PartENat.orderTop, PartENat.orderBot with }", "start": [412, 1], "end": [413, 48], "kind": "commanddeclaration"}, {"full_name": "PartENat.lattice", "code": "noncomputable instance lattice : Lattice PartENat :=\n  { PartENat.semilatticeSup with\n    inf := min\n    inf_le_left := min_le_left\n    inf_le_right := min_le_right\n    le_inf := fun _ _ _ => le_min }", "start": [415, 1], "end": [420, 36], "kind": "commanddeclaration"}, {"full_name": "PartENat.orderedAddCommMonoid", "code": "noncomputable instance orderedAddCommMonoid : OrderedAddCommMonoid PartENat :=\n  { PartENat.linearOrder, PartENat.addCommMonoid with\n    add_le_add_left := fun a b \u27e8h\u2081, h\u2082\u27e9 c =>\n      PartENat.casesOn c (by simp [top_add]) fun c =>\n        \u27e8fun h => And.intro (dom_natCast _) (h\u2081 h.2), fun h => by\n          simpa only [coe_add_get] using add_le_add_left (h\u2082 _) c\u27e9 }", "start": [422, 1], "end": [427, 69], "kind": "commanddeclaration"}, {"full_name": "PartENat.eq_natCast_sub_of_add_eq_natCast", "code": "theorem eq_natCast_sub_of_add_eq_natCast {x y : PartENat} {n : \u2115} (h : x + y = n) :\n    x = \u2191(n - y.get (dom_of_le_natCast ((le_add_left le_rfl).trans_eq h)))", "start": [442, 1], "end": [447, 53], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_lt_add_right", "code": "protected theorem add_lt_add_right {x y z : PartENat} (h : x < y) (hz : z \u2260 \u22a4) : x + z < y + z", "start": [450, 1], "end": [459, 38], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right {x y z : PartENat} (hz : z \u2260 \u22a4) : x + z < y + z \u2194 x < y", "start": [462, 1], "end": [463, 68], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left {x y z : PartENat} (hz : z \u2260 \u22a4) : z + x < z + y \u2194 x < y", "start": [466, 1], "end": [467, 64], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_add_iff_pos_right", "code": "protected theorem lt_add_iff_pos_right {x y : PartENat} (hx : x \u2260 \u22a4) : x < x + y \u2194 0 < y", "start": [470, 1], "end": [472, 16], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_add_one", "code": "theorem lt_add_one {x : PartENat} (hx : x \u2260 \u22a4) : x < x + 1", "start": [475, 1], "end": [477, 12], "kind": "commanddeclaration"}, {"full_name": "PartENat.le_of_lt_add_one", "code": "theorem le_of_lt_add_one {x y : PartENat} (h : x < y + 1) : x \u2264 y", "start": [480, 1], "end": [485, 53], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_one_le_of_lt", "code": "theorem add_one_le_of_lt {x y : PartENat} (h : x < y) : x + 1 \u2264 y", "start": [488, 1], "end": [493, 53], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_one_le_iff_lt", "code": "theorem add_one_le_iff_lt {x y : PartENat} (hx : x \u2260 \u22a4) : x + 1 \u2264 y \u2194 x < y", "start": [496, 1], "end": [502, 53], "kind": "commanddeclaration"}, {"full_name": "PartENat.coe_succ_le_iff", "code": "theorem coe_succ_le_iff {n : \u2115} {e : PartENat} : \u2191n.succ \u2264 e \u2194 \u2191n < e", "start": [505, 1], "end": [506, 95], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_add_one_iff_lt", "code": "theorem lt_add_one_iff_lt {x y : PartENat} (hx : x \u2260 \u22a4) : x < y + 1 \u2194 x \u2264 y", "start": [509, 1], "end": [516, 53], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_coe_succ_iff_le", "code": "lemma lt_coe_succ_iff_le {x : PartENat} {n : \u2115} (hx : x \u2260 \u22a4) : x < n.succ \u2194 x \u2264 n := by\n  rw [Nat.succ_eq_add_one n, Nat.cast_add, Nat.cast_one, lt_add_one_iff_lt hx]", "start": [519, 1], "end": [520, 79], "kind": "mathlibtacticlemma"}, {"full_name": "PartENat.add_eq_top_iff", "code": "theorem add_eq_top_iff {a b : PartENat} : a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4", "start": [523, 1], "end": [527, 67], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_right_cancel_iff", "code": "protected theorem add_right_cancel_iff {a b c : PartENat} (hc : c \u2260 \u22a4) : a + c = b + c \u2194 a = b", "start": [530, 1], "end": [535, 95], "kind": "commanddeclaration"}, {"full_name": "PartENat.add_left_cancel_iff", "code": "protected theorem add_left_cancel_iff {a b c : PartENat} (ha : a \u2260 \u22a4) : a + b = a + c \u2194 b = c", "start": [538, 1], "end": [539, 64], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop", "code": "def toWithTop (x : PartENat) [Decidable x.Dom] : \u2115\u221e :=\n  x.toOption", "start": [544, 1], "end": [546, 13], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_top", "code": "theorem toWithTop_top :\n    have : Decidable (\u22a4 : PartENat).Dom := Part.noneDecidable\n    toWithTop \u22a4 = \u22a4", "start": [549, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_top'", "code": "@[simp]\ntheorem toWithTop_top' {h : Decidable (\u22a4 : PartENat).Dom} : toWithTop \u22a4 = \u22a4", "start": [555, 1], "end": [557, 24], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_zero", "code": "theorem toWithTop_zero :\n    have : Decidable (0 : PartENat).Dom := someDecidable 0\n    toWithTop 0 = 0", "start": [560, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_zero'", "code": "@[simp]\ntheorem toWithTop_zero' {h : Decidable (0 : PartENat).Dom} : toWithTop 0 = 0", "start": [566, 1], "end": [568, 25], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_some", "code": "theorem toWithTop_some (n : \u2115) : toWithTop (some n) = n", "start": [571, 1], "end": [572, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_natCast", "code": "theorem toWithTop_natCast (n : \u2115) {_ : Decidable (n : PartENat).Dom} : toWithTop n = n", "start": [575, 1], "end": [577, 8], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_natCast'", "code": "@[simp]\ntheorem toWithTop_natCast' (n : \u2115) {h : Decidable (n : PartENat).Dom} :\n    toWithTop (n : PartENat) = n", "start": [580, 1], "end": [583, 27], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_le", "code": "@[simp]\ntheorem toWithTop_le {x y : PartENat} [hx : Decidable x.Dom] [hy : Decidable y.Dom] :\n    toWithTop x \u2264 toWithTop y \u2194 x \u2264 y", "start": [596, 1], "end": [603, 9], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_lt", "code": "@[simp]\ntheorem toWithTop_lt {x y : PartENat} [Decidable x.Dom] [Decidable y.Dom] :\n    toWithTop x < toWithTop y \u2194 x < y", "start": [616, 1], "end": [619, 38], "kind": "commanddeclaration"}, {"full_name": "PartENat.ofENat", "code": "@[coe]\ndef ofENat : \u2115\u221e \u2192 PartENat :=\n  fun x => match x with\n  | Option.none => none\n  | Option.some n => some n", "start": [625, 1], "end": [630, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.ofENat_none", "code": "@[simp]\nlemma ofENat_none : ofENat Option.none = \u22a4 := rfl", "start": [639, 1], "end": [640, 50], "kind": "mathlibtacticlemma"}, {"full_name": "PartENat.ofENat_some", "code": "@[simp]\nlemma ofENat_some (n : \u2115) : ofENat (Option.some n) = \u2191n := rfl", "start": [643, 1], "end": [644, 63], "kind": "mathlibtacticlemma"}, {"full_name": "PartENat.toWithTop_ofENat", "code": "@[simp, norm_cast]\ntheorem toWithTop_ofENat (n : \u2115\u221e) {_ : Decidable (n : PartENat).Dom} : toWithTop (\u2191n) = n", "start": [647, 1], "end": [653, 8], "kind": "commanddeclaration"}, {"full_name": "PartENat.toWithTop_add", "code": "@[simp]\ntheorem toWithTop_add {x y : PartENat} : toWithTop (x + y) = toWithTop x + toWithTop y", "start": [659, 1], "end": [666, 83], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv", "code": "noncomputable def withTopEquiv : PartENat \u2243 \u2115\u221e where\n  toFun x := toWithTop x\n  invFun x := \u2191x\n  left_inv x := by\n    induction x using PartENat.casesOn <;>\n    intros <;>\n    simp <;>\n    rfl\n  right_inv x := by\n    simp [toWithTop_ofENat]", "start": [673, 1], "end": [684, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_top", "code": "@[simp]\ntheorem withTopEquiv_top : withTopEquiv \u22a4 = \u22a4", "start": [687, 1], "end": [689, 17], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_natCast", "code": "@[simp]\ntheorem withTopEquiv_natCast (n : Nat) : withTopEquiv n = n", "start": [692, 1], "end": [694, 23], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_zero", "code": "@[simp]\ntheorem withTopEquiv_zero : withTopEquiv 0 = 0", "start": [697, 1], "end": [699, 58], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_le", "code": "@[simp]\ntheorem withTopEquiv_le {x y : PartENat} : withTopEquiv x \u2264 withTopEquiv y \u2194 x \u2264 y", "start": [702, 1], "end": [704, 15], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_lt", "code": "@[simp]\ntheorem withTopEquiv_lt {x y : PartENat} : withTopEquiv x < withTopEquiv y \u2194 x < y", "start": [707, 1], "end": [709, 15], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopOrderIso", "code": "noncomputable def withTopOrderIso : PartENat \u2243o \u2115\u221e :=\n  { withTopEquiv with map_rel_iff' := @fun _ _ => withTopEquiv_le }", "start": [712, 1], "end": [714, 68], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_symm_top", "code": "@[simp]\ntheorem withTopEquiv_symm_top : withTopEquiv.symm \u22a4 = \u22a4", "start": [717, 1], "end": [719, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_symm_coe", "code": "@[simp]\ntheorem withTopEquiv_symm_coe (n : Nat) : withTopEquiv.symm n = n", "start": [722, 1], "end": [724, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_symm_zero", "code": "@[simp]\ntheorem withTopEquiv_symm_zero : withTopEquiv.symm 0 = 0", "start": [727, 1], "end": [729, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_symm_le", "code": "@[simp]\ntheorem withTopEquiv_symm_le {x y : \u2115\u221e} : withTopEquiv.symm x \u2264 withTopEquiv.symm y \u2194 x \u2264 y", "start": [732, 1], "end": [735, 7], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopEquiv_symm_lt", "code": "@[simp]\ntheorem withTopEquiv_symm_lt {x y : \u2115\u221e} : withTopEquiv.symm x < withTopEquiv.symm y \u2194 x < y", "start": [738, 1], "end": [741, 7], "kind": "commanddeclaration"}, {"full_name": "PartENat.withTopAddEquiv", "code": "noncomputable def withTopAddEquiv : PartENat \u2243+ \u2115\u221e :=\n  { withTopEquiv with\n    map_add' := fun x y => by\n      simp only [withTopEquiv]\n      exact toWithTop_add }", "start": [744, 1], "end": [749, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_wf", "code": "theorem lt_wf : @WellFounded PartENat (\u00b7 < \u00b7)", "start": [754, 1], "end": [758, 65], "kind": "commanddeclaration"}, {"full_name": "PartENat.isWellOrder", "code": "instance isWellOrder : IsWellOrder PartENat (\u00b7 < \u00b7) := {}", "start": [764, 1], "end": [764, 58], "kind": "commanddeclaration"}, {"full_name": "PartENat.wellFoundedRelation", "code": "instance wellFoundedRelation : WellFoundedRelation PartENat :=\n  \u27e8(\u00b7 < \u00b7), lt_wf\u27e9", "start": [766, 1], "end": [767, 19], "kind": "commanddeclaration"}, {"full_name": "PartENat.find", "code": "def find : PartENat :=\n  \u27e8\u2203 n, P n, Nat.find\u27e9", "start": [773, 1], "end": [775, 23], "kind": "commanddeclaration"}, {"full_name": "PartENat.find_get", "code": "@[simp]\ntheorem find_get (h : (find P).Dom) : (find P).get h = Nat.find h", "start": [778, 1], "end": [780, 6], "kind": "commanddeclaration"}, {"full_name": "PartENat.find_dom", "code": "theorem find_dom (h : \u2203 n, P n) : (find P).Dom", "start": [783, 1], "end": [784, 4], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_find", "code": "theorem lt_find (n : \u2115) (h : \u2200 m \u2264 n, \u00acP m) : (n : PartENat) < find P", "start": [787, 1], "end": [794, 12], "kind": "commanddeclaration"}, {"full_name": "PartENat.lt_find_iff", "code": "theorem lt_find_iff (n : \u2115) : (n : PartENat) < find P \u2194 \u2200 m \u2264 n, \u00acP m", "start": [797, 1], "end": [805, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.find_le", "code": "theorem find_le (n : \u2115) (h : P n) : find P \u2264 n", "start": [808, 1], "end": [810, 45], "kind": "commanddeclaration"}, {"full_name": "PartENat.find_eq_top_iff", "code": "theorem find_eq_top_iff : find P = \u22a4 \u2194 \u2200 n, \u00acP n", "start": [813, 1], "end": [815, 92], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/SuccPred/Limit.lean", "imports": ["Mathlib/Order/BoundedOrder.lean", "Mathlib/Order/SuccPred/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.IsSuccLimit", "code": "def IsSuccLimit (a : \u03b1) : Prop :=\n  \u2200 b, \u00acb \u22d6 a", "start": [38, 1], "end": [43, 14], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_iff_exists_covby", "code": "theorem not_isSuccLimit_iff_exists_covby (a : \u03b1) : \u00acIsSuccLimit a \u2194 \u2203 b, b \u22d6 a", "start": [46, 1], "end": [47, 21], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_of_dense", "code": "@[simp]\ntheorem isSuccLimit_of_dense [DenselyOrdered \u03b1] (a : \u03b1) : IsSuccLimit a", "start": [50, 1], "end": [51, 94], "kind": "commanddeclaration"}, {"full_name": "IsMin.isSuccLimit", "code": "protected theorem _root_.IsMin.isSuccLimit : IsMin a \u2192 IsSuccLimit a", "start": [60, 1], "end": [61, 27], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_bot", "code": "theorem isSuccLimit_bot [OrderBot \u03b1] : IsSuccLimit (\u22a5 : \u03b1)", "start": [64, 1], "end": [65, 30], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.isMax", "code": "protected theorem IsSuccLimit.isMax (h : IsSuccLimit (succ a)) : IsMax a", "start": [70, 1], "end": [72, 40], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_succ_of_not_isMax", "code": "theorem not_isSuccLimit_succ_of_not_isMax (ha : \u00acIsMax a) : \u00acIsSuccLimit (succ a)", "start": [75, 1], "end": [77, 17], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.succ_ne", "code": "theorem IsSuccLimit.succ_ne (h : IsSuccLimit a) (b : \u03b1) : succ b \u2260 a", "start": [84, 1], "end": [86, 28], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_succ", "code": "@[simp]\ntheorem not_isSuccLimit_succ (a : \u03b1) : \u00acIsSuccLimit (succ a)", "start": [89, 1], "end": [90, 89], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.isMin_of_noMax", "code": "theorem IsSuccLimit.isMin_of_noMax [NoMaxOrder \u03b1] (h : IsSuccLimit a) : IsMin a", "start": [99, 1], "end": [103, 42], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_iff_of_noMax", "code": "@[simp]\ntheorem isSuccLimit_iff_of_noMax [NoMaxOrder \u03b1] : IsSuccLimit a \u2194 IsMin a", "start": [106, 1], "end": [108, 50], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_of_noMax", "code": "theorem not_isSuccLimit_of_noMax [NoMinOrder \u03b1] [NoMaxOrder \u03b1] : \u00acIsSuccLimit a", "start": [111, 1], "end": [111, 91], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_of_succ_ne", "code": "theorem isSuccLimit_of_succ_ne (h : \u2200 b, succ b \u2260 a) : IsSuccLimit a", "start": [122, 1], "end": [123, 26], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_iff", "code": "theorem not_isSuccLimit_iff : \u00acIsSuccLimit a \u2194 \u2203 b, \u00acIsMax b \u2227 succ b = a", "start": [126, 1], "end": [130, 34], "kind": "commanddeclaration"}, {"full_name": "Order.mem_range_succ_of_not_isSuccLimit", "code": "theorem mem_range_succ_of_not_isSuccLimit (h : \u00acIsSuccLimit a) : a \u2208 range (@succ \u03b1 _ _)", "start": [133, 1], "end": [137, 18], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_of_succ_lt", "code": "theorem isSuccLimit_of_succ_lt (H : \u2200 a < b, succ a < b) : IsSuccLimit b", "start": [140, 1], "end": [141, 38], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.succ_lt", "code": "theorem IsSuccLimit.succ_lt (hb : IsSuccLimit b) (ha : a < b) : succ a < b", "start": [144, 1], "end": [150, 28], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.succ_lt_iff", "code": "theorem IsSuccLimit.succ_lt_iff (hb : IsSuccLimit b) : succ a < b \u2194 a < b", "start": [153, 1], "end": [154, 48], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_iff_succ_lt", "code": "theorem isSuccLimit_iff_succ_lt : IsSuccLimit b \u2194 \u2200 a < b, succ a < b", "start": [157, 1], "end": [158, 51], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimitRecOn", "code": "@[elab_as_elim]\nnoncomputable def isSuccLimitRecOn (b : \u03b1) (hs : \u2200 a, \u00acIsMax a \u2192 C (succ a))\n    (hl : \u2200 a, IsSuccLimit a \u2192 C a) : C b := by\n  by_cases hb : IsSuccLimit b\n  \u00b7 exact hl b hb\n  \u00b7 have H := Classical.choose_spec (not_isSuccLimit_iff.1 hb)\n    rw [\u2190 H.2]\n    exact hs _ H.1", "start": [161, 1], "end": [169, 19], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimitRecOn_limit", "code": "theorem isSuccLimitRecOn_limit (hs : \u2200 a, \u00acIsMax a \u2192 C (succ a)) (hl : \u2200 a, IsSuccLimit a \u2192 C a)\n    (hb : IsSuccLimit b) : @isSuccLimitRecOn \u03b1 _ _ C b hs hl = hl b hb", "start": [172, 1], "end": [174, 29], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimitRecOn_succ'", "code": "theorem isSuccLimitRecOn_succ' (hs : \u2200 a, \u00acIsMax a \u2192 C (succ a)) (hl : \u2200 a, IsSuccLimit a \u2192 C a)\n    {b : \u03b1} (hb : \u00acIsMax b) : @isSuccLimitRecOn \u03b1 _ _ C (succ b) hs hl = hs b hb", "start": [177, 1], "end": [185, 36], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimitRecOn_succ", "code": "@[simp]\ntheorem isSuccLimitRecOn_succ (hs : \u2200 a, \u00acIsMax a \u2192 C (succ a)) (hl : \u2200 a, IsSuccLimit a \u2192 C a)\n    (b : \u03b1) : @isSuccLimitRecOn \u03b1 _ _ C (succ b) hs hl = hs b (not_isMax b)", "start": [192, 1], "end": [195, 31], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_iff_succ_ne", "code": "theorem isSuccLimit_iff_succ_ne : IsSuccLimit a \u2194 \u2200 b, succ b \u2260 a", "start": [198, 1], "end": [199, 48], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit_iff'", "code": "theorem not_isSuccLimit_iff' : \u00acIsSuccLimit a \u2194 a \u2208 range (@succ \u03b1 _ _)", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Order.IsSuccLimit.isMin", "code": "protected theorem IsSuccLimit.isMin (h : IsSuccLimit a) : IsMin a", "start": [213, 1], "end": [218, 13], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_iff", "code": "@[simp]\ntheorem isSuccLimit_iff : IsSuccLimit a \u2194 IsMin a", "start": [221, 1], "end": [223, 41], "kind": "commanddeclaration"}, {"full_name": "Order.not_isSuccLimit", "code": "theorem not_isSuccLimit [NoMinOrder \u03b1] : \u00acIsSuccLimit a", "start": [226, 1], "end": [226, 67], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit", "code": "def IsPredLimit (a : \u03b1) : Prop :=\n  \u2200 b, \u00aca \u22d6 b", "start": [240, 1], "end": [245, 14], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit_iff_exists_covby", "code": "theorem not_isPredLimit_iff_exists_covby (a : \u03b1) : \u00acIsPredLimit a \u2194 \u2203 b, a \u22d6 b", "start": [248, 1], "end": [249, 21], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_of_dense", "code": "theorem isPredLimit_of_dense [DenselyOrdered \u03b1] (a : \u03b1) : IsPredLimit a", "start": [252, 1], "end": [252, 94], "kind": "commanddeclaration"}, {"full_name": "Order.isSuccLimit_toDual_iff", "code": "@[simp]\ntheorem isSuccLimit_toDual_iff : IsSuccLimit (toDual a) \u2194 IsPredLimit a", "start": [255, 1], "end": [257, 34], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_toDual_iff", "code": "@[simp]\ntheorem isPredLimit_toDual_iff : IsPredLimit (toDual a) \u2194 IsSuccLimit a", "start": [260, 1], "end": [262, 34], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit.dual", "code": "alias \u27e8_, isPredLimit.dual\u27e9 := isSuccLimit_toDual_iff", "start": [265, 1], "end": [265, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Order.isSuccLimit.dual", "code": "alias \u27e8_, isSuccLimit.dual\u27e9 := isPredLimit_toDual_iff", "start": [268, 1], "end": [268, 54], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMax.isPredLimit", "code": "protected theorem _root_.IsMax.isPredLimit : IsMax a \u2192 IsPredLimit a", "start": [277, 1], "end": [278, 27], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_top", "code": "theorem isPredLimit_top [OrderTop \u03b1] : IsPredLimit (\u22a4 : \u03b1)", "start": [281, 1], "end": [282, 31], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.isMin", "code": "protected theorem IsPredLimit.isMin (h : IsPredLimit (pred a)) : IsMin a", "start": [287, 1], "end": [289, 40], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit_pred_of_not_isMin", "code": "theorem not_isPredLimit_pred_of_not_isMin (ha : \u00acIsMin a) : \u00acIsPredLimit (pred a)", "start": [292, 1], "end": [294, 17], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.pred_ne", "code": "theorem IsPredLimit.pred_ne (h : IsPredLimit a) (b : \u03b1) : pred b \u2260 a", "start": [301, 1], "end": [303, 28], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit_pred", "code": "@[simp]\ntheorem not_isPredLimit_pred (a : \u03b1) : \u00acIsPredLimit (pred a)", "start": [306, 1], "end": [307, 89], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.isMax_of_noMin", "code": "protected theorem IsPredLimit.isMax_of_noMin [NoMinOrder \u03b1] (h : IsPredLimit a) : IsMax a", "start": [316, 1], "end": [317, 38], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_iff_of_noMin", "code": "@[simp]\ntheorem isPredLimit_iff_of_noMin [NoMinOrder \u03b1] : IsPredLimit a \u2194 IsMax a", "start": [320, 1], "end": [322, 61], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit_of_noMin", "code": "theorem not_isPredLimit_of_noMin [NoMinOrder \u03b1] [NoMaxOrder \u03b1] : \u00acIsPredLimit a", "start": [325, 1], "end": [325, 91], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_of_pred_ne", "code": "theorem isPredLimit_of_pred_ne (h : \u2200 b, pred b \u2260 a) : IsPredLimit a", "start": [336, 1], "end": [337, 26], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit_iff", "code": "theorem not_isPredLimit_iff : \u00acIsPredLimit a \u2194 \u2203 b, \u00acIsMin b \u2227 pred b = a", "start": [340, 1], "end": [342, 28], "kind": "commanddeclaration"}, {"full_name": "Order.mem_range_pred_of_not_isPredLimit", "code": "theorem mem_range_pred_of_not_isPredLimit (h : \u00acIsPredLimit a) : a \u2208 range (@pred \u03b1 _ _)", "start": [345, 1], "end": [349, 18], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_of_pred_lt", "code": "theorem isPredLimit_of_pred_lt (H : \u2200 a > b, pred a < b) : IsPredLimit b", "start": [352, 1], "end": [353, 38], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.lt_pred", "code": "theorem IsPredLimit.lt_pred (h : IsPredLimit a) : a < b \u2192 a < pred b", "start": [356, 1], "end": [357, 31], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.lt_pred_iff", "code": "theorem IsPredLimit.lt_pred_iff (h : IsPredLimit a) : a < pred b \u2194 a < b", "start": [360, 1], "end": [361, 35], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_iff_lt_pred", "code": "theorem isPredLimit_iff_lt_pred : IsPredLimit a \u2194 \u2200 \u2983b\u2984, a < b \u2192 a < pred b", "start": [364, 1], "end": [365, 60], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimitRecOn", "code": "@[elab_as_elim]\nnoncomputable def isPredLimitRecOn (b : \u03b1) (hs : \u2200 a, \u00acIsMin a \u2192 C (pred a))\n    (hl : \u2200 a, IsPredLimit a \u2192 C a) : C b :=\n  @isSuccLimitRecOn \u03b1\u1d52\u1d48 _ _ _ _ hs fun _ ha => hl _ (isSuccLimit.dual ha)", "start": [368, 1], "end": [372, 74], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimitRecOn_limit", "code": "theorem isPredLimitRecOn_limit (hs : \u2200 a, \u00acIsMin a \u2192 C (pred a)) (hl : \u2200 a, IsPredLimit a \u2192 C a)\n    (hb : IsPredLimit b) : @isPredLimitRecOn \u03b1 _ _ C b hs hl = hl b hb", "start": [375, 1], "end": [377, 51], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimitRecOn_pred'", "code": "theorem isPredLimitRecOn_pred' (hs : \u2200 a, \u00acIsMin a \u2192 C (pred a)) (hl : \u2200 a, IsPredLimit a \u2192 C a)\n    {b : \u03b1} (hb : \u00acIsMin b) : @isPredLimitRecOn \u03b1 _ _ C (pred b) hs hl = hs b hb", "start": [380, 1], "end": [382, 31], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimitRecOn_pred", "code": "@[simp]\ntheorem isPredLimitRecOn_pred (hs : \u2200 a, \u00acIsMin a \u2192 C (pred a)) (hl : \u2200 a, IsPredLimit a \u2192 C a)\n    (b : \u03b1) : @isPredLimitRecOn \u03b1 _ _ C (pred b) hs hl = hs b (not_isMin b)", "start": [389, 1], "end": [392, 30], "kind": "commanddeclaration"}, {"full_name": "Order.IsPredLimit.isMax", "code": "protected theorem IsPredLimit.isMax (h : IsPredLimit a) : IsMax a", "start": [401, 1], "end": [402, 29], "kind": "commanddeclaration"}, {"full_name": "Order.isPredLimit_iff", "code": "@[simp]\ntheorem isPredLimit_iff : IsPredLimit a \u2194 IsMax a", "start": [405, 1], "end": [407, 52], "kind": "commanddeclaration"}, {"full_name": "Order.not_isPredLimit", "code": "theorem not_isPredLimit [NoMaxOrder \u03b1] : \u00acIsPredLimit a", "start": [410, 1], "end": [410, 67], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/QuotientGroup.lean", "imports": ["Mathlib/GroupTheory/Coset.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subgroup/Finite.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "Mathlib/GroupTheory/Congruence.lean"], "premises": [{"full_name": "QuotientGroup.con", "code": "@[to_additive \"The additive congruence relation generated by a normal additive subgroup.\"]\nprotected def con : Con G where\n  toSetoid := leftRel N\n  mul' := @fun a b c d hab hcd => by\n    rw [leftRel_eq] at hab hcd \u22a2\n    dsimp only\n    calc\n      (a * c)\u207b\u00b9 * (b * d) = c\u207b\u00b9 * (a\u207b\u00b9 * b) * c\u207b\u00b9\u207b\u00b9 * (c\u207b\u00b9 * d) :=\n        by simp only [mul_inv_rev, mul_assoc, inv_mul_cancel_left]\n      _ \u2208 N := N.mul_mem (nN.conj_mem _ hab _) hcd", "start": [54, 1], "end": [64, 51], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.Quotient.group", "code": "@[to_additive]\ninstance Quotient.group : Group (G \u29f8 N) :=\n  (QuotientGroup.con N).group", "start": [68, 1], "end": [70, 30], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk'", "code": "@[to_additive \"The additive group homomorphism from `G` to `G/N`.\"]\ndef mk' : G \u2192* G \u29f8 N :=\n  MonoidHom.mk' QuotientGroup.mk fun _ _ => rfl", "start": [74, 1], "end": [77, 48], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.coe_mk'", "code": "@[to_additive (attr := simp)]\ntheorem coe_mk' : (mk' N : G \u2192 G \u29f8 N) = mk", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk'_apply", "code": "@[to_additive (attr := simp)]\ntheorem mk'_apply (x : G) : mk' N x = x", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk'_surjective", "code": "@[to_additive]\ntheorem mk'_surjective : Surjective <| mk' N", "start": [93, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk'_eq_mk'", "code": "@[to_additive]\ntheorem mk'_eq_mk' {x y : G} : mk' N x = mk' N y \u2194 \u2203 z \u2208 N, x * z = y", "start": [99, 1], "end": [102, 77], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.monoidHom_ext", "code": "@[to_additive (attr := ext 1100) \"Two `AddMonoidHom`s from an additive quotient group are equal if\n their compositions with `AddQuotientGroup.mk'` are equal.\n\n See note [partially-applied ext lemmas]. \"]\ntheorem monoidHom_ext \u2983f g : G \u29f8 N \u2192* M\u2984 (h : f.comp (mk' N) = g.comp (mk' N)) : f = g", "start": [106, 1], "end": [115, 83], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.eq_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem eq_one_iff {N : Subgroup G} [nN : N.Normal] (x : G) : (x : G \u29f8 N) = 1 \u2194 x \u2208 N", "start": [119, 1], "end": [122, 37], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.ker_le_range_iff", "code": "@[to_additive]\ntheorem ker_le_range_iff {I : Type w} [Group I] (f : G \u2192* H) [f.range.Normal] (g : H \u2192* I) :\n    g.ker \u2264 f.range \u2194 (mk' f.range).comp g.ker.subtype = 1", "start": [126, 1], "end": [130, 77], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.ker_mk'", "code": "@[to_additive (attr := simp)]\ntheorem ker_mk' : MonoidHom.ker (QuotientGroup.mk' N : G \u2192* G \u29f8 N) = N", "start": [132, 1], "end": [134, 26], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.eq_iff_div_mem", "code": "@[to_additive]\ntheorem eq_iff_div_mem {N : Subgroup G} [nN : N.Normal] {x y : G} :\n    (x : G \u29f8 N) = y \u2194 x / y \u2208 N", "start": [139, 1], "end": [143, 39], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.Quotient.commGroup", "code": "@[to_additive]\ninstance Quotient.commGroup {G : Type*} [CommGroup G] (N : Subgroup G) : CommGroup (G \u29f8 N) :=\n  { toGroup := @QuotientGroup.Quotient.group _ _ N N.normal_of_comm\n    mul_comm := fun a b => Quotient.inductionOn\u2082' a b fun a b => congr_arg mk (mul_comm a b) }", "start": [149, 1], "end": [152, 95], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_one", "code": "@[to_additive (attr := simp)]\ntheorem mk_one : ((1 : G) : Q) = 1", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_mul", "code": "@[to_additive (attr := simp)]\ntheorem mk_mul (a b : G) : ((a * b : G) : Q) = a * b", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_inv", "code": "@[to_additive (attr := simp)]\ntheorem mk_inv (a : G) : ((a\u207b\u00b9 : G) : Q) = (a : Q)\u207b\u00b9", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_div", "code": "@[to_additive (attr := simp)]\ntheorem mk_div (a b : G) : ((a / b : G) : Q) = a / b", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_pow", "code": "@[to_additive (attr := simp)]\ntheorem mk_pow (a : G) (n : \u2115) : ((a ^ n : G) : Q) = (a : Q) ^ n", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_zpow", "code": "@[to_additive (attr := simp)]\ntheorem mk_zpow (a : G) (n : \u2124) : ((a ^ n : G) : Q) = (a : Q) ^ n", "start": [188, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.mk_prod", "code": "@[to_additive (attr := simp)]\ntheorem mk_prod {G \u03b9 : Type*} [CommGroup G] (N : Subgroup G) (s : Finset \u03b9) {f : \u03b9 \u2192 G} :\n    ((Finset.prod s f : G) : G \u29f8 N) = Finset.prod s (fun i => (f i : G \u29f8 N))", "start": [194, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.lift", "code": "@[to_additive \"An `AddGroup` homomorphism `\u03c6 : G \u2192+ M` with `N \u2286 ker(\u03c6)` descends (i.e. `lift`s)\n to a group homomorphism `G/N \u2192* M`.\"]\ndef lift (\u03c6 : G \u2192* M) (HN : N \u2264 \u03c6.ker) : Q \u2192* M :=\n  (QuotientGroup.con N).lift \u03c6 fun x y h => by\n    simp only [QuotientGroup.con, leftRel_apply, Con.rel_mk] at h\n    rw [Con.ker_rel]\n    calc\n      \u03c6 x = \u03c6 (y * (x\u207b\u00b9 * y)\u207b\u00b9) := by rw [mul_inv_rev, inv_inv, mul_inv_cancel_left]\n      _ = \u03c6 y := by rw [\u03c6.map_mul, HN (N.inv_mem h), mul_one]", "start": [199, 1], "end": [209, 62], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.lift_mk", "code": "@[to_additive (attr := simp)]\ntheorem lift_mk {\u03c6 : G \u2192* M} (HN : N \u2264 \u03c6.ker) (g : G) : lift N \u03c6 HN (g : Q) = \u03c6 g", "start": [213, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.lift_mk'", "code": "@[to_additive (attr := simp)]\ntheorem lift_mk' {\u03c6 : G \u2192* M} (HN : N \u2264 \u03c6.ker) (g : G) : lift N \u03c6 HN (mk g : Q) = \u03c6 g", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.lift_quot_mk", "code": "@[to_additive (attr := simp)]\ntheorem lift_quot_mk {\u03c6 : G \u2192* M} (HN : N \u2264 \u03c6.ker) (g : G) :\n    lift N \u03c6 HN (Quot.mk _ g : Q) = \u03c6 g", "start": [226, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map", "code": "@[to_additive\n      \"An `AddGroup` homomorphism `f : G \u2192+ H` induces a map `G/N \u2192+ H/M` if `N \u2286 f\u207b\u00b9(M)`.\"]\ndef map (M : Subgroup H) [M.Normal] (f : G \u2192* H) (h : N \u2264 M.comap f) : G \u29f8 N \u2192* H \u29f8 M := by\n  refine' QuotientGroup.lift N ((mk' M).comp f) _\n  intro x hx\n  refine' QuotientGroup.eq.2 _\n  rw [mul_one, Subgroup.inv_mem_iff]\n  exact h hx", "start": [233, 1], "end": [241, 13], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_mk", "code": "@[to_additive (attr := simp)]\ntheorem map_mk (M : Subgroup H) [M.Normal] (f : G \u2192* H) (h : N \u2264 M.comap f) (x : G) :\n    map N M f h \u2191x = \u2191(f x)", "start": [245, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_mk'", "code": "@[to_additive]\ntheorem map_mk' (M : Subgroup H) [M.Normal] (f : G \u2192* H) (h : N \u2264 M.comap f) (x : G) :\n    map N M f h (mk' _ x) = \u2191(f x)", "start": [252, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_id_apply", "code": "@[to_additive]\ntheorem map_id_apply (h : N \u2264 Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) (x) :\n    map N N (MonoidHom.id _) h x = x", "start": [259, 1], "end": [262, 32], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_id", "code": "@[to_additive (attr := simp)]\ntheorem map_id (h : N \u2264 Subgroup.comap (MonoidHom.id _) N := (Subgroup.comap_id N).le) :\n    map N N (MonoidHom.id _) h = MonoidHom.id _", "start": [266, 1], "end": [269, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_map", "code": "@[to_additive (attr := simp)]\ntheorem map_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G \u2192* H) (g : H \u2192* I) (hf : N \u2264 Subgroup.comap f M) (hg : M \u2264 Subgroup.comap g O)\n    (hgf : N \u2264 Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _)))\n    (x : G \u29f8 N) : map M O g hg (map N M f hf x) = map N O (g.comp f) hgf x", "start": [273, 1], "end": [280, 43], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_comp_map", "code": "@[to_additive (attr := simp)]\ntheorem map_comp_map {I : Type*} [Group I] (M : Subgroup H) (O : Subgroup I) [M.Normal] [O.Normal]\n    (f : G \u2192* H) (g : H \u2192* I) (hf : N \u2264 Subgroup.comap f M) (hg : M \u2264 Subgroup.comap g O)\n    (hgf : N \u2264 Subgroup.comap (g.comp f) O :=\n      hf.trans ((Subgroup.comap_mono hg).trans_eq (Subgroup.comap_comap _ _ _))) :\n    (map M O g hg).comp (map N M f hf) = map N O (g.comp f) hgf", "start": [284, 1], "end": [290, 46], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr", "code": "@[to_additive \"`QuotientAddGroup.congr` lifts the isomorphism `e : G \u2243 H` to `G \u29f8 G' \u2243 H \u29f8 H'`,\n given that `e` maps `G` to `H`.\"]\ndef congr (e : G \u2243* H) (he : G'.map e = H') : G \u29f8 G' \u2243* H \u29f8 H' :=\n  { map G' H' e (he \u25b8 G'.le_comap_map (e : G \u2192* H)) with\n    toFun := map G' H' e (he \u25b8 G'.le_comap_map (e : G \u2192* H))\n    invFun := map H' G' e.symm (he \u25b8 (G'.map_equiv_eq_comap_symm e).le)\n    left_inv := fun x => by\n      rw [map_map G' H' G' e e.symm (he \u25b8 G'.le_comap_map (e : G \u2192* H))\n        (he \u25b8 (G'.map_equiv_eq_comap_symm e).le)]\n      simp only [map_map, \u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.self_trans_symm,\n        MulEquiv.coe_monoidHom_refl, map_id_apply]\n    right_inv := fun x => by\n      rw [map_map H' G' H' e.symm e (he \u25b8 (G'.map_equiv_eq_comap_symm e).le)\n        (he \u25b8 G'.le_comap_map (e : G \u2192* H)) ]\n      simp only [\u2190 MulEquiv.coe_monoidHom_trans, MulEquiv.symm_trans_self,\n        MulEquiv.coe_monoidHom_refl, map_id_apply] }", "start": [298, 1], "end": [315, 53], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr_mk", "code": "@[simp]\ntheorem congr_mk (e : G \u2243* H) (he : G'.map \u2191e = H') (x) : congr G' H' e he (mk x) = e x", "start": [319, 1], "end": [321, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr_mk'", "code": "theorem congr_mk' (e : G \u2243* H) (he : G'.map \u2191e = H') (x) :\n    congr G' H' e he (mk' G' x) = mk' H' (e x)", "start": [324, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr_apply", "code": "@[simp]\ntheorem congr_apply (e : G \u2243* H) (he : G'.map \u2191e = H') (x : G) :\n    congr G' H' e he x = mk' H' (e x)", "start": [329, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr_refl", "code": "@[simp]\ntheorem congr_refl (he : G'.map (MulEquiv.refl G : G \u2192* G) = G' := Subgroup.map_id G') :\n    congr G' G' (MulEquiv.refl G) he = MulEquiv.refl (G \u29f8 G')", "start": [335, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.congr_symm", "code": "@[simp]\ntheorem congr_symm (e : G \u2243* H) (he : G'.map \u2191e = H') :\n    (congr G' H' e he).symm = congr H' G' e.symm ((Subgroup.map_symm_eq_iff_map_eq _).mpr he)", "start": [342, 1], "end": [345, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.kerLift", "code": "@[to_additive \"The induced map from the quotient by the kernel to the codomain.\"]\ndef kerLift : G \u29f8 ker \u03c6 \u2192* H :=\n  lift _ \u03c6 fun _g => \u03c6.mem_ker.mp", "start": [354, 1], "end": [357, 34], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.kerLift_mk", "code": "@[to_additive (attr := simp)]\ntheorem kerLift_mk (g : G) : (kerLift \u03c6) g = \u03c6 g", "start": [361, 1], "end": [363, 16], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.kerLift_mk'", "code": "@[to_additive (attr := simp)]\ntheorem kerLift_mk' (g : G) : (kerLift \u03c6) (mk g) = \u03c6 g", "start": [367, 1], "end": [369, 17], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.kerLift_injective", "code": "@[to_additive]\ntheorem kerLift_injective : Injective (kerLift \u03c6)", "start": [373, 1], "end": [376, 95], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rangeKerLift", "code": "@[to_additive \"The induced map from the quotient by the kernel to the range.\"]\ndef rangeKerLift : G \u29f8 ker \u03c6 \u2192* \u03c6.range :=\n  lift _ \u03c6.rangeRestrict fun g hg => (mem_ker _).mp <| by rwa [ker_rangeRestrict]", "start": [382, 1], "end": [385, 82], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rangeKerLift_injective", "code": "@[to_additive]\ntheorem rangeKerLift_injective : Injective (rangeKerLift \u03c6)", "start": [389, 1], "end": [394, 47], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.rangeKerLift_surjective", "code": "@[to_additive]\ntheorem rangeKerLift_surjective : Surjective (rangeKerLift \u03c6)", "start": [398, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientKerEquivRange", "code": "@[to_additive \"The first isomorphism theorem (a definition): the canonical isomorphism between\n`G/(ker \u03c6)` to `range \u03c6`.\"]\nnoncomputable def quotientKerEquivRange : G \u29f8 ker \u03c6 \u2243* range \u03c6 :=\n  MulEquiv.ofBijective (rangeKerLift \u03c6) \u27e8rangeKerLift_injective \u03c6, rangeKerLift_surjective \u03c6\u27e9", "start": [406, 1], "end": [411, 94], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientKerEquivOfRightInverse", "code": "@[to_additive (attr := simps) \"The canonical isomorphism `G/(ker \u03c6) \u2243+ H` induced by a homomorphism\n`\u03c6 : G \u2192+ H` with a right inverse `\u03c8 : H \u2192 G`.\"]\ndef quotientKerEquivOfRightInverse (\u03c8 : H \u2192 G) (h\u03c6 : RightInverse \u03c8 \u03c6) : G \u29f8 ker \u03c6 \u2243* H :=\n  { kerLift \u03c6 with\n    toFun := kerLift \u03c6\n    invFun := mk \u2218 \u03c8\n    left_inv := fun x => kerLift_injective \u03c6 (by rw [Function.comp_apply, kerLift_mk', h\u03c6])\n    right_inv := h\u03c6 }", "start": [415, 1], "end": [424, 22], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientBot", "code": "@[to_additive (attr := simps!) \"The canonical isomorphism `G/\u22a5 \u2243+ G`.\"]\ndef quotientBot : G \u29f8 (\u22a5 : Subgroup G) \u2243* G :=\n  quotientKerEquivOfRightInverse (MonoidHom.id G) id fun _x => rfl", "start": [428, 1], "end": [431, 67], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientKerEquivOfSurjective", "code": "@[to_additive \"The canonical isomorphism `G/(ker \u03c6) \u2243+ H` induced by a surjection `\u03c6 : G \u2192+ H`.\nFor a `computable` version, see `QuotientAddGroup.quotientKerEquivOfRightInverse`.\"]\nnoncomputable def quotientKerEquivOfSurjective (h\u03c6 : Surjective \u03c6) : G \u29f8 ker \u03c6 \u2243* H :=\n  quotientKerEquivOfRightInverse \u03c6 _ h\u03c6.hasRightInverse.choose_spec", "start": [435, 1], "end": [442, 68], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientMulEquivOfEq", "code": "@[to_additive \"If two normal subgroups `M` and `N` of `G` are the same, their quotient groups are\nisomorphic.\"]\ndef quotientMulEquivOfEq {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) : G \u29f8 M \u2243* G \u29f8 N :=\n  { Subgroup.quotientEquivOfEq h with\n    map_mul' := fun q r => Quotient.inductionOn\u2082' q r fun _g _h => rfl }", "start": [446, 1], "end": [452, 73], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientMulEquivOfEq_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientMulEquivOfEq_mk {M N : Subgroup G} [M.Normal] [N.Normal] (h : M = N) (x : G) :\n    QuotientGroup.quotientMulEquivOfEq h (QuotientGroup.mk x) = QuotientGroup.mk x", "start": [456, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientMapSubgroupOfOfLe", "code": "@[to_additive \"Let `A', A, B', B` be subgroups of `G`. If `A' \u2264 B'` and `A \u2264 B`, then there is a map\n`A / (A' \u2293 A) \u2192+ B / (B' \u2293 B)` induced by the inclusions.\"]\ndef quotientMapSubgroupOfOfLe {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]\n    [_hBN : (B'.subgroupOf B).Normal] (h' : A' \u2264 B') (h : A \u2264 B) :\n    A \u29f8 A'.subgroupOf A \u2192* B \u29f8 B'.subgroupOf B :=\n  map _ _ (Subgroup.inclusion h) <| Subgroup.comap_mono h'", "start": [463, 1], "end": [470, 59], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientMapSubgroupOfOfLe_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientMapSubgroupOfOfLe_mk {A' A B' B : Subgroup G} [_hAN : (A'.subgroupOf A).Normal]\n    [_hBN : (B'.subgroupOf B).Normal] (h' : A' \u2264 B') (h : A \u2264 B) (x : A) :\n    quotientMapSubgroupOfOfLe h' h x = \u2191(Subgroup.inclusion h x : B)", "start": [474, 1], "end": [478, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.equivQuotientSubgroupOfOfEq", "code": "@[to_additive \"Let `A', A, B', B` be subgroups of `G`. If `A' = B'` and `A = B`, then the quotients\n`A / (A' \u2293 A)` and `B / (B' \u2293 B)` are isomorphic. Applying this equiv is nicer than rewriting along\nthe equalities, since the type of `(A'.addSubgroupOf A : AddSubgroup A)` depends on on `A`. \"]\ndef equivQuotientSubgroupOfOfEq {A' A B' B : Subgroup G} [hAN : (A'.subgroupOf A).Normal]\n    [hBN : (B'.subgroupOf B).Normal] (h' : A' = B') (h : A = B) :\n    A \u29f8 A'.subgroupOf A \u2243* B \u29f8 B'.subgroupOf B :=\n  MonoidHom.toMulEquiv (quotientMapSubgroupOfOfLe h'.le h.le) (quotientMapSubgroupOfOfLe h'.ge h.ge)\n    (by ext \u27e8x, hx\u27e9; rfl)\n    (by ext \u27e8x, hx\u27e9; rfl)", "start": [482, 1], "end": [496, 26], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.homQuotientZPowOfHom", "code": "@[to_additive \"The map of quotients by multiples of an integer induced by an additive group\nhomomorphism.\"]\ndef homQuotientZPowOfHom :\n    A \u29f8 (zpowGroupHom n : A \u2192* A).range \u2192* B \u29f8 (zpowGroupHom n : B \u2192* B).range :=\n  lift _ ((mk' _).comp f) fun g \u27e8h, (hg : h ^ n = g)\u27e9 =>\n    (eq_one_iff _).mpr \u27e8f h, by\n      simp only [\u2190 hg, map_zpow, zpowGroupHom_apply]\u27e9", "start": [506, 1], "end": [513, 54], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.homQuotientZPowOfHom_id", "code": "@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _", "start": [517, 1], "end": [519, 22], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.homQuotientZPowOfHom_comp", "code": "@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp :\n    homQuotientZPowOfHom (f.comp g) n =\n      (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n)", "start": [523, 1], "end": [527, 22], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.homQuotientZPowOfHom_comp_of_rightInverse", "code": "@[to_additive (attr := simp)]\ntheorem homQuotientZPowOfHom_comp_of_rightInverse (i : Function.RightInverse g f) :\n    (homQuotientZPowOfHom f n).comp (homQuotientZPowOfHom g n) = MonoidHom.id _", "start": [531, 1], "end": [534, 62], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.equivQuotientZPowOfEquiv", "code": "@[to_additive \"The equivalence of quotients by multiples of an integer induced by an additive group\nisomorphism.\"]\ndef equivQuotientZPowOfEquiv :\n    A \u29f8 (zpowGroupHom n : A \u2192* A).range \u2243* B \u29f8 (zpowGroupHom n : B \u2192* B).range :=\n  MonoidHom.toMulEquiv _ _\n    (homQuotientZPowOfHom_comp_of_rightInverse (e.symm : B \u2192* A) (e : A \u2192* B) n e.left_inv)\n    (homQuotientZPowOfHom_comp_of_rightInverse (e : A \u2192* B) (e.symm : B \u2192* A) n e.right_inv)", "start": [538, 1], "end": [545, 93], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.equivQuotientZPowOfEquiv_refl", "code": "@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_refl :\n    MulEquiv.refl (A \u29f8 (zpowGroupHom n : A \u2192* A).range) =\n      equivQuotientZPowOfEquiv (MulEquiv.refl A) n", "start": [550, 1], "end": [556, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.equivQuotientZPowOfEquiv_symm", "code": "@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_symm :\n    (equivQuotientZPowOfEquiv e n).symm = equivQuotientZPowOfEquiv e.symm n", "start": [560, 1], "end": [563, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.equivQuotientZPowOfEquiv_trans", "code": "@[to_additive (attr := simp)]\ntheorem equivQuotientZPowOfEquiv_trans :\n    (equivQuotientZPowOfEquiv e n).trans (equivQuotientZPowOfEquiv d n) =\n      equivQuotientZPowOfEquiv (e.trans d) n", "start": [567, 1], "end": [573, 6], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientInfEquivProdNormalQuotient", "code": "@[to_additive \"The second isomorphism theorem: given two subgroups `H` and `N` of a group `G`, where\n`N` is normal, defines an isomorphism between `H/(H \u2229 N)` and `(H + N)/N`\"]\nnoncomputable def quotientInfEquivProdNormalQuotient (H N : Subgroup G) [N.Normal] :\n    H \u29f8 N.subgroupOf H \u2243* _ \u29f8 N.subgroupOf (H \u2294 N) :=\n  let\n    \u03c6 :H \u2192*\n      _ \u29f8 N.subgroupOf (H \u2294 N) :=\n    (mk' <| N.subgroupOf (H \u2294 N)).comp (inclusion le_sup_left)\n  have \u03c6_surjective : Surjective \u03c6 := fun x =>\n    x.inductionOn' <| by\n      rintro \u27e8y, hy : y \u2208 (H \u2294 N)\u27e9;\n      rw [\u2190SetLike.mem_coe] at hy\n      rw [mul_normal H N] at hy\n      rcases hy with \u27e8h, n, hh, hn, rfl\u27e9\n      use \u27e8h, hh\u27e9\n      let _ : Setoid \u2191(H \u2294 N) :=\n        (@leftRel \u2191(H \u2294 N) (H \u2294 N : Subgroup G).toGroup (N.subgroupOf (H \u2294 N)))\n      refine Quotient.eq.mpr ?_\n      change Setoid.r _ _\n      rw [leftRel_apply]\n      change h\u207b\u00b9 * (h * n) \u2208 N\n      rwa [\u2190 mul_assoc, inv_mul_self, one_mul]\n  (quotientMulEquivOfEq (by simp [\u2190 comap_ker])).trans (quotientKerEquivOfSurjective \u03c6 \u03c6_surjective)", "start": [583, 1], "end": [609, 101], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.map_normal", "code": "@[to_additive]\ninstance map_normal : (M.map (QuotientGroup.mk' N)).Normal :=\n  nM.map _ mk_surjective", "start": [619, 1], "end": [621, 25], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientQuotientEquivQuotientAux", "code": "@[to_additive \"The map from the third isomorphism theorem for additive groups:\n`(A / N) / (M / N) \u2192 A / M`.\"]\ndef quotientQuotientEquivQuotientAux : (G \u29f8 N) \u29f8 M.map (mk' N) \u2192* G \u29f8 M :=\n  lift (M.map (mk' N)) (map N M (MonoidHom.id G) h)\n    (by\n      rintro _ \u27e8x, hx, rfl\u27e9\n      rw [mem_ker, map_mk' N M _ _ x]\n      exact (QuotientGroup.eq_one_iff _).mpr hx)", "start": [627, 1], "end": [635, 49], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientQuotientEquivQuotientAux_mk", "code": "@[to_additive (attr := simp)]\ntheorem quotientQuotientEquivQuotientAux_mk (x : G \u29f8 N) :\n    quotientQuotientEquivQuotientAux N M h x = QuotientGroup.map N M (MonoidHom.id G) h x", "start": [639, 1], "end": [642, 31], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientQuotientEquivQuotientAux_mk_mk", "code": "@[to_additive]\ntheorem quotientQuotientEquivQuotientAux_mk_mk (x : G) :\n    quotientQuotientEquivQuotientAux N M h (x : G \u29f8 N) = x", "start": [646, 1], "end": [649, 45], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.quotientQuotientEquivQuotient", "code": "@[to_additive\n      \"**Noether's third isomorphism theorem** for additive groups: `(A / N) / (M / N) \u2243+ A / M`.\"]\ndef quotientQuotientEquivQuotient : (G \u29f8 N) \u29f8 M.map (QuotientGroup.mk' N) \u2243* G \u29f8 M :=\n  MonoidHom.toMulEquiv (quotientQuotientEquivQuotientAux N M h)\n    (QuotientGroup.map _ _ (QuotientGroup.mk' N) (Subgroup.le_comap_map _ _))\n    (by ext; simp)\n    (by ext; simp)", "start": [653, 1], "end": [660, 19], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.subsingleton_quotient_top", "code": "@[to_additive]\ntheorem subsingleton_quotient_top : Subsingleton (G \u29f8 (\u22a4 : Subgroup G))", "start": [668, 1], "end": [672, 36], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.subgroup_eq_top_of_subsingleton", "code": "@[to_additive \"If the quotient by an additive subgroup gives a singleton then the additive subgroup\nis the whole additive group.\"]\ntheorem subgroup_eq_top_of_subsingleton (H : Subgroup G) (h : Subsingleton (G \u29f8 H)) : H = \u22a4", "start": [676, 1], "end": [682, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.comap_comap_center", "code": "@[to_additive]\ntheorem comap_comap_center {H\u2081 : Subgroup G} [H\u2081.Normal] {H\u2082 : Subgroup (G \u29f8 H\u2081)} [H\u2082.Normal] :\n    ((Subgroup.center ((G \u29f8 H\u2081) \u29f8 H\u2082)).comap (mk' H\u2082)).comap (mk' H\u2081) =\n      (Subgroup.center (G \u29f8 H\u2082.comap (mk' H\u2081))).comap (mk' (H\u2082.comap (mk' H\u2081)))", "start": [688, 1], "end": [694, 28], "kind": "commanddeclaration"}, {"full_name": "Group.fintypeOfKerLeRange", "code": "@[to_additive \"If `F` and `H` are finite such that `ker(G \u2192+ H) \u2264 im(F \u2192+ G)`, then `G` is finite.\"]\nnoncomputable def fintypeOfKerLeRange (h : g.ker \u2264 f.range) : Fintype G :=\n  @Fintype.ofEquiv _ _\n    (@instFintypeProd _ _ (Fintype.ofInjective _ <| kerLift_injective g) <|\n      Fintype.ofInjective _ <| inclusion_injective h)\n    groupEquivQuotientProdSubgroup.symm", "start": [710, 1], "end": [716, 40], "kind": "commanddeclaration"}, {"full_name": "Group.fintypeOfKerEqRange", "code": "@[to_additive \"If `F` and `H` are finite such that `ker(G \u2192+ H) = im(F \u2192+ G)`, then `G` is finite.\"]\nnoncomputable def fintypeOfKerEqRange (h : g.ker = f.range) : Fintype G :=\n  fintypeOfKerLeRange _ _ h.le", "start": [720, 1], "end": [723, 31], "kind": "commanddeclaration"}, {"full_name": "Group.fintypeOfKerOfCodom", "code": "@[to_additive \"If `ker(G \u2192+ H)` and `H` are finite, then `G` is finite.\"]\nnoncomputable def fintypeOfKerOfCodom [Fintype g.ker] : Fintype G :=\n  fintypeOfKerLeRange ((topEquiv : _ \u2243* G).toMonoidHom.comp <| inclusion le_top) g fun x hx =>\n    \u27e8\u27e8x, hx\u27e9, rfl\u27e9", "start": [727, 1], "end": [731, 19], "kind": "commanddeclaration"}, {"full_name": "Group.fintypeOfDomOfCoker", "code": "@[to_additive \"If `F` and `coker(F \u2192+ G)` are finite, then `G` is finite.\"]\nnoncomputable def fintypeOfDomOfCoker [Normal f.range] [Fintype <| G \u29f8 f.range] : Fintype G :=\n  fintypeOfKerLeRange _ (mk' f.range) fun x => (eq_one_iff x).mp", "start": [735, 1], "end": [738, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith/Frontend.lean", "imports": ["Mathlib/Control/Basic.lean", "Mathlib/Tactic/Linarith/Preprocessing.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/HashMap.lean", "Mathlib/Tactic/Linarith/Verification.lean"], "premises": [{"full_name": "Linarith.getContrLemma", "code": "def getContrLemma (e : Expr) : Option (Name \u00d7 Expr) :=\n  match e.getAppFnArgs with\n  | (``LT.lt, #[t, _, _, _]) => (``lt_of_not_ge, t)\n  | (``LE.le, #[t, _, _, _]) => (``le_of_not_gt, t)\n  | (``Eq, #[t, _, _]) => (``eq_of_not_lt_of_not_gt, t)\n  | (``Ne, #[t, _, _]) => (``Not.intro, t)\n  | (``GE.ge, #[t, _, _, _]) => (``le_of_not_gt, t)\n  | (``GT.gt, #[t, _, _, _]) => (``lt_of_not_ge, t)\n  | (``Not, #[e']) => match e'.getAppFnArgs with\n    | (``LT.lt, #[t, _, _, _]) => (``Not.intro, t)\n    | (``LE.le, #[t, _, _, _]) => (``Not.intro, t)\n    | (``Eq, #[t, _, _]) => (``Not.intro, t)\n    | (``GE.ge, #[t, _, _, _]) => (``Not.intro, t)\n    | (``GT.gt, #[t, _, _, _]) => (``Not.intro, t)\n    | _ => none\n  | _ => none", "start": [130, 1], "end": [152, 14], "kind": "commanddeclaration"}, {"full_name": "Linarith.applyContrLemma", "code": "def applyContrLemma (g : MVarId) : MetaM (Option (Expr \u00d7 Expr) \u00d7 MVarId) := do\n  match getContrLemma (\u2190 withReducible g.getType') with\n  | some (nm, tp) => do\n      let [g] \u2190 g.apply (\u2190 mkConst' nm) | failure\n      let (f, g) \u2190 g.intro1P\n      return (some (tp, .fvar f), g)\n  | none => return (none, g)", "start": [154, 1], "end": [168, 29], "kind": "commanddeclaration"}, {"full_name": "Linarith.ExprMultiMap", "code": "abbrev ExprMultiMap \u03b1 := Array (Expr \u00d7 List \u03b1)", "start": [170, 1], "end": [172, 47], "kind": "commanddeclaration"}, {"full_name": "Linarith.ExprMultiMap.find", "code": "def ExprMultiMap.find (self : ExprMultiMap \u03b1) (k : Expr) : MetaM (Nat \u00d7 List \u03b1) := do\n  for h : i in [:self.size] do\n    let (k', vs) := self[i]'h.2\n    if \u2190 isDefEq k' k then\n      return (i, vs)\n  return (self.size, [])", "start": [174, 1], "end": [181, 25], "kind": "commanddeclaration"}, {"full_name": "Linarith.ExprMultiMap.insert", "code": "def ExprMultiMap.insert (self : ExprMultiMap \u03b1) (k : Expr) (v : \u03b1) : MetaM (ExprMultiMap \u03b1) := do\n  for h : i in [:self.size] do\n    if \u2190 isDefEq (self[i]'h.2).1 k then\n      return self.modify i fun (k, vs) => (k, v::vs)\n  return self.push (k, [v])", "start": [183, 1], "end": [189, 28], "kind": "commanddeclaration"}, {"full_name": "Linarith.partitionByType", "code": "def partitionByType (l : List Expr) : MetaM (ExprMultiMap Expr) :=\n  l.foldlM (fun m h => do m.insert (\u2190 typeOfIneqProof h) h) #[]", "start": [191, 1], "end": [197, 64], "kind": "commanddeclaration"}, {"full_name": "Linarith.findLinarithContradiction", "code": "def findLinarithContradiction (cfg : LinarithConfig) (g : MVarId) (ls : List (List Expr)) :\n    MetaM Expr :=\n  try\n    ls.firstM (fun L => proveFalseByLinarith cfg g L)\n  catch e => throwError \"linarith failed to find a contradiction\\n{g}\\n{e.toMessageData}\"", "start": [199, 1], "end": [208, 90], "kind": "commanddeclaration"}, {"full_name": "Linarith.runLinarith", "code": "def runLinarith (cfg : LinarithConfig) (prefType : Option Expr) (g : MVarId)\n    (hyps : List Expr) : MetaM Unit := do\n  let singleProcess (g : MVarId) (hyps : List Expr) : MetaM Expr := do\n    linarithTraceProofs s!\"after preprocessing, linarith has {hyps.length} facts:\" hyps\n    let hyp_set \u2190 partitionByType hyps\n    trace[linarith] \"hypotheses appear in {hyp_set.size} different types\"\n      if let some t := prefType then\n        let (i, vs) \u2190 hyp_set.find t\n        proveFalseByLinarith cfg g vs <|>\n        findLinarithContradiction cfg g ((hyp_set.eraseIdx i).toList.map (\u00b7.2))\n      else findLinarithContradiction cfg g (hyp_set.toList.map (\u00b7.2))\n  let preprocessors :=\n    (if cfg.splitHypotheses then [Linarith.splitConjunctions.globalize.branching] else []) ++\n    cfg.preprocessors.getD defaultPreprocessors\n  let preprocessors := if cfg.splitNe then Linarith.removeNe::preprocessors else preprocessors\n  let branches \u2190 preprocess preprocessors g hyps\n  for (g, es) in branches do\n    let r \u2190 singleProcess g es\n    g.assign r\n  (Expr.mvar g).ensureHasNoMVars", "start": [211, 1], "end": [242, 33], "kind": "commanddeclaration"}, {"full_name": "Linarith.linarith", "code": "partial def linarith (only_on : Bool) (hyps : List Expr) (cfg : LinarithConfig := {})\n    (g : MVarId) : MetaM Unit := do\n  if (\u2190 whnfR (\u2190 instantiateMVars (\u2190 g.getType))).isEq then\n    trace[linarith] \"target is an equality: splitting\"\n    if let some [g\u2081, g\u2082] \u2190 try? (g.apply (\u2190 mkConst' ``eq_of_not_lt_of_not_gt)) then\n      linarith only_on hyps cfg g\u2081\n      linarith only_on hyps cfg g\u2082\n      return\n\n  \n\n  let (g, target_type, new_var) \u2190 match \u2190 applyContrLemma g with\n  | (none, g) =>\n    if cfg.exfalso then\n      trace[linarith] \"using exfalso\"\n      pure (\u2190 g.exfalso, none, none)\n    else\n      pure (g, none, none)\n  | (some (t, v), g) => pure (g, some t, some v)\n\n  g.withContext do\n  let hyps \u2190 (if only_on then return new_var.toList ++ hyps\n      else return (\u2190 getLocalHyps).toList ++ hyps)\n\n    linarithTraceProofs \"linarith is running on the following hypotheses:\" hyps\n    runLinarith cfg target_type g hyps", "start": [255, 1], "end": [302, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Multiset/NatAntidiagonal.lean", "imports": ["Mathlib/Data/List/NatAntidiagonal.lean", "Mathlib/Data/Multiset/Nodup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.Nat.antidiagonal", "code": "def antidiagonal (n : \u2115) : Multiset (\u2115 \u00d7 \u2115) :=\n  List.Nat.antidiagonal n", "start": [28, 1], "end": [31, 26], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.mem_antidiagonal", "code": "@[simp]\ntheorem mem_antidiagonal {n : \u2115} {x : \u2115 \u00d7 \u2115} : x \u2208 antidiagonal n \u2194 x.1 + x.2 = n", "start": [34, 1], "end": [37, 56], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.card_antidiagonal", "code": "@[simp]\ntheorem card_antidiagonal (n : \u2115) : card (antidiagonal n) = n + 1", "start": [40, 1], "end": [43, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonal_zero", "code": "@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = {(0, 0)}", "start": [46, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.nodup_antidiagonal", "code": "@[simp]\ntheorem nodup_antidiagonal (n : \u2115) : Nodup (antidiagonal n)", "start": [52, 1], "end": [55, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonal_succ", "code": "@[simp]\ntheorem antidiagonal_succ {n : \u2115} :\n    antidiagonal (n + 1) = (0, n + 1) ::\u2098 (antidiagonal n).map (Prod.map Nat.succ id)", "start": [58, 1], "end": [61, 74], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonal_succ'", "code": "theorem antidiagonal_succ' {n : \u2115} :\n    antidiagonal (n + 1) = (n + 1, 0) ::\u2098 (antidiagonal n).map (Prod.map id Nat.succ)", "start": [64, 1], "end": [67, 46], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.antidiagonal_succ_succ'", "code": "theorem antidiagonal_succ_succ' {n : \u2115} :\n    antidiagonal (n + 2) =\n      (0, n + 2) ::\u2098 (n + 2, 0) ::\u2098 (antidiagonal n).map (Prod.map Nat.succ Nat.succ)", "start": [70, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.Nat.map_swap_antidiagonal", "code": "theorem map_swap_antidiagonal {n : \u2115} : (antidiagonal n).map Prod.swap = antidiagonal n", "start": [77, 1], "end": [78, 74], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Order/Lemmas.lean", "imports": ["Mathlib/Algebra/Order/Ring/Abs.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Algebra/GroupWithZero/Divisibility.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.natAbs_eq_iff_mul_self_eq", "code": "theorem natAbs_eq_iff_mul_self_eq {a b : \u2124} : a.natAbs = b.natAbs \u2194 a * a = b * b", "start": [29, 1], "end": [31, 30], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_lt_iff_mul_self_lt", "code": "theorem natAbs_lt_iff_mul_self_lt {a b : \u2124} : a.natAbs < b.natAbs \u2194 a * a < b * b", "start": [36, 1], "end": [38, 26], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_le_iff_mul_self_le", "code": "theorem natAbs_le_iff_mul_self_le {a b : \u2124} : a.natAbs \u2264 b.natAbs \u2194 a * a \u2264 b * b", "start": [41, 1], "end": [43, 26], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_div_of_mul_dvd", "code": "theorem dvd_div_of_mul_dvd {a b c : \u2124} (h : a * b \u2223 c) : b \u2223 c / a", "start": [46, 1], "end": [51, 48], "kind": "commanddeclaration"}, {"full_name": "Int.eq_zero_of_abs_lt_dvd", "code": "theorem eq_zero_of_abs_lt_dvd {m x : \u2124} (h1 : m \u2223 x) (h2 : |x| < m) : x = 0", "start": [57, 1], "end": [64, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Bitwise.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Init/Data/Int/Bitwise.lean", "Mathlib/Data/Nat/Bitwise.lean", "Mathlib/Data/Nat/Size.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Pow.lean"], "premises": [{"full_name": "Int.bodd_zero", "code": "@[simp]\ntheorem bodd_zero : bodd 0 = false", "start": [27, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_one", "code": "@[simp]\ntheorem bodd_one : bodd 1 = true", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_two", "code": "theorem bodd_two : bodd 2 = false", "start": [37, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_coe", "code": "@[simp, norm_cast]\ntheorem bodd_coe (n : \u2115) : Int.bodd n = Nat.bodd n", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_subNatNat", "code": "@[simp]\ntheorem bodd_subNatNat (m n : \u2115) : bodd (subNatNat m n) = xor m.bodd n.bodd", "start": [46, 1], "end": [51, 28], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_negOfNat", "code": "@[simp]\ntheorem bodd_negOfNat (n : \u2115) : bodd (negOfNat n) = n.bodd", "start": [54, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_neg", "code": "@[simp]\ntheorem bodd_neg (n : \u2124) : bodd (-n) = bodd n", "start": [60, 1], "end": [69, 18], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_add", "code": "@[simp]\ntheorem bodd_add (m n : \u2124) : bodd (m + n) = xor (bodd m) (bodd n)", "start": [74, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_mul", "code": "@[simp]\ntheorem bodd_mul (m n : \u2124) : bodd (m * n) = (bodd m && bodd n)", "start": [87, 1], "end": [92, 61], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_add_div2", "code": "theorem bodd_add_div2 : \u2200 n, cond (bodd n) 1 0 + 2 * div2 n = n", "start": [98, 1], "end": [108, 10], "kind": "commanddeclaration"}, {"full_name": "Int.div2_val", "code": "theorem div2_val : \u2200 n, div2 n = n / 2", "start": [111, 1], "end": [113, 43], "kind": "commanddeclaration"}, {"full_name": "Int.bit0_val", "code": "@[deprecated]\ntheorem bit0_val (n : \u2124) : bit0 n = 2 * n", "start": [120, 1], "end": [122, 19], "kind": "commanddeclaration"}, {"full_name": "Int.bit1_val", "code": "@[deprecated]\ntheorem bit1_val (n : \u2124) : bit1 n = 2 * n + 1", "start": [125, 1], "end": [127, 39], "kind": "commanddeclaration"}, {"full_name": "Int.bit_val", "code": "theorem bit_val (b n) : bit b n = 2 * n + cond b 1 0", "start": [130, 1], "end": [133, 17], "kind": "commanddeclaration"}, {"full_name": "Int.bit_decomp", "code": "theorem bit_decomp (n : \u2124) : bit (bodd n) (div2 n) = n", "start": [136, 1], "end": [137, 65], "kind": "commanddeclaration"}, {"full_name": "Int.bitCasesOn", "code": "def bitCasesOn.{u} {C : \u2124 \u2192 Sort u} (n) (h : \u2200 b n, C (bit b n)) : C n := by\n  rw [\u2190 bit_decomp n]\n  apply h", "start": [140, 1], "end": [144, 10], "kind": "commanddeclaration"}, {"full_name": "Int.bit_zero", "code": "@[simp]\ntheorem bit_zero : bit false 0 = 0", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Int.bit_coe_nat", "code": "@[simp]\ntheorem bit_coe_nat (b) (n : \u2115) : bit b n = Nat.bit b n", "start": [152, 1], "end": [155, 18], "kind": "commanddeclaration"}, {"full_name": "Int.bit_negSucc", "code": "@[simp]\ntheorem bit_negSucc (b) (n : \u2115) : bit b -[n+1] = -[Nat.bit (not b) n+1]", "start": [158, 1], "end": [161, 18], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_bit", "code": "@[simp]\ntheorem bodd_bit (b n) : bodd (bit b n) = b", "start": [164, 1], "end": [167, 36], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_bit0", "code": "@[simp, deprecated]\ntheorem bodd_bit0 (n : \u2124) : bodd (bit0 n) = false", "start": [170, 1], "end": [172, 19], "kind": "commanddeclaration"}, {"full_name": "Int.bodd_bit1", "code": "@[simp, deprecated]\ntheorem bodd_bit1 (n : \u2124) : bodd (bit1 n) = true", "start": [175, 1], "end": [177, 18], "kind": "commanddeclaration"}, {"full_name": "Int.bit0_ne_bit1", "code": "@[deprecated]\ntheorem bit0_ne_bit1 (m n : \u2124) : bit0 m \u2260 bit1 n", "start": [180, 1], "end": [182, 33], "kind": "commanddeclaration"}, {"full_name": "Int.bit1_ne_bit0", "code": "@[deprecated]\ntheorem bit1_ne_bit0 (m n : \u2124) : bit1 m \u2260 bit0 n", "start": [185, 1], "end": [187, 26], "kind": "commanddeclaration"}, {"full_name": "Int.bit1_ne_zero", "code": "@[deprecated]\ntheorem bit1_ne_zero (m : \u2124) : bit1 m \u2260 0", "start": [190, 1], "end": [191, 94], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_zero", "code": "@[simp]\ntheorem testBit_zero (b) : \u2200 n, testBit (bit b n) 0 = b", "start": [196, 1], "end": [202, 10], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_succ", "code": "@[simp]\ntheorem testBit_succ (m b) : \u2200 n, testBit (bit b n) (Nat.succ m) = testBit n m", "start": [205, 1], "end": [211, 76], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise_or", "code": "theorem bitwise_or : bitwise or = lor", "start": [221, 1], "end": [235, 32], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise_and", "code": "theorem bitwise_and : bitwise and = land", "start": [239, 1], "end": [251, 32], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise_diff", "code": "theorem bitwise_diff : (bitwise fun a b => a && not b) = ldiff", "start": [255, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise_xor", "code": "theorem bitwise_xor : bitwise xor = Int.xor", "start": [274, 1], "end": [289, 32], "kind": "commanddeclaration"}, {"full_name": "Int.bitwise_bit", "code": "@[simp]\ntheorem bitwise_bit (f : Bool \u2192 Bool \u2192 Bool) (a m b n) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n)", "start": [292, 1], "end": [301, 42], "kind": "commanddeclaration"}, {"full_name": "Int.lor_bit", "code": "@[simp]\ntheorem lor_bit (a m b n) : lor (bit a m) (bit b n) = bit (a || b) (lor m n)", "start": [304, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "Int.land_bit", "code": "@[simp]\ntheorem land_bit (a m b n) : land (bit a m) (bit b n) = bit (a && b) (land m n)", "start": [309, 1], "end": [311, 34], "kind": "commanddeclaration"}, {"full_name": "Int.ldiff_bit", "code": "@[simp]\ntheorem ldiff_bit (a m b n) : ldiff (bit a m) (bit b n) = bit (a && not b) (ldiff m n)", "start": [314, 1], "end": [316, 35], "kind": "commanddeclaration"}, {"full_name": "Int.lxor_bit", "code": "@[simp]\ntheorem lxor_bit (a m b n) : Int.xor (bit a m) (bit b n) = bit (xor a b) (Int.xor m n)", "start": [319, 1], "end": [321, 34], "kind": "commanddeclaration"}, {"full_name": "Int.lnot_bit", "code": "@[simp]\ntheorem lnot_bit (b) : \u2200 n, lnot (bit b n) = bit (not b) (lnot n)", "start": [324, 1], "end": [327, 29], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_bitwise", "code": "@[simp]\ntheorem testBit_bitwise (f : Bool \u2192 Bool \u2192 Bool) (m n k) :\n    testBit (bitwise f m n) k = f (testBit m k) (testBit n k)", "start": [330, 1], "end": [337, 42], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_lor", "code": "@[simp]\ntheorem testBit_lor (m n k) : testBit (lor m n) k = (testBit m k || testBit n k)", "start": [340, 1], "end": [342, 37], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_land", "code": "@[simp]\ntheorem testBit_land (m n k) : testBit (land m n) k = (testBit m k && testBit n k)", "start": [345, 1], "end": [347, 38], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_ldiff", "code": "@[simp]\ntheorem testBit_ldiff (m n k) : testBit (ldiff m n) k = (testBit m k && not (testBit n k))", "start": [350, 1], "end": [352, 39], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_lxor", "code": "@[simp]\ntheorem testBit_lxor (m n k) : testBit (Int.xor m n) k = xor (testBit m k) (testBit n k)", "start": [355, 1], "end": [357, 38], "kind": "commanddeclaration"}, {"full_name": "Int.testBit_lnot", "code": "@[simp]\ntheorem testBit_lnot : \u2200 n k, testBit (lnot n) k = not (testBit n k)", "start": [360, 1], "end": [363, 41], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_neg", "code": "@[simp]\ntheorem shiftLeft_neg (m n : \u2124) : m <<< (-n) = m >>> n", "start": [366, 1], "end": [368, 6], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight_neg", "code": "@[simp]\ntheorem shiftRight_neg (m n : \u2124) : m >>> (-n) = m <<< n", "start": [371, 1], "end": [372, 92], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_coe_nat", "code": "@[simp]\ntheorem shiftLeft_coe_nat (m n : \u2115) : (m : \u2124) <<< (n : \u2124) = \u2191(m <<< n)", "start": [376, 1], "end": [378, 52], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight_coe_nat", "code": "@[simp]\ntheorem shiftRight_coe_nat (m n : \u2115) : (m : \u2124) >>> (n : \u2124) = m >>> n", "start": [382, 1], "end": [383, 91], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_negSucc", "code": "@[simp]\ntheorem shiftLeft_negSucc (m n : \u2115) : -[m+1] <<< (n : \u2124) = -[Nat.shiftLeft' true m n+1]", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight_negSucc", "code": "@[simp]\ntheorem shiftRight_negSucc (m n : \u2115) : -[m+1] >>> (n : \u2124) = -[m >>> n+1]", "start": [391, 1], "end": [392, 95], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight_add", "code": "theorem shiftRight_add : \u2200 (m : \u2124) (n k : \u2115), m >>> (n + k : \u2124) = (m >>> (n : \u2124)) >>> (k : \u2124)", "start": [395, 1], "end": [401, 26], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_add", "code": "theorem shiftLeft_add : \u2200 (m : \u2124) (n : \u2115) (k : \u2124), m <<< (n + k) = (m <<< (n : \u2124)) <<< k", "start": [408, 1], "end": [428, 14], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_sub", "code": "theorem shiftLeft_sub (m : \u2124) (n : \u2115) (k : \u2124) : m <<< (n - k) = (m <<< (n : \u2124)) >>> k", "start": [431, 1], "end": [432, 22], "kind": "commanddeclaration"}, {"full_name": "Int.shiftLeft_eq_mul_pow", "code": "theorem shiftLeft_eq_mul_pow : \u2200 (m : \u2124) (n : \u2115), m <<< (n : \u2124) = m * \u2191(2 ^ n)", "start": [435, 1], "end": [437, 85], "kind": "commanddeclaration"}, {"full_name": "Int.shiftRight_eq_div_pow", "code": "theorem shiftRight_eq_div_pow : \u2200 (m : \u2124) (n : \u2115), m >>> (n : \u2124) = m / \u2191(2 ^ n)", "start": [440, 1], "end": [444, 55], "kind": "commanddeclaration"}, {"full_name": "Int.one_shiftLeft", "code": "theorem one_shiftLeft (n : \u2115) : 1 <<< (n : \u2124) = (2 ^ n : \u2115)", "start": [447, 1], "end": [448, 36], "kind": "commanddeclaration"}, {"full_name": "Int.zero_shiftLeft", "code": "@[simp]\ntheorem zero_shiftLeft : \u2200 n : \u2124, 0 <<< n = 0", "start": [451, 1], "end": [454, 48], "kind": "commanddeclaration"}, {"full_name": "Int.zero_shiftRight", "code": "@[simp]\ntheorem zero_shiftRight (n : \u2124) : 0 >>> n = 0", "start": [457, 1], "end": [459, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GroupWithZero/Power.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Util/AssertExists.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "pow_sub\u2080", "code": "theorem pow_sub\u2080 (a : G\u2080) {m n : \u2115} (ha : a \u2260 0) (h : n \u2264 m) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9", "start": [25, 1], "end": [28, 75], "kind": "commanddeclaration"}, {"full_name": "pow_sub_of_lt", "code": "theorem pow_sub_of_lt (a : G\u2080) {m n : \u2115} (h : n < m) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9", "start": [31, 1], "end": [34, 29], "kind": "commanddeclaration"}, {"full_name": "pow_inv_comm\u2080", "code": "theorem pow_inv_comm\u2080 (a : G\u2080) (m n : \u2115) : a\u207b\u00b9 ^ m * a ^ n = a ^ n * a\u207b\u00b9 ^ m", "start": [37, 1], "end": [38, 41], "kind": "commanddeclaration"}, {"full_name": "inv_pow_sub\u2080", "code": "theorem inv_pow_sub\u2080 (ha : a \u2260 0) (h : n \u2264 m) : a\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n", "start": [41, 1], "end": [42, 64], "kind": "commanddeclaration"}, {"full_name": "inv_pow_sub_of_lt", "code": "theorem inv_pow_sub_of_lt (a : G\u2080) (h : n < m) : a\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n", "start": [45, 1], "end": [46, 54], "kind": "commanddeclaration"}, {"full_name": "zero_zpow", "code": "theorem zero_zpow : \u2200 z : \u2124, z \u2260 0 \u2192 (0 : G\u2080) ^ z = 0", "start": [61, 1], "end": [65, 25], "kind": "commanddeclaration"}, {"full_name": "zero_zpow_eq", "code": "theorem zero_zpow_eq (n : \u2124) : (0 : G\u2080) ^ n = if n = 0 then 1 else 0", "start": [68, 1], "end": [71, 23], "kind": "commanddeclaration"}, {"full_name": "zpow_add_one\u2080", "code": "theorem zpow_add_one\u2080 {a : G\u2080} (ha : a \u2260 0) : \u2200 n : \u2124, a ^ (n + 1) = a ^ n * a", "start": [74, 1], "end": [80, 15], "kind": "commanddeclaration"}, {"full_name": "zpow_sub_one\u2080", "code": "theorem zpow_sub_one\u2080 {a : G\u2080} (ha : a \u2260 0) (n : \u2124) : a ^ (n - 1) = a ^ n * a\u207b\u00b9", "start": [83, 1], "end": [86, 66], "kind": "commanddeclaration"}, {"full_name": "zpow_add\u2080", "code": "theorem zpow_add\u2080 {a : G\u2080} (ha : a \u2260 0) (m n : \u2124) : a ^ (m + n) = a ^ m * a ^ n", "start": [89, 1], "end": [93, 81], "kind": "commanddeclaration"}, {"full_name": "zpow_add'", "code": "theorem zpow_add' {a : G\u2080} {m n : \u2124} (h : a \u2260 0 \u2228 m + n \u2260 0 \u2228 m = 0 \u2227 n = 0) :\n    a ^ (m + n) = a ^ m * a ^ n", "start": [96, 1], "end": [107, 27], "kind": "commanddeclaration"}, {"full_name": "zpow_one_add\u2080", "code": "theorem zpow_one_add\u2080 {a : G\u2080} (h : a \u2260 0) (i : \u2124) : a ^ (1 + i) = a * a ^ i", "start": [110, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "SemiconjBy.zpow_right\u2080", "code": "theorem SemiconjBy.zpow_right\u2080 {a x y : G\u2080} (h : SemiconjBy a x y) :\n    \u2200 m : \u2124, SemiconjBy a (x ^ m) (y ^ m)", "start": [114, 1], "end": [117, 76], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_right\u2080", "code": "theorem Commute.zpow_right\u2080 {a b : G\u2080} (h : Commute a b) : \u2200 m : \u2124, Commute a (b ^ m)", "start": [120, 1], "end": [121, 27], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_left\u2080", "code": "theorem Commute.zpow_left\u2080 {a b : G\u2080} (h : Commute a b) (m : \u2124) : Commute (a ^ m) b", "start": [124, 1], "end": [125, 30], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_zpow\u2080", "code": "theorem Commute.zpow_zpow\u2080 {a b : G\u2080} (h : Commute a b) (m n : \u2124) : Commute (a ^ m) (b ^ n)", "start": [128, 1], "end": [129, 33], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_self\u2080", "code": "theorem Commute.zpow_self\u2080 (a : G\u2080) (n : \u2124) : Commute (a ^ n) a", "start": [132, 1], "end": [133, 32], "kind": "commanddeclaration"}, {"full_name": "Commute.self_zpow\u2080", "code": "theorem Commute.self_zpow\u2080 (a : G\u2080) (n : \u2124) : Commute a (a ^ n)", "start": [136, 1], "end": [137, 33], "kind": "commanddeclaration"}, {"full_name": "Commute.zpow_zpow_self\u2080", "code": "theorem Commute.zpow_zpow_self\u2080 (a : G\u2080) (m n : \u2124) : Commute (a ^ m) (a ^ n)", "start": [140, 1], "end": [141, 34], "kind": "commanddeclaration"}, {"full_name": "zpow_ne_zero_of_ne_zero", "code": "theorem zpow_ne_zero_of_ne_zero {a : G\u2080} (ha : a \u2260 0) : \u2200 z : \u2124, a ^ z \u2260 0", "start": [144, 1], "end": [150, 41], "kind": "commanddeclaration"}, {"full_name": "zpow_sub\u2080", "code": "theorem zpow_sub\u2080 {a : G\u2080} (ha : a \u2260 0) (z1 z2 : \u2124) : a ^ (z1 - z2) = a ^ z1 / a ^ z2", "start": [153, 1], "end": [154, 62], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_zero", "code": "theorem zpow_eq_zero {x : G\u2080} {n : \u2124} (h : x ^ n = 0) : x = 0", "start": [157, 1], "end": [158, 60], "kind": "commanddeclaration"}, {"full_name": "zpow_eq_zero_iff", "code": "theorem zpow_eq_zero_iff {a : G\u2080} {n : \u2124} (hn : n \u2260 0) : a ^ n = 0 \u2194 a = 0", "start": [161, 1], "end": [162, 53], "kind": "commanddeclaration"}, {"full_name": "zpow_ne_zero", "code": "theorem zpow_ne_zero {x : G\u2080} (n : \u2124) : x \u2260 0 \u2192 x ^ n \u2260 0", "start": [165, 1], "end": [166, 18], "kind": "commanddeclaration"}, {"full_name": "zpow_neg_mul_zpow_self", "code": "theorem zpow_neg_mul_zpow_self (n : \u2124) {x : G\u2080} (h : x \u2260 0) : x ^ (-n) * x ^ n = 1", "start": [169, 1], "end": [171, 42], "kind": "commanddeclaration"}, {"full_name": "div_sq_cancel", "code": "theorem div_sq_cancel (a b : G\u2080) : a ^ 2 * b / a = a * b", "start": [180, 1], "end": [183, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/GCD.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Order/Bounds/Basic.lean", "Mathlib/Data/Int/Dvd/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Regular.lean", "Mathlib/Data/Nat/GCD/Basic.lean"], "premises": [{"full_name": "Nat.xgcdAux", "code": "def xgcdAux : \u2115 \u2192 \u2124 \u2192 \u2124 \u2192 \u2115 \u2192 \u2124 \u2192 \u2124 \u2192 \u2115 \u00d7 \u2124 \u00d7 \u2124\n  | 0, _, _, r', s', t' => (r', s', t')\n  | succ k, s, t, r', s', t' =>\n    have : r' % succ k < succ k := mod_lt _ <| (succ_pos _).gt\n    let q := r' / succ k\n    xgcdAux (r' % succ k) (s' - q * s) (t' - q * t) (succ k) s t", "start": [40, 1], "end": [46, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_zero", "code": "theorem xgcdAux_zero : xgcdAux 0 s t r' s' t' = (r', s', t')", "start": [51, 1], "end": [51, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_succ", "code": "theorem xgcdAux_succ : xgcdAux (succ k) s t r' s' t' =\n    xgcdAux (r' % succ k) (s' - (r' / succ k) * s) (t' - (r' / succ k) * t) (succ k) s t", "start": [53, 1], "end": [54, 96], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcd_zero_left", "code": "@[simp]\ntheorem xgcd_zero_left {s t r' s' t'} : xgcdAux 0 s t r' s' t' = (r', s', t')", "start": [56, 1], "end": [57, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_rec", "code": "theorem xgcdAux_rec {r s t r' s' t'} (h : 0 < r) :\n    xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t", "start": [60, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcd", "code": "def xgcd (x y : \u2115) : \u2124 \u00d7 \u2124 :=\n  (xgcdAux x 1 0 y 0 1).2", "start": [66, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdA", "code": "def gcdA (x y : \u2115) : \u2124 :=\n  (xgcd x y).1", "start": [72, 1], "end": [74, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdB", "code": "def gcdB (x y : \u2115) : \u2124 :=\n  (xgcd x y).2", "start": [77, 1], "end": [79, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdA_zero_left", "code": "@[simp]\ntheorem gcdA_zero_left {s : \u2115} : gcdA 0 s = 0", "start": [82, 1], "end": [85, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdB_zero_left", "code": "@[simp]\ntheorem gcdB_zero_left {s : \u2115} : gcdB 0 s = 1", "start": [88, 1], "end": [91, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdA_zero_right", "code": "@[simp]\ntheorem gcdA_zero_right {s : \u2115} (h : s \u2260 0) : gcdA s 0 = 1", "start": [94, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.gcdB_zero_right", "code": "@[simp]\ntheorem gcdB_zero_right {s : \u2115} (h : s \u2260 0) : gcdB s 0 = 0", "start": [104, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_fst", "code": "@[simp]\ntheorem xgcdAux_fst (x y) : \u2200 s t s' t', (xgcdAux x s t y s' t').1 = gcd x y", "start": [114, 1], "end": [118, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_val", "code": "theorem xgcdAux_val (x y) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)", "start": [121, 1], "end": [122, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcd_val", "code": "theorem xgcd_val (x y) : xgcd x y = (gcdA x y, gcdB x y)", "start": [125, 1], "end": [126, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.P", "code": "private def P : \u2115 \u00d7 \u2124 \u00d7 \u2124 \u2192 Prop\n  | (r, s, t) => (r : \u2124) = x * s + y * t", "start": [133, 1], "end": [134, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.xgcdAux_P", "code": "theorem xgcdAux_P {r r'} :\n    \u2200 {s t s' t'}, P x y (r, s, t) \u2192 P x y (r', s', t') \u2192 P x y (xgcdAux r s t r' s' t')", "start": [136, 1], "end": [145, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.gcd_eq_gcd_ab", "code": "theorem gcd_eq_gcd_ab : (gcd x y : \u2124) = x * gcdA x y + y * gcdB x y", "start": [149, 1], "end": [154, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_mul_emod_eq_gcd", "code": "theorem exists_mul_emod_eq_gcd {k n : \u2115} (hk : gcd n k < k) : \u2203 m, n * m % k = gcd n k", "start": [159, 1], "end": [167, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_mul_emod_eq_one_of_coprime", "code": "theorem exists_mul_emod_eq_one_of_coprime {k n : \u2115} (hkn : Coprime n k) (hk : 1 < k) :\n    \u2203 m, n * m % k = 1", "start": [170, 1], "end": [173, 22], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_def", "code": "theorem gcd_def (i j : \u2124) : gcd i j = Nat.gcd i.natAbs j.natAbs", "start": [183, 1], "end": [183, 71], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_gcd", "code": "protected theorem coe_nat_gcd (m n : \u2115) : Int.gcd \u2191m \u2191n = Nat.gcd m n", "start": [185, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Int.gcdA", "code": "def gcdA : \u2124 \u2192 \u2124 \u2192 \u2124\n  | ofNat m, n => m.gcdA n.natAbs\n  | -[m+1], n => -m.succ.gcdA n.natAbs", "start": [189, 1], "end": [192, 39], "kind": "commanddeclaration"}, {"full_name": "Int.gcdB", "code": "def gcdB : \u2124 \u2192 \u2124 \u2192 \u2124\n  | m, ofNat n => m.natAbs.gcdB n\n  | m, -[n+1] => -m.natAbs.gcdB n.succ", "start": [195, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_gcd_ab", "code": "theorem gcd_eq_gcd_ab : \u2200 x y : \u2124, (gcd x y : \u2124) = x * gcdA x y + y * gcdB x y", "start": [201, 1], "end": [211, 30], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_ediv", "code": "theorem natAbs_ediv (a b : \u2124) (H : b \u2223 a) : natAbs (a / b) = natAbs a / natAbs b", "start": [214, 1], "end": [223, 61], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_mul_dvd_mul_left", "code": "theorem dvd_of_mul_dvd_mul_left {i j k : \u2124} (k_non_zero : k \u2260 0) (H : k * i \u2223 k * j) : i \u2223 j", "start": [226, 1], "end": [227, 92], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_mul_dvd_mul_right", "code": "theorem dvd_of_mul_dvd_mul_right {i j k : \u2124} (k_non_zero : k \u2260 0) (H : i * k \u2223 j * k) : i \u2223 j", "start": [230, 1], "end": [231, 83], "kind": "commanddeclaration"}, {"full_name": "Int.lcm", "code": "def lcm (i j : \u2124) : \u2115 :=\n  Nat.lcm (natAbs i) (natAbs j)", "start": [234, 1], "end": [236, 32], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_def", "code": "theorem lcm_def (i j : \u2124) : lcm i j = Nat.lcm (natAbs i) (natAbs j)", "start": [239, 1], "end": [240, 6], "kind": "commanddeclaration"}, {"full_name": "Int.coe_nat_lcm", "code": "protected theorem coe_nat_lcm (m n : \u2115) : Int.lcm \u2191m \u2191n = Nat.lcm m n", "start": [243, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_left", "code": "theorem gcd_dvd_left (i j : \u2124) : (gcd i j : \u2124) \u2223 i", "start": [247, 1], "end": [248, 59], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_right", "code": "theorem gcd_dvd_right (i j : \u2124) : (gcd i j : \u2124) \u2223 j", "start": [251, 1], "end": [252, 60], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_gcd", "code": "theorem dvd_gcd {i j k : \u2124} (h1 : k \u2223 i) (h2 : k \u2223 j) : k \u2223 gcd i j", "start": [255, 1], "end": [257, 83], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_mul_lcm", "code": "theorem gcd_mul_lcm (i j : \u2124) : gcd i j * lcm i j = natAbs (i * j)", "start": [260, 1], "end": [261, 53], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_comm", "code": "theorem gcd_comm (i j : \u2124) : gcd i j = gcd j i", "start": [264, 1], "end": [265, 19], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_assoc", "code": "theorem gcd_assoc (i j k : \u2124) : gcd (gcd i j) k = gcd i (gcd j k)", "start": [268, 1], "end": [269, 22], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_self", "code": "@[simp]\ntheorem gcd_self (i : \u2124) : gcd i i = natAbs i", "start": [272, 1], "end": [273, 63], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_zero_left", "code": "@[simp]\ntheorem gcd_zero_left (i : \u2124) : gcd 0 i = natAbs i", "start": [276, 1], "end": [277, 68], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_zero_right", "code": "@[simp]\ntheorem gcd_zero_right (i : \u2124) : gcd i 0 = natAbs i", "start": [280, 1], "end": [281, 69], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_one_left", "code": "@[simp]\ntheorem gcd_one_left (i : \u2124) : gcd 1 i = 1", "start": [284, 1], "end": [286, 21], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_one_right", "code": "@[simp]\ntheorem gcd_one_right (i : \u2124) : gcd i 1 = 1", "start": [289, 1], "end": [291, 22], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_neg_right", "code": "@[simp]\ntheorem gcd_neg_right {x y : \u2124} : gcd x (-y) = gcd x y", "start": [294, 1], "end": [295, 95], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_neg_left", "code": "@[simp]\ntheorem gcd_neg_left {x y : \u2124} : gcd (-x) y = gcd x y", "start": [298, 1], "end": [299, 94], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_mul_left", "code": "theorem gcd_mul_left (i j k : \u2124) : gcd (i * j) (i * k) = natAbs i * gcd j k", "start": [302, 1], "end": [304, 25], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_mul_right", "code": "theorem gcd_mul_right (i j k : \u2124) : gcd (i * j) (k * j) = gcd i k * natAbs j", "start": [307, 1], "end": [309, 26], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_pos_of_ne_zero_left", "code": "theorem gcd_pos_of_ne_zero_left {i : \u2124} (j : \u2124) (hi : i \u2260 0) : 0 < gcd i j", "start": [312, 1], "end": [313, 46], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_pos_of_ne_zero_right", "code": "theorem gcd_pos_of_ne_zero_right (i : \u2124) {j : \u2124} (hj : j \u2260 0) : 0 < gcd i j", "start": [316, 1], "end": [317, 47], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_zero_iff", "code": "theorem gcd_eq_zero_iff {i j : \u2124} : gcd i j = 0 \u2194 i = 0 \u2227 j = 0", "start": [320, 1], "end": [321, 64], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_pos_iff", "code": "theorem gcd_pos_iff {i j : \u2124} : 0 < gcd i j \u2194 i \u2260 0 \u2228 j \u2260 0", "start": [324, 1], "end": [325, 64], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_div", "code": "theorem gcd_div {i j k : \u2124} (H1 : k \u2223 i) (H2 : k \u2223 j) :\n    gcd (i / k) (j / k) = gcd i j / natAbs k", "start": [328, 1], "end": [331, 74], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_div_gcd_div_gcd", "code": "theorem gcd_div_gcd_div_gcd {i j : \u2124} (H : 0 < gcd i j) : gcd (i / gcd i j) (j / gcd i j) = 1", "start": [334, 1], "end": [335, 84], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_of_dvd_left", "code": "theorem gcd_dvd_gcd_of_dvd_left {i k : \u2124} (j : \u2124) (H : i \u2223 k) : gcd i j \u2223 gcd k j", "start": [338, 1], "end": [339, 80], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_of_dvd_right", "code": "theorem gcd_dvd_gcd_of_dvd_right {i k : \u2124} (j : \u2124) (H : i \u2223 k) : gcd j i \u2223 gcd j k", "start": [342, 1], "end": [343, 80], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_mul_left", "code": "theorem gcd_dvd_gcd_mul_left (i j k : \u2124) : gcd i j \u2223 gcd (k * i) j", "start": [346, 1], "end": [347, 47], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_mul_right", "code": "theorem gcd_dvd_gcd_mul_right (i j k : \u2124) : gcd i j \u2223 gcd (i * k) j", "start": [350, 1], "end": [351, 48], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_mul_left_right", "code": "theorem gcd_dvd_gcd_mul_left_right (i j k : \u2124) : gcd i j \u2223 gcd i (k * j)", "start": [354, 1], "end": [355, 48], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_gcd_mul_right_right", "code": "theorem gcd_dvd_gcd_mul_right_right (i j k : \u2124) : gcd i j \u2223 gcd i (j * k)", "start": [358, 1], "end": [359, 49], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_left", "code": "theorem gcd_eq_left {i j : \u2124} (H : i \u2223 j) : gcd i j = natAbs i", "start": [362, 1], "end": [363, 90], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_eq_right", "code": "theorem gcd_eq_right {i j : \u2124} (H : j \u2223 i) : gcd i j = natAbs j", "start": [366, 1], "end": [366, 99], "kind": "commanddeclaration"}, {"full_name": "Int.ne_zero_of_gcd", "code": "theorem ne_zero_of_gcd {x y : \u2124} (hc : gcd x y \u2260 0) : x \u2260 0 \u2228 y \u2260 0", "start": [369, 1], "end": [371, 54], "kind": "commanddeclaration"}, {"full_name": "Int.exists_gcd_one", "code": "theorem exists_gcd_one {m n : \u2124} (H : 0 < gcd m n) :\n    \u2203 m' n' : \u2124, gcd m' n' = 1 \u2227 m = m' * gcd m n \u2227 n = n' * gcd m n", "start": [374, 1], "end": [377, 52], "kind": "commanddeclaration"}, {"full_name": "Int.exists_gcd_one'", "code": "theorem exists_gcd_one' {m n : \u2124} (H : 0 < gcd m n) :\n    \u2203 (g : \u2115) (m' n' : \u2124), 0 < g \u2227 gcd m' n' = 1 \u2227 m = m' * g \u2227 n = n' * g", "start": [380, 1], "end": [383, 20], "kind": "commanddeclaration"}, {"full_name": "Int.pow_dvd_pow_iff", "code": "theorem pow_dvd_pow_iff {m n : \u2124} {k : \u2115} (k0 : 0 < k) : m ^ k \u2223 n ^ k \u2194 m \u2223 n", "start": [386, 1], "end": [389, 23], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_dvd_iff", "code": "theorem gcd_dvd_iff {a b : \u2124} {n : \u2115} : gcd a b \u2223 n \u2194 \u2203 x y : \u2124, \u2191n = a * x + b * y", "start": [392, 1], "end": [400, 101], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_greatest", "code": "theorem gcd_greatest {a b d : \u2124} (hd_pos : 0 \u2264 d) (hda : d \u2223 a) (hdb : d \u2223 b)\n    (hd : \u2200 e : \u2124, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) : d = gcd a b", "start": [403, 1], "end": [406, 50], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_dvd_mul_left_of_gcd_one", "code": "theorem dvd_of_dvd_mul_left_of_gcd_one {a b c : \u2124} (habc : a \u2223 b * c) (hab : gcd a c = 1) :\n    a \u2223 b", "start": [409, 1], "end": [418, 88], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_of_dvd_mul_right_of_gcd_one", "code": "theorem dvd_of_dvd_mul_right_of_gcd_one {a b c : \u2124} (habc : a \u2223 b * c) (hab : gcd a b = 1) :\n    a \u2223 c", "start": [421, 1], "end": [427, 48], "kind": "commanddeclaration"}, {"full_name": "Int.gcd_least_linear", "code": "theorem gcd_least_linear {a b : \u2124} (ha : a \u2260 0) :\n    IsLeast { n : \u2115 | 0 < n \u2227 \u2203 x y : \u2124, \u2191n = a * x + b * y } (a.gcd b)", "start": [430, 1], "end": [438, 53], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_comm", "code": "theorem lcm_comm (i j : \u2124) : lcm i j = lcm j i", "start": [444, 1], "end": [446, 25], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_assoc", "code": "theorem lcm_assoc (i j k : \u2124) : lcm (lcm i j) k = lcm i (lcm j k)", "start": [449, 1], "end": [451, 22], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_zero_left", "code": "@[simp]\ntheorem lcm_zero_left (i : \u2124) : lcm 0 i = 0", "start": [454, 1], "end": [457, 26], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_zero_right", "code": "@[simp]\ntheorem lcm_zero_right (i : \u2124) : lcm i 0 = 0", "start": [460, 1], "end": [463, 27], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_one_left", "code": "@[simp]\ntheorem lcm_one_left (i : \u2124) : lcm 1 i = natAbs i", "start": [466, 1], "end": [469, 25], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_one_right", "code": "@[simp]\ntheorem lcm_one_right (i : \u2124) : lcm i 1 = natAbs i", "start": [472, 1], "end": [475, 26], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_self", "code": "@[simp]\ntheorem lcm_self (i : \u2124) : lcm i i = natAbs i", "start": [478, 1], "end": [481, 21], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_lcm_left", "code": "theorem dvd_lcm_left (i j : \u2124) : i \u2223 lcm i j", "start": [484, 1], "end": [487, 25], "kind": "commanddeclaration"}, {"full_name": "Int.dvd_lcm_right", "code": "theorem dvd_lcm_right (i j : \u2124) : j \u2223 lcm i j", "start": [490, 1], "end": [493, 26], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_dvd", "code": "theorem lcm_dvd {i j k : \u2124} : i \u2223 k \u2192 j \u2223 k \u2192 (lcm i j : \u2124) \u2223 k", "start": [496, 1], "end": [499, 97], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_mul_left", "code": "theorem lcm_mul_left {m n k : \u2124} : (m * n).lcm (m * k) = natAbs m * n.lcm k", "start": [502, 1], "end": [503, 50], "kind": "commanddeclaration"}, {"full_name": "Int.lcm_mul_right", "code": "theorem lcm_mul_right {m n k : \u2124} : (m * n).lcm (k * n) = m.lcm k * natAbs n", "start": [505, 1], "end": [506, 51], "kind": "commanddeclaration"}, {"full_name": "pow_gcd_eq_one", "code": "@[to_additive gcd_nsmul_eq_zero]\ntheorem pow_gcd_eq_one {M : Type*} [Monoid M] (x : M) {m n : \u2115} (hm : x ^ m = 1) (hn : x ^ n = 1) :\n    x ^ m.gcd n = 1", "start": [510, 1], "end": [517, 79], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Separation.lean", "imports": ["Mathlib/Topology/Compactness/SigmaCompact.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/Inseparable.lean", "Mathlib/Topology/Connected/LocallyConnected.lean", "Mathlib/Topology/Connected/TotallyDisconnected.lean"], "premises": [{"full_name": "SeparatedNhds", "code": "def SeparatedNhds : Set \u03b1 \u2192 Set \u03b1 \u2192 Prop := fun s t : Set \u03b1 =>\n  \u2203 U V : Set \u03b1, IsOpen U \u2227 IsOpen V \u2227 s \u2286 U \u2227 t \u2286 V \u2227 Disjoint U V", "start": [100, 1], "end": [105, 68], "kind": "commanddeclaration"}, {"full_name": "separatedNhds_iff_disjoint", "code": "theorem separatedNhds_iff_disjoint {s t : Set \u03b1} : SeparatedNhds s t \u2194 Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd\u02e2 t)", "start": [108, 1], "end": [110, 57], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.disjoint_nhdsSet", "code": "alias \u27e8SeparatedNhds.disjoint_nhdsSet, _\u27e9 := separatedNhds_iff_disjoint", "start": [113, 1], "end": [113, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "SeparatedNhds.symm", "code": "@[symm]\ntheorem symm : SeparatedNhds s t \u2192 SeparatedNhds t s", "start": [119, 1], "end": [121, 43], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.comm", "code": "theorem comm (s t : Set \u03b1) : SeparatedNhds s t \u2194 SeparatedNhds t s", "start": [124, 1], "end": [125, 15], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.preimage", "code": "theorem preimage [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s t : Set \u03b2} (h : SeparatedNhds s t)\n    (hf : Continuous f) : SeparatedNhds (f \u207b\u00b9' s) (f \u207b\u00b9' t)", "start": [128, 1], "end": [132, 19], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.disjoint", "code": "protected theorem disjoint (h : SeparatedNhds s t) : Disjoint s t", "start": [135, 1], "end": [136, 55], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.disjoint_closure_left", "code": "theorem disjoint_closure_left (h : SeparatedNhds s t) : Disjoint (closure s) t", "start": [139, 1], "end": [141, 51], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.disjoint_closure_right", "code": "theorem disjoint_closure_right (h : SeparatedNhds s t) : Disjoint s (closure t)", "start": [144, 1], "end": [145, 36], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.empty_right", "code": "theorem empty_right (s : Set \u03b1) : SeparatedNhds s \u2205", "start": [148, 1], "end": [149, 89], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.empty_left", "code": "theorem empty_left (s : Set \u03b1) : SeparatedNhds \u2205 s", "start": [152, 1], "end": [153, 23], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.mono", "code": "theorem mono (h : SeparatedNhds s\u2082 t\u2082) (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : SeparatedNhds s\u2081 t\u2081", "start": [156, 1], "end": [158, 49], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.union_left", "code": "theorem union_left : SeparatedNhds s u \u2192 SeparatedNhds t u \u2192 SeparatedNhds (s \u222a t) u", "start": [161, 1], "end": [162, 92], "kind": "commanddeclaration"}, {"full_name": "SeparatedNhds.union_right", "code": "theorem union_right (ht : SeparatedNhds s t) (hu : SeparatedNhds s u) : SeparatedNhds s (t \u222a u)", "start": [165, 1], "end": [166, 36], "kind": "commanddeclaration"}, {"full_name": "T0Space", "code": "class T0Space (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  t0 : \u2200 \u2983x y : \u03b1\u2984, Inseparable x y \u2192 x = y", "start": [171, 1], "end": [176, 44], "kind": "commanddeclaration"}, {"full_name": "t0Space_iff_inseparable", "code": "theorem t0Space_iff_inseparable (\u03b1 : Type u) [TopologicalSpace \u03b1] :\n    T0Space \u03b1 \u2194 \u2200 x y : \u03b1, Inseparable x y \u2192 x = y", "start": [179, 1], "end": [181, 31], "kind": "commanddeclaration"}, {"full_name": "t0Space_iff_not_inseparable", "code": "theorem t0Space_iff_not_inseparable (\u03b1 : Type u) [TopologicalSpace \u03b1] :\n    T0Space \u03b1 \u2194 \u2200 x y : \u03b1, x \u2260 y \u2192 \u00acInseparable x y", "start": [184, 1], "end": [186, 59], "kind": "commanddeclaration"}, {"full_name": "Inseparable.eq", "code": "theorem Inseparable.eq [T0Space \u03b1] {x y : \u03b1} (h : Inseparable x y) : x = y", "start": [189, 1], "end": [190, 15], "kind": "commanddeclaration"}, {"full_name": "Inducing.injective", "code": "protected theorem Inducing.injective [TopologicalSpace \u03b2] [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : Inducing f) : Injective f", "start": [193, 1], "end": [196, 40], "kind": "commanddeclaration"}, {"full_name": "Inducing.embedding", "code": "protected theorem Inducing.embedding [TopologicalSpace \u03b2] [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : Inducing f) : Embedding f", "start": [199, 1], "end": [202, 21], "kind": "commanddeclaration"}, {"full_name": "embedding_iff_inducing", "code": "lemma embedding_iff_inducing [TopologicalSpace \u03b2] [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2} :\n    Embedding f \u2194 Inducing f :=\n  \u27e8Embedding.toInducing, Inducing.embedding\u27e9", "start": [205, 1], "end": [207, 45], "kind": "mathlibtacticlemma"}, {"full_name": "t0Space_iff_nhds_injective", "code": "theorem t0Space_iff_nhds_injective (\u03b1 : Type u) [TopologicalSpace \u03b1] :\n    T0Space \u03b1 \u2194 Injective (\ud835\udcdd : \u03b1 \u2192 Filter \u03b1)", "start": [210, 1], "end": [212, 28], "kind": "commanddeclaration"}, {"full_name": "nhds_injective", "code": "theorem nhds_injective [T0Space \u03b1] : Injective (\ud835\udcdd : \u03b1 \u2192 Filter \u03b1)", "start": [215, 1], "end": [216, 39], "kind": "commanddeclaration"}, {"full_name": "inseparable_iff_eq", "code": "theorem inseparable_iff_eq [T0Space \u03b1] {x y : \u03b1} : Inseparable x y \u2194 x = y", "start": [219, 1], "end": [220, 24], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_nhds_iff", "code": "@[simp]\ntheorem nhds_eq_nhds_iff [T0Space \u03b1] {a b : \u03b1} : \ud835\udcdd a = \ud835\udcdd b \u2194 a = b", "start": [223, 1], "end": [225, 24], "kind": "commanddeclaration"}, {"full_name": "inseparable_eq_eq", "code": "@[simp]\ntheorem inseparable_eq_eq [T0Space \u03b1] : Inseparable = @Eq \u03b1", "start": [228, 1], "end": [230, 48], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.inseparable_iff", "code": "theorem TopologicalSpace.IsTopologicalBasis.inseparable_iff {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) {x y : \u03b1} : Inseparable x y \u2194 \u2200 s \u2208 b, (x \u2208 s \u2194 y \u2208 s)", "start": [233, 1], "end": [238, 35], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.eq_iff", "code": "theorem TopologicalSpace.IsTopologicalBasis.eq_iff [T0Space \u03b1] {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) {x y : \u03b1} : x = y \u2194 \u2200 s \u2208 b, (x \u2208 s \u2194 y \u2208 s)", "start": [240, 1], "end": [242, 51], "kind": "commanddeclaration"}, {"full_name": "t0Space_iff_exists_isOpen_xor'_mem", "code": "theorem t0Space_iff_exists_isOpen_xor'_mem (\u03b1 : Type u) [TopologicalSpace \u03b1] :\n    T0Space \u03b1 \u2194 \u2200 x y, x \u2260 y \u2192 \u2203 U : Set \u03b1, IsOpen U \u2227 Xor' (x \u2208 U) (y \u2208 U)", "start": [244, 1], "end": [247, 33], "kind": "commanddeclaration"}, {"full_name": "exists_isOpen_xor'_mem", "code": "theorem exists_isOpen_xor'_mem [T0Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 U : Set \u03b1, IsOpen U \u2227 Xor' (x \u2208 U) (y \u2208 U)", "start": [250, 1], "end": [252, 53], "kind": "commanddeclaration"}, {"full_name": "specializationOrder", "code": "def specializationOrder (\u03b1 : Type*) [TopologicalSpace \u03b1] [T0Space \u03b1] : PartialOrder \u03b1 :=\n  { specializationPreorder \u03b1, PartialOrder.lift (OrderDual.toDual \u2218 \ud835\udcdd) nhds_injective with }", "start": [255, 1], "end": [257, 93], "kind": "commanddeclaration"}, {"full_name": "minimal_nonempty_closed_subsingleton", "code": "theorem minimal_nonempty_closed_subsingleton [T0Space \u03b1] {s : Set \u03b1} (hs : IsClosed s)\n    (hmin : \u2200 t, t \u2286 s \u2192 t.Nonempty \u2192 IsClosed t \u2192 t = s) : s.Subsingleton", "start": [264, 1], "end": [273, 36], "kind": "commanddeclaration"}, {"full_name": "minimal_nonempty_closed_eq_singleton", "code": "theorem minimal_nonempty_closed_eq_singleton [T0Space \u03b1] {s : Set \u03b1} (hs : IsClosed s)\n    (hne : s.Nonempty) (hmin : \u2200 t, t \u2286 s \u2192 t.Nonempty \u2192 IsClosed t \u2192 t = s) : \u2203 x, s = {x}", "start": [276, 1], "end": [279, 56], "kind": "commanddeclaration"}, {"full_name": "IsClosed.exists_closed_singleton", "code": "theorem IsClosed.exists_closed_singleton {\u03b1 : Type*} [TopologicalSpace \u03b1] [T0Space \u03b1]\n    [CompactSpace \u03b1] {S : Set \u03b1} (hS : IsClosed S) (hne : S.Nonempty) :\n    \u2203 x : \u03b1, x \u2208 S \u2227 IsClosed ({x} : Set \u03b1)", "start": [282, 1], "end": [289, 42], "kind": "commanddeclaration"}, {"full_name": "minimal_nonempty_open_subsingleton", "code": "theorem minimal_nonempty_open_subsingleton [T0Space \u03b1] {s : Set \u03b1} (hs : IsOpen s)\n    (hmin : \u2200 t, t \u2286 s \u2192 t.Nonempty \u2192 IsOpen t \u2192 t = s) : s.Subsingleton", "start": [292, 1], "end": [301, 36], "kind": "commanddeclaration"}, {"full_name": "minimal_nonempty_open_eq_singleton", "code": "theorem minimal_nonempty_open_eq_singleton [T0Space \u03b1] {s : Set \u03b1} (hs : IsOpen s)\n    (hne : s.Nonempty) (hmin : \u2200 t, t \u2286 s \u2192 t.Nonempty \u2192 IsOpen t \u2192 t = s) : \u2203 x, s = {x}", "start": [304, 1], "end": [306, 100], "kind": "commanddeclaration"}, {"full_name": "exists_open_singleton_of_open_finite", "code": "theorem exists_open_singleton_of_open_finite [T0Space \u03b1] {s : Set \u03b1} (hfin : s.Finite)\n    (hne : s.Nonempty) (ho : IsOpen s) : \u2203 x \u2208 s, IsOpen ({x} : Set \u03b1)", "start": [309, 1], "end": [324, 82], "kind": "commanddeclaration"}, {"full_name": "exists_open_singleton_of_finite", "code": "theorem exists_open_singleton_of_finite [T0Space \u03b1] [Finite \u03b1] [Nonempty \u03b1] :\n    \u2203 x : \u03b1, IsOpen ({x} : Set \u03b1)", "start": [327, 1], "end": [330, 9], "kind": "commanddeclaration"}, {"full_name": "t0Space_of_injective_of_continuous", "code": "theorem t0Space_of_injective_of_continuous [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (hf' : Continuous f) [T0Space \u03b2] : T0Space \u03b1", "start": [333, 1], "end": [335, 38], "kind": "commanddeclaration"}, {"full_name": "Embedding.t0Space", "code": "protected theorem Embedding.t0Space [TopologicalSpace \u03b2] [T0Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Embedding f) : T0Space \u03b1", "start": [338, 1], "end": [340, 58], "kind": "commanddeclaration"}, {"full_name": "Subtype.t0Space", "code": "instance Subtype.t0Space [T0Space \u03b1] {p : \u03b1 \u2192 Prop} : T0Space (Subtype p) :=\n  embedding_subtype_val.t0Space", "start": [343, 1], "end": [344, 32], "kind": "commanddeclaration"}, {"full_name": "t0Space_iff_or_not_mem_closure", "code": "theorem t0Space_iff_or_not_mem_closure (\u03b1 : Type u) [TopologicalSpace \u03b1] :\n    T0Space \u03b1 \u2194 \u2200 a b : \u03b1, a \u2260 b \u2192 a \u2209 closure ({b} : Set \u03b1) \u2228 b \u2209 closure ({a} : Set \u03b1)", "start": [347, 1], "end": [349, 83], "kind": "commanddeclaration"}, {"full_name": "Prod.instT0Space", "code": "instance Prod.instT0Space [TopologicalSpace \u03b2] [T0Space \u03b1] [T0Space \u03b2] : T0Space (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun _ _ h => Prod.ext (h.map continuous_fst).eq (h.map continuous_snd).eq\u27e9", "start": [352, 1], "end": [353, 78], "kind": "commanddeclaration"}, {"full_name": "Pi.instT0Space", "code": "instance Pi.instT0Space {\u03b9 : Type*} {\u03c0 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03c0 i)]\n    [\u2200 i, T0Space (\u03c0 i)] :\n    T0Space (\u2200 i, \u03c0 i) :=\n  \u27e8fun _ _ h => funext fun i => (h.map (continuous_apply i)).eq\u27e9", "start": [355, 1], "end": [358, 65], "kind": "commanddeclaration"}, {"full_name": "T0Space.of_cover", "code": "theorem T0Space.of_cover (h : \u2200 x y, Inseparable x y \u2192 \u2203 s : Set \u03b1, x \u2208 s \u2227 y \u2208 s \u2227 T0Space s) :\n    T0Space \u03b1", "start": [361, 1], "end": [367, 37], "kind": "commanddeclaration"}, {"full_name": "T0Space.of_open_cover", "code": "theorem T0Space.of_open_cover (h : \u2200 x, \u2203 s : Set \u03b1, x \u2208 s \u2227 IsOpen s \u2227 T0Space s) : T0Space \u03b1", "start": [370, 1], "end": [373, 47], "kind": "commanddeclaration"}, {"full_name": "T1Space", "code": "class T1Space (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  t1 : \u2200 x, IsClosed ({x} : Set \u03b1)", "start": [376, 1], "end": [381, 35], "kind": "commanddeclaration"}, {"full_name": "isClosed_singleton", "code": "theorem isClosed_singleton [T1Space \u03b1] {x : \u03b1} : IsClosed ({x} : Set \u03b1)", "start": [384, 1], "end": [385, 15], "kind": "commanddeclaration"}, {"full_name": "isOpen_compl_singleton", "code": "theorem isOpen_compl_singleton [T1Space \u03b1] {x : \u03b1} : IsOpen ({x}\u1d9c : Set \u03b1)", "start": [388, 1], "end": [389, 34], "kind": "commanddeclaration"}, {"full_name": "isOpen_ne", "code": "theorem isOpen_ne [T1Space \u03b1] {x : \u03b1} : IsOpen { y | y \u2260 x }", "start": [392, 1], "end": [393, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.isOpen_mulSupport", "code": "@[to_additive]\ntheorem Continuous.isOpen_mulSupport [T1Space \u03b1] [One \u03b1] [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Continuous f) : IsOpen (mulSupport f)", "start": [396, 1], "end": [399, 24], "kind": "commanddeclaration"}, {"full_name": "Ne.nhdsWithin_compl_singleton", "code": "theorem Ne.nhdsWithin_compl_singleton [T1Space \u03b1] {x y : \u03b1} (h : x \u2260 y) : \ud835\udcdd[{y}\u1d9c] x = \ud835\udcdd x", "start": [403, 1], "end": [404, 28], "kind": "commanddeclaration"}, {"full_name": "Ne.nhdsWithin_diff_singleton", "code": "theorem Ne.nhdsWithin_diff_singleton [T1Space \u03b1] {x y : \u03b1} (h : x \u2260 y) (s : Set \u03b1) :\n    \ud835\udcdd[s \\ {y}] x = \ud835\udcdd[s] x", "start": [407, 1], "end": [410, 58], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_compl_singleton_le", "code": "lemma nhdsWithin_compl_singleton_le [T1Space \u03b1] (x y : \u03b1) : \ud835\udcdd[{x}\u1d9c] x \u2264 \ud835\udcdd[{y}\u1d9c] x := by\n  rcases eq_or_ne x y with rfl|hy\n  \u00b7 exact Eq.le rfl\n  \u00b7 rw [Ne.nhdsWithin_compl_singleton hy]\n    exact nhdsWithin_le_nhds", "start": [413, 1], "end": [417, 29], "kind": "mathlibtacticlemma"}, {"full_name": "isOpen_setOf_eventually_nhdsWithin", "code": "theorem isOpen_setOf_eventually_nhdsWithin [T1Space \u03b1] {p : \u03b1 \u2192 Prop} :\n    IsOpen { x | \u2200\u1da0 y in \ud835\udcdd[\u2260] x, p y }", "start": [419, 1], "end": [426, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.isClosed", "code": "protected theorem Set.Finite.isClosed [T1Space \u03b1] {s : Set \u03b1} (hs : Set.Finite s) : IsClosed s", "start": [429, 1], "end": [431, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne", "code": "theorem TopologicalSpace.IsTopologicalBasis.exists_mem_of_ne [T1Space \u03b1] {b : Set (Set \u03b1)}\n    (hb : IsTopologicalBasis b) {x y : \u03b1} (h : x \u2260 y) : \u2203 a \u2208 b, x \u2208 a \u2227 y \u2209 a", "start": [434, 1], "end": [437, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.coclosedCompact_le_cofinite", "code": "theorem Filter.coclosedCompact_le_cofinite [T1Space \u03b1] :\n    Filter.coclosedCompact \u03b1 \u2264 Filter.cofinite", "start": [440, 1], "end": [442, 81], "kind": "commanddeclaration"}, {"full_name": "Bornology.relativelyCompact", "code": "def Bornology.relativelyCompact [T1Space \u03b1] : Bornology \u03b1 where\n  cobounded' := Filter.coclosedCompact \u03b1\n  le_cofinite' := Filter.coclosedCompact_le_cofinite", "start": [447, 1], "end": [452, 53], "kind": "commanddeclaration"}, {"full_name": "Bornology.relativelyCompact.isBounded_iff", "code": "theorem Bornology.relativelyCompact.isBounded_iff [T1Space \u03b1] {s : Set \u03b1} :\n    @Bornology.IsBounded _ (Bornology.relativelyCompact \u03b1) s \u2194 IsCompact (closure s)", "start": [457, 1], "end": [466, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.isClosed", "code": "protected theorem Finset.isClosed [T1Space \u03b1] (s : Finset \u03b1) : IsClosed (s : Set \u03b1)", "start": [469, 1], "end": [470, 26], "kind": "commanddeclaration"}, {"full_name": "t1Space_TFAE", "code": "theorem t1Space_TFAE (\u03b1 : Type u) [ TopologicalSpace \u03b1 ] :\n    List.TFAE [T1Space \u03b1,\n      \u2200 x, IsClosed ({ x } : Set \u03b1),\n      \u2200 x, IsOpen ({ x }\u1d9c : Set \u03b1),\n      Continuous (@CofiniteTopology.of \u03b1),\n      \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 {y}\u1d9c \u2208 \ud835\udcdd x,\n      \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 \u2203 s \u2208 \ud835\udcdd x, y \u2209 s,\n      \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 \u2203 U : Set \u03b1, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U,\n      \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 Disjoint (\ud835\udcdd x) (pure y),\n      \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 Disjoint (pure x) (\ud835\udcdd y),\n      \u2200 \u2983x y : \u03b1\u2984, x \u2933 y \u2192 x = y]", "start": [473, 1], "end": [509, 14], "kind": "commanddeclaration"}, {"full_name": "t1Space_iff_continuous_cofinite_of", "code": "theorem t1Space_iff_continuous_cofinite_of {\u03b1 : Type*} [TopologicalSpace \u03b1] :\n    T1Space \u03b1 \u2194 Continuous (@CofiniteTopology.of \u03b1)", "start": [512, 1], "end": [514, 27], "kind": "commanddeclaration"}, {"full_name": "CofiniteTopology.continuous_of", "code": "theorem CofiniteTopology.continuous_of [T1Space \u03b1] : Continuous (@CofiniteTopology.of \u03b1)", "start": [517, 1], "end": [518, 44], "kind": "commanddeclaration"}, {"full_name": "t1Space_iff_exists_open", "code": "theorem t1Space_iff_exists_open :\n    T1Space \u03b1 \u2194 \u2200 x y, x \u2260 y \u2192 \u2203 U : Set \u03b1, IsOpen U \u2227 x \u2208 U \u2227 y \u2209 U", "start": [521, 1], "end": [523, 27], "kind": "commanddeclaration"}, {"full_name": "t1Space_iff_disjoint_pure_nhds", "code": "theorem t1Space_iff_disjoint_pure_nhds : T1Space \u03b1 \u2194 \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 Disjoint (pure x) (\ud835\udcdd y)", "start": [526, 1], "end": [527, 27], "kind": "commanddeclaration"}, {"full_name": "t1Space_iff_disjoint_nhds_pure", "code": "theorem t1Space_iff_disjoint_nhds_pure : T1Space \u03b1 \u2194 \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 Disjoint (\ud835\udcdd x) (pure y)", "start": [530, 1], "end": [531, 27], "kind": "commanddeclaration"}, {"full_name": "t1Space_iff_specializes_imp_eq", "code": "theorem t1Space_iff_specializes_imp_eq : T1Space \u03b1 \u2194 \u2200 \u2983x y : \u03b1\u2984, x \u2933 y \u2192 x = y", "start": [534, 1], "end": [535, 27], "kind": "commanddeclaration"}, {"full_name": "disjoint_pure_nhds", "code": "theorem disjoint_pure_nhds [T1Space \u03b1] {x y : \u03b1} (h : x \u2260 y) : Disjoint (pure x) (\ud835\udcdd y)", "start": [538, 1], "end": [539, 42], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_pure", "code": "theorem disjoint_nhds_pure [T1Space \u03b1] {x y : \u03b1} (h : x \u2260 y) : Disjoint (\ud835\udcdd x) (pure y)", "start": [542, 1], "end": [543, 42], "kind": "commanddeclaration"}, {"full_name": "Specializes.eq", "code": "theorem Specializes.eq [T1Space \u03b1] {x y : \u03b1} (h : x \u2933 y) : x = y", "start": [546, 1], "end": [547, 41], "kind": "commanddeclaration"}, {"full_name": "specializes_iff_eq", "code": "theorem specializes_iff_eq [T1Space \u03b1] {x y : \u03b1} : x \u2933 y \u2194 x = y", "start": [550, 1], "end": [551, 49], "kind": "commanddeclaration"}, {"full_name": "specializes_eq_eq", "code": "@[simp] theorem specializes_eq_eq [T1Space \u03b1] : (\u00b7 \u2933 \u00b7) = @Eq \u03b1", "start": [554, 1], "end": [555, 48], "kind": "commanddeclaration"}, {"full_name": "pure_le_nhds_iff", "code": "@[simp]\ntheorem pure_le_nhds_iff [T1Space \u03b1] {a b : \u03b1} : pure a \u2264 \ud835\udcdd b \u2194 a = b", "start": [558, 1], "end": [560, 53], "kind": "commanddeclaration"}, {"full_name": "nhds_le_nhds_iff", "code": "@[simp]\ntheorem nhds_le_nhds_iff [T1Space \u03b1] {a b : \u03b1} : \ud835\udcdd a \u2264 \ud835\udcdd b \u2194 a = b", "start": [563, 1], "end": [565, 21], "kind": "commanddeclaration"}, {"full_name": "t1Space_antitone", "code": "theorem t1Space_antitone {\u03b1 : Type*} : Antitone (@T1Space \u03b1)", "start": [571, 1], "end": [572, 49], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_update_of_ne", "code": "theorem continuousWithinAt_update_of_ne [T1Space \u03b1] [DecidableEq \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {x y : \u03b1} {z : \u03b2} (hne : y \u2260 x) :\n    ContinuousWithinAt (Function.update f x z) s y \u2194 ContinuousWithinAt f s y", "start": [575, 1], "end": [581, 36], "kind": "commanddeclaration"}, {"full_name": "continuousAt_update_of_ne", "code": "theorem continuousAt_update_of_ne [T1Space \u03b1] [DecidableEq \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {x y : \u03b1} {z : \u03b2} (hne : y \u2260 x) : ContinuousAt (Function.update f x z) y \u2194 ContinuousAt f y", "start": [584, 1], "end": [586, 80], "kind": "commanddeclaration"}, {"full_name": "continuousOn_update_iff", "code": "theorem continuousOn_update_iff [T1Space \u03b1] [DecidableEq \u03b1] [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {x : \u03b1} {y : \u03b2} :\n    ContinuousOn (Function.update f x y) s \u2194\n      ContinuousOn f (s \\ {x}) \u2227 (x \u2208 s \u2192 Tendsto f (\ud835\udcdd[s \\ {x}] x) (\ud835\udcdd y))", "start": [589, 1], "end": [601, 41], "kind": "commanddeclaration"}, {"full_name": "t1Space_of_injective_of_continuous", "code": "theorem t1Space_of_injective_of_continuous [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Function.Injective f) (hf' : Continuous f) [T1Space \u03b2] : T1Space \u03b1", "start": [604, 1], "end": [606, 66], "kind": "commanddeclaration"}, {"full_name": "Embedding.t1Space", "code": "protected theorem Embedding.t1Space [TopologicalSpace \u03b2] [T1Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Embedding f) : T1Space \u03b1", "start": [609, 1], "end": [611, 58], "kind": "commanddeclaration"}, {"full_name": "Subtype.t1Space", "code": "instance Subtype.t1Space {\u03b1 : Type u} [TopologicalSpace \u03b1] [T1Space \u03b1] {p : \u03b1 \u2192 Prop} :\n    T1Space (Subtype p) :=\n  embedding_subtype_val.t1Space", "start": [614, 1], "end": [616, 32], "kind": "commanddeclaration"}, {"full_name": "T1Space.t0Space", "code": "instance (priority := 100) T1Space.t0Space [T1Space \u03b1] : T0Space \u03b1 :=\n  \u27e8fun _ _ h => h.specializes.eq\u27e9", "start": [627, 1], "end": [628, 34], "kind": "commanddeclaration"}, {"full_name": "compl_singleton_mem_nhds_iff", "code": "@[simp]\ntheorem compl_singleton_mem_nhds_iff [T1Space \u03b1] {x y : \u03b1} : {x}\u1d9c \u2208 \ud835\udcdd y \u2194 y \u2260 x", "start": [631, 1], "end": [633, 38], "kind": "commanddeclaration"}, {"full_name": "compl_singleton_mem_nhds", "code": "theorem compl_singleton_mem_nhds [T1Space \u03b1] {x y : \u03b1} (h : y \u2260 x) : {x}\u1d9c \u2208 \ud835\udcdd y", "start": [636, 1], "end": [637, 37], "kind": "commanddeclaration"}, {"full_name": "closure_singleton", "code": "@[simp]\ntheorem closure_singleton [T1Space \u03b1] {a : \u03b1} : closure ({a} : Set \u03b1) = {a}", "start": [640, 1], "end": [642, 32], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.closure", "code": "theorem Set.Subsingleton.closure [T1Space \u03b1] {s : Set \u03b1} (hs : s.Subsingleton) :\n    (closure s).Subsingleton", "start": [646, 1], "end": [648, 65], "kind": "commanddeclaration"}, {"full_name": "subsingleton_closure", "code": "@[simp]\ntheorem subsingleton_closure [T1Space \u03b1] {s : Set \u03b1} : (closure s).Subsingleton \u2194 s.Subsingleton", "start": [651, 1], "end": [653, 55], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_const", "code": "theorem isClosedMap_const {\u03b1 \u03b2} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] [T1Space \u03b2] {y : \u03b2} :\n    IsClosedMap (Function.const \u03b1 y)", "start": [656, 1], "end": [658, 97], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_insert_of_ne", "code": "theorem nhdsWithin_insert_of_ne [T1Space \u03b1] {x y : \u03b1} {s : Set \u03b1} (hxy : x \u2260 y) :\n    \ud835\udcdd[insert y s] x = \ud835\udcdd[s] x", "start": [661, 1], "end": [667, 69], "kind": "commanddeclaration"}, {"full_name": "insert_mem_nhdsWithin_of_subset_insert", "code": "theorem insert_mem_nhdsWithin_of_subset_insert [T1Space \u03b1] {x y : \u03b1} {s t : Set \u03b1}\n    (hu : t \u2286 insert y s) : insert x s \u2208 \ud835\udcdd[t] x", "start": [670, 1], "end": [678, 64], "kind": "commanddeclaration"}, {"full_name": "ker_nhds", "code": "@[simp]\ntheorem ker_nhds [T1Space \u03b1] (x : \u03b1) : (\ud835\udcdd x).ker = {x}", "start": [681, 1], "end": [683, 33], "kind": "commanddeclaration"}, {"full_name": "biInter_basis_nhds", "code": "theorem biInter_basis_nhds [T1Space \u03b1] {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} {x : \u03b1}\n    (h : (\ud835\udcdd x).HasBasis p s) : \u22c2 (i) (_ : p i), s i = {x}", "start": [685, 1], "end": [687, 25], "kind": "commanddeclaration"}, {"full_name": "compl_singleton_mem_nhdsSet_iff", "code": "@[simp]\ntheorem compl_singleton_mem_nhdsSet_iff [T1Space \u03b1] {x : \u03b1} {s : Set \u03b1} : {x}\u1d9c \u2208 \ud835\udcdd\u02e2 s \u2194 x \u2209 s", "start": [690, 1], "end": [692, 70], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_le_iff", "code": "@[simp]\ntheorem nhdsSet_le_iff [T1Space \u03b1] {s t : Set \u03b1} : \ud835\udcdd\u02e2 s \u2264 \ud835\udcdd\u02e2 t \u2194 s \u2286 t", "start": [695, 1], "end": [702, 17], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_inj_iff", "code": "@[simp]\ntheorem nhdsSet_inj_iff [T1Space \u03b1] {s t : Set \u03b1} : \ud835\udcdd\u02e2 s = \ud835\udcdd\u02e2 t \u2194 s = t", "start": [705, 1], "end": [708, 48], "kind": "commanddeclaration"}, {"full_name": "injective_nhdsSet", "code": "theorem injective_nhdsSet [T1Space \u03b1] : Function.Injective (\ud835\udcdd\u02e2 : Set \u03b1 \u2192 Filter \u03b1)", "start": [711, 1], "end": [712, 25], "kind": "commanddeclaration"}, {"full_name": "strictMono_nhdsSet", "code": "theorem strictMono_nhdsSet [T1Space \u03b1] : StrictMono (\ud835\udcdd\u02e2 : Set \u03b1 \u2192 Filter \u03b1)", "start": [715, 1], "end": [716, 61], "kind": "commanddeclaration"}, {"full_name": "nhds_le_nhdsSet_iff", "code": "@[simp]\ntheorem nhds_le_nhdsSet_iff [T1Space \u03b1] {s : Set \u03b1} {x : \u03b1} : \ud835\udcdd x \u2264 \ud835\udcdd\u02e2 s \u2194 x \u2208 s", "start": [719, 1], "end": [721, 65], "kind": "commanddeclaration"}, {"full_name": "Dense.diff_singleton", "code": "theorem Dense.diff_singleton [T1Space \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) [NeBot (\ud835\udcdd[\u2260] x)] :\n    Dense (s \\ {x})", "start": [724, 1], "end": [727, 74], "kind": "commanddeclaration"}, {"full_name": "Dense.diff_finset", "code": "theorem Dense.diff_finset [T1Space \u03b1] [\u2200 x : \u03b1, NeBot (\ud835\udcdd[\u2260] x)] {s : Set \u03b1} (hs : Dense s)\n    (t : Finset \u03b1) : Dense (s \\ t)", "start": [730, 1], "end": [738, 30], "kind": "commanddeclaration"}, {"full_name": "Dense.diff_finite", "code": "theorem Dense.diff_finite [T1Space \u03b1] [\u2200 x : \u03b1, NeBot (\ud835\udcdd[\u2260] x)] {s : Set \u03b1} (hs : Dense s)\n    {t : Set \u03b1} (ht : t.Finite) : Dense (s \\ t)", "start": [741, 1], "end": [746, 37], "kind": "commanddeclaration"}, {"full_name": "eq_of_tendsto_nhds", "code": "theorem eq_of_tendsto_nhds [TopologicalSpace \u03b2] [T1Space \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}\n    (h : Tendsto f (\ud835\udcdd a) (\ud835\udcdd b)) : f a = b", "start": [749, 1], "end": [756, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_ne", "code": "theorem Filter.Tendsto.eventually_ne [TopologicalSpace \u03b2] [T1Space \u03b2] {\u03b1 : Type*} {g : \u03b1 \u2192 \u03b2}\n    {l : Filter \u03b1} {b\u2081 b\u2082 : \u03b2} (hg : Tendsto g l (\ud835\udcdd b\u2081)) (hb : b\u2081 \u2260 b\u2082) : \u2200\u1da0 z in l, g z \u2260 b\u2082", "start": [759, 1], "end": [761, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.eventually_ne", "code": "theorem ContinuousAt.eventually_ne [TopologicalSpace \u03b2] [T1Space \u03b2] {g : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}\n    (hg1 : ContinuousAt g a) (hg2 : g a \u2260 b) : \u2200\u1da0 z in \ud835\udcdd a, g z \u2260 b", "start": [764, 1], "end": [766, 32], "kind": "commanddeclaration"}, {"full_name": "eventually_ne_nhds", "code": "theorem eventually_ne_nhds [T1Space \u03b1] {a b : \u03b1} (h : a \u2260 b) : \u2200\u1da0 x in \ud835\udcdd a, x \u2260 b", "start": [769, 1], "end": [770, 36], "kind": "commanddeclaration"}, {"full_name": "eventually_ne_nhdsWithin", "code": "theorem eventually_ne_nhdsWithin [T1Space \u03b1] {a b : \u03b1} {s : Set \u03b1} (h : a \u2260 b) :\n    \u2200\u1da0 x in \ud835\udcdd[s] a, x \u2260 b", "start": [772, 1], "end": [774, 75], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_tendsto_nhds", "code": "theorem continuousAt_of_tendsto_nhds [TopologicalSpace \u03b2] [T1Space \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {b : \u03b2}\n    (h : Tendsto f (\ud835\udcdd a) (\ud835\udcdd b)) : ContinuousAt f a", "start": [776, 1], "end": [780, 43], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_nhds_iff", "code": "@[simp]\ntheorem tendsto_const_nhds_iff [T1Space \u03b1] {l : Filter \u03b2} [NeBot l] {c d : \u03b1} :\n    Tendsto (fun _ => c) l (\ud835\udcdd d) \u2194 c = d", "start": [783, 1], "end": [785, 101], "kind": "commanddeclaration"}, {"full_name": "isOpen_singleton_of_finite_mem_nhds", "code": "theorem isOpen_singleton_of_finite_mem_nhds {\u03b1 : Type*} [TopologicalSpace \u03b1] [T1Space \u03b1] (x : \u03b1)\n    {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) (hsf : s.Finite) : IsOpen ({x} : Set \u03b1)", "start": [788, 1], "end": [795, 93], "kind": "commanddeclaration"}, {"full_name": "infinite_of_mem_nhds", "code": "theorem infinite_of_mem_nhds {\u03b1} [TopologicalSpace \u03b1] [T1Space \u03b1] (x : \u03b1) [hx : NeBot (\ud835\udcdd[\u2260] x)]\n    {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) : Set.Infinite s", "start": [798, 1], "end": [804, 53], "kind": "commanddeclaration"}, {"full_name": "discrete_of_t1_of_finite", "code": "theorem discrete_of_t1_of_finite {X : Type*} [TopologicalSpace X] [T1Space X] [Finite X] :\n    DiscreteTopology X", "start": [807, 1], "end": [812, 34], "kind": "commanddeclaration"}, {"full_name": "PreconnectedSpace.trivial_of_discrete", "code": "theorem PreconnectedSpace.trivial_of_discrete [PreconnectedSpace \u03b1] [DiscreteTopology \u03b1] :\n    Subsingleton \u03b1", "start": [815, 1], "end": [820, 25], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.infinite_of_nontrivial", "code": "theorem IsPreconnected.infinite_of_nontrivial [T1Space \u03b1] {s : Set \u03b1} (h : IsPreconnected s)\n    (hs : s.Nontrivial) : s.Infinite", "start": [823, 1], "end": [827, 83], "kind": "commanddeclaration"}, {"full_name": "ConnectedSpace.infinite", "code": "theorem ConnectedSpace.infinite [ConnectedSpace \u03b1] [Nontrivial \u03b1] [T1Space \u03b1] : Infinite \u03b1", "start": [830, 1], "end": [831, 85], "kind": "commanddeclaration"}, {"full_name": "ConnectedSpace.neBot_nhdsWithin_compl_of_nontrivial_of_t1space", "code": "instance ConnectedSpace.neBot_nhdsWithin_compl_of_nontrivial_of_t1space\n    [ConnectedSpace \u03b1] [Nontrivial \u03b1] [T1Space \u03b1] (x : \u03b1) :\n    NeBot (\ud835\udcdd[\u2260] x) := by\n  by_contra contra\n  rw [not_neBot, \u2190 isOpen_singleton_iff_punctured_nhds] at contra\n  replace contra := nonempty_inter isOpen_compl_singleton\n    contra (compl_union_self _) (Set.nonempty_compl_of_nontrivial _) (singleton_nonempty _)\n  simp [compl_inter_self {x}] at contra", "start": [834, 1], "end": [842, 40], "kind": "commanddeclaration"}, {"full_name": "singleton_mem_nhdsWithin_of_mem_discrete", "code": "theorem singleton_mem_nhdsWithin_of_mem_discrete {s : Set \u03b1} [DiscreteTopology s] {x : \u03b1}\n    (hx : x \u2208 s) : {x} \u2208 \ud835\udcdd[s] x", "start": [844, 1], "end": [848, 46], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_of_mem_discrete", "code": "theorem nhdsWithin_of_mem_discrete {s : Set \u03b1} [DiscreteTopology s] {x : \u03b1} (hx : x \u2208 s) :\n    \ud835\udcdd[s] x = pure x", "start": [851, 1], "end": [855, 101], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete", "code": "theorem Filter.HasBasis.exists_inter_eq_singleton_of_mem_discrete {\u03b9 : Type*} {p : \u03b9 \u2192 Prop}\n    {t : \u03b9 \u2192 Set \u03b1} {s : Set \u03b1} [DiscreteTopology s] {x : \u03b1} (hb : (\ud835\udcdd x).HasBasis p t)\n    (hx : x \u2208 s) : \u2203 i, p i \u2227 t i \u2229 s = {x}", "start": [858, 1], "end": [863, 98], "kind": "commanddeclaration"}, {"full_name": "nhds_inter_eq_singleton_of_mem_discrete", "code": "theorem nhds_inter_eq_singleton_of_mem_discrete {s : Set \u03b1} [DiscreteTopology s] {x : \u03b1}\n    (hx : x \u2208 s) : \u2203 U \u2208 \ud835\udcdd x, U \u2229 s = {x}", "start": [866, 1], "end": [870, 76], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhdsWithin_of_mem_discrete", "code": "theorem disjoint_nhdsWithin_of_mem_discrete {s : Set \u03b1} [DiscreteTopology s] {x : \u03b1} (hx : x \u2208 s) :\n    \u2203 U \u2208 \ud835\udcdd[\u2260] x, Disjoint U s", "start": [873, 1], "end": [882, 81], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.subset_trans", "code": "@[deprecated embedding_inclusion]\ntheorem TopologicalSpace.subset_trans {X : Type*} [TopologicalSpace X] {s t : Set X}\n    (ts : t \u2286 s) :\n    (instTopologicalSpaceSubtype : TopologicalSpace t) =\n      (instTopologicalSpaceSubtype : TopologicalSpace s).induced (Set.inclusion ts)", "start": [885, 1], "end": [893, 35], "kind": "commanddeclaration"}, {"full_name": "T2Space", "code": "@[mk_iff t2Space_iff]\nclass T2Space (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  t2 : \u2200 x y, x \u2260 y \u2192 \u2203 u v : Set \u03b1, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v", "start": [896, 1], "end": [902, 88], "kind": "commanddeclaration"}, {"full_name": "t2_separation", "code": "theorem t2_separation [T2Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 u v : Set \u03b1, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v", "start": [905, 1], "end": [908, 19], "kind": "commanddeclaration"}, {"full_name": "t2Space_iff_disjoint_nhds", "code": "theorem t2Space_iff_disjoint_nhds : T2Space \u03b1 \u2194 \u2200 x y : \u03b1, x \u2260 y \u2192 Disjoint (\ud835\udcdd x) (\ud835\udcdd y)", "start": [912, 1], "end": [915, 40], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_nhds", "code": "@[simp]\ntheorem disjoint_nhds_nhds [T2Space \u03b1] {x y : \u03b1} : Disjoint (\ud835\udcdd x) (\ud835\udcdd y) \u2194 x \u2260 y", "start": [918, 1], "end": [920, 89], "kind": "commanddeclaration"}, {"full_name": "pairwise_disjoint_nhds", "code": "theorem pairwise_disjoint_nhds [T2Space \u03b1] : Pairwise (Disjoint on (\ud835\udcdd : \u03b1 \u2192 Filter \u03b1))", "start": [923, 1], "end": [924, 23], "kind": "commanddeclaration"}, {"full_name": "Set.pairwiseDisjoint_nhds", "code": "protected theorem Set.pairwiseDisjoint_nhds [T2Space \u03b1] (s : Set \u03b1) : s.PairwiseDisjoint \ud835\udcdd", "start": [927, 1], "end": [928, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.t2_separation", "code": "theorem Set.Finite.t2_separation [T2Space \u03b1] {s : Set \u03b1} (hs : s.Finite) :\n    \u2203 U : \u03b1 \u2192 Set \u03b1, (\u2200 x, x \u2208 U x \u2227 IsOpen (U x)) \u2227 s.PairwiseDisjoint U", "start": [931, 1], "end": [934, 70], "kind": "commanddeclaration"}, {"full_name": "isOpen_setOf_disjoint_nhds_nhds", "code": "theorem isOpen_setOf_disjoint_nhds_nhds : IsOpen { p : \u03b1 \u00d7 \u03b1 | Disjoint (\ud835\udcdd p.1) (\ud835\udcdd p.2) }", "start": [937, 1], "end": [944, 80], "kind": "commanddeclaration"}, {"full_name": "T2Space.t1Space", "code": "instance (priority := 100) T2Space.t1Space [T2Space \u03b1] : T1Space \u03b1 :=\n  t1Space_iff_disjoint_pure_nhds.mpr fun _ _ hne =>\n    (disjoint_nhds_nhds.2 hne).mono_left <| pure_le_nhds _", "start": [948, 1], "end": [950, 59], "kind": "commanddeclaration"}, {"full_name": "t2_iff_nhds", "code": "theorem t2_iff_nhds : T2Space \u03b1 \u2194 \u2200 {x y : \u03b1}, NeBot (\ud835\udcdd x \u2293 \ud835\udcdd y) \u2192 x = y", "start": [953, 1], "end": [955, 87], "kind": "commanddeclaration"}, {"full_name": "eq_of_nhds_neBot", "code": "theorem eq_of_nhds_neBot [T2Space \u03b1] {x y : \u03b1} (h : NeBot (\ud835\udcdd x \u2293 \ud835\udcdd y)) : x = y", "start": [958, 1], "end": [959, 23], "kind": "commanddeclaration"}, {"full_name": "t2Space_iff_nhds", "code": "theorem t2Space_iff_nhds : T2Space \u03b1 \u2194 \u2200 {x y : \u03b1}, x \u2260 y \u2192 \u2203 U \u2208 \ud835\udcdd x, \u2203 V \u2208 \ud835\udcdd y, Disjoint U V", "start": [962, 1], "end": [963, 61], "kind": "commanddeclaration"}, {"full_name": "t2_separation_nhds", "code": "theorem t2_separation_nhds [T2Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 u v, u \u2208 \ud835\udcdd x \u2227 v \u2208 \ud835\udcdd y \u2227 Disjoint u v", "start": [966, 1], "end": [969, 58], "kind": "commanddeclaration"}, {"full_name": "t2_separation_compact_nhds", "code": "theorem t2_separation_compact_nhds [LocallyCompactSpace \u03b1] [T2Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 u v, u \u2208 \ud835\udcdd x \u2227 v \u2208 \ud835\udcdd y \u2227 IsCompact u \u2227 IsCompact v \u2227 Disjoint u v", "start": [972, 1], "end": [975, 92], "kind": "commanddeclaration"}, {"full_name": "t2_iff_ultrafilter", "code": "theorem t2_iff_ultrafilter :\n    T2Space \u03b1 \u2194 \u2200 {x y : \u03b1} (f : Ultrafilter \u03b1), \u2191f \u2264 \ud835\udcdd x \u2192 \u2191f \u2264 \ud835\udcdd y \u2192 x = y", "start": [978, 1], "end": [980, 96], "kind": "commanddeclaration"}, {"full_name": "t2_iff_isClosed_diagonal", "code": "theorem t2_iff_isClosed_diagonal : T2Space \u03b1 \u2194 IsClosed (diagonal \u03b1)", "start": [983, 1], "end": [985, 76], "kind": "commanddeclaration"}, {"full_name": "isClosed_diagonal", "code": "theorem isClosed_diagonal [T2Space \u03b1] : IsClosed (diagonal \u03b1)", "start": [988, 1], "end": [989, 34], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_unique", "code": "theorem tendsto_nhds_unique [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a b : \u03b1} [NeBot l]\n    (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto f l (\ud835\udcdd b)) : a = b", "start": [994, 1], "end": [996, 50], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_unique'", "code": "theorem tendsto_nhds_unique' [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a b : \u03b1} (_ : NeBot l)\n    (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto f l (\ud835\udcdd b)) : a = b", "start": [999, 1], "end": [1001, 50], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_unique_of_eventuallyEq", "code": "theorem tendsto_nhds_unique_of_eventuallyEq [T2Space \u03b1] {f g : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a b : \u03b1}\n    [NeBot l] (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto g l (\ud835\udcdd b)) (hfg : f =\u1da0[l] g) : a = b", "start": [1004, 1], "end": [1006, 41], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_unique_of_frequently_eq", "code": "theorem tendsto_nhds_unique_of_frequently_eq [T2Space \u03b1] {f g : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a b : \u03b1}\n    (ha : Tendsto f l (\ud835\udcdd a)) (hb : Tendsto g l (\ud835\udcdd b)) (hfg : \u2203\u1da0 x in l, f x = g x) : a = b", "start": [1009, 1], "end": [1012, 74], "kind": "commanddeclaration"}, {"full_name": "T25Space", "code": "class T25Space (\u03b1 : Type u) [TopologicalSpace \u03b1] : Prop where\n  \n  t2_5 : \u2200 \u2983x y : \u03b1\u2984, x \u2260 y \u2192 Disjoint ((\ud835\udcdd x).lift' closure) ((\ud835\udcdd y).lift' closure)", "start": [1015, 1], "end": [1021, 83], "kind": "commanddeclaration"}, {"full_name": "disjoint_lift'_closure_nhds", "code": "@[simp]\ntheorem disjoint_lift'_closure_nhds [T25Space \u03b1] {x y : \u03b1} :\n    Disjoint ((\ud835\udcdd x).lift' closure) ((\ud835\udcdd y).lift' closure) \u2194 x \u2260 y", "start": [1024, 1], "end": [1027, 77], "kind": "commanddeclaration"}, {"full_name": "T25Space.t2Space", "code": "instance (priority := 100) T25Space.t2Space [T25Space \u03b1] : T2Space \u03b1 :=\n  t2Space_iff_disjoint_nhds.2 fun _ _ hne =>\n    (disjoint_lift'_closure_nhds.2 hne).mono (le_lift'_closure _) (le_lift'_closure _)", "start": [1031, 1], "end": [1033, 87], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_disjoint_closure", "code": "theorem exists_nhds_disjoint_closure [T25Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 s \u2208 \ud835\udcdd x, \u2203 t \u2208 \ud835\udcdd y, Disjoint (closure s) (closure t)", "start": [1036, 1], "end": [1039, 36], "kind": "commanddeclaration"}, {"full_name": "exists_open_nhds_disjoint_closure", "code": "theorem exists_open_nhds_disjoint_closure [T25Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 u : Set \u03b1,\n      x \u2208 u \u2227 IsOpen u \u2227 \u2203 v : Set \u03b1, y \u2208 v \u2227 IsOpen v \u2227 Disjoint (closure u) (closure v)", "start": [1042, 1], "end": [1047, 40], "kind": "commanddeclaration"}, {"full_name": "lim_eq", "code": "theorem lim_eq {a : \u03b1} [NeBot f] (h : f \u2264 \ud835\udcdd a) : @lim _ _ \u27e8a\u27e9 f = a", "start": [1062, 1], "end": [1063, 45], "kind": "commanddeclaration"}, {"full_name": "lim_eq_iff", "code": "theorem lim_eq_iff [NeBot f] (h : \u2203 a : \u03b1, f \u2264 nhds a) {a} : @lim _ _ \u27e8a\u27e9 f = a \u2194 f \u2264 \ud835\udcdd a", "start": [1067, 1], "end": [1068, 39], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.lim_eq_iff_le_nhds", "code": "theorem Ultrafilter.lim_eq_iff_le_nhds [CompactSpace \u03b1] {x : \u03b1} {F : Ultrafilter \u03b1} :\n    F.lim = x \u2194 \u2191F \u2264 \ud835\udcdd x", "start": [1072, 1], "end": [1074, 39], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_ultrafilter'", "code": "theorem isOpen_iff_ultrafilter' [CompactSpace \u03b1] (U : Set \u03b1) :\n    IsOpen U \u2194 \u2200 F : Ultrafilter \u03b1, F.lim \u2208 U \u2192 U \u2208 F.1", "start": [1078, 1], "end": [1084, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.limUnder_eq", "code": "theorem Filter.Tendsto.limUnder_eq {a : \u03b1} {f : Filter \u03b2} [NeBot f] {g : \u03b2 \u2192 \u03b1}\n    (h : Tendsto g f (\ud835\udcdd a)) : @limUnder _ _ _ \u27e8a\u27e9 f g = a", "start": [1087, 1], "end": [1089, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.limUnder_eq_iff", "code": "theorem Filter.limUnder_eq_iff {f : Filter \u03b2} [NeBot f] {g : \u03b2 \u2192 \u03b1} (h : \u2203 a, Tendsto g f (\ud835\udcdd a))\n    {a} : @limUnder _ _ _ \u27e8a\u27e9 f g = a \u2194 Tendsto g f (\ud835\udcdd a)", "start": [1092, 1], "end": [1094, 69], "kind": "commanddeclaration"}, {"full_name": "Continuous.limUnder_eq", "code": "theorem Continuous.limUnder_eq [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (h : Continuous f) (a : \u03b2) :\n    @limUnder _ _ _ \u27e8f a\u27e9 (\ud835\udcdd a) f = f a", "start": [1097, 1], "end": [1099, 28], "kind": "commanddeclaration"}, {"full_name": "lim_nhds", "code": "@[simp]\ntheorem lim_nhds (a : \u03b1) : @lim _ _ \u27e8a\u27e9 (\ud835\udcdd a) = a", "start": [1102, 1], "end": [1104, 16], "kind": "commanddeclaration"}, {"full_name": "limUnder_nhds_id", "code": "@[simp]\ntheorem limUnder_nhds_id (a : \u03b1) : @limUnder _ _ _ \u27e8a\u27e9 (\ud835\udcdd a) id = a", "start": [1108, 1], "end": [1110, 13], "kind": "commanddeclaration"}, {"full_name": "lim_nhdsWithin", "code": "@[simp]\ntheorem lim_nhdsWithin {a : \u03b1} {s : Set \u03b1} (h : a \u2208 closure s) : @lim _ _ \u27e8a\u27e9 (\ud835\udcdd[s] a) = a", "start": [1113, 1], "end": [1116, 21], "kind": "commanddeclaration"}, {"full_name": "limUnder_nhdsWithin_id", "code": "@[simp]\ntheorem limUnder_nhdsWithin_id {a : \u03b1} {s : Set \u03b1} (h : a \u2208 closure s) :\n    @limUnder _ _ _ \u27e8a\u27e9 (\ud835\udcdd[s] a) id = a", "start": [1120, 1], "end": [1123, 19], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.toT2Space", "code": "instance (priority := 100) DiscreteTopology.toT2Space {\u03b1 : Type*} [TopologicalSpace \u03b1]\n    [DiscreteTopology \u03b1] : T2Space \u03b1 :=\n  \u27e8fun x y h => \u27e8{x}, {y}, isOpen_discrete _, isOpen_discrete _, rfl, rfl, disjoint_singleton.2 h\u27e9\u27e9", "start": [1146, 1], "end": [1148, 100], "kind": "commanddeclaration"}, {"full_name": "separated_by_continuous", "code": "theorem separated_by_continuous {\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) {x y : \u03b1} (h : f x \u2260 f y) :\n    \u2203 u v : Set \u03b1, IsOpen u \u2227 IsOpen v \u2227 x \u2208 u \u2227 y \u2208 v \u2227 Disjoint u v", "start": [1151, 1], "end": [1155, 76], "kind": "commanddeclaration"}, {"full_name": "separated_by_openEmbedding", "code": "theorem separated_by_openEmbedding {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [T2Space \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : OpenEmbedding f) {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 u v : Set \u03b2, IsOpen u \u2227 IsOpen v \u2227 f x \u2208 u \u2227 f y \u2208 v \u2227 Disjoint u v", "start": [1158, 1], "end": [1163, 66], "kind": "commanddeclaration"}, {"full_name": "Prod.t2Space", "code": "instance Prod.t2Space {\u03b1 : Type*} {\u03b2 : Type*} [TopologicalSpace \u03b1] [T2Space \u03b1]\n    [TopologicalSpace \u03b2] [T2Space \u03b2] : T2Space (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun _ _ h => Or.elim (not_and_or.mp (mt Prod.ext_iff.mpr h))\n    (fun h\u2081 => separated_by_continuous continuous_fst h\u2081) fun h\u2082 =>\n    separated_by_continuous continuous_snd h\u2082\u27e9", "start": [1169, 1], "end": [1173, 47], "kind": "commanddeclaration"}, {"full_name": "T2Space.of_injective_continuous", "code": "theorem T2Space.of_injective_continuous [TopologicalSpace \u03b2] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hinj : Injective f) (hc : Continuous f) : T2Space \u03b1", "start": [1175, 1], "end": [1179, 56], "kind": "commanddeclaration"}, {"full_name": "Embedding.t2Space", "code": "theorem Embedding.t2Space [TopologicalSpace \u03b2] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) :\n    T2Space \u03b1", "start": [1181, 1], "end": [1185, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.t2Space", "code": "instance Pi.t2Space {\u03b1 : Type*} {\u03b2 : \u03b1 \u2192 Type v} [\u2200 a, TopologicalSpace (\u03b2 a)]\n    [\u2200 a, T2Space (\u03b2 a)] : T2Space (\u2200 a, \u03b2 a) :=\n  \u27e8fun _ _ h =>\n    let \u27e8i, hi\u27e9 := not_forall.mp (mt funext h)\n    separated_by_continuous (continuous_apply i) hi\u27e9", "start": [1197, 1], "end": [1201, 53], "kind": "commanddeclaration"}, {"full_name": "Sigma.t2Space", "code": "instance Sigma.t2Space {\u03b9} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (\u03b1 i)] [\u2200 a, T2Space (\u03b1 a)] :\n    T2Space (\u03a3i, \u03b1 i) := by\n  constructor\n  rintro \u27e8i, x\u27e9 \u27e8j, y\u27e9 neq\n  rcases eq_or_ne i j with (rfl | h)\n  \u00b7 replace neq : x \u2260 y := ne_of_apply_ne _ neq\n    exact separated_by_openEmbedding openEmbedding_sigmaMk neq\n  \u00b7 let _ := (\u22a5 : TopologicalSpace \u03b9); have : DiscreteTopology \u03b9 := \u27e8rfl\u27e9\n    exact separated_by_continuous (continuous_def.2 fun u _ => isOpen_sigma_fst_preimage u) h", "start": [1204, 1], "end": [1212, 94], "kind": "commanddeclaration"}, {"full_name": "isClosed_eq", "code": "theorem isClosed_eq [T2Space \u03b1] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) :\n    IsClosed { x : \u03b2 | f x = g x }", "start": [1217, 1], "end": [1219, 65], "kind": "commanddeclaration"}, {"full_name": "isOpen_ne_fun", "code": "theorem isOpen_ne_fun [T2Space \u03b1] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) :\n    IsOpen { x : \u03b2 | f x \u2260 g x }", "start": [1222, 1], "end": [1224, 44], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.closure", "code": "protected theorem Set.EqOn.closure [T2Space \u03b1] {s : Set \u03b2} {f g : \u03b2 \u2192 \u03b1} (h : EqOn f g s)\n    (hf : Continuous f) (hg : Continuous g) : EqOn f g (closure s)", "start": [1227, 1], "end": [1231, 40], "kind": "commanddeclaration"}, {"full_name": "Continuous.ext_on", "code": "theorem Continuous.ext_on [T2Space \u03b1] {s : Set \u03b2} (hs : Dense s) {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) (h : EqOn f g s) : f = g", "start": [1234, 1], "end": [1237, 41], "kind": "commanddeclaration"}, {"full_name": "eqOn_closure\u2082'", "code": "theorem eqOn_closure\u2082' [T2Space \u03b1] {s : Set \u03b2} {t : Set \u03b3} {f g : \u03b2 \u2192 \u03b3 \u2192 \u03b1}\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 t, f x y = g x y) (hf\u2081 : \u2200 x, Continuous (f x))\n    (hf\u2082 : \u2200 y, Continuous fun x => f x y) (hg\u2081 : \u2200 x, Continuous (g x))\n    (hg\u2082 : \u2200 y, Continuous fun x => g x y) : \u2200 x \u2208 closure s, \u2200 y \u2208 closure t, f x y = g x y", "start": [1240, 1], "end": [1246, 60], "kind": "commanddeclaration"}, {"full_name": "eqOn_closure\u2082", "code": "theorem eqOn_closure\u2082 [T2Space \u03b1] {s : Set \u03b2} {t : Set \u03b3} {f g : \u03b2 \u2192 \u03b3 \u2192 \u03b1}\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 t, f x y = g x y) (hf : Continuous (uncurry f))\n    (hg : Continuous (uncurry g)) : \u2200 x \u2208 closure s, \u2200 y \u2208 closure t, f x y = g x y", "start": [1249, 1], "end": [1253, 83], "kind": "commanddeclaration"}, {"full_name": "Set.EqOn.of_subset_closure", "code": "theorem Set.EqOn.of_subset_closure [T2Space \u03b1] {s t : Set \u03b2} {f g : \u03b2 \u2192 \u03b1} (h : EqOn f g s)\n    (hf : ContinuousOn f t) (hg : ContinuousOn g t) (hst : s \u2286 t) (hts : t \u2286 closure s) :\n    EqOn f g t", "start": [1256, 1], "end": [1265, 97], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.closed_range", "code": "theorem Function.LeftInverse.closed_range [T2Space \u03b1] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : IsClosed (range g)", "start": [1268, 1], "end": [1272, 56], "kind": "commanddeclaration"}, {"full_name": "Function.LeftInverse.closedEmbedding", "code": "theorem Function.LeftInverse.closedEmbedding [T2Space \u03b1] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b1}\n    (h : Function.LeftInverse f g) (hf : Continuous f) (hg : Continuous g) : ClosedEmbedding g", "start": [1275, 1], "end": [1277, 44], "kind": "commanddeclaration"}, {"full_name": "isCompact_isCompact_separated", "code": "theorem isCompact_isCompact_separated [T2Space \u03b1] {s t : Set \u03b1} (hs : IsCompact s)\n    (ht : IsCompact t) (hst : Disjoint s t) : SeparatedNhds s t", "start": [1280, 1], "end": [1283, 72], "kind": "commanddeclaration"}, {"full_name": "finset_disjoint_finset_opens_of_t2", "code": "theorem finset_disjoint_finset_opens_of_t2 [T2Space \u03b1] (s t : Finset \u03b1) (h : Disjoint s t) :\n    SeparatedNhds (s : Set \u03b1) t", "start": [1288, 1], "end": [1291, 21], "kind": "commanddeclaration"}, {"full_name": "point_disjoint_finset_opens_of_t2", "code": "theorem point_disjoint_finset_opens_of_t2 [T2Space \u03b1] {x : \u03b1} {s : Finset \u03b1} (h : x \u2209 s) :\n    SeparatedNhds ({x} : Set \u03b1) s", "start": [1294, 1], "end": [1296, 97], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isClosed", "code": "theorem IsCompact.isClosed [T2Space \u03b1] {s : Set \u03b1} (hs : IsCompact s) : IsClosed s", "start": [1301, 1], "end": [1306, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.coclosedCompact_eq_cocompact", "code": "@[simp]\ntheorem Filter.coclosedCompact_eq_cocompact [T2Space \u03b1] : coclosedCompact \u03b1 = cocompact \u03b1", "start": [1309, 1], "end": [1312, 56], "kind": "commanddeclaration"}, {"full_name": "Bornology.relativelyCompact_eq_inCompact", "code": "@[simp]\ntheorem Bornology.relativelyCompact_eq_inCompact [T2Space \u03b1] :\n    Bornology.relativelyCompact \u03b1 = Bornology.inCompact \u03b1", "start": [1315, 1], "end": [1318, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.preimage_continuous", "code": "theorem IsCompact.preimage_continuous [CompactSpace \u03b1] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2}\n    (hs : IsCompact s) (hf : Continuous f) : IsCompact (f \u207b\u00b9' s)", "start": [1321, 1], "end": [1323, 38], "kind": "commanddeclaration"}, {"full_name": "exists_subset_nhds_of_isCompact", "code": "theorem exists_subset_nhds_of_isCompact [T2Space \u03b1] {\u03b9 : Type*} [Nonempty \u03b9] {V : \u03b9 \u2192 Set \u03b1}\n    (hV : Directed (\u00b7 \u2287 \u00b7) V) (hV_cpct : \u2200 i, IsCompact (V i)) {U : Set \u03b1}\n    (hU : \u2200 x \u2208 \u22c2 i, V i, U \u2208 \ud835\udcdd x) : \u2203 i, V i \u2286 U", "start": [1325, 1], "end": [1332, 81], "kind": "commanddeclaration"}, {"full_name": "CompactExhaustion.isClosed", "code": "theorem CompactExhaustion.isClosed [T2Space \u03b1] (K : CompactExhaustion \u03b1) (n : \u2115) : IsClosed (K n)", "start": [1335, 1], "end": [1336, 27], "kind": "commanddeclaration"}, {"full_name": "IsCompact.inter", "code": "theorem IsCompact.inter [T2Space \u03b1] {s t : Set \u03b1} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s \u2229 t)", "start": [1339, 1], "end": [1341, 32], "kind": "commanddeclaration"}, {"full_name": "isCompact_closure_of_subset_compact", "code": "theorem isCompact_closure_of_subset_compact [T2Space \u03b1] {s t : Set \u03b1} (ht : IsCompact t)\n    (h : s \u2286 t) : IsCompact (closure s)", "start": [1344, 1], "end": [1346, 73], "kind": "commanddeclaration"}, {"full_name": "exists_compact_superset_iff", "code": "@[simp]\ntheorem exists_compact_superset_iff [T2Space \u03b1] {s : Set \u03b1} :\n    (\u2203 K, IsCompact K \u2227 s \u2286 K) \u2194 IsCompact (closure s)", "start": [1349, 1], "end": [1353, 36], "kind": "commanddeclaration"}, {"full_name": "image_closure_of_isCompact", "code": "theorem image_closure_of_isCompact [T2Space \u03b2] {s : Set \u03b1} (hs : IsCompact (closure s)) {f : \u03b1 \u2192 \u03b2}\n    (hf : ContinuousOn f (closure s)) : f '' closure s = closure (f '' s)", "start": [1356, 1], "end": [1359, 91], "kind": "commanddeclaration"}, {"full_name": "IsCompact.binary_compact_cover", "code": "theorem IsCompact.binary_compact_cover [T2Space \u03b1] {K U V : Set \u03b1} (hK : IsCompact K)\n    (hU : IsOpen U) (hV : IsOpen V) (h2K : K \u2286 U \u222a V) :\n    \u2203 K\u2081 K\u2082 : Set \u03b1, IsCompact K\u2081 \u2227 IsCompact K\u2082 \u2227 K\u2081 \u2286 U \u2227 K\u2082 \u2286 V \u2227 K = K\u2081 \u222a K\u2082", "start": [1362, 1], "end": [1371, 50], "kind": "commanddeclaration"}, {"full_name": "Continuous.isClosedMap", "code": "protected theorem Continuous.isClosedMap [CompactSpace \u03b1] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) : IsClosedMap f", "start": [1374, 1], "end": [1376, 87], "kind": "commanddeclaration"}, {"full_name": "Continuous.closedEmbedding", "code": "theorem Continuous.closedEmbedding [CompactSpace \u03b1] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2} (h : Continuous f)\n    (hf : Function.Injective f) : ClosedEmbedding f", "start": [1379, 1], "end": [1382, 68], "kind": "commanddeclaration"}, {"full_name": "QuotientMap.of_surjective_continuous", "code": "theorem QuotientMap.of_surjective_continuous [CompactSpace \u03b1] [T2Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hsurj : Surjective f) (hcont : Continuous f) : QuotientMap f", "start": [1385, 1], "end": [1388, 47], "kind": "commanddeclaration"}, {"full_name": "IsCompact.finite_compact_cover", "code": "theorem IsCompact.finite_compact_cover [T2Space \u03b1] {s : Set \u03b1} (hs : IsCompact s) {\u03b9} (t : Finset \u03b9)\n    (U : \u03b9 \u2192 Set \u03b1) (hU : \u2200 i \u2208 t, IsOpen (U i)) (hsC : s \u2286 \u22c3 i \u2208 t, U i) :\n    \u2203 K : \u03b9 \u2192 Set \u03b1, (\u2200 i, IsCompact (K i)) \u2227 (\u2200 i, K i \u2286 U i) \u2227 s = \u22c3 i \u2208 t, K i", "start": [1395, 1], "end": [1417, 56], "kind": "commanddeclaration"}, {"full_name": "WeaklyLocallyCompactSpace.locallyCompactSpace", "code": "instance WeaklyLocallyCompactSpace.locallyCompactSpace [WeaklyLocallyCompactSpace \u03b1] [T2Space \u03b1] :\n    LocallyCompactSpace \u03b1 :=\n  \u27e8fun x _n hn =>\n    let \u27e8_u, un, uo, xu\u27e9 := mem_nhds_iff.mp hn\n    let \u27e8k, kc, kx\u27e9 := exists_compact_mem_nhds x\n    let \u27e8v, w, vo, wo, xv, kuw, vw\u27e9 :=\n      isCompact_isCompact_separated isCompact_singleton (kc.diff uo)\n        (disjoint_singleton_left.2 fun h => h.2 xu)\n    have wn : w\u1d9c \u2208 \ud835\udcdd x :=\n      mem_nhds_iff.mpr \u27e8v, vw.subset_compl_right, vo, singleton_subset_iff.mp xv\u27e9\n    \u27e8k \\ w, Filter.inter_mem kx wn, Subset.trans (diff_subset_comm.mp kuw) un, kc.diff wo\u27e9\u27e9", "start": [1423, 1], "end": [1438, 92], "kind": "commanddeclaration"}, {"full_name": "locally_compact_of_compact", "code": "@[deprecated WeaklyLocallyCompactSpace.locallyCompactSpace]\ntheorem locally_compact_of_compact [T2Space \u03b1] [CompactSpace \u03b1] :\n    LocallyCompactSpace \u03b1", "start": [1441, 1], "end": [1444, 16], "kind": "commanddeclaration"}, {"full_name": "exists_open_superset_and_isCompact_closure", "code": "theorem exists_open_superset_and_isCompact_closure [WeaklyLocallyCompactSpace \u03b1] [T2Space \u03b1]\n    {K : Set \u03b1} (hK : IsCompact K) : \u2203 V, IsOpen V \u2227 K \u2286 V \u2227 IsCompact (closure V)", "start": [1447, 1], "end": [1453, 61], "kind": "commanddeclaration"}, {"full_name": "exists_open_with_compact_closure", "code": "theorem exists_open_with_compact_closure [WeaklyLocallyCompactSpace \u03b1] [T2Space \u03b1] (x : \u03b1) :\n    \u2203 U : Set \u03b1, IsOpen U \u2227 x \u2208 U \u2227 IsCompact (closure U)", "start": [1456, 1], "end": [1461, 73], "kind": "commanddeclaration"}, {"full_name": "exists_open_between_and_isCompact_closure", "code": "theorem exists_open_between_and_isCompact_closure [LocallyCompactSpace \u03b1] [T2Space \u03b1] {K U : Set \u03b1}\n    (hK : IsCompact K) (hU : IsOpen U) (hKU : K \u2286 U) :\n    \u2203 V, IsOpen V \u2227 K \u2286 V \u2227 closure V \u2286 U \u2227 IsCompact (closure V)", "start": [1464, 1], "end": [1473, 62], "kind": "commanddeclaration"}, {"full_name": "isPreirreducible_iff_subsingleton", "code": "theorem isPreirreducible_iff_subsingleton [T2Space \u03b1] {S : Set \u03b1} :\n    IsPreirreducible S \u2194 S.Subsingleton", "start": [1476, 1], "end": [1481, 97], "kind": "commanddeclaration"}, {"full_name": "IsPreirreducible.subsingleton", "code": "protected lemma IsPreirreducible.subsingleton [T2Space \u03b1] {S : Set \u03b1} (h : IsPreirreducible S) :\n    S.Subsingleton :=\n  isPreirreducible_iff_subsingleton.1 h", "start": [1485, 1], "end": [1487, 40], "kind": "mathlibtacticlemma"}, {"full_name": "isIrreducible_iff_singleton", "code": "theorem isIrreducible_iff_singleton [T2Space \u03b1] {S : Set \u03b1} : IsIrreducible S \u2194 \u2203 x, S = {x}", "start": [1490, 1], "end": [1492, 51], "kind": "commanddeclaration"}, {"full_name": "not_preirreducible_nontrivial_t2", "code": "theorem not_preirreducible_nontrivial_t2 (\u03b1) [TopologicalSpace \u03b1] [PreirreducibleSpace \u03b1]\n    [Nontrivial \u03b1] [T2Space \u03b1] : False", "start": [1495, 1], "end": [1498, 99], "kind": "commanddeclaration"}, {"full_name": "RegularSpace", "code": "@[mk_iff regularSpace_iff]\nclass RegularSpace (X : Type u) [TopologicalSpace X] : Prop where\n  \n  regular : \u2200 {s : Set X} {a}, IsClosed s \u2192 a \u2209 s \u2192 Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd a)", "start": [1505, 1], "end": [1512, 74], "kind": "commanddeclaration"}, {"full_name": "regularSpace_TFAE", "code": "theorem regularSpace_TFAE (X : Type u) [ TopologicalSpace X ] :\n    List.TFAE [RegularSpace X,\n      \u2200 (s : Set X) a, a \u2209 closure s \u2192 Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd a),\n      \u2200 (a : X) (s : Set X), Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd a) \u2194 a \u2209 closure s,\n      \u2200 (a : X) (s : Set X), s \u2208 \ud835\udcdd a \u2192 \u2203 t \u2208 \ud835\udcdd a, IsClosed t \u2227 t \u2286 s,\n      \u2200 a : X, (\ud835\udcdd a).lift' closure \u2264 \ud835\udcdd a,\n      \u2200 a : X , (\ud835\udcdd a).lift' closure = \ud835\udcdd a]", "start": [1515, 1], "end": [1546, 14], "kind": "commanddeclaration"}, {"full_name": "RegularSpace.ofLift'_closure", "code": "theorem RegularSpace.ofLift'_closure (h : \u2200 a : \u03b1, (\ud835\udcdd a).lift' closure = \ud835\udcdd a) : RegularSpace \u03b1", "start": [1549, 1], "end": [1550, 44], "kind": "commanddeclaration"}, {"full_name": "RegularSpace.ofBasis", "code": "theorem RegularSpace.ofBasis {\u03b9 : \u03b1 \u2192 Sort*} {p : \u2200 a, \u03b9 a \u2192 Prop} {s : \u2200 a, \u03b9 a \u2192 Set \u03b1}\n    (h\u2081 : \u2200 a, (\ud835\udcdd a).HasBasis (p a) (s a)) (h\u2082 : \u2200 a i, p a i \u2192 IsClosed (s a i)) :\n    RegularSpace \u03b1", "start": [1553, 1], "end": [1556, 76], "kind": "commanddeclaration"}, {"full_name": "RegularSpace.ofExistsMemNhdsIsClosedSubset", "code": "theorem RegularSpace.ofExistsMemNhdsIsClosedSubset\n    (h : \u2200 (a : \u03b1), \u2200 s \u2208 \ud835\udcdd a, \u2203 t \u2208 \ud835\udcdd a, IsClosed t \u2227 t \u2286 s) : RegularSpace \u03b1", "start": [1559, 1], "end": [1561, 44], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhdsSet_nhds", "code": "theorem disjoint_nhdsSet_nhds : Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd a) \u2194 a \u2209 closure s", "start": [1566, 1], "end": [1568, 21], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_nhdsSet", "code": "theorem disjoint_nhds_nhdsSet : Disjoint (\ud835\udcdd a) (\ud835\udcdd\u02e2 s) \u2194 a \u2209 closure s", "start": [1571, 1], "end": [1572, 44], "kind": "commanddeclaration"}, {"full_name": "exists_mem_nhds_isClosed_subset", "code": "theorem exists_mem_nhds_isClosed_subset {a : \u03b1} {s : Set \u03b1} (h : s \u2208 \ud835\udcdd a) :\n    \u2203 t \u2208 \ud835\udcdd a, IsClosed t \u2227 t \u2286 s", "start": [1575, 1], "end": [1578, 24], "kind": "commanddeclaration"}, {"full_name": "closed_nhds_basis", "code": "theorem closed_nhds_basis (a : \u03b1) : (\ud835\udcdd a).HasBasis (fun s : Set \u03b1 => s \u2208 \ud835\udcdd a \u2227 IsClosed s) id", "start": [1581, 1], "end": [1582, 59], "kind": "commanddeclaration"}, {"full_name": "lift'_nhds_closure", "code": "theorem lift'_nhds_closure (a : \u03b1) : (\ud835\udcdd a).lift' closure = \ud835\udcdd a", "start": [1585, 1], "end": [1586, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.nhds_closure", "code": "theorem Filter.HasBasis.nhds_closure {\u03b9 : Sort*} {a : \u03b1} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd a).HasBasis p s) : (\ud835\udcdd a).HasBasis p fun i => closure (s i)", "start": [1589, 1], "end": [1591, 41], "kind": "commanddeclaration"}, {"full_name": "hasBasis_nhds_closure", "code": "theorem hasBasis_nhds_closure (a : \u03b1) : (\ud835\udcdd a).HasBasis (fun s => s \u2208 \ud835\udcdd a) closure", "start": [1594, 1], "end": [1595, 32], "kind": "commanddeclaration"}, {"full_name": "hasBasis_opens_closure", "code": "theorem hasBasis_opens_closure (a : \u03b1) : (\ud835\udcdd a).HasBasis (fun s => a \u2208 s \u2227 IsOpen s) closure", "start": [1598, 1], "end": [1599, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.nhds_basis_closure", "code": "theorem TopologicalSpace.IsTopologicalBasis.nhds_basis_closure {B : Set (Set \u03b1)}\n    (hB : IsTopologicalBasis B) (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun s : Set \u03b1 => a \u2208 s \u2227 s \u2208 B) closure", "start": [1602, 1], "end": [1605, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsTopologicalBasis.exists_closure_subset", "code": "theorem TopologicalSpace.IsTopologicalBasis.exists_closure_subset {B : Set (Set \u03b1)}\n    (hB : IsTopologicalBasis B) {a : \u03b1} {s : Set \u03b1} (h : s \u2208 \ud835\udcdd a) :\n    \u2203 t \u2208 B, a \u2208 t \u2227 closure t \u2286 s", "start": [1608, 1], "end": [1611, 87], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_nhds_iff_not_specializes", "code": "theorem disjoint_nhds_nhds_iff_not_specializes {a b : \u03b1} : Disjoint (\ud835\udcdd a) (\ud835\udcdd b) \u2194 \u00aca \u2933 b", "start": [1614, 1], "end": [1615, 79], "kind": "commanddeclaration"}, {"full_name": "specializes_comm", "code": "theorem specializes_comm {a b : \u03b1} : a \u2933 b \u2194 b \u2933 a", "start": [1618, 1], "end": [1619, 90], "kind": "commanddeclaration"}, {"full_name": "Specializes.symm", "code": "alias \u27e8Specializes.symm, _\u27e9 := specializes_comm", "start": [1622, 1], "end": [1622, 48], "kind": "stdtacticaliasaliaslr"}, {"full_name": "specializes_iff_inseparable", "code": "theorem specializes_iff_inseparable {a b : \u03b1} : a \u2933 b \u2194 Inseparable a b", "start": [1625, 1], "end": [1626, 41], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_specializes", "code": "theorem isClosed_setOf_specializes : IsClosed { p : \u03b1 \u00d7 \u03b1 | p.1 \u2933 p.2 }", "start": [1629, 1], "end": [1631, 37], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_inseparable", "code": "theorem isClosed_setOf_inseparable : IsClosed { p : \u03b1 \u00d7 \u03b1 | Inseparable p.1 p.2 }", "start": [1634, 1], "end": [1635, 72], "kind": "commanddeclaration"}, {"full_name": "Inducing.regularSpace", "code": "protected theorem Inducing.regularSpace [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : Inducing f) :\n    RegularSpace \u03b2", "start": [1638, 1], "end": [1642, 55], "kind": "commanddeclaration"}, {"full_name": "regularSpace_induced", "code": "theorem regularSpace_induced (f : \u03b2 \u2192 \u03b1) : @RegularSpace \u03b2 (induced f \u2039_\u203a)", "start": [1645, 1], "end": [1647, 30], "kind": "commanddeclaration"}, {"full_name": "regularSpace_sInf", "code": "theorem regularSpace_sInf {X} {T : Set (TopologicalSpace X)} (h : \u2200 t \u2208 T, @RegularSpace X t) :\n    @RegularSpace X (sInf T)", "start": [1650, 1], "end": [1661, 45], "kind": "commanddeclaration"}, {"full_name": "regularSpace_iInf", "code": "theorem regularSpace_iInf {\u03b9 X} {t : \u03b9 \u2192 TopologicalSpace X} (h : \u2200 i, @RegularSpace X (t i)) :\n    @RegularSpace X (iInf t)", "start": [1664, 1], "end": [1666, 46], "kind": "commanddeclaration"}, {"full_name": "RegularSpace.inf", "code": "theorem RegularSpace.inf {X} {t\u2081 t\u2082 : TopologicalSpace X} (h\u2081 : @RegularSpace X t\u2081)\n    (h\u2082 : @RegularSpace X t\u2082) : @RegularSpace X (t\u2081 \u2293 t\u2082)", "start": [1669, 1], "end": [1672, 56], "kind": "commanddeclaration"}, {"full_name": "T3Space", "code": "class T3Space (\u03b1 : Type u) [TopologicalSpace \u03b1] extends T0Space \u03b1, RegularSpace \u03b1 : Prop", "start": [1689, 1], "end": [1691, 89], "kind": "commanddeclaration"}, {"full_name": "T3Space.t25Space", "code": "instance (priority := 100) T3Space.t25Space [T3Space \u03b1] : T25Space \u03b1 := by\n  refine' \u27e8fun x y hne => _\u27e9\n  rw [lift'_nhds_closure, lift'_nhds_closure]\n  have : x \u2209 closure {y} \u2228 y \u2209 closure {x} :=\n    (t0Space_iff_or_not_mem_closure \u03b1).mp inferInstance x y hne\n  simp only [\u2190 disjoint_nhds_nhdsSet, nhdsSet_singleton] at this\n  exact this.elim id fun h => h.symm", "start": [1697, 1], "end": [1703, 37], "kind": "commanddeclaration"}, {"full_name": "Embedding.t3Space", "code": "protected theorem Embedding.t3Space [TopologicalSpace \u03b2] [T3Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Embedding f) : T3Space \u03b1", "start": [1706, 1], "end": [1709, 51], "kind": "commanddeclaration"}, {"full_name": "Subtype.t3Space", "code": "instance Subtype.t3Space [T3Space \u03b1] {p : \u03b1 \u2192 Prop} : T3Space (Subtype p) :=\n  embedding_subtype_val.t3Space", "start": [1712, 1], "end": [1713, 32], "kind": "commanddeclaration"}, {"full_name": "disjoint_nested_nhds", "code": "theorem disjoint_nested_nhds [T3Space \u03b1] {x y : \u03b1} (h : x \u2260 y) :\n    \u2203 U\u2081 \u2208 \ud835\udcdd x, \u2203 V\u2081 \u2208 \ud835\udcdd x, \u2203 U\u2082 \u2208 \ud835\udcdd y, \u2203 V\u2082 \u2208 \ud835\udcdd y,\n      IsClosed V\u2081 \u2227 IsClosed V\u2082 \u2227 IsOpen U\u2081 \u2227 IsOpen U\u2082 \u2227 V\u2081 \u2286 U\u2081 \u2227 V\u2082 \u2286 U\u2082 \u2227 Disjoint U\u2081 U\u2082", "start": [1721, 1], "end": [1730, 51], "kind": "commanddeclaration"}, {"full_name": "NormalSpace", "code": "class NormalSpace (X : Type u) [TopologicalSpace X] : Prop where\n  \n  normal : \u2200 s t : Set X, IsClosed s \u2192 IsClosed t \u2192 Disjoint s t \u2192 SeparatedNhds s t", "start": [1746, 1], "end": [1750, 85], "kind": "commanddeclaration"}, {"full_name": "normal_separation", "code": "theorem normal_separation [NormalSpace \u03b1] {s t : Set \u03b1} (H1 : IsClosed s) (H2 : IsClosed t)\n    (H3 : Disjoint s t) : SeparatedNhds s t", "start": [1752, 1], "end": [1754, 34], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhdsSet_nhdsSet", "code": "theorem disjoint_nhdsSet_nhdsSet [NormalSpace \u03b1] {s t : Set \u03b1} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd\u02e2 t)", "start": [1757, 1], "end": [1759, 48], "kind": "commanddeclaration"}, {"full_name": "normal_exists_closure_subset", "code": "theorem normal_exists_closure_subset [NormalSpace \u03b1] {s t : Set \u03b1} (hs : IsClosed s) (ht : IsOpen t)\n    (hst : s \u2286 t) : \u2203 u, IsOpen u \u2227 s \u2286 u \u2227 closure u \u2286 t", "start": [1761, 1], "end": [1768, 49], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.normalSpace", "code": "protected theorem ClosedEmbedding.normalSpace [TopologicalSpace \u03b2] [NormalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : ClosedEmbedding f) : NormalSpace \u03b1 where", "start": [1771, 1], "end": [1778, 98], "kind": "commanddeclaration"}, {"full_name": "NormalSpace.of_regularSpace_secondCountableTopology", "code": "instance (priority := 100) NormalSpace.of_regularSpace_secondCountableTopology\n    [RegularSpace \u03b1] [SecondCountableTopology \u03b1] : NormalSpace \u03b1 := by\n  have key : \u2200 {s t : Set \u03b1}, IsClosed t \u2192 Disjoint s t \u2192\n    \u2203 U : Set (countableBasis \u03b1), (s \u2286 \u22c3 u \u2208 U, \u2191u) \u2227 (\u2200 u \u2208 U, Disjoint (closure \u2191u) t) \u2227\n      \u2200 n : \u2115, IsClosed (\u22c3 (u \u2208 U) (_ : Encodable.encode u \u2264 n), closure (u : Set \u03b1)) := by\n    intro s t hc hd\n    rw [disjoint_left] at hd\n    have : \u2200 x \u2208 s, \u2203 U \u2208 countableBasis \u03b1, x \u2208 U \u2227 Disjoint (closure U) t := by\n      intro x hx\n      rcases (isBasis_countableBasis \u03b1).exists_closure_subset (hc.compl_mem_nhds (hd hx))\n        with \u27e8u, hu, hxu, hut\u27e9\n      exact \u27e8u, hu, hxu, disjoint_left.2 hut\u27e9\n    choose! U hu hxu hd using this\n    set V : s \u2192 countableBasis \u03b1 := MapsTo.restrict _ _ _ hu\n    refine' \u27e8range V, _, forall_range_iff.2 <| Subtype.forall.2 hd, fun n => _\u27e9\n    \u00b7 rw [biUnion_range]\n      exact fun x hx => mem_iUnion.2 \u27e8\u27e8x, hx\u27e9, hxu x hx\u27e9\n    \u00b7 simp only [\u2190 iSup_eq_iUnion, iSup_and']\n      exact (((finite_le_nat n).preimage_embedding (Encodable.encode' _)).subset <|\n        inter_subset_right _ _).isClosed_biUnion fun u _ => isClosed_closure\n  refine' { normal := fun s t hs ht hd => _ }\n  rcases key ht hd with \u27e8U, hsU, hUd, hUc\u27e9\n  rcases key hs hd.symm with \u27e8V, htV, hVd, hVc\u27e9\n  refine \u27e8\u22c3 u \u2208 U, \u2191u \\ \u22c3 (v \u2208 V) (_ : Encodable.encode v \u2264 Encodable.encode u), closure \u2191v,\n    \u22c3 v \u2208 V, \u2191v \\ \u22c3 (u \u2208 U) (_ : Encodable.encode u \u2264 Encodable.encode v), closure \u2191u,\n    isOpen_biUnion fun u _ => (isOpen_of_mem_countableBasis u.2).sdiff (hVc _),\n    isOpen_biUnion fun v _ => (isOpen_of_mem_countableBasis v.2).sdiff (hUc _),\n    fun x hx => ?_, fun x hx => ?_, ?_\u27e9\n  \u00b7 rcases mem_iUnion\u2082.1 (hsU hx) with \u27e8u, huU, hxu\u27e9\n    refine' mem_biUnion huU \u27e8hxu, _\u27e9\n    simp only [mem_iUnion]\n    rintro \u27e8v, hvV, -, hxv\u27e9\n    exact (hVd v hvV).le_bot \u27e8hxv, hx\u27e9\n  \u00b7 rcases mem_iUnion\u2082.1 (htV hx) with \u27e8v, hvV, hxv\u27e9\n    refine' mem_biUnion hvV \u27e8hxv, _\u27e9\n    simp only [mem_iUnion]\n    rintro \u27e8u, huU, -, hxu\u27e9\n    exact (hUd u huU).le_bot \u27e8hxu, hx\u27e9\n  \u00b7 simp only [disjoint_left, mem_iUnion, mem_diff, not_exists, not_and, not_forall, not_not]\n    rintro a \u27e8u, huU, hau, haV\u27e9 v hvV hav\n    cases' le_total (Encodable.encode u) (Encodable.encode v) with hle hle\n    exacts [\u27e8u, huU, hle, subset_closure hau\u27e9, (haV _ hvV hle <| subset_closure hav).elim]", "start": [1780, 1], "end": [1822, 91], "kind": "commanddeclaration"}, {"full_name": "T4Space", "code": "class T4Space (\u03b1 : Type u) [TopologicalSpace \u03b1] extends T1Space \u03b1, NormalSpace \u03b1 : Prop", "start": [1829, 1], "end": [1830, 88], "kind": "commanddeclaration"}, {"full_name": "T4Space.t3Space", "code": "instance (priority := 100) T4Space.t3Space [T4Space \u03b1] : T3Space \u03b1 where\n  regular hs hxs := by simpa only [nhdsSet_singleton] using (normal_separation hs isClosed_singleton\n    (disjoint_singleton_right.mpr hxs)).disjoint_nhdsSet", "start": [1836, 1], "end": [1838, 57], "kind": "commanddeclaration"}, {"full_name": "T4Space.of_compactSpace_t2Space", "code": "instance (priority := 100) T4Space.of_compactSpace_t2Space [CompactSpace \u03b1] [T2Space \u03b1] :\n    T4Space \u03b1 where\n  normal _s _t hs ht := isCompact_isCompact_separated hs.isCompact ht.isCompact", "start": [1841, 1], "end": [1843, 80], "kind": "commanddeclaration"}, {"full_name": "ClosedEmbedding.t4Space", "code": "protected theorem ClosedEmbedding.t4Space [TopologicalSpace \u03b2] [T4Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : ClosedEmbedding f) : T4Space \u03b1 where", "start": [1846, 1], "end": [1850, 34], "kind": "commanddeclaration"}, {"full_name": "T5Space", "code": "class T5Space (\u03b1 : Type u) [TopologicalSpace \u03b1] extends T1Space \u03b1 : Prop where\n  \n  completely_normal :\n    \u2200 \u2983s t : Set \u03b1\u2984, Disjoint (closure s) t \u2192 Disjoint s (closure t) \u2192 Disjoint (\ud835\udcdd\u02e2 s) (\ud835\udcdd\u02e2 t)", "start": [1870, 1], "end": [1878, 94], "kind": "commanddeclaration"}, {"full_name": "Embedding.t5Space", "code": "theorem Embedding.t5Space [TopologicalSpace \u03b2] [T5Space \u03b2] {e : \u03b1 \u2192 \u03b2} (he : Embedding e) :\n    T5Space \u03b1", "start": [1883, 1], "end": [1892, 79], "kind": "commanddeclaration"}, {"full_name": "T5Space.toT4Space", "code": "instance (priority := 100) T5Space.toT4Space [T5Space \u03b1] : T4Space \u03b1 where\n  normal s t hs ht hd := separatedNhds_iff_disjoint.2 <|\n    completely_normal (by rwa [hs.closure_eq]) (by rwa [ht.closure_eq])", "start": [1900, 1], "end": [1903, 72], "kind": "commanddeclaration"}, {"full_name": "connectedComponent_eq_iInter_clopen", "code": "theorem connectedComponent_eq_iInter_clopen [T2Space \u03b1] [CompactSpace \u03b1] (x : \u03b1) :\n    connectedComponent x = \u22c2 Z : { Z : Set \u03b1 // IsClopen Z \u2227 x \u2208 Z }, Z", "start": [1923, 1], "end": [1976, 42], "kind": "commanddeclaration"}, {"full_name": "totallySeparatedSpace_of_t1_of_basis_clopen", "code": "theorem totallySeparatedSpace_of_t1_of_basis_clopen [T1Space \u03b1]\n    (h : IsTopologicalBasis { s : Set \u03b1 | IsClopen s }) : TotallySeparatedSpace \u03b1", "start": [1981, 1], "end": [1988, 26], "kind": "commanddeclaration"}, {"full_name": "compact_t2_tot_disc_iff_tot_sep", "code": "theorem compact_t2_tot_disc_iff_tot_sep : TotallyDisconnectedSpace \u03b1 \u2194 TotallySeparatedSpace \u03b1", "start": [1993, 1], "end": [2005, 24], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_clopen", "code": "theorem nhds_basis_clopen (x : \u03b1) : (\ud835\udcdd x).HasBasis (fun s : Set \u03b1 => x \u2208 s \u2227 IsClopen s) id", "start": [2013, 1], "end": [2034, 33], "kind": "commanddeclaration"}, {"full_name": "isTopologicalBasis_clopen", "code": "theorem isTopologicalBasis_clopen : IsTopologicalBasis { s : Set \u03b1 | IsClopen s }", "start": [2037, 1], "end": [2043, 8], "kind": "commanddeclaration"}, {"full_name": "compact_exists_clopen_in_open", "code": "theorem compact_exists_clopen_in_open {x : \u03b1} {U : Set \u03b1} (is_open : IsOpen U) (memU : x \u2208 U) :\n    \u2203 V : Set \u03b1, IsClopen V \u2227 x \u2208 V \u2227 V \u2286 U", "start": [2046, 1], "end": [2050, 67], "kind": "commanddeclaration"}, {"full_name": "loc_compact_Haus_tot_disc_of_zero_dim", "code": "theorem loc_compact_Haus_tot_disc_of_zero_dim [TotallyDisconnectedSpace H] :\n    IsTopologicalBasis { s : Set H | IsClopen s }", "start": [2059, 1], "end": [2087, 7], "kind": "commanddeclaration"}, {"full_name": "loc_compact_t2_tot_disc_iff_tot_sep", "code": "theorem loc_compact_t2_tot_disc_iff_tot_sep :\n    TotallyDisconnectedSpace H \u2194 TotallySeparatedSpace H", "start": [2091, 1], "end": [2098, 55], "kind": "commanddeclaration"}, {"full_name": "ConnectedComponents.t2", "code": "instance ConnectedComponents.t2 [T2Space \u03b1] [CompactSpace \u03b1] : T2Space (ConnectedComponents \u03b1) := by\n  refine \u27e8ConnectedComponents.surjective_coe.forall\u2082.2 fun a b ne => ?_\u27e9\n  rw [ConnectedComponents.coe_ne_coe] at ne\n  have h := connectedComponent_disjoint ne\n  rw [connectedComponent_eq_iInter_clopen b, disjoint_iff_inter_eq_empty] at h\n  obtain \u27e8U, V, hU, ha, hb, rfl\u27e9 : \u2203 (U : Set \u03b1) (V : Set (ConnectedComponents \u03b1)),\n      IsClopen U \u2227 connectedComponent a \u2229 U = \u2205 \u2227 connectedComponent b \u2286 U \u2227 (\u2191) \u207b\u00b9' V = U := by\n    have h :=\n      (isClosed_connectedComponent (\u03b1 := \u03b1)).isCompact.elim_finite_subfamily_closed\n        _ (fun Z : { Z : Set \u03b1 // IsClopen Z \u2227 b \u2208 Z } => Z.2.1.2) h\n    cases' h with fin_a ha\n    set U : Set \u03b1 := \u22c2 (i : { Z // IsClopen Z \u2227 b \u2208 Z }) (_ : i \u2208 fin_a), i\n    have hU : IsClopen U := isClopen_biInter_finset fun i _ => i.2.1\n    exact \u27e8U, (\u2191) '' U, hU, ha, subset_iInter\u2082 fun Z _ => Z.2.1.connectedComponent_subset Z.2.2,\n      (connectedComponents_preimage_image U).symm \u25b8 hU.biUnion_connectedComponent_eq\u27e9\n  rw [ConnectedComponents.quotientMap_coe.isClopen_preimage] at hU\n  refine' \u27e8V\u1d9c, V, hU.compl.isOpen, hU.isOpen, _, hb mem_connectedComponent, disjoint_compl_left\u27e9\n  exact fun h => flip Set.Nonempty.ne_empty ha \u27e8a, mem_connectedComponent, h\u27e9", "start": [2103, 1], "end": [2126, 78], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/Init.lean", "imports": ["lake-packages/aesop/Aesop.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Combinatorics/Quiver/Basic.lean", "imports": ["Mathlib/Tactic/Cases.lean", "Mathlib/Data/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver", "code": "class Quiver (V : Type u) where\n  \n  Hom : V \u2192 V \u2192 Sort v", "start": [36, 1], "end": [48, 23], "kind": "commanddeclaration"}, {"full_name": "Prefunctor", "code": "structure Prefunctor (V : Type u\u2081) [Quiver.{v\u2081} V] (W : Type u\u2082) [Quiver.{v\u2082} W] where\n  \n  obj : V \u2192 W\n  \n  map : \u2200 {X Y : V}, (X \u27f6 Y) \u2192 (obj X \u27f6 obj Y)", "start": [58, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mk_obj", "code": "lemma mk_obj [Quiver V] {obj : V \u2192 V} {map} {X : V} : (Prefunctor.mk obj map).obj X = obj X := rfl", "start": [74, 1], "end": [74, 99], "kind": "mathlibtacticlemma"}, {"full_name": "Prefunctor.mk_map", "code": "lemma mk_map [Quiver V] {obj : V \u2192 V} {map} {X Y : V} {f : X \u27f6 Y} :\n    (Prefunctor.mk obj map).map f = map f := rfl", "start": [75, 1], "end": [76, 49], "kind": "mathlibtacticlemma"}, {"full_name": "Prefunctor.ext", "code": "@[ext]\ntheorem ext {V : Type u} [Quiver.{v\u2081} V] {W : Type u\u2082} [Quiver.{v\u2082} W] {F G : Prefunctor V W}\n    (h_obj : \u2200 X, F.obj X = G.obj X)\n    (h_map : \u2200 (X Y : V) (f : X \u27f6 Y),\n      F.map f = Eq.recOn (h_obj Y).symm (Eq.recOn (h_obj X).symm (G.map f))) : F = G", "start": [78, 1], "end": [90, 26], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.id", "code": "@[simps]\ndef id (V : Type*) [Quiver V] : Prefunctor V V where\n  obj := fun X => X\n  map f := f", "start": [93, 1], "end": [97, 13], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.comp", "code": "@[simps, pp_dot]\ndef comp {U : Type*} [Quiver U] {V : Type*} [Quiver V] {W : Type*} [Quiver W]\n    (F : Prefunctor U V) (G : Prefunctor V W) : Prefunctor U W where\n  obj X := G.obj (F.obj X)\n  map f := G.map (F.map f)", "start": [105, 1], "end": [110, 27], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.comp_id", "code": "@[simp]\ntheorem comp_id {U V : Type*} [Quiver U] [Quiver V] (F : Prefunctor U V) :\n    F.comp (id _) = F", "start": [115, 1], "end": [117, 29], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.id_comp", "code": "@[simp]\ntheorem id_comp {U V : Type*} [Quiver U] [Quiver V] (F : Prefunctor U V) :\n    (id _).comp F = F", "start": [120, 1], "end": [122, 29], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.comp_assoc", "code": "@[simp]\ntheorem comp_assoc {U V W Z : Type*} [Quiver U] [Quiver V] [Quiver W] [Quiver Z]\n    (F : Prefunctor U V) (G : Prefunctor V W) (H : Prefunctor W Z) :\n    (F.comp G).comp H = F.comp (G.comp H)", "start": [125, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.opposite", "code": "instance opposite {V} [Quiver V] : Quiver V\u1d52\u1d56 :=\n  \u27e8fun a b => (unop b \u27f6 unop a)\u1d52\u1d56\u27e9", "start": [145, 1], "end": [147, 35], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.op", "code": "@[pp_dot]\ndef Hom.op {V} [Quiver V] {X Y : V} (f : X \u27f6 Y) : op Y \u27f6 op X := \u27e8f\u27e9", "start": [150, 1], "end": [152, 69], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.unop", "code": "@[pp_dot]\ndef Hom.unop {V} [Quiver V] {X Y : V\u1d52\u1d56} (f : X \u27f6 Y) : unop Y \u27f6 unop X := Opposite.unop f", "start": [155, 1], "end": [157, 89], "kind": "commanddeclaration"}, {"full_name": "Quiver.Empty", "code": "def Empty (V : Type u) : Type u := V", "start": [160, 1], "end": [163, 37], "kind": "commanddeclaration"}, {"full_name": "Quiver.emptyQuiver", "code": "instance emptyQuiver (V : Type u) : Quiver.{u} (Empty V) := \u27e8fun _ _ => PEmpty\u27e9", "start": [166, 1], "end": [166, 80], "kind": "commanddeclaration"}, {"full_name": "Quiver.empty_arrow", "code": "@[simp]\ntheorem empty_arrow {V : Type u} (a b : Empty V) : (a \u27f6 b) = PEmpty", "start": [169, 1], "end": [170, 75], "kind": "commanddeclaration"}, {"full_name": "Quiver.IsThin", "code": "@[reducible]\ndef IsThin (V : Type u) [Quiver V] : Prop := \u2200 a b : V, Subsingleton (a \u27f6 b)", "start": [173, 1], "end": [175, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Data/Subtype/Basic.lean", "imports": ["Mathlib/Init/Logic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Subtype.exists_of_subtype", "code": "theorem exists_of_subtype {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} : { x // p x } \u2192 \u2203 x, p x", "start": [21, 1], "end": [22, 21], "kind": "commanddeclaration"}, {"full_name": "Subtype.tag_irrelevant", "code": "theorem tag_irrelevant {a : \u03b1} (h1 h2 : p a) : mk a h1 = mk a h2", "start": [27, 1], "end": [28, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.ne_of_val_ne", "code": "theorem ne_of_val_ne {a1 a2 : { x // p x }} : val a1 \u2260 val a2 \u2192 a1 \u2260 a2", "start": [33, 1], "end": [34, 20], "kind": "commanddeclaration"}, {"full_name": "Subtype.inhabited", "code": "def Subtype.inhabited {\u03b1 : Type u} {p : \u03b1 \u2192 Prop} {a : \u03b1} (h : p a) : Inhabited { x // p x } :=\n  \u27e8\u27e8a, h\u27e9\u27e9", "start": [43, 1], "end": [45, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Submodule/Bilinear.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/LinearAlgebra/BilinearMap.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.map\u2082", "code": "def map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) : Submodule R P :=\n  \u2a06 s : p, q.map (f s)", "start": [44, 1], "end": [48, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.apply_mem_map\u2082", "code": "theorem apply_mem_map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) {m : M} {n : N} {p : Submodule R M}\n    {q : Submodule R N} (hm : m \u2208 p) (hn : n \u2208 q) : f m n \u2208 map\u2082 f p q", "start": [51, 1], "end": [53, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_le", "code": "theorem map\u2082_le {f : M \u2192\u2097[R] N \u2192\u2097[R] P} {p : Submodule R M} {q : Submodule R N}\n    {r : Submodule R P} : map\u2082 f p q \u2264 r \u2194 \u2200 m \u2208 p, \u2200 n \u2208 q, f m n \u2208 r", "start": [56, 1], "end": [59, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_span_span", "code": "theorem map\u2082_span_span (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : Set M) (t : Set N) :\n    map\u2082 f (span R s) (span R t) = span R (Set.image2 (fun m n => f m n) s t)", "start": [63, 1], "end": [77, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_bot_right", "code": "@[simp]\ntheorem map\u2082_bot_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) : map\u2082 f p \u22a5 = \u22a5", "start": [81, 1], "end": [86, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_bot_left", "code": "@[simp]\ntheorem map\u2082_bot_left (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (q : Submodule R N) : map\u2082 f \u22a5 q = \u22a5", "start": [89, 1], "end": [94, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_le_map\u2082", "code": "@[mono]\ntheorem map\u2082_le_map\u2082 {f : M \u2192\u2097[R] N \u2192\u2097[R] P} {p\u2081 p\u2082 : Submodule R M} {q\u2081 q\u2082 : Submodule R N}\n    (hp : p\u2081 \u2264 p\u2082) (hq : q\u2081 \u2264 q\u2082) : map\u2082 f p\u2081 q\u2081 \u2264 map\u2082 f p\u2082 q\u2082", "start": [97, 1], "end": [100, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_le_map\u2082_left", "code": "theorem map\u2082_le_map\u2082_left {f : M \u2192\u2097[R] N \u2192\u2097[R] P} {p\u2081 p\u2082 : Submodule R M} {q : Submodule R N}\n    (h : p\u2081 \u2264 p\u2082) : map\u2082 f p\u2081 q \u2264 map\u2082 f p\u2082 q", "start": [103, 1], "end": [105, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_le_map\u2082_right", "code": "theorem map\u2082_le_map\u2082_right {f : M \u2192\u2097[R] N \u2192\u2097[R] P} {p : Submodule R M} {q\u2081 q\u2082 : Submodule R N}\n    (h : q\u2081 \u2264 q\u2082) : map\u2082 f p q\u2081 \u2264 map\u2082 f p q\u2082", "start": [108, 1], "end": [110, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_sup_right", "code": "theorem map\u2082_sup_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q\u2081 q\u2082 : Submodule R N) :\n    map\u2082 f p (q\u2081 \u2294 q\u2082) = map\u2082 f p q\u2081 \u2294 map\u2082 f p q\u2082", "start": [113, 1], "end": [119, 80], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_sup_left", "code": "theorem map\u2082_sup_left (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p\u2081 p\u2082 : Submodule R M) (q : Submodule R N) :\n    map\u2082 f (p\u2081 \u2294 p\u2082) q = map\u2082 f p\u2081 q \u2294 map\u2082 f p\u2082 q", "start": [122, 1], "end": [130, 78], "kind": "commanddeclaration"}, {"full_name": "Submodule.image2_subset_map\u2082", "code": "theorem image2_subset_map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) :\n    Set.image2 (fun m n => f m n) (\u2191p : Set M) (\u2191q : Set N) \u2286 (\u2191(map\u2082 f p q) : Set P)", "start": [133, 1], "end": [136, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_eq_span_image2", "code": "theorem map\u2082_eq_span_image2 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) :\n    map\u2082 f p q = span R (Set.image2 (fun m n => f m n) (p : Set M) (q : Set N))", "start": [139, 1], "end": [141, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_flip", "code": "theorem map\u2082_flip (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : Submodule R M) (q : Submodule R N) :\n    map\u2082 f.flip q p = map\u2082 f p q", "start": [144, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_iSup_left", "code": "theorem map\u2082_iSup_left (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : \u03b9 \u2192 Submodule R M) (t : Submodule R N) :\n    map\u2082 f (\u2a06 i, s i) t = \u2a06 i, map\u2082 f (s i) t", "start": [150, 1], "end": [154, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_iSup_right", "code": "theorem map\u2082_iSup_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : Submodule R M) (t : \u03b9 \u2192 Submodule R N) :\n    map\u2082 f s (\u2a06 i, t i) = \u2a06 i, map\u2082 f s (t i)", "start": [157, 1], "end": [161, 83], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_span_singleton_eq_map", "code": "theorem map\u2082_span_singleton_eq_map (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) :\n    map\u2082 f (span R {m}) = map (f m)", "start": [164, 1], "end": [173, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.map\u2082_span_singleton_eq_map_flip", "code": "theorem map\u2082_span_singleton_eq_map_flip (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : Submodule R M) (n : N) :\n    map\u2082 f s (span R {n}) = map (f.flip n) s", "start": [176, 1], "end": [177, 96], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_restrictBilinear_eq_of_codisjoint", "code": "lemma LinearMap.ker_restrictBilinear_eq_of_codisjoint\n    {R M : Type*} [CommSemiring R] [AddCommMonoid M] [Module R M]\n    {p q : Submodule R M} (hpq : Codisjoint p q)\n    {B : M \u2192\u2097[R] M \u2192\u2097[R] R} (hB : \u2200 x \u2208 p, \u2200 y \u2208 q, B x y = 0) :\n    LinearMap.ker (p.restrictBilinear B) = (LinearMap.ker B).comap p.subtype := by\n  ext \u27e8z, hz\u27e9\n  simp only [LinearMap.mem_ker, Submodule.mem_comap, Submodule.coeSubtype]\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 ext w\n    obtain \u27e8x, hx, y, hy, rfl\u27e9 := Submodule.exists_add_eq_of_codisjoint hpq w\n    simpa [hB z hz y hy] using LinearMap.congr_fun h \u27e8x, hx\u27e9\n  \u00b7 ext \u27e8x, hx\u27e9\n    simpa using LinearMap.congr_fun h x", "start": [182, 1], "end": [194, 40], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Tactic/SuppressCompilation.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "elabSuppressCompilationDecl", "code": "def elabSuppressCompilationDecl : CommandElab := fun\n| `($[$doc?:docComment]? $(attrs?)? $(vis?)? $[noncomputable]? $(unsafe?)?\n    $(recKind?)? def $id $sig:optDeclSig $val:declVal $(term?)? $(decr?)?) => do\n  elabDeclaration <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(vis?)? noncomputable $(unsafe?)?\n    $(recKind?)? def $id $sig:optDeclSig $val:declVal $(term?)? $(decr?)?)\n| `($[$doc?:docComment]? $(attrs?)? $(vis?)? $[noncomputable]? $(unsafe?)?\n    $(recKind?)? def $id $sig:optDeclSig $val:declVal deriving $derivs,* $(term?)? $(decr?)?) => do\n  elabDeclaration <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(vis?)? noncomputable $(unsafe?)?\n    $(recKind?)? def $id $sig:optDeclSig $val:declVal deriving $derivs,* $(term?)? $(decr?)?)\n| `($[$doc?:docComment]? $(attrs?)? $(vis?)? $[noncomputable]? $(unsafe?)?\n    $(recKind?)? $(attrKind?)? instance $(prio?)? $(id?)? $sig:declSig $val:declVal $(term?)?) => do\n  elabDeclaration <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(vis?)? noncomputable $(unsafe?)?\n    $(recKind?)? $(attrKind?)? instance $(prio?)? $(id?)? $sig:declSig $val:declVal $(term?)?)\n| `($[$doc?:docComment]? $(attrs?)? $(vis?)? $[noncomputable]? $(unsafe?)?\n    $(recKind?)? example $sig:optDeclSig $val:declVal) => do\n  elabDeclaration <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(vis?)? noncomputable $(unsafe?)?\n    $(recKind?)? example $sig:optDeclSig $val:declVal)\n| `($[$doc?:docComment]? $(attrs?)? $(vis?)? $[noncomputable]? $(unsafe?)?\n    $(recKind?)? abbrev $id $sig:optDeclSig $val:declVal $(term?)? $(decr?)?) => do\n  elabDeclaration <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(vis?)? noncomputable $(unsafe?)?\n    $(recKind?)? abbrev $id $sig:optDeclSig $val:declVal $(term?)? $(decr?)?)\n| _ => throwUnsupportedSyntax", "start": [26, 1], "end": [50, 30], "kind": "commanddeclaration"}, {"full_name": "expandSuppressCompilationNotation", "code": "def expandSuppressCompilationNotation : Macro := fun\n| `($[$doc?:docComment]? $(attrs?)? $(attrKind)? notation\n    $(prec?)? $(name?)? $(prio?)? $items* => $v) => do\n  let defn \u2190 expandNotation <| \u2190 `($[$doc?:docComment]? $(attrs?)? $(attrKind)? notation\n    $(prec?)? $(name?)? $(prio?)? $items* => $v)\n  `(unsuppress_compilation in $(\u27e8defn\u27e9):command)\n| _ => Macro.throwUnsupported", "start": [56, 1], "end": [64, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Hom/CompleteLattice.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Order/Hom/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "sSupHom", "code": "structure sSupHom (\u03b1 \u03b2 : Type*) [SupSet \u03b1] [SupSet \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_sSup' (s : Set \u03b1) : toFun (sSup s) = sSup (toFun '' s)", "start": [48, 1], "end": [53, 61], "kind": "commanddeclaration"}, {"full_name": "sInfHom", "code": "structure sInfHom (\u03b1 \u03b2 : Type*) [InfSet \u03b1] [InfSet \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  map_sInf' (s : Set \u03b1) : toFun (sInf s) = sInf (toFun '' s)", "start": [56, 1], "end": [61, 61], "kind": "commanddeclaration"}, {"full_name": "FrameHom", "code": "structure FrameHom (\u03b1 \u03b2 : Type*) [CompleteLattice \u03b1] [CompleteLattice \u03b2] extends\n  InfTopHom \u03b1 \u03b2 where\n  \n  map_sSup' (s : Set \u03b1) : toFun (sSup s) = sSup (toFun '' s)", "start": [64, 1], "end": [69, 61], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom", "code": "structure CompleteLatticeHom (\u03b1 \u03b2 : Type*) [CompleteLattice \u03b1] [CompleteLattice \u03b2] extends\n  sInfHom \u03b1 \u03b2 where\n  \n  map_sSup' (s : Set \u03b1) : toFun (sSup s) = sSup (toFun '' s)", "start": [73, 1], "end": [77, 61], "kind": "commanddeclaration"}, {"full_name": "sSupHomClass", "code": "class sSupHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [SupSet \u03b1] [SupSet \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_sSup (f : F) (s : Set \u03b1) : f (sSup s) = sSup (f '' s)", "start": [83, 1], "end": [89, 60], "kind": "commanddeclaration"}, {"full_name": "sInfHomClass", "code": "class sInfHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [InfSet \u03b1] [InfSet \u03b2] extends\n  FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_sInf (f : F) (s : Set \u03b1) : f (sInf s) = sInf (f '' s)", "start": [92, 1], "end": [98, 60], "kind": "commanddeclaration"}, {"full_name": "FrameHomClass", "code": "class FrameHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [CompleteLattice \u03b1]\n  [CompleteLattice \u03b2] extends InfTopHomClass F \u03b1 \u03b2 where\n  \n  map_sSup (f : F) (s : Set \u03b1) : f (sSup s) = sSup (f '' s)", "start": [101, 1], "end": [107, 60], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHomClass", "code": "class CompleteLatticeHomClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [CompleteLattice \u03b1]\n  [CompleteLattice \u03b2] extends sInfHomClass F \u03b1 \u03b2 where\n  \n  map_sSup (f : F) (s : Set \u03b1) : f (sSup s) = sSup (f '' s)", "start": [110, 1], "end": [117, 60], "kind": "commanddeclaration"}, {"full_name": "map_iSup", "code": "theorem map_iSup [SupSet \u03b1] [SupSet \u03b2] [sSupHomClass F \u03b1 \u03b2] (f : F) (g : \u03b9 \u2192 \u03b1) :\n    f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [128, 1], "end": [129, 83], "kind": "commanddeclaration"}, {"full_name": "map_iSup\u2082", "code": "theorem map_iSup\u2082 [SupSet \u03b1] [SupSet \u03b2] [sSupHomClass F \u03b1 \u03b2] (f : F) (g : \u2200 i, \u03ba i \u2192 \u03b1) :\n    f (\u2a06 (i) (j), g i j) = \u2a06 (i) (j), f (g i j)", "start": [132, 1], "end": [133, 73], "kind": "commanddeclaration"}, {"full_name": "map_iInf", "code": "theorem map_iInf [InfSet \u03b1] [InfSet \u03b2] [sInfHomClass F \u03b1 \u03b2] (f : F) (g : \u03b9 \u2192 \u03b1) :\n    f (\u2a05 i, g i) = \u2a05 i, f (g i)", "start": [136, 1], "end": [137, 83], "kind": "commanddeclaration"}, {"full_name": "map_iInf\u2082", "code": "theorem map_iInf\u2082 [InfSet \u03b1] [InfSet \u03b2] [sInfHomClass F \u03b1 \u03b2] (f : F) (g : \u2200 i, \u03ba i \u2192 \u03b1) :\n    f (\u2a05 (i) (j), g i j) = \u2a05 (i) (j), f (g i j)", "start": [140, 1], "end": [141, 73], "kind": "commanddeclaration"}, {"full_name": "sSupHomClass.toSupBotHomClass", "code": "instance (priority := 100) sSupHomClass.toSupBotHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [sSupHomClass F \u03b1 \u03b2] : SupBotHomClass F \u03b1 \u03b2 :=\n  {  \u2039sSupHomClass F \u03b1 \u03b2\u203a with\n    map_sup := fun f a b => by\n      rw [\u2190 sSup_pair, map_sSup]\n      simp only [Set.image_pair, sSup_insert, sSup_singleton]\n    map_bot := fun f => by\n      rw [\u2190 sSup_empty, map_sSup, Set.image_empty]\n      exact sSup_empty }", "start": [145, 1], "end": [154, 25], "kind": "commanddeclaration"}, {"full_name": "sInfHomClass.toInfTopHomClass", "code": "instance (priority := 100) sInfHomClass.toInfTopHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [sInfHomClass F \u03b1 \u03b2] : InfTopHomClass F \u03b1 \u03b2 :=\n  { \u2039sInfHomClass F \u03b1 \u03b2\u203a with\n    map_inf := fun f a b => by\n      rw [\u2190 sInf_pair, map_sInf, Set.image_pair]\n      simp only [Set.image_pair, sInf_insert, sInf_singleton]\n    map_top := fun f => by\n      rw [\u2190 sInf_empty, map_sInf, Set.image_empty]\n      exact sInf_empty }", "start": [158, 1], "end": [167, 25], "kind": "commanddeclaration"}, {"full_name": "FrameHomClass.tosSupHomClass", "code": "instance (priority := 100) FrameHomClass.tosSupHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [FrameHomClass F \u03b1 \u03b2] : sSupHomClass F \u03b1 \u03b2 :=\n  { \u2039FrameHomClass F \u03b1 \u03b2\u203a with }", "start": [171, 1], "end": [173, 33], "kind": "commanddeclaration"}, {"full_name": "FrameHomClass.toBoundedLatticeHomClass", "code": "instance (priority := 100) FrameHomClass.toBoundedLatticeHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [FrameHomClass F \u03b1 \u03b2] : BoundedLatticeHomClass F \u03b1 \u03b2 :=\n  { \u2039FrameHomClass F \u03b1 \u03b2\u203a, sSupHomClass.toSupBotHomClass with }", "start": [177, 1], "end": [179, 64], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHomClass.toFrameHomClass", "code": "instance (priority := 100) CompleteLatticeHomClass.toFrameHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [CompleteLatticeHomClass F \u03b1 \u03b2] : FrameHomClass F \u03b1 \u03b2 :=\n  { \u2039CompleteLatticeHomClass F \u03b1 \u03b2\u203a, sInfHomClass.toInfTopHomClass with }", "start": [183, 1], "end": [185, 74], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHomClass.toBoundedLatticeHomClass", "code": "instance (priority := 100) CompleteLatticeHomClass.toBoundedLatticeHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [CompleteLatticeHomClass F \u03b1 \u03b2] : BoundedLatticeHomClass F \u03b1 \u03b2 :=\n  { sSupHomClass.toSupBotHomClass, sInfHomClass.toInfTopHomClass with }", "start": [189, 1], "end": [191, 72], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.tosSupHomClass", "code": "instance (priority := 100) OrderIsoClass.tosSupHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [OrderIsoClass F \u03b1 \u03b2] : sSupHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_sSup := fun f s =>\n      eq_of_forall_ge_iff fun c => by\n        simp only [\u2190 le_map_inv_iff, sSup_le_iff, Set.ball_image_iff] }", "start": [195, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.tosInfHomClass", "code": "instance (priority := 100) OrderIsoClass.tosInfHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [OrderIsoClass F \u03b1 \u03b2] : sInfHomClass F \u03b1 \u03b2 :=\n  { show OrderHomClass F \u03b1 \u03b2 from inferInstance with\n    map_sInf := fun f s =>\n      eq_of_forall_le_iff fun c => by\n        simp only [\u2190 map_inv_le_iff, le_sInf_iff, Set.ball_image_iff] }", "start": [204, 1], "end": [209, 72], "kind": "commanddeclaration"}, {"full_name": "OrderIsoClass.toCompleteLatticeHomClass", "code": "instance (priority := 100) OrderIsoClass.toCompleteLatticeHomClass [CompleteLattice \u03b1]\n    [CompleteLattice \u03b2] [OrderIsoClass F \u03b1 \u03b2] : CompleteLatticeHomClass F \u03b1 \u03b2 :=\n  { OrderIsoClass.tosSupHomClass, OrderIsoClass.tosInfHomClass with }", "start": [213, 1], "end": [218, 70], "kind": "commanddeclaration"}, {"full_name": "sSupHom.toFun_eq_coe", "code": "@[simp] lemma toFun_eq_coe (f : sSupHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [257, 1], "end": [257, 66], "kind": "mathlibtacticlemma"}, {"full_name": "sSupHom.coe_mk", "code": "@[simp, norm_cast] lemma coe_mk (f : \u03b1 \u2192 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [260, 1], "end": [260, 73], "kind": "mathlibtacticlemma"}, {"full_name": "sSupHom.ext", "code": "@[ext]\ntheorem ext {f g : sSupHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [262, 1], "end": [264, 20], "kind": "commanddeclaration"}, {"full_name": "sSupHom.copy", "code": "protected def copy (f : sSupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : sSupHom \u03b1 \u03b2\n    where\n  toFun := f'\n  map_sSup' := h.symm \u25b8 f.map_sSup'", "start": [267, 1], "end": [272, 36], "kind": "commanddeclaration"}, {"full_name": "sSupHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : sSupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.copy_eq", "code": "theorem copy_eq (f : sSupHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [280, 1], "end": [281, 17], "kind": "commanddeclaration"}, {"full_name": "sSupHom.id", "code": "protected def id : sSupHom \u03b1 \u03b1 :=\n  \u27e8id, fun s => by rw [id, Set.image_id]\u27e9", "start": [286, 1], "end": [288, 42], "kind": "commanddeclaration"}, {"full_name": "sSupHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(sSupHom.id \u03b1) = id", "start": [294, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : sSupHom.id \u03b1 a = a", "start": [301, 1], "end": [303, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.comp", "code": "def comp (f : sSupHom \u03b2 \u03b3) (g : sSupHom \u03b1 \u03b2) : sSupHom \u03b1 \u03b3\n    where\n  toFun := f \u2218 g\n  map_sSup' s := by rw [comp_apply, map_sSup, map_sSup, Set.image_image]; simp only [Function.comp]", "start": [306, 1], "end": [310, 100], "kind": "commanddeclaration"}, {"full_name": "sSupHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : sSupHom \u03b2 \u03b3) (g : sSupHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : sSupHom \u03b2 \u03b3) (g : sSupHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : sSupHom \u03b3 \u03b4) (g : sSupHom \u03b2 \u03b3) (h : sSupHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [323, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : sSupHom \u03b1 \u03b2) : f.comp (sSupHom.id \u03b1) = f", "start": [329, 1], "end": [331, 19], "kind": "commanddeclaration"}, {"full_name": "sSupHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : sSupHom \u03b1 \u03b2) : (sSupHom.id \u03b2).comp f = f", "start": [334, 1], "end": [336, 19], "kind": "commanddeclaration"}, {"full_name": "sSupHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : sSupHom \u03b2 \u03b3} {f : sSupHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [339, 1], "end": [342, 85], "kind": "commanddeclaration"}, {"full_name": "sSupHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : sSupHom \u03b2 \u03b3} {f\u2081 f\u2082 : sSupHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [345, 1], "end": [348, 81], "kind": "commanddeclaration"}, {"full_name": "sSupHom.coe_bot", "code": "@[simp]\ntheorem coe_bot : \u21d1(\u22a5 : sSupHom \u03b1 \u03b2) = \u22a5", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.bot_apply", "code": "@[simp]\ntheorem bot_apply (a : \u03b1) : (\u22a5 : sSupHom \u03b1 \u03b2) a = \u22a5", "start": [373, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.toFun_eq_coe", "code": "@[simp] lemma toFun_eq_coe (f : sInfHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [403, 1], "end": [403, 66], "kind": "mathlibtacticlemma"}, {"full_name": "sInfHom.coe_mk", "code": "@[simp] lemma coe_mk (f : \u03b1 \u2192 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [406, 1], "end": [406, 62], "kind": "mathlibtacticlemma"}, {"full_name": "sInfHom.ext", "code": "@[ext]\ntheorem ext {f g : sInfHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [408, 1], "end": [410, 20], "kind": "commanddeclaration"}, {"full_name": "sInfHom.copy", "code": "protected def copy (f : sInfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : sInfHom \u03b1 \u03b2\n    where\n  toFun := f'\n  map_sInf' := h.symm \u25b8 f.map_sInf'", "start": [413, 1], "end": [418, 36], "kind": "commanddeclaration"}, {"full_name": "sInfHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : sInfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [421, 1], "end": [423, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.copy_eq", "code": "theorem copy_eq (f : sInfHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [426, 1], "end": [427, 17], "kind": "commanddeclaration"}, {"full_name": "sInfHom.id", "code": "protected def id : sInfHom \u03b1 \u03b1 :=\n  \u27e8id, fun s => by rw [id, Set.image_id]\u27e9", "start": [432, 1], "end": [434, 42], "kind": "commanddeclaration"}, {"full_name": "sInfHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(sInfHom.id \u03b1) = id", "start": [440, 1], "end": [442, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : sInfHom.id \u03b1 a = a", "start": [447, 1], "end": [449, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.comp", "code": "def comp (f : sInfHom \u03b2 \u03b3) (g : sInfHom \u03b1 \u03b2) : sInfHom \u03b1 \u03b3\n    where\n  toFun := f \u2218 g\n  map_sInf' s := by rw [comp_apply, map_sInf, map_sInf, Set.image_image]; simp only [Function.comp]", "start": [452, 1], "end": [456, 100], "kind": "commanddeclaration"}, {"full_name": "sInfHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : sInfHom \u03b2 \u03b3) (g : sInfHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [459, 1], "end": [461, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : sInfHom \u03b2 \u03b3) (g : sInfHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [464, 1], "end": [466, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : sInfHom \u03b3 \u03b4) (g : sInfHom \u03b2 \u03b3) (h : sInfHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [469, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : sInfHom \u03b1 \u03b2) : f.comp (sInfHom.id \u03b1) = f", "start": [475, 1], "end": [477, 19], "kind": "commanddeclaration"}, {"full_name": "sInfHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : sInfHom \u03b1 \u03b2) : (sInfHom.id \u03b2).comp f = f", "start": [480, 1], "end": [482, 19], "kind": "commanddeclaration"}, {"full_name": "sInfHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : sInfHom \u03b2 \u03b3} {f : sInfHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [485, 1], "end": [488, 85], "kind": "commanddeclaration"}, {"full_name": "sInfHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : sInfHom \u03b2 \u03b3} {f\u2081 f\u2082 : sInfHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [491, 1], "end": [494, 81], "kind": "commanddeclaration"}, {"full_name": "sInfHom.coe_top", "code": "@[simp]\ntheorem coe_top : \u21d1(\u22a4 : sInfHom \u03b1 \u03b2) = \u22a4", "start": [514, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.top_apply", "code": "@[simp]\ntheorem top_apply (a : \u03b1) : (\u22a4 : sInfHom \u03b1 \u03b2) a = \u22a4", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.toLatticeHom", "code": "def toLatticeHom (f : FrameHom \u03b1 \u03b2) : LatticeHom \u03b1 \u03b2 :=\n  f", "start": [550, 1], "end": [552, 4], "kind": "commanddeclaration"}, {"full_name": "FrameHom.toFun_eq_coe", "code": "lemma toFun_eq_coe (f : FrameHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [555, 1], "end": [555, 59], "kind": "mathlibtacticlemma"}, {"full_name": "FrameHom.coe_toInfTopHom", "code": "@[simp] lemma coe_toInfTopHom (f : FrameHom \u03b1 \u03b2) : \u21d1f.toInfTopHom = f := rfl", "start": [558, 1], "end": [558, 77], "kind": "mathlibtacticlemma"}, {"full_name": "FrameHom.coe_toLatticeHom", "code": "@[simp] lemma coe_toLatticeHom (f : FrameHom \u03b1 \u03b2) : \u21d1f.toLatticeHom = f := rfl", "start": [559, 1], "end": [559, 79], "kind": "mathlibtacticlemma"}, {"full_name": "FrameHom.coe_mk", "code": "@[simp] lemma coe_mk (f : InfTopHom \u03b1 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [560, 1], "end": [560, 70], "kind": "mathlibtacticlemma"}, {"full_name": "FrameHom.ext", "code": "@[ext]\ntheorem ext {f g : FrameHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [562, 1], "end": [564, 20], "kind": "commanddeclaration"}, {"full_name": "FrameHom.copy", "code": "protected def copy (f : FrameHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : FrameHom \u03b1 \u03b2 :=\n  { (f : sSupHom \u03b1 \u03b2).copy f' h with toInfTopHom := f.toInfTopHom.copy f' h }", "start": [567, 1], "end": [570, 78], "kind": "commanddeclaration"}, {"full_name": "FrameHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : FrameHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [573, 1], "end": [575, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.copy_eq", "code": "theorem copy_eq (f : FrameHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [578, 1], "end": [579, 17], "kind": "commanddeclaration"}, {"full_name": "FrameHom.id", "code": "protected def id : FrameHom \u03b1 \u03b1 :=\n  { sSupHom.id \u03b1 with toInfTopHom := InfTopHom.id \u03b1 }", "start": [584, 1], "end": [586, 54], "kind": "commanddeclaration"}, {"full_name": "FrameHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(FrameHom.id \u03b1) = id", "start": [592, 1], "end": [594, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : FrameHom.id \u03b1 a = a", "start": [599, 1], "end": [601, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.comp", "code": "def comp (f : FrameHom \u03b2 \u03b3) (g : FrameHom \u03b1 \u03b2) : FrameHom \u03b1 \u03b3 :=\n  { (f : sSupHom \u03b2 \u03b3).comp (g : sSupHom \u03b1 \u03b2) with\n    toInfTopHom := f.toInfTopHom.comp g.toInfTopHom }", "start": [604, 1], "end": [607, 54], "kind": "commanddeclaration"}, {"full_name": "FrameHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : FrameHom \u03b2 \u03b3) (g : FrameHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [610, 1], "end": [612, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : FrameHom \u03b2 \u03b3) (g : FrameHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a)", "start": [615, 1], "end": [617, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : FrameHom \u03b3 \u03b4) (g : FrameHom \u03b2 \u03b3) (h : FrameHom \u03b1 \u03b2) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [620, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "FrameHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : FrameHom \u03b1 \u03b2) : f.comp (FrameHom.id \u03b1) = f", "start": [626, 1], "end": [628, 19], "kind": "commanddeclaration"}, {"full_name": "FrameHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : FrameHom \u03b1 \u03b2) : (FrameHom.id \u03b2).comp f = f", "start": [631, 1], "end": [633, 19], "kind": "commanddeclaration"}, {"full_name": "FrameHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : FrameHom \u03b2 \u03b3} {f : FrameHom \u03b1 \u03b2} (hf : Surjective f) :\n    g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [636, 1], "end": [639, 85], "kind": "commanddeclaration"}, {"full_name": "FrameHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : FrameHom \u03b2 \u03b3} {f\u2081 f\u2082 : FrameHom \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [642, 1], "end": [645, 81], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.tosSupHom", "code": "def tosSupHom (f : CompleteLatticeHom \u03b1 \u03b2) : sSupHom \u03b1 \u03b2 :=\n  f", "start": [667, 1], "end": [669, 4], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.toBoundedLatticeHom", "code": "def toBoundedLatticeHom (f : CompleteLatticeHom \u03b1 \u03b2) : BoundedLatticeHom \u03b1 \u03b2 :=\n  f", "start": [672, 1], "end": [674, 4], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.toFun_eq_coe", "code": "lemma toFun_eq_coe (f : CompleteLatticeHom \u03b1 \u03b2) : f.toFun = f := rfl", "start": [683, 1], "end": [683, 69], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteLatticeHom.coe_tosInfHom", "code": "@[simp] lemma coe_tosInfHom (f : CompleteLatticeHom \u03b1 \u03b2) : \u21d1f.tosInfHom = f := rfl", "start": [686, 1], "end": [686, 83], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteLatticeHom.coe_tosSupHom", "code": "@[simp] lemma coe_tosSupHom (f : CompleteLatticeHom \u03b1 \u03b2) : \u21d1f.tosSupHom = f := rfl", "start": [687, 1], "end": [687, 83], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteLatticeHom.coe_toBoundedLatticeHom", "code": "@[simp] lemma coe_toBoundedLatticeHom (f : CompleteLatticeHom \u03b1 \u03b2) : \u21d1f.toBoundedLatticeHom = f :=\nrfl", "start": [688, 1], "end": [689, 4], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteLatticeHom.coe_mk", "code": "@[simp] lemma coe_mk (f : sInfHom \u03b1 \u03b2) (hf) : \u21d1(mk f hf) = f := rfl", "start": [690, 1], "end": [690, 68], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteLatticeHom.ext", "code": "@[ext]\ntheorem ext {f g : CompleteLatticeHom \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [692, 1], "end": [694, 20], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.copy", "code": "protected def copy (f : CompleteLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) :\n    CompleteLatticeHom \u03b1 \u03b2 :=\n  { f.tosSupHom.copy f' h with tosInfHom := f.tosInfHom.copy f' h }", "start": [697, 1], "end": [701, 68], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : CompleteLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [704, 1], "end": [706, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.copy_eq", "code": "theorem copy_eq (f : CompleteLatticeHom \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [709, 1], "end": [710, 17], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.id", "code": "protected def id : CompleteLatticeHom \u03b1 \u03b1 :=\n  { sSupHom.id \u03b1, sInfHom.id \u03b1 with toFun := id }", "start": [715, 1], "end": [717, 50], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(CompleteLatticeHom.id \u03b1) = id", "start": [723, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : CompleteLatticeHom.id \u03b1 a = a", "start": [729, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.comp", "code": "def comp (f : CompleteLatticeHom \u03b2 \u03b3) (g : CompleteLatticeHom \u03b1 \u03b2) : CompleteLatticeHom \u03b1 \u03b3 :=\n  { f.tosSupHom.comp g.tosSupHom with tosInfHom := f.tosInfHom.comp g.tosInfHom }", "start": [734, 1], "end": [736, 82], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : CompleteLatticeHom \u03b2 \u03b3) (g : CompleteLatticeHom \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [739, 1], "end": [741, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : CompleteLatticeHom \u03b2 \u03b3) (g : CompleteLatticeHom \u03b1 \u03b2) (a : \u03b1) :\n    (f.comp g) a = f (g a)", "start": [744, 1], "end": [747, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : CompleteLatticeHom \u03b3 \u03b4) (g : CompleteLatticeHom \u03b2 \u03b3)\n    (h : CompleteLatticeHom \u03b1 \u03b2) : (f.comp g).comp h = f.comp (g.comp h)", "start": [750, 1], "end": [753, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.comp_id", "code": "@[simp]\ntheorem comp_id (f : CompleteLatticeHom \u03b1 \u03b2) : f.comp (CompleteLatticeHom.id \u03b1) = f", "start": [756, 1], "end": [758, 19], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.id_comp", "code": "@[simp]\ntheorem id_comp (f : CompleteLatticeHom \u03b1 \u03b2) : (CompleteLatticeHom.id \u03b2).comp f = f", "start": [761, 1], "end": [763, 19], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : CompleteLatticeHom \u03b2 \u03b3} {f : CompleteLatticeHom \u03b1 \u03b2}\n    (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [766, 1], "end": [769, 85], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : CompleteLatticeHom \u03b2 \u03b3} {f\u2081 f\u2082 : CompleteLatticeHom \u03b1 \u03b2}\n    (hg : Injective g) : g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [772, 1], "end": [775, 81], "kind": "commanddeclaration"}, {"full_name": "sSupHom.dual", "code": "@[simps]\nprotected def dual : sSupHom \u03b1 \u03b2 \u2243 sInfHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48\n    where\n  toFun f := \u27e8toDual \u2218 f \u2218 ofDual, f.map_sSup'\u27e9\n  invFun f := \u27e8ofDual \u2218 f \u2218 toDual, f.map_sInf'\u27e9\n  left_inv _ := sSupHom.ext fun _ => rfl\n  right_inv _ := sInfHom.ext fun _ => rfl", "start": [787, 1], "end": [794, 42], "kind": "commanddeclaration"}, {"full_name": "sSupHom.dual_id", "code": "@[simp]\ntheorem dual_id : sSupHom.dual (sSupHom.id \u03b1) = sInfHom.id _", "start": [797, 1], "end": [799, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : sSupHom \u03b2 \u03b3) (f : sSupHom \u03b1 \u03b2) :\n    sSupHom.dual (g.comp f) = (sSupHom.dual g).comp (sSupHom.dual f)", "start": [802, 1], "end": [805, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : sSupHom.dual.symm (sInfHom.id _) = sSupHom.id \u03b1", "start": [808, 1], "end": [810, 6], "kind": "commanddeclaration"}, {"full_name": "sSupHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : sInfHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : sInfHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    sSupHom.dual.symm (g.comp f) = (sSupHom.dual.symm g).comp (sSupHom.dual.symm f)", "start": [813, 1], "end": [816, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.dual", "code": "@[simps]\nprotected def dual : sInfHom \u03b1 \u03b2 \u2243 sSupHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48\n    where\n  toFun f :=\n    { toFun := toDual \u2218 f \u2218 ofDual\n      map_sSup' := fun _ => congr_arg toDual (map_sInf f _) }\n  invFun f :=\n    { toFun := ofDual \u2218 f \u2218 toDual\n      map_sInf' := fun _ => congr_arg ofDual (map_sSup f _) }\n  left_inv _ := sInfHom.ext fun _ => rfl\n  right_inv _ := sSupHom.ext fun _ => rfl", "start": [825, 1], "end": [836, 42], "kind": "commanddeclaration"}, {"full_name": "sInfHom.dual_id", "code": "@[simp]\ntheorem dual_id : sInfHom.dual (sInfHom.id \u03b1) = sSupHom.id _", "start": [839, 1], "end": [841, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : sInfHom \u03b2 \u03b3) (f : sInfHom \u03b1 \u03b2) :\n    sInfHom.dual (g.comp f) = (sInfHom.dual g).comp (sInfHom.dual f)", "start": [844, 1], "end": [847, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id : sInfHom.dual.symm (sSupHom.id _) = sInfHom.id \u03b1", "start": [850, 1], "end": [852, 6], "kind": "commanddeclaration"}, {"full_name": "sInfHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : sSupHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : sSupHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    sInfHom.dual.symm (g.comp f) = (sInfHom.dual.symm g).comp (sInfHom.dual.symm f)", "start": [855, 1], "end": [858, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.dual", "code": "@[simps!]\nprotected def dual : CompleteLatticeHom \u03b1 \u03b2 \u2243 CompleteLatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48\n    where\n  toFun f := \u27e8sSupHom.dual f.tosSupHom, fun s \u21a6 f.map_sInf' s\u27e9\n  invFun f := \u27e8sSupHom.dual f.tosSupHom, fun s \u21a6 f.map_sInf' s\u27e9\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := ext fun _ => rfl", "start": [867, 1], "end": [875, 34], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.dual_id", "code": "@[simp]\ntheorem dual_id : CompleteLatticeHom.dual (CompleteLatticeHom.id \u03b1) = CompleteLatticeHom.id _", "start": [878, 1], "end": [880, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.dual_comp", "code": "@[simp]\ntheorem dual_comp (g : CompleteLatticeHom \u03b2 \u03b3) (f : CompleteLatticeHom \u03b1 \u03b2) :\n    CompleteLatticeHom.dual (g.comp f) =\n      (CompleteLatticeHom.dual g).comp (CompleteLatticeHom.dual f)", "start": [883, 1], "end": [887, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.symm_dual_id", "code": "@[simp]\ntheorem symm_dual_id :\n    CompleteLatticeHom.dual.symm (CompleteLatticeHom.id _) = CompleteLatticeHom.id \u03b1", "start": [890, 1], "end": [893, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.symm_dual_comp", "code": "@[simp]\ntheorem symm_dual_comp (g : CompleteLatticeHom \u03b2\u1d52\u1d48 \u03b3\u1d52\u1d48) (f : CompleteLatticeHom \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48) :\n    CompleteLatticeHom.dual.symm (g.comp f) =\n      (CompleteLatticeHom.dual.symm g).comp (CompleteLatticeHom.dual.symm f)", "start": [896, 1], "end": [900, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.setPreimage", "code": "def setPreimage (f : \u03b1 \u2192 \u03b2) : CompleteLatticeHom (Set \u03b2) (Set \u03b1)\n    where\n  toFun := preimage f\n  map_sSup' s := preimage_sUnion.trans <| by simp only [Set.sSup_eq_sUnion, Set.sUnion_image]\n  map_sInf' s := preimage_sInter.trans <| by simp only [Set.sInf_eq_sInter, Set.sInter_image]", "start": [910, 1], "end": [917, 94], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.coe_setPreimage", "code": "@[simp]\ntheorem coe_setPreimage (f : \u03b1 \u2192 \u03b2) : \u21d1(setPreimage f) = preimage f", "start": [920, 1], "end": [922, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.setPreimage_apply", "code": "@[simp]\ntheorem setPreimage_apply (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) : setPreimage f s = s.preimage f", "start": [925, 1], "end": [927, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.setPreimage_id", "code": "@[simp]\ntheorem setPreimage_id : setPreimage (id : \u03b1 \u2192 \u03b1) = CompleteLatticeHom.id _", "start": [930, 1], "end": [932, 6], "kind": "commanddeclaration"}, {"full_name": "CompleteLatticeHom.setPreimage_comp", "code": "theorem setPreimage_comp (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) :\n    setPreimage (g \u2218 f) = (setPreimage f).comp (setPreimage g)", "start": [936, 1], "end": [938, 6], "kind": "commanddeclaration"}, {"full_name": "Set.image_sSup", "code": "theorem Set.image_sSup {f : \u03b1 \u2192 \u03b2} (s : Set (Set \u03b1)) : f '' sSup s = sSup (image f '' s)", "start": [943, 1], "end": [950, 34], "kind": "commanddeclaration"}, {"full_name": "sSupHom.setImage", "code": "@[simps]\ndef sSupHom.setImage (f : \u03b1 \u2192 \u03b2) : sSupHom (Set \u03b1) (Set \u03b2)\n    where\n  toFun := image f\n  map_sSup' := Set.image_sSup", "start": [953, 1], "end": [961, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.toOrderIsoSet", "code": "@[simps]\ndef Equiv.toOrderIsoSet (e : \u03b1 \u2243 \u03b2) : Set \u03b1 \u2243o Set \u03b2\n    where\n  toFun s := e '' s\n  invFun s := e.symm '' s\n  left_inv s := by simp only [\u2190 image_comp, Equiv.symm_comp_self, id.def, image_id']\n  right_inv s := by simp only [\u2190 image_comp, Equiv.self_comp_symm, id.def, image_id']\n  map_rel_iff' :=\n    \u27e8fun h => by simpa using @monotone_image _ _ e.symm _ _ h, fun h => monotone_image h\u27e9", "start": [964, 1], "end": [973, 90], "kind": "commanddeclaration"}, {"full_name": "supsSupHom", "code": "def supsSupHom : sSupHom (\u03b1 \u00d7 \u03b1) \u03b1 where\n  toFun x := x.1 \u2294 x.2\n  map_sSup' s := by simp_rw [Prod.fst_sSup, Prod.snd_sSup, sSup_image, iSup_sup_eq]", "start": [978, 1], "end": [981, 84], "kind": "commanddeclaration"}, {"full_name": "infsInfHom", "code": "def infsInfHom : sInfHom (\u03b1 \u00d7 \u03b1) \u03b1 where\n  toFun x := x.1 \u2293 x.2\n  map_sInf' s := by simp_rw [Prod.fst_sInf, Prod.snd_sInf, sInf_image, iInf_inf_eq]", "start": [984, 1], "end": [987, 84], "kind": "commanddeclaration"}, {"full_name": "supsSupHom_apply", "code": "@[simp, norm_cast]\ntheorem supsSupHom_apply : supsSupHom x = x.1 \u2294 x.2", "start": [990, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "infsInfHom_apply", "code": "@[simp, norm_cast]\ntheorem infsInfHom_apply : infsInfHom x = x.1 \u2293 x.2", "start": [995, 1], "end": [997, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Prod.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/Order/PartialSups.lean", "Mathlib/Algebra/Algebra/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.fst", "code": "def fst : M \u00d7 M\u2082 \u2192\u2097[R] M where\n  toFun := Prod.fst\n  map_add' _x _y := rfl\n  map_smul' _x _y := rfl", "start": [58, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.snd", "code": "def snd : M \u00d7 M\u2082 \u2192\u2097[R] M\u2082 where\n  toFun := Prod.snd\n  map_add' _x _y := rfl\n  map_smul' _x _y := rfl", "start": [65, 1], "end": [69, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.fst_apply", "code": "@[simp]\ntheorem fst_apply (x : M \u00d7 M\u2082) : fst R M M\u2082 x = x.1", "start": [74, 1], "end": [76, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.snd_apply", "code": "@[simp]\ntheorem snd_apply (x : M \u00d7 M\u2082) : snd R M M\u2082 x = x.2", "start": [79, 1], "end": [81, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.fst_surjective", "code": "theorem fst_surjective : Function.Surjective (fst R M M\u2082)", "start": [84, 1], "end": [84, 84], "kind": "commanddeclaration"}, {"full_name": "LinearMap.snd_surjective", "code": "theorem snd_surjective : Function.Surjective (snd R M M\u2082)", "start": [87, 1], "end": [87, 84], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod", "code": "@[simps]\ndef prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) : M \u2192\u2097[R] M\u2082 \u00d7 M\u2083 where\n  toFun := Pi.prod f g\n  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]\n  map_smul' c x := by simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]", "start": [90, 1], "end": [95, 84], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_prod", "code": "theorem coe_prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) : \u21d1(f.prod g) = Pi.prod f g", "start": [98, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.fst_prod", "code": "@[simp]\ntheorem fst_prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) : (fst R M\u2082 M\u2083).comp (prod f g) = f", "start": [102, 1], "end": [103, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.snd_prod", "code": "@[simp]\ntheorem snd_prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) : (snd R M\u2082 M\u2083).comp (prod f g) = g", "start": [106, 1], "end": [107, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pair_fst_snd", "code": "@[simp]\ntheorem pair_fst_snd : prod (fst R M M\u2082) (snd R M M\u2082) = LinearMap.id", "start": [110, 1], "end": [111, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod_comp", "code": "theorem prod_comp (f : M\u2082 \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2084)\n    (h : M \u2192\u2097[R] M\u2082) : (f.prod g).comp h = (f.comp h).prod (g.comp h)", "start": [114, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodEquiv", "code": "@[simps]\ndef prodEquiv [Module S M\u2082] [Module S M\u2083] [SMulCommClass R S M\u2082] [SMulCommClass R S M\u2083] :\n    ((M \u2192\u2097[R] M\u2082) \u00d7 (M \u2192\u2097[R] M\u2083)) \u2243\u2097[S] M \u2192\u2097[R] M\u2082 \u00d7 M\u2083 where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv f := by ext <;> rfl\n  right_inv f := by ext <;> rfl\n  map_add' a b := rfl\n  map_smul' r a := rfl", "start": [118, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inl", "code": "def inl : M \u2192\u2097[R] M \u00d7 M\u2082 :=\n  prod LinearMap.id 0", "start": [137, 1], "end": [139, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inr", "code": "def inr : M\u2082 \u2192\u2097[R] M \u00d7 M\u2082 :=\n  prod 0 LinearMap.id", "start": [142, 1], "end": [144, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_inl", "code": "theorem range_inl : range (inl R M M\u2082) = ker (snd R M M\u2082)", "start": [147, 1], "end": [154, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_snd", "code": "theorem ker_snd : ker (snd R M M\u2082) = range (inl R M M\u2082)", "start": [157, 1], "end": [158, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_inr", "code": "theorem range_inr : range (inr R M M\u2082) = ker (fst R M M\u2082)", "start": [161, 1], "end": [168, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_fst", "code": "theorem ker_fst : ker (fst R M M\u2082) = range (inr R M M\u2082)", "start": [171, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_inl", "code": "@[simp]\ntheorem coe_inl : (inl R M M\u2082 : M \u2192 M \u00d7 M\u2082) = fun x => (x, 0)", "start": [177, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inl_apply", "code": "theorem inl_apply (x : M) : inl R M M\u2082 x = (x, 0)", "start": [182, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_inr", "code": "@[simp]\ntheorem coe_inr : (inr R M M\u2082 : M\u2082 \u2192 M \u00d7 M\u2082) = Prod.mk 0", "start": [186, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inr_apply", "code": "theorem inr_apply (x : M\u2082) : inr R M M\u2082 x = (0, x)", "start": [191, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inl_eq_prod", "code": "theorem inl_eq_prod : inl R M M\u2082 = prod LinearMap.id 0", "start": [195, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inr_eq_prod", "code": "theorem inr_eq_prod : inr R M M\u2082 = prod 0 LinearMap.id", "start": [199, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inl_injective", "code": "theorem inl_injective : Function.Injective (inl R M M\u2082)", "start": [203, 1], "end": [203, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inr_injective", "code": "theorem inr_injective : Function.Injective (inr R M M\u2082)", "start": [206, 1], "end": [206, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod", "code": "def coprod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) : M \u00d7 M\u2082 \u2192\u2097[R] M\u2083 :=\n  f.comp (fst _ _ _) + g.comp (snd _ _ _)", "start": [209, 1], "end": [211, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_apply", "code": "@[simp]\ntheorem coprod_apply (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (x : M \u00d7 M\u2082) :\n    coprod f g x = f x.1 + g x.2", "start": [214, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_inl", "code": "@[simp]\ntheorem coprod_inl (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) : (coprod f g).comp (inl R M M\u2082) = f", "start": [220, 1], "end": [222, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_inr", "code": "@[simp]\ntheorem coprod_inr (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) : (coprod f g).comp (inr R M M\u2082) = g", "start": [225, 1], "end": [227, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_inl_inr", "code": "@[simp]\ntheorem coprod_inl_inr : coprod (inl R M M\u2082) (inr R M M\u2082) = LinearMap.id", "start": [230, 1], "end": [233, 97], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_zero_left", "code": "theorem coprod_zero_left (g : M\u2082 \u2192\u2097[R] M\u2083) : (0 : M \u2192\u2097[R] M\u2083).coprod g = g.comp (snd R M M\u2082)", "start": [236, 1], "end": [237, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_zero_right", "code": "theorem coprod_zero_right (f : M \u2192\u2097[R] M\u2083) : f.coprod (0 : M\u2082 \u2192\u2097[R] M\u2083) = f.comp (fst R M M\u2082)", "start": [239, 1], "end": [240, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comp_coprod", "code": "theorem comp_coprod (f : M\u2083 \u2192\u2097[R] M\u2084) (g\u2081 : M \u2192\u2097[R] M\u2083) (g\u2082 : M\u2082 \u2192\u2097[R] M\u2083) :\n    f.comp (g\u2081.coprod g\u2082) = (f.comp g\u2081).coprod (f.comp g\u2082)", "start": [242, 1], "end": [244, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.fst_eq_coprod", "code": "theorem fst_eq_coprod : fst R M M\u2082 = coprod LinearMap.id 0", "start": [247, 1], "end": [247, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.snd_eq_coprod", "code": "theorem snd_eq_coprod : snd R M M\u2082 = coprod 0 LinearMap.id", "start": [250, 1], "end": [250, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_comp_prod", "code": "@[simp]\ntheorem coprod_comp_prod (f : M\u2082 \u2192\u2097[R] M\u2084) (g : M\u2083 \u2192\u2097[R] M\u2084) (f' : M \u2192\u2097[R] M\u2082) (g' : M \u2192\u2097[R] M\u2083) :\n    (f.coprod g).comp (f'.prod g') = f.comp f' + g.comp g'", "start": [253, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprod_map_prod", "code": "@[simp]\ntheorem coprod_map_prod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (S : Submodule R M)\n    (S' : Submodule R M\u2082) : (Submodule.prod S S').map (LinearMap.coprod f g) = S.map f \u2294 S'.map g", "start": [259, 1], "end": [265, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coprodEquiv", "code": "@[simps]\ndef coprodEquiv [Module S M\u2083] [SMulCommClass R S M\u2083] :\n    ((M \u2192\u2097[R] M\u2083) \u00d7 (M\u2082 \u2192\u2097[R] M\u2083)) \u2243\u2097[S] M \u00d7 M\u2082 \u2192\u2097[R] M\u2083\n    where\n  toFun f := f.1.coprod f.2\n  invFun f := (f.comp (inl _ _ _), f.comp (inr _ _ _))\n  left_inv f := by simp only [coprod_inl, coprod_inr]\n  right_inv f := by simp only [\u2190 comp_coprod, comp_id, coprod_inl_inr]\n  map_add' a b := by\n    ext\n    simp only [Prod.snd_add, add_apply, coprod_apply, Prod.fst_add, add_add_add_comm]\n  map_smul' r a := by\n    dsimp\n    ext\n    simp only [smul_add, smul_apply, Prod.smul_snd, Prod.smul_fst, coprod_apply]", "start": [268, 1], "end": [286, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod_ext_iff", "code": "theorem prod_ext_iff {f g : M \u00d7 M\u2082 \u2192\u2097[R] M\u2083} :\n    f = g \u2194 f.comp (inl _ _ _) = g.comp (inl _ _ _) \u2227 f.comp (inr _ _ _) = g.comp (inr _ _ _)", "start": [289, 1], "end": [291, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod_ext", "code": "@[ext 1100]\ntheorem prod_ext {f g : M \u00d7 M\u2082 \u2192\u2097[R] M\u2083} (hl : f.comp (inl _ _ _) = g.comp (inl _ _ _))\n    (hr : f.comp (inr _ _ _) = g.comp (inr _ _ _)) : f = g", "start": [294, 1], "end": [302, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap", "code": "def prodMap (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2084) : M \u00d7 M\u2082 \u2192\u2097[R] M\u2083 \u00d7 M\u2084 :=\n  (f.comp (fst R M M\u2082)).prod (g.comp (snd R M M\u2082))", "start": [305, 1], "end": [307, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_prodMap", "code": "theorem coe_prodMap (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2084) : \u21d1(f.prodMap g) = Prod.map f g", "start": [310, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_apply", "code": "@[simp]\ntheorem prodMap_apply (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2084) (x) : f.prodMap g x = (f x.1, g x.2)", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_comap_prod", "code": "theorem prodMap_comap_prod (f : M \u2192\u2097[R] M\u2082) (g : M\u2083 \u2192\u2097[R] M\u2084) (S : Submodule R M\u2082)\n    (S' : Submodule R M\u2084) :\n    (Submodule.prod S S').comap (LinearMap.prodMap f g) = (S.comap f).prod (S'.comap g)", "start": [319, 1], "end": [322, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_prodMap", "code": "theorem ker_prodMap (f : M \u2192\u2097[R] M\u2082) (g : M\u2083 \u2192\u2097[R] M\u2084) :\n    ker (LinearMap.prodMap f g) = Submodule.prod (ker f) (ker g)", "start": [325, 1], "end": [328, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_id", "code": "@[simp]\ntheorem prodMap_id : (id : M \u2192\u2097[R] M).prodMap (id : M\u2082 \u2192\u2097[R] M\u2082) = id", "start": [331, 1], "end": [333, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_one", "code": "@[simp]\ntheorem prodMap_one : (1 : M \u2192\u2097[R] M).prodMap (1 : M\u2082 \u2192\u2097[R] M\u2082) = 1", "start": [336, 1], "end": [338, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_comp", "code": "theorem prodMap_comp (f\u2081\u2082 : M \u2192\u2097[R] M\u2082) (f\u2082\u2083 : M\u2082 \u2192\u2097[R] M\u2083) (g\u2081\u2082 : M\u2084 \u2192\u2097[R] M\u2085)\n    (g\u2082\u2083 : M\u2085 \u2192\u2097[R] M\u2086) :\n    f\u2082\u2083.prodMap g\u2082\u2083 \u2218\u2097 f\u2081\u2082.prodMap g\u2081\u2082 = (f\u2082\u2083 \u2218\u2097 f\u2081\u2082).prodMap (g\u2082\u2083 \u2218\u2097 g\u2081\u2082)", "start": [341, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_mul", "code": "theorem prodMap_mul (f\u2081\u2082 : M \u2192\u2097[R] M) (f\u2082\u2083 : M \u2192\u2097[R] M) (g\u2081\u2082 : M\u2082 \u2192\u2097[R] M\u2082) (g\u2082\u2083 : M\u2082 \u2192\u2097[R] M\u2082) :\n    f\u2082\u2083.prodMap g\u2082\u2083 * f\u2081\u2082.prodMap g\u2081\u2082 = (f\u2082\u2083 * f\u2081\u2082).prodMap (g\u2082\u2083 * g\u2081\u2082)", "start": [347, 1], "end": [349, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_add", "code": "theorem prodMap_add (f\u2081 : M \u2192\u2097[R] M\u2083) (f\u2082 : M \u2192\u2097[R] M\u2083) (g\u2081 : M\u2082 \u2192\u2097[R] M\u2084) (g\u2082 : M\u2082 \u2192\u2097[R] M\u2084) :\n    (f\u2081 + f\u2082).prodMap (g\u2081 + g\u2082) = f\u2081.prodMap g\u2081 + f\u2082.prodMap g\u2082", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_zero", "code": "@[simp]\ntheorem prodMap_zero : (0 : M \u2192\u2097[R] M\u2082).prodMap (0 : M\u2083 \u2192\u2097[R] M\u2084) = 0", "start": [357, 1], "end": [359, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMap_smul", "code": "@[simp]\ntheorem prodMap_smul [Module S M\u2083] [Module S M\u2084] [SMulCommClass R S M\u2083] [SMulCommClass R S M\u2084]\n    (s : S) (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2084) : prodMap (s \u2022 f) (s \u2022 g) = s \u2022 prodMap f g", "start": [362, 1], "end": [365, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMapLinear", "code": "@[simps]\ndef prodMapLinear [Module S M\u2083] [Module S M\u2084] [SMulCommClass R S M\u2083] [SMulCommClass R S M\u2084] :\n    (M \u2192\u2097[R] M\u2083) \u00d7 (M\u2082 \u2192\u2097[R] M\u2084) \u2192\u2097[S] M \u00d7 M\u2082 \u2192\u2097[R] M\u2083 \u00d7 M\u2084\n    where\n  toFun f := prodMap f.1 f.2\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [370, 1], "end": [377, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMapRingHom", "code": "@[simps]\ndef prodMapRingHom : (M \u2192\u2097[R] M) \u00d7 (M\u2082 \u2192\u2097[R] M\u2082) \u2192+* M \u00d7 M\u2082 \u2192\u2097[R] M \u00d7 M\u2082\n    where\n  toFun f := prodMap f.1 f.2\n  map_one' := prodMap_one\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [380, 1], "end": [388, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inl_map_mul", "code": "theorem inl_map_mul (a\u2081 a\u2082 : A) :\n    LinearMap.inl R A B (a\u2081 * a\u2082) = LinearMap.inl R A B a\u2081 * LinearMap.inl R A B a\u2082", "start": [399, 1], "end": [401, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.inr_map_mul", "code": "theorem inr_map_mul (b\u2081 b\u2082 : B) :\n    LinearMap.inr R A B (b\u2081 * b\u2082) = LinearMap.inr R A B b\u2081 * LinearMap.inr R A B b\u2082", "start": [404, 1], "end": [406, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prodMapAlgHom", "code": "@[simps!]\ndef prodMapAlgHom : Module.End R M \u00d7 Module.End R M\u2082 \u2192\u2090[R] Module.End R (M \u00d7 M\u2082) :=\n  { prodMapRingHom R M M\u2082 with commutes' := fun _ => rfl }", "start": [425, 1], "end": [428, 59], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_coprod", "code": "theorem range_coprod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) : range (f.coprod g) = range f \u2294 range g", "start": [440, 1], "end": [441, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isCompl_range_inl_inr", "code": "theorem isCompl_range_inl_inr : IsCompl (range $ inl R M M\u2082) (range $ inr R M M\u2082)", "start": [444, 1], "end": [454, 9], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sup_range_inl_inr", "code": "theorem sup_range_inl_inr : (range $ inl R M M\u2082) \u2294 (range $ inr R M M\u2082) = \u22a4", "start": [457, 1], "end": [458, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.disjoint_inl_inr", "code": "theorem disjoint_inl_inr : Disjoint (range $ inl R M M\u2082) (range $ inr R M M\u2082)", "start": [461, 1], "end": [462, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_coprod_prod", "code": "theorem map_coprod_prod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (p : Submodule R M)\n    (q : Submodule R M\u2082) : map (coprod f g) (p.prod q) = map f p \u2294 map g q", "start": [465, 1], "end": [472, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comap_prod_prod", "code": "theorem comap_prod_prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) (p : Submodule R M\u2082)\n    (q : Submodule R M\u2083) : comap (prod f g) (p.prod q) = comap f p \u2293 comap g q", "start": [475, 1], "end": [477, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod_eq_inf_comap", "code": "theorem prod_eq_inf_comap (p : Submodule R M) (q : Submodule R M\u2082) :\n    p.prod q = p.comap (LinearMap.fst R M M\u2082) \u2293 q.comap (LinearMap.snd R M M\u2082)", "start": [480, 1], "end": [482, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.prod_eq_sup_map", "code": "theorem prod_eq_sup_map (p : Submodule R M) (q : Submodule R M\u2082) :\n    p.prod q = p.map (LinearMap.inl R M M\u2082) \u2294 q.map (LinearMap.inr R M M\u2082)", "start": [485, 1], "end": [487, 49], "kind": "commanddeclaration"}, {"full_name": "LinearMap.span_inl_union_inr", "code": "theorem span_inl_union_inr {s : Set M} {t : Set M\u2082} :\n    span R (inl R M M\u2082 '' s \u222a inr R M M\u2082 '' t) = (span R s).prod (span R t)", "start": [490, 1], "end": [492, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_prod", "code": "@[simp]\ntheorem ker_prod (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) : ker (prod f g) = ker f \u2293 ker g", "start": [495, 1], "end": [497, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_prod_le", "code": "theorem range_prod_le (f : M \u2192\u2097[R] M\u2082) (g : M \u2192\u2097[R] M\u2083) :\n    range (prod f g) \u2264 (range f).prod (range g)", "start": [500, 1], "end": [504, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_prod_ker_le_ker_coprod", "code": "theorem ker_prod_ker_le_ker_coprod {M\u2082 : Type*} [AddCommGroup M\u2082] [Module R M\u2082] {M\u2083 : Type*}\n    [AddCommGroup M\u2083] [Module R M\u2083] (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) :\n    (ker f).prod (ker g) \u2264 ker (f.coprod g)", "start": [507, 1], "end": [511, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_coprod_of_disjoint_range", "code": "theorem ker_coprod_of_disjoint_range {M\u2082 : Type*} [AddCommGroup M\u2082] [Module R M\u2082] {M\u2083 : Type*}\n    [AddCommGroup M\u2083] [Module R M\u2083] (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083)\n    (hd : Disjoint (range f) (range g)) : ker (f.coprod g) = (ker f).prod (ker g)", "start": [514, 1], "end": [526, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_eq_range", "code": "theorem sup_eq_range (p q : Submodule R M) : p \u2294 q = range (p.subtype.coprod q.subtype)", "start": [541, 1], "end": [542, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inl", "code": "@[simp]\ntheorem map_inl : p.map (inl R M M\u2082) = prod p \u22a5", "start": [547, 1], "end": [551, 14], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_inr", "code": "@[simp]\ntheorem map_inr : q.map (inr R M M\u2082) = prod \u22a5 q", "start": [554, 1], "end": [556, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_fst", "code": "@[simp]\ntheorem comap_fst : p.comap (fst R M M\u2082) = prod p \u22a4", "start": [559, 1], "end": [560, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_snd", "code": "@[simp]\ntheorem comap_snd : q.comap (snd R M M\u2082) = prod \u22a4 q", "start": [563, 1], "end": [564, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_comap_inl", "code": "@[simp]\ntheorem prod_comap_inl : (prod p q).comap (inl R M M\u2082) = p", "start": [567, 1], "end": [568, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_comap_inr", "code": "@[simp]\ntheorem prod_comap_inr : (prod p q).comap (inr R M M\u2082) = q", "start": [571, 1], "end": [572, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_map_fst", "code": "@[simp]\ntheorem prod_map_fst : (prod p q).map (fst R M M\u2082) = p", "start": [575, 1], "end": [577, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_map_snd", "code": "@[simp]\ntheorem prod_map_snd : (prod p q).map (snd R M M\u2082) = q", "start": [580, 1], "end": [582, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_inl", "code": "@[simp]\ntheorem ker_inl : ker (inl R M M\u2082) = \u22a5", "start": [585, 1], "end": [586, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_inr", "code": "@[simp]\ntheorem ker_inr : ker (inr R M M\u2082) = \u22a5", "start": [589, 1], "end": [590, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_fst", "code": "@[simp]\ntheorem range_fst : range (fst R M M\u2082) = \u22a4", "start": [593, 1], "end": [594, 93], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_snd", "code": "@[simp]\ntheorem range_snd : range (snd R M M\u2082) = \u22a4", "start": [597, 1], "end": [598, 93], "kind": "commanddeclaration"}, {"full_name": "Submodule.fst", "code": "def fst : Submodule R (M \u00d7 M\u2082) :=\n  (\u22a5 : Submodule R M\u2082).comap (LinearMap.snd R M M\u2082)", "start": [603, 1], "end": [605, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.fstEquiv", "code": "@[simps]\ndef fstEquiv : Submodule.fst R M M\u2082 \u2243\u2097[R] M where\n  toFun x := x.1.1\n  invFun m := \u27e8\u27e8m, 0\u27e9, by simp only [fst, comap_bot, mem_ker, snd_apply]\u27e9\n  map_add' := by simp only [AddSubmonoid.coe_add, coe_toAddSubmonoid, Prod.fst_add, Subtype.forall,\n    implies_true, Prod.forall, forall_const]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_fst, RingHom.id_apply, Subtype.forall,\n    implies_true, Prod.forall, forall_const]\n  left_inv := by\n    rintro \u27e8\u27e8x, y\u27e9, hy\u27e9\n    simp only [fst, comap_bot, mem_ker, snd_apply] at hy\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, true_and] using hy.symm\n  right_inv := by rintro x; rfl", "start": [608, 1], "end": [622, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.fst_map_fst", "code": "theorem fst_map_fst : (Submodule.fst R M M\u2082).map (LinearMap.fst R M M\u2082) = \u22a4", "start": [625, 1], "end": [629, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.fst_map_snd", "code": "theorem fst_map_snd : (Submodule.fst R M M\u2082).map (LinearMap.snd R M M\u2082) = \u22a5", "start": [632, 1], "end": [636, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.snd", "code": "def snd : Submodule R (M \u00d7 M\u2082) :=\n  (\u22a5 : Submodule R M).comap (LinearMap.fst R M M\u2082)", "start": [639, 1], "end": [641, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.sndEquiv", "code": "@[simps]\ndef sndEquiv : Submodule.snd R M M\u2082 \u2243\u2097[R] M\u2082 where\n  toFun x := x.1.2\n  invFun n := \u27e8\u27e80, n\u27e9, by simp only [snd, comap_bot, mem_ker, fst_apply]\u27e9\n  map_add' := by simp only [AddSubmonoid.coe_add, coe_toAddSubmonoid, Prod.snd_add, Subtype.forall,\n    implies_true, Prod.forall, forall_const]\n  map_smul' := by simp only [SetLike.val_smul, Prod.smul_snd, RingHom.id_apply, Subtype.forall,\n    implies_true, Prod.forall, forall_const]\n  left_inv := by\n    rintro \u27e8\u27e8x, y\u27e9, hx\u27e9\n    simp only [snd, comap_bot, mem_ker, fst_apply] at hx\n    simpa only [Subtype.mk.injEq, Prod.mk.injEq, and_true] using hx.symm\n  right_inv := by rintro x; rfl", "start": [644, 1], "end": [658, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.snd_map_fst", "code": "theorem snd_map_fst : (Submodule.snd R M M\u2082).map (LinearMap.fst R M M\u2082) = \u22a5", "start": [661, 1], "end": [665, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.snd_map_snd", "code": "theorem snd_map_snd : (Submodule.snd R M M\u2082).map (LinearMap.snd R M M\u2082) = \u22a4", "start": [668, 1], "end": [672, 45], "kind": "commanddeclaration"}, {"full_name": "Submodule.fst_sup_snd", "code": "theorem fst_sup_snd : Submodule.fst R M M\u2082 \u2294 Submodule.snd R M M\u2082 = \u22a4", "start": [675, 1], "end": [681, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.fst_inf_snd", "code": "theorem fst_inf_snd : Submodule.fst R M M\u2082 \u2293 Submodule.snd R M M\u2082 = \u22a5", "start": [684, 1], "end": [688, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_prod_iff", "code": "theorem le_prod_iff {p\u2081 : Submodule R M} {p\u2082 : Submodule R M\u2082} {q : Submodule R (M \u00d7 M\u2082)} :\n    q \u2264 p\u2081.prod p\u2082 \u2194 map (LinearMap.fst R M M\u2082) q \u2264 p\u2081 \u2227 map (LinearMap.snd R M M\u2082) q \u2264 p\u2082", "start": [691, 1], "end": [701, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_le_iff", "code": "theorem prod_le_iff {p\u2081 : Submodule R M} {p\u2082 : Submodule R M\u2082} {q : Submodule R (M \u00d7 M\u2082)} :\n    p\u2081.prod p\u2082 \u2264 q \u2194 map (LinearMap.inl R M M\u2082) p\u2081 \u2264 q \u2227 map (LinearMap.inr R M M\u2082) p\u2082 \u2264 q", "start": [704, 1], "end": [722, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_eq_bot_iff", "code": "theorem prod_eq_bot_iff {p\u2081 : Submodule R M} {p\u2082 : Submodule R M\u2082} :\n    p\u2081.prod p\u2082 = \u22a5 \u2194 p\u2081 = \u22a5 \u2227 p\u2082 = \u22a5", "start": [725, 1], "end": [727, 95], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_eq_top_iff", "code": "theorem prod_eq_top_iff {p\u2081 : Submodule R M} {p\u2082 : Submodule R M\u2082} :\n    p\u2081.prod p\u2082 = \u22a4 \u2194 p\u2081 = \u22a4 \u2227 p\u2082 = \u22a4", "start": [730, 1], "end": [732, 99], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prodComm", "code": "@[simps apply]\ndef prodComm (R M N : Type*) [Semiring R] [AddCommMonoid M] [AddCommMonoid N] [Module R M]\n    [Module R N] : (M \u00d7 N) \u2243\u2097[R] N \u00d7 M :=\n  { AddEquiv.prodComm with\n    toFun := Prod.swap\n    map_smul' := fun _r \u27e8_m, _n\u27e9 => rfl }", "start": [739, 1], "end": [745, 42], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.fst_comp_prodComm", "code": "theorem fst_comp_prodComm :\n    (LinearMap.fst R M\u2082 M).comp (prodComm R M M\u2082).toLinearMap = (LinearMap.snd R M M\u2082)", "start": [752, 1], "end": [754, 15], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.snd_comp_prodComm", "code": "theorem snd_comp_prodComm :\n    (LinearMap.snd R M\u2082 M).comp (prodComm R M M\u2082).toLinearMap = (LinearMap.fst R M M\u2082)", "start": [756, 1], "end": [758, 15], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prodProdProdComm", "code": "@[simps apply]\ndef prodProdProdComm : ((M \u00d7 M\u2082) \u00d7 M\u2083 \u00d7 M\u2084) \u2243\u2097[R] (M \u00d7 M\u2083) \u00d7 M\u2082 \u00d7 M\u2084 :=\n  { AddEquiv.prodProdProdComm M M\u2082 M\u2083 M\u2084 with\n    toFun := fun mnmn => ((mnmn.1.1, mnmn.2.1), (mnmn.1.2, mnmn.2.2))\n    invFun := fun mmnn => ((mmnn.1.1, mmnn.2.1), (mmnn.1.2, mmnn.2.2))\n    map_smul' := fun _c _mnmn => rfl }", "start": [769, 1], "end": [775, 39], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prodProdProdComm_symm", "code": "@[simp]\ntheorem prodProdProdComm_symm :\n    (prodProdProdComm R M M\u2082 M\u2083 M\u2084).symm = prodProdProdComm R M M\u2083 M\u2082 M\u2084", "start": [778, 1], "end": [781, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prodProdProdComm_toAddEquiv", "code": "@[simp]\ntheorem prodProdProdComm_toAddEquiv :\n    (prodProdProdComm R M M\u2082 M\u2083 M\u2084 : _ \u2243+ _) = AddEquiv.prodProdProdComm M M\u2082 M\u2083 M\u2084", "start": [784, 1], "end": [787, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prod", "code": "protected def prod : (M \u00d7 M\u2083) \u2243\u2097[R] M\u2082 \u00d7 M\u2084 :=\n  { e\u2081.toAddEquiv.prodCongr e\u2082.toAddEquiv with\n    map_smul' := fun c _x => Prod.ext (e\u2081.map_smul\u209b\u2097 c _) (e\u2082.map_smul\u209b\u2097 c _) }", "start": [804, 1], "end": [807, 80], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prod_symm", "code": "theorem prod_symm : (e\u2081.prod e\u2082).symm = e\u2081.symm.prod e\u2082.symm", "start": [810, 1], "end": [811, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.prod_apply", "code": "@[simp]\ntheorem prod_apply (p) : e\u2081.prod e\u2082 p = (e\u2081 p.1, e\u2082 p.2)", "start": [814, 1], "end": [816, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.coe_prod", "code": "@[simp, norm_cast]\ntheorem coe_prod :\n    (e\u2081.prod e\u2082 : M \u00d7 M\u2083 \u2192\u2097[R] M\u2082 \u00d7 M\u2084) = (e\u2081 : M \u2192\u2097[R] M\u2082).prodMap (e\u2082 : M\u2083 \u2192\u2097[R] M\u2084)", "start": [819, 1], "end": [822, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.skewProd", "code": "protected def skewProd (f : M \u2192\u2097[R] M\u2084) : (M \u00d7 M\u2083) \u2243\u2097[R] M\u2082 \u00d7 M\u2084 :=\n  { ((e\u2081 : M \u2192\u2097[R] M\u2082).comp (LinearMap.fst R M M\u2083)).prod\n      ((e\u2082 : M\u2083 \u2192\u2097[R] M\u2084).comp (LinearMap.snd R M M\u2083) +\n        f.comp (LinearMap.fst R M M\u2083)) with\n    invFun := fun p : M\u2082 \u00d7 M\u2084 => (e\u2081.symm p.1, e\u2082.symm (p.2 - f (e\u2081.symm p.1)))\n    left_inv := fun p => by simp\n    right_inv := fun p => by simp }", "start": [835, 1], "end": [843, 36], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.skewProd_apply", "code": "@[simp]\ntheorem skewProd_apply (f : M \u2192\u2097[R] M\u2084) (x) : e\u2081.skewProd e\u2082 f x = (e\u2081 x.1, e\u2082 x.2 + f x.1)", "start": [846, 1], "end": [848, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.skewProd_symm_apply", "code": "@[simp]\ntheorem skewProd_symm_apply (f : M \u2192\u2097[R] M\u2084) (x) :\n    (e\u2081.skewProd e\u2082 f).symm x = (e\u2081.symm x.1, e\u2082.symm (x.2 - f (e\u2081.symm x.1)))", "start": [851, 1], "end": [854, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_prod_eq", "code": "theorem range_prod_eq {f : M \u2192\u2097[R] M\u2082} {g : M \u2192\u2097[R] M\u2083} (h : ker f \u2294 ker g = \u22a4) :\n    range (prod f g) = (range f).prod (range g)", "start": [869, 1], "end": [882, 93], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tunnelAux", "code": "def tunnelAux (f : M \u00d7 N \u2192\u2097[R] M) (K\u03c6 : \u03a3K : Submodule R M, K \u2243\u2097[R] M) : M \u00d7 N \u2192\u2097[R] M :=\n  (K\u03c6.1.subtype.comp K\u03c6.2.symm.toLinearMap).comp f", "start": [918, 1], "end": [922, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tunnelAux_injective", "code": "theorem tunnelAux_injective (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f)\n    (K\u03c6 : \u03a3K : Submodule R M, K \u2243\u2097[R] M) : Injective (tunnelAux f K\u03c6)", "start": [925, 1], "end": [927, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tunnel'", "code": "def tunnel' (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) : \u2115 \u2192 \u03a3K : Submodule R M, K \u2243\u2097[R] M\n  | 0 => \u27e8\u22a4, LinearEquiv.ofTop \u22a4 rfl\u27e9\n  | n + 1 =>\n    \u27e8(Submodule.fst R M N).map (tunnelAux f (tunnel' f i n)),\n      ((Submodule.fst R M N).equivMapOfInjective _\n        (tunnelAux_injective f i (tunnel' f i n))).symm.trans (Submodule.fstEquiv R M N)\u27e9", "start": [930, 1], "end": [936, 90], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tunnel", "code": "def tunnel (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) : \u2115 \u2192o (Submodule R M)\u1d52\u1d48 :=\n  \u27e8fun n => OrderDual.toDual (tunnel' f i n).1,\n    monotone_nat_of_le_succ fun n => by\n      dsimp [tunnel', tunnelAux]\n      rw [Submodule.map_comp, Submodule.map_comp]\n      apply Submodule.map_subtype_le\u27e9", "start": [939, 1], "end": [947, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailing", "code": "def tailing (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) : Submodule R M :=\n  (Submodule.snd R M N).map (tunnelAux f (tunnel' f i n))", "start": [950, 1], "end": [954, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailingLinearEquiv", "code": "def tailingLinearEquiv (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) : tailing f i n \u2243\u2097[R] N :=\n  ((Submodule.snd R M N).equivMapOfInjective _ (tunnelAux_injective f i (tunnel' f i n))).symm.trans\n    (Submodule.sndEquiv R M N)", "start": [957, 1], "end": [960, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailing_le_tunnel", "code": "theorem tailing_le_tunnel (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    tailing f i n \u2264 OrderDual.ofDual (tunnel f i n)", "start": [963, 1], "end": [967, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailing_disjoint_tunnel_succ", "code": "theorem tailing_disjoint_tunnel_succ (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    Disjoint (tailing f i n) (OrderDual.ofDual $ tunnel f i (n + 1))", "start": [970, 1], "end": [976, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailing_sup_tunnel_succ_le_tunnel", "code": "theorem tailing_sup_tunnel_succ_le_tunnel (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    tailing f i n \u2294 (OrderDual.ofDual $ tunnel f i (n + 1)) \u2264\n      (OrderDual.ofDual $ tunnel f i n)", "start": [979, 1], "end": [984, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailings", "code": "def tailings (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) : \u2115 \u2192 Submodule R M :=\n  partialSups (tailing f i)", "start": [987, 1], "end": [989, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailings_zero", "code": "@[simp]\ntheorem tailings_zero (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) : tailings f i 0 = tailing f i 0", "start": [992, 1], "end": [994, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailings_succ", "code": "@[simp]\ntheorem tailings_succ (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    tailings f i (n + 1) = tailings f i n \u2294 tailing f i (n + 1)", "start": [997, 1], "end": [999, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailings_disjoint_tunnel", "code": "theorem tailings_disjoint_tunnel (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    Disjoint (tailings f i n) (OrderDual.ofDual $ tunnel f i (n + 1))", "start": [1002, 1], "end": [1011, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.tailings_disjoint_tailing", "code": "theorem tailings_disjoint_tailing (f : M \u00d7 N \u2192\u2097[R] M) (i : Injective f) (n : \u2115) :\n    Disjoint (tailings f i n) (tailing f i (n + 1))", "start": [1014, 1], "end": [1016, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.graph", "code": "def graph : Submodule R (M \u00d7 M\u2082)\n    where\n  carrier := { p | p.2 = f p.1 }\n  add_mem' (ha : _ = _) (hb : _ = _) := by\n    change _ + _ = f (_ + _)\n    rw [map_add, ha, hb]\n  zero_mem' := Eq.symm (map_zero f)\n  smul_mem' c x (hx : _ = _) := by\n    change _ \u2022 _ = f (_ \u2022 _)\n    rw [map_smul, hx]", "start": [1026, 1], "end": [1036, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mem_graph_iff", "code": "@[simp]\ntheorem mem_graph_iff (x : M \u00d7 M\u2082) : x \u2208 f.graph \u2194 x.2 = f x.1", "start": [1039, 1], "end": [1041, 10], "kind": "commanddeclaration"}, {"full_name": "LinearMap.graph_eq_ker_coprod", "code": "theorem graph_eq_ker_coprod : g.graph = ker ((-g).coprod LinearMap.id)", "start": [1044, 1], "end": [1047, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.graph_eq_range_prod", "code": "theorem graph_eq_range_prod : f.graph = range (LinearMap.id.prod f)", "start": [1050, 1], "end": [1052, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Finsupp.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/Data/Finsupp/Encodable.lean", "Mathlib/LinearAlgebra/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.lsingle", "code": "def lsingle (a : \u03b1) : M \u2192\u2097[R] \u03b1 \u2192\u2080 M :=\n  { Finsupp.singleAddHom a with map_smul' := fun _ _ => (smul_single _ _ _).symm }", "start": [58, 1], "end": [60, 83], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lhom_ext", "code": "theorem lhom_ext \u2983\u03c6 \u03c8 : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N\u2984 (h : \u2200 a b, \u03c6 (single a b) = \u03c8 (single a b)) : \u03c6 = \u03c8", "start": [63, 1], "end": [65, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lhom_ext'", "code": "@[ext high]\ntheorem lhom_ext' \u2983\u03c6 \u03c8 : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N\u2984 (h : \u2200 a, \u03c6.comp (lsingle a) = \u03c8.comp (lsingle a)) :\n    \u03c6 = \u03c8", "start": [68, 1], "end": [77, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lapply", "code": "def lapply (a : \u03b1) : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] M :=\n  { Finsupp.applyAddHom a with map_smul' := fun _ _ => rfl }", "start": [80, 1], "end": [82, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcoeFun", "code": "@[simps]\ndef lcoeFun : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] \u03b1 \u2192 M where\n  toFun := (\u21d1)\n  map_add' x y := by\n    ext\n    simp\n  map_smul' x y := by\n    ext\n    simp", "start": [85, 1], "end": [96, 9], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsubtypeDomain", "code": "def lsubtypeDomain : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] s \u2192\u2080 M\n    where\n  toFun := subtypeDomain fun x => x \u2208 s\n  map_add' _ _ := subtypeDomain_add\n  map_smul' _ _ := ext fun _ => rfl", "start": [103, 1], "end": [108, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsubtypeDomain_apply", "code": "theorem lsubtypeDomain_apply (f : \u03b1 \u2192\u2080 M) :\n    (lsubtypeDomain s : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] s \u2192\u2080 M) f = subtypeDomain (fun x => x \u2208 s) f", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsingle_apply", "code": "@[simp]\ntheorem lsingle_apply (a : \u03b1) (b : M) : (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M) b = single a b", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lapply_apply", "code": "@[simp]\ntheorem lapply_apply (a : \u03b1) (f : \u03b1 \u2192\u2080 M) : (lapply a : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] M) f = f a", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.ker_lsingle", "code": "@[simp]\ntheorem ker_lsingle (a : \u03b1) : ker (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M) = \u22a5", "start": [128, 1], "end": [130, 47], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsingle_range_le_ker_lapply", "code": "theorem lsingle_range_le_ker_lapply (s t : Set \u03b1) (h : Disjoint s t) :\n    \u2a06 a \u2208 s, LinearMap.range (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M) \u2264\n      \u2a05 a \u2208 t, ker (lapply a : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] M)", "start": [133, 1], "end": [140, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.iInf_ker_lapply_le_bot", "code": "theorem iInf_ker_lapply_le_bot : \u2a05 a, ker (lapply a : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] M) \u2264 \u22a5", "start": [143, 1], "end": [145, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.iSup_lsingle_range", "code": "theorem iSup_lsingle_range : \u2a06 a, LinearMap.range (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M) = \u22a4", "start": [148, 1], "end": [151, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.disjoint_lsingle_lsingle", "code": "theorem disjoint_lsingle_lsingle (s t : Set \u03b1) (hs : Disjoint s t) :\n    Disjoint (\u2a06 a \u2208 s, LinearMap.range (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M))\n      (\u2a06 a \u2208 t, LinearMap.range (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M))", "start": [154, 1], "end": [172, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.span_single_image", "code": "theorem span_single_image (s : Set M) (a : \u03b1) :\n    Submodule.span R (single a '' s) = (Submodule.span R s).map (lsingle a : M \u2192\u2097[R] \u03b1 \u2192\u2080 M)", "start": [175, 1], "end": [177, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported", "code": "def supported (s : Set \u03b1) : Submodule R (\u03b1 \u2192\u2080 M) where\n  carrier := { p | \u2191p.support \u2286 s }\n  add_mem' {p q} hp hq := by\n    classical\n    refine' Subset.trans (Subset.trans (Finset.coe_subset.2 support_add) _) (union_subset hp hq)\n    rw [Finset.coe_union]\n  zero_mem' := by\n    simp only [subset_def, Finset.mem_coe, Set.mem_setOf_eq, mem_support_iff, zero_apply]\n    intro h ha\n    exact (ha rfl).elim\n  smul_mem' a p hp := Subset.trans (Finset.coe_subset.2 support_smul) hp", "start": [182, 1], "end": [193, 73], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_supported", "code": "theorem mem_supported {s : Set \u03b1} (p : \u03b1 \u2192\u2080 M) : p \u2208 supported M R s \u2194 \u2191p.support \u2286 s", "start": [198, 1], "end": [199, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_supported'", "code": "theorem mem_supported' {s : Set \u03b1} (p : \u03b1 \u2192\u2080 M) :\n    p \u2208 supported M R s \u2194 \u2200 (x) (_ : x \u2209 s), p x = 0", "start": [202, 1], "end": [204, 100], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_supported_support", "code": "theorem mem_supported_support (p : \u03b1 \u2192\u2080 M) : p \u2208 Finsupp.supported M R (p.support : Set \u03b1)", "start": [207, 1], "end": [208, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_mem_supported", "code": "theorem single_mem_supported {s : Set \u03b1} {a : \u03b1} (b : M) (h : a \u2208 s) :\n    single a b \u2208 supported M R s", "start": [211, 1], "end": [213, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_eq_span_single", "code": "theorem supported_eq_span_single (s : Set \u03b1) :\n    supported R R s = span R ((fun i => single i 1) '' s)", "start": [216, 1], "end": [227, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.restrictDom", "code": "def restrictDom (s : Set \u03b1) : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] supported M R s :=\n  LinearMap.codRestrict _\n    { toFun := filter (\u00b7 \u2208 s)\n      map_add' := fun _ _ => filter_add\n      map_smul' := fun _ _ => filter_smul } fun l =>\n    (mem_supported' _ _).2 fun _ => filter_apply_neg (\u00b7 \u2208 s) l", "start": [232, 1], "end": [238, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.restrictDom_apply", "code": "@[simp]\ntheorem restrictDom_apply (s : Set \u03b1) (l : \u03b1 \u2192\u2080 M) :\n    ((restrictDom M R s : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] supported M R s) l : \u03b1 \u2192\u2080 M) = Finsupp.filter (\u00b7 \u2208 s) l", "start": [245, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.restrictDom_comp_subtype", "code": "theorem restrictDom_comp_subtype (s : Set \u03b1) :\n    (restrictDom M R s).comp (Submodule.subtype _) = LinearMap.id", "start": [253, 1], "end": [257, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.range_restrictDom", "code": "theorem range_restrictDom (s : Set \u03b1) : LinearMap.range (restrictDom M R s) = \u22a4", "start": [260, 1], "end": [262, 89], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_mono", "code": "theorem supported_mono {s t : Set \u03b1} (st : s \u2286 t) : supported M R s \u2264 supported M R t", "start": [265, 1], "end": [266, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_empty", "code": "@[simp]\ntheorem supported_empty : supported M R (\u2205 : Set \u03b1) = \u22a5", "start": [269, 1], "end": [271, 87], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_univ", "code": "@[simp]\ntheorem supported_univ : supported M R (Set.univ : Set \u03b1) = \u22a4", "start": [274, 1], "end": [276, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_iUnion", "code": "theorem supported_iUnion {\u03b4 : Type*} (s : \u03b4 \u2192 Set \u03b1) :\n    supported M R (\u22c3 i, s i) = \u2a06 i, supported M R (s i)", "start": [279, 1], "end": [295, 83], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_union", "code": "theorem supported_union (s t : Set \u03b1) : supported M R (s \u222a t) = supported M R s \u2294 supported M R t", "start": [298, 1], "end": [299, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_iInter", "code": "theorem supported_iInter {\u03b9 : Type*} (s : \u03b9 \u2192 Set \u03b1) :\n    supported M R (\u22c2 i, s i) = \u2a05 i, supported M R (s i)", "start": [302, 1], "end": [304, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_inter", "code": "theorem supported_inter (s t : Set \u03b1) : supported M R (s \u2229 t) = supported M R s \u2293 supported M R t", "start": [307, 1], "end": [308, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.disjoint_supported_supported", "code": "theorem disjoint_supported_supported {s t : Set \u03b1} (h : Disjoint s t) :\n    Disjoint (supported M R s) (supported M R t)", "start": [311, 1], "end": [313, 96], "kind": "commanddeclaration"}, {"full_name": "Finsupp.disjoint_supported_supported_iff", "code": "theorem disjoint_supported_supported_iff [Nontrivial M] {s t : Set \u03b1} :\n    Disjoint (supported M R s) (supported M R t) \u2194 Disjoint s t", "start": [316, 1], "end": [322, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supportedEquivFinsupp", "code": "def supportedEquivFinsupp (s : Set \u03b1) : supported M R s \u2243\u2097[R] s \u2192\u2080 M := by\n  let F : supported M R s \u2243 (s \u2192\u2080 M) := restrictSupportEquiv s M\n  refine' F.toLinearEquiv _\n  have :\n    (F : supported M R s \u2192 \u21a5s \u2192\u2080 M) =\n      (lsubtypeDomain s : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] s \u2192\u2080 M).comp (Submodule.subtype (supported M R s)) :=\n    rfl\n  rw [this]\n  exact LinearMap.isLinear _", "start": [325, 1], "end": [335, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsum", "code": "def lsum : (\u03b1 \u2192 M \u2192\u2097[R] N) \u2243\u2097[S] (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N where\n  toFun F :=\n    { toFun := fun d => d.sum fun i => F i\n      map_add' := (liftAddHom (\u03b1 := \u03b1) (M := M) (N := N) fun x => (F x).toAddMonoidHom).map_add\n      map_smul' := fun c f => by simp [sum_smul_index', smul_sum] }\n  invFun F x := F.comp (lsingle x)\n  left_inv F := by\n    ext x y\n    simp\n  right_inv F := by\n    ext x y\n    simp\n  map_add' F G := by\n    ext x y\n    simp\n  map_smul' F G := by\n    ext x y\n    simp", "start": [343, 1], "end": [365, 9], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_lsum", "code": "@[simp]\ntheorem coe_lsum (f : \u03b1 \u2192 M \u2192\u2097[R] N) : (lsum S f : (\u03b1 \u2192\u2080 M) \u2192 N) = fun d => d.sum fun i => f i", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsum_apply", "code": "theorem lsum_apply (f : \u03b1 \u2192 M \u2192\u2097[R] N) (l : \u03b1 \u2192\u2080 M) : Finsupp.lsum S f l = l.sum fun b => f b", "start": [373, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsum_single", "code": "theorem lsum_single (f : \u03b1 \u2192 M \u2192\u2097[R] N) (i : \u03b1) (m : M) :\n    Finsupp.lsum S f (Finsupp.single i m) = f i m", "start": [377, 1], "end": [379, 42], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lsum_symm_apply", "code": "theorem lsum_symm_apply (f : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] N) (x : \u03b1) : (lsum S).symm f x = f.comp (lsingle x)", "start": [382, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lift", "code": "noncomputable def lift : (X \u2192 M) \u2243+ ((X \u2192\u2080 R) \u2192\u2097[R] M) :=\n  (AddEquiv.arrowCongr (Equiv.refl X) (ringLmapEquivSelf R \u2115 M).toAddEquiv.symm).trans\n    (lsum _ : _ \u2243\u2097[\u2115] _).toAddEquiv", "start": [393, 1], "end": [398, 36], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (f) (x) : ((lift M R X).symm f) x = f (single x 1)", "start": [401, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lift_apply", "code": "@[simp]\ntheorem lift_apply (f) (g) : ((lift M R X) f) g = g.sum fun x r => r \u2022 f x", "start": [406, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.llift", "code": "noncomputable def llift : (X \u2192 M) \u2243\u2097[S] (X \u2192\u2080 R) \u2192\u2097[R] M :=\n  { lift M R X with\n    map_smul' := by\n      intros\n      dsimp\n      ext\n      simp only [coe_comp, Function.comp_apply, lsingle_apply, lift_apply, Pi.smul_apply,\n        sum_single_index, zero_smul, one_smul, LinearMap.smul_apply] }", "start": [411, 1], "end": [421, 71], "kind": "commanddeclaration"}, {"full_name": "Finsupp.llift_apply", "code": "@[simp]\ntheorem llift_apply (f : X \u2192 M) (x : X \u2192\u2080 R) : llift M R S X f x = lift M R X f x", "start": [424, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.llift_symm_apply", "code": "@[simp]\ntheorem llift_symm_apply (f : (X \u2192\u2080 R) \u2192\u2097[R] M) (x : X) :\n    (llift M R S X).symm f x = f (single x 1)", "start": [429, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain", "code": "def lmapDomain (f : \u03b1 \u2192 \u03b1') : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] \u03b1' \u2192\u2080 M\n    where\n  toFun := mapDomain f\n  map_add' _ _ := mapDomain_add\n  map_smul' := mapDomain_smul", "start": [441, 1], "end": [446, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_apply", "code": "@[simp]\ntheorem lmapDomain_apply (f : \u03b1 \u2192 \u03b1') (l : \u03b1 \u2192\u2080 M) :\n    (lmapDomain M R f : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] \u03b1' \u2192\u2080 M) l = mapDomain f l", "start": [449, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_id", "code": "@[simp]\ntheorem lmapDomain_id : (lmapDomain M R _root_.id : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] \u03b1 \u2192\u2080 M) = LinearMap.id", "start": [455, 1], "end": [457, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_comp", "code": "theorem lmapDomain_comp (f : \u03b1 \u2192 \u03b1') (g : \u03b1' \u2192 \u03b1'') :\n    lmapDomain M R (g \u2218 f) = (lmapDomain M R g).comp (lmapDomain M R f)", "start": [460, 1], "end": [462, 40], "kind": "commanddeclaration"}, {"full_name": "Finsupp.supported_comap_lmapDomain", "code": "theorem supported_comap_lmapDomain (f : \u03b1 \u2192 \u03b1') (s : Set \u03b1') :\n    supported M R (f \u207b\u00b9' s) \u2264 (supported M R s).comap (lmapDomain M R f)", "start": [465, 1], "end": [471, 46], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_supported", "code": "theorem lmapDomain_supported (f : \u03b1 \u2192 \u03b1') (s : Set \u03b1) :\n    (supported M R s).map (lmapDomain M R f) = supported M R (f '' s)", "start": [474, 1], "end": [491, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_disjoint_ker", "code": "theorem lmapDomain_disjoint_ker (f : \u03b1 \u2192 \u03b1') {s : Set \u03b1}\n    (H : \u2200 (a) (_ : a \u2208 s) (b) (_ : b \u2208 s), f a = f b \u2192 a = b) :\n    Disjoint (supported M R s) (ker (lmapDomain M R f))", "start": [494, 1], "end": [513, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcomapDomain", "code": "def lcomapDomain (f : \u03b1 \u2192 \u03b2) (hf : Function.Injective f) : (\u03b2 \u2192\u2080 M) \u2192\u2097[R] \u03b1 \u2192\u2080 M\n    where\n  toFun l := Finsupp.comapDomain f l (hf.injOn _)\n  map_add' x y := by ext; simp\n  map_smul' c x := by ext; simp", "start": [522, 1], "end": [531, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total", "code": "protected def total : (\u03b1 \u2192\u2080 R) \u2192\u2097[R] M :=\n  Finsupp.lsum \u2115 fun i => LinearMap.id.smulRight (v i)", "start": [541, 1], "end": [544, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_apply", "code": "theorem total_apply (l : \u03b1 \u2192\u2080 R) : Finsupp.total \u03b1 M R v l = l.sum fun i a => a \u2022 v i", "start": [549, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_apply_of_mem_supported", "code": "theorem total_apply_of_mem_supported {l : \u03b1 \u2192\u2080 R} {s : Finset \u03b1}\n    (hs : l \u2208 supported R R (\u2191s : Set \u03b1)) : Finsupp.total \u03b1 M R v l = s.sum fun i => l i \u2022 v i", "start": [553, 1], "end": [556, 68], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_single", "code": "@[simp]\ntheorem total_single (c : R) (a : \u03b1) : Finsupp.total \u03b1 M R v (single a c) = c \u2022 v a", "start": [559, 1], "end": [561, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_zero_apply", "code": "theorem total_zero_apply (x : \u03b1 \u2192\u2080 R) : (Finsupp.total \u03b1 M R 0) x = 0", "start": [564, 1], "end": [565, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_zero", "code": "@[simp]\ntheorem total_zero : Finsupp.total \u03b1 M R 0 = 0", "start": [570, 1], "end": [572, 37], "kind": "commanddeclaration"}, {"full_name": "Finsupp.apply_total", "code": "theorem apply_total (f : M \u2192\u2097[R] M') (v) (l : \u03b1 \u2192\u2080 R) :\n    f (Finsupp.total \u03b1 M R v l) = Finsupp.total \u03b1 M' R (f \u2218 v) l", "start": [577, 1], "end": [579, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.apply_total_id", "code": "theorem apply_total_id (f : M \u2192\u2097[R] M') (l : M \u2192\u2080 R) :\n    f (Finsupp.total M M R _root_.id l) = Finsupp.total M M' R f l", "start": [582, 1], "end": [584, 17], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_unique", "code": "theorem total_unique [Unique \u03b1] (l : \u03b1 \u2192\u2080 R) (v) :\n    Finsupp.total \u03b1 M R v l = l default \u2022 v default", "start": [586, 1], "end": [587, 97], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_surjective", "code": "theorem total_surjective (h : Function.Surjective v) :\n    Function.Surjective (Finsupp.total \u03b1 M R v)", "start": [590, 1], "end": [594, 43], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_range", "code": "theorem total_range (h : Function.Surjective v) : LinearMap.range (Finsupp.total \u03b1 M R v) = \u22a4", "start": [597, 1], "end": [598, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_id_surjective", "code": "theorem total_id_surjective (M) [AddCommMonoid M] [Module R M] :\n    Function.Surjective (Finsupp.total M M R _root_.id)", "start": [601, 1], "end": [605, 44], "kind": "commanddeclaration"}, {"full_name": "Finsupp.range_total", "code": "theorem range_total : LinearMap.range (Finsupp.total \u03b1 M R v) = span R (range v)", "start": [608, 1], "end": [622, 14], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lmapDomain_total", "code": "theorem lmapDomain_total (f : \u03b1 \u2192 \u03b1') (g : M \u2192\u2097[R] M') (h : \u2200 i, g (v i) = v' (f i)) :\n    (Finsupp.total \u03b1' M' R v').comp (lmapDomain R R f) = g.comp (Finsupp.total \u03b1 M R v)", "start": [625, 1], "end": [628, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_comp_lmapDomain", "code": "theorem total_comp_lmapDomain (f : \u03b1 \u2192 \u03b1') :\n    (Finsupp.total \u03b1' M' R v').comp (Finsupp.lmapDomain R R f) = Finsupp.total \u03b1 M' R (v' \u2218 f)", "start": [631, 1], "end": [634, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_embDomain", "code": "@[simp]\ntheorem total_embDomain (f : \u03b1 \u21aa \u03b1') (l : \u03b1 \u2192\u2080 R) :\n    (Finsupp.total \u03b1' M' R v') (embDomain f l) = (Finsupp.total \u03b1 M' R (v' \u2218 f)) l", "start": [637, 1], "end": [640, 70], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_mapDomain", "code": "@[simp]\ntheorem total_mapDomain (f : \u03b1 \u2192 \u03b1') (l : \u03b1 \u2192\u2080 R) :\n    (Finsupp.total \u03b1' M' R v') (mapDomain f l) = (Finsupp.total \u03b1 M' R (v' \u2218 f)) l", "start": [643, 1], "end": [646, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_equivMapDomain", "code": "@[simp]\ntheorem total_equivMapDomain (f : \u03b1 \u2243 \u03b1') (l : \u03b1 \u2192\u2080 R) :\n    (Finsupp.total \u03b1' M' R v') (equivMapDomain f l) = (Finsupp.total \u03b1 M' R (v' \u2218 f)) l", "start": [649, 1], "end": [652, 52], "kind": "commanddeclaration"}, {"full_name": "Finsupp.span_eq_range_total", "code": "theorem span_eq_range_total (s : Set M) : span R s = LinearMap.range (Finsupp.total s M R (\u2191))", "start": [655, 1], "end": [657, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_span_iff_total", "code": "theorem mem_span_iff_total (s : Set M) (x : M) :\n    x \u2208 span R s \u2194 \u2203 l : s \u2192\u2080 R, Finsupp.total s M R (\u2191) l = x", "start": [660, 1], "end": [662, 51], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_span_range_iff_exists_finsupp", "code": "theorem mem_span_range_iff_exists_finsupp {v : \u03b1 \u2192 M} {x : M} :\n    x \u2208 span R (range v) \u2194 \u2203 c : \u03b1 \u2192\u2080 R, (c.sum fun i a => a \u2022 v i) = x", "start": [667, 1], "end": [669, 78], "kind": "commanddeclaration"}, {"full_name": "Finsupp.span_image_eq_map_total", "code": "theorem span_image_eq_map_total (s : Set \u03b1) :\n    span R (v '' s) = Submodule.map (Finsupp.total \u03b1 M R v) (supported R R s)", "start": [674, 1], "end": [692, 16], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_span_image_iff_total", "code": "theorem mem_span_image_iff_total {s : Set \u03b1} {x : M} :\n    x \u2208 span R (v '' s) \u2194 \u2203 l \u2208 supported R R s, Finsupp.total \u03b1 M R v l = x", "start": [695, 1], "end": [698, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_option", "code": "theorem total_option (v : Option \u03b1 \u2192 M) (f : Option \u03b1 \u2192\u2080 R) :\n    Finsupp.total (Option \u03b1) M R v f =\n      f none \u2022 v none + Finsupp.total \u03b1 M R (v \u2218 Option.some) f.some", "start": [701, 1], "end": [704, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_total", "code": "theorem total_total {\u03b1 \u03b2 : Type*} (A : \u03b1 \u2192 M) (B : \u03b2 \u2192 \u03b1 \u2192\u2080 R) (f : \u03b2 \u2192\u2080 R) :\n    Finsupp.total \u03b1 M R A (Finsupp.total \u03b2 (\u03b1 \u2192\u2080 R) R B f) =\n      Finsupp.total \u03b2 M R (fun b => Finsupp.total \u03b1 M R A (B b)) f", "start": [707, 1], "end": [716, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_fin_zero", "code": "@[simp]\ntheorem total_fin_zero (f : Fin 0 \u2192 M) : Finsupp.total (Fin 0) M R f = 0", "start": [719, 1], "end": [722, 22], "kind": "commanddeclaration"}, {"full_name": "Finsupp.totalOn", "code": "protected def totalOn (s : Set \u03b1) : supported R R s \u2192\u2097[R] span R (v '' s) :=\n  LinearMap.codRestrict _ ((Finsupp.total _ _ _ v).comp (Submodule.subtype (supported R R s)))\n    fun \u27e8l, hl\u27e9 => (mem_span_image_iff_total _).2 \u27e8l, hl, rfl\u27e9", "start": [727, 1], "end": [734, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.totalOn_range", "code": "theorem totalOn_range (s : Set \u03b1) : LinearMap.range (Finsupp.totalOn \u03b1 M R v s) = \u22a4", "start": [739, 1], "end": [743, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_comp", "code": "theorem total_comp (f : \u03b1' \u2192 \u03b1) :\n    Finsupp.total \u03b1' M R (v \u2218 f) = (Finsupp.total \u03b1 M R v).comp (lmapDomain R R f)", "start": [746, 1], "end": [749, 21], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_comapDomain", "code": "theorem total_comapDomain (f : \u03b1 \u2192 \u03b1') (l : \u03b1' \u2192\u2080 R) (hf : Set.InjOn f (f \u207b\u00b9' \u2191l.support)) :\n    Finsupp.total \u03b1 M R v (Finsupp.comapDomain f l hf) =\n      (l.support.preimage f hf).sum fun i => l (f i) \u2022 v i", "start": [752, 1], "end": [755, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_onFinset", "code": "theorem total_onFinset {s : Finset \u03b1} {f : \u03b1 \u2192 R} (g : \u03b1 \u2192 M) (hf : \u2200 a, f a \u2260 0 \u2192 a \u2208 s) :\n    Finsupp.total \u03b1 M R g (Finsupp.onFinset s f hf) = Finset.sum s fun x : \u03b1 => f x \u2022 g x", "start": [758, 1], "end": [765, 11], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr", "code": "protected def domLCongr {\u03b1\u2081 \u03b1\u2082 : Type*} (e : \u03b1\u2081 \u2243 \u03b1\u2082) : (\u03b1\u2081 \u2192\u2080 M) \u2243\u2097[R] \u03b1\u2082 \u2192\u2080 M :=\n  (Finsupp.domCongr e : (\u03b1\u2081 \u2192\u2080 M) \u2243+ (\u03b1\u2082 \u2192\u2080 M)).toLinearEquiv <| by\n    simpa only [equivMapDomain_eq_mapDomain, domCongr_apply] using (lmapDomain M R e).map_smul", "start": [770, 1], "end": [776, 95], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr_apply", "code": "@[simp]\ntheorem domLCongr_apply {\u03b1\u2081 : Type*} {\u03b1\u2082 : Type*} (e : \u03b1\u2081 \u2243 \u03b1\u2082) (v : \u03b1\u2081 \u2192\u2080 M) :\n    (Finsupp.domLCongr e : _ \u2243\u2097[R] _) v = Finsupp.domCongr e v", "start": [779, 1], "end": [782, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr_refl", "code": "@[simp]\ntheorem domLCongr_refl : Finsupp.domLCongr (Equiv.refl \u03b1) = LinearEquiv.refl R (\u03b1 \u2192\u2080 M)", "start": [785, 1], "end": [787, 49], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr_trans", "code": "theorem domLCongr_trans {\u03b1\u2081 \u03b1\u2082 \u03b1\u2083 : Type*} (f : \u03b1\u2081 \u2243 \u03b1\u2082) (f\u2082 : \u03b1\u2082 \u2243 \u03b1\u2083) :\n    (Finsupp.domLCongr f).trans (Finsupp.domLCongr f\u2082) =\n      (Finsupp.domLCongr (f.trans f\u2082) : (_ \u2192\u2080 M) \u2243\u2097[R] _)", "start": [790, 1], "end": [793, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr_symm", "code": "@[simp]\ntheorem domLCongr_symm {\u03b1\u2081 \u03b1\u2082 : Type*} (f : \u03b1\u2081 \u2243 \u03b1\u2082) :\n    ((Finsupp.domLCongr f).symm : (_ \u2192\u2080 M) \u2243\u2097[R] _) = Finsupp.domLCongr f.symm", "start": [796, 1], "end": [799, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.domLCongr_single", "code": "theorem domLCongr_single {\u03b1\u2081 : Type*} {\u03b1\u2082 : Type*} (e : \u03b1\u2081 \u2243 \u03b1\u2082) (i : \u03b1\u2081) (m : M) :\n    (Finsupp.domLCongr e : _ \u2243\u2097[R] _) (Finsupp.single i m) = Finsupp.single (e i) m", "start": [803, 1], "end": [805, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.congr", "code": "noncomputable def congr {\u03b1' : Type*} (s : Set \u03b1) (t : Set \u03b1') (e : s \u2243 t) :\n    supported M R s \u2243\u2097[R] supported M R t := by\n  haveI := Classical.decPred fun x => x \u2208 s\n  haveI := Classical.decPred fun x => x \u2208 t\n  exact Finsupp.supportedEquivFinsupp s \u226a\u226b\u2097\n    (Finsupp.domLCongr e \u226a\u226b\u2097 (Finsupp.supportedEquivFinsupp t).symm)", "start": [808, 1], "end": [814, 69], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearMap", "code": "def mapRange.linearMap (f : M \u2192\u2097[R] N) : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] \u03b1 \u2192\u2080 N :=\n  { mapRange.addMonoidHom f.toAddMonoidHom with\n    toFun := (mapRange f f.map_zero : (\u03b1 \u2192\u2080 M) \u2192 \u03b1 \u2192\u2080 N)\n    map_smul' := fun c v => mapRange_smul (hf := f.map_zero) c v (f.map_smul c) }", "start": [817, 1], "end": [822, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearMap_apply", "code": "@[simp]\ntheorem mapRange.linearMap_apply (f : M \u2192\u2097[R] N) (g : \u03b1 \u2192\u2080 M) :\n    mapRange.linearMap f g = mapRange f f.map_zero g", "start": [826, 1], "end": [828, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearMap_id", "code": "@[simp]\ntheorem mapRange.linearMap_id :\n    mapRange.linearMap LinearMap.id = (LinearMap.id : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] _)", "start": [831, 1], "end": [834, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearMap_comp", "code": "theorem mapRange.linearMap_comp (f : N \u2192\u2097[R] P) (f\u2082 : M \u2192\u2097[R] N) :\n    (mapRange.linearMap (f.comp f\u2082) : (\u03b1 \u2192\u2080 _) \u2192\u2097[R] _) =\n      (mapRange.linearMap f).comp (mapRange.linearMap f\u2082)", "start": [837, 1], "end": [841, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearMap_toAddMonoidHom", "code": "@[simp]\ntheorem mapRange.linearMap_toAddMonoidHom (f : M \u2192\u2097[R] N) :\n    (mapRange.linearMap f).toAddMonoidHom =\n      (mapRange.addMonoidHom f.toAddMonoidHom : (\u03b1 \u2192\u2080 M) \u2192+ _)", "start": [844, 1], "end": [848, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv", "code": "def mapRange.linearEquiv (e : M \u2243\u2097[R] N) : (\u03b1 \u2192\u2080 M) \u2243\u2097[R] \u03b1 \u2192\u2080 N :=\n  { mapRange.linearMap e.toLinearMap,\n    mapRange.addEquiv e.toAddEquiv with\n    toFun := mapRange e e.map_zero\n    invFun := mapRange e.symm e.symm.map_zero }", "start": [851, 1], "end": [856, 48], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_apply", "code": "@[simp]\ntheorem mapRange.linearEquiv_apply (e : M \u2243\u2097[R] N) (g : \u03b1 \u2192\u2080 M) :\n    mapRange.linearEquiv e g = mapRange.linearMap e.toLinearMap g", "start": [860, 1], "end": [862, 73], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_refl", "code": "@[simp]\ntheorem mapRange.linearEquiv_refl :\n    mapRange.linearEquiv (LinearEquiv.refl R M) = LinearEquiv.refl R (\u03b1 \u2192\u2080 M)", "start": [865, 1], "end": [868, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_trans", "code": "theorem mapRange.linearEquiv_trans (f : M \u2243\u2097[R] N) (f\u2082 : N \u2243\u2097[R] P) :\n    (mapRange.linearEquiv (f.trans f\u2082) : (\u03b1 \u2192\u2080 _) \u2243\u2097[R] _) =\n      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f\u2082)", "start": [871, 1], "end": [875, 85], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_symm", "code": "@[simp]\ntheorem mapRange.linearEquiv_symm (f : M \u2243\u2097[R] N) :\n    ((mapRange.linearEquiv f).symm : (\u03b1 \u2192\u2080 _) \u2243\u2097[R] _) = mapRange.linearEquiv f.symm", "start": [878, 1], "end": [881, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_toAddEquiv", "code": "@[simp 1500]\ntheorem mapRange.linearEquiv_toAddEquiv (f : M \u2243\u2097[R] N) :\n    (mapRange.linearEquiv f).toAddEquiv = (mapRange.addEquiv f.toAddEquiv : (\u03b1 \u2192\u2080 M) \u2243+ _)", "start": [885, 1], "end": [888, 28], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mapRange.linearEquiv_toLinearMap", "code": "@[simp]\ntheorem mapRange.linearEquiv_toLinearMap (f : M \u2243\u2097[R] N) :\n    (mapRange.linearEquiv f).toLinearMap = (mapRange.linearMap f.toLinearMap : (\u03b1 \u2192\u2080 M) \u2192\u2097[R] _)", "start": [891, 1], "end": [894, 29], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcongr", "code": "def lcongr {\u03b9 \u03ba : Sort _} (e\u2081 : \u03b9 \u2243 \u03ba) (e\u2082 : M \u2243\u2097[R] N) : (\u03b9 \u2192\u2080 M) \u2243\u2097[R] \u03ba \u2192\u2080 N :=\n  (Finsupp.domLCongr e\u2081).trans (mapRange.linearEquiv e\u2082)", "start": [897, 1], "end": [900, 57], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcongr_single", "code": "@[simp]\ntheorem lcongr_single {\u03b9 \u03ba : Sort _} (e\u2081 : \u03b9 \u2243 \u03ba) (e\u2082 : M \u2243\u2097[R] N) (i : \u03b9) (m : M) :\n    lcongr e\u2081 e\u2082 (Finsupp.single i m) = Finsupp.single (e\u2081 i) (e\u2082 m)", "start": [903, 1], "end": [905, 89], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcongr_apply_apply", "code": "@[simp]\ntheorem lcongr_apply_apply {\u03b9 \u03ba : Sort _} (e\u2081 : \u03b9 \u2243 \u03ba) (e\u2082 : M \u2243\u2097[R] N) (f : \u03b9 \u2192\u2080 M) (k : \u03ba) :\n    lcongr e\u2081 e\u2082 f k = e\u2082 (f (e\u2081.symm k))", "start": [908, 1], "end": [911, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcongr_symm_single", "code": "theorem lcongr_symm_single {\u03b9 \u03ba : Sort _} (e\u2081 : \u03b9 \u2243 \u03ba) (e\u2082 : M \u2243\u2097[R] N) (k : \u03ba) (n : N) :\n    (lcongr e\u2081 e\u2082).symm (Finsupp.single k n) = Finsupp.single (e\u2081.symm k) (e\u2082.symm n)", "start": [914, 1], "end": [917, 7], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lcongr_symm", "code": "@[simp]\ntheorem lcongr_symm {\u03b9 \u03ba : Sort _} (e\u2081 : \u03b9 \u2243 \u03ba) (e\u2082 : M \u2243\u2097[R] N) :\n    (lcongr e\u2081 e\u2082).symm = lcongr e\u2081.symm e\u2082.symm", "start": [920, 1], "end": [924, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppLEquivProdFinsupp", "code": "@[simps apply symm_apply]\ndef sumFinsuppLEquivProdFinsupp {\u03b1 \u03b2 : Type*} : (Sum \u03b1 \u03b2 \u2192\u2080 M) \u2243\u2097[R] (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M) :=\n  { sumFinsuppAddEquivProdFinsupp with\n    map_smul' := by\n      intros\n      ext <;>\n        simp only [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe, AddEquiv.coe_toEquiv, Prod.smul_fst,\n          Prod.smul_snd, smul_apply,\n          snd_sumFinsuppAddEquivProdFinsupp, fst_sumFinsuppAddEquivProdFinsupp,\n          RingHom.id_apply] }", "start": [931, 1], "end": [945, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.fst_sumFinsuppLEquivProdFinsupp", "code": "theorem fst_sumFinsuppLEquivProdFinsupp {\u03b1 \u03b2 : Type*} (f : Sum \u03b1 \u03b2 \u2192\u2080 M) (x : \u03b1) :\n    (sumFinsuppLEquivProdFinsupp R f).1 x = f (Sum.inl x)", "start": [948, 1], "end": [950, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.snd_sumFinsuppLEquivProdFinsupp", "code": "theorem snd_sumFinsuppLEquivProdFinsupp {\u03b1 \u03b2 : Type*} (f : Sum \u03b1 \u03b2 \u2192\u2080 M) (y : \u03b2) :\n    (sumFinsuppLEquivProdFinsupp R f).2 y = f (Sum.inr y)", "start": [953, 1], "end": [955, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppLEquivProdFinsupp_symm_inl", "code": "theorem sumFinsuppLEquivProdFinsupp_symm_inl {\u03b1 \u03b2 : Type*} (fg : (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M)) (x : \u03b1) :\n    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inl x) = fg.1 x", "start": [958, 1], "end": [960, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sumFinsuppLEquivProdFinsupp_symm_inr", "code": "theorem sumFinsuppLEquivProdFinsupp_symm_inr {\u03b1 \u03b2 : Type*} (fg : (\u03b1 \u2192\u2080 M) \u00d7 (\u03b2 \u2192\u2080 M)) (y : \u03b2) :\n    ((sumFinsuppLEquivProdFinsupp R).symm fg) (Sum.inr y) = fg.2 y", "start": [963, 1], "end": [965, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppLEquivPiFinsupp", "code": "noncomputable def sigmaFinsuppLEquivPiFinsupp {M : Type*} {\u03b9s : \u03b7 \u2192 Type*} [AddCommMonoid M]\n    [Module R M] : ((\u03a3 j, \u03b9s j) \u2192\u2080 M) \u2243\u2097[R] (j : _) \u2192 (\u03b9s j \u2192\u2080 M) :=\n  { sigmaFinsuppAddEquivPiFinsupp (\u03b9s := \u03b9s) with\n    map_smul' := fun c f => by\n      ext\n      simp }", "start": [976, 1], "end": [986, 13], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppLEquivPiFinsupp_apply", "code": "@[simp]\ntheorem sigmaFinsuppLEquivPiFinsupp_apply {M : Type*} {\u03b9s : \u03b7 \u2192 Type*} [AddCommMonoid M]\n    [Module R M] (f : (\u03a3j, \u03b9s j) \u2192\u2080 M) (j i) : sigmaFinsuppLEquivPiFinsupp R f j i = f \u27e8j, i\u27e9", "start": [989, 1], "end": [992, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sigmaFinsuppLEquivPiFinsupp_symm_apply", "code": "@[simp]\ntheorem sigmaFinsuppLEquivPiFinsupp_symm_apply {M : Type*} {\u03b9s : \u03b7 \u2192 Type*} [AddCommMonoid M]\n    [Module R M] (f : (j : _) \u2192 (\u03b9s j \u2192\u2080 M)) (ji) :\n    (Finsupp.sigmaFinsuppLEquivPiFinsupp R).symm f ji = f ji.1 ji.2", "start": [995, 1], "end": [999, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finsuppProdLEquiv", "code": "noncomputable def finsuppProdLEquiv {\u03b1 \u03b2 : Type*} (R : Type*) {M : Type*} [Semiring R]\n    [AddCommMonoid M] [Module R M] : (\u03b1 \u00d7 \u03b2 \u2192\u2080 M) \u2243\u2097[R] \u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M :=\n  { finsuppProdEquiv with\n    map_add' := fun f g => by\n      ext\n      simp [finsuppProdEquiv, curry_apply]\n    map_smul' := fun c f => by\n      ext\n      simp [finsuppProdEquiv, curry_apply] }", "start": [1006, 1], "end": [1017, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finsuppProdLEquiv_apply", "code": "@[simp]\ntheorem finsuppProdLEquiv_apply {\u03b1 \u03b2 R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : \u03b1 \u00d7 \u03b2 \u2192\u2080 M) (x y) : finsuppProdLEquiv R f x y = f (x, y)", "start": [1020, 1], "end": [1023, 84], "kind": "commanddeclaration"}, {"full_name": "Finsupp.finsuppProdLEquiv_symm_apply", "code": "@[simp]\ntheorem finsuppProdLEquiv_symm_apply {\u03b1 \u03b2 R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M]\n    (f : \u03b1 \u2192\u2080 \u03b2 \u2192\u2080 M) (xy) : (finsuppProdLEquiv R).symm f xy = f xy.1 xy.2", "start": [1026, 1], "end": [1030, 77], "kind": "commanddeclaration"}, {"full_name": "Fintype.total", "code": "protected def Fintype.total : (\u03b1 \u2192 M) \u2192\u2097[S] (\u03b1 \u2192 R) \u2192\u2097[R] M where\n  toFun v :=\n    { toFun := fun f => \u2211 i, f i \u2022 v i\n      map_add' := fun f g => by simp_rw [\u2190 Finset.sum_add_distrib, \u2190 add_smul]; rfl\n      map_smul' := fun r f => by simp_rw [Finset.smul_sum, smul_smul]; rfl }\n  map_add' u v := by ext; simp [Finset.sum_add_distrib, Pi.add_apply, smul_add]\n  map_smul' r v := by ext; simp [Finset.smul_sum, smul_comm]", "start": [1053, 1], "end": [1065, 61], "kind": "commanddeclaration"}, {"full_name": "Fintype.total_apply", "code": "theorem Fintype.total_apply (f) : Fintype.total R S v f = \u2211 i, f i \u2022 v i", "start": [1070, 1], "end": [1071, 6], "kind": "commanddeclaration"}, {"full_name": "Fintype.total_apply_single", "code": "@[simp]\ntheorem Fintype.total_apply_single [DecidableEq \u03b1] (i : \u03b1) (r : R) :\n    Fintype.total R S v (Pi.single i r) = r \u2022 v i", "start": [1074, 1], "end": [1078, 54], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_eq_fintype_total_apply", "code": "theorem Finsupp.total_eq_fintype_total_apply (x : \u03b1 \u2192 R) : Finsupp.total \u03b1 M R v\n    ((Finsupp.linearEquivFunOnFinite R R \u03b1).symm x) = Fintype.total R S v x", "start": [1083, 1], "end": [1089, 24], "kind": "commanddeclaration"}, {"full_name": "Finsupp.total_eq_fintype_total", "code": "theorem Finsupp.total_eq_fintype_total :\n    (Finsupp.total \u03b1 M R v).comp (Finsupp.linearEquivFunOnFinite R R \u03b1).symm.toLinearMap =\n      Fintype.total R S v", "start": [1092, 1], "end": [1095, 62], "kind": "commanddeclaration"}, {"full_name": "Fintype.range_total", "code": "@[simp]\ntheorem Fintype.range_total :\n    LinearMap.range (Fintype.total R S v) = Submodule.span R (Set.range v)", "start": [1100, 1], "end": [1104, 44], "kind": "commanddeclaration"}, {"full_name": "mem_span_range_iff_exists_fun", "code": "theorem mem_span_range_iff_exists_fun :\n    x \u2208 span R (range v) \u2194 \u2203 c : \u03b1 \u2192 R, \u2211 i, c i \u2022 v i = x", "start": [1111, 1], "end": [1118, 94], "kind": "commanddeclaration"}, {"full_name": "top_le_span_range_iff_forall_exists_fun", "code": "theorem top_le_span_range_iff_forall_exists_fun :\n    \u22a4 \u2264 span R (range v) \u2194 \u2200 x, \u2203 c : \u03b1 \u2192 R, \u2211 i, c i \u2022 v i = x", "start": [1121, 1], "end": [1127, 49], "kind": "commanddeclaration"}, {"full_name": "Span.repr", "code": "irreducible_def Span.repr (w : Set M) (x : span R w) : w \u2192\u2080 R :=\n  ((Finsupp.mem_span_iff_total _ _ _).mp x.2).choose", "start": [1142, 1], "end": [1146, 53], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Span.finsupp_total_repr", "code": "@[simp]\ntheorem Span.finsupp_total_repr {w : Set M} (x : span R w) :\n    Finsupp.total w M R (\u2191) (Span.repr R w x) = x", "start": [1149, 1], "end": [1153, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.finsupp_sum_mem", "code": "protected theorem Submodule.finsupp_sum_mem {\u03b9 \u03b2 : Type*} [Zero \u03b2] (S : Submodule R M) (f : \u03b9 \u2192\u2080 \u03b2)\n    (g : \u03b9 \u2192 \u03b2 \u2192 M) (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 S) : f.sum g \u2208 S", "start": [1158, 1], "end": [1160, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_finsupp_total", "code": "theorem LinearMap.map_finsupp_total (f : M \u2192\u2097[R] N) {\u03b9 : Type*} {g : \u03b9 \u2192 M} (l : \u03b9 \u2192\u2080 R) :\n    f (Finsupp.total \u03b9 M R g l) = Finsupp.total \u03b9 N R (f \u2218 g) l", "start": [1163, 1], "end": [1166, 96], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_finset_of_mem_iSup", "code": "theorem Submodule.exists_finset_of_mem_iSup {\u03b9 : Sort _} (p : \u03b9 \u2192 Submodule R M) {m : M}\n    (hm : m \u2208 \u2a06 i, p i) : \u2203 s : Finset \u03b9, m \u2208 \u2a06 i \u2208 s, p i", "start": [1169, 1], "end": [1175, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_iff_exists_finset", "code": "theorem Submodule.mem_iSup_iff_exists_finset {\u03b9 : Sort _} {p : \u03b9 \u2192 Submodule R M} {m : M} :\n    (m \u2208 \u2a06 i, p i) \u2194 \u2203 s : Finset \u03b9, m \u2208 \u2a06 i \u2208 s, p i", "start": [1178, 1], "end": [1182, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_sSup_iff_exists_finset", "code": "theorem Submodule.mem_sSup_iff_exists_finset {S : Set (Submodule R M)} {m : M} :\n    m \u2208 sSup S \u2194 \u2203 s : Finset (Submodule R M), \u2191s \u2286 S \u2227 m \u2208 \u2a06 i \u2208 s, i", "start": [1185, 1], "end": [1194, 68], "kind": "commanddeclaration"}, {"full_name": "mem_span_finset", "code": "theorem mem_span_finset {s : Finset M} {x : M} :\n    x \u2208 span R (\u2191s : Set M) \u2194 \u2203 f : M \u2192 R, \u2211 i in s, f i \u2022 i = x", "start": [1196, 1], "end": [1203, 76], "kind": "commanddeclaration"}, {"full_name": "mem_span_set", "code": "theorem mem_span_set {m : M} {s : Set M} :\n    m \u2208 Submodule.span R s \u2194\n      \u2203 c : M \u2192\u2080 R, (c.support : Set M) \u2286 s \u2227 (c.sum fun mi r => r \u2022 mi) = m", "start": [1206, 1], "end": [1213, 69], "kind": "commanddeclaration"}, {"full_name": "mem_span_set'", "code": "lemma mem_span_set' {m : M} {s : Set M} :\n    m \u2208 Submodule.span R s \u2194 \u2203 (n : \u2115) (f : Fin n \u2192 R) (g : Fin n \u2192 s),\n      \u2211 i, f i \u2022 (g i : M) = m := by\n  refine \u27e8fun h \u21a6 ?_, ?_\u27e9\n  \u00b7 rcases mem_span_set.1 h with \u27e8c, cs, rfl\u27e9\n    have A : c.support \u2243 Fin c.support.card := Finset.equivFin _\n    refine \u27e8_, fun i \u21a6 c (A.symm i), fun i \u21a6 \u27e8A.symm i, cs (A.symm i).2\u27e9, ?_\u27e9\n    rw [Finsupp.sum, \u2190 Finset.sum_coe_sort c.support]\n    exact Fintype.sum_equiv A.symm _ (fun j \u21a6 c j \u2022 (j : M)) (fun i \u21a6 rfl)\n  \u00b7 rintro \u27e8n, f, g, rfl\u27e9\n    exact Submodule.sum_mem _ (fun i _ \u21a6 Submodule.smul_mem _ _ (Submodule.subset_span (g i).2))", "start": [1216, 1], "end": [1229, 97], "kind": "mathlibtacticlemma"}, {"full_name": "span_eq_iUnion_nat", "code": "lemma span_eq_iUnion_nat (s : Set M) :\n    (Submodule.span R s : Set M) = \u22c3 (n : \u2115),\n      (fun (f : Fin n \u2192 (R \u00d7 M)) \u21a6 \u2211 i, (f i).1 \u2022 (f i).2) '' ({f | \u2200 i, (f i).2 \u2208 s}) := by\n  ext m\n  simp only [SetLike.mem_coe, mem_iUnion, mem_image, mem_setOf_eq, mem_span_set']\n  refine exists_congr (fun n \u21a6 \u27e8?_, ?_\u27e9)\n  \u00b7 rintro \u27e8f, g, rfl\u27e9\n    exact \u27e8fun i \u21a6 (f i, g i), fun i \u21a6 (g i).2, rfl\u27e9\n  \u00b7 rintro \u27e8f, hf, rfl\u27e9\n    exact \u27e8fun i \u21a6 (f i).1, fun i \u21a6 \u27e8(f i).2, (hf i)\u27e9, rfl\u27e9", "start": [1231, 1], "end": [1242, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Module.subsingletonEquiv", "code": "@[simps]\ndef Module.subsingletonEquiv (R M \u03b9 : Type*) [Semiring R] [Subsingleton R] [AddCommMonoid M]\n    [Module R M] : M \u2243\u2097[R] \u03b9 \u2192\u2080 R where\n  toFun _ := 0\n  invFun _ := 0\n  left_inv m := by\n    letI := Module.subsingleton R M\n    simp only [eq_iff_true_of_subsingleton]\n  right_inv f := by simp only [eq_iff_true_of_subsingleton]\n  map_add' _ _ := (add_zero 0).symm\n  map_smul' r _ := (smul_zero r).symm", "start": [1244, 1], "end": [1255, 38], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFinsuppSurjective", "code": "def splittingOfFinsuppSurjective (f : M \u2192\u2097[R] \u03b1 \u2192\u2080 R) (s : Surjective f) : (\u03b1 \u2192\u2080 R) \u2192\u2097[R] M :=\n  Finsupp.lift _ _ _ fun x : \u03b1 => (s (Finsupp.single x 1)).choose", "start": [1265, 1], "end": [1267, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFinsuppSurjective_splits", "code": "theorem splittingOfFinsuppSurjective_splits (f : M \u2192\u2097[R] \u03b1 \u2192\u2080 R) (s : Surjective f) :\n    f.comp (splittingOfFinsuppSurjective f s) = LinearMap.id", "start": [1270, 1], "end": [1278, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.leftInverse_splittingOfFinsuppSurjective", "code": "theorem leftInverse_splittingOfFinsuppSurjective (f : M \u2192\u2097[R] \u03b1 \u2192\u2080 R) (s : Surjective f) :\n    LeftInverse f (splittingOfFinsuppSurjective f s)", "start": [1281, 1], "end": [1283, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFinsuppSurjective_injective", "code": "theorem splittingOfFinsuppSurjective_injective (f : M \u2192\u2097[R] \u03b1 \u2192\u2080 R) (s : Surjective f) :\n    Injective (splittingOfFinsuppSurjective f s)", "start": [1286, 1], "end": [1288, 59], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFunOnFintypeSurjective", "code": "def splittingOfFunOnFintypeSurjective [Fintype \u03b1] (f : M \u2192\u2097[R] \u03b1 \u2192 R) (s : Surjective f) :\n    (\u03b1 \u2192 R) \u2192\u2097[R] M :=\n  (Finsupp.lift _ _ _ fun x : \u03b1 => (s (Finsupp.single x 1)).choose).comp\n    (linearEquivFunOnFinite R R \u03b1).symm.toLinearMap", "start": [1292, 1], "end": [1296, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFunOnFintypeSurjective_splits", "code": "theorem splittingOfFunOnFintypeSurjective_splits [Fintype \u03b1] (f : M \u2192\u2097[R] \u03b1 \u2192 R)\n    (s : Surjective f) : f.comp (splittingOfFunOnFintypeSurjective f s) = LinearMap.id", "start": [1299, 1], "end": [1307, 17], "kind": "commanddeclaration"}, {"full_name": "LinearMap.leftInverse_splittingOfFunOnFintypeSurjective", "code": "theorem leftInverse_splittingOfFunOnFintypeSurjective [Fintype \u03b1] (f : M \u2192\u2097[R] \u03b1 \u2192 R)\n    (s : Surjective f) : LeftInverse f (splittingOfFunOnFintypeSurjective f s)", "start": [1310, 1], "end": [1312, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.splittingOfFunOnFintypeSurjective_injective", "code": "theorem splittingOfFunOnFintypeSurjective_injective [Fintype \u03b1] (f : M \u2192\u2097[R] \u03b1 \u2192 R)\n    (s : Surjective f) : Injective (splittingOfFunOnFintypeSurjective f s)", "start": [1315, 1], "end": [1317, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/Basic.lean", "imports": ["Mathlib/Order/SuccPred/Limit.lean", "Mathlib/Tactic/Positivity.lean", "Mathlib/Data/Nat/PartENat.lean", "Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/SetTheory/Cardinal/SchroederBernstein.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Logic/Small/Basic.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Data/Finsupp/Defs.lean", "Mathlib/Data/Set/Countable.lean"], "premises": [{"full_name": "Cardinal.isEquivalent", "code": "instance Cardinal.isEquivalent : Setoid (Type u) where\n  r \u03b1 \u03b2 := Nonempty (\u03b1 \u2243 \u03b2)\n  iseqv := \u27e8\n    fun \u03b1 => \u27e8Equiv.refl \u03b1\u27e9,\n    fun \u27e8e\u27e9 => \u27e8e.symm\u27e9,\n    fun \u27e8e\u2081\u27e9 \u27e8e\u2082\u27e9 => \u27e8e\u2081.trans e\u2082\u27e9\u27e9", "start": [93, 1], "end": [101, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal", "code": "@[pp_with_univ]\ndef Cardinal : Type (u + 1) :=\n  Quotient Cardinal.isEquivalent", "start": [104, 1], "end": [109, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk", "code": "def mk : Type u \u2192 Cardinal :=\n  Quotient.mk'", "start": [114, 1], "end": [116, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.canLiftCardinalType", "code": "instance canLiftCardinalType : CanLift Cardinal.{u} (Type u) mk fun _ => True :=\n  \u27e8fun c _ => Quot.inductionOn c fun \u03b1 => \u27e8\u03b1, rfl\u27e9\u27e9", "start": [122, 1], "end": [123, 52], "kind": "commanddeclaration"}, {"full_name": "Cardinal.inductionOn", "code": "@[elab_as_elim]\ntheorem inductionOn {p : Cardinal \u2192 Prop} (c : Cardinal) (h : \u2200 \u03b1, p #\u03b1) : p c", "start": [126, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.inductionOn\u2082", "code": "@[elab_as_elim]\ntheorem inductionOn\u2082 {p : Cardinal \u2192 Cardinal \u2192 Prop} (c\u2081 : Cardinal) (c\u2082 : Cardinal)\n    (h : \u2200 \u03b1 \u03b2, p #\u03b1 #\u03b2) : p c\u2081 c\u2082", "start": [131, 1], "end": [134, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.inductionOn\u2083", "code": "@[elab_as_elim]\ntheorem inductionOn\u2083 {p : Cardinal \u2192 Cardinal \u2192 Cardinal \u2192 Prop} (c\u2081 : Cardinal) (c\u2082 : Cardinal)\n    (c\u2083 : Cardinal) (h : \u2200 \u03b1 \u03b2 \u03b3, p #\u03b1 #\u03b2 #\u03b3) : p c\u2081 c\u2082 c\u2083", "start": [137, 1], "end": [140, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq", "code": "protected theorem eq : #\u03b1 = #\u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "start": [143, 1], "end": [144, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk'_def", "code": "@[simp]\ntheorem mk'_def (\u03b1 : Type u) : @Eq Cardinal \u27e6\u03b1\u27e7 #\u03b1", "start": [147, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_out", "code": "@[simp]\ntheorem mk_out (c : Cardinal) : #c.out = c", "start": [152, 1], "end": [154, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.outMkEquiv", "code": "def outMkEquiv {\u03b1 : Type v} : (#\u03b1).out \u2243 \u03b1 :=\n  Nonempty.some <| Cardinal.eq.mp (by simp)", "start": [157, 1], "end": [159, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_congr", "code": "theorem mk_congr (e : \u03b1 \u2243 \u03b2) : #\u03b1 = #\u03b2", "start": [162, 1], "end": [163, 17], "kind": "commanddeclaration"}, {"full_name": "Equiv.cardinal_eq", "code": "alias _root_.Equiv.cardinal_eq := mk_congr", "start": [166, 1], "end": [166, 43], "kind": "stdtacticaliasalias"}, {"full_name": "Cardinal.map", "code": "def map (f : Type u \u2192 Type v) (hf : \u2200 \u03b1 \u03b2, \u03b1 \u2243 \u03b2 \u2192 f \u03b1 \u2243 f \u03b2) : Cardinal.{u} \u2192 Cardinal.{v} :=\n  Quotient.map f fun \u03b1 \u03b2 \u27e8e\u27e9 => \u27e8hf \u03b1 \u03b2 e\u27e9", "start": [169, 1], "end": [171, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.map_mk", "code": "@[simp]\ntheorem map_mk (f : Type u \u2192 Type v) (hf : \u2200 \u03b1 \u03b2, \u03b1 \u2243 \u03b2 \u2192 f \u03b1 \u2243 f \u03b2) (\u03b1 : Type u) :\n    map f hf #\u03b1 = #(f \u03b1)", "start": [174, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.map\u2082", "code": "def map\u2082 (f : Type u \u2192 Type v \u2192 Type w) (hf : \u2200 \u03b1 \u03b2 \u03b3 \u03b4, \u03b1 \u2243 \u03b2 \u2192 \u03b3 \u2243 \u03b4 \u2192 f \u03b1 \u03b3 \u2243 f \u03b2 \u03b4) :\n    Cardinal.{u} \u2192 Cardinal.{v} \u2192 Cardinal.{w} :=\n  Quotient.map\u2082 f fun \u03b1 \u03b2 \u27e8e\u2081\u27e9 \u03b3 \u03b4 \u27e8e\u2082\u27e9 => \u27e8hf \u03b1 \u03b2 \u03b3 \u03b4 e\u2081 e\u2082\u27e9", "start": [180, 1], "end": [183, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift", "code": "@[pp_with_univ]\ndef lift (c : Cardinal.{v}) : Cardinal.{max v u} :=\n  map ULift.{u, v} (fun _ _ e => Equiv.ulift.trans <| e.trans Equiv.ulift.symm) c", "start": [186, 1], "end": [190, 82], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_uLift", "code": "@[simp]\ntheorem mk_uLift (\u03b1) : #(ULift.{v, u} \u03b1) = lift.{v} #\u03b1", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_umax", "code": "@[simp, nolint simpNF]\ntheorem lift_umax : lift.{max u v, u} = lift.{v, u}", "start": [200, 1], "end": [203, 90], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_umax'", "code": "@[simp, nolint simpNF]\ntheorem lift_umax' : lift.{max v u, u} = lift.{v, u}", "start": [208, 1], "end": [211, 12], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_id'", "code": "@[simp, nolint simpNF]\ntheorem lift_id' (a : Cardinal.{max u v}) : lift.{u} a = a", "start": [216, 1], "end": [219, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_id", "code": "@[simp]\ntheorem lift_id (a : Cardinal) : lift.{u, u} a = a", "start": [222, 1], "end": [225, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_uzero", "code": "theorem lift_uzero (a : Cardinal.{u}) : lift.{0} a = a", "start": [228, 1], "end": [232, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lift", "code": "@[simp]\ntheorem lift_lift.{u_1} (a : Cardinal.{u_1}) : lift.{w} (lift.{v} a) = lift.{max v w} a", "start": [235, 1], "end": [237, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.partialOrder", "code": "instance partialOrder : PartialOrder Cardinal.{u} where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl := by\n    rintro \u27e8\u03b1\u27e9\n    exact \u27e8Embedding.refl _\u27e9\n  le_trans := by\n    rintro \u27e8\u03b1\u27e9 \u27e8\u03b2\u27e9 \u27e8\u03b3\u27e9 \u27e8e\u2081\u27e9 \u27e8e\u2082\u27e9\n    exact \u27e8e\u2081.trans e\u2082\u27e9\n  le_antisymm := by\n    rintro \u27e8\u03b1\u27e9 \u27e8\u03b2\u27e9 \u27e8e\u2081\u27e9 \u27e8e\u2082\u27e9\n    exact Quotient.sound (e\u2081.antisymm e\u2082)", "start": [247, 1], "end": [257, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.linearOrder", "code": "instance linearOrder : LinearOrder Cardinal.{u} :=\n  { Cardinal.partialOrder with\n    le_total := by\n      rintro \u27e8\u03b1\u27e9 \u27e8\u03b2\u27e9\n      apply Embedding.total\n    decidableLE := Classical.decRel _ }", "start": [259, 1], "end": [264, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_def", "code": "theorem le_def (\u03b1 \u03b2 : Type u) : #\u03b1 \u2264 #\u03b2 \u2194 Nonempty (\u03b1 \u21aa \u03b2)", "start": [266, 1], "end": [267, 10], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_of_injective", "code": "theorem mk_le_of_injective {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) : #\u03b1 \u2264 #\u03b2", "start": [270, 1], "end": [271, 12], "kind": "commanddeclaration"}, {"full_name": "Function.Embedding.cardinal_le", "code": "theorem _root_.Function.Embedding.cardinal_le {\u03b1 \u03b2 : Type u} (f : \u03b1 \u21aa \u03b2) : #\u03b1 \u2264 #\u03b2", "start": [274, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_of_surjective", "code": "theorem mk_le_of_surjective {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} (hf : Surjective f) : #\u03b2 \u2264 #\u03b1", "start": [278, 1], "end": [279, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_mk_iff_exists_set", "code": "theorem le_mk_iff_exists_set {c : Cardinal} {\u03b1 : Type u} : c \u2264 #\u03b1 \u2194 \u2203 p : Set \u03b1, #p = c", "start": [282, 1], "end": [284, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subtype_le", "code": "theorem mk_subtype_le {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) : #(Subtype p) \u2264 #\u03b1", "start": [287, 1], "end": [288, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_set_le", "code": "theorem mk_set_le (s : Set \u03b1) : #s \u2264 #\u03b1", "start": [291, 1], "end": [292, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_down", "code": "@[simp]\nlemma mk_preimage_down {s : Set \u03b1} : #(ULift.down.{v} \u207b\u00b9' s) = lift.{v} (#s) := by\n  rw [\u2190 mk_uLift, Cardinal.eq]\n  constructor\n  let f : ULift.down \u207b\u00b9' s \u2192 ULift s := fun x \u21a6 ULift.up (restrictPreimage s ULift.down x)\n  have : Function.Bijective f :=\n    ULift.up_bijective.comp (restrictPreimage_bijective _ (ULift.down_bijective))\n  exact Equiv.ofBijective f this", "start": [295, 1], "end": [302, 33], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.out_embedding", "code": "theorem out_embedding {c c' : Cardinal} : c \u2264 c' \u2194 Nonempty (c.out \u21aa c'.out)", "start": [304, 1], "end": [307, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_le", "code": "theorem lift_mk_le {\u03b1 : Type v} {\u03b2 : Type w} :\n    lift.{max u w} #\u03b1 \u2264 lift.{max u v} #\u03b2 \u2194 Nonempty (\u03b1 \u21aa \u03b2)", "start": [310, 1], "end": [313, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_le'", "code": "theorem lift_mk_le' {\u03b1 : Type u} {\u03b2 : Type v} : lift.{v} #\u03b1 \u2264 lift.{u} #\u03b2 \u2194 Nonempty (\u03b1 \u21aa \u03b2)", "start": [316, 1], "end": [321, 17], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_eq", "code": "theorem lift_mk_eq {\u03b1 : Type u} {\u03b2 : Type v} :\n    lift.{max v w} #\u03b1 = lift.{max u w} #\u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "start": [324, 1], "end": [328, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_eq'", "code": "theorem lift_mk_eq' {\u03b1 : Type u} {\u03b2 : Type v} : lift.{v} #\u03b1 = lift.{u} #\u03b2 \u2194 Nonempty (\u03b1 \u2243 \u03b2)", "start": [331, 1], "end": [336, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_le", "code": "@[simp]\ntheorem lift_le {a b : Cardinal.{v}} : lift.{u, v} a \u2264 lift.{u, v} b \u2194 a \u2264 b", "start": [339, 1], "end": [343, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.liftOrderEmbedding", "code": "@[simps! (config := { fullyApplied := false })]\ndef liftOrderEmbedding : Cardinal.{v} \u21aao Cardinal.{max v u} :=\n  OrderEmbedding.ofMapLEIff lift.{u, v} fun _ _ => lift_le", "start": [347, 1], "end": [350, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_injective", "code": "theorem lift_injective : Injective lift.{u, v}", "start": [353, 1], "end": [354, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_inj", "code": "@[simp]\ntheorem lift_inj {a b : Cardinal.{u}} : lift.{v, u} a = lift.{v, u} b \u2194 a = b", "start": [357, 1], "end": [359, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt", "code": "@[simp]\ntheorem lift_lt {a b : Cardinal.{u}} : lift.{v, u} a < lift.{v, u} b \u2194 a < b", "start": [362, 1], "end": [364, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_strictMono", "code": "theorem lift_strictMono : StrictMono lift", "start": [367, 1], "end": [367, 66], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_monotone", "code": "theorem lift_monotone : Monotone lift", "start": [370, 1], "end": [371, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_zero", "code": "theorem mk_eq_zero (\u03b1 : Type u) [IsEmpty \u03b1] : #\u03b1 = 0", "start": [381, 1], "end": [382, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_zero", "code": "@[simp]\ntheorem lift_zero : lift 0 = 0", "start": [385, 1], "end": [386, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_eq_zero", "code": "@[simp]\ntheorem lift_eq_zero {a : Cardinal.{v}} : lift.{u} a = 0 \u2194 a = 0", "start": [389, 1], "end": [391, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_zero_iff", "code": "theorem mk_eq_zero_iff {\u03b1 : Type u} : #\u03b1 = 0 \u2194 IsEmpty \u03b1", "start": [394, 1], "end": [398, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_ne_zero_iff", "code": "theorem mk_ne_zero_iff {\u03b1 : Type u} : #\u03b1 \u2260 0 \u2194 Nonempty \u03b1", "start": [401, 1], "end": [402, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_ne_zero", "code": "@[simp]\ntheorem mk_ne_zero (\u03b1 : Type u) [Nonempty \u03b1] : #\u03b1 \u2260 0", "start": [405, 1], "end": [407, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_one", "code": "theorem mk_eq_one (\u03b1 : Type u) [Unique \u03b1] : #\u03b1 = 1", "start": [417, 1], "end": [418, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_one_iff_subsingleton", "code": "theorem le_one_iff_subsingleton {\u03b1 : Type u} : #\u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "start": [421, 1], "end": [423, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_one_iff_set_subsingleton", "code": "@[simp]\ntheorem mk_le_one_iff_set_subsingleton {s : Set \u03b1} : #s \u2264 1 \u2194 s.Subsingleton", "start": [426, 1], "end": [428, 51], "kind": "commanddeclaration"}, {"full_name": "Set.Subsingleton.cardinal_mk_le_one", "code": "alias \u27e8_, _root_.Set.Subsingleton.cardinal_mk_le_one\u27e9 := mk_le_one_iff_set_subsingleton", "start": [431, 1], "end": [431, 88], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Cardinal.add_def", "code": "theorem add_def (\u03b1 \u03b2 : Type u) : #\u03b1 + #\u03b2 = #(Sum \u03b1 \u03b2)", "start": [437, 1], "end": [438, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_sum", "code": "@[simp]\ntheorem mk_sum (\u03b1 : Type u) (\u03b2 : Type v) : #(\u03b1 \u2295 \u03b2) = lift.{v, u} #\u03b1 + lift.{u, v} #\u03b2", "start": [444, 1], "end": [446, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_option", "code": "@[simp]\ntheorem mk_option {\u03b1 : Type u} : #(Option \u03b1) = #\u03b1 + 1", "start": [449, 1], "end": [451, 99], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_psum", "code": "@[simp]\ntheorem mk_psum (\u03b1 : Type u) (\u03b2 : Type v) : #(PSum \u03b1 \u03b2) = lift.{v} #\u03b1 + lift.{u} #\u03b2", "start": [454, 1], "end": [456, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_fintype", "code": "@[simp]\ntheorem mk_fintype (\u03b1 : Type u) [h : Fintype \u03b1] : #\u03b1 = Fintype.card \u03b1", "start": [459, 1], "end": [461, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cast_succ", "code": "protected theorem cast_succ (n : \u2115) : ((n + 1 : \u2115) : Cardinal.{u}) = n + 1", "start": [463, 1], "end": [466, 72], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_def", "code": "theorem mul_def (\u03b1 \u03b2 : Type u) : #\u03b1 * #\u03b2 = #(\u03b1 \u00d7 \u03b2)", "start": [471, 1], "end": [472, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_prod", "code": "@[simp]\ntheorem mk_prod (\u03b1 : Type u) (\u03b2 : Type v) : #(\u03b1 \u00d7 \u03b2) = lift.{v, u} #\u03b1 * lift.{u, v} #\u03b2", "start": [475, 1], "end": [477, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_comm'", "code": "private theorem mul_comm' (a b : Cardinal.{u}) : a * b = b * a", "start": [480, 1], "end": [481, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.instPowCardinal", "code": "instance instPowCardinal : Pow Cardinal.{u} Cardinal.{u} :=\n  \u27e8map\u2082 (fun \u03b1 \u03b2 => \u03b2 \u2192 \u03b1) fun _ _ _ _ e\u2081 e\u2082 => e\u2082.arrowCongr e\u2081\u27e9", "start": [483, 1], "end": [485, 66], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_def", "code": "theorem power_def (\u03b1 \u03b2) : #\u03b1 ^ #\u03b2 = #(\u03b2 \u2192 \u03b1)", "start": [496, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_arrow", "code": "theorem mk_arrow (\u03b1 : Type u) (\u03b2 : Type v) : #(\u03b1 \u2192 \u03b2) = (lift.{u} #\u03b2^lift.{v} #\u03b1)", "start": [500, 1], "end": [501, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_power", "code": "@[simp]\ntheorem lift_power (a b : Cardinal.{u}) : lift.{v} (a ^ b) = ((lift.{v} a) ^ (lift.{v} b))", "start": [504, 1], "end": [507, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_zero", "code": "@[simp]\ntheorem power_zero {a : Cardinal} : (a ^ 0) = 1", "start": [510, 1], "end": [512, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_one", "code": "@[simp]\ntheorem power_one {a : Cardinal.{u}} : (a ^ 1) = a", "start": [515, 1], "end": [517, 74], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_add", "code": "theorem power_add {a b c : Cardinal} : (a ^ (b + c)) = (a ^ b) * (a ^ c)", "start": [520, 1], "end": [521, 81], "kind": "commanddeclaration"}, {"full_name": "Cardinal.commSemiring", "code": "instance commSemiring : CommSemiring Cardinal.{u} where\n  zero := 0\n  one := 1\n  add := (\u00b7 + \u00b7)\n  mul := (\u00b7 * \u00b7)\n  zero_add a := inductionOn a fun \u03b1 => mk_congr <| Equiv.emptySum (ULift (Fin 0)) \u03b1\n  add_zero a := inductionOn a fun \u03b1 => mk_congr <| Equiv.sumEmpty \u03b1 (ULift (Fin 0))\n  add_assoc a b c := inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.sumAssoc \u03b1 \u03b2 \u03b3\n  add_comm a b := inductionOn\u2082 a b fun \u03b1 \u03b2 => mk_congr <| Equiv.sumComm \u03b1 \u03b2\n  zero_mul a := inductionOn a fun \u03b1 => mk_eq_zero _\n  mul_zero a := inductionOn a fun \u03b1 => mk_eq_zero _\n  one_mul a := inductionOn a fun \u03b1 => mk_congr <| Equiv.uniqueProd \u03b1 (ULift (Fin 1))\n  mul_one a := inductionOn a fun \u03b1 => mk_congr <| Equiv.prodUnique \u03b1 (ULift (Fin 1))\n  mul_assoc a b c := inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.prodAssoc \u03b1 \u03b2 \u03b3\n  mul_comm := mul_comm'\n  left_distrib a b c := inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.prodSumDistrib \u03b1 \u03b2 \u03b3\n  right_distrib a b c := inductionOn\u2083 a b c fun \u03b1 \u03b2 \u03b3 => mk_congr <| Equiv.sumProdDistrib \u03b1 \u03b2 \u03b3\n  npow n c := c^n\n  npow_zero := @power_zero\n  npow_succ n c := show (c ^ (n + 1 : \u2115)) = c * (c ^ n)\n    by rw [Cardinal.cast_succ, power_add, power_one, mul_comm']\n  natCast := (fun n => lift.{u} #(Fin n) : \u2115 \u2192 Cardinal.{u})\n  natCast_zero := rfl\n  natCast_succ := Cardinal.cast_succ", "start": [524, 1], "end": [547, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_bit0", "code": "@[deprecated]\ntheorem power_bit0 (a b : Cardinal) : (a ^ bit0 b) = (a ^ b) * (a ^ b)", "start": [553, 1], "end": [555, 12], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_bit1", "code": "@[deprecated]\ntheorem power_bit1 (a b : Cardinal) : (a ^ bit1 b) = (a ^ b) * (a ^ b) * a", "start": [558, 1], "end": [560, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_power", "code": "@[simp]\ntheorem one_power {a : Cardinal} : (1 ^ a) = 1", "start": [565, 1], "end": [567, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_bool", "code": "theorem mk_bool : #Bool = 2", "start": [572, 1], "end": [572, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_Prop", "code": "theorem mk_Prop : #Prop = 2", "start": [577, 1], "end": [577, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.zero_power", "code": "@[simp]\ntheorem zero_power {a : Cardinal} : a \u2260 0 \u2192 (0 ^ a) = 0", "start": [580, 1], "end": [586, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_ne_zero", "code": "theorem power_ne_zero {a : Cardinal} (b) : a \u2260 0 \u2192 (a ^ b) \u2260 0", "start": [589, 1], "end": [592, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_power", "code": "theorem mul_power {a b c : Cardinal} : ((a * b) ^ c) = (a ^ c) * (b ^ c)", "start": [595, 1], "end": [596, 82], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_mul", "code": "theorem power_mul {a b c : Cardinal} : (a ^ (b * c)) = ((a ^ b) ^ c)", "start": [599, 1], "end": [601, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.pow_cast_right", "code": "@[simp]\ntheorem pow_cast_right (a : Cardinal.{u}) (n : \u2115) : (a^(\u2191n : Cardinal.{u})) = a ^\u2115 n", "start": [604, 1], "end": [606, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_one", "code": "@[simp]\ntheorem lift_one : lift 1 = 1", "start": [609, 1], "end": [610, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_add", "code": "@[simp]\ntheorem lift_add (a b : Cardinal.{u}) : lift.{v} (a + b) = lift.{v} a + lift.{v} b", "start": [613, 1], "end": [616, 80], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mul", "code": "@[simp]\ntheorem lift_mul (a b : Cardinal.{u}) : lift.{v} (a * b) = lift.{v} a * lift.{v} b", "start": [619, 1], "end": [622, 81], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_bit0", "code": "@[simp, deprecated]\ntheorem lift_bit0 (a : Cardinal) : lift.{v} (bit0 a) = bit0 (lift.{v} a)", "start": [629, 1], "end": [631, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_bit1", "code": "@[simp, deprecated]\ntheorem lift_bit1 (a : Cardinal) : lift.{v} (bit1 a) = bit1 (lift.{v} a)", "start": [634, 1], "end": [635, 91], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_two", "code": "theorem lift_two : lift.{u, v} 2 = 2", "start": [641, 1], "end": [641, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_set", "code": "@[simp]\ntheorem mk_set {\u03b1 : Type u} : #(Set \u03b1) = (2 ^ #\u03b1)", "start": [644, 1], "end": [645, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_powerset", "code": "@[simp]\ntheorem mk_powerset {\u03b1 : Type u} (s : Set \u03b1) : #(\u21a5(\ud835\udcab s)) = (2 ^ #(\u21a5s))", "start": [648, 1], "end": [651, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_two_power", "code": "theorem lift_two_power (a) : lift.{v} (2 ^ a) = (2 ^ lift.{v} a)", "start": [654, 1], "end": [654, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.zero_le", "code": "protected theorem zero_le : \u2200 a : Cardinal, 0 \u2264 a", "start": [661, 1], "end": [663, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_le_add'", "code": "private theorem add_le_add' : \u2200 {a b c d : Cardinal}, a \u2264 b \u2192 c \u2264 d \u2192 a + c \u2264 b + d", "start": [666, 1], "end": [667, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_covariantClass", "code": "instance add_covariantClass : CovariantClass Cardinal Cardinal (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => add_le_add' le_rfl\u27e9", "start": [670, 1], "end": [671, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_swap_covariantClass", "code": "instance add_swap_covariantClass : CovariantClass Cardinal Cardinal (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ h => add_le_add' h le_rfl\u27e9", "start": [674, 1], "end": [675, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.canonicallyOrderedCommSemiring", "code": "instance canonicallyOrderedCommSemiring : CanonicallyOrderedCommSemiring Cardinal.{u} :=\n  { Cardinal.commSemiring,\n    Cardinal.partialOrder with\n    bot := 0\n    bot_le := Cardinal.zero_le\n    add_le_add_left := fun a b => add_le_add_left\n    exists_add_of_le := fun {a b} =>\n      inductionOn\u2082 a b fun \u03b1 \u03b2 \u27e8\u27e8f, hf\u27e9\u27e9 =>\n        have : Sum \u03b1 ((range f)\u1d9c : Set \u03b2) \u2243 \u03b2 :=\n          (Equiv.sumCongr (Equiv.ofInjective f hf) (Equiv.refl _)).trans <|\n            Equiv.Set.sumCompl (range f)\n        \u27e8#(\u21a5(range f)\u1d9c), mk_congr this.symm\u27e9\n    le_self_add := fun a b => (add_zero a).ge.trans <| add_le_add_left (Cardinal.zero_le _) _\n    eq_zero_or_eq_zero_of_mul_eq_zero := fun {a b} =>\n      inductionOn\u2082 a b fun \u03b1 \u03b2 => by\n        simpa only [mul_def, mk_eq_zero_iff, isEmpty_prod] using id }", "start": [678, 1], "end": [693, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.zero_power_le", "code": "theorem zero_power_le (c : Cardinal.{u}) : ((0 : Cardinal.{u})^c) \u2264 1", "start": [717, 1], "end": [721, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_le_power_left", "code": "theorem power_le_power_left : \u2200 {a b c : Cardinal}, a \u2260 0 \u2192 b \u2264 c \u2192 (a^b) \u2264 (a^c)", "start": [724, 1], "end": [727, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.self_le_power", "code": "theorem self_le_power (a : Cardinal) {b : Cardinal} (hb : 1 \u2264 b) : a \u2264 (a^b)", "start": [730, 1], "end": [734, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantor", "code": "theorem cantor (a : Cardinal.{u}) : a < (2^a)", "start": [737, 1], "end": [743, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_lt_iff_nontrivial", "code": "theorem one_lt_iff_nontrivial {\u03b1 : Type u} : 1 < #\u03b1 \u2194 Nontrivial \u03b1", "start": [751, 1], "end": [752, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_le_max_power_one", "code": "theorem power_le_max_power_one {a b c : Cardinal} (h : b \u2264 c) : (a^b) \u2264 max (a^c) 1", "start": [755, 1], "end": [758, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_le_power_right", "code": "theorem power_le_power_right {a b c : Cardinal} : a \u2264 b \u2192 (a^c) \u2264 (b^c)", "start": [761, 1], "end": [762, 68], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_pos", "code": "theorem power_pos {a : Cardinal} (b) (ha : 0 < a) : 0 < (a^b)", "start": [765, 1], "end": [766, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_wf", "code": "protected theorem lt_wf : @WellFounded Cardinal.{u} (\u00b7 < \u00b7)", "start": [771, 1], "end": [781, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.wo", "code": "instance wo : @IsWellOrder Cardinal.{u} (\u00b7 < \u00b7) where", "start": [791, 1], "end": [791, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf (\u2205 : Set Cardinal.{u}) = 0", "start": [797, 1], "end": [799, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.succ_def", "code": "theorem succ_def (c : Cardinal) : succ c = sInf { c' | c < c' }", "start": [810, 1], "end": [811, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.succ_pos", "code": "theorem succ_pos : \u2200 c : Cardinal, 0 < succ c", "start": [814, 1], "end": [815, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.succ_ne_zero", "code": "theorem succ_ne_zero (c : Cardinal) : succ c \u2260 0", "start": [818, 1], "end": [819, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_one_le_succ", "code": "theorem add_one_le_succ (c : Cardinal.{u}) : c + 1 \u2264 succ c", "start": [822, 1], "end": [834, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsLimit", "code": "def IsLimit (c : Cardinal) : Prop :=\n  c \u2260 0 \u2227 IsSuccLimit c", "start": [837, 1], "end": [842, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsLimit.ne_zero", "code": "protected theorem IsLimit.ne_zero {c} (h : IsLimit c) : c \u2260 0", "start": [845, 1], "end": [846, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsLimit.isSuccLimit", "code": "protected theorem IsLimit.isSuccLimit {c} (h : IsLimit c) : IsSuccLimit c", "start": [849, 1], "end": [850, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsLimit.succ_lt", "code": "theorem IsLimit.succ_lt {x c} (h : IsLimit c) : x < c \u2192 succ x < c", "start": [853, 1], "end": [854, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isSuccLimit_zero", "code": "theorem isSuccLimit_zero : IsSuccLimit (0 : Cardinal)", "start": [857, 1], "end": [858, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum", "code": "def sum {\u03b9} (f : \u03b9 \u2192 Cardinal) : Cardinal :=\n  mk (\u03a3i, (f i).out)", "start": [861, 1], "end": [864, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_sum", "code": "theorem le_sum {\u03b9} (f : \u03b9 \u2192 Cardinal) (i) : f i \u2264 sum f", "start": [867, 1], "end": [869, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_sigma", "code": "@[simp]\ntheorem mk_sigma {\u03b9} (f : \u03b9 \u2192 Type*) : #(\u03a3 i, f i) = sum fun i => #(f i)", "start": [872, 1], "end": [874, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_const", "code": "@[simp]\ntheorem sum_const (\u03b9 : Type u) (a : Cardinal.{v}) :\n    (sum fun _ : \u03b9 => a) = lift.{v} #\u03b9 * lift.{u} a", "start": [877, 1], "end": [884, 96], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_const'", "code": "theorem sum_const' (\u03b9 : Type u) (a : Cardinal.{u}) : (sum fun _ : \u03b9 => a) = #\u03b9 * a", "start": [887, 1], "end": [887, 94], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_add_distrib", "code": "@[simp]\ntheorem sum_add_distrib {\u03b9} (f g : \u03b9 \u2192 Cardinal) : sum (f + g) = sum f + sum g", "start": [890, 1], "end": [894, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_add_distrib'", "code": "@[simp]\ntheorem sum_add_distrib' {\u03b9} (f g : \u03b9 \u2192 Cardinal) :\n    (Cardinal.sum fun i => f i + g i) = sum f + sum g", "start": [897, 1], "end": [900, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_sum", "code": "@[simp]\ntheorem lift_sum {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{v}) :\n    Cardinal.lift.{w} (Cardinal.sum f) = Cardinal.sum fun i => Cardinal.lift.{w} (f i)", "start": [903, 1], "end": [910, 81], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_le_sum", "code": "theorem sum_le_sum {\u03b9} (f g : \u03b9 \u2192 Cardinal) (H : \u2200 i, f i \u2264 g i) : sum f \u2264 sum g", "start": [913, 1], "end": [915, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_mk_mul_of_mk_preimage_le", "code": "theorem mk_le_mk_mul_of_mk_preimage_le {c : Cardinal} (f : \u03b1 \u2192 \u03b2) (hf : \u2200 b : \u03b2, #(f \u207b\u00b9' {b}) \u2264 c) :\n    #\u03b1 \u2264 #\u03b2 * c", "start": [918, 1], "end": [921, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le", "code": "theorem lift_mk_le_lift_mk_mul_of_lift_mk_preimage_le {\u03b1 : Type u} {\u03b2 : Type v} {c : Cardinal}\n    (f : \u03b1 \u2192 \u03b2) (hf : \u2200 b : \u03b2, lift.{v} #(f \u207b\u00b9' {b}) \u2264 c) : lift.{v} #\u03b1 \u2264 lift.{u} #\u03b2 * c", "start": [924, 1], "end": [940, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bddAbove_range", "code": "theorem bddAbove_range {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{max u v}) : BddAbove (Set.range f)", "start": [943, 1], "end": [949, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bddAbove_iff_small", "code": "theorem bddAbove_iff_small {s : Set Cardinal.{u}} : BddAbove s \u2194 Small.{u} s", "start": [961, 1], "end": [972, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bddAbove_of_small", "code": "theorem bddAbove_of_small (s : Set Cardinal.{u}) [h : Small.{u} s] : BddAbove s", "start": [975, 1], "end": [976, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bddAbove_image", "code": "theorem bddAbove_image (f : Cardinal.{u} \u2192 Cardinal.{max u v}) {s : Set Cardinal.{u}}\n    (hs : BddAbove s) : BddAbove (f '' s)", "start": [979, 1], "end": [983, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bddAbove_range_comp", "code": "theorem bddAbove_range_comp {\u03b9 : Type u} {f : \u03b9 \u2192 Cardinal.{v}} (hf : BddAbove (range f))\n    (g : Cardinal.{v} \u2192 Cardinal.{max v w}) : BddAbove (range (g \u2218 f))", "start": [986, 1], "end": [989, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.iSup_le_sum", "code": "theorem iSup_le_sum {\u03b9} (f : \u03b9 \u2192 Cardinal) : iSup f \u2264 sum f", "start": [992, 1], "end": [993, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_le_iSup_lift", "code": "theorem sum_le_iSup_lift {\u03b9 : Type u}\n    (f : \u03b9 \u2192 Cardinal.{max u v}) : sum f \u2264 Cardinal.lift.{v,_} #\u03b9 * iSup f", "start": [997, 1], "end": [1000, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_le_iSup", "code": "theorem sum_le_iSup {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal.{u}) : sum f \u2264 #\u03b9 * iSup f", "start": [1003, 1], "end": [1005, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_nat_eq_add_sum_succ", "code": "theorem sum_nat_eq_add_sum_succ (f : \u2115 \u2192 Cardinal.{u}) :\n    Cardinal.sum f = f 0 + Cardinal.sum fun i => f (i + 1)", "start": [1008, 1], "end": [1011, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.iSup_of_empty", "code": "protected theorem iSup_of_empty {\u03b9} (f : \u03b9 \u2192 Cardinal) [IsEmpty \u03b9] : iSup f = 0", "start": [1016, 1], "end": [1018, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_shrink", "code": "@[simp, nolint simpNF]\ntheorem lift_mk_shrink (\u03b1 : Type u) [Small.{v} \u03b1] :\n    Cardinal.lift.{max u w} #(Shrink.{v} \u03b1) = Cardinal.lift.{max v w} #\u03b1", "start": [1022, 1], "end": [1026, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_shrink'", "code": "@[simp]\ntheorem lift_mk_shrink' (\u03b1 : Type u) [Small.{v} \u03b1] :\n    Cardinal.lift.{u} #(Shrink.{v} \u03b1) = Cardinal.lift.{v} #\u03b1", "start": [1029, 1], "end": [1032, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_shrink''", "code": "@[simp]\ntheorem lift_mk_shrink'' (\u03b1 : Type max u v) [Small.{v} \u03b1] :\n    Cardinal.lift.{u} #(Shrink.{v} \u03b1) = #\u03b1", "start": [1035, 1], "end": [1038, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod", "code": "def prod {\u03b9 : Type u} (f : \u03b9 \u2192 Cardinal) : Cardinal :=\n  #(\u2200 i, (f i).out)", "start": [1041, 1], "end": [1044, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_pi", "code": "@[simp]\ntheorem mk_pi {\u03b9 : Type u} (\u03b1 : \u03b9 \u2192 Type v) : #(\u2200 i, \u03b1 i) = prod fun i => #(\u03b1 i)", "start": [1047, 1], "end": [1049, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_const", "code": "@[simp]\ntheorem prod_const (\u03b9 : Type u) (a : Cardinal.{v}) :\n    (prod fun _ : \u03b9 => a) = (lift.{u} a^lift.{v} #\u03b9)", "start": [1052, 1], "end": [1056, 90], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_const'", "code": "theorem prod_const' (\u03b9 : Type u) (a : Cardinal.{u}) : (prod fun _ : \u03b9 => a) = (a^#\u03b9)", "start": [1059, 1], "end": [1060, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_le_prod", "code": "theorem prod_le_prod {\u03b9} (f g : \u03b9 \u2192 Cardinal) (H : \u2200 i, f i \u2264 g i) : prod f \u2264 prod g", "start": [1063, 1], "end": [1065, 88], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_eq_zero", "code": "@[simp]\ntheorem prod_eq_zero {\u03b9} (f : \u03b9 \u2192 Cardinal.{u}) : prod f = 0 \u2194 \u2203 i, f i = 0", "start": [1068, 1], "end": [1071, 50], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_ne_zero", "code": "theorem prod_ne_zero {\u03b9} (f : \u03b9 \u2192 Cardinal) : prod f \u2260 0 \u2194 \u2200 i, f i \u2260 0", "start": [1074, 1], "end": [1074, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_prod", "code": "@[simp]\ntheorem lift_prod {\u03b9 : Type u} (c : \u03b9 \u2192 Cardinal.{v}) :\n    lift.{w} (prod c) = prod fun i => lift.{w} (c i)", "start": [1077, 1], "end": [1082, 85], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_eq_of_fintype", "code": "theorem prod_eq_of_fintype {\u03b1 : Type u} [h : Fintype \u03b1] (f : \u03b1 \u2192 Cardinal.{v}) :\n    prod f = Cardinal.lift.{u} (\u220f i, f i)", "start": [1085, 1], "end": [1098, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_sInf", "code": "@[simp]\ntheorem lift_sInf (s : Set Cardinal) : lift.{u,v} (sInf s) = sInf (lift.{u,v} '' s)", "start": [1102, 1], "end": [1106, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iInf", "code": "@[simp]\ntheorem lift_iInf {\u03b9} (f : \u03b9 \u2192 Cardinal) : lift.{u,v} (iInf f) = \u2a05 i, lift.{u,v} (f i)", "start": [1110, 1], "end": [1114, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_down", "code": "theorem lift_down {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b \u2264 lift.{v,u} a \u2192 \u2203 a', lift.{v,u} a' = b", "start": [1117, 1], "end": [1125, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_lift_iff", "code": "theorem le_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b \u2264 lift.{v,u} a \u2194 \u2203 a', lift.{v,u} a' = b \u2227 a' \u2264 a", "start": [1129, 1], "end": [1134, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_lift_iff", "code": "theorem lt_lift_iff {a : Cardinal.{u}} {b : Cardinal.{max u v}} :\n    b < lift.{v,u} a \u2194 \u2203 a', lift.{v,u} a' = b \u2227 a' < a", "start": [1138, 1], "end": [1143, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_succ", "code": "@[simp]\ntheorem lift_succ (a) : lift.{v,u} (succ a) = succ (lift.{v,u} a)", "start": [1147, 1], "end": [1154, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_umax_eq", "code": "@[simp, nolint simpNF]\ntheorem lift_umax_eq {a : Cardinal.{u}} {b : Cardinal.{v}} :\n    lift.{max v w} a = lift.{max u w} b \u2194 lift.{v} a = lift.{u} b", "start": [1159, 1], "end": [1162, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_min", "code": "@[simp]\ntheorem lift_min {a b : Cardinal} : lift.{u,v} (min a b) = min (lift.{u,v} a) (lift.{u,v} b)", "start": [1166, 1], "end": [1168, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_max", "code": "@[simp]\ntheorem lift_max {a b : Cardinal} : lift.{u,v} (max a b) = max (lift.{u,v} a) (lift.{u,v} b)", "start": [1172, 1], "end": [1174, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_sSup", "code": "theorem lift_sSup {s : Set Cardinal} (hs : BddAbove s) :\n    lift.{u} (sSup s) = sSup (lift.{u} '' s)", "start": [1177, 1], "end": [1188, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iSup", "code": "theorem lift_iSup {\u03b9 : Type v} {f : \u03b9 \u2192 Cardinal.{w}} (hf : BddAbove (range f)) :\n    lift.{u} (iSup f) = \u2a06 i, lift.{u} (f i)", "start": [1191, 1], "end": [1195, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iSup_le", "code": "theorem lift_iSup_le {\u03b9 : Type v} {f : \u03b9 \u2192 Cardinal.{w}} {t : Cardinal} (hf : BddAbove (range f))\n    (w : \u2200 i, lift.{u} (f i) \u2264 t) : lift.{u} (iSup f) \u2264 t", "start": [1198, 1], "end": [1203, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iSup_le_iff", "code": "@[simp]\ntheorem lift_iSup_le_iff {\u03b9 : Type v} {f : \u03b9 \u2192 Cardinal.{w}} (hf : BddAbove (range f))\n    {t : Cardinal} : lift.{u} (iSup f) \u2264 t \u2194 \u2200 i, lift.{u} (f i) \u2264 t", "start": [1206, 1], "end": [1210, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iSup_le_lift_iSup", "code": "theorem lift_iSup_le_lift_iSup {\u03b9 : Type v} {\u03b9' : Type v'} {f : \u03b9 \u2192 Cardinal.{w}}\n    {f' : \u03b9' \u2192 Cardinal.{w'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) {g : \u03b9 \u2192 \u03b9'}\n    (h : \u2200 i, lift.{w'} (f i) \u2264 lift.{w} (f' (g i))) : lift.{w'} (iSup f) \u2264 lift.{w} (iSup f')", "start": [1215, 1], "end": [1223, 74], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_iSup_le_lift_iSup'", "code": "theorem lift_iSup_le_lift_iSup' {\u03b9 : Type v} {\u03b9' : Type v'} {f : \u03b9 \u2192 Cardinal.{v}}\n    {f' : \u03b9' \u2192 Cardinal.{v'}} (hf : BddAbove (range f)) (hf' : BddAbove (range f')) (g : \u03b9 \u2192 \u03b9')\n    (h : \u2200 i, lift.{v'} (f i) \u2264 lift.{v} (f' (g i))) : lift.{v'} (iSup f) \u2264 lift.{v} (iSup f')", "start": [1226, 1], "end": [1231, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0", "code": "def aleph0 : Cardinal.{u} :=\n  lift #\u2115", "start": [1234, 1], "end": [1236, 10], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_nat", "code": "theorem mk_nat : #\u2115 = \u2135\u2080", "start": [1243, 1], "end": [1244, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_ne_zero", "code": "theorem aleph0_ne_zero : \u2135\u2080 \u2260 0", "start": [1247, 1], "end": [1248, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_pos", "code": "theorem aleph0_pos : 0 < \u2135\u2080", "start": [1251, 1], "end": [1252, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_aleph0", "code": "@[simp]\ntheorem lift_aleph0 : lift \u2135\u2080 = \u2135\u2080", "start": [1255, 1], "end": [1257, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_lift", "code": "@[simp]\ntheorem aleph0_le_lift {c : Cardinal.{u}} : \u2135\u2080 \u2264 lift.{v} c \u2194 \u2135\u2080 \u2264 c", "start": [1260, 1], "end": [1262, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_le_aleph0", "code": "@[simp]\ntheorem lift_le_aleph0 {c : Cardinal.{u}} : lift.{v} c \u2264 \u2135\u2080 \u2194 c \u2264 \u2135\u2080", "start": [1265, 1], "end": [1267, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_lt_lift", "code": "@[simp]\ntheorem aleph0_lt_lift {c : Cardinal.{u}} : \u2135\u2080 < lift.{v} c \u2194 \u2135\u2080 < c", "start": [1270, 1], "end": [1272, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt_aleph0", "code": "@[simp]\ntheorem lift_lt_aleph0 {c : Cardinal.{u}} : lift.{v} c < \u2135\u2080 \u2194 c < \u2135\u2080", "start": [1275, 1], "end": [1277, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_fin", "code": "theorem mk_fin (n : \u2115) : #(Fin n) = n", "start": [1284, 1], "end": [1284, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_natCast", "code": "@[simp]\ntheorem lift_natCast (n : \u2115) : lift.{u} (n : Cardinal.{v}) = n", "start": [1287, 1], "end": [1288, 94], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_eq_nat_iff", "code": "@[simp]\ntheorem lift_eq_nat_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a = n \u2194 a = n", "start": [1291, 1], "end": [1293, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_eq_lift_iff", "code": "@[simp]\ntheorem nat_eq_lift_iff {n : \u2115} {a : Cardinal.{u}} :\n    (n : Cardinal) = lift.{v} a \u2194 (n : Cardinal) = a", "start": [1296, 1], "end": [1299, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_le_nat_iff", "code": "@[simp]\ntheorem lift_le_nat_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a \u2264 n \u2194 a \u2264 n", "start": [1302, 1], "end": [1304, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_le_lift_iff", "code": "@[simp]\ntheorem nat_le_lift_iff {n : \u2115} {a : Cardinal.{u}} : n \u2264 lift.{v} a \u2194 n \u2264 a", "start": [1307, 1], "end": [1309, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt_nat_iff", "code": "@[simp]\ntheorem lift_lt_nat_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a < n \u2194 a < n", "start": [1312, 1], "end": [1314, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_lt_lift_iff", "code": "@[simp]\ntheorem nat_lt_lift_iff {n : \u2115} {a : Cardinal.{u}} : n < lift.{v} a \u2194 n < a", "start": [1317, 1], "end": [1319, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_fin", "code": "theorem lift_mk_fin (n : \u2115) : lift #(Fin n) = n", "start": [1322, 1], "end": [1322, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_coe_finset", "code": "theorem mk_coe_finset {\u03b1 : Type u} {s : Finset \u03b1} : #s = \u2191(Finset.card s)", "start": [1325, 1], "end": [1325, 85], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finset_of_fintype", "code": "theorem mk_finset_of_fintype [Fintype \u03b1] : #(Finset \u03b1) = 2 ^\u2115 Fintype.card \u03b1", "start": [1328, 1], "end": [1329, 17], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_lift_of_fintype", "code": "@[simp]\ntheorem mk_finsupp_lift_of_fintype (\u03b1 : Type u) (\u03b2 : Type v) [Fintype \u03b1] [Zero \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = lift.{u} #\u03b2 ^\u2115 Fintype.card \u03b1", "start": [1332, 1], "end": [1335, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_of_fintype", "code": "theorem mk_finsupp_of_fintype (\u03b1 \u03b2 : Type u) [Fintype \u03b1] [Zero \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = #\u03b2 ^\u2115 Fintype.card \u03b1", "start": [1338, 1], "end": [1339, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_le_of_finset", "code": "theorem card_le_of_finset {\u03b1} (s : Finset \u03b1) : (s.card : Cardinal) \u2264 #\u03b1", "start": [1342, 1], "end": [1343, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_pow", "code": "@[norm_cast]\ntheorem natCast_pow {m n : \u2115} : (\u2191(m ^ n) : Cardinal) = (m^n)", "start": [1348, 1], "end": [1350, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_le", "code": "@[norm_cast]\ntheorem natCast_le {m n : \u2115} : (m : Cardinal) \u2264 n \u2194 m \u2264 n", "start": [1355, 1], "end": [1358, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_lt", "code": "@[norm_cast]\ntheorem natCast_lt {m n : \u2115} : (m : Cardinal) < n \u2194 m < n", "start": [1363, 1], "end": [1367, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_inj", "code": "theorem natCast_inj {m n : \u2115} : (m : Cardinal) = n \u2194 m = n", "start": [1373, 1], "end": [1374, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_injective", "code": "theorem natCast_injective : Injective ((\u2191) : \u2115 \u2192 Cardinal)", "start": [1377, 1], "end": [1378, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_succ", "code": "@[simp, norm_cast]\ntheorem nat_succ (n : \u2115) : (n.succ : Cardinal) = succ \u2191n", "start": [1381, 1], "end": [1386, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.succ_zero", "code": "@[simp]\ntheorem succ_zero : succ (0 : Cardinal) = 1", "start": [1388, 1], "end": [1389, 60], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_le_of", "code": "theorem card_le_of {\u03b1 : Type u} {n : \u2115} (H : \u2200 s : Finset \u03b1, s.card \u2264 n) : #\u03b1 \u2264 n", "start": [1392, 1], "end": [1398, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cantor'", "code": "theorem cantor' (a) {b : Cardinal} (hb : 1 < b) : a < (b^a)", "start": [1401, 1], "end": [1403, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_le_iff_pos", "code": "theorem one_le_iff_pos {c : Cardinal} : 1 \u2264 c \u2194 0 < c", "start": [1406, 1], "end": [1407, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_le_iff_ne_zero", "code": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 \u2264 c \u2194 c \u2260 0", "start": [1410, 1], "end": [1411, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_lt_aleph0", "code": "theorem nat_lt_aleph0 (n : \u2115) : (n : Cardinal.{u}) < \u2135\u2080", "start": [1414, 1], "end": [1418, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_lt_aleph0", "code": "@[simp]\ntheorem one_lt_aleph0 : 1 < \u2135\u2080", "start": [1421, 1], "end": [1422, 65], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_le_aleph0", "code": "theorem one_le_aleph0 : 1 \u2264 \u2135\u2080", "start": [1425, 1], "end": [1426, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_aleph0", "code": "theorem lt_aleph0 {c : Cardinal} : c < \u2135\u2080 \u2194 \u2203 n : \u2115, c = n", "start": [1429, 1], "end": [1438, 77], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le", "code": "theorem aleph0_le {c : Cardinal} : \u2135\u2080 \u2264 c \u2194 \u2200 n : \u2115, \u2191n \u2264 c", "start": [1441, 1], "end": [1445, 68], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isSuccLimit_aleph0", "code": "theorem isSuccLimit_aleph0 : IsSuccLimit \u2135\u2080", "start": [1448, 1], "end": [1452, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isLimit_aleph0", "code": "theorem isLimit_aleph0 : IsLimit \u2135\u2080", "start": [1455, 1], "end": [1456, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsLimit.aleph0_le", "code": "theorem IsLimit.aleph0_le {c : Cardinal} (h : IsLimit c) : \u2135\u2080 \u2264 c", "start": [1459, 1], "end": [1464, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.range_natCast", "code": "@[simp]\ntheorem range_natCast : range ((\u2191) : \u2115 \u2192 Cardinal) = Iio \u2135\u2080", "start": [1467, 1], "end": [1469, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_nat_iff", "code": "theorem mk_eq_nat_iff {\u03b1 : Type u} {n : \u2115} : #\u03b1 = n \u2194 Nonempty (\u03b1 \u2243 Fin n)", "start": [1472, 1], "end": [1473, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_aleph0_iff_finite", "code": "theorem lt_aleph0_iff_finite {\u03b1 : Type u} : #\u03b1 < \u2135\u2080 \u2194 Finite \u03b1", "start": [1476, 1], "end": [1477, 68], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_aleph0_iff_fintype", "code": "theorem lt_aleph0_iff_fintype {\u03b1 : Type u} : #\u03b1 < \u2135\u2080 \u2194 Nonempty (Fintype \u03b1)", "start": [1480, 1], "end": [1481, 61], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_aleph0_of_finite", "code": "theorem lt_aleph0_of_finite (\u03b1 : Type u) [Finite \u03b1] : #\u03b1 < \u2135\u2080", "start": [1484, 1], "end": [1485, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_aleph0_iff_set_finite", "code": "theorem lt_aleph0_iff_set_finite {S : Set \u03b1} : #S < \u2135\u2080 \u2194 S.Finite", "start": [1490, 1], "end": [1491, 44], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.lt_aleph0", "code": "alias \u27e8_, _root_.Set.Finite.lt_aleph0\u27e9 := lt_aleph0_iff_set_finite", "start": [1494, 1], "end": [1494, 67], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Cardinal.lt_aleph0_iff_subtype_finite", "code": "@[simp]\ntheorem lt_aleph0_iff_subtype_finite {p : \u03b1 \u2192 Prop} : #{ x // p x } < \u2135\u2080 \u2194 { x | p x }.Finite", "start": [1497, 1], "end": [1499, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_aleph0_iff", "code": "theorem mk_le_aleph0_iff : #\u03b1 \u2264 \u2135\u2080 \u2194 Countable \u03b1", "start": [1502, 1], "end": [1503, 78], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_aleph0", "code": "@[simp]\ntheorem mk_le_aleph0 [Countable \u03b1] : #\u03b1 \u2264 \u2135\u2080", "start": [1506, 1], "end": [1508, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_aleph0_iff_set_countable", "code": "theorem le_aleph0_iff_set_countable {s : Set \u03b1} : #s \u2264 \u2135\u2080 \u2194 s.Countable", "start": [1513, 1], "end": [1514, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Countable.le_aleph0", "code": "alias \u27e8_, _root_.Set.Countable.le_aleph0\u27e9 := le_aleph0_iff_set_countable", "start": [1517, 1], "end": [1517, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Cardinal.le_aleph0_iff_subtype_countable", "code": "@[simp]\ntheorem le_aleph0_iff_subtype_countable {p : \u03b1 \u2192 Prop} :\n    #{ x // p x } \u2264 \u2135\u2080 \u2194 { x | p x }.Countable", "start": [1520, 1], "end": [1523, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.canLiftCardinalNat", "code": "instance canLiftCardinalNat : CanLift Cardinal \u2115 (\u2191) fun x => x < \u2135\u2080 :=\n  \u27e8fun _ hx =>\n    let \u27e8n, hn\u27e9 := lt_aleph0.mp hx\n    \u27e8n, hn.symm\u27e9\u27e9", "start": [1526, 1], "end": [1529, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_lt_aleph0", "code": "theorem add_lt_aleph0 {a b : Cardinal} (ha : a < \u2135\u2080) (hb : b < \u2135\u2080) : a + b < \u2135\u2080", "start": [1532, 1], "end": [1534, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_lt_aleph0_iff", "code": "theorem add_lt_aleph0_iff {a b : Cardinal} : a + b < \u2135\u2080 \u2194 a < \u2135\u2080 \u2227 b < \u2135\u2080", "start": [1537, 1], "end": [1539, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_add_iff", "code": "theorem aleph0_le_add_iff {a b : Cardinal} : \u2135\u2080 \u2264 a + b \u2194 \u2135\u2080 \u2264 a \u2228 \u2135\u2080 \u2264 b", "start": [1542, 1], "end": [1543, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nsmul_lt_aleph0_iff", "code": "theorem nsmul_lt_aleph0_iff {n : \u2115} {a : Cardinal} : n \u2022 a < \u2135\u2080 \u2194 n = 0 \u2228 a < \u2135\u2080", "start": [1546, 1], "end": [1554, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nsmul_lt_aleph0_iff_of_ne_zero", "code": "theorem nsmul_lt_aleph0_iff_of_ne_zero {n : \u2115} {a : Cardinal} (h : n \u2260 0) : n \u2022 a < \u2135\u2080 \u2194 a < \u2135\u2080", "start": [1557, 1], "end": [1559, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_lt_aleph0", "code": "theorem mul_lt_aleph0 {a b : Cardinal} (ha : a < \u2135\u2080) (hb : b < \u2135\u2080) : a * b < \u2135\u2080", "start": [1562, 1], "end": [1564, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_lt_aleph0_iff", "code": "theorem mul_lt_aleph0_iff {a b : Cardinal} : a * b < \u2135\u2080 \u2194 a = 0 \u2228 b = 0 \u2228 a < \u2135\u2080 \u2227 b < \u2135\u2080", "start": [1567, 1], "end": [1581, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_mul_iff", "code": "theorem aleph0_le_mul_iff {a b : Cardinal} : \u2135\u2080 \u2264 a * b \u2194 a \u2260 0 \u2227 b \u2260 0 \u2227 (\u2135\u2080 \u2264 a \u2228 \u2135\u2080 \u2264 b)", "start": [1584, 1], "end": [1587, 64], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_mul_iff'", "code": "theorem aleph0_le_mul_iff' {a b : Cardinal.{u}} : \u2135\u2080 \u2264 a * b \u2194 a \u2260 0 \u2227 \u2135\u2080 \u2264 b \u2228 \u2135\u2080 \u2264 a \u2227 b \u2260 0", "start": [1590, 1], "end": [1594, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_lt_aleph0_iff_of_ne_zero", "code": "theorem mul_lt_aleph0_iff_of_ne_zero {a b : Cardinal} (ha : a \u2260 0) (hb : b \u2260 0) :\n    a * b < \u2135\u2080 \u2194 a < \u2135\u2080 \u2227 b < \u2135\u2080", "start": [1597, 1], "end": [1598, 72], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_lt_aleph0", "code": "theorem power_lt_aleph0 {a b : Cardinal} (ha : a < \u2135\u2080) (hb : b < \u2135\u2080) : (a^b) < \u2135\u2080", "start": [1601, 1], "end": [1603, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_one_iff_unique", "code": "theorem eq_one_iff_unique {\u03b1 : Type*} : #\u03b1 = 1 \u2194 Subsingleton \u03b1 \u2227 Nonempty \u03b1", "start": [1606, 1], "end": [1610, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.infinite_iff", "code": "theorem infinite_iff {\u03b1 : Type u} : Infinite \u03b1 \u2194 \u2135\u2080 \u2264 #\u03b1", "start": [1613, 1], "end": [1614, 63], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_mk", "code": "@[simp]\ntheorem aleph0_le_mk (\u03b1 : Type u) [Infinite \u03b1] : \u2135\u2080 \u2264 #\u03b1", "start": [1617, 1], "end": [1619, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_aleph0", "code": "@[simp]\ntheorem mk_eq_aleph0 (\u03b1 : Type*) [Countable \u03b1] [Infinite \u03b1] : #\u03b1 = \u2135\u2080", "start": [1622, 1], "end": [1624, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.denumerable_iff", "code": "theorem denumerable_iff {\u03b1 : Type u} : Nonempty (Denumerable \u03b1) \u2194 #\u03b1 = \u2135\u2080", "start": [1627, 1], "end": [1630, 52], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_denumerable", "code": "theorem mk_denumerable (\u03b1 : Type u) [Denumerable \u03b1] : #\u03b1 = \u2135\u2080", "start": [1635, 1], "end": [1636, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_add_aleph0", "code": "@[simp]\ntheorem aleph0_add_aleph0 : \u2135\u2080 + \u2135\u2080 = \u2135\u2080", "start": [1639, 1], "end": [1641, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_aleph0", "code": "theorem aleph0_mul_aleph0 : \u2135\u2080 * \u2135\u2080 = \u2135\u2080", "start": [1644, 1], "end": [1645, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_mul_aleph0", "code": "@[simp]\ntheorem nat_mul_aleph0 {n : \u2115} (hn : n \u2260 0) : \u2191n * \u2135\u2080 = \u2135\u2080", "start": [1648, 1], "end": [1652, 63], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_nat", "code": "@[simp]\ntheorem aleph0_mul_nat {n : \u2115} (hn : n \u2260 0) : \u2135\u2080 * n = \u2135\u2080", "start": [1655, 1], "end": [1656, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ofNat_mul_aleph0", "code": "@[simp]\ntheorem ofNat_mul_aleph0 {n : \u2115} [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) * \u2135\u2080 = \u2135\u2080", "start": [1660, 1], "end": [1662, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_ofNat", "code": "@[simp]\ntheorem aleph0_mul_ofNat {n : \u2115} [Nat.AtLeastTwo n] : \u2135\u2080 * no_index (OfNat.ofNat n) = \u2135\u2080", "start": [1665, 1], "end": [1667, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_le_aleph0", "code": "@[simp]\ntheorem add_le_aleph0 {c\u2081 c\u2082 : Cardinal} : c\u2081 + c\u2082 \u2264 \u2135\u2080 \u2194 c\u2081 \u2264 \u2135\u2080 \u2227 c\u2082 \u2264 \u2135\u2080", "start": [1669, 1], "end": [1672, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_add_nat", "code": "@[simp]\ntheorem aleph0_add_nat (n : \u2115) : \u2135\u2080 + n = \u2135\u2080", "start": [1675, 1], "end": [1677, 72], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_add_aleph0", "code": "@[simp]\ntheorem nat_add_aleph0 (n : \u2115) : \u2191n + \u2135\u2080 = \u2135\u2080", "start": [1680, 1], "end": [1681, 82], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ofNat_add_aleph0", "code": "@[simp]\ntheorem ofNat_add_aleph0 {n : \u2115} [Nat.AtLeastTwo n] : no_index (OfNat.ofNat n) + \u2135\u2080 = \u2135\u2080", "start": [1685, 1], "end": [1687, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_add_ofNat", "code": "@[simp]\ntheorem aleph0_add_ofNat {n : \u2115} [Nat.AtLeastTwo n] : \u2135\u2080 + no_index (OfNat.ofNat n) = \u2135\u2080", "start": [1690, 1], "end": [1692, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat", "code": "def toNat : ZeroHom Cardinal \u2115 where\n  toFun c := if h : c < aleph0.{v} then Classical.choose (lt_aleph0.1 h) else 0\n  map_zero' := by\n    have h : 0 < \u2135\u2080 := nat_lt_aleph0 0\n    dsimp only\n    rw [dif_pos h, \u2190 Cardinal.natCast_inj, \u2190 Classical.choose_spec (lt_aleph0.1 h),\n      Nat.cast_zero]", "start": [1694, 1], "end": [1702, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_apply_of_lt_aleph0", "code": "theorem toNat_apply_of_lt_aleph0 {c : Cardinal} (h : c < \u2135\u2080) :\n    toNat c = Classical.choose (lt_aleph0.1 h)", "start": [1705, 1], "end": [1707, 12], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_apply_of_aleph0_le", "code": "theorem toNat_apply_of_aleph0_le {c : Cardinal} (h : \u2135\u2080 \u2264 c) : toNat c = 0", "start": [1710, 1], "end": [1711, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cast_toNat_of_lt_aleph0", "code": "theorem cast_toNat_of_lt_aleph0 {c : Cardinal} (h : c < \u2135\u2080) : \u2191(toNat c) = c", "start": [1714, 1], "end": [1715, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.cast_toNat_of_aleph0_le", "code": "theorem cast_toNat_of_aleph0_le {c : Cardinal} (h : \u2135\u2080 \u2264 c) : \u2191(toNat c) = (0 : Cardinal)", "start": [1718, 1], "end": [1719, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_eq_iff_eq_of_lt_aleph0", "code": "theorem toNat_eq_iff_eq_of_lt_aleph0 {c d : Cardinal} (hc : c < \u2135\u2080) (hd : d < \u2135\u2080) :\n    toNat c = toNat d \u2194 c = d", "start": [1722, 1], "end": [1725, 77], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_le_iff_le_of_lt_aleph0", "code": "theorem toNat_le_iff_le_of_lt_aleph0 {c d : Cardinal} (hc : c < \u2135\u2080) (hd : d < \u2135\u2080) :\n    toNat c \u2264 toNat d \u2194 c \u2264 d", "start": [1728, 1], "end": [1730, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_lt_iff_lt_of_lt_aleph0", "code": "theorem toNat_lt_iff_lt_of_lt_aleph0 {c d : Cardinal} (hc : c < \u2135\u2080) (hd : d < \u2135\u2080) :\n    toNat c < toNat d \u2194 c < d", "start": [1733, 1], "end": [1735, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_le_of_le_of_lt_aleph0", "code": "theorem toNat_le_of_le_of_lt_aleph0 {c d : Cardinal} (hd : d < \u2135\u2080) (hcd : c \u2264 d) :\n    toNat c \u2264 toNat d", "start": [1738, 1], "end": [1740, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_lt_of_lt_of_lt_aleph0", "code": "theorem toNat_lt_of_lt_of_lt_aleph0 {c d : Cardinal} (hd : d < \u2135\u2080) (hcd : c < d) :\n    toNat c < toNat d", "start": [1743, 1], "end": [1745, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_cast", "code": "@[simp]\ntheorem toNat_cast (n : \u2115) : Cardinal.toNat n = n", "start": [1748, 1], "end": [1751, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_ofNat", "code": "@[simp]\ntheorem toNat_ofNat (n : \u2115) [n.AtLeastTwo] : Cardinal.toNat (OfNat.ofNat n) = OfNat.ofNat n", "start": [1754, 1], "end": [1756, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_rightInverse", "code": "theorem toNat_rightInverse : Function.RightInverse ((\u2191) : \u2115 \u2192 Cardinal) toNat", "start": [1758, 1], "end": [1760, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_surjective", "code": "theorem toNat_surjective : Surjective toNat", "start": [1763, 1], "end": [1764, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.exists_nat_eq_of_le_nat", "code": "theorem exists_nat_eq_of_le_nat {c : Cardinal} {n : \u2115} (h : c \u2264 n) : \u2203 m, m \u2264 n \u2227 c = m", "start": [1767, 1], "end": [1769, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_toNat_of_infinite", "code": "@[simp]\ntheorem mk_toNat_of_infinite [h : Infinite \u03b1] : toNat #\u03b1 = 0", "start": [1772, 1], "end": [1774, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_toNat", "code": "@[simp]\ntheorem aleph0_toNat : toNat \u2135\u2080 = 0", "start": [1777, 1], "end": [1779, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_toNat_eq_card", "code": "theorem mk_toNat_eq_card [Fintype \u03b1] : toNat #\u03b1 = Fintype.card \u03b1", "start": [1782, 1], "end": [1782, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.zero_toNat", "code": "theorem zero_toNat : toNat 0 = 0", "start": [1787, 1], "end": [1787, 74], "kind": "commanddeclaration"}, {"full_name": "Cardinal.one_toNat", "code": "@[simp]\ntheorem one_toNat : toNat 1 = 1", "start": [1790, 1], "end": [1791, 72], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_eq_iff", "code": "theorem toNat_eq_iff {c : Cardinal} {n : \u2115} (hn : n \u2260 0) : toNat c = n \u2194 c = n", "start": [1794, 1], "end": [1799, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_eq_ofNat", "code": "theorem toNat_eq_ofNat {c : Cardinal} {n : \u2115} [Nat.AtLeastTwo n] :\n    toNat c = OfNat.ofNat n \u2194 c = OfNat.ofNat n", "start": [1802, 1], "end": [1805, 64], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_eq_one", "code": "@[simp]\ntheorem toNat_eq_one {c : Cardinal} : toNat c = 1 \u2194 c = 1", "start": [1807, 1], "end": [1809, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_eq_one_iff_unique", "code": "theorem toNat_eq_one_iff_unique {\u03b1 : Type*} : toNat #\u03b1 = 1 \u2194 Subsingleton \u03b1 \u2227 Nonempty \u03b1", "start": [1812, 1], "end": [1813, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_lift", "code": "@[simp]\ntheorem toNat_lift (c : Cardinal.{v}) : toNat (lift.{u, v} c) = toNat c", "start": [1816, 1], "end": [1823, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_congr", "code": "theorem toNat_congr {\u03b2 : Type v} (e : \u03b1 \u2243 \u03b2) : toNat #\u03b1 = toNat #\u03b2", "start": [1826, 1], "end": [1828, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_mul", "code": "@[simp]\ntheorem toNat_mul (x y : Cardinal) : toNat (x * y) = toNat x * toNat y", "start": [1831, 1], "end": [1845, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNatHom", "code": "@[simps]\ndef toNatHom : Cardinal \u2192*\u2080 \u2115 where\n  toFun := toNat\n  map_zero' := zero_toNat\n  map_one' := one_toNat\n  map_mul' := toNat_mul", "start": [1848, 1], "end": [1854, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_finset_prod", "code": "theorem toNat_finset_prod (s : Finset \u03b1) (f : \u03b1 \u2192 Cardinal) :\n    toNat (\u220f i in s, f i) = \u220f i in s, toNat (f i)", "start": [1857, 1], "end": [1859, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toNat_add_of_lt_aleph0", "code": "@[simp]\ntheorem toNat_add_of_lt_aleph0 {a : Cardinal.{u}} {b : Cardinal.{v}} (ha : a < \u2135\u2080) (hb : b < \u2135\u2080) :\n    toNat (lift.{v, u} a + lift.{u, v} b) = toNat a + toNat b", "start": [1862, 1], "end": [1869, 79], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat", "code": "def toPartENat : Cardinal \u2192+ PartENat where\n  toFun c := if c < \u2135\u2080 then toNat c else \u22a4\n  map_zero' := by simp [if_pos (zero_lt_one.trans one_lt_aleph0)]\n  map_add' x y := by\n    by_cases hx : x < \u2135\u2080\n    \u00b7 obtain \u27e8x0, rfl\u27e9 := lt_aleph0.1 hx\n      by_cases hy : y < \u2135\u2080\n      \u00b7 obtain \u27e8y0, rfl\u27e9 := lt_aleph0.1 hy\n        simp only [add_lt_aleph0 hx hy, hx, hy, toNat_cast, if_true]\n        rw [\u2190 Nat.cast_add, toNat_cast, Nat.cast_add]\n      \u00b7 simp_rw [if_neg hy, PartENat.add_top]\n        contrapose! hy\n        simp only [ne_eq, ite_eq_right_iff,\n          PartENat.natCast_ne_top, not_forall, exists_prop, and_true] at hy\n        exact le_add_self.trans_lt hy\n    \u00b7 simp_rw [if_neg hx, PartENat.top_add]\n      contrapose! hx\n      simp only [ne_eq, ite_eq_right_iff,\n      PartENat.natCast_ne_top, not_forall, exists_prop, and_true] at hx\n      exact le_self_add.trans_lt hx", "start": [1872, 1], "end": [1893, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_apply_of_lt_aleph0", "code": "theorem toPartENat_apply_of_lt_aleph0 {c : Cardinal} (h : c < \u2135\u2080) : toPartENat c = toNat c", "start": [1896, 1], "end": [1897, 11], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_apply_of_aleph0_le", "code": "theorem toPartENat_apply_of_aleph0_le {c : Cardinal} (h : \u2135\u2080 \u2264 c) : toPartENat c = \u22a4", "start": [1900, 1], "end": [1901, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_cast", "code": "@[simp]\ntheorem toPartENat_cast (n : \u2115) : toPartENat n = n", "start": [1904, 1], "end": [1906, 67], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_toPartENat_of_infinite", "code": "@[simp]\ntheorem mk_toPartENat_of_infinite [h : Infinite \u03b1] : toPartENat #\u03b1 = \u22a4", "start": [1909, 1], "end": [1911, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_toPartENat", "code": "@[simp]\ntheorem aleph0_toPartENat : toPartENat \u2135\u2080 = \u22a4", "start": [1914, 1], "end": [1916, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_surjective", "code": "theorem toPartENat_surjective : Surjective toPartENat", "start": [1919, 1], "end": [1920, 96], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_eq_top_iff_le_aleph0", "code": "theorem toPartENat_eq_top_iff_le_aleph0 {c : Cardinal} :\n    toPartENat c = \u22a4 \u2194 \u2135\u2080 \u2264 c", "start": [1923, 1], "end": [1928, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_le_iff_of_le_aleph0", "code": "lemma toPartENat_le_iff_of_le_aleph0 {c c' : Cardinal} (h : c \u2264 \u2135\u2080) :\n    toPartENat c \u2264 toPartENat c' \u2194 c \u2264 c' := by\n  cases lt_or_ge c \u2135\u2080 with\n  | inl hc =>\n    rw [toPartENat_apply_of_lt_aleph0 hc]\n    cases lt_or_ge c' \u2135\u2080 with\n    | inl hc' =>\n      rw [toPartENat_apply_of_lt_aleph0 hc', PartENat.coe_le_coe]\n      exact toNat_le_iff_le_of_lt_aleph0 hc hc'\n    | inr hc' =>\n      simp only [toPartENat_apply_of_aleph0_le hc',\n      le_top, true_iff]\n      exact le_trans h hc'\n  | inr hc =>\n    rw [toPartENat_apply_of_aleph0_le hc]\n    simp only [top_le_iff, toPartENat_eq_top_iff_le_aleph0,\n    le_antisymm h hc]", "start": [1931, 1], "end": [1947, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.toPartENat_le_iff_of_lt_aleph0", "code": "lemma toPartENat_le_iff_of_lt_aleph0 {c c' : Cardinal} (hc' : c' < \u2135\u2080) :\n    toPartENat c \u2264 toPartENat c' \u2194 c \u2264 c' := by\n  cases lt_or_ge c \u2135\u2080 with\n  | inl hc =>\n    rw [toPartENat_apply_of_lt_aleph0 hc]\n    rw [toPartENat_apply_of_lt_aleph0 hc', PartENat.coe_le_coe]\n    exact toNat_le_iff_le_of_lt_aleph0 hc hc'\n  | inr hc =>\n    rw [toPartENat_apply_of_aleph0_le hc]\n    simp only [top_le_iff, toPartENat_eq_top_iff_le_aleph0]\n    rw [\u2190 not_iff_not, not_le, not_le]\n    simp only [hc', lt_of_lt_of_le hc' hc]", "start": [1950, 1], "end": [1961, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.toPartENat_eq_iff_of_le_aleph0", "code": "lemma toPartENat_eq_iff_of_le_aleph0 {c c' : Cardinal} (hc : c \u2264 \u2135\u2080) (hc' : c' \u2264 \u2135\u2080) :\n    toPartENat c = toPartENat c' \u2194 c = c' := by\n  rw [le_antisymm_iff, le_antisymm_iff, toPartENat_le_iff_of_le_aleph0 hc,\n    toPartENat_le_iff_of_le_aleph0 hc']", "start": [1964, 1], "end": [1967, 40], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.toPartENat_mono", "code": "theorem toPartENat_mono {c c' : Cardinal} (h : c \u2264 c') :\n    toPartENat c \u2264 toPartENat c'", "start": [1970, 1], "end": [1984, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_lift", "code": "theorem toPartENat_lift (c : Cardinal.{v}) : toPartENat (lift.{u, v} c) = toPartENat c", "start": [1987, 1], "end": [1995, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_congr", "code": "theorem toPartENat_congr {\u03b2 : Type v} (e : \u03b1 \u2243 \u03b2) : toPartENat #\u03b1 = toPartENat #\u03b2", "start": [1998, 1], "end": [1999, 71], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_toPartENat_eq_coe_card", "code": "theorem mk_toPartENat_eq_coe_card [Fintype \u03b1] : toPartENat #\u03b1 = Fintype.card \u03b1", "start": [2002, 1], "end": [2002, 90], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_int", "code": "theorem mk_int : #\u2124 = \u2135\u2080", "start": [2005, 1], "end": [2006, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_pNat", "code": "theorem mk_pNat : #\u2115+ = \u2135\u2080", "start": [2009, 1], "end": [2010, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_lt_prod", "code": "theorem sum_lt_prod {\u03b9} (f g : \u03b9 \u2192 Cardinal) (H : \u2200 i, f i < g i) : sum f < prod g", "start": [2013, 1], "end": [2030, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_empty", "code": "theorem mk_empty : #Empty = 0", "start": [2035, 1], "end": [2036, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_pempty", "code": "theorem mk_pempty : #PEmpty = 0", "start": [2041, 1], "end": [2042, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_punit", "code": "theorem mk_punit : #PUnit = 1", "start": [2047, 1], "end": [2048, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_unit", "code": "theorem mk_unit : #Unit = 1", "start": [2051, 1], "end": [2052, 11], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_singleton", "code": "theorem mk_singleton {\u03b1 : Type u} (x : \u03b1) : #({x} : Set \u03b1) = 1", "start": [2057, 1], "end": [2058, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_plift_true", "code": "theorem mk_plift_true : #(PLift True) = 1", "start": [2063, 1], "end": [2064, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_plift_false", "code": "theorem mk_plift_false : #(PLift False) = 0", "start": [2069, 1], "end": [2070, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_vector", "code": "@[simp]\ntheorem mk_vector (\u03b1 : Type u) (n : \u2115) : #(Vector \u03b1 n) = #\u03b1 ^\u2115 n", "start": [2073, 1], "end": [2075, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_list_eq_sum_pow", "code": "theorem mk_list_eq_sum_pow (\u03b1 : Type u) : #(List \u03b1) = sum fun n : \u2115 => #\u03b1 ^\u2115 n", "start": [2078, 1], "end": [2081, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quot_le", "code": "theorem mk_quot_le {\u03b1 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} : #(Quot r) \u2264 #\u03b1", "start": [2084, 1], "end": [2085, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_quotient_le", "code": "theorem mk_quotient_le {\u03b1 : Type u} {s : Setoid \u03b1} : #(Quotient s) \u2264 #\u03b1", "start": [2088, 1], "end": [2089, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subtype_le_of_subset", "code": "theorem mk_subtype_le_of_subset {\u03b1 : Type u} {p q : \u03b1 \u2192 Prop} (h : \u2200 \u2983x\u2984, p x \u2192 q x) :\n    #(Subtype p) \u2264 #(Subtype q)", "start": [2092, 1], "end": [2094, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_emptyCollection", "code": "theorem mk_emptyCollection (\u03b1 : Type u) : #(\u2205 : Set \u03b1) = 0", "start": [2099, 1], "end": [2100, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_emptyCollection_iff", "code": "theorem mk_emptyCollection_iff {\u03b1 : Type u} {s : Set \u03b1} : #s = 0 \u2194 s = \u2205", "start": [2103, 1], "end": [2109, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_univ", "code": "@[simp]\ntheorem mk_univ {\u03b1 : Type u} : #(@univ \u03b1) = #\u03b1", "start": [2112, 1], "end": [2114, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_le", "code": "theorem mk_image_le {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : #(f '' s) \u2264 #s", "start": [2117, 1], "end": [2118, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_le_lift", "code": "theorem mk_image_le_lift {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    lift.{u} #(f '' s) \u2264 lift.{v} #s", "start": [2121, 1], "end": [2123, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_range_le", "code": "theorem mk_range_le {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} : #(range f) \u2264 #\u03b1", "start": [2126, 1], "end": [2127, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_range_le_lift", "code": "theorem mk_range_le_lift {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} :\n    lift.{u} #(range f) \u2264 lift.{v} #\u03b1", "start": [2130, 1], "end": [2132, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_range_eq", "code": "theorem mk_range_eq (f : \u03b1 \u2192 \u03b2) (h : Injective f) : #(range f) = #\u03b1", "start": [2135, 1], "end": [2136, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_range_eq_of_injective", "code": "theorem mk_range_eq_of_injective {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    lift.{u} #(range f) = lift.{v} #\u03b1", "start": [2139, 1], "end": [2141, 50], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_mk_le_lift_mk_of_injective", "code": "lemma lift_mk_le_lift_mk_of_injective {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    Cardinal.lift.{v} (#\u03b1) \u2264 Cardinal.lift.{u} (#\u03b2) := by\n  rw [\u2190 Cardinal.mk_range_eq_of_injective hf]\n  exact Cardinal.lift_le.2 (Cardinal.mk_set_le _)", "start": [2144, 1], "end": [2147, 50], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.mk_range_eq_lift", "code": "theorem mk_range_eq_lift {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} (hf : Injective f) :\n    lift.{max u w} #(range f) = lift.{max v w} #\u03b1", "start": [2149, 1], "end": [2151, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_eq", "code": "theorem mk_image_eq {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : Injective f) : #(f '' s) = #s", "start": [2154, 1], "end": [2155, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_iUnion_le_sum_mk", "code": "theorem mk_iUnion_le_sum_mk {\u03b1 \u03b9 : Type u} {f : \u03b9 \u2192 Set \u03b1} : #(\u22c3 i, f i) \u2264 sum fun i => #(f i)", "start": [2158, 1], "end": [2161, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_iUnion_eq_sum_mk", "code": "theorem mk_iUnion_eq_sum_mk {\u03b1 \u03b9 : Type u} {f : \u03b9 \u2192 Set \u03b1}\n    (h : \u2200 i j, i \u2260 j \u2192 Disjoint (f i) (f j)) : #(\u22c3 i, f i) = sum fun i => #(f i)", "start": [2164, 1], "end": [2168, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_iUnion_le", "code": "theorem mk_iUnion_le {\u03b1 \u03b9 : Type u} (f : \u03b9 \u2192 Set \u03b1) : #(\u22c3 i, f i) \u2264 #\u03b9 * \u2a06 i, #(f i)", "start": [2171, 1], "end": [2172, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_sUnion_le", "code": "theorem mk_sUnion_le {\u03b1 : Type u} (A : Set (Set \u03b1)) : #(\u22c3\u2080 A) \u2264 #A * \u2a06 s : A, #s", "start": [2175, 1], "end": [2177, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_biUnion_le", "code": "theorem mk_biUnion_le {\u03b9 \u03b1 : Type u} (A : \u03b9 \u2192 Set \u03b1) (s : Set \u03b9) :\n    #(\u22c3 x \u2208 s, A x) \u2264 #s * \u2a06 x : s, #(A x.1)", "start": [2180, 1], "end": [2183, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.finset_card_lt_aleph0", "code": "theorem finset_card_lt_aleph0 (s : Finset \u03b1) : #(\u2191s : Set \u03b1) < \u2135\u2080", "start": [2186, 1], "end": [2187, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_set_eq_nat_iff_finset", "code": "theorem mk_set_eq_nat_iff_finset {\u03b1} {s : Set \u03b1} {n : \u2115} :\n    #s = n \u2194 \u2203 t : Finset \u03b1, (t : Set \u03b1) = s \u2227 t.card = n", "start": [2190, 1], "end": [2197, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_nat_iff_finset", "code": "theorem mk_eq_nat_iff_finset {n : \u2115} :\n    #\u03b1 = n \u2194 \u2203 t : Finset \u03b1, (t : Set \u03b1) = univ \u2227 t.card = n", "start": [2200, 1], "end": [2202, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_nat_iff_fintype", "code": "theorem mk_eq_nat_iff_fintype {n : \u2115} : #\u03b1 = n \u2194 \u2203 h : Fintype \u03b1, @Fintype.card \u03b1 h = n", "start": [2205, 1], "end": [2211, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_union_add_mk_inter", "code": "theorem mk_union_add_mk_inter {\u03b1 : Type u} {S T : Set \u03b1} :\n    #(S \u222a T : Set \u03b1) + #(S \u2229 T : Set \u03b1) = #S + #T", "start": [2214, 1], "end": [2216, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_union_le", "code": "theorem mk_union_le {\u03b1 : Type u} (S T : Set \u03b1) : #(S \u222a T : Set \u03b1) \u2264 #S + #T", "start": [2219, 1], "end": [2222, 85], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_union_of_disjoint", "code": "theorem mk_union_of_disjoint {\u03b1 : Type u} {S T : Set \u03b1} (H : Disjoint S T) :\n    #(S \u222a T : Set \u03b1) = #S + #T", "start": [2225, 1], "end": [2227, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_insert", "code": "theorem mk_insert {\u03b1 : Type u} {s : Set \u03b1} {a : \u03b1} (h : a \u2209 s) :\n    #(insert a s : Set \u03b1) = #s + 1", "start": [2230, 1], "end": [2233, 8], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_sum_compl", "code": "theorem mk_sum_compl {\u03b1} (s : Set \u03b1) : #s + #(s\u1d9c : Set \u03b1) = #\u03b1", "start": [2236, 1], "end": [2237, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_mk_of_subset", "code": "theorem mk_le_mk_of_subset {\u03b1} {s t : Set \u03b1} (h : s \u2286 t) : #s \u2264 #t", "start": [2240, 1], "end": [2241, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_iff_forall_finset_subset_card_le", "code": "theorem mk_le_iff_forall_finset_subset_card_le {\u03b1 : Type u} {n : \u2115} {t : Set \u03b1} :\n    #t \u2264 n \u2194 \u2200 s : Finset \u03b1, (s : Set \u03b1) \u2286 t \u2192 s.card \u2264 n", "start": [2244, 1], "end": [2253, 89], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subtype_mono", "code": "theorem mk_subtype_mono {p q : \u03b1 \u2192 Prop} (h : \u2200 x, p x \u2192 q x) :\n    #{ x // p x } \u2264 #{ x // q x }", "start": [2255, 1], "end": [2257, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_mk_diff_add_mk", "code": "theorem le_mk_diff_add_mk (S T : Set \u03b1) : #S \u2264 #(S \\ T : Set \u03b1) + #T", "start": [2260, 1], "end": [2261, 73], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_diff_add_mk", "code": "theorem mk_diff_add_mk {S T : Set \u03b1} (h : T \u2286 S) : #(S \\ T : Set \u03b1) + #T = #S", "start": [2264, 1], "end": [2266, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_union_le_aleph0", "code": "theorem mk_union_le_aleph0 {\u03b1} {P Q : Set \u03b1} :\n    #(P \u222a Q : Set \u03b1) \u2264 \u2135\u2080 \u2194 #P \u2264 \u2135\u2080 \u2227 #Q \u2264 \u2135\u2080", "start": [2269, 1], "end": [2272, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_eq_lift", "code": "theorem mk_image_eq_lift {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : Injective f) :\n    lift.{u} #(f '' s) = lift.{v} #s", "start": [2275, 1], "end": [2277, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_eq_of_injOn_lift", "code": "theorem mk_image_eq_of_injOn_lift {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1)\n    (h : InjOn f s) : lift.{u} #(f '' s) = lift.{v} #s", "start": [2280, 1], "end": [2282, 65], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_image_eq_of_injOn", "code": "theorem mk_image_eq_of_injOn {\u03b1 \u03b2 : Type u} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) (h : InjOn f s) :\n    #(f '' s) = #s", "start": [2285, 1], "end": [2287, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subtype_of_equiv", "code": "theorem mk_subtype_of_equiv {\u03b1 \u03b2 : Type u} (p : \u03b2 \u2192 Prop) (e : \u03b1 \u2243 \u03b2) :\n    #{ a : \u03b1 // p (e a) } = #{ b : \u03b2 // p b }", "start": [2290, 1], "end": [2292, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_sep", "code": "theorem mk_sep (s : Set \u03b1) (t : \u03b1 \u2192 Prop) : #({ x \u2208 s | t x } : Set \u03b1) = #{ x : s | t x.1 }", "start": [2295, 1], "end": [2296, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_injective_lift", "code": "theorem mk_preimage_of_injective_lift {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2)\n    (h : Injective f) : lift.{v} #(f \u207b\u00b9' s) \u2264 lift.{u} #s", "start": [2299, 1], "end": [2304, 68], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_subset_range_lift", "code": "theorem mk_preimage_of_subset_range_lift {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2)\n    (h : s \u2286 range f) : lift.{u} #s \u2264 lift.{v} #(f \u207b\u00b9' s)", "start": [2307, 1], "end": [2317, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_injective_of_subset_range_lift", "code": "theorem mk_preimage_of_injective_of_subset_range_lift {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2)\n    (h : Injective f) (h2 : s \u2286 range f) : lift.{v} #(f \u207b\u00b9' s) = lift.{u} #s", "start": [2320, 1], "end": [2322, 94], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_injective", "code": "theorem mk_preimage_of_injective (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) (h : Injective f) :\n    #(f \u207b\u00b9' s) \u2264 #s", "start": [2325, 1], "end": [2328, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_subset_range", "code": "theorem mk_preimage_of_subset_range (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) (h : s \u2286 range f) :\n    #s \u2264 #(f \u207b\u00b9' s)", "start": [2331, 1], "end": [2334, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_preimage_of_injective_of_subset_range", "code": "theorem mk_preimage_of_injective_of_subset_range (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) (h : Injective f)\n    (h2 : s \u2286 range f) : #(f \u207b\u00b9' s) = #s", "start": [2337, 1], "end": [2339, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subset_ge_of_subset_image_lift", "code": "theorem mk_subset_ge_of_subset_image_lift {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) {s : Set \u03b1}\n    {t : Set \u03b2} (h : t \u2286 f '' s) : lift.{u} #t \u2264 lift.{v} #({ x \u2208 s | f x \u2208 t } : Set \u03b1)", "start": [2342, 1], "end": [2347, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subset_ge_of_subset_image", "code": "theorem mk_subset_ge_of_subset_image (f : \u03b1 \u2192 \u03b2) {s : Set \u03b1} {t : Set \u03b2} (h : t \u2286 f '' s) :\n    #t \u2264 #({ x \u2208 s | f x \u2208 t } : Set \u03b1)", "start": [2350, 1], "end": [2355, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_mk_iff_exists_subset", "code": "theorem le_mk_iff_exists_subset {c : Cardinal} {\u03b1 : Type u} {s : Set \u03b1} :\n    c \u2264 #s \u2194 \u2203 p : Set \u03b1, p \u2286 s \u2227 #p = c", "start": [2358, 1], "end": [2361, 77], "kind": "commanddeclaration"}, {"full_name": "Cardinal.two_le_iff", "code": "theorem two_le_iff : (2 : Cardinal) \u2264 #\u03b1 \u2194 \u2203 x y : \u03b1, x \u2260 y", "start": [2364, 1], "end": [2365, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.two_le_iff'", "code": "theorem two_le_iff' (x : \u03b1) : (2 : Cardinal) \u2264 #\u03b1 \u2194 \u2203 y : \u03b1, y \u2260 x", "start": [2368, 1], "end": [2369, 64], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_two_iff", "code": "theorem mk_eq_two_iff : #\u03b1 = 2 \u2194 \u2203 x y : \u03b1, x \u2260 y \u2227 ({x, y} : Set \u03b1) = univ", "start": [2372, 1], "end": [2378, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_eq_two_iff'", "code": "theorem mk_eq_two_iff' (x : \u03b1) : #\u03b1 = 2 \u2194 \u2203! y, y \u2260 x", "start": [2381, 1], "end": [2388, 84], "kind": "commanddeclaration"}, {"full_name": "Cardinal.exists_not_mem_of_length_lt", "code": "theorem exists_not_mem_of_length_lt {\u03b1 : Type*} (l : List \u03b1) (h : \u2191l.length < #\u03b1) :\n    \u2203 z : \u03b1, z \u2209 l", "start": [2391, 1], "end": [2398, 70], "kind": "commanddeclaration"}, {"full_name": "Cardinal.three_le", "code": "theorem three_le {\u03b1 : Type*} (h : 3 \u2264 #\u03b1) (x : \u03b1) (y : \u03b1) : \u2203 z : \u03b1, z \u2260 x \u2227 z \u2260 y", "start": [2401, 1], "end": [2405, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt", "code": "def powerlt (a b : Cardinal.{u}) : Cardinal.{u} :=\n  \u2a06 c : Iio b, a^c", "start": [2408, 1], "end": [2410, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_powerlt", "code": "theorem le_powerlt {b c : Cardinal.{u}} (a) (h : c < b) : (a^c) \u2264 a ^< b", "start": [2416, 1], "end": [2419, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_le", "code": "theorem powerlt_le {a b c : Cardinal.{u}} : a ^< b \u2264 c \u2194 \u2200 x < b, (a^x) \u2264 c", "start": [2422, 1], "end": [2426, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_le_powerlt_left", "code": "theorem powerlt_le_powerlt_left {a b c : Cardinal} (h : b \u2264 c) : a ^< b \u2264 a ^< c", "start": [2429, 1], "end": [2430, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_mono_left", "code": "theorem powerlt_mono_left (a) : Monotone fun c => a ^< c", "start": [2433, 1], "end": [2433, 95], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_succ", "code": "theorem powerlt_succ {a b : Cardinal} (h : a \u2260 0) : a ^< succ b = (a^b)", "start": [2436, 1], "end": [2438, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_min", "code": "theorem powerlt_min {a b c : Cardinal} : a ^< min b c = min (a ^< b) (a ^< c)", "start": [2441, 1], "end": [2442, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_max", "code": "theorem powerlt_max {a b c : Cardinal} : a ^< max b c = max (a ^< b) (a ^< c)", "start": [2445, 1], "end": [2446, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.zero_powerlt", "code": "theorem zero_powerlt {a : Cardinal} (h : a \u2260 0) : 0 ^< a = 1", "start": [2449, 1], "end": [2452, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_zero", "code": "@[simp]\ntheorem powerlt_zero {a : Cardinal} : a ^< 0 = 0", "start": [2455, 1], "end": [2458, 86], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_le_of_module", "code": "theorem mk_le_of_module (R : Type u) (E : Type v)\n    [AddCommGroup E] [Ring R] [Module R E] [Nontrivial E] [NoZeroSMulDivisors R E] :\n    Cardinal.lift.{v} (#R) \u2264 Cardinal.lift.{u} (#E)", "start": [2461, 1], "end": [2468, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/FinCases.lean", "imports": ["Mathlib/Data/Fintype/Basic.lean", "Mathlib/Tactic/Core.lean", "Mathlib/Lean/Expr/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Lean.Elab.Tactic.getMemType", "code": "def getMemType {m : Type \u2192 Type} [Monad m] [MonadError m] (e : Expr) : m (Option Expr) := do\n  match e.getAppFnArgs with\n  | (``Membership.mem, #[_, type, _, _, _]) =>\n    match type.getAppFnArgs with\n    | (``List, #[\u03b1])     => return \u03b1\n    | (``Multiset, #[\u03b1]) => return \u03b1\n    | (``Finset, #[\u03b1])   => return \u03b1\n    | _ => throwError (\"Hypothesis must be of type `x \u2208 (A : List \u03b1)`, `x \u2208 (A : Finset \u03b1)`,\"\n        ++ \" or `x \u2208 (A : Multiset \u03b1)`\")\n  | _ => return none", "start": [24, 1], "end": [35, 21], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.unfoldCases", "code": "partial def unfoldCases (g : MVarId) (h : FVarId) : MetaM (List MVarId) := do\n  let gs \u2190 g.cases h\n  try\n    let #[g\u2081, g\u2082] := gs | throwError \"unexpected number of cases\"\n    let gs \u2190 unfoldCases g\u2082.mvarId g\u2082.fields[2]!.fvarId!\n    return g\u2081.mvarId :: gs\n  catch _ => return []", "start": [37, 1], "end": [52, 23], "kind": "commanddeclaration"}, {"full_name": "Lean.Elab.Tactic.finCasesAt", "code": "partial def finCasesAt (g : MVarId) (hyp : FVarId) : MetaM (List MVarId) := g.withContext do\n  let type \u2190 hyp.getType >>= instantiateMVars\n  match \u2190 getMemType type with\n  | some _ => unfoldCases g hyp\n  | none =>\n    let inst \u2190 synthInstance (\u2190 mkAppM ``Fintype #[type])\n    let elems \u2190 mkAppOptM ``Fintype.elems #[type, inst]\n    let t \u2190 mkAppM ``Membership.mem #[.fvar hyp, elems]\n    let v \u2190 mkAppOptM ``Fintype.complete #[type, inst, Expr.fvar hyp]\n    let (fvar, g) \u2190 (\u2190 g.assert `this t v).intro1P\n    finCasesAt g fvar", "start": [54, 1], "end": [66, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/LinearCombination.lean", "imports": ["Mathlib/Tactic/Ring.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.LinearCombination.pf_add_c", "code": "theorem pf_add_c [Add \u03b1] (p : a = b) (c : \u03b1) : a + c = b + c", "start": [39, 1], "end": [39, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.c_add_pf", "code": "theorem c_add_pf [Add \u03b1] (p : b = c) (a : \u03b1) : a + b = a + c", "start": [40, 1], "end": [40, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.add_pf", "code": "theorem add_pf [Add \u03b1] (p\u2081 : (a\u2081:\u03b1) = b\u2081) (p\u2082 : a\u2082 = b\u2082) : a\u2081 + a\u2082 = b\u2081 + b\u2082", "start": [41, 1], "end": [41, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.pf_sub_c", "code": "theorem pf_sub_c [Sub \u03b1] (p : a = b) (c : \u03b1) : a - c = b - c", "start": [42, 1], "end": [42, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.c_sub_pf", "code": "theorem c_sub_pf [Sub \u03b1] (p : b = c) (a : \u03b1) : a - b = a - c", "start": [43, 1], "end": [43, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.sub_pf", "code": "theorem sub_pf [Sub \u03b1] (p\u2081 : (a\u2081:\u03b1) = b\u2081) (p\u2082 : a\u2082 = b\u2082) : a\u2081 - a\u2082 = b\u2081 - b\u2082", "start": [44, 1], "end": [44, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.neg_pf", "code": "theorem neg_pf [Neg \u03b1] (p : (a:\u03b1) = b) : -a = -b", "start": [45, 1], "end": [45, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.pf_mul_c", "code": "theorem pf_mul_c [Mul \u03b1] (p : a = b) (c : \u03b1) : a * c = b * c", "start": [46, 1], "end": [46, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.c_mul_pf", "code": "theorem c_mul_pf [Mul \u03b1] (p : b = c) (a : \u03b1) : a * b = a * c", "start": [47, 1], "end": [47, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.mul_pf", "code": "theorem mul_pf [Mul \u03b1] (p\u2081 : (a\u2081:\u03b1) = b\u2081) (p\u2082 : a\u2082 = b\u2082) : a\u2081 * a\u2082 = b\u2081 * b\u2082", "start": [48, 1], "end": [48, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.inv_pf", "code": "theorem inv_pf [Inv \u03b1] (p : (a:\u03b1) = b) : a\u207b\u00b9 = b\u207b\u00b9", "start": [49, 1], "end": [49, 62], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.pf_div_c", "code": "theorem pf_div_c [Div \u03b1] (p : a = b) (c : \u03b1) : a / c = b / c", "start": [50, 1], "end": [50, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.c_div_pf", "code": "theorem c_div_pf [Div \u03b1] (p : b = c) (a : \u03b1) : a / b = a / c", "start": [51, 1], "end": [51, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.div_pf", "code": "theorem div_pf [Div \u03b1] (p\u2081 : (a\u2081:\u03b1) = b\u2081) (p\u2082 : a\u2082 = b\u2082) : a\u2081 / a\u2082 = b\u2081 / b\u2082", "start": [52, 1], "end": [52, 94], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.expandLinearCombo", "code": "partial def expandLinearCombo (stx : Syntax.Term) : TermElabM (Option Syntax.Term) := do\n  let mut result \u2190 match stx with\n  | `(($e)) => expandLinearCombo e\n  | `($e\u2081 + $e\u2082) => do\n    match \u2190 expandLinearCombo e\u2081, \u2190 expandLinearCombo e\u2082 with\n    | none, none => pure none\n    | some p\u2081, none => ``(pf_add_c $p\u2081 $e\u2082)\n    | none, some p\u2082 => ``(c_add_pf $p\u2082 $e\u2081)\n    | some p\u2081, some p\u2082 => ``(add_pf $p\u2081 $p\u2082)\n  | `($e\u2081 - $e\u2082) => do\n    match \u2190 expandLinearCombo e\u2081, \u2190 expandLinearCombo e\u2082 with\n    | none, none => pure none\n    | some p\u2081, none => ``(pf_sub_c $p\u2081 $e\u2082)\n    | none, some p\u2082 => ``(c_sub_pf $p\u2082 $e\u2081)\n    | some p\u2081, some p\u2082 => ``(sub_pf $p\u2081 $p\u2082)\n  | `(-$e) => do\n    match \u2190 expandLinearCombo e with\n    | none => pure none\n    | some p => ``(neg_pf $p)\n  | `(\u2190 $e) => do\n    match \u2190 expandLinearCombo e with\n    | none => pure none\n    | some p => ``(Eq.symm $p)\n  | `($e\u2081 * $e\u2082) => do\n    match \u2190 expandLinearCombo e\u2081, \u2190 expandLinearCombo e\u2082 with\n    | none, none => pure none\n    | some p\u2081, none => ``(pf_mul_c $p\u2081 $e\u2082)\n    | none, some p\u2082 => ``(c_mul_pf $p\u2082 $e\u2081)\n    | some p\u2081, some p\u2082 => ``(mul_pf $p\u2081 $p\u2082)\n  | `($e\u207b\u00b9) => do\n    match \u2190 expandLinearCombo e with\n    | none => pure none\n    | some p => ``(inv_pf $p)\n  | `($e\u2081 / $e\u2082) => do\n    match \u2190 expandLinearCombo e\u2081, \u2190 expandLinearCombo e\u2082 with\n    | none, none => pure none\n    | some p\u2081, none => ``(pf_div_c $p\u2081 $e\u2082)\n    | none, some p\u2082 => ``(c_div_pf $p\u2082 $e\u2081)\n    | some p\u2081, some p\u2082 => ``(div_pf $p\u2081 $p\u2082)\n  | e => do\n    let e \u2190 elabTerm e none\n    let eType \u2190 inferType e\n    let .true := (\u2190 withReducible do whnf eType).isEq | pure none\n    some <$> e.toSyntax\n  return result.map fun r => \u27e8r.raw.setInfo (SourceInfo.fromRef stx true)\u27e9", "start": [54, 1], "end": [107, 75], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.eq_trans\u2083", "code": "theorem eq_trans\u2083 (p : (a:\u03b1) = b) (p\u2081 : a = a') (p\u2082 : b = b') : a' = b'", "start": [109, 1], "end": [109, 87], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.eq_of_add", "code": "theorem eq_of_add [AddGroup \u03b1] (p : (a:\u03b1) = b) (H : (a' - b') - (a - b) = 0) : a' = b'", "start": [111, 1], "end": [112, 55], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.eq_of_add_pow", "code": "theorem eq_of_add_pow [Ring \u03b1] [NoZeroDivisors \u03b1] (n : \u2115) (p : (a:\u03b1) = b)\n    (H : (a' - b')^n - (a - b) = 0) : a' = b'", "start": [114, 1], "end": [116, 83], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.LinearCombination.elabLinearCombination", "code": "def elabLinearCombination\n    (norm? : Option Syntax.Tactic) (exp? : Option Syntax.NumLit) (input : Option Syntax.Term)\n    (twoGoals := false) : Tactic.TacticM Unit := Tactic.withMainContext do\n  let p \u2190 match input with\n  | none => `(Eq.refl 0)\n  | some e => withSynthesize do\n    match \u2190 expandLinearCombo e with\n    | none => `(Eq.refl $e)\n    | some p => pure p\n  let norm := norm?.getD (Unhygienic.run `(tactic| ring1))\n  Tactic.evalTactic <| \u2190 withFreshMacroScope <|\n  if twoGoals then\n    `(tactic| (\n      refine eq_trans\u2083 $p ?a ?b\n      case' a => $norm:tactic\n      case' b => $norm:tactic))\n  else\n    match exp? with\n    | some n =>\n      if n.getNat = 1 then `(tactic| (refine eq_of_add $p ?a; case' a => $norm:tactic))\n      else `(tactic| (refine eq_of_add_pow $n $p ?a; case' a => $norm:tactic))\n    | _ => `(tactic| (refine eq_of_add $p ?a; case' a => $norm:tactic))", "start": [118, 1], "end": [140, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Quotient.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/GroupTheory/QuotientGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.quotientRel", "code": "def quotientRel : Setoid M :=\n  QuotientAddGroup.leftRel p.toAddSubgroup", "start": [30, 1], "end": [35, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientRel_r_def", "code": "theorem quotientRel_r_def {x y : M} : @Setoid.r _ p.quotientRel x y \u2194 x - y \u2208 p", "start": [38, 1], "end": [43, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.hasQuotient", "code": "instance hasQuotient : HasQuotient M (Submodule R M) :=\n  \u27e8fun p => Quotient (quotientRel p)\u27e9", "start": [46, 1], "end": [48, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk", "code": "def mk {p : Submodule R M} : M \u2192 M \u29f8 p :=\n  Quotient.mk''", "start": [53, 1], "end": [56, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk'_eq_mk'", "code": "@[simp]\ntheorem mk'_eq_mk' {p : Submodule R M} (x : M) :\n    @Quotient.mk' _ (quotientRel p) x = (mk : M \u2192 M \u29f8 p) x", "start": [62, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk''_eq_mk", "code": "@[simp]\ntheorem mk''_eq_mk {p : Submodule R M} (x : M) : (Quotient.mk'' x : M \u29f8 p) = (mk : M \u2192 M \u29f8 p) x", "start": [68, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.quot_mk_eq_mk", "code": "@[simp]\ntheorem quot_mk_eq_mk {p : Submodule R M} (x : M) : (Quot.mk _ x : M \u29f8 p) = (mk : M \u2192 M \u29f8 p) x", "start": [73, 1], "end": [75, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.eq'", "code": "protected theorem eq' {x y : M} : (mk x : M \u29f8 p) = (mk : M \u2192 M \u29f8 p) y \u2194 -x + y \u2208 p", "start": [78, 1], "end": [79, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.eq", "code": "protected theorem eq {x y : M} : (mk x : M \u29f8 p) = (mk y : M \u29f8 p) \u2194 x - y \u2208 p", "start": [82, 1], "end": [83, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_zero", "code": "@[simp]\ntheorem mk_zero : mk 0 = (0 : M \u29f8 p)", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_eq_zero", "code": "@[simp]\ntheorem mk_eq_zero : (mk x : M \u29f8 p) = 0 \u2194 x \u2208 p", "start": [100, 1], "end": [101, 98], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.addCommGroup", "code": "instance addCommGroup : AddCommGroup (M \u29f8 p) :=\n  QuotientAddGroup.Quotient.addCommGroup p.toAddSubgroup", "start": [104, 1], "end": [105, 57], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_add", "code": "@[simp]\ntheorem mk_add : (mk (x + y) : M \u29f8 p) = (mk x : M \u29f8 p) + (mk y : M \u29f8 p)", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_neg", "code": "@[simp]\ntheorem mk_neg : (mk (-x) : M \u29f8 p) = -(mk x : M \u29f8 p)", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_sub", "code": "@[simp]\ntheorem mk_sub : (mk (x - y) : M \u29f8 p) = (mk x : M \u29f8 p) - (mk y : M \u29f8 p)", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.instSMul'", "code": "instance instSMul' : SMul S (M \u29f8 P) :=\n  \u27e8fun a =>\n    Quotient.map' ((\u00b7 \u2022 \u00b7) a) fun x y h =>\n      leftRel_apply.mpr <| by simpa using Submodule.smul_mem P (a \u2022 (1 : R)) (leftRel_apply.mp h)\u27e9", "start": [127, 1], "end": [130, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.instSMul", "code": "instance instSMul : SMul R (M \u29f8 P) :=\n  Quotient.instSMul' P", "start": [134, 1], "end": [136, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_smul", "code": "@[simp]\ntheorem mk_smul (r : S) (x : M) : (mk (r \u2022 x) : M \u29f8 p) = r \u2022 mk x", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.smulCommClass", "code": "instance smulCommClass (T : Type*) [SMul T R] [SMul T M] [IsScalarTower T R M]\n    [SMulCommClass S T M] : SMulCommClass S T (M \u29f8 P) where\n  smul_comm _x _y := Quotient.ind' fun _z => congr_arg mk (smul_comm _ _ _)", "start": [144, 1], "end": [146, 76], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.isScalarTower", "code": "instance isScalarTower (T : Type*) [SMul T R] [SMul T M] [IsScalarTower T R M] [SMul S T]\n    [IsScalarTower S T M] : IsScalarTower S T (M \u29f8 P) where\n  smul_assoc _x _y := Quotient.ind' fun _z => congr_arg mk (smul_assoc _ _ _)", "start": [149, 1], "end": [151, 78], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.isCentralScalar", "code": "instance isCentralScalar [SMul S\u1d50\u1d52\u1d56 R] [SMul S\u1d50\u1d52\u1d56 M] [IsScalarTower S\u1d50\u1d52\u1d56 R M]\n    [IsCentralScalar S M] : IsCentralScalar S (M \u29f8 P) where\n  op_smul_eq_smul _x := Quotient.ind' fun _z => congr_arg mk <| op_smul_eq_smul _ _", "start": [154, 1], "end": [156, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mulAction'", "code": "instance mulAction' [Monoid S] [SMul S R] [MulAction S M] [IsScalarTower S R M]\n    (P : Submodule R M) : MulAction S (M \u29f8 P) :=\n  { Function.Surjective.mulAction mk (surjective_quot_mk _) <| Submodule.Quotient.mk_smul P with\n    toSMul := instSMul' _ }", "start": [167, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mulAction", "code": "instance mulAction (P : Submodule R M) : MulAction R (M \u29f8 P) :=\n  Quotient.mulAction' P", "start": [174, 1], "end": [175, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.smulZeroClass'", "code": "instance smulZeroClass' [SMul S R] [SMulZeroClass S M] [IsScalarTower S R M] (P : Submodule R M) :\n    SMulZeroClass S (M \u29f8 P) :=\n  ZeroHom.smulZeroClass \u27e8mk, mk_zero _\u27e9 <| Submodule.Quotient.mk_smul P", "start": [178, 1], "end": [180, 72], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.smulZeroClass", "code": "instance smulZeroClass (P : Submodule R M) : SMulZeroClass R (M \u29f8 P) :=\n  Quotient.smulZeroClass' P", "start": [184, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.distribSMul'", "code": "instance distribSMul' [SMul S R] [DistribSMul S M] [IsScalarTower S R M] (P : Submodule R M) :\n    DistribSMul S (M \u29f8 P) :=\n  { Function.Surjective.distribSMul {toFun := mk, map_zero' := rfl, map_add' := fun _ _ => rfl}\n    (surjective_quot_mk _) (Submodule.Quotient.mk_smul P) with\n    toSMulZeroClass := smulZeroClass' _ }", "start": [190, 1], "end": [194, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.distribSMul", "code": "instance distribSMul (P : Submodule R M) : DistribSMul R (M \u29f8 P) :=\n  Quotient.distribSMul' P", "start": [198, 1], "end": [199, 26], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.distribMulAction'", "code": "instance distribMulAction' [Monoid S] [SMul S R] [DistribMulAction S M] [IsScalarTower S R M]\n    (P : Submodule R M) : DistribMulAction S (M \u29f8 P) :=\n  { Function.Surjective.distribMulAction {toFun := mk, map_zero' := rfl, map_add' := fun _ _ => rfl}\n    (surjective_quot_mk _) (Submodule.Quotient.mk_smul P) with\n    toMulAction := mulAction' _ }", "start": [204, 1], "end": [208, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.distribMulAction", "code": "instance distribMulAction (P : Submodule R M) : DistribMulAction R (M \u29f8 P) :=\n  Quotient.distribMulAction' P", "start": [212, 1], "end": [213, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.module'", "code": "instance module' [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M] (P : Submodule R M) :\n    Module S (M \u29f8 P) :=\n  { Function.Surjective.module _ {toFun := mk, map_zero' := by rfl, map_add' := fun _ _ => by rfl}\n    (surjective_quot_mk _) (Submodule.Quotient.mk_smul P) with\n    toDistribMulAction := distribMulAction' _ }", "start": [218, 1], "end": [222, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.module", "code": "instance module (P : Submodule R M) : Module R (M \u29f8 P) :=\n  Quotient.module' P", "start": [226, 1], "end": [227, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.restrictScalarsEquiv", "code": "def restrictScalarsEquiv [Ring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    (P : Submodule R M) : (M \u29f8 P.restrictScalars S) \u2243\u2097[S] M \u29f8 P :=\n  { Quotient.congrRight fun _ _ => Iff.rfl with\n    map_add' := fun x y => Quotient.inductionOn\u2082' x y fun _x' _y' => rfl\n    map_smul' := fun _c x => Quotient.inductionOn' x fun _x' => rfl }", "start": [232, 1], "end": [239, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.restrictScalarsEquiv_mk", "code": "@[simp]\ntheorem restrictScalarsEquiv_mk [Ring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    (P : Submodule R M) (x : M) :\n    restrictScalarsEquiv S P (mk x : M \u29f8 P) = (mk x : M \u29f8 P)", "start": [242, 1], "end": [246, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.restrictScalarsEquiv_symm_mk", "code": "@[simp]\ntheorem restrictScalarsEquiv_symm_mk [Ring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    (P : Submodule R M) (x : M) :\n    (restrictScalarsEquiv S P).symm ((mk : M \u2192 M \u29f8 P) x) = (mk : M \u2192 M \u29f8 P) x", "start": [249, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.mk_surjective", "code": "theorem mk_surjective : Function.Surjective (@mk _ _ _ _ _ p)", "start": [258, 1], "end": [260, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.nontrivial_of_lt_top", "code": "theorem nontrivial_of_lt_top (h : p < \u22a4) : Nontrivial (M \u29f8 p)", "start": [263, 1], "end": [266, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.QuotientBot.infinite", "code": "instance QuotientBot.infinite [Infinite M] : Infinite (M \u29f8 (\u22a5 : Submodule R M)) :=\n  Infinite.of_injective Submodule.Quotient.mk fun _x _y h =>\n    sub_eq_zero.mp <| (Submodule.Quotient.eq \u22a5).mp h", "start": [271, 1], "end": [273, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.QuotientTop.unique", "code": "instance QuotientTop.unique : Unique (M \u29f8 (\u22a4 : Submodule R M)) where\n  default := 0\n  uniq x := Quotient.inductionOn' x fun _x => (Submodule.Quotient.eq \u22a4).mpr Submodule.mem_top", "start": [276, 1], "end": [278, 94], "kind": "commanddeclaration"}, {"full_name": "Submodule.QuotientTop.fintype", "code": "instance QuotientTop.fintype : Fintype (M \u29f8 (\u22a4 : Submodule R M)) :=\n  Fintype.ofSubsingleton 0", "start": [281, 1], "end": [282, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.subsingleton_quotient_iff_eq_top", "code": "theorem subsingleton_quotient_iff_eq_top : Subsingleton (M \u29f8 p) \u2194 p = \u22a4", "start": [287, 1], "end": [294, 19], "kind": "commanddeclaration"}, {"full_name": "Submodule.unique_quotient_iff_eq_top", "code": "theorem unique_quotient_iff_eq_top : Nonempty (Unique (M \u29f8 p)) \u2194 p = \u22a4", "start": [297, 1], "end": [299, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.fintype", "code": "noncomputable instance Quotient.fintype [Fintype M] (S : Submodule R M) : Fintype (M \u29f8 S) :=\n  @_root_.Quotient.fintype _ _ _ fun _ _ => Classical.dec _", "start": [304, 1], "end": [305, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.card_eq_card_quotient_mul_card", "code": "theorem card_eq_card_quotient_mul_card [Fintype M] (S : Submodule R M) [DecidablePred (\u00b7 \u2208 S)] :\n    Fintype.card M = Fintype.card S * Fintype.card (M \u29f8 S)", "start": [308, 1], "end": [311, 76], "kind": "commanddeclaration"}, {"full_name": "Submodule.quot_hom_ext", "code": "theorem quot_hom_ext (f g : (M \u29f8 p) \u2192\u2097[R] M\u2082) (h : \u2200 x : M, f (Quotient.mk x) = g (Quotient.mk x)) :\n    f = g", "start": [318, 1], "end": [320, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.mkQ", "code": "def mkQ : M \u2192\u2097[R] M \u29f8 p where\n  toFun := Quotient.mk\n  map_add' := by simp\n  map_smul' := by simp", "start": [323, 1], "end": [327, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.mkQ_apply", "code": "@[simp]\ntheorem mkQ_apply (x : M) : p.mkQ x = (Quotient.mk x : M \u29f8 p)", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mkQ_surjective", "code": "theorem mkQ_surjective (A : Submodule R M) : Function.Surjective A.mkQ", "start": [335, 1], "end": [336, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearMap_qext", "code": "@[ext 1100] theorem linearMap_qext \u2983f g : M \u29f8 p \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082\u2984 (h : f.comp p.mkQ = g.comp p.mkQ) : f = g", "start": [343, 1], "end": [349, 80], "kind": "commanddeclaration"}, {"full_name": "Submodule.liftQ", "code": "def liftQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h : p \u2264 ker f) : M \u29f8 p \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082 :=\n  { QuotientAddGroup.lift p.toAddSubgroup f.toAddMonoidHom h with\n    map_smul' := by rintro a \u27e8x\u27e9; exact f.map_smul\u209b\u2097 a x }", "start": [352, 1], "end": [356, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.liftQ_apply", "code": "@[simp]\ntheorem liftQ_apply (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {h} (x : M) : p.liftQ f h (Quotient.mk x) = f x", "start": [359, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.liftQ_mkQ", "code": "@[simp]\ntheorem liftQ_mkQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) : (p.liftQ f h).comp p.mkQ = f", "start": [364, 1], "end": [365, 88], "kind": "commanddeclaration"}, {"full_name": "Submodule.liftQSpanSingleton", "code": "def liftQSpanSingleton (x : M) (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h : f x = 0) : (M \u29f8 R \u2219 x) \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082 :=\n  (R \u2219 x).liftQ f <| by rw [span_singleton_le_iff_mem, LinearMap.mem_ker, h]", "start": [368, 1], "end": [371, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.liftQSpanSingleton_apply", "code": "@[simp]\ntheorem liftQSpanSingleton_apply (x : M) (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h : f x = 0) (y : M) :\n    liftQSpanSingleton x f h (Quotient.mk y) = f y", "start": [374, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_mkQ", "code": "@[simp]\ntheorem range_mkQ : range p.mkQ = \u22a4", "start": [380, 1], "end": [382, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_mkQ", "code": "@[simp]\ntheorem ker_mkQ : ker p.mkQ = p", "start": [385, 1], "end": [386, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_comap_mkQ", "code": "theorem le_comap_mkQ (p' : Submodule R (M \u29f8 p)) : p \u2264 comap p.mkQ p'", "start": [389, 1], "end": [390, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.mkQ_map_self", "code": "@[simp]\ntheorem mkQ_map_self : map p.mkQ p = \u22a5", "start": [393, 1], "end": [395, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_map_mkQ", "code": "@[simp]\ntheorem comap_map_mkQ : comap p.mkQ (map p.mkQ p') = p \u2294 p'", "start": [398, 1], "end": [399, 96], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_mkQ_eq_top", "code": "@[simp]\ntheorem map_mkQ_eq_top : map p.mkQ p' = \u22a4 \u2194 p \u2294 p' = \u22a4", "start": [402, 1], "end": [406, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ", "code": "def mapQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h : p \u2264 comap f q) : M \u29f8 p \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082 \u29f8 q :=\n  p.liftQ (q.mkQ.comp f) <| by simpa [ker_comp] using h", "start": [411, 1], "end": [414, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_apply", "code": "@[simp]\ntheorem mapQ_apply (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {h} (x : M) :\n    mapQ p q f h (Quotient.mk x : M \u29f8 p) = (Quotient.mk (f x) : M\u2082 \u29f8 q)", "start": [417, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_mkQ", "code": "theorem mapQ_mkQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) {h} : (mapQ p q f h).comp p.mkQ = q.mkQ.comp f", "start": [423, 1], "end": [424, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_zero", "code": "@[simp]\ntheorem mapQ_zero (h : p \u2264 q.comap (0 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) := (by simp)) :\n    p.mapQ q (0 : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) h = 0", "start": [427, 1], "end": [431, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_comp", "code": "theorem mapQ_comp {R\u2083 M\u2083 : Type*} [Ring R\u2083] [AddCommGroup M\u2083] [Module R\u2083 M\u2083] (p\u2082 : Submodule R\u2082 M\u2082)\n    (p\u2083 : Submodule R\u2083 M\u2083) {\u03c4\u2082\u2083 : R\u2082 \u2192+* R\u2083} {\u03c4\u2081\u2083 : R \u2192+* R\u2083} [RingHomCompTriple \u03c4\u2081\u2082 \u03c4\u2082\u2083 \u03c4\u2081\u2083]\n    (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083) (hf : p \u2264 p\u2082.comap f) (hg : p\u2082 \u2264 p\u2083.comap g)\n    (h := hf.trans (comap_mono hg)) :\n    p.mapQ p\u2083 (g.comp f) h = (p\u2082.mapQ p\u2083 g hg).comp (p.mapQ p\u2082 f hf)", "start": [434, 1], "end": [443, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_id", "code": "@[simp]\ntheorem mapQ_id (h : p \u2264 p.comap LinearMap.id := (by rw [comap_id])) :\n    p.mapQ p LinearMap.id h = LinearMap.id", "start": [446, 1], "end": [450, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQ_pow", "code": "theorem mapQ_pow {f : M \u2192\u2097[R] M} (h : p \u2264 p.comap f) (k : \u2115)\n    (h' : p \u2264 p.comap (f ^ k) := p.le_comap_pow_of_le_comap h k) :\n    p.mapQ p (f ^ k) h' = p.mapQ p f h ^ k", "start": [453, 1], "end": [463, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_liftQ", "code": "theorem comap_liftQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) : q.comap (p.liftQ f h) = (q.comap f).map (mkQ p)", "start": [466, 1], "end": [468, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_liftQ", "code": "theorem map_liftQ [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) (q : Submodule R (M \u29f8 p)) :\n    q.map (p.liftQ f h) = (q.comap p.mkQ).map f", "start": [471, 1], "end": [474, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_liftQ", "code": "theorem ker_liftQ (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) : ker (p.liftQ f h) = (ker f).map (mkQ p)", "start": [477, 1], "end": [478, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_liftQ", "code": "theorem range_liftQ [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) :\n    range (p.liftQ f h) = range f", "start": [481, 1], "end": [482, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.ker_liftQ_eq_bot", "code": "theorem ker_liftQ_eq_bot (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) (h' : ker f \u2264 p) : ker (p.liftQ f h) = \u22a5", "start": [485, 1], "end": [486, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.comapMkQRelIso", "code": "def comapMkQRelIso : Submodule R (M \u29f8 p) \u2243o { p' : Submodule R M // p \u2264 p' } where\n  toFun p' := \u27e8comap p.mkQ p', le_comap_mkQ p _\u27e9\n  invFun q := map p.mkQ q\n  left_inv p' := map_comap_eq_self <| by simp\n  right_inv := fun \u27e8q, hq\u27e9 => Subtype.ext_val <| by simpa [comap_map_mkQ p]\n  map_rel_iff' := comap_le_comap_iff <| range_mkQ _", "start": [489, 1], "end": [496, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.comapMkQOrderEmbedding", "code": "def comapMkQOrderEmbedding : Submodule R (M \u29f8 p) \u21aao Submodule R M :=\n  (RelIso.toRelEmbedding <| comapMkQRelIso p).trans (Subtype.relEmbedding (\u00b7 \u2264 \u00b7) _)", "start": [499, 1], "end": [502, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.comapMkQOrderEmbedding_eq", "code": "@[simp]\ntheorem comapMkQOrderEmbedding_eq (p' : Submodule R (M \u29f8 p)) :\n    comapMkQOrderEmbedding p p' = comap p.mkQ p'", "start": [505, 1], "end": [508, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_preimage_eq", "code": "theorem span_preimage_eq [RingHomSurjective \u03c4\u2081\u2082] {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {s : Set M\u2082} (h\u2080 : s.Nonempty)\n    (h\u2081 : s \u2286 range f) : span R (f \u207b\u00b9' s) = (span R\u2082 s).comap f", "start": [511, 1], "end": [524, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.equiv", "code": "@[simps]\ndef Quotient.equiv {N : Type*} [AddCommGroup N] [Module R N] (P : Submodule R M)\n    (Q : Submodule R N) (f : M \u2243\u2097[R] N) (hf : P.map f = Q) : (M \u29f8 P) \u2243\u2097[R] N \u29f8 Q :=\n  { P.mapQ Q (f : M \u2192\u2097[R] N) fun x hx => hf \u25b8 Submodule.mem_map_of_mem hx with\n    toFun := P.mapQ Q (f : M \u2192\u2097[R] N) fun x hx => hf \u25b8 Submodule.mem_map_of_mem hx\n    invFun :=\n      Q.mapQ P (f.symm : N \u2192\u2097[R] M) fun x hx => by\n        rw [\u2190 hf, Submodule.mem_map] at hx\n        obtain \u27e8y, hy, rfl\u27e9 := hx\n        simpa\n    left_inv := fun x => Quotient.inductionOn' x (by simp)\n    right_inv := fun x => Quotient.inductionOn' x (by simp) }", "start": [527, 1], "end": [540, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.equiv_symm", "code": "@[simp]\ntheorem Quotient.equiv_symm {R M N : Type*} [CommRing R] [AddCommGroup M] [Module R M]\n    [AddCommGroup N] [Module R N] (P : Submodule R M) (Q : Submodule R N) (f : M \u2243\u2097[R] N)\n    (hf : P.map f = Q) :\n    (Quotient.equiv P Q f hf).symm =\n      Quotient.equiv Q P f.symm ((Submodule.map_symm_eq_iff f).mpr hf)", "start": [544, 1], "end": [550, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.equiv_trans", "code": "@[simp]\ntheorem Quotient.equiv_trans {N O : Type*} [AddCommGroup N] [Module R N] [AddCommGroup O]\n    [Module R O] (P : Submodule R M) (Q : Submodule R N) (S : Submodule R O) (e : M \u2243\u2097[R] N)\n    (f : N \u2243\u2097[R] O) (he : P.map e = Q) (hf : Q.map f = S) (hef : P.map (e.trans f) = S) :\n    Quotient.equiv P S (e.trans f) hef =\n      (Quotient.equiv P Q e he).trans (Quotient.equiv Q S f hf)", "start": [553, 1], "end": [563, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_mkQ_comp", "code": "theorem range_mkQ_comp (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.range.mkQ.comp f = 0", "start": [586, 1], "end": [587, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_le_range_iff", "code": "theorem ker_le_range_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} :\n    ker g \u2264 range f \u2194 f.range.mkQ.comp g.ker.subtype = 0", "start": [590, 1], "end": [592, 70], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_eq_top_of_cancel", "code": "theorem range_eq_top_of_cancel {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082}\n    (h : \u2200 u v : M\u2082 \u2192\u2097[R\u2082] M\u2082 \u29f8 (range f), u.comp f = v.comp f \u2192 u = v) : range f = \u22a4", "start": [595, 1], "end": [600, 17], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotEquivOfEqBot", "code": "def quotEquivOfEqBot (hp : p = \u22a5) : (M \u29f8 p) \u2243\u2097[R] M :=\n  LinearEquiv.ofLinear (p.liftQ id <| hp.symm \u25b8 bot_le) p.mkQ (liftQ_mkQ _ _ _) <|\n    p.quot_hom_ext _ LinearMap.id fun _ => rfl", "start": [615, 1], "end": [618, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotEquivOfEqBot_apply_mk", "code": "@[simp]\ntheorem quotEquivOfEqBot_apply_mk (hp : p = \u22a5) (x : M) :\n    p.quotEquivOfEqBot hp (Quotient.mk x : M \u29f8 p) = x", "start": [621, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotEquivOfEqBot_symm_apply", "code": "@[simp]\ntheorem quotEquivOfEqBot_symm_apply (hp : p = \u22a5) (x : M) :\n    (p.quotEquivOfEqBot hp).symm x = (Quotient.mk x : M \u29f8 p)", "start": [627, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_quotEquivOfEqBot_symm", "code": "@[simp]\ntheorem coe_quotEquivOfEqBot_symm (hp : p = \u22a5) :\n    ((p.quotEquivOfEqBot hp).symm : M \u2192\u2097[R] M \u29f8 p) = p.mkQ", "start": [633, 1], "end": [636, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotEquivOfEq", "code": "def quotEquivOfEq (h : p = p') : (M \u29f8 p) \u2243\u2097[R] M \u29f8 p' :=\n  { @Quotient.congr _ _ (quotientRel p) (quotientRel p') (Equiv.refl _) fun a b => by\n      subst h\n      rfl with\n    map_add' := by\n      rintro \u27e8x\u27e9 \u27e8y\u27e9\n      rfl\n    map_smul' := by\n      rintro x \u27e8y\u27e9\n      rfl }", "start": [639, 1], "end": [649, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotEquivOfEq_mk", "code": "@[simp]\ntheorem quotEquivOfEq_mk (h : p = p') (x : M) :\n    Submodule.quotEquivOfEq p p' h (Submodule.Quotient.mk x : M \u29f8 p) =\n      (Submodule.Quotient.mk x : M \u29f8 p')", "start": [652, 1], "end": [656, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.equiv_refl", "code": "@[simp]\ntheorem Quotient.equiv_refl (P : Submodule R M) (Q : Submodule R M)\n    (hf : P.map (LinearEquiv.refl R M : M \u2192\u2097[R] M) = Q) :\n    Quotient.equiv P Q (LinearEquiv.refl R M) hf = quotEquivOfEq _ _ (by simpa using hf)", "start": [659, 1], "end": [663, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapQLinear", "code": "def mapQLinear : compatibleMaps p q \u2192\u2097[R] M \u29f8 p \u2192\u2097[R] M\u2082 \u29f8 q\n    where\n  toFun f := mapQ _ _ f.val f.property\n  map_add' x y := by\n    ext\n    rfl\n  map_smul' c f := by\n    ext\n    rfl", "start": [677, 1], "end": [687, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Linarith.lean", "imports": ["Mathlib/Tactic/Linarith/Frontend.lean", "Mathlib/Tactic/NormNum.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Finset/NatAntidiagonal.lean", "imports": ["Mathlib/Data/Multiset/NatAntidiagonal.lean", "Mathlib/Data/Finset/Card.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Nat.antidiagonal", "code": "def antidiagonal (n : \u2115) : Finset (\u2115 \u00d7 \u2115) :=\n  \u27e8Multiset.Nat.antidiagonal n, Multiset.Nat.nodup_antidiagonal n\u27e9", "start": [29, 1], "end": [32, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.mem_antidiagonal", "code": "@[simp]\ntheorem mem_antidiagonal {n : \u2115} {x : \u2115 \u00d7 \u2115} : x \u2208 antidiagonal n \u2194 x.1 + x.2 = n", "start": [35, 1], "end": [38, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.card_antidiagonal", "code": "@[simp]\ntheorem card_antidiagonal (n : \u2115) : (antidiagonal n).card = n + 1", "start": [41, 1], "end": [43, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_zero", "code": "@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = {(0, 0)}", "start": [46, 1], "end": [48, 61], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_succ", "code": "theorem antidiagonal_succ (n : \u2115) :\n    antidiagonal (n + 1) =\n      cons (0, n + 1)\n        ((antidiagonal n).map\n          (Embedding.prodMap \u27e8Nat.succ, Nat.succ_injective\u27e9 (Embedding.refl _)))\n        (by simp)", "start": [51, 1], "end": [59, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_succ'", "code": "theorem antidiagonal_succ' (n : \u2115) :\n    antidiagonal (n + 1) =\n      cons (n + 1, 0)\n        ((antidiagonal n).map\n          (Embedding.prodMap (Embedding.refl _) \u27e8Nat.succ, Nat.succ_injective\u27e9))\n        (by simp)", "start": [62, 1], "end": [70, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_succ_succ'", "code": "theorem antidiagonal_succ_succ' {n : \u2115} :\n    antidiagonal (n + 2) =\n      cons (0, n + 2)\n        (cons (n + 2, 0)\n            ((antidiagonal n).map\n              (Embedding.prodMap \u27e8Nat.succ, Nat.succ_injective\u27e9\n                \u27e8Nat.succ, Nat.succ_injective\u27e9)) <|\n          by simp)\n        (by simp)", "start": [73, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.map_swap_antidiagonal", "code": "@[simp] theorem map_swap_antidiagonal {n : \u2115} :\n    (antidiagonal n).map \u27e8Prod.swap, Prod.swap_injective\u27e9 = antidiagonal n", "start": [86, 1], "end": [89, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.map_prodComm_antidiagonal", "code": "@[simp] theorem map_prodComm_antidiagonal {n : \u2115} :\n    (antidiagonal n).map (Equiv.prodComm \u2115 \u2115) = antidiagonal n", "start": [92, 1], "end": [94, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_congr", "code": "theorem antidiagonal_congr {n : \u2115} {p q : \u2115 \u00d7 \u2115} (hp : p \u2208 antidiagonal n)\n    (hq : q \u2208 antidiagonal n) : p = q \u2194 p.fst = q.fst", "start": [96, 1], "end": [101, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_subtype_ext", "code": "@[ext] theorem antidiagonal_subtype_ext {n : \u2115} {p q : antidiagonal n} (h : p.val.1 = q.val.1) :\n    p = q", "start": [104, 1], "end": [107, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal.fst_le", "code": "theorem antidiagonal.fst_le {n : \u2115} {kl : \u2115 \u00d7 \u2115} (hlk : kl \u2208 antidiagonal n) : kl.1 \u2264 n", "start": [109, 1], "end": [112, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal.fst_lt", "code": "theorem antidiagonal.fst_lt {n : \u2115} {kl : \u2115 \u00d7 \u2115} (hlk : kl \u2208 antidiagonal n) : kl.1 < n + 1", "start": [115, 1], "end": [116, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal.snd_le", "code": "theorem antidiagonal.snd_le {n : \u2115} {kl : \u2115 \u00d7 \u2115} (hlk : kl \u2208 antidiagonal n) : kl.2 \u2264 n", "start": [118, 1], "end": [121, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal.snd_lt", "code": "theorem antidiagonal.snd_lt {n : \u2115} {kl : \u2115 \u00d7 \u2115} (hlk : kl \u2208 antidiagonal n) : kl.2 < n + 1", "start": [124, 1], "end": [125, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.filter_fst_eq_antidiagonal", "code": "theorem filter_fst_eq_antidiagonal (n m : \u2115) :\n    filter (fun x : \u2115 \u00d7 \u2115 \u21a6 x.fst = m) (antidiagonal n) = if m \u2264 n then {(m, n - m)} else \u2205", "start": [127, 1], "end": [135, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.filter_snd_eq_antidiagonal", "code": "theorem filter_snd_eq_antidiagonal (n m : \u2115) :\n    filter (fun x : \u2115 \u00d7 \u2115 \u21a6 x.snd = m) (antidiagonal n) = if m \u2264 n then {(n - m, m)} else \u2205", "start": [138, 1], "end": [143, 68], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonal_filter_snd_le_of_le", "code": "@[simp] lemma antidiagonal_filter_snd_le_of_le {n k : \u2115} (h : k \u2264 n) :\n    (antidiagonal n).filter (fun a \u21a6 a.snd \u2264 k) = (antidiagonal k).map\n      (Embedding.prodMap \u27e8_, add_left_injective (n - k)\u27e9 (Embedding.refl \u2115)) := by\n  ext \u27e8i, j\u27e9\n  suffices i + j = n \u2227 j \u2264 k \u2194 \u2203 a, a + j = k \u2227 a + (n - k) = i by simpa\n  refine' \u27e8fun hi \u21a6 \u27e8k - j, tsub_add_cancel_of_le hi.2, _\u27e9, _\u27e9\n  \u00b7 rw [add_comm, tsub_add_eq_add_tsub h, \u2190 hi.1, add_assoc, Nat.add_sub_of_le hi.2,\n      add_tsub_cancel_right]\n  \u00b7 rintro \u27e8l, hl, rfl\u27e9\n    refine' \u27e8_, hl \u25b8 Nat.le_add_left j l\u27e9\n    rw [add_assoc, add_comm, add_assoc, add_comm j l, hl]\n    exact Nat.sub_add_cancel h", "start": [146, 1], "end": [157, 31], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Nat.antidiagonal_filter_fst_le_of_le", "code": "@[simp] lemma antidiagonal_filter_fst_le_of_le {n k : \u2115} (h : k \u2264 n) :\n    (antidiagonal n).filter (fun a \u21a6 a.fst \u2264 k) = (antidiagonal k).map\n      (Embedding.prodMap (Embedding.refl \u2115) \u27e8_, add_left_injective (n - k)\u27e9) := by\n  have aux\u2081 : fun a \u21a6 a.fst \u2264 k = (fun a \u21a6 a.snd \u2264 k) \u2218 (Equiv.prodComm \u2115 \u2115).symm := rfl\n  have aux\u2082 : \u2200 i j, (\u2203 a b, a + b = k \u2227 b = i \u2227 a + (n - k) = j) \u2194\n                      \u2203 a b, a + b = k \u2227 a = i \u2227 b + (n - k) = j :=\n    fun i j \u21a6 by rw [exists_comm]; exact exists\u2082_congr (fun a b \u21a6 by rw [add_comm])\n  rw [\u2190 map_prodComm_antidiagonal]\n  simp_rw [aux\u2081, \u2190 map_filter, antidiagonal_filter_snd_le_of_le h, map_map]\n  ext \u27e8i, j\u27e9\n  simpa using aux\u2082 i j", "start": [159, 1], "end": [169, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Nat.antidiagonal_filter_le_fst_of_le", "code": "@[simp] lemma antidiagonal_filter_le_fst_of_le {n k : \u2115} (h : k \u2264 n) :\n    (antidiagonal n).filter (fun a \u21a6 k \u2264 a.fst) = (antidiagonal (n - k)).map\n      (Embedding.prodMap \u27e8_, add_left_injective k\u27e9 (Embedding.refl \u2115)) := by\n  ext \u27e8i, j\u27e9\n  suffices i + j = n \u2227 k \u2264 i \u2194 \u2203 a, a + j = n - k \u2227 a + k = i by simpa\n  refine' \u27e8fun hi \u21a6 \u27e8i - k, _, tsub_add_cancel_of_le hi.2\u27e9, _\u27e9\n  \u00b7 rw [\u2190 Nat.sub_add_comm hi.2, hi.1]\n  \u00b7 rintro \u27e8l, hl, rfl\u27e9\n    refine' \u27e8_, Nat.le_add_left k l\u27e9\n    rw [add_right_comm, hl]\n    exact tsub_add_cancel_of_le h", "start": [171, 1], "end": [181, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Nat.antidiagonal_filter_le_snd_of_le", "code": "@[simp] lemma antidiagonal_filter_le_snd_of_le {n k : \u2115} (h : k \u2264 n) :\n    (antidiagonal n).filter (fun a \u21a6 k \u2264 a.snd) = (antidiagonal (n - k)).map\n      (Embedding.prodMap (Embedding.refl \u2115) \u27e8_, add_left_injective k\u27e9) := by\n  have aux\u2081 : fun a \u21a6 k \u2264 a.snd = (fun a \u21a6 k \u2264 a.fst) \u2218 (Equiv.prodComm \u2115 \u2115).symm := rfl\n  have aux\u2082 : \u2200 i j, (\u2203 a b, a + b = n - k \u2227 b = i \u2227 a + k = j) \u2194\n                      \u2203 a b, a + b = n - k \u2227 a = i \u2227 b + k = j :=\n    fun i j \u21a6 by rw [exists_comm]; exact exists\u2082_congr (fun a b \u21a6 by rw [add_comm])\n  rw [\u2190 map_prodComm_antidiagonal]\n  simp_rw [aux\u2081, \u2190 map_filter, antidiagonal_filter_le_fst_of_le h, map_map]\n  ext \u27e8i, j\u27e9\n  simpa using aux\u2082 i j", "start": [183, 1], "end": [193, 23], "kind": "mathlibtacticlemma"}, {"full_name": "Finset.Nat.sigmaAntidiagonalEquivProd", "code": "@[simps]\ndef sigmaAntidiagonalEquivProd : (\u03a3n : \u2115, antidiagonal n) \u2243 \u2115 \u00d7 \u2115 where\n  toFun x := x.2\n  invFun x := \u27e8x.1 + x.2, x, mem_antidiagonal.mpr rfl\u27e9\n  left_inv := by\n    rintro \u27e8n, \u27e8k, l\u27e9, h\u27e9\n    rw [mem_antidiagonal] at h\n    exact Sigma.subtype_ext h rfl\n  right_inv x := rfl", "start": [197, 1], "end": [207, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.antidiagonalEquivFin", "code": "@[simps]\ndef antidiagonalEquivFin (n : \u2115) : antidiagonal n \u2243 Fin (n + 1) where\n  toFun := fun \u27e8\u27e8i, j\u27e9, h\u27e9 \u21a6 \u27e8i, antidiagonal.fst_lt h\u27e9\n  invFun := fun \u27e8i, h\u27e9 \u21a6 \u27e8\u27e8i, n - i\u27e9, by\n    rw [mem_antidiagonal, add_comm, tsub_add_cancel_iff_le]\n    exact Nat.le_of_lt_succ h\u27e9\n  left_inv := by rintro \u27e8\u27e8i, j\u27e9, h\u27e9; ext; rfl\n  right_inv x := rfl", "start": [215, 1], "end": [223, 21], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/DischargerAsTactic.lean", "imports": ["lake-packages/std/Std/Tactic/Exact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "wrapSimpDischarger", "code": "def wrapSimpDischarger (dis : Simp.Discharge) : TacticM Unit := do\n  let eS : Lean.Meta.Simp.State := {}\n  let eC : Lean.Meta.Simp.Context := {}\n  let (some a, _) \u2190 liftM <| StateRefT'.run (ReaderT.run (dis <| \u2190 getMainTarget) eC) eS | failure\n  (\u2190 getMainGoal).assignIfDefeq a", "start": [17, 1], "end": [24, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Init/Meta/WellFoundedTactics.lean", "imports": ["Mathlib/Init/Data/Nat/Lemmas.lean"], "premises": [{"full_name": "Nat.lt_add_of_zero_lt_left", "code": "theorem Nat.lt_add_of_zero_lt_left (a b : Nat) (h : 0 < b) : a < a + b", "start": [13, 1], "end": [16, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.zero_lt_one_add", "code": "theorem Nat.zero_lt_one_add (a : Nat) : 0 < 1 + a", "start": [19, 1], "end": [23, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_add_left", "code": "theorem Nat.lt_add_left (a b c : Nat) : a < b \u2192 a < c + b", "start": [28, 1], "end": [29, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Lemmas.lean", "imports": ["Mathlib/Data/Nat/Order/Lemmas.lean", "Mathlib/Data/Nat/Cast/Order.lean", "Mathlib/Data/Int/Bitwise.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Int/Order/Lemmas.lean"], "premises": [{"full_name": "Int.le_coe_nat_sub", "code": "theorem le_coe_nat_sub (m n : \u2115) : (m - n : \u2124) \u2264 \u2191(m - n : \u2115)", "start": [27, 1], "end": [30, 36], "kind": "commanddeclaration"}, {"full_name": "Int.succ_coe_nat_pos", "code": "theorem succ_coe_nat_pos (n : \u2115) : 0 < (n : \u2124) + 1", "start": [37, 1], "end": [38, 31], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_eq_iff_sq_eq", "code": "theorem natAbs_eq_iff_sq_eq {a b : \u2124} : a.natAbs = b.natAbs \u2194 a ^ 2 = b ^ 2", "start": [46, 1], "end": [48, 34], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_lt_iff_sq_lt", "code": "theorem natAbs_lt_iff_sq_lt {a b : \u2124} : a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2", "start": [51, 1], "end": [53, 34], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_le_iff_sq_le", "code": "theorem natAbs_le_iff_sq_le {a b : \u2124} : a.natAbs \u2264 b.natAbs \u2194 a ^ 2 \u2264 b ^ 2", "start": [56, 1], "end": [58, 34], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_inj_of_nonneg_of_nonneg", "code": "theorem natAbs_inj_of_nonneg_of_nonneg {a b : \u2124} (ha : 0 \u2264 a) (hb : 0 \u2264 b) :\n    natAbs a = natAbs b \u2194 a = b", "start": [61, 1], "end": [62, 83], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_inj_of_nonpos_of_nonpos", "code": "theorem natAbs_inj_of_nonpos_of_nonpos {a b : \u2124} (ha : a \u2264 0) (hb : b \u2264 0) :\n    natAbs a = natAbs b \u2194 a = b", "start": [65, 1], "end": [68, 87], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_inj_of_nonneg_of_nonpos", "code": "theorem natAbs_inj_of_nonneg_of_nonpos {a b : \u2124} (ha : 0 \u2264 a) (hb : b \u2264 0) :\n    natAbs a = natAbs b \u2194 a = -b", "start": [71, 1], "end": [73, 96], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_inj_of_nonpos_of_nonneg", "code": "theorem natAbs_inj_of_nonpos_of_nonneg {a b : \u2124} (ha : a \u2264 0) (hb : 0 \u2264 b) :\n    natAbs a = natAbs b \u2194 -a = b", "start": [76, 1], "end": [78, 96], "kind": "commanddeclaration"}, {"full_name": "Int.strictMonoOn_natAbs", "code": "theorem strictMonoOn_natAbs : StrictMonoOn natAbs (Ici 0)", "start": [85, 1], "end": [86, 42], "kind": "commanddeclaration"}, {"full_name": "Int.strictAntiOn_natAbs", "code": "theorem strictAntiOn_natAbs : StrictAntiOn natAbs (Iic 0)", "start": [89, 1], "end": [91, 92], "kind": "commanddeclaration"}, {"full_name": "Int.injOn_natAbs_Ici", "code": "theorem injOn_natAbs_Ici : InjOn natAbs (Ici 0)", "start": [94, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "Int.injOn_natAbs_Iic", "code": "theorem injOn_natAbs_Iic : InjOn natAbs (Iic 0)", "start": [98, 1], "end": [99, 28], "kind": "commanddeclaration"}, {"full_name": "Int.toNat_of_nonpos", "code": "theorem toNat_of_nonpos : \u2200 {z : \u2124}, z \u2264 0 \u2192 z.toNat = 0", "start": [107, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "Int.div2_bit", "code": "@[simp]\ntheorem div2_bit (b n) : div2 (bit b n) = n", "start": [121, 1], "end": [128, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Group.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Data/Set/Pairwise/Basic.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/Basic.lean"], "premises": [{"full_name": "Set.inv_mem_Icc_iff", "code": "@[to_additive]\ntheorem inv_mem_Icc_iff : a\u207b\u00b9 \u2208 Set.Icc c d \u2194 a \u2208 Set.Icc d\u207b\u00b9 c\u207b\u00b9", "start": [27, 1], "end": [29, 46], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_Ico_iff", "code": "@[to_additive]\ntheorem inv_mem_Ico_iff : a\u207b\u00b9 \u2208 Set.Ico c d \u2194 a \u2208 Set.Ioc d\u207b\u00b9 c\u207b\u00b9", "start": [33, 1], "end": [35, 46], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_Ioc_iff", "code": "@[to_additive]\ntheorem inv_mem_Ioc_iff : a\u207b\u00b9 \u2208 Set.Ioc c d \u2194 a \u2208 Set.Ico d\u207b\u00b9 c\u207b\u00b9", "start": [39, 1], "end": [41, 46], "kind": "commanddeclaration"}, {"full_name": "Set.inv_mem_Ioo_iff", "code": "@[to_additive]\ntheorem inv_mem_Ioo_iff : a\u207b\u00b9 \u2208 Set.Ioo c d \u2194 a \u2208 Set.Ioo d\u207b\u00b9 c\u207b\u00b9", "start": [45, 1], "end": [47, 46], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Icc_iff_left", "code": "theorem add_mem_Icc_iff_left : a + b \u2208 Set.Icc c d \u2194 a \u2208 Set.Icc (c - b) (d - b)", "start": [61, 1], "end": [62, 77], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ico_iff_left", "code": "theorem add_mem_Ico_iff_left : a + b \u2208 Set.Ico c d \u2194 a \u2208 Set.Ico (c - b) (d - b)", "start": [65, 1], "end": [66, 77], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ioc_iff_left", "code": "theorem add_mem_Ioc_iff_left : a + b \u2208 Set.Ioc c d \u2194 a \u2208 Set.Ioc (c - b) (d - b)", "start": [69, 1], "end": [70, 77], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ioo_iff_left", "code": "theorem add_mem_Ioo_iff_left : a + b \u2208 Set.Ioo c d \u2194 a \u2208 Set.Ioo (c - b) (d - b)", "start": [73, 1], "end": [74, 77], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Icc_iff_right", "code": "theorem add_mem_Icc_iff_right : a + b \u2208 Set.Icc c d \u2194 b \u2208 Set.Icc (c - a) (d - a)", "start": [80, 1], "end": [81, 57], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ico_iff_right", "code": "theorem add_mem_Ico_iff_right : a + b \u2208 Set.Ico c d \u2194 b \u2208 Set.Ico (c - a) (d - a)", "start": [84, 1], "end": [85, 57], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ioc_iff_right", "code": "theorem add_mem_Ioc_iff_right : a + b \u2208 Set.Ioc c d \u2194 b \u2208 Set.Ioc (c - a) (d - a)", "start": [88, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "Set.add_mem_Ioo_iff_right", "code": "theorem add_mem_Ioo_iff_right : a + b \u2208 Set.Ioo c d \u2194 b \u2208 Set.Ioo (c - a) (d - a)", "start": [92, 1], "end": [93, 57], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Icc_iff_left", "code": "theorem sub_mem_Icc_iff_left : a - b \u2208 Set.Icc c d \u2194 a \u2208 Set.Icc (c + b) (d + b)", "start": [99, 1], "end": [100, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ico_iff_left", "code": "theorem sub_mem_Ico_iff_left : a - b \u2208 Set.Ico c d \u2194 a \u2208 Set.Ico (c + b) (d + b)", "start": [103, 1], "end": [104, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ioc_iff_left", "code": "theorem sub_mem_Ioc_iff_left : a - b \u2208 Set.Ioc c d \u2194 a \u2208 Set.Ioc (c + b) (d + b)", "start": [107, 1], "end": [108, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ioo_iff_left", "code": "theorem sub_mem_Ioo_iff_left : a - b \u2208 Set.Ioo c d \u2194 a \u2208 Set.Ioo (c + b) (d + b)", "start": [111, 1], "end": [112, 48], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Icc_iff_right", "code": "theorem sub_mem_Icc_iff_right : a - b \u2208 Set.Icc c d \u2194 b \u2208 Set.Icc (a - d) (a - c)", "start": [118, 1], "end": [119, 54], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ico_iff_right", "code": "theorem sub_mem_Ico_iff_right : a - b \u2208 Set.Ico c d \u2194 b \u2208 Set.Ioc (a - d) (a - c)", "start": [122, 1], "end": [123, 54], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ioc_iff_right", "code": "theorem sub_mem_Ioc_iff_right : a - b \u2208 Set.Ioc c d \u2194 b \u2208 Set.Ico (a - d) (a - c)", "start": [126, 1], "end": [127, 54], "kind": "commanddeclaration"}, {"full_name": "Set.sub_mem_Ioo_iff_right", "code": "theorem sub_mem_Ioo_iff_right : a - b \u2208 Set.Ioo c d \u2194 b \u2208 Set.Ioo (a - d) (a - c)", "start": [130, 1], "end": [131, 54], "kind": "commanddeclaration"}, {"full_name": "Set.mem_Icc_iff_abs_le", "code": "theorem mem_Icc_iff_abs_le {R : Type*} [LinearOrderedAddCommGroup R] {x y z : R} :\n    |x - y| \u2264 z \u2194 y \u2208 Icc (x - z) (x + z)", "start": [136, 1], "end": [138, 80], "kind": "commanddeclaration"}, {"full_name": "Set.nonempty_Ico_sdiff", "code": "theorem nonempty_Ico_sdiff {x dx y dy : \u03b1} (h : dy < dx) (hx : 0 < dx) :\n    Nonempty \u2191(Ico x (x + dx) \\ Ico y (y + dy))", "start": [147, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioc_mul_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ioc_mul_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioc (a * b ^ n) (a * b ^ (n + 1)))", "start": [167, 1], "end": [179, 26], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ico_mul_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ico_mul_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ico (a * b ^ n) (a * b ^ (n + 1)))", "start": [183, 1], "end": [195, 26], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioo_mul_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ioo_mul_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioo (a * b ^ n) (a * b ^ (n + 1)))", "start": [199, 1], "end": [202, 88], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioc_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ioc_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioc (b ^ n) (b ^ (n + 1)))", "start": [206, 1], "end": [209, 64], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ico_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ico_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ico (b ^ n) (b ^ (n + 1)))", "start": [213, 1], "end": [216, 64], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioo_zpow", "code": "@[to_additive]\ntheorem pairwise_disjoint_Ioo_zpow :\n    Pairwise (Disjoint on fun n : \u2124 => Ioo (b ^ n) (b ^ (n + 1)))", "start": [220, 1], "end": [223, 64], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioc_add_int_cast", "code": "theorem pairwise_disjoint_Ioc_add_int_cast :\n    Pairwise (Disjoint on fun n : \u2124 => Ioc (a + n) (a + n + 1))", "start": [233, 1], "end": [236, 46], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ico_add_int_cast", "code": "theorem pairwise_disjoint_Ico_add_int_cast :\n    Pairwise (Disjoint on fun n : \u2124 => Ico (a + n) (a + n + 1))", "start": [239, 1], "end": [242, 46], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioo_add_int_cast", "code": "theorem pairwise_disjoint_Ioo_add_int_cast :\n    Pairwise (Disjoint on fun n : \u2124 => Ioo (a + n) (a + n + 1))", "start": [245, 1], "end": [248, 46], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ico_int_cast", "code": "theorem pairwise_disjoint_Ico_int_cast : Pairwise (Disjoint on fun n : \u2124 => Ico (n : \u03b1) (n + 1))", "start": [253, 1], "end": [254, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioo_int_cast", "code": "theorem pairwise_disjoint_Ioo_int_cast : Pairwise (Disjoint on fun n : \u2124 => Ioo (n : \u03b1) (n + 1))", "start": [257, 1], "end": [258, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pairwise_disjoint_Ioc_int_cast", "code": "theorem pairwise_disjoint_Ioc_int_cast : Pairwise (Disjoint on fun n : \u2124 => Ioc (n : \u03b1) (n + 1))", "start": [261, 1], "end": [262, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/EuclideanDomain/Defs.lean", "imports": ["Mathlib/Algebra/Divisibility/Basic.lean", "Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EuclideanDomain", "code": "class EuclideanDomain (R : Type u) extends CommRing R, Nontrivial R where\n  \n  protected quotient : R \u2192 R \u2192 R\n  \n  protected quotient_zero : \u2200 a, quotient a 0 = 0\n  \n  protected remainder : R \u2192 R \u2192 R\n  \n  protected quotient_mul_add_remainder_eq : \u2200 a b, b * quotient a b + remainder a b = a\n  \n  protected r : R \u2192 R \u2192 Prop\n  \n  r_wellFounded : WellFounded r\n  \n  protected remainder_lt : \u2200 (a) {b}, b \u2260 0 \u2192 r (remainder a b) b\n  \n  mul_left_not_lt : \u2200 (a) {b}, b \u2260 0 \u2192 \u00acr (a * b) a", "start": [68, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.wellFoundedRelation", "code": "local instance wellFoundedRelation : WellFoundedRelation R where\n  wf := r_wellFounded", "start": [112, 1], "end": [113, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_add_mod", "code": "theorem div_add_mod (a b : R) : b * (a / b) + a % b = a", "start": [123, 1], "end": [124, 52], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_add_div", "code": "theorem mod_add_div (a b : R) : a % b + b * (a / b) = a", "start": [127, 1], "end": [128, 41], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_add_div'", "code": "theorem mod_add_div' (m k : R) : m % k + m / k * k = m", "start": [131, 1], "end": [133, 24], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_add_mod'", "code": "theorem div_add_mod' (m k : R) : m / k * k + m % k = m", "start": [136, 1], "end": [138, 24], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_eq_sub_mul_div", "code": "theorem mod_eq_sub_mul_div {R : Type*} [EuclideanDomain R] (a b : R) : a % b = a - b * (a / b)", "start": [141, 1], "end": [144, 47], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_lt", "code": "theorem mod_lt : \u2200 (a) {b : R}, b \u2260 0 \u2192 a % b \u227a b", "start": [147, 1], "end": [148, 31], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mul_right_not_lt", "code": "theorem mul_right_not_lt {a : R} (b) (h : a \u2260 0) : \u00aca * b \u227a b", "start": [151, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.mod_zero", "code": "@[simp]\ntheorem mod_zero (a : R) : a % 0 = a", "start": [156, 1], "end": [157, 97], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lt_one", "code": "theorem lt_one (a : R) : a \u227a (1 : R) \u2192 a = 0", "start": [160, 1], "end": [162, 75], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.val_dvd_le", "code": "theorem val_dvd_le : \u2200 a b : R, b \u2223 a \u2192 a \u2260 0 \u2192 \u00aca \u227a b", "start": [165, 1], "end": [166, 86], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.div_zero", "code": "@[simp]\ntheorem div_zero (a : R) : a / 0 = 0", "start": [169, 1], "end": [171, 34], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.GCD.induction", "code": "@[elab_as_elim]\ntheorem GCD.induction {P : R \u2192 R \u2192 Prop} (a b : R) (H0 : \u2200 x, P 0 x)\n    (H1 : \u2200 a b, a \u2260 0 \u2192 P (b % a) a \u2192 P a b) : P a b", "start": [178, 1], "end": [189, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd", "code": "def gcd (a b : R) : R :=\n  if a0 : a = 0 then b\n  else\n    have _ := mod_lt b a0\n    gcd (b % a) a\ntermination_by _ => a", "start": [198, 1], "end": [205, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcd_zero_left", "code": "@[simp]\ntheorem gcd_zero_left (a : R) : gcd 0 a = a", "start": [208, 1], "end": [211, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcdAux", "code": "def xgcdAux (r s t r' s' t' : R) : R \u00d7 R \u00d7 R :=\n  if _hr : r = 0 then (r', s', t')\n  else\n    let q := r' / r\n    have _ := mod_lt r' _hr\n    xgcdAux (r' % r) (s' - q * s) (t' - q * t) r s t\ntermination_by _ => r", "start": [214, 1], "end": [229, 22], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcd_zero_left", "code": "@[simp]\ntheorem xgcd_zero_left {s t r' s' t' : R} : xgcdAux 0 s t r' s' t' = (r', s', t')", "start": [232, 1], "end": [235, 19], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcdAux_rec", "code": "theorem xgcdAux_rec {r s t r' s' t' : R} (h : r \u2260 0) :\n    xgcdAux r s t r' s' t' = xgcdAux (r' % r) (s' - r' / r * s) (t' - r' / r * t) r s t", "start": [238, 1], "end": [243, 17], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcd", "code": "def xgcd (x y : R) : R \u00d7 R :=\n  (xgcdAux x 1 0 y 0 1).2", "start": [246, 1], "end": [249, 26], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcdA", "code": "def gcdA (x y : R) : R :=\n  (xgcd x y).1", "start": [252, 1], "end": [254, 15], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcdB", "code": "def gcdB (x y : R) : R :=\n  (xgcd x y).2", "start": [257, 1], "end": [259, 15], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcdA_zero_left", "code": "@[simp]\ntheorem gcdA_zero_left {s : R} : gcdA 0 s = 0", "start": [262, 1], "end": [265, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.gcdB_zero_left", "code": "@[simp]\ntheorem gcdB_zero_left {s : R} : gcdB 0 s = 1", "start": [268, 1], "end": [271, 28], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.xgcd_val", "code": "theorem xgcd_val (x y : R) : xgcd x y = (gcdA x y, gcdB x y)", "start": [274, 1], "end": [275, 6], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.lcm", "code": "def lcm (x y : R) : R :=\n  x * y / gcd x y", "start": [284, 1], "end": [287, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/Power.lean", "imports": ["Mathlib/Algebra/Parity.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "Mathlib/Data/Int/Bitwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Algebra/GroupWithZero/Power.lean"], "premises": [{"full_name": "zpow_le_of_le", "code": "theorem zpow_le_of_le (ha : 1 \u2264 a) (h : m \u2264 n) : a ^ m \u2264 a ^ n", "start": [30, 1], "end": [37, 86], "kind": "commanddeclaration"}, {"full_name": "zpow_le_one_of_nonpos", "code": "theorem zpow_le_one_of_nonpos (ha : 1 \u2264 a) (hn : n \u2264 0) : a ^ n \u2264 1", "start": [40, 1], "end": [41, 48], "kind": "commanddeclaration"}, {"full_name": "one_le_zpow_of_nonneg", "code": "theorem one_le_zpow_of_nonneg (ha : 1 \u2264 a) (hn : 0 \u2264 n) : 1 \u2264 a ^ n", "start": [44, 1], "end": [45, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.zpow_pos_of_pos", "code": "protected theorem Nat.zpow_pos_of_pos {a : \u2115} (h : 0 < a) (n : \u2124) : 0 < (a : \u03b1) ^ n", "start": [48, 1], "end": [50, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.zpow_ne_zero_of_pos", "code": "theorem Nat.zpow_ne_zero_of_pos {a : \u2115} (h : 0 < a) (n : \u2124) : (a : \u03b1) ^ n \u2260 0", "start": [53, 1], "end": [54, 32], "kind": "commanddeclaration"}, {"full_name": "one_lt_zpow", "code": "theorem one_lt_zpow (ha : 1 < a) : \u2200 n : \u2124, 0 < n \u2192 1 < a ^ n", "start": [57, 1], "end": [59, 53], "kind": "commanddeclaration"}, {"full_name": "zpow_strictMono", "code": "theorem zpow_strictMono (hx : 1 < a) : StrictMono ((\u00b7 ^ \u00b7) a : \u2124 \u2192 \u03b1)", "start": [62, 1], "end": [67, 57], "kind": "commanddeclaration"}, {"full_name": "zpow_strictAnti", "code": "theorem zpow_strictAnti (h\u2080 : 0 < a) (h\u2081 : a < 1) : StrictAnti ((\u00b7 ^ \u00b7) a : \u2124 \u2192 \u03b1)", "start": [70, 1], "end": [75, 29], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_iff_lt", "code": "@[simp]\ntheorem zpow_lt_iff_lt (hx : 1 < a) : a ^ m < a ^ n \u2194 m < n", "start": [78, 1], "end": [80, 33], "kind": "commanddeclaration"}, {"full_name": "zpow_le_iff_le", "code": "@[simp]\ntheorem zpow_le_iff_le (hx : 1 < a) : a ^ m \u2264 a ^ n \u2194 m \u2264 n", "start": [83, 1], "end": [85, 33], "kind": "commanddeclaration"}, {"full_name": "div_pow_le", "code": "@[simp]\ntheorem div_pow_le (ha : 0 \u2264 a) (hb : 1 \u2264 b) (k : \u2115) : a / b ^ k \u2264 a", "start": [88, 1], "end": [90, 46], "kind": "commanddeclaration"}, {"full_name": "zpow_injective", "code": "theorem zpow_injective (h\u2080 : 0 < a) (h\u2081 : a \u2260 1) : Injective ((\u00b7 ^ \u00b7) a : \u2124 \u2192 \u03b1)", "start": [93, 1], "end": [96, 40], "kind": "commanddeclaration"}, {"full_name": "zpow_inj", "code": "@[simp]\ntheorem zpow_inj (h\u2080 : 0 < a) (h\u2081 : a \u2260 1) : a ^ m = a ^ n \u2194 m = n", "start": [99, 1], "end": [101, 32], "kind": "commanddeclaration"}, {"full_name": "zpow_le_max_of_min_le", "code": "theorem zpow_le_max_of_min_le {x : \u03b1} (hx : 1 \u2264 x) {a b c : \u2124} (h : min a b \u2264 c) :\n    x ^ (-c) \u2264 max (x ^ (-a)) (x ^ (-b))", "start": [104, 1], "end": [107, 33], "kind": "commanddeclaration"}, {"full_name": "zpow_le_max_iff_min_le", "code": "theorem zpow_le_max_iff_min_le {x : \u03b1} (hx : 1 < x) {a b c : \u2124} :\n    x ^ (-c) \u2264 max (x ^ (-a)) (x ^ (-b)) \u2194 min a b \u2264 c", "start": [110, 1], "end": [112, 70], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0_nonneg", "code": "theorem zpow_bit0_nonneg (a : \u03b1) (n : \u2124) : 0 \u2264 a ^ bit0 n", "start": [127, 1], "end": [128, 55], "kind": "commanddeclaration"}, {"full_name": "zpow_two_nonneg", "code": "theorem zpow_two_nonneg (a : \u03b1) : 0 \u2264 a ^ (2 : \u2124)", "start": [131, 1], "end": [132, 31], "kind": "commanddeclaration"}, {"full_name": "zpow_neg_two_nonneg", "code": "theorem zpow_neg_two_nonneg (a : \u03b1) : 0 \u2264 a ^ (-2 : \u2124)", "start": [135, 1], "end": [136, 26], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0_pos", "code": "theorem zpow_bit0_pos (h : a \u2260 0) (n : \u2124) : 0 < a ^ bit0 n", "start": [139, 1], "end": [140, 58], "kind": "commanddeclaration"}, {"full_name": "zpow_two_pos_of_ne_zero", "code": "theorem zpow_two_pos_of_ne_zero (h : a \u2260 0) : 0 < a ^ (2 : \u2124)", "start": [143, 1], "end": [144, 28], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0_pos_iff", "code": "@[simp]\ntheorem zpow_bit0_pos_iff (hn : n \u2260 0) : 0 < a ^ bit0 n \u2194 a \u2260 0", "start": [147, 1], "end": [153, 31], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1_neg_iff", "code": "@[simp]\ntheorem zpow_bit1_neg_iff : a ^ bit1 n < 0 \u2194 a < 0", "start": [156, 1], "end": [159, 89], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1_nonneg_iff", "code": "@[simp]\ntheorem zpow_bit1_nonneg_iff : 0 \u2264 a ^ bit1 n \u2194 0 \u2264 a", "start": [162, 1], "end": [164, 46], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1_nonpos_iff", "code": "@[simp]\ntheorem zpow_bit1_nonpos_iff : a ^ bit1 n \u2264 0 \u2194 a \u2264 0", "start": [167, 1], "end": [169, 98], "kind": "commanddeclaration"}, {"full_name": "zpow_bit1_pos_iff", "code": "@[simp]\ntheorem zpow_bit1_pos_iff : 0 < a ^ bit1 n \u2194 0 < a", "start": [172, 1], "end": [174, 46], "kind": "commanddeclaration"}, {"full_name": "Even.zpow_nonneg", "code": "protected theorem Even.zpow_nonneg (hn : Even n) (a : \u03b1) : 0 \u2264 a ^ n", "start": [179, 1], "end": [180, 52], "kind": "commanddeclaration"}, {"full_name": "Even.zpow_pos_iff", "code": "theorem Even.zpow_pos_iff (hn : Even n) (h : n \u2260 0) : 0 < a ^ n \u2194 a \u2260 0", "start": [183, 1], "end": [184, 76], "kind": "commanddeclaration"}, {"full_name": "Odd.zpow_neg_iff", "code": "theorem Odd.zpow_neg_iff (hn : Odd n) : a ^ n < 0 \u2194 a < 0", "start": [187, 1], "end": [188, 72], "kind": "commanddeclaration"}, {"full_name": "Odd.zpow_nonneg_iff", "code": "protected theorem Odd.zpow_nonneg_iff (hn : Odd n) : 0 \u2264 a ^ n \u2194 0 \u2264 a", "start": [191, 1], "end": [192, 75], "kind": "commanddeclaration"}, {"full_name": "Odd.zpow_nonpos_iff", "code": "theorem Odd.zpow_nonpos_iff (hn : Odd n) : a ^ n \u2264 0 \u2194 a \u2264 0", "start": [195, 1], "end": [196, 75], "kind": "commanddeclaration"}, {"full_name": "Odd.zpow_pos_iff", "code": "theorem Odd.zpow_pos_iff (hn : Odd n) : 0 < a ^ n \u2194 0 < a", "start": [199, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "Even.zpow_pos", "code": "alias \u27e8_, Even.zpow_pos\u27e9 := Even.zpow_pos_iff", "start": [203, 1], "end": [203, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Odd.zpow_neg", "code": "alias \u27e8_, Odd.zpow_neg\u27e9 := Odd.zpow_neg_iff", "start": [206, 1], "end": [206, 44], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Odd.zpow_nonpos", "code": "alias \u27e8_, Odd.zpow_nonpos\u27e9 := Odd.zpow_nonpos_iff", "start": [209, 1], "end": [209, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Even.zpow_abs", "code": "theorem Even.zpow_abs {p : \u2124} (hp : Even p) (a : \u03b1) : |a| ^ p = a ^ p", "start": [212, 1], "end": [213, 64], "kind": "commanddeclaration"}, {"full_name": "zpow_bit0_abs", "code": "@[simp]\ntheorem zpow_bit0_abs (a : \u03b1) (p : \u2124) : |a| ^ bit0 p = a ^ bit0 p", "start": [217, 1], "end": [219, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_le_pow_sub_div_sub", "code": "theorem Nat.cast_le_pow_sub_div_sub (H : 1 < a) (n : \u2115) : (n : \u03b1) \u2264 (a ^ n - 1) / (a - 1)", "start": [225, 1], "end": [228, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_le_pow_div_sub", "code": "theorem Nat.cast_le_pow_div_sub (H : 1 < a) (n : \u2115) : (n : \u03b1) \u2264 a ^ n / (a - 1)", "start": [231, 1], "end": [235, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/ModEq.lean", "imports": ["Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Data/Int/GCD.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Int/Order/Lemmas.lean", "Mathlib/Tactic/NormNum.lean"], "premises": [{"full_name": "Nat.ModEq", "code": "def ModEq (n a b : \u2115) :=\n  a % n = b % n", "start": [32, 1], "end": [34, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.refl", "code": "@[refl]\nprotected theorem refl (a : \u2115) : a \u2261 a [MOD n]", "start": [47, 1], "end": [48, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.rfl", "code": "protected theorem rfl : a \u2261 a [MOD n]", "start": [51, 1], "end": [52, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.symm", "code": "@[symm]\nprotected theorem symm : a \u2261 b [MOD n] \u2192 b \u2261 a [MOD n]", "start": [58, 1], "end": [60, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.trans", "code": "@[trans]\nprotected theorem trans : a \u2261 b [MOD n] \u2192 b \u2261 c [MOD n] \u2192 a \u2261 c [MOD n]", "start": [63, 1], "end": [65, 11], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.comm", "code": "protected theorem comm : a \u2261 b [MOD n] \u2194 b \u2261 a [MOD n]", "start": [71, 1], "end": [72, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_zero_iff_dvd", "code": "theorem modEq_zero_iff_dvd : a \u2261 0 [MOD n] \u2194 n \u2223 a", "start": [77, 1], "end": [77, 99], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.modEq_zero_nat", "code": "theorem _root_.Dvd.dvd.modEq_zero_nat (h : n \u2223 a) : a \u2261 0 [MOD n]", "start": [80, 1], "end": [81, 25], "kind": "commanddeclaration"}, {"full_name": "Dvd.dvd.zero_modEq_nat", "code": "theorem _root_.Dvd.dvd.zero_modEq_nat (h : n \u2223 a) : 0 \u2261 a [MOD n]", "start": [84, 1], "end": [85, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_iff_dvd", "code": "theorem modEq_iff_dvd : a \u2261 b [MOD n] \u2194 (n : \u2124) \u2223 b - a", "start": [88, 1], "end": [90, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.dvd", "code": "alias \u27e8ModEq.dvd, modEq_of_dvd\u27e9 := modEq_iff_dvd", "start": [93, 1], "end": [93, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.modEq_of_dvd", "code": "alias \u27e8ModEq.dvd, modEq_of_dvd\u27e9 := modEq_iff_dvd", "start": [93, 1], "end": [93, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.modEq_iff_dvd'", "code": "theorem modEq_iff_dvd' (h : a \u2264 b) : a \u2261 b [MOD n] \u2194 n \u2223 b - a", "start": [97, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_modEq", "code": "theorem mod_modEq (a n) : a % n \u2261 a [MOD n]", "start": [102, 1], "end": [103, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.of_dvd", "code": "lemma of_dvd (d : m \u2223 n) (h : a \u2261 b [MOD n]) : a \u2261 b [MOD m] := modEq_of_dvd $ d.natCast.trans h.dvd", "start": [108, 1], "end": [108, 101], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.mul_left'", "code": "protected theorem mul_left' (c : \u2115) (h : a \u2261 b [MOD n]) : c * a \u2261 c * b [MOD c * n]", "start": [111, 1], "end": [112, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_left", "code": "@[gcongr]\nprotected theorem mul_left (c : \u2115) (h : a \u2261 b [MOD n]) : c * a \u2261 c * b [MOD n]", "start": [115, 1], "end": [117, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_right'", "code": "protected theorem mul_right' (c : \u2115) (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n * c]", "start": [120, 1], "end": [121, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_right", "code": "@[gcongr]\nprotected theorem mul_right (c : \u2115) (h : a \u2261 b [MOD n]) : a * c \u2261 b * c [MOD n]", "start": [124, 1], "end": [126, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul", "code": "@[gcongr]\nprotected theorem mul (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) : a * c \u2261 b * d [MOD n]", "start": [129, 1], "end": [131, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.pow", "code": "@[gcongr]\nprotected theorem pow (m : \u2115) (h : a \u2261 b [MOD n]) : a ^ m \u2261 b ^ m [MOD n]", "start": [134, 1], "end": [140, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add", "code": "@[gcongr]\nprotected theorem add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) : a + c \u2261 b + d [MOD n]", "start": [143, 1], "end": [146, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_left", "code": "@[gcongr]\nprotected theorem add_left (c : \u2115) (h : a \u2261 b [MOD n]) : c + a \u2261 c + b [MOD n]", "start": [149, 1], "end": [151, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_right", "code": "@[gcongr]\nprotected theorem add_right (c : \u2115) (h : a \u2261 b [MOD n]) : a + c \u2261 b + c [MOD n]", "start": [154, 1], "end": [156, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_left_cancel", "code": "protected theorem add_left_cancel (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : a + c \u2261 b + d [MOD n]) :\n    c \u2261 d [MOD n]", "start": [159, 1], "end": [164, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_left_cancel'", "code": "protected theorem add_left_cancel' (c : \u2115) (h : c + a \u2261 c + b [MOD n]) : a \u2261 b [MOD n]", "start": [167, 1], "end": [168, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_right_cancel", "code": "protected theorem add_right_cancel (h\u2081 : c \u2261 d [MOD n]) (h\u2082 : a + c \u2261 b + d [MOD n]) :\n    a \u2261 b [MOD n]", "start": [171, 1], "end": [174, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_right_cancel'", "code": "protected theorem add_right_cancel' (c : \u2115) (h : a + c \u2261 b + c [MOD n]) : a \u2261 b [MOD n]", "start": [177, 1], "end": [178, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_left_cancel'", "code": "protected theorem mul_left_cancel' {a b c m : \u2115} (hc : c \u2260 0) :\n    c * a \u2261 c * b [MOD c * m] \u2192 a \u2261 b [MOD m]", "start": [181, 1], "end": [186, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_left_cancel_iff'", "code": "protected theorem mul_left_cancel_iff' {a b c m : \u2115} (hc : c \u2260 0) :\n    c * a \u2261 c * b [MOD c * m] \u2194 a \u2261 b [MOD m]", "start": [189, 1], "end": [191, 49], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_right_cancel'", "code": "protected theorem mul_right_cancel' {a b c m : \u2115} (hc : c \u2260 0) :\n    a * c \u2261 b * c [MOD m * c] \u2192 a \u2261 b [MOD m]", "start": [194, 1], "end": [199, 86], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.mul_right_cancel_iff'", "code": "protected theorem mul_right_cancel_iff' {a b c m : \u2115} (hc : c \u2260 0) :\n    a * c \u2261 b * c [MOD m * c] \u2194 a \u2261 b [MOD m]", "start": [202, 1], "end": [204, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.of_mul_left", "code": "lemma of_mul_left (m : \u2115) (h : a \u2261 b [MOD m * n]) : a \u2261 b [MOD n] := by\n  rw [modEq_iff_dvd] at *\n  exact (dvd_mul_left (n : \u2124) (m : \u2124)).trans h", "start": [207, 1], "end": [212, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.of_mul_right", "code": "lemma of_mul_right (m : \u2115) : a \u2261 b [MOD n * m] \u2192 a \u2261 b [MOD n] := mul_comm m n \u25b8 of_mul_left _", "start": [215, 1], "end": [218, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.of_div", "code": "theorem of_div (h : a / c \u2261 b / c [MOD m / c]) (ha : c \u2223 a) (ha : c \u2223 b) (ha : c \u2223 m) :\n    a \u2261 b [MOD m]", "start": [221, 1], "end": [222, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_sub", "code": "lemma modEq_sub (h : b \u2264 a) : a \u2261 b [MOD a - b] := (modEq_of_dvd $ by rw [Int.ofNat_sub h]).symm", "start": [227, 1], "end": [227, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.modEq_one", "code": "lemma modEq_one : a \u2261 b [MOD 1] := modEq_of_dvd $ one_dvd _", "start": [230, 1], "end": [230, 60], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.modEq_zero_iff", "code": "@[simp] lemma modEq_zero_iff : a \u2261 b [MOD 0] \u2194 a = b := by rw [ModEq, mod_zero, mod_zero]", "start": [233, 1], "end": [233, 90], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.add_modEq_left", "code": "@[simp] lemma add_modEq_left : n + a \u2261 a [MOD n] := by rw [ModEq, add_mod_left]", "start": [236, 1], "end": [236, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.add_modEq_right", "code": "@[simp] lemma add_modEq_right : a + n \u2261 a [MOD n] := by rw [ModEq, add_mod_right]", "start": [239, 1], "end": [239, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.le_of_lt_add", "code": "theorem le_of_lt_add (h1 : a \u2261 b [MOD m]) (h2 : a < b + m) : a \u2264 b", "start": [244, 1], "end": [247, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.add_le_of_lt", "code": "theorem add_le_of_lt (h1 : a \u2261 b [MOD m]) (h2 : a < b) : a + m \u2264 b", "start": [250, 1], "end": [251, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.dvd_iff", "code": "theorem dvd_iff (h : a \u2261 b [MOD m]) (hdm : d \u2223 m) : d \u2223 a \u2194 d \u2223 b", "start": [254, 1], "end": [257, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.gcd_eq", "code": "theorem gcd_eq (h : a \u2261 b [MOD m]) : gcd a m = gcd b m", "start": [260, 1], "end": [265, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.ModEq.eq_of_abs_lt", "code": "lemma eq_of_abs_lt (h : a \u2261 b [MOD m]) (h2 : |(b : \u2124) - a| < m) : a = b := by\n  apply Int.ofNat.inj\n  rw [eq_comm, \u2190 sub_eq_zero]\n  exact Int.eq_zero_of_abs_lt_dvd h.dvd h2", "start": [268, 1], "end": [271, 43], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.eq_of_lt_of_lt", "code": "lemma eq_of_lt_of_lt (h : a \u2261 b [MOD m]) (ha : a < m) (hb : b < m) : a = b :=\n  h.eq_of_abs_lt $ abs_sub_lt_iff.2\n    \u27e8(sub_le_self _ $ Int.coe_nat_nonneg _).trans_lt $ Int.ofNat_lt.2 hb,\n    (sub_le_self _ $ Int.coe_nat_nonneg _).trans_lt $ Int.ofNat_lt.2 ha\u27e9", "start": [274, 1], "end": [277, 73], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_left_div_gcd", "code": "lemma cancel_left_div_gcd (hm : 0 < m) (h : c * a \u2261 c * b [MOD m]) :  a \u2261 b [MOD m / gcd m c] := by\n  let d := gcd m c\n  have hmd := gcd_dvd_left m c\n  have hcd := gcd_dvd_right m c\n  rw [modEq_iff_dvd]\n  refine' @Int.dvd_of_dvd_mul_right_of_gcd_one (m / d) (c / d) (b - a) _ _\n  show (m / d : \u2124) \u2223 c / d * (b - a)\n  \u00b7 rw [mul_comm, \u2190 Int.mul_ediv_assoc (b - a) (Int.coe_nat_dvd.mpr hcd), mul_comm]\n    apply Int.ediv_dvd_ediv (Int.coe_nat_dvd.mpr hmd)\n    rw [mul_sub]\n    exact modEq_iff_dvd.mp h\n  show Int.gcd (m / d) (c / d) = 1\n  \u00b7 simp only [\u2190 Int.coe_nat_div, Int.coe_nat_gcd (m / d) (c / d), gcd_div hmd hcd,\n      Nat.div_self (gcd_pos_of_pos_left c hm)]", "start": [280, 1], "end": [294, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_right_div_gcd", "code": "lemma cancel_right_div_gcd (hm : 0 < m) (h : a * c \u2261 b * c [MOD m]) : a \u2261 b [MOD m / gcd m c] := by\n  apply cancel_left_div_gcd hm\n  simpa [mul_comm] using h", "start": [297, 1], "end": [300, 27], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_left_div_gcd'", "code": "lemma cancel_left_div_gcd' (hm : 0 < m) (hcd : c \u2261 d [MOD m]) (h : c * a \u2261 d * b [MOD m]) :\n    a \u2261 b [MOD m / gcd m c] :=\n  (h.trans $ hcd.symm.mul_right b).cancel_left_div_gcd hm", "start": [303, 1], "end": [305, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_right_div_gcd'", "code": "lemma cancel_right_div_gcd' (hm : 0 < m) (hcd : c \u2261 d [MOD m]) (h : a * c \u2261 b * d [MOD m]) :\n    a \u2261 b [MOD m / gcd m c] :=\n  (h.trans $ hcd.symm.mul_left b).cancel_right_div_gcd hm", "start": [308, 1], "end": [310, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_left_of_coprime", "code": "lemma cancel_left_of_coprime (hmc : gcd m c = 1) (h : c * a \u2261 c * b [MOD m]) : a \u2261 b [MOD m] := by\n  rcases m.eq_zero_or_pos with (rfl | hm)\n  \u00b7 simp only [gcd_zero_left] at hmc\n    simp only [gcd_zero_left, hmc, one_mul, modEq_zero_iff] at h\n    subst h\n    rfl\n  simpa [hmc] using h.cancel_left_div_gcd hm", "start": [313, 1], "end": [320, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.ModEq.cancel_right_of_coprime", "code": "lemma cancel_right_of_coprime (hmc : gcd m c = 1) (h : a * c \u2261 b * c [MOD m]) : a \u2261 b [MOD m] :=\n  cancel_left_of_coprime hmc $ by simpa [mul_comm] using h", "start": [323, 1], "end": [325, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Nat.chineseRemainder'", "code": "def chineseRemainder' (h : a \u2261 b [MOD gcd n m]) : { k // k \u2261 a [MOD n] \u2227 k \u2261 b [MOD m] } :=\n  if hn : n = 0 then \u27e8a, by rw [hn, gcd_zero_left] at h; constructor; rfl; exact h\u27e9\n  else\n    if hm : m = 0 then \u27e8b, by rw [hm, gcd_zero_right] at h; constructor; exact h.symm; rfl\u27e9\n    else\n      \u27e8let (c, d) := xgcd n m; Int.toNat ((n * c * b + m * d * a) / gcd n m % lcm n m), by\n        rw [xgcd_val]\n        dsimp\n        rw [modEq_iff_dvd, modEq_iff_dvd,\n          Int.toNat_of_nonneg (Int.emod_nonneg _ (Int.coe_nat_ne_zero.2 (lcm_ne_zero hn hm)))]\n        have hnonzero : (gcd n m : \u2124) \u2260 0 := by\n          norm_cast\n          rw [Nat.gcd_eq_zero_iff, not_and]\n          exact fun _ => hm\n        have hcoedvd : \u2200 t, (gcd n m : \u2124) \u2223 t * (b - a) := fun t => h.dvd.mul_left _\n        have := gcd_eq_gcd_ab n m\n        constructor <;> rw [Int.emod_def, \u2190 sub_add] <;>\n            refine' dvd_add _ (dvd_mul_of_dvd_left _ _) <;>\n          try norm_cast\n        \u00b7 rw [\u2190 sub_eq_iff_eq_add'] at this\n          rw [\u2190 this, sub_mul, \u2190 add_sub_assoc, add_comm, add_sub_assoc, \u2190 mul_sub,\n            Int.add_ediv_of_dvd_left, Int.mul_ediv_cancel_left _ hnonzero,\n            Int.mul_ediv_assoc _ h.dvd, \u2190 sub_sub, sub_self, zero_sub, dvd_neg, mul_assoc]\n          exact dvd_mul_right _ _\n          norm_cast\n          exact dvd_mul_right _ _\n        \u00b7 exact dvd_lcm_left n m\n        \u00b7 rw [\u2190 sub_eq_iff_eq_add] at this\n          rw [\u2190 this, sub_mul, sub_add, \u2190 mul_sub, Int.sub_ediv_of_dvd,\n            Int.mul_ediv_cancel_left _ hnonzero, Int.mul_ediv_assoc _ h.dvd, \u2190 sub_add, sub_self,\n            zero_add, mul_assoc]\n          exact dvd_mul_right _ _\n          exact hcoedvd _\n        \u00b7 exact dvd_lcm_right n m\u27e9", "start": [330, 1], "end": [364, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.chineseRemainder", "code": "def chineseRemainder (co : n.Coprime m) (a b : \u2115) : { k // k \u2261 a [MOD n] \u2227 k \u2261 b [MOD m] } :=\n  chineseRemainder' (by convert @modEq_one a b)", "start": [367, 1], "end": [369, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.chineseRemainder'_lt_lcm", "code": "theorem chineseRemainder'_lt_lcm (h : a \u2261 b [MOD gcd n m]) (hn : n \u2260 0) (hm : m \u2260 0) :\n    \u2191(chineseRemainder' h) < lcm n m", "start": [372, 1], "end": [377, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.chineseRemainder_lt_mul", "code": "theorem chineseRemainder_lt_mul (co : n.Coprime m) (a b : \u2115) (hn : n \u2260 0) (hm : m \u2260 0) :\n    \u2191(chineseRemainder co a b) < n * m", "start": [380, 1], "end": [382, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.modEq_and_modEq_iff_modEq_mul", "code": "theorem modEq_and_modEq_iff_modEq_mul {a b m n : \u2115} (hmn : m.Coprime n) :\n    a \u2261 b [MOD m] \u2227 a \u2261 b [MOD n] \u2194 a \u2261 b [MOD m * n]", "start": [385, 1], "end": [392, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_mul_modEq_one", "code": "theorem coprime_of_mul_modEq_one (b : \u2115) {a n : \u2115} (h : a * b \u2261 1 [MOD n]) : a.Coprime n", "start": [395, 1], "end": [401, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mul_right_mod", "code": "@[simp 1100]\ntheorem mod_mul_right_mod (a b c : \u2115) : a % (b * c) % b = a % b", "start": [404, 1], "end": [406, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_mul_left_mod", "code": "@[simp 1100]\ntheorem mod_mul_left_mod (a b c : \u2115) : a % (b * c) % c = a % c", "start": [409, 1], "end": [411, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.div_mod_eq_mod_mul_div", "code": "theorem div_mod_eq_mod_mul_div (a b c : \u2115) : a / b % c = a % (b * c) / b", "start": [414, 1], "end": [420, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_add_ite", "code": "theorem add_mod_add_ite (a b c : \u2115) :\n    ((a + b) % c + if c \u2264 a % c + b % c then c else 0) = a % c + b % c", "start": [423, 1], "end": [440, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_of_add_mod_lt", "code": "theorem add_mod_of_add_mod_lt {a b c : \u2115} (hc : a % c + b % c < c) : (a + b) % c = a % c + b % c", "start": [443, 1], "end": [444, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.add_mod_add_of_le_add_mod", "code": "theorem add_mod_add_of_le_add_mod {a b c : \u2115} (hc : c \u2264 a % c + b % c) :\n    (a + b) % c + c = a % c + b % c", "start": [447, 1], "end": [448, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div", "code": "theorem add_div {a b c : \u2115} (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + if c \u2264 a % c + b % c then 1 else 0", "start": [451, 1], "end": [462, 9], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_eq_of_add_mod_lt", "code": "theorem add_div_eq_of_add_mod_lt {a b c : \u2115} (hc : a % c + b % c < c) :\n    (a + b) / c = a / c + b / c", "start": [465, 1], "end": [468, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_of_dvd_right", "code": "protected theorem add_div_of_dvd_right {a b c : \u2115} (hca : c \u2223 a) : (a + b) / c = a / c + b / c", "start": [471, 1], "end": [477, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_of_dvd_left", "code": "protected theorem add_div_of_dvd_left {a b c : \u2115} (hca : c \u2223 b) : (a + b) / c = a / c + b / c", "start": [480, 1], "end": [481, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_eq_of_le_mod_add_mod", "code": "theorem add_div_eq_of_le_mod_add_mod {a b c : \u2115} (hc : c \u2264 a % c + b % c) (hc0 : 0 < c) :\n    (a + b) / c = a / c + b / c + 1", "start": [484, 1], "end": [485, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.add_div_le_add_div", "code": "theorem add_div_le_add_div (a b c : \u2115) : a / c + b / c \u2264 (a + b) / c", "start": [488, 1], "end": [490, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.le_mod_add_mod_of_dvd_add_of_not_dvd", "code": "theorem le_mod_add_mod_of_dvd_add_of_not_dvd {a b c : \u2115} (h : c \u2223 a + b) (ha : \u00acc \u2223 a) :\n    c \u2264 a % c + b % c", "start": [493, 1], "end": [497, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_mul_odd", "code": "theorem odd_mul_odd {n m : \u2115} : n % 2 = 1 \u2192 m % 2 = 1 \u2192 n * m % 2 = 1", "start": [500, 1], "end": [501, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_mul_odd_div_two", "code": "theorem odd_mul_odd_div_two {m n : \u2115} (hm1 : m % 2 = 1) (hn1 : n % 2 = 1) :\n    m * n / 2 = m * (n / 2) + m / 2", "start": [504, 1], "end": [513, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_of_mod_four_eq_one", "code": "theorem odd_of_mod_four_eq_one {n : \u2115} : n % 4 = 1 \u2192 n % 2 = 1", "start": [516, 1], "end": [517, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_of_mod_four_eq_three", "code": "theorem odd_of_mod_four_eq_three {n : \u2115} : n % 4 = 3 \u2192 n % 2 = 1", "start": [520, 1], "end": [522, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_mod_four_iff", "code": "theorem odd_mod_four_iff {n : \u2115} : n % 2 = 1 \u2194 n % 4 = 1 \u2228 n % 4 = 3", "start": [525, 1], "end": [530, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/DenseEmbedding.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DenseInducing", "code": "structure DenseInducing [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (i : \u03b1 \u2192 \u03b2)\n    extends Inducing i : Prop where\n  \n  protected dense : DenseRange i", "start": [36, 1], "end": [41, 33], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.nhds_eq_comap", "code": "theorem nhds_eq_comap (di : DenseInducing i) : \u2200 a : \u03b1, \ud835\udcdd a = comap i (\ud835\udcdd <| i a)", "start": [50, 1], "end": [51, 30], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.continuous", "code": "protected theorem continuous (di : DenseInducing i) : Continuous i", "start": [54, 1], "end": [55, 27], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.closure_range", "code": "theorem closure_range : closure (range i) = univ", "start": [58, 1], "end": [59, 25], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.preconnectedSpace", "code": "protected theorem preconnectedSpace [PreconnectedSpace \u03b1] (di : DenseInducing i) :\n    PreconnectedSpace \u03b2", "start": [62, 1], "end": [64, 43], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.closure_image_mem_nhds", "code": "theorem closure_image_mem_nhds {s : Set \u03b1} {a : \u03b1} (di : DenseInducing i) (hs : s \u2208 \ud835\udcdd a) :\n    closure (i '' s) \u2208 \ud835\udcdd (i a)", "start": [67, 1], "end": [74, 62], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.dense_image", "code": "theorem dense_image (di : DenseInducing i) {s : Set \u03b1} : Dense (i '' s) \u2194 Dense s", "start": [77, 1], "end": [80, 10], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.interior_compact_eq_empty", "code": "theorem interior_compact_eq_empty [T2Space \u03b2] (di : DenseInducing i) (hd : Dense (range i)\u1d9c)\n    {s : Set \u03b1} (hs : IsCompact s) : interior s = \u2205", "start": [83, 1], "end": [92, 41], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.prod", "code": "protected theorem prod [TopologicalSpace \u03b3] [TopologicalSpace \u03b4] {e\u2081 : \u03b1 \u2192 \u03b2} {e\u2082 : \u03b3 \u2192 \u03b4}\n    (de\u2081 : DenseInducing e\u2081) (de\u2082 : DenseInducing e\u2082) :\n    DenseInducing fun p : \u03b1 \u00d7 \u03b3 => (e\u2081 p.1, e\u2082 p.2) where", "start": [95, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.separableSpace", "code": "protected theorem separableSpace [SeparableSpace \u03b1] : SeparableSpace \u03b2", "start": [105, 1], "end": [107, 40], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.tendsto_comap_nhds_nhds", "code": "theorem tendsto_comap_nhds_nhds {d : \u03b4} {a : \u03b1} (di : DenseInducing i)\n    (H : Tendsto h (\ud835\udcdd d) (\ud835\udcdd (i a))) (comm : h \u2218 g = i \u2218 f) : Tendsto f (comap g (\ud835\udcdd d)) (\ud835\udcdd a)", "start": [112, 1], "end": [125, 27], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.nhdsWithin_neBot", "code": "protected theorem nhdsWithin_neBot (di : DenseInducing i) (b : \u03b2) : NeBot (\ud835\udcdd[range i] b)", "start": [128, 1], "end": [129, 30], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.comap_nhds_neBot", "code": "theorem comap_nhds_neBot (di : DenseInducing i) (b : \u03b2) : NeBot (comap i (\ud835\udcdd b))", "start": [132, 1], "end": [135, 18], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend", "code": "def extend (di : DenseInducing i) (f : \u03b1 \u2192 \u03b3) (b : \u03b2) : \u03b3 :=\n  @limUnder _ _ _ \u27e8f (di.dense.some b)\u27e9 (comap i (\ud835\udcdd b)) f", "start": [140, 1], "end": [144, 58], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_eq_of_tendsto", "code": "theorem extend_eq_of_tendsto [T2Space \u03b3] {b : \u03b2} {c : \u03b3} {f : \u03b1 \u2192 \u03b3}\n    (hf : Tendsto f (comap i (\ud835\udcdd b)) (\ud835\udcdd c)) : di.extend f b = c", "start": [147, 1], "end": [150, 17], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_eq_at", "code": "theorem extend_eq_at [T2Space \u03b3] {f : \u03b1 \u2192 \u03b3} {a : \u03b1} (hf : ContinuousAt f a) :\n    di.extend f (i a) = f a", "start": [153, 1], "end": [155, 52], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_eq_at'", "code": "theorem extend_eq_at' [T2Space \u03b3] {f : \u03b1 \u2192 \u03b3} {a : \u03b1} (c : \u03b3) (hf : Tendsto f (\ud835\udcdd a) (\ud835\udcdd c)) :\n    di.extend f (i a) = f a", "start": [158, 1], "end": [160, 52], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_eq", "code": "theorem extend_eq [T2Space \u03b3] {f : \u03b1 \u2192 \u03b3} (hf : Continuous f) (a : \u03b1) : di.extend f (i a) = f a", "start": [163, 1], "end": [164, 34], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_eq'", "code": "theorem extend_eq' [T2Space \u03b3] {f : \u03b1 \u2192 \u03b3} (di : DenseInducing i)\n    (hf : \u2200 b, \u2203 c, Tendsto f (comap i (\ud835\udcdd b)) (\ud835\udcdd c)) (a : \u03b1) : di.extend f (i a) = f a", "start": [167, 1], "end": [174, 44], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_unique_at", "code": "theorem extend_unique_at [T2Space \u03b3] {b : \u03b2} {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (di : DenseInducing i)\n    (hf : \u2200\u1da0 x in comap i (\ud835\udcdd b), g (i x) = f x) (hg : ContinuousAt g b) : di.extend f b = g b", "start": [177, 1], "end": [185, 12], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_unique", "code": "theorem extend_unique [T2Space \u03b3] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b3} (di : DenseInducing i)\n    (hf : \u2200 x, g (i x) = f x) (hg : Continuous g) : di.extend f = g", "start": [188, 1], "end": [190, 80], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.continuousAt_extend", "code": "theorem continuousAt_extend [T3Space \u03b3] {b : \u03b2} {f : \u03b1 \u2192 \u03b3} (di : DenseInducing i)\n    (hf : \u2200\u1da0 x in \ud835\udcdd b, \u2203 c, Tendsto f (comap i <| \ud835\udcdd x) (\ud835\udcdd c)) : ContinuousAt (di.extend f) b", "start": [193, 1], "end": [214, 8], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.continuous_extend", "code": "theorem continuous_extend [T3Space \u03b3] {f : \u03b1 \u2192 \u03b3} (di : DenseInducing i)\n    (hf : \u2200 b, \u2203 c, Tendsto f (comap i (\ud835\udcdd b)) (\ud835\udcdd c)) : Continuous (di.extend f)", "start": [217, 1], "end": [219, 82], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.mk'", "code": "theorem mk' (i : \u03b1 \u2192 \u03b2) (c : Continuous i) (dense : \u2200 x, x \u2208 closure (range i))\n    (H : \u2200 (a : \u03b1), \u2200 s \u2208 \ud835\udcdd a, \u2203 t \u2208 \ud835\udcdd (i a), \u2200 b, i b \u2208 t \u2192 b \u2208 s) : DenseInducing i", "start": [222, 1], "end": [226, 12], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding", "code": "structure DenseEmbedding [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (e : \u03b1 \u2192 \u03b2) extends\n  DenseInducing e : Prop where\n  \n  inj : Function.Injective e", "start": [231, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.mk'", "code": "theorem DenseEmbedding.mk' [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] (e : \u03b1 \u2192 \u03b2) (c : Continuous e)\n    (dense : DenseRange e) (inj : Function.Injective e)\n    (H : \u2200 (a : \u03b1), \u2200 s \u2208 \ud835\udcdd a, \u2203 t \u2208 \ud835\udcdd (e a), \u2200 b, e b \u2208 t \u2192 b \u2208 s) : DenseEmbedding e", "start": [238, 1], "end": [241, 45], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.inj_iff", "code": "theorem inj_iff {x y} : e x = e y \u2194 x = y", "start": [252, 1], "end": [253, 16], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.to_embedding", "code": "theorem to_embedding : Embedding e", "start": [256, 1], "end": [258, 20], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.separableSpace", "code": "protected theorem separableSpace [SeparableSpace \u03b1] : SeparableSpace \u03b2", "start": [261, 1], "end": [263, 36], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.prod", "code": "protected theorem prod {e\u2081 : \u03b1 \u2192 \u03b2} {e\u2082 : \u03b3 \u2192 \u03b4} (de\u2081 : DenseEmbedding e\u2081)\n    (de\u2082 : DenseEmbedding e\u2082) : DenseEmbedding fun p : \u03b1 \u00d7 \u03b3 => (e\u2081 p.1, e\u2082 p.2)", "start": [266, 1], "end": [270, 38], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.subtypeEmb", "code": "@[simps]\ndef subtypeEmb {\u03b1 : Type*} (p : \u03b1 \u2192 Prop) (e : \u03b1 \u2192 \u03b2) (x : { x // p x }) :\n    { x // x \u2208 closure (e '' { x | p x }) } :=\n  \u27e8e x, subset_closure <| mem_image_of_mem e x.prop\u27e9", "start": [273, 1], "end": [277, 53], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.subtype", "code": "protected theorem subtype (p : \u03b1 \u2192 Prop) : DenseEmbedding (subtypeEmb p e)", "start": [280, 1], "end": [290, 21], "kind": "commanddeclaration"}, {"full_name": "DenseEmbedding.dense_image", "code": "theorem dense_image {s : Set \u03b1} : Dense (e '' s) \u2194 Dense s", "start": [293, 1], "end": [294, 33], "kind": "commanddeclaration"}, {"full_name": "denseEmbedding_id", "code": "theorem denseEmbedding_id {\u03b1 : Type*} [TopologicalSpace \u03b1] : DenseEmbedding (id : \u03b1 \u2192 \u03b1)", "start": [299, 1], "end": [300, 47], "kind": "commanddeclaration"}, {"full_name": "Dense.denseEmbedding_val", "code": "theorem Dense.denseEmbedding_val [TopologicalSpace \u03b1] {s : Set \u03b1} (hs : Dense s) :\n    DenseEmbedding ((\u2191) : s \u2192 \u03b1)", "start": [303, 1], "end": [305, 60], "kind": "commanddeclaration"}, {"full_name": "isClosed_property", "code": "theorem isClosed_property [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 Prop} (he : DenseRange e)\n    (hp : IsClosed { x | p x }) (h : \u2200 a, p (e a)) : \u2200 b, p b", "start": [308, 1], "end": [316, 24], "kind": "commanddeclaration"}, {"full_name": "isClosed_property2", "code": "theorem isClosed_property2 [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 \u03b2 \u2192 Prop} (he : DenseRange e)\n    (hp : IsClosed { q : \u03b2 \u00d7 \u03b2 | p q.1 q.2 }) (h : \u2200 a\u2081 a\u2082, p (e a\u2081) (e a\u2082)) : \u2200 b\u2081 b\u2082, p b\u2081 b\u2082", "start": [319, 1], "end": [322, 29], "kind": "commanddeclaration"}, {"full_name": "isClosed_property3", "code": "theorem isClosed_property3 [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 \u03b2 \u2192 \u03b2 \u2192 Prop}\n    (he : DenseRange e) (hp : IsClosed { q : \u03b2 \u00d7 \u03b2 \u00d7 \u03b2 | p q.1 q.2.1 q.2.2 })\n    (h : \u2200 a\u2081 a\u2082 a\u2083, p (e a\u2081) (e a\u2082) (e a\u2083)) : \u2200 b\u2081 b\u2082 b\u2083, p b\u2081 b\u2082 b\u2083", "start": [325, 1], "end": [330, 36], "kind": "commanddeclaration"}, {"full_name": "DenseRange.induction_on", "code": "@[elab_as_elim]\ntheorem DenseRange.induction_on [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} (he : DenseRange e) {p : \u03b2 \u2192 Prop}\n    (b\u2080 : \u03b2) (hp : IsClosed { b | p b }) (ih : \u2200 a : \u03b1, p <| e a) : p b\u2080", "start": [333, 1], "end": [336, 32], "kind": "commanddeclaration"}, {"full_name": "DenseRange.induction_on\u2082", "code": "@[elab_as_elim]\ntheorem DenseRange.induction_on\u2082 [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    (he : DenseRange e) (hp : IsClosed { q : \u03b2 \u00d7 \u03b2 | p q.1 q.2 }) (h : \u2200 a\u2081 a\u2082, p (e a\u2081) (e a\u2082))\n    (b\u2081 b\u2082 : \u03b2) : p b\u2081 b\u2082", "start": [339, 1], "end": [343, 33], "kind": "commanddeclaration"}, {"full_name": "DenseRange.induction_on\u2083", "code": "@[elab_as_elim]\ntheorem DenseRange.induction_on\u2083 [TopologicalSpace \u03b2] {e : \u03b1 \u2192 \u03b2} {p : \u03b2 \u2192 \u03b2 \u2192 \u03b2 \u2192 Prop}\n    (he : DenseRange e) (hp : IsClosed { q : \u03b2 \u00d7 \u03b2 \u00d7 \u03b2 | p q.1 q.2.1 q.2.2 })\n    (h : \u2200 a\u2081 a\u2082 a\u2083, p (e a\u2081) (e a\u2082) (e a\u2083)) (b\u2081 b\u2082 b\u2083 : \u03b2) : p b\u2081 b\u2082 b\u2083", "start": [346, 1], "end": [350, 35], "kind": "commanddeclaration"}, {"full_name": "DenseRange.equalizer", "code": "theorem DenseRange.equalizer (hfd : DenseRange f) {g h : \u03b2 \u2192 \u03b3} (hg : Continuous g)\n    (hh : Continuous h) (H : g \u2218 f = h \u2218 f) : g = h", "start": [359, 1], "end": [362, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.hasBasis_of_denseInducing", "code": "theorem Filter.HasBasis.hasBasis_of_denseInducing [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [T3Space \u03b2] {\u03b9 : Type*} {s : \u03b9 \u2192 Set \u03b1} {p : \u03b9 \u2192 Prop} {x : \u03b1} (h : (\ud835\udcdd x).HasBasis p s)\n    {f : \u03b1 \u2192 \u03b2} (hf : DenseInducing f) : (\ud835\udcdd (f x)).HasBasis p fun i => closure <| f '' s i", "start": [368, 1], "end": [386, 38], "kind": "commanddeclaration"}]}