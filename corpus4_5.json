{"path": "Mathlib/Topology/Support.lean", "imports": ["Mathlib/Topology/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "mulTSupport", "code": "@[to_additive \" The topological support of a function is the closure of its support. i.e. the\nclosure of the set of all elements where the function is nonzero. \"]\ndef mulTSupport (f : X \u2192 \u03b1) : Set X := closure (mulSupport f)", "start": [40, 1], "end": [44, 62], "kind": "commanddeclaration"}, {"full_name": "subset_mulTSupport", "code": "@[to_additive]\ntheorem subset_mulTSupport (f : X \u2192 \u03b1) : mulSupport f \u2286 mulTSupport f", "start": [48, 1], "end": [50, 17], "kind": "commanddeclaration"}, {"full_name": "isClosed_mulTSupport", "code": "@[to_additive]\ntheorem isClosed_mulTSupport (f : X \u2192 \u03b1) : IsClosed (mulTSupport f)", "start": [54, 1], "end": [56, 19], "kind": "commanddeclaration"}, {"full_name": "mulTSupport_eq_empty_iff", "code": "@[to_additive]\ntheorem mulTSupport_eq_empty_iff {f : X \u2192 \u03b1} : mulTSupport f = \u2205 \u2194 f = 1", "start": [60, 1], "end": [62, 63], "kind": "commanddeclaration"}, {"full_name": "image_eq_one_of_nmem_mulTSupport", "code": "@[to_additive]\ntheorem image_eq_one_of_nmem_mulTSupport {f : X \u2192 \u03b1} {x : X} (hx : x \u2209 mulTSupport f) : f x = 1", "start": [66, 1], "end": [68, 56], "kind": "commanddeclaration"}, {"full_name": "range_subset_insert_image_mulTSupport", "code": "@[to_additive]\ntheorem range_subset_insert_image_mulTSupport (f : X \u2192 \u03b1) :\n    range f \u2286 insert 1 (f '' mulTSupport f)", "start": [72, 1], "end": [76, 58], "kind": "commanddeclaration"}, {"full_name": "range_eq_image_mulTSupport_or", "code": "@[to_additive]\ntheorem range_eq_image_mulTSupport_or (f : X \u2192 \u03b1) :\n    range f = f '' mulTSupport f \u2228 range f = insert 1 (f '' mulTSupport f)", "start": [80, 1], "end": [83, 98], "kind": "commanddeclaration"}, {"full_name": "tsupport_mul_subset_left", "code": "theorem tsupport_mul_subset_left {\u03b1 : Type*} [MulZeroClass \u03b1] {f g : X \u2192 \u03b1} :\n    (tsupport fun x => f x * g x) \u2286 tsupport f", "start": [87, 1], "end": [89, 45], "kind": "commanddeclaration"}, {"full_name": "tsupport_mul_subset_right", "code": "theorem tsupport_mul_subset_right {\u03b1 : Type*} [MulZeroClass \u03b1] {f g : X \u2192 \u03b1} :\n    (tsupport fun x => f x * g x) \u2286 tsupport g", "start": [92, 1], "end": [94, 46], "kind": "commanddeclaration"}, {"full_name": "tsupport_smul_subset_left", "code": "theorem tsupport_smul_subset_left {M \u03b1} [TopologicalSpace X] [Zero M] [Zero \u03b1] [SMulWithZero M \u03b1]\n    (f : X \u2192 M) (g : X \u2192 \u03b1) : (tsupport fun x => f x \u2022 g x) \u2286 tsupport f", "start": [99, 1], "end": [101, 47], "kind": "commanddeclaration"}, {"full_name": "not_mem_mulTSupport_iff_eventuallyEq", "code": "@[to_additive]\ntheorem not_mem_mulTSupport_iff_eventuallyEq : x \u2209 mulTSupport f \u2194 f =\u1da0[\ud835\udcdd x] 1", "start": [112, 1], "end": [115, 89], "kind": "commanddeclaration"}, {"full_name": "continuous_of_mulTSupport", "code": "@[to_additive]\ntheorem continuous_of_mulTSupport [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : \u2200 x \u2208 mulTSupport f, ContinuousAt f x) : Continuous f", "start": [119, 1], "end": [123, 94], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport", "code": "@[to_additive \" A function `f` *has compact support* or is *compactly supported* if the closure of\nthe support of `f` is compact. In a T\u2082 space this is equivalent to `f` being equal to `0` outside a\ncompact set. \"]\ndef HasCompactMulSupport (f : \u03b1 \u2192 \u03b2) : Prop :=\n  IsCompact (mulTSupport f)", "start": [127, 1], "end": [134, 28], "kind": "commanddeclaration"}, {"full_name": "hasCompactMulSupport_def", "code": "@[to_additive]\ntheorem hasCompactMulSupport_def : HasCompactMulSupport f \u2194 IsCompact (closure (mulSupport f))", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "exists_compact_iff_hasCompactMulSupport", "code": "@[to_additive]\ntheorem exists_compact_iff_hasCompactMulSupport [T2Space \u03b1] :\n    (\u2203 K : Set \u03b1, IsCompact K \u2227 \u2200 x, x \u2209 K \u2192 f x = 1) \u2194 HasCompactMulSupport f", "start": [144, 1], "end": [148, 59], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.intro", "code": "@[to_additive]\ntheorem HasCompactMulSupport.intro [T2Space \u03b1] {K : Set \u03b1} (hK : IsCompact K)\n    (hfK : \u2200 x, x \u2209 K \u2192 f x = 1) : HasCompactMulSupport f", "start": [152, 1], "end": [155, 58], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.of_mulSupport_subset_isCompact", "code": "@[to_additive]\ntheorem HasCompactMulSupport.of_mulSupport_subset_isCompact [T2Space \u03b1] {K : Set \u03b1}\n    (hK : IsCompact K) (h : mulSupport f \u2286 K) : HasCompactMulSupport f", "start": [159, 1], "end": [162, 43], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.isCompact", "code": "@[to_additive]\ntheorem HasCompactMulSupport.isCompact (hf : HasCompactMulSupport f) : IsCompact (mulTSupport f)", "start": [164, 1], "end": [166, 5], "kind": "commanddeclaration"}, {"full_name": "hasCompactMulSupport_iff_eventuallyEq", "code": "@[to_additive]\ntheorem hasCompactMulSupport_iff_eventuallyEq :\n    HasCompactMulSupport f \u2194 f =\u1da0[coclosedCompact \u03b1] 1", "start": [170, 1], "end": [178, 98], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.isCompact_range", "code": "@[to_additive]\ntheorem HasCompactMulSupport.isCompact_range [TopologicalSpace \u03b2] (h : HasCompactMulSupport f)\n    (hf : Continuous f) : IsCompact (range f)", "start": [182, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.mono'", "code": "@[to_additive]\ntheorem HasCompactMulSupport.mono' {f' : \u03b1 \u2192 \u03b3} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' \u2286 mulTSupport f) : HasCompactMulSupport f'", "start": [190, 1], "end": [193, 92], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.mono", "code": "@[to_additive]\ntheorem HasCompactMulSupport.mono {f' : \u03b1 \u2192 \u03b3} (hf : HasCompactMulSupport f)\n    (hff' : mulSupport f' \u2286 mulSupport f) : HasCompactMulSupport f'", "start": [197, 1], "end": [200, 40], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.comp_left", "code": "@[to_additive]\ntheorem HasCompactMulSupport.comp_left (hf : HasCompactMulSupport f) (hg : g 1 = 1) :\n    HasCompactMulSupport (g \u2218 f)", "start": [204, 1], "end": [207, 41], "kind": "commanddeclaration"}, {"full_name": "hasCompactMulSupport_comp_left", "code": "@[to_additive]\ntheorem hasCompactMulSupport_comp_left (hg : \u2200 {x}, g x = 1 \u2194 x = 1) :\n    HasCompactMulSupport (g \u2218 f) \u2194 HasCompactMulSupport f", "start": [211, 1], "end": [214, 67], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.comp_closedEmbedding", "code": "@[to_additive]\ntheorem HasCompactMulSupport.comp_closedEmbedding (hf : HasCompactMulSupport f) {g : \u03b1' \u2192 \u03b1}\n    (hg : ClosedEmbedding g) : HasCompactMulSupport (f \u2218 g)", "start": [218, 1], "end": [224, 66], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.comp\u2082_left", "code": "@[to_additive]\ntheorem HasCompactMulSupport.comp\u2082_left (hf : HasCompactMulSupport f)\n    (hf\u2082 : HasCompactMulSupport f\u2082) (hm : m 1 1 = 1) :\n    HasCompactMulSupport fun x => m (f x) (f\u2082 x)", "start": [228, 1], "end": [233, 88], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.mul", "code": "@[to_additive]\ntheorem HasCompactMulSupport.mul (hf : HasCompactMulSupport f) (hf' : HasCompactMulSupport f') :\n    HasCompactMulSupport (f * f')", "start": [245, 1], "end": [247, 67], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.smul_left", "code": "theorem HasCompactSupport.smul_left (hf : HasCompactSupport f') : HasCompactSupport (f \u2022 f')", "start": [259, 1], "end": [261, 86], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.smul_right", "code": "theorem HasCompactSupport.smul_right (hf : HasCompactSupport f) : HasCompactSupport (f \u2022 f')", "start": [272, 1], "end": [274, 86], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.smul_left'", "code": "theorem HasCompactSupport.smul_left' (hf : HasCompactSupport f') : HasCompactSupport (f \u2022 f')", "start": [277, 1], "end": [279, 88], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.mul_right", "code": "theorem HasCompactSupport.mul_right (hf : HasCompactSupport f) : HasCompactSupport (f * f')", "start": [290, 1], "end": [292, 85], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.mul_left", "code": "theorem HasCompactSupport.mul_left (hf : HasCompactSupport f') : HasCompactSupport (f * f')", "start": [295, 1], "end": [297, 85], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_finset_nhd_mulSupport_subset", "code": "@[to_additive \" If a family of functions `f` has locally-finite support, subordinate to a family of\nopen sets, then for any point we can find a neighbourhood on which only finitely-many members of `f`\nare non-zero. \"]\ntheorem exists_finset_nhd_mulSupport_subset {f : \u03b9 \u2192 X \u2192 R}\n    (hlf : LocallyFinite fun i => mulSupport (f i)) (hso : \u2200 i, mulTSupport (f i) \u2286 U i)\n    (ho : \u2200 i, IsOpen (U i)) (x : X) :\n    \u2203 (is : Finset \u03b9), \u2203 n, n \u2208 \ud835\udcdd x \u2227 (n \u2286 \u22c2 i \u2208 is, U i) \u2227\n      \u2200 z \u2208 n, (mulSupport fun i => f i z) \u2286 is", "start": [307, 1], "end": [340, 27], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Category/Basic.lean", "imports": ["Mathlib/Combinatorics/Quiver/Basic.lean", "Mathlib/CategoryTheory/Category/Init.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/PPWithUniv.lean", "Mathlib/Tactic/Common.lean"], "premises": [{"full_name": "Std.Tactic.Ext.extCore'", "code": "def extCore' : TacticM Unit := do\n  evalTactic (\u2190 `(tactic| ext))", "start": [83, 1], "end": [85, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.CategoryStruct", "code": "@[pp_with_univ]\nclass CategoryStruct (obj : Type u) extends Quiver.{v + 1} obj : Type max u (v + 1) where\n  \n  id : \u2200 X : obj, Hom X X\n  \n  comp : \u2200 {X Y Z : obj}, (X \u27f6 Y) \u2192 (Y \u27f6 Z) \u2192 (X \u27f6 Z)", "start": [93, 1], "end": [100, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Category", "code": "@[pp_with_univ]\nclass Category (obj : Type u) extends CategoryStruct.{v} obj : Type max u (v + 1) where\n  \n  id_comp : \u2200 {X Y : obj} (f : X \u27f6 Y), \ud835\udfd9 X \u226b f = f := by aesop_cat\n  \n  comp_id : \u2200 {X Y : obj} (f : X \u27f6 Y), f \u226b \ud835\udfd9 Y = f := by aesop_cat\n  \n  assoc : \u2200 {W X Y Z : obj} (f : W \u27f6 X) (g : X \u27f6 Y) (h : Y \u27f6 Z), (f \u226b g) \u226b h = f \u226b g \u226b h :=\n    by aesop_cat", "start": [146, 1], "end": [160, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.LargeCategory", "code": "abbrev LargeCategory (C : Type (u + 1)) : Type (u + 1) := Category.{u} C", "start": [176, 1], "end": [180, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.SmallCategory", "code": "abbrev SmallCategory (C : Type u) : Type (u + 1) := Category.{u} C", "start": [183, 1], "end": [185, 67], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_whisker", "code": "theorem eq_whisker {f g : X \u27f6 Y} (w : f = g) (h : Y \u27f6 Z) : f \u226b h = g \u226b h", "start": [194, 1], "end": [195, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whisker_eq", "code": "theorem whisker_eq (f : X \u27f6 Y) {g h : Y \u27f6 Z} (w : g = h) : f \u226b g = f \u226b h", "start": [198, 1], "end": [199, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_of_comp_left_eq", "code": "theorem eq_of_comp_left_eq {f g : X \u27f6 Y} (w : \u2200 {Z : C} (h : Y \u27f6 Z), f \u226b h = g \u226b h) :\n    f = g", "start": [214, 1], "end": [216, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_of_comp_right_eq", "code": "theorem eq_of_comp_right_eq {f g : Y \u27f6 Z} (w : \u2200 {X : C} (h : X \u27f6 Y), h \u226b f = h \u226b g) :\n    f = g", "start": [219, 1], "end": [221, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_of_comp_left_eq'", "code": "theorem eq_of_comp_left_eq' (f g : X \u27f6 Y)\n    (w : (fun {Z} (h : Y \u27f6 Z) => f \u226b h) = fun {Z} (h : Y \u27f6 Z) => g \u226b h) : f = g", "start": [224, 1], "end": [226, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_of_comp_right_eq'", "code": "theorem eq_of_comp_right_eq' (f g : Y \u27f6 Z)\n    (w : (fun {X} (h : X \u27f6 Y) => h \u226b f) = fun {X} (h : X \u27f6 Y) => h \u226b g) : f = g", "start": [229, 1], "end": [231, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.id_of_comp_left_id", "code": "theorem id_of_comp_left_id (f : X \u27f6 X) (w : \u2200 {Y : C} (g : X \u27f6 Y), f \u226b g = g) : f = \ud835\udfd9 X", "start": [234, 1], "end": [236, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.id_of_comp_right_id", "code": "theorem id_of_comp_right_id (f : X \u27f6 X) (w : \u2200 {Y : C} (g : Y \u27f6 X), g \u226b f = g) : f = \ud835\udfd9 X", "start": [239, 1], "end": [241, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_ite", "code": "theorem comp_ite {P : Prop} [Decidable P] {X Y Z : C} (f : X \u27f6 Y) (g g' : Y \u27f6 Z) :\n    (f \u226b if P then g else g') = if P then f \u226b g else f \u226b g'", "start": [244, 1], "end": [245, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.ite_comp", "code": "theorem ite_comp {P : Prop} [Decidable P] {X Y Z : C} (f f' : X \u27f6 Y) (g : Y \u27f6 Z) :\n    (if P then f else f') \u226b g = if P then f \u226b g else f' \u226b g", "start": [248, 1], "end": [249, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_dite", "code": "theorem comp_dite {P : Prop} [Decidable P]\n    {X Y Z : C} (f : X \u27f6 Y) (g : P \u2192 (Y \u27f6 Z)) (g' : \u00acP \u2192 (Y \u27f6 Z)) :\n    (f \u226b if h : P then g h else g' h) = if h : P then f \u226b g h else f \u226b g' h", "start": [252, 1], "end": [254, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.dite_comp", "code": "theorem dite_comp {P : Prop} [Decidable P]\n    {X Y Z : C} (f : P \u2192 (X \u27f6 Y)) (f' : \u00acP \u2192 (X \u27f6 Y)) (g : Y \u27f6 Z) :\n    (if h : P then f h else f' h) \u226b g = if h : P then f h \u226b g else f' h \u226b g", "start": [257, 1], "end": [259, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Epi", "code": "class Epi (f : X \u27f6 Y) : Prop where\n  \n  left_cancellation : \u2200 {Z : C} (g h : Y \u27f6 Z), f \u226b g = f \u226b h \u2192 g = h", "start": [262, 1], "end": [269, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Mono", "code": "class Mono (f : X \u27f6 Y) : Prop where\n  \n  right_cancellation : \u2200 {Z : C} (g h : Z \u27f6 X), g \u226b f = h \u226b f \u2192 g = h", "start": [272, 1], "end": [279, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cancel_epi", "code": "theorem cancel_epi (f : X \u27f6 Y) [Epi f] {g h : Y \u27f6 Z} : f \u226b g = f \u226b h \u2194 g = h", "start": [288, 1], "end": [289, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cancel_mono", "code": "theorem cancel_mono (f : X \u27f6 Y) [Mono f] {g h : Z \u27f6 X} : g \u226b f = h \u226b f \u2194 g = h", "start": [292, 1], "end": [294, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cancel_epi_id", "code": "theorem cancel_epi_id (f : X \u27f6 Y) [Epi f] {h : Y \u27f6 Y} : f \u226b h = f \u2194 h = \ud835\udfd9 Y", "start": [297, 1], "end": [299, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.cancel_mono_id", "code": "theorem cancel_mono_id (f : X \u27f6 Y) [Mono f] {g : X \u27f6 X} : g \u226b f = f \u2194 g = \ud835\udfd9 X", "start": [302, 1], "end": [304, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.epi_comp", "code": "theorem epi_comp {X Y Z : C} (f : X \u27f6 Y) [Epi f] (g : Y \u27f6 Z) [Epi g] : Epi (f \u226b g)", "start": [307, 1], "end": [312, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_comp", "code": "theorem mono_comp {X Y Z : C} (f : X \u27f6 Y) [Mono f] (g : Y \u27f6 Z) [Mono g] : Mono (f \u226b g)", "start": [315, 1], "end": [320, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_of_mono", "code": "theorem mono_of_mono {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [Mono (f \u226b g)] : Mono f", "start": [323, 1], "end": [329, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.mono_of_mono_fac", "code": "theorem mono_of_mono_fac {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {h : X \u27f6 Z} [Mono h]\n    (w : f \u226b g = h) : Mono f", "start": [332, 1], "end": [335, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.epi_of_epi", "code": "theorem epi_of_epi {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [Epi (f \u226b g)] : Epi g", "start": [338, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.epi_of_epi_fac", "code": "theorem epi_of_epi_fac {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {h : X \u27f6 Z} [Epi h]\n    (w : f \u226b g = h) : Epi g", "start": [347, 1], "end": [349, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.uliftCategory", "code": "instance uliftCategory : Category.{v} (ULift.{u'} C) where\n  Hom X Y := X.down \u27f6 Y.down\n  id X := \ud835\udfd9 X.down\n  comp f g := f \u226b g", "start": [362, 1], "end": [365, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Equiv.lean", "imports": ["Mathlib/Algebra/Algebra/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AlgEquiv", "code": "structure AlgEquiv (R : Type u) (A : Type v) (B : Type w) [CommSemiring R] [Semiring A] [Semiring B]\n  [Algebra R A] [Algebra R B] extends A \u2243 B, A \u2243* B, A \u2243+ B, A \u2243+* B where\n  \n  protected commutes' : \u2200 r : R, toFun (algebraMap R A r) = algebraMap R B r", "start": [31, 1], "end": [35, 77], "kind": "commanddeclaration"}, {"full_name": "AlgEquivClass", "code": "class AlgEquivClass (F : Type*) (R A B : outParam (Type*)) [CommSemiring R] [Semiring A]\n  [Semiring B] [Algebra R A] [Algebra R B] extends RingEquivClass F A B where\n  \n  commutes : \u2200 (f : F) (r : R), f (algebraMap R A r) = algebraMap R B r", "start": [46, 1], "end": [51, 72], "kind": "commanddeclaration"}, {"full_name": "AlgEquivClass.toAlgHomClass", "code": "instance (priority := 100) toAlgHomClass (F R A B : Type*) [CommSemiring R] [Semiring A]\n    [Semiring B] [Algebra R A] [Algebra R B] [h : AlgEquivClass F R A B] :\n    AlgHomClass F R A B :=\n  { h with\n    coe := (\u21d1)\n    coe_injective' := FunLike.coe_injective\n    map_zero := map_zero\n    map_one := map_one }", "start": [59, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquivClass.toLinearEquivClass", "code": "instance (priority := 100) toLinearEquivClass (F R A B : Type*) [CommSemiring R]\n    [Semiring A] [Semiring B] [Algebra R A] [Algebra R B]\n    [h : AlgEquivClass F R A B] : LinearEquivClass F R A B :=\n  { h with map_smul\u209b\u2097 := fun f => map_smul\u209b\u2097 f }", "start": [69, 1], "end": [72, 49], "kind": "commanddeclaration"}, {"full_name": "AlgEquivClass.toAlgEquiv", "code": "@[coe]\ndef toAlgEquiv {F R A B : Type*} [CommSemiring R] [Semiring A] [Semiring B] [Algebra R A]\n    [Algebra R B] [AlgEquivClass F R A B] (f : F) : A \u2243\u2090[R] B :=\n  { (f : A \u2243 B), (f : A \u2243+* B) with commutes' := commutes f }", "start": [75, 1], "end": [80, 62], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.Simps.apply", "code": "def Simps.apply (e : A\u2081 \u2243\u2090[R] A\u2082) : A\u2081 \u2192 A\u2082 :=\n  e", "start": [134, 1], "end": [136, 4], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.Simps.toEquiv", "code": "def Simps.toEquiv (e : A\u2081 \u2243\u2090[R] A\u2082) : A\u2081 \u2243 A\u2082 :=\n  e", "start": [139, 1], "end": [141, 4], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_coe", "code": "@[simp]\nprotected theorem coe_coe {F : Type*} [AlgEquivClass F R A\u2081 A\u2082] (f : F) :\n    \u21d1(f : A\u2081 \u2243\u2090[R] A\u2082) = f", "start": [144, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ext", "code": "@[ext]\ntheorem ext {f g : A\u2081 \u2243\u2090[R] A\u2082} (h : \u2200 a, f a = g a) : f = g", "start": [150, 1], "end": [152, 20], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.congr_arg", "code": "protected theorem congr_arg {f : A\u2081 \u2243\u2090[R] A\u2082} {x x' : A\u2081} : x = x' \u2192 f x = f x'", "start": [155, 1], "end": [156, 22], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.congr_fun", "code": "protected theorem congr_fun {f g : A\u2081 \u2243\u2090[R] A\u2082} (h : f = g) (x : A\u2081) : f x = g x", "start": [159, 1], "end": [160, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ext_iff", "code": "protected theorem ext_iff {f g : A\u2081 \u2243\u2090[R] A\u2082} : f = g \u2194 \u2200 x, f x = g x", "start": [163, 1], "end": [164, 18], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_fun_injective", "code": "theorem coe_fun_injective : @Function.Injective (A\u2081 \u2243\u2090[R] A\u2082) (A\u2081 \u2192 A\u2082) fun e => (e : A\u2081 \u2192 A\u2082)", "start": [167, 1], "end": [168, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.hasCoeToRingEquiv", "code": "instance hasCoeToRingEquiv : CoeOut (A\u2081 \u2243\u2090[R] A\u2082) (A\u2081 \u2243+* A\u2082) :=\n  \u27e8AlgEquiv.toRingEquiv\u27e9", "start": [172, 1], "end": [173, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_mk", "code": "@[simp]\ntheorem coe_mk {toFun invFun left_inv right_inv map_mul map_add commutes} :\n    \u21d1(\u27e8\u27e8toFun, invFun, left_inv, right_inv\u27e9, map_mul, map_add, commutes\u27e9 : A\u2081 \u2243\u2090[R] A\u2082) = toFun", "start": [176, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mk_coe", "code": "@[simp]\ntheorem mk_coe (e : A\u2081 \u2243\u2090[R] A\u2082) (e' h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) :\n    (\u27e8\u27e8e, e', h\u2081, h\u2082\u27e9, h\u2083, h\u2084, h\u2085\u27e9 : A\u2081 \u2243\u2090[R] A\u2082) = e", "start": [182, 1], "end": [185, 19], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toEquiv_eq_coe", "code": "@[simp]\ntheorem toEquiv_eq_coe : e.toEquiv = e", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_eq_coe", "code": "@[simp]\ntheorem toRingEquiv_eq_coe : e.toRingEquiv = e", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_ringEquiv", "code": "@[simp, norm_cast]\ntheorem coe_ringEquiv : ((e : A\u2081 \u2243+* A\u2082) : A\u2081 \u2192 A\u2082) = e", "start": [201, 1], "end": [203, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_ringEquiv'", "code": "theorem coe_ringEquiv' : (e.toRingEquiv : A\u2081 \u2192 A\u2082) = e", "start": [206, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_ringEquiv_injective", "code": "theorem coe_ringEquiv_injective : Function.Injective ((\u2191) : (A\u2081 \u2243\u2090[R] A\u2082) \u2192 A\u2081 \u2243+* A\u2082)", "start": [210, 1], "end": [211, 44], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_add", "code": "protected theorem map_add : \u2200 x y, e (x + y) = e x + e y", "start": [214, 1], "end": [215, 12], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_zero", "code": "protected theorem map_zero : e 0 = 0", "start": [218, 1], "end": [219, 13], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_mul", "code": "protected theorem map_mul : \u2200 x y, e (x * y) = e x * e y", "start": [222, 1], "end": [223, 12], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_one", "code": "protected theorem map_one : e 1 = 1", "start": [226, 1], "end": [227, 12], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.commutes", "code": "@[simp]\ntheorem commutes : \u2200 r : R, e (algebraMap R A\u2081 r) = algebraMap R A\u2082 r", "start": [230, 1], "end": [232, 14], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_smul", "code": "theorem map_smul (r : R) (x : A\u2081) : e (r \u2022 x) = r \u2022 e x", "start": [236, 1], "end": [237, 50], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_sum", "code": "theorem map_sum {\u03b9 : Type*} (f : \u03b9 \u2192 A\u2081) (s : Finset \u03b9) : e (\u2211 x in s, f x) = \u2211 x in s, e (f x)", "start": [240, 1], "end": [241, 27], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_finsupp_sum", "code": "theorem map_finsupp_sum {\u03b1 : Type*} [Zero \u03b1] {\u03b9 : Type*} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A\u2081) :\n    e (f.sum g) = f.sum fun i b => e (g i b)", "start": [244, 1], "end": [246, 16], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toAlgHom", "code": "@[coe]\ndef toAlgHom : A\u2081 \u2192\u2090[R] A\u2082 :=\n  { e with\n    map_one' := e.map_one\n    map_zero' := e.map_zero }", "start": [250, 1], "end": [258, 30], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toAlgHom_eq_coe", "code": "@[simp]\ntheorem toAlgHom_eq_coe : e.toAlgHom = e", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_algHom", "code": "@[simp, norm_cast]\ntheorem coe_algHom : FunLike.coe (e.toAlgHom) = FunLike.coe e", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_algHom_injective", "code": "theorem coe_algHom_injective : Function.Injective ((\u2191) : (A\u2081 \u2243\u2090[R] A\u2082) \u2192 A\u2081 \u2192\u2090[R] A\u2082)", "start": [271, 1], "end": [272, 41], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_ringHom_commutes", "code": "theorem coe_ringHom_commutes : ((e : A\u2081 \u2192\u2090[R] A\u2082) : A\u2081 \u2192+* A\u2082) = ((e : A\u2081 \u2243+* A\u2082) : A\u2081 \u2192+* A\u2082)", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_pow", "code": "protected theorem map_pow : \u2200 (x : A\u2081) (n : \u2115), e (x ^ n) = e x ^ n", "start": [280, 1], "end": [281, 12], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.injective", "code": "protected theorem injective : Function.Injective e", "start": [284, 1], "end": [285, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.surjective", "code": "protected theorem surjective : Function.Surjective e", "start": [288, 1], "end": [289, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.bijective", "code": "protected theorem bijective : Function.Bijective e", "start": [292, 1], "end": [293, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.refl", "code": "@[refl]\ndef refl : A\u2081 \u2243\u2090[R] A\u2081 :=\n  { (1 : A\u2081 \u2243+* A\u2081) with commutes' := fun _ => rfl }", "start": [296, 1], "end": [299, 53], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.refl_toAlgHom", "code": "@[simp]\ntheorem refl_toAlgHom : \u2191(refl : A\u2081 \u2243\u2090[R] A\u2081) = AlgHom.id R A\u2081", "start": [305, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_refl", "code": "@[simp]\ntheorem coe_refl : \u21d1(refl : A\u2081 \u2243\u2090[R] A\u2081) = id", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm", "code": "@[symm]\ndef symm (e : A\u2081 \u2243\u2090[R] A\u2082) : A\u2082 \u2243\u2090[R] A\u2081 :=\n  { e.toRingEquiv.symm with\n    commutes' := fun r => by\n      rw [\u2190 e.toRingEquiv.symm_apply_apply (algebraMap R A\u2081 r)]\n      congr\n      change _ = e _\n      rw [e.commutes] }", "start": [315, 1], "end": [323, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (e : A\u2081 \u2243\u2090[R] A\u2082) : A\u2082 \u2192 A\u2081 :=\n  e.symm", "start": [326, 1], "end": [328, 9], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_apply_coe_coe_symm_apply", "code": "theorem coe_apply_coe_coe_symm_apply {F : Type*} [AlgEquivClass F R A\u2081 A\u2082] (f : F) (x : A\u2082) :\n    f ((f : A\u2081 \u2243\u2090[R] A\u2082).symm x) = x", "start": [334, 1], "end": [336, 26], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_coe_symm_apply_coe_apply", "code": "theorem coe_coe_symm_apply_coe_apply {F : Type*} [AlgEquivClass F R A\u2081 A\u2082] (f : F) (x : A\u2081) :\n    (f : A\u2081 \u2243\u2090[R] A\u2082).symm (f x) = x", "start": [340, 1], "end": [342, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_toEquiv_eq_symm", "code": "@[simp]\ntheorem symm_toEquiv_eq_symm {e : A\u2081 \u2243\u2090[R] A\u2082} : (e : A\u2081 \u2243 A\u2082).symm = e.symm", "start": [346, 1], "end": [348, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.invFun_eq_symm", "code": "theorem invFun_eq_symm {e : A\u2081 \u2243\u2090[R] A\u2082} : e.invFun = e.symm", "start": [350, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_symm", "code": "@[simp]\ntheorem symm_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : e.symm.symm = e", "start": [354, 1], "end": [357, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_bijective", "code": "theorem symm_bijective : Function.Bijective (symm : (A\u2081 \u2243\u2090[R] A\u2082) \u2192 A\u2082 \u2243\u2090[R] A\u2081)", "start": [360, 1], "end": [361, 53], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mk_coe'", "code": "@[simp]\ntheorem mk_coe' (e : A\u2081 \u2243\u2090[R] A\u2082) (f h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) :\n    (\u27e8\u27e8f, e, h\u2081, h\u2082\u27e9, h\u2083, h\u2084, h\u2085\u27e9 : A\u2082 \u2243\u2090[R] A\u2081) = e.symm", "start": [364, 1], "end": [367, 47], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_mk", "code": "@[simp]\ntheorem symm_mk (f f') (h\u2081 h\u2082 h\u2083 h\u2084 h\u2085) :\n    (\u27e8\u27e8f, f', h\u2081, h\u2082\u27e9, h\u2083, h\u2084, h\u2085\u27e9 : A\u2081 \u2243\u2090[R] A\u2082).symm =\n      {(\u27e8\u27e8f, f', h\u2081, h\u2082\u27e9, h\u2083, h\u2084, h\u2085\u27e9 : A\u2081 \u2243\u2090[R] A\u2082).symm with\n        toFun := f'\n        invFun := f }", "start": [370, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm : (AlgEquiv.refl : A\u2081 \u2243\u2090[R] A\u2081).symm = AlgEquiv.refl", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_symm", "code": "theorem toRingEquiv_symm (f : A\u2081 \u2243\u2090[R] A\u2081) : (f : A\u2081 \u2243+* A\u2081).symm = f.symm", "start": [385, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_toRingEquiv", "code": "@[simp]\ntheorem symm_toRingEquiv : (e.symm : A\u2082 \u2243+* A\u2081) = (e : A\u2081 \u2243+* A\u2082).symm", "start": [389, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.trans", "code": "@[trans]\ndef trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) : A\u2081 \u2243\u2090[R] A\u2083 :=\n  { e\u2081.toRingEquiv.trans e\u2082.toRingEquiv with\n    commutes' := fun r => show e\u2082.toFun (e\u2081.toFun _) = _ by rw [e\u2081.commutes', e\u2082.commutes'] }", "start": [394, 1], "end": [398, 94], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (e : A\u2081 \u2243\u2090[R] A\u2082) : \u2200 x, e (e.symm x) = x", "start": [401, 1], "end": [403, 29], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (e : A\u2081 \u2243\u2090[R] A\u2082) : \u2200 x, e.symm (e x) = x", "start": [406, 1], "end": [408, 29], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) (x : A\u2083) :\n    (e\u2081.trans e\u2082).symm x = e\u2081.symm (e\u2082.symm x)", "start": [411, 1], "end": [414, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_trans", "code": "@[simp]\ntheorem coe_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081", "start": [417, 1], "end": [419, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) (x : A\u2081) : (e\u2081.trans e\u2082) x = e\u2082 (e\u2081 x)", "start": [422, 1], "end": [424, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.comp_symm", "code": "@[simp]\ntheorem comp_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : AlgHom.comp (e : A\u2081 \u2192\u2090[R] A\u2082) \u2191e.symm = AlgHom.id R A\u2082", "start": [427, 1], "end": [430, 7], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.symm_comp", "code": "@[simp]\ntheorem symm_comp (e : A\u2081 \u2243\u2090[R] A\u2082) : AlgHom.comp \u2191e.symm (e : A\u2081 \u2192\u2090[R] A\u2082) = AlgHom.id R A\u2081", "start": [433, 1], "end": [436, 7], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.leftInverse_symm", "code": "theorem leftInverse_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : Function.LeftInverse e.symm e", "start": [439, 1], "end": [440, 13], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.rightInverse_symm", "code": "theorem rightInverse_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : Function.RightInverse e.symm e", "start": [443, 1], "end": [444, 14], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.arrowCongr", "code": "@[simps apply]\ndef arrowCongr (e\u2081 : A\u2081 \u2243\u2090[R] A\u2081') (e\u2082 : A\u2082 \u2243\u2090[R] A\u2082') : (A\u2081 \u2192\u2090[R] A\u2082) \u2243 (A\u2081' \u2192\u2090[R] A\u2082') where\n  toFun f := (e\u2082.toAlgHom.comp f).comp e\u2081.symm.toAlgHom\n  invFun f := (e\u2082.symm.toAlgHom.comp f).comp e\u2081.toAlgHom\n  left_inv f := by\n    simp only [AlgHom.comp_assoc, toAlgHom_eq_coe, symm_comp]\n    simp only [\u2190 AlgHom.comp_assoc, symm_comp, AlgHom.id_comp, AlgHom.comp_id]\n  right_inv f := by\n    simp only [AlgHom.comp_assoc, toAlgHom_eq_coe, comp_symm]\n    simp only [\u2190 AlgHom.comp_assoc, comp_symm, AlgHom.id_comp, AlgHom.comp_id]", "start": [447, 1], "end": [458, 79], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.arrowCongr_comp", "code": "theorem arrowCongr_comp (e\u2081 : A\u2081 \u2243\u2090[R] A\u2081') (e\u2082 : A\u2082 \u2243\u2090[R] A\u2082')\n    (e\u2083 : A\u2083 \u2243\u2090[R] A\u2083') (f : A\u2081 \u2192\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2083) :\n    arrowCongr e\u2081 e\u2083 (g.comp f) = (arrowCongr e\u2082 e\u2083 g).comp (arrowCongr e\u2081 e\u2082 f)", "start": [461, 1], "end": [467, 37], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.arrowCongr_refl", "code": "@[simp]\ntheorem arrowCongr_refl : arrowCongr AlgEquiv.refl AlgEquiv.refl = Equiv.refl (A\u2081 \u2192\u2090[R] A\u2082)", "start": [470, 1], "end": [473, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.arrowCongr_trans", "code": "@[simp]\ntheorem arrowCongr_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2081' : A\u2081' \u2243\u2090[R] A\u2082')\n    (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) (e\u2082' : A\u2082' \u2243\u2090[R] A\u2083') :\n    arrowCongr (e\u2081.trans e\u2082) (e\u2081'.trans e\u2082') = (arrowCongr e\u2081 e\u2081').trans (arrowCongr e\u2082 e\u2082')", "start": [476, 1], "end": [481, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.arrowCongr_symm", "code": "@[simp]\ntheorem arrowCongr_symm (e\u2081 : A\u2081 \u2243\u2090[R] A\u2081') (e\u2082 : A\u2082 \u2243\u2090[R] A\u2082') :\n    (arrowCongr e\u2081 e\u2082).symm = arrowCongr e\u2081.symm e\u2082.symm", "start": [484, 1], "end": [488, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.equivCongr", "code": "@[simps apply]\ndef equivCongr (e : A\u2081 \u2243\u2090[R] A\u2082) (e' : A\u2081' \u2243\u2090[R] A\u2082') : (A\u2081 \u2243\u2090[R] A\u2081') \u2243 A\u2082 \u2243\u2090[R] A\u2082' where\n  toFun \u03c8 := e.symm.trans (\u03c8.trans e')\n  invFun \u03c8 := e.trans (\u03c8.trans e'.symm)\n  left_inv \u03c8 := by\n    ext\n    simp_rw [trans_apply, symm_apply_apply]\n  right_inv \u03c8 := by\n    ext\n    simp_rw [trans_apply, apply_symm_apply]", "start": [491, 1], "end": [504, 44], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.equivCongr_refl", "code": "@[simp]\ntheorem equivCongr_refl : equivCongr AlgEquiv.refl AlgEquiv.refl = Equiv.refl (A\u2081 \u2243\u2090[R] A\u2081')", "start": [506, 1], "end": [509, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.equivCongr_symm", "code": "@[simp]\ntheorem equivCongr_symm (e : A\u2081 \u2243\u2090[R] A\u2082) (e' : A\u2081' \u2243\u2090[R] A\u2082') :\n    (equivCongr e e').symm = equivCongr e.symm e'.symm", "start": [511, 1], "end": [514, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.equivCongr_trans", "code": "@[simp]\ntheorem equivCongr_trans (e\u2081\u2082 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2081\u2082' : A\u2081' \u2243\u2090[R] A\u2082')\n    (e\u2082\u2083 : A\u2082 \u2243\u2090[R] A\u2083) (e\u2082\u2083' : A\u2082' \u2243\u2090[R] A\u2083') :\n    (equivCongr e\u2081\u2082 e\u2081\u2082').trans (equivCongr e\u2082\u2083 e\u2082\u2083') =\n      equivCongr (e\u2081\u2082.trans e\u2082\u2083) (e\u2081\u2082'.trans e\u2082\u2083')", "start": [516, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofAlgHom", "code": "def ofAlgHom (f : A\u2081 \u2192\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2081) (h\u2081 : f.comp g = AlgHom.id R A\u2082)\n    (h\u2082 : g.comp f = AlgHom.id R A\u2081) : A\u2081 \u2243\u2090[R] A\u2082 :=\n  { f with\n    toFun := f\n    invFun := g\n    left_inv := AlgHom.ext_iff.1 h\u2082\n    right_inv := AlgHom.ext_iff.1 h\u2081 }", "start": [523, 1], "end": [530, 39], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_algHom_ofAlgHom", "code": "theorem coe_algHom_ofAlgHom (f : A\u2081 \u2192\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2081) (h\u2081 h\u2082) :\n    \u2191(ofAlgHom f g h\u2081 h\u2082) = f", "start": [533, 1], "end": [535, 26], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofAlgHom_coe_algHom", "code": "@[simp]\ntheorem ofAlgHom_coe_algHom (f : A\u2081 \u2243\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2081) (h\u2081 h\u2082) :\n    ofAlgHom (\u2191f) g h\u2081 h\u2082 = f", "start": [538, 1], "end": [541, 19], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofAlgHom_symm", "code": "theorem ofAlgHom_symm (f : A\u2081 \u2192\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2081) (h\u2081 h\u2082) :\n    (ofAlgHom f g h\u2081 h\u2082).symm = ofAlgHom g f h\u2082 h\u2081", "start": [544, 1], "end": [546, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofBijective", "code": "noncomputable def ofBijective (f : A\u2081 \u2192\u2090[R] A\u2082) (hf : Function.Bijective f) : A\u2081 \u2243\u2090[R] A\u2082 :=\n  { RingEquiv.ofBijective (f : A\u2081 \u2192+* A\u2082) hf, f with }", "start": [549, 1], "end": [551, 55], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_ofBijective", "code": "@[simp]\ntheorem coe_ofBijective {f : A\u2081 \u2192\u2090[R] A\u2082} {hf : Function.Bijective f} :\n    (AlgEquiv.ofBijective f hf : A\u2081 \u2192 A\u2082) = f", "start": [554, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofBijective_apply", "code": "theorem ofBijective_apply {f : A\u2081 \u2192\u2090[R] A\u2082} {hf : Function.Bijective f} (a : A\u2081) :\n    (AlgEquiv.ofBijective f hf) a = f a", "start": [560, 1], "end": [562, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv", "code": "@[simps apply]\ndef toLinearEquiv (e : A\u2081 \u2243\u2090[R] A\u2082) : A\u2081 \u2243\u2097[R] A\u2082 :=\n  { e with\n    toFun := e\n    map_smul' := e.map_smul\n    invFun := e.symm }", "start": [565, 1], "end": [571, 23], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_refl", "code": "@[simp]\ntheorem toLinearEquiv_refl : (AlgEquiv.refl : A\u2081 \u2243\u2090[R] A\u2081).toLinearEquiv = LinearEquiv.refl R A\u2081", "start": [575, 1], "end": [577, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_symm", "code": "@[simp]\ntheorem toLinearEquiv_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : e.toLinearEquiv.symm = e.symm.toLinearEquiv", "start": [580, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_trans", "code": "@[simp]\ntheorem toLinearEquiv_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) :\n    (e\u2081.trans e\u2082).toLinearEquiv = e\u2081.toLinearEquiv.trans e\u2082.toLinearEquiv", "start": [585, 1], "end": [588, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_injective", "code": "theorem toLinearEquiv_injective : Function.Injective (toLinearEquiv : _ \u2192 A\u2081 \u2243\u2097[R] A\u2082)", "start": [591, 1], "end": [592, 46], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearMap", "code": "def toLinearMap : A\u2081 \u2192\u2097[R] A\u2082 :=\n  e.toAlgHom.toLinearMap", "start": [595, 1], "end": [597, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toAlgHom_toLinearMap", "code": "@[simp]\ntheorem toAlgHom_toLinearMap : (e : A\u2081 \u2192\u2090[R] A\u2082).toLinearMap = e.toLinearMap", "start": [600, 1], "end": [602, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearMap_ofAlgHom", "code": "theorem toLinearMap_ofAlgHom (f : A\u2081 \u2192\u2090[R] A\u2082) (g : A\u2082 \u2192\u2090[R] A\u2081) (h\u2081 h\u2082) :\n    (ofAlgHom f g h\u2081 h\u2082).toLinearMap = f.toLinearMap", "start": [605, 1], "end": [607, 29], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_toLinearMap", "code": "@[simp]\ntheorem toLinearEquiv_toLinearMap : e.toLinearEquiv.toLinearMap = e.toLinearMap", "start": [609, 1], "end": [611, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearMap_apply", "code": "@[simp]\ntheorem toLinearMap_apply (x : A\u2081) : e.toLinearMap x = e x", "start": [614, 1], "end": [616, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearMap_injective", "code": "theorem toLinearMap_injective : Function.Injective (toLinearMap : _ \u2192 A\u2081 \u2192\u2097[R] A\u2082)", "start": [619, 1], "end": [620, 31], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.trans_toLinearMap", "code": "@[simp]\ntheorem trans_toLinearMap (f : A\u2081 \u2243\u2090[R] A\u2082) (g : A\u2082 \u2243\u2090[R] A\u2083) :\n    (f.trans g).toLinearMap = g.toLinearMap.comp f.toLinearMap", "start": [623, 1], "end": [626, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLinearEquiv", "code": "@[simps apply]\ndef ofLinearEquiv : A\u2081 \u2243\u2090[R] A\u2082 :=\n  { l with\n    toFun := l\n    invFun := l.symm\n    map_mul' := map_mul\n    commutes' := (AlgHom.ofLinearMap l map_one map_mul : A\u2081 \u2192\u2090[R] A\u2082).commutes }", "start": [633, 1], "end": [642, 81], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLinearEquiv_symm", "code": "@[simp]\ntheorem ofLinearEquiv_symm :\n    (ofLinearEquiv l map_one map_mul).symm =\n      ofLinearEquiv l.symm (ofLinearEquiv l map_one map_mul).symm.map_one\n        (ofLinearEquiv l map_one map_mul).symm.map_mul", "start": [645, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLinearEquiv_toLinearEquiv", "code": "@[simp]\ntheorem ofLinearEquiv_toLinearEquiv (map_mul) (map_one) :\n    ofLinearEquiv e.toLinearEquiv map_mul map_one = e", "start": [653, 1], "end": [657, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toLinearEquiv_ofLinearEquiv", "code": "@[simp]\ntheorem toLinearEquiv_ofLinearEquiv : toLinearEquiv (ofLinearEquiv l map_one map_mul) = l", "start": [660, 1], "end": [663, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofRingEquiv", "code": "@[simps apply symm_apply toEquiv] def ofRingEquiv {f : A\u2081 \u2243+* A\u2082} (hf : \u2200 x, f (algebraMap R A\u2081 x) = algebraMap R A\u2082 x) :\n    A\u2081 \u2243\u2090[R] A\u2082 :=\n  { f with\n    toFun := f\n    invFun := f.symm\n    commutes' := hf }", "start": [670, 1], "end": [677, 22], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.aut", "code": "instance aut : Group (A\u2081 \u2243\u2090[R] A\u2081) where\n  mul \u03d5 \u03c8 := \u03c8.trans \u03d5\n  mul_assoc \u03d5 \u03c8 \u03c7 := rfl\n  one := refl\n  one_mul \u03d5 := ext fun x => rfl\n  mul_one \u03d5 := ext fun x => rfl\n  inv := symm\n  mul_left_inv \u03d5 := ext <| symm_apply_apply \u03d5", "start": [684, 1], "end": [691, 46], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.aut_mul", "code": "theorem aut_mul (\u03d5 \u03c8 : A\u2081 \u2243\u2090[R] A\u2081) : \u03d5 * \u03c8 = \u03c8.trans \u03d5", "start": [694, 1], "end": [695, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.aut_one", "code": "theorem aut_one : 1 = AlgEquiv.refl (R := R) (A\u2081 := A\u2081)", "start": [697, 1], "end": [698, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.one_apply", "code": "@[simp]\ntheorem one_apply (x : A\u2081) : (1 : A\u2081 \u2243\u2090[R] A\u2081) x = x", "start": [700, 1], "end": [702, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mul_apply", "code": "@[simp]\ntheorem mul_apply (e\u2081 e\u2082 : A\u2081 \u2243\u2090[R] A\u2081) (x : A\u2081) : (e\u2081 * e\u2082) x = e\u2081 (e\u2082 x)", "start": [705, 1], "end": [707, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.autCongr", "code": "@[simps apply]\ndef autCongr (\u03d5 : A\u2081 \u2243\u2090[R] A\u2082) : (A\u2081 \u2243\u2090[R] A\u2081) \u2243* A\u2082 \u2243\u2090[R] A\u2082 where\n  __ := equivCongr \u03d5 \u03d5\n  toFun \u03c8 := \u03d5.symm.trans (\u03c8.trans \u03d5)\n  invFun \u03c8 := \u03d5.trans (\u03c8.trans \u03d5.symm)\n  map_mul' \u03c8 \u03c7 := by\n    ext\n    simp only [mul_apply, trans_apply, symm_apply_apply]", "start": [710, 1], "end": [720, 57], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.autCongr_refl", "code": "@[simp]\ntheorem autCongr_refl : autCongr AlgEquiv.refl = MulEquiv.refl (A\u2081 \u2243\u2090[R] A\u2081)", "start": [723, 1], "end": [726, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.autCongr_symm", "code": "@[simp]\ntheorem autCongr_symm (\u03d5 : A\u2081 \u2243\u2090[R] A\u2082) : (autCongr \u03d5).symm = autCongr \u03d5.symm", "start": [729, 1], "end": [731, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.autCongr_trans", "code": "@[simp]\ntheorem autCongr_trans (\u03d5 : A\u2081 \u2243\u2090[R] A\u2082) (\u03c8 : A\u2082 \u2243\u2090[R] A\u2083) :\n    (autCongr \u03d5).trans (autCongr \u03c8) = autCongr (\u03d5.trans \u03c8)", "start": [734, 1], "end": [737, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.applyMulSemiringAction", "code": "instance applyMulSemiringAction : MulSemiringAction (A\u2081 \u2243\u2090[R] A\u2081) A\u2081 where\n  smul := (\u00b7 <| \u00b7)\n  smul_zero := AlgEquiv.map_zero\n  smul_add := AlgEquiv.map_add\n  smul_one := AlgEquiv.map_one\n  smul_mul := AlgEquiv.map_mul\n  one_smul _ := rfl\n  mul_smul _ _ _ := rfl", "start": [740, 1], "end": [750, 24], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.smul_def", "code": "@[simp]\nprotected theorem smul_def (f : A\u2081 \u2243\u2090[R] A\u2081) (a : A\u2081) : f \u2022 a = f a", "start": [753, 1], "end": [755, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.apply_faithfulSMul", "code": "instance apply_faithfulSMul : FaithfulSMul (A\u2081 \u2243\u2090[R] A\u2081) A\u2081 :=\n  \u27e8AlgEquiv.ext\u27e9", "start": [758, 1], "end": [759, 17], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.apply_smulCommClass", "code": "instance apply_smulCommClass : SMulCommClass R (A\u2081 \u2243\u2090[R] A\u2081) A\u2081 where\n  smul_comm r e a := (e.map_smul r a).symm", "start": [762, 1], "end": [763, 43], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.apply_smulCommClass'", "code": "instance apply_smulCommClass' : SMulCommClass (A\u2081 \u2243\u2090[R] A\u2081) R A\u2081 where\n  smul_comm e r a := e.map_smul r a", "start": [766, 1], "end": [767, 36], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.algebraMap_eq_apply", "code": "@[simp]\ntheorem algebraMap_eq_apply (e : A\u2081 \u2243\u2090[R] A\u2082) {y : R} {x : A\u2081} :\n    algebraMap R A\u2082 y = e x \u2194 algebraMap R A\u2081 y = x", "start": [770, 1], "end": [774, 38], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_prod", "code": "nonrec theorem map_prod {\u03b9 : Type*} (f : \u03b9 \u2192 A\u2081) (s : Finset \u03b9) :\n    e (\u220f x in s, f x) = \u220f x in s, e (f x)", "start": [786, 1], "end": [788, 17], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_finsupp_prod", "code": "nonrec theorem map_finsupp_prod {\u03b1 : Type*} [Zero \u03b1] {\u03b9 : Type*} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A\u2081) :\n    e (f.prod g) = f.prod fun i a => e (g i a)", "start": [792, 1], "end": [794, 25], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_neg", "code": "protected theorem map_neg (x) : e (-x) = -e x", "start": [805, 1], "end": [806, 14], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.map_sub", "code": "protected theorem map_sub (x y) : e (x - y) = e x - e y", "start": [809, 1], "end": [810, 16], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toAlgEquiv", "code": "@[simps! apply symm_apply toEquiv] def toAlgEquiv (g : G) : A \u2243\u2090[R] A :=\n  { MulSemiringAction.toRingEquiv _ _ g, MulSemiringAction.toAlgHom R A g with }", "start": [825, 1], "end": [831, 81], "kind": "commanddeclaration"}, {"full_name": "MulSemiringAction.toAlgEquiv_injective", "code": "theorem toAlgEquiv_injective [FaithfulSMul G A] :\n    Function.Injective (MulSemiringAction.toAlgEquiv R A : G \u2192 A \u2243\u2090[R] A)", "start": [834, 1], "end": [836, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Opposites.lean", "imports": ["Mathlib/Algebra/Module/Equiv.lean", "Mathlib/GroupTheory/GroupAction/Opposite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.module", "code": "instance module : Module R (MulOpposite M) :=\n  { MulOpposite.distribMulAction M R with\n    add_smul := fun r\u2081 r\u2082 x => unop_injective <| add_smul r\u2081 r\u2082 (unop x)\n    zero_smul := fun x => unop_injective <| zero_smul _ (unop x) }", "start": [25, 1], "end": [29, 67], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opLinearEquiv", "code": "def opLinearEquiv : M \u2243\u2097[R] M\u1d50\u1d52\u1d56 :=\n  { opAddEquiv with map_smul' := MulOpposite.op_smul }", "start": [31, 1], "end": [33, 55], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv", "code": "@[simp]\ntheorem coe_opLinearEquiv : (opLinearEquiv R : M \u2192 M\u1d50\u1d52\u1d56) = op", "start": [36, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv_symm", "code": "@[simp]\ntheorem coe_opLinearEquiv_symm : ((opLinearEquiv R).symm : M\u1d50\u1d52\u1d56 \u2192 M) = unop", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv_toLinearMap", "code": "@[simp]\ntheorem coe_opLinearEquiv_toLinearMap : ((opLinearEquiv R).toLinearMap : M \u2192 M\u1d50\u1d52\u1d56) = op", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv_symm_toLinearMap", "code": "@[simp]\ntheorem coe_opLinearEquiv_symm_toLinearMap :\n    ((opLinearEquiv R).symm.toLinearMap : M\u1d50\u1d52\u1d56 \u2192 M) = unop", "start": [51, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opLinearEquiv_toAddEquiv", "code": "theorem opLinearEquiv_toAddEquiv : (opLinearEquiv R : M \u2243\u2097[R] M\u1d50\u1d52\u1d56).toAddEquiv = opAddEquiv", "start": [58, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv_addEquiv", "code": "@[simp]\ntheorem coe_opLinearEquiv_addEquiv : ((opLinearEquiv R : M \u2243\u2097[R] M\u1d50\u1d52\u1d56) : M \u2243+ M\u1d50\u1d52\u1d56) = opAddEquiv", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opLinearEquiv_symm_toAddEquiv", "code": "theorem opLinearEquiv_symm_toAddEquiv :\n    (opLinearEquiv R : M \u2243\u2097[R] M\u1d50\u1d52\u1d56).symm.toAddEquiv = opAddEquiv.symm", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.coe_opLinearEquiv_symm_addEquiv", "code": "@[simp]\ntheorem coe_opLinearEquiv_symm_addEquiv :\n    ((opLinearEquiv R : M \u2243\u2097[R] M\u1d50\u1d52\u1d56).symm : M\u1d50\u1d52\u1d56 \u2243+ M) = opAddEquiv.symm", "start": [72, 1], "end": [75, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/SelfAdjoint.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Init/Data/Subtype/Basic.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsSelfAdjoint", "code": "def IsSelfAdjoint [Star R] (x : R) : Prop :=\n  star x = x", "start": [46, 1], "end": [48, 13], "kind": "commanddeclaration"}, {"full_name": "IsStarNormal", "code": "class IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  \n  star_comm_self : Commute (star x) x", "start": [51, 1], "end": [54, 38], "kind": "commanddeclaration"}, {"full_name": "star_comm_self'", "code": "theorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x", "start": [59, 1], "end": [60, 30], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.all", "code": "theorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r", "start": [66, 1], "end": [68, 17], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.star_eq", "code": "theorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x", "start": [71, 1], "end": [72, 5], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_iff", "code": "theorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x \u2194 star x = x", "start": [75, 1], "end": [76, 10], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.star_iff", "code": "@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) \u2194 IsSelfAdjoint x", "start": [79, 1], "end": [81, 54], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.star_mul_self", "code": "@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x)", "start": [84, 1], "end": [86, 49], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.mul_star_self", "code": "@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x)", "start": [89, 1], "end": [91, 54], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.commute_iff", "code": "lemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y \u2194 IsSelfAdjoint (x * y) := by\n  refine \u27e8fun h \u21a6 ?_, fun h \u21a6 ?_\u27e9\n  \u00b7 rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  \u00b7 simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm", "start": [94, 1], "end": [99, 63], "kind": "mathlibtacticlemma"}, {"full_name": "IsSelfAdjoint.starHom_apply", "code": "theorem starHom_apply {F R S : Type*} [Star R] [Star S] [StarHomClass F R S] {x : R}\n    (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x)", "start": [101, 1], "end": [104, 59], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_starHom_apply", "code": "theorem _root_.isSelfAdjoint_starHom_apply {F R S : Type*} [Star R] [Star S] [StarHomClass F R S]\n    [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x)", "start": [109, 1], "end": [111, 40], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_zero", "code": "theorem _root_.isSelfAdjoint_zero : IsSelfAdjoint (0 : R)", "start": [119, 1], "end": [120, 14], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.add", "code": "theorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y)", "start": [125, 1], "end": [126, 66], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.bit0", "code": "@[deprecated]\ntheorem bit0 {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (bit0 x)", "start": [130, 1], "end": [132, 55], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.neg", "code": "theorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x)", "start": [141, 1], "end": [142, 54], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.sub", "code": "theorem sub {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x - y)", "start": [145, 1], "end": [146, 66], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_add_star_self", "code": "theorem _root_.isSelfAdjoint_add_star_self (x : R) : IsSelfAdjoint (x + star x)", "start": [155, 1], "end": [156, 63], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_star_add_self", "code": "theorem _root_.isSelfAdjoint_star_add_self (x : R) : IsSelfAdjoint (star x + x)", "start": [159, 1], "end": [160, 63], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.conjugate", "code": "theorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z)", "start": [169, 1], "end": [170, 76], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.conjugate'", "code": "theorem conjugate' {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (star z * x * z)", "start": [173, 1], "end": [174, 76], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.isStarNormal", "code": "theorem isStarNormal {x : R} (hx : IsSelfAdjoint x) : IsStarNormal x", "start": [177, 1], "end": [178, 51], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_one", "code": "theorem _root_.isSelfAdjoint_one : IsSelfAdjoint (1 : R)", "start": [189, 1], "end": [190, 13], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.pow", "code": "theorem pow {x : R} (hx : IsSelfAdjoint x) (n : \u2115) : IsSelfAdjoint (x ^ n)", "start": [199, 1], "end": [200, 54], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.bit1", "code": "@[deprecated]\ntheorem bit1 {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (bit1 x)", "start": [210, 1], "end": [212, 55], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_natCast", "code": "@[simp]\ntheorem _root_.isSelfAdjoint_natCast (n : \u2115) : IsSelfAdjoint (n : R)", "start": [215, 1], "end": [217, 17], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.mul", "code": "theorem mul {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x * y)", "start": [226, 1], "end": [227, 67], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_intCast", "code": "@[simp]\ntheorem _root_.isSelfAdjoint_intCast (z : \u2124) : IsSelfAdjoint (z : R)", "start": [236, 1], "end": [238, 17], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.inv", "code": "theorem inv {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint x\u207b\u00b9", "start": [247, 1], "end": [248, 55], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.zpow", "code": "theorem zpow {x : R} (hx : IsSelfAdjoint x) (n : \u2124) : IsSelfAdjoint (x ^ n)", "start": [251, 1], "end": [252, 56], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_ratCast", "code": "theorem _root_.isSelfAdjoint_ratCast (x : \u211a) : IsSelfAdjoint (x : R)", "start": [261, 1], "end": [262, 17], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.div", "code": "theorem div {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x / y)", "start": [271, 1], "end": [272, 67], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.smul", "code": "theorem smul {r : R} (hr : IsSelfAdjoint r) {x : A} (hx : IsSelfAdjoint x) :\n    IsSelfAdjoint (r \u2022 x)", "start": [281, 1], "end": [282, 97], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint", "code": "def selfAdjoint [AddGroup R] [StarAddMonoid R] : AddSubgroup R where\n  carrier := { x | IsSelfAdjoint x }\n  zero_mem' := star_zero R\n  add_mem' hx := hx.add\n  neg_mem' hx := hx.neg", "start": [291, 1], "end": [296, 24], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint", "code": "def skewAdjoint [AddCommGroup R] [StarAddMonoid R] : AddSubgroup R where\n  carrier := { x | star x = -x }\n  zero_mem' := show star (0 : R) = -0 by simp only [star_zero, neg_zero]\n  add_mem' := @fun x y (hx : star x = -x) (hy : star y = -y) =>\n    show star (x + y) = -(x + y) by rw [star_add x y, hx, hy, neg_add]\n  neg_mem' := @fun x (hx : star x = -x) => show star (-x) = - -x by simp only [hx, star_neg]", "start": [299, 1], "end": [305, 93], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.mem_iff", "code": "theorem mem_iff {x : R} : x \u2208 selfAdjoint R \u2194 star x = x", "start": [316, 1], "end": [318, 16], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.star_val_eq", "code": "@[simp, norm_cast]\ntheorem star_val_eq {x : selfAdjoint R} : star (x : R) = x", "start": [321, 1], "end": [323, 9], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.isStarNormal", "code": "instance isStarNormal [NonUnitalRing R] [StarRing R] (x : selfAdjoint R) :\n    IsStarNormal (x : R) :=\n  x.prop.isStarNormal", "start": [331, 1], "end": [333, 22], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_one", "code": "@[simp, norm_cast]\ntheorem val_one : \u2191(1 : selfAdjoint R) = (1 : R)", "start": [342, 1], "end": [344, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_pow", "code": "@[simp, norm_cast]\ntheorem val_pow (x : selfAdjoint R) (n : \u2115) : \u2191(x ^ n) = (x : R) ^ n", "start": [359, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_mul", "code": "@[simp, norm_cast]\ntheorem val_mul (x y : selfAdjoint R) : \u2191(x * y) = (x : R) * y", "start": [373, 1], "end": [375, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_inv", "code": "@[simp, norm_cast]\ntheorem val_inv (x : selfAdjoint R) : \u2191x\u207b\u00b9 = (x : R)\u207b\u00b9", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_div", "code": "@[simp, norm_cast]\ntheorem val_div (x y : selfAdjoint R) : \u2191(x / y) = (x / y : R)", "start": [407, 1], "end": [409, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_zpow", "code": "@[simp, norm_cast]\ntheorem val_zpow (x : selfAdjoint R) (z : \u2124) : \u2191(x ^ z) = (x : R) ^ z", "start": [415, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_ratCast", "code": "@[simp, norm_cast]\ntheorem val_ratCast (x : \u211a) : \u2191(x : selfAdjoint R) = (x : R)", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.instQSMul", "code": "instance instQSMul : SMul \u211a (selfAdjoint R) where\n  smul a x :=\n    \u27e8a \u2022 (x : R), by rw [Rat.smul_def]; exact IsSelfAdjoint.mul (isSelfAdjoint_ratCast a) x.prop\u27e9", "start": [428, 1], "end": [430, 98], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_rat_smul", "code": "@[simp, norm_cast]\ntheorem val_rat_smul (x : selfAdjoint R) (a : \u211a) : \u2191(a \u2022 x) = a \u2022 (x : R)", "start": [433, 1], "end": [435, 6], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.val_smul", "code": "@[simp, norm_cast]\ntheorem val_smul [SMul R A] [StarModule R A] (r : R) (x : selfAdjoint A) : \u2191(r \u2022 x) = r \u2022 (x : A)", "start": [453, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.mem_iff", "code": "theorem mem_iff {x : R} : x \u2208 skewAdjoint R \u2194 star x = -x", "start": [483, 1], "end": [485, 16], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.star_val_eq", "code": "@[simp, norm_cast]\ntheorem star_val_eq {x : skewAdjoint R} : star (x : R) = -x", "start": [488, 1], "end": [490, 9], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.bit0_mem", "code": "@[deprecated]\ntheorem bit0_mem {x : R} (hx : x \u2208 skewAdjoint R) : bit0 x \u2208 skewAdjoint R", "start": [497, 1], "end": [499, 62], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.conjugate", "code": "theorem conjugate {x : R} (hx : x \u2208 skewAdjoint R) (z : R) : z * x * star z \u2208 skewAdjoint R", "start": [508, 1], "end": [509, 87], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.conjugate'", "code": "theorem conjugate' {x : R} (hx : x \u2208 skewAdjoint R) (z : R) : star z * x * z \u2208 skewAdjoint R", "start": [512, 1], "end": [513, 87], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.isStarNormal_of_mem", "code": "theorem isStarNormal_of_mem {x : R} (hx : x \u2208 skewAdjoint R) : IsStarNormal x", "start": [516, 1], "end": [519, 52], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.smul_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem smul_mem [Monoid R] [DistribMulAction R A] [StarModule R A] (r : R) {x : A}\n    (h : x \u2208 skewAdjoint A) : r \u2022 x \u2208 skewAdjoint A", "start": [531, 1], "end": [534, 66], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.val_smul", "code": "@[simp, norm_cast]\ntheorem val_smul [Monoid R] [DistribMulAction R A] [StarModule R A] (r : R) (x : skewAdjoint A) :\n    \u2191(r \u2022 x) = r \u2022 (x : A)", "start": [540, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.smul_mem_skewAdjoint", "code": "theorem IsSelfAdjoint.smul_mem_skewAdjoint [Ring R] [AddCommGroup A] [Module R A] [StarAddMonoid R]\n    [StarAddMonoid A] [StarModule R A] {r : R} (hr : r \u2208 skewAdjoint R) {a : A}\n    (ha : IsSelfAdjoint a) : r \u2022 a \u2208 skewAdjoint A", "start": [556, 1], "end": [561, 70], "kind": "commanddeclaration"}, {"full_name": "isSelfAdjoint_smul_of_mem_skewAdjoint", "code": "theorem isSelfAdjoint_smul_of_mem_skewAdjoint [Ring R] [AddCommGroup A] [Module R A]\n    [StarAddMonoid R] [StarAddMonoid A] [StarModule R A] {r : R} (hr : r \u2208 skewAdjoint R) {a : A}\n    (ha : a \u2208 skewAdjoint A) : IsSelfAdjoint (r \u2022 a)", "start": [564, 1], "end": [569, 74], "kind": "commanddeclaration"}, {"full_name": "isStarNormal_zero", "code": "instance isStarNormal_zero [Semiring R] [StarRing R] : IsStarNormal (0 : R) :=\n  \u27e8by simp only [Commute.refl, star_comm_self, star_zero]\u27e9", "start": [572, 1], "end": [573, 59], "kind": "commanddeclaration"}, {"full_name": "isStarNormal_one", "code": "instance isStarNormal_one [MulOneClass R] [StarMul R] : IsStarNormal (1 : R) :=\n  \u27e8by simp only [Commute.refl, star_comm_self, star_one]\u27e9", "start": [576, 1], "end": [577, 58], "kind": "commanddeclaration"}, {"full_name": "isStarNormal_star_self", "code": "instance isStarNormal_star_self [Mul R] [StarMul R] {x : R} [IsStarNormal x] :\n    IsStarNormal (star x) :=\n  \u27e8show star (star x) * star x = star x * star (star x) by rw [star_star, star_comm_self']\u27e9", "start": [580, 1], "end": [582, 92], "kind": "commanddeclaration"}, {"full_name": "TrivialStar.isStarNormal", "code": "instance (priority := 100) TrivialStar.isStarNormal [Mul R] [StarMul R] [TrivialStar R]\n    {x : R} : IsStarNormal x :=\n  \u27e8by rw [star_trivial]\u27e9", "start": [586, 1], "end": [588, 25], "kind": "commanddeclaration"}, {"full_name": "CommMonoid.isStarNormal", "code": "instance (priority := 100) CommMonoid.isStarNormal [CommMonoid R] [StarMul R] {x : R} :\n    IsStarNormal x :=\n  \u27e8mul_comm _ _\u27e9", "start": [592, 1], "end": [594, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProduct.lean", "imports": ["Mathlib/GroupTheory/Congruence.lean", "Mathlib/Tactic/SuppressCompilation.lean", "Mathlib/Algebra/Module/Submodule/Bilinear.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.Eqv", "code": "inductive Eqv : FreeAddMonoid (M \u00d7 N) \u2192 FreeAddMonoid (M \u00d7 N) \u2192 Prop\n  | of_zero_left : \u2200 n : N, Eqv (.of (0, n)) 0\n  | of_zero_right : \u2200 m : M, Eqv (.of (m, 0)) 0\n  | of_add_left : \u2200 (m\u2081 m\u2082 : M) (n : N), Eqv (.of (m\u2081, n) + .of (m\u2082, n)) (.of (m\u2081 + m\u2082, n))\n  | of_add_right : \u2200 (m : M) (n\u2081 n\u2082 : N), Eqv (.of (m, n\u2081) + .of (m, n\u2082)) (.of (m, n\u2081 + n\u2082))\n  | of_smul : \u2200 (r : R) (m : M) (n : N), Eqv (.of (r \u2022 m, n)) (.of (m, r \u2022 n))\n  | add_comm : \u2200 x y, Eqv (x + y) (y + x)", "start": [57, 1], "end": [65, 42], "kind": "commanddeclaration"}, {"full_name": "TensorProduct", "code": "def TensorProduct : Type _ :=\n  (addConGen (TensorProduct.Eqv R M N)).Quotient", "start": [74, 1], "end": [77, 49], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addMonoid", "code": "def addMonoid : AddMonoid (M \u2297[R] N) :=\n  { (addConGen (TensorProduct.Eqv R M N)).addMonoid with }", "start": [93, 1], "end": [94, 59], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.add", "code": "protected instance add : Add (M \u2297[R] N) :=\n  (addConGen (TensorProduct.Eqv R M N)).hasAdd", "start": [96, 1], "end": [97, 47], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addZeroClass", "code": "instance addZeroClass : AddZeroClass (M \u2297[R] N) :=\n  { (addConGen (TensorProduct.Eqv R M N)).addMonoid with\n    \n    toAdd := TensorProduct.add _ _ }", "start": [99, 1], "end": [104, 37], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addSemigroup", "code": "instance addSemigroup : AddSemigroup (M \u2297[R] N) :=\n  { (addConGen (TensorProduct.Eqv R M N)).addMonoid with\n    toAdd := TensorProduct.add _ _ }", "start": [106, 1], "end": [108, 37], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addCommSemigroup", "code": "instance addCommSemigroup : AddCommSemigroup (M \u2297[R] N) :=\n  { (addConGen (TensorProduct.Eqv R M N)).addMonoid with\n    toAddSemigroup := TensorProduct.addSemigroup _ _\n    add_comm := fun x y =>\n      AddCon.induction_on\u2082 x y fun _ _ =>\n        Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.add_comm _ _ }", "start": [110, 1], "end": [115, 70], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul", "code": "def tmul (m : M) (n : N) : M \u2297[R] N :=\n  AddCon.mk' _ <| FreeAddMonoid.of (m, n)", "start": [122, 1], "end": [125, 42], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {motive : M \u2297[R] N \u2192 Prop} (z : M \u2297[R] N)\n    (zero : motive 0)\n    (tmul : \u2200 x y, motive <| x \u2297\u209c[R] y)\n    (add : \u2200 x y, motive x \u2192 motive y \u2192 motive (x + y)) : motive z", "start": [135, 1], "end": [143, 33], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.zero_tmul", "code": "@[simp]\ntheorem zero_tmul (n : N) : (0 : M) \u2297\u209c[R] n = 0", "start": [148, 1], "end": [150, 64], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.add_tmul", "code": "theorem add_tmul (m\u2081 m\u2082 : M) (n : N) : (m\u2081 + m\u2082) \u2297\u209c n = m\u2081 \u2297\u209c n + m\u2082 \u2297\u209c[R] n", "start": [155, 1], "end": [156, 78], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_zero", "code": "@[simp]\ntheorem tmul_zero (m : M) : m \u2297\u209c[R] (0 : N) = 0", "start": [161, 1], "end": [163, 65], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_add", "code": "theorem tmul_add (m : M) (n\u2081 n\u2082 : N) : m \u2297\u209c (n\u2081 + n\u2082) = m \u2297\u209c n\u2081 + m \u2297\u209c[R] n\u2082", "start": [168, 1], "end": [169, 79], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.CompatibleSMul", "code": "class CompatibleSMul [DistribMulAction R' N] : Prop where\n  smul_tmul : \u2200 (r : R') (m : M) (n : N), (r \u2022 m) \u2297\u209c n = m \u2297\u209c[R] (r \u2022 n)", "start": [176, 1], "end": [187, 73], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.CompatibleSMul.isScalarTower", "code": "instance (priority := 100) CompatibleSMul.isScalarTower [SMul R' R] [IsScalarTower R' R M]\n    [DistribMulAction R' N] [IsScalarTower R' R N] : CompatibleSMul R R' M N :=\n  \u27e8fun r m n => by\n    conv_lhs => rw [\u2190 one_smul R m]\n    conv_rhs => rw [\u2190 one_smul R n]\n    rw [\u2190 smul_assoc, \u2190 smul_assoc]\n    exact Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_smul _ _ _\u27e9", "start": [192, 1], "end": [200, 72], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smul_tmul", "code": "theorem smul_tmul [DistribMulAction R' N] [CompatibleSMul R R' M N] (r : R') (m : M) (n : N) :\n    (r \u2022 m) \u2297\u209c n = m \u2297\u209c[R] (r \u2022 n)", "start": [203, 1], "end": [206, 33], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.SMul.aux", "code": "def SMul.aux {R' : Type*} [SMul R' M] (r : R') : FreeAddMonoid (M \u00d7 N) \u2192+ M \u2297[R] N :=\n  FreeAddMonoid.lift fun p : M \u00d7 N => (r \u2022 p.1) \u2297\u209c p.2", "start": [210, 1], "end": [212, 55], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.SMul.aux_of", "code": "theorem SMul.aux_of {R' : Type*} [SMul R' M] (r : R') (m : M) (n : N) :\n    SMul.aux r (.of (m, n)) = (r \u2022 m) \u2297\u209c[R] n", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftHasSMul", "code": "instance leftHasSMul : SMul R' (M \u2297[R] N) :=\n  \u27e8fun r =>\n    (addConGen (TensorProduct.Eqv R M N)).lift (SMul.aux r : _ \u2192+ M \u2297[R] N) <|\n      AddCon.addConGen_le fun x y hxy =>\n        match x, y, hxy with\n        | _, _, .of_zero_left n =>\n          (AddCon.ker_rel _).2 <| by simp_rw [map_zero, SMul.aux_of, smul_zero, zero_tmul]\n        | _, _, .of_zero_right m =>\n          (AddCon.ker_rel _).2 <| by simp_rw [map_zero, SMul.aux_of, tmul_zero]\n        | _, _, .of_add_left m\u2081 m\u2082 n =>\n          (AddCon.ker_rel _).2 <| by simp_rw [map_add, SMul.aux_of, smul_add, add_tmul]\n        | _, _, .of_add_right m n\u2081 n\u2082 =>\n          (AddCon.ker_rel _).2 <| by simp_rw [map_add, SMul.aux_of, tmul_add]\n        | _, _, .of_smul s m n =>\n          (AddCon.ker_rel _).2 <| by rw [SMul.aux_of, SMul.aux_of, \u2190 smul_comm, smul_tmul]\n        | _, _, .add_comm x y =>\n          (AddCon.ker_rel _).2 <| by simp_rw [map_add, add_comm]\u27e9", "start": [223, 1], "end": [251, 66], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smul_zero", "code": "protected theorem smul_zero (r : R') : r \u2022 (0 : M \u2297[R] N) = 0", "start": [257, 1], "end": [258, 26], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smul_add", "code": "protected theorem smul_add (r : R') (x y : M \u2297[R] N) : r \u2022 (x + y) = r \u2022 x + r \u2022 y", "start": [261, 1], "end": [262, 29], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.zero_smul", "code": "protected theorem zero_smul (x : M \u2297[R] N) : (0 : R'') \u2022 x = 0", "start": [265, 1], "end": [269, 52], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.one_smul", "code": "protected theorem one_smul (x : M \u2297[R] N) : (1 : R') \u2022 x = x", "start": [272, 1], "end": [276, 64], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.add_smul", "code": "protected theorem add_smul (r s : R'') (x : M \u2297[R] N) : (r + s) \u2022 x = r \u2022 x + s \u2022 x", "start": [279, 1], "end": [284, 36], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid (M \u2297[R] N) :=\n  { TensorProduct.addCommSemigroup _ _,\n    TensorProduct.addZeroClass _ _ with\n    toAddSemigroup := TensorProduct.addSemigroup _ _\n    toZero := (TensorProduct.addZeroClass _ _).toZero\n    nsmul := fun n v => n \u2022 v\n    nsmul_zero := by simp [TensorProduct.zero_smul]\n    nsmul_succ := by simp only [TensorProduct.one_smul, TensorProduct.add_smul, add_comm,\n      forall_const] }", "start": [287, 1], "end": [295, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftDistribMulAction", "code": "instance leftDistribMulAction : DistribMulAction R' (M \u2297[R] N) :=\n  have : \u2200 (r : R') (m : M) (n : N), r \u2022 m \u2297\u209c[R] n = (r \u2022 m) \u2297\u209c n := fun _ _ _ => rfl\n  { smul_add := fun r x y => TensorProduct.smul_add r x y\n    mul_smul := fun r s x =>\n      x.induction_on (by simp_rw [TensorProduct.smul_zero])\n        (fun m n => by simp_rw [this, mul_smul]) fun x y ihx ihy => by\n        simp_rw [TensorProduct.smul_add]\n        rw [ihx, ihy]\n    one_smul := TensorProduct.one_smul\n    smul_zero := TensorProduct.smul_zero }", "start": [297, 1], "end": [306, 43], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smul_tmul'", "code": "theorem smul_tmul' (r : R') (m : M) (n : N) : r \u2022 m \u2297\u209c[R] n = (r \u2022 m) \u2297\u209c n", "start": [312, 1], "end": [313, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_smul", "code": "@[simp]\ntheorem tmul_smul [DistribMulAction R' N] [CompatibleSMul R R' M N] (r : R') (x : M) (y : N) :\n    x \u2297\u209c (r \u2022 y) = r \u2022 x \u2297\u209c[R] y", "start": [316, 1], "end": [319, 25], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smul_tmul_smul", "code": "theorem smul_tmul_smul (r s : R) (m : M) (n : N) : (r \u2022 m) \u2297\u209c[R] (s \u2022 n) = (r * s) \u2022 m \u2297\u209c[R] n", "start": [322, 1], "end": [323, 43], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftModule", "code": "instance leftModule : Module R'' (M \u2297[R] N) :=\n  { add_smul := TensorProduct.add_smul\n    zero_smul := TensorProduct.zero_smul }", "start": [326, 1], "end": [328, 43], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.smulCommClass_left", "code": "instance smulCommClass_left [SMulCommClass R' R'\u2082 M] : SMulCommClass R' R'\u2082 (M \u2297[R] N) where\n  smul_comm r' r'\u2082 x :=\n    TensorProduct.induction_on x (by simp_rw [TensorProduct.smul_zero])\n      (fun m n => by simp_rw [smul_tmul', smul_comm]) fun x y ihx ihy => by\n      simp_rw [TensorProduct.smul_add]; rw [ihx, ihy]", "start": [346, 1], "end": [351, 54], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isScalarTower_left", "code": "instance isScalarTower_left [IsScalarTower R'\u2082 R' M] : IsScalarTower R'\u2082 R' (M \u2297[R] N) :=\n  \u27e8fun s r x =>\n    x.induction_on (by simp)\n      (fun m n => by rw [smul_tmul', smul_tmul', smul_tmul', smul_assoc]) fun x y ihx ihy => by\n      rw [smul_add, smul_add, smul_add, ihx, ihy]\u27e9", "start": [356, 1], "end": [361, 51], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isScalarTower_right", "code": "instance isScalarTower_right [IsScalarTower R'\u2082 R' N] : IsScalarTower R'\u2082 R' (M \u2297[R] N) :=\n  \u27e8fun s r x =>\n    x.induction_on (by simp)\n      (fun m n => by rw [\u2190 tmul_smul, \u2190 tmul_smul, \u2190 tmul_smul, smul_assoc]) fun x y ihx ihy => by\n      rw [smul_add, smul_add, smul_add, ihx, ihy]\u27e9", "start": [367, 1], "end": [372, 51], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.isScalarTower", "code": "instance isScalarTower [SMul R' R] [IsScalarTower R' R M] : IsScalarTower R' R (M \u2297[R] N) :=\n  TensorProduct.isScalarTower_left", "start": [377, 1], "end": [380, 35], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.mk", "code": "def mk : M \u2192\u2097[R] N \u2192\u2097[R] M \u2297[R] N :=\n  LinearMap.mk\u2082 R (\u00b7 \u2297\u209c \u00b7) add_tmul (fun c m n => by simp_rw [smul_tmul, tmul_smul])\n    tmul_add tmul_smul", "start": [386, 1], "end": [389, 23], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.mk_apply", "code": "@[simp]\ntheorem mk_apply (m : M) (n : N) : mk R M N m n = m \u2297\u209c n", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ite_tmul", "code": "theorem ite_tmul (x\u2081 : M) (x\u2082 : N) (P : Prop) [Decidable P] :\n    (if P then x\u2081 else 0) \u2297\u209c[R] x\u2082 = if P then x\u2081 \u2297\u209c x\u2082 else 0", "start": [399, 1], "end": [400, 88], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_ite", "code": "theorem tmul_ite (x\u2081 : M) (x\u2082 : N) (P : Prop) [Decidable P] :\n    (x\u2081 \u2297\u209c[R] if P then x\u2082 else 0) = if P then x\u2081 \u2297\u209c x\u2082 else 0", "start": [403, 1], "end": [404, 88], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.sum_tmul", "code": "theorem sum_tmul {\u03b1 : Type*} (s : Finset \u03b1) (m : \u03b1 \u2192 M) (n : N) :\n    (\u2211 a in s, m a) \u2297\u209c[R] n = \u2211 a in s, m a \u2297\u209c[R] n", "start": [411, 1], "end": [416, 49], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_sum", "code": "theorem tmul_sum (m : M) {\u03b1 : Type*} (s : Finset \u03b1) (n : \u03b1 \u2192 N) :\n    (m \u2297\u209c[R] \u2211 a in s, n a) = \u2211 a in s, m \u2297\u209c[R] n a", "start": [419, 1], "end": [424, 49], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.span_tmul_eq_top", "code": "theorem span_tmul_eq_top : Submodule.span R { t : M \u2297[R] N | \u2203 m n, m \u2297\u209c n = t } = \u22a4", "start": [431, 1], "end": [440, 38], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map\u2082_mk_top_top_eq_top", "code": "@[simp]\ntheorem map\u2082_mk_top_top_eq_top : Submodule.map\u2082 (mk R M N) \u22a4 \u22a4 = \u22a4", "start": [443, 1], "end": [446, 75], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.exists_eq_tmul_of_forall", "code": "theorem exists_eq_tmul_of_forall (x : TensorProduct R M N)\n    (h : \u2200 (m\u2081 m\u2082 : M) (n\u2081 n\u2082 : N), \u2203 m n, m\u2081 \u2297\u209c n\u2081 + m\u2082 \u2297\u209c n\u2082 = m \u2297\u209c[R] n) :\n    \u2203 m n, x = m \u2297\u209c n", "start": [449, 1], "end": [460, 12], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.liftAux", "code": "def liftAux : M \u2297[R] N \u2192+ P :=\n  (addConGen (TensorProduct.Eqv R M N)).lift (FreeAddMonoid.lift fun p : M \u00d7 N => f p.1 p.2) <|\n    AddCon.addConGen_le fun x y hxy =>\n      match x, y, hxy with\n      | _, _, Eqv.of_zero_left n =>\n        (AddCon.ker_rel _).2 <| by simp_rw [map_zero, FreeAddMonoid.lift_eval_of, f.map_zero\u2082]\n      | _, _, Eqv.of_zero_right m =>\n        (AddCon.ker_rel _).2 <| by simp_rw [map_zero, FreeAddMonoid.lift_eval_of, (f m).map_zero]\n      | _, _, Eqv.of_add_left m\u2081 m\u2082 n =>\n        (AddCon.ker_rel _).2 <| by simp_rw [map_add, FreeAddMonoid.lift_eval_of, f.map_add\u2082]\n      | _, _, Eqv.of_add_right m n\u2081 n\u2082 =>\n        (AddCon.ker_rel _).2 <| by simp_rw [map_add, FreeAddMonoid.lift_eval_of, (f m).map_add]\n      | _, _, Eqv.of_smul r m n =>\n        (AddCon.ker_rel _).2 <| by simp_rw [FreeAddMonoid.lift_eval_of, f.map_smul\u2082, (f m).map_smul]\n      | _, _, Eqv.add_comm x y =>\n        (AddCon.ker_rel _).2 <| by simp_rw [map_add, add_comm]", "start": [469, 1], "end": [487, 63], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.liftAux_tmul", "code": "theorem liftAux_tmul (m n) : liftAux f (m \u2297\u209c n) = f m n", "start": [490, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.liftAux.smul", "code": "@[simp]\ntheorem liftAux.smul (r : R) (x) : liftAux f (r \u2022 x) = r \u2022 liftAux f x", "start": [496, 1], "end": [500, 86], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift", "code": "def lift : M \u2297[R] N \u2192\u2097[R] P :=\n  { liftAux f with map_smul' := liftAux.smul }", "start": [505, 1], "end": [509, 47], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.tmul", "code": "@[simp]\ntheorem lift.tmul (x y) : lift f (x \u2297\u209c y) = f x y", "start": [514, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.tmul'", "code": "@[simp]\ntheorem lift.tmul' (x y) : (lift f).1 (x \u2297\u209c y) = f x y", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ext'", "code": "theorem ext' {g h : M \u2297[R] N \u2192\u2097[R] P} (H : \u2200 x y, g (x \u2297\u209c y) = h (x \u2297\u209c y)) : g = h", "start": [524, 1], "end": [527, 42], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.unique", "code": "theorem lift.unique {g : M \u2297[R] N \u2192\u2097[R] P} (H : \u2200 x y, g (x \u2297\u209c y) = f x y) : g = lift f", "start": [530, 1], "end": [531, 39], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift_mk", "code": "theorem lift_mk : lift (mk R M N) = LinearMap.id", "start": [534, 1], "end": [535, 40], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift_compr\u2082", "code": "theorem lift_compr\u2082 (g : P \u2192\u2097[R] Q) : lift (f.compr\u2082 g) = g.comp (lift f)", "start": [538, 1], "end": [539, 44], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift_mk_compr\u2082", "code": "theorem lift_mk_compr\u2082 (f : M \u2297 N \u2192\u2097[R] P) : lift ((mk R M N).compr\u2082 f) = f", "start": [542, 1], "end": [543, 49], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ext", "code": "theorem ext {g h : M \u2297 N \u2192\u2097[R] P} (H : (mk R M N).compr\u2082 g = (mk R M N).compr\u2082 h) : g = h", "start": [546, 1], "end": [553, 45], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.uncurry", "code": "def uncurry : (M \u2192\u2097[R] N \u2192\u2097[R] P) \u2192\u2097[R] M \u2297[R] N \u2192\u2097[R] P :=\n  LinearMap.flip <| lift <| LinearMap.lflip.comp (LinearMap.flip LinearMap.id)", "start": [562, 1], "end": [566, 79], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.uncurry_apply", "code": "@[simp]\ntheorem uncurry_apply (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) (n : N) :\n    uncurry R M N P f (m \u2297\u209c n) = f m n", "start": [571, 1], "end": [573, 96], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.equiv", "code": "def lift.equiv : (M \u2192\u2097[R] N \u2192\u2097[R] P) \u2243\u2097[R] M \u2297[R] N \u2192\u2097[R] P :=\n  { uncurry R M N P with\n    invFun := fun f => (mk R M N).compr\u2082 f\n    left_inv := fun _ => LinearMap.ext\u2082 fun _ _ => lift.tmul _ _\n    right_inv := fun _ => ext' fun _ _ => lift.tmul _ _ }", "start": [578, 1], "end": [585, 58], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.equiv_apply", "code": "@[simp]\ntheorem lift.equiv_apply (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) (n : N) :\n    lift.equiv R M N P f (m \u2297\u209c n) = f m n", "start": [588, 1], "end": [591, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift.equiv_symm_apply", "code": "@[simp]\ntheorem lift.equiv_symm_apply (f : M \u2297[R] N \u2192\u2097[R] P) (m : M) (n : N) :\n    (lift.equiv R M N P).symm f m n = f (m \u2297\u209c n)", "start": [594, 1], "end": [597, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lcurry", "code": "def lcurry : (M \u2297[R] N \u2192\u2097[R] P) \u2192\u2097[R] M \u2192\u2097[R] N \u2192\u2097[R] P :=\n  (lift.equiv R M N P).symm", "start": [600, 1], "end": [603, 28], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lcurry_apply", "code": "@[simp]\ntheorem lcurry_apply (f : M \u2297[R] N \u2192\u2097[R] P) (m : M) (n : N) : lcurry R M N P f m n = f (m \u2297\u209c n)", "start": [608, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.curry", "code": "def curry (f : M \u2297[R] N \u2192\u2097[R] P) : M \u2192\u2097[R] N \u2192\u2097[R] P :=\n  lcurry R M N P f", "start": [613, 1], "end": [616, 19], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.curry_apply", "code": "@[simp]\ntheorem curry_apply (f : M \u2297 N \u2192\u2097[R] P) (m : M) (n : N) : curry f m n = f (m \u2297\u209c n)", "start": [619, 1], "end": [621, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.curry_injective", "code": "theorem curry_injective : Function.Injective (curry : (M \u2297[R] N \u2192\u2097[R] P) \u2192 M \u2192\u2097[R] N \u2192\u2097[R] P)", "start": [624, 1], "end": [625, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ext_threefold", "code": "theorem ext_threefold {g h : (M \u2297[R] N) \u2297[R] P \u2192\u2097[R] Q}\n    (H : \u2200 x y z, g (x \u2297\u209c y \u2297\u209c z) = h (x \u2297\u209c y \u2297\u209c z)) : g = h", "start": [628, 1], "end": [631, 16], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ext_fourfold", "code": "theorem ext_fourfold {g h : ((M \u2297[R] N) \u2297[R] P) \u2297[R] Q \u2192\u2097[R] S}\n    (H : \u2200 w x y z, g (w \u2297\u209c x \u2297\u209c y \u2297\u209c z) = h (w \u2297\u209c x \u2297\u209c y \u2297\u209c z)) : g = h", "start": [635, 1], "end": [638, 18], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.ext_fourfold'", "code": "theorem ext_fourfold' {\u03c6 \u03c8 : (M \u2297[R] N) \u2297[R] P \u2297[R] Q \u2192\u2097[R] S}\n    (H : \u2200 w x y z, \u03c6 (w \u2297\u209c x \u2297\u209c (y \u2297\u209c z)) = \u03c8 (w \u2297\u209c x \u2297\u209c (y \u2297\u209c z))) : \u03c6 = \u03c8", "start": [641, 1], "end": [646, 18], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lid", "code": "protected def lid : R \u2297[R] M \u2243\u2097[R] M :=\n  LinearEquiv.ofLinear (lift <| LinearMap.lsmul R M) (mk R R M 1) (LinearMap.ext fun _ => by simp)\n    (ext' fun r m => by simp; rw [\u2190 tmul_smul, \u2190 smul_tmul, smul_eq_mul, mul_one])", "start": [657, 1], "end": [661, 83], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lid_tmul", "code": "@[simp]\ntheorem lid_tmul (m : M) (r : R) : (TensorProduct.lid R M : R \u2297 M \u2192 M) (r \u2297\u209c m) = r \u2022 m", "start": [666, 1], "end": [668, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lid_symm_apply", "code": "@[simp]\ntheorem lid_symm_apply (m : M) : (TensorProduct.lid R M).symm m = 1 \u2297\u209c m", "start": [671, 1], "end": [673, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.comm", "code": "protected def comm : M \u2297[R] N \u2243\u2097[R] N \u2297[R] M :=\n  LinearEquiv.ofLinear (lift (mk R N M).flip) (lift (mk R M N).flip) (ext' fun _ _ => rfl)\n    (ext' fun _ _ => rfl)", "start": [680, 1], "end": [684, 26], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.comm_tmul", "code": "@[simp]\ntheorem comm_tmul (m : M) (n : N) : (TensorProduct.comm R M N) (m \u2297\u209c n) = n \u2297\u209c m", "start": [687, 1], "end": [689, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.comm_symm_tmul", "code": "@[simp]\ntheorem comm_symm_tmul (m : M) (n : N) : (TensorProduct.comm R M N).symm (n \u2297\u209c m) = m \u2297\u209c n", "start": [692, 1], "end": [694, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift_comp_comm_eq", "code": "lemma lift_comp_comm_eq  (f : M \u2192\u2097[R] N \u2192\u2097[R] P) :\n    lift f \u2218\u2097 TensorProduct.comm R N M = lift f.flip :=\n  ext rfl", "start": [697, 1], "end": [699, 10], "kind": "mathlibtacticlemma"}, {"full_name": "TensorProduct.rid", "code": "protected def rid : M \u2297[R] R \u2243\u2097[R] M :=\n  LinearEquiv.trans (TensorProduct.comm R M R) (TensorProduct.lid R M)", "start": [706, 1], "end": [709, 71], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.rid_tmul", "code": "@[simp]\ntheorem rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m \u2297\u209c r) = r \u2022 m", "start": [714, 1], "end": [716, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.rid_symm_apply", "code": "@[simp]\ntheorem rid_symm_apply (m : M) : (TensorProduct.rid R M).symm m = m \u2297\u209c 1", "start": [719, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.assoc", "code": "protected def assoc : (M \u2297[R] N) \u2297[R] P \u2243\u2097[R] M \u2297[R] N \u2297[R] P := by\n  refine\n      LinearEquiv.ofLinear (lift <| lift <| comp (lcurry R _ _ _) <| mk _ _ _)\n        (lift <| comp (uncurry R _ _ _) <| curry <| mk _ _ _)\n        (ext <| LinearMap.ext fun m => ext' fun n p => ?_)\n        (ext <| flip_inj <| LinearMap.ext fun p => ext' fun m n => ?_) <;>\n    repeat'\n      first\n        |rw [lift.tmul]|rw [compr\u2082_apply]|rw [comp_apply]|rw [mk_apply]|rw [flip_apply]\n        |rw [lcurry_apply]|rw [uncurry_apply]|rw [curry_apply]|rw [id_apply]", "start": [730, 1], "end": [740, 77], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.assoc_tmul", "code": "@[simp]\ntheorem assoc_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P) (m \u2297\u209c n \u2297\u209c p) = m \u2297\u209c (n \u2297\u209c p)", "start": [745, 1], "end": [748, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.assoc_symm_tmul", "code": "@[simp]\ntheorem assoc_symm_tmul (m : M) (n : N) (p : P) :\n    (TensorProduct.assoc R M N P).symm (m \u2297\u209c (n \u2297\u209c p)) = m \u2297\u209c n \u2297\u209c p", "start": [751, 1], "end": [754, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map", "code": "def map (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) : M \u2297[R] N \u2192\u2097[R] P \u2297[R] Q :=\n  lift <| comp (compl\u2082 (mk _ _ _) g) f", "start": [757, 1], "end": [759, 39], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_tmul", "code": "@[simp]\ntheorem map_tmul (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) (m : M) (n : N) : map f g (m \u2297\u209c n) = f m \u2297\u209c g n", "start": [762, 1], "end": [764, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_comp_comm_eq", "code": "lemma map_comp_comm_eq (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    map f g \u2218\u2097 TensorProduct.comm R N M =\n      TensorProduct.comm R Q P \u2218\u2097 map g f :=\n  ext rfl", "start": [767, 1], "end": [770, 10], "kind": "mathlibtacticlemma"}, {"full_name": "TensorProduct.map_range_eq_span_tmul", "code": "theorem map_range_eq_span_tmul (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    range (map f g) = Submodule.span R { t | \u2203 m n, f m \u2297\u209c g n = t }", "start": [772, 1], "end": [783, 25], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.mapIncl", "code": "@[simp]\ndef mapIncl (p : Submodule R P) (q : Submodule R Q) : p \u2297[R] q \u2192\u2097[R] P \u2297[R] Q :=\n  map p.subtype q.subtype", "start": [786, 1], "end": [789, 26], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_comp", "code": "theorem map_comp (f\u2082 : P \u2192\u2097[R] P') (f\u2081 : M \u2192\u2097[R] P) (g\u2082 : Q \u2192\u2097[R] Q') (g\u2081 : N \u2192\u2097[R] Q) :\n    map (f\u2082.comp f\u2081) (g\u2082.comp g\u2081) = (map f\u2082 g\u2082).comp (map f\u2081 g\u2081)", "start": [798, 1], "end": [800, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lift_comp_map", "code": "theorem lift_comp_map (i : P \u2192\u2097[R] Q \u2192\u2097[R] Q') (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    (lift i).comp (map f g) = lift ((i.comp f).compl\u2082 g)", "start": [803, 1], "end": [805, 22], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_id", "code": "@[simp]\ntheorem map_id : map (id : M \u2192\u2097[R] M) (id : N \u2192\u2097[R] N) = .id", "start": [810, 1], "end": [813, 63], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_one", "code": "@[simp]\ntheorem map_one : map (1 : M \u2192\u2097[R] M) (1 : N \u2192\u2097[R] N) = 1", "start": [816, 1], "end": [818, 9], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_mul", "code": "theorem map_mul (f\u2081 f\u2082 : M \u2192\u2097[R] M) (g\u2081 g\u2082 : N \u2192\u2097[R] N) :\n    map (f\u2081 * f\u2082) (g\u2081 * g\u2082) = map f\u2081 g\u2081 * map f\u2082 g\u2082", "start": [821, 1], "end": [823, 23], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_pow", "code": "@[simp]\nprotected theorem map_pow (f : M \u2192\u2097[R] M) (g : N \u2192\u2097[R] N) (n : \u2115) :\n    map f g ^ n = map (f ^ n) (g ^ n)", "start": [826, 1], "end": [831, 39], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_add_left", "code": "theorem map_add_left (f\u2081 f\u2082 : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    map (f\u2081 + f\u2082) g = map f\u2081 g + map f\u2082 g", "start": [834, 1], "end": [837, 68], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_add_right", "code": "theorem map_add_right (f : M \u2192\u2097[R] P) (g\u2081 g\u2082 : N \u2192\u2097[R] Q) :\n    map f (g\u2081 + g\u2082) = map f g\u2081 + map f g\u2082", "start": [840, 1], "end": [843, 68], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_smul_left", "code": "theorem map_smul_left (r : R) (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) : map (r \u2022 f) g = r \u2022 map f g", "start": [846, 1], "end": [848, 81], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.map_smul_right", "code": "theorem map_smul_right (r : R) (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) : map f (r \u2022 g) = r \u2022 map f g", "start": [851, 1], "end": [853, 81], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.mapBilinear", "code": "def mapBilinear : (M \u2192\u2097[R] P) \u2192\u2097[R] (N \u2192\u2097[R] Q) \u2192\u2097[R] M \u2297[R] N \u2192\u2097[R] P \u2297[R] Q :=\n  LinearMap.mk\u2082 R map map_add_left map_smul_left map_add_right map_smul_right", "start": [858, 1], "end": [860, 78], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lTensorHomToHomLTensor", "code": "def lTensorHomToHomLTensor : P \u2297[R] (M \u2192\u2097[R] Q) \u2192\u2097[R] M \u2192\u2097[R] P \u2297[R] Q :=\n  TensorProduct.lift (llcomp R M Q _ \u2218\u2097 mk R P Q)", "start": [863, 1], "end": [865, 50], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.rTensorHomToHomRTensor", "code": "def rTensorHomToHomRTensor : (M \u2192\u2097[R] P) \u2297[R] Q \u2192\u2097[R] M \u2192\u2097[R] P \u2297[R] Q :=\n  TensorProduct.lift (llcomp R M P _ \u2218\u2097 (mk R P Q).flip).flip", "start": [868, 1], "end": [870, 62], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.homTensorHomMap", "code": "def homTensorHomMap : (M \u2192\u2097[R] P) \u2297[R] (N \u2192\u2097[R] Q) \u2192\u2097[R] M \u2297[R] N \u2192\u2097[R] P \u2297[R] Q :=\n  lift (mapBilinear R M N P Q)", "start": [873, 1], "end": [876, 31], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.mapBilinear_apply", "code": "@[simp]\ntheorem mapBilinear_apply (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) : mapBilinear R M N P Q f g = map f g", "start": [881, 1], "end": [883, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.lTensorHomToHomLTensor_apply", "code": "@[simp]\ntheorem lTensorHomToHomLTensor_apply (p : P) (f : M \u2192\u2097[R] Q) (m : M) :\n    lTensorHomToHomLTensor R M P Q (p \u2297\u209c f) m = p \u2297\u209c f m", "start": [886, 1], "end": [889, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.rTensorHomToHomRTensor_apply", "code": "@[simp]\ntheorem rTensorHomToHomRTensor_apply (f : M \u2192\u2097[R] P) (q : Q) (m : M) :\n    rTensorHomToHomRTensor R M P Q (f \u2297\u209c q) m = f m \u2297\u209c q", "start": [892, 1], "end": [895, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.homTensorHomMap_apply", "code": "@[simp]\ntheorem homTensorHomMap_apply (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    homTensorHomMap R M N P Q (f \u2297\u209c g) = map f g", "start": [898, 1], "end": [901, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.congr", "code": "def congr (f : M \u2243\u2097[R] P) (g : N \u2243\u2097[R] Q) : M \u2297[R] N \u2243\u2097[R] P \u2297[R] Q :=\n  LinearEquiv.ofLinear (map f g) (map f.symm g.symm)\n    (ext' fun m n => by simp)\n    (ext' fun m n => by simp)", "start": [906, 1], "end": [911, 30], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.congr_tmul", "code": "@[simp]\ntheorem congr_tmul (f : M \u2243\u2097[R] P) (g : N \u2243\u2097[R] Q) (m : M) (n : N) :\n    congr f g (m \u2297\u209c n) = f m \u2297\u209c g n", "start": [914, 1], "end": [917, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.congr_symm_tmul", "code": "@[simp]\ntheorem congr_symm_tmul (f : M \u2243\u2097[R] P) (g : N \u2243\u2097[R] Q) (p : P) (q : Q) :\n    (congr f g).symm (p \u2297\u209c q) = f.symm p \u2297\u209c g.symm q", "start": [920, 1], "end": [923, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftComm", "code": "def leftComm : M \u2297[R] N \u2297[R] P \u2243\u2097[R] N \u2297[R] M \u2297[R] P :=\n  let e\u2081 := (TensorProduct.assoc R M N P).symm\n  let e\u2082 := congr (TensorProduct.comm R M N) (1 : P \u2243\u2097[R] P)\n  let e\u2083 := TensorProduct.assoc R N M P\n  e\u2081 \u226a\u226b\u2097 (e\u2082 \u226a\u226b\u2097 e\u2083)", "start": [928, 1], "end": [933, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftComm_tmul", "code": "@[simp]\ntheorem leftComm_tmul (m : M) (n : N) (p : P) : leftComm R M N P (m \u2297\u209c (n \u2297\u209c p)) = n \u2297\u209c (m \u2297\u209c p)", "start": [938, 1], "end": [940, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.leftComm_symm_tmul", "code": "@[simp]\ntheorem leftComm_symm_tmul (m : M) (n : N) (p : P) :\n    (leftComm R M N P).symm (n \u2297\u209c (m \u2297\u209c p)) = m \u2297\u209c (n \u2297\u209c p)", "start": [943, 1], "end": [946, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorComm", "code": "def tensorTensorTensorComm : (M \u2297[R] N) \u2297[R] P \u2297[R] Q \u2243\u2097[R] (M \u2297[R] P) \u2297[R] N \u2297[R] Q :=\n  let e\u2081 := TensorProduct.assoc R M N (P \u2297[R] Q)\n  let e\u2082 := congr (1 : M \u2243\u2097[R] M) (leftComm R N P Q)\n  let e\u2083 := (TensorProduct.assoc R M P (N \u2297[R] Q)).symm\n  e\u2081 \u226a\u226b\u2097 (e\u2082 \u226a\u226b\u2097 e\u2083)", "start": [951, 1], "end": [965, 21], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorComm_tmul", "code": "@[simp]\ntheorem tensorTensorTensorComm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorComm R M N P Q (m \u2297\u209c n \u2297\u209c (p \u2297\u209c q)) = m \u2297\u209c p \u2297\u209c (n \u2297\u209c q)", "start": [970, 1], "end": [973, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorComm_symm", "code": "@[simp]\ntheorem tensorTensorTensorComm_symm :\n    (tensorTensorTensorComm R M N P Q).symm = tensorTensorTensorComm R M P N Q", "start": [977, 1], "end": [980, 14], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorAssoc", "code": "def tensorTensorTensorAssoc : (M \u2297[R] N) \u2297[R] P \u2297[R] Q \u2243\u2097[R] (M \u2297[R] N \u2297[R] P) \u2297[R] Q :=\n  (TensorProduct.assoc R (M \u2297[R] N) P Q).symm \u226a\u226b\u2097\n    congr (TensorProduct.assoc R M N P) (1 : Q \u2243\u2097[R] Q)", "start": [985, 1], "end": [995, 56], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorAssoc_tmul", "code": "@[simp]\ntheorem tensorTensorTensorAssoc_tmul (m : M) (n : N) (p : P) (q : Q) :\n    tensorTensorTensorAssoc R M N P Q (m \u2297\u209c n \u2297\u209c (p \u2297\u209c q)) = m \u2297\u209c (n \u2297\u209c p) \u2297\u209c q", "start": [1000, 1], "end": [1003, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tensorTensorTensorAssoc_symm_tmul", "code": "@[simp]\ntheorem tensorTensorTensorAssoc_symm_tmul (m : M) (n : N) (p : P) (q : Q) :\n    (tensorTensorTensorAssoc R M N P Q).symm (m \u2297\u209c (n \u2297\u209c p) \u2297\u209c q) = m \u2297\u209c n \u2297\u209c (p \u2297\u209c q)", "start": [1006, 1], "end": [1009, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor", "code": "def lTensor (f : N \u2192\u2097[R] P) : M \u2297[R] N \u2192\u2097[R] M \u2297[R] P :=\n  TensorProduct.map id f", "start": [1019, 1], "end": [1021, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor", "code": "def rTensor (f : N \u2192\u2097[R] P) : N \u2297[R] M \u2192\u2097[R] P \u2297[R] M :=\n  TensorProduct.map f id", "start": [1024, 1], "end": [1026, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_tmul", "code": "@[simp]\ntheorem lTensor_tmul (m : M) (n : N) : f.lTensor M (m \u2297\u209c n) = m \u2297\u209c f n", "start": [1031, 1], "end": [1033, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_tmul", "code": "@[simp]\ntheorem rTensor_tmul (m : M) (n : N) : f.rTensor M (n \u2297\u209c m) = f n \u2297\u209c m", "start": [1036, 1], "end": [1038, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comm_comp_rTensor_comp_comm_eq", "code": "lemma comm_comp_rTensor_comp_comm_eq (g : N \u2192\u2097[R] P) :\n    TensorProduct.comm R P Q \u2218\u2097 rTensor Q g \u2218\u2097 TensorProduct.comm R Q N =\n      lTensor Q g :=\n  TensorProduct.ext rfl", "start": [1041, 1], "end": [1044, 24], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.comm_comp_lTensor_comp_comm_eq", "code": "lemma comm_comp_lTensor_comp_comm_eq (g : N \u2192\u2097[R] P) :\n    TensorProduct.comm R Q P \u2218\u2097 lTensor Q g \u2218\u2097 TensorProduct.comm R N Q =\n      rTensor Q g :=\n  TensorProduct.ext rfl", "start": [1046, 1], "end": [1049, 24], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.lTensorHom", "code": "def lTensorHom : (N \u2192\u2097[R] P) \u2192\u2097[R] M \u2297[R] N \u2192\u2097[R] M \u2297[R] P where\n  toFun := lTensor M\n  map_add' f g := by\n    ext x y\n    simp only [compr\u2082_apply, mk_apply, add_apply, lTensor_tmul, tmul_add]\n  map_smul' r f := by\n    dsimp\n    ext x y\n    simp only [compr\u2082_apply, mk_apply, tmul_smul, smul_apply, lTensor_tmul]", "start": [1055, 1], "end": [1064, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensorHom", "code": "def rTensorHom : (N \u2192\u2097[R] P) \u2192\u2097[R] N \u2297[R] M \u2192\u2097[R] P \u2297[R] M where\n  toFun f := f.rTensor M\n  map_add' f g := by\n    ext x y\n    simp only [compr\u2082_apply, mk_apply, add_apply, rTensor_tmul, add_tmul]\n  map_smul' r f := by\n    dsimp\n    ext x y\n    simp only [compr\u2082_apply, mk_apply, smul_tmul, tmul_smul, smul_apply, rTensor_tmul]", "start": [1067, 1], "end": [1076, 87], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_lTensorHom", "code": "@[simp]\ntheorem coe_lTensorHom : (lTensorHom M : (N \u2192\u2097[R] P) \u2192 M \u2297[R] N \u2192\u2097[R] M \u2297[R] P) = lTensor M", "start": [1079, 1], "end": [1081, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_rTensorHom", "code": "@[simp]\ntheorem coe_rTensorHom : (rTensorHom M : (N \u2192\u2097[R] P) \u2192 N \u2297[R] M \u2192\u2097[R] P \u2297[R] M) = rTensor M", "start": [1084, 1], "end": [1086, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_add", "code": "@[simp]\ntheorem lTensor_add (f g : N \u2192\u2097[R] P) : (f + g).lTensor M = f.lTensor M + g.lTensor M", "start": [1089, 1], "end": [1091, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_add", "code": "@[simp]\ntheorem rTensor_add (f g : N \u2192\u2097[R] P) : (f + g).rTensor M = f.rTensor M + g.rTensor M", "start": [1094, 1], "end": [1096, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_zero", "code": "@[simp]\ntheorem lTensor_zero : lTensor M (0 : N \u2192\u2097[R] P) = 0", "start": [1099, 1], "end": [1101, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_zero", "code": "@[simp]\ntheorem rTensor_zero : rTensor M (0 : N \u2192\u2097[R] P) = 0", "start": [1104, 1], "end": [1106, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_smul", "code": "@[simp]\ntheorem lTensor_smul (r : R) (f : N \u2192\u2097[R] P) : (r \u2022 f).lTensor M = r \u2022 f.lTensor M", "start": [1109, 1], "end": [1111, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_smul", "code": "@[simp]\ntheorem rTensor_smul (r : R) (f : N \u2192\u2097[R] P) : (r \u2022 f).rTensor M = r \u2022 f.rTensor M", "start": [1114, 1], "end": [1116, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_comp", "code": "theorem lTensor_comp : (g.comp f).lTensor M = (g.lTensor M).comp (f.lTensor M)", "start": [1119, 1], "end": [1121, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_comp_apply", "code": "theorem lTensor_comp_apply (x : M \u2297[R] N) :\n    (g.comp f).lTensor M x = (g.lTensor M) ((f.lTensor M) x)", "start": [1124, 1], "end": [1125, 100], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_comp", "code": "theorem rTensor_comp : (g.comp f).rTensor M = (g.rTensor M).comp (f.rTensor M)", "start": [1128, 1], "end": [1130, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_comp_apply", "code": "theorem rTensor_comp_apply (x : N \u2297[R] M) :\n    (g.comp f).rTensor M x = (g.rTensor M) ((f.rTensor M) x)", "start": [1133, 1], "end": [1134, 100], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_mul", "code": "theorem lTensor_mul (f g : Module.End R N) : (f * g).lTensor M = f.lTensor M * g.lTensor M", "start": [1137, 1], "end": [1138, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_mul", "code": "theorem rTensor_mul (f g : Module.End R N) : (f * g).rTensor M = f.rTensor M * g.rTensor M", "start": [1141, 1], "end": [1142, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_id", "code": "@[simp]\ntheorem lTensor_id : (id : N \u2192\u2097[R] N).lTensor M = id", "start": [1147, 1], "end": [1149, 9], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_id_apply", "code": "theorem lTensor_id_apply (x : M \u2297[R] N) : (LinearMap.id : N \u2192\u2097[R] N).lTensor M x = x", "start": [1153, 1], "end": [1154, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_id", "code": "@[simp]\ntheorem rTensor_id : (id : N \u2192\u2097[R] N).rTensor M = id", "start": [1157, 1], "end": [1159, 9], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_id_apply", "code": "theorem rTensor_id_apply (x : N \u2297[R] M) : (LinearMap.id : N \u2192\u2097[R] N).rTensor M x = x", "start": [1163, 1], "end": [1164, 34], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_comp_rTensor", "code": "@[simp]\ntheorem lTensor_comp_rTensor (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    (g.lTensor P).comp (f.rTensor N) = map f g", "start": [1169, 1], "end": [1172, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_comp_lTensor", "code": "@[simp]\ntheorem rTensor_comp_lTensor (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    (f.rTensor Q).comp (g.lTensor M) = map f g", "start": [1175, 1], "end": [1178, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_comp_rTensor", "code": "@[simp]\ntheorem map_comp_rTensor (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) (f' : S \u2192\u2097[R] M) :\n    (map f g).comp (f'.rTensor _) = map (f.comp f') g", "start": [1181, 1], "end": [1184, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_comp_lTensor", "code": "@[simp]\ntheorem map_comp_lTensor (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) (g' : S \u2192\u2097[R] N) :\n    (map f g).comp (g'.lTensor _) = map f (g.comp g')", "start": [1187, 1], "end": [1190, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_comp_map", "code": "@[simp]\ntheorem rTensor_comp_map (f' : P \u2192\u2097[R] S) (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    (f'.rTensor _).comp (map f g) = map (f'.comp f) g", "start": [1193, 1], "end": [1196, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_comp_map", "code": "@[simp]\ntheorem lTensor_comp_map (g' : Q \u2192\u2097[R] S) (f : M \u2192\u2097[R] P) (g : N \u2192\u2097[R] Q) :\n    (g'.lTensor _).comp (map f g) = map f (g'.comp g)", "start": [1199, 1], "end": [1202, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_pow", "code": "@[simp]\ntheorem rTensor_pow (f : M \u2192\u2097[R] M) (n : \u2115) : f.rTensor N ^ n = (f ^ n).rTensor N", "start": [1207, 1], "end": [1210, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_pow", "code": "@[simp]\ntheorem lTensor_pow (f : N \u2192\u2097[R] N) (n : \u2115) : f.lTensor M ^ n = (f ^ n).lTensor M", "start": [1213, 1], "end": [1216, 20], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.Neg.aux", "code": "def Neg.aux : M \u2297[R] N \u2192\u2097[R] M \u2297[R] N :=\n  lift <| (mk R M N).comp (-LinearMap.id)", "start": [1238, 1], "end": [1240, 42], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.neg", "code": "instance neg : Neg (M \u2297[R] N) where\n  neg := Neg.aux R", "start": [1247, 1], "end": [1248, 19], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.add_left_neg", "code": "protected theorem add_left_neg (x : M \u2297[R] N) : -x + x = 0", "start": [1250, 1], "end": [1261, 26], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.addCommGroup", "code": "instance addCommGroup : AddCommGroup (M \u2297[R] N) :=\n  { TensorProduct.addCommMonoid with\n    neg := Neg.neg\n    sub := _\n    sub_eq_add_neg := fun _ _ => rfl\n    add_left_neg := fun x => TensorProduct.add_left_neg x\n    zsmul := fun n v => n \u2022 v\n    zsmul_zero' := by simp [TensorProduct.zero_smul]\n    zsmul_succ' := by simp [Nat.succ_eq_one_add, TensorProduct.one_smul, TensorProduct.add_smul]\n    zsmul_neg' := fun n x => by\n      change (-n.succ : \u2124) \u2022 x = -(((n : \u2124) + 1) \u2022 x)\n      rw [\u2190 zero_add (_ \u2022 x), \u2190 TensorProduct.add_left_neg ((n.succ : \u2124) \u2022 x), add_assoc,\n        \u2190 add_smul, \u2190 sub_eq_add_neg, sub_self, zero_smul, add_zero]\n      rfl }", "start": [1264, 1], "end": [1277, 12], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.neg_tmul", "code": "theorem neg_tmul (m : M) (n : N) : (-m) \u2297\u209c n = -m \u2297\u209c[R] n", "start": [1279, 1], "end": [1280, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_neg", "code": "theorem tmul_neg (m : M) (n : N) : m \u2297\u209c (-n) = -m \u2297\u209c[R] n", "start": [1283, 1], "end": [1284, 25], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.tmul_sub", "code": "theorem tmul_sub (m : M) (n\u2081 n\u2082 : N) : m \u2297\u209c (n\u2081 - n\u2082) = m \u2297\u209c[R] n\u2081 - m \u2297\u209c[R] n\u2082", "start": [1287, 1], "end": [1288, 27], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.sub_tmul", "code": "theorem sub_tmul (m\u2081 m\u2082 : M) (n : N) : (m\u2081 - m\u2082) \u2297\u209c n = m\u2081 \u2297\u209c[R] n - m\u2082 \u2297\u209c[R] n", "start": [1291, 1], "end": [1292, 28], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.CompatibleSMul.int", "code": "instance CompatibleSMul.int : CompatibleSMul R \u2124 M N :=\n  \u27e8fun r m n =>\n    Int.induction_on r (by simp) (fun r ih => by simpa [add_smul, tmul_add, add_tmul] using ih)\n      fun r ih => by simpa [sub_smul, tmul_sub, sub_tmul] using ih\u27e9", "start": [1295, 1], "end": [1306, 68], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.CompatibleSMul.unit", "code": "instance CompatibleSMul.unit {S} [Monoid S] [DistribMulAction S M] [DistribMulAction S N]\n    [CompatibleSMul R S M N] : CompatibleSMul R S\u02e3 M N :=\n  \u27e8fun s m n => (CompatibleSMul.smul_tmul (s : S) m n : _)\u27e9", "start": [1309, 1], "end": [1311, 60], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_sub", "code": "@[simp]\ntheorem lTensor_sub (f g : N \u2192\u2097[R] P) : (f - g).lTensor M = f.lTensor M - g.lTensor M", "start": [1318, 1], "end": [1321, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_sub", "code": "@[simp]\ntheorem rTensor_sub (f g : N \u2192\u2097[R] P) : (f - g).rTensor M = f.rTensor M - g.rTensor M", "start": [1324, 1], "end": [1327, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.lTensor_neg", "code": "@[simp]\ntheorem lTensor_neg (f : N \u2192\u2097[R] P) : (-f).lTensor M = -f.lTensor M", "start": [1330, 1], "end": [1333, 60], "kind": "commanddeclaration"}, {"full_name": "LinearMap.rTensor_neg", "code": "@[simp]\ntheorem rTensor_neg (f : N \u2192\u2097[R] P) : (-f).rTensor M = -f.rTensor M", "start": [1336, 1], "end": [1339, 60], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Hom/NonUnitalAlg.lean", "imports": ["Mathlib/Algebra/Algebra/Hom.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "NonUnitalAlgHom", "code": "structure NonUnitalAlgHom [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n  [NonUnitalNonAssocSemiring B] [DistribMulAction R B] extends A \u2192+[R] B, A \u2192\u2099* B", "start": [53, 1], "end": [56, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHomClass", "code": "class NonUnitalAlgHomClass (F : Type*) (R : outParam (Type*)) (A : outParam (Type*))\n  (B : outParam (Type*)) [Monoid R] [NonUnitalNonAssocSemiring A] [NonUnitalNonAssocSemiring B]\n  [DistribMulAction R A] [DistribMulAction R B] extends DistribMulActionHomClass F R A B,\n  MulHomClass F A B", "start": [67, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHomClass.toNonUnitalRingHomClass", "code": "instance (priority := 100) toNonUnitalRingHomClass {F R A B : Type*}\n    [Monoid R] [NonUnitalNonAssocSemiring A] [DistribMulAction R A]\n    [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n    [NonUnitalAlgHomClass F R A B] : NonUnitalRingHomClass F A B :=\n  { \u2039NonUnitalAlgHomClass F R A B\u203a with coe := (\u21d1) }", "start": [82, 1], "end": [86, 53], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHomClass.toNonUnitalAlgHom", "code": "@[coe]\ndef toNonUnitalAlgHom {F R A B : Type*} [Monoid R] [NonUnitalNonAssocSemiring A]\n    [DistribMulAction R A] [NonUnitalNonAssocSemiring B] [DistribMulAction R B]\n    [NonUnitalAlgHomClass F R A B] (f : F) : A \u2192\u2099\u2090[R] B :=\n  { (f : A \u2192\u2099+* B) with\n    map_smul' := map_smul f }", "start": [96, 1], "end": [103, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : A \u2192\u2099\u2090[R] B) : f.toFun = \u21d1f", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.Simps.apply", "code": "def Simps.apply (f : A \u2192\u2099\u2090[R] B) : A \u2192 B := f", "start": [136, 1], "end": [137, 46], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_coe", "code": "@[simp]\nprotected theorem coe_coe {F : Type*} [NonUnitalAlgHomClass F R A B] (f : F) :\n    \u21d1(f : A \u2192\u2099\u2090[R] B) = f", "start": [142, 1], "end": [145, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_injective", "code": "theorem coe_injective : @Function.Injective (A \u2192\u2099\u2090[R] B) (A \u2192 B) (\u2191)", "start": [148, 1], "end": [149, 52], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.ext", "code": "@[ext]\ntheorem ext {f g : A \u2192\u2099\u2090[R] B} (h : \u2200 x, f x = g x) : f = g", "start": [161, 1], "end": [163, 28], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.ext_iff", "code": "theorem ext_iff {f g : A \u2192\u2099\u2090[R] B} : f = g \u2194 \u2200 x, f x = g x", "start": [166, 1], "end": [169, 14], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.congr_fun", "code": "theorem congr_fun {f g : A \u2192\u2099\u2090[R] B} (h : f = g) (x : A) : f x = g x", "start": [172, 1], "end": [173, 10], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : A \u2192 B) (h\u2081 h\u2082 h\u2083 h\u2084) : \u21d1(\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9 : A \u2192\u2099\u2090[R] B) = f", "start": [176, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.mk_coe", "code": "@[simp]\ntheorem mk_coe (f : A \u2192\u2099\u2090[R] B) (h\u2081 h\u2082 h\u2083 h\u2084) : (\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9 : A \u2192\u2099\u2090[R] B) = f", "start": [181, 1], "end": [183, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.toDistribMulActionHom_eq_coe", "code": "@[simp]\ntheorem toDistribMulActionHom_eq_coe (f : A \u2192\u2099\u2090[R] B) : f.toDistribMulActionHom = \u2191f", "start": [192, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.toMulHom_eq_coe", "code": "@[simp]\ntheorem toMulHom_eq_coe (f : A \u2192\u2099\u2090[R] B) : f.toMulHom = \u2191f", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_to_distribMulActionHom", "code": "@[simp, norm_cast]\ntheorem coe_to_distribMulActionHom (f : A \u2192\u2099\u2090[R] B) : \u21d1(f : A \u2192+[R] B) = f", "start": [202, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_to_mulHom", "code": "@[simp, norm_cast]\ntheorem coe_to_mulHom (f : A \u2192\u2099\u2090[R] B) : \u21d1(f : A \u2192\u2099* B) = f", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.to_distribMulActionHom_injective", "code": "theorem to_distribMulActionHom_injective {f g : A \u2192\u2099\u2090[R] B}\n    (h : (f : A \u2192+[R] B) = (g : A \u2192+[R] B)) : f = g", "start": [212, 1], "end": [215, 42], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.to_mulHom_injective", "code": "theorem to_mulHom_injective {f g : A \u2192\u2099\u2090[R] B} (h : (f : A \u2192\u2099* B) = (g : A \u2192\u2099* B)) : f = g", "start": [218, 1], "end": [220, 30], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_distribMulActionHom_mk", "code": "@[norm_cast]\ntheorem coe_distribMulActionHom_mk (f : A \u2192\u2099\u2090[R] B) (h\u2081 h\u2082 h\u2083 h\u2084) :\n    ((\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9 : A \u2192\u2099\u2090[R] B) : A \u2192+[R] B) = \u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9", "start": [223, 1], "end": [226, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_mulHom_mk", "code": "@[norm_cast]\ntheorem coe_mulHom_mk (f : A \u2192\u2099\u2090[R] B) (h\u2081 h\u2082 h\u2083 h\u2084) :\n    ((\u27e8\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9, h\u2084\u27e9 : A \u2192\u2099\u2090[R] B) : A \u2192\u2099* B) = \u27e8f, h\u2084\u27e9", "start": [229, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.map_smul", "code": "protected theorem map_smul (f : A \u2192\u2099\u2090[R] B) (c : R) (x : A) : f (c \u2022 x) = c \u2022 f x", "start": [236, 1], "end": [237, 17], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.map_add", "code": "protected theorem map_add (f : A \u2192\u2099\u2090[R] B) (x y : A) : f (x + y) = f x + f y", "start": [241, 1], "end": [242, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.map_mul", "code": "protected theorem map_mul (f : A \u2192\u2099\u2090[R] B) (x y : A) : f (x * y) = f x * f y", "start": [246, 1], "end": [247, 16], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.map_zero", "code": "protected theorem map_zero (f : A \u2192\u2099\u2090[R] B) : f 0 = 0", "start": [251, 1], "end": [252, 13], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.id", "code": "protected def id (R A : Type*) [Monoid R] [NonUnitalNonAssocSemiring A]\n    [DistribMulAction R A] : A \u2192\u2099\u2090[R] A :=\n  { NonUnitalRingHom.id A with\n    toFun := id\n    map_smul' := fun _ _ => rfl }", "start": [255, 1], "end": [260, 34], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(NonUnitalAlgHom.id R A) = id", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u21d1(0 : A \u2192\u2099\u2090[R] B) = 0", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_one", "code": "@[simp]\ntheorem coe_one : ((1 : A \u2192\u2099\u2090[R] A) : A \u2192 A) = id", "start": [277, 1], "end": [279, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.zero_apply", "code": "theorem zero_apply (a : A) : (0 : A \u2192\u2099\u2090[R] B) a = 0", "start": [282, 1], "end": [283, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.one_apply", "code": "theorem one_apply (a : A) : (1 : A \u2192\u2099\u2090[R] A) a = a", "start": [286, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.comp", "code": "def comp (f : B \u2192\u2099\u2090[R] C) (g : A \u2192\u2099\u2090[R] B) : A \u2192\u2099\u2090[R] C :=\n  { (f : B \u2192\u2099* C).comp (g : A \u2192\u2099* B), (f : B \u2192+[R] C).comp (g : A \u2192+[R] B) with }", "start": [293, 1], "end": [295, 82], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_comp", "code": "@[simp, norm_cast]\ntheorem coe_comp (f : B \u2192\u2099\u2090[R] C) (g : A \u2192\u2099\u2090[R] B) :\n    \u21d1(f.comp g) = (\u21d1f) \u2218 (\u21d1g)", "start": [298, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.comp_apply", "code": "theorem comp_apply (f : B \u2192\u2099\u2090[R] C) (g : A \u2192\u2099\u2090[R] B) (x : A) : f.comp g x = f (g x)", "start": [304, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.inverse", "code": "def inverse (f : A \u2192\u2099\u2090[R] B) (g : B \u2192 A) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : B \u2192\u2099\u2090[R] A :=\n  { (f : A \u2192\u2099* B).inverse g h\u2081 h\u2082, (f : A \u2192+[R] B).inverse g h\u2081 h\u2082 with }", "start": [308, 1], "end": [311, 74], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_inverse", "code": "@[simp]\ntheorem coe_inverse (f : A \u2192\u2099\u2090[R] B) (g : B \u2192 A) (h\u2081 : Function.LeftInverse g f)\n    (h\u2082 : Function.RightInverse g f) : (inverse f g h\u2081 h\u2082 : B \u2192 A) = g", "start": [314, 1], "end": [317, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.fst", "code": "@[simps]\ndef fst : A \u00d7 B \u2192\u2099\u2090[R] A where\n  toFun := Prod.fst\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [329, 1], "end": [336, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.snd", "code": "@[simps]\ndef snd : A \u00d7 B \u2192\u2099\u2090[R] B where\n  toFun := Prod.snd\n  map_zero' := rfl\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [339, 1], "end": [346, 22], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.prod", "code": "@[simps]\ndef prod (f : A \u2192\u2099\u2090[R] B) (g : A \u2192\u2099\u2090[R] C) : A \u2192\u2099\u2090[R] B \u00d7 C\n    where\n  toFun := Pi.prod f g\n  map_zero' := by simp only [Pi.prod, Prod.zero_eq_mk, map_zero]\n  map_add' x y := by simp only [Pi.prod, Prod.mk_add_mk, map_add]\n  map_mul' x y := by simp only [Pi.prod, Prod.mk_mul_mk, map_mul]\n  map_smul' c x := by simp only [Pi.prod, Prod.smul_mk, map_smul, RingHom.id_apply]", "start": [351, 1], "end": [359, 84], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_prod", "code": "theorem coe_prod (f : A \u2192\u2099\u2090[R] B) (g : A \u2192\u2099\u2090[R] C) : \u21d1(f.prod g) = Pi.prod f g", "start": [362, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.fst_prod", "code": "@[simp]\ntheorem fst_prod (f : A \u2192\u2099\u2090[R] B) (g : A \u2192\u2099\u2090[R] C) : (fst R B C).comp (prod f g) = f", "start": [366, 1], "end": [368, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.snd_prod", "code": "@[simp]\ntheorem snd_prod (f : A \u2192\u2099\u2090[R] B) (g : A \u2192\u2099\u2090[R] C) : (snd R B C).comp (prod f g) = g", "start": [371, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.prod_fst_snd", "code": "@[simp]\ntheorem prod_fst_snd : prod (fst R A B) (snd R A B) = 1", "start": [376, 1], "end": [378, 32], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.prodEquiv", "code": "@[simps]\ndef prodEquiv : (A \u2192\u2099\u2090[R] B) \u00d7 (A \u2192\u2099\u2090[R] C) \u2243 (A \u2192\u2099\u2090[R] B \u00d7 C)\n    where\n  toFun f := f.1.prod f.2\n  invFun f := ((fst _ _ _).comp f, (snd _ _ _).comp f)\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [381, 1], "end": [389, 21], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.inl", "code": "def inl : A \u2192\u2099\u2090[R] A \u00d7 B :=\n  prod 1 0", "start": [394, 1], "end": [396, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.inr", "code": "def inr : B \u2192\u2099\u2090[R] A \u00d7 B :=\n  prod 0 1", "start": [399, 1], "end": [401, 11], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_inl", "code": "@[simp]\ntheorem coe_inl : (inl R A B : A \u2192 A \u00d7 B) = fun x => (x, 0)", "start": [406, 1], "end": [408, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.inl_apply", "code": "theorem inl_apply (x : A) : inl R A B x = (x, 0)", "start": [411, 1], "end": [412, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_inr", "code": "@[simp]\ntheorem coe_inr : (inr R A B : B \u2192 A \u00d7 B) = Prod.mk 0", "start": [415, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.inr_apply", "code": "theorem inr_apply (x : B) : inr R A B x = (0, x)", "start": [420, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toNonUnitalAlgHom", "code": "@[coe]\ndef toNonUnitalAlgHom (f : A \u2192\u2090[R] B) : A \u2192\u2099\u2090[R] B :=\n  { f with map_smul' := map_smul f }", "start": [440, 1], "end": [443, 37], "kind": "commanddeclaration"}, {"full_name": "AlgHom.NonUnitalAlgHom.hasCoe", "code": "instance NonUnitalAlgHom.hasCoe : CoeOut (A \u2192\u2090[R] B) (A \u2192\u2099\u2090[R] B) :=\n  \u27e8toNonUnitalAlgHom\u27e9", "start": [446, 1], "end": [447, 22], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toNonUnitalAlgHom_eq_coe", "code": "@[simp]\ntheorem toNonUnitalAlgHom_eq_coe (f : A \u2192\u2090[R] B) : f.toNonUnitalAlgHom = f", "start": [450, 1], "end": [452, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_to_nonUnitalAlgHom", "code": "@[simp, norm_cast]\ntheorem coe_to_nonUnitalAlgHom (f : A \u2192\u2090[R] B) : \u21d1(f.toNonUnitalAlgHom) = \u21d1f", "start": [455, 1], "end": [457, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Kleene.lean", "imports": ["Mathlib/Algebra/Ring/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Ring/Pi.lean", "Mathlib/Algebra/Order/Ring/Canonical.lean", "Mathlib/Order/Hom/CompleteLattice.lean"], "premises": [{"full_name": "IdemSemiring", "code": "class IdemSemiring (\u03b1 : Type u) extends Semiring \u03b1, SemilatticeSup \u03b1 where\n  protected sup := (\u00b7 + \u00b7)\n  protected add_eq_sup : \u2200 a b : \u03b1, a + b = a \u2294 b := by\n    intros\n    rfl\n  protected bot : \u03b1 := 0\n  protected bot_le : \u2200 a, bot \u2264 a", "start": [59, 1], "end": [67, 34], "kind": "commanddeclaration"}, {"full_name": "IdemCommSemiring", "code": "class IdemCommSemiring (\u03b1 : Type u) extends CommSemiring \u03b1, IdemSemiring \u03b1", "start": [70, 1], "end": [72, 75], "kind": "commanddeclaration"}, {"full_name": "KStar", "code": "class KStar (\u03b1 : Type*) where\n  protected kstar : \u03b1 \u2192 \u03b1", "start": [75, 1], "end": [77, 26], "kind": "commanddeclaration"}, {"full_name": "KleeneAlgebra", "code": "class KleeneAlgebra (\u03b1 : Type*) extends IdemSemiring \u03b1, KStar \u03b1 where\n  protected one_le_kstar : \u2200 a : \u03b1, 1 \u2264 a\u2217\n  protected mul_kstar_le_kstar : \u2200 a : \u03b1, a * a\u2217 \u2264 a\u2217\n  protected kstar_mul_le_kstar : \u2200 a : \u03b1, a\u2217 * a \u2264 a\u2217\n  protected mul_kstar_le_self : \u2200 a b : \u03b1, b * a \u2264 b \u2192 b * a\u2217 \u2264 b\n  protected kstar_mul_le_self : \u2200 a b : \u03b1, a * b \u2264 b \u2192 a\u2217 * b \u2264 b", "start": [84, 1], "end": [96, 66], "kind": "commanddeclaration"}, {"full_name": "IdemSemiring.toOrderBot", "code": "instance (priority := 100) IdemSemiring.toOrderBot [IdemSemiring \u03b1] : OrderBot \u03b1 :=\n  { \u2039IdemSemiring \u03b1\u203a with }", "start": [100, 1], "end": [101, 28], "kind": "commanddeclaration"}, {"full_name": "IdemSemiring.ofSemiring", "code": "@[reducible]\ndef IdemSemiring.ofSemiring [Semiring \u03b1] (h : \u2200 a : \u03b1, a + a = a) : IdemSemiring \u03b1 :=\n  { \u2039Semiring \u03b1\u203a with\n    le := fun a b \u21a6 a + b = b\n    le_refl := h\n    le_trans := fun a b c hab hbc \u21a6 by\n      simp only\n      rw [\u2190 hbc, \u2190 add_assoc, hab]\n    le_antisymm := fun a b hab hba \u21a6 by rwa [\u2190 hba, add_comm]\n    sup := (\u00b7 + \u00b7)\n    le_sup_left := fun a b \u21a6 by\n      simp only\n      rw [\u2190 add_assoc, h]\n    le_sup_right := fun a b \u21a6 by\n      simp only\n      rw [add_comm, add_assoc, h]\n    sup_le := fun a b c hab hbc \u21a6 by\n      simp only\n      rwa [add_assoc, hbc]\n    bot := 0\n    bot_le := zero_add }", "start": [105, 1], "end": [126, 25], "kind": "commanddeclaration"}, {"full_name": "add_eq_sup", "code": "theorem add_eq_sup (a b : \u03b1) : a + b = a \u2294 b", "start": [133, 1], "end": [134, 30], "kind": "commanddeclaration"}, {"full_name": "add_idem", "code": "theorem add_idem (a : \u03b1) : a + a = a", "start": [141, 1], "end": [141, 48], "kind": "commanddeclaration"}, {"full_name": "nsmul_eq_self", "code": "theorem nsmul_eq_self : \u2200 {n : \u2115} (_ : n \u2260 0) (a : \u03b1), n \u2022 a = a", "start": [144, 1], "end": [147, 83], "kind": "commanddeclaration"}, {"full_name": "add_eq_left_iff_le", "code": "theorem add_eq_left_iff_le : a + b = a \u2194 b \u2264 a", "start": [150, 1], "end": [150, 58], "kind": "commanddeclaration"}, {"full_name": "add_eq_right_iff_le", "code": "theorem add_eq_right_iff_le : a + b = b \u2194 a \u2264 b", "start": [153, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "LE.le.add_eq_left", "code": "alias \u27e8_, LE.le.add_eq_left\u27e9 := add_eq_left_iff_le", "start": [156, 1], "end": [156, 51], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LE.le.add_eq_right", "code": "alias \u27e8_, LE.le.add_eq_right\u27e9 := add_eq_right_iff_le", "start": [159, 1], "end": [159, 53], "kind": "stdtacticaliasaliaslr"}, {"full_name": "add_le_iff", "code": "theorem add_le_iff : a + b \u2264 c \u2194 a \u2264 c \u2227 b \u2264 c", "start": [162, 1], "end": [162, 58], "kind": "commanddeclaration"}, {"full_name": "add_le", "code": "theorem add_le (ha : a \u2264 c) (hb : b \u2264 c) : a + b \u2264 c", "start": [165, 1], "end": [166, 24], "kind": "commanddeclaration"}, {"full_name": "IdemSemiring.toCanonicallyOrderedAddCommMonoid", "code": "instance (priority := 100) IdemSemiring.toCanonicallyOrderedAddCommMonoid :\n    CanonicallyOrderedAddCommMonoid \u03b1 :=\n  { \u2039IdemSemiring \u03b1\u203a with\n    add_le_add_left := fun a b hbc c \u21a6 by\n      simp_rw [add_eq_sup]\n      exact sup_le_sup_left hbc _\n    exists_add_of_le := fun h \u21a6 \u27e8_, h.add_eq_right.symm\u27e9\n    le_self_add := fun a b \u21a6 add_eq_right_iff_le.1 <| by rw [\u2190 add_assoc, add_idem] }", "start": [170, 1], "end": [177, 86], "kind": "commanddeclaration"}, {"full_name": "IdemSemiring.toCovariantClass_mul_le", "code": "instance (priority := 100) IdemSemiring.toCovariantClass_mul_le :\n    CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b c hbc \u21a6 add_eq_left_iff_le.1 <| by rw [\u2190 mul_add, hbc.add_eq_left]\u27e9", "start": [181, 1], "end": [183, 79], "kind": "commanddeclaration"}, {"full_name": "IdemSemiring.toCovariantClass_swap_mul_le", "code": "instance (priority := 100) IdemSemiring.toCovariantClass_swap_mul_le :\n    CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b c hbc \u21a6 add_eq_left_iff_le.1 <| by rw [\u2190 add_mul, hbc.add_eq_left]\u27e9", "start": [187, 1], "end": [189, 79], "kind": "commanddeclaration"}, {"full_name": "one_le_kstar", "code": "@[simp]\ntheorem one_le_kstar : 1 \u2264 a\u2217", "start": [198, 1], "end": [200, 31], "kind": "commanddeclaration"}, {"full_name": "mul_kstar_le_kstar", "code": "theorem mul_kstar_le_kstar : a * a\u2217 \u2264 a\u2217", "start": [203, 1], "end": [204, 37], "kind": "commanddeclaration"}, {"full_name": "kstar_mul_le_kstar", "code": "theorem kstar_mul_le_kstar : a\u2217 * a \u2264 a\u2217", "start": [207, 1], "end": [208, 37], "kind": "commanddeclaration"}, {"full_name": "mul_kstar_le_self", "code": "theorem mul_kstar_le_self : b * a \u2264 b \u2192 b * a\u2217 \u2264 b", "start": [211, 1], "end": [212, 38], "kind": "commanddeclaration"}, {"full_name": "kstar_mul_le_self", "code": "theorem kstar_mul_le_self : a * b \u2264 b \u2192 a\u2217 * b \u2264 b", "start": [215, 1], "end": [216, 38], "kind": "commanddeclaration"}, {"full_name": "mul_kstar_le", "code": "theorem mul_kstar_le (hb : b \u2264 c) (ha : c * a \u2264 c) : b * a\u2217 \u2264 c", "start": [219, 1], "end": [220, 57], "kind": "commanddeclaration"}, {"full_name": "kstar_mul_le", "code": "theorem kstar_mul_le (hb : b \u2264 c) (ha : a * c \u2264 c) : a\u2217 * b \u2264 c", "start": [223, 1], "end": [224, 56], "kind": "commanddeclaration"}, {"full_name": "kstar_le_of_mul_le_left", "code": "theorem kstar_le_of_mul_le_left (hb : 1 \u2264 b) : b * a \u2264 b \u2192 a\u2217 \u2264 b", "start": [227, 1], "end": [228, 30], "kind": "commanddeclaration"}, {"full_name": "kstar_le_of_mul_le_right", "code": "theorem kstar_le_of_mul_le_right (hb : 1 \u2264 b) : a * b \u2264 b \u2192 a\u2217 \u2264 b", "start": [231, 1], "end": [232, 30], "kind": "commanddeclaration"}, {"full_name": "le_kstar", "code": "@[simp]\ntheorem le_kstar : a \u2264 a\u2217", "start": [235, 1], "end": [237, 68], "kind": "commanddeclaration"}, {"full_name": "kstar_mono", "code": "@[mono]\ntheorem kstar_mono : Monotone (KStar.kstar : \u03b1 \u2192 \u03b1)", "start": [240, 1], "end": [243, 98], "kind": "commanddeclaration"}, {"full_name": "kstar_eq_one", "code": "@[simp]\ntheorem kstar_eq_one : a\u2217 = 1 \u2194 a \u2264 1", "start": [246, 1], "end": [249, 90], "kind": "commanddeclaration"}, {"full_name": "kstar_zero", "code": "@[simp]\ntheorem kstar_zero : (0 : \u03b1)\u2217 = 1", "start": [252, 1], "end": [254, 29], "kind": "commanddeclaration"}, {"full_name": "kstar_one", "code": "@[simp]\ntheorem kstar_one : (1 : \u03b1)\u2217 = 1", "start": [257, 1], "end": [259, 24], "kind": "commanddeclaration"}, {"full_name": "kstar_mul_kstar", "code": "@[simp]\ntheorem kstar_mul_kstar (a : \u03b1) : a\u2217 * a\u2217 = a\u2217", "start": [262, 1], "end": [264, 94], "kind": "commanddeclaration"}, {"full_name": "kstar_eq_self", "code": "@[simp]\ntheorem kstar_eq_self : a\u2217 = a \u2194 a * a = a \u2227 1 \u2264 a", "start": [267, 1], "end": [270, 68], "kind": "commanddeclaration"}, {"full_name": "kstar_idem", "code": "@[simp]\ntheorem kstar_idem (a : \u03b1) : a\u2217\u2217 = a\u2217", "start": [273, 1], "end": [275, 52], "kind": "commanddeclaration"}, {"full_name": "pow_le_kstar", "code": "@[simp]\ntheorem pow_le_kstar : \u2200 {n : \u2115}, a ^ n \u2264 a\u2217", "start": [278, 1], "end": [283, 69], "kind": "commanddeclaration"}, {"full_name": "Prod.instIdemSemiring", "code": "instance instIdemSemiring [IdemSemiring \u03b1] [IdemSemiring \u03b2] : IdemSemiring (\u03b1 \u00d7 \u03b2) :=\n  { Prod.instSemiring, Prod.semilatticeSup _ _, Prod.orderBot _ _ with\n    add_eq_sup := fun _ _ \u21a6 ext (add_eq_sup _ _) (add_eq_sup _ _) }", "start": [290, 1], "end": [292, 68], "kind": "commanddeclaration"}, {"full_name": "Prod.kstar_def", "code": "theorem kstar_def (a : \u03b1 \u00d7 \u03b2) : a\u2217 = (a.1\u2217, a.2\u2217)", "start": [308, 1], "end": [309, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_kstar", "code": "@[simp]\ntheorem fst_kstar (a : \u03b1 \u00d7 \u03b2) : a\u2217.1 = a.1\u2217", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_kstar", "code": "@[simp]\ntheorem snd_kstar (a : \u03b1 \u00d7 \u03b2) : a\u2217.2 = a.2\u2217", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instIdemSemiring", "code": "instance instIdemSemiring [\u2200 i, IdemSemiring (\u03c0 i)] : IdemSemiring (\u2200 i, \u03c0 i) :=\n  { Pi.semiring, Pi.semilatticeSup, Pi.orderBot with\n    add_eq_sup := fun _ _ \u21a6 funext fun _ \u21a6 add_eq_sup _ _ }", "start": [326, 1], "end": [328, 60], "kind": "commanddeclaration"}, {"full_name": "Pi.kstar_def", "code": "theorem kstar_def (a : \u2200 i, \u03c0 i) : a\u2217 = fun i \u21a6 (a i)\u2217", "start": [344, 1], "end": [345, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.kstar_apply", "code": "@[simp]\ntheorem kstar_apply (a : \u2200 i, \u03c0 i) (i : \u03b9) : a\u2217 i = (a i)\u2217", "start": [348, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.idemSemiring", "code": "@[reducible]\nprotected def idemSemiring [IdemSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2]\n    [NatCast \u03b2] [Sup \u03b2] [Bot \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1)\n    (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (bot : f \u22a5 = \u22a5) :\n    IdemSemiring \u03b2 :=\n  { hf.semiring f zero one add mul nsmul npow nat_cast, hf.semilatticeSup _ sup,\n    \u2039Bot \u03b2\u203a with\n    add_eq_sup := fun a b \u21a6 hf <| by erw [sup, add, add_eq_sup]\n    bot := \u22a5\n    bot_le := fun a \u21a6 bot.trans_le <| @bot_le _ _ _ <| f a }", "start": [358, 1], "end": [370, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.idemCommSemiring", "code": "@[reducible]\nprotected def idemCommSemiring [IdemCommSemiring \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115]\n    [SMul \u2115 \u03b2] [NatCast \u03b2] [Sup \u03b2] [Bot \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (bot : f \u22a5 = \u22a5) :\n    IdemCommSemiring \u03b2 :=\n  { hf.commSemiring f zero one add mul nsmul npow nat_cast,\n    hf.idemSemiring f zero one add mul nsmul npow nat_cast sup bot with }", "start": [374, 1], "end": [383, 74], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.kleeneAlgebra", "code": "@[reducible]\nprotected def kleeneAlgebra [KleeneAlgebra \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2]\n    [NatCast \u03b2] [Sup \u03b2] [Bot \u03b2] [KStar \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f) (zero : f 0 = 0)\n    (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y) (mul : \u2200 x y, f (x * y) = f x * f y)\n    (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x) (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (sup : \u2200 a b, f (a \u2294 b) = f a \u2294 f b) (bot : f \u22a5 = \u22a5)\n    (kstar : \u2200 a, f a\u2217 = (f a)\u2217) : KleeneAlgebra \u03b2 :=\n  { hf.idemSemiring f zero one add mul nsmul npow nat_cast sup bot,\n    \u2039KStar \u03b2\u203a with\n    one_le_kstar := fun a \u21a6 one.trans_le <| by\n      erw [kstar]\n      exact one_le_kstar\n    mul_kstar_le_kstar := fun a \u21a6 by\n      change f _ \u2264 _\n      erw [mul, kstar]\n      exact mul_kstar_le_kstar\n    kstar_mul_le_kstar := fun a \u21a6 by\n      change f _ \u2264 _\n      erw [mul, kstar]\n      exact kstar_mul_le_kstar\n    mul_kstar_le_self := fun a b (h : f _ \u2264 _) \u21a6 by\n      change f _ \u2264 _\n      erw [mul, kstar]\n      erw [mul] at h\n      exact mul_kstar_le_self h\n    kstar_mul_le_self := fun a b (h : f _ \u2264 _) \u21a6 by\n      change f _ \u2264 _\n      erw [mul, kstar]\n      erw [mul] at h\n      exact kstar_mul_le_self h }", "start": [387, 1], "end": [417, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finset/NAry.lean", "imports": ["Mathlib/Data/Finset/Prod.lean", "Mathlib/Data/Set/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.image\u2082", "code": "def image\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) : Finset \u03b3 :=\n  (s \u00d7\u02e2 t).image <| uncurry f", "start": [37, 1], "end": [40, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image\u2082", "code": "@[simp]\ntheorem mem_image\u2082 : c \u2208 image\u2082 f s t \u2194 \u2203 a b, a \u2208 s \u2227 b \u2208 t \u2227 f a b = c", "start": [43, 1], "end": [45, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_image\u2082", "code": "@[simp, norm_cast]\ntheorem coe_image\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    (image\u2082 f s t : Set \u03b3) = Set.image2 f s t", "start": [48, 1], "end": [51, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image\u2082_le", "code": "theorem card_image\u2082_le (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    (image\u2082 f s t).card \u2264 s.card * t.card", "start": [54, 1], "end": [56, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image\u2082_iff", "code": "theorem card_image\u2082_iff :\n    (image\u2082 f s t).card = s.card * t.card \u2194 (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b2)).InjOn fun x => f x.1 x.2", "start": [59, 1], "end": [62, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image\u2082", "code": "theorem card_image\u2082 (hf : Injective2 f) (s : Finset \u03b1) (t : Finset \u03b2) :\n    (image\u2082 f s t).card = s.card * t.card", "start": [65, 1], "end": [67, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image\u2082_of_mem", "code": "theorem mem_image\u2082_of_mem (ha : a \u2208 s) (hb : b \u2208 t) : f a b \u2208 image\u2082 f s t", "start": [70, 1], "end": [71, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_image\u2082_iff", "code": "theorem mem_image\u2082_iff (hf : Injective2 f) : f a b \u2208 image\u2082 f s t \u2194 a \u2208 s \u2227 b \u2208 t", "start": [74, 1], "end": [75, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset", "code": "theorem image\u2082_subset (hs : s \u2286 s') (ht : t \u2286 t') : image\u2082 f s t \u2286 image\u2082 f s' t'", "start": [78, 1], "end": [80, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset_left", "code": "theorem image\u2082_subset_left (ht : t \u2286 t') : image\u2082 f s t \u2286 image\u2082 f s t'", "start": [83, 1], "end": [84, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset_right", "code": "theorem image\u2082_subset_right (hs : s \u2286 s') : image\u2082 f s t \u2286 image\u2082 f s' t", "start": [87, 1], "end": [88, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_image\u2082_left", "code": "theorem image_subset_image\u2082_left (hb : b \u2208 t) : s.image (fun a => f a b) \u2286 image\u2082 f s t", "start": [91, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.image_subset_image\u2082_right", "code": "theorem image_subset_image\u2082_right (ha : a \u2208 s) : t.image (fun b => f a b) \u2286 image\u2082 f s t", "start": [95, 1], "end": [96, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.forall_image\u2082_iff", "code": "theorem forall_image\u2082_iff {p : \u03b3 \u2192 Prop} :\n    (\u2200 z \u2208 image\u2082 f s t, p z) \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, p (f x y)", "start": [99, 1], "end": [101, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset_iff", "code": "@[simp]\ntheorem image\u2082_subset_iff : image\u2082 f s t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, f x y \u2208 u", "start": [104, 1], "end": [106, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset_iff_left", "code": "theorem image\u2082_subset_iff_left : image\u2082 f s t \u2286 u \u2194 \u2200 a \u2208 s, (t.image fun b => f a b) \u2286 u", "start": [109, 1], "end": [110, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_subset_iff_right", "code": "theorem image\u2082_subset_iff_right : image\u2082 f s t \u2286 u \u2194 \u2200 b \u2208 t, (s.image fun a => f a b) \u2286 u", "start": [113, 1], "end": [114, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_nonempty_iff", "code": "@[simp]\ntheorem image\u2082_nonempty_iff : (image\u2082 f s t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [117, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.image\u2082", "code": "theorem Nonempty.image\u2082 (hs : s.Nonempty) (ht : t.Nonempty) : (image\u2082 f s t).Nonempty", "start": [123, 1], "end": [124, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_image\u2082_left", "code": "theorem Nonempty.of_image\u2082_left (h : (s.image\u2082 f t).Nonempty) : s.Nonempty", "start": [127, 1], "end": [128, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_image\u2082_right", "code": "theorem Nonempty.of_image\u2082_right (h : (s.image\u2082 f t).Nonempty) : t.Nonempty", "start": [131, 1], "end": [132, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_empty_left", "code": "@[simp]\ntheorem image\u2082_empty_left : image\u2082 f \u2205 t = \u2205", "start": [135, 1], "end": [137, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_empty_right", "code": "@[simp]\ntheorem image\u2082_empty_right : image\u2082 f s \u2205 = \u2205", "start": [140, 1], "end": [142, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_eq_empty_iff", "code": "@[simp]\ntheorem image\u2082_eq_empty_iff : image\u2082 f s t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [145, 1], "end": [147, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_singleton_left", "code": "@[simp]\ntheorem image\u2082_singleton_left : image\u2082 f {a} t = t.image fun b => f a b", "start": [150, 1], "end": [152, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_singleton_right", "code": "@[simp]\ntheorem image\u2082_singleton_right : image\u2082 f s {b} = s.image fun a => f a b", "start": [155, 1], "end": [157, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_singleton_left'", "code": "theorem image\u2082_singleton_left' : image\u2082 f {a} t = t.image (f a)", "start": [160, 1], "end": [161, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_singleton", "code": "theorem image\u2082_singleton : image\u2082 f {a} {b} = {f a b}", "start": [164, 1], "end": [164, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_union_left", "code": "theorem image\u2082_union_left [DecidableEq \u03b1] : image\u2082 f (s \u222a s') t = image\u2082 f s t \u222a image\u2082 f s' t", "start": [167, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_union_right", "code": "theorem image\u2082_union_right [DecidableEq \u03b2] : image\u2082 f s (t \u222a t') = image\u2082 f s t \u222a image\u2082 f s t'", "start": [173, 1], "end": [176, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_insert_left", "code": "@[simp]\ntheorem image\u2082_insert_left [DecidableEq \u03b1] :\n    image\u2082 f (insert a s) t = (t.image fun b => f a b) \u222a image\u2082 f s t", "start": [179, 1], "end": [184, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_insert_right", "code": "@[simp]\ntheorem image\u2082_insert_right [DecidableEq \u03b2] :\n    image\u2082 f s (insert b t) = (s.image fun a => f a b) \u222a image\u2082 f s t", "start": [187, 1], "end": [192, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_left", "code": "theorem image\u2082_inter_left [DecidableEq \u03b1] (hf : Injective2 f) :\n    image\u2082 f (s \u2229 s') t = image\u2082 f s t \u2229 image\u2082 f s' t", "start": [195, 1], "end": [199, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_right", "code": "theorem image\u2082_inter_right [DecidableEq \u03b2] (hf : Injective2 f) :\n    image\u2082 f s (t \u2229 t') = image\u2082 f s t \u2229 image\u2082 f s t'", "start": [202, 1], "end": [206, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_subset_left", "code": "theorem image\u2082_inter_subset_left [DecidableEq \u03b1] :\n    image\u2082 f (s \u2229 s') t \u2286 image\u2082 f s t \u2229 image\u2082 f s' t", "start": [209, 1], "end": [213, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_subset_right", "code": "theorem image\u2082_inter_subset_right [DecidableEq \u03b2] :\n    image\u2082 f s (t \u2229 t') \u2286 image\u2082 f s t \u2229 image\u2082 f s t'", "start": [216, 1], "end": [220, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_congr", "code": "theorem image\u2082_congr (h : \u2200 a \u2208 s, \u2200 b \u2208 t, f a b = f' a b) : image\u2082 f s t = image\u2082 f' s t", "start": [223, 1], "end": [226, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_congr'", "code": "theorem image\u2082_congr' (h : \u2200 a b, f a b = f' a b) : image\u2082 f s t = image\u2082 f' s t", "start": [229, 1], "end": [231, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_image\u2082", "code": "theorem subset_image\u2082 {s : Set \u03b1} {t : Set \u03b2} (hu : \u2191u \u2286 image2 f s t) :\n    \u2203 (s' : Finset \u03b1) (t' : Finset \u03b2), \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 image\u2082 f s' t'", "start": [234, 1], "end": [249, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image\u2082_singleton_left", "code": "theorem card_image\u2082_singleton_left (hf : Injective (f a)) : (image\u2082 f {a} t).card = t.card", "start": [254, 1], "end": [255, 59], "kind": "commanddeclaration"}, {"full_name": "Finset.card_image\u2082_singleton_right", "code": "theorem card_image\u2082_singleton_right (hf : Injective fun a => f a b) :\n    (image\u2082 f s {b}).card = s.card", "start": [258, 1], "end": [259, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_singleton_inter", "code": "theorem image\u2082_singleton_inter [DecidableEq \u03b2] (t\u2081 t\u2082 : Finset \u03b2) (hf : Injective (f a)) :\n    image\u2082 f {a} (t\u2081 \u2229 t\u2082) = image\u2082 f {a} t\u2081 \u2229 image\u2082 f {a} t\u2082", "start": [262, 1], "end": [264, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_singleton", "code": "theorem image\u2082_inter_singleton [DecidableEq \u03b1] (s\u2081 s\u2082 : Finset \u03b1) (hf : Injective fun a => f a b) :\n    image\u2082 f (s\u2081 \u2229 s\u2082) {b} = image\u2082 f s\u2081 {b} \u2229 image\u2082 f s\u2082 {b}", "start": [267, 1], "end": [269, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_image\u2082_left", "code": "theorem card_le_card_image\u2082_left {s : Finset \u03b1} (hs : s.Nonempty) (hf : \u2200 a, Injective (f a)) :\n    t.card \u2264 (image\u2082 f s t).card", "start": [272, 1], "end": [276, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_image\u2082_right", "code": "theorem card_le_card_image\u2082_right {t : Finset \u03b2} (ht : t.Nonempty)\n    (hf : \u2200 b, Injective fun a => f a b) : s.card \u2264 (image\u2082 f s t).card", "start": [279, 1], "end": [283, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_image_left", "code": "theorem biUnion_image_left : (s.biUnion fun a => t.image <| f a) = image\u2082 f s t", "start": [288, 1], "end": [291, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_image_right", "code": "theorem biUnion_image_right : (t.biUnion fun b => s.image fun a => f a b) = image\u2082 f s t", "start": [294, 1], "end": [297, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082", "code": "theorem image_image\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (g : \u03b3 \u2192 \u03b4) :\n    (image\u2082 f s t).image g = image\u2082 (fun a b => g (f a b)) s t", "start": [310, 1], "end": [314, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_image_left", "code": "theorem image\u2082_image_left (f : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (g : \u03b1 \u2192 \u03b3) :\n    image\u2082 f (s.image g) t = image\u2082 (fun a b => f (g a) b) s t", "start": [317, 1], "end": [321, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_image_right", "code": "theorem image\u2082_image_right (f : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b3) :\n    image\u2082 f s (t.image g) = image\u2082 (fun a b => f a (g b)) s t", "start": [324, 1], "end": [328, 33], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_mk_eq_product", "code": "@[simp]\ntheorem image\u2082_mk_eq_product [DecidableEq \u03b1] [DecidableEq \u03b2] (s : Finset \u03b1) (t : Finset \u03b2) :\n    image\u2082 Prod.mk s t = s \u00d7\u02e2 t", "start": [331, 1], "end": [333, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_curry", "code": "@[simp]\ntheorem image\u2082_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    image\u2082 (curry f) s t = (s \u00d7\u02e2 t).image f", "start": [336, 1], "end": [339, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.image_uncurry_product", "code": "@[simp]\ntheorem image_uncurry_product (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    (s \u00d7\u02e2 t).image (uncurry f) = image\u2082 f s t", "start": [342, 1], "end": [344, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_swap", "code": "theorem image\u2082_swap (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Finset \u03b1) (t : Finset \u03b2) :\n    image\u2082 f s t = image\u2082 (fun a b => f b a) t s", "start": [347, 1], "end": [351, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_left", "code": "@[simp]\ntheorem image\u2082_left [DecidableEq \u03b1] (h : t.Nonempty) : image\u2082 (fun x _ => x) s t = s", "start": [354, 1], "end": [358, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_right", "code": "@[simp]\ntheorem image\u2082_right [DecidableEq \u03b2] (h : s.Nonempty) : image\u2082 (fun _ y => y) s t = t", "start": [361, 1], "end": [365, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_assoc", "code": "theorem image\u2082_assoc {\u03b3 : Type*} {u : Finset \u03b3} {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b5' \u2192 \u03b5}\n    {g' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'} (h_assoc : \u2200 a b c, f (g a b) c = f' a (g' b c)) :\n    image\u2082 f (image\u2082 g s t) u = image\u2082 f' s (image\u2082 g' t u)", "start": [368, 1], "end": [373, 31], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_comm", "code": "theorem image\u2082_comm {g : \u03b2 \u2192 \u03b1 \u2192 \u03b3} (h_comm : \u2200 a b, f a b = g b a) : image\u2082 f s t = image\u2082 g t s", "start": [376, 1], "end": [377, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_left_comm", "code": "theorem image\u2082_left_comm {\u03b3 : Type*} {u : Finset \u03b3} {f : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {g : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b2 \u2192 \u03b4' \u2192 \u03b5} (h_left_comm : \u2200 a b c, f a (g b c) = g' b (f' a c)) :\n    image\u2082 f s (image\u2082 g t u) = image\u2082 g' t (image\u2082 f' s u)", "start": [380, 1], "end": [385, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_right_comm", "code": "theorem image\u2082_right_comm {\u03b3 : Type*} {u : Finset \u03b3} {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4}\n    {f' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {g' : \u03b4' \u2192 \u03b2 \u2192 \u03b5} (h_right_comm : \u2200 a b c, f (g a b) c = g' (f' a c) b) :\n    image\u2082 f (image\u2082 g s t) u = image\u2082 g' (image\u2082 f' s u) t", "start": [388, 1], "end": [393, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_image\u2082_image\u2082_comm", "code": "theorem image\u2082_image\u2082_image\u2082_comm {\u03b3 \u03b4 : Type*} {u : Finset \u03b3} {v : Finset \u03b4} [DecidableEq \u03b6]\n    [DecidableEq \u03b6'] [DecidableEq \u03bd] {f : \u03b5 \u2192 \u03b6 \u2192 \u03bd} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b5} {h : \u03b3 \u2192 \u03b4 \u2192 \u03b6}\n    {f' : \u03b5' \u2192 \u03b6' \u2192 \u03bd} {g' : \u03b1 \u2192 \u03b3 \u2192 \u03b5'} {h' : \u03b2 \u2192 \u03b4 \u2192 \u03b6'}\n    (h_comm : \u2200 a b c d, f (g a b) (h c d) = f' (g' a c) (h' b d)) :\n    image\u2082 f (image\u2082 g s t) (image\u2082 h u v) = image\u2082 f' (image\u2082 g' s u) (image\u2082 h' t v)", "start": [396, 1], "end": [403, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_distrib", "code": "theorem image_image\u2082_distrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2' \u2192 \u03b4} {g\u2081 : \u03b1 \u2192 \u03b1'} {g\u2082 : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g\u2081 a) (g\u2082 b)) :\n    (image\u2082 f s t).image g = image\u2082 f' (s.image g\u2081) (t.image g\u2082)", "start": [406, 1], "end": [411, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_distrib_left", "code": "theorem image_image\u2082_distrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b1' \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_distrib : \u2200 a b, g (f a b) = f' (g' a) b) :\n    (image\u2082 f s t).image g = image\u2082 f' (s.image g') t", "start": [414, 1], "end": [420, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_distrib_right", "code": "theorem image_image\u2082_distrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b1 \u2192 \u03b2' \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, g (f a b) = f' a (g' b)) :\n    (image\u2082 f s t).image g = image\u2082 f' s (t.image g')", "start": [423, 1], "end": [429, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_image_left_comm", "code": "theorem image\u2082_image_left_comm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_comm : \u2200 a b, f (g a) b = g' (f' a b)) :\n    image\u2082 f (s.image g) t = (image\u2082 f' s t).image g'", "start": [432, 1], "end": [436, 69], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_right_comm", "code": "theorem image_image\u2082_right_comm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_comm : \u2200 a b, f a (g b) = g' (f' a b)) :\n    image\u2082 f s (t.image g) = (image\u2082 f' s t).image g'", "start": [439, 1], "end": [443, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_distrib_subset_left", "code": "theorem image\u2082_distrib_subset_left {\u03b3 : Type*} {u : Finset \u03b3} {f : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {g : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    {f\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'} {f\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'} {g' : \u03b2' \u2192 \u03b3' \u2192 \u03b5}\n    (h_distrib : \u2200 a b c, f a (g b c) = g' (f\u2081 a b) (f\u2082 a c)) :\n    image\u2082 f s (image\u2082 g t u) \u2286 image\u2082 g' (image\u2082 f\u2081 s t) (image\u2082 f\u2082 s u)", "start": [446, 1], "end": [453, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_distrib_subset_right", "code": "theorem image\u2082_distrib_subset_right {\u03b3 : Type*} {u : Finset \u03b3} {f : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {g : \u03b1 \u2192 \u03b2 \u2192 \u03b4}\n    {f\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'} {f\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'} {g' : \u03b1' \u2192 \u03b2' \u2192 \u03b5}\n    (h_distrib : \u2200 a b c, f (g a b) c = g' (f\u2081 a c) (f\u2082 b c)) :\n    image\u2082 f (image\u2082 g s t) u \u2286 image\u2082 g' (image\u2082 f\u2081 s u) (image\u2082 f\u2082 t u)", "start": [456, 1], "end": [463, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_antidistrib", "code": "theorem image_image\u2082_antidistrib {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {g\u2081 : \u03b2 \u2192 \u03b2'} {g\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g\u2081 b) (g\u2082 a)) :\n    (image\u2082 f s t).image g = image\u2082 f' (t.image g\u2081) (s.image g\u2082)", "start": [466, 1], "end": [470, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_antidistrib_left", "code": "theorem image_image\u2082_antidistrib_left {g : \u03b3 \u2192 \u03b4} {f' : \u03b2' \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b2 \u2192 \u03b2'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' (g' b) a) :\n    (image\u2082 f s t).image g = image\u2082 f' (t.image g') s", "start": [473, 1], "end": [479, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_antidistrib_right", "code": "theorem image_image\u2082_antidistrib_right {g : \u03b3 \u2192 \u03b4} {f' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {g' : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, g (f a b) = f' b (g' a)) :\n    (image\u2082 f s t).image g = image\u2082 f' t (s.image g')", "start": [482, 1], "end": [488, 55], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_image_left_anticomm", "code": "theorem image\u2082_image_left_anticomm {f : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b1'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_left_anticomm : \u2200 a b, f (g a) b = g' (f' b a)) :\n    image\u2082 f (s.image g) t = (image\u2082 f' t s).image g'", "start": [491, 1], "end": [495, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.image_image\u2082_right_anticomm", "code": "theorem image_image\u2082_right_anticomm {f : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {g : \u03b2 \u2192 \u03b2'} {f' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {g' : \u03b4 \u2192 \u03b3}\n    (h_right_anticomm : \u2200 a b, f a (g b) = g' (f' b a)) :\n    image\u2082 f s (t.image g) = (image\u2082 f' t s).image g'", "start": [498, 1], "end": [502, 79], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_left_identity", "code": "theorem image\u2082_left_identity {f : \u03b1 \u2192 \u03b3 \u2192 \u03b3} {a : \u03b1} (h : \u2200 b, f a b = b) (t : Finset \u03b3) :\n    image\u2082 f {a} t = t", "start": [505, 1], "end": [509, 81], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_right_identity", "code": "theorem image\u2082_right_identity {f : \u03b3 \u2192 \u03b2 \u2192 \u03b3} {b : \u03b2} (h : \u2200 a, f a b = a) (s : Finset \u03b3) :\n    image\u2082 f s {b} = s", "start": [512, 1], "end": [515, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dvd_card_image\u2082_right", "code": "theorem card_dvd_card_image\u2082_right (hf : \u2200 a \u2208 s, Injective (f a))\n    (hs : ((fun a => t.image <| f a) '' s).PairwiseDisjoint id) : t.card \u2223 (image\u2082 f s t).card", "start": [518, 1], "end": [537, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dvd_card_image\u2082_left", "code": "theorem card_dvd_card_image\u2082_left (hf : \u2200 b \u2208 t, Injective fun a => f a b)\n    (ht : ((fun b => s.image fun a => f a b) '' t).PairwiseDisjoint id) :\n    s.card \u2223 (image\u2082 f s t).card", "start": [540, 1], "end": [545, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_union_subset_union", "code": "theorem image\u2082_inter_union_subset_union :\n    image\u2082 f (s \u2229 s') (t \u222a t') \u2286 image\u2082 f s t \u222a image\u2082 f s' t'", "start": [550, 1], "end": [554, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_union_inter_subset_union", "code": "theorem image\u2082_union_inter_subset_union :\n    image\u2082 f (s \u222a s') (t \u2229 t') \u2286 image\u2082 f s t \u222a image\u2082 f s' t'", "start": [557, 1], "end": [561, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_inter_union_subset", "code": "theorem image\u2082_inter_union_subset {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} {s t : Finset \u03b1} (hf : \u2200 a b, f a b = f b a) :\n    image\u2082 f (s \u2229 t) (s \u222a t) \u2286 image\u2082 f s t", "start": [564, 1], "end": [568, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.image\u2082_union_inter_subset", "code": "theorem image\u2082_union_inter_subset {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} {s t : Finset \u03b1} (hf : \u2200 a b, f a b = f b a) :\n    image\u2082 f (s \u222a t) (s \u2229 t) \u2286 image\u2082 f s t", "start": [571, 1], "end": [575, 39], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_image2", "code": "@[simp]\ntheorem toFinset_image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (s : Set \u03b1) (t : Set \u03b2) [Fintype s] [Fintype t]\n    [Fintype (image2 f s t)] : (image2 f s t).toFinset = Finset.image\u2082 f s.toFinset t.toFinset", "start": [584, 1], "end": [587, 34], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_image2", "code": "theorem Finite.toFinset_image2 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hs : s.Finite) (ht : t.Finite)\n    (hf := hs.image2 f ht) : hf.toFinset = Finset.image\u2082 f hs.toFinset ht.toFinset", "start": [590, 1], "end": [592, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/ListOfFn.lean", "imports": ["Mathlib/Data/List/OfFn.lean", "Mathlib/Data/Set/Pointwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.mem_prod_list_ofFn", "code": "@[to_additive]\ntheorem mem_prod_list_ofFn {a : \u03b1} {s : Fin n \u2192 Set \u03b1} :\n    a \u2208 (List.ofFn s).prod \u2194 \u2203 f : \u2200 i : Fin n, s i, (List.ofFn fun i \u21a6 (f i : \u03b1)).prod = a", "start": [25, 1], "end": [31, 87], "kind": "commanddeclaration"}, {"full_name": "Set.mem_list_prod", "code": "@[to_additive]\ntheorem mem_list_prod {l : List (Set \u03b1)} {a : \u03b1} :\n    a \u2208 l.prod \u2194\n      \u2203 l' : List (\u03a3s : Set \u03b1, \u21a5s),\n        List.prod (l'.map fun x \u21a6 (Sigma.snd x : \u03b1)) = a \u2227 l'.map Sigma.fst = l", "start": [35, 1], "end": [47, 27], "kind": "commanddeclaration"}, {"full_name": "Set.mem_pow", "code": "@[to_additive]\ntheorem mem_pow {a : \u03b1} {n : \u2115} :\n    a \u2208 s ^ n \u2194 \u2203 f : Fin n \u2192 s, (List.ofFn fun i \u21a6 (f i : \u03b1)).prod = a", "start": [51, 1], "end": [54, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/Finite.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Data/Set/Finite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.finite_one", "code": "@[to_additive (attr := simp)]\ntheorem finite_one : (1 : Set \u03b1).Finite", "start": [24, 1], "end": [26, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.inv", "code": "@[to_additive]\ntheorem Finite.inv (hs : s.Finite) : s\u207b\u00b9.Finite", "start": [36, 1], "end": [38, 39], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.mul", "code": "@[to_additive]\ntheorem Finite.mul : s.Finite \u2192 t.Finite \u2192 (s * t).Finite", "start": [48, 1], "end": [50, 18], "kind": "commanddeclaration"}, {"full_name": "Set.fintypeMul", "code": "@[to_additive \"Addition preserves finiteness.\"]\ndef fintypeMul [DecidableEq \u03b1] (s t : Set \u03b1) [Fintype s] [Fintype t] : Fintype (s * t : Set \u03b1) :=\n  Set.fintypeImage2 _ _ _", "start": [54, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemMul", "code": "@[to_additive]\ninstance decidableMemMul [Fintype \u03b1] [DecidableEq \u03b1] [DecidablePred (\u00b7 \u2208 s)]\n    [DecidablePred (\u00b7 \u2208 t)] : DecidablePred (\u00b7 \u2208 s * t) := fun _ \u21a6 decidable_of_iff _ mem_mul.symm", "start": [67, 1], "end": [69, 99], "kind": "commanddeclaration"}, {"full_name": "Set.decidableMemPow", "code": "@[to_additive]\ninstance decidableMemPow [Fintype \u03b1] [DecidableEq \u03b1] [DecidablePred (\u00b7 \u2208 s)] (n : \u2115) :\n    DecidablePred (\u00b7 \u2208 s ^ n) := by\n  induction' n with n ih\n  \u00b7 simp only [Nat.zero_eq, pow_zero, mem_one]\n    infer_instance\n  \u00b7 letI := ih\n    rw [pow_succ]\n    infer_instance", "start": [73, 1], "end": [81, 19], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.smul", "code": "@[to_additive]\ntheorem Finite.smul : s.Finite \u2192 t.Finite \u2192 (s \u2022 t).Finite", "start": [91, 1], "end": [93, 18], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.smul_set", "code": "@[to_additive]\ntheorem Finite.smul_set : s.Finite \u2192 (a \u2022 s).Finite", "start": [103, 1], "end": [105, 17], "kind": "commanddeclaration"}, {"full_name": "Set.Infinite.of_smul_set", "code": "@[to_additive]\ntheorem Infinite.of_smul_set : (a \u2022 s).Infinite \u2192 s.Infinite", "start": [109, 1], "end": [111, 22], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.vsub", "code": "theorem Finite.vsub (hs : s.Finite) (ht : t.Finite) : Set.Finite (s -\u1d65 t)", "start": [121, 1], "end": [122, 17], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_mul", "code": "@[to_additive]\ntheorem infinite_mul : (s * t).Infinite \u2194 s.Infinite \u2227 t.Nonempty \u2228 t.Infinite \u2227 s.Nonempty", "start": [131, 1], "end": [134, 36], "kind": "commanddeclaration"}, {"full_name": "Set.finite_smul_set", "code": "@[to_additive (attr := simp)]\ntheorem finite_smul_set : (a \u2022 s).Finite \u2194 s.Finite", "start": [144, 1], "end": [146, 54], "kind": "commanddeclaration"}, {"full_name": "Set.infinite_smul_set", "code": "@[to_additive (attr := simp)]\ntheorem infinite_smul_set : (a \u2022 s).Infinite \u2194 s.Infinite", "start": [150, 1], "end": [152, 56], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.of_smul_set", "code": "alias \u27e8Finite.of_smul_set, _\u27e9 := finite_smul_set", "start": [156, 1], "end": [156, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Set.Infinite.smul_set", "code": "alias \u27e8_, Infinite.smul_set\u27e9 := infinite_smul_set", "start": [159, 1], "end": [159, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Group.card_pow_eq_card_pow_card_univ", "code": "@[to_additive]\ntheorem card_pow_eq_card_pow_card_univ [\u2200 k : \u2115, DecidablePred (\u00b7 \u2208 S ^ k)] :\n    \u2200 k, Fintype.card G \u2264 k \u2192 Fintype.card (\u21a5(S ^ k)) = Fintype.card (\u21a5(S ^ Fintype.card G))", "start": [174, 1], "end": [200, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Finprod.lean", "imports": ["Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Algebra/BigOperators/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "finsum", "code": "noncomputable irreducible_def finsum (lemma := finsum_def') [AddCommMonoid M] (f : \u03b1 \u2192 M) : M :=\n  if h : (support (f \u2218 PLift.down)).Finite then \u2211 i in h.toFinset, f i.down else 0", "start": [92, 1], "end": [95, 83], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "finprod", "code": "@[to_additive existing]\nnoncomputable irreducible_def finprod (lemma := finprod_def') (f : \u03b1 \u2192 M) : M :=\n  if h : (mulSupport (f \u2218 PLift.down)).Finite then \u220f i in h.toFinset, f i.down else 1", "start": [98, 1], "end": [102, 86], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "finprod_eq_prod_plift_of_mulSupport_toFinset_subset", "code": "@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_toFinset_subset {f : \u03b1 \u2192 M}\n    (hf : (mulSupport (f \u2218 PLift.down)).Finite) {s : Finset (PLift \u03b1)} (hs : hf.toFinset \u2286 s) :\n    \u220f\u1da0 i, f i = \u220f i in s, f i.down", "start": [173, 1], "end": [179, 48], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_prod_plift_of_mulSupport_subset", "code": "@[to_additive]\ntheorem finprod_eq_prod_plift_of_mulSupport_subset {f : \u03b1 \u2192 M} {s : Finset (PLift \u03b1)}\n    (hs : mulSupport (f \u2218 PLift.down) \u2286 s) : \u220f\u1da0 i, f i = \u220f i in s, f i.down", "start": [183, 1], "end": [188, 16], "kind": "commanddeclaration"}, {"full_name": "finprod_one", "code": "@[to_additive (attr := simp)]\ntheorem finprod_one : (\u220f\u1da0 _ : \u03b1, (1 : M)) = 1", "start": [192, 1], "end": [196, 74], "kind": "commanddeclaration"}, {"full_name": "finprod_of_isEmpty", "code": "@[to_additive]\ntheorem finprod_of_isEmpty [IsEmpty \u03b1] (f : \u03b1 \u2192 M) : \u220f\u1da0 i, f i = 1", "start": [200, 1], "end": [204, 7], "kind": "commanddeclaration"}, {"full_name": "finprod_false", "code": "@[to_additive (attr := simp)]\ntheorem finprod_false (f : False \u2192 M) : \u220f\u1da0 i, f i = 1", "start": [208, 1], "end": [210, 23], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_single", "code": "@[to_additive]\ntheorem finprod_eq_single (f : \u03b1 \u2192 M) (a : \u03b1) (ha : \u2200 x, x \u2260 a \u2192 f x = 1) :\n    \u220f\u1da0 x, f x = f a", "start": [214, 1], "end": [221, 78], "kind": "commanddeclaration"}, {"full_name": "finprod_unique", "code": "@[to_additive]\ntheorem finprod_unique [Unique \u03b1] (f : \u03b1 \u2192 M) : \u220f\u1da0 i, f i = f default", "start": [225, 1], "end": [227, 76], "kind": "commanddeclaration"}, {"full_name": "finprod_true", "code": "@[to_additive (attr := simp)]\ntheorem finprod_true (f : True \u2192 M) : \u220f\u1da0 i, f i = f trivial", "start": [231, 1], "end": [233, 55], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_dif", "code": "@[to_additive]\ntheorem finprod_eq_dif {p : Prop} [Decidable p] (f : p \u2192 M) :\n    \u220f\u1da0 i, f i = if h : p then f h else 1", "start": [237, 1], "end": [244, 31], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_if", "code": "@[to_additive]\ntheorem finprod_eq_if {p : Prop} [Decidable p] {x : M} : \u220f\u1da0 _ : p, x = if p then x else 1", "start": [248, 1], "end": [250, 28], "kind": "commanddeclaration"}, {"full_name": "finprod_congr", "code": "@[to_additive]\ntheorem finprod_congr {f g : \u03b1 \u2192 M} (h : \u2200 x, f x = g x) : finprod f = finprod g", "start": [254, 1], "end": [256, 26], "kind": "commanddeclaration"}, {"full_name": "finprod_congr_Prop", "code": "@[to_additive (attr := congr)]\ntheorem finprod_congr_Prop {p q : Prop} {f : p \u2192 M} {g : q \u2192 M} (hpq : p = q)\n    (hfg : \u2200 h : q, f (hpq.mpr h) = g h) : finprod f = finprod g", "start": [260, 1], "end": [264, 26], "kind": "commanddeclaration"}, {"full_name": "finprod_induction", "code": "@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on the summands.\"]\ntheorem finprod_induction {f : \u03b1 \u2192 M} (p : M \u2192 Prop) (hp\u2080 : p 1)\n    (hp\u2081 : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) (hp\u2082 : \u2200 i, p (f i)) : p (\u220f\u1da0 i, f i)", "start": [268, 1], "end": [277, 67], "kind": "commanddeclaration"}, {"full_name": "finprod_nonneg", "code": "theorem finprod_nonneg {R : Type*} [OrderedCommSemiring R] {f : \u03b1 \u2192 R} (hf : \u2200 x, 0 \u2264 f x) :\n    0 \u2264 \u220f\u1da0 x, f x", "start": [281, 1], "end": [283, 76], "kind": "commanddeclaration"}, {"full_name": "one_le_finprod'", "code": "@[to_additive finsum_nonneg]\ntheorem one_le_finprod' {M : Type*} [OrderedCommMonoid M] {f : \u03b1 \u2192 M} (hf : \u2200 i, 1 \u2264 f i) :\n    1 \u2264 \u220f\u1da0 i, f i", "start": [286, 1], "end": [289, 56], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_plift", "code": "@[to_additive]\ntheorem MonoidHom.map_finprod_plift (f : M \u2192* N) (g : \u03b1 \u2192 M)\n    (h : (mulSupport <| g \u2218 PLift.down).Finite) : f (\u220f\u1da0 x, g x) = \u220f\u1da0 x, f (g x)", "start": [293, 1], "end": [299, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_Prop", "code": "@[to_additive]\ntheorem MonoidHom.map_finprod_Prop {p : Prop} (f : M \u2192* N) (g : p \u2192 M) :\n    f (\u220f\u1da0 x, g x) = \u220f\u1da0 x, f (g x)", "start": [303, 1], "end": [306, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_of_preimage_one", "code": "@[to_additive]\ntheorem MonoidHom.map_finprod_of_preimage_one (f : M \u2192* N) (hf : \u2200 x, f x = 1 \u2192 x = 1) (g : \u03b1 \u2192 M) :\n    f (\u220f\u1da0 i, g i) = \u220f\u1da0 i, f (g i)", "start": [310, 1], "end": [315, 68], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_of_injective", "code": "@[to_additive]\ntheorem MonoidHom.map_finprod_of_injective (g : M \u2192* N) (hg : Injective g) (f : \u03b1 \u2192 M) :\n    g (\u220f\u1da0 i, f i) = \u220f\u1da0 i, g (f i)", "start": [319, 1], "end": [322, 71], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_finprod", "code": "@[to_additive]\ntheorem MulEquiv.map_finprod (g : M \u2243* N) (f : \u03b1 \u2192 M) : g (\u220f\u1da0 i, f i) = \u220f\u1da0 i, g (f i)", "start": [326, 1], "end": [328, 67], "kind": "commanddeclaration"}, {"full_name": "finsum_smul", "code": "theorem finsum_smul {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    (f : \u03b9 \u2192 R) (x : M) : (\u2211\u1da0 i, f i) \u2022 x = \u2211\u1da0 i, f i \u2022 x", "start": [332, 1], "end": [338, 89], "kind": "commanddeclaration"}, {"full_name": "smul_finsum", "code": "theorem smul_finsum {R M : Type*} [Ring R] [AddCommGroup M] [Module R M] [NoZeroSMulDivisors R M]\n    (c : R) (f : \u03b9 \u2192 M) : (c \u2022 \u2211\u1da0 i, f i) = \u2211\u1da0 i, c \u2022 f i", "start": [341, 1], "end": [347, 83], "kind": "commanddeclaration"}, {"full_name": "finprod_inv_distrib", "code": "@[to_additive]\ntheorem finprod_inv_distrib [DivisionCommMonoid G] (f : \u03b1 \u2192 G) : (\u220f\u1da0 x, (f x)\u207b\u00b9) = (\u220f\u1da0 x, f x)\u207b\u00b9", "start": [350, 1], "end": [352, 40], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_mulIndicator_apply", "code": "@[to_additive]\ntheorem finprod_eq_mulIndicator_apply (s : Set \u03b1) (f : \u03b1 \u2192 M) (a : \u03b1) :\n    \u220f\u1da0 _ : a \u2208 s, f a = mulIndicator s f a", "start": [365, 1], "end": [368, 67], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_mulSupport", "code": "@[to_additive (attr := simp)]\ntheorem finprod_mem_mulSupport (f : \u03b1 \u2192 M) (a : \u03b1) : \u220f\u1da0 _ : f a \u2260 1, f a = f a", "start": [372, 1], "end": [374, 80], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_def", "code": "@[to_additive]\ntheorem finprod_mem_def (s : Set \u03b1) (f : \u03b1 \u2192 M) : \u220f\u1da0 a \u2208 s, f a = \u220f\u1da0 a, mulIndicator s f a", "start": [378, 1], "end": [380, 53], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_prod_of_mulSupport_subset", "code": "@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_subset (f : \u03b1 \u2192 M) {s : Finset \u03b1} (h : mulSupport f \u2286 s) :\n    \u220f\u1da0 i, f i = \u220f i in s, f i", "start": [384, 1], "end": [395, 8], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_prod_of_mulSupport_toFinset_subset", "code": "@[to_additive]\ntheorem finprod_eq_prod_of_mulSupport_toFinset_subset (f : \u03b1 \u2192 M) (hf : (mulSupport f).Finite)\n    {s : Finset \u03b1} (h : hf.toFinset \u2286 s) : \u220f\u1da0 i, f i = \u220f i in s, f i", "start": [399, 1], "end": [402, 79], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_finset_prod_of_mulSupport_subset", "code": "@[to_additive]\ntheorem finprod_eq_finset_prod_of_mulSupport_subset (f : \u03b1 \u2192 M) {s : Finset \u03b1}\n    (h : mulSupport f \u2286 (s : Set \u03b1)) : \u220f\u1da0 i, f i = \u220f i in s, f i", "start": [406, 1], "end": [411, 55], "kind": "commanddeclaration"}, {"full_name": "finprod_def", "code": "@[to_additive]\ntheorem finprod_def (f : \u03b1 \u2192 M) [Decidable (mulSupport f).Finite] :\n    \u220f\u1da0 i : \u03b1, f i = if h : (mulSupport f).Finite then \u220f i in h.toFinset, f i else 1", "start": [415, 1], "end": [422, 65], "kind": "commanddeclaration"}, {"full_name": "finprod_of_infinite_mulSupport", "code": "@[to_additive]\ntheorem finprod_of_infinite_mulSupport {f : \u03b1 \u2192 M} (hf : (mulSupport f).Infinite) :\n    \u220f\u1da0 i, f i = 1", "start": [426, 1], "end": [428, 63], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_prod", "code": "@[to_additive]\ntheorem finprod_eq_prod (f : \u03b1 \u2192 M) (hf : (mulSupport f).Finite) :\n    \u220f\u1da0 i : \u03b1, f i = \u220f i in hf.toFinset, f i", "start": [432, 1], "end": [434, 89], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_prod_of_fintype", "code": "@[to_additive]\ntheorem finprod_eq_prod_of_fintype [Fintype \u03b1] (f : \u03b1 \u2192 M) : \u220f\u1da0 i : \u03b1, f i = \u220f i, f i", "start": [438, 1], "end": [440, 91], "kind": "commanddeclaration"}, {"full_name": "finprod_cond_eq_prod_of_cond_iff", "code": "@[to_additive]\ntheorem finprod_cond_eq_prod_of_cond_iff (f : \u03b1 \u2192 M) {p : \u03b1 \u2192 Prop} {t : Finset \u03b1}\n    (h : \u2200 {x}, f x \u2260 1 \u2192 (p x \u2194 x \u2208 t)) : (\u220f\u1da0 (i) (_ : p i), f i) = \u220f i in t, f i", "start": [444, 1], "end": [455, 21], "kind": "commanddeclaration"}, {"full_name": "finprod_cond_ne", "code": "@[to_additive]\ntheorem finprod_cond_ne (f : \u03b1 \u2192 M) (a : \u03b1) [DecidableEq \u03b1] (hf : (mulSupport f).Finite) :\n    (\u220f\u1da0 (i) (_ : i \u2260 a), f i) = \u220f i in hf.toFinset.erase a, f i", "start": [459, 1], "end": [465, 48], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_prod_of_inter_mulSupport_eq", "code": "@[to_additive]\ntheorem finprod_mem_eq_prod_of_inter_mulSupport_eq (f : \u03b1 \u2192 M) {s : Set \u03b1} {t : Finset \u03b1}\n    (h : s \u2229 mulSupport f = t.toSet \u2229 mulSupport f) : \u220f\u1da0 i \u2208 s, f i = \u220f i in t, f i", "start": [469, 1], "end": [481, 22], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_prod_of_subset", "code": "@[to_additive]\ntheorem finprod_mem_eq_prod_of_subset (f : \u03b1 \u2192 M) {s : Set \u03b1} {t : Finset \u03b1}\n    (h\u2081 : s \u2229 mulSupport f \u2286 t) (h\u2082 : \u2191t \u2286 s) : \u220f\u1da0 i \u2208 s, f i = \u220f i in t, f i", "start": [485, 1], "end": [488, 84], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_prod", "code": "@[to_additive]\ntheorem finprod_mem_eq_prod (f : \u03b1 \u2192 M) {s : Set \u03b1} (hf : (s \u2229 mulSupport f).Finite) :\n    \u220f\u1da0 i \u2208 s, f i = \u220f i in hf.toFinset, f i", "start": [492, 1], "end": [495, 72], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_prod_filter", "code": "@[to_additive]\ntheorem finprod_mem_eq_prod_filter (f : \u03b1 \u2192 M) (s : Set \u03b1) [DecidablePred (\u00b7 \u2208 s)]\n    (hf : (mulSupport f).Finite) :\n    \u220f\u1da0 i \u2208 s, f i = \u220f i in Finset.filter (\u00b7 \u2208 s) hf.toFinset, f i", "start": [499, 1], "end": [505, 20], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_toFinset_prod", "code": "@[to_additive]\ntheorem finprod_mem_eq_toFinset_prod (f : \u03b1 \u2192 M) (s : Set \u03b1) [Fintype s] :\n    \u220f\u1da0 i \u2208 s, f i = \u220f i in s.toFinset, f i", "start": [509, 1], "end": [512, 78], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_finite_toFinset_prod", "code": "@[to_additive]\ntheorem finprod_mem_eq_finite_toFinset_prod (f : \u03b1 \u2192 M) {s : Set \u03b1} (hs : s.Finite) :\n    \u220f\u1da0 i \u2208 s, f i = \u220f i in hs.toFinset, f i", "start": [516, 1], "end": [519, 74], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_finset_eq_prod", "code": "@[to_additive]\ntheorem finprod_mem_finset_eq_prod (f : \u03b1 \u2192 M) (s : Finset \u03b1) : \u220f\u1da0 i \u2208 s, f i = \u220f i in s, f i", "start": [523, 1], "end": [525, 51], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_coe_finset", "code": "@[to_additive]\ntheorem finprod_mem_coe_finset (f : \u03b1 \u2192 M) (s : Finset \u03b1) :\n    (\u220f\u1da0 i \u2208 (s : Set \u03b1), f i) = \u220f i in s, f i", "start": [529, 1], "end": [532, 51], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_one_of_infinite", "code": "@[to_additive]\ntheorem finprod_mem_eq_one_of_infinite {f : \u03b1 \u2192 M} {s : Set \u03b1} (hs : (s \u2229 mulSupport f).Infinite) :\n    \u220f\u1da0 i \u2208 s, f i = 1", "start": [536, 1], "end": [541, 40], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_one_of_forall_eq_one", "code": "@[to_additive]\ntheorem finprod_mem_eq_one_of_forall_eq_one {f : \u03b1 \u2192 M} {s : Set \u03b1} (h : \u2200 x \u2208 s, f x = 1) :\n    \u220f\u1da0 i \u2208 s, f i = 1", "start": [545, 1], "end": [547, 72], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inter_mulSupport", "code": "@[to_additive]\ntheorem finprod_mem_inter_mulSupport (f : \u03b1 \u2192 M) (s : Set \u03b1) :\n    \u220f\u1da0 i \u2208 s \u2229 mulSupport f, f i = \u220f\u1da0 i \u2208 s, f i", "start": [551, 1], "end": [554, 71], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inter_mulSupport_eq", "code": "@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq (f : \u03b1 \u2192 M) (s t : Set \u03b1)\n    (h : s \u2229 mulSupport f = t \u2229 mulSupport f) : \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 i \u2208 t, f i", "start": [558, 1], "end": [561, 71], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inter_mulSupport_eq'", "code": "@[to_additive]\ntheorem finprod_mem_inter_mulSupport_eq' (f : \u03b1 \u2192 M) (s t : Set \u03b1)\n    (h : \u2200 x \u2208 mulSupport f, x \u2208 s \u2194 x \u2208 t) : \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 i \u2208 t, f i", "start": [565, 1], "end": [570, 29], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_univ", "code": "@[to_additive]\ntheorem finprod_mem_univ (f : \u03b1 \u2192 M) : \u220f\u1da0 i \u2208 @Set.univ \u03b1, f i = \u220f\u1da0 i : \u03b1, f i", "start": [574, 1], "end": [576, 40], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_congr", "code": "@[to_additive]\ntheorem finprod_mem_congr (h\u2080 : s = t) (h\u2081 : \u2200 x \u2208 t, f x = g x) :\n    \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 i \u2208 t, g i", "start": [582, 1], "end": [585, 65], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_one_of_forall_eq_one", "code": "@[to_additive]\ntheorem finprod_eq_one_of_forall_eq_one {f : \u03b1 \u2192 M} (h : \u2200 x, f x = 1) : \u220f\u1da0 i, f i = 1", "start": [589, 1], "end": [591, 46], "kind": "commanddeclaration"}, {"full_name": "one_lt_finprod'", "code": "@[to_additive finsum_pos']\ntheorem one_lt_finprod' {M : Type*} [OrderedCancelCommMonoid M] {f : \u03b9 \u2192 M}\n    (h : \u2200 i, 1 \u2264 f i) (h' : \u2203 i, 1 < f i) (hf : (mulSupport f).Finite) : 1 < \u220f\u1da0 i, f i", "start": [595, 1], "end": [601, 69], "kind": "commanddeclaration"}, {"full_name": "finprod_mul_distrib", "code": "@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i + g i`\n      equals the sum of `f i` plus the sum of `g i`.\"]\ntheorem finprod_mul_distrib (hf : (mulSupport f).Finite) (hg : (mulSupport g).Finite) :\n    \u220f\u1da0 i, f i * g i = (\u220f\u1da0 i, f i) * \u220f\u1da0 i, g i", "start": [608, 1], "end": [625, 18], "kind": "commanddeclaration"}, {"full_name": "finprod_div_distrib", "code": "@[to_additive\n      \"If the additive supports of `f` and `g` are finite, then the sum of `f i - g i`\n      equals the sum of `f i` minus the sum of `g i`.\"]\ntheorem finprod_div_distrib [DivisionCommMonoid G] {f g : \u03b1 \u2192 G} (hf : (mulSupport f).Finite)\n    (hg : (mulSupport g).Finite) : \u220f\u1da0 i, f i / g i = (\u220f\u1da0 i, f i) / \u220f\u1da0 i, g i", "start": [629, 1], "end": [637, 25], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_mul_distrib'", "code": "@[to_additive\n      \"A more general version of `finsum_mem_add_distrib` that only requires `s \u2229 support f`\n      and `s \u2229 support g` rather than `s` to be finite.\"]\ntheorem finprod_mem_mul_distrib' (hf : (s \u2229 mulSupport f).Finite) (hg : (s \u2229 mulSupport g).Finite) :\n    \u220f\u1da0 i \u2208 s, f i * g i = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 s, g i", "start": [641, 1], "end": [649, 75], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_one", "code": "@[to_additive \"The product of the constant function `0` over any set equals `0`.\"]\ntheorem finprod_mem_one (s : Set \u03b1) : (\u220f\u1da0 i \u2208 s, (1 : M)) = 1", "start": [653, 1], "end": [655, 73], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_of_eqOn_one", "code": "@[to_additive\n      \"If a function `f` equals `0` on a set `s`, then the product of `f i` over `i \u2208 s`\n      equals `0`.\"]\ntheorem finprod_mem_of_eqOn_one (hf : s.EqOn f 1) : \u220f\u1da0 i \u2208 s, f i = 1", "start": [659, 1], "end": [665, 33], "kind": "commanddeclaration"}, {"full_name": "exists_ne_one_of_finprod_mem_ne_one", "code": "@[to_additive\n      \"If the product of `f i` over `i \u2208 s` is not equal to `0`, then there is some `x \u2208 s`\n      such that `f x \u2260 0`.\"]\ntheorem exists_ne_one_of_finprod_mem_ne_one (h : \u220f\u1da0 i \u2208 s, f i \u2260 1) : \u2203 x \u2208 s, f x \u2260 1", "start": [669, 1], "end": [676, 39], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_mul_distrib", "code": "@[to_additive\n      \"Given a finite set `s`, the sum of `f i + g i` over `i \u2208 s` equals the sum of `f i`\n      over `i \u2208 s` plus the sum of `g i` over `i \u2208 s`.\"]\ntheorem finprod_mem_mul_distrib (hs : s.Finite) :\n    \u220f\u1da0 i \u2208 s, f i * g i = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 s, g i", "start": [680, 1], "end": [687, 69], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod", "code": "@[to_additive]\ntheorem MonoidHom.map_finprod {f : \u03b1 \u2192 M} (g : M \u2192* N) (hf : (mulSupport f).Finite) :\n    g (\u220f\u1da0 i, f i) = \u220f\u1da0 i, g (f i)", "start": [691, 1], "end": [694, 72], "kind": "commanddeclaration"}, {"full_name": "finprod_pow", "code": "@[to_additive]\ntheorem finprod_pow (hf : (mulSupport f).Finite) (n : \u2115) : (\u220f\u1da0 i, f i) ^ n = \u220f\u1da0 i, f i ^ n", "start": [698, 1], "end": [700, 34], "kind": "commanddeclaration"}, {"full_name": "finsum_smul'", "code": "theorem finsum_smul' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] {f : \u03b9 \u2192 R}\n    (hf : (support f).Finite) (x : M) : (\u2211\u1da0 i, f i) \u2022 x = \u2211\u1da0 i, f i \u2022 x", "start": [704, 1], "end": [708, 42], "kind": "commanddeclaration"}, {"full_name": "smul_finsum'", "code": "theorem smul_finsum' {R M : Type*} [Semiring R] [AddCommMonoid M] [Module R M] (c : R) {f : \u03b9 \u2192 M}\n    (hf : (support f).Finite) : (c \u2022 \u2211\u1da0 i, f i) = \u2211\u1da0 i, c \u2022 f i", "start": [710, 1], "end": [714, 35], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_mem'", "code": "@[to_additive\n      \"A more general version of `AddMonoidHom.map_finsum_mem` that requires\n      `s \u2229 support f` rather than `s` to be finite.\"]\ntheorem MonoidHom.map_finprod_mem' {f : \u03b1 \u2192 M} (g : M \u2192* N) (h\u2080 : (s \u2229 mulSupport f).Finite) :\n    g (\u220f\u1da0 j \u2208 s, f j) = \u220f\u1da0 i \u2208 s, g (f i)", "start": [716, 1], "end": [725, 72], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.map_finprod_mem", "code": "@[to_additive\n      \"Given an additive monoid homomorphism `g : M \u2192* N` and a function `f : \u03b1 \u2192 M`, the\n      value of `g` at the sum of `f i` over `i \u2208 s` equals the sum of `g (f i)` over `s`.\"]\ntheorem MonoidHom.map_finprod_mem (f : \u03b1 \u2192 M) (g : M \u2192* N) (hs : s.Finite) :\n    g (\u220f\u1da0 j \u2208 s, f j) = \u220f\u1da0 i \u2208 s, g (f i)", "start": [729, 1], "end": [736, 42], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.map_finprod_mem", "code": "@[to_additive]\ntheorem MulEquiv.map_finprod_mem (g : M \u2243* N) (f : \u03b1 \u2192 M) {s : Set \u03b1} (hs : s.Finite) :\n    g (\u220f\u1da0 i \u2208 s, f i) = \u220f\u1da0 i \u2208 s, g (f i)", "start": [740, 1], "end": [743, 37], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inv_distrib", "code": "@[to_additive]\ntheorem finprod_mem_inv_distrib [DivisionCommMonoid G] (f : \u03b1 \u2192 G) (hs : s.Finite) :\n    (\u220f\u1da0 x \u2208 s, (f x)\u207b\u00b9) = (\u220f\u1da0 x \u2208 s, f x)\u207b\u00b9", "start": [747, 1], "end": [750, 47], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_div_distrib", "code": "@[to_additive\n      \"Given a finite set `s`, the sum of `f i / g i` over `i \u2208 s` equals the sum of `f i`\n      over `i \u2208 s` minus the sum of `g i` over `i \u2208 s`.\"]\ntheorem finprod_mem_div_distrib [DivisionCommMonoid G] (f g : \u03b1 \u2192 G) (hs : s.Finite) :\n    \u220f\u1da0 i \u2208 s, f i / g i = (\u220f\u1da0 i \u2208 s, f i) / \u220f\u1da0 i \u2208 s, g i", "start": [754, 1], "end": [761, 87], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_empty", "code": "@[to_additive \"The sum of any function over an empty set is `0`.\"]\ntheorem finprod_mem_empty : (\u220f\u1da0 i \u2208 (\u2205 : Set \u03b1), f i) = 1", "start": [770, 1], "end": [772, 69], "kind": "commanddeclaration"}, {"full_name": "nonempty_of_finprod_mem_ne_one", "code": "@[to_additive \"A set `s` is nonempty if the sum of some function over `s` is not equal to `0`.\"]\ntheorem nonempty_of_finprod_mem_ne_one (h : \u220f\u1da0 i \u2208 s, f i \u2260 1) : s.Nonempty", "start": [776, 1], "end": [779, 69], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_union_inter", "code": "@[to_additive\n      \"Given finite sets `s` and `t`, the sum of `f i` over `i \u2208 s \u222a t` plus the sum of\n      `f i` over `i \u2208 s \u2229 t` equals the sum of `f i` over `i \u2208 s` plus the sum of `f i`\n      over `i \u2208 t`.\"]\ntheorem finprod_mem_union_inter (hs : s.Finite) (ht : t.Finite) :\n    ((\u220f\u1da0 i \u2208 s \u222a t, f i) * \u220f\u1da0 i \u2208 s \u2229 t, f i) = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i", "start": [783, 1], "end": [795, 64], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_union_inter'", "code": "@[to_additive\n      \"A more general version of `finsum_mem_union_inter` that requires `s \u2229 support f` and\n      `t \u2229 support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union_inter' (hs : (s \u2229 mulSupport f).Finite) (ht : (t \u2229 mulSupport f).Finite) :\n    ((\u220f\u1da0 i \u2208 s \u222a t, f i) * \u220f\u1da0 i \u2208 s \u2229 t, f i) = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i", "start": [799, 1], "end": [810, 78], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_union'", "code": "@[to_additive\n      \"A more general version of `finsum_mem_union` that requires `s \u2229 support f` and\n      `t \u2229 support f` rather than `s` and `t` to be finite.\"]\ntheorem finprod_mem_union' (hst : Disjoint s t) (hs : (s \u2229 mulSupport f).Finite)\n    (ht : (t \u2229 mulSupport f).Finite) : \u220f\u1da0 i \u2208 s \u222a t, f i = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i", "start": [814, 1], "end": [822, 13], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_union", "code": "@[to_additive\n      \"Given two finite disjoint sets `s` and `t`, the sum of `f i` over `i \u2208 s \u222a t` equals\n      the sum of `f i` over `i \u2208 s` plus the sum of `f i` over `i \u2208 t`.\"]\ntheorem finprod_mem_union (hst : Disjoint s t) (hs : s.Finite) (ht : t.Finite) :\n    \u220f\u1da0 i \u2208 s \u222a t, f i = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i", "start": [826, 1], "end": [833, 67], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_union''", "code": "@[to_additive\n      \"A more general version of `finsum_mem_union'` that requires `s \u2229 support f` and\n      `t \u2229 support f` rather than `s` and `t` to be disjoint\"]\ntheorem finprod_mem_union'' (hst : Disjoint (s \u2229 mulSupport f) (t \u2229 mulSupport f))\n    (hs : (s \u2229 mulSupport f).Finite) (ht : (t \u2229 mulSupport f).Finite) :\n    \u220f\u1da0 i \u2208 s \u222a t, f i = (\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t, f i", "start": [837, 1], "end": [846, 92], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_singleton", "code": "@[to_additive \"The sum of `f i` over `i \u2208 {a}` equals `f a`.\"]\ntheorem finprod_mem_singleton : (\u220f\u1da0 i \u2208 ({a} : Set \u03b1), f i) = f a", "start": [850, 1], "end": [853, 77], "kind": "commanddeclaration"}, {"full_name": "finprod_cond_eq_left", "code": "@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_left : (\u220f\u1da0 (i) (_ : i = a), f i) = f a", "start": [857, 1], "end": [859, 24], "kind": "commanddeclaration"}, {"full_name": "finprod_cond_eq_right", "code": "@[to_additive (attr := simp)]\ntheorem finprod_cond_eq_right : (\u220f\u1da0 (i) (_ : a = i), f i) = f a", "start": [863, 1], "end": [864, 90], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_insert'", "code": "@[to_additive\n      \"A more general version of `finsum_mem_insert` that requires `s \u2229 support f` rather\n      than `s` to be finite.\"]\ntheorem finprod_mem_insert' (f : \u03b1 \u2192 M) (h : a \u2209 s) (hs : (s \u2229 mulSupport f).Finite) :\n    \u220f\u1da0 i \u2208 insert a s, f i = f a * \u220f\u1da0 i \u2208 s, f i", "start": [868, 1], "end": [877, 47], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_insert", "code": "@[to_additive\n      \"Given a finite set `s` and an element `a \u2209 s`, the sum of `f i` over `i \u2208 insert a s`\n      equals `f a` plus the sum of `f i` over `i \u2208 s`.\"]\ntheorem finprod_mem_insert (f : \u03b1 \u2192 M) (h : a \u2209 s) (hs : s.Finite) :\n    \u220f\u1da0 i \u2208 insert a s, f i = f a * \u220f\u1da0 i \u2208 s, f i", "start": [881, 1], "end": [888, 48], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_insert_of_eq_one_if_not_mem", "code": "@[to_additive\n      \"If `f a = 0` when `a \u2209 s`, then the sum of `f i` over `i \u2208 insert a s` equals the sum\n      of `f i` over `i \u2208 s`.\"]\ntheorem finprod_mem_insert_of_eq_one_if_not_mem (h : a \u2209 s \u2192 f a = 1) :\n    \u220f\u1da0 i \u2208 insert a s, f i = \u220f\u1da0 i \u2208 s, f i", "start": [892, 1], "end": [901, 36], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_insert_one", "code": "@[to_additive\n      \"If `f a = 0`, then the sum of `f i` over `i \u2208 insert a s` equals the sum of `f i`\n      over `i \u2208 s`.\"]\ntheorem finprod_mem_insert_one (h : f a = 1) : \u220f\u1da0 i \u2208 insert a s, f i = \u220f\u1da0 i \u2208 s, f i", "start": [905, 1], "end": [911, 53], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_dvd", "code": "theorem finprod_mem_dvd {f : \u03b1 \u2192 N} (a : \u03b1) (hf : (mulSupport f).Finite) : f a \u2223 finprod f", "start": [915, 1], "end": [922, 30], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_pair", "code": "@[to_additive \"The sum of `f i` over `i \u2208 {a, b}`, `a \u2260 b`, is equal to `f a + f b`.\"]\ntheorem finprod_mem_pair (h : a \u2260 b) : (\u220f\u1da0 i \u2208 ({a, b} : Set \u03b1), f i) = f a * f b", "start": [925, 1], "end": [929, 33], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_image'", "code": "@[to_additive\n      \"The sum of `f y` over `y \u2208 g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s \u2229 support (f \u2218 g)`.\"]\ntheorem finprod_mem_image' {s : Set \u03b2} {g : \u03b2 \u2192 \u03b1} (hg : (s \u2229 mulSupport (f \u2218 g)).InjOn g) :\n    \u220f\u1da0 i \u2208 g '' s, f i = \u220f\u1da0 j \u2208 s, f (g j)", "start": [933, 1], "end": [951, 61], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_image", "code": "@[to_additive\n      \"The sum of `f y` over `y \u2208 g '' s` equals the sum of `f (g i)` over `s` provided that\n      `g` is injective on `s`.\"]\ntheorem finprod_mem_image {s : Set \u03b2} {g : \u03b2 \u2192 \u03b1} (hg : s.InjOn g) :\n    \u220f\u1da0 i \u2208 g '' s, f i = \u220f\u1da0 j \u2208 s, f (g j)", "start": [955, 1], "end": [962, 57], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_range'", "code": "@[to_additive\n      \"The sum of `f y` over `y \u2208 Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective on `support (f \u2218 g)`.\"]\ntheorem finprod_mem_range' {g : \u03b2 \u2192 \u03b1} (hg : (mulSupport (f \u2218 g)).InjOn g) :\n    \u220f\u1da0 i \u2208 range g, f i = \u220f\u1da0 j, f (g j)", "start": [966, 1], "end": [974, 19], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_range", "code": "@[to_additive\n      \"The sum of `f y` over `y \u2208 Set.range g` equals the sum of `f (g i)` over all `i`\n      provided that `g` is injective.\"]\ntheorem finprod_mem_range {g : \u03b2 \u2192 \u03b1} (hg : Injective g) : \u220f\u1da0 i \u2208 range g, f i = \u220f\u1da0 j, f (g j)", "start": [978, 1], "end": [984, 34], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_eq_of_bijOn", "code": "@[to_additive \"See also `Finset.sum_bij`.\"]\ntheorem finprod_mem_eq_of_bijOn {s : Set \u03b1} {t : Set \u03b2} {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2)\n    (he\u2080 : s.BijOn e t) (he\u2081 : \u2200 x \u2208 s, f x = g (e x)) : \u220f\u1da0 i \u2208 s, f i = \u220f\u1da0 j \u2208 t, g j", "start": [988, 1], "end": [993, 34], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_of_bijective", "code": "@[to_additive \"See `finsum_comp`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_eq_of_bijective {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2) (he\u2080 : Bijective e)\n    (he\u2081 : \u2200 x, f x = g (e x)) : \u220f\u1da0 i, f i = \u220f\u1da0 j, g j", "start": [997, 1], "end": [1002, 85], "kind": "commanddeclaration"}, {"full_name": "finprod_comp", "code": "@[to_additive \"See also `finsum_eq_of_bijective`, `Fintype.sum_bijective` and `Finset.sum_bij`.\"]\ntheorem finprod_comp {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2) (he\u2080 : Function.Bijective e) :\n    (\u220f\u1da0 i, g (e i)) = \u220f\u1da0 j, g j", "start": [1006, 1], "end": [1010, 45], "kind": "commanddeclaration"}, {"full_name": "finprod_comp_equiv", "code": "@[to_additive]\ntheorem finprod_comp_equiv (e : \u03b1 \u2243 \u03b2) {f : \u03b2 \u2192 M} : (\u220f\u1da0 i, f (e i)) = \u220f\u1da0 i', f i'", "start": [1014, 1], "end": [1016, 29], "kind": "commanddeclaration"}, {"full_name": "finprod_set_coe_eq_finprod_mem", "code": "@[to_additive]\ntheorem finprod_set_coe_eq_finprod_mem (s : Set \u03b1) : \u220f\u1da0 j : s, f j = \u220f\u1da0 i \u2208 s, f i", "start": [1020, 1], "end": [1023, 30], "kind": "commanddeclaration"}, {"full_name": "finprod_subtype_eq_finprod_cond", "code": "@[to_additive]\ntheorem finprod_subtype_eq_finprod_cond (p : \u03b1 \u2192 Prop) :\n    \u220f\u1da0 j : Subtype p, f j = \u220f\u1da0 (i) (_ : p i), f i", "start": [1027, 1], "end": [1030, 45], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inter_mul_diff'", "code": "@[to_additive]\ntheorem finprod_mem_inter_mul_diff' (t : Set \u03b1) (h : (s \u2229 mulSupport f).Finite) :\n    ((\u220f\u1da0 i \u2208 s \u2229 t, f i) * \u220f\u1da0 i \u2208 s \\ t, f i) = \u220f\u1da0 i \u2208 s, f i", "start": [1034, 1], "end": [1040, 41], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_inter_mul_diff", "code": "@[to_additive]\ntheorem finprod_mem_inter_mul_diff (t : Set \u03b1) (h : s.Finite) :\n    ((\u220f\u1da0 i \u2208 s \u2229 t, f i) * \u220f\u1da0 i \u2208 s \\ t, f i) = \u220f\u1da0 i \u2208 s, f i", "start": [1044, 1], "end": [1047, 53], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_mul_diff'", "code": "@[to_additive\n      \"A more general version of `finsum_mem_add_diff` that requires `t \u2229 support f` rather\n      than `t` to be finite.\"]\ntheorem finprod_mem_mul_diff' (hst : s \u2286 t) (ht : (t \u2229 mulSupport f).Finite) :\n    ((\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t \\ s, f i) = \u220f\u1da0 i \u2208 t, f i", "start": [1051, 1], "end": [1058, 77], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_mul_diff", "code": "@[to_additive\n      \"Given a finite set `t` and a subset `s` of `t`, the sum of `f i` over `i \u2208 s` plus\n      the sum of `f i` over `t \\\\ s` equals the sum of `f i` over `i \u2208 t`.\"]\ntheorem finprod_mem_mul_diff (hst : s \u2286 t) (ht : t.Finite) :\n    ((\u220f\u1da0 i \u2208 s, f i) * \u220f\u1da0 i \u2208 t \\ s, f i) = \u220f\u1da0 i \u2208 t, f i", "start": [1062, 1], "end": [1069, 49], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_iUnion", "code": "@[to_additive\n      \"Given a family of pairwise disjoint finite sets `t i` indexed by a finite type, the\n      sum of `f a` over the union `\u22c3 i, t i` is equal to the sum over all indexes `i` of the\n      sums of `f a` over `a \u2208 t i`.\"]\ntheorem finprod_mem_iUnion [Finite \u03b9] {t : \u03b9 \u2192 Set \u03b1} (h : Pairwise (Disjoint on t))\n    (ht : \u2200 i, (t i).Finite) : \u220f\u1da0 a \u2208 \u22c3 i : \u03b9, t i, f a = \u220f\u1da0 i, \u220f\u1da0 a \u2208 t i, f a", "start": [1073, 1], "end": [1088, 61], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_biUnion", "code": "@[to_additive\n      \"Given a family of sets `t : \u03b9 \u2192 Set \u03b1`, a finite set `I` in the index type such that\n      all sets `t i`, `i \u2208 I`, are finite, if all `t i`, `i \u2208 I`, are pairwise disjoint, then the\n      sum of `f a` over `a \u2208 \u22c3 i \u2208 I, t i` is equal to the sum over `i \u2208 I` of the sums of `f a`\n      over `a \u2208 t i`.\"]\ntheorem finprod_mem_biUnion {I : Set \u03b9} {t : \u03b9 \u2192 Set \u03b1} (h : I.PairwiseDisjoint t) (hI : I.Finite)\n    (ht : \u2200 i \u2208 I, (t i).Finite) : \u220f\u1da0 a \u2208 \u22c3 x \u2208 I, t x, f a = \u220f\u1da0 i \u2208 I, \u220f\u1da0 j \u2208 t i, f j", "start": [1092, 1], "end": [1105, 86], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_sUnion", "code": "@[to_additive\n      \"If `t` is a finite set of pairwise disjoint finite sets, then the sum of `f a` over\n      `a \u2208 \u22c3\u2080 t` is the sum over `s \u2208 t` of the sums of `f a` over `a \u2208 s`.\"]\ntheorem finprod_mem_sUnion {t : Set (Set \u03b1)} (h : t.PairwiseDisjoint id) (ht\u2080 : t.Finite)\n    (ht\u2081 : \u2200 x \u2208 t, Set.Finite x) : \u220f\u1da0 a \u2208 \u22c3\u2080 t, f a = \u220f\u1da0 s \u2208 t, \u220f\u1da0 a \u2208 s, f a", "start": [1109, 1], "end": [1117, 38], "kind": "commanddeclaration"}, {"full_name": "mul_finprod_cond_ne", "code": "@[to_additive]\ntheorem mul_finprod_cond_ne (a : \u03b1) (hf : (mulSupport f).Finite) :\n    (f a * \u220f\u1da0 (i) (_ : i \u2260 a), f i) = \u220f\u1da0 i, f i", "start": [1121, 1], "end": [1135, 35], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_comm", "code": "@[to_additive\n      \"If `s : Set \u03b1` and `t : Set \u03b2` are finite sets, then summing over `s` commutes with\n      summing over `t`.\"]\ntheorem finprod_mem_comm {s : Set \u03b1} {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 M) (hs : s.Finite) (ht : t.Finite) :\n    (\u220f\u1da0 i \u2208 s, \u220f\u1da0 j \u2208 t, f i j) = \u220f\u1da0 j \u2208 t, \u220f\u1da0 i \u2208 s, f i j", "start": [1139, 1], "end": [1148, 25], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_induction", "code": "@[to_additive\n      \"To prove a property of a finite sum, it suffices to prove that the property is\n      additive and holds on summands.\"]\ntheorem finprod_mem_induction (p : M \u2192 Prop) (hp\u2080 : p 1) (hp\u2081 : \u2200 x y, p x \u2192 p y \u2192 p (x * y))\n    (hp\u2082 : \u2200 x \u2208 s, p <| f x) : p (\u220f\u1da0 i \u2208 s, f i)", "start": [1152, 1], "end": [1159, 76], "kind": "commanddeclaration"}, {"full_name": "finprod_cond_nonneg", "code": "theorem finprod_cond_nonneg {R : Type*} [OrderedCommSemiring R] {p : \u03b1 \u2192 Prop} {f : \u03b1 \u2192 R}\n    (hf : \u2200 x, p x \u2192 0 \u2264 f x) : 0 \u2264 \u220f\u1da0 (x) (_ : p x), f x", "start": [1163, 1], "end": [1165, 49], "kind": "commanddeclaration"}, {"full_name": "single_le_finprod", "code": "@[to_additive]\ntheorem single_le_finprod {M : Type*} [OrderedCommMonoid M] (i : \u03b1) {f : \u03b1 \u2192 M}\n    (hf : (mulSupport f).Finite) (h : \u2200 j, 1 \u2264 f j) : f i \u2264 \u220f\u1da0 j, f j", "start": [1168, 1], "end": [1175, 93], "kind": "commanddeclaration"}, {"full_name": "finprod_eq_zero", "code": "theorem finprod_eq_zero {M\u2080 : Type*} [CommMonoidWithZero M\u2080] (f : \u03b1 \u2192 M\u2080) (x : \u03b1) (hx : f x = 0)\n    (hf : (mulSupport f).Finite) : \u220f\u1da0 x, f x = 0", "start": [1179, 1], "end": [1184, 12], "kind": "commanddeclaration"}, {"full_name": "finprod_prod_comm", "code": "@[to_additive]\ntheorem finprod_prod_comm (s : Finset \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 M)\n    (h : \u2200 b \u2208 s, (mulSupport fun a => f a b).Finite) :\n    (\u220f\u1da0 a : \u03b1, \u220f b in s, f a b) = \u220f b in s, \u220f\u1da0 a : \u03b1, f a b", "start": [1187, 1], "end": [1203, 20], "kind": "commanddeclaration"}, {"full_name": "prod_finprod_comm", "code": "@[to_additive]\ntheorem prod_finprod_comm (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2 \u2192 M) (h : \u2200 a \u2208 s, (mulSupport (f a)).Finite) :\n    (\u220f a in s, \u220f\u1da0 b : \u03b2, f a b) = \u220f\u1da0 b : \u03b2, \u220f a in s, f a b", "start": [1207, 1], "end": [1210, 50], "kind": "commanddeclaration"}, {"full_name": "mul_finsum", "code": "theorem mul_finsum {R : Type*} [Semiring R] (f : \u03b1 \u2192 R) (r : R) (h : (support f).Finite) :\n    (r * \u2211\u1da0 a : \u03b1, f a) = \u2211\u1da0 a : \u03b1, r * f a", "start": [1214, 1], "end": [1216, 40], "kind": "commanddeclaration"}, {"full_name": "finsum_mul", "code": "theorem finsum_mul {R : Type*} [Semiring R] (f : \u03b1 \u2192 R) (r : R) (h : (support f).Finite) :\n    (\u2211\u1da0 a : \u03b1, f a) * r = \u2211\u1da0 a : \u03b1, f a * r", "start": [1219, 1], "end": [1221, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.mulSupport_of_fiberwise_prod_subset_image", "code": "@[to_additive]\ntheorem Finset.mulSupport_of_fiberwise_prod_subset_image [DecidableEq \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 M)\n    (g : \u03b1 \u2192 \u03b2) : (mulSupport fun b => (s.filter fun a => g a = b).prod f) \u2286 s.image g", "start": [1224, 1], "end": [1231, 41], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_finset_product'", "code": "@[to_additive\n      \"Note that `b \u2208 (s.filter (fun ab => Prod.fst ab = a)).image Prod.snd` iff `(a, b) \u2208 s` so\n      we can simplify the right hand side of this lemma. However the form stated here is more\n      useful for iterating this lemma, e.g., if we have `f : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M`.\"]\ntheorem finprod_mem_finset_product' [DecidableEq \u03b1] [DecidableEq \u03b2] (s : Finset (\u03b1 \u00d7 \u03b2))\n    (f : \u03b1 \u00d7 \u03b2 \u2192 M) :\n    (\u220f\u1da0 (ab) (_ : ab \u2208 s), f ab) =\n      \u220f\u1da0 (a) (b) (_ : b \u2208 (s.filter fun ab => Prod.fst ab = a).image Prod.snd), f (a, b)", "start": [1235, 1], "end": [1261, 33], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_finset_product", "code": "@[to_additive \"See also `finsum_mem_finset_product'`.\"]\ntheorem finprod_mem_finset_product (s : Finset (\u03b1 \u00d7 \u03b2)) (f : \u03b1 \u00d7 \u03b2 \u2192 M) :\n    (\u220f\u1da0 (ab) (_ : ab \u2208 s), f ab) = \u220f\u1da0 (a) (b) (_ : (a, b) \u2208 s), f (a, b)", "start": [1265, 1], "end": [1271, 9], "kind": "commanddeclaration"}, {"full_name": "finprod_mem_finset_product\u2083", "code": "@[to_additive]\ntheorem finprod_mem_finset_product\u2083 {\u03b3 : Type*} (s : Finset (\u03b1 \u00d7 \u03b2 \u00d7 \u03b3)) (f : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M) :\n    (\u220f\u1da0 (abc) (_ : abc \u2208 s), f abc) = \u220f\u1da0 (a) (b) (c) (_ : (a, b, c) \u2208 s), f (a, b, c)", "start": [1275, 1], "end": [1281, 9], "kind": "commanddeclaration"}, {"full_name": "finprod_curry", "code": "@[to_additive]\ntheorem finprod_curry (f : \u03b1 \u00d7 \u03b2 \u2192 M) (hf : (mulSupport f).Finite) :\n    \u220f\u1da0 ab, f ab = \u220f\u1da0 (a) (b), f (a, b)", "start": [1285, 1], "end": [1290, 47], "kind": "commanddeclaration"}, {"full_name": "finprod_curry\u2083", "code": "@[to_additive]\ntheorem finprod_curry\u2083 {\u03b3 : Type*} (f : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 \u2192 M) (h : (mulSupport f).Finite) :\n    \u220f\u1da0 abc, f abc = \u220f\u1da0 (a) (b) (c), f (a, b, c)", "start": [1294, 1], "end": [1301, 11], "kind": "commanddeclaration"}, {"full_name": "finprod_dmem", "code": "@[to_additive]\ntheorem finprod_dmem {s : Set \u03b1} [DecidablePred (\u00b7 \u2208 s)] (f : \u2200 a : \u03b1, a \u2208 s \u2192 M) :\n    (\u220f\u1da0 (a : \u03b1) (h : a \u2208 s), f a h) = \u220f\u1da0 (a : \u03b1) (_ : a \u2208 s), if h' : a \u2208 s then f a h' else 1", "start": [1305, 1], "end": [1308, 67], "kind": "commanddeclaration"}, {"full_name": "finprod_emb_domain'", "code": "@[to_additive]\ntheorem finprod_emb_domain' {f : \u03b1 \u2192 \u03b2} (hf : Injective f) [DecidablePred (\u00b7 \u2208 Set.range f)]\n    (g : \u03b1 \u2192 M) :\n    (\u220f\u1da0 b : \u03b2, if h : b \u2208 Set.range f then g (Classical.choose h) else 1) = \u220f\u1da0 a : \u03b1, g a", "start": [1312, 1], "end": [1319, 89], "kind": "commanddeclaration"}, {"full_name": "finprod_emb_domain", "code": "@[to_additive]\ntheorem finprod_emb_domain (f : \u03b1 \u21aa \u03b2) [DecidablePred (\u00b7 \u2208 Set.range f)] (g : \u03b1 \u2192 M) :\n    (\u220f\u1da0 b : \u03b2, if h : b \u2208 Set.range f then g (Classical.choose h) else 1) = \u220f\u1da0 a : \u03b1, g a", "start": [1323, 1], "end": [1326, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/LinearIndependent.lean", "imports": ["Mathlib/Tactic/LinearCombination.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "Mathlib/LinearAlgebra/Prod.lean"], "premises": [{"full_name": "LinearIndependent", "code": "def LinearIndependent : Prop :=\n  LinearMap.ker (Finsupp.total \u03b9 M R v) = \u22a5", "start": [98, 1], "end": [100, 44], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff", "code": "theorem linearIndependent_iff : LinearIndependent R v \u2194 \u2200 l, Finsupp.total \u03b9 M R v l = 0 \u2192 l = 0", "start": [105, 1], "end": [106, 53], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff'", "code": "theorem linearIndependent_iff' :\n    LinearIndependent R v \u2194\n      \u2200 s : Finset \u03b9, \u2200 g : \u03b9 \u2192 R, \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i \u2208 s, g i = 0", "start": [109, 1], "end": [129, 96], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff''", "code": "theorem linearIndependent_iff'' :\n    LinearIndependent R v \u2194\n      \u2200 (s : Finset \u03b9) (g : \u03b9 \u2192 R) (_hg : \u2200 (i) (_ : i \u2209 s), g i = 0),\n        \u2211 i in s, g i \u2022 v i = 0 \u2192 \u2200 i, g i = 0", "start": [132, 1], "end": [142, 30], "kind": "commanddeclaration"}, {"full_name": "not_linearIndependent_iff", "code": "theorem not_linearIndependent_iff :\n    \u00acLinearIndependent R v \u2194\n      \u2203 s : Finset \u03b9, \u2203 g : \u03b9 \u2192 R, \u2211 i in s, g i \u2022 v i = 0 \u2227 \u2203 i \u2208 s, g i \u2260 0", "start": [145, 1], "end": [149, 38], "kind": "commanddeclaration"}, {"full_name": "Fintype.linearIndependent_iff", "code": "theorem Fintype.linearIndependent_iff [Fintype \u03b9] :\n    LinearIndependent R v \u2194 \u2200 g : \u03b9 \u2192 R, \u2211 i, g i \u2022 v i = 0 \u2192 \u2200 i, g i = 0", "start": [152, 1], "end": [159, 26], "kind": "commanddeclaration"}, {"full_name": "Fintype.linearIndependent_iff'", "code": "theorem Fintype.linearIndependent_iff' [Fintype \u03b9] [DecidableEq \u03b9] :\n    LinearIndependent R v \u2194\n      LinearMap.ker (LinearMap.lsum R (fun _ \u21a6 R) \u2115 fun i \u21a6 LinearMap.id.smulRight (v i)) = \u22a5", "start": [162, 1], "end": [167, 77], "kind": "commanddeclaration"}, {"full_name": "Fintype.not_linearIndependent_iff", "code": "theorem Fintype.not_linearIndependent_iff [Fintype \u03b9] :\n    \u00acLinearIndependent R v \u2194 \u2203 g : \u03b9 \u2192 R, \u2211 i, g i \u2022 v i = 0 \u2227 \u2203 i, g i \u2260 0", "start": [170, 1], "end": [172, 58], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_empty_type", "code": "theorem linearIndependent_empty_type [IsEmpty \u03b9] : LinearIndependent R v", "start": [175, 1], "end": [176, 63], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.ne_zero", "code": "theorem LinearIndependent.ne_zero [Nontrivial R] (i : \u03b9) (hv : LinearIndependent R v) : v i \u2260 0", "start": [179, 1], "end": [187, 20], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.eq_zero_of_pair", "code": "lemma LinearIndependent.eq_zero_of_pair {x y : M} (h : LinearIndependent R ![x, y])\n    {s t : R} (h' : s \u2022 x + t \u2022 y = 0) : s = 0 \u2227 t = 0 := by\n  have := linearIndependent_iff'.1 h Finset.univ ![s, t]\n  simp only [Fin.sum_univ_two, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons, h',\n    Finset.mem_univ, forall_true_left] at this\n  exact \u27e8this 0, this 1\u27e9", "start": [190, 1], "end": [195, 25], "kind": "mathlibtacticlemma"}, {"full_name": "LinearIndependent.pair_iff", "code": "lemma LinearIndependent.pair_iff {x y : M} :\n    LinearIndependent R ![x, y] \u2194 \u2200 (s t : R), s \u2022 x + t \u2022 y = 0 \u2192 s = 0 \u2227 t = 0 := by\n  refine \u27e8fun h s t hst \u21a6 h.eq_zero_of_pair hst, fun h \u21a6 ?_\u27e9\n  apply Fintype.linearIndependent_iff.2\n  intro g hg\n  simp only [Fin.sum_univ_two, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons] at hg\n  intro i\n  fin_cases i\n  exacts [(h _ _ hg).1, (h _ _ hg).2]", "start": [197, 1], "end": [205, 38], "kind": "mathlibtacticlemma"}, {"full_name": "LinearIndependent.comp", "code": "theorem LinearIndependent.comp (h : LinearIndependent R v) (f : \u03b9' \u2192 \u03b9) (hf : Injective f) :\n    LinearIndependent R (v \u2218 f)", "start": [207, 1], "end": [217, 34], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.coe_range", "code": "theorem LinearIndependent.coe_range (i : LinearIndependent R v) :\n    LinearIndependent R ((\u2191) : range v \u2192 M)", "start": [220, 1], "end": [221, 100], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.map", "code": "theorem LinearIndependent.map (hv : LinearIndependent R v) {f : M \u2192\u2097[R] M'}\n    (hf_inj : Disjoint (span R (range v)) (LinearMap.ker f)) : LinearIndependent R (f \u2218 v)", "start": [224, 1], "end": [237, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.range_ker_disjoint", "code": "theorem Submodule.range_ker_disjoint {f : M \u2192\u2097[R] M'}\n    (hv : LinearIndependent R (f \u2218 v)) :\n    Disjoint (span R (range v)) (LinearMap.ker f)", "start": [240, 1], "end": [248, 55], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.map'", "code": "theorem LinearIndependent.map' (hv : LinearIndependent R v) (f : M \u2192\u2097[R] M')\n    (hf_inj : LinearMap.ker f = \u22a5) : LinearIndependent R (f \u2218 v)", "start": [250, 1], "end": [254, 29], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.of_comp", "code": "theorem LinearIndependent.of_comp (f : M \u2192\u2097[R] M') (hfv : LinearIndependent R (f \u2218 v)) :\n    LinearIndependent R v", "start": [257, 1], "end": [264, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.linearIndependent_iff", "code": "protected theorem LinearMap.linearIndependent_iff (f : M \u2192\u2097[R] M') (hf_inj : LinearMap.ker f = \u22a5) :\n    LinearIndependent R (f \u2218 v) \u2194 LinearIndependent R v", "start": [267, 1], "end": [271, 86], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_of_subsingleton", "code": "@[nontriviality]\ntheorem linearIndependent_of_subsingleton [Subsingleton R] : LinearIndependent R v", "start": [274, 1], "end": [276, 62], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_equiv", "code": "theorem linearIndependent_equiv (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 M} :\n    LinearIndependent R (f \u2218 e) \u2194 LinearIndependent R f", "start": [279, 1], "end": [282, 26], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_equiv'", "code": "theorem linearIndependent_equiv' (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 M} {g : \u03b9 \u2192 M} (h : f \u2218 e = g) :\n    LinearIndependent R g \u2194 LinearIndependent R f", "start": [285, 1], "end": [287, 32], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_subtype_range", "code": "theorem linearIndependent_subtype_range {\u03b9} {f : \u03b9 \u2192 M} (hf : Injective f) :\n    LinearIndependent R ((\u2191) : range f \u2192 M) \u2194 LinearIndependent R f", "start": [290, 1], "end": [292, 68], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.of_subtype_range", "code": "alias \u27e8LinearIndependent.of_subtype_range, _\u27e9 := linearIndependent_subtype_range", "start": [295, 1], "end": [295, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "linearIndependent_image", "code": "theorem linearIndependent_image {\u03b9} {s : Set \u03b9} {f : \u03b9 \u2192 M} (hf : Set.InjOn f s) :\n    (LinearIndependent R fun x : s => f x) \u2194 LinearIndependent R fun x : f '' s => (x : M)", "start": [298, 1], "end": [300, 63], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_span", "code": "theorem linearIndependent_span (hs : LinearIndependent R v) :\n    @LinearIndependent \u03b9 R (span R (range v)) (fun i : \u03b9 => \u27e8v i, subset_span (mem_range_self i)\u27e9) _\n      _ _", "start": [303, 1], "end": [306, 58], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.fin_cons'", "code": "theorem LinearIndependent.fin_cons' {m : \u2115} (x : M) (v : Fin m \u2192 M) (hli : LinearIndependent R v)\n    (x_ortho : \u2200 (c : R) (y : Submodule.span R (Set.range v)), c \u2022 x + y = (0 : M) \u2192 c = 0) :\n    LinearIndependent R (Fin.cons x v : Fin m.succ \u2192 M)", "start": [309, 1], "end": [320, 42], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.restrict_scalars", "code": "theorem LinearIndependent.restrict_scalars [Semiring K] [SMulWithZero R K] [Module K M]\n    [IsScalarTower R K M] (hinj : Function.Injective fun r : R => r \u2022 (1 : K))\n    (li : LinearIndependent K v) : LinearIndependent R v", "start": [323, 1], "end": [335, 11], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_finset_map_embedding_subtype", "code": "theorem linearIndependent_finset_map_embedding_subtype (s : Set M)\n    (li : LinearIndependent R ((\u2191) : s \u2192 M)) (t : Finset s) :\n    LinearIndependent R ((\u2191) : Finset.map (Embedding.subtype s) t \u2192 M)", "start": [338, 1], "end": [353, 41], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_bounded_of_finset_linearIndependent_bounded", "code": "theorem linearIndependent_bounded_of_finset_linearIndependent_bounded {n : \u2115}\n    (H : \u2200 s : Finset M, (LinearIndependent R fun i : s => (i : M)) \u2192 s.card \u2264 n) :\n    \u2200 s : Set M, LinearIndependent R ((\u2191) : s \u2192 M) \u2192 #s \u2264 n", "start": [356, 1], "end": [367, 60], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_comp_subtype", "code": "theorem linearIndependent_comp_subtype {s : Set \u03b9} :\n    LinearIndependent R (v \u2218 (\u2191) : s \u2192 M) \u2194\n      \u2200 l \u2208 Finsupp.supported R R s, (Finsupp.total \u03b9 M R v) l = 0 \u2192 l = 0", "start": [375, 1], "end": [390, 67], "kind": "commanddeclaration"}, {"full_name": "linearDependent_comp_subtype'", "code": "theorem linearDependent_comp_subtype' {s : Set \u03b9} :\n    \u00acLinearIndependent R (v \u2218 (\u2191) : s \u2192 M) \u2194\n      \u2203 f : \u03b9 \u2192\u2080 R, f \u2208 Finsupp.supported R R s \u2227 Finsupp.total \u03b9 M R v f = 0 \u2227 f \u2260 0", "start": [393, 1], "end": [396, 58], "kind": "commanddeclaration"}, {"full_name": "linearDependent_comp_subtype", "code": "theorem linearDependent_comp_subtype {s : Set \u03b9} :\n    \u00acLinearIndependent R (v \u2218 (\u2191) : s \u2192 M) \u2194\n      \u2203 f : \u03b9 \u2192\u2080 R, f \u2208 Finsupp.supported R R s \u2227 \u2211 i in f.support, f i \u2022 v i = 0 \u2227 f \u2260 0", "start": [399, 1], "end": [403, 32], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_subtype", "code": "theorem linearIndependent_subtype {s : Set M} :\n    LinearIndependent R (fun x => x : s \u2192 M) \u2194\n      \u2200 l \u2208 Finsupp.supported R R s, (Finsupp.total M M R id) l = 0 \u2192 l = 0", "start": [406, 1], "end": [409, 52], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_comp_subtype_disjoint", "code": "theorem linearIndependent_comp_subtype_disjoint {s : Set \u03b9} :\n    LinearIndependent R (v \u2218 (\u2191) : s \u2192 M) \u2194\n      Disjoint (Finsupp.supported R R s) (LinearMap.ker $ Finsupp.total \u03b9 M R v)", "start": [412, 1], "end": [415, 65], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_subtype_disjoint", "code": "theorem linearIndependent_subtype_disjoint {s : Set M} :\n    LinearIndependent R (fun x => x : s \u2192 M) \u2194\n      Disjoint (Finsupp.supported R R s) (LinearMap.ker $ Finsupp.total M M R id)", "start": [418, 1], "end": [421, 61], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_totalOn", "code": "theorem linearIndependent_iff_totalOn {s : Set M} :\n    LinearIndependent R (fun x => x : s \u2192 M) \u2194\n    (LinearMap.ker $ Finsupp.totalOn M M R id s) = \u22a5", "start": [424, 1], "end": [429, 80], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.restrict_of_comp_subtype", "code": "theorem LinearIndependent.restrict_of_comp_subtype {s : Set \u03b9}\n    (hs : LinearIndependent R (v \u2218 (\u2191) : s \u2192 M)) : LinearIndependent R (s.restrict v)", "start": [432, 1], "end": [434, 5], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_empty", "code": "theorem linearIndependent_empty : LinearIndependent R (fun x => x : (\u2205 : Set M) \u2192 M)", "start": [439, 1], "end": [440, 44], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.mono", "code": "theorem LinearIndependent.mono {t s : Set M} (h : t \u2286 s) :\n    LinearIndependent R (fun x => x : s \u2192 M) \u2192 LinearIndependent R (fun x => x : t \u2192 M)", "start": [445, 1], "end": [448, 54], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_of_finite", "code": "theorem linearIndependent_of_finite (s : Set M)\n    (H : \u2200 (t) (_ : t \u2286 s), Set.Finite t \u2192 LinearIndependent R (fun x => x : t \u2192 M)) :\n    LinearIndependent R (fun x => x : s \u2192 M)", "start": [451, 1], "end": [455, 83], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iUnion_of_directed", "code": "theorem linearIndependent_iUnion_of_directed {\u03b7 : Type*} {s : \u03b7 \u2192 Set M} (hs : Directed (\u00b7 \u2286 \u00b7) s)\n    (h : \u2200 i, LinearIndependent R (fun x => x : s i \u2192 M)) :\n    LinearIndependent R (fun x => x : (\u22c3 i, s i) \u2192 M)", "start": [458, 1], "end": [469, 17], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_sUnion_of_directed", "code": "theorem linearIndependent_sUnion_of_directed {s : Set (Set M)} (hs : DirectedOn (\u00b7 \u2286 \u00b7) s)\n    (h : \u2200 a \u2208 s, LinearIndependent R ((\u2191) : ((a : Set M) : Type _) \u2192 M)) :\n    LinearIndependent R (fun x => x : \u22c3\u2080 s \u2192 M)", "start": [472, 1], "end": [476, 82], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_biUnion_of_directed", "code": "theorem linearIndependent_biUnion_of_directed {\u03b7} {s : Set \u03b7} {t : \u03b7 \u2192 Set M}\n    (hs : DirectedOn (t \u207b\u00b9'o (\u00b7 \u2286 \u00b7)) s) (h : \u2200 a \u2208 s, LinearIndependent R (fun x => x : t a \u2192 M)) :\n    LinearIndependent R (fun x => x : (\u22c3 a \u2208 s, t a) \u2192 M)", "start": [479, 1], "end": [484, 97], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_injective_total", "code": "theorem linearIndependent_iff_injective_total :\n    LinearIndependent R v \u2194 Function.Injective (Finsupp.total \u03b9 M R v)", "start": [501, 1], "end": [504, 76], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.injective_total", "code": "alias \u27e8LinearIndependent.injective_total, _\u27e9 := linearIndependent_iff_injective_total", "start": [507, 1], "end": [507, 86], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LinearIndependent.injective", "code": "theorem LinearIndependent.injective [Nontrivial R] (hv : LinearIndependent R v) : Injective v", "start": [510, 1], "end": [519, 57], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.to_subtype_range", "code": "theorem LinearIndependent.to_subtype_range {\u03b9} {f : \u03b9 \u2192 M} (hf : LinearIndependent R f) :\n    LinearIndependent R ((\u2191) : range f \u2192 M)", "start": [522, 1], "end": [525, 60], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.to_subtype_range'", "code": "theorem LinearIndependent.to_subtype_range' {\u03b9} {f : \u03b9 \u2192 M} (hf : LinearIndependent R f) {t}\n    (ht : range f = t) : LinearIndependent R ((\u2191) : t \u2192 M)", "start": [528, 1], "end": [530, 27], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.image_of_comp", "code": "theorem LinearIndependent.image_of_comp {\u03b9 \u03b9'} (s : Set \u03b9) (f : \u03b9 \u2192 \u03b9') (g : \u03b9' \u2192 M)\n    (hs : LinearIndependent R fun x : s => g (f x)) :\n    LinearIndependent R fun x : f '' s => g x", "start": [533, 1], "end": [538, 78], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.image", "code": "theorem LinearIndependent.image {\u03b9} {s : Set \u03b9} {f : \u03b9 \u2192 M}\n    (hs : LinearIndependent R fun x : s => f x) : LinearIndependent R fun x : f '' s => (x : M)", "start": [541, 1], "end": [543, 55], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.group_smul", "code": "theorem LinearIndependent.group_smul {G : Type*} [hG : Group G] [DistribMulAction G R]\n    [DistribMulAction G M] [IsScalarTower G R M] [SMulCommClass G R M] {v : \u03b9 \u2192 M}\n    (hv : LinearIndependent R v) (w : \u03b9 \u2192 G) : LinearIndependent R (w \u2022 v)", "start": [546, 1], "end": [557, 47], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.units_smul", "code": "theorem LinearIndependent.units_smul {v : \u03b9 \u2192 M} (hv : LinearIndependent R v) (w : \u03b9 \u2192 R\u02e3) :\n    LinearIndependent R (w \u2022 v)", "start": [562, 1], "end": [573, 8], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.eq_of_pair", "code": "lemma LinearIndependent.eq_of_pair {x y : M} (h : LinearIndependent R ![x, y])\n    {s t s' t' : R} (h' : s \u2022 x + t \u2022 y = s' \u2022 x + t' \u2022 y) : s = s' \u2227 t = t' := by\n  have : (s - s') \u2022 x + (t - t') \u2022 y = 0 := by\n    rw [\u2190 sub_eq_zero_of_eq h', \u2190 sub_eq_zero]\n    simp only [sub_smul]\n    abel\n  simpa [sub_eq_zero] using h.eq_zero_of_pair this", "start": [576, 1], "end": [582, 51], "kind": "mathlibtacticlemma"}, {"full_name": "LinearIndependent.eq_zero_of_pair'", "code": "lemma LinearIndependent.eq_zero_of_pair' {x y : M} (h : LinearIndependent R ![x, y])\n    {s t : R} (h' : s \u2022 x = t \u2022 y) : s = 0 \u2227 t = 0 := by\n  suffices H : s = 0 \u2227 0 = t from \u27e8H.1, H.2.symm\u27e9\n  exact h.eq_of_pair (by simpa using h')", "start": [584, 1], "end": [587, 41], "kind": "mathlibtacticlemma"}, {"full_name": "LinearIndependent.linear_combination_pair_of_det_ne_zero", "code": "lemma LinearIndependent.linear_combination_pair_of_det_ne_zero {R M : Type*} [CommRing R]\n    [NoZeroDivisors R] [AddCommGroup M] [Module R M]\n    {x y : M} (h : LinearIndependent R ![x, y])\n    {a b c d : R} (h' : a * d - b * c \u2260 0) :\n    LinearIndependent R ![a \u2022 x + b \u2022 y, c \u2022 x + d \u2022 y] := by\n  apply LinearIndependent.pair_iff.2 (fun s t hst \u21a6 ?_)\n  have H : (s * a + t * c) \u2022 x + (s * b + t * d) \u2022 y = 0 := by\n    convert hst using 1\n    simp only [_root_.add_smul, smul_add, smul_smul]\n    abel\n  have I1 : s * a + t * c = 0 := (h.eq_zero_of_pair H).1\n  have I2 : s * b + t * d = 0 := (h.eq_zero_of_pair H).2\n  have J1 : (a * d - b * c) * s = 0 := by linear_combination d * I1 - c * I2\n  have J2 : (a * d - b * c) * t = 0 := by linear_combination -b * I1 + a * I2\n  exact \u27e8by simpa [h'] using mul_eq_zero.1 J1, by simpa [h'] using mul_eq_zero.1 J2\u27e9", "start": [589, 1], "end": [605, 85], "kind": "mathlibtacticlemma"}, {"full_name": "LinearIndependent.Maximal", "code": "@[nolint unusedArguments]\ndef LinearIndependent.Maximal {\u03b9 : Type w} {R : Type u} [Semiring R] {M : Type v} [AddCommMonoid M]\n    [Module R M] {v : \u03b9 \u2192 M} (_i : LinearIndependent R v) : Prop :=\n  \u2200 (s : Set M) (_i' : LinearIndependent R ((\u2191) : s \u2192 M)) (_h : range v \u2264 s), range v = s", "start": [611, 1], "end": [617, 90], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.maximal_iff", "code": "theorem LinearIndependent.maximal_iff {\u03b9 : Type w} {R : Type u} [Ring R] [Nontrivial R] {M : Type v}\n    [AddCommGroup M] [Module R M] {v : \u03b9 \u2192 M} (i : LinearIndependent R v) :\n    i.Maximal \u2194\n      \u2200 (\u03ba : Type v) (w : \u03ba \u2192 M) (_i' : LinearIndependent R w) (j : \u03b9 \u2192 \u03ba) (_h : w \u2218 j = v),\n        Surjective j", "start": [620, 1], "end": [642, 18], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.eq_of_smul_apply_eq_smul_apply", "code": "theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type*} [AddCommGroup M] [Module R M]\n    {v : \u03b9 \u2192 M} (li : LinearIndependent R v) (c d : R) (i j : \u03b9) (hc : c \u2260 0)\n    (h : c \u2022 v i = d \u2022 v j) : i = j", "start": [647, 1], "end": [660, 18], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.disjoint_span_image", "code": "theorem LinearIndependent.disjoint_span_image (hv : LinearIndependent R v) {s t : Set \u03b9}\n    (hs : Disjoint s t) : Disjoint (Submodule.span R <| v '' s) (Submodule.span R <| v '' t)", "start": [667, 1], "end": [673, 14], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.not_mem_span_image", "code": "theorem LinearIndependent.not_mem_span_image [Nontrivial R] (hv : LinearIndependent R v) {s : Set \u03b9}\n    {x : \u03b9} (h : x \u2209 s) : v x \u2209 Submodule.span R (v '' s)", "start": [676, 1], "end": [684, 16], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.total_ne_of_not_mem_support", "code": "theorem LinearIndependent.total_ne_of_not_mem_support [Nontrivial R] (hv : LinearIndependent R v)\n    {x : \u03b9} (f : \u03b9 \u2192\u2080 R) (h : x \u2209 f.support) : Finsupp.total \u03b9 M R v f \u2260 v x", "start": [687, 1], "end": [695, 44], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_sum", "code": "theorem linearIndependent_sum {v : Sum \u03b9 \u03b9' \u2192 M} :\n    LinearIndependent R v \u2194\n      LinearIndependent R (v \u2218 Sum.inl) \u2227\n        LinearIndependent R (v \u2218 Sum.inr) \u2227\n          Disjoint (Submodule.span R (range (v \u2218 Sum.inl)))\n            (Submodule.span R (range (v \u2218 Sum.inr)))", "start": [698, 1], "end": [736, 50], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.sum_type", "code": "theorem LinearIndependent.sum_type {v' : \u03b9' \u2192 M} (hv : LinearIndependent R v)\n    (hv' : LinearIndependent R v')\n    (h : Disjoint (Submodule.span R (range v)) (Submodule.span R (range v'))) :\n    LinearIndependent R (Sum.elim v v')", "start": [739, 1], "end": [743, 39], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.union", "code": "theorem LinearIndependent.union {s t : Set M} (hs : LinearIndependent R (fun x => x : s \u2192 M))\n    (ht : LinearIndependent R (fun x => x : t \u2192 M)) (hst : Disjoint (span R s) (span R t)) :\n    LinearIndependent R (fun x => x : \u21a5(s \u222a t) \u2192 M)", "start": [746, 1], "end": [749, 60], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iUnion_finite_subtype", "code": "theorem linearIndependent_iUnion_finite_subtype {\u03b9 : Type*} {f : \u03b9 \u2192 Set M}\n    (hl : \u2200 i, LinearIndependent R (fun x => x : f i \u2192 M))\n    (hd : \u2200 i, \u2200 t : Set \u03b9, t.Finite \u2192 i \u2209 t \u2192 Disjoint (span R (f i)) (\u2a06 i \u2208 t, span R (f i))) :\n    LinearIndependent R (fun x => x : (\u22c3 i, f i) \u2192 M)", "start": [752, 1], "end": [768, 36], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iUnion_finite", "code": "theorem linearIndependent_iUnion_finite {\u03b7 : Type*} {\u03b9s : \u03b7 \u2192 Type*} {f : \u2200 j : \u03b7, \u03b9s j \u2192 M}\n    (hindep : \u2200 j, LinearIndependent R (f j))\n    (hd : \u2200 i, \u2200 t : Set \u03b7,\n      t.Finite \u2192 i \u2209 t \u2192 Disjoint (span R (range (f i))) (\u2a06 i \u2208 t, span R (range (f i)))) :\n    LinearIndependent R fun ji : \u03a3 j, \u03b9s j => f ji.1 ji.2", "start": [771, 1], "end": [794, 90], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.totalEquiv", "code": "@[simps (config := { rhsMd := default }) symm_apply]\ndef LinearIndependent.totalEquiv (hv : LinearIndependent R v) :\n    (\u03b9 \u2192\u2080 R) \u2243\u2097[R] span R (range v) := by\n  apply LinearEquiv.ofBijective (LinearMap.codRestrict (span R (range v)) (Finsupp.total \u03b9 M R v) _)\n  constructor\n  \u00b7 rw [\u2190 LinearMap.ker_eq_bot, LinearMap.ker_codRestrict]\n    apply hv\n    \u00b7 intro l\n      rw [\u2190 Finsupp.range_total]\n      rw [LinearMap.mem_range]\n      apply mem_range_self l\n  \u00b7 rw [\u2190 LinearMap.range_eq_top, LinearMap.range_eq_map, LinearMap.map_codRestrict, \u2190\n      LinearMap.range_le_iff_comap, range_subtype, Submodule.map_top]\n    rw [Finsupp.range_total]", "start": [803, 1], "end": [818, 29], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.totalEquiv_apply_coe", "code": "@[simp]\ntheorem LinearIndependent.totalEquiv_apply_coe (hv : LinearIndependent R v) (l : \u03b9 \u2192\u2080 R) :\n    hv.totalEquiv l = Finsupp.total \u03b9 M R v l", "start": [824, 1], "end": [826, 53], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.repr", "code": "def LinearIndependent.repr (hv : LinearIndependent R v) : span R (range v) \u2192\u2097[R] \u03b9 \u2192\u2080 R :=\n  hv.totalEquiv.symm", "start": [829, 1], "end": [835, 21], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.total_repr", "code": "@[simp]\ntheorem LinearIndependent.total_repr (x) : Finsupp.total \u03b9 M R v (hv.repr x) = x", "start": [838, 1], "end": [840, 67], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.total_comp_repr", "code": "theorem LinearIndependent.total_comp_repr :\n    (Finsupp.total \u03b9 M R v).comp hv.repr = Submodule.subtype _", "start": [843, 1], "end": [845, 33], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.repr_ker", "code": "theorem LinearIndependent.repr_ker : LinearMap.ker hv.repr = \u22a5", "start": [848, 1], "end": [849, 47], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.repr_range", "code": "theorem LinearIndependent.repr_range : LinearMap.range hv.repr = \u22a4", "start": [852, 1], "end": [853, 49], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.repr_eq", "code": "theorem LinearIndependent.repr_eq {l : \u03b9 \u2192\u2080 R} {x : span R (range v)}\n    (eq : Finsupp.total \u03b9 M R v l = \u2191x) : hv.repr x = l", "start": [856, 1], "end": [867, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.repr_eq_single", "code": "theorem LinearIndependent.repr_eq_single (i) (x : span R (range v)) (hx : \u2191x = v i) :\n    hv.repr x = Finsupp.single i 1", "start": [870, 1], "end": [873, 34], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.span_repr_eq", "code": "theorem LinearIndependent.span_repr_eq [Nontrivial R] (x) :\n    Span.repr R (Set.range v) x =\n      (hv.repr x).equivMapDomain (Equiv.ofInjective _ hv.injective)", "start": [876, 1], "end": [887, 13], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_not_smul_mem_span", "code": "theorem linearIndependent_iff_not_smul_mem_span :\n    LinearIndependent R v \u2194 \u2200 (i : \u03b9) (a : R), a \u2022 v i \u2208 span R (v '' (univ \\ {i})) \u2192 a = 0", "start": [890, 1], "end": [909, 19], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.independent_span_singleton", "code": "theorem LinearIndependent.independent_span_singleton (hv : LinearIndependent R v) :\n    CompleteLattice.Independent fun i => R \u2219 v i", "start": [912, 1], "end": [925, 7], "kind": "commanddeclaration"}, {"full_name": "exists_maximal_independent'", "code": "theorem exists_maximal_independent' (s : \u03b9 \u2192 M) :\n    \u2203 I : Set \u03b9,\n      (LinearIndependent R fun x : I => s x) \u2227\n        \u2200 J : Set \u03b9, I \u2286 J \u2192 (LinearIndependent R fun x : J => s x) \u2192 I = J", "start": [930, 1], "end": [952, 82], "kind": "commanddeclaration"}, {"full_name": "exists_maximal_independent", "code": "theorem exists_maximal_independent (s : \u03b9 \u2192 M) :\n    \u2203 I : Set \u03b9,\n      (LinearIndependent R fun x : I => s x) \u2227\n        \u2200 (i) (_ : i \u2209 I), \u2203 a : R, a \u2260 0 \u2227 a \u2022 s i \u2208 span R (s '' I)", "start": [955, 1], "end": [987, 99], "kind": "commanddeclaration"}, {"full_name": "surjective_of_linearIndependent_of_span", "code": "theorem surjective_of_linearIndependent_of_span [Nontrivial R] (hv : LinearIndependent R v)\n    (f : \u03b9' \u21aa \u03b9) (hss : range v \u2286 span R (range (v \u2218 f))) : Surjective f", "start": [992, 1], "end": [1010, 14], "kind": "commanddeclaration"}, {"full_name": "eq_of_linearIndependent_of_span_subtype", "code": "theorem eq_of_linearIndependent_of_span_subtype [Nontrivial R] {s t : Set M}\n    (hs : LinearIndependent R (fun x => x : s \u2192 M)) (h : t \u2286 s) (hst : s \u2286 span R t) : s = t", "start": [1013, 1], "end": [1025, 29], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.image_subtype", "code": "theorem LinearIndependent.image_subtype {s : Set M} {f : M \u2192\u2097[R] M'}\n    (hs : LinearIndependent R (fun x => x : s \u2192 M))\n    (hf_inj : Disjoint (span R s) (LinearMap.ker f)) :\n    LinearIndependent R (fun x => x : f '' s \u2192 M')", "start": [1030, 1], "end": [1036, 26], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.inl_union_inr", "code": "theorem LinearIndependent.inl_union_inr {s : Set M} {t : Set M'}\n    (hs : LinearIndependent R (fun x => x : s \u2192 M))\n    (ht : LinearIndependent R (fun x => x : t \u2192 M')) :\n    LinearIndependent R (fun x => x : \u21a5(inl R M M' '' s \u222a inr R M M' '' t) \u2192 M \u00d7 M')", "start": [1039, 1], "end": [1045, 37], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_inl_union_inr'", "code": "theorem linearIndependent_inl_union_inr' {v : \u03b9 \u2192 M} {v' : \u03b9' \u2192 M'} (hv : LinearIndependent R v)\n    (hv' : LinearIndependent R v') :\n    LinearIndependent R (Sum.elim (inl R M M' \u2218 v) (inr R M M' \u2218 v'))", "start": [1048, 1], "end": [1053, 62], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_monoidHom", "code": "theorem linearIndependent_monoidHom (G : Type*) [Monoid G] (L : Type*) [CommRing L]\n    [NoZeroDivisors L] : @LinearIndependent _ L (G \u2192 L) (fun f => f : (G \u2192* L) \u2192 G \u2192 L) _ _ _", "start": [1058, 1], "end": [1148, 52], "kind": "commanddeclaration"}, {"full_name": "le_of_span_le_span", "code": "theorem le_of_span_le_span [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R ((\u2191) : u \u2192 M))\n    (hsu : s \u2286 u) (htu : t \u2286 u) (hst : span R s \u2264 span R t) : s \u2286 t", "start": [1151, 1], "end": [1156, 43], "kind": "commanddeclaration"}, {"full_name": "span_le_span_iff", "code": "theorem span_le_span_iff [Nontrivial R] {s t u : Set M} (hl : LinearIndependent R ((\u2191) : u \u2192 M))\n    (hsu : s \u2286 u) (htu : t \u2286 u) : span R s \u2264 span R t \u2194 s \u2286 t", "start": [1159, 1], "end": [1161, 45], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_unique_iff", "code": "theorem linearIndependent_unique_iff (v : \u03b9 \u2192 M) [Unique \u03b9] :\n    LinearIndependent R v \u2194 v default \u2260 0", "start": [1174, 1], "end": [1179, 52], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_unique", "code": "alias \u27e8_, linearIndependent_unique\u27e9 := linearIndependent_unique_iff", "start": [1182, 1], "end": [1182, 68], "kind": "stdtacticaliasaliaslr"}, {"full_name": "linearIndependent_singleton", "code": "theorem linearIndependent_singleton {x : M} (hx : x \u2260 0) :\n    LinearIndependent R (fun x => x : ({x} : Set M) \u2192 M)", "start": [1185, 1], "end": [1187, 56], "kind": "commanddeclaration"}, {"full_name": "mem_span_insert_exchange", "code": "theorem mem_span_insert_exchange :\n    x \u2208 span K (insert y s) \u2192 x \u2209 span K s \u2192 y \u2208 span K (insert x s)", "start": [1211, 1], "end": [1219, 33], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_iff_not_mem_span", "code": "theorem linearIndependent_iff_not_mem_span :\n    LinearIndependent K v \u2194 \u2200 i, v i \u2209 span K (v '' (univ \\ {i}))", "start": [1222, 1], "end": [1230, 55], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.insert", "code": "protected theorem LinearIndependent.insert (hs : LinearIndependent K (fun b => b : s \u2192 V))\n    (hx : x \u2209 span K s) : LinearIndependent K (fun b => b : \u21a5(insert x s) \u2192 V)", "start": [1233, 1], "end": [1238, 36], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_option'", "code": "theorem linearIndependent_option' :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option \u03b9 \u2192 V) \u2194\n      LinearIndependent K v \u2227 x \u2209 Submodule.span K (range v)", "start": [1241, 1], "end": [1250, 25], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.option", "code": "theorem LinearIndependent.option (hv : LinearIndependent K v)\n    (hx : x \u2209 Submodule.span K (range v)) :\n    LinearIndependent K (fun o => Option.casesOn' o x v : Option \u03b9 \u2192 V)", "start": [1253, 1], "end": [1256, 39], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_option", "code": "theorem linearIndependent_option {v : Option \u03b9 \u2192 V} :\n    LinearIndependent K v \u2194\n      LinearIndependent K (v \u2218 (\u2191) : \u03b9 \u2192 V) \u2227 v none \u2209 Submodule.span K (range (v \u2218 (\u2191) : \u03b9 \u2192 V))", "start": [1259, 1], "end": [1262, 71], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_insert'", "code": "theorem linearIndependent_insert' {\u03b9} {s : Set \u03b9} {a : \u03b9} {f : \u03b9 \u2192 V} (has : a \u2209 s) :\n    (LinearIndependent K fun x : \u21a5(insert a s) => f x) \u2194\n      (LinearIndependent K fun x : s => f x) \u2227 f a \u2209 Submodule.span K (f '' s)", "start": [1265, 1], "end": [1275, 7], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_insert", "code": "theorem linearIndependent_insert (hxs : x \u2209 s) :\n    (LinearIndependent K fun b : \u21a5(insert x s) => (b : V)) \u2194\n      (LinearIndependent K fun b : s => (b : V)) \u2227 x \u2209 Submodule.span K s", "start": [1278, 1], "end": [1281, 71], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_pair", "code": "theorem linearIndependent_pair {x y : V} (hx : x \u2260 0) (hy : \u2200 a : K, a \u2022 x \u2260 y) :\n    LinearIndependent K ((\u2191) : ({x, y} : Set V) \u2192 V)", "start": [1284, 1], "end": [1287, 46], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_fin_cons", "code": "theorem linearIndependent_fin_cons {n} {v : Fin n \u2192 V} :\n    LinearIndependent K (Fin.cons x v : Fin (n + 1) \u2192 V) \u2194\n      LinearIndependent K v \u2227 x \u2209 Submodule.span K (range v)", "start": [1290, 1], "end": [1295, 16], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_fin_snoc", "code": "theorem linearIndependent_fin_snoc {n} {v : Fin n \u2192 V} :\n    LinearIndependent K (Fin.snoc v x : Fin (n + 1) \u2192 V) \u2194\n      LinearIndependent K v \u2227 x \u2209 Submodule.span K (range v)", "start": [1298, 1], "end": [1305, 85], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.fin_cons", "code": "theorem LinearIndependent.fin_cons {n} {v : Fin n \u2192 V} (hv : LinearIndependent K v)\n    (hx : x \u2209 Submodule.span K (range v)) : LinearIndependent K (Fin.cons x v : Fin (n + 1) \u2192 V)", "start": [1308, 1], "end": [1312, 40], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_fin_succ", "code": "theorem linearIndependent_fin_succ {n} {v : Fin (n + 1) \u2192 V} :\n    LinearIndependent K v \u2194\n      LinearIndependent K (Fin.tail v) \u2227 v 0 \u2209 Submodule.span K (range <| Fin.tail v)", "start": [1315, 1], "end": [1318, 59], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_fin_succ'", "code": "theorem linearIndependent_fin_succ' {n} {v : Fin (n + 1) \u2192 V} :\n    LinearIndependent K v \u2194\n      LinearIndependent K (Fin.init v) \u2227 v (Fin.last _) \u2209 Submodule.span K (range <| Fin.init v)", "start": [1321, 1], "end": [1324, 59], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_fin2", "code": "theorem linearIndependent_fin2 {f : Fin 2 \u2192 V} :\n    LinearIndependent K f \u2194 f 1 \u2260 0 \u2227 \u2200 a : K, a \u2022 f 1 \u2260 f 0", "start": [1327, 1], "end": [1330, 83], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent_extension", "code": "theorem exists_linearIndependent_extension (hs : LinearIndependent K ((\u2191) : s \u2192 V)) (hst : s \u2286 t) :\n    \u2203 (b : _) (_ : b \u2286 t), s \u2286 b \u2227 t \u2286 span K b \u2227 LinearIndependent K ((\u2191) : b \u2192 V)", "start": [1333, 1], "end": [1348, 39], "kind": "commanddeclaration"}, {"full_name": "exists_linearIndependent", "code": "theorem exists_linearIndependent :\n    \u2203 (b : _) (_ : b \u2286 t), span K b = span K t \u2227 LinearIndependent K ((\u2191) : b \u2192 V)", "start": [1353, 1], "end": [1357, 76], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.extend", "code": "noncomputable def LinearIndependent.extend (hs : LinearIndependent K (fun x => x : s \u2192 V))\n    (hst : s \u2286 t) : Set V :=\n  Classical.choose (exists_linearIndependent_extension hs hst)", "start": [1362, 1], "end": [1366, 63], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.extend_subset", "code": "theorem LinearIndependent.extend_subset (hs : LinearIndependent K (fun x => x : s \u2192 V))\n    (hst : s \u2286 t) : hs.extend hst \u2286 t", "start": [1369, 1], "end": [1372, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.subset_extend", "code": "theorem LinearIndependent.subset_extend (hs : LinearIndependent K (fun x => x : s \u2192 V))\n    (hst : s \u2286 t) : s \u2286 hs.extend hst", "start": [1375, 1], "end": [1378, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.subset_span_extend", "code": "theorem LinearIndependent.subset_span_extend (hs : LinearIndependent K (fun x => x : s \u2192 V))\n    (hst : s \u2286 t) : t \u2286 span K (hs.extend hst)", "start": [1381, 1], "end": [1384, 6], "kind": "commanddeclaration"}, {"full_name": "LinearIndependent.linearIndependent_extend", "code": "theorem LinearIndependent.linearIndependent_extend (hs : LinearIndependent K (fun x => x : s \u2192 V))\n    (hst : s \u2286 t) : LinearIndependent K ((\u2191) : hs.extend hst \u2192 V)", "start": [1387, 1], "end": [1390, 6], "kind": "commanddeclaration"}, {"full_name": "exists_of_linearIndependent_of_finite_span", "code": "theorem exists_of_linearIndependent_of_finite_span {t : Finset V}\n    (hs : LinearIndependent K (fun x => x : s \u2192 V)) (hst : s \u2286 (span K \u2191t : Submodule K V)) :\n    \u2203 t' : Finset V, \u2191t' \u2286 s \u222a \u2191t \u2227 s \u2286 \u2191t' \u2227 t'.card = t.card", "start": [1396, 1], "end": [1460, 39], "kind": "commanddeclaration"}, {"full_name": "exists_finite_card_le_of_finite_of_linearIndependent_of_span", "code": "theorem exists_finite_card_le_of_finite_of_linearIndependent_of_span (ht : t.Finite)\n    (hs : LinearIndependent K (fun x => x : s \u2192 V)) (hst : s \u2286 span K t) :\n    \u2203 h : s.Finite, h.toFinset.card \u2264 ht.toFinset.card", "start": [1463, 1], "end": [1469, 96], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/LinearPMap.lean", "imports": ["Mathlib/LinearAlgebra/Basic.lean", "Mathlib/LinearAlgebra/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearPMap", "code": "structure LinearPMap (R : Type u) [Ring R] (E : Type v) [AddCommGroup E] [Module R E] (F : Type w)\n  [AddCommGroup F] [Module R F] where\n  domain : Submodule R E\n  toFun : domain \u2192\u2097[R] F", "start": [38, 1], "end": [42, 25], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.toFun'", "code": "@[coe]\ndef toFun' (f : E \u2192\u2097.[R] F) : f.domain \u2192 F := f.toFun", "start": [55, 1], "end": [56, 54], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : E \u2192\u2097.[R] F) (x : f.domain) : f.toFun x = f x", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.ext", "code": "@[ext]\ntheorem ext {f g : E \u2192\u2097.[R] F} (h : f.domain = g.domain)\n    (h' : \u2200 \u2983x : f.domain\u2984 \u2983y : g.domain\u2984 (_h : (x : E) = y), f x = g y) : f = g", "start": [66, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.map_zero", "code": "@[simp]\ntheorem map_zero (f : E \u2192\u2097.[R] F) : f 0 = 0", "start": [76, 1], "end": [78, 19], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.ext_iff", "code": "theorem ext_iff {f g : E \u2192\u2097.[R] F} :\n    f = g \u2194\n      \u2203 _domain_eq : f.domain = g.domain,\n        \u2200 \u2983x : f.domain\u2984 \u2983y : g.domain\u2984 (_h : (x : E) = y), f x = g y", "start": [81, 1], "end": [90, 35], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.ext'", "code": "theorem ext' {s : Submodule R E} {f g : s \u2192\u2097[R] F} (h : f = g) : mk s f = mk s g", "start": [93, 1], "end": [94, 10], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.map_add", "code": "theorem map_add (f : E \u2192\u2097.[R] F) (x y : f.domain) : f (x + y) = f x + f y", "start": [97, 1], "end": [98, 22], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.map_neg", "code": "theorem map_neg (f : E \u2192\u2097.[R] F) (x : f.domain) : f (-x) = -f x", "start": [101, 1], "end": [102, 20], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.map_sub", "code": "theorem map_sub (f : E \u2192\u2097.[R] F) (x y : f.domain) : f (x - y) = f x - f y", "start": [105, 1], "end": [106, 22], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.map_smul", "code": "theorem map_smul (f : E \u2192\u2097.[R] F) (c : R) (x : f.domain) : f (c \u2022 x) = c \u2022 f x", "start": [109, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mk_apply", "code": "@[simp]\ntheorem mk_apply (p : Submodule R E) (f : p \u2192\u2097[R] F) (x : p) : mk p f x = f x", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mkSpanSingleton'", "code": "noncomputable def mkSpanSingleton' (x : E) (y : F) (H : \u2200 c : R, c \u2022 x = 0 \u2192 c \u2022 y = 0) :\n    E \u2192\u2097.[R] F where\n  domain := R \u2219 x\n  toFun :=\n    have H : \u2200 c\u2081 c\u2082 : R, c\u2081 \u2022 x = c\u2082 \u2022 x \u2192 c\u2081 \u2022 y = c\u2082 \u2022 y := by\n      intro c\u2081 c\u2082 h\n      rw [\u2190 sub_eq_zero, \u2190 sub_smul] at h \u22a2\n      exact H _ h\n    { toFun := fun z => Classical.choose (mem_span_singleton.1 z.prop) \u2022 y\n      map_add' := fun y z => by\n        dsimp only []\n        rw [\u2190 add_smul]\n        apply H\n        simp only [add_smul, sub_smul,\n          fun w : R \u2219 x => Classical.choose_spec (mem_span_singleton.1 w.prop)]\n        apply coe_add\n      map_smul' := fun c z => by\n        dsimp only []\n        rw [smul_smul]\n        apply H\n        simp only [mul_smul,\n          fun w : R \u2219 x => Classical.choose_spec (mem_span_singleton.1 w.prop)]\n        apply coe_smul }", "start": [118, 1], "end": [144, 25], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domain_mkSpanSingleton", "code": "@[simp]\ntheorem domain_mkSpanSingleton (x : E) (y : F) (H : \u2200 c : R, c \u2022 x = 0 \u2192 c \u2022 y = 0) :\n    (mkSpanSingleton' x y H).domain = R \u2219 x", "start": [147, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mkSpanSingleton'_apply", "code": "@[simp]\ntheorem mkSpanSingleton'_apply (x : E) (y : F) (H : \u2200 c : R, c \u2022 x = 0 \u2192 c \u2022 y = 0) (c : R) (h) :\n    mkSpanSingleton' x y H \u27e8c \u2022 x, h\u27e9 = c \u2022 y", "start": [153, 1], "end": [160, 55], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mkSpanSingleton'_apply_self", "code": "@[simp]\ntheorem mkSpanSingleton'_apply_self (x : E) (y : F) (H : \u2200 c : R, c \u2022 x = 0 \u2192 c \u2022 y = 0) (h) :\n    mkSpanSingleton' x y H \u27e8x, h\u27e9 = y", "start": [163, 1], "end": [168, 33], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mkSpanSingleton", "code": "@[reducible]\nnoncomputable def mkSpanSingleton {K E F : Type*} [DivisionRing K] [AddCommGroup E] [Module K E]\n    [AddCommGroup F] [Module K F] (x : E) (y : F) (hx : x \u2260 0) : E \u2192\u2097.[K] F :=\n  mkSpanSingleton' x y fun c hc =>\n    (smul_eq_zero.1 hc).elim (fun hc => by rw [hc, zero_smul]) fun hx' => absurd hx' hx", "start": [171, 1], "end": [177, 88], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mkSpanSingleton_apply", "code": "theorem mkSpanSingleton_apply (K : Type*) {E F : Type*} [DivisionRing K] [AddCommGroup E]\n    [Module K E] [AddCommGroup F] [Module K F] {x : E} (hx : x \u2260 0) (y : F) :\n    mkSpanSingleton x y hx \u27e8x, (Submodule.mem_span_singleton_self x : x \u2208 Submodule.span K {x})\u27e9 =\n      y", "start": [180, 1], "end": [184, 49], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.fst", "code": "protected def fst (p : Submodule R E) (p' : Submodule R F) : E \u00d7 F \u2192\u2097.[R] E where\n  domain := p.prod p'\n  toFun := (LinearMap.fst R E F).comp (p.prod p').subtype", "start": [187, 1], "end": [190, 58], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.fst_apply", "code": "@[simp]\ntheorem fst_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :\n    LinearPMap.fst p p' x = (x : E \u00d7 F).1", "start": [193, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.snd", "code": "protected def snd (p : Submodule R E) (p' : Submodule R F) : E \u00d7 F \u2192\u2097.[R] F where\n  domain := p.prod p'\n  toFun := (LinearMap.snd R E F).comp (p.prod p').subtype", "start": [199, 1], "end": [202, 58], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.snd_apply", "code": "@[simp]\ntheorem snd_apply (p : Submodule R E) (p' : Submodule R F) (x : p.prod p') :\n    LinearPMap.snd p p' x = (x : E \u00d7 F).2", "start": [205, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le", "code": "instance le : LE (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g => f.domain \u2264 g.domain \u2227 \u2200 \u2983x : f.domain\u2984 \u2983y : g.domain\u2984 (_h : (x : E) = y), f x = g y\u27e9", "start": [211, 1], "end": [212, 99], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.apply_comp_ofLe", "code": "theorem apply_comp_ofLe {T S : E \u2192\u2097.[R] F} (h : T \u2264 S) (x : T.domain) :\n    T x = S (Submodule.ofLe h.1 x)", "start": [215, 1], "end": [217, 10], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.exists_of_le", "code": "theorem exists_of_le {T S : E \u2192\u2097.[R] F} (h : T \u2264 S) (x : T.domain) :\n    \u2203 y : S.domain, (x : E) = y \u2227 T x = S y", "start": [220, 1], "end": [222, 35], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.eq_of_le_of_domain_eq", "code": "theorem eq_of_le_of_domain_eq {f g : E \u2192\u2097.[R] F} (hle : f \u2264 g) (heq : f.domain = g.domain) :\n    f = g", "start": [225, 1], "end": [227, 16], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.eqLocus", "code": "def eqLocus (f g : E \u2192\u2097.[R] F) : Submodule R E where\n  carrier := { x | \u2203 (hf : x \u2208 f.domain) (hg : x \u2208 g.domain), f \u27e8x, hf\u27e9 = g \u27e8x, hg\u27e9 }\n  zero_mem' := \u27e8zero_mem _, zero_mem _, f.map_zero.trans g.map_zero.symm\u27e9\n  add_mem' := fun {x y} \u27e8hfx, hgx, hx\u27e9 \u27e8hfy, hgy, hy\u27e9 =>\n    \u27e8add_mem hfx hfy, add_mem hgx hgy, by\n      erw [f.map_add \u27e8x, hfx\u27e9 \u27e8y, hfy\u27e9, g.map_add \u27e8x, hgx\u27e9 \u27e8y, hgy\u27e9, hx, hy]\u27e9\n  smul_mem' := by\n    rintro c x \u27e8hfx, hgx, hx\u27e9\n    exact\n      \u27e8smul_mem _ c hfx, smul_mem _ c hgx,\n        by erw [f.map_smul c \u27e8x, hfx\u27e9, g.map_smul c \u27e8x, hgx\u27e9, hx]\u27e9", "start": [230, 1], "end": [243, 67], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inf", "code": "instance inf : Inf (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g => \u27e8f.eqLocus g, f.toFun.comp <| ofLe fun _x hx => hx.fst\u27e9\u27e9", "start": [246, 1], "end": [247, 71], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.bot", "code": "instance bot : Bot (E \u2192\u2097.[R] F) :=\n  \u27e8\u27e8\u22a5, 0\u27e9\u27e9", "start": [250, 1], "end": [251, 11], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inhabited", "code": "instance inhabited : Inhabited (E \u2192\u2097.[R] F) :=\n  \u27e8\u22a5\u27e9", "start": [254, 1], "end": [255, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.semilatticeInf", "code": "instance semilatticeInf : SemilatticeInf (E \u2192\u2097.[R] F) where\n  le := (\u00b7 \u2264 \u00b7)\n  le_refl f := \u27e8le_refl f.domain, fun x y h => Subtype.eq h \u25b8 rfl\u27e9\n  le_trans := fun f g h \u27e8fg_le, fg_eq\u27e9 \u27e8gh_le, gh_eq\u27e9 =>\n    \u27e8le_trans fg_le gh_le, fun x z hxz =>\n      have hxy : (x : E) = ofLe fg_le x := rfl\n      (fg_eq hxy).trans (gh_eq <| hxy.symm.trans hxz)\u27e9\n  le_antisymm f g fg gf := eq_of_le_of_domain_eq fg (le_antisymm fg.1 gf.1)\n  inf := (\u00b7 \u2293 \u00b7)\n  le_inf := by\n    rintro f g h \u27e8fg_le, fg_eq\u27e9 \u27e8fh_le, fh_eq\u27e9\n    exact \u27e8fun x hx =>\n      \u27e8fg_le hx, fh_le hx, by\n        refine' (fg_eq _).symm.trans (fh_eq _) <;> [skip; exact \u27e8x, hx\u27e9; skip] <;> rfl\u27e9,\n      fun x \u27e8y, yg, hy\u27e9 h => by\n        apply fg_eq\n        exact h\u27e9\n  inf_le_left f g := \u27e8fun x hx => hx.fst, fun x y h => congr_arg f <| Subtype.eq <| h\u27e9\n  inf_le_right f g :=\n    \u27e8fun x hx => hx.snd.fst, fun \u27e8x, xf, xg, hx\u27e9 y h => hx.trans <| congr_arg g <| Subtype.eq <| h\u27e9", "start": [258, 1], "end": [279, 100], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.orderBot", "code": "instance orderBot : OrderBot (E \u2192\u2097.[R] F) where\n  bot := \u22a5\n  bot_le f :=\n    \u27e8bot_le, fun x y h => by\n      have hx : x = 0 := Subtype.eq ((mem_bot R).1 x.2)\n      have hy : y = 0 := Subtype.eq (h.symm.trans (congr_arg _ hx))\n      rw [hx, hy, map_zero, map_zero]\u27e9", "start": [282, 1], "end": [288, 39], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_of_eqLocus_ge", "code": "theorem le_of_eqLocus_ge {f g : E \u2192\u2097.[R] F} (H : f.domain \u2264 f.eqLocus g) : f \u2264 g", "start": [291, 1], "end": [293, 68], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domain_mono", "code": "theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _)", "start": [296, 1], "end": [297, 93], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sup_aux", "code": "private theorem sup_aux (f g : E \u2192\u2097.[R] F)\n    (h : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) :\n    \u2203 fg : \u21a5(f.domain \u2294 g.domain) \u2192\u2097[R] F,\n      \u2200 (x : f.domain) (y : g.domain) (z : \u21a5(f.domain \u2294 g.domain)),\n        (x : E) + y = \u2191z \u2192 fg z = f x + g y", "start": [300, 1], "end": [326, 68], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sup", "code": "protected noncomputable def sup (f g : E \u2192\u2097.[R] F)\n    (h : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) : E \u2192\u2097.[R] F :=\n  \u27e8_, Classical.choose (sup_aux f g h)\u27e9", "start": [328, 1], "end": [333, 40], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domain_sup", "code": "@[simp]\ntheorem domain_sup (f g : E \u2192\u2097.[R] F)\n    (h : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) :\n    (f.sup g h).domain = f.domain \u2294 g.domain", "start": [336, 1], "end": [340, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sup_apply", "code": "theorem sup_apply {f g : E \u2192\u2097.[R] F} (H : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y)\n    (x : f.domain) (y : g.domain) (z : \u21a5(f.domain \u2294 g.domain)) (hz : (\u2191x : E) + \u2191y = \u2191z) :\n    f.sup g H z = f x + g y", "start": [343, 1], "end": [346, 49], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.left_le_sup", "code": "protected theorem left_le_sup (f g : E \u2192\u2097.[R] F)\n    (h : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) : f \u2264 f.sup g h", "start": [349, 1], "end": [354, 8], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.right_le_sup", "code": "protected theorem right_le_sup (f g : E \u2192\u2097.[R] F)\n    (h : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) : g \u2264 f.sup g h", "start": [357, 1], "end": [362, 8], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sup_le", "code": "protected theorem sup_le {f g h : E \u2192\u2097.[R] F}\n    (H : \u2200 (x : f.domain) (y : g.domain), (x : E) = y \u2192 f x = g y) (fh : f \u2264 h) (gh : g \u2264 h) :\n    f.sup g H \u2264 h", "start": [365, 1], "end": [370, 39], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sup_h_of_disjoint", "code": "theorem sup_h_of_disjoint (f g : E \u2192\u2097.[R] F) (h : Disjoint f.domain g.domain) (x : f.domain)\n    (y : g.domain) (hxy : (x : E) = y) : f x = g y", "start": [373, 1], "end": [379, 11], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instZero", "code": "instance instZero : Zero (E \u2192\u2097.[R] F) := \u27e8\u22a4, 0\u27e9", "start": [387, 1], "end": [387, 48], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.zero_domain", "code": "@[simp]\ntheorem zero_domain : (0 : E \u2192\u2097.[R] F).domain = \u22a4", "start": [389, 1], "end": [390, 57], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.zero_apply", "code": "@[simp]\ntheorem zero_apply (x : (\u22a4 : Submodule R E)) : (0 : E \u2192\u2097.[R] F) x = 0", "start": [392, 1], "end": [393, 77], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instSMul", "code": "instance instSMul : SMul M (E \u2192\u2097.[R] F) :=\n  \u27e8fun a f =>\n    { domain := f.domain\n      toFun := a \u2022 f.toFun }\u27e9", "start": [403, 1], "end": [406, 30], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.smul_domain", "code": "@[simp]\ntheorem smul_domain (a : M) (f : E \u2192\u2097.[R] F) : (a \u2022 f).domain = f.domain", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.smul_apply", "code": "theorem smul_apply (a : M) (f : E \u2192\u2097.[R] F) (x : (a \u2022 f).domain) : (a \u2022 f) x = a \u2022 f x", "start": [414, 1], "end": [415, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.coe_smul", "code": "@[simp]\ntheorem coe_smul (a : M) (f : E \u2192\u2097.[R] F) : \u21d1(a \u2022 f) = a \u2022 \u21d1f", "start": [418, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instSMulCommClass", "code": "instance instSMulCommClass [SMulCommClass M N F] : SMulCommClass M N (E \u2192\u2097.[R] F) :=\n  \u27e8fun a b f => ext' <| smul_comm a b f.toFun\u27e9", "start": [423, 1], "end": [424, 47], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instIsScalarTower", "code": "instance instIsScalarTower [SMul M N] [IsScalarTower M N F] : IsScalarTower M N (E \u2192\u2097.[R] F) :=\n  \u27e8fun a b f => ext' <| smul_assoc a b f.toFun\u27e9", "start": [427, 1], "end": [428, 48], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instMulAction", "code": "instance instMulAction : MulAction M (E \u2192\u2097.[R] F) where\n  smul := (\u00b7 \u2022 \u00b7)\n  one_smul := fun \u27e8_s, f\u27e9 => ext' <| one_smul M f\n  mul_smul a b f := ext' <| mul_smul a b f.toFun", "start": [431, 1], "end": [434, 49], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instNeg", "code": "instance instNeg : Neg (E \u2192\u2097.[R] F) :=\n  \u27e8fun f => \u27e8f.domain, -f.toFun\u27e9\u27e9", "start": [439, 1], "end": [440, 34], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.neg_domain", "code": "@[simp]\ntheorem neg_domain (f : E \u2192\u2097.[R] F) : (-f).domain = f.domain", "start": [443, 1], "end": [444, 68], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.neg_apply", "code": "@[simp]\ntheorem neg_apply (f : E \u2192\u2097.[R] F) (x) : (-f) x = -f x", "start": [446, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instInvolutiveNeg", "code": "instance instInvolutiveNeg : InvolutiveNeg (E \u2192\u2097.[R] F) :=\n  \u27e8fun f => by\n    ext x y hxy\n    \u00b7 rfl\n    \u00b7 simp only [neg_apply, neg_neg]\n      cases x\n      congr\u27e9", "start": [451, 1], "end": [457, 13], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAdd", "code": "instance instAdd : Add (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g =>\n    { domain := f.domain \u2293 g.domain\n      toFun := f.toFun.comp (ofLe (inf_le_left : f.domain \u2293 g.domain \u2264 _))\n        + g.toFun.comp (ofLe (inf_le_right : f.domain \u2293 g.domain \u2264 _)) }\u27e9", "start": [461, 1], "end": [465, 74], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.add_domain", "code": "theorem add_domain (f g : E \u2192\u2097.[R] F) : (f + g).domain = f.domain \u2293 g.domain", "start": [467, 1], "end": [467, 84], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.add_apply", "code": "theorem add_apply (f g : E \u2192\u2097.[R] F) (x : (f.domain \u2293 g.domain : Submodule R E)) :\n    (f + g) x = f \u27e8x, x.prop.1\u27e9 + g \u27e8x, x.prop.2\u27e9", "start": [469, 1], "end": [470, 57], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAddSemigroup", "code": "instance instAddSemigroup : AddSemigroup (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g h => by\n    ext x y hxy\n    \u00b7 simp only [add_domain, inf_assoc]\n    \u00b7 simp only [add_apply, hxy, add_assoc]\u27e9", "start": [472, 1], "end": [476, 45], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAddZeroClass", "code": "instance instAddZeroClass : AddZeroClass (E \u2192\u2097.[R] F) :=\n  \u27e8fun f => by\n    ext x y hxy\n    \u00b7 simp [add_domain]\n    \u00b7 simp only [add_apply, hxy, zero_apply, zero_add],\n  fun f => by\n    ext x y hxy\n    \u00b7 simp [add_domain]\n    \u00b7 simp only [add_apply, hxy, zero_apply, add_zero]\u27e9", "start": [478, 1], "end": [486, 56], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAddMonoid", "code": "instance instAddMonoid : AddMonoid (E \u2192\u2097.[R] F) where\n  zero_add f := by\n    simp\n  add_zero := by\n    simp", "start": [488, 1], "end": [492, 9], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAddCommMonoid", "code": "instance instAddCommMonoid : AddCommMonoid (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g => by\n    ext x y hxy\n    \u00b7 simp only [add_domain, inf_comm]\n    \u00b7 simp only [add_apply, hxy, add_comm]\u27e9", "start": [494, 1], "end": [498, 44], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instVAdd", "code": "instance instVAdd : VAdd (E \u2192\u2097[R] F) (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g =>\n    { domain := g.domain\n      toFun := f.comp g.domain.subtype + g.toFun }\u27e9", "start": [504, 1], "end": [507, 52], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.vadd_domain", "code": "@[simp]\ntheorem vadd_domain (f : E \u2192\u2097[R] F) (g : E \u2192\u2097.[R] F) : (f +\u1d65 g).domain = g.domain", "start": [510, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.vadd_apply", "code": "theorem vadd_apply (f : E \u2192\u2097[R] F) (g : E \u2192\u2097.[R] F) (x : (f +\u1d65 g).domain) :\n    (f +\u1d65 g) x = f x + g x", "start": [515, 1], "end": [517, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.coe_vadd", "code": "@[simp]\ntheorem coe_vadd (f : E \u2192\u2097[R] F) (g : E \u2192\u2097.[R] F) : \u21d1(f +\u1d65 g) = \u21d1(f.comp g.domain.subtype) + \u21d1g", "start": [520, 1], "end": [522, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instAddAction", "code": "instance instAddAction : AddAction (E \u2192\u2097[R] F) (E \u2192\u2097.[R] F)\n    where\n  vadd := (\u00b7 +\u1d65 \u00b7)\n  zero_vadd := fun \u27e8_s, _f\u27e9 => ext' <| zero_add _\n  add_vadd := fun _f\u2081 _f\u2082 \u27e8_s, _g\u27e9 => ext' <| LinearMap.ext fun _x => add_assoc _ _ _", "start": [525, 1], "end": [529, 86], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instSub", "code": "instance instSub : Sub (E \u2192\u2097.[R] F) :=\n  \u27e8fun f g =>\n    { domain := f.domain \u2293 g.domain\n      toFun := f.toFun.comp (ofLe (inf_le_left : f.domain \u2293 g.domain \u2264 _))\n        - g.toFun.comp (ofLe (inf_le_right : f.domain \u2293 g.domain \u2264 _)) }\u27e9", "start": [536, 1], "end": [540, 74], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sub_domain", "code": "theorem sub_domain (f g : E \u2192\u2097.[R] F) : (f - g).domain = f.domain \u2293 g.domain", "start": [542, 1], "end": [542, 84], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sub_apply", "code": "theorem sub_apply (f g : E \u2192\u2097.[R] F) (x : (f.domain \u2293 g.domain : Submodule R E)) :\n    (f - g) x = f \u27e8x, x.prop.1\u27e9 - g \u27e8x, x.prop.2\u27e9", "start": [544, 1], "end": [545, 57], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.instSubtractionCommMonoid", "code": "instance instSubtractionCommMonoid : SubtractionCommMonoid (E \u2192\u2097.[R] F) where\n  add_comm := add_comm\n  sub_eq_add_neg f g := by\n    ext x y h\n    \u00b7 rfl\n    simp [sub_apply, add_apply, neg_apply, \u2190 sub_eq_add_neg, h]\n  neg_neg := neg_neg\n  neg_add_rev f g := by\n    ext x y h\n    \u00b7 simp [add_domain, sub_domain, neg_domain, And.comm]\n    simp [sub_apply, add_apply, neg_apply, \u2190 sub_eq_add_neg, h]\n  neg_eq_of_add f g h' := by\n    ext x y h\n    \u00b7 have : (0 : E \u2192\u2097.[R] F).domain = \u22a4 := zero_domain\n      simp only [\u2190 h', add_domain, ge_iff_le, inf_eq_top_iff] at this\n      rw [neg_domain, this.1, this.2]\n    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, neg_apply]\n    rw [ext_iff] at h'\n    rcases h' with \u27e8hdom, h'\u27e9\n    rw [zero_domain] at hdom\n    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, zero_domain, top_coe, zero_apply,\n      Subtype.forall, mem_top, forall_true_left, forall_eq'] at h'\n    specialize h' x.1 (by simp [hdom])\n    simp only [inf_coe, neg_domain, Eq.ndrec, Int.ofNat_eq_coe, add_apply, Subtype.coe_eta,\n      \u2190 neg_eq_iff_add_eq_zero] at h'\n    rw [h', h]", "start": [547, 1], "end": [572, 15], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.supSpanSingleton", "code": "noncomputable def supSpanSingleton (f : E \u2192\u2097.[K] F) (x : E) (y : F) (hx : x \u2209 f.domain) :\n    E \u2192\u2097.[K] F :=\n  f.sup (mkSpanSingleton x y fun h\u2080 => hx <| h\u2080.symm \u25b8 f.domain.zero_mem) <|\n    sup_h_of_disjoint _ _ <| by simp [disjoint_span_singleton]; exact fun h => False.elim <| hx h", "start": [580, 1], "end": [585, 98], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domain_supSpanSingleton", "code": "@[simp]\ntheorem domain_supSpanSingleton (f : E \u2192\u2097.[K] F) (x : E) (y : F) (hx : x \u2209 f.domain) :\n    (f.supSpanSingleton x y hx).domain = f.domain \u2294 K \u2219 x", "start": [588, 1], "end": [591, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.supSpanSingleton_apply_mk", "code": "@[simp, nolint simpNF] theorem supSpanSingleton_apply_mk (f : E \u2192\u2097.[K] F) (x : E) (y : F) (hx : x \u2209 f.domain) (x' : E)\n    (hx' : x' \u2208 f.domain) (c : K) :\n    f.supSpanSingleton x y hx\n        \u27e8x' + c \u2022 x, mem_sup.2 \u27e8x', hx', _, mem_span_singleton.2 \u27e8c, rfl\u27e9, rfl\u27e9\u27e9 =\n      f \u27e8x', hx'\u27e9 + c \u2022 y", "start": [594, 1], "end": [604, 8], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sSup_aux", "code": "private theorem sSup_aux (c : Set (E \u2192\u2097.[R] F)) (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) :\n    \u2203 f : \u21a5(sSup (domain '' c)) \u2192\u2097[R] F, (\u27e8_, f\u27e9 : E \u2192\u2097.[R] F) \u2208 upperBounds c", "start": [609, 1], "end": [642, 37], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sSup", "code": "protected noncomputable def sSup (c : Set (E \u2192\u2097.[R] F)) (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) : E \u2192\u2097.[R] F :=\n  \u27e8_, Classical.choose <| sSup_aux c hc\u27e9", "start": [644, 1], "end": [645, 41], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_sSup", "code": "protected theorem le_sSup {c : Set (E \u2192\u2097.[R] F)} (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {f : E \u2192\u2097.[R] F}\n    (hf : f \u2208 c) : f \u2264 LinearPMap.sSup c hc", "start": [648, 1], "end": [650, 43], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sSup_le", "code": "protected theorem sSup_le {c : Set (E \u2192\u2097.[R] F)} (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {g : E \u2192\u2097.[R] F}\n    (hg : \u2200 f \u2208 c, f \u2264 g) : LinearPMap.sSup c hc \u2264 g", "start": [653, 1], "end": [659, 15], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.sSup_apply", "code": "protected theorem sSup_apply {c : Set (E \u2192\u2097.[R] F)} (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {l : E \u2192\u2097.[R] F}\n    (hl : l \u2208 c) (x : l.domain) :\n    (LinearPMap.sSup c hc) \u27e8x, (LinearPMap.le_sSup hc hl).1 x.2\u27e9 = l x", "start": [662, 1], "end": [667, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toPMap", "code": "def toPMap (f : E \u2192\u2097[R] F) (p : Submodule R E) : E \u2192\u2097.[R] F :=\n  \u27e8p, f.comp p.subtype\u27e9", "start": [674, 1], "end": [676, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toPMap_apply", "code": "@[simp]\ntheorem toPMap_apply (f : E \u2192\u2097[R] F) (p : Submodule R E) (x : p) : f.toPMap p x = f x", "start": [679, 1], "end": [681, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toPMap_domain", "code": "@[simp]\ntheorem toPMap_domain (f : E \u2192\u2097[R] F) (p : Submodule R E) : (f.toPMap p).domain = p", "start": [684, 1], "end": [686, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compPMap", "code": "def compPMap (g : F \u2192\u2097[R] G) (f : E \u2192\u2097.[R] F) : E \u2192\u2097.[R] G where\n  domain := f.domain\n  toFun := g.comp f.toFun", "start": [689, 1], "end": [692, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.compPMap_apply", "code": "@[simp]\ntheorem compPMap_apply (g : F \u2192\u2097[R] G) (f : E \u2192\u2097.[R] F) (x) : g.compPMap f x = g (f x)", "start": [695, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.codRestrict", "code": "def codRestrict (f : E \u2192\u2097.[R] F) (p : Submodule R F) (H : \u2200 x, f x \u2208 p) : E \u2192\u2097.[R] p\n    where\n  domain := f.domain\n  toFun := f.toFun.codRestrict p H", "start": [704, 1], "end": [708, 35], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.comp", "code": "def comp (g : F \u2192\u2097.[R] G) (f : E \u2192\u2097.[R] F) (H : \u2200 x : f.domain, f x \u2208 g.domain) : E \u2192\u2097.[R] G :=\n  g.toFun.compPMap <| f.codRestrict _ H", "start": [711, 1], "end": [713, 40], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.coprod", "code": "def coprod (f : E \u2192\u2097.[R] G) (g : F \u2192\u2097.[R] G) : E \u00d7 F \u2192\u2097.[R] G where\n  domain := f.domain.prod g.domain\n  toFun :=\n    HAdd.hAdd\n      (\u03b1 := f.domain.prod g.domain \u2192\u2097[R] G)\n      (\u03b2 := f.domain.prod g.domain \u2192\u2097[R] G)\n      (f.comp (LinearPMap.fst f.domain g.domain) fun x => x.2.1).toFun\n      (g.comp (LinearPMap.snd f.domain g.domain) fun x => x.2.2).toFun", "start": [716, 1], "end": [728, 71], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.coprod_apply", "code": "@[simp]\ntheorem coprod_apply (f : E \u2192\u2097.[R] G) (g : F \u2192\u2097.[R] G) (x) :\n    f.coprod g x = f \u27e8(x : E \u00d7 F).1, x.2.1\u27e9 + g \u27e8(x : E \u00d7 F).2, x.2.2\u27e9", "start": [731, 1], "end": [734, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domRestrict", "code": "def domRestrict (f : E \u2192\u2097.[R] F) (S : Submodule R E) : E \u2192\u2097.[R] F :=\n  \u27e8S \u2293 f.domain, f.toFun.comp (Submodule.ofLe (by simp))\u27e9", "start": [737, 1], "end": [739, 58], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domRestrict_domain", "code": "@[simp]\ntheorem domRestrict_domain (f : E \u2192\u2097.[R] F) {S : Submodule R E} :\n    (f.domRestrict S).domain = S \u2293 f.domain", "start": [742, 1], "end": [745, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domRestrict_apply", "code": "theorem domRestrict_apply {f : E \u2192\u2097.[R] F} {S : Submodule R E} \u2983x : \u21a5(S \u2293 f.domain)\u2984 \u2983y : f.domain\u2984\n    (h : (x : E) = y) : f.domRestrict S x = f y", "start": [748, 1], "end": [754, 34], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.domRestrict_le", "code": "theorem domRestrict_le {f : E \u2192\u2097.[R] F} {S : Submodule R E} : f.domRestrict S \u2264 f", "start": [757, 1], "end": [758, 50], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.graph", "code": "def graph (f : E \u2192\u2097.[R] F) : Submodule R (E \u00d7 F) :=\n  f.toFun.graph.map (f.domain.subtype.prodMap (LinearMap.id : F \u2192\u2097[R] F))", "start": [766, 1], "end": [768, 74], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_graph_iff'", "code": "theorem mem_graph_iff' (f : E \u2192\u2097.[R] F) {x : E \u00d7 F} : x \u2208 f.graph \u2194 \u2203 y : f.domain, (\u2191y, f y) = x", "start": [771, 1], "end": [772, 18], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_graph_iff", "code": "@[simp]\ntheorem mem_graph_iff (f : E \u2192\u2097.[R] F) {x : E \u00d7 F} :\n    x \u2208 f.graph \u2194 \u2203 y : f.domain, (\u2191y : E) = x.1 \u2227 f y = x.2", "start": [775, 1], "end": [779, 44], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_graph", "code": "theorem mem_graph (f : E \u2192\u2097.[R] F) (x : domain f) : ((x : E), f x) \u2208 f.graph", "start": [782, 1], "end": [783, 88], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.graph_map_fst_eq_domain", "code": "theorem graph_map_fst_eq_domain (f : E \u2192\u2097.[R] F) :\n    f.graph.map (LinearMap.fst R E F) = f.domain", "start": [786, 1], "end": [795, 31], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.graph_map_snd_eq_range", "code": "theorem graph_map_snd_eq_range (f : E \u2192\u2097.[R] F) :\n    f.graph.map (LinearMap.snd R E F) = LinearMap.range f.toFun", "start": [797, 1], "end": [798, 80], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.smul_graph", "code": "theorem smul_graph (f : E \u2192\u2097.[R] F) (z : M) :\n    (z \u2022 f).graph =\n      f.graph.map ((LinearMap.id : E \u2192\u2097[R] E).prodMap (z \u2022 (LinearMap.id : F \u2192\u2097[R] F)))", "start": [802, 1], "end": [824, 17], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.neg_graph", "code": "theorem neg_graph (f : E \u2192\u2097.[R] F) :\n    (-f).graph =\n    f.graph.map ((LinearMap.id : E \u2192\u2097[R] E).prodMap (-(LinearMap.id : F \u2192\u2097[R] F)))", "start": [827, 1], "end": [849, 17], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_graph_snd_inj", "code": "theorem mem_graph_snd_inj (f : E \u2192\u2097.[R] F) {x y : E} {x' y' : F} (hx : (x, x') \u2208 f.graph)\n    (hy : (y, y') \u2208 f.graph) (hxy : x = y) : x' = y'", "start": [852, 1], "end": [859, 25], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_graph_snd_inj'", "code": "theorem mem_graph_snd_inj' (f : E \u2192\u2097.[R] F) {x y : E \u00d7 F} (hx : x \u2208 f.graph) (hy : y \u2208 f.graph)\n    (hxy : x.1 = y.1) : x.2 = y.2", "start": [862, 1], "end": [866, 38], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.graph_fst_eq_zero_snd", "code": "theorem graph_fst_eq_zero_snd (f : E \u2192\u2097.[R] F) {x : E} {x' : F} (h : (x, x') \u2208 f.graph)\n    (hx : x = 0) : x' = 0", "start": [869, 1], "end": [872, 44], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_domain_iff", "code": "theorem mem_domain_iff {f : E \u2192\u2097.[R] F} {x : E} : x \u2208 f.domain \u2194 \u2203 y : F, (x, y) \u2208 f.graph", "start": [875, 1], "end": [884, 7], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_domain_of_mem_graph", "code": "theorem mem_domain_of_mem_graph {f : E \u2192\u2097.[R] F} {x : E} {y : F} (h : (x, y) \u2208 f.graph) :\n    x \u2208 f.domain", "start": [887, 1], "end": [890, 15], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.image_iff", "code": "theorem image_iff {f : E \u2192\u2097.[R] F} {x : E} {y : F} (hx : x \u2208 f.domain) :\n    y = f \u27e8x, hx\u27e9 \u2194 (x, y) \u2208 f.graph", "start": [893, 1], "end": [901, 23], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_range_iff", "code": "theorem mem_range_iff {f : E \u2192\u2097.[R] F} {y : F} : y \u2208 Set.range f \u2194 \u2203 x : E, (x, y) \u2208 f.graph", "start": [904, 1], "end": [917, 11], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_domain_iff_of_eq_graph", "code": "theorem mem_domain_iff_of_eq_graph {f g : E \u2192\u2097.[R] F} (h : f.graph = g.graph) {x : E} :\n    x \u2208 f.domain \u2194 x \u2208 g.domain", "start": [920, 1], "end": [921, 66], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_of_le_graph", "code": "theorem le_of_le_graph {f g : E \u2192\u2097.[R] F} (h : f.graph \u2264 g.graph) : f \u2264 g", "start": [924, 1], "end": [937, 13], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_graph_of_le", "code": "theorem le_graph_of_le {f g : E \u2192\u2097.[R] F} (h : f \u2264 g) : f.graph \u2264 g.graph", "start": [940, 1], "end": [948, 37], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.le_graph_iff", "code": "theorem le_graph_iff {f g : E \u2192\u2097.[R] F} : f.graph \u2264 g.graph \u2194 f \u2264 g", "start": [951, 1], "end": [952, 35], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.eq_of_eq_graph", "code": "theorem eq_of_eq_graph {f g : E \u2192\u2097.[R] F} (h : f.graph = g.graph) : f = g", "start": [955, 1], "end": [959, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.existsUnique_from_graph", "code": "theorem existsUnique_from_graph {g : Submodule R (E \u00d7 F)}\n    (hg : \u2200 {x : E \u00d7 F} (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) {a : E}\n    (ha : a \u2208 g.map (LinearMap.fst R E F)) : \u2203! b : F, (a, b) \u2208 g", "start": [970, 1], "end": [980, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.valFromGraph", "code": "noncomputable def valFromGraph {g : Submodule R (E \u00d7 F)}\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) {a : E}\n    (ha : a \u2208 g.map (LinearMap.fst R E F)) : F :=\n  (ExistsUnique.exists (existsUnique_from_graph @hg ha)).choose", "start": [983, 1], "end": [987, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.valFromGraph_mem", "code": "theorem valFromGraph_mem {g : Submodule R (E \u00d7 F)}\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) {a : E}\n    (ha : a \u2208 g.map (LinearMap.fst R E F)) : (a, valFromGraph hg ha) \u2208 g", "start": [990, 1], "end": [993, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMapAux", "code": "noncomputable def toLinearPMapAux (g : Submodule R (E \u00d7 F))\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) :\n    g.map (LinearMap.fst R E F) \u2192\u2097[R] F where\n  toFun := fun x => valFromGraph hg x.2\n  map_add' := fun v w => by\n    have hadd := (g.map (LinearMap.fst R E F)).add_mem v.2 w.2\n    have hvw := valFromGraph_mem hg hadd\n    have hvw' := g.add_mem (valFromGraph_mem hg v.2) (valFromGraph_mem hg w.2)\n    rw [Prod.mk_add_mk] at hvw'\n    exact (existsUnique_from_graph @hg hadd).unique hvw hvw'\n  map_smul' := fun a v => by\n    have hsmul := (g.map (LinearMap.fst R E F)).smul_mem a v.2\n    have hav := valFromGraph_mem hg hsmul\n    have hav' := g.smul_mem a (valFromGraph_mem hg v.2)\n    rw [Prod.smul_mk] at hav'\n    exact (existsUnique_from_graph @hg hsmul).unique hav hav'", "start": [996, 1], "end": [1014, 62], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMap", "code": "noncomputable def toLinearPMap (g : Submodule R (E \u00d7 F)) : E \u2192\u2097.[R] F\n    where\n  domain := g.map (LinearMap.fst R E F)\n  toFun := if hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0 then\n    g.toLinearPMapAux hg else 0", "start": [1017, 1], "end": [1025, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMap_domain", "code": "theorem toLinearPMap_domain (g : Submodule R (E \u00d7 F)) :\n    g.toLinearPMap.domain = g.map (LinearMap.fst R E F)", "start": [1028, 1], "end": [1029, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMap_apply_aux", "code": "theorem toLinearPMap_apply_aux {g : Submodule R (E \u00d7 F)}\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0)\n    (x : g.map (LinearMap.fst R E F)) :\n    g.toLinearPMap x = valFromGraph hg x.2", "start": [1031, 1], "end": [1039, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_graph_toLinearPMap", "code": "theorem mem_graph_toLinearPMap {g : Submodule R (E \u00d7 F)}\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0)\n    (x : g.map (LinearMap.fst R E F)) : (x.val, g.toLinearPMap x) \u2208 g", "start": [1041, 1], "end": [1045, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMap_graph_eq", "code": "@[simp]\ntheorem toLinearPMap_graph_eq (g : Submodule R (E \u00d7 F))\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) :\n    g.toLinearPMap.graph = g", "start": [1048, 1], "end": [1065, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.toLinearPMap_range", "code": "theorem toLinearPMap_range (g : Submodule R (E \u00d7 F))\n    (hg : \u2200 (x : E \u00d7 F) (_hx : x \u2208 g) (_hx' : x.fst = 0), x.snd = 0) :\n    LinearMap.range g.toLinearPMap.toFun = g.map (LinearMap.snd R E F)", "start": [1068, 1], "end": [1071, 67], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse", "code": "noncomputable def inverse (f : E \u2192\u2097.[R] F) : F \u2192\u2097.[R] E :=\n  (f.graph.map (LinearEquiv.prodComm R E F)).toLinearPMap", "start": [1081, 1], "end": [1083, 58], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_domain", "code": "theorem inverse_domain : (inverse f).domain = LinearMap.range f.toFun", "start": [1087, 1], "end": [1090, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_inverse_graph_snd_eq_zero", "code": "theorem mem_inverse_graph_snd_eq_zero (x : F \u00d7 E)\n    (hv : x \u2208 (graph f).map (LinearEquiv.prodComm R E F))\n    (hv' : x.fst = 0) : x.snd = 0", "start": [1094, 1], "end": [1106, 11], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_graph", "code": "theorem inverse_graph : (inverse f).graph = f.graph.map (LinearEquiv.prodComm R E F)", "start": [1108, 1], "end": [1109, 85], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_range", "code": "theorem inverse_range : LinearMap.range (inverse f).toFun = f.domain", "start": [1111, 1], "end": [1114, 6], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.mem_inverse_graph", "code": "theorem mem_inverse_graph (x : f.domain) : (f x, (x : E)) \u2208 (inverse f).graph", "start": [1116, 1], "end": [1119, 63], "kind": "commanddeclaration"}, {"full_name": "LinearPMap.inverse_apply_eq", "code": "theorem inverse_apply_eq {y : (inverse f).domain} {x : f.domain} (hxy : f x = y) :\n    (inverse f) y = x", "start": [1121, 1], "end": [1128, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Projection.lean", "imports": ["Mathlib/LinearAlgebra/Quotient.lean", "Mathlib/LinearAlgebra/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.ker_id_sub_eq_of_proj", "code": "theorem ker_id_sub_eq_of_proj {f : E \u2192\u2097[R] p} (hf : \u2200 x : p, f x = x) :\n    ker (id - p.subtype.comp f) = p", "start": [41, 1], "end": [45, 95], "kind": "commanddeclaration"}, {"full_name": "LinearMap.range_eq_of_proj", "code": "theorem range_eq_of_proj {f : E \u2192\u2097[R] p} (hf : \u2200 x : p, f x = x) : range f = \u22a4", "start": [48, 1], "end": [49, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isCompl_of_proj", "code": "theorem isCompl_of_proj {f : E \u2192\u2097[R] p} (hf : \u2200 x : p, f x = x) : IsCompl p (ker f)", "start": [52, 1], "end": [62, 50], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientEquivOfIsCompl", "code": "def quotientEquivOfIsCompl (h : IsCompl p q) : (E \u29f8 p) \u2243\u2097[R] q :=\n  LinearEquiv.symm <|\n    LinearEquiv.ofBijective (p.mkQ.comp q.subtype)\n      \u27e8by rw [\u2190 ker_eq_bot, ker_comp, ker_mkQ, disjoint_iff_comap_eq_bot.1 h.symm.disjoint], by\n        rw [\u2190 range_eq_top, range_comp, range_subtype, map_mkQ_eq_top, h.sup_eq_top]\u27e9", "start": [71, 1], "end": [76, 86], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientEquivOfIsCompl_symm_apply", "code": "@[simp]\ntheorem quotientEquivOfIsCompl_symm_apply (h : IsCompl p q) (x : q) :\n    (quotientEquivOfIsCompl p q h).symm x = (Quotient.mk (x:E) : E \u29f8 p)", "start": [79, 1], "end": [82, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientEquivOfIsCompl_apply_mk_coe", "code": "@[simp]\ntheorem quotientEquivOfIsCompl_apply_mk_coe (h : IsCompl p q) (x : q) :\n    quotientEquivOfIsCompl p q h (Quotient.mk x) = x", "start": [85, 1], "end": [88, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.mk_quotientEquivOfIsCompl_apply", "code": "@[simp]\ntheorem mk_quotientEquivOfIsCompl_apply (h : IsCompl p q) (x : E \u29f8 p) :\n    (Quotient.mk (quotientEquivOfIsCompl p q h x) : E \u29f8 p) = x", "start": [91, 1], "end": [94, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodEquivOfIsCompl", "code": "def prodEquivOfIsCompl (h : IsCompl p q) : (p \u00d7 q) \u2243\u2097[R] E := by\n  apply LinearEquiv.ofBijective (p.subtype.coprod q.subtype)\n  constructor\n  \u00b7 rw [\u2190 ker_eq_bot, ker_coprod_of_disjoint_range, ker_subtype, ker_subtype, prod_bot]\n    rw [range_subtype, range_subtype]\n    exact h.1\n  \u00b7 rw [\u2190 range_eq_top, \u2190 sup_eq_range, h.sup_eq_top]", "start": [97, 1], "end": [105, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_prodEquivOfIsCompl", "code": "@[simp]\ntheorem coe_prodEquivOfIsCompl (h : IsCompl p q) :\n    (prodEquivOfIsCompl p q h : p \u00d7 q \u2192\u2097[R] E) = p.subtype.coprod q.subtype", "start": [108, 1], "end": [110, 83], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_prodEquivOfIsCompl'", "code": "@[simp]\ntheorem coe_prodEquivOfIsCompl' (h : IsCompl p q) (x : p \u00d7 q) :\n    prodEquivOfIsCompl p q h x = x.1 + x.2", "start": [113, 1], "end": [115, 50], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodEquivOfIsCompl_symm_apply_left", "code": "@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_left (h : IsCompl p q) (x : p) :\n    (prodEquivOfIsCompl p q h).symm x = (x, 0)", "start": [118, 1], "end": [121, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodEquivOfIsCompl_symm_apply_right", "code": "@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_right (h : IsCompl p q) (x : q) :\n    (prodEquivOfIsCompl p q h).symm x = (0, x)", "start": [124, 1], "end": [127, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodEquivOfIsCompl_symm_apply_fst_eq_zero", "code": "@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_fst_eq_zero (h : IsCompl p q) {x : E} :\n    ((prodEquivOfIsCompl p q h).symm x).1 = 0 \u2194 x \u2208 q", "start": [130, 1], "end": [135, 50], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodEquivOfIsCompl_symm_apply_snd_eq_zero", "code": "@[simp]\ntheorem prodEquivOfIsCompl_symm_apply_snd_eq_zero (h : IsCompl p q) {x : E} :\n    ((prodEquivOfIsCompl p q h).symm x).2 = 0 \u2194 x \u2208 p", "start": [138, 1], "end": [143, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.prodComm_trans_prodEquivOfIsCompl", "code": "@[simp]\ntheorem prodComm_trans_prodEquivOfIsCompl (h : IsCompl p q) :\n    LinearEquiv.prodComm R q p \u226a\u226b\u2097 prodEquivOfIsCompl p q h = prodEquivOfIsCompl q p h.symm", "start": [146, 1], "end": [149, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl", "code": "def linearProjOfIsCompl (h : IsCompl p q) : E \u2192\u2097[R] p :=\n  LinearMap.fst R p q \u2218\u2097 \u2191(prodEquivOfIsCompl p q h).symm", "start": [152, 1], "end": [154, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_apply_left", "code": "@[simp]\ntheorem linearProjOfIsCompl_apply_left (h : IsCompl p q) (x : p) :\n    linearProjOfIsCompl p q h x = x", "start": [159, 1], "end": [161, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_range", "code": "@[simp]\ntheorem linearProjOfIsCompl_range (h : IsCompl p q) : range (linearProjOfIsCompl p q h) = \u22a4", "start": [164, 1], "end": [166, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_apply_eq_zero_iff", "code": "@[simp]\ntheorem linearProjOfIsCompl_apply_eq_zero_iff (h : IsCompl p q) {x : E} :\n    linearProjOfIsCompl p q h x = 0 \u2194 x \u2208 q", "start": [169, 1], "end": [171, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_apply_right'", "code": "theorem linearProjOfIsCompl_apply_right' (h : IsCompl p q) (x : E) (hx : x \u2208 q) :\n    linearProjOfIsCompl p q h x = 0", "start": [174, 1], "end": [176, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_apply_right", "code": "@[simp]\ntheorem linearProjOfIsCompl_apply_right (h : IsCompl p q) (x : q) :\n    linearProjOfIsCompl p q h x = 0", "start": [179, 1], "end": [182, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_ker", "code": "@[simp]\ntheorem linearProjOfIsCompl_ker (h : IsCompl p q) : ker (linearProjOfIsCompl p q h) = q", "start": [185, 1], "end": [187, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_comp_subtype", "code": "theorem linearProjOfIsCompl_comp_subtype (h : IsCompl p q) :\n    (linearProjOfIsCompl p q h).comp p.subtype = LinearMap.id", "start": [190, 1], "end": [192, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.linearProjOfIsCompl_idempotent", "code": "theorem linearProjOfIsCompl_idempotent (h : IsCompl p q) (x : E) :\n    linearProjOfIsCompl p q h (linearProjOfIsCompl p q h x) = linearProjOfIsCompl p q h x", "start": [195, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.existsUnique_add_of_isCompl_prod", "code": "theorem existsUnique_add_of_isCompl_prod (hc : IsCompl p q) (x : E) :\n    \u2203! u : p \u00d7 q, (u.fst : E) + u.snd = x", "start": [200, 1], "end": [202, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.existsUnique_add_of_isCompl", "code": "theorem existsUnique_add_of_isCompl (hc : IsCompl p q) (x : E) :\n    \u2203 (u : p) (v : q), (u : E) + v = x \u2227 \u2200 (r : p) (s : q), (r : E) + s = x \u2192 r = u \u2227 s = v", "start": [205, 1], "end": [208, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.linear_proj_add_linearProjOfIsCompl_eq_self", "code": "theorem linear_proj_add_linearProjOfIsCompl_eq_self (hpq : IsCompl p q) (x : E) :\n    (p.linearProjOfIsCompl q hpq x + q.linearProjOfIsCompl p hpq.symm x : E) = x", "start": [211, 1], "end": [215, 56], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl", "code": "def ofIsCompl {p q : Submodule R E} (h : IsCompl p q) (\u03c6 : p \u2192\u2097[R] F) (\u03c8 : q \u2192\u2097[R] F) : E \u2192\u2097[R] F :=\n  LinearMap.coprod \u03c6 \u03c8 \u2218\u2097 \u2191(Submodule.prodEquivOfIsCompl _ _ h).symm", "start": [224, 1], "end": [227, 69], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_left_apply", "code": "@[simp]\ntheorem ofIsCompl_left_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (u : p) :\n    ofIsCompl h \u03c6 \u03c8 (u : E) = \u03c6 u", "start": [232, 1], "end": [234, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_right_apply", "code": "@[simp]\ntheorem ofIsCompl_right_apply (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (v : q) :\n    ofIsCompl h \u03c6 \u03c8 (v : E) = \u03c8 v", "start": [237, 1], "end": [239, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_eq", "code": "theorem ofIsCompl_eq (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} {\u03c7 : E \u2192\u2097[R] F}\n    (h\u03c6 : \u2200 u, \u03c6 u = \u03c7 u) (h\u03c8 : \u2200 u, \u03c8 u = \u03c7 u) : ofIsCompl h \u03c6 \u03c8 = \u03c7", "start": [242, 1], "end": [246, 27], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_eq'", "code": "theorem ofIsCompl_eq' (h : IsCompl p q) {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} {\u03c7 : E \u2192\u2097[R] F}\n    (h\u03c6 : \u03c6 = \u03c7.comp p.subtype) (h\u03c8 : \u03c8 = \u03c7.comp q.subtype) : ofIsCompl h \u03c6 \u03c8 = \u03c7", "start": [249, 1], "end": [251, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_zero", "code": "@[simp]\ntheorem ofIsCompl_zero (h : IsCompl p q) : (ofIsCompl h 0 0 : E \u2192\u2097[R] F) = 0", "start": [254, 1], "end": [256, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_add", "code": "@[simp]\ntheorem ofIsCompl_add (h : IsCompl p q) {\u03c6\u2081 \u03c6\u2082 : p \u2192\u2097[R] F} {\u03c8\u2081 \u03c8\u2082 : q \u2192\u2097[R] F} :\n    ofIsCompl h (\u03c6\u2081 + \u03c6\u2082) (\u03c8\u2081 + \u03c8\u2082) = ofIsCompl h \u03c6\u2081 \u03c8\u2081 + ofIsCompl h \u03c6\u2082 \u03c8\u2082", "start": [259, 1], "end": [262, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsCompl_smul", "code": "@[simp]\ntheorem ofIsCompl_smul {R : Type*} [CommRing R] {E : Type*} [AddCommGroup E] [Module R E]\n    {F : Type*} [AddCommGroup F] [Module R F] {p q : Submodule R E} (h : IsCompl p q)\n    {\u03c6 : p \u2192\u2097[R] F} {\u03c8 : q \u2192\u2097[R] F} (c : R) : ofIsCompl h (c \u2022 \u03c6) (c \u2022 \u03c8) = c \u2022 ofIsCompl h \u03c6 \u03c8", "start": [265, 1], "end": [269, 37], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsComplProd", "code": "def ofIsComplProd {p q : Submodule R\u2081 E} (h : IsCompl p q) :\n    (p \u2192\u2097[R\u2081] F) \u00d7 (q \u2192\u2097[R\u2081] F) \u2192\u2097[R\u2081] E \u2192\u2097[R\u2081] F where\n  toFun \u03c6 := ofIsCompl h \u03c6.1 \u03c6.2\n  map_add' := by intro \u03c6 \u03c8; dsimp only; rw [Prod.snd_add, Prod.fst_add, ofIsCompl_add]\n  map_smul' := by intro c \u03c6; simp [Prod.smul_snd, Prod.smul_fst, ofIsCompl_smul]", "start": [276, 1], "end": [281, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsComplProd_apply", "code": "@[simp]\ntheorem ofIsComplProd_apply {p q : Submodule R\u2081 E} (h : IsCompl p q)\n    (\u03c6 : (p \u2192\u2097[R\u2081] F) \u00d7 (q \u2192\u2097[R\u2081] F)) : ofIsComplProd h \u03c6 = ofIsCompl h \u03c6.1 \u03c6.2", "start": [284, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ofIsComplProdEquiv", "code": "def ofIsComplProdEquiv {p q : Submodule R\u2081 E} (h : IsCompl p q) :\n    ((p \u2192\u2097[R\u2081] F) \u00d7 (q \u2192\u2097[R\u2081] F)) \u2243\u2097[R\u2081] E \u2192\u2097[R\u2081] F :=\n  { ofIsComplProd h with\n    invFun := fun \u03c6 => \u27e8\u03c6.domRestrict p, \u03c6.domRestrict q\u27e9\n    left_inv := fun \u03c6 \u21a6 by\n      ext x\n      \u00b7 exact ofIsCompl_left_apply h x\n      \u00b7 exact ofIsCompl_right_apply h x\n    right_inv := fun \u03c6 \u21a6 by\n      ext x\n      obtain \u27e8a, b, hab, _\u27e9 := existsUnique_add_of_isCompl h x\n      rw [\u2190 hab]; simp }", "start": [290, 1], "end": [302, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.linearProjOfIsCompl_of_proj", "code": "@[simp, nolint simpNF] theorem linearProjOfIsCompl_of_proj (f : E \u2192\u2097[R] p) (hf : \u2200 x : p, f x = x) :\n    p.linearProjOfIsCompl (ker f) (isCompl_of_proj hf) = f", "start": [307, 1], "end": [313, 12], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivProdOfSurjectiveOfIsCompl", "code": "def equivProdOfSurjectiveOfIsCompl (f : E \u2192\u2097[R] F) (g : E \u2192\u2097[R] G) (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) : E \u2243\u2097[R] F \u00d7 G :=\n  LinearEquiv.ofBijective (f.prod g)\n    \u27e8by simp [\u2190 ker_eq_bot, hfg.inf_eq_bot], by\n      rw [\u2190 range_eq_top]\n      simp [range_prod_eq hfg.sup_eq_top, *]\u27e9", "start": [316, 1], "end": [324, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_equivProdOfSurjectiveOfIsCompl", "code": "@[simp]\ntheorem coe_equivProdOfSurjectiveOfIsCompl {f : E \u2192\u2097[R] F} {g : E \u2192\u2097[R] G} (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg : E \u2192\u2097[R] F \u00d7 G) = f.prod g", "start": [327, 1], "end": [330, 85], "kind": "commanddeclaration"}, {"full_name": "LinearMap.equivProdOfSurjectiveOfIsCompl_apply", "code": "@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_apply {f : E \u2192\u2097[R] F} {g : E \u2192\u2097[R] G} (hf : range f = \u22a4)\n    (hg : range g = \u22a4) (hfg : IsCompl (ker f) (ker g)) (x : E) :\n    equivProdOfSurjectiveOfIsCompl f g hf hg hfg x = (f x, g x)", "start": [333, 1], "end": [336, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.isComplEquivProj", "code": "def isComplEquivProj : { q // IsCompl p q } \u2243 { f : E \u2192\u2097[R] p // \u2200 x : p, f x = x } where\n  toFun q := \u27e8linearProjOfIsCompl p q q.2, linearProjOfIsCompl_apply_left q.2\u27e9\n  invFun f := \u27e8ker (f : E \u2192\u2097[R] p), isCompl_of_proj f.2\u27e9\n  left_inv := fun \u27e8q, hq\u27e9 => by simp only [linearProjOfIsCompl_ker, Subtype.coe_mk]\n  right_inv := fun \u27e8f, hf\u27e9 => Subtype.eq <| f.linearProjOfIsCompl_of_proj hf", "start": [345, 1], "end": [351, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_isComplEquivProj_apply", "code": "@[simp]\ntheorem coe_isComplEquivProj_apply (q : { q // IsCompl p q }) :\n    (p.isComplEquivProj q : E \u2192\u2097[R] p) = linearProjOfIsCompl p q q.2", "start": [354, 1], "end": [356, 76], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_isComplEquivProj_symm_apply", "code": "@[simp]\ntheorem coe_isComplEquivProj_symm_apply (f : { f : E \u2192\u2097[R] p // \u2200 x : p, f x = x }) :\n    (p.isComplEquivProj.symm f : Submodule R E) = ker (f : E \u2192\u2097[R] p)", "start": [359, 1], "end": [361, 77], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj", "code": "structure IsProj {F : Type*} [FunLike F M fun _ => M] (f : F) : Prop where\n  map_mem : \u2200 x, f x \u2208 m\n  map_id : \u2200 x \u2208 m, f x = x", "start": [370, 1], "end": [378, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isProj_iff_idempotent", "code": "theorem isProj_iff_idempotent (f : M \u2192\u2097[S] M) : (\u2203 p : Submodule S M, IsProj p f) \u2194 f \u2218\u2097 f = f", "start": [381, 1], "end": [395, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.codRestrict", "code": "def codRestrict {f : M \u2192\u2097[S] M} (h : IsProj m f) : M \u2192\u2097[S] m :=\n  f.codRestrict m h.map_mem", "start": [402, 1], "end": [406, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.codRestrict_apply", "code": "@[simp]\ntheorem codRestrict_apply {f : M \u2192\u2097[S] M} (h : IsProj m f) (x : M) : \u2191(h.codRestrict x) = f x", "start": [409, 1], "end": [411, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.codRestrict_apply_cod", "code": "@[simp]\ntheorem codRestrict_apply_cod {f : M \u2192\u2097[S] M} (h : IsProj m f) (x : m) : h.codRestrict x = x", "start": [414, 1], "end": [418, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.codRestrict_ker", "code": "theorem codRestrict_ker {f : M \u2192\u2097[S] M} (h : IsProj m f) : ker h.codRestrict = ker f", "start": [421, 1], "end": [422, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.isCompl", "code": "theorem isCompl {f : E \u2192\u2097[R] E} (h : IsProj p f) : IsCompl p (ker f)", "start": [425, 1], "end": [427, 48], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.eq_conj_prod_map'", "code": "theorem eq_conj_prod_map' {f : E \u2192\u2097[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).toLinearMap \u2218\u2097\n        prodMap id 0 \u2218\u2097 (p.prodEquivOfIsCompl (ker f) h.isCompl).symm.toLinearMap", "start": [430, 1], "end": [438, 78], "kind": "commanddeclaration"}, {"full_name": "LinearMap.IsProj.eq_conj_prodMap", "code": "theorem IsProj.eq_conj_prodMap {f : E \u2192\u2097[R] E} (h : IsProj p f) :\n    f = (p.prodEquivOfIsCompl (ker f) h.isCompl).conj (prodMap id 0)", "start": [453, 1], "end": [456, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Intervals.lean", "imports": ["Mathlib/Tactic/Linarith.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Nat/Interval.lean"], "premises": [{"full_name": "Finset.prod_Ico_add'", "code": "@[to_additive]\ntheorem prod_Ico_add' [OrderedCancelAddCommMonoid \u03b1] [ExistsAddOfLE \u03b1] [LocallyFiniteOrder \u03b1]\n    (f : \u03b1 \u2192 \u03b2) (a b c : \u03b1) : (\u220f x in Ico a b, f (x + c)) = \u220f x in Ico (a + c) (b + c), f x", "start": [33, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_add", "code": "@[to_additive]\ntheorem prod_Ico_add [OrderedCancelAddCommMonoid \u03b1] [ExistsAddOfLE \u03b1] [LocallyFiniteOrder \u03b1]\n    (f : \u03b1 \u2192 \u03b2) (a b c : \u03b1) : (\u220f x in Ico a b, f (c + x)) = \u220f x in Ico (a + c) (b + c), f x", "start": [41, 1], "end": [45, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_succ_top", "code": "@[to_additive]\ntheorem prod_Ico_succ_top {a b : \u2115} (hab : a \u2264 b) (f : \u2115 \u2192 \u03b2) :\n    (\u220f k in Ico a (b + 1), f k) = (\u220f k in Ico a b, f k) * f b", "start": [49, 1], "end": [52, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_eq_prod_Ico_succ_bot", "code": "@[to_additive]\ntheorem prod_eq_prod_Ico_succ_bot {a b : \u2115} (hab : a < b) (f : \u2115 \u2192 \u03b2) :\n    \u220f k in Ico a b, f k = f a * \u220f k in Ico (a + 1) b, f k", "start": [56, 1], "end": [60, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_consecutive", "code": "@[to_additive]\ntheorem prod_Ico_consecutive (f : \u2115 \u2192 \u03b2) {m n k : \u2115} (hmn : m \u2264 n) (hnk : n \u2264 k) :\n    ((\u220f i in Ico m n, f i) * \u220f i in Ico n k, f i) = \u220f i in Ico m k, f i", "start": [64, 1], "end": [67, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ioc_consecutive", "code": "@[to_additive]\ntheorem prod_Ioc_consecutive (f : \u2115 \u2192 \u03b2) {m n k : \u2115} (hmn : m \u2264 n) (hnk : n \u2264 k) :\n    ((\u220f i in Ioc m n, f i) * \u220f i in Ioc n k, f i) = \u220f i in Ioc m k, f i", "start": [71, 1], "end": [77, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ioc_succ_top", "code": "@[to_additive]\ntheorem prod_Ioc_succ_top {a b : \u2115} (hab : a \u2264 b) (f : \u2115 \u2192 \u03b2) :\n    (\u220f k in Ioc a (b + 1), f k) = (\u220f k in Ioc a b, f k) * f (b + 1)", "start": [81, 1], "end": [84, 92], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_mul_prod_Ico", "code": "@[to_additive]\ntheorem prod_range_mul_prod_Ico (f : \u2115 \u2192 \u03b2) {m n : \u2115} (h : m \u2264 n) :\n    ((\u220f k in range m, f k) * \u220f k in Ico m n, f k) = \u220f k in range n, f k", "start": [88, 1], "end": [91, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_eq_mul_inv", "code": "@[to_additive]\ntheorem prod_Ico_eq_mul_inv {\u03b4 : Type*} [CommGroup \u03b4] (f : \u2115 \u2192 \u03b4) {m n : \u2115} (h : m \u2264 n) :\n    \u220f k in Ico m n, f k = (\u220f k in range n, f k) * (\u220f k in range m, f k)\u207b\u00b9", "start": [95, 1], "end": [98, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_eq_div", "code": "@[to_additive]\ntheorem prod_Ico_eq_div {\u03b4 : Type*} [CommGroup \u03b4] (f : \u2115 \u2192 \u03b4) {m n : \u2115} (h : m \u2264 n) :\n    \u220f k in Ico m n, f k = (\u220f k in range n, f k) / \u220f k in range m, f k", "start": [102, 1], "end": [105, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_div_prod_range", "code": "@[to_additive]\ntheorem prod_range_div_prod_range {\u03b1 : Type*} [CommGroup \u03b1] {f : \u2115 \u2192 \u03b1} {n m : \u2115} (hnm : n \u2264 m) :\n    ((\u220f k in range m, f k) / \u220f k in range n, f k) =\n    \u220f k in (range m).filter fun k => n \u2264 k, f k", "start": [109, 1], "end": [117, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_Ico_Ico_comm", "code": "theorem sum_Ico_Ico_comm {M : Type*} [AddCommMonoid M] (a b : \u2115) (f : \u2115 \u2192 \u2115 \u2192 M) :\n    (\u2211 i in Finset.Ico a b, \u2211 j in Finset.Ico i b, f i j) =\n      \u2211 j in Finset.Ico a b, \u2211 i in Finset.Ico a (j + 1), f i j", "start": [121, 1], "end": [133, 11], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_eq_prod_range", "code": "@[to_additive]\ntheorem prod_Ico_eq_prod_range (f : \u2115 \u2192 \u03b2) (m n : \u2115) :\n    \u220f k in Ico m n, f k = \u220f k in range (n - m), f (m + k)", "start": [136, 1], "end": [142, 93], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_reflect", "code": "theorem prod_Ico_reflect (f : \u2115 \u2192 \u03b2) (k : \u2115) {m n : \u2115} (h : m \u2264 n + 1) :\n    (\u220f j in Ico k m, f (n - j)) = \u220f j in Ico (n + 1 - m) (n + 1 - k), f j", "start": [146, 1], "end": [161, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_Ico_reflect", "code": "theorem sum_Ico_reflect {\u03b4 : Type*} [AddCommMonoid \u03b4] (f : \u2115 \u2192 \u03b4) (k : \u2115) {m n : \u2115}\n    (h : m \u2264 n + 1) : (\u2211 j in Ico k m, f (n - j)) = \u2211 j in Ico (n + 1 - m) (n + 1 - k), f j", "start": [164, 1], "end": [166, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_reflect", "code": "theorem prod_range_reflect (f : \u2115 \u2192 \u03b2) (n : \u2115) :\n    (\u220f j in range n, f (n - 1 - j)) = \u220f j in range n, f j", "start": [169, 1], "end": [175, 9], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_reflect", "code": "theorem sum_range_reflect {\u03b4 : Type*} [AddCommMonoid \u03b4] (f : \u2115 \u2192 \u03b4) (n : \u2115) :\n    (\u2211 j in range n, f (n - 1 - j)) = \u2211 j in range n, f j", "start": [178, 1], "end": [180, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_id_eq_factorial", "code": "@[simp]\ntheorem prod_Ico_id_eq_factorial : \u2200 n : \u2115, (\u220f x in Ico 1 (n + 1), x) = n !", "start": [183, 1], "end": [188, 65], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_add_one_eq_factorial", "code": "@[simp]\ntheorem prod_range_add_one_eq_factorial : \u2200 n : \u2115, (\u220f x in range n, (x + 1)) = n !", "start": [191, 1], "end": [194, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_id_mul_two", "code": "theorem sum_range_id_mul_two (n : \u2115) : (\u2211 i in range n, i) * 2 = n * (n - 1)", "start": [199, 1], "end": [207, 71], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_id", "code": "theorem sum_range_id (n : \u2115) : \u2211 i in range n, i = n * (n - 1) / 2", "start": [210, 1], "end": [212, 66], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_succ_div_prod", "code": "@[to_additive]\ntheorem prod_range_succ_div_prod : ((\u220f i in range (n + 1), f i) / \u220f i in range n, f i) = f n", "start": [229, 1], "end": [231, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_range_succ_div_top", "code": "@[to_additive]\ntheorem prod_range_succ_div_top : (\u220f i in range (n + 1), f i) / f n = \u220f i in range n, f i", "start": [235, 1], "end": [237, 47], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_div_bot", "code": "@[to_additive]\ntheorem prod_Ico_div_bot (hmn : m < n) : (\u220f i in Ico m n, f i) / f m = \u220f i in Ico (m + 1) n, f i", "start": [241, 1], "end": [243, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_Ico_succ_div_top", "code": "@[to_additive]\ntheorem prod_Ico_succ_div_top (hmn : m \u2264 n) :\n    (\u220f i in Ico m (n + 1), f i) / f n = \u220f i in Ico m n, f i", "start": [247, 1], "end": [250, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_Ico_by_parts", "code": "theorem sum_Ico_by_parts (hmn : m < n) :\n    \u2211 i in Ico m n, f i \u2022 g i =\n      f (n - 1) \u2022 G n - f m \u2022 G m - \u2211 i in Ico m (n - 1), (f (i + 1) - f i) \u2022 G (i + 1)", "start": [267, 1], "end": [304, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_range_by_parts", "code": "theorem sum_range_by_parts :\n    \u2211 i in range n, f i \u2022 g i =\n      f (n - 1) \u2022 G n - \u2211 i in range (n - 1), (f (i + 1) - f i) \u2022 G (i + 1)", "start": [309, 1], "end": [316, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "imports": ["Mathlib/Data/Finset/NatAntidiagonal.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finset.Nat.prod_antidiagonal_succ", "code": "theorem prod_antidiagonal_succ {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 M} :\n    (\u220f p in antidiagonal (n + 1), f p) = f (0, n + 1) * \u220f p in antidiagonal n, f (p.1 + 1, p.2)", "start": [25, 1], "end": [27, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.sum_antidiagonal_succ", "code": "theorem sum_antidiagonal_succ {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 N} :\n    (\u2211 p in antidiagonal (n + 1), f p) = f (0, n + 1) + \u2211 p in antidiagonal n, f (p.1 + 1, p.2)", "start": [30, 1], "end": [32, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.prod_antidiagonal_swap", "code": "@[to_additive]\ntheorem prod_antidiagonal_swap {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 M} :\n    \u220f p in antidiagonal n, f p.swap = \u220f p in antidiagonal n, f p", "start": [35, 1], "end": [38, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.prod_antidiagonal_succ'", "code": "theorem prod_antidiagonal_succ' {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 M} : (\u220f p in antidiagonal (n + 1), f p) =\n    f (n + 1, 0) * \u220f p in antidiagonal n, f (p.1, p.2 + 1)", "start": [42, 1], "end": [45, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.sum_antidiagonal_succ'", "code": "theorem sum_antidiagonal_succ' {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 N} :\n    (\u2211 p in antidiagonal (n + 1), f p) = f (n + 1, 0) + \u2211 p in antidiagonal n, f (p.1, p.2 + 1)", "start": [48, 1], "end": [50, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.prod_antidiagonal_subst", "code": "@[to_additive]\ntheorem prod_antidiagonal_subst {n : \u2115} {f : \u2115 \u00d7 \u2115 \u2192 \u2115 \u2192 M} :\n    \u220f p in antidiagonal n, f p n = \u220f p in antidiagonal n, f p (p.1 + p.2)", "start": [53, 1], "end": [56, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.prod_antidiagonal_eq_prod_range_succ_mk", "code": "@[to_additive]\ntheorem prod_antidiagonal_eq_prod_range_succ_mk {M : Type*} [CommMonoid M] (f : \u2115 \u00d7 \u2115 \u2192 M)\n    (n : \u2115) : \u220f ij in Finset.Nat.antidiagonal n, f ij = \u220f k in range n.succ, f (k, n - k)", "start": [60, 1], "end": [63, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.Nat.prod_antidiagonal_eq_prod_range_succ", "code": "@[to_additive \"This lemma matches more generally than\n`Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk` when using `rw \u2190`.\"]\ntheorem prod_antidiagonal_eq_prod_range_succ {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) (n : \u2115) :\n    \u220f ij in Finset.Nat.antidiagonal n, f ij.1 ij.2 = \u220f k in range n.succ, f k (n - k)", "start": [67, 1], "end": [73, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Monotonicity/Lemmas.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Algebra/Order/Group/Abs.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Monotonicity/Attr.lean", "Mathlib/Algebra/Order/Sub/Canonical.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": []}
{"path": "Mathlib/Tactic/Monotonicity/Basic.lean", "imports": ["Mathlib/Tactic/SolveByElim.lean", "Mathlib/Tactic/Monotonicity/Attr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Tactic/FieldSimp.lean", "imports": ["lake-packages/std/Std/Lean/Parser.lean", "Mathlib/Algebra/Group/Units.lean", "lake-packages/lean4/src/lean/Lean/Elab/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Positivity/Core.lean", "lake-packages/Qq/Qq.lean", "Mathlib/Util/DischargerAsTactic.lean", "lake-packages/lean4/src/lean/Lean/Meta/Tactic/Simp/Main.lean", "Mathlib/Tactic/NormNum/Core.lean"], "premises": [{"full_name": "Mathlib.Tactic.FieldSimp.dischargerTraceMessage", "code": "private def dischargerTraceMessage (prop: Expr) : Except \u03b5 (Option Expr) \u2192 SimpM MessageData\n| .error _ | .ok none => return m!\"{crossEmoji} discharge {prop}\"\n| .ok (some _) => return m!\"{checkEmoji} discharge {prop}\"", "start": [31, 1], "end": [34, 59], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.FieldSimp.discharge", "code": "partial def discharge (prop : Expr) : SimpM (Option Expr) :=\n  withTraceNode `Tactic.field_simp (dischargerTraceMessage prop) do\n    if let some r \u2190 Simp.dischargeUsingAssumption? prop then\n      return some r\n\n    let prop : Q(Prop) \u2190 (do pure prop)\n    let pf? \u2190 match prop with\n    | ~q(($e : $\u03b1) \u2260 $b) =>\n        try\n          let res \u2190 Mathlib.Meta.NormNum.derive (\u03b1 := (q(Prop) : Q(Type))) prop\n          match res with\n          | .isTrue pf => pure (some pf)\n          | _ => pure none\n        catch _ =>\n          pure none\n    | _ => pure none\n    if let some pf := pf? then return some pf\n\n    let pf? \u2190\n      try some <$> Mathlib.Meta.Positivity.solve prop\n      catch _ => pure none\n    if let some pf := pf? then return some pf\n\n    let ctx \u2190 read\n    let usedTheorems := (\u2190 get).usedTheorems\n\n    let \u27e8simpResult, usedTheorems'\u27e9 \u2190\n      simp prop { ctx with dischargeDepth := ctx.dischargeDepth + 1} discharge usedTheorems\n    set {(\u2190 get) with usedTheorems := usedTheorems'}\n    if simpResult.expr.isConstOf ``True then\n      try\n        return some (\u2190 mkOfEqTrue (\u2190 simpResult.getProof))\n      catch _ =>\n        return none\n    else\n      return none", "start": [36, 1], "end": [82, 18], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Floor.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Tactic/Abel.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Data/Set/Lattice.lean", "Mathlib/Data/Set/Intervals/Group.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Int/Lemmas.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Init/Meta/WellFoundedTactics.lean", "Mathlib/Data/Int/CharZero.lean"], "premises": [{"full_name": "FloorSemiring", "code": "class FloorSemiring (\u03b1) [OrderedSemiring \u03b1] where\n  \n  floor : \u03b1 \u2192 \u2115\n  \n  ceil : \u03b1 \u2192 \u2115\n  \n  floor_of_neg {a : \u03b1} (ha : a < 0) : floor a = 0\n  \n  gc_floor {a : \u03b1} {n : \u2115} (ha : 0 \u2264 a) : n \u2264 floor a \u2194 (n : \u03b1) \u2264 a\n  \n  gc_ceil : GaloisConnection ceil (\u2191)", "start": [64, 1], "end": [78, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.floor", "code": "def floor : \u03b1 \u2192 \u2115 :=\n  FloorSemiring.floor", "start": [98, 1], "end": [100, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil", "code": "def ceil : \u03b1 \u2192 \u2115 :=\n  FloorSemiring.ceil", "start": [103, 1], "end": [105, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_nat", "code": "@[simp]\ntheorem floor_nat : (Nat.floor : \u2115 \u2192 \u2115) = id", "start": [108, 1], "end": [110, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_nat", "code": "@[simp]\ntheorem ceil_nat : (Nat.ceil : \u2115 \u2192 \u2115) = id", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.le_floor_iff", "code": "theorem le_floor_iff (ha : 0 \u2264 a) : n \u2264 \u230aa\u230b\u208a \u2194 (n : \u03b1) \u2264 a", "start": [130, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.le_floor", "code": "theorem le_floor (h : (n : \u03b1) \u2264 a) : n \u2264 \u230aa\u230b\u208a", "start": [134, 1], "end": [135, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_lt", "code": "theorem floor_lt (ha : 0 \u2264 a) : \u230aa\u230b\u208a < n \u2194 a < n", "start": [138, 1], "end": [139, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_lt_one", "code": "theorem floor_lt_one (ha : 0 \u2264 a) : \u230aa\u230b\u208a < 1 \u2194 a < 1", "start": [142, 1], "end": [143, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_floor_lt", "code": "theorem lt_of_floor_lt (h : \u230aa\u230b\u208a < n) : a < n", "start": [146, 1], "end": [147, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_one_of_floor_lt_one", "code": "theorem lt_one_of_floor_lt_one (h : \u230aa\u230b\u208a < 1) : a < 1", "start": [150, 1], "end": [150, 92], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_le", "code": "theorem floor_le (ha : 0 \u2264 a) : (\u230aa\u230b\u208a : \u03b1) \u2264 a", "start": [153, 1], "end": [154, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_succ_floor", "code": "theorem lt_succ_floor (a : \u03b1) : a < \u230aa\u230b\u208a.succ", "start": [157, 1], "end": [158, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_floor_add_one", "code": "theorem lt_floor_add_one (a : \u03b1) : a < \u230aa\u230b\u208a + 1", "start": [161, 1], "end": [161, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_coe", "code": "@[simp]\ntheorem floor_coe (n : \u2115) : \u230a(n : \u03b1)\u230b\u208a = n", "start": [164, 1], "end": [168, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_zero", "code": "@[simp]\ntheorem floor_zero : \u230a(0 : \u03b1)\u230b\u208a = 0", "start": [171, 1], "end": [172, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_one", "code": "@[simp]\ntheorem floor_one : \u230a(1 : \u03b1)\u230b\u208a = 1", "start": [175, 1], "end": [176, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_of_nonpos", "code": "theorem floor_of_nonpos (ha : a \u2264 0) : \u230aa\u230b\u208a = 0", "start": [179, 1], "end": [182, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_mono", "code": "theorem floor_mono : Monotone (floor : \u03b1 \u2192 \u2115)", "start": [185, 1], "end": [189, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.le_floor_iff'", "code": "theorem le_floor_iff' (hn : n \u2260 0) : n \u2264 \u230aa\u230b\u208a \u2194 (n : \u03b1) \u2264 a", "start": [192, 1], "end": [198, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_floor_iff", "code": "@[simp]\ntheorem one_le_floor_iff (x : \u03b1) : 1 \u2264 \u230ax\u230b\u208a \u2194 1 \u2264 x", "start": [201, 1], "end": [203, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_lt'", "code": "theorem floor_lt' (hn : n \u2260 0) : \u230aa\u230b\u208a < n \u2194 a < n", "start": [206, 1], "end": [207, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_pos", "code": "theorem floor_pos : 0 < \u230aa\u230b\u208a \u2194 1 \u2264 a", "start": [210, 1], "end": [212, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.pos_of_floor_pos", "code": "theorem pos_of_floor_pos (h : 0 < \u230aa\u230b\u208a) : 0 < a", "start": [215, 1], "end": [216, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_lt_floor", "code": "theorem lt_of_lt_floor (h : n < \u230aa\u230b\u208a) : \u2191n < a", "start": [219, 1], "end": [220, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_le_of_le", "code": "theorem floor_le_of_le (h : a \u2264 n) : \u230aa\u230b\u208a \u2264 n", "start": [223, 1], "end": [224, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_le_one_of_le_one", "code": "theorem floor_le_one_of_le_one (h : a \u2264 1) : \u230aa\u230b\u208a \u2264 1", "start": [227, 1], "end": [228, 52], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_eq_zero", "code": "@[simp]\ntheorem floor_eq_zero : \u230aa\u230b\u208a = 0 \u2194 a < 1", "start": [231, 1], "end": [234, 34], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_eq_iff", "code": "theorem floor_eq_iff (ha : 0 \u2264 a) : \u230aa\u230b\u208a = n \u2194 \u2191n \u2264 a \u2227 a < \u2191n + 1", "start": [237, 1], "end": [239, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_eq_iff'", "code": "theorem floor_eq_iff' (hn : n \u2260 0) : \u230aa\u230b\u208a = n \u2194 \u2191n \u2264 a \u2227 a < \u2191n + 1", "start": [242, 1], "end": [244, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_eq_on_Ico", "code": "theorem floor_eq_on_Ico (n : \u2115) : \u2200 a \u2208 (Set.Ico n (n + 1) : Set \u03b1), \u230aa\u230b\u208a = n", "start": [247, 1], "end": [248, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_eq_on_Ico'", "code": "theorem floor_eq_on_Ico' (n : \u2115) :\n    \u2200 a \u2208 (Set.Ico n (n + 1) : Set \u03b1), (\u230aa\u230b\u208a : \u03b1) = n", "start": [251, 1], "end": [253, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_floor_zero", "code": "@[simp]\ntheorem preimage_floor_zero : (floor : \u03b1 \u2192 \u2115) \u207b\u00b9' {0} = Iio 1", "start": [256, 1], "end": [258, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_floor_of_ne_zero", "code": "theorem preimage_floor_of_ne_zero {n : \u2115} (hn : n \u2260 0) :\n    (floor : \u03b1 \u2192 \u2115) \u207b\u00b9' {n} = Ico (n:\u03b1) (n + 1)", "start": [262, 1], "end": [264, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.gc_ceil_coe", "code": "theorem gc_ceil_coe : GaloisConnection (ceil : \u03b1 \u2192 \u2115) (\u2191)", "start": [270, 1], "end": [271, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_le", "code": "@[simp]\ntheorem ceil_le : \u2308a\u2309\u208a \u2264 n \u2194 a \u2264 n", "start": [274, 1], "end": [276, 18], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_ceil", "code": "theorem lt_ceil : n < \u2308a\u2309\u208a \u2194 (n : \u03b1) < a", "start": [279, 1], "end": [280, 33], "kind": "commanddeclaration"}, {"full_name": "Nat.add_one_le_ceil_iff", "code": "theorem add_one_le_ceil_iff : n + 1 \u2264 \u2308a\u2309\u208a \u2194 (n : \u03b1) < a", "start": [285, 1], "end": [286, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.one_le_ceil_iff", "code": "@[simp]\ntheorem one_le_ceil_iff : 1 \u2264 \u2308a\u2309\u208a \u2194 0 < a", "start": [289, 1], "end": [291, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_le_floor_add_one", "code": "theorem ceil_le_floor_add_one (a : \u03b1) : \u2308a\u2309\u208a \u2264 \u230aa\u230b\u208a + 1", "start": [294, 1], "end": [296, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.le_ceil", "code": "theorem le_ceil (a : \u03b1) : a \u2264 \u2308a\u2309\u208a", "start": [299, 1], "end": [300, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_intCast", "code": "@[simp]\ntheorem ceil_intCast {\u03b1 : Type*} [LinearOrderedRing \u03b1] [FloorSemiring \u03b1] (z : \u2124) :\n    \u2308(z : \u03b1)\u2309\u208a = z.toNat", "start": [303, 1], "end": [308, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_natCast", "code": "@[simp]\ntheorem ceil_natCast (n : \u2115) : \u2308(n : \u03b1)\u2309\u208a = n", "start": [311, 1], "end": [313, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_mono", "code": "theorem ceil_mono : Monotone (ceil : \u03b1 \u2192 \u2115)", "start": [316, 1], "end": [317, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_zero", "code": "@[simp]\ntheorem ceil_zero : \u2308(0 : \u03b1)\u2309\u208a = 0", "start": [320, 1], "end": [321, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_one", "code": "@[simp]\ntheorem ceil_one : \u2308(1 : \u03b1)\u2309\u208a = 1", "start": [324, 1], "end": [325, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_eq_zero", "code": "@[simp]\ntheorem ceil_eq_zero : \u2308a\u2309\u208a = 0 \u2194 a \u2264 0", "start": [328, 1], "end": [329, 89], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_pos", "code": "@[simp]\ntheorem ceil_pos : 0 < \u2308a\u2309\u208a \u2194 0 < a", "start": [332, 1], "end": [333, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.lt_of_ceil_lt", "code": "theorem lt_of_ceil_lt (h : \u2308a\u2309\u208a < n) : a < n", "start": [336, 1], "end": [337, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.le_of_ceil_le", "code": "theorem le_of_ceil_le (h : \u2308a\u2309\u208a \u2264 n) : a \u2264 n", "start": [340, 1], "end": [341, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_le_ceil", "code": "theorem floor_le_ceil (a : \u03b1) : \u230aa\u230b\u208a \u2264 \u2308a\u2309\u208a", "start": [344, 1], "end": [348, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_lt_ceil_of_lt_of_pos", "code": "theorem floor_lt_ceil_of_lt_of_pos {a b : \u03b1} (h : a < b) (h' : 0 < b) : \u230aa\u230b\u208a < \u2308b\u2309\u208a", "start": [351, 1], "end": [355, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_eq_iff", "code": "theorem ceil_eq_iff (hn : n \u2260 0) : \u2308a\u2309\u208a = n \u2194 \u2191(n - 1) < a \u2227 a \u2264 n", "start": [358, 1], "end": [361, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_ceil_zero", "code": "@[simp]\ntheorem preimage_ceil_zero : (Nat.ceil : \u03b1 \u2192 \u2115) \u207b\u00b9' {0} = Iic 0", "start": [364, 1], "end": [366, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_ceil_of_ne_zero", "code": "theorem preimage_ceil_of_ne_zero (hn : n \u2260 0) : (Nat.ceil : \u03b1 \u2192 \u2115) \u207b\u00b9' {n} = Ioc (\u2191(n - 1) : \u03b1) n", "start": [370, 1], "end": [371, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Ioo", "code": "@[simp]\ntheorem preimage_Ioo {a b : \u03b1} (ha : 0 \u2264 a) :\n    (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ioo a b = Set.Ioo \u230aa\u230b\u208a \u2308b\u2309\u208a", "start": [377, 1], "end": [381, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Ico", "code": "@[simp]\ntheorem preimage_Ico {a b : \u03b1} : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309\u208a \u2308b\u2309\u208a", "start": [385, 1], "end": [388, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Ioc", "code": "@[simp]\ntheorem preimage_Ioc {a b : \u03b1} (ha : 0 \u2264 a) (hb : 0 \u2264 b) :\n    (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ioc a b = Set.Ioc \u230aa\u230b\u208a \u230ab\u230b\u208a", "start": [392, 1], "end": [396, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Icc", "code": "@[simp]\ntheorem preimage_Icc {a b : \u03b1} (hb : 0 \u2264 b) :\n    (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309\u208a \u230ab\u230b\u208a", "start": [400, 1], "end": [404, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Ioi", "code": "@[simp]\ntheorem preimage_Ioi {a : \u03b1} (ha : 0 \u2264 a) : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ioi a = Set.Ioi \u230aa\u230b\u208a", "start": [408, 1], "end": [411, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Ici", "code": "@[simp]\ntheorem preimage_Ici {a : \u03b1} : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ici a = Set.Ici \u2308a\u2309\u208a", "start": [415, 1], "end": [418, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Iio", "code": "@[simp]\ntheorem preimage_Iio {a : \u03b1} : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Iio a = Set.Iio \u2308a\u2309\u208a", "start": [422, 1], "end": [425, 17], "kind": "commanddeclaration"}, {"full_name": "Nat.preimage_Iic", "code": "@[simp]\ntheorem preimage_Iic {a : \u03b1} (ha : 0 \u2264 a) : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Iic a = Set.Iic \u230aa\u230b\u208a", "start": [429, 1], "end": [432, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_add_nat", "code": "theorem floor_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u230aa + n\u230b\u208a = \u230aa\u230b\u208a + n", "start": [435, 1], "end": [445, 87], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_add_one", "code": "theorem floor_add_one (ha : 0 \u2264 a) : \u230aa + 1\u230b\u208a = \u230aa\u230b\u208a + 1", "start": [448, 1], "end": [450, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_add_ofNat", "code": "theorem floor_add_ofNat (ha : 0 \u2264 a) (n : \u2115) [n.AtLeastTwo] :\n    \u230aa + OfNat.ofNat n\u230b\u208a = \u230aa\u230b\u208a + OfNat.ofNat n", "start": [453, 1], "end": [455, 21], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_sub_nat", "code": "@[simp]\ntheorem floor_sub_nat [Sub \u03b1] [OrderedSub \u03b1] [ExistsAddOfLE \u03b1] (a : \u03b1) (n : \u2115) :\n    \u230aa - n\u230b\u208a = \u230aa\u230b\u208a - n", "start": [457, 1], "end": [466, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_sub_one", "code": "@[simp]\ntheorem floor_sub_one [Sub \u03b1] [OrderedSub \u03b1] [ExistsAddOfLE \u03b1] (a : \u03b1) : \u230aa - 1\u230b\u208a = \u230aa\u230b\u208a - 1", "start": [469, 1], "end": [471, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_sub_ofNat", "code": "@[simp]\ntheorem floor_sub_ofNat [Sub \u03b1] [OrderedSub \u03b1] [ExistsAddOfLE \u03b1] (a : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    \u230aa - OfNat.ofNat n\u230b\u208a = \u230aa\u230b\u208a - OfNat.ofNat n", "start": [473, 1], "end": [476, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_add_nat", "code": "theorem ceil_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u2308a + n\u2309\u208a = \u2308a\u2309\u208a + n", "start": [478, 1], "end": [485, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_add_one", "code": "theorem ceil_add_one (ha : 0 \u2264 a) : \u2308a + 1\u2309\u208a = \u2308a\u2309\u208a + 1", "start": [488, 1], "end": [490, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_add_ofNat", "code": "theorem ceil_add_ofNat (ha : 0 \u2264 a) (n : \u2115) [n.AtLeastTwo] :\n    \u2308a + OfNat.ofNat n\u2309\u208a = \u2308a\u2309\u208a + OfNat.ofNat n", "start": [493, 1], "end": [495, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_lt_add_one", "code": "theorem ceil_lt_add_one (ha : 0 \u2264 a) : (\u2308a\u2309\u208a : \u03b1) < a + 1", "start": [497, 1], "end": [498, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_add_le", "code": "theorem ceil_add_le (a b : \u03b1) : \u2308a + b\u2309\u208a \u2264 \u2308a\u2309\u208a + \u2308b\u2309\u208a", "start": [501, 1], "end": [503, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.sub_one_lt_floor", "code": "theorem sub_one_lt_floor (a : \u03b1) : a - 1 < \u230aa\u230b\u208a", "start": [512, 1], "end": [513, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_div_nat", "code": "theorem floor_div_nat (a : \u03b1) (n : \u2115) : \u230aa / n\u230b\u208a = \u230aa\u230b\u208a / n", "start": [524, 1], "end": [537, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_div_ofNat", "code": "theorem floor_div_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    \u230aa / OfNat.ofNat n\u230b\u208a = \u230aa\u230b\u208a / OfNat.ofNat n", "start": [540, 1], "end": [542, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_div_eq_div", "code": "theorem floor_div_eq_div (m n : \u2115) : \u230a(m : \u03b1) / n\u230b\u208a = m / n", "start": [544, 1], "end": [547, 19], "kind": "commanddeclaration"}, {"full_name": "subsingleton_floorSemiring", "code": "theorem subsingleton_floorSemiring {\u03b1} [LinearOrderedSemiring \u03b1] :\n    Subsingleton (FloorSemiring \u03b1)", "start": [554, 1], "end": [567, 8], "kind": "commanddeclaration"}, {"full_name": "FloorRing", "code": "class FloorRing (\u03b1) [LinearOrderedRing \u03b1] where\n  \n  floor : \u03b1 \u2192 \u2124\n  \n  ceil : \u03b1 \u2192 \u2124\n  \n  gc_coe_floor : GaloisConnection (\u2191) floor\n  \n  gc_ceil_coe : GaloisConnection ceil (\u2191)", "start": [572, 1], "end": [583, 42], "kind": "commanddeclaration"}, {"full_name": "FloorRing.ofFloor", "code": "def FloorRing.ofFloor (\u03b1) [LinearOrderedRing \u03b1] (floor : \u03b1 \u2192 \u2124)\n    (gc_coe_floor : GaloisConnection (\u2191) floor) : FloorRing \u03b1 :=\n  { floor\n    ceil := fun a => -floor (-a)\n    gc_coe_floor\n    gc_ceil_coe := fun a z => by rw [neg_le, \u2190 gc_coe_floor, Int.cast_neg, neg_le_neg_iff] }", "start": [596, 1], "end": [602, 93], "kind": "commanddeclaration"}, {"full_name": "FloorRing.ofCeil", "code": "def FloorRing.ofCeil (\u03b1) [LinearOrderedRing \u03b1] (ceil : \u03b1 \u2192 \u2124)\n    (gc_ceil_coe : GaloisConnection ceil (\u2191)) : FloorRing \u03b1 :=\n  { floor := fun a => -ceil (-a)\n    ceil\n    gc_coe_floor := fun a z => by rw [le_neg, gc_ceil_coe, Int.cast_neg, neg_le_neg_iff]\n    gc_ceil_coe }", "start": [605, 1], "end": [611, 18], "kind": "commanddeclaration"}, {"full_name": "Int.floor", "code": "def floor : \u03b1 \u2192 \u2124 :=\n  FloorRing.floor", "start": [618, 1], "end": [620, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ceil", "code": "def ceil : \u03b1 \u2192 \u2124 :=\n  FloorRing.ceil", "start": [623, 1], "end": [625, 17], "kind": "commanddeclaration"}, {"full_name": "Int.fract", "code": "def fract (a : \u03b1) : \u03b1 :=\n  a - floor a", "start": [628, 1], "end": [630, 14], "kind": "commanddeclaration"}, {"full_name": "Int.floor_int", "code": "@[simp]\ntheorem floor_int : (Int.floor : \u2124 \u2192 \u2124) = id", "start": [633, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_int", "code": "@[simp]\ntheorem ceil_int : (Int.ceil : \u2124 \u2192 \u2124) = id", "start": [638, 1], "end": [640, 6], "kind": "commanddeclaration"}, {"full_name": "Int.fract_int", "code": "@[simp]\ntheorem fract_int : (Int.fract : \u2124 \u2192 \u2124) = 0", "start": [643, 1], "end": [645, 34], "kind": "commanddeclaration"}, {"full_name": "Int.floorRing_floor_eq", "code": "@[simp]\ntheorem floorRing_floor_eq : @FloorRing.floor = @Int.floor", "start": [655, 1], "end": [657, 6], "kind": "commanddeclaration"}, {"full_name": "Int.floorRing_ceil_eq", "code": "@[simp]\ntheorem floorRing_ceil_eq : @FloorRing.ceil = @Int.ceil", "start": [660, 1], "end": [662, 6], "kind": "commanddeclaration"}, {"full_name": "Int.gc_coe_floor", "code": "theorem gc_coe_floor : GaloisConnection (Int.cast : \u2124 \u2192 \u03b1) floor", "start": [669, 1], "end": [670, 25], "kind": "commanddeclaration"}, {"full_name": "Int.le_floor", "code": "theorem le_floor : z \u2264 \u230aa\u230b \u2194 (z : \u03b1) \u2264 a", "start": [673, 1], "end": [674, 26], "kind": "commanddeclaration"}, {"full_name": "Int.floor_lt", "code": "theorem floor_lt : \u230aa\u230b < z \u2194 a < z", "start": [677, 1], "end": [678, 34], "kind": "commanddeclaration"}, {"full_name": "Int.floor_le", "code": "theorem floor_le (a : \u03b1) : (\u230aa\u230b : \u03b1) \u2264 a", "start": [681, 1], "end": [682, 24], "kind": "commanddeclaration"}, {"full_name": "Int.floor_nonneg", "code": "theorem floor_nonneg : 0 \u2264 \u230aa\u230b \u2194 0 \u2264 a", "start": [685, 1], "end": [685, 74], "kind": "commanddeclaration"}, {"full_name": "Int.floor_le_sub_one_iff", "code": "@[simp]\ntheorem floor_le_sub_one_iff : \u230aa\u230b \u2264 z - 1 \u2194 a < z", "start": [688, 1], "end": [689, 89], "kind": "commanddeclaration"}, {"full_name": "Int.floor_le_neg_one_iff", "code": "@[simp]\ntheorem floor_le_neg_one_iff : \u230aa\u230b \u2264 -1 \u2194 a < 0", "start": [692, 1], "end": [694, 59], "kind": "commanddeclaration"}, {"full_name": "Int.floor_nonpos", "code": "theorem floor_nonpos (ha : a \u2264 0) : \u230aa\u230b \u2264 0", "start": [697, 1], "end": [699, 30], "kind": "commanddeclaration"}, {"full_name": "Int.lt_succ_floor", "code": "theorem lt_succ_floor (a : \u03b1) : a < \u230aa\u230b.succ", "start": [702, 1], "end": [703, 35], "kind": "commanddeclaration"}, {"full_name": "Int.lt_floor_add_one", "code": "@[simp]\ntheorem lt_floor_add_one (a : \u03b1) : a < \u230aa\u230b + 1", "start": [706, 1], "end": [708, 74], "kind": "commanddeclaration"}, {"full_name": "Int.sub_one_lt_floor", "code": "@[simp]\ntheorem sub_one_lt_floor (a : \u03b1) : a - 1 < \u230aa\u230b", "start": [711, 1], "end": [713, 43], "kind": "commanddeclaration"}, {"full_name": "Int.floor_intCast", "code": "@[simp]\ntheorem floor_intCast (z : \u2124) : \u230a(z : \u03b1)\u230b = z", "start": [716, 1], "end": [718, 61], "kind": "commanddeclaration"}, {"full_name": "Int.floor_natCast", "code": "@[simp]\ntheorem floor_natCast (n : \u2115) : \u230a(n : \u03b1)\u230b = n", "start": [721, 1], "end": [723, 71], "kind": "commanddeclaration"}, {"full_name": "Int.floor_zero", "code": "@[simp]\ntheorem floor_zero : \u230a(0 : \u03b1)\u230b = 0", "start": [726, 1], "end": [727, 73], "kind": "commanddeclaration"}, {"full_name": "Int.floor_one", "code": "@[simp]\ntheorem floor_one : \u230a(1 : \u03b1)\u230b = 1", "start": [730, 1], "end": [731, 71], "kind": "commanddeclaration"}, {"full_name": "Int.floor_ofNat", "code": "@[simp] theorem floor_ofNat (n : \u2115) [n.AtLeastTwo] : \u230a(OfNat.ofNat n : \u03b1)\u230b = n", "start": [734, 1], "end": [734, 98], "kind": "commanddeclaration"}, {"full_name": "Int.floor_mono", "code": "@[mono]\ntheorem floor_mono : Monotone (floor : \u03b1 \u2192 \u2124)", "start": [736, 1], "end": [738, 26], "kind": "commanddeclaration"}, {"full_name": "Int.floor_pos", "code": "theorem floor_pos : 0 < \u230aa\u230b \u2194 1 \u2264 a", "start": [741, 1], "end": [743, 59], "kind": "commanddeclaration"}, {"full_name": "Int.floor_add_int", "code": "@[simp]\ntheorem floor_add_int (a : \u03b1) (z : \u2124) : \u230aa + z\u230b = \u230aa\u230b + z", "start": [746, 1], "end": [749, 84], "kind": "commanddeclaration"}, {"full_name": "Int.floor_add_one", "code": "@[simp]\ntheorem floor_add_one (a : \u03b1) : \u230aa + 1\u230b = \u230aa\u230b + 1", "start": [752, 1], "end": [755, 33], "kind": "commanddeclaration"}, {"full_name": "Int.le_floor_add", "code": "theorem le_floor_add (a b : \u03b1) : \u230aa\u230b + \u230ab\u230b \u2264 \u230aa + b\u230b", "start": [758, 1], "end": [760, 45], "kind": "commanddeclaration"}, {"full_name": "Int.le_floor_add_floor", "code": "theorem le_floor_add_floor (a b : \u03b1) : \u230aa + b\u230b - 1 \u2264 \u230aa\u230b + \u230ab\u230b", "start": [763, 1], "end": [767, 19], "kind": "commanddeclaration"}, {"full_name": "Int.floor_int_add", "code": "@[simp]\ntheorem floor_int_add (z : \u2124) (a : \u03b1) : \u230a\u2191z + a\u230b = z + \u230aa\u230b", "start": [770, 1], "end": [772, 48], "kind": "commanddeclaration"}, {"full_name": "Int.floor_add_nat", "code": "@[simp]\ntheorem floor_add_nat (a : \u03b1) (n : \u2115) : \u230aa + n\u230b = \u230aa\u230b + n", "start": [775, 1], "end": [776, 101], "kind": "commanddeclaration"}, {"full_name": "Int.floor_add_ofNat", "code": "@[simp]\ntheorem floor_add_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    \u230aa + OfNat.ofNat n\u230b = \u230aa\u230b + OfNat.ofNat n", "start": [779, 1], "end": [782, 20], "kind": "commanddeclaration"}, {"full_name": "Int.floor_nat_add", "code": "@[simp]\ntheorem floor_nat_add (n : \u2115) (a : \u03b1) : \u230a\u2191n + a\u230b = n + \u230aa\u230b", "start": [784, 1], "end": [786, 39], "kind": "commanddeclaration"}, {"full_name": "Int.floor_ofNat_add", "code": "@[simp]\ntheorem floor_ofNat_add (n : \u2115) [n.AtLeastTwo] (a : \u03b1) :\n    \u230aOfNat.ofNat n + a\u230b = OfNat.ofNat n + \u230aa\u230b", "start": [789, 1], "end": [792, 20], "kind": "commanddeclaration"}, {"full_name": "Int.floor_sub_int", "code": "@[simp]\ntheorem floor_sub_int (a : \u03b1) (z : \u2124) : \u230aa - z\u230b = \u230aa\u230b - z", "start": [794, 1], "end": [796, 70], "kind": "commanddeclaration"}, {"full_name": "Int.floor_sub_nat", "code": "@[simp]\ntheorem floor_sub_nat (a : \u03b1) (n : \u2115) : \u230aa - n\u230b = \u230aa\u230b - n", "start": [799, 1], "end": [800, 101], "kind": "commanddeclaration"}, {"full_name": "Int.floor_sub_one", "code": "@[simp] theorem floor_sub_one (a : \u03b1) : \u230aa - 1\u230b = \u230aa\u230b - 1", "start": [803, 1], "end": [803, 97], "kind": "commanddeclaration"}, {"full_name": "Int.floor_sub_ofNat", "code": "@[simp]\ntheorem floor_sub_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    \u230aa - OfNat.ofNat n\u230b = \u230aa\u230b - OfNat.ofNat n", "start": [805, 1], "end": [808, 20], "kind": "commanddeclaration"}, {"full_name": "Int.abs_sub_lt_one_of_floor_eq_floor", "code": "theorem abs_sub_lt_one_of_floor_eq_floor {\u03b1 : Type*} [LinearOrderedCommRing \u03b1] [FloorRing \u03b1]\n    {a b : \u03b1} (h : \u230aa\u230b = \u230ab\u230b) : |a - b| < 1", "start": [810, 1], "end": [817, 52], "kind": "commanddeclaration"}, {"full_name": "Int.floor_eq_iff", "code": "theorem floor_eq_iff : \u230aa\u230b = z \u2194 \u2191z \u2264 a \u2227 a < z + 1", "start": [820, 1], "end": [822, 14], "kind": "commanddeclaration"}, {"full_name": "Int.floor_eq_zero_iff", "code": "@[simp]\ntheorem floor_eq_zero_iff : \u230aa\u230b = 0 \u2194 a \u2208 Ico (0 : \u03b1) 1", "start": [825, 1], "end": [826, 82], "kind": "commanddeclaration"}, {"full_name": "Int.floor_eq_on_Ico", "code": "theorem floor_eq_on_Ico (n : \u2124) : \u2200 a \u2208 Set.Ico (n : \u03b1) (n + 1), \u230aa\u230b = n", "start": [829, 1], "end": [830, 28], "kind": "commanddeclaration"}, {"full_name": "Int.floor_eq_on_Ico'", "code": "theorem floor_eq_on_Ico' (n : \u2124) : \u2200 a \u2208 Set.Ico (n : \u03b1) (n + 1), (\u230aa\u230b : \u03b1) = n", "start": [833, 1], "end": [834, 40], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_floor_singleton", "code": "@[simp]\ntheorem preimage_floor_singleton (m : \u2124) : (floor : \u03b1 \u2192 \u2124) \u207b\u00b9' {m} = Ico (m : \u03b1) (m + 1)", "start": [838, 1], "end": [840, 28], "kind": "commanddeclaration"}, {"full_name": "Int.self_sub_floor", "code": "@[simp]\ntheorem self_sub_floor (a : \u03b1) : a - \u230aa\u230b = fract a", "start": [846, 1], "end": [848, 6], "kind": "commanddeclaration"}, {"full_name": "Int.floor_add_fract", "code": "@[simp]\ntheorem floor_add_fract (a : \u03b1) : (\u230aa\u230b : \u03b1) + fract a = a", "start": [851, 1], "end": [853, 28], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_floor", "code": "@[simp]\ntheorem fract_add_floor (a : \u03b1) : fract a + \u230aa\u230b = a", "start": [856, 1], "end": [858, 21], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_int", "code": "@[simp]\ntheorem fract_add_int (a : \u03b1) (m : \u2124) : fract (a + m) = fract a", "start": [861, 1], "end": [864, 7], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_nat", "code": "@[simp]\ntheorem fract_add_nat (a : \u03b1) (m : \u2115) : fract (a + m) = fract a", "start": [867, 1], "end": [870, 7], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_one", "code": "@[simp]\ntheorem fract_add_one (a : \u03b1) : fract (a + 1) = fract a", "start": [873, 1], "end": [874, 95], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_ofNat", "code": "@[simp]\ntheorem fract_add_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] : fract (a + OfNat.ofNat n) = fract a", "start": [876, 1], "end": [878, 20], "kind": "commanddeclaration"}, {"full_name": "Int.fract_int_add", "code": "@[simp]\ntheorem fract_int_add (m : \u2124) (a : \u03b1) : fract (\u2191m + a) = fract a", "start": [880, 1], "end": [881, 100], "kind": "commanddeclaration"}, {"full_name": "Int.fract_nat_add", "code": "@[simp]\ntheorem fract_nat_add (n : \u2115) (a : \u03b1) : fract (\u2191n + a) = fract a", "start": [884, 1], "end": [885, 100], "kind": "commanddeclaration"}, {"full_name": "Int.fract_one_add", "code": "@[simp]\ntheorem fract_one_add (a : \u03b1) : fract (1 + a) = fract a", "start": [887, 1], "end": [888, 95], "kind": "commanddeclaration"}, {"full_name": "Int.fract_ofNat_add", "code": "@[simp]\ntheorem fract_ofNat_add (n : \u2115) [n.AtLeastTwo] (a : \u03b1) : fract (OfNat.ofNat n + a) = fract a", "start": [890, 1], "end": [892, 20], "kind": "commanddeclaration"}, {"full_name": "Int.fract_sub_int", "code": "@[simp]\ntheorem fract_sub_int (a : \u03b1) (m : \u2124) : fract (a - m) = fract a", "start": [894, 1], "end": [897, 7], "kind": "commanddeclaration"}, {"full_name": "Int.fract_sub_nat", "code": "@[simp]\ntheorem fract_sub_nat (a : \u03b1) (n : \u2115) : fract (a - n) = fract a", "start": [900, 1], "end": [903, 7], "kind": "commanddeclaration"}, {"full_name": "Int.fract_sub_one", "code": "@[simp]\ntheorem fract_sub_one (a : \u03b1) : fract (a - 1) = fract a", "start": [906, 1], "end": [907, 95], "kind": "commanddeclaration"}, {"full_name": "Int.fract_sub_ofNat", "code": "@[simp]\ntheorem fract_sub_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] : fract (a - OfNat.ofNat n) = fract a", "start": [909, 1], "end": [911, 20], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_le", "code": "theorem fract_add_le (a b : \u03b1) : fract (a + b) \u2264 fract a + fract b", "start": [916, 1], "end": [918, 25], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add_fract_le", "code": "theorem fract_add_fract_le (a b : \u03b1) : fract a + fract b \u2264 fract (a + b) + 1", "start": [921, 1], "end": [923, 40], "kind": "commanddeclaration"}, {"full_name": "Int.self_sub_fract", "code": "@[simp]\ntheorem self_sub_fract (a : \u03b1) : a - fract a = \u230aa\u230b", "start": [926, 1], "end": [928, 21], "kind": "commanddeclaration"}, {"full_name": "Int.fract_sub_self", "code": "@[simp]\ntheorem fract_sub_self (a : \u03b1) : fract a - a = -\u230aa\u230b", "start": [931, 1], "end": [933, 26], "kind": "commanddeclaration"}, {"full_name": "Int.fract_nonneg", "code": "@[simp]\ntheorem fract_nonneg (a : \u03b1) : 0 \u2264 fract a", "start": [936, 1], "end": [938, 29], "kind": "commanddeclaration"}, {"full_name": "Int.fract_pos", "code": "lemma fract_pos : 0 < fract a \u2194 a \u2260 \u230aa\u230b :=\n  (fract_nonneg a).lt_iff_ne.trans $ ne_comm.trans sub_ne_zero", "start": [941, 1], "end": [943, 63], "kind": "mathlibtacticlemma"}, {"full_name": "Int.fract_lt_one", "code": "theorem fract_lt_one (a : \u03b1) : fract a < 1", "start": [946, 1], "end": [947, 38], "kind": "commanddeclaration"}, {"full_name": "Int.fract_zero", "code": "@[simp]\ntheorem fract_zero : fract (0 : \u03b1) = 0", "start": [950, 1], "end": [951, 89], "kind": "commanddeclaration"}, {"full_name": "Int.fract_one", "code": "@[simp]\ntheorem fract_one : fract (1 : \u03b1) = 0", "start": [954, 1], "end": [955, 57], "kind": "commanddeclaration"}, {"full_name": "Int.abs_fract", "code": "theorem abs_fract : |fract a| = fract a", "start": [958, 1], "end": [959, 36], "kind": "commanddeclaration"}, {"full_name": "Int.abs_one_sub_fract", "code": "@[simp]\ntheorem abs_one_sub_fract : |1 - fract a| = 1 - fract a", "start": [962, 1], "end": [964, 56], "kind": "commanddeclaration"}, {"full_name": "Int.fract_intCast", "code": "@[simp]\ntheorem fract_intCast (z : \u2124) : fract (z : \u03b1) = 0", "start": [967, 1], "end": [971, 19], "kind": "commanddeclaration"}, {"full_name": "Int.fract_natCast", "code": "@[simp]\ntheorem fract_natCast (n : \u2115) : fract (n : \u03b1) = 0", "start": [974, 1], "end": [975, 69], "kind": "commanddeclaration"}, {"full_name": "Int.fract_ofNat", "code": "@[simp]\ntheorem fract_ofNat (n : \u2115) [n.AtLeastTwo] : fract (OfNat.ofNat n : \u03b1) = 0", "start": [978, 1], "end": [979, 94], "kind": "commanddeclaration"}, {"full_name": "Int.fract_floor", "code": "theorem fract_floor (a : \u03b1) : fract (\u230aa\u230b : \u03b1) = 0", "start": [983, 1], "end": [984, 18], "kind": "commanddeclaration"}, {"full_name": "Int.floor_fract", "code": "@[simp]\ntheorem floor_fract (a : \u03b1) : \u230afract a\u230b = 0", "start": [987, 1], "end": [989, 85], "kind": "commanddeclaration"}, {"full_name": "Int.fract_eq_iff", "code": "theorem fract_eq_iff {a b : \u03b1} : fract a = b \u2194 0 \u2264 b \u2227 b < 1 \u2227 \u2203 z : \u2124, a - b = z", "start": [992, 1], "end": [1000, 56], "kind": "commanddeclaration"}, {"full_name": "Int.fract_eq_fract", "code": "theorem fract_eq_fract {a b : \u03b1} : fract a = fract b \u2194 \u2203 z : \u2124, a - b = z", "start": [1003, 1], "end": [1009, 36], "kind": "commanddeclaration"}, {"full_name": "Int.fract_eq_self", "code": "@[simp]\ntheorem fract_eq_self {a : \u03b1} : fract a = a \u2194 0 \u2264 a \u2227 a < 1", "start": [1012, 1], "end": [1014, 74], "kind": "commanddeclaration"}, {"full_name": "Int.fract_fract", "code": "@[simp]\ntheorem fract_fract (a : \u03b1) : fract (fract a) = fract a", "start": [1017, 1], "end": [1019, 51], "kind": "commanddeclaration"}, {"full_name": "Int.fract_add", "code": "theorem fract_add (a b : \u03b1) : \u2203 z : \u2124, fract (a + b) - fract a - fract b = z", "start": [1022, 1], "end": [1026, 10], "kind": "commanddeclaration"}, {"full_name": "Int.fract_neg", "code": "theorem fract_neg {x : \u03b1} (hx : fract x \u2260 0) : fract (-x) = 1 - fract x", "start": [1029, 1], "end": [1037, 26], "kind": "commanddeclaration"}, {"full_name": "Int.fract_neg_eq_zero", "code": "@[simp]\ntheorem fract_neg_eq_zero {x : \u03b1} : fract (-x) = 0 \u2194 fract x = 0", "start": [1040, 1], "end": [1043, 60], "kind": "commanddeclaration"}, {"full_name": "Int.fract_mul_nat", "code": "theorem fract_mul_nat (a : \u03b1) (b : \u2115) : \u2203 z : \u2124, fract a * b - fract (a * b) = z", "start": [1046, 1], "end": [1054, 9], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_fract", "code": "theorem preimage_fract (s : Set \u03b1) :\n    fract \u207b\u00b9' s = \u22c3 m : \u2124, (fun x => x - (m:\u03b1)) \u207b\u00b9' (s \u2229 Ico (0 : \u03b1) 1)", "start": [1058, 1], "end": [1065, 12], "kind": "commanddeclaration"}, {"full_name": "Int.image_fract", "code": "theorem image_fract (s : Set \u03b1) : fract '' s = \u22c3 m : \u2124, (fun x : \u03b1 => x - m) '' s \u2229 Ico 0 1", "start": [1068, 1], "end": [1075, 24], "kind": "commanddeclaration"}, {"full_name": "Int.fract_div_mul_self_mem_Ico", "code": "theorem fract_div_mul_self_mem_Ico (a b : k) (ha : 0 < a) : fract (b / a) * a \u2208 Ico 0 a", "start": [1082, 1], "end": [1084, 58], "kind": "commanddeclaration"}, {"full_name": "Int.fract_div_mul_self_add_zsmul_eq", "code": "theorem fract_div_mul_self_add_zsmul_eq (a b : k) (ha : a \u2260 0) :\n    fract (b / a) * a + \u230ab / a\u230b \u2022 a = b", "start": [1087, 1], "end": [1089, 69], "kind": "commanddeclaration"}, {"full_name": "Int.sub_floor_div_mul_nonneg", "code": "theorem sub_floor_div_mul_nonneg (a : k) (hb : 0 < b) : 0 \u2264 a - \u230aa / b\u230b * b", "start": [1092, 1], "end": [1093, 54], "kind": "commanddeclaration"}, {"full_name": "Int.sub_floor_div_mul_lt", "code": "theorem sub_floor_div_mul_lt (a : k) (hb : 0 < b) : a - \u230aa / b\u230b * b < b", "start": [1096, 1], "end": [1100, 29], "kind": "commanddeclaration"}, {"full_name": "Int.fract_div_natCast_eq_div_natCast_mod", "code": "theorem fract_div_natCast_eq_div_natCast_mod {m n : \u2115} : fract ((m : k) / n) = \u2191(m % n) / n", "start": [1103, 1], "end": [1114, 45], "kind": "commanddeclaration"}, {"full_name": "Int.fract_div_intCast_eq_div_intCast_mod", "code": "theorem fract_div_intCast_eq_div_intCast_mod {m : \u2124} {n : \u2115} :\n    fract ((m : k) / n) = \u2191(m % n) / n", "start": [1118, 1], "end": [1149, 62], "kind": "commanddeclaration"}, {"full_name": "Int.gc_ceil_coe", "code": "theorem gc_ceil_coe : GaloisConnection ceil (Int.cast : \u2124 \u2192 \u03b1)", "start": [1158, 1], "end": [1159, 24], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_le", "code": "theorem ceil_le : \u2308a\u2309 \u2264 z \u2194 a \u2264 z", "start": [1162, 1], "end": [1163, 18], "kind": "commanddeclaration"}, {"full_name": "Int.floor_neg", "code": "theorem floor_neg : \u230a-a\u230b = -\u2308a\u2309", "start": [1166, 1], "end": [1167, 87], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_neg", "code": "theorem ceil_neg : \u2308-a\u2309 = -\u230aa\u230b", "start": [1170, 1], "end": [1171, 87], "kind": "commanddeclaration"}, {"full_name": "Int.lt_ceil", "code": "theorem lt_ceil : z < \u2308a\u2309 \u2194 (z : \u03b1) < a", "start": [1174, 1], "end": [1175, 33], "kind": "commanddeclaration"}, {"full_name": "Int.add_one_le_ceil_iff", "code": "@[simp]\ntheorem add_one_le_ceil_iff : z + 1 \u2264 \u2308a\u2309 \u2194 (z : \u03b1) < a", "start": [1178, 1], "end": [1179, 93], "kind": "commanddeclaration"}, {"full_name": "Int.one_le_ceil_iff", "code": "@[simp]\ntheorem one_le_ceil_iff : 1 \u2264 \u2308a\u2309 \u2194 0 < a", "start": [1182, 1], "end": [1184, 58], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_le_floor_add_one", "code": "theorem ceil_le_floor_add_one (a : \u03b1) : \u2308a\u2309 \u2264 \u230aa\u230b + 1", "start": [1187, 1], "end": [1189, 32], "kind": "commanddeclaration"}, {"full_name": "Int.le_ceil", "code": "theorem le_ceil (a : \u03b1) : a \u2264 \u2308a\u2309", "start": [1192, 1], "end": [1193, 23], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_intCast", "code": "@[simp]\ntheorem ceil_intCast (z : \u2124) : \u2308(z : \u03b1)\u2309 = z", "start": [1196, 1], "end": [1198, 60], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_natCast", "code": "@[simp]\ntheorem ceil_natCast (n : \u2115) : \u2308(n : \u03b1)\u2309 = n", "start": [1201, 1], "end": [1203, 70], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_ofNat", "code": "@[simp]\ntheorem ceil_ofNat (n : \u2115) [n.AtLeastTwo] : \u2308(OfNat.ofNat n : \u03b1)\u2309 = n", "start": [1206, 1], "end": [1207, 88], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_mono", "code": "theorem ceil_mono : Monotone (ceil : \u03b1 \u2192 \u2124)", "start": [1209, 1], "end": [1210, 25], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_int", "code": "@[simp]\ntheorem ceil_add_int (a : \u03b1) (z : \u2124) : \u2308a + z\u2309 = \u2308a\u2309 + z", "start": [1213, 1], "end": [1215, 78], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_nat", "code": "@[simp]\ntheorem ceil_add_nat (a : \u03b1) (n : \u2115) : \u2308a + n\u2309 = \u2308a\u2309 + n", "start": [1218, 1], "end": [1219, 99], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_one", "code": "@[simp]\ntheorem ceil_add_one (a : \u03b1) : \u2308a + 1\u2309 = \u2308a\u2309 + 1", "start": [1222, 1], "end": [1225, 41], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_ofNat", "code": "@[simp]\ntheorem ceil_add_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] : \u2308a + OfNat.ofNat n\u2309 = \u2308a\u2309 + OfNat.ofNat n", "start": [1228, 1], "end": [1230, 19], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_sub_int", "code": "@[simp]\ntheorem ceil_sub_int (a : \u03b1) (z : \u2124) : \u2308a - z\u2309 = \u2308a\u2309 - z", "start": [1232, 1], "end": [1234, 69], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_sub_nat", "code": "@[simp]\ntheorem ceil_sub_nat (a : \u03b1) (n : \u2115) : \u2308a - n\u2309 = \u2308a\u2309 - n", "start": [1237, 1], "end": [1240, 7], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_sub_one", "code": "@[simp]\ntheorem ceil_sub_one (a : \u03b1) : \u2308a - 1\u2309 = \u2308a\u2309 - 1", "start": [1243, 1], "end": [1245, 57], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_sub_ofNat", "code": "@[simp]\ntheorem ceil_sub_ofNat (a : \u03b1) (n : \u2115) [n.AtLeastTwo] : \u2308a - OfNat.ofNat n\u2309 = \u2308a\u2309 - OfNat.ofNat n", "start": [1248, 1], "end": [1250, 19], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_lt_add_one", "code": "theorem ceil_lt_add_one (a : \u03b1) : (\u2308a\u2309 : \u03b1) < a + 1", "start": [1252, 1], "end": [1254, 19], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_le", "code": "theorem ceil_add_le (a b : \u03b1) : \u2308a + b\u2309 \u2264 \u2308a\u2309 + \u2308b\u2309", "start": [1257, 1], "end": [1259, 43], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_add_ceil_le", "code": "theorem ceil_add_ceil_le (a b : \u03b1) : \u2308a\u2309 + \u2308b\u2309 \u2264 \u2308a + b\u2309 + 1", "start": [1262, 1], "end": [1266, 18], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_pos", "code": "@[simp]\ntheorem ceil_pos : 0 < \u2308a\u2309 \u2194 0 < a", "start": [1269, 1], "end": [1270, 65], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_zero", "code": "@[simp]\ntheorem ceil_zero : \u2308(0 : \u03b1)\u2309 = 0", "start": [1273, 1], "end": [1274, 71], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_one", "code": "@[simp]\ntheorem ceil_one : \u2308(1 : \u03b1)\u2309 = 1", "start": [1277, 1], "end": [1278, 69], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_nonneg", "code": "theorem ceil_nonneg (ha : 0 \u2264 a) : 0 \u2264 \u2308a\u2309", "start": [1281, 1], "end": [1281, 85], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_eq_iff", "code": "theorem ceil_eq_iff : \u2308a\u2309 = z \u2194 \u2191z - 1 < a \u2227 a \u2264 z", "start": [1284, 1], "end": [1286, 14], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_eq_zero_iff", "code": "@[simp]\ntheorem ceil_eq_zero_iff : \u2308a\u2309 = 0 \u2194 a \u2208 Ioc (-1 : \u03b1) 0", "start": [1289, 1], "end": [1290, 81], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_eq_on_Ioc", "code": "theorem ceil_eq_on_Ioc (z : \u2124) : \u2200 a \u2208 Set.Ioc (z - 1 : \u03b1) z, \u2308a\u2309 = z", "start": [1293, 1], "end": [1294, 27], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_eq_on_Ioc'", "code": "theorem ceil_eq_on_Ioc' (z : \u2124) : \u2200 a \u2208 Set.Ioc (z - 1 : \u03b1) z, (\u2308a\u2309 : \u03b1) = z", "start": [1297, 1], "end": [1298, 39], "kind": "commanddeclaration"}, {"full_name": "Int.floor_le_ceil", "code": "theorem floor_le_ceil (a : \u03b1) : \u230aa\u230b \u2264 \u2308a\u2309", "start": [1301, 1], "end": [1302, 47], "kind": "commanddeclaration"}, {"full_name": "Int.floor_lt_ceil_of_lt", "code": "theorem floor_lt_ceil_of_lt {a b : \u03b1} (h : a < b) : \u230aa\u230b < \u2308b\u2309", "start": [1305, 1], "end": [1306, 64], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_ceil_singleton", "code": "@[simp]\ntheorem preimage_ceil_singleton (m : \u2124) : (ceil : \u03b1 \u2192 \u2124) \u207b\u00b9' {m} = Ioc ((m : \u03b1) - 1) m", "start": [1310, 1], "end": [1312, 27], "kind": "commanddeclaration"}, {"full_name": "Int.fract_eq_zero_or_add_one_sub_ceil", "code": "theorem fract_eq_zero_or_add_one_sub_ceil (a : \u03b1) : fract a = 0 \u2228 fract a = a + 1 - (\u2308a\u2309 : \u03b1)", "start": [1315, 1], "end": [1326, 42], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_eq_add_one_sub_fract", "code": "theorem ceil_eq_add_one_sub_fract (ha : fract a \u2260 0) : (\u2308a\u2309 : \u03b1) = a + 1 - fract a", "start": [1329, 1], "end": [1331, 7], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_sub_self_eq", "code": "theorem ceil_sub_self_eq (ha : fract a \u2260 0) : (\u2308a\u2309 : \u03b1) - a = 1 - fract a", "start": [1334, 1], "end": [1336, 7], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Ioo", "code": "@[simp]\ntheorem preimage_Ioo {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Ioo a b = Set.Ioo \u230aa\u230b \u2308b\u2309", "start": [1343, 1], "end": [1346, 27], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Ico", "code": "@[simp]\ntheorem preimage_Ico {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309 \u2308b\u2309", "start": [1350, 1], "end": [1353, 26], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Ioc", "code": "@[simp]\ntheorem preimage_Ioc {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Ioc a b = Set.Ioc \u230aa\u230b \u230ab\u230b", "start": [1357, 1], "end": [1360, 28], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Icc", "code": "@[simp]\ntheorem preimage_Icc {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309 \u230ab\u230b", "start": [1364, 1], "end": [1367, 27], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Ioi", "code": "@[simp]\ntheorem preimage_Ioi : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Ioi a = Set.Ioi \u230aa\u230b", "start": [1371, 1], "end": [1374, 18], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Ici", "code": "@[simp]\ntheorem preimage_Ici : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Ici a = Set.Ici \u2308a\u2309", "start": [1378, 1], "end": [1381, 17], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Iio", "code": "@[simp]\ntheorem preimage_Iio : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Iio a = Set.Iio \u2308a\u2309", "start": [1385, 1], "end": [1388, 17], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_Iic", "code": "@[simp]\ntheorem preimage_Iic : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Iic a = Set.Iic \u230aa\u230b", "start": [1392, 1], "end": [1395, 18], "kind": "commanddeclaration"}, {"full_name": "round", "code": "def round (x : \u03b1) : \u2124 :=\n  if 2 * fract x < 1 then \u230ax\u230b else \u2308x\u2309", "start": [1411, 1], "end": [1413, 39], "kind": "commanddeclaration"}, {"full_name": "round_zero", "code": "@[simp]\ntheorem round_zero : round (0 : \u03b1) = 0", "start": [1416, 1], "end": [1417, 58], "kind": "commanddeclaration"}, {"full_name": "round_one", "code": "@[simp]\ntheorem round_one : round (1 : \u03b1) = 1", "start": [1420, 1], "end": [1421, 57], "kind": "commanddeclaration"}, {"full_name": "round_natCast", "code": "@[simp]\ntheorem round_natCast (n : \u2115) : round (n : \u03b1) = n", "start": [1424, 1], "end": [1425, 69], "kind": "commanddeclaration"}, {"full_name": "round_ofNat", "code": "@[simp]\ntheorem round_ofNat (n : \u2115) [n.AtLeastTwo] : round (OfNat.ofNat n : \u03b1) = n", "start": [1428, 1], "end": [1429, 94], "kind": "commanddeclaration"}, {"full_name": "round_intCast", "code": "@[simp]\ntheorem round_intCast (n : \u2124) : round (n : \u03b1) = n", "start": [1431, 1], "end": [1432, 69], "kind": "commanddeclaration"}, {"full_name": "round_add_int", "code": "@[simp]\ntheorem round_add_int (x : \u03b1) (y : \u2124) : round (x + y) = round x + y", "start": [1435, 1], "end": [1437, 100], "kind": "commanddeclaration"}, {"full_name": "round_add_one", "code": "@[simp]\ntheorem round_add_one (a : \u03b1) : round (a + 1) = round a + 1", "start": [1440, 1], "end": [1443, 36], "kind": "commanddeclaration"}, {"full_name": "round_sub_int", "code": "@[simp]\ntheorem round_sub_int (x : \u03b1) (y : \u2124) : round (x - y) = round x - y", "start": [1446, 1], "end": [1450, 37], "kind": "commanddeclaration"}, {"full_name": "round_sub_one", "code": "@[simp]\ntheorem round_sub_one (a : \u03b1) : round (a - 1) = round a - 1", "start": [1453, 1], "end": [1456, 36], "kind": "commanddeclaration"}, {"full_name": "round_add_nat", "code": "@[simp]\ntheorem round_add_nat (x : \u03b1) (y : \u2115) : round (x + y) = round x + y", "start": [1459, 1], "end": [1461, 35], "kind": "commanddeclaration"}, {"full_name": "round_add_ofNat", "code": "@[simp]\ntheorem round_add_ofNat (x : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    round (x + OfNat.ofNat n) = round x + OfNat.ofNat n", "start": [1464, 1], "end": [1467, 20], "kind": "commanddeclaration"}, {"full_name": "round_sub_nat", "code": "@[simp]\ntheorem round_sub_nat (x : \u03b1) (y : \u2115) : round (x - y) = round x - y", "start": [1469, 1], "end": [1471, 35], "kind": "commanddeclaration"}, {"full_name": "round_sub_ofNat", "code": "@[simp]\ntheorem round_sub_ofNat (x : \u03b1) (n : \u2115) [n.AtLeastTwo] :\n    round (x - OfNat.ofNat n) = round x - OfNat.ofNat n", "start": [1474, 1], "end": [1477, 20], "kind": "commanddeclaration"}, {"full_name": "round_int_add", "code": "@[simp]\ntheorem round_int_add (x : \u03b1) (y : \u2124) : round ((y : \u03b1) + x) = y + round x", "start": [1479, 1], "end": [1481, 41], "kind": "commanddeclaration"}, {"full_name": "round_nat_add", "code": "@[simp]\ntheorem round_nat_add (x : \u03b1) (y : \u2115) : round ((y : \u03b1) + x) = y + round x", "start": [1484, 1], "end": [1486, 41], "kind": "commanddeclaration"}, {"full_name": "round_ofNat_add", "code": "@[simp]\ntheorem round_ofNat_add (n : \u2115) [n.AtLeastTwo] (x : \u03b1) :\n    round (OfNat.ofNat n + x) = OfNat.ofNat n + round x", "start": [1489, 1], "end": [1492, 20], "kind": "commanddeclaration"}, {"full_name": "abs_sub_round_eq_min", "code": "theorem abs_sub_round_eq_min (x : \u03b1) : |x - round x| = min (fract x) (1 - fract x)", "start": [1494, 1], "end": [1502, 25], "kind": "commanddeclaration"}, {"full_name": "round_le", "code": "theorem round_le (x : \u03b1) (z : \u2124) : |x - round x| \u2264 |x - z|", "start": [1505, 1], "end": [1515, 38], "kind": "commanddeclaration"}, {"full_name": "round_eq", "code": "theorem round_eq (x : \u03b1) : round x = \u230ax + 1 / 2\u230b", "start": [1524, 1], "end": [1543, 32], "kind": "commanddeclaration"}, {"full_name": "round_two_inv", "code": "@[simp]\ntheorem round_two_inv : round (2\u207b\u00b9 : \u03b1) = 1", "start": [1546, 1], "end": [1548, 58], "kind": "commanddeclaration"}, {"full_name": "round_neg_two_inv", "code": "@[simp]\ntheorem round_neg_two_inv : round (-2\u207b\u00b9 : \u03b1) = 0", "start": [1551, 1], "end": [1553, 60], "kind": "commanddeclaration"}, {"full_name": "round_eq_zero_iff", "code": "@[simp]\ntheorem round_eq_zero_iff {x : \u03b1} : round x = 0 \u2194 x \u2208 Ico (-(1 / 2)) ((1 : \u03b1) / 2)", "start": [1556, 1], "end": [1559, 11], "kind": "commanddeclaration"}, {"full_name": "abs_sub_round", "code": "theorem abs_sub_round (x : \u03b1) : |x - round x| \u2264 1 / 2", "start": [1562, 1], "end": [1566, 27], "kind": "commanddeclaration"}, {"full_name": "abs_sub_round_div_natCast_eq", "code": "theorem abs_sub_round_div_natCast_eq {m n : \u2115} :\n    |(m : \u03b1) / n - round ((m : \u03b1) / n)| = \u2191(min (m % n) (n - m % n)) / n", "start": [1569, 1], "end": [1576, 100], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_congr", "code": "theorem floor_congr (h : \u2200 n : \u2115, (n : \u03b1) \u2264 a \u2194 (n : \u03b2) \u2264 b) : \u230aa\u230b\u208a = \u230ab\u230b\u208a", "start": [1591, 1], "end": [1595, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_congr", "code": "theorem ceil_congr (h : \u2200 n : \u2115, a \u2264 n \u2194 b \u2264 n) : \u2308a\u2309\u208a = \u2308b\u2309\u208a", "start": [1598, 1], "end": [1599, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.map_floor", "code": "theorem map_floor (f : F) (hf : StrictMono f) (a : \u03b1) : \u230af a\u230b\u208a = \u230aa\u230b\u208a", "start": [1602, 1], "end": [1603, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.map_ceil", "code": "theorem map_ceil (f : F) (hf : StrictMono f) (a : \u03b1) : \u2308f a\u2309\u208a = \u2308a\u2309\u208a", "start": [1606, 1], "end": [1607, 60], "kind": "commanddeclaration"}, {"full_name": "Int.floor_congr", "code": "theorem floor_congr (h : \u2200 n : \u2124, (n : \u03b1) \u2264 a \u2194 (n : \u03b2) \u2264 b) : \u230aa\u230b = \u230ab\u230b", "start": [1620, 1], "end": [1621, 88], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_congr", "code": "theorem ceil_congr (h : \u2200 n : \u2124, a \u2264 n \u2194 b \u2264 n) : \u2308a\u2309 = \u2308b\u2309", "start": [1624, 1], "end": [1625, 84], "kind": "commanddeclaration"}, {"full_name": "Int.map_floor", "code": "theorem map_floor (f : F) (hf : StrictMono f) (a : \u03b1) : \u230af a\u230b = \u230aa\u230b", "start": [1628, 1], "end": [1629, 61], "kind": "commanddeclaration"}, {"full_name": "Int.map_ceil", "code": "theorem map_ceil (f : F) (hf : StrictMono f) (a : \u03b1) : \u2308f a\u2309 = \u2308a\u2309", "start": [1632, 1], "end": [1633, 60], "kind": "commanddeclaration"}, {"full_name": "Int.map_fract", "code": "theorem map_fract (f : F) (hf : StrictMono f) (a : \u03b1) : fract (f a) = f (fract a)", "start": [1636, 1], "end": [1637, 56], "kind": "commanddeclaration"}, {"full_name": "Int.map_round", "code": "theorem map_round (f : F) (hf : StrictMono f) (a : \u03b1) : round (f a) = round a", "start": [1650, 1], "end": [1652, 70], "kind": "commanddeclaration"}, {"full_name": "FloorRing.toFloorSemiring", "code": "instance (priority := 100) FloorRing.toFloorSemiring : FloorSemiring \u03b1 where\n  floor a := \u230aa\u230b.toNat\n  ceil a := \u2308a\u2309.toNat\n  floor_of_neg {a} ha := Int.toNat_of_nonpos (Int.floor_nonpos ha.le)\n  gc_floor {a n} ha := by rw [Int.le_toNat (Int.floor_nonneg.2 ha), Int.le_floor, Int.cast_ofNat]\n  gc_ceil a n := by rw [Int.toNat_le, Int.ceil_le, Int.cast_ofNat]", "start": [1668, 1], "end": [1673, 67], "kind": "commanddeclaration"}, {"full_name": "Int.floor_toNat", "code": "theorem Int.floor_toNat (a : \u03b1) : \u230aa\u230b.toNat = \u230aa\u230b\u208a", "start": [1676, 1], "end": [1677, 6], "kind": "commanddeclaration"}, {"full_name": "Int.ceil_toNat", "code": "theorem Int.ceil_toNat (a : \u03b1) : \u2308a\u2309.toNat = \u2308a\u2309\u208a", "start": [1680, 1], "end": [1681, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.floor_int", "code": "@[simp]\ntheorem Nat.floor_int : (Nat.floor : \u2124 \u2192 \u2115) = Int.toNat", "start": [1684, 1], "end": [1686, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.ceil_int", "code": "@[simp]\ntheorem Nat.ceil_int : (Nat.ceil : \u2124 \u2192 \u2115) = Int.toNat", "start": [1689, 1], "end": [1691, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_floor_eq_int_floor", "code": "theorem Nat.cast_floor_eq_int_floor (ha : 0 \u2264 a) : (\u230aa\u230b\u208a : \u2124) = \u230aa\u230b", "start": [1696, 1], "end": [1697, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_floor_eq_cast_int_floor", "code": "theorem Nat.cast_floor_eq_cast_int_floor (ha : 0 \u2264 a) : (\u230aa\u230b\u208a : \u03b1) = \u230aa\u230b", "start": [1700, 1], "end": [1701, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ceil_eq_int_ceil", "code": "theorem Nat.cast_ceil_eq_int_ceil (ha : 0 \u2264 a) : (\u2308a\u2309\u208a : \u2124) = \u2308a\u2309", "start": [1704, 1], "end": [1705, 66], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_ceil_eq_cast_int_ceil", "code": "theorem Nat.cast_ceil_eq_cast_int_ceil (ha : 0 \u2264 a) : (\u2308a\u2309\u208a : \u03b1) = \u2308a\u2309", "start": [1708, 1], "end": [1709, 54], "kind": "commanddeclaration"}, {"full_name": "subsingleton_floorRing", "code": "theorem subsingleton_floorRing {\u03b1} [LinearOrderedRing \u03b1] : Subsingleton (FloorRing \u03b1)", "start": [1714, 1], "end": [1720, 28], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.int_floor_nonneg", "code": "private theorem int_floor_nonneg [LinearOrderedRing \u03b1] [FloorRing \u03b1] {a : \u03b1} (ha : 0 \u2264 a) :\n    0 \u2264 \u230aa\u230b", "start": [1726, 1], "end": [1728, 24], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.int_floor_nonneg_of_pos", "code": "private theorem int_floor_nonneg_of_pos [LinearOrderedRing \u03b1] [FloorRing \u03b1] {a : \u03b1}\n    (ha : 0 < a) :\n    0 \u2264 \u230aa\u230b", "start": [1730, 1], "end": [1733, 25], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalIntFloor", "code": "@[positivity \u230a _ \u230b]\ndef evalIntFloor : PositivityExt where eval {_u _\u03b1} _z\u03b1 _p\u03b1 (e : Q(\u2124)) := do\n  let ~q(@Int.floor $\u03b1' $i $j $a) := e | throwError \"failed to match on Int.floor application\"\n  match \u2190 core q(inferInstance) q(inferInstance) a with\n  | .positive pa =>\n      letI ret : Q(0 \u2264 $e) := q(int_floor_nonneg_of_pos (\u03b1 := $\u03b1') $pa)\n      pure (.nonnegative ret)\n  | .nonnegative pa =>\n      letI ret : Q(0 \u2264 $e) := q(int_floor_nonneg (\u03b1 := $\u03b1') $pa)\n      pure (.nonnegative ret)\n  | _ => pure .none", "start": [1735, 1], "end": [1746, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.nat_ceil_pos", "code": "private theorem nat_ceil_pos [LinearOrderedSemiring \u03b1] [FloorSemiring \u03b1] {a : \u03b1} :\n    0 < a \u2192 0 < \u2308a\u2309\u208a", "start": [1748, 1], "end": [1750, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNatCeil", "code": "@[positivity \u2308 _ \u2309\u208a]\ndef evalNatCeil : PositivityExt where eval {_u _\u03b1} _z\u03b1 _p\u03b1 (e : Q(\u2115)) := do\n  let ~q(@Nat.ceil $\u03b1' $i $j $a) := e | throwError \"failed to match on Nat.ceil application\"\n  let _i : Q(LinearOrderedSemiring $\u03b1') \u2190 synthInstanceQ (u := u_1) _\n  assertInstancesCommute\n  match \u2190 core q(inferInstance) q(inferInstance) a with\n  | .positive pa =>\n    letI ret : Q(0 < $e) := q(nat_ceil_pos (\u03b1 := $\u03b1') $pa)\n    pure (.positive ret)\n  | _ => pure .none", "start": [1752, 1], "end": [1762, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.int_ceil_pos", "code": "private theorem int_ceil_pos [LinearOrderedRing \u03b1] [FloorRing \u03b1] {a : \u03b1} : 0 < a \u2192 0 < \u2308a\u2309", "start": [1764, 1], "end": [1765, 17], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalIntCeil", "code": "@[positivity \u2308 _ \u2309]\ndef evalIntCeil : PositivityExt where eval {_u _\u03b1} _z\u03b1 _p\u03b1 (e : Q(\u2124)) := do\n  let ~q(@Int.ceil $\u03b1' $i $j $a) := e | throwError \"failed to match on Int.ceil application\"\n  match \u2190 core q(inferInstance) q(inferInstance) a with\n  | .positive pa =>\n      letI ret : Q(0 < $e) := q(int_ceil_pos (\u03b1 := $\u03b1') $pa)\n      pure (.positive ret)\n  | .nonnegative pa =>\n      letI ret : Q(0 \u2264 $e) := q(Int.ceil_nonneg (\u03b1 := $\u03b1') $pa)\n      pure (.nonnegative ret)\n  | _ => pure .none", "start": [1767, 1], "end": [1778, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/EuclideanDomain/Instances.lean", "imports": ["Mathlib/Data/Int/Basic.lean", "Mathlib/Data/Int/Order/Basic.lean", "Mathlib/Algebra/EuclideanDomain/Defs.lean", "Mathlib/Algebra/Order/Ring/Lemmas.lean", "Mathlib/Init/Data/Int/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Field/Defs.lean", "Mathlib/Data/Nat/Order/Basic.lean", "Mathlib/Algebra/GroupWithZero/Units/Lemmas.lean"], "premises": [{"full_name": "Int.euclideanDomain", "code": "instance Int.euclideanDomain : EuclideanDomain \u2124 :=\n  { inferInstanceAs (CommRing Int), inferInstanceAs (Nontrivial Int) with\n    quotient := (\u00b7 / \u00b7), quotient_zero := Int.ediv_zero, remainder := (\u00b7 % \u00b7),\n    quotient_mul_add_remainder_eq := Int.ediv_add_emod,\n    r := fun a b => a.natAbs < b.natAbs,\n    r_wellFounded := (measure natAbs).wf\n    remainder_lt := fun a b b0 => Int.ofNat_lt.1 <| by\n      rw [Int.natAbs_of_nonneg (Int.emod_nonneg _ b0), \u2190 Int.abs_eq_natAbs]\n      exact Int.emod_lt _ b0\n    mul_left_not_lt := fun a b b0 =>\n      not_lt_of_ge <| by\n        rw [\u2190 mul_one a.natAbs, Int.natAbs_mul]\n        rw [\u2190Int.natAbs_pos] at b0\n        exact Nat.mul_le_mul_of_nonneg_left b0 }", "start": [23, 1], "end": [36, 49], "kind": "commanddeclaration"}, {"full_name": "Field.toEuclideanDomain", "code": "instance (priority := 100) Field.toEuclideanDomain {K : Type*} [Field K] : EuclideanDomain K :=\n{ toCommRing := Field.toCommRing\n  quotient := (\u00b7 / \u00b7), remainder := fun a b => a - a * b / b, quotient_zero := div_zero,\n  quotient_mul_add_remainder_eq := fun a b => by\n    by_cases h : b = 0 <;> simp [h, mul_div_cancel']\n  r := fun a b => a = 0 \u2227 b \u2260 0,\n  r_wellFounded :=\n    WellFounded.intro fun a =>\n      (Acc.intro _) fun b \u27e8hb, _\u27e9 => (Acc.intro _) fun c \u27e8_, hnb\u27e9 => False.elim <| hnb hb,\n  remainder_lt := fun a b hnb => by simp [hnb],\n  mul_left_not_lt := fun a b hnb \u27e8hab, hna\u27e9 => Or.casesOn (mul_eq_zero.1 hab) hna hnb }", "start": [39, 1], "end": [49, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/GCongr.lean", "imports": ["Mathlib/Algebra/Order/Field/Power.lean", "Mathlib/Tactic/Positivity.lean", "Mathlib/Tactic/GCongr/Core.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.div_le_div", "code": "protected theorem Nat.div_le_div {a b c d : \u2115} (h1 : a \u2264 b) (h2 : d \u2264 c) (h3 : d \u2260 0) :\n    a / c \u2264 b / d", "start": [75, 1], "end": [78, 64], "kind": "commanddeclaration"}, {"full_name": "zpow_lt_of_lt", "code": "theorem zpow_lt_of_lt [LinearOrderedSemifield \u03b1] {a : \u03b1} {m n : \u2124} (hx : 1 < a) (h : m < n) :\n    a ^ m < a ^ n", "start": [106, 1], "end": [108, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.cast_le_cast", "code": "@[gcongr]\ntheorem Nat.cast_le_cast [OrderedSemiring \u03b1] [CharZero \u03b1] {x y : \u2115} (h : x \u2264 y) : (x:\u03b1) \u2264 y", "start": [116, 1], "end": [118, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Bracket.lean", "imports": ["Mathlib/Mathport/Rename.lean", "Mathlib/Tactic/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Bracket", "code": "class Bracket (L M : Type*) where\n  \n  bracket : L \u2192 M \u2192 M", "start": [27, 1], "end": [38, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/ZMod/Defs.lean", "imports": ["Mathlib/Data/Nat/ModEq.lean", "Mathlib/Algebra/NeZero.lean", "Mathlib/Data/Fintype/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Fin.instCommSemigroup", "code": "instance instCommSemigroup (n : \u2115) : CommSemigroup (Fin n) :=\n  { inferInstanceAs (Mul (Fin n)) with\n    mul_assoc := fun \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 \u27e8c, hc\u27e9 =>\n      Fin.eq_of_veq <|\n        calc\n          a * b % n * c \u2261 a * b * c [MOD n] := (Nat.mod_modEq _ _).mul_right _\n          _ \u2261 a * (b * c) [MOD n] := by rw [mul_assoc]\n          _ \u2261 a * (b * c % n) [MOD n] := (Nat.mod_modEq _ _).symm.mul_left _\n    mul_comm := Fin.mul_comm }", "start": [45, 1], "end": [54, 31], "kind": "commanddeclaration"}, {"full_name": "Fin.left_distrib_aux", "code": "private theorem left_distrib_aux (n : \u2115) : \u2200 a b c : Fin n, a * (b + c) = a * b + a * c", "start": [57, 1], "end": [63, 97], "kind": "commanddeclaration"}, {"full_name": "Fin.instDistrib", "code": "instance instDistrib (n : \u2115) : Distrib (Fin n) :=\n  { Fin.addCommSemigroup n, Fin.instCommSemigroup n with\n    left_distrib := left_distrib_aux n\n    right_distrib := fun a b c => by\n      rw [mul_comm, left_distrib_aux, mul_comm _ b, mul_comm] }", "start": [65, 1], "end": [70, 64], "kind": "commanddeclaration"}, {"full_name": "Fin.instCommRing", "code": "instance instCommRing (n : \u2115) [NeZero n] : CommRing (Fin n) :=\n  { Fin.instAddMonoidWithOne n, Fin.addCommGroup n, Fin.instCommSemigroup n, Fin.instDistrib n with\n    one_mul := Fin.one_mul'\n    mul_one := Fin.mul_one',\n    zero_mul := Fin.zero_mul'\n    mul_zero := Fin.mul_zero' }", "start": [73, 1], "end": [81, 32], "kind": "commanddeclaration"}, {"full_name": "Fin.instHasDistribNeg", "code": "instance instHasDistribNeg (n : \u2115) : HasDistribNeg (Fin n) :=\n  { toInvolutiveNeg := Fin.instInvolutiveNeg n\n    mul_neg := Nat.casesOn n finZeroElim fun _i => mul_neg\n    neg_mul := Nat.casesOn n finZeroElim fun _i => neg_mul }", "start": [84, 1], "end": [88, 61], "kind": "commanddeclaration"}, {"full_name": "ZMod", "code": "def ZMod : \u2115 \u2192 Type\n  | 0 => \u2124\n  | n + 1 => Fin (n + 1)", "start": [93, 1], "end": [96, 25], "kind": "commanddeclaration"}, {"full_name": "ZMod.decidableEq", "code": "instance ZMod.decidableEq : \u2200 n : \u2115, DecidableEq (ZMod n)\n  | 0 => inferInstanceAs (DecidableEq \u2124)\n  | n + 1 => inferInstanceAs (DecidableEq (Fin (n + 1)))", "start": [99, 1], "end": [101, 57], "kind": "commanddeclaration"}, {"full_name": "ZMod.repr", "code": "instance ZMod.repr : \u2200 n : \u2115, Repr (ZMod n)\n  | 0 => by dsimp [ZMod]; infer_instance\n  | n + 1 => by dsimp [ZMod]; infer_instance", "start": [104, 1], "end": [106, 45], "kind": "commanddeclaration"}, {"full_name": "ZMod.fintype", "code": "instance fintype : \u2200 (n : \u2115) [NeZero n], Fintype (ZMod n)\n  | 0, h => (h.ne rfl).elim\n  | n + 1, _ => Fin.fintype (n + 1)", "start": [111, 1], "end": [113, 36], "kind": "commanddeclaration"}, {"full_name": "ZMod.infinite", "code": "instance infinite : Infinite (ZMod 0) :=\n  Int.infinite", "start": [116, 1], "end": [117, 15], "kind": "commanddeclaration"}, {"full_name": "ZMod.card", "code": "@[simp]\ntheorem card (n : \u2115) [Fintype (ZMod n)] : Fintype.card (ZMod n) = n", "start": [120, 1], "end": [124, 55], "kind": "commanddeclaration"}, {"full_name": "ZMod.commRing", "code": "instance commRing (n : \u2115) : CommRing (ZMod n) where\n  add := Nat.casesOn n (@Add.add Int _) fun n => @Add.add (Fin n.succ) _\n  add_assoc := Nat.casesOn n (@add_assoc Int _) fun n => @add_assoc (Fin n.succ) _\n  zero := Nat.casesOn n (0 : Int) fun n => (0 : Fin n.succ)\n  zero_add := Nat.casesOn n (@zero_add Int _) fun n => @zero_add (Fin n.succ) _\n  add_zero := Nat.casesOn n (@add_zero Int _) fun n => @add_zero (Fin n.succ) _\n  neg := Nat.casesOn n (@Neg.neg Int _) fun n => @Neg.neg (Fin n.succ) _\n  sub := Nat.casesOn n (@Sub.sub Int _) fun n => @Sub.sub (Fin n.succ) _\n  sub_eq_add_neg := Nat.casesOn n (@sub_eq_add_neg Int _) fun n => @sub_eq_add_neg (Fin n.succ) _\n  zsmul := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).zsmul fun n => (inferInstanceAs (CommRing (Fin n.succ))).zsmul\n  zsmul_zero' := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).zsmul_zero'\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).zsmul_zero'\n  zsmul_succ' := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).zsmul_succ'\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).zsmul_succ'\n  zsmul_neg' := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).zsmul_neg'\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).zsmul_neg'\n  nsmul := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).nsmul fun n => (inferInstanceAs (CommRing (Fin n.succ))).nsmul\n  nsmul_zero := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).nsmul_zero\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).nsmul_zero\n  nsmul_succ := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).nsmul_succ\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).nsmul_succ\n  add_left_neg := Nat.casesOn n (@add_left_neg Int _) fun n => @add_left_neg (Fin n.succ) _\n  add_comm := Nat.casesOn n (@add_comm Int _) fun n => @add_comm (Fin n.succ) _\n  mul := Nat.casesOn n (@Mul.mul Int _) fun n => @Mul.mul (Fin n.succ) _\n  mul_assoc := Nat.casesOn n (@mul_assoc Int _) fun n => @mul_assoc (Fin n.succ) _\n  one := Nat.casesOn n (1 : Int) fun n => (1 : Fin n.succ)\n  one_mul := Nat.casesOn n (@one_mul Int _) fun n => @one_mul (Fin n.succ) _\n  mul_one := Nat.casesOn n (@mul_one Int _) fun n => @mul_one (Fin n.succ) _\n  natCast := Nat.casesOn n ((\u2191) : \u2115 \u2192 \u2124) fun n => ((\u2191) : \u2115 \u2192 Fin n.succ)\n  natCast_zero := Nat.casesOn n (@Nat.cast_zero Int _) fun n => @Nat.cast_zero (Fin n.succ) _\n  natCast_succ := Nat.casesOn n (@Nat.cast_succ Int _) fun n => @Nat.cast_succ (Fin n.succ) _\n  intCast := Nat.casesOn n ((\u2191) : \u2124 \u2192 \u2124) fun n => ((\u2191) : \u2124 \u2192 Fin n.succ)\n  intCast_ofNat := Nat.casesOn n (@Int.cast_ofNat Int _) fun n => @Int.cast_ofNat (Fin n.succ) _\n  intCast_negSucc :=\n    Nat.casesOn n (@Int.cast_negSucc Int _) fun n => @Int.cast_negSucc (Fin n.succ) _\n  left_distrib := Nat.casesOn n (@left_distrib Int _ _ _) fun n => @left_distrib (Fin n.succ) _ _ _\n  right_distrib :=\n    Nat.casesOn n (@right_distrib Int _ _ _) fun n => @right_distrib (Fin n.succ) _ _ _\n  mul_comm := Nat.casesOn n (@mul_comm Int _) fun n => @mul_comm (Fin n.succ) _\n  zero_mul := Nat.casesOn n (@zero_mul Int _) fun n => @zero_mul (Fin n.succ) _\n  mul_zero := Nat.casesOn n (@mul_zero Int _) fun n => @mul_zero (Fin n.succ) _\n  npow := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).npow fun n => (inferInstanceAs (CommRing (Fin n.succ))).npow\n  npow_zero := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).npow_zero\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).npow_zero\n  npow_succ := Nat.casesOn n\n    (inferInstanceAs (CommRing \u2124)).npow_succ\n    fun n => (inferInstanceAs (CommRing (Fin n.succ))).npow_succ", "start": [130, 1], "end": [189, 65], "kind": "commanddeclaration"}, {"full_name": "ZMod.inhabited", "code": "instance inhabited (n : \u2115) : Inhabited (ZMod n) :=\n  \u27e80\u27e9", "start": [192, 1], "end": [193, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Homeomorph.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Topology/Support.lean", "Mathlib/Topology/DenseEmbedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Homeomorph", "code": "structure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X \u2243 Y where\n  \n  continuous_toFun : Continuous toFun := by continuity\n  \n  continuous_invFun : Continuous invFun := by continuity", "start": [38, 1], "end": [44, 57], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toEquiv_injective", "code": "theorem toEquiv_injective : Function.Injective (toEquiv : X \u2243\u209c Y \u2192 X \u2243 Y)", "start": [55, 1], "end": [56, 37], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.homeomorph_mk_coe", "code": "@[simp] theorem homeomorph_mk_coe (a : X \u2243 Y) (b c) : (Homeomorph.mk a b c : X \u2192 Y) = a", "start": [68, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm", "code": "protected def symm (h : X \u2243\u209c Y) : Y \u2243\u209c X where\n  continuous_toFun := h.continuous_invFun\n  continuous_invFun := h.continuous_toFun\n  toEquiv := h.toEquiv.symm", "start": [72, 1], "end": [76, 28], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_symm", "code": "@[simp] theorem symm_symm (h : X \u2243\u209c Y) : h.symm.symm = h", "start": [79, 1], "end": [79, 64], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.Simps.symm_apply", "code": "def Simps.symm_apply (h : X \u2243\u209c Y) : Y \u2192 X :=\n  h.symm", "start": [82, 1], "end": [84, 9], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (h : X \u2243\u209c Y) : \u21d1h.toEquiv = h", "start": [89, 1], "end": [91, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_symm_toEquiv", "code": "@[simp]\ntheorem coe_symm_toEquiv (h : X \u2243\u209c Y) : \u21d1h.toEquiv.symm = h.symm", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.ext", "code": "@[ext]\ntheorem ext {h h' : X \u2243\u209c Y} (H : \u2200 x, h x = h' x) : h = h'", "start": [99, 1], "end": [101, 20], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.refl", "code": "@[simps! (config := { fullyApplied := false }) apply]\nprotected def refl (X : Type*) [TopologicalSpace X] : X \u2243\u209c X where\n  continuous_toFun := continuous_id\n  continuous_invFun := continuous_id\n  toEquiv := Equiv.refl X", "start": [104, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.trans", "code": "protected def trans (h\u2081 : X \u2243\u209c Y) (h\u2082 : Y \u2243\u209c Z) : X \u2243\u209c Z where\n  continuous_toFun := h\u2082.continuous_toFun.comp h\u2081.continuous_toFun\n  continuous_invFun := h\u2081.continuous_invFun.comp h\u2082.continuous_invFun\n  toEquiv := Equiv.trans h\u2081.toEquiv h\u2082.toEquiv", "start": [112, 1], "end": [116, 47], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.trans_apply", "code": "@[simp]\ntheorem trans_apply (h\u2081 : X \u2243\u209c Y) (h\u2082 : Y \u2243\u209c Z) (x : X) : h\u2081.trans h\u2082 x = h\u2082 (h\u2081 x)", "start": [119, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_trans_apply", "code": "@[simp]\ntheorem symm_trans_apply (f : X \u2243\u209c Y) (g : Y \u2243\u209c Z) (z : Z) :\n    (f.trans g).symm z = f.symm (g.symm z)", "start": [124, 1], "end": [126, 50], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.homeomorph_mk_coe_symm", "code": "@[simp]\ntheorem homeomorph_mk_coe_symm (a : X \u2243 Y) (b c) :\n    ((Homeomorph.mk a b c).symm : Y \u2192 X) = a.symm", "start": [128, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.refl_symm", "code": "@[simp]\ntheorem refl_symm : (Homeomorph.refl X).symm = Homeomorph.refl X", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.continuous", "code": "@[continuity]\nprotected theorem continuous (h : X \u2243\u209c Y) : Continuous h", "start": [139, 1], "end": [141, 21], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.continuous_symm", "code": "@[continuity]\nprotected theorem continuous_symm (h : X \u2243\u209c Y) : Continuous h.symm", "start": [145, 1], "end": [147, 22], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (h : X \u2243\u209c Y) (y : Y) : h (h.symm y) = y", "start": [150, 1], "end": [152, 31], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (h : X \u2243\u209c Y) (x : X) : h.symm (h x) = x", "start": [155, 1], "end": [157, 31], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.self_trans_symm", "code": "@[simp]\ntheorem self_trans_symm (h : X \u2243\u209c Y) : h.trans h.symm = Homeomorph.refl X", "start": [160, 1], "end": [163, 25], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_trans_self", "code": "@[simp]\ntheorem symm_trans_self (h : X \u2243\u209c Y) : h.symm.trans h = Homeomorph.refl Y", "start": [166, 1], "end": [169, 25], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.bijective", "code": "protected theorem bijective (h : X \u2243\u209c Y) : Function.Bijective h", "start": [172, 1], "end": [173, 22], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.injective", "code": "protected theorem injective (h : X \u2243\u209c Y) : Function.Injective h", "start": [176, 1], "end": [177, 22], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.surjective", "code": "protected theorem surjective (h : X \u2243\u209c Y) : Function.Surjective h", "start": [180, 1], "end": [181, 23], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.changeInv", "code": "def changeInv (f : X \u2243\u209c Y) (g : Y \u2192 X) (hg : Function.RightInverse g f) : X \u2243\u209c Y :=\n  haveI : g = f.symm := (f.left_inv.eq_rightInverse hg).symm\n  { toFun := f\n    invFun := g\n    left_inv := by convert f.left_inv\n    right_inv := by convert f.right_inv using 1\n    continuous_toFun := f.continuous\n    continuous_invFun := by convert f.symm.continuous }", "start": [184, 1], "end": [192, 56], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_comp_self", "code": "@[simp]\ntheorem symm_comp_self (h : X \u2243\u209c Y) : h.symm \u2218 h = id", "start": [195, 1], "end": [197, 28], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.self_comp_symm", "code": "@[simp]\ntheorem self_comp_symm (h : X \u2243\u209c Y) : h \u2218 h.symm = id", "start": [200, 1], "end": [202, 28], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.range_coe", "code": "@[simp]\ntheorem range_coe (h : X \u2243\u209c Y) : range h = univ", "start": [205, 1], "end": [207, 24], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image_symm", "code": "theorem image_symm (h : X \u2243\u209c Y) : image h.symm = preimage h", "start": [210, 1], "end": [211, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.preimage_symm", "code": "theorem preimage_symm (h : X \u2243\u209c Y) : preimage h.symm = image h", "start": [214, 1], "end": [215, 44], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image_preimage", "code": "@[simp]\ntheorem image_preimage (h : X \u2243\u209c Y) (s : Set Y) : h '' (h \u207b\u00b9' s) = s", "start": [218, 1], "end": [220, 29], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.preimage_image", "code": "@[simp]\ntheorem preimage_image (h : X \u2243\u209c Y) (s : Set X) : h \u207b\u00b9' (h '' s) = s", "start": [223, 1], "end": [225, 29], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.inducing", "code": "protected theorem inducing (h : X \u2243\u209c Y) : Inducing h", "start": [228, 1], "end": [230, 44], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.induced_eq", "code": "theorem induced_eq (h : X \u2243\u209c Y) : TopologicalSpace.induced h \u2039_\u203a = \u2039_\u203a", "start": [233, 1], "end": [234, 20], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.quotientMap", "code": "protected theorem quotientMap (h : X \u2243\u209c Y) : QuotientMap h", "start": [237, 1], "end": [239, 47], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coinduced_eq", "code": "theorem coinduced_eq (h : X \u2243\u209c Y) : TopologicalSpace.coinduced h \u2039_\u203a = \u2039_\u203a", "start": [242, 1], "end": [243, 23], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.embedding", "code": "protected theorem embedding (h : X \u2243\u209c Y) : Embedding h", "start": [246, 1], "end": [247, 28], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.ofEmbedding", "code": "noncomputable def ofEmbedding (f : X \u2192 Y) (hf : Embedding f) : X \u2243\u209c Set.range f where\n  continuous_toFun := hf.continuous.subtype_mk _\n  continuous_invFun := hf.continuous_iff.2 <| by simp [continuous_subtype_val]\n  toEquiv := Equiv.ofInjective f hf.inj", "start": [250, 1], "end": [254, 40], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.secondCountableTopology", "code": "protected theorem secondCountableTopology [TopologicalSpace.SecondCountableTopology Y]\n    (h : X \u2243\u209c Y) : TopologicalSpace.SecondCountableTopology X", "start": [257, 1], "end": [259, 37], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isCompact_image", "code": "@[simp]\ntheorem isCompact_image {s : Set X} (h : X \u2243\u209c Y) : IsCompact (h '' s) \u2194 IsCompact s", "start": [262, 1], "end": [265, 33], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isCompact_preimage", "code": "@[simp]\ntheorem isCompact_preimage {s : Set Y} (h : X \u2243\u209c Y) : IsCompact (h \u207b\u00b9' s) \u2194 IsCompact s", "start": [268, 1], "end": [271, 50], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isSigmaCompact_image", "code": "@[simp]\ntheorem isSigmaCompact_image {s : Set X} (h : X \u2243\u209c Y) :\n    IsSigmaCompact (h '' s) \u2194 IsSigmaCompact s", "start": [274, 1], "end": [278, 38], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isSigmaCompact_preimage", "code": "@[simp]\ntheorem isSigmaCompact_preimage {s : Set Y} (h : X \u2243\u209c Y) :\n    IsSigmaCompact (h \u207b\u00b9' s) \u2194 IsSigmaCompact s", "start": [280, 1], "end": [284, 55], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isPreconnected_image", "code": "@[simp]\ntheorem isPreconnected_image {s : Set X} (h : X \u2243\u209c Y) :\n    IsPreconnected (h '' s) \u2194 IsPreconnected s", "start": [286, 1], "end": [291, 51], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isPreconnected_preimage", "code": "@[simp]\ntheorem isPreconnected_preimage {s : Set Y} (h : X \u2243\u209c Y) :\n    IsPreconnected (h \u207b\u00b9' s) \u2194 IsPreconnected s", "start": [293, 1], "end": [296, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isConnected_image", "code": "@[simp]\ntheorem isConnected_image {s : Set X} (h : X \u2243\u209c Y) :\n    IsConnected (h '' s) \u2194 IsConnected s", "start": [298, 1], "end": [301, 48], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isConnected_preimage", "code": "@[simp]\ntheorem isConnected_preimage {s : Set Y} (h : X \u2243\u209c Y) :\n    IsConnected (h \u207b\u00b9' s) \u2194 IsConnected s", "start": [303, 1], "end": [306, 39], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comap_cocompact", "code": "@[simp]\ntheorem comap_cocompact (h : X \u2243\u209c Y) : comap h (cocompact Y) = cocompact X", "start": [308, 1], "end": [312, 55], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.map_cocompact", "code": "@[simp]\ntheorem map_cocompact (h : X \u2243\u209c Y) : map h (cocompact X) = cocompact Y", "start": [315, 1], "end": [317, 65], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.compactSpace", "code": "protected theorem compactSpace [CompactSpace X] (h : X \u2243\u209c Y) : CompactSpace Y where", "start": [320, 1], "end": [321, 63], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.t0Space", "code": "protected theorem t0Space [T0Space X] (h : X \u2243\u209c Y) : T0Space Y", "start": [324, 1], "end": [325, 27], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.t1Space", "code": "protected theorem t1Space [T1Space X] (h : X \u2243\u209c Y) : T1Space Y", "start": [328, 1], "end": [329, 27], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.t2Space", "code": "protected theorem t2Space [T2Space X] (h : X \u2243\u209c Y) : T2Space Y", "start": [332, 1], "end": [333, 27], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.t3Space", "code": "protected theorem t3Space [T3Space X] (h : X \u2243\u209c Y) : T3Space Y", "start": [336, 1], "end": [337, 27], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.denseEmbedding", "code": "protected theorem denseEmbedding (h : X \u2243\u209c Y) : DenseEmbedding h", "start": [340, 1], "end": [341, 56], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isOpen_preimage", "code": "@[simp]\ntheorem isOpen_preimage (h : X \u2243\u209c Y) {s : Set Y} : IsOpen (h \u207b\u00b9' s) \u2194 IsOpen s", "start": [344, 1], "end": [346, 32], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isOpen_image", "code": "@[simp]\ntheorem isOpen_image (h : X \u2243\u209c Y) {s : Set X} : IsOpen (h '' s) \u2194 IsOpen s", "start": [349, 1], "end": [351, 40], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isOpenMap", "code": "protected theorem isOpenMap (h : X \u2243\u209c Y) : IsOpenMap h", "start": [354, 1], "end": [354, 84], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isClosed_preimage", "code": "@[simp]\ntheorem isClosed_preimage (h : X \u2243\u209c Y) {s : Set Y} : IsClosed (h \u207b\u00b9' s) \u2194 IsClosed s", "start": [357, 1], "end": [359, 68], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isClosed_image", "code": "@[simp]\ntheorem isClosed_image (h : X \u2243\u209c Y) {s : Set X} : IsClosed (h '' s) \u2194 IsClosed s", "start": [362, 1], "end": [364, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.isClosedMap", "code": "protected theorem isClosedMap (h : X \u2243\u209c Y) : IsClosedMap h", "start": [367, 1], "end": [367, 90], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.openEmbedding", "code": "protected theorem openEmbedding (h : X \u2243\u209c Y) : OpenEmbedding h", "start": [370, 1], "end": [371, 58], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.closedEmbedding", "code": "protected theorem closedEmbedding (h : X \u2243\u209c Y) : ClosedEmbedding h", "start": [374, 1], "end": [375, 64], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.normalSpace", "code": "protected theorem normalSpace [NormalSpace X] (h : X \u2243\u209c Y) : NormalSpace Y", "start": [378, 1], "end": [379, 37], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.t4Space", "code": "protected theorem t4Space [T4Space X] (h : X \u2243\u209c Y) : T4Space Y", "start": [381, 1], "end": [382, 33], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.preimage_closure", "code": "theorem preimage_closure (h : X \u2243\u209c Y) (s : Set Y) : h \u207b\u00b9' closure s = closure (h \u207b\u00b9' s)", "start": [385, 1], "end": [386, 66], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image_closure", "code": "theorem image_closure (h : X \u2243\u209c Y) (s : Set X) : h '' closure s = closure (h '' s)", "start": [389, 1], "end": [390, 41], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.preimage_interior", "code": "theorem preimage_interior (h : X \u2243\u209c Y) (s : Set Y) : h \u207b\u00b9' interior s = interior (h \u207b\u00b9' s)", "start": [393, 1], "end": [394, 68], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image_interior", "code": "theorem image_interior (h : X \u2243\u209c Y) (s : Set X) : h '' interior s = interior (h '' s)", "start": [397, 1], "end": [398, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.preimage_frontier", "code": "theorem preimage_frontier (h : X \u2243\u209c Y) (s : Set Y) : h \u207b\u00b9' frontier s = frontier (h \u207b\u00b9' s)", "start": [401, 1], "end": [402, 68], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image_frontier", "code": "theorem image_frontier (h : X \u2243\u209c Y) (s : Set X) : h '' frontier s = frontier (h '' s)", "start": [405, 1], "end": [406, 42], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.comp_homeomorph", "code": "@[to_additive]\ntheorem _root_.HasCompactMulSupport.comp_homeomorph {M} [One M] {f : Y \u2192 M}\n    (hf : HasCompactMulSupport f) (\u03c6 : X \u2243\u209c Y) : HasCompactMulSupport (f \u2218 \u03c6)", "start": [409, 1], "end": [412, 44], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.map_nhds_eq", "code": "@[simp]\ntheorem map_nhds_eq (h : X \u2243\u209c Y) (x : X) : map h (\ud835\udcdd x) = \ud835\udcdd (h x)", "start": [416, 1], "end": [418, 42], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_map_nhds_eq", "code": "theorem symm_map_nhds_eq (h : X \u2243\u209c Y) (x : X) : map h.symm (\ud835\udcdd (h x)) = \ud835\udcdd x", "start": [421, 1], "end": [422, 46], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.nhds_eq_comap", "code": "theorem nhds_eq_comap (h : X \u2243\u209c Y) (x : X) : \ud835\udcdd x = comap h (\ud835\udcdd (h x))", "start": [425, 1], "end": [426, 29], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comap_nhds_eq", "code": "@[simp]\ntheorem comap_nhds_eq (h : X \u2243\u209c Y) (y : Y) : comap h (\ud835\udcdd y) = \ud835\udcdd (h.symm y)", "start": [429, 1], "end": [431, 43], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.locallyConnectedSpace", "code": "theorem locallyConnectedSpace [i : LocallyConnectedSpace Y] (h : X \u2243\u209c Y) :\n    LocallyConnectedSpace X", "start": [434, 1], "end": [443, 56], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.homeomorphOfContinuousOpen", "code": "def homeomorphOfContinuousOpen (e : X \u2243 Y) (h\u2081 : Continuous e) (h\u2082 : IsOpenMap e) : X \u2243\u209c Y where\n  continuous_toFun := h\u2081\n  continuous_invFun := by\n    rw [continuous_def]\n    intro s hs\n    convert \u2190 h\u2082 s hs using 1\n    apply e.image_eq_preimage\n  toEquiv := e", "start": [445, 1], "end": [453, 15], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuousOn_iff", "code": "@[simp]\ntheorem comp_continuousOn_iff (h : X \u2243\u209c Y) (f : Z \u2192 X) (s : Set Z) :\n    ContinuousOn (h \u2218 f) s \u2194 ContinuousOn f s", "start": [456, 1], "end": [459, 35], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuous_iff", "code": "@[simp]\ntheorem comp_continuous_iff (h : X \u2243\u209c Y) {f : Z \u2192 X} : Continuous (h \u2218 f) \u2194 Continuous f", "start": [462, 1], "end": [464, 33], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuous_iff'", "code": "@[simp]\ntheorem comp_continuous_iff' (h : X \u2243\u209c Y) {f : Y \u2192 Z} : Continuous (f \u2218 h) \u2194 Continuous f", "start": [467, 1], "end": [469, 36], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuousAt_iff", "code": "theorem comp_continuousAt_iff (h : X \u2243\u209c Y) (f : Z \u2192 X) (z : Z) :\n    ContinuousAt (h \u2218 f) z \u2194 ContinuousAt f z", "start": [472, 1], "end": [474, 35], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuousAt_iff'", "code": "theorem comp_continuousAt_iff' (h : X \u2243\u209c Y) (f : Y \u2192 Z) (x : X) :\n    ContinuousAt (f \u2218 h) x \u2194 ContinuousAt f (h x)", "start": [477, 1], "end": [479, 41], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_continuousWithinAt_iff", "code": "theorem comp_continuousWithinAt_iff (h : X \u2243\u209c Y) (f : Z \u2192 X) (s : Set Z) (z : Z) :\n    ContinuousWithinAt f s z \u2194 ContinuousWithinAt (h \u2218 f) s z", "start": [482, 1], "end": [484, 36], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_isOpenMap_iff", "code": "@[simp]\ntheorem comp_isOpenMap_iff (h : X \u2243\u209c Y) {f : Z \u2192 X} : IsOpenMap (h \u2218 f) \u2194 IsOpenMap f", "start": [487, 1], "end": [492, 33], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.comp_isOpenMap_iff'", "code": "@[simp]\ntheorem comp_isOpenMap_iff' (h : X \u2243\u209c Y) {f : Y \u2192 Z} : IsOpenMap (f \u2218 h) \u2194 IsOpenMap f", "start": [495, 1], "end": [500, 33], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.setCongr", "code": "def setCongr {s t : Set X} (h : s = t) : s \u2243\u209c t where\n  continuous_toFun := continuous_inclusion h.subset\n  continuous_invFun := continuous_inclusion h.symm.subset\n  toEquiv := Equiv.setCongr h", "start": [503, 1], "end": [507, 30], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.sumCongr", "code": "def sumCongr (h\u2081 : X \u2243\u209c X') (h\u2082 : Y \u2243\u209c Y') : Sum X Y \u2243\u209c Sum X' Y' where\n  continuous_toFun := h\u2081.continuous.sum_map h\u2082.continuous\n  continuous_invFun := h\u2081.symm.continuous.sum_map h\u2082.symm.continuous\n  toEquiv := h\u2081.toEquiv.sumCongr h\u2082.toEquiv", "start": [510, 1], "end": [514, 44], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodCongr", "code": "def prodCongr (h\u2081 : X \u2243\u209c X') (h\u2082 : Y \u2243\u209c Y') : X \u00d7 Y \u2243\u209c X' \u00d7 Y' where\n  continuous_toFun := h\u2081.continuous.prod_map h\u2082.continuous\n  continuous_invFun := h\u2081.symm.continuous.prod_map h\u2082.symm.continuous\n  toEquiv := h\u2081.toEquiv.prodCongr h\u2082.toEquiv", "start": [517, 1], "end": [521, 45], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodCongr_symm", "code": "@[simp]\ntheorem prodCongr_symm (h\u2081 : X \u2243\u209c X') (h\u2082 : Y \u2243\u209c Y') :\n    (h\u2081.prodCongr h\u2082).symm = h\u2081.symm.prodCongr h\u2082.symm", "start": [524, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_prodCongr", "code": "@[simp]\ntheorem coe_prodCongr (h\u2081 : X \u2243\u209c X') (h\u2082 : Y \u2243\u209c Y') : \u21d1(h\u2081.prodCongr h\u2082) = Prod.map h\u2081 h\u2082", "start": [530, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodComm", "code": "def prodComm : X \u00d7 Y \u2243\u209c Y \u00d7 X where\n  continuous_toFun := continuous_snd.prod_mk continuous_fst\n  continuous_invFun := continuous_snd.prod_mk continuous_fst\n  toEquiv := Equiv.prodComm X Y", "start": [539, 1], "end": [543, 32], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodComm_symm", "code": "@[simp]\ntheorem prodComm_symm : (prodComm X Y).symm = prodComm Y X", "start": [546, 1], "end": [548, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm : \u21d1(prodComm X Y) = Prod.swap", "start": [551, 1], "end": [553, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodAssoc", "code": "def prodAssoc : (X \u00d7 Y) \u00d7 Z \u2243\u209c X \u00d7 Y \u00d7 Z where\n  continuous_toFun := continuous_fst.fst.prod_mk (continuous_fst.snd.prod_mk continuous_snd)\n  continuous_invFun := (continuous_fst.prod_mk continuous_snd.fst).prod_mk continuous_snd.snd\n  toEquiv := Equiv.prodAssoc X Y Z", "start": [556, 1], "end": [560, 35], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodPUnit", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef prodPUnit : X \u00d7 PUnit \u2243\u209c X where\n  toEquiv := Equiv.prodPUnit X\n  continuous_toFun := continuous_fst\n  continuous_invFun := continuous_id.prod_mk continuous_const", "start": [563, 1], "end": [568, 62], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.punitProd", "code": "def punitProd : PUnit \u00d7 X \u2243\u209c X :=\n  (prodComm _ _).trans (prodPUnit _)", "start": [571, 1], "end": [573, 37], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_punitProd", "code": "@[simp] theorem coe_punitProd : \u21d1(punitProd X) = Prod.snd", "start": [576, 1], "end": [576, 65], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.homeomorphOfUnique", "code": "@[simps!]\ndef homeomorphOfUnique [Unique X] [Unique Y] : X \u2243\u209c Y :=\n  { Equiv.equivOfUnique X Y with\n    continuous_toFun := continuous_const\n    continuous_invFun := continuous_const }", "start": [579, 1], "end": [584, 44], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piCongrLeft", "code": "@[simps! apply toEquiv]\ndef piCongrLeft {\u03b9 \u03b9' : Type*} {Y : \u03b9' \u2192 Type*} [\u2200 j, TopologicalSpace (Y j)]\n    (e : \u03b9 \u2243 \u03b9') : (\u2200 i, Y (e i)) \u2243\u209c \u2200 j, Y j where\n  continuous_toFun := continuous_pi <| e.forall_congr_left.mp <| fun i \u21a6 by\n    simpa only [Equiv.toFun_as_coe_apply, Equiv.piCongrLeft_apply_apply] using continuous_apply i\n  continuous_invFun := Pi.continuous_precomp' e\n  toEquiv := Equiv.piCongrLeft _ e", "start": [589, 1], "end": [597, 35], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piCongrRight", "code": "@[simps! apply toEquiv]\ndef piCongrRight {\u03b9 : Type*} {Y\u2081 Y\u2082 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (Y\u2081 i)]\n    [\u2200 i, TopologicalSpace (Y\u2082 i)] (F : \u2200 i, Y\u2081 i \u2243\u209c Y\u2082 i) : (\u2200 i, Y\u2081 i) \u2243\u209c \u2200 i, Y\u2082 i where\n  continuous_toFun := Pi.continuous_postcomp' fun i \u21a6 (F i).continuous\n  continuous_invFun := Pi.continuous_postcomp' fun i \u21a6 (F i).symm.continuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv", "start": [599, 1], "end": [606, 55], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piCongrRight_symm", "code": "@[simp]\ntheorem piCongrRight_symm {\u03b9 : Type*} {Y\u2081 Y\u2082 : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (Y\u2081 i)]\n    [\u2200 i, TopologicalSpace (Y\u2082 i)] (F : \u2200 i, Y\u2081 i \u2243\u209c Y\u2082 i) :\n    (piCongrRight F).symm = piCongrRight fun i => (F i).symm", "start": [609, 1], "end": [613, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piCongr", "code": "@[simps! apply toEquiv]\ndef piCongr {\u03b9\u2081 \u03b9\u2082 : Type*} {Y\u2081 : \u03b9\u2081 \u2192 Type*} {Y\u2082 : \u03b9\u2082 \u2192 Type*}\n    [\u2200 i\u2081, TopologicalSpace (Y\u2081 i\u2081)] [\u2200 i\u2082, TopologicalSpace (Y\u2082 i\u2082)]\n    (e : \u03b9\u2081 \u2243 \u03b9\u2082) (F : \u2200 i\u2081, Y\u2081 i\u2081 \u2243\u209c Y\u2082 (e i\u2081)) : (\u2200 i\u2081, Y\u2081 i\u2081) \u2243\u209c \u2200 i\u2082, Y\u2082 i\u2082 :=\n  (Homeomorph.piCongrRight F).trans (Homeomorph.piCongrLeft e)", "start": [616, 1], "end": [623, 63], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.ulift", "code": "def ulift.{u, v} {X : Type u} [TopologicalSpace X] : ULift.{v, u} X \u2243\u209c X where\n  continuous_toFun := continuous_uLift_down\n  continuous_invFun := continuous_uLift_up\n  toEquiv := Equiv.ulift", "start": [626, 1], "end": [630, 25], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.sumProdDistrib", "code": "def sumProdDistrib : Sum X Y \u00d7 Z \u2243\u209c Sum (X \u00d7 Z) (Y \u00d7 Z) :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sumProdDistrib X Y Z).symm\n        ((continuous_inl.prod_map continuous_id).sum_elim\n          (continuous_inr.prod_map continuous_id)) <|\n      (isOpenMap_inl.prod IsOpenMap.id).sum_elim (isOpenMap_inr.prod IsOpenMap.id)", "start": [635, 1], "end": [641, 83], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.prodSumDistrib", "code": "def prodSumDistrib : X \u00d7 Sum Y Z \u2243\u209c Sum (X \u00d7 Y) (X \u00d7 Z) :=\n  (prodComm _ _).trans <| sumProdDistrib.trans <| sumCongr (prodComm _ _) (prodComm _ _)", "start": [644, 1], "end": [646, 89], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.sigmaProdDistrib", "code": "def sigmaProdDistrib : (\u03a3i, X i) \u00d7 Y \u2243\u209c \u03a3i, X i \u00d7 Y :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sigmaProdDistrib X Y).symm\n      (continuous_sigma fun _ => continuous_sigmaMk.fst'.prod_mk continuous_snd)\n      (isOpenMap_sigma.2 fun _ => isOpenMap_sigmaMk.prod IsOpenMap.id)", "start": [651, 1], "end": [656, 71], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.funUnique", "code": "@[simps! (config := { fullyApplied := false })]\ndef funUnique (\u03b9 X : Type*) [Unique \u03b9] [TopologicalSpace X] : (\u03b9 \u2192 X) \u2243\u209c X where\n  toEquiv := Equiv.funUnique \u03b9 X\n  continuous_toFun := continuous_apply _\n  continuous_invFun := continuous_pi fun _ => continuous_id", "start": [661, 1], "end": [666, 60], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piFinTwo", "code": "@[simps! (config := { fullyApplied := false })]\ndef piFinTwo.{u} (X : Fin 2 \u2192 Type u) [\u2200 i, TopologicalSpace (X i)] : (\u2200 i, X i) \u2243\u209c X 0 \u00d7 X 1 where\n  toEquiv := piFinTwoEquiv X\n  continuous_toFun := (continuous_apply 0).prod_mk (continuous_apply 1)\n  continuous_invFun := continuous_pi <| Fin.forall_fin_two.2 \u27e8continuous_fst, continuous_snd\u27e9", "start": [669, 1], "end": [674, 94], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.finTwoArrow", "code": "@[simps! (config := { fullyApplied := false })]\ndef finTwoArrow : (Fin 2 \u2192 X) \u2243\u209c X \u00d7 X :=\n  { piFinTwo fun _ => X with toEquiv := finTwoArrowEquiv X }", "start": [677, 1], "end": [680, 61], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.image", "code": "@[simps!]\ndef image (e : X \u2243\u209c Y) (s : Set X) : s \u2243\u209c e '' s where\n  continuous_toFun := e.continuous.continuousOn.restrict_mapsTo (mapsTo_image _ _)\n  continuous_invFun := (e.symm.continuous.comp continuous_subtype_val).codRestrict _\n  toEquiv := e.toEquiv.image s", "start": [683, 1], "end": [690, 31], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.Set.univ", "code": "@[simps! (config := { fullyApplied := false })]\ndef Set.univ (X : Type*) [TopologicalSpace X] : (univ : Set X) \u2243\u209c X where\n  toEquiv := Equiv.Set.univ X\n  continuous_toFun := continuous_subtype_val\n  continuous_invFun := continuous_id.subtype_mk _", "start": [693, 1], "end": [698, 50], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.Set.prod", "code": "@[simps!]\ndef Set.prod (s : Set X) (t : Set Y) : \u21a5(s \u00d7\u02e2 t) \u2243\u209c s \u00d7 t where\n  toEquiv := Equiv.Set.prod s t\n  continuous_toFun :=\n    (continuous_subtype_val.fst.subtype_mk _).prod_mk (continuous_subtype_val.snd.subtype_mk _)\n  continuous_invFun :=\n    (continuous_subtype_val.fst'.prod_mk continuous_subtype_val.snd').subtype_mk _", "start": [701, 1], "end": [708, 83], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piEquivPiSubtypeProd", "code": "@[simps!]\ndef piEquivPiSubtypeProd (p : \u03b9 \u2192 Prop) (Y : \u03b9 \u2192 Type*) [\u2200 i, TopologicalSpace (Y i)]\n    [DecidablePred p] : (\u2200 i, Y i) \u2243\u209c (\u2200 i : { x // p x }, Y i) \u00d7 \u2200 i : { x // \u00acp x }, Y i\n    where\n  toEquiv := Equiv.piEquivPiSubtypeProd p Y\n  continuous_toFun := by\n    apply Continuous.prod_mk <;> exact continuous_pi fun j => continuous_apply j.1\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piEquivPiSubtypeProd]; split_ifs\n      exacts [(continuous_apply _).comp continuous_fst, (continuous_apply _).comp continuous_snd]", "start": [715, 1], "end": [727, 98], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.piSplitAt", "code": "@[simps!]\ndef piSplitAt (Y : \u03b9 \u2192 Type*) [\u2200 j, TopologicalSpace (Y j)] :\n    (\u2200 j, Y j) \u2243\u209c Y i \u00d7 \u2200 j : { j // j \u2260 i }, Y j\n    where\n  toEquiv := Equiv.piSplitAt i Y\n  continuous_toFun := (continuous_apply i).prod_mk (continuous_pi fun j => continuous_apply j.1)\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piSplitAt]\n      split_ifs with h\n      subst h\n      exacts [continuous_fst, (continuous_apply _).comp continuous_snd]", "start": [732, 1], "end": [745, 72], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.funSplitAt", "code": "@[simps!]\ndef funSplitAt : (\u03b9 \u2192 Y) \u2243\u209c Y \u00d7 ({ j // j \u2260 i } \u2192 Y) :=\n  piSplitAt i _", "start": [750, 1], "end": [754, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.toHomeomorph", "code": "@[simps toEquiv]\ndef toHomeomorph (e : X \u2243 Y) (he : \u2200 s, IsOpen (e \u207b\u00b9' s) \u2194 IsOpen s) : X \u2243\u209c Y where\n  toEquiv := e\n  continuous_toFun := continuous_def.2 \u03bb s \u21a6 (he _).2\n  continuous_invFun := continuous_def.2 \u03bb s \u21a6 by convert (he _).1; simp", "start": [764, 1], "end": [769, 72], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_toHomeomorph", "code": "@[simp] lemma coe_toHomeomorph (e : X \u2243 Y) (he) : \u21d1(e.toHomeomorph he) = e := rfl", "start": [771, 1], "end": [771, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.toHomeomorph_apply", "code": "lemma toHomeomorph_apply (e : X \u2243 Y) (he) (x : X) : e.toHomeomorph he x = e x := rfl", "start": [772, 1], "end": [772, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.toHomeomorph_refl", "code": "@[simp] lemma toHomeomorph_refl :\n  (Equiv.refl X).toHomeomorph (\u03bb _s \u21a6 Iff.rfl) = Homeomorph.refl _ := rfl", "start": [774, 1], "end": [775, 74], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.toHomeomorph_symm", "code": "@[simp] lemma toHomeomorph_symm (e : X \u2243 Y) (he) :\n  (e.toHomeomorph he).symm = e.symm.toHomeomorph \u03bb s \u21a6 by convert (he _).symm; simp := rfl", "start": [777, 1], "end": [778, 91], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.toHomeomorph_trans", "code": "lemma toHomeomorph_trans (e : X \u2243 Y) (f : Y \u2243 Z) (he hf) :\n    (e.trans f).toHomeomorph (\u03bb _s \u21a6 (he _).trans (hf _)) =\n    (e.toHomeomorph he).trans (f.toHomeomorph hf) := rfl", "start": [780, 1], "end": [782, 57], "kind": "mathlibtacticlemma"}, {"full_name": "Equiv.toHomeomorphOfInducing", "code": "@[simps toEquiv] def toHomeomorphOfInducing (f : X \u2243 Y) (hf : Inducing f) : X \u2243\u209c Y :=\n  { f with\n    continuous_toFun := hf.continuous\n    continuous_invFun := hf.continuous_iff.2 <| by simpa using continuous_id }", "start": [784, 1], "end": [789, 79], "kind": "commanddeclaration"}, {"full_name": "Continuous.continuous_symm_of_equiv_compact_to_t2", "code": "theorem continuous_symm_of_equiv_compact_to_t2 [CompactSpace X] [T2Space Y] {f : X \u2243 Y}\n    (hf : Continuous f) : Continuous f.symm", "start": [798, 1], "end": [803, 39], "kind": "commanddeclaration"}, {"full_name": "Continuous.homeoOfEquivCompactToT2", "code": "@[simps toEquiv] def homeoOfEquivCompactToT2 [CompactSpace X] [T2Space Y] {f : X \u2243 Y} (hf : Continuous f) : X \u2243\u209c Y :=\n  { f with\n    continuous_toFun := hf\n    continuous_invFun := hf.continuous_symm_of_equiv_compact_to_t2 }", "start": [806, 1], "end": [814, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/Basic.lean", "imports": ["Mathlib/CategoryTheory/Category/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor", "code": "structure Functor (C : Type u\u2081) [Category.{v\u2081} C] (D : Type u\u2082) [Category.{v\u2082} D]\n    extends Prefunctor C D : Type max v\u2081 v\u2082 u\u2081 u\u2082 where\n  \n  map_id : \u2200 X : C, map (\ud835\udfd9 X) = \ud835\udfd9 (obj X) := by aesop_cat\n  \n  map_comp : \u2200 {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z), map (f \u226b g) = map f \u226b map g := by aesop_cat", "start": [29, 1], "end": [43, 96], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_comp_assoc", "code": "lemma Functor.map_comp_assoc {C : Type u\u2081} [Category C] {D : Type u\u2082} [Category D] (F : C \u2964 D)\n    {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) {W : D} (h : F.obj Z \u27f6 W) :\n    (F.map (f \u226b g)) \u226b h = F.map f \u226b F.map g \u226b h := by\n  rw [F.map_comp, Category.assoc]", "start": [64, 1], "end": [67, 34], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Functor.id", "code": "protected def id : C \u2964 C where\n  obj X := X\n  map f := f", "start": [79, 1], "end": [82, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.id_obj", "code": "@[simp]\ntheorem id_obj (X : C) : (\ud835\udfed C).obj X = X", "start": [93, 1], "end": [94, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.id_map", "code": "@[simp]\ntheorem id_map {X Y : C} (f : X \u27f6 Y) : (\ud835\udfed C).map f = f", "start": [97, 1], "end": [98, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.comp", "code": "@[simps obj]\ndef comp (F : C \u2964 D) (G : D \u2964 E) : C \u2964 E where\n  obj X := G.obj (F.obj X)\n  map f := G.map (F.map f)\n  map_comp := by intros; dsimp; rw [F.map_comp, G.map_comp]", "start": [108, 1], "end": [114, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.comp_map", "code": "@[simp]\ntheorem comp_map (F : C \u2964 D) (G : D \u2964 E) {X Y : C} (f : X \u27f6 Y) :\n    (F \u22d9 G).map f = G.map (F.map f)", "start": [121, 1], "end": [123, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.comp_id", "code": "protected theorem comp_id (F : C \u2964 D) : F \u22d9 \ud835\udfed D = F", "start": [129, 1], "end": [129, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.id_comp", "code": "protected theorem id_comp (F : C \u2964 D) : \ud835\udfed C \u22d9 F = F", "start": [132, 1], "end": [132, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_dite", "code": "@[simp]\ntheorem map_dite (F : C \u2964 D) {X Y : C} {P : Prop} [Decidable P]\n    (f : P \u2192 (X \u27f6 Y)) (g : \u00acP \u2192 (X \u27f6 Y)) :\n    F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h)", "start": [135, 1], "end": [139, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toPrefunctor_comp", "code": "@[simp]\ntheorem toPrefunctor_comp (F : C \u2964 D) (G : D \u2964 E) :\n    F.toPrefunctor.comp G.toPrefunctor = (F \u22d9 G).toPrefunctor", "start": [145, 1], "end": [147, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Util/AddRelatedDecl.lean", "imports": ["lake-packages/lean4/src/lean/Lean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.addRelatedDecl", "code": "def addRelatedDecl (src : Name) (suffix : String) (ref : Syntax)\n    (attrs? : Option (Syntax.TSepArray `Lean.Parser.Term.attrInstance \",\"))\n    (construct : Expr \u2192 Expr \u2192 List Name \u2192 MetaM (Expr \u00d7 List Name)) :\n    MetaM Unit := do\n  let tgt := match src with\n    | Name.str n s => Name.mkStr n $ s ++ suffix\n    | x => x\n  addDeclarationRanges tgt {\n    range := \u2190 getDeclarationRange (\u2190 getRef)\n    selectionRange := \u2190 getDeclarationRange ref }\n  let info \u2190 getConstInfo src\n  let (newValue, newLevels) \u2190 construct info.type info.value! info.levelParams\n  let newValue \u2190 instantiateMVars newValue\n  let newType \u2190 instantiateMVars (\u2190 inferType newValue)\n  match info with\n  | ConstantInfo.thmInfo info =>\n    addAndCompile <| .thmDecl\n      { info with levelParams := newLevels, type := newType, name := tgt, value := newValue }\n  | ConstantInfo.defnInfo info =>\n    addAndCompile <| if \u2190 isProp newType then .thmDecl\n      { info with levelParams := newLevels, type := newType, name := tgt, value := newValue }\n      else .defnDecl\n      { info with levelParams := newLevels, type := newType, name := tgt, value := newValue }\n  | _ => throwError \"Constant {src} is not a theorem or definition.\"\n  if isProtected (\u2190 getEnv) src then\n    setEnv $ addProtected (\u2190 getEnv) tgt\n  let attrs := match attrs? with | some attrs => attrs | none => #[]\n  _ \u2190 Term.TermElabM.run' <| do\n    let attrs \u2190 elabAttrs attrs\n    Term.applyAttributes src attrs\n    Term.applyAttributes tgt attrs", "start": [17, 1], "end": [74, 35], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Opposite.lean", "imports": ["Mathlib/Algebra/Ring/Opposite.lean", "Mathlib/Algebra/Module/Opposites.lean", "Mathlib/Algebra/Algebra/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.MulOpposite.instAlgebra", "code": "instance MulOpposite.instAlgebra : Algebra R A\u1d50\u1d52\u1d56 where\n  toRingHom := (algebraMap R A).toOpposite fun x y => Algebra.commutes _ _\n  smul_def' c x := unop_injective <| by\n    simp only [unop_smul, RingHom.toOpposite_apply, Function.comp_apply, unop_mul, op_mul,\n      Algebra.smul_def, Algebra.commutes, op_unop, unop_op]\n  commutes' r := MulOpposite.rec' fun x => by\n    simp only [RingHom.toOpposite_apply, Function.comp_apply, \u2190 op_mul, Algebra.commutes]", "start": [40, 1], "end": [46, 90], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply (c : R) : algebraMap R A\u1d50\u1d52\u1d56 c = op (algebraMap R A c)", "start": [48, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.opOp", "code": "@[simps!]\ndef opOp : A \u2243\u2090[R] A\u1d50\u1d52\u1d56\u1d50\u1d52\u1d56 where\n  __ := RingEquiv.opOp A\n  commutes' _ := rfl", "start": [58, 1], "end": [62, 21], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_opOp", "code": "@[simp] theorem toRingEquiv_opOp : (opOp R A : A \u2243+* A\u1d50\u1d52\u1d56\u1d50\u1d52\u1d56) = RingEquiv.opOp A", "start": [64, 1], "end": [64, 88], "kind": "commanddeclaration"}, {"full_name": "AlgHom.fromOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef fromOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) : A\u1d50\u1d52\u1d56 \u2192\u2090[R] B :=\n  { f.toRingHom.fromOpposite hf with\n    toFun := f \u2218 unop\n    commutes' := fun r => f.commutes r }", "start": [70, 1], "end": [77, 41], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_fromOpposite", "code": "@[simp]\ntheorem toLinearMap_fromOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) :\n    (f.fromOpposite hf).toLinearMap = f.toLinearMap \u2218\u2097 (opLinearEquiv R (M := A)).symm", "start": [79, 1], "end": [82, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_fromOpposite", "code": "@[simp]\ntheorem toRingHom_fromOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) :\n    (f.fromOpposite hf : A\u1d50\u1d52\u1d56 \u2192+* B) = (f : A \u2192+* B).fromOpposite hf", "start": [84, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toOpposite", "code": "@[simps (config := { fullyApplied := false })]\ndef toOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) : A \u2192\u2090[R] B\u1d50\u1d52\u1d56 :=\n  { f.toRingHom.toOpposite hf with\n    toFun := op \u2218 f\n    commutes' := fun r => unop_injective <| f.commutes r }", "start": [89, 1], "end": [96, 59], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toLinearMap_toOpposite", "code": "@[simp]\ntheorem toLinearMap_toOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) :\n    (f.toOpposite hf).toLinearMap = (opLinearEquiv R : B \u2243\u2097[R] B\u1d50\u1d52\u1d56) \u2218\u2097 f.toLinearMap", "start": [98, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_toOpposite", "code": "@[simp]\ntheorem toRingHom_toOpposite (f : A \u2192\u2090[R] B) (hf : \u2200 x y, Commute (f x) (f y)) :\n    (f.toOpposite hf : A \u2192+* B\u1d50\u1d52\u1d56) = (f : A \u2192+* B).toOpposite hf", "start": [103, 1], "end": [106, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.op", "code": "@[simps!]\nprotected def op : (A \u2192\u2090[R] B) \u2243 (A\u1d50\u1d52\u1d56 \u2192\u2090[R] B\u1d50\u1d52\u1d56) where\n  toFun f := { RingHom.op f.toRingHom with commutes' := fun r => unop_injective <| f.commutes r }\n  invFun f := { RingHom.unop f.toRingHom with commutes' := fun r => op_injective <| f.commutes r }\n  left_inv _f := AlgHom.ext fun _a => rfl\n  right_inv _f := AlgHom.ext fun _a => rfl", "start": [108, 1], "end": [115, 43], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_op", "code": "theorem toRingHom_op (f : A \u2192\u2090[R] B) : f.op.toRingHom = RingHom.op f.toRingHom", "start": [117, 1], "end": [118, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.unop", "code": "abbrev unop : (A\u1d50\u1d52\u1d56 \u2192\u2090[R] B\u1d50\u1d52\u1d56) \u2243 (A \u2192\u2090[R] B) := AlgHom.op.symm", "start": [120, 1], "end": [121, 64], "kind": "commanddeclaration"}, {"full_name": "AlgHom.toRingHom_unop", "code": "theorem toRingHom_unop (f : A\u1d50\u1d52\u1d56 \u2192\u2090[R] B\u1d50\u1d52\u1d56) : f.unop.toRingHom = RingHom.unop f.toRingHom", "start": [123, 1], "end": [124, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.opComm", "code": "@[simps!]\ndef opComm : (A \u2192\u2090[R] B\u1d50\u1d52\u1d56) \u2243 (A\u1d50\u1d52\u1d56 \u2192\u2090[R] B) :=\n  AlgHom.op.trans <| AlgEquiv.refl.arrowCongr (AlgEquiv.opOp R B).symm", "start": [126, 1], "end": [129, 71], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.op", "code": "@[simps!]\ndef op : (A \u2243\u2090[R] B) \u2243 A\u1d50\u1d52\u1d56 \u2243\u2090[R] B\u1d50\u1d52\u1d56 where\n  toFun f :=\n    { RingEquiv.op f.toRingEquiv with\n      commutes' := fun r => MulOpposite.unop_injective <| f.commutes r }\n  invFun f :=\n    { RingEquiv.unop f.toRingEquiv with\n      commutes' := fun r => MulOpposite.op_injective <| f.commutes r }\n  left_inv _f := AlgEquiv.ext fun _a => rfl\n  right_inv _f := AlgEquiv.ext fun _a => rfl", "start": [135, 1], "end": [146, 45], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toAlgHom_op", "code": "theorem toAlgHom_op (f : A \u2243\u2090[R] B) :\n    (AlgEquiv.op f).toAlgHom = AlgHom.op f.toAlgHom", "start": [148, 1], "end": [150, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_op", "code": "theorem toRingEquiv_op (f : A \u2243\u2090[R] B) :\n    (AlgEquiv.op f).toRingEquiv = RingEquiv.op f.toRingEquiv", "start": [152, 1], "end": [154, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.unop", "code": "abbrev unop : (A\u1d50\u1d52\u1d56 \u2243\u2090[R] B\u1d50\u1d52\u1d56) \u2243 A \u2243\u2090[R] B := AlgEquiv.op.symm", "start": [156, 1], "end": [157, 64], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toAlgHom_unop", "code": "theorem toAlgHom_unop (f : A\u1d50\u1d52\u1d56 \u2243\u2090[R] B\u1d50\u1d52\u1d56) : f.unop.toAlgHom = AlgHom.unop f.toAlgHom", "start": [159, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_unop", "code": "theorem toRingEquiv_unop (f : A\u1d50\u1d52\u1d56 \u2243\u2090[R] B\u1d50\u1d52\u1d56) :\n    (AlgEquiv.unop f).toRingEquiv = RingEquiv.unop f.toRingEquiv", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.opComm", "code": "@[simps!]\ndef opComm : (A \u2243\u2090[R] B\u1d50\u1d52\u1d56) \u2243 (A\u1d50\u1d52\u1d56 \u2243\u2090[R] B) :=\n  AlgEquiv.op.trans <| AlgEquiv.refl.equivCongr (opOp R B).symm", "start": [166, 1], "end": [169, 64], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toOpposite", "code": "@[simps!]\ndef toOpposite : A \u2243\u2090[R] A\u1d50\u1d52\u1d56 where\n  __ := RingEquiv.toOpposite A\n  commutes' _r := rfl", "start": [180, 1], "end": [184, 22], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.toRingEquiv_toOpposite", "code": "@[simp] lemma toRingEquiv_toOpposite : (toOpposite R A : A \u2243+* A\u1d50\u1d52\u1d56) = RingEquiv.toOpposite A := rfl", "start": [186, 1], "end": [186, 101], "kind": "mathlibtacticlemma"}, {"full_name": "AlgEquiv.toLinearEquiv_toOpposite", "code": "@[simp] lemma toLinearEquiv_toOpposite : toLinearEquiv (toOpposite R A) = opLinearEquiv R := rfl", "start": [187, 1], "end": [187, 97], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Algebra/Pi.lean", "imports": ["Mathlib/Algebra/Algebra/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.algebra", "code": "instance algebra {r : CommSemiring R} [s : \u2200 i, Semiring (f i)] [\u2200 i, Algebra R (f i)] :\n    Algebra R (\u2200 i : I, f i) :=\n  { (Pi.ringHom fun i => algebraMap R (f i) : R \u2192+* \u2200 i : I, f i) with\n    commutes' := fun a f => by ext; simp [Algebra.commutes]\n    smul_def' := fun a f => by ext; simp [Algebra.smul_def] }", "start": [40, 1], "end": [44, 62], "kind": "commanddeclaration"}, {"full_name": "Pi.algebraMap_def", "code": "theorem algebraMap_def {_ : CommSemiring R} [_s : \u2200 i, Semiring (f i)] [\u2200 i, Algebra R (f i)]\n    (a : R) : algebraMap R (\u2200 i, f i) a = fun i => algebraMap R (f i) a", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.algebraMap_apply", "code": "@[simp]\ntheorem algebraMap_apply {_ : CommSemiring R} [_s : \u2200 i, Semiring (f i)] [\u2200 i, Algebra R (f i)]\n    (a : R) (i : I) : algebraMap R (\u2200 i, f i) a i = algebraMap R (f i) a", "start": [52, 1], "end": [55, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.evalAlgHom", "code": "@[simps]\ndef evalAlgHom {_ : CommSemiring R} [\u2200 i, Semiring (f i)] [\u2200 i, Algebra R (f i)] (i : I) :\n    (\u2200 i, f i) \u2192\u2090[R] f i :=\n  { Pi.evalRingHom f i with\n    toFun := fun f => f i\n    commutes' := fun _ => rfl }", "start": [62, 1], "end": [69, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.constAlgHom", "code": "@[simps]\ndef constAlgHom : B \u2192\u2090[R] A \u2192 B :=\n  { Pi.constRingHom A B with\n    toFun := Function.const _\n    commutes' := fun _ => rfl }", "start": [74, 1], "end": [80, 32], "kind": "commanddeclaration"}, {"full_name": "Pi.constRingHom_eq_algebraMap", "code": "@[simp]\ntheorem constRingHom_eq_algebraMap : constRingHom A R = algebraMap R (A \u2192 R)", "start": [83, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.constAlgHom_eq_algebra_ofId", "code": "@[simp]\ntheorem constAlgHom_eq_algebra_ofId : constAlgHom R A R = Algebra.ofId R (A \u2192 R)", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "Function.algebra", "code": "instance Function.algebra {R : Type*} (I : Type*) (A : Type*) [CommSemiring R] [Semiring A]\n    [Algebra R A] : Algebra R (I \u2192 A) :=\n  Pi.algebra _ _", "start": [97, 1], "end": [101, 17], "kind": "commanddeclaration"}, {"full_name": "AlgHom.compLeft", "code": "@[simps]\nprotected def compLeft (f : A \u2192\u2090[R] B) (I : Type*) : (I \u2192 A) \u2192\u2090[R] I \u2192 B :=\n  { f.toRingHom.compLeft I with\n    toFun := fun h => f \u2218 h\n    commutes' := fun c => by\n      ext\n      exact f.commutes' c }", "start": [112, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.piCongrRight", "code": "@[simps apply]\ndef piCongrRight {R \u03b9 : Type*} {A\u2081 A\u2082 : \u03b9 \u2192 Type*} [CommSemiring R] [\u2200 i, Semiring (A\u2081 i)]\n    [\u2200 i, Semiring (A\u2082 i)] [\u2200 i, Algebra R (A\u2081 i)] [\u2200 i, Algebra R (A\u2082 i)]\n    (e : \u2200 i, A\u2081 i \u2243\u2090[R] A\u2082 i) : (\u2200 i, A\u2081 i) \u2243\u2090[R] \u2200 i, A\u2082 i :=\n  { @RingEquiv.piCongrRight \u03b9 A\u2081 A\u2082 _ _ fun i => (e i).toRingEquiv with\n    toFun := fun x j => e j (x j)\n    invFun := fun x j => (e j).symm (x j)\n    commutes' := fun r => by\n      ext i\n      simp }", "start": [127, 1], "end": [142, 13], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.piCongrRight_refl", "code": "@[simp]\ntheorem piCongrRight_refl {R \u03b9 : Type*} {A : \u03b9 \u2192 Type*} [CommSemiring R] [\u2200 i, Semiring (A i)]\n    [\u2200 i, Algebra R (A i)] :\n    (piCongrRight fun i => (AlgEquiv.refl : A i \u2243\u2090[R] A i)) = AlgEquiv.refl", "start": [145, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.piCongrRight_symm", "code": "@[simp]\ntheorem piCongrRight_symm {R \u03b9 : Type*} {A\u2081 A\u2082 : \u03b9 \u2192 Type*} [CommSemiring R]\n    [\u2200 i, Semiring (A\u2081 i)] [\u2200 i, Semiring (A\u2082 i)] [\u2200 i, Algebra R (A\u2081 i)] [\u2200 i, Algebra R (A\u2082 i)]\n    (e : \u2200 i, A\u2081 i \u2243\u2090[R] A\u2082 i) : (piCongrRight e).symm = piCongrRight fun i => (e i).symm", "start": [152, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.piCongrRight_trans", "code": "@[simp]\ntheorem piCongrRight_trans {R \u03b9 : Type*} {A\u2081 A\u2082 A\u2083 : \u03b9 \u2192 Type*} [CommSemiring R]\n    [\u2200 i, Semiring (A\u2081 i)] [\u2200 i, Semiring (A\u2082 i)] [\u2200 i, Semiring (A\u2083 i)] [\u2200 i, Algebra R (A\u2081 i)]\n    [\u2200 i, Algebra R (A\u2082 i)] [\u2200 i, Algebra R (A\u2083 i)] (e\u2081 : \u2200 i, A\u2081 i \u2243\u2090[R] A\u2082 i)\n    (e\u2082 : \u2200 i, A\u2082 i \u2243\u2090[R] A\u2083 i) :\n    (piCongrRight e\u2081).trans (piCongrRight e\u2082) = piCongrRight fun i => (e\u2081 i).trans (e\u2082 i)", "start": [159, 1], "end": [165, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Pi.lean", "imports": ["Mathlib/Algebra/Star/Basic.lean", "Mathlib/Algebra/Ring/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.star_apply", "code": "@[simp]\ntheorem star_apply [\u2200 i, Star (f i)] (x : \u2200 i, f i) (i : I) : star x i = star (x i)", "start": [31, 1], "end": [33, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.star_def", "code": "theorem star_def [\u2200 i, Star (f i)] (x : \u2200 i, f i) : star x = fun i => star (x i)", "start": [36, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.single_star", "code": "theorem single_star [\u2200 i, AddMonoid (f i)] [\u2200 i, StarAddMonoid (f i)] [DecidableEq I] (i : I)\n    (a : f i) : Pi.single i (star a) = star (Pi.single i a)", "start": [59, 1], "end": [61, 64], "kind": "commanddeclaration"}, {"full_name": "Function.update_star", "code": "theorem update_star [\u2200 i, Star (f i)] [DecidableEq I] (h : \u2200 i : I, f i) (i : I) (a : f i) :\n    Function.update (star h) i (star a) = star (Function.update h i a)", "start": [68, 1], "end": [70, 62], "kind": "commanddeclaration"}, {"full_name": "Function.star_sum_elim", "code": "theorem star_sum_elim {I J \u03b1 : Type*} (x : I \u2192 \u03b1) (y : J \u2192 \u03b1) [Star \u03b1] :\n    star (Sum.elim x y) = Sum.elim (star x) (star y)", "start": [73, 1], "end": [75, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/RingEquiv.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Ring/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingEquiv.map_list_prod", "code": "protected theorem map_list_prod [Semiring R] [Semiring S] (f : R \u2243+* S) (l : List R) :\n    f l.prod = (l.map f).prod", "start": [22, 1], "end": [23, 51], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_list_sum", "code": "protected theorem map_list_sum [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2243+* S)\n    (l : List R) : f l.sum = (l.map f).sum", "start": [26, 1], "end": [27, 63], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.unop_map_list_prod", "code": "protected theorem unop_map_list_prod [Semiring R] [Semiring S] (f : R \u2243+* S\u1d50\u1d52\u1d56) (l : List R) :\n    MulOpposite.unop (f l.prod) = (l.map (MulOpposite.unop \u2218 f)).reverse.prod", "start": [30, 1], "end": [33, 25], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_multiset_prod", "code": "protected theorem map_multiset_prod [CommSemiring R] [CommSemiring S] (f : R \u2243+* S)\n    (s : Multiset R) : f s.prod = (s.map f).prod", "start": [36, 1], "end": [38, 24], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_multiset_sum", "code": "protected theorem map_multiset_sum [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2243+* S)\n    (s : Multiset R) : f s.sum = (s.map f).sum", "start": [41, 1], "end": [43, 23], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_prod", "code": "protected theorem map_prod [CommSemiring R] [CommSemiring S] (g : R \u2243+* S) (f : \u03b1 \u2192 R)\n    (s : Finset \u03b1) : g (\u220f x in s, f x) = \u220f x in s, g (f x)", "start": [46, 1], "end": [48, 17], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.map_sum", "code": "protected theorem map_sum [NonAssocSemiring R] [NonAssocSemiring S] (g : R \u2243+* S) (f : \u03b1 \u2192 R)\n    (s : Finset \u03b1) : g (\u2211 x in s, f x) = \u2211 x in s, g (f x)", "start": [51, 1], "end": [53, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Module.lean", "imports": ["Mathlib/LinearAlgebra/Prod.lean", "Mathlib/Algebra/Module/Equiv.lean", "Mathlib/Algebra/Star/SelfAdjoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "star_nat_cast_smul", "code": "@[simp]\ntheorem star_nat_cast_smul [Semiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M] (n : \u2115)\n    (x : M) : star ((n : R) \u2022 x) = (n : R) \u2022 star x", "start": [37, 1], "end": [40, 52], "kind": "commanddeclaration"}, {"full_name": "star_int_cast_smul", "code": "@[simp]\ntheorem star_int_cast_smul [Ring R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : \u2124)\n    (x : M) : star ((n : R) \u2022 x) = (n : R) \u2022 star x", "start": [43, 1], "end": [46, 52], "kind": "commanddeclaration"}, {"full_name": "star_inv_nat_cast_smul", "code": "@[simp]\ntheorem star_inv_nat_cast_smul [DivisionSemiring R] [AddCommMonoid M] [Module R M] [StarAddMonoid M]\n    (n : \u2115) (x : M) : star ((n\u207b\u00b9 : R) \u2022 x) = (n\u207b\u00b9 : R) \u2022 star x", "start": [49, 1], "end": [52, 56], "kind": "commanddeclaration"}, {"full_name": "star_inv_int_cast_smul", "code": "@[simp]\ntheorem star_inv_int_cast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M]\n    (n : \u2124) (x : M) : star ((n\u207b\u00b9 : R) \u2022 x) = (n\u207b\u00b9 : R) \u2022 star x", "start": [55, 1], "end": [58, 56], "kind": "commanddeclaration"}, {"full_name": "star_rat_cast_smul", "code": "@[simp]\ntheorem star_rat_cast_smul [DivisionRing R] [AddCommGroup M] [Module R M] [StarAddMonoid M] (n : \u211a)\n    (x : M) : star ((n : R) \u2022 x) = (n : R) \u2022 star x", "start": [61, 1], "end": [64, 52], "kind": "commanddeclaration"}, {"full_name": "star_rat_smul", "code": "@[simp]\ntheorem star_rat_smul {R : Type*} [AddCommGroup R] [StarAddMonoid R] [Module \u211a R] (x : R) (n : \u211a) :\n    star (n \u2022 x) = n \u2022 star x", "start": [67, 1], "end": [70, 43], "kind": "commanddeclaration"}, {"full_name": "starLinearEquiv", "code": "@[simps]\ndef starLinearEquiv (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] : A \u2243\u2097\u22c6[R] A :=\n  { starAddEquiv with\n    toFun := star\n    map_smul' := star_smul }", "start": [75, 1], "end": [82, 29], "kind": "commanddeclaration"}, {"full_name": "selfAdjoint.submodule", "code": "def selfAdjoint.submodule : Submodule R A :=\n  { selfAdjoint A with smul_mem' := fun _ _ => (IsSelfAdjoint.all _).smul }", "start": [88, 1], "end": [90, 76], "kind": "commanddeclaration"}, {"full_name": "skewAdjoint.submodule", "code": "def skewAdjoint.submodule : Submodule R A :=\n  { skewAdjoint A with smul_mem' := skewAdjoint.smul_mem }", "start": [93, 1], "end": [95, 59], "kind": "commanddeclaration"}, {"full_name": "selfAdjointPart", "code": "@[simps]\ndef selfAdjointPart : A \u2192\u2097[R] selfAdjoint A where\n  toFun x :=\n    \u27e8(\u215f 2 : R) \u2022 (x + star x), by\n      simp only [selfAdjoint.mem_iff, star_smul, add_comm, StarAddMonoid.star_add, star_inv',\n        star_bit0, star_one, star_star, star_invOf (2 : R), star_trivial]\u27e9\n  map_add' x y := by\n    ext\n    simp [add_add_add_comm]\n  map_smul' r x := by\n    ext\n    simp [\u2190 mul_smul, show \u215f 2 * r = r * \u215f 2 from Commute.invOf_left <| (2 : \u2115).cast_commute r]", "start": [100, 1], "end": [112, 96], "kind": "commanddeclaration"}, {"full_name": "skewAdjointPart", "code": "@[simps]\ndef skewAdjointPart : A \u2192\u2097[R] skewAdjoint A where\n  toFun x :=\n    \u27e8(\u215f 2 : R) \u2022 (x - star x), by\n      simp only [skewAdjoint.mem_iff, star_smul, star_sub, star_star, star_trivial, \u2190 smul_neg,\n        neg_sub]\u27e9\n  map_add' x y := by\n    ext\n    simp only [sub_add, \u2190 smul_add, sub_sub_eq_add_sub, star_add, AddSubgroup.coe_mk,\n      AddSubgroup.coe_add]\n  map_smul' r x := by\n    ext\n    simp [\u2190 mul_smul, \u2190 smul_sub,\n      show r * \u215f 2 = \u215f 2 * r from Commute.invOf_right <| (2 : \u2115).commute_cast r]", "start": [115, 1], "end": [129, 81], "kind": "commanddeclaration"}, {"full_name": "StarModule.selfAdjointPart_add_skewAdjointPart", "code": "theorem StarModule.selfAdjointPart_add_skewAdjointPart (x : A) :\n    (selfAdjointPart R x : A) + skewAdjointPart R x = x", "start": [132, 1], "end": [135, 59], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.coe_selfAdjointPart_apply", "code": "theorem IsSelfAdjoint.coe_selfAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    (selfAdjointPart R x : A) = x", "start": [138, 1], "end": [140, 90], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.selfAdjointPart_apply", "code": "theorem IsSelfAdjoint.selfAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    selfAdjointPart R x = \u27e8x, hx\u27e9", "start": [142, 1], "end": [144, 46], "kind": "commanddeclaration"}, {"full_name": "selfAdjointPart_comp_subtype_selfAdjoint", "code": "theorem selfAdjointPart_comp_subtype_selfAdjoint :\n    (selfAdjointPart R).comp (selfAdjoint.submodule R A).subtype = .id", "start": [147, 1], "end": [149, 52], "kind": "commanddeclaration"}, {"full_name": "IsSelfAdjoint.skewAdjointPart_apply", "code": "theorem IsSelfAdjoint.skewAdjointPart_apply {x : A} (hx : IsSelfAdjoint x) :\n    skewAdjointPart R x = 0", "start": [151, 1], "end": [153, 89], "kind": "commanddeclaration"}, {"full_name": "skewAdjointPart_comp_subtype_selfAdjoint", "code": "theorem skewAdjointPart_comp_subtype_selfAdjoint :\n    (skewAdjointPart R).comp (selfAdjoint.submodule R A).subtype = 0", "start": [156, 1], "end": [158, 52], "kind": "commanddeclaration"}, {"full_name": "selfAdjointPart_comp_subtype_skewAdjoint", "code": "theorem selfAdjointPart_comp_subtype_skewAdjoint :\n    (selfAdjointPart R).comp (skewAdjoint.submodule R A).subtype = 0", "start": [161, 1], "end": [163, 67], "kind": "commanddeclaration"}, {"full_name": "skewAdjointPart_comp_subtype_skewAdjoint", "code": "theorem skewAdjointPart_comp_subtype_skewAdjoint :\n    (skewAdjointPart R).comp (skewAdjoint.submodule R A).subtype = .id", "start": [166, 1], "end": [170, 72], "kind": "commanddeclaration"}, {"full_name": "StarModule.decomposeProdAdjoint", "code": "@[simps!]\ndef StarModule.decomposeProdAdjoint : A \u2243\u2097[R] selfAdjoint A \u00d7 skewAdjoint A := by\n  refine LinearEquiv.ofLinear ((selfAdjointPart R).prod (skewAdjointPart R))\n    (LinearMap.coprod ((selfAdjoint.submodule R A).subtype) (skewAdjoint.submodule R A).subtype)\n    ?_ (LinearMap.ext <| StarModule.selfAdjointPart_add_skewAdjointPart R)\n  ext x <;> dsimp <;> erw [Submodule.coeSubtype, Submodule.coeSubtype] <;> simp", "start": [174, 1], "end": [183, 80], "kind": "commanddeclaration"}, {"full_name": "algebraMap_star_comm", "code": "@[simp]\ntheorem algebraMap_star_comm {R A : Type*} [CommSemiring R] [StarRing R] [Semiring A]\n    [StarMul A] [Algebra R A] [StarModule R A] (r : R) :\n    algebraMap R A (star r) = star (algebraMap R A r)", "start": [186, 1], "end": [190, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/BigOperators.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "star_prod", "code": "@[simp]\ntheorem star_prod [CommMonoid R] [StarMul R] {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 R) :\n    star (\u220f x in s, f x) = \u220f x in s, star (f x)", "start": [21, 1], "end": [23, 86], "kind": "commanddeclaration"}, {"full_name": "star_sum", "code": "@[simp]\ntheorem star_sum [AddCommMonoid R] [StarAddMonoid R] {\u03b1 : Type*} (s : Finset \u03b1) (f : \u03b1 \u2192 R) :\n    star (\u2211 x in s, f x) = \u2211 x in s, star (f x)", "start": [26, 1], "end": [28, 87], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Bilinear.lean", "imports": ["Mathlib/Algebra/Algebra/Equiv.lean", "Mathlib/Algebra/Hom/NonUnitalAlg.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/LinearAlgebra/TensorProduct.lean", "Mathlib/Algebra/Hom/Iterate.lean"], "premises": [{"full_name": "LinearMap.mul", "code": "def mul : A \u2192\u2097[R] A \u2192\u2097[R] A :=\n  LinearMap.mk\u2082 R (\u00b7 * \u00b7) add_mul smul_mul_assoc mul_add mul_smul_comm", "start": [31, 1], "end": [35, 71], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul'", "code": "noncomputable def mul' : A \u2297[R] A \u2192\u2097[R] A :=\n  TensorProduct.lift (mul R A)", "start": [38, 1], "end": [40, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft", "code": "def mulLeft (a : A) : A \u2192\u2097[R] A :=\n  mul R A a", "start": [45, 1], "end": [47, 12], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight", "code": "def mulRight (a : A) : A \u2192\u2097[R] A :=\n  (mul R A).flip a", "start": [50, 1], "end": [52, 19], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeftRight", "code": "def mulLeftRight (ab : A \u00d7 A) : A \u2192\u2097[R] A :=\n  (mulRight R ab.snd).comp (mulLeft R ab.fst)", "start": [55, 1], "end": [57, 46], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_toAddMonoidHom", "code": "@[simp]\ntheorem mulLeft_toAddMonoidHom (a : A) : (mulLeft R a : A \u2192+ A) = AddMonoidHom.mulLeft a", "start": [60, 1], "end": [62, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_toAddMonoidHom", "code": "@[simp]\ntheorem mulRight_toAddMonoidHom (a : A) : (mulRight R a : A \u2192+ A) = AddMonoidHom.mulRight a", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_apply'", "code": "@[simp]\ntheorem mul_apply' (a b : A) : mul R A a b = a * b", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_apply", "code": "@[simp]\ntheorem mulLeft_apply (a b : A) : mulLeft R a b = a * b", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_apply", "code": "@[simp]\ntheorem mulRight_apply (a b : A) : mulRight R a b = b * a", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeftRight_apply", "code": "@[simp]\ntheorem mulLeftRight_apply (a b x : A) : mulLeftRight R (a, b) x = a * x * b", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul'_apply", "code": "@[simp]\ntheorem mul'_apply {a b : A} : mul' R A (a \u2297\u209c b) = a * b", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_zero_eq_zero", "code": "@[simp]\ntheorem mulLeft_zero_eq_zero : mulLeft R (0 : A) = 0", "start": [97, 1], "end": [99, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_zero_eq_zero", "code": "@[simp]\ntheorem mulRight_zero_eq_zero : mulRight R (0 : A) = 0", "start": [102, 1], "end": [104, 26], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.lmul", "code": "def _root_.NonUnitalAlgHom.lmul : A \u2192\u2099\u2090[R] End R A :=\n  { mul R A with\n    map_mul' := by\n      intro a b\n      ext c\n      exact mul_assoc a b c\n    map_zero' := by\n      ext a\n      exact zero_mul a }", "start": [114, 1], "end": [125, 25], "kind": "commanddeclaration"}, {"full_name": "NonUnitalAlgHom.coe_lmul_eq_mul", "code": "@[simp]\ntheorem _root_.NonUnitalAlgHom.coe_lmul_eq_mul : \u21d1(NonUnitalAlgHom.lmul R A) = mul R A", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.commute_mulLeft_right", "code": "theorem commute_mulLeft_right (a b : A) : Commute (mulLeft R a) (mulRight R b)", "start": [135, 1], "end": [137, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_mul", "code": "@[simp]\ntheorem mulLeft_mul (a b : A) : mulLeft R (a * b) = (mulLeft R a).comp (mulLeft R b)", "start": [140, 1], "end": [143, 51], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_mul", "code": "@[simp]\ntheorem mulRight_mul (a b : A) : mulRight R (a * b) = (mulRight R b).comp (mulRight R a)", "start": [146, 1], "end": [149, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.map_mul_iff", "code": "theorem map_mul_iff (f : A \u2192\u2097[R] B) :\n    (\u2200 x y, f (x * y) = f x * f y) \u2194\n      (LinearMap.mul R A).compr\u2082 f = (LinearMap.mul R B \u2218\u2097 f).compl\u2082 f", "start": [159, 1], "end": [167, 30], "kind": "commanddeclaration"}, {"full_name": "Algebra.lmul", "code": "def _root_.Algebra.lmul : A \u2192\u2090[R] End R A :=\n  { LinearMap.mul R A with\n    map_one' := by\n      ext a\n      exact one_mul a\n    map_mul' := by\n      intro a b\n      ext c\n      exact mul_assoc a b c\n    map_zero' := by\n      ext a\n      exact zero_mul a\n    commutes' := by\n      intro r\n      ext a\n      exact (Algebra.smul_def r a).symm }", "start": [169, 1], "end": [188, 42], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_lmul_eq_mul", "code": "@[simp]\ntheorem _root_.Algebra.coe_lmul_eq_mul : \u21d1(Algebra.lmul R A) = mul R A", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_eq_zero_iff", "code": "@[simp]\ntheorem mulLeft_eq_zero_iff (a : A) : mulLeft R a = 0 \u2194 a = 0", "start": [198, 1], "end": [204, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_eq_zero_iff", "code": "@[simp]\ntheorem mulRight_eq_zero_iff (a : A) : mulRight R a = 0 \u2194 a = 0", "start": [207, 1], "end": [213, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_one", "code": "@[simp]\ntheorem mulLeft_one : mulLeft R (1 : A) = LinearMap.id", "start": [216, 1], "end": [219, 63], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_one", "code": "@[simp]\ntheorem mulRight_one : mulRight R (1 : A) = LinearMap.id", "start": [222, 1], "end": [225, 64], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_mulLeft", "code": "@[simp]\ntheorem pow_mulLeft (a : A) (n : \u2115) : mulLeft R a ^ n = mulLeft R (a ^ n)", "start": [228, 1], "end": [230, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.pow_mulRight", "code": "@[simp]\ntheorem pow_mulRight (a : A) (n : \u2115) : mulRight R a ^ n = mulRight R (a ^ n)", "start": [233, 1], "end": [237, 86], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulLeft_injective", "code": "theorem mulLeft_injective [NoZeroDivisors A] {x : A} (hx : x \u2260 0) :\n    Function.Injective (mulLeft R x)", "start": [246, 1], "end": [250, 32], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mulRight_injective", "code": "theorem mulRight_injective [NoZeroDivisors A] {x : A} (hx : x \u2260 0) :\n    Function.Injective (mulRight R x)", "start": [253, 1], "end": [257, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mul_injective", "code": "theorem mul_injective [NoZeroDivisors A] {x : A} (hx : x \u2260 0) : Function.Injective (mul R A x)", "start": [260, 1], "end": [263, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/BigOperators.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Data/Set/Pointwise/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.image_list_prod", "code": "@[to_additive]\ntheorem image_list_prod (f : F) :\n    \u2200 l : List (Set \u03b1), (f : \u03b1 \u2192 \u03b2) '' l.prod = (l.map fun s => f '' s).prod", "start": [28, 1], "end": [32, 101], "kind": "commanddeclaration"}, {"full_name": "Set.image_multiset_prod", "code": "@[to_additive]\ntheorem image_multiset_prod (f : F) :\n    \u2200 m : Multiset (Set \u03b1), (f : \u03b1 \u2192 \u03b2) '' m.prod = (m.map fun s => f '' s).prod", "start": [42, 1], "end": [47, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image_finset_prod", "code": "@[to_additive]\ntheorem image_finset_prod (f : F) (m : Finset \u03b9) (s : \u03b9 \u2192 Set \u03b1) :\n    ((f : \u03b1 \u2192 \u03b2) '' \u220f i in m, s i) = \u220f i in m, f '' s i", "start": [51, 1], "end": [54, 87], "kind": "commanddeclaration"}, {"full_name": "Set.mem_finset_prod", "code": "@[to_additive \" The n-ary version of `Set.mem_add`. \"]\ntheorem mem_finset_prod (t : Finset \u03b9) (f : \u03b9 \u2192 Set \u03b1) (a : \u03b1) :\n    (a \u2208 \u220f i in t, f i) \u2194 \u2203 (g : \u03b9 \u2192 \u03b1) (_ : \u2200 {i}, i \u2208 t \u2192 g i \u2208 f i), \u220f i in t, g i = a", "start": [58, 1], "end": [81, 68], "kind": "commanddeclaration"}, {"full_name": "Set.mem_fintype_prod", "code": "@[to_additive \" A version of `Set.mem_finset_sum` with a simpler RHS for sums over a Fintype. \"]\ntheorem mem_fintype_prod [Fintype \u03b9] (f : \u03b9 \u2192 Set \u03b1) (a : \u03b1) :\n    (a \u2208 \u220f i, f i) \u2194 \u2203 (g : \u03b9 \u2192 \u03b1) (_ : \u2200 i, g i \u2208 f i), \u220f i, g i = a", "start": [85, 1], "end": [90, 7], "kind": "commanddeclaration"}, {"full_name": "Set.list_prod_mem_list_prod", "code": "@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem list_prod_mem_list_prod (t : List \u03b9) (f : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1) (hg : \u2200 i \u2208 t, g i \u2208 f i) :\n    (t.map g).prod \u2208 (t.map f).prod", "start": [94, 1], "end": [102, 56], "kind": "commanddeclaration"}, {"full_name": "Set.list_prod_subset_list_prod", "code": "@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem list_prod_subset_list_prod (t : List \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1) (hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) :\n    (t.map f\u2081).prod \u2286 (t.map f\u2082).prod", "start": [106, 1], "end": [114, 56], "kind": "commanddeclaration"}, {"full_name": "Set.list_prod_singleton", "code": "@[to_additive]\ntheorem list_prod_singleton {M : Type*} [CommMonoid M] (s : List M) :\n    (s.map fun i \u21a6 ({i} : Set M)).prod = {s.prod}", "start": [118, 1], "end": [121, 59], "kind": "commanddeclaration"}, {"full_name": "Set.multiset_prod_mem_multiset_prod", "code": "@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem multiset_prod_mem_multiset_prod (t : Multiset \u03b9) (f : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1)\n    (hg : \u2200 i \u2208 t, g i \u2208 f i) : (t.map g).prod \u2208 (t.map f).prod", "start": [125, 1], "end": [131, 41], "kind": "commanddeclaration"}, {"full_name": "Set.multiset_prod_subset_multiset_prod", "code": "@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem multiset_prod_subset_multiset_prod (t : Multiset \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1)\n    (hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) : (t.map f\u2081).prod \u2286 (t.map f\u2082).prod", "start": [135, 1], "end": [141, 44], "kind": "commanddeclaration"}, {"full_name": "Set.multiset_prod_singleton", "code": "@[to_additive]\ntheorem multiset_prod_singleton {M : Type*} [CommMonoid M] (s : Multiset M) :\n    (s.map fun i \u21a6 ({i} : Set M)).prod = {s.prod}", "start": [145, 1], "end": [148, 63], "kind": "commanddeclaration"}, {"full_name": "Set.finset_prod_mem_finset_prod", "code": "@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem finset_prod_mem_finset_prod (t : Finset \u03b9) (f : \u03b9 \u2192 Set \u03b1) (g : \u03b9 \u2192 \u03b1)\n    (hg : \u2200 i \u2208 t, g i \u2208 f i) : (\u220f i in t, g i) \u2208 \u220f i in t, f i", "start": [152, 1], "end": [156, 43], "kind": "commanddeclaration"}, {"full_name": "Set.finset_prod_subset_finset_prod", "code": "@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem finset_prod_subset_finset_prod (t : Finset \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1)\n    (hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) : \u220f i in t, f\u2081 i \u2286 \u220f i in t, f\u2082 i", "start": [160, 1], "end": [164, 46], "kind": "commanddeclaration"}, {"full_name": "Set.finset_prod_singleton", "code": "@[to_additive]\ntheorem finset_prod_singleton {M \u03b9 : Type*} [CommMonoid M] (s : Finset \u03b9) (I : \u03b9 \u2192 M) :\n    (\u220f i : \u03b9 in s, ({I i} : Set M)) = {\u220f i : \u03b9 in s, I i}", "start": [168, 1], "end": [171, 56], "kind": "commanddeclaration"}, {"full_name": "Set.image_finset_prod_pi", "code": "@[to_additive \"The n-ary version of `Set.add_image_prod`. \"]\ntheorem image_finset_prod_pi (l : Finset \u03b9) (S : \u03b9 \u2192 Set \u03b1) :\n    (fun f : \u03b9 \u2192 \u03b1 => \u220f i in l, f i) '' (l : Set \u03b9).pi S = \u220f i in l, S i", "start": [175, 1], "end": [180, 76], "kind": "commanddeclaration"}, {"full_name": "Set.image_fintype_prod_pi", "code": "@[to_additive \"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. \"]\ntheorem image_fintype_prod_pi [Fintype \u03b9] (S : \u03b9 \u2192 Set \u03b1) :\n    (fun f : \u03b9 \u2192 \u03b1 => \u220f i, f i) '' univ.pi S = \u220f i, S i", "start": [184, 1], "end": [188, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/GroupTheory/Subgroup/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.pointwiseNeg", "code": "protected def pointwiseNeg : Neg (Submodule R M) where\n  neg p :=\n    { -p.toAddSubmonoid with\n      smul_mem' := fun r m hm => Set.mem_neg.2 <| smul_neg r m \u25b8 p.smul_mem r <| Set.mem_neg.1 hm }", "start": [45, 1], "end": [55, 100], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_set_neg", "code": "@[simp]\ntheorem coe_set_neg (S : Submodule R M) : \u2191(-S) = -(S : Set M)", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_toAddSubmonoid", "code": "@[simp]\ntheorem neg_toAddSubmonoid (S : Submodule R M) : (-S).toAddSubmonoid = -S.toAddSubmonoid", "start": [67, 1], "end": [69, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_neg", "code": "@[simp]\ntheorem mem_neg {g : M} {S : Submodule R M} : g \u2208 -S \u2194 -g \u2208 S", "start": [72, 1], "end": [74, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.involutivePointwiseNeg", "code": "protected def involutivePointwiseNeg : InvolutiveNeg (Submodule R M)\n    where\n  neg := Neg.neg\n  neg_neg _S := SetLike.coe_injective <| neg_neg _", "start": [77, 1], "end": [83, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_le_neg", "code": "@[simp]\ntheorem neg_le_neg (S T : Submodule R M) : -S \u2264 -T \u2194 S \u2264 T", "start": [88, 1], "end": [90, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_le", "code": "theorem neg_le (S T : Submodule R M) : -S \u2264 T \u2194 S \u2264 -T", "start": [93, 1], "end": [94, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.negOrderIso", "code": "def negOrderIso : Submodule R M \u2243o Submodule R M\n    where\n  toEquiv := Equiv.neg _\n  map_rel_iff' := @neg_le_neg _ _ _ _ _", "start": [97, 1], "end": [101, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.closure_neg", "code": "theorem closure_neg (s : Set M) : span R (-s) = -span R s", "start": [104, 1], "end": [109, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_inf", "code": "@[simp]\ntheorem neg_inf (S T : Submodule R M) : -(S \u2293 T) = -S \u2293 -T", "start": [112, 1], "end": [114, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_sup", "code": "@[simp]\ntheorem neg_sup (S T : Submodule R M) : -(S \u2294 T) = -S \u2294 -T", "start": [117, 1], "end": [119, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_bot", "code": "@[simp]\ntheorem neg_bot : -(\u22a5 : Submodule R M) = \u22a5", "start": [122, 1], "end": [124, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_top", "code": "@[simp]\ntheorem neg_top : -(\u22a4 : Submodule R M) = \u22a4", "start": [127, 1], "end": [129, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_iInf", "code": "@[simp]\ntheorem neg_iInf {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R M) : (-\u2a05 i, S i) = \u2a05 i, -S i", "start": [132, 1], "end": [134, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_iSup", "code": "@[simp]\ntheorem neg_iSup {\u03b9 : Sort*} (S : \u03b9 \u2192 Submodule R M) : (-\u2a06 i, S i) = \u2a06 i, -S i", "start": [137, 1], "end": [139, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.neg_eq_self", "code": "@[simp]\ntheorem neg_eq_self [Ring R] [AddCommGroup M] [Module R M] (p : Submodule R M) : -p = p", "start": [146, 1], "end": [148, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwiseAddCommMonoid", "code": "instance pointwiseAddCommMonoid : AddCommMonoid (Submodule R M)\n    where\n  add := (\u00b7 \u2294 \u00b7)\n  add_assoc _ _ _ := sup_assoc\n  zero := \u22a5\n  zero_add _ := bot_sup_eq\n  add_zero _ := sup_bot_eq\n  add_comm _ _ := sup_comm", "start": [155, 1], "end": [162, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.add_eq_sup", "code": "@[simp]\ntheorem add_eq_sup (p q : Submodule R M) : p + q = p \u2294 q", "start": [165, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.zero_eq_bot", "code": "@[simp]\ntheorem zero_eq_bot : (0 : Submodule R M) = \u22a5", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwiseDistribMulAction", "code": "protected def pointwiseDistribMulAction : DistribMulAction \u03b1 (Submodule R M)\n    where\n  smul a S := S.map (DistribMulAction.toLinearMap R M a : M \u2192\u2097[R] M)\n  one_smul S :=\n    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| one_smul \u03b1)).trans S.map_id\n  mul_smul _a\u2081 _a\u2082 S :=\n    (congr_arg (fun f : Module.End R M => S.map f) (LinearMap.ext <| mul_smul _ _)).trans\n      (S.map_comp _ _)\n  smul_zero _a := map_bot _\n  smul_add _a _S\u2081 _S\u2082 := map_sup _ _ _", "start": [186, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_pointwise_smul", "code": "@[simp]\ntheorem coe_pointwise_smul (a : \u03b1) (S : Submodule R M) : \u2191(a \u2022 S) = a \u2022 (S : Set M)", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwise_smul_toAddSubmonoid", "code": "@[simp]\ntheorem pointwise_smul_toAddSubmonoid (a : \u03b1) (S : Submodule R M) :\n    (a \u2022 S).toAddSubmonoid = a \u2022 S.toAddSubmonoid", "start": [210, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwise_smul_toAddSubgroup", "code": "@[simp]\ntheorem pointwise_smul_toAddSubgroup {R M : Type*} [Ring R] [AddCommGroup M] [DistribMulAction \u03b1 M]\n    [Module R M] [SMulCommClass \u03b1 R M] (a : \u03b1) (S : Submodule R M) :\n    (a \u2022 S).toAddSubgroup = a \u2022 S.toAddSubgroup", "start": [216, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_pointwise_smul", "code": "theorem smul_mem_pointwise_smul (m : M) (a : \u03b1) (S : Submodule R M) : m \u2208 S \u2192 a \u2022 m \u2208 a \u2022 S", "start": [223, 1], "end": [224, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_bot'", "code": "@[simp]\ntheorem smul_bot' (a : \u03b1) : a \u2022 (\u22a5 : Submodule R M) = \u22a5", "start": [227, 1], "end": [230, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_sup'", "code": "theorem smul_sup' (a : \u03b1) (S T : Submodule R M) : a \u2022 (S \u2294 T) = a \u2022 S \u2294 a \u2022 T", "start": [233, 1], "end": [235, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_span", "code": "theorem smul_span (a : \u03b1) (s : Set M) : a \u2022 span R s = span R (a \u2022 s)", "start": [238, 1], "end": [239, 15], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_smul", "code": "theorem span_smul (a : \u03b1) (s : Set M) : span R (a \u2022 s) = a \u2022 span R s", "start": [242, 1], "end": [243, 30], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwiseCentralScalar", "code": "instance pointwiseCentralScalar [DistribMulAction \u03b1\u1d50\u1d52\u1d56 M] [SMulCommClass \u03b1\u1d50\u1d52\u1d56 R M]\n    [IsCentralScalar \u03b1 M] : IsCentralScalar \u03b1 (Submodule R M) :=\n  \u27e8fun _a S => (congr_arg fun f : Module.End R M => S.map f) <| LinearMap.ext <| op_smul_eq_smul _\u27e9", "start": [246, 1], "end": [248, 100], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_le_self_of_tower", "code": "@[simp]\ntheorem smul_le_self_of_tower {\u03b1 : Type*} [Semiring \u03b1] [Module \u03b1 R] [Module \u03b1 M]\n    [SMulCommClass \u03b1 R M] [IsScalarTower \u03b1 R M] (a : \u03b1) (S : Submodule R M) : a \u2022 S \u2264 S", "start": [251, 1], "end": [255, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwiseMulActionWithZero", "code": "protected def pointwiseMulActionWithZero : MulActionWithZero \u03b1 (Submodule R M) :=\n  { Submodule.pointwiseDistribMulAction with\n    zero_smul := fun S =>\n      (congr_arg (fun f : M \u2192\u2097[R] M => S.map f) (LinearMap.ext <| zero_smul \u03b1)).trans S.map_zero }", "start": [264, 1], "end": [273, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/SubMulAction/Pointwise.lean", "imports": ["Mathlib/GroupTheory/GroupAction/SubMulAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SubMulAction.coe_one", "code": "theorem coe_one : \u2191(1 : SubMulAction R M) = Set.range fun r : R => r \u2022 (1 : M)", "start": [36, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mem_one", "code": "@[simp]\ntheorem mem_one {x : M} : x \u2208 (1 : SubMulAction R M) \u2194 \u2203 r : R, r \u2022 (1 : M) = x", "start": [40, 1], "end": [42, 10], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.subset_coe_one", "code": "theorem subset_coe_one : (1 : Set M) \u2286 (1 : SubMulAction R M)", "start": [45, 1], "end": [46, 36], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.coe_mul", "code": "@[norm_cast]\ntheorem coe_mul (p q : SubMulAction R M) : \u2191(p * q) = (p * q : Set M)", "start": [61, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mem_mul", "code": "theorem mem_mul {p q : SubMulAction R M} {x : M} : x \u2208 p * q \u2194 \u2203 y z, y \u2208 p \u2227 z \u2208 q \u2227 y * z = x", "start": [66, 1], "end": [67, 14], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mulOneClass", "code": "instance mulOneClass : MulOneClass (SubMulAction R M)\n    where\n  mul := (\u00b7 * \u00b7)\n  one := 1\n  mul_one a := by\n    ext x\n    simp only [mem_mul, mem_one, mul_smul_comm, exists_and_left, exists_exists_eq_and, mul_one]\n    constructor\n    \u00b7 rintro \u27e8y, hy, r, rfl\u27e9\n      exact smul_mem _ _ hy\n    \u00b7 intro hx\n      exact \u27e8x, hx, 1, one_smul _ _\u27e9\n  one_mul a := by\n    ext x\n    simp only [mem_mul, mem_one, smul_mul_assoc, exists_and_left, exists_exists_eq_and, one_mul]\n    refine' \u27e8_, fun hx => \u27e81, x, hx, one_smul _ _\u27e9\u27e9\n    rintro \u27e8r, y, hy, rfl\u27e9\n    exact smul_mem _ _ hy", "start": [77, 1], "end": [94, 26], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.semiGroup", "code": "instance semiGroup : Semigroup (SubMulAction R M)\n    where\n  mul := (\u00b7 * \u00b7)\n  mul_assoc _ _ _ := SetLike.coe_injective (mul_assoc (_ : Set _) _ _)", "start": [103, 1], "end": [106, 71], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.coe_pow", "code": "theorem coe_pow (p : SubMulAction R M) : \u2200 {n : \u2115} (_ : n \u2260 0), (p ^ n : Set M) = ((p : Set M) ^ n)", "start": [118, 1], "end": [122, 83], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.subset_coe_pow", "code": "theorem subset_coe_pow (p : SubMulAction R M) : \u2200 {n : \u2115}, ((p : Set M) ^ n) \u2286 (p ^ n : Set M)", "start": [125, 1], "end": [129, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Semiring.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Order/Kleene.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SetSemiring", "code": "def SetSemiring (\u03b1 : Type*) : Type _ :=\n  Set \u03b1", "start": [27, 1], "end": [30, 8], "kind": "commanddeclaration"}, {"full_name": "Set.up", "code": "protected def Set.up : Set \u03b1 \u2243 SetSemiring \u03b1 :=\n  Equiv.refl _", "start": [42, 1], "end": [44, 15], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down", "code": "protected def down : SetSemiring \u03b1 \u2243 Set \u03b1 :=\n  Equiv.refl _", "start": [49, 1], "end": [51, 15], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_up", "code": "@[simp]\nprotected theorem down_up (s : Set \u03b1) : SetSemiring.down (Set.up s) = s", "start": [59, 1], "end": [61, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.up_down", "code": "@[simp]\nprotected theorem up_down (s : SetSemiring \u03b1) : Set.up (SetSemiring.down s) = s", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.up_le_up", "code": "theorem up_le_up {s t : Set \u03b1} : Set.up s \u2264 Set.up t \u2194 s \u2286 t", "start": [72, 1], "end": [73, 10], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.up_lt_up", "code": "theorem up_lt_up {s t : Set \u03b1} : Set.up s < Set.up t \u2194 s \u2282 t", "start": [77, 1], "end": [78, 10], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_subset_down", "code": "@[simp]\ntheorem down_subset_down {s t : SetSemiring \u03b1} : SetSemiring.down s \u2286 SetSemiring.down t \u2194 s \u2264 t", "start": [82, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_ssubset_down", "code": "@[simp]\ntheorem down_ssubset_down {s t : SetSemiring \u03b1} : SetSemiring.down s \u2282 SetSemiring.down t \u2194 s < t", "start": [88, 1], "end": [90, 10], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.zero_def", "code": "theorem zero_def : (0 : SetSemiring \u03b1) = Set.up \u2205", "start": [102, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_zero", "code": "@[simp]\ntheorem down_zero : down (0 : SetSemiring \u03b1) = \u2205", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Set.up_empty", "code": "@[simp]\ntheorem _root_.Set.up_empty : Set.up (\u2205 : Set \u03b1) = 0", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.add_def", "code": "theorem add_def (s t : SetSemiring \u03b1) : s + t = up (down s \u222a down t)", "start": [116, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_add", "code": "@[simp]\ntheorem down_add (s t : SetSemiring \u03b1) : down (s + t) = down s \u222a down t", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "Set.up_union", "code": "@[simp]\ntheorem _root_.Set.up_union (s t : Set \u03b1) : up (s \u222a t) = up s + up t", "start": [125, 1], "end": [127, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.covariantClass_add", "code": "instance covariantClass_add : CovariantClass (SetSemiring \u03b1) (SetSemiring \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => union_subset_union_right _\u27e9", "start": [132, 1], "end": [133, 44], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.mul_def", "code": "theorem mul_def (s t : SetSemiring \u03b1) : s * t = up (down s * down t)", "start": [150, 1], "end": [151, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_mul", "code": "@[simp]\ntheorem down_mul (s t : SetSemiring \u03b1) : down (s * t) = down s * down t", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Set.up_mul", "code": "@[simp]\ntheorem _root_.Set.up_mul (s t : Set \u03b1) : up (s * t) = up s * up t", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.covariantClass_mul_left", "code": "instance covariantClass_mul_left :\n    CovariantClass (SetSemiring \u03b1) (SetSemiring \u03b1) (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => mul_subset_mul_left\u27e9", "start": [170, 1], "end": [172, 37], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.covariantClass_mul_right", "code": "instance covariantClass_mul_right :\n    CovariantClass (SetSemiring \u03b1) (SetSemiring \u03b1) (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => mul_subset_mul_right\u27e9", "start": [175, 1], "end": [177, 38], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.one_def", "code": "theorem one_def : (1 : SetSemiring \u03b1) = Set.up 1", "start": [189, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.down_one", "code": "@[simp]\ntheorem down_one : down (1 : SetSemiring \u03b1) = 1", "start": [193, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Set.up_one", "code": "@[simp]\ntheorem _root_.Set.up_one : up (1 : Set \u03b1) = 1", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.imageHom", "code": "def imageHom [MulOneClass \u03b1] [MulOneClass \u03b2] (f : \u03b1 \u2192* \u03b2) : SetSemiring \u03b1 \u2192+* SetSemiring \u03b2\n    where\n  toFun s := up (image f (down s))\n  map_zero' := image_empty _\n  map_one' := by\n    dsimp only  rw [down_one, image_one, map_one, singleton_one, up_one]\n  map_add' := image_union _\n  map_mul' _ _ := image_mul f", "start": [235, 1], "end": [245, 30], "kind": "commanddeclaration"}, {"full_name": "SetSemiring.imageHom_def", "code": "lemma imageHom_def [MulOneClass \u03b1] [MulOneClass \u03b2] (f : \u03b1 \u2192* \u03b2) (s : SetSemiring \u03b1) :\n    imageHom f s = up (image f (down s)) :=\n  rfl", "start": [248, 1], "end": [250, 6], "kind": "mathlibtacticlemma"}, {"full_name": "SetSemiring.down_imageHom", "code": "@[simp]\nlemma down_imageHom [MulOneClass \u03b1] [MulOneClass \u03b2] (f : \u03b1 \u2192* \u03b2) (s : SetSemiring \u03b1) :\n    down (imageHom f s) = f '' down s :=\n  rfl", "start": [253, 1], "end": [256, 6], "kind": "mathlibtacticlemma"}, {"full_name": "Set.up_image", "code": "@[simp]\nlemma _root_.Set.up_image [MulOneClass \u03b1] [MulOneClass \u03b2] (f : \u03b1 \u2192* \u03b2) (s : Set \u03b1) :\n    up (f '' s) = imageHom f (up s) :=\n  rfl", "start": [259, 1], "end": [262, 6], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Data/Finset/Pointwise.lean", "imports": ["Mathlib/Data/Set/Pointwise/Finite.lean", "Mathlib/Data/Finset/Preimage.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Data/Set/Pointwise/ListOfFn.lean", "Mathlib/Data/Finset/NAry.lean"], "premises": [{"full_name": "Finset.one", "code": "@[to_additive \"The finset `0 : Finset \u03b1` is defined as `{0}` in locale `Pointwise`.\"]\nprotected def one : One (Finset \u03b1) :=\n  \u27e8{1}\u27e9", "start": [72, 1], "end": [75, 8], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_one", "code": "@[to_additive (attr := simp)]\ntheorem mem_one : a \u2208 (1 : Finset \u03b1) \u2194 a = 1", "start": [81, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_one", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_one : \u2191(1 : Finset \u03b1) = (1 : Set \u03b1)", "start": [87, 1], "end": [89, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.one_subset", "code": "@[to_additive (attr := simp)]\ntheorem one_subset : (1 : Finset \u03b1) \u2286 s \u2194 (1 : \u03b1) \u2208 s", "start": [93, 1], "end": [95, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_one", "code": "@[to_additive]\ntheorem singleton_one : ({1} : Finset \u03b1) = 1", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one : (1 : \u03b1) \u2208 (1 : Finset \u03b1)", "start": [105, 1], "end": [107, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.one_nonempty", "code": "@[to_additive]\ntheorem one_nonempty : (1 : Finset \u03b1).Nonempty", "start": [111, 1], "end": [113, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.map_one", "code": "@[to_additive (attr := simp)]\nprotected theorem map_one {f : \u03b1 \u21aa \u03b2} : map f 1 = {f 1}", "start": [117, 1], "end": [119, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.image_one", "code": "@[to_additive (attr := simp)]\ntheorem image_one [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} : image f 1 = {f 1}", "start": [123, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_one_iff_eq", "code": "@[to_additive]\ntheorem subset_one_iff_eq : s \u2286 1 \u2194 s = \u2205 \u2228 s = 1", "start": [129, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.subset_one_iff", "code": "@[to_additive]\ntheorem Nonempty.subset_one_iff (h : s.Nonempty) : s \u2286 1 \u2194 s = 1", "start": [135, 1], "end": [137, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.card_one", "code": "@[to_additive (attr := simp)]\ntheorem card_one : (1 : Finset \u03b1).card = 1", "start": [141, 1], "end": [143, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonOneHom", "code": "@[to_additive \"The singleton operation as a `ZeroHom`.\"]\ndef singletonOneHom : OneHom \u03b1 (Finset \u03b1) where\n  toFun := singleton; map_one' := singleton_one", "start": [147, 1], "end": [150, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_singletonOneHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonOneHom : (singletonOneHom : \u03b1 \u2192 Finset \u03b1) = singleton", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonOneHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem singletonOneHom_apply (a : \u03b1) : singletonOneHom a = {a}", "start": [160, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.imageOneHom", "code": "@[to_additive (attr := simps) \"Lift a `ZeroHom` to `Finset` via `image`\"]\ndef imageOneHom [DecidableEq \u03b2] [One \u03b2] [OneHomClass F \u03b1 \u03b2] (f : F) : OneHom (Finset \u03b1) (Finset \u03b2)\n    where\n  toFun := Finset.image f\n  map_one' := by rw [image_one, map_one, singleton_one]", "start": [166, 1], "end": [171, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.inv", "code": "@[to_additive\n      \"The pointwise negation of finset `-s` is defined as `{-x | x \u2208 s}` in locale `Pointwise`.\"]\nprotected def inv : Inv (Finset \u03b1) :=\n  \u27e8image Inv.inv\u27e9", "start": [184, 1], "end": [188, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_def", "code": "@[to_additive]\ntheorem inv_def : s\u207b\u00b9 = s.image fun x => x\u207b\u00b9", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_inv", "code": "@[to_additive]\ntheorem image_inv : (s.image fun x => x\u207b\u00b9) = s\u207b\u00b9", "start": [200, 1], "end": [202, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_inv", "code": "@[to_additive]\ntheorem mem_inv {x : \u03b1} : x \u2208 s\u207b\u00b9 \u2194 \u2203 y \u2208 s, y\u207b\u00b9 = x", "start": [206, 1], "end": [208, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_mem_inv", "code": "@[to_additive]\ntheorem inv_mem_inv (ha : a \u2208 s) : a\u207b\u00b9 \u2208 s\u207b\u00b9", "start": [212, 1], "end": [214, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.card_inv_le", "code": "@[to_additive]\ntheorem card_inv_le : s\u207b\u00b9.card \u2264 s.card", "start": [218, 1], "end": [220, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_empty", "code": "@[to_additive (attr := simp)]\ntheorem inv_empty : (\u2205 : Finset \u03b1)\u207b\u00b9 = \u2205", "start": [224, 1], "end": [226, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_nonempty_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_nonempty_iff : s\u207b\u00b9.Nonempty \u2194 s.Nonempty", "start": [230, 1], "end": [232, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_inv", "code": "alias \u27e8Nonempty.of_inv, Nonempty.inv\u27e9 := inv_nonempty_iff", "start": [236, 1], "end": [236, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.Nonempty.inv", "code": "alias \u27e8Nonempty.of_inv, Nonempty.inv\u27e9 := inv_nonempty_iff", "start": [236, 1], "end": [236, 58], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Finset.inv_subset_inv", "code": "@[to_additive (attr := mono)]\ntheorem inv_subset_inv (h : s \u2286 t) : s\u207b\u00b9 \u2286 t\u207b\u00b9", "start": [242, 1], "end": [244, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_singleton", "code": "@[to_additive (attr := simp)]\ntheorem inv_singleton (a : \u03b1) : ({a} : Finset \u03b1)\u207b\u00b9 = {a\u207b\u00b9}", "start": [248, 1], "end": [250, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_insert", "code": "@[to_additive (attr := simp)]\ntheorem inv_insert (a : \u03b1) (s : Finset \u03b1) : (insert a s)\u207b\u00b9 = insert a\u207b\u00b9 s\u207b\u00b9", "start": [254, 1], "end": [256, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_inv", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_inv : \u2191s\u207b\u00b9 = (s : Set \u03b1)\u207b\u00b9", "start": [268, 1], "end": [270, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.card_inv", "code": "@[to_additive (attr := simp)]\ntheorem card_inv : s\u207b\u00b9.card = s.card", "start": [274, 1], "end": [276, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_inv", "code": "@[to_additive (attr := simp)]\ntheorem preimage_inv : s.preimage Inv.inv (inv_injective.injOn _) = s\u207b\u00b9", "start": [280, 1], "end": [282, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.mul", "code": "@[to_additive\n      \"The pointwise addition of finsets `s + t` is defined as `{x + y | x \u2208 s, y \u2208 t}` in\n      locale `Pointwise`.\"]\nprotected def mul : Mul (Finset \u03b1) :=\n  \u27e8image\u2082 (\u00b7 * \u00b7)\u27e9", "start": [296, 1], "end": [302, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_def", "code": "@[to_additive]\ntheorem mul_def : s * t = (s \u00d7\u02e2 t).image fun p : \u03b1 \u00d7 \u03b1 => p.1 * p.2", "start": [308, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul_product", "code": "@[to_additive]\ntheorem image_mul_product : ((s \u00d7\u02e2 t).image fun x : \u03b1 \u00d7 \u03b1 => x.fst * x.snd) = s * t", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_mul", "code": "@[to_additive]\ntheorem mem_mul {x : \u03b1} : x \u2208 s * t \u2194 \u2203 y z, y \u2208 s \u2227 z \u2208 t \u2227 y * z = x", "start": [320, 1], "end": [322, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_mul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_mul (s t : Finset \u03b1) : (\u2191(s * t) : Set \u03b1) = \u2191s * \u2191t", "start": [326, 1], "end": [328, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_mem_mul", "code": "@[to_additive]\ntheorem mul_mem_mul : a \u2208 s \u2192 b \u2208 t \u2192 a * b \u2208 s * t", "start": [332, 1], "end": [334, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_le", "code": "@[to_additive]\ntheorem card_mul_le : (s * t).card \u2264 s.card * t.card", "start": [338, 1], "end": [340, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_iff", "code": "@[to_additive]\ntheorem card_mul_iff :\n    (s * t).card = s.card * t.card \u2194 (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b1)).InjOn fun p => p.1 * p.2", "start": [344, 1], "end": [347, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_mul", "code": "@[to_additive (attr := simp)]\ntheorem empty_mul (s : Finset \u03b1) : \u2205 * s = \u2205", "start": [351, 1], "end": [353, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_empty", "code": "@[to_additive (attr := simp)]\ntheorem mul_empty (s : Finset \u03b1) : s * \u2205 = \u2205", "start": [357, 1], "end": [359, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq_empty : s * t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [363, 1], "end": [365, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem mul_nonempty : (s * t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [369, 1], "end": [371, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.mul", "code": "@[to_additive]\ntheorem Nonempty.mul : s.Nonempty \u2192 t.Nonempty \u2192 (s * t).Nonempty", "start": [375, 1], "end": [377, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_mul_left", "code": "@[to_additive]\ntheorem Nonempty.of_mul_left : (s * t).Nonempty \u2192 s.Nonempty", "start": [381, 1], "end": [383, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_mul_right", "code": "@[to_additive]\ntheorem Nonempty.of_mul_right : (s * t).Nonempty \u2192 t.Nonempty", "start": [387, 1], "end": [389, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_singleton", "code": "@[to_additive]\ntheorem mul_singleton (a : \u03b1) : s * {a} = s.image (\u00b7 * a)", "start": [393, 1], "end": [395, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_mul", "code": "@[to_additive]\ntheorem singleton_mul (a : \u03b1) : {a} * s = s.image ((\u00b7 * \u00b7) a)", "start": [399, 1], "end": [401, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_mul_singleton", "code": "@[to_additive (attr := simp)]\ntheorem singleton_mul_singleton (a b : \u03b1) : ({a} : Finset \u03b1) * {b} = {a * b}", "start": [405, 1], "end": [407, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_mul", "code": "@[to_additive (attr := mono)]\ntheorem mul_subset_mul : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 * t\u2081 \u2286 s\u2082 * t\u2082", "start": [411, 1], "end": [413, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_mul_left", "code": "@[to_additive]\ntheorem mul_subset_mul_left : t\u2081 \u2286 t\u2082 \u2192 s * t\u2081 \u2286 s * t\u2082", "start": [417, 1], "end": [419, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_mul_right", "code": "@[to_additive]\ntheorem mul_subset_mul_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 * t \u2286 s\u2082 * t", "start": [423, 1], "end": [425, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_iff", "code": "@[to_additive]\ntheorem mul_subset_iff : s * t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x * y \u2208 u", "start": [429, 1], "end": [431, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.union_mul", "code": "@[to_additive]\ntheorem union_mul : (s\u2081 \u222a s\u2082) * t = s\u2081 * t \u222a s\u2082 * t", "start": [435, 1], "end": [437, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_union", "code": "@[to_additive]\ntheorem mul_union : s * (t\u2081 \u222a t\u2082) = s * t\u2081 \u222a s * t\u2082", "start": [441, 1], "end": [443, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_mul_subset", "code": "@[to_additive]\ntheorem inter_mul_subset : s\u2081 \u2229 s\u2082 * t \u2286 s\u2081 * t \u2229 (s\u2082 * t)", "start": [447, 1], "end": [449, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_inter_subset", "code": "@[to_additive]\ntheorem mul_inter_subset : s * (t\u2081 \u2229 t\u2082) \u2286 s * t\u2081 \u2229 (s * t\u2082)", "start": [453, 1], "end": [455, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_mul_union_subset_union", "code": "@[to_additive]\ntheorem inter_mul_union_subset_union : s\u2081 \u2229 s\u2082 * (t\u2081 \u222a t\u2082) \u2286 s\u2081 * t\u2081 \u222a s\u2082 * t\u2082", "start": [459, 1], "end": [461, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_mul_inter_subset_union", "code": "@[to_additive]\ntheorem union_mul_inter_subset_union : (s\u2081 \u222a s\u2082) * (t\u2081 \u2229 t\u2082) \u2286 s\u2081 * t\u2081 \u222a s\u2082 * t\u2082", "start": [465, 1], "end": [467, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_mul", "code": "@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s + t`, we can find two finsets\n      `s'`, `t'` such that `s' \u2286 s`, `t' \u2286 t` and `u \u2286 s' + t'`.\"]\ntheorem subset_mul {s t : Set \u03b1} :\n    \u2191u \u2286 s * t \u2192 \u2203 s' t' : Finset \u03b1, \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' * t'", "start": [471, 1], "end": [478, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul", "code": "@[to_additive]\ntheorem image_mul : (s * t).image (f : \u03b1 \u2192 \u03b2) = s.image f * t.image f", "start": [482, 1], "end": [484, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonMulHom", "code": "@[to_additive \"The singleton operation as an `AddHom`.\"]\ndef singletonMulHom : \u03b1 \u2192\u2099* Finset \u03b1 where\n  toFun := singleton; map_mul' _ _ := (singleton_mul_singleton _ _).symm", "start": [488, 1], "end": [491, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_singletonMulHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonMulHom : (singletonMulHom : \u03b1 \u2192 Finset \u03b1) = singleton", "start": [495, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonMulHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem singletonMulHom_apply (a : \u03b1) : singletonMulHom a = {a}", "start": [501, 1], "end": [503, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.imageMulHom", "code": "@[to_additive (attr := simps) \"Lift an `AddHom` to `Finset` via `image`\"]\ndef imageMulHom : Finset \u03b1 \u2192\u2099* Finset \u03b2 where\n  toFun := Finset.image f\n  map_mul' _ _ := image_mul _", "start": [507, 1], "end": [511, 30], "kind": "commanddeclaration"}, {"full_name": "Finset.div", "code": "@[to_additive\n      \"The pointwise subtraction of finsets `s - t` is defined as `{x - y | x \u2208 s, y \u2208 t}`\n      in locale `Pointwise`.\"]\nprotected def div : Div (Finset \u03b1) :=\n  \u27e8image\u2082 (\u00b7 / \u00b7)\u27e9", "start": [524, 1], "end": [530, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.div_def", "code": "@[to_additive]\ntheorem div_def : s / t = (s \u00d7\u02e2 t).image fun p : \u03b1 \u00d7 \u03b1 => p.1 / p.2", "start": [536, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_div_prod", "code": "@[to_additive add_image_prod]\ntheorem image_div_prod : ((s \u00d7\u02e2 t).image fun x : \u03b1 \u00d7 \u03b1 => x.fst / x.snd) = s / t", "start": [542, 1], "end": [544, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_div", "code": "@[to_additive]\ntheorem mem_div : a \u2208 s / t \u2194 \u2203 b c, b \u2208 s \u2227 c \u2208 t \u2227 b / c = a", "start": [548, 1], "end": [550, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_div", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_div (s t : Finset \u03b1) : (\u2191(s / t) : Set \u03b1) = \u2191s / \u2191t", "start": [554, 1], "end": [556, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.div_mem_div", "code": "@[to_additive]\ntheorem div_mem_div : a \u2208 s \u2192 b \u2208 t \u2192 a / b \u2208 s / t", "start": [560, 1], "end": [562, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.div_card_le", "code": "@[to_additive]\ntheorem div_card_le : (s / t).card \u2264 s.card * t.card", "start": [566, 1], "end": [568, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_div", "code": "@[to_additive (attr := simp)]\ntheorem empty_div (s : Finset \u03b1) : \u2205 / s = \u2205", "start": [572, 1], "end": [574, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.div_empty", "code": "@[to_additive (attr := simp)]\ntheorem div_empty (s : Finset \u03b1) : s / \u2205 = \u2205", "start": [578, 1], "end": [580, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.div_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem div_eq_empty : s / t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [584, 1], "end": [586, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.div_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem div_nonempty : (s / t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [590, 1], "end": [592, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.div", "code": "@[to_additive]\ntheorem Nonempty.div : s.Nonempty \u2192 t.Nonempty \u2192 (s / t).Nonempty", "start": [596, 1], "end": [598, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_div_left", "code": "@[to_additive]\ntheorem Nonempty.of_div_left : (s / t).Nonempty \u2192 s.Nonempty", "start": [602, 1], "end": [604, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_div_right", "code": "@[to_additive]\ntheorem Nonempty.of_div_right : (s / t).Nonempty \u2192 t.Nonempty", "start": [608, 1], "end": [610, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.div_singleton", "code": "@[to_additive (attr := simp)]\ntheorem div_singleton (a : \u03b1) : s / {a} = s.image (\u00b7 / a)", "start": [614, 1], "end": [616, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_div", "code": "@[to_additive (attr := simp)]\ntheorem singleton_div (a : \u03b1) : {a} / s = s.image ((\u00b7 / \u00b7) a)", "start": [620, 1], "end": [622, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_div_singleton", "code": "@[to_additive]\ntheorem singleton_div_singleton (a b : \u03b1) : ({a} : Finset \u03b1) / {b} = {a / b}", "start": [627, 1], "end": [629, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.div_subset_div", "code": "@[to_additive (attr := mono)]\ntheorem div_subset_div : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 / t\u2081 \u2286 s\u2082 / t\u2082", "start": [633, 1], "end": [635, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.div_subset_div_left", "code": "@[to_additive]\ntheorem div_subset_div_left : t\u2081 \u2286 t\u2082 \u2192 s / t\u2081 \u2286 s / t\u2082", "start": [639, 1], "end": [641, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.div_subset_div_right", "code": "@[to_additive]\ntheorem div_subset_div_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 / t \u2286 s\u2082 / t", "start": [645, 1], "end": [647, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.div_subset_iff", "code": "@[to_additive]\ntheorem div_subset_iff : s / t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x / y \u2208 u", "start": [651, 1], "end": [653, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.union_div", "code": "@[to_additive]\ntheorem union_div : (s\u2081 \u222a s\u2082) / t = s\u2081 / t \u222a s\u2082 / t", "start": [657, 1], "end": [659, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.div_union", "code": "@[to_additive]\ntheorem div_union : s / (t\u2081 \u222a t\u2082) = s / t\u2081 \u222a s / t\u2082", "start": [663, 1], "end": [665, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_div_subset", "code": "@[to_additive]\ntheorem inter_div_subset : s\u2081 \u2229 s\u2082 / t \u2286 s\u2081 / t \u2229 (s\u2082 / t)", "start": [669, 1], "end": [671, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.div_inter_subset", "code": "@[to_additive]\ntheorem div_inter_subset : s / (t\u2081 \u2229 t\u2082) \u2286 s / t\u2081 \u2229 (s / t\u2082)", "start": [675, 1], "end": [677, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_div_union_subset_union", "code": "@[to_additive]\ntheorem inter_div_union_subset_union : s\u2081 \u2229 s\u2082 / (t\u2081 \u222a t\u2082) \u2286 s\u2081 / t\u2081 \u222a s\u2082 / t\u2082", "start": [681, 1], "end": [683, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_div_inter_subset_union", "code": "@[to_additive]\ntheorem union_div_inter_subset_union : (s\u2081 \u222a s\u2082) / (t\u2081 \u2229 t\u2082) \u2286 s\u2081 / t\u2081 \u222a s\u2082 / t\u2082", "start": [687, 1], "end": [689, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_div", "code": "@[to_additive\n      \"If a finset `u` is contained in the sum of two sets `s - t`, we can find two finsets\n      `s'`, `t'` such that `s' \u2286 s`, `t' \u2286 t` and `u \u2286 s' - t'`.\"]\ntheorem subset_div {s t : Set \u03b1} :\n    \u2191u \u2286 s / t \u2192 \u2203 s' t' : Finset \u03b1, \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' / t'", "start": [693, 1], "end": [700, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.nsmul", "code": "protected def nsmul [Zero \u03b1] [Add \u03b1] : SMul \u2115 (Finset \u03b1) :=\n  \u27e8nsmulRec\u27e9", "start": [715, 1], "end": [718, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.npow", "code": "protected def npow [One \u03b1] [Mul \u03b1] : Pow (Finset \u03b1) \u2115 :=\n  \u27e8fun s n => npowRec n s\u27e9", "start": [721, 1], "end": [724, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.zsmul", "code": "protected def zsmul [Zero \u03b1] [Add \u03b1] [Neg \u03b1] : SMul \u2124 (Finset \u03b1) :=\n  \u27e8zsmulRec\u27e9", "start": [730, 1], "end": [733, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.zpow", "code": "@[to_additive existing]\nprotected def zpow [One \u03b1] [Mul \u03b1] [Inv \u03b1] : Pow (Finset \u03b1) \u2124 :=\n  \u27e8fun s n => zpowRec n s\u27e9", "start": [736, 1], "end": [740, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.semigroup", "code": "@[to_additive \"`Finset \u03b1` is an `AddSemigroup` under pointwise operations if `\u03b1` is. \"]\nprotected def semigroup [Semigroup \u03b1] : Semigroup (Finset \u03b1) :=\n  coe_injective.semigroup _ coe_mul", "start": [745, 1], "end": [748, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.commSemigroup", "code": "@[to_additive \"`Finset \u03b1` is an `AddCommSemigroup` under pointwise operations if `\u03b1` is. \"]\nprotected def commSemigroup : CommSemigroup (Finset \u03b1) :=\n  coe_injective.commSemigroup _ coe_mul", "start": [756, 1], "end": [759, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_mul_union_subset", "code": "@[to_additive]\ntheorem inter_mul_union_subset : s \u2229 t * (s \u222a t) \u2286 s * t", "start": [763, 1], "end": [765, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.union_mul_inter_subset", "code": "@[to_additive]\ntheorem union_mul_inter_subset : (s \u222a t) * (s \u2229 t) \u2286 s * t", "start": [769, 1], "end": [771, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.mulOneClass", "code": "@[to_additive \"`Finset \u03b1` is an `AddZeroClass` under pointwise operations if `\u03b1` is.\"]\nprotected def mulOneClass : MulOneClass (Finset \u03b1) :=\n  coe_injective.mulOneClass _ (coe_singleton 1) coe_mul", "start": [781, 1], "end": [784, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_mul_left", "code": "@[to_additive]\ntheorem subset_mul_left (s : Finset \u03b1) {t : Finset \u03b1} (ht : (1 : \u03b1) \u2208 t) : s \u2286 s * t", "start": [791, 1], "end": [793, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_mul_right", "code": "@[to_additive]\ntheorem subset_mul_right {s : Finset \u03b1} (t : Finset \u03b1) (hs : (1 : \u03b1) \u2208 s) : t \u2286 s * t", "start": [797, 1], "end": [799, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonMonoidHom", "code": "@[to_additive \"The singleton operation as an `AddMonoidHom`.\"]\ndef singletonMonoidHom : \u03b1 \u2192* Finset \u03b1 :=\n  { singletonMulHom, singletonOneHom with }", "start": [803, 1], "end": [806, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_singletonMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_singletonMonoidHom : (singletonMonoidHom : \u03b1 \u2192 Finset \u03b1) = singleton", "start": [810, 1], "end": [812, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.singletonMonoidHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem singletonMonoidHom_apply (a : \u03b1) : singletonMonoidHom a = {a}", "start": [816, 1], "end": [818, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.coeMonoidHom", "code": "@[to_additive \"The coercion from `Finset` to `set` as an `AddMonoidHom`.\"]\nnoncomputable def coeMonoidHom : Finset \u03b1 \u2192* Set \u03b1 where\n  toFun := CoeTC.coe\n  map_one' := coe_one\n  map_mul' := coe_mul", "start": [822, 1], "end": [827, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_coeMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_coeMonoidHom : (coeMonoidHom : Finset \u03b1 \u2192 Set \u03b1) = CoeTC.coe", "start": [831, 1], "end": [833, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.coeMonoidHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem coeMonoidHom_apply (s : Finset \u03b1) : coeMonoidHom s = s", "start": [837, 1], "end": [839, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.imageMonoidHom", "code": "@[to_additive (attr := simps) \"Lift an `add_monoid_hom` to `Finset` via `image`\"]\ndef imageMonoidHom [MulOneClass \u03b2] [MonoidHomClass F \u03b1 \u03b2] (f : F) : Finset \u03b1 \u2192* Finset \u03b2 :=\n  { imageMulHom f, imageOneHom f with }", "start": [843, 1], "end": [846, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_pow", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_pow (s : Finset \u03b1) (n : \u2115) : \u2191(s ^ n) = (s : Set \u03b1) ^ n", "start": [856, 1], "end": [861, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.monoid", "code": "@[to_additive \"`Finset \u03b1` is an `AddMonoid` under pointwise operations if `\u03b1` is. \"]\nprotected def monoid : Monoid (Finset \u03b1) :=\n  coe_injective.monoid _ coe_one coe_mul coe_pow", "start": [864, 1], "end": [867, 49], "kind": "commanddeclaration"}, {"full_name": "Finset.pow_mem_pow", "code": "@[to_additive]\ntheorem pow_mem_pow (ha : a \u2208 s) : \u2200 n : \u2115, a ^ n \u2208 s ^ n", "start": [873, 1], "end": [880, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.pow_subset_pow", "code": "@[to_additive]\ntheorem pow_subset_pow (hst : s \u2286 t) : \u2200 n : \u2115, s ^ n \u2286 t ^ n", "start": [884, 1], "end": [890, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.pow_subset_pow_of_one_mem", "code": "@[to_additive]\ntheorem pow_subset_pow_of_one_mem (hs : (1 : \u03b1) \u2208 s) : m \u2264 n \u2192 s ^ m \u2286 s ^ n", "start": [894, 1], "end": [900, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_list_prod", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_list_prod (s : List (Finset \u03b1)) : (\u2191s.prod : Set \u03b1) = (s.map (\u2191)).prod", "start": [904, 1], "end": [906, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_prod_list_ofFn", "code": "@[to_additive]\ntheorem mem_prod_list_ofFn {a : \u03b1} {s : Fin n \u2192 Finset \u03b1} :\n    a \u2208 (List.ofFn s).prod \u2194 \u2203 f : \u2200 i : Fin n, s i, (List.ofFn fun i => (f i : \u03b1)).prod = a", "start": [910, 1], "end": [914, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_pow", "code": "@[to_additive]\ntheorem mem_pow {a : \u03b1} {n : \u2115} :\n    a \u2208 s ^ n \u2194 \u2203 f : Fin n \u2192 s, (List.ofFn fun i => \u2191(f i)).prod = a", "start": [918, 1], "end": [921, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_pow", "code": "@[to_additive (attr := simp)]\ntheorem empty_pow (hn : n \u2260 0) : (\u2205 : Finset \u03b1) ^ n = \u2205", "start": [925, 1], "end": [927, 97], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_univ_of_one_mem", "code": "@[to_additive]\ntheorem mul_univ_of_one_mem [Fintype \u03b1] (hs : (1 : \u03b1) \u2208 s) : s * univ = univ", "start": [931, 1], "end": [933, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_mul_of_one_mem", "code": "@[to_additive]\ntheorem univ_mul_of_one_mem [Fintype \u03b1] (ht : (1 : \u03b1) \u2208 t) : univ * t = univ", "start": [937, 1], "end": [939, 76], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_mul_univ", "code": "@[to_additive (attr := simp)]\ntheorem univ_mul_univ [Fintype \u03b1] : (univ : Finset \u03b1) * univ = univ", "start": [943, 1], "end": [945, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.univ_pow", "code": "@[to_additive (attr := simp) nsmul_univ]\ntheorem univ_pow [Fintype \u03b1] (hn : n \u2260 0) : (univ : Finset \u03b1) ^ n = univ", "start": [949, 1], "end": [951, 62], "kind": "commanddeclaration"}, {"full_name": "IsUnit.finset", "code": "@[to_additive]\nprotected theorem _root_.IsUnit.finset : IsUnit a \u2192 IsUnit ({a} : Finset \u03b1)", "start": [955, 1], "end": [957, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.commMonoid", "code": "@[to_additive \"`Finset \u03b1` is an `AddCommMonoid` under pointwise operations if `\u03b1` is. \"]\nprotected def commMonoid : CommMonoid (Finset \u03b1) :=\n  coe_injective.commMonoid _ coe_one coe_mul coe_pow", "start": [967, 1], "end": [970, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_prod", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_prod {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 Finset \u03b1) :\n    \u2191(\u220f i in s, f i) = \u220f i in s, (f i : Set \u03b1)", "start": [976, 1], "end": [979, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_zpow", "code": "@[to_additive (attr := simp)]\ntheorem coe_zpow (s : Finset \u03b1) : \u2200 n : \u2124, \u2191(s ^ n) = (s : Set \u03b1) ^ n", "start": [991, 1], "end": [996, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_eq_one_iff", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff : s * t = 1 \u2194 \u2203 a b, s = {a} \u2227 t = {b} \u2227 a * b = 1", "start": [1000, 1], "end": [1002, 75], "kind": "commanddeclaration"}, {"full_name": "Finset.divisionMonoid", "code": "@[to_additive subtractionMonoid\n  \"`Finset \u03b1` is a subtraction monoid under pointwise operations if `\u03b1` is.\"]\nprotected def divisionMonoid : DivisionMonoid (Finset \u03b1) :=\n  coe_injective.divisionMonoid _ coe_one coe_mul coe_inv coe_div coe_pow coe_zpow", "start": [1006, 1], "end": [1010, 82], "kind": "commanddeclaration"}, {"full_name": "Finset.isUnit_iff", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_iff : IsUnit s \u2194 \u2203 a, s = {a} \u2227 IsUnit a", "start": [1014, 1], "end": [1023, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.isUnit_coe", "code": "@[to_additive (attr := simp)]\ntheorem isUnit_coe : IsUnit (s : Set \u03b1) \u2194 IsUnit s", "start": [1027, 1], "end": [1029, 57], "kind": "commanddeclaration"}, {"full_name": "Finset.divisionCommMonoid", "code": "@[to_additive subtractionCommMonoid\n      \"`Finset \u03b1` is a commutative subtraction monoid under pointwise operations if `\u03b1` is.\"]\nprotected def divisionCommMonoid [DivisionCommMonoid \u03b1] : DivisionCommMonoid (Finset \u03b1) :=\n  coe_injective.divisionCommMonoid _ coe_one coe_mul coe_inv coe_div coe_pow coe_zpow", "start": [1035, 1], "end": [1039, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.distribNeg", "code": "protected def distribNeg [Mul \u03b1] [HasDistribNeg \u03b1] : HasDistribNeg (Finset \u03b1) :=\n  coe_injective.hasDistribNeg _ coe_neg coe_mul", "start": [1043, 1], "end": [1045, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_add_subset", "code": "theorem mul_add_subset : s * (t + u) \u2286 s * t + s * u", "start": [1071, 1], "end": [1072, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.add_mul_subset", "code": "theorem add_mul_subset : (s + t) * u \u2286 s * u + t * u", "start": [1075, 1], "end": [1076, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_zero_subset", "code": "theorem mul_zero_subset (s : Finset \u03b1) : s * 0 \u2286 0", "start": [1088, 1], "end": [1088, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_mul_subset", "code": "theorem zero_mul_subset (s : Finset \u03b1) : 0 * s \u2286 0", "start": [1091, 1], "end": [1091, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.mul_zero", "code": "theorem Nonempty.mul_zero (hs : s.Nonempty) : s * 0 = 0", "start": [1094, 1], "end": [1095, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.zero_mul", "code": "theorem Nonempty.zero_mul (hs : s.Nonempty) : 0 * s = 0", "start": [1098, 1], "end": [1099, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.one_mem_div_iff", "code": "@[to_additive (attr := simp)]\ntheorem one_mem_div_iff : (1 : \u03b1) \u2208 s / t \u2194 \u00acDisjoint s t", "start": [1111, 1], "end": [1113, 63], "kind": "commanddeclaration"}, {"full_name": "Finset.not_one_mem_div_iff", "code": "@[to_additive]\ntheorem not_one_mem_div_iff : (1 : \u03b1) \u2209 s / t \u2194 Disjoint s t", "start": [1117, 1], "end": [1119, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.one_mem_div", "code": "@[to_additive]\ntheorem Nonempty.one_mem_div (h : s.Nonempty) : (1 : \u03b1) \u2208 s / s", "start": [1123, 1], "end": [1126, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.isUnit_singleton", "code": "@[to_additive]\ntheorem isUnit_singleton (a : \u03b1) : IsUnit ({a} : Finset \u03b1)", "start": [1130, 1], "end": [1132, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.isUnit_iff_singleton", "code": "theorem isUnit_iff_singleton : IsUnit s \u2194 \u2203 a, s = {a}", "start": [1142, 1], "end": [1143, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.isUnit_iff_singleton_aux", "code": "@[simp]\ntheorem isUnit_iff_singleton_aux : (\u2203 a, s = {a} \u2227 IsUnit a) \u2194 \u2203 a, s = {a}", "start": [1146, 1], "end": [1148, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul_left", "code": "@[to_additive (attr := simp)]\ntheorem image_mul_left :\n    image (fun b => a * b) t = preimage t (fun b => a\u207b\u00b9 * b) ((mul_right_injective _).injOn _)", "start": [1150, 1], "end": [1153, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul_right", "code": "@[to_additive (attr := simp)]\ntheorem image_mul_right : image (\u00b7 * b) t = preimage t (\u00b7 * b\u207b\u00b9) ((mul_left_injective _).injOn _)", "start": [1157, 1], "end": [1159, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul_left'", "code": "@[to_additive]\ntheorem image_mul_left' :\n    image (fun b => a\u207b\u00b9 * b) t = preimage t (fun b => a * b) ((mul_right_injective _).injOn _)", "start": [1163, 1], "end": [1166, 7], "kind": "commanddeclaration"}, {"full_name": "Finset.image_mul_right'", "code": "@[to_additive]\ntheorem image_mul_right' :\n    image (\u00b7 * b\u207b\u00b9) t = preimage t (\u00b7 * b) ((mul_left_injective _).injOn _)", "start": [1170, 1], "end": [1172, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.image_div", "code": "theorem image_div : (s / t).image (f : \u03b1 \u2192 \u03b2) = s.image f / t.image f", "start": [1176, 1], "end": [1177, 36], "kind": "commanddeclaration"}, {"full_name": "Finset.div_zero_subset", "code": "theorem div_zero_subset (s : Finset \u03b1) : s / 0 \u2286 0", "start": [1186, 1], "end": [1186, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_div_subset", "code": "theorem zero_div_subset (s : Finset \u03b1) : 0 / s \u2286 0", "start": [1189, 1], "end": [1189, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.div_zero", "code": "theorem Nonempty.div_zero (hs : s.Nonempty) : s / 0 = 0", "start": [1192, 1], "end": [1193, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.zero_div", "code": "theorem Nonempty.zero_div (hs : s.Nonempty) : 0 / s = 0", "start": [1196, 1], "end": [1197, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_left_singleton", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_singleton :\n    preimage {b} ((\u00b7 * \u00b7) a) ((mul_right_injective _).injOn _) = {a\u207b\u00b9 * b}", "start": [1208, 1], "end": [1211, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_right_singleton", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_singleton :\n    preimage {b} (\u00b7 * a) ((mul_left_injective _).injOn _) = {b * a\u207b\u00b9}", "start": [1215, 1], "end": [1218, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_left_one", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_left_one : preimage 1 ((\u00b7 * \u00b7) a) ((mul_right_injective _).injOn _) = {a\u207b\u00b9}", "start": [1222, 1], "end": [1224, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_right_one", "code": "@[to_additive (attr := simp)]\ntheorem preimage_mul_right_one : preimage 1 (\u00b7 * b) ((mul_left_injective _).injOn _) = {b\u207b\u00b9}", "start": [1228, 1], "end": [1230, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_left_one'", "code": "@[to_additive]\ntheorem preimage_mul_left_one' : preimage 1 ((\u00b7 * \u00b7) a\u207b\u00b9) ((mul_right_injective _).injOn _) = {a}", "start": [1234, 1], "end": [1236, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.preimage_mul_right_one'", "code": "@[to_additive]\ntheorem preimage_mul_right_one' : preimage 1 (\u00b7 * b\u207b\u00b9) ((mul_left_injective _).injOn _) = {b}", "start": [1240, 1], "end": [1242, 39], "kind": "commanddeclaration"}, {"full_name": "Finset.smul", "code": "@[to_additive \"The pointwise sum of two finsets `s` and `t`: `s +\u1d65 t = {x +\u1d65 y | x \u2208 s, y \u2208 t}`.\"]\nprotected def smul : SMul (Finset \u03b1) (Finset \u03b2) :=\n  \u27e8image\u2082 (\u00b7 \u2022 \u00b7)\u27e9", "start": [1255, 1], "end": [1258, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_def", "code": "@[to_additive]\ntheorem smul_def : s \u2022 t = (s \u00d7\u02e2 t).image fun p : \u03b1 \u00d7 \u03b2 => p.1 \u2022 p.2", "start": [1264, 1], "end": [1266, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_smul_product", "code": "@[to_additive]\ntheorem image_smul_product : ((s \u00d7\u02e2 t).image fun x : \u03b1 \u00d7 \u03b2 => x.fst \u2022 x.snd) = s \u2022 t", "start": [1270, 1], "end": [1272, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_smul", "code": "@[to_additive]\ntheorem mem_smul {x : \u03b2} : x \u2208 s \u2022 t \u2194 \u2203 y z, y \u2208 s \u2227 z \u2208 t \u2227 y \u2022 z = x", "start": [1276, 1], "end": [1278, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_smul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul (s : Finset \u03b1) (t : Finset \u03b2) : \u2191(s \u2022 t) = (s : Set \u03b1) \u2022 (t : Set \u03b2)", "start": [1282, 1], "end": [1284, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_mem_smul", "code": "@[to_additive]\ntheorem smul_mem_smul : a \u2208 s \u2192 b \u2208 t \u2192 a \u2022 b \u2208 s \u2022 t", "start": [1288, 1], "end": [1290, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_card_le", "code": "@[to_additive]\ntheorem smul_card_le : (s \u2022 t).card \u2264 s.card \u2022 t.card", "start": [1294, 1], "end": [1296, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_smul", "code": "@[to_additive (attr := simp)]\ntheorem empty_smul (t : Finset \u03b2) : (\u2205 : Finset \u03b1) \u2022 t = \u2205", "start": [1300, 1], "end": [1302, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_empty (s : Finset \u03b1) : s \u2022 (\u2205 : Finset \u03b2) = \u2205", "start": [1306, 1], "end": [1308, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_eq_empty : s \u2022 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [1312, 1], "end": [1314, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_nonempty_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_nonempty_iff : (s \u2022 t).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [1318, 1], "end": [1320, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.smul", "code": "@[to_additive]\ntheorem Nonempty.smul : s.Nonempty \u2192 t.Nonempty \u2192 (s \u2022 t).Nonempty", "start": [1324, 1], "end": [1326, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_smul_left", "code": "@[to_additive]\ntheorem Nonempty.of_smul_left : (s \u2022 t).Nonempty \u2192 s.Nonempty", "start": [1330, 1], "end": [1332, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_smul_right", "code": "@[to_additive]\ntheorem Nonempty.of_smul_right : (s \u2022 t).Nonempty \u2192 t.Nonempty", "start": [1336, 1], "end": [1338, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_singleton", "code": "@[to_additive]\ntheorem smul_singleton (b : \u03b2) : s \u2022 ({b} : Finset \u03b2) = s.image (\u00b7 \u2022 b)", "start": [1342, 1], "end": [1344, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_smul_singleton", "code": "@[to_additive]\ntheorem singleton_smul_singleton (a : \u03b1) (b : \u03b2) : ({a} : Finset \u03b1) \u2022 ({b} : Finset \u03b2) = {a \u2022 b}", "start": [1348, 1], "end": [1350, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_subset_smul", "code": "@[to_additive (attr := mono)]\ntheorem smul_subset_smul : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 \u2022 t\u2081 \u2286 s\u2082 \u2022 t\u2082", "start": [1354, 1], "end": [1356, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_subset_smul_left", "code": "@[to_additive]\ntheorem smul_subset_smul_left : t\u2081 \u2286 t\u2082 \u2192 s \u2022 t\u2081 \u2286 s \u2022 t\u2082", "start": [1360, 1], "end": [1362, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_subset_smul_right", "code": "@[to_additive]\ntheorem smul_subset_smul_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 \u2022 t \u2286 s\u2082 \u2022 t", "start": [1366, 1], "end": [1368, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_subset_iff", "code": "@[to_additive]\ntheorem smul_subset_iff : s \u2022 t \u2286 u \u2194 \u2200 a \u2208 s, \u2200 b \u2208 t, a \u2022 b \u2208 u", "start": [1372, 1], "end": [1374, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.union_smul", "code": "@[to_additive]\ntheorem union_smul [DecidableEq \u03b1] : (s\u2081 \u222a s\u2082) \u2022 t = s\u2081 \u2022 t \u222a s\u2082 \u2022 t", "start": [1378, 1], "end": [1380, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_union", "code": "@[to_additive]\ntheorem smul_union : s \u2022 (t\u2081 \u222a t\u2082) = s \u2022 t\u2081 \u222a s \u2022 t\u2082", "start": [1384, 1], "end": [1386, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_smul_subset", "code": "@[to_additive]\ntheorem inter_smul_subset [DecidableEq \u03b1] : (s\u2081 \u2229 s\u2082) \u2022 t \u2286 s\u2081 \u2022 t \u2229 s\u2082 \u2022 t", "start": [1390, 1], "end": [1392, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_inter_subset", "code": "@[to_additive]\ntheorem smul_inter_subset : s \u2022 (t\u2081 \u2229 t\u2082) \u2286 s \u2022 t\u2081 \u2229 s \u2022 t\u2082", "start": [1396, 1], "end": [1398, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_smul_union_subset_union", "code": "@[to_additive]\ntheorem inter_smul_union_subset_union [DecidableEq \u03b1] : (s\u2081 \u2229 s\u2082) \u2022 (t\u2081 \u222a t\u2082) \u2286 s\u2081 \u2022 t\u2081 \u222a s\u2082 \u2022 t\u2082", "start": [1402, 1], "end": [1404, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.union_smul_inter_subset_union", "code": "@[to_additive]\ntheorem union_smul_inter_subset_union [DecidableEq \u03b1] : (s\u2081 \u222a s\u2082) \u2022 (t\u2081 \u2229 t\u2082) \u2286 s\u2081 \u2022 t\u2081 \u222a s\u2082 \u2022 t\u2082", "start": [1408, 1], "end": [1410, 34], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_smul", "code": "@[to_additive\n      \"If a finset `u` is contained in the scalar sum of two sets `s +\u1d65 t`, we can find two\n      finsets `s'`, `t'` such that `s' \u2286 s`, `t' \u2286 t` and `u \u2286 s' +\u1d65 t'`.\"]\ntheorem subset_smul {s : Set \u03b1} {t : Set \u03b2} :\n    \u2191u \u2286 s \u2022 t \u2192 \u2203 (s' : Finset \u03b1) (t' : Finset \u03b2), \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' \u2022 t'", "start": [1414, 1], "end": [1421, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub", "code": "protected def vsub : VSub (Finset \u03b1) (Finset \u03b2) :=\n  \u27e8image\u2082 (\u00b7 -\u1d65 \u00b7)\u27e9", "start": [1435, 1], "end": [1437, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_def", "code": "theorem vsub_def : s -\u1d65 t = image\u2082 (\u00b7 -\u1d65 \u00b7) s t", "start": [1442, 1], "end": [1443, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_vsub_product", "code": "@[simp]\ntheorem image_vsub_product : image\u2082 (\u00b7 -\u1d65 \u00b7) s t = s -\u1d65 t", "start": [1446, 1], "end": [1448, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_vsub", "code": "theorem mem_vsub : a \u2208 s -\u1d65 t \u2194 \u2203 b c, b \u2208 s \u2227 c \u2208 t \u2227 b -\u1d65 c = a", "start": [1451, 1], "end": [1452, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_vsub", "code": "@[simp, norm_cast]\ntheorem coe_vsub (s t : Finset \u03b2) : (\u2191(s -\u1d65 t) : Set \u03b1) = (s : Set \u03b2) -\u1d65 t", "start": [1455, 1], "end": [1457, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_mem_vsub", "code": "theorem vsub_mem_vsub : b \u2208 s \u2192 c \u2208 t \u2192 b -\u1d65 c \u2208 s -\u1d65 t", "start": [1460, 1], "end": [1461, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_card_le", "code": "theorem vsub_card_le : (s -\u1d65 t : Finset \u03b1).card \u2264 s.card * t.card", "start": [1464, 1], "end": [1465, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.empty_vsub", "code": "@[simp]\ntheorem empty_vsub (t : Finset \u03b2) : (\u2205 : Finset \u03b2) -\u1d65 t = \u2205", "start": [1468, 1], "end": [1470, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_empty", "code": "@[simp]\ntheorem vsub_empty (s : Finset \u03b2) : s -\u1d65 (\u2205 : Finset \u03b2) = \u2205", "start": [1473, 1], "end": [1475, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_eq_empty", "code": "@[simp]\ntheorem vsub_eq_empty : s -\u1d65 t = \u2205 \u2194 s = \u2205 \u2228 t = \u2205", "start": [1478, 1], "end": [1480, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_nonempty", "code": "@[simp]\ntheorem vsub_nonempty : (s -\u1d65 t : Finset \u03b1).Nonempty \u2194 s.Nonempty \u2227 t.Nonempty", "start": [1483, 1], "end": [1485, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.vsub", "code": "theorem Nonempty.vsub : s.Nonempty \u2192 t.Nonempty \u2192 (s -\u1d65 t : Finset \u03b1).Nonempty", "start": [1488, 1], "end": [1489, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_vsub_left", "code": "theorem Nonempty.of_vsub_left : (s -\u1d65 t : Finset \u03b1).Nonempty \u2192 s.Nonempty", "start": [1492, 1], "end": [1493, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.of_vsub_right", "code": "theorem Nonempty.of_vsub_right : (s -\u1d65 t : Finset \u03b1).Nonempty \u2192 t.Nonempty", "start": [1496, 1], "end": [1497, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_singleton", "code": "@[simp]\ntheorem vsub_singleton (b : \u03b2) : s -\u1d65 ({b} : Finset \u03b2) = s.image (\u00b7 -\u1d65 b)", "start": [1500, 1], "end": [1502, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_vsub", "code": "theorem singleton_vsub (a : \u03b2) : ({a} : Finset \u03b2) -\u1d65 t = t.image ((\u00b7 -\u1d65 \u00b7) a)", "start": [1505, 1], "end": [1506, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_vsub_singleton", "code": "theorem singleton_vsub_singleton (a b : \u03b2) : ({a} : Finset \u03b2) -\u1d65 {b} = {a -\u1d65 b}", "start": [1510, 1], "end": [1511, 19], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_subset_vsub", "code": "@[mono]\ntheorem vsub_subset_vsub : s\u2081 \u2286 s\u2082 \u2192 t\u2081 \u2286 t\u2082 \u2192 s\u2081 -\u1d65 t\u2081 \u2286 s\u2082 -\u1d65 t\u2082", "start": [1514, 1], "end": [1516, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_subset_vsub_left", "code": "theorem vsub_subset_vsub_left : t\u2081 \u2286 t\u2082 \u2192 s -\u1d65 t\u2081 \u2286 s -\u1d65 t\u2082", "start": [1519, 1], "end": [1520, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_subset_vsub_right", "code": "theorem vsub_subset_vsub_right : s\u2081 \u2286 s\u2082 \u2192 s\u2081 -\u1d65 t \u2286 s\u2082 -\u1d65 t", "start": [1523, 1], "end": [1524, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_subset_iff", "code": "theorem vsub_subset_iff : s -\u1d65 t \u2286 u \u2194 \u2200 x \u2208 s, \u2200 y \u2208 t, x -\u1d65 y \u2208 u", "start": [1527, 1], "end": [1528, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.union_vsub", "code": "theorem union_vsub : s\u2081 \u222a s\u2082 -\u1d65 t = s\u2081 -\u1d65 t \u222a (s\u2082 -\u1d65 t)", "start": [1535, 1], "end": [1536, 20], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_union", "code": "theorem vsub_union : s -\u1d65 (t\u2081 \u222a t\u2082) = s -\u1d65 t\u2081 \u222a (s -\u1d65 t\u2082)", "start": [1539, 1], "end": [1540, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_vsub_subset", "code": "theorem inter_vsub_subset : s\u2081 \u2229 s\u2082 -\u1d65 t \u2286 (s\u2081 -\u1d65 t) \u2229 (s\u2082 -\u1d65 t)", "start": [1543, 1], "end": [1544, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.vsub_inter_subset", "code": "theorem vsub_inter_subset : s -\u1d65 t\u2081 \u2229 t\u2082 \u2286 (s -\u1d65 t\u2081) \u2229 (s -\u1d65 t\u2082)", "start": [1547, 1], "end": [1548, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_vsub", "code": "theorem subset_vsub {s t : Set \u03b2} :\n    \u2191u \u2286 s -\u1d65 t \u2192 \u2203 s' t' : Finset \u03b2, \u2191s' \u2286 s \u2227 \u2191t' \u2286 t \u2227 u \u2286 s' -\u1d65 t'", "start": [1553, 1], "end": [1557, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.smulFinset", "code": "@[to_additive \"The translation of a finset `s` by a vector `a`: `a +\u1d65 s = {a +\u1d65 x | x \u2208 s}`.\"]\nprotected def smulFinset : SMul \u03b1 (Finset \u03b2) :=\n  \u27e8fun a => image <| (\u00b7 \u2022 \u00b7) a\u27e9", "start": [1571, 1], "end": [1574, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_def", "code": "@[to_additive]\ntheorem smul_finset_def : a \u2022 s = s.image ((\u00b7 \u2022 \u00b7) a)", "start": [1580, 1], "end": [1582, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.image_smul", "code": "@[to_additive]\ntheorem image_smul : (s.image fun x => a \u2022 x) = a \u2022 s", "start": [1586, 1], "end": [1588, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_smul_finset", "code": "@[to_additive]\ntheorem mem_smul_finset {x : \u03b2} : x \u2208 a \u2022 s \u2194 \u2203 y, y \u2208 s \u2227 a \u2022 y = x", "start": [1592, 1], "end": [1594, 98], "kind": "commanddeclaration"}, {"full_name": "Finset.coe_smul_finset", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul_finset (a : \u03b1) (s : Finset \u03b2) : \u2191(a \u2022 s) = a \u2022 (\u2191s : Set \u03b2)", "start": [1598, 1], "end": [1600, 12], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_mem_smul_finset", "code": "@[to_additive]\ntheorem smul_mem_smul_finset : b \u2208 s \u2192 a \u2022 b \u2208 a \u2022 s", "start": [1604, 1], "end": [1606, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_card_le", "code": "@[to_additive]\ntheorem smul_finset_card_le : (a \u2022 s).card \u2264 s.card", "start": [1610, 1], "end": [1612, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_empty (a : \u03b1) : a \u2022 (\u2205 : Finset \u03b2) = \u2205", "start": [1616, 1], "end": [1618, 16], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_eq_empty", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_eq_empty : a \u2022 s = \u2205 \u2194 s = \u2205", "start": [1622, 1], "end": [1624, 17], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_nonempty", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_nonempty : (a \u2022 s).Nonempty \u2194 s.Nonempty", "start": [1628, 1], "end": [1630, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.smul_finset", "code": "@[to_additive]\ntheorem Nonempty.smul_finset (hs : s.Nonempty) : (a \u2022 s).Nonempty", "start": [1634, 1], "end": [1636, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_smul", "code": "@[to_additive (attr := simp)]\ntheorem singleton_smul (a : \u03b1) : ({a} : Finset \u03b1) \u2022 t = a \u2022 t", "start": [1640, 1], "end": [1642, 24], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_smul_finset", "code": "@[to_additive (attr := mono)]\ntheorem smul_finset_subset_smul_finset : s \u2286 t \u2192 a \u2022 s \u2286 a \u2022 t", "start": [1646, 1], "end": [1648, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_singleton", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_singleton (b : \u03b2) : a \u2022 ({b} : Finset \u03b2) = {a \u2022 b}", "start": [1652, 1], "end": [1654, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_union", "code": "@[to_additive]\ntheorem smul_finset_union : a \u2022 (s\u2081 \u222a s\u2082) = a \u2022 s\u2081 \u222a a \u2022 s\u2082", "start": [1658, 1], "end": [1660, 18], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_inter_subset", "code": "@[to_additive]\ntheorem smul_finset_inter_subset : a \u2022 (s\u2081 \u2229 s\u2082) \u2286 a \u2022 s\u2081 \u2229 a \u2022 s\u2082", "start": [1664, 1], "end": [1666, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_smul", "code": "@[to_additive]\ntheorem smul_finset_subset_smul {s : Finset \u03b1} : a \u2208 s \u2192 a \u2022 t \u2286 s \u2022 t", "start": [1670, 1], "end": [1672, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_smul_finset", "code": "@[to_additive (attr := simp)]\ntheorem biUnion_smul_finset (s : Finset \u03b1) (t : Finset \u03b2) : s.biUnion (\u00b7 \u2022 t) = s \u2022 t", "start": [1676, 1], "end": [1678, 21], "kind": "commanddeclaration"}, {"full_name": "Finset.smulCommClass_finset", "code": "@[to_additive]\ninstance smulCommClass_finset [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 \u03b2 (Finset \u03b3) :=\n  \u27e8fun _ _ => Commute.finset_image <| smul_comm _ _\u27e9", "start": [1690, 1], "end": [1693, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.smulCommClass_finset'", "code": "@[to_additive]\ninstance smulCommClass_finset' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 (Finset \u03b2) (Finset \u03b3) :=\n  \u27e8fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_comm]\u27e9", "start": [1697, 1], "end": [1700, 86], "kind": "commanddeclaration"}, {"full_name": "Finset.smulCommClass_finset''", "code": "@[to_additive]\ninstance smulCommClass_finset'' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Finset \u03b1) \u03b2 (Finset \u03b3) :=\n  haveI := SMulCommClass.symm \u03b1 \u03b2 \u03b3\n  SMulCommClass.symm _ _ _", "start": [1704, 1], "end": [1708, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Finset \u03b1) (Finset \u03b2) (Finset \u03b3) :=\n  \u27e8fun s t u => coe_injective <| by simp_rw [coe_smul, smul_comm]\u27e9", "start": [1712, 1], "end": [1715, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.isScalarTower", "code": "@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 \u03b2 (Finset \u03b3) :=\n  \u27e8fun a b s => by simp only [\u2190 image_smul, image_image, smul_assoc, Function.comp]\u27e9", "start": [1719, 1], "end": [1722, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.isScalarTower'", "code": "@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 (Finset \u03b2) (Finset \u03b3) :=\n  \u27e8fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]\u27e9", "start": [1728, 1], "end": [1731, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.isScalarTower''", "code": "@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower (Finset \u03b1) (Finset \u03b2) (Finset \u03b3) :=\n  \u27e8fun a s t => coe_injective <| by simp only [coe_smul_finset, coe_smul, smul_assoc]\u27e9", "start": [1735, 1], "end": [1738, 87], "kind": "commanddeclaration"}, {"full_name": "Finset.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar [SMul \u03b1 \u03b2] [SMul \u03b1\u1d50\u1d52\u1d56 \u03b2] [IsCentralScalar \u03b1 \u03b2] :\n    IsCentralScalar \u03b1 (Finset \u03b2) :=\n  \u27e8fun a s => coe_injective <| by simp only [coe_smul_finset, coe_smul, op_smul_eq_smul]\u27e9", "start": [1742, 1], "end": [1745, 90], "kind": "commanddeclaration"}, {"full_name": "Finset.mulAction", "code": "@[to_additive\n      \"An additive action of an additive monoid `\u03b1` on a type `\u03b2` gives an additive action\n      of `Finset \u03b1` on `Finset \u03b2`\"]\nprotected def mulAction [DecidableEq \u03b1] [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction (Finset \u03b1) (Finset \u03b2)\n    where\n  mul_smul _ _ _ := image\u2082_assoc mul_smul\n  one_smul s := image\u2082_singleton_left.trans <| by simp_rw [one_smul, image_id']", "start": [1749, 1], "end": [1757, 80], "kind": "commanddeclaration"}, {"full_name": "Finset.mulActionFinset", "code": "@[to_additive\n      \"An additive action of an additive monoid on a type `\u03b2` gives an additive action\n      on `Finset \u03b2`.\"]\nprotected def mulActionFinset [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction \u03b1 (Finset \u03b2) :=\n  coe_injective.mulAction _ coe_smul_finset", "start": [1761, 1], "end": [1767, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.distribMulActionFinset", "code": "protected def distribMulActionFinset [Monoid \u03b1] [AddMonoid \u03b2] [DistribMulAction \u03b1 \u03b2] :\n    DistribMulAction \u03b1 (Finset \u03b2) :=\n  Function.Injective.distribMulAction coeAddMonoidHom coe_injective coe_smul_finset", "start": [1775, 1], "end": [1779, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.mulDistribMulActionFinset", "code": "protected def mulDistribMulActionFinset [Monoid \u03b1] [Monoid \u03b2] [MulDistribMulAction \u03b1 \u03b2] :\n    MulDistribMulAction \u03b1 (Finset \u03b2) :=\n  Function.Injective.mulDistribMulAction coeMonoidHom coe_injective coe_smul_finset", "start": [1782, 1], "end": [1785, 84], "kind": "commanddeclaration"}, {"full_name": "Finset.noZeroSMulDivisors", "code": "instance noZeroSMulDivisors [Zero \u03b1] [Zero \u03b2] [SMul \u03b1 \u03b2] [NoZeroSMulDivisors \u03b1 \u03b2] :\n    NoZeroSMulDivisors (Finset \u03b1) (Finset \u03b2) :=\n  \u27e8by\n    intro s t h\n    by_contra H\n    have hst : (s \u2022 t).Nonempty := h.symm.subst zero_nonempty\n    rw [\u2190 hst.of_smul_left.subset_zero_iff, \u2190 hst.of_smul_right.subset_zero_iff] at H\n    push_neg at H\n    simp_rw [not_subset, mem_zero] at H\n    obtain \u27e8\u27e8a, hs, ha\u27e9, b, ht, hb\u27e9 := H\n    exact (eq_zero_or_eq_zero_of_smul_eq_zero <| mem_zero.1 <| subset_of_eq h\n      <| smul_mem_smul hs ht).elim ha hb\u27e9", "start": [1794, 1], "end": [1805, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.noZeroSMulDivisors_finset", "code": "instance noZeroSMulDivisors_finset [Zero \u03b1] [Zero \u03b2] [SMul \u03b1 \u03b2] [NoZeroSMulDivisors \u03b1 \u03b2] :\n    NoZeroSMulDivisors \u03b1 (Finset \u03b2) :=\n  Function.Injective.noZeroSMulDivisors (\u2191) coe_injective coe_zero coe_smul_finset", "start": [1807, 1], "end": [1809, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.op_smul_finset_smul_eq_smul_smul_finset", "code": "@[to_additive]\ntheorem op_smul_finset_smul_eq_smul_smul_finset (a : \u03b1) (s : Finset \u03b2) (t : Finset \u03b3)\n    (h : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), (op a \u2022 b) \u2022 c = b \u2022 a \u2022 c) : (op a \u2022 s) \u2022 t = s \u2022 a \u2022 t", "start": [1819, 1], "end": [1823, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.op_smul_finset_subset_mul", "code": "@[to_additive]\ntheorem op_smul_finset_subset_mul : a \u2208 t \u2192 op a \u2022 s \u2286 s * t", "start": [1833, 1], "end": [1835, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.biUnion_op_smul_finset", "code": "@[to_additive (attr := simp)]\ntheorem biUnion_op_smul_finset (s t : Finset \u03b1) : (t.biUnion fun a => op a \u2022 s) = s * t", "start": [1839, 1], "end": [1841, 22], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_iff_left", "code": "@[to_additive]\ntheorem mul_subset_iff_left : s * t \u2286 u \u2194 \u2200 a \u2208 s, a \u2022 t \u2286 u", "start": [1845, 1], "end": [1847, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.mul_subset_iff_right", "code": "@[to_additive]\ntheorem mul_subset_iff_right : s * t \u2286 u \u2194 \u2200 b \u2208 t, op b \u2022 s \u2286 u", "start": [1851, 1], "end": [1853, 26], "kind": "commanddeclaration"}, {"full_name": "Finset.op_smul_finset_mul_eq_mul_smul_finset", "code": "@[to_additive]\ntheorem op_smul_finset_mul_eq_mul_smul_finset (a : \u03b1) (s : Finset \u03b1) (t : Finset \u03b1) :\n    op a \u2022 s * t = s * a \u2022 t", "start": [1863, 1], "end": [1866, 77], "kind": "commanddeclaration"}, {"full_name": "Finset.pairwiseDisjoint_smul_iff", "code": "@[to_additive]\ntheorem pairwiseDisjoint_smul_iff {s : Set \u03b1} {t : Finset \u03b1} :\n    s.PairwiseDisjoint (\u00b7 \u2022 t) \u2194 (s \u00d7\u02e2 t : Set (\u03b1 \u00d7 \u03b1)).InjOn fun p => p.1 * p.2", "start": [1876, 1], "end": [1879, 83], "kind": "commanddeclaration"}, {"full_name": "Finset.card_singleton_mul", "code": "@[to_additive (attr := simp)]\ntheorem card_singleton_mul : ({a} * t).card = t.card", "start": [1883, 1], "end": [1885, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.singleton_mul_inter", "code": "@[to_additive]\ntheorem singleton_mul_inter : {a} * (s \u2229 t) = {a} * s \u2229 ({a} * t)", "start": [1889, 1], "end": [1891, 54], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_mul_left", "code": "@[to_additive]\ntheorem card_le_card_mul_left {s : Finset \u03b1} (hs : s.Nonempty) : t.card \u2264 (s * t).card", "start": [1895, 1], "end": [1897, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.card_mul_singleton", "code": "@[to_additive (attr := simp)]\ntheorem card_mul_singleton : (s * {a}).card = s.card", "start": [1907, 1], "end": [1909, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.inter_mul_singleton", "code": "@[to_additive]\ntheorem inter_mul_singleton : s \u2229 t * {a} = s * {a} \u2229 (t * {a})", "start": [1913, 1], "end": [1915, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.card_le_card_mul_right", "code": "@[to_additive]\ntheorem card_le_card_mul_right {t : Finset \u03b1} (ht : t.Nonempty) : s.card \u2264 (s * t).card", "start": [1919, 1], "end": [1921, 52], "kind": "commanddeclaration"}, {"full_name": "Finset.image_smul_comm", "code": "@[to_additive]\ntheorem image_smul_comm [DecidableEq \u03b2] [DecidableEq \u03b3] [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] (f : \u03b2 \u2192 \u03b3) (a : \u03b1)\n    (s : Finset \u03b2) : (\u2200 b, f (a \u2022 b) = a \u2022 f b) \u2192 (a \u2022 s).image f = a \u2022 s.image f", "start": [1929, 1], "end": [1932, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.image_smul_distrib", "code": "@[to_additive]\ntheorem image_smul_distrib [DecidableEq \u03b1] [DecidableEq \u03b2] [Monoid \u03b1] [Monoid \u03b2]\n    [MonoidHomClass F \u03b1 \u03b2] (f : F) (a : \u03b1) (s : Finset \u03b1) : (a \u2022 s).image f = f a \u2022 s.image f", "start": [1936, 1], "end": [1939, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_mem_smul_finset_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_mem_smul_finset_iff (a : \u03b1) : a \u2022 b \u2208 a \u2022 s \u2194 b \u2208 s", "start": [1947, 1], "end": [1949, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_smul_mem_iff", "code": "@[to_additive]\ntheorem inv_smul_mem_iff : a\u207b\u00b9 \u2022 b \u2208 s \u2194 b \u2208 a \u2022 s", "start": [1953, 1], "end": [1955, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_inv_smul_finset_iff", "code": "@[to_additive]\ntheorem mem_inv_smul_finset_iff : b \u2208 a\u207b\u00b9 \u2022 s \u2194 a \u2022 b \u2208 s", "start": [1959, 1], "end": [1961, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_smul_finset_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_subset_smul_finset_iff : a \u2022 s \u2286 a \u2022 t \u2194 s \u2286 t", "start": [1965, 1], "end": [1967, 50], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_iff", "code": "@[to_additive]\ntheorem smul_finset_subset_iff : a \u2022 s \u2286 t \u2194 s \u2286 a\u207b\u00b9 \u2022 t", "start": [1971, 1], "end": [1975, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_smul_finset_iff", "code": "@[to_additive]\ntheorem subset_smul_finset_iff : s \u2286 a \u2022 t \u2194 a\u207b\u00b9 \u2022 s \u2286 t", "start": [1979, 1], "end": [1983, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_inter", "code": "@[to_additive]\ntheorem smul_finset_inter : a \u2022 (s \u2229 t) = a \u2022 s \u2229 a \u2022 t", "start": [1987, 1], "end": [1989, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_sdiff", "code": "@[to_additive]\ntheorem smul_finset_sdiff : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t", "start": [1993, 1], "end": [1995, 43], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_symmDiff", "code": "@[to_additive]\ntheorem smul_finset_symmDiff : a \u2022 s \u2206 t = (a \u2022 s) \u2206 (a \u2022 t)", "start": [1999, 1], "end": [2001, 46], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_univ", "code": "@[to_additive (attr := simp)]\ntheorem smul_finset_univ [Fintype \u03b2] : a \u2022 (univ : Finset \u03b2) = univ", "start": [2005, 1], "end": [2007, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_univ", "code": "@[to_additive (attr := simp)]\ntheorem smul_univ [Fintype \u03b2] {s : Finset \u03b1} (hs : s.Nonempty) : s \u2022 (univ : Finset \u03b2) = univ", "start": [2011, 1], "end": [2015, 27], "kind": "commanddeclaration"}, {"full_name": "Finset.card_smul_finset", "code": "@[to_additive (attr := simp)]\ntheorem card_smul_finset (a : \u03b1) (s : Finset \u03b2) : (a \u2022 s).card = s.card", "start": [2019, 1], "end": [2021, 53], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dvd_card_smul_right", "code": "@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s +\u1d65 t`.\"]\ntheorem card_dvd_card_smul_right {s : Finset \u03b1} :\n    ((\u00b7 \u2022 t) '' (s : Set \u03b1)).PairwiseDisjoint id \u2192 t.card \u2223 (s \u2022 t).card", "start": [2025, 1], "end": [2031, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dvd_card_mul_left", "code": "@[to_additive \"If the right cosets of `s` by elements of `t` are disjoint (but not necessarily\ndistinct!), then the size of `s` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_left {s t : Finset \u03b1} :\n    ((fun b => s.image fun a => a * b) '' (t : Set \u03b1)).PairwiseDisjoint id \u2192\n      s.card \u2223 (s * t).card", "start": [2037, 1], "end": [2044, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.card_dvd_card_mul_right", "code": "@[to_additive \"If the left cosets of `t` by elements of `s` are disjoint (but not necessarily\ndistinct!), then the size of `t` divides the size of `s + t`.\"]\ntheorem card_dvd_card_mul_right {s t : Finset \u03b1} :\n    ((\u00b7 \u2022 t) '' (s : Set \u03b1)).PairwiseDisjoint id \u2192 t.card \u2223 (s * t).card", "start": [2048, 1], "end": [2054, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_mem_smul_finset_iff\u2080", "code": "@[simp]\ntheorem smul_mem_smul_finset_iff\u2080 (ha : a \u2260 0) : a \u2022 b \u2208 a \u2022 s \u2194 b \u2208 s", "start": [2062, 1], "end": [2064, 44], "kind": "commanddeclaration"}, {"full_name": "Finset.inv_smul_mem_iff\u2080", "code": "theorem inv_smul_mem_iff\u2080 (ha : a \u2260 0) : a\u207b\u00b9 \u2022 b \u2208 s \u2194 b \u2208 a \u2022 s", "start": [2067, 1], "end": [2068, 56], "kind": "commanddeclaration"}, {"full_name": "Finset.mem_inv_smul_finset_iff\u2080", "code": "theorem mem_inv_smul_finset_iff\u2080 (ha : a \u2260 0) : b \u2208 a\u207b\u00b9 \u2022 s \u2194 a \u2022 b \u2208 s", "start": [2071, 1], "end": [2072, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_smul_finset_iff\u2080", "code": "@[simp]\ntheorem smul_finset_subset_smul_finset_iff\u2080 (ha : a \u2260 0) : a \u2022 s \u2286 a \u2022 t \u2194 s \u2286 t", "start": [2075, 1], "end": [2077, 74], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_subset_iff\u2080", "code": "theorem smul_finset_subset_iff\u2080 (ha : a \u2260 0) : a \u2022 s \u2286 t \u2194 s \u2286 a\u207b\u00b9 \u2022 t", "start": [2080, 1], "end": [2081, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.subset_smul_finset_iff\u2080", "code": "theorem subset_smul_finset_iff\u2080 (ha : a \u2260 0) : s \u2286 a \u2022 t \u2194 a\u207b\u00b9 \u2022 s \u2286 t", "start": [2084, 1], "end": [2085, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_inter\u2080", "code": "theorem smul_finset_inter\u2080 (ha : a \u2260 0) : a \u2022 (s \u2229 t) = a \u2022 s \u2229 a \u2022 t", "start": [2088, 1], "end": [2089, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_sdiff\u2080", "code": "theorem smul_finset_sdiff\u2080 (ha : a \u2260 0) : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t", "start": [2092, 1], "end": [2093, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_symmDiff\u2080", "code": "theorem smul_finset_symmDiff\u2080 (ha : a \u2260 0) : a \u2022 s \u2206 t = (a \u2022 s) \u2206 (a \u2022 t)", "start": [2096, 1], "end": [2097, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_univ\u2080", "code": "theorem smul_univ\u2080 [Fintype \u03b2] {s : Finset \u03b1} (hs : \u00acs \u2286 0) : s \u2022 (univ : Finset \u03b2) = univ", "start": [2100, 1], "end": [2104, 28], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_univ\u2080", "code": "theorem smul_finset_univ\u2080 [Fintype \u03b2] (ha : a \u2260 0) : a \u2022 (univ : Finset \u03b2) = univ", "start": [2107, 1], "end": [2110, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_zero_subset", "code": "theorem smul_zero_subset (s : Finset \u03b1) : s \u2022 (0 : Finset \u03b2) \u2286 0", "start": [2125, 1], "end": [2125, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_smul_subset", "code": "theorem zero_smul_subset (t : Finset \u03b2) : (0 : Finset \u03b1) \u2022 t \u2286 0", "start": [2128, 1], "end": [2128, 99], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.smul_zero", "code": "theorem Nonempty.smul_zero (hs : s.Nonempty) : s \u2022 (0 : Finset \u03b2) = 0", "start": [2131, 1], "end": [2132, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.Nonempty.zero_smul", "code": "theorem Nonempty.zero_smul (ht : t.Nonempty) : (0 : Finset \u03b1) \u2022 t = 0", "start": [2135, 1], "end": [2136, 62], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_smul_finset", "code": "theorem zero_smul_finset {s : Finset \u03b2} (h : s.Nonempty) : (0 : \u03b1) \u2022 s = (0 : Finset \u03b2)", "start": [2139, 1], "end": [2141, 67], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_smul_finset_subset", "code": "theorem zero_smul_finset_subset (s : Finset \u03b2) : (0 : \u03b1) \u2022 s \u2286 0", "start": [2144, 1], "end": [2145, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_mem_smul_finset", "code": "theorem zero_mem_smul_finset {t : Finset \u03b2} {a : \u03b1} (h : (0 : \u03b2) \u2208 t) : (0 : \u03b2) \u2208 a \u2022 t", "start": [2148, 1], "end": [2149, 40], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_mem_smul_iff", "code": "theorem zero_mem_smul_iff :\n    (0 : \u03b2) \u2208 s \u2022 t \u2194 (0 : \u03b1) \u2208 s \u2227 t.Nonempty \u2228 (0 : \u03b2) \u2208 t \u2227 s.Nonempty", "start": [2154, 1], "end": [2157, 6], "kind": "commanddeclaration"}, {"full_name": "Finset.zero_mem_smul_finset_iff", "code": "theorem zero_mem_smul_finset_iff (ha : a \u2260 0) : (0 : \u03b2) \u2208 a \u2022 t \u2194 (0 : \u03b2) \u2208 t", "start": [2160, 1], "end": [2161, 73], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_finset_neg", "code": "@[simp]\ntheorem smul_finset_neg : a \u2022 -t = -(a \u2022 t)", "start": [2171, 1], "end": [2173, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.smul_neg", "code": "@[simp]\nprotected theorem smul_neg : s \u2022 -t = -(s \u2022 t)", "start": [2176, 1], "end": [2179, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.neg_smul_finset", "code": "@[simp]\ntheorem neg_smul_finset : -a \u2022 t = -(a \u2022 t)", "start": [2189, 1], "end": [2191, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.neg_smul", "code": "@[simp]\nprotected theorem neg_smul [DecidableEq \u03b1] : -s \u2022 t = -(s \u2022 t)", "start": [2194, 1], "end": [2197, 40], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_one", "code": "@[to_additive (attr := simp)]\ntheorem toFinset_one : (1 : Set \u03b1).toFinset = 1", "start": [2212, 1], "end": [2214, 6], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_one", "code": "@[to_additive (attr := simp high)]\ntheorem Finite.toFinset_one (h : (1 : Set \u03b1).Finite := finite_one) : h.toFinset = 1", "start": [2219, 1], "end": [2221, 30], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_mul", "code": "@[to_additive (attr := simp)]\ntheorem toFinset_mul (s t : Set \u03b1) [Fintype s] [Fintype t] [Fintype \u2191(s * t)] :\n    (s * t).toFinset = s.toFinset * t.toFinset", "start": [2231, 1], "end": [2234, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_mul", "code": "@[to_additive]\ntheorem Finite.toFinset_mul (hs : s.Finite) (ht : t.Finite) (hf := hs.mul ht) :\n    hf.toFinset = hs.toFinset * ht.toFinset", "start": [2238, 1], "end": [2241, 31], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_smul", "code": "@[to_additive (attr := simp)]\ntheorem toFinset_smul (s : Set \u03b1) (t : Set \u03b2) [Fintype s] [Fintype t] [Fintype \u2191(s \u2022 t)] :\n    (s \u2022 t).toFinset = s.toFinset \u2022 t.toFinset", "start": [2251, 1], "end": [2254, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_smul", "code": "@[to_additive]\ntheorem Finite.toFinset_smul (hs : s.Finite) (ht : t.Finite) (hf := hs.smul ht) :\n    hf.toFinset = hs.toFinset \u2022 ht.toFinset", "start": [2258, 1], "end": [2261, 31], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_smul_set", "code": "@[to_additive (attr := simp)]\ntheorem toFinset_smul_set (a : \u03b1) (s : Set \u03b2) [Fintype s] [Fintype \u2191(a \u2022 s)] :\n    (a \u2022 s).toFinset = a \u2022 s.toFinset", "start": [2271, 1], "end": [2274, 21], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_smul_set", "code": "@[to_additive]\ntheorem Finite.toFinset_smul_set (hs : s.Finite) (hf : (a \u2022 s).Finite := hs.smul_set) :\n    hf.toFinset = a \u2022 hs.toFinset", "start": [2278, 1], "end": [2281, 30], "kind": "commanddeclaration"}, {"full_name": "Set.toFinset_vsub", "code": "@[simp]\ntheorem toFinset_vsub (s t : Set \u03b2) [Fintype s] [Fintype t] [Fintype \u2191(s -\u1d65 t)] :\n    (s -\u1d65 t : Set \u03b1).toFinset = s.toFinset -\u1d65 t.toFinset", "start": [2291, 1], "end": [2294, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.toFinset_vsub", "code": "theorem Finite.toFinset_vsub (hs : s.Finite) (ht : t.Finite) (hf := hs.vsub ht) :\n    hf.toFinset = hs.toFinset -\u1d65 ht.toFinset", "start": [2297, 1], "end": [2299, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Basis.lean", "imports": ["Mathlib/LinearAlgebra/Projection.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/LinearAlgebra/LinearPMap.lean", "Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/Algebra/BigOperators/Finprod.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "Basis", "code": "structure Basis where\n  \n  ofRepr ::\n    \n    repr : M \u2243\u2097[R] \u03b9 \u2192\u2080 R", "start": [84, 1], "end": [96, 26], "kind": "commanddeclaration"}, {"full_name": "uniqueBasis", "code": "instance uniqueBasis [Subsingleton R] : Unique (Basis \u03b9 R M) :=\n  \u27e8\u27e8\u27e8default\u27e9\u27e9, fun \u27e8b\u27e9 => by rw [Subsingleton.elim b]\u27e9", "start": [103, 1], "end": [104, 56], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_injective", "code": "theorem repr_injective : Injective (repr : Basis \u03b9 R M \u2192 M \u2243\u2097[R] \u03b9 \u2192\u2080 R)", "start": [116, 1], "end": [117, 26], "kind": "commanddeclaration"}, {"full_name": "Basis.funLike", "code": "instance funLike : FunLike (Basis \u03b9 R M) \u03b9 fun _ => M where\n  coe b i := b.repr.symm (Finsupp.single i 1)\n  coe_injective' f g h := repr_injective <| LinearEquiv.symm_bijective.injective <|\n    LinearEquiv.toLinearMap_injective <| by ext; exact congr_fun h _", "start": [120, 1], "end": [124, 69], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_ofRepr", "code": "@[simp]\ntheorem coe_ofRepr (e : M \u2243\u2097[R] \u03b9 \u2192\u2080 R) : \u21d1(ofRepr e) = fun i => e.symm (Finsupp.single i 1)", "start": [127, 1], "end": [129, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.injective", "code": "protected theorem injective [Nontrivial R] : Injective b", "start": [132, 1], "end": [133, 97], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_symm_single_one", "code": "theorem repr_symm_single_one : b.repr.symm (Finsupp.single i 1) = b i", "start": [136, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_symm_single", "code": "theorem repr_symm_single : b.repr.symm (Finsupp.single i c) = c \u2022 b i", "start": [140, 1], "end": [144, 70], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_self", "code": "@[simp]\ntheorem repr_self : b.repr (b i) = Finsupp.single i 1", "start": [147, 1], "end": [149, 35], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_self_apply", "code": "theorem repr_self_apply (j) [Decidable (i = j)] : b.repr (b i) j = if i = j then 1 else 0", "start": [152, 1], "end": [153, 39], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_symm_apply", "code": "@[simp]\ntheorem repr_symm_apply (v) : b.repr.symm v = Finsupp.total \u03b9 M R b v", "start": [156, 1], "end": [161, 88], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_repr_symm", "code": "@[simp]\ntheorem coe_repr_symm : \u2191b.repr.symm = Finsupp.total \u03b9 M R b", "start": [164, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_total", "code": "@[simp]\ntheorem repr_total (v) : b.repr (Finsupp.total _ _ _ b v) = v", "start": [169, 1], "end": [172, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.total_repr", "code": "@[simp]\ntheorem total_repr : Finsupp.total _ _ _ b (b.repr x) = x", "start": [175, 1], "end": [178, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_range", "code": "theorem repr_range : LinearMap.range (b.repr : M \u2192\u2097[R] \u03b9 \u2192\u2080 R) = Finsupp.supported R R univ", "start": [181, 1], "end": [182, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_span_repr_support", "code": "theorem mem_span_repr_support (m : M) : m \u2208 span R (b '' (b.repr m).support)", "start": [185, 1], "end": [186, 93], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_support_subset_of_mem_span", "code": "theorem repr_support_subset_of_mem_span (s : Set \u03b9) {m : M}\n    (hm : m \u2208 span R (b '' s)) : \u2191(b.repr m).support \u2286 s", "start": [189, 1], "end": [192, 48], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_span_image", "code": "theorem mem_span_image {m : M} {s : Set \u03b9} : m \u2208 span R (b '' s) \u2194 \u2191(b.repr m).support \u2286 s", "start": [195, 1], "end": [197, 62], "kind": "commanddeclaration"}, {"full_name": "Basis.self_mem_span_image", "code": "@[simp]\ntheorem self_mem_span_image [Nontrivial R] {i : \u03b9} {s : Set \u03b9} :\n    b i \u2208 span R (b '' s) \u2194 i \u2208 s", "start": [199, 1], "end": [202, 56], "kind": "commanddeclaration"}, {"full_name": "Basis.coord", "code": "@[simps!]\ndef coord : M \u2192\u2097[R] R :=\n  Finsupp.lapply i \u2218\u2097 \u2191b.repr", "start": [208, 1], "end": [216, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.forall_coord_eq_zero_iff", "code": "theorem forall_coord_eq_zero_iff {x : M} : (\u2200 i, b.coord i x = 0) \u2194 x = 0", "start": [219, 1], "end": [221, 27], "kind": "commanddeclaration"}, {"full_name": "Basis.sumCoords", "code": "noncomputable def sumCoords : M \u2192\u2097[R] R :=\n  (Finsupp.lsum \u2115 fun _ => LinearMap.id) \u2218\u2097 (b.repr : M \u2192\u2097[R] \u03b9 \u2192\u2080 R)", "start": [224, 1], "end": [226, 70], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_sumCoords", "code": "@[simp]\ntheorem coe_sumCoords : (b.sumCoords : M \u2192 R) = fun m => (b.repr m).sum fun _ => id", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_sumCoords_eq_finsum", "code": "theorem coe_sumCoords_eq_finsum : (b.sumCoords : M \u2192 R) = fun m => \u2211\u1da0 i, b.coord i m", "start": [234, 1], "end": [239, 28], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_sumCoords_of_fintype", "code": "@[simp high]\ntheorem coe_sumCoords_of_fintype [Fintype \u03b9] : (b.sumCoords : M \u2192 R) = \u2211 i, b.coord i", "start": [242, 1], "end": [249, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.sumCoords_self_apply", "code": "@[simp]\ntheorem sumCoords_self_apply : b.sumCoords (b i) = 1", "start": [252, 1], "end": [255, 89], "kind": "commanddeclaration"}, {"full_name": "Basis.dvd_coord_smul", "code": "theorem dvd_coord_smul (i : \u03b9) (m : M) (r : R) : r \u2223 b.coord i (r \u2022 m)", "start": [258, 1], "end": [259, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.coord_repr_symm", "code": "theorem coord_repr_symm (b : Basis \u03b9 R M) (i : \u03b9) (f : \u03b9 \u2192\u2080 R) : b.coord i (b.repr.symm f) = f i", "start": [262, 1], "end": [263, 58], "kind": "commanddeclaration"}, {"full_name": "Basis.ext", "code": "theorem ext {f\u2081 f\u2082 : M \u2192\u209b\u2097[\u03c3] M\u2081} (h : \u2200 i, f\u2081 (b i) = f\u2082 (b i)) : f\u2081 = f\u2082", "start": [274, 1], "end": [278, 47], "kind": "commanddeclaration"}, {"full_name": "Basis.ext'", "code": "theorem ext' {f\u2081 f\u2082 : M \u2243\u209b\u2097[\u03c3] M\u2081} (h : \u2200 i, f\u2081 (b i) = f\u2082 (b i)) : f\u2081 = f\u2082", "start": [281, 1], "end": [285, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_elem_iff", "code": "theorem ext_elem_iff {x y : M} : x = y \u2194 \u2200 i, b.repr x i = b.repr y i", "start": [288, 1], "end": [290, 63], "kind": "commanddeclaration"}, {"full_name": "Basis.ext_elem", "code": "alias \u27e8_, _root_.Basis.ext_elem\u27e9 := ext_elem_iff", "start": [293, 1], "end": [293, 49], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Basis.repr_eq_iff", "code": "theorem repr_eq_iff {b : Basis \u03b9 R M} {f : M \u2192\u2097[R] \u03b9 \u2192\u2080 R} :\n    \u2191b.repr = f \u2194 \u2200 i, f (b i) = Finsupp.single i 1", "start": [296, 1], "end": [298, 91], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_eq_iff'", "code": "theorem repr_eq_iff' {b : Basis \u03b9 R M} {f : M \u2243\u2097[R] \u03b9 \u2192\u2080 R} :\n    b.repr = f \u2194 \u2200 i, f (b i) = Finsupp.single i 1", "start": [301, 1], "end": [303, 92], "kind": "commanddeclaration"}, {"full_name": "Basis.apply_eq_iff", "code": "theorem apply_eq_iff {b : Basis \u03b9 R M} {x : M} {i : \u03b9} : b i = x \u2194 b.repr x = Finsupp.single i 1", "start": [306, 1], "end": [307, 89], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_apply_eq", "code": "theorem repr_apply_eq (f : M \u2192 \u03b9 \u2192 R) (hadd : \u2200 x y, f (x + y) = f x + f y)\n    (hsmul : \u2200 (c : R) (x : M), f (c \u2022 x) = c \u2022 f x) (f_eq : \u2200 i, f (b i) = Finsupp.single i 1)\n    (x : M) (i : \u03b9) : b.repr x i = f x i", "start": [310, 1], "end": [327, 21], "kind": "commanddeclaration"}, {"full_name": "Basis.eq_ofRepr_eq_repr", "code": "theorem eq_ofRepr_eq_repr {b\u2081 b\u2082 : Basis \u03b9 R M} (h : \u2200 x i, b\u2081.repr x i = b\u2082.repr x i) : b\u2081 = b\u2082", "start": [330, 1], "end": [332, 36], "kind": "commanddeclaration"}, {"full_name": "Basis.eq_of_apply_eq", "code": "@[ext]\ntheorem eq_of_apply_eq {b\u2081 b\u2082 : Basis \u03b9 R M} : (\u2200 i, b\u2081 i = b\u2082 i) \u2192 b\u2081 = b\u2082", "start": [335, 1], "end": [338, 18], "kind": "commanddeclaration"}, {"full_name": "Basis.map", "code": "@[simps]\nprotected def map : Basis \u03b9 R M' :=\n  ofRepr (f.symm.trans b.repr)", "start": [347, 1], "end": [350, 31], "kind": "commanddeclaration"}, {"full_name": "Basis.map_apply", "code": "@[simp]\ntheorem map_apply (i) : b.map f i = f (b i)", "start": [353, 1], "end": [355, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_map", "code": "theorem coe_map : (b.map f : \u03b9 \u2192 M') = f \u2218 b", "start": [358, 1], "end": [359, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.mapCoeffs", "code": "@[simps (config := { simpRhs := true })]\ndef mapCoeffs : Basis \u03b9 R' M := by\n  letI : Module R' R := Module.compHom R (\u2191f.symm : R' \u2192+* R)\n  haveI : IsScalarTower R' R M :=\n    { smul_assoc := fun x y z => by\n        change (f.symm x * y) \u2022 z = x \u2022 (y \u2022 z)\n        rw [mul_smul, \u2190 h, f.apply_symm_apply] }\n  exact ofRepr <| (b.repr.restrictScalars R').trans <|\n    Finsupp.mapRange.linearEquiv (Module.compHom.toLinearEquiv f.symm).symm", "start": [370, 1], "end": [385, 76], "kind": "commanddeclaration"}, {"full_name": "Basis.mapCoeffs_apply", "code": "theorem mapCoeffs_apply (i : \u03b9) : b.mapCoeffs f h i = b i", "start": [388, 1], "end": [399, 9], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_mapCoeffs", "code": "@[simp]\ntheorem coe_mapCoeffs : (b.mapCoeffs f h : \u03b9 \u2192 M) = b", "start": [402, 1], "end": [404, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.reindex", "code": "def reindex : Basis \u03b9' R M :=\n  .ofRepr (b.repr.trans (Finsupp.domLCongr e))", "start": [415, 1], "end": [417, 47], "kind": "commanddeclaration"}, {"full_name": "Basis.reindex_apply", "code": "theorem reindex_apply (i' : \u03b9') : b.reindex e i' = b (e.symm i')", "start": [420, 1], "end": [423, 89], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_reindex", "code": "@[simp]\ntheorem coe_reindex : (b.reindex e : \u03b9' \u2192 M) = b \u2218 e.symm", "start": [426, 1], "end": [428, 29], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_reindex_apply", "code": "theorem repr_reindex_apply (i' : \u03b9') : (b.reindex e).repr x i' = b.repr x (e.symm i')", "start": [431, 1], "end": [432, 67], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_reindex", "code": "@[simp]\ntheorem repr_reindex : (b.reindex e).repr x = (b.repr x).mapDomain e", "start": [435, 1], "end": [437, 50], "kind": "commanddeclaration"}, {"full_name": "Basis.reindex_refl", "code": "@[simp]\ntheorem reindex_refl : b.reindex (Equiv.refl \u03b9) = b", "start": [440, 1], "end": [442, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.range_reindex", "code": "theorem range_reindex : Set.range (b.reindex e) = Set.range b", "start": [445, 1], "end": [447, 33], "kind": "commanddeclaration"}, {"full_name": "Basis.sumCoords_reindex", "code": "@[simp]\ntheorem sumCoords_reindex : (b.reindex e).sumCoords = b.sumCoords", "start": [450, 1], "end": [454, 68], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange", "code": "def reindexRange : Basis (range b) R M :=\n  haveI := Classical.dec (Nontrivial R)\n  if h : Nontrivial R then\n    letI := h\n    b.reindex (Equiv.ofInjective b (Basis.injective b))\n  else\n    letI : Subsingleton R := not_nontrivial_iff_subsingleton.mp h\n    .ofRepr (Module.subsingletonEquiv R M (range b))", "start": [457, 1], "end": [465, 53], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange_self", "code": "theorem reindexRange_self (i : \u03b9) (h := Set.mem_range_self i) : b.reindexRange \u27e8b i, h\u27e9 = b i", "start": [468, 1], "end": [475, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange_repr_self", "code": "theorem reindexRange_repr_self (i : \u03b9) :\n    b.reindexRange.repr (b i) = Finsupp.single \u27e8b i, mem_range_self i\u27e9 1", "start": [478, 1], "end": [483, 79], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange_apply", "code": "@[simp]\ntheorem reindexRange_apply (x : range b) : b.reindexRange x = x", "start": [486, 1], "end": [489, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange_repr'", "code": "theorem reindexRange_repr' (x : M) {bi : M} {i : \u03b9} (h : b i = bi) :\n    b.reindexRange.repr x \u27e8bi, \u27e8i, h\u27e9\u27e9 = b.repr x i", "start": [492, 1], "end": [507, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexRange_repr", "code": "@[simp]\ntheorem reindexRange_repr (x : M) (i : \u03b9) (h := Set.mem_range_self i) :\n    b.reindexRange.repr x \u27e8b i, h\u27e9 = b.repr x i", "start": [510, 1], "end": [513, 29], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexFinsetRange", "code": "def reindexFinsetRange : Basis (Finset.univ.image b) R M :=\n  b.reindexRange.reindex ((Equiv.refl M).subtypeEquiv (by simp))", "start": [520, 1], "end": [523, 65], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexFinsetRange_self", "code": "theorem reindexFinsetRange_self (i : \u03b9) (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange \u27e8b i, h\u27e9 = b i", "start": [526, 1], "end": [529, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexFinsetRange_apply", "code": "@[simp]\ntheorem reindexFinsetRange_apply (x : Finset.univ.image b) : b.reindexFinsetRange x = x", "start": [532, 1], "end": [536, 36], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexFinsetRange_repr_self", "code": "theorem reindexFinsetRange_repr_self (i : \u03b9) :\n    b.reindexFinsetRange.repr (b i) =\n      Finsupp.single \u27e8b i, Finset.mem_image_of_mem b (Finset.mem_univ i)\u27e9 1", "start": [539, 1], "end": [545, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.reindexFinsetRange_repr", "code": "@[simp]\ntheorem reindexFinsetRange_repr (x : M) (i : \u03b9)\n    (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange.repr x \u27e8b i, h\u27e9 = b.repr x i", "start": [548, 1], "end": [551, 86], "kind": "commanddeclaration"}, {"full_name": "Basis.linearIndependent", "code": "protected theorem linearIndependent : LinearIndependent R b", "start": [558, 1], "end": [562, 48], "kind": "commanddeclaration"}, {"full_name": "Basis.ne_zero", "code": "protected theorem ne_zero [Nontrivial R] (i) : b i \u2260 0", "start": [565, 1], "end": [566, 32], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_span", "code": "protected theorem mem_span (x : M) : x \u2208 span R (range b)", "start": [569, 1], "end": [570, 65], "kind": "commanddeclaration"}, {"full_name": "Basis.span_eq", "code": "@[simp]\nprotected theorem span_eq : span R (range b) = \u22a4", "start": [573, 1], "end": [575, 41], "kind": "commanddeclaration"}, {"full_name": "Basis.index_nonempty", "code": "theorem index_nonempty (b : Basis \u03b9 R M) [Nontrivial M] : Nonempty \u03b9", "start": [578, 1], "end": [581, 12], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_submodule_iff", "code": "theorem mem_submodule_iff {P : Submodule R M} (b : Basis \u03b9 R P) {x : M} :\n    x \u2208 P \u2194 \u2203 c : \u03b9 \u2192\u2080 R, x = Finsupp.sum c fun i x => x \u2022 (b i : M)", "start": [584, 1], "end": [590, 58], "kind": "commanddeclaration"}, {"full_name": "Basis.constr", "code": "def constr : (\u03b9 \u2192 M') \u2243\u2097[S] M \u2192\u2097[R] M' where\n  toFun f := (Finsupp.total M' M' R id).comp <| Finsupp.lmapDomain R R f \u2218\u2097 \u2191b.repr\n  invFun f i := f (b i)\n  left_inv f := by\n    ext\n    simp\n  right_inv f := by\n    refine' b.ext fun i => _\n    simp\n  map_add' f g := by\n    refine' b.ext fun i => _\n    simp\n  map_smul' c f := by\n    refine' b.ext fun i => _\n    simp", "start": [599, 1], "end": [623, 9], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_def", "code": "theorem constr_def (f : \u03b9 \u2192 M') :\n    constr (M' := M') b S f = Finsupp.total M' M' R id \u2218\u2097 Finsupp.lmapDomain R R f \u2218\u2097 \u2191b.repr", "start": [626, 1], "end": [628, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_apply", "code": "theorem constr_apply (f : \u03b9 \u2192 M') (x : M) :\n    constr (M' := M') b S f x = (b.repr x).sum fun b a => a \u2022 f b", "start": [631, 1], "end": [634, 55], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_basis", "code": "@[simp]\ntheorem constr_basis (f : \u03b9 \u2192 M') (i : \u03b9) : (constr (M' := M') b S f : M \u2192 M') (b i) = f i", "start": [637, 1], "end": [639, 41], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_eq", "code": "theorem constr_eq {g : \u03b9 \u2192 M'} {f : M \u2192\u2097[R] M'} (h : \u2200 i, g i = f (b i)) :\n    constr (M' := M') b S g = f", "start": [642, 1], "end": [644, 52], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_self", "code": "theorem constr_self (f : M \u2192\u2097[R] M') : (constr (M' := M') b S fun i => f (b i)) = f", "start": [647, 1], "end": [648, 29], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_range", "code": "theorem constr_range {f : \u03b9 \u2192 M'} :\n    LinearMap.range (constr (M' := M') b S f) = span R (range f)", "start": [651, 1], "end": [655, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_comp", "code": "@[simp]\ntheorem constr_comp (f : M' \u2192\u2097[R] M') (v : \u03b9 \u2192 M') :\n    constr (M' := M') b S (f \u2218 v) = f.comp (constr (M' := M') b S v)", "start": [658, 1], "end": [661, 88], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv", "code": "protected def equiv : M \u2243\u2097[R] M' :=\n  b.repr.trans (b'.reindex e.symm).repr.symm", "start": [672, 1], "end": [675, 45], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv_apply", "code": "@[simp]\ntheorem equiv_apply : b.equiv b' e (b i) = b' (e i)", "start": [678, 1], "end": [679, 77], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv_refl", "code": "@[simp]\ntheorem equiv_refl : b.equiv b (Equiv.refl \u03b9) = LinearEquiv.refl R M", "start": [682, 1], "end": [684, 26], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv_symm", "code": "@[simp]\ntheorem equiv_symm : (b.equiv b' e).symm = b'.equiv b e.symm", "start": [687, 1], "end": [689, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv_trans", "code": "@[simp]\ntheorem equiv_trans {\u03b9'' : Type*} (b'' : Basis \u03b9'' R M'') (e : \u03b9 \u2243 \u03b9') (e' : \u03b9' \u2243 \u03b9'') :\n    (b.equiv b' e).trans (b'.equiv b'' e') = b.equiv b'' (e.trans e')", "start": [692, 1], "end": [695, 26], "kind": "commanddeclaration"}, {"full_name": "Basis.map_equiv", "code": "@[simp]\ntheorem map_equiv (b : Basis \u03b9 R M) (b' : Basis \u03b9' R M') (e : \u03b9 \u2243 \u03b9') :\n    b.map (b.equiv b' e) = b'.reindex e.symm", "start": [698, 1], "end": [702, 7], "kind": "commanddeclaration"}, {"full_name": "Basis.prod", "code": "protected def prod : Basis (Sum \u03b9 \u03b9') R (M \u00d7 M') :=\n  ofRepr ((b.repr.prod b'.repr).trans (Finsupp.sumFinsuppLEquivProdFinsupp R).symm)", "start": [711, 1], "end": [715, 84], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_repr_inl", "code": "@[simp]\ntheorem prod_repr_inl (x) (i) : (b.prod b').repr x (Sum.inl i) = b.repr x.1 i", "start": [718, 1], "end": [720, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_repr_inr", "code": "@[simp]\ntheorem prod_repr_inr (x) (i) : (b.prod b').repr x (Sum.inr i) = b'.repr x.2 i", "start": [723, 1], "end": [725, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_apply_inl_fst", "code": "theorem prod_apply_inl_fst (i) : (b.prod b' (Sum.inl i)).1 = b i", "start": [728, 1], "end": [734, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_apply_inr_fst", "code": "theorem prod_apply_inr_fst (i) : (b.prod b' (Sum.inr i)).1 = 0", "start": [737, 1], "end": [744, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_apply_inl_snd", "code": "theorem prod_apply_inl_snd (i) : (b.prod b' (Sum.inl i)).2 = 0", "start": [747, 1], "end": [754, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_apply_inr_snd", "code": "theorem prod_apply_inr_snd (i) : (b.prod b' (Sum.inr i)).2 = b' i", "start": [757, 1], "end": [763, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.prod_apply", "code": "@[simp]\ntheorem prod_apply (i) :\n    b.prod b' i = Sum.elim (LinearMap.inl R M M' \u2218 b) (LinearMap.inr R M M' \u2218 b') i", "start": [766, 1], "end": [771, 96], "kind": "commanddeclaration"}, {"full_name": "Basis.noZeroSMulDivisors", "code": "protected theorem noZeroSMulDivisors [NoZeroDivisors R] (b : Basis \u03b9 R M) :\n    NoZeroSMulDivisors R M", "start": [779, 1], "end": [786, 76], "kind": "commanddeclaration"}, {"full_name": "Basis.smul_eq_zero", "code": "protected theorem smul_eq_zero [NoZeroDivisors R] (b : Basis \u03b9 R M) {c : R} {x : M} :\n    c \u2022 x = 0 \u2194 c = 0 \u2228 x = 0", "start": [789, 1], "end": [791, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.eq_bot_of_rank_eq_zero", "code": "theorem eq_bot_of_rank_eq_zero [NoZeroDivisors R] (b : Basis \u03b9 R M) (N : Submodule R M)\n    (rank_eq : \u2200 {m : \u2115} (v : Fin m \u2192 N), LinearIndependent R ((\u2191) \u2218 v : Fin m \u2192 M) \u2192 m = 0) :\n    N = \u22a5", "start": [794, 1], "end": [806, 56], "kind": "commanddeclaration"}, {"full_name": "Basis.singleton", "code": "protected def singleton (\u03b9 R : Type*) [Unique \u03b9] [Semiring R] : Basis \u03b9 R R :=\n  ofRepr\n    { toFun := fun x => Finsupp.single default x\n      invFun := fun f => f default\n      left_inv := fun x => by simp\n      right_inv := fun f => Finsupp.unique_ext (by simp)\n      map_add' := fun x y => by simp\n      map_smul' := fun c x => by simp }", "start": [813, 1], "end": [821, 40], "kind": "commanddeclaration"}, {"full_name": "Basis.singleton_apply", "code": "@[simp]\ntheorem singleton_apply (\u03b9 R : Type*) [Unique \u03b9] [Semiring R] (i) : Basis.singleton \u03b9 R i = 1", "start": [824, 1], "end": [826, 47], "kind": "commanddeclaration"}, {"full_name": "Basis.singleton_repr", "code": "@[simp]\ntheorem singleton_repr (\u03b9 R : Type*) [Unique \u03b9] [Semiring R] (x i) :\n    (Basis.singleton \u03b9 R).repr x i = x", "start": [829, 1], "end": [831, 89], "kind": "commanddeclaration"}, {"full_name": "Basis.basis_singleton_iff", "code": "theorem basis_singleton_iff {R M : Type*} [Ring R] [Nontrivial R] [AddCommGroup M] [Module R M]\n    [NoZeroSMulDivisors R M] (\u03b9 : Type*) [Unique \u03b9] :\n    Nonempty (Basis \u03b9 R M) \u2194 \u2203 (x : _) (_ : x \u2260 0), \u2200 y : M, \u2203 r : R, r \u2022 x = y", "start": [834, 1], "end": [856, 30], "kind": "commanddeclaration"}, {"full_name": "Basis.empty", "code": "protected def empty [Subsingleton M] [IsEmpty \u03b9] : Basis \u03b9 R M :=\n  ofRepr 0", "start": [865, 1], "end": [867, 11], "kind": "commanddeclaration"}, {"full_name": "Basis.emptyUnique", "code": "instance emptyUnique [Subsingleton M] [IsEmpty \u03b9] : Unique (Basis \u03b9 R M) where\n  default := Basis.empty M\n  uniq := fun _ => congr_arg ofRepr <| Subsingleton.elim _ _", "start": [870, 1], "end": [872, 61], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun", "code": "def Basis.equivFun : M \u2243\u2097[R] \u03b9 \u2192 R :=\n  LinearEquiv.trans b.repr\n    ({ Finsupp.equivFunOnFinite with\n        toFun := (\u2191)\n        map_add' := Finsupp.coe_add\n        map_smul' := Finsupp.coe_smul } :\n      (\u03b9 \u2192\u2080 R) \u2243\u2097[R] \u03b9 \u2192 R)", "start": [887, 1], "end": [895, 28], "kind": "commanddeclaration"}, {"full_name": "Module.fintypeOfFintype", "code": "def Module.fintypeOfFintype (b : Basis \u03b9 R M) [Fintype R] : Fintype M :=\n  haveI := Classical.decEq \u03b9\n  Fintype.ofEquiv _ b.equivFun.toEquiv.symm", "start": [898, 1], "end": [901, 44], "kind": "commanddeclaration"}, {"full_name": "Module.card_fintype", "code": "theorem Module.card_fintype (b : Basis \u03b9 R M) [Fintype R] [Fintype M] :\n    card M = card R ^ card \u03b9", "start": [904, 1], "end": [909, 38], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun_symm_apply", "code": "@[simp]\ntheorem Basis.equivFun_symm_apply (x : \u03b9 \u2192 R) : b.equivFun.symm x = \u2211 i, x i \u2022 b i", "start": [912, 1], "end": [916, 92], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun_apply", "code": "@[simp]\ntheorem Basis.equivFun_apply (u : M) : b.equivFun u = b.repr u", "start": [919, 1], "end": [921, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.map_equivFun", "code": "@[simp]\ntheorem Basis.map_equivFun (f : M \u2243\u2097[R] M') : (b.map f).equivFun = f.symm.trans b.equivFun", "start": [924, 1], "end": [926, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.sum_equivFun", "code": "theorem Basis.sum_equivFun (u : M) : \u2211 i, b.equivFun u i \u2022 b i = u", "start": [929, 1], "end": [931, 68], "kind": "commanddeclaration"}, {"full_name": "Basis.sum_repr", "code": "theorem Basis.sum_repr (u : M) : \u2211 i, b.repr u i \u2022 b i = u", "start": [934, 1], "end": [935, 19], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun_self", "code": "@[simp]\ntheorem Basis.equivFun_self [DecidableEq \u03b9] (i j : \u03b9) :\n    b.equivFun (b i) j = if i = j then 1 else 0", "start": [938, 1], "end": [940, 95], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_sum_self", "code": "theorem Basis.repr_sum_self (c : \u03b9 \u2192 R) : \u21d1(b.repr (\u2211 i, c i \u2022 b i)) = c", "start": [943, 1], "end": [952, 18], "kind": "commanddeclaration"}, {"full_name": "Basis.ofEquivFun", "code": "def Basis.ofEquivFun (e : M \u2243\u2097[R] \u03b9 \u2192 R) : Basis \u03b9 R M :=\n  .ofRepr <| e.trans <| LinearEquiv.symm <| Finsupp.linearEquivFunOnFinite R R \u03b9", "start": [955, 1], "end": [958, 81], "kind": "commanddeclaration"}, {"full_name": "Basis.ofEquivFun_repr_apply", "code": "@[simp]\ntheorem Basis.ofEquivFun_repr_apply (e : M \u2243\u2097[R] \u03b9 \u2192 R) (x : M) (i : \u03b9) :\n    (Basis.ofEquivFun e).repr x i = e x i", "start": [961, 1], "end": [964, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_ofEquivFun", "code": "@[simp]\ntheorem Basis.coe_ofEquivFun [DecidableEq \u03b9] (e : M \u2243\u2097[R] \u03b9 \u2192 R) :\n    (Basis.ofEquivFun e : \u03b9 \u2192 M) = fun i => e.symm (Function.update 0 i 1)", "start": [967, 1], "end": [973, 89], "kind": "commanddeclaration"}, {"full_name": "Basis.ofEquivFun_equivFun", "code": "@[simp]\ntheorem Basis.ofEquivFun_equivFun (v : Basis \u03b9 R M) : Basis.ofEquivFun v.equivFun = v", "start": [976, 1], "end": [982, 97], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun_ofEquivFun", "code": "@[simp]\ntheorem Basis.equivFun_ofEquivFun (e : M \u2243\u2097[R] \u03b9 \u2192 R) : (Basis.ofEquivFun e).equivFun = e", "start": [985, 1], "end": [988, 62], "kind": "commanddeclaration"}, {"full_name": "Basis.constr_apply_fintype", "code": "@[simp]\ntheorem Basis.constr_apply_fintype (f : \u03b9 \u2192 M') (x : M) :\n    (constr (M' := M') b S f : M \u2192 M') x = \u2211 i, b.equivFun x i \u2022 f i", "start": [995, 1], "end": [998, 63], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_submodule_iff'", "code": "theorem Basis.mem_submodule_iff' {P : Submodule R M} (b : Basis \u03b9 R P) {x : M} :\n    x \u2208 P \u2194 \u2203 c : \u03b9 \u2192 R, x = \u2211 i, c i \u2022 (b i : M)", "start": [1001, 1], "end": [1007, 84], "kind": "commanddeclaration"}, {"full_name": "Basis.coord_equivFun_symm", "code": "theorem Basis.coord_equivFun_symm (i : \u03b9) (f : \u03b9 \u2192 R) : b.coord i (b.equivFun.symm f) = f i", "start": [1010, 1], "end": [1011, 56], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv'", "code": "def equiv' (f : M \u2192 M') (g : M' \u2192 M) (hf : \u2200 i, f (b i) \u2208 range b') (hg : \u2200 i, g (b' i) \u2208 range b)\n    (hgf : \u2200 i, g (f (b i)) = b i) (hfg : \u2200 i, f (g (b' i)) = b' i) : M \u2243\u2097[R] M' :=\n  { constr (M' := M') b R (f \u2218 b) with\n    invFun := constr (M' := M) b' R (g \u2218 b')\n    left_inv :=\n      have : (constr (M' := M) b' R (g \u2218 b')).comp (constr (M' := M') b R (f \u2218 b)) = LinearMap.id :=\n        b.ext fun i =>\n          Exists.elim (hf i) fun i' hi' => by\n            rw [LinearMap.comp_apply, b.constr_basis, Function.comp_apply, \u2190 hi', b'.constr_basis,\n              Function.comp_apply, hi', hgf, LinearMap.id_apply]\n      fun x => congr_arg (fun h : M \u2192\u2097[R] M => h x) this\n    right_inv :=\n      have : (constr (M' := M') b R (f \u2218 b)).comp (constr (M' := M) b' R (g \u2218 b')) = LinearMap.id :=\n        b'.ext fun i =>\n          Exists.elim (hg i) fun i' hi' => by\n            rw [LinearMap.comp_apply, b'.constr_basis, Function.comp_apply, \u2190 hi', b.constr_basis,\n              Function.comp_apply, hi', hfg, LinearMap.id_apply]\n      fun x => congr_arg (fun h : M' \u2192\u2097[R] M' => h x) this }", "start": [1028, 1], "end": [1049, 61], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv'_apply", "code": "@[simp]\ntheorem equiv'_apply (f : M \u2192 M') (g : M' \u2192 M) (hf hg hgf hfg) (i : \u03b9) :\n    b.equiv' b' f g hf hg hgf hfg (b i) = f (b i)", "start": [1052, 1], "end": [1055, 23], "kind": "commanddeclaration"}, {"full_name": "Basis.equiv'_symm_apply", "code": "@[simp]\ntheorem equiv'_symm_apply (f : M \u2192 M') (g : M' \u2192 M) (hf hg hgf hfg) (i : \u03b9') :\n    (b.equiv' b' f g hf hg hgf hfg).symm (b' i) = g (b' i)", "start": [1058, 1], "end": [1061, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.sum_repr_mul_repr", "code": "theorem sum_repr_mul_repr {\u03b9'} [Fintype \u03b9'] (b' : Basis \u03b9' R M) (x : M) (i : \u03b9) :\n    (\u2211 j : \u03b9', b.repr (b' j) i * b'.repr x j) = b.repr x i", "start": [1064, 1], "end": [1069, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.maximal", "code": "theorem maximal [Nontrivial R] (b : Basis \u03b9 R M) : b.linearIndependent.Maximal", "start": [1092, 1], "end": [1115, 17], "kind": "commanddeclaration"}, {"full_name": "Basis.mk", "code": "protected noncomputable def mk : Basis \u03b9 R M :=\n  .ofRepr\n    { hli.repr.comp (LinearMap.id.codRestrict _ fun _ => hsp Submodule.mem_top) with\n      invFun := Finsupp.total _ _ _ v\n      left_inv := fun x => hli.total_repr \u27e8x, _\u27e9\n      right_inv := fun _ => hli.repr_eq rfl }", "start": [1122, 1], "end": [1128, 46], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_repr", "code": "@[simp]\ntheorem mk_repr : (Basis.mk hli hsp).repr x = hli.repr \u27e8x, hsp Submodule.mem_top\u27e9", "start": [1131, 1], "end": [1133, 6], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_apply", "code": "theorem mk_apply (i : \u03b9) : Basis.mk hli hsp i = v i", "start": [1136, 1], "end": [1137, 45], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_mk", "code": "@[simp]\ntheorem coe_mk : \u21d1(Basis.mk hli hsp) = v", "start": [1140, 1], "end": [1142, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_coord_apply_eq", "code": "theorem mk_coord_apply_eq (i : \u03b9) : (Basis.mk hli hsp).coord i (v i) = 1", "start": [1147, 1], "end": [1150, 101], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_coord_apply_ne", "code": "theorem mk_coord_apply_ne {i j : \u03b9} (h : j \u2260 i) : (Basis.mk hli hsp).coord i (v j) = 0", "start": [1153, 1], "end": [1157, 35], "kind": "commanddeclaration"}, {"full_name": "Basis.mk_coord_apply", "code": "theorem mk_coord_apply [DecidableEq \u03b9] {i j : \u03b9} :\n    (Basis.mk hli hsp).coord i (v j) = if j = i then 1 else 0", "start": [1160, 1], "end": [1166, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.span", "code": "protected noncomputable def span : Basis \u03b9 R (span R (range v)) :=\n  Basis.mk (linearIndependent_span hli) <| by\n    intro x _\n    have : \u2200 i, v i \u2208 span R (range v) := fun i \u21a6 subset_span (Set.mem_range_self _)\n    have h\u2081 : (((\u2191) : span R (range v) \u2192 M) '' range fun i => \u27e8v i, this i\u27e9) = range v := by\n      simp only [SetLike.coe_sort_coe, \u2190 Set.range_comp]\n      rfl\n    have h\u2082 : map (Submodule.subtype (span R (range v))) (span R (range fun i => \u27e8v i, this i\u27e9)) =\n        span R (range v) := by\n      rw [\u2190 span_image, Submodule.coeSubtype]\n      exact congr_arg _ h\u2081\n    have h\u2083 : (x : M) \u2208 map (Submodule.subtype (span R (range v)))\n        (span R (Set.range fun i => Subtype.mk (v i) _)) := by\n      rw [h\u2082]\n      apply Subtype.mem x\n    rcases mem_map.1 h\u2083 with \u27e8y, hy\u2081, hy\u2082\u27e9\n    have h_x_eq_y : x = y := by\n      rw [Subtype.ext_iff, \u2190 hy\u2082]\n      simp\n    rwa [h_x_eq_y]", "start": [1175, 1], "end": [1196, 19], "kind": "commanddeclaration"}, {"full_name": "Basis.span_apply", "code": "protected theorem span_apply (i : \u03b9) : (Basis.span hli i : M) = v i", "start": [1199, 1], "end": [1200, 65], "kind": "commanddeclaration"}, {"full_name": "Basis.groupSMul_span_eq_top", "code": "theorem groupSMul_span_eq_top {G : Type*} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] {v : \u03b9 \u2192 M} (hv : Submodule.span R (Set.range v) = \u22a4) {w : \u03b9 \u2192 G} :\n    Submodule.span R (Set.range (w \u2022 v)) = \u22a4", "start": [1205, 1], "end": [1215, 45], "kind": "commanddeclaration"}, {"full_name": "Basis.groupSMul", "code": "def groupSMul {G : Type*} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] [SMulCommClass G R M] (v : Basis \u03b9 R M) (w : \u03b9 \u2192 G) : Basis \u03b9 R M :=\n  Basis.mk (LinearIndependent.group_smul v.linearIndependent w) (groupSMul_span_eq_top v.span_eq).ge", "start": [1218, 1], "end": [1222, 101], "kind": "commanddeclaration"}, {"full_name": "Basis.groupSMul_apply", "code": "theorem groupSMul_apply {G : Type*} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n    [IsScalarTower G R M] [SMulCommClass G R M] {v : Basis \u03b9 R M} {w : \u03b9 \u2192 G} (i : \u03b9) :\n    v.groupSMul w i = (w \u2022 (v : \u03b9 \u2192 M)) i", "start": [1225, 1], "end": [1229, 43], "kind": "commanddeclaration"}, {"full_name": "Basis.units_smul_span_eq_top", "code": "theorem units_smul_span_eq_top {v : \u03b9 \u2192 M} (hv : Submodule.span R (Set.range v) = \u22a4) {w : \u03b9 \u2192 R\u02e3} :\n    Submodule.span R (Set.range (w \u2022 v)) = \u22a4", "start": [1232, 1], "end": [1234, 27], "kind": "commanddeclaration"}, {"full_name": "Basis.unitsSMul", "code": "def unitsSMul (v : Basis \u03b9 R M) (w : \u03b9 \u2192 R\u02e3) : Basis \u03b9 R M :=\n  Basis.mk (LinearIndependent.units_smul v.linearIndependent w)\n    (units_smul_span_eq_top v.span_eq).ge", "start": [1237, 1], "end": [1241, 42], "kind": "commanddeclaration"}, {"full_name": "Basis.unitsSMul_apply", "code": "theorem unitsSMul_apply {v : Basis \u03b9 R M} {w : \u03b9 \u2192 R\u02e3} (i : \u03b9) : unitsSMul v w i = w i \u2022 v i", "start": [1244, 1], "end": [1246, 44], "kind": "commanddeclaration"}, {"full_name": "Basis.coord_unitsSMul", "code": "@[simp]\ntheorem coord_unitsSMul (e : Basis \u03b9 R\u2082 M) (w : \u03b9 \u2192 R\u2082\u02e3) (i : \u03b9) :\n    (unitsSMul e w).coord i = (w i)\u207b\u00b9 \u2022 e.coord i", "start": [1249, 1], "end": [1260, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.repr_unitsSMul", "code": "@[simp]\ntheorem repr_unitsSMul (e : Basis \u03b9 R\u2082 M) (w : \u03b9 \u2192 R\u2082\u02e3) (v : M) (i : \u03b9) :\n    (e.unitsSMul w).repr v i = (w i)\u207b\u00b9 \u2022 e.repr v i", "start": [1263, 1], "end": [1266, 65], "kind": "commanddeclaration"}, {"full_name": "Basis.isUnitSMul", "code": "def isUnitSMul (v : Basis \u03b9 R M) {w : \u03b9 \u2192 R} (hw : \u2200 i, IsUnit (w i)) : Basis \u03b9 R M :=\n  unitsSMul v fun i => (hw i).unit", "start": [1269, 1], "end": [1271, 35], "kind": "commanddeclaration"}, {"full_name": "Basis.isUnitSMul_apply", "code": "theorem isUnitSMul_apply {v : Basis \u03b9 R M} {w : \u03b9 \u2192 R} (hw : \u2200 i, IsUnit (w i)) (i : \u03b9) :\n    v.isUnitSMul hw i = w i \u2022 v i", "start": [1274, 1], "end": [1276, 20], "kind": "commanddeclaration"}, {"full_name": "Basis.mkFinCons", "code": "noncomputable def mkFinCons {n : \u2115} {N : Submodule R M} (y : M) (b : Basis (Fin n) R N)\n    (hli : \u2200 (c : R), \u2200 x \u2208 N, c \u2022 y + x = 0 \u2192 c = 0) (hsp : \u2200 z : M, \u2203 c : R, z + c \u2022 y \u2208 N) :\n    Basis (Fin (n + 1)) R M :=\n  have span_b : Submodule.span R (Set.range (N.subtype \u2218 b)) = N := by\n    rw [Set.range_comp, Submodule.span_image, b.span_eq, Submodule.map_subtype_top]\n  Basis.mk (v := Fin.cons y (N.subtype \u2218 b))\n    ((b.linearIndependent.map' N.subtype (Submodule.ker_subtype _)).fin_cons' _ _\n      (by\n        rintro c \u27e8x, hx\u27e9 hc\n        rw [span_b] at hx\n        exact hli c x hx hc))\n    fun x _ => by\n      rw [Fin.range_cons, Submodule.mem_span_insert', span_b]\n      exact hsp x", "start": [1281, 1], "end": [1297, 18], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_mkFinCons", "code": "@[simp]\ntheorem coe_mkFinCons {n : \u2115} {N : Submodule R M} (y : M) (b : Basis (Fin n) R N)\n    (hli : \u2200 (c : R), \u2200 x \u2208 N, c \u2022 y + x = 0 \u2192 c = 0) (hsp : \u2200 z : M, \u2203 c : R, z + c \u2022 y \u2208 N) :\n    (mkFinCons y b hli hsp : Fin (n + 1) \u2192 M) = Fin.cons y ((\u2191) \u2218 b)", "start": [1300, 1], "end": [1307, 53], "kind": "commanddeclaration"}, {"full_name": "Basis.mkFinConsOfLE", "code": "noncomputable def mkFinConsOfLE {n : \u2115} {N O : Submodule R M} (y : M) (yO : y \u2208 O)\n    (b : Basis (Fin n) R N) (hNO : N \u2264 O) (hli : \u2200 (c : R), \u2200 x \u2208 N, c \u2022 y + x = 0 \u2192 c = 0)\n    (hsp : \u2200 z \u2208 O, \u2203 c : R, z + c \u2022 y \u2208 N) : Basis (Fin (n + 1)) R O :=\n  mkFinCons \u27e8y, yO\u27e9 (b.map (Submodule.comapSubtypeEquivOfLe hNO).symm)\n    (fun c x hc hx => hli c x (Submodule.mem_comap.mp hc) (congr_arg ((\u2191) : O \u2192 M) hx))\n    fun z => hsp z z.2", "start": [1310, 1], "end": [1318, 23], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_mkFinConsOfLE", "code": "@[simp]\ntheorem coe_mkFinConsOfLE {n : \u2115} {N O : Submodule R M} (y : M) (yO : y \u2208 O) (b : Basis (Fin n) R N)\n    (hNO : N \u2264 O) (hli : \u2200 (c : R), \u2200 x \u2208 N, c \u2022 y + x = 0 \u2192 c = 0)\n    (hsp : \u2200 z \u2208 O, \u2203 c : R, z + c \u2022 y \u2208 N) :\n    (mkFinConsOfLE y yO b hNO hli hsp : Fin (n + 1) \u2192 O) =\n      Fin.cons \u27e8y, yO\u27e9 (Submodule.ofLe hNO \u2218 b)", "start": [1321, 1], "end": [1327, 24], "kind": "commanddeclaration"}, {"full_name": "Basis.finTwoProd", "code": "protected def finTwoProd (R : Type*) [Semiring R] : Basis (Fin 2) R (R \u00d7 R) :=\n  Basis.ofEquivFun (LinearEquiv.finTwoArrow R R).symm", "start": [1330, 1], "end": [1332, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.finTwoProd_zero", "code": "@[simp]\ntheorem finTwoProd_zero (R : Type*) [Semiring R] : Basis.finTwoProd R 0 = (1, 0)", "start": [1335, 1], "end": [1337, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.finTwoProd_one", "code": "@[simp]\ntheorem finTwoProd_one (R : Type*) [Semiring R] : Basis.finTwoProd R 1 = (0, 1)", "start": [1340, 1], "end": [1342, 51], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_finTwoProd_repr", "code": "@[simp]\ntheorem coe_finTwoProd_repr {R : Type*} [Semiring R] (x : R \u00d7 R) :\n    \u21d1((Basis.finTwoProd R).repr x) = ![x.fst, x.snd]", "start": [1345, 1], "end": [1348, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.inductionOnRankAux", "code": "def Submodule.inductionOnRankAux (b : Basis \u03b9 R M) (P : Submodule R M \u2192 Sort*)\n    (ih : \u2200 N : Submodule R M,\n      (\u2200 N' \u2264 N, \u2200 x \u2208 N, (\u2200 (c : R), \u2200 y \u2208 N', c \u2022 x + y = (0 : M) \u2192 c = 0) \u2192 P N') \u2192 P N)\n    (n : \u2115) (N : Submodule R M)\n    (rank_le : \u2200 {m : \u2115} (v : Fin m \u2192 N), LinearIndependent R ((\u2191) \u2218 v : Fin m \u2192 M) \u2192 m \u2264 n) :\n    P N := by\n  haveI : DecidableEq M := Classical.decEq M\n  have Pbot : P \u22a5 := by\n    apply ih\n    intro N _ x x_mem x_ortho\n    exfalso\n    rw [mem_bot] at x_mem\n    simpa [x_mem] using x_ortho 1 0 N.zero_mem\n  induction' n with n rank_ih generalizing N\n  \u00b7 suffices N = \u22a5 by rwa [this]\n    apply Basis.eq_bot_of_rank_eq_zero b _ fun m hv => le_zero_iff.mp (rank_le _ hv)\n  apply ih\n  intro N' N'_le x x_mem x_ortho\n  apply rank_ih\n  intro m v hli\n  refine' Nat.succ_le_succ_iff.mp (rank_le (Fin.cons \u27e8x, x_mem\u27e9 fun i => \u27e8v i, N'_le (v i).2\u27e9) _)\n  convert hli.fin_cons' x _ ?_\n  \u00b7 ext i\n    refine' Fin.cases _ _ i <;> simp\n  \u00b7 intro c y hcy\n    refine' x_ortho c y (Submodule.span_le.mpr _ y.2) hcy\n    rintro _ \u27e8z, rfl\u27e9\n    exact (v z).2", "start": [1362, 1], "end": [1391, 18], "kind": "commanddeclaration"}, {"full_name": "Basis.restrictScalars", "code": "noncomputable def Basis.restrictScalars : Basis \u03b9 R (span R (Set.range b)) :=\n  Basis.span (b.linearIndependent.restrict_scalars (smul_left_injective R one_ne_zero))", "start": [1408, 1], "end": [1411, 88], "kind": "commanddeclaration"}, {"full_name": "Basis.restrictScalars_apply", "code": "@[simp]\ntheorem Basis.restrictScalars_apply (i : \u03b9) : (b.restrictScalars R i : M) = b i", "start": [1414, 1], "end": [1416, 54], "kind": "commanddeclaration"}, {"full_name": "Basis.restrictScalars_repr_apply", "code": "@[simp]\ntheorem Basis.restrictScalars_repr_apply (m : span R (Set.range b)) (i : \u03b9) :\n    algebraMap R S ((b.restrictScalars R).repr m i) = b.repr m i", "start": [1419, 1], "end": [1430, 64], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_span_iff_repr_mem", "code": "theorem Basis.mem_span_iff_repr_mem (m : M) :\n    m \u2208 span R (Set.range b) \u2194 \u2200 i, b.repr m i \u2208 Set.range (algebraMap R S)", "start": [1433, 1], "end": [1444, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Coprime/Basic.lean", "imports": ["Mathlib/Algebra/GroupPower/Ring.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Algebra/Ring/Divisibility/Basic.lean", "Mathlib/GroupTheory/GroupAction/Units.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "IsCoprime", "code": "def IsCoprime : Prop :=\n  \u2203 a b, a * x + b * y = 1", "start": [35, 1], "end": [39, 27], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.symm", "code": "@[symm]\ntheorem IsCoprime.symm (H : IsCoprime x y) : IsCoprime y x", "start": [44, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "isCoprime_comm", "code": "theorem isCoprime_comm : IsCoprime x y \u2194 IsCoprime y x", "start": [50, 1], "end": [51, 35], "kind": "commanddeclaration"}, {"full_name": "isCoprime_self", "code": "theorem isCoprime_self : IsCoprime x x \u2194 IsUnit x", "start": [54, 1], "end": [57, 41], "kind": "commanddeclaration"}, {"full_name": "isCoprime_zero_left", "code": "theorem isCoprime_zero_left : IsCoprime 0 x \u2194 IsUnit x", "start": [60, 1], "end": [63, 40], "kind": "commanddeclaration"}, {"full_name": "isCoprime_zero_right", "code": "theorem isCoprime_zero_right : IsCoprime x 0 \u2194 IsUnit x", "start": [66, 1], "end": [67, 43], "kind": "commanddeclaration"}, {"full_name": "not_isCoprime_zero_zero", "code": "theorem not_isCoprime_zero_zero [Nontrivial R] : \u00acIsCoprime (0 : R) 0", "start": [70, 1], "end": [71, 45], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.intCast", "code": "lemma IsCoprime.intCast {R : Type*} [CommRing R] {a b : \u2124} (h : IsCoprime a b) :\n    IsCoprime (a : R) (b : R) := by\n  rcases h with \u27e8u, v, H\u27e9\n  use u, v\n  rw_mod_cast [H]\n  exact Int.cast_one", "start": [74, 1], "end": [79, 21], "kind": "mathlibtacticlemma"}, {"full_name": "IsCoprime.ne_zero", "code": "theorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 \u2192 R} (h : IsCoprime (p 0) (p 1)) : p \u2260 0", "start": [81, 1], "end": [84, 34], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.ne_zero_or_ne_zero", "code": "theorem IsCoprime.ne_zero_or_ne_zero [Nontrivial R] (h : IsCoprime x y) : x \u2260 0 \u2228 y \u2260 0", "start": [87, 1], "end": [90, 34], "kind": "commanddeclaration"}, {"full_name": "isCoprime_one_left", "code": "theorem isCoprime_one_left : IsCoprime 1 x", "start": [92, 1], "end": [93, 46], "kind": "commanddeclaration"}, {"full_name": "isCoprime_one_right", "code": "theorem isCoprime_one_right : IsCoprime x 1", "start": [96, 1], "end": [97, 46], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.dvd_of_dvd_mul_right", "code": "theorem IsCoprime.dvd_of_dvd_mul_right (H1 : IsCoprime x z) (H2 : x \u2223 y * z) : x \u2223 y", "start": [100, 1], "end": [103, 51], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.dvd_of_dvd_mul_left", "code": "theorem IsCoprime.dvd_of_dvd_mul_left (H1 : IsCoprime x y) (H2 : x \u2223 y * z) : x \u2223 z", "start": [106, 1], "end": [109, 51], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_left", "code": "theorem IsCoprime.mul_left (H1 : IsCoprime x z) (H2 : IsCoprime y z) : IsCoprime (x * y) z", "start": [112, 1], "end": [121, 8], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_right", "code": "theorem IsCoprime.mul_right (H1 : IsCoprime x y) (H2 : IsCoprime x z) : IsCoprime x (y * z)", "start": [124, 1], "end": [126, 23], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_dvd", "code": "theorem IsCoprime.mul_dvd (H : IsCoprime x y) (H1 : x \u2223 z) (H2 : y \u2223 z) : x * y \u2223 z", "start": [129, 1], "end": [136, 47], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_left_left", "code": "theorem IsCoprime.of_mul_left_left (H : IsCoprime (x * y) z) : IsCoprime x z", "start": [139, 1], "end": [141, 49], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_left_right", "code": "theorem IsCoprime.of_mul_left_right (H : IsCoprime (x * y) z) : IsCoprime y z", "start": [144, 1], "end": [146, 27], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_right_left", "code": "theorem IsCoprime.of_mul_right_left (H : IsCoprime x (y * z)) : IsCoprime x y", "start": [149, 1], "end": [151, 27], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_right_right", "code": "theorem IsCoprime.of_mul_right_right (H : IsCoprime x (y * z)) : IsCoprime x z", "start": [154, 1], "end": [156, 28], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_left_iff", "code": "theorem IsCoprime.mul_left_iff : IsCoprime (x * y) z \u2194 IsCoprime x z \u2227 IsCoprime y z", "start": [159, 1], "end": [160, 87], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_right_iff", "code": "theorem IsCoprime.mul_right_iff : IsCoprime x (y * z) \u2194 IsCoprime x y \u2227 IsCoprime x z", "start": [163, 1], "end": [164, 85], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_isCoprime_of_dvd_left", "code": "theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x \u2223 y) : IsCoprime x z", "start": [167, 1], "end": [169, 37], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_isCoprime_of_dvd_right", "code": "theorem IsCoprime.of_isCoprime_of_dvd_right (h : IsCoprime z y) (hdvd : x \u2223 y) : IsCoprime z x", "start": [172, 1], "end": [173, 46], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.isUnit_of_dvd", "code": "theorem IsCoprime.isUnit_of_dvd (H : IsCoprime x y) (d : x \u2223 y) : IsUnit x", "start": [176, 1], "end": [178, 90], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.isUnit_of_dvd'", "code": "theorem IsCoprime.isUnit_of_dvd' {a b x : R} (h : IsCoprime a b) (ha : x \u2223 a) (hb : x \u2223 b) :\n    IsUnit x", "start": [181, 1], "end": [183, 51], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.map", "code": "theorem IsCoprime.map (H : IsCoprime x y) {S : Type v} [CommSemiring S] (f : R \u2192+* S) :\n    IsCoprime (f x) (f y)", "start": [186, 1], "end": [189, 74], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_add_mul_left_left", "code": "theorem IsCoprime.of_add_mul_left_left (h : IsCoprime (x + y * z) y) : IsCoprime x y", "start": [192, 1], "end": [196, 30], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_add_mul_right_left", "code": "theorem IsCoprime.of_add_mul_right_left (h : IsCoprime (x + z * y) y) : IsCoprime x y", "start": [199, 1], "end": [201, 31], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_add_mul_left_right", "code": "theorem IsCoprime.of_add_mul_left_right (h : IsCoprime x (y + x * z)) : IsCoprime x y", "start": [204, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_add_mul_right_right", "code": "theorem IsCoprime.of_add_mul_right_right (h : IsCoprime x (y + z * x)) : IsCoprime x y", "start": [209, 1], "end": [211, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_add_left_left", "code": "theorem IsCoprime.of_mul_add_left_left (h : IsCoprime (y * z + x) y) : IsCoprime x y", "start": [214, 1], "end": [216, 31], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_add_right_left", "code": "theorem IsCoprime.of_mul_add_right_left (h : IsCoprime (z * y + x) y) : IsCoprime x y", "start": [219, 1], "end": [221, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_add_left_right", "code": "theorem IsCoprime.of_mul_add_left_right (h : IsCoprime x (x * z + y)) : IsCoprime x y", "start": [224, 1], "end": [226, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_mul_add_right_right", "code": "theorem IsCoprime.of_mul_add_right_right (h : IsCoprime x (z * x + y)) : IsCoprime x y", "start": [229, 1], "end": [231, 33], "kind": "commanddeclaration"}, {"full_name": "isCoprime_group_smul_left", "code": "theorem isCoprime_group_smul_left : IsCoprime (x \u2022 y) z \u2194 IsCoprime y z", "start": [241, 1], "end": [243, 66], "kind": "commanddeclaration"}, {"full_name": "isCoprime_group_smul_right", "code": "theorem isCoprime_group_smul_right : IsCoprime y (x \u2022 z) \u2194 IsCoprime y z", "start": [246, 1], "end": [247, 81], "kind": "commanddeclaration"}, {"full_name": "isCoprime_group_smul", "code": "theorem isCoprime_group_smul : IsCoprime (x \u2022 y) (x \u2022 z) \u2194 IsCoprime y z", "start": [250, 1], "end": [251, 83], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_left_left", "code": "theorem isCoprime_mul_unit_left_left : IsCoprime (x * y) z \u2194 IsCoprime y z", "start": [260, 1], "end": [262, 39], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_left_right", "code": "theorem isCoprime_mul_unit_left_right : IsCoprime y (x * z) \u2194 IsCoprime y z", "start": [265, 1], "end": [267, 40], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_left", "code": "theorem isCoprime_mul_unit_left : IsCoprime (x * y) (x * z) \u2194 IsCoprime y z", "start": [270, 1], "end": [271, 91], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_right_left", "code": "theorem isCoprime_mul_unit_right_left : IsCoprime (y * x) z \u2194 IsCoprime y z", "start": [274, 1], "end": [275, 53], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_right_right", "code": "theorem isCoprime_mul_unit_right_right : IsCoprime y (z * x) \u2194 IsCoprime y z", "start": [278, 1], "end": [279, 54], "kind": "commanddeclaration"}, {"full_name": "isCoprime_mul_unit_right", "code": "theorem isCoprime_mul_unit_right : IsCoprime (y * x) (z * x) \u2194 IsCoprime y z", "start": [282, 1], "end": [283, 93], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_left_left", "code": "theorem add_mul_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + y * z) y", "start": [294, 1], "end": [295, 94], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_right_left", "code": "theorem add_mul_right_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + z * y) y", "start": [298, 1], "end": [300, 30], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_left_right", "code": "theorem add_mul_left_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + x * z)", "start": [303, 1], "end": [305, 35], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_right_right", "code": "theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x)", "start": [308, 1], "end": [310, 36], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_left_left", "code": "theorem mul_add_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (y * z + x) y", "start": [313, 1], "end": [315, 30], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_right_left", "code": "theorem mul_add_right_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (z * y + x) y", "start": [318, 1], "end": [320, 31], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_left_right", "code": "theorem mul_add_left_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (x * z + y)", "start": [323, 1], "end": [325, 31], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_right_right", "code": "theorem mul_add_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (z * x + y)", "start": [328, 1], "end": [330, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_left_left_iff", "code": "theorem add_mul_left_left_iff {x y z : R} : IsCoprime (x + y * z) y \u2194 IsCoprime x y", "start": [333, 1], "end": [334, 57], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_right_left_iff", "code": "theorem add_mul_right_left_iff {x y z : R} : IsCoprime (x + z * y) y \u2194 IsCoprime x y", "start": [337, 1], "end": [338, 59], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_left_right_iff", "code": "theorem add_mul_left_right_iff {x y z : R} : IsCoprime x (y + x * z) \u2194 IsCoprime x y", "start": [341, 1], "end": [342, 59], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_mul_right_right_iff", "code": "theorem add_mul_right_right_iff {x y z : R} : IsCoprime x (y + z * x) \u2194 IsCoprime x y", "start": [345, 1], "end": [346, 61], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_left_left_iff", "code": "theorem mul_add_left_left_iff {x y z : R} : IsCoprime (y * z + x) y \u2194 IsCoprime x y", "start": [349, 1], "end": [350, 57], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_right_left_iff", "code": "theorem mul_add_right_left_iff {x y z : R} : IsCoprime (z * y + x) y \u2194 IsCoprime x y", "start": [353, 1], "end": [354, 59], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_left_right_iff", "code": "theorem mul_add_left_right_iff {x y z : R} : IsCoprime x (x * z + y) \u2194 IsCoprime x y", "start": [357, 1], "end": [358, 59], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.mul_add_right_right_iff", "code": "theorem mul_add_right_right_iff {x y z : R} : IsCoprime x (z * x + y) \u2194 IsCoprime x y", "start": [361, 1], "end": [362, 61], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_left", "code": "theorem neg_left {x y : R} (h : IsCoprime x y) : IsCoprime (-x) y", "start": [365, 1], "end": [368, 20], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_left_iff", "code": "theorem neg_left_iff (x y : R) : IsCoprime (-x) y \u2194 IsCoprime x y", "start": [371, 1], "end": [372, 46], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_right", "code": "theorem neg_right {x y : R} (h : IsCoprime x y) : IsCoprime x (-y)", "start": [375, 1], "end": [376, 23], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_right_iff", "code": "theorem neg_right_iff (x y : R) : IsCoprime x (-y) \u2194 IsCoprime x y", "start": [379, 1], "end": [380, 48], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_neg", "code": "theorem neg_neg {x y : R} (h : IsCoprime x y) : IsCoprime (-x) (-y)", "start": [383, 1], "end": [384, 23], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.neg_neg_iff", "code": "theorem neg_neg_iff (x y : R) : IsCoprime (-x) (-y) \u2194 IsCoprime x y", "start": [387, 1], "end": [388, 47], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.sq_add_sq_ne_zero", "code": "theorem sq_add_sq_ne_zero {R : Type*} [LinearOrderedCommRing R] {a b : R} (h : IsCoprime a b) :\n    a ^ 2 + b ^ 2 \u2260 0", "start": [393, 1], "end": [402, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Choose/Sum.lean", "imports": ["Mathlib/Algebra/BigOperators/NatAntidiagonal.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Choose/Basic.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "Mathlib/Tactic/Ring.lean"], "premises": [{"full_name": "Commute.add_pow", "code": "theorem add_pow (h : Commute x y) (n : \u2115) :\n    (x + y) ^ n = \u2211 m in range (n + 1), x ^ m * y ^ (n - m) * choose n m", "start": [38, 1], "end": [69, 95], "kind": "commanddeclaration"}, {"full_name": "Commute.add_pow'", "code": "theorem add_pow' (h : Commute x y) (n : \u2115) :\n    (x + y) ^ n = \u2211 m in Nat.antidiagonal n, choose n m.fst \u2022 (x ^ m.fst * y ^ m.snd)", "start": [72, 1], "end": [77, 47], "kind": "commanddeclaration"}, {"full_name": "add_pow", "code": "theorem add_pow [CommSemiring R] (x y : R) (n : \u2115) :\n    (x + y) ^ n = \u2211 m in range (n + 1), x ^ m * y ^ (n - m) * choose n m", "start": [82, 1], "end": [85, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_range_choose", "code": "theorem sum_range_choose (n : \u2115) : (\u2211 m in range (n + 1), choose n m) = 2 ^ n", "start": [90, 1], "end": [93, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.sum_range_choose_halfway", "code": "theorem sum_range_choose_halfway (m : Nat) : (\u2211 i in range (m + 1), choose (2 * m + 1) i) = 4 ^ m", "start": [96, 1], "end": [117, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.choose_middle_le_pow", "code": "theorem choose_middle_le_pow (n : \u2115) : choose (2 * n + 1) n \u2264 4 ^ n", "start": [120, 1], "end": [123, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.four_pow_le_two_mul_add_one_mul_central_binom", "code": "theorem four_pow_le_two_mul_add_one_mul_central_binom (n : \u2115) :\n    4 ^ n \u2264 (2 * n + 1) * choose (2 * n) n", "start": [126, 1], "end": [132, 50], "kind": "commanddeclaration"}, {"full_name": "Int.alternating_sum_range_choose", "code": "theorem Int.alternating_sum_range_choose {n : \u2115} :\n    (\u2211 m in range (n + 1), ((-1) ^ m * \u2191(choose n m) : \u2124)) = if n = 0 then 1 else 0", "start": [137, 1], "end": [143, 69], "kind": "commanddeclaration"}, {"full_name": "Int.alternating_sum_range_choose_of_ne", "code": "theorem Int.alternating_sum_range_choose_of_ne {n : \u2115} (h0 : n \u2260 0) :\n    (\u2211 m in range (n + 1), ((-1) ^ m * \u2191(choose n m) : \u2124)) = 0", "start": [146, 1], "end": [148, 51], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_powerset_apply_card", "code": "theorem sum_powerset_apply_card {\u03b1 \u03b2 : Type*} [AddCommMonoid \u03b1] (f : \u2115 \u2192 \u03b1) {x : Finset \u03b2} :\n    \u2211 m in x.powerset, f m.card = \u2211 m in range (x.card + 1), x.card.choose m \u2022 f m", "start": [153, 1], "end": [164, 35], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_powerset_neg_one_pow_card", "code": "theorem sum_powerset_neg_one_pow_card {\u03b1 : Type*} [DecidableEq \u03b1] {x : Finset \u03b1} :\n    (\u2211 m in x.powerset, (-1 : \u2124) ^ m.card) = if x = \u2205 then 1 else 0", "start": [167, 1], "end": [170, 78], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_powerset_neg_one_pow_card_of_nonempty", "code": "theorem sum_powerset_neg_one_pow_card_of_nonempty {\u03b1 : Type*} {x : Finset \u03b1} (h0 : x.Nonempty) :\n    (\u2211 m in x.powerset, (-1 : \u2124) ^ m.card) = 0", "start": [173, 1], "end": [178, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_pow_choose_succ", "code": "@[to_additive sum_choose_succ_nsmul]\ntheorem prod_pow_choose_succ {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) (n : \u2115) :\n    (\u220f i in range (n + 2), f i (n + 1 - i) ^ (n + 1).choose i) =\n      (\u220f i in range (n + 1), f i (n + 1 - i) ^ n.choose i) *\n        \u220f i in range (n + 1), f (i + 1) (n - i) ^ n.choose i", "start": [184, 1], "end": [194, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_antidiagonal_pow_choose_succ", "code": "@[to_additive sum_antidiagonal_choose_succ_nsmul]\ntheorem prod_antidiagonal_pow_choose_succ {M : Type*} [CommMonoid M] (f : \u2115 \u2192 \u2115 \u2192 M) (n : \u2115) :\n    (\u220f ij in Nat.antidiagonal (n + 1), f ij.1 ij.2 ^ (n + 1).choose ij.1) =\n      (\u220f ij in Nat.antidiagonal n, f ij.1 (ij.2 + 1) ^ n.choose ij.1) *\n        \u220f ij in Nat.antidiagonal n, f (ij.1 + 1) ij.2 ^ n.choose ij.2", "start": [197, 1], "end": [208, 37], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_choose_succ_mul", "code": "theorem sum_choose_succ_mul (f : \u2115 \u2192 \u2115 \u2192 R) (n : \u2115) :\n    (\u2211 i in range (n + 2), ((n + 1).choose i : R) * f i (n + 1 - i)) =\n      (\u2211 i in range (n + 1), (n.choose i : R) * f i (n + 1 - i)) +\n        \u2211 i in range (n + 1), (n.choose i : R) * f (i + 1) (n - i)", "start": [211, 1], "end": [217, 60], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_antidiagonal_choose_succ_mul", "code": "theorem sum_antidiagonal_choose_succ_mul (f : \u2115 \u2192 \u2115 \u2192 R) (n : \u2115) :\n    (\u2211 ij in Nat.antidiagonal (n + 1), ((n + 1).choose ij.1 : R) * f ij.1 ij.2) =\n      (\u2211 ij in Nat.antidiagonal n, (n.choose ij.1 : R) * f ij.1 (ij.2 + 1)) +\n        \u2211 ij in Nat.antidiagonal n, (n.choose ij.2 : R) * f (ij.1 + 1) ij.2", "start": [220, 1], "end": [226, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/Monotonicity.lean", "imports": ["Mathlib/Tactic/Monotonicity/Basic.lean", "Mathlib/Tactic/Monotonicity/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/Data/Rat/Floor.lean", "imports": ["Mathlib/Algebra/EuclideanDomain/Instances.lean", "Mathlib/Algebra/Order/Floor.lean", "Mathlib/Tactic/FieldSimp.lean", "Mathlib/Data/Rat/Cast/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/Ring.lean"], "premises": [{"full_name": "Rat.floor_def'", "code": "protected theorem floor_def' (a : \u211a) : a.floor = a.num / a.den", "start": [34, 1], "end": [38, 16], "kind": "commanddeclaration"}, {"full_name": "Rat.le_floor", "code": "protected theorem le_floor {z : \u2124} : \u2200 {r : \u211a}, z \u2264 Rat.floor r \u2194 (z : \u211a) \u2264 r", "start": [40, 1], "end": [48, 36], "kind": "commanddeclaration"}, {"full_name": "Rat.floor_def", "code": "protected theorem floor_def {q : \u211a} : \u230aq\u230b = q.num / q.den", "start": [54, 1], "end": [54, 78], "kind": "commanddeclaration"}, {"full_name": "Rat.floor_int_div_nat_eq_div", "code": "theorem floor_int_div_nat_eq_div {n : \u2124} {d : \u2115} : \u230a(\u2191n : \u211a) / (\u2191d : \u211a)\u230b = n / (\u2191d : \u2124)", "start": [57, 1], "end": [67, 44], "kind": "commanddeclaration"}, {"full_name": "Rat.floor_cast", "code": "@[simp, norm_cast]\ntheorem floor_cast (x : \u211a) : \u230a(x : \u03b1)\u230b = \u230ax\u230b", "start": [70, 1], "end": [72, 66], "kind": "commanddeclaration"}, {"full_name": "Rat.ceil_cast", "code": "@[simp, norm_cast]\ntheorem ceil_cast (x : \u211a) : \u2308(x : \u03b1)\u2309 = \u2308x\u2309", "start": [75, 1], "end": [77, 75], "kind": "commanddeclaration"}, {"full_name": "Rat.round_cast", "code": "@[simp, norm_cast]\ntheorem round_cast (x : \u211a) : round (x : \u03b1) = round x", "start": [80, 1], "end": [85, 46], "kind": "commanddeclaration"}, {"full_name": "Rat.cast_fract", "code": "@[simp, norm_cast]\ntheorem cast_fract (x : \u211a) : (\u2191(fract x) : \u03b1) = fract (x : \u03b1)", "start": [88, 1], "end": [90, 56], "kind": "commanddeclaration"}, {"full_name": "Int.mod_nat_eq_sub_mul_floor_rat_div", "code": "theorem Int.mod_nat_eq_sub_mul_floor_rat_div {n : \u2124} {d : \u2115} : n % d = n - d * \u230a(n : \u211a) / d\u230b", "start": [95, 1], "end": [96, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_sub_mul_floor_rat_div_of_coprime", "code": "theorem Nat.coprime_sub_mul_floor_rat_div_of_coprime {n d : \u2115} (n_coprime_d : n.Coprime d) :\n    ((n : \u2124) - d * \u230a(n : \u211a) / d\u230b).natAbs.Coprime d", "start": [99, 1], "end": [104, 41], "kind": "commanddeclaration"}, {"full_name": "Rat.num_lt_succ_floor_mul_den", "code": "theorem num_lt_succ_floor_mul_den (q : \u211a) : q.num < (\u230aq\u230b + 1) * q.den", "start": [109, 1], "end": [128, 47], "kind": "commanddeclaration"}, {"full_name": "Rat.fract_inv_num_lt_num_of_pos", "code": "theorem fract_inv_num_lt_num_of_pos {q : \u211a} (q_pos : 0 < q) : (fract q\u207b\u00b9).num < q.num", "start": [131, 1], "end": [166, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/LeastGreatest.lean", "imports": ["Mathlib/Data/Int/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.leastOfBdd", "code": "def leastOfBdd {P : \u2124 \u2192 Prop} [DecidablePred P] (b : \u2124) (Hb : \u2200 z : \u2124, P z \u2192 b \u2264 z)\n    (Hinh : \u2203 z : \u2124, P z) : { lb : \u2124 // P lb \u2227 \u2200 z : \u2124, P z \u2192 lb \u2264 z } :=\n  have EX : \u2203 n : \u2115, P (b + n) :=\n    let \u27e8elt, Helt\u27e9 := Hinh\n    match elt, le.dest (Hb _ Helt), Helt with\n    | _, \u27e8n, rfl\u27e9, Hn => \u27e8n, Hn\u27e9\n  \u27e8b + (Nat.find EX : \u2124), Nat.find_spec EX, fun z h =>\n    match z, le.dest (Hb _ h), h with\n    | _, \u27e8_, rfl\u27e9, h => add_le_add_left (Int.ofNat_le.2 <| Nat.find_min' _ h) _\u27e9", "start": [42, 1], "end": [53, 81], "kind": "commanddeclaration"}, {"full_name": "Int.exists_least_of_bdd", "code": "theorem exists_least_of_bdd\n    {P : \u2124 \u2192 Prop}\n    [DecidablePred P]\n    (Hbdd : \u2203 b : \u2124 , \u2200 z : \u2124 , P z \u2192 b \u2264 z)\n    (Hinh : \u2203 z : \u2124 , P z) : \u2203 lb : \u2124 , P lb \u2227 \u2200 z : \u2124 , P z \u2192 lb \u2264 z", "start": [57, 1], "end": [68, 17], "kind": "commanddeclaration"}, {"full_name": "Int.coe_leastOfBdd_eq", "code": "theorem coe_leastOfBdd_eq {P : \u2124 \u2192 Prop} [DecidablePred P] {b b' : \u2124} (Hb : \u2200 z : \u2124, P z \u2192 b \u2264 z)\n    (Hb' : \u2200 z : \u2124, P z \u2192 b' \u2264 z) (Hinh : \u2203 z : \u2124, P z) :\n    (leastOfBdd b Hb Hinh : \u2124) = leastOfBdd b' Hb' Hinh", "start": [71, 1], "end": [76, 44], "kind": "commanddeclaration"}, {"full_name": "Int.greatestOfBdd", "code": "def greatestOfBdd {P : \u2124 \u2192 Prop} [DecidablePred P] (b : \u2124) (Hb : \u2200 z : \u2124, P z \u2192 z \u2264 b)\n    (Hinh : \u2203 z : \u2124, P z) : { ub : \u2124 // P ub \u2227 \u2200 z : \u2124, P z \u2192 z \u2264 ub } :=\n  have Hbdd' : \u2200 z : \u2124, P (-z) \u2192 -b \u2264 z := fun z h => neg_le.1 (Hb _ h)\n  have Hinh' : \u2203 z : \u2124, P (-z) :=\n    let \u27e8elt, Helt\u27e9 := Hinh\n    \u27e8-elt, by rw [neg_neg]; exact Helt\u27e9\n  let \u27e8lb, Plb, al\u27e9 := leastOfBdd (-b) Hbdd' Hinh'\n  \u27e8-lb, Plb, fun z h => le_neg.1 <| al _ <| by rwa [neg_neg]\u27e9", "start": [79, 1], "end": [89, 62], "kind": "commanddeclaration"}, {"full_name": "Int.exists_greatest_of_bdd", "code": "theorem exists_greatest_of_bdd\n    {P : \u2124 \u2192 Prop}\n    [DecidablePred P]\n    (Hbdd : \u2203 b : \u2124 , \u2200 z : \u2124 , P z \u2192 z \u2264 b)\n    (Hinh : \u2203 z : \u2124 , P z) : \u2203 ub : \u2124 , P ub \u2227 \u2200 z : \u2124 , P z \u2192 z \u2264 ub", "start": [92, 1], "end": [103, 19], "kind": "commanddeclaration"}, {"full_name": "Int.coe_greatestOfBdd_eq", "code": "theorem coe_greatestOfBdd_eq {P : \u2124 \u2192 Prop} [DecidablePred P] {b b' : \u2124}\n    (Hb : \u2200 z : \u2124, P z \u2192 z \u2264 b) (Hb' : \u2200 z : \u2124, P z \u2192 z \u2264 b') (Hinh : \u2203 z : \u2124, P z) :\n    (greatestOfBdd b Hb Hinh : \u2124) = greatestOfBdd b' Hb' Hinh", "start": [106, 1], "end": [111, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/CauSeq.lean", "imports": ["Mathlib/Algebra/GroupPower/Lemmas.lean", "Mathlib/Algebra/Order/Group/MinMax.lean", "Mathlib/GroupTheory/GroupAction/Pi.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/AbsoluteValue.lean", "Mathlib/Algebra/Ring/Pi.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Init/Align.lean"], "premises": [{"full_name": "exists_forall_ge_and", "code": "theorem exists_forall_ge_and {\u03b1} [LinearOrder \u03b1] {P Q : \u03b1 \u2192 Prop} :\n    (\u2203 i, \u2200 j \u2265 i, P j) \u2192 (\u2203 i, \u2200 j \u2265 i, Q j) \u2192 \u2203 i, \u2200 j \u2265 i, P j \u2227 Q j", "start": [41, 1], "end": [45, 68], "kind": "commanddeclaration"}, {"full_name": "rat_add_continuous_lemma", "code": "theorem rat_add_continuous_lemma {\u03b5 : \u03b1} (\u03b50 : 0 < \u03b5) :\n    \u2203 \u03b4 > 0, \u2200 {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b2}, abv (a\u2081 - b\u2081) < \u03b4 \u2192 abv (a\u2082 - b\u2082) < \u03b4 \u2192\n      abv (a\u2081 + a\u2082 - (b\u2081 + b\u2082)) < \u03b5", "start": [52, 1], "end": [57, 59], "kind": "commanddeclaration"}, {"full_name": "rat_mul_continuous_lemma", "code": "theorem rat_mul_continuous_lemma {\u03b5 K\u2081 K\u2082 : \u03b1} (\u03b50 : 0 < \u03b5) :\n    \u2203 \u03b4 > 0, \u2200 {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b2}, abv a\u2081 < K\u2081 \u2192 abv b\u2082 < K\u2082 \u2192 abv (a\u2081 - b\u2081) < \u03b4 \u2192\n      abv (a\u2082 - b\u2082) < \u03b4 \u2192 abv (a\u2081 * a\u2082 - b\u2081 * b\u2082) < \u03b5", "start": [60, 1], "end": [73, 42], "kind": "commanddeclaration"}, {"full_name": "rat_inv_continuous_lemma", "code": "theorem rat_inv_continuous_lemma {\u03b2 : Type*} [DivisionRing \u03b2] (abv : \u03b2 \u2192 \u03b1) [IsAbsoluteValue abv]\n    {\u03b5 K : \u03b1} (\u03b50 : 0 < \u03b5) (K0 : 0 < K) :\n    \u2203 \u03b4 > 0, \u2200 {a b : \u03b2}, K \u2264 abv a \u2192 K \u2264 abv b \u2192 abv (a - b) < \u03b4 \u2192 abv (a\u207b\u00b9 - b\u207b\u00b9) < \u03b5", "start": [76, 1], "end": [87, 9], "kind": "commanddeclaration"}, {"full_name": "IsCauSeq", "code": "def IsCauSeq {\u03b1 : Type*} [LinearOrderedField \u03b1] {\u03b2 : Type*} [Ring \u03b2] (abv : \u03b2 \u2192 \u03b1) (f : \u2115 \u2192 \u03b2) :\n    Prop :=\n  \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, abv (f j - f i) < \u03b5", "start": [92, 1], "end": [95, 45], "kind": "commanddeclaration"}, {"full_name": "IsCauSeq.cauchy\u2082", "code": "theorem cauchy\u2082 (hf : IsCauSeq abv f) {\u03b5 : \u03b1} (\u03b50 : 0 < \u03b5) :\n    \u2203 i, \u2200 j \u2265 i, \u2200 k \u2265 i, abv (f j - f k) < \u03b5", "start": [104, 1], "end": [109, 34], "kind": "commanddeclaration"}, {"full_name": "IsCauSeq.cauchy\u2083", "code": "theorem cauchy\u2083 (hf : IsCauSeq abv f) {\u03b5 : \u03b1} (\u03b50 : 0 < \u03b5) :\n    \u2203 i, \u2200 j \u2265 i, \u2200 k \u2265 j, abv (f k - f j) < \u03b5", "start": [112, 1], "end": [115, 50], "kind": "commanddeclaration"}, {"full_name": "IsCauSeq.add", "code": "theorem add (hf : IsCauSeq abv f) (hg : IsCauSeq abv g) : IsCauSeq abv (f + g)", "start": [118, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "CauSeq", "code": "def CauSeq {\u03b1 : Type*} [LinearOrderedField \u03b1] (\u03b2 : Type*) [Ring \u03b2] (abv : \u03b2 \u2192 \u03b1) : Type _ :=\n  { f : \u2115 \u2192 \u03b2 // IsCauSeq abv f }", "start": [128, 1], "end": [131, 34], "kind": "commanddeclaration"}, {"full_name": "CauSeq.ext", "code": "theorem ext {f g : CauSeq \u03b2 abv} (h : \u2200 i, f i = g i) : f = g", "start": [151, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "CauSeq.isCauSeq", "code": "theorem isCauSeq (f : CauSeq \u03b2 abv) : IsCauSeq abv f", "start": [155, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.cauchy", "code": "theorem cauchy (f : CauSeq \u03b2 abv) : \u2200 {\u03b5}, 0 < \u03b5 \u2192 \u2203 i, \u2200 j \u2265 i, abv (f j - f i) < \u03b5", "start": [159, 1], "end": [159, 93], "kind": "commanddeclaration"}, {"full_name": "CauSeq.ofEq", "code": "def ofEq (f : CauSeq \u03b2 abv) (g : \u2115 \u2192 \u03b2) (e : \u2200 i, f i = g i) : CauSeq \u03b2 abv :=\n  \u27e8g, fun \u03b5 => by rw [show g = f from (funext e).symm]; exact f.cauchy\u27e9", "start": [162, 1], "end": [165, 72], "kind": "commanddeclaration"}, {"full_name": "CauSeq.cauchy\u2082", "code": "theorem cauchy\u2082 (f : CauSeq \u03b2 abv) {\u03b5} :\n    0 < \u03b5 \u2192 \u2203 i, \u2200 (j) (_ : j \u2265 i) (k) (_ : k \u2265 i), abv (f j - f k) < \u03b5", "start": [172, 1], "end": [174, 14], "kind": "commanddeclaration"}, {"full_name": "CauSeq.cauchy\u2083", "code": "theorem cauchy\u2083 (f : CauSeq \u03b2 abv) {\u03b5} : 0 < \u03b5 \u2192 \u2203 i, \u2200 j \u2265 i, \u2200 k \u2265 j, abv (f k - f j) < \u03b5", "start": [177, 1], "end": [178, 14], "kind": "commanddeclaration"}, {"full_name": "CauSeq.bounded", "code": "theorem bounded (f : CauSeq \u03b2 abv) : \u2203 r, \u2200 i, abv (f i) < r", "start": [181, 1], "end": [194, 21], "kind": "commanddeclaration"}, {"full_name": "CauSeq.bounded'", "code": "theorem bounded' (f : CauSeq \u03b2 abv) (x : \u03b1) : \u2203 r > x, \u2200 i, abv (f i) < r", "start": [197, 1], "end": [200, 44], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (f g : CauSeq \u03b2 abv) : \u21d1(f + g) = (f : \u2115 \u2192 \u03b2) + g", "start": [206, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.add_apply", "code": "@[simp, norm_cast]\ntheorem add_apply (f g : CauSeq \u03b2 abv) (i : \u2115) : (f + g) i = f i + g i", "start": [211, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const", "code": "def const (x : \u03b2) : CauSeq \u03b2 abv :=\n  \u27e8fun _ => x, fun \u03b5 \u03b50 => \u27e80, fun j _ => by simpa [abv_zero] using \u03b50\u27e9\u27e9", "start": [218, 1], "end": [220, 73], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_const", "code": "@[simp, norm_cast]\ntheorem coe_const (x : \u03b2) : (const x : \u2115 \u2192 \u03b2) = Function.const \u2115 x", "start": [228, 1], "end": [230, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_apply", "code": "@[simp, norm_cast]\ntheorem const_apply (x : \u03b2) (i : \u2115) : (const x : \u2115 \u2192 \u03b2) i = x", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_inj", "code": "theorem const_inj {x y : \u03b2} : (const x : CauSeq \u03b2 abv) = const y \u2194 x = y", "start": [238, 1], "end": [239, 78], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u21d1(0 : CauSeq \u03b2 abv) = 0", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : \u21d1(1 : CauSeq \u03b2 abv) = 1", "start": [256, 1], "end": [258, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.zero_apply", "code": "@[simp, norm_cast]\ntheorem zero_apply (i) : (0 : CauSeq \u03b2 abv) i = 0", "start": [261, 1], "end": [263, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.one_apply", "code": "@[simp, norm_cast]\ntheorem one_apply (i) : (1 : CauSeq \u03b2 abv) i = 1", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_zero", "code": "@[simp]\ntheorem const_zero : const 0 = 0", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_one", "code": "@[simp]\ntheorem const_one : const 1 = 1", "start": [276, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_add", "code": "theorem const_add (x y : \u03b2) : const (x + y) = const x + const y", "start": [281, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (f g : CauSeq \u03b2 abv) : \u21d1(f * g) = (f : \u2115 \u2192 \u03b2) * g", "start": [296, 1], "end": [298, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_apply", "code": "@[simp, norm_cast]\ntheorem mul_apply (f g : CauSeq \u03b2 abv) (i : \u2115) : (f * g) i = f i * g i", "start": [301, 1], "end": [303, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_mul", "code": "theorem const_mul (x y : \u03b2) : const (x * y) = const x * const y", "start": [306, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (f : CauSeq \u03b2 abv) : \u21d1(-f) = -f", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.neg_apply", "code": "@[simp, norm_cast]\ntheorem neg_apply (f : CauSeq \u03b2 abv) (i) : (-f) i = -f i", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_neg", "code": "theorem const_neg (x : \u03b2) : const (-x) = -const x", "start": [323, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (f g : CauSeq \u03b2 abv) : \u21d1(f - g) = (f : \u2115 \u2192 \u03b2) - g", "start": [330, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sub_apply", "code": "@[simp, norm_cast]\ntheorem sub_apply (f g : CauSeq \u03b2 abv) (i : \u2115) : (f - g) i = f i - g i", "start": [335, 1], "end": [337, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_sub", "code": "theorem const_sub (x y : \u03b2) : const (x - y) = const x - const y", "start": [340, 1], "end": [341, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (a : G) (f : CauSeq \u03b2 abv) : \u21d1(a \u2022 f) = a \u2022 (f : \u2115 \u2192 \u03b2)", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.smul_apply", "code": "@[simp, norm_cast]\ntheorem smul_apply (a : G) (f : CauSeq \u03b2 abv) (i : \u2115) : (a \u2022 f) i = a \u2022 f i", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_smul", "code": "theorem const_smul (a : G) (x : \u03b2) : const (a \u2022 x) = a \u2022 const x", "start": [361, 1], "end": [362, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.addGroup", "code": "instance addGroup : AddGroup (CauSeq \u03b2 abv) :=\n  Function.Injective.addGroup Subtype.val Subtype.val_injective rfl coe_add coe_neg coe_sub\n    (fun _ _ => coe_smul _ _) fun _ _ => coe_smul _ _", "start": [370, 1], "end": [372, 54], "kind": "commanddeclaration"}, {"full_name": "CauSeq.instNatCast", "code": "instance instNatCast : NatCast (CauSeq \u03b2 abv) := \u27e8fun n => const n\u27e9", "start": [374, 1], "end": [374, 68], "kind": "commanddeclaration"}, {"full_name": "CauSeq.instIntCast", "code": "instance instIntCast : IntCast (CauSeq \u03b2 abv) := \u27e8fun n => const n\u27e9", "start": [376, 1], "end": [376, 68], "kind": "commanddeclaration"}, {"full_name": "CauSeq.addGroupWithOne", "code": "instance addGroupWithOne : AddGroupWithOne (CauSeq \u03b2 abv) :=\n  Function.Injective.addGroupWithOne Subtype.val Subtype.val_injective rfl rfl\n  coe_add coe_neg coe_sub\n  (by intros; rfl)\n  (by intros; rfl)\n  (by intros; rfl)\n  (by intros; rfl)", "start": [378, 1], "end": [384, 19], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (f : CauSeq \u03b2 abv) (n : \u2115) : \u21d1(f ^ n) = (f : \u2115 \u2192 \u03b2) ^ n", "start": [390, 1], "end": [392, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.pow_apply", "code": "@[simp, norm_cast]\ntheorem pow_apply (f : CauSeq \u03b2 abv) (n i : \u2115) : (f ^ n) i = f i ^ n", "start": [395, 1], "end": [397, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_pow", "code": "theorem const_pow (x : \u03b2) (n : \u2115) : const (x ^ n) = const x ^ n", "start": [400, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.ring", "code": "instance ring : Ring (CauSeq \u03b2 abv) :=\n  Function.Injective.ring Subtype.val Subtype.val_injective rfl rfl coe_add coe_mul coe_neg coe_sub\n    (fun _ _ => coe_smul _ _) (fun _ _ => coe_smul _ _) coe_pow (fun _ => rfl) fun _ => rfl", "start": [404, 1], "end": [406, 92], "kind": "commanddeclaration"}, {"full_name": "CauSeq.LimZero", "code": "def LimZero {abv : \u03b2 \u2192 \u03b1} (f : CauSeq \u03b2 abv) : Prop :=\n  \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, abv (f j) < \u03b5", "start": [412, 1], "end": [414, 39], "kind": "commanddeclaration"}, {"full_name": "CauSeq.add_limZero", "code": "theorem add_limZero {f g : CauSeq \u03b2 abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f + g)", "start": [417, 1], "end": [421, 85], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_limZero_right", "code": "theorem mul_limZero_right (f : CauSeq \u03b2 abv) {g} (hg : LimZero g) : LimZero (f * g)", "start": [424, 1], "end": [429, 74], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_limZero_left", "code": "theorem mul_limZero_left {f} (g : CauSeq \u03b2 abv) (hg : LimZero f) : LimZero (f * g)", "start": [432, 1], "end": [437, 62], "kind": "commanddeclaration"}, {"full_name": "CauSeq.neg_limZero", "code": "theorem neg_limZero {f : CauSeq \u03b2 abv} (hf : LimZero f) : LimZero (-f)", "start": [440, 1], "end": [442, 31], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sub_limZero", "code": "theorem sub_limZero {f g : CauSeq \u03b2 abv} (hf : LimZero f) (hg : LimZero g) : LimZero (f - g)", "start": [445, 1], "end": [446, 68], "kind": "commanddeclaration"}, {"full_name": "CauSeq.limZero_sub_rev", "code": "theorem limZero_sub_rev {f g : CauSeq \u03b2 abv} (hfg : LimZero (f - g)) : LimZero (g - f)", "start": [449, 1], "end": [450, 30], "kind": "commanddeclaration"}, {"full_name": "CauSeq.zero_limZero", "code": "theorem zero_limZero : LimZero (0 : CauSeq \u03b2 abv)", "start": [453, 1], "end": [454, 62], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_limZero", "code": "theorem const_limZero {x : \u03b2} : LimZero (const x) \u2194 x = 0", "start": [457, 1], "end": [463, 36], "kind": "commanddeclaration"}, {"full_name": "CauSeq.equiv", "code": "instance equiv : Setoid (CauSeq \u03b2 abv) :=\n  \u27e8fun f g => LimZero (f - g),\n    \u27e8fun f => by simp [zero_limZero],\n    fun f \u03b5 h\u03b5 => by simpa using neg_limZero f \u03b5 h\u03b5,\n    fun fg gh => by simpa using add_limZero fg gh\u27e9\u27e9", "start": [466, 1], "end": [470, 52], "kind": "commanddeclaration"}, {"full_name": "CauSeq.add_equiv_add", "code": "theorem add_equiv_add {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 + g1 \u2248 f2 + g2", "start": [473, 1], "end": [474, 84], "kind": "commanddeclaration"}, {"full_name": "CauSeq.neg_equiv_neg", "code": "theorem neg_equiv_neg {f g : CauSeq \u03b2 abv} (hf : f \u2248 g) : -f \u2248 -g", "start": [477, 1], "end": [478, 45], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sub_equiv_sub", "code": "theorem sub_equiv_sub {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 - g1 \u2248 f2 - g2", "start": [481, 1], "end": [482, 98], "kind": "commanddeclaration"}, {"full_name": "CauSeq.equiv_def\u2083", "code": "theorem equiv_def\u2083 {f g : CauSeq \u03b2 abv} (h : f \u2248 g) {\u03b5 : \u03b1} (\u03b50 : 0 < \u03b5) :\n    \u2203 i, \u2200 j \u2265 i, \u2200 k \u2265 j, abv (f k - g j) < \u03b5", "start": [485, 1], "end": [490, 50], "kind": "commanddeclaration"}, {"full_name": "CauSeq.limZero_congr", "code": "theorem limZero_congr {f g : CauSeq \u03b2 abv} (h : f \u2248 g) : LimZero f \u2194 LimZero g", "start": [493, 1], "end": [494, 99], "kind": "commanddeclaration"}, {"full_name": "CauSeq.abv_pos_of_not_limZero", "code": "theorem abv_pos_of_not_limZero {f : CauSeq \u03b2 abv} (hf : \u00acLimZero f) :\n    \u2203 K > 0, \u2203 i, \u2200 j \u2265 i, K \u2264 abv (f j)", "start": [497, 1], "end": [507, 43], "kind": "commanddeclaration"}, {"full_name": "CauSeq.of_near", "code": "theorem of_near (f : \u2115 \u2192 \u03b2) (g : CauSeq \u03b2 abv) (h : \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, abv (f j - g j) < \u03b5) :\n    IsCauSeq abv f", "start": [510, 1], "end": [518, 100], "kind": "commanddeclaration"}, {"full_name": "CauSeq.not_limZero_of_not_congr_zero", "code": "theorem not_limZero_of_not_congr_zero {f : CauSeq _ abv} (hf : \u00acf \u2248 0) : \u00acLimZero f", "start": [521, 1], "end": [524, 16], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_equiv_zero", "code": "theorem mul_equiv_zero (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f \u2248 0) : g * f \u2248 0", "start": [527, 1], "end": [530, 36], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_equiv_zero'", "code": "theorem mul_equiv_zero' (g : CauSeq _ abv) {f : CauSeq _ abv} (hf : f \u2248 0) : f * g \u2248 0", "start": [533, 1], "end": [536, 36], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_not_equiv_zero", "code": "theorem mul_not_equiv_zero {f g : CauSeq _ abv} (hf : \u00acf \u2248 0) (hg : \u00acg \u2248 0) : \u00acf * g \u2248 0", "start": [539, 1], "end": [555, 9], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_equiv", "code": "theorem const_equiv {x y : \u03b2} : const x \u2248 const y \u2194 x = y", "start": [558, 1], "end": [559, 69], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_equiv_mul", "code": "theorem mul_equiv_mul {f1 f2 g1 g2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (hg : g1 \u2248 g2) :\n    f1 * g1 \u2248 f2 * g2", "start": [562, 1], "end": [568, 58], "kind": "commanddeclaration"}, {"full_name": "CauSeq.smul_equiv_smul", "code": "theorem smul_equiv_smul [SMul G \u03b2] [IsScalarTower G \u03b2 \u03b2] {f1 f2 : CauSeq \u03b2 abv} (c : G)\n    (hf : f1 \u2248 f2) : c \u2022 f1 \u2248 c \u2022 f2", "start": [576, 1], "end": [579, 65], "kind": "commanddeclaration"}, {"full_name": "CauSeq.pow_equiv_pow", "code": "theorem pow_equiv_pow {f1 f2 : CauSeq \u03b2 abv} (hf : f1 \u2248 f2) (n : \u2115) : f1 ^ n \u2248 f2 ^ n", "start": [582, 1], "end": [585, 52], "kind": "commanddeclaration"}, {"full_name": "CauSeq.one_not_equiv_zero", "code": "theorem one_not_equiv_zero : \u00acconst abv 1 \u2248 const abv 0", "start": [594, 1], "end": [602, 26], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inv_aux", "code": "theorem inv_aux {f : CauSeq \u03b2 abv} (hf : \u00acLimZero f) :\n    \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, abv ((f j)\u207b\u00b9 - (f i)\u207b\u00b9) < \u03b5", "start": [611, 1], "end": [619, 34], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inv", "code": "def inv (f : CauSeq \u03b2 abv) (hf : \u00acLimZero f) : CauSeq \u03b2 abv :=\n  \u27e8_, inv_aux hf\u27e9", "start": [622, 1], "end": [625, 18], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv {f : CauSeq \u03b2 abv} (hf) : \u21d1(inv f hf) = (f : \u2115 \u2192 \u03b2)\u207b\u00b9", "start": [628, 1], "end": [630, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inv_apply", "code": "@[simp, norm_cast]\ntheorem inv_apply {f : CauSeq \u03b2 abv} (hf i) : inv f hf i = (f i)\u207b\u00b9", "start": [633, 1], "end": [635, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inv_mul_cancel", "code": "theorem inv_mul_cancel {f : CauSeq \u03b2 abv} (hf) : inv f hf * f \u2248 1", "start": [638, 1], "end": [640, 98], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_inv_cancel", "code": "theorem mul_inv_cancel {f : CauSeq \u03b2 abv} (hf) : f * inv f hf \u2248 1", "start": [643, 1], "end": [645, 98], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_inv", "code": "theorem const_inv {x : \u03b2} (hx : x \u2260 0) :\n    const abv x\u207b\u00b9 = inv (const abv x) (by rwa [const_limZero])", "start": [648, 1], "end": [650, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Pos", "code": "def Pos (f : CauSeq \u03b1 abs) : Prop :=\n  \u2203 K > 0, \u2203 i, \u2200 j \u2265 i, K \u2264 f j", "start": [660, 1], "end": [662, 33], "kind": "commanddeclaration"}, {"full_name": "CauSeq.not_limZero_of_pos", "code": "theorem not_limZero_of_pos {f : CauSeq \u03b1 abs} : Pos f \u2192 \u00acLimZero f", "start": [665, 1], "end": [669, 36], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_pos", "code": "theorem const_pos {x : \u03b1} : Pos (const x) \u2194 0 < x", "start": [672, 1], "end": [673, 95], "kind": "commanddeclaration"}, {"full_name": "CauSeq.add_pos", "code": "theorem add_pos {f g : CauSeq \u03b1 abs} : Pos f \u2192 Pos g \u2192 Pos (f + g)", "start": [676, 1], "end": [681, 24], "kind": "commanddeclaration"}, {"full_name": "CauSeq.pos_add_limZero", "code": "theorem pos_add_limZero {f g : CauSeq \u03b1 abs} : Pos f \u2192 LimZero g \u2192 Pos (f + g)", "start": [684, 1], "end": [690, 56], "kind": "commanddeclaration"}, {"full_name": "CauSeq.mul_pos", "code": "protected theorem mul_pos {f g : CauSeq \u03b1 abs} : Pos f \u2192 Pos g \u2192 Pos (f * g)", "start": [693, 1], "end": [698, 66], "kind": "commanddeclaration"}, {"full_name": "CauSeq.trichotomy", "code": "theorem trichotomy (f : CauSeq \u03b1 abs) : Pos f \u2228 LimZero f \u2228 Pos (-f)", "start": [701, 1], "end": [717, 57], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_of_lt_of_eq", "code": "theorem lt_of_lt_of_eq {f g h : CauSeq \u03b1 abs} (fg : f < g) (gh : g \u2248 h) : f < h", "start": [726, 1], "end": [729, 9], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_of_eq_of_lt", "code": "theorem lt_of_eq_of_lt {f g h : CauSeq \u03b1 abs} (fg : f \u2248 g) (gh : g < h) : f < h", "start": [732, 1], "end": [734, 59], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_trans", "code": "theorem lt_trans {f g h : CauSeq \u03b1 abs} (fg : f < g) (gh : g < h) : f < h", "start": [737, 1], "end": [740, 9], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_irrefl", "code": "theorem lt_irrefl {f : CauSeq \u03b1 abs} : \u00acf < f", "start": [743, 1], "end": [744, 55], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_of_eq_of_le", "code": "theorem le_of_eq_of_le {f g h : CauSeq \u03b1 abs} (hfg : f \u2248 g) (hgh : g \u2264 h) : f \u2264 h", "start": [747, 1], "end": [748, 76], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_of_le_of_eq", "code": "theorem le_of_le_of_eq {f g h : CauSeq \u03b1 abs} (hfg : f \u2264 g) (hgh : g \u2248 h) : f \u2264 h", "start": [751, 1], "end": [752, 96], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_antisymm", "code": "theorem le_antisymm {f g : CauSeq \u03b1 abs} (fg : f \u2264 g) (gf : g \u2264 f) : f \u2248 g", "start": [769, 1], "end": [770, 36], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_total", "code": "theorem lt_total (f g : CauSeq \u03b1 abs) : f < g \u2228 f \u2248 g \u2228 g < f", "start": [773, 1], "end": [775, 66], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_total", "code": "theorem le_total (f g : CauSeq \u03b1 abs) : f \u2264 g \u2228 g \u2264 f", "start": [778, 1], "end": [779, 47], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_lt", "code": "theorem const_lt {x y : \u03b1} : const x < const y \u2194 x < y", "start": [782, 1], "end": [783, 57], "kind": "commanddeclaration"}, {"full_name": "CauSeq.const_le", "code": "theorem const_le {x y : \u03b1} : const x \u2264 const y \u2194 x \u2264 y", "start": [786, 1], "end": [787, 60], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_of_exists", "code": "theorem le_of_exists {f g : CauSeq \u03b1 abs} (h : \u2203 i, \u2200 j \u2265 i, f j \u2264 g j) : f \u2264 g", "start": [790, 1], "end": [796, 69], "kind": "commanddeclaration"}, {"full_name": "CauSeq.exists_gt", "code": "theorem exists_gt (f : CauSeq \u03b1 abs) : \u2203 a : \u03b1, f < const a", "start": [799, 1], "end": [803, 39], "kind": "commanddeclaration"}, {"full_name": "CauSeq.exists_lt", "code": "theorem exists_lt (f : CauSeq \u03b1 abs) : \u2203 a : \u03b1, const a < f", "start": [806, 1], "end": [808, 82], "kind": "commanddeclaration"}, {"full_name": "CauSeq.rat_sup_continuous_lemma", "code": "theorem rat_sup_continuous_lemma {\u03b5 : \u03b1} {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    abs (a\u2081 - b\u2081) < \u03b5 \u2192 abs (a\u2082 - b\u2082) < \u03b5 \u2192 abs (a\u2081 \u2294 a\u2082 - b\u2081 \u2294 b\u2082) < \u03b5", "start": [812, 1], "end": [814, 59], "kind": "commanddeclaration"}, {"full_name": "CauSeq.rat_inf_continuous_lemma", "code": "theorem rat_inf_continuous_lemma {\u03b5 : \u03b1} {a\u2081 a\u2082 b\u2081 b\u2082 : \u03b1} :\n    abs (a\u2081 - b\u2081) < \u03b5 \u2192 abs (a\u2082 - b\u2082) < \u03b5 \u2192 abs (a\u2081 \u2293 a\u2082 - b\u2081 \u2293 b\u2082) < \u03b5", "start": [818, 1], "end": [820, 59], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_sup", "code": "@[simp, norm_cast]\ntheorem coe_sup (f g : CauSeq \u03b1 abs) : \u21d1(f \u2294 g) = (f : \u2115 \u2192 \u03b1) \u2294 g", "start": [837, 1], "end": [839, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (f g : CauSeq \u03b1 abs) : \u21d1(f \u2293 g) = (f : \u2115 \u2192 \u03b1) \u2293 g", "start": [842, 1], "end": [844, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_limZero", "code": "theorem sup_limZero {f g : CauSeq \u03b1 abs} (hf : LimZero f) (hg : LimZero g) : LimZero (f \u2294 g)", "start": [847, 1], "end": [852, 72], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_limZero", "code": "theorem inf_limZero {f g : CauSeq \u03b1 abs} (hf : LimZero f) (hg : LimZero g) : LimZero (f \u2293 g)", "start": [855, 1], "end": [860, 72], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_equiv_sup", "code": "theorem sup_equiv_sup {a\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs} (ha : a\u2081 \u2248 a\u2082) (hb : b\u2081 \u2248 b\u2082) :\n    a\u2081 \u2294 b\u2081 \u2248 a\u2082 \u2294 b\u2082", "start": [863, 1], "end": [871, 76], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_equiv_inf", "code": "theorem inf_equiv_inf {a\u2081 b\u2081 a\u2082 b\u2082 : CauSeq \u03b1 abs} (ha : a\u2081 \u2248 a\u2082) (hb : b\u2081 \u2248 b\u2082) :\n    a\u2081 \u2293 b\u2081 \u2248 a\u2082 \u2293 b\u2082", "start": [874, 1], "end": [882, 76], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_lt", "code": "protected theorem sup_lt {a b c : CauSeq \u03b1 abs} (ha : a < c) (hb : b < c) : a \u2294 b < c", "start": [885, 1], "end": [889, 47], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_inf", "code": "protected theorem lt_inf {a b c : CauSeq \u03b1 abs} (hb : a < b) (hc : a < c) : a < b \u2293 c", "start": [892, 1], "end": [896, 48], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_idem", "code": "@[simp]\nprotected theorem sup_idem (a : CauSeq \u03b1 abs) : a \u2294 a = a", "start": [899, 1], "end": [901, 23], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_idem", "code": "@[simp]\nprotected theorem inf_idem (a : CauSeq \u03b1 abs) : a \u2293 a = a", "start": [904, 1], "end": [906, 23], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_comm", "code": "protected theorem sup_comm (a b : CauSeq \u03b1 abs) : a \u2294 b = b \u2294 a", "start": [909, 1], "end": [910, 23], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_comm", "code": "protected theorem inf_comm (a b : CauSeq \u03b1 abs) : a \u2293 b = b \u2293 a", "start": [913, 1], "end": [914, 23], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_eq_right", "code": "protected theorem sup_eq_right {a b : CauSeq \u03b1 abs} (h : a \u2264 b) : a \u2294 b \u2248 b", "start": [917, 1], "end": [927, 25], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_eq_right", "code": "protected theorem inf_eq_right {a b : CauSeq \u03b1 abs} (h : b \u2264 a) : a \u2293 b \u2248 b", "start": [930, 1], "end": [939, 25], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_eq_left", "code": "protected theorem sup_eq_left {a b : CauSeq \u03b1 abs} (h : b \u2264 a) : a \u2294 b \u2248 a", "start": [942, 1], "end": [943, 59], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_eq_left", "code": "protected theorem inf_eq_left {a b : CauSeq \u03b1 abs} (h : a \u2264 b) : a \u2293 b \u2248 a", "start": [946, 1], "end": [947, 59], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_sup_left", "code": "protected theorem le_sup_left {a b : CauSeq \u03b1 abs} : a \u2264 a \u2294 b", "start": [950, 1], "end": [951, 43], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_le_left", "code": "protected theorem inf_le_left {a b : CauSeq \u03b1 abs} : a \u2293 b \u2264 a", "start": [954, 1], "end": [955, 43], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_sup_right", "code": "protected theorem le_sup_right {a b : CauSeq \u03b1 abs} : b \u2264 a \u2294 b", "start": [958, 1], "end": [959, 44], "kind": "commanddeclaration"}, {"full_name": "CauSeq.inf_le_right", "code": "protected theorem inf_le_right {a b : CauSeq \u03b1 abs} : a \u2293 b \u2264 b", "start": [962, 1], "end": [963, 44], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_le", "code": "protected theorem sup_le {a b c : CauSeq \u03b1 abs} (ha : a \u2264 c) (hb : b \u2264 c) : a \u2294 b \u2264 c", "start": [966, 1], "end": [975, 32], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_inf", "code": "protected theorem le_inf {a b c : CauSeq \u03b1 abs} (hb : a \u2264 b) (hc : a \u2264 c) : a \u2264 b \u2293 c", "start": [978, 1], "end": [987, 46], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_inf_distrib_left", "code": "protected theorem sup_inf_distrib_left (a b c : CauSeq \u03b1 abs) : a \u2294 b \u2293 c = (a \u2294 b) \u2293 (a \u2294 c)", "start": [993, 1], "end": [994, 54], "kind": "commanddeclaration"}, {"full_name": "CauSeq.sup_inf_distrib_right", "code": "protected theorem sup_inf_distrib_right (a b c : CauSeq \u03b1 abs) : a \u2293 b \u2294 c = (a \u2294 c) \u2293 (b \u2294 c)", "start": [997, 1], "end": [998, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Pi.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Algebra/Ring/Pi.lean", "Mathlib/Algebra/Order/Ring/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.orderedCommMonoid", "code": "@[to_additive\n      \"The product of a family of ordered additive commutative monoids is\nan ordered additive commutative monoid.\"]\ninstance orderedCommMonoid {\u03b9 : Type*} {Z : \u03b9 \u2192 Type*} [\u2200 i, OrderedCommMonoid (Z i)] :\n    OrderedCommMonoid (\u2200 i, Z i) :=\n  { Pi.partialOrder, Pi.commMonoid with\n    mul_le_mul_left := fun _ _ w _ i => mul_le_mul_left' (w i) _ }", "start": [28, 1], "end": [35, 67], "kind": "commanddeclaration"}, {"full_name": "Pi.existsMulOfLe", "code": "@[to_additive]\ninstance existsMulOfLe {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, LE (\u03b1 i)] [\u2200 i, Mul (\u03b1 i)]\n    [\u2200 i, ExistsMulOfLE (\u03b1 i)] : ExistsMulOfLE (\u2200 i, \u03b1 i) :=\n  \u27e8fun h =>\n    \u27e8fun i => (exists_mul_of_le <| h i).choose,\n      funext fun i => (exists_mul_of_le <| h i).choose_spec\u27e9\u27e9", "start": [39, 1], "end": [44, 62], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedCancelCommMonoid", "code": "@[to_additive]\ninstance orderedCancelCommMonoid [\u2200 i, OrderedCancelCommMonoid <| f i] :\n    OrderedCancelCommMonoid (\u2200 i : I, f i) :=\n  { Pi.partialOrder, Pi.commMonoid with\n    npow := Monoid.npow,\n    le_of_mul_le_mul_left := fun _ _ _ h i =>\n      OrderedCancelCommMonoid.le_of_mul_le_mul_left _ _ _ (h i)\n    mul_le_mul_left := fun _ _ c h i =>\n      OrderedCancelCommMonoid.mul_le_mul_left _ _ (c i) (h i) }", "start": [57, 1], "end": [65, 64], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedCommGroup", "code": "@[to_additive]\ninstance orderedCommGroup [\u2200 i, OrderedCommGroup <| f i] : OrderedCommGroup (\u2200 i : I, f i) :=\n  { Pi.commGroup, Pi.orderedCommMonoid with\n    npow := Monoid.npow }", "start": [78, 1], "end": [81, 26], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedSemiring", "code": "instance orderedSemiring [\u2200 i, OrderedSemiring (f i)] : OrderedSemiring (\u2200 i, f i) :=\n  { Pi.semiring,\n    Pi.partialOrder with\n    add_le_add_left := fun _ _ hab _ _ => add_le_add_left (hab _) _\n    zero_le_one := fun i => zero_le_one (\u03b1 := f i)\n    mul_le_mul_of_nonneg_left := fun _ _ _ hab hc _ => mul_le_mul_of_nonneg_left (hab _) <| hc _\n    mul_le_mul_of_nonneg_right := fun _ _ _ hab hc _ => mul_le_mul_of_nonneg_right (hab _) <| hc _ }", "start": [85, 1], "end": [91, 101], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedCommSemiring", "code": "instance orderedCommSemiring [\u2200 i, OrderedCommSemiring (f i)] : OrderedCommSemiring (\u2200 i, f i) :=\n  { Pi.commSemiring, Pi.orderedSemiring with }", "start": [94, 1], "end": [95, 47], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedRing", "code": "instance orderedRing [\u2200 i, OrderedRing (f i)] : OrderedRing (\u2200 i, f i) :=\n  { Pi.ring, Pi.orderedSemiring with mul_nonneg := fun _ _ ha hb _ => mul_nonneg (ha _) (hb _) }", "start": [98, 1], "end": [99, 97], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedCommRing", "code": "instance orderedCommRing [\u2200 i, OrderedCommRing (f i)] : OrderedCommRing (\u2200 i, f i) :=\n  { Pi.commRing, Pi.orderedRing with }", "start": [102, 1], "end": [103, 39], "kind": "commanddeclaration"}, {"full_name": "Function.one_le_const_of_one_le", "code": "@[to_additive const_nonneg_of_nonneg]\ntheorem one_le_const_of_one_le (ha : 1 \u2264 a) : 1 \u2264 const \u03b2 a", "start": [112, 1], "end": [113, 75], "kind": "commanddeclaration"}, {"full_name": "Function.const_le_one_of_le_one", "code": "@[to_additive]\ntheorem const_le_one_of_le_one (ha : a \u2264 1) : const \u03b2 a \u2264 1", "start": [117, 1], "end": [118, 75], "kind": "commanddeclaration"}, {"full_name": "Function.one_le_const", "code": "@[to_additive (attr := simp) const_nonneg]\ntheorem one_le_const : 1 \u2264 const \u03b2 a \u2194 1 \u2264 a", "start": [124, 1], "end": [126, 30], "kind": "commanddeclaration"}, {"full_name": "Function.one_lt_const", "code": "@[to_additive (attr := simp) const_pos]\ntheorem one_lt_const : 1 < const \u03b2 a \u2194 1 < a", "start": [130, 1], "end": [132, 30], "kind": "commanddeclaration"}, {"full_name": "Function.const_le_one", "code": "@[to_additive (attr := simp)]\ntheorem const_le_one : const \u03b2 a \u2264 1 \u2194 a \u2264 1", "start": [136, 1], "end": [138, 30], "kind": "commanddeclaration"}, {"full_name": "Function.const_lt_one", "code": "@[to_additive (attr := simp)]\ntheorem const_lt_one : const \u03b2 a < 1 \u2194 a < 1", "start": [142, 1], "end": [144, 30], "kind": "commanddeclaration"}, {"full_name": "Function.one_le_extend", "code": "@[to_additive extend_nonneg] lemma one_le_extend (hg : 1 \u2264 g) (he : 1 \u2264 e) : 1 \u2264 extend f g e :=\n  fun _b \u21a6 by classical exact one_le_dite (fun _ \u21a6 hg _) (fun _ \u21a6 he _)", "start": [153, 1], "end": [154, 72], "kind": "mathlibtacticlemma"}, {"full_name": "Function.extend_le_one", "code": "@[to_additive] lemma extend_le_one (hg : g \u2264 1) (he : e \u2264 1) : extend f g e \u2264 1 :=\n  fun _b \u21a6 by classical exact dite_le_one (fun _ \u21a6 hg _) (fun _ \u21a6 he _)", "start": [156, 1], "end": [157, 72], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Group/Commutator.lean", "imports": ["Mathlib/Algebra/Group/Defs.lean", "Mathlib/Data/Bracket.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "commutatorElement", "code": "instance commutatorElement {G : Type*} [Group G] : Bracket G G :=\n  \u27e8fun g\u2081 g\u2082 \u21a6 g\u2081 * g\u2082 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9\u27e9", "start": [15, 1], "end": [17, 38], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_def", "code": "theorem commutatorElement_def {G : Type*} [Group G] (g\u2081 g\u2082 : G) :\n    \u2045g\u2081, g\u2082\u2046 = g\u2081 * g\u2082 * g\u2081\u207b\u00b9 * g\u2082\u207b\u00b9", "start": [20, 1], "end": [22, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/Finite.lean", "imports": ["Mathlib/Data/ZMod/Defs.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.card", "code": "protected def card (\u03b1 : Type*) : \u2115 :=\n  toNat (mk \u03b1)", "start": [35, 1], "end": [38, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_fintype_card", "code": "@[simp]\ntheorem card_eq_fintype_card [Fintype \u03b1] : Nat.card \u03b1 = Fintype.card \u03b1", "start": [41, 1], "end": [43, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_zero_of_infinite", "code": "@[simp]\ntheorem card_eq_zero_of_infinite [Infinite \u03b1] : Nat.card \u03b1 = 0", "start": [46, 1], "end": [48, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.finite_of_card_ne_zero", "code": "theorem finite_of_card_ne_zero (h : Nat.card \u03b1 \u2260 0) : Finite \u03b1", "start": [51, 1], "end": [52, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.card_congr", "code": "theorem card_congr (f : \u03b1 \u2243 \u03b2) : Nat.card \u03b1 = Nat.card \u03b2", "start": [55, 1], "end": [56, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_of_bijective", "code": "theorem card_eq_of_bijective (f : \u03b1 \u2192 \u03b2) (hf : Function.Bijective f) : Nat.card \u03b1 = Nat.card \u03b2", "start": [59, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_of_equiv_fin", "code": "theorem card_eq_of_equiv_fin {\u03b1 : Type*} {n : \u2115} (f : \u03b1 \u2243 Fin n) : Nat.card \u03b1 = n", "start": [63, 1], "end": [64, 73], "kind": "commanddeclaration"}, {"full_name": "Nat.equivFinOfCardPos", "code": "def equivFinOfCardPos {\u03b1 : Type*} (h : Nat.card \u03b1 \u2260 0) : \u03b1 \u2243 Fin (Nat.card \u03b1) := by\n  cases fintypeOrInfinite \u03b1\n  \u00b7 simpa only [card_eq_fintype_card] using Fintype.equivFin \u03b1\n  \u00b7 simp only [card_eq_zero_of_infinite, ne_eq] at h", "start": [67, 1], "end": [72, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.card_of_subsingleton", "code": "theorem card_of_subsingleton (a : \u03b1) [Subsingleton \u03b1] : Nat.card \u03b1 = 1", "start": [75, 1], "end": [77, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.card_unique", "code": "theorem card_unique [Unique \u03b1] : Nat.card \u03b1 = 1", "start": [81, 1], "end": [82, 31], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_one_iff_unique", "code": "theorem card_eq_one_iff_unique : Nat.card \u03b1 = 1 \u2194 Subsingleton \u03b1 \u2227 Nonempty \u03b1", "start": [85, 1], "end": [86, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_two_iff", "code": "theorem card_eq_two_iff : Nat.card \u03b1 = 2 \u2194 \u2203 x y : \u03b1, x \u2260 y \u2227 {x, y} = @Set.univ \u03b1", "start": [89, 1], "end": [90, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_two_iff'", "code": "theorem card_eq_two_iff' (x : \u03b1) : Nat.card \u03b1 = 2 \u2194 \u2203! y, y \u2260 x", "start": [93, 1], "end": [94, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.card_of_isEmpty", "code": "theorem card_of_isEmpty [IsEmpty \u03b1] : Nat.card \u03b1 = 0", "start": [97, 1], "end": [97, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.card_sum", "code": "@[simp]\ntheorem card_sum [Finite \u03b1] [Finite \u03b2] : Nat.card (\u03b1 \u2295 \u03b2) = Nat.card \u03b1 + Nat.card \u03b2", "start": [100, 1], "end": [104, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.card_prod", "code": "@[simp]\ntheorem card_prod (\u03b1 \u03b2 : Type*) : Nat.card (\u03b1 \u00d7 \u03b2) = Nat.card \u03b1 * Nat.card \u03b2", "start": [106, 1], "end": [108, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.card_ulift", "code": "@[simp]\ntheorem card_ulift (\u03b1 : Type*) : Nat.card (ULift \u03b1) = Nat.card \u03b1", "start": [111, 1], "end": [113, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.card_plift", "code": "@[simp]\ntheorem card_plift (\u03b1 : Type*) : Nat.card (PLift \u03b1) = Nat.card \u03b1", "start": [116, 1], "end": [118, 25], "kind": "commanddeclaration"}, {"full_name": "Nat.card_pi", "code": "theorem card_pi {\u03b2 : \u03b1 \u2192 Type*} [Fintype \u03b1] : Nat.card (\u2200 a, \u03b2 a) = \u220f a, Nat.card (\u03b2 a)", "start": [121, 1], "end": [122, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.card_fun", "code": "theorem card_fun [Finite \u03b1] : Nat.card (\u03b1 \u2192 \u03b2) = Nat.card \u03b2 ^ Nat.card \u03b1", "start": [125, 1], "end": [127, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.card_zmod", "code": "@[simp]\ntheorem card_zmod (n : \u2115) : Nat.card (ZMod n) = n", "start": [130, 1], "end": [134, 45], "kind": "commanddeclaration"}, {"full_name": "PartENat.card", "code": "def card (\u03b1 : Type*) : PartENat :=\n  toPartENat (mk \u03b1)", "start": [141, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_eq_coe_fintype_card", "code": "@[simp]\ntheorem card_eq_coe_fintype_card [Fintype \u03b1] : card \u03b1 = Fintype.card \u03b1", "start": [147, 1], "end": [149, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_eq_top_of_infinite", "code": "@[simp]\ntheorem card_eq_top_of_infinite [Infinite \u03b1] : card \u03b1 = \u22a4", "start": [152, 1], "end": [154, 28], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_sum", "code": "@[simp]\ntheorem card_sum (\u03b1 \u03b2 : Type*) :\n    PartENat.card (\u03b1 \u2295 \u03b2) = PartENat.card \u03b1 + PartENat.card \u03b2", "start": [157, 1], "end": [160, 80], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_congr", "code": "theorem card_congr {\u03b1 : Type*} {\u03b2 : Type*} (f : \u03b1 \u2243 \u03b2) : PartENat.card \u03b1 = PartENat.card \u03b2", "start": [162, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_uLift", "code": "theorem card_uLift (\u03b1 : Type*) : card (ULift \u03b1) = card \u03b1", "start": [166, 1], "end": [167, 25], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_pLift", "code": "@[simp]\ntheorem card_pLift (\u03b1 : Type*) : card (PLift \u03b1) = card \u03b1", "start": [170, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_image_of_injOn", "code": "theorem card_image_of_injOn {\u03b1 : Type u} {\u03b2 : Type v} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (h : Set.InjOn f s) :\n    card (f '' s) = card s", "start": [175, 1], "end": [177, 49], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_image_of_injective", "code": "theorem card_image_of_injective {\u03b1 : Type u} {\u03b2 : Type v} (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1)\n    (h : Function.Injective f) : card (f '' s) = card s", "start": [180, 1], "end": [182, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_le_toPartENat_iff", "code": "@[simp]\ntheorem _root_.Cardinal.natCast_le_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n \u2264 toPartENat c \u2194 \u2191n \u2264 c", "start": [186, 1], "end": [189, 88], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_le_natCast_iff", "code": "@[simp]\ntheorem _root_.Cardinal.toPartENat_le_natCast_iff {c : Cardinal} {n : \u2115} :\n    toPartENat c \u2264 n \u2194 c \u2264 n", "start": [192, 1], "end": [195, 77], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_eq_toPartENat_iff", "code": "@[simp]\ntheorem _root_.Cardinal.natCast_eq_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n = toPartENat c \u2194 \u2191n = c", "start": [198, 1], "end": [202, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_eq_natCast_iff", "code": "@[simp]\ntheorem _root_.Cardinal.toPartENat_eq_natCast_iff {c : Cardinal} {n : \u2115} :\n    Cardinal.toPartENat c = n \u2194 c = n", "start": [205, 1], "end": [208, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.natCast_lt_toPartENat_iff", "code": "@[simp]\ntheorem _root_.Cardinal.natCast_lt_toPartENat_iff {n : \u2115} {c : Cardinal} :\n    \u2191n < toPartENat c \u2194 \u2191n < c", "start": [211, 1], "end": [214, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.toPartENat_lt_natCast_iff", "code": "@[simp]\ntheorem _root_.Cardinal.toPartENat_lt_natCast_iff {n : \u2115} {c : Cardinal} :\n    toPartENat c < \u2191n \u2194 c < \u2191n", "start": [217, 1], "end": [220, 60], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_eq_zero_iff_empty", "code": "theorem card_eq_zero_iff_empty (\u03b1 : Type*) : card \u03b1 = 0 \u2194 IsEmpty \u03b1", "start": [223, 1], "end": [227, 43], "kind": "commanddeclaration"}, {"full_name": "PartENat.card_le_one_iff_subsingleton", "code": "theorem card_le_one_iff_subsingleton (\u03b1 : Type*) : card \u03b1 \u2264 1 \u2194 Subsingleton \u03b1", "start": [230, 1], "end": [234, 42], "kind": "commanddeclaration"}, {"full_name": "PartENat.one_lt_card_iff_nontrivial", "code": "theorem one_lt_card_iff_nontrivial (\u03b1 : Type*) : 1 < card \u03b1 \u2194 Nontrivial \u03b1", "start": [237, 1], "end": [241, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/List.lean", "imports": ["Mathlib/Data/Finset/Powerset.lean", "Mathlib/Data/Fintype/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiset.lists", "code": "def lists : Multiset \u03b1 \u2192 Finset (List \u03b1) := fun s =>\n  Quotient.liftOn s (fun l => l.permutations.toFinset) fun l l' (h : l ~ l') => by\n    ext sl\n    simp only [mem_permutations, List.mem_toFinset]\n    exact \u27e8fun hs => hs.trans h, fun hs => hs.trans h.symm\u27e9", "start": [36, 1], "end": [42, 60], "kind": "commanddeclaration"}, {"full_name": "Multiset.lists_coe", "code": "@[simp]\ntheorem lists_coe (l : List \u03b1) : lists (l : Multiset \u03b1) = l.permutations.toFinset", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Multiset.mem_lists_iff", "code": "@[simp]\ntheorem mem_lists_iff (s : Multiset \u03b1) (l : List \u03b1) : l \u2208 lists s \u2194 s = \u27e6l\u27e7", "start": [50, 1], "end": [53, 24], "kind": "commanddeclaration"}, {"full_name": "fintypeNodupList", "code": "instance fintypeNodupList [Fintype \u03b1] : Fintype { l : List \u03b1 // l.Nodup } :=\n  Fintype.subtype ((Finset.univ : Finset \u03b1).powerset.biUnion fun s => s.val.lists) fun l => by\n    suffices (\u2203 a : Finset \u03b1, a.val = \u2191l) \u2194 l.Nodup by simpa\n    constructor\n    \u00b7 rintro \u27e8s, hs\u27e9\n      simpa [\u2190 Multiset.coe_nodup, \u2190 hs] using s.nodup\n    \u00b7 intro hl\n      refine' \u27e8\u27e8\u2191l, hl\u27e9, _\u27e9\n      simp", "start": [58, 1], "end": [66, 11], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Rotate.lean", "imports": ["Mathlib/Data/List/Range.lean", "Mathlib/Data/List/Perm.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.rotate_mod", "code": "theorem rotate_mod (l : List \u03b1) (n : \u2115) : l.rotate (n % l.length) = l.rotate n", "start": [35, 1], "end": [35, 99], "kind": "commanddeclaration"}, {"full_name": "List.rotate_nil", "code": "@[simp]\ntheorem rotate_nil (n : \u2115) : ([] : List \u03b1).rotate n = []", "start": [38, 1], "end": [39, 77], "kind": "commanddeclaration"}, {"full_name": "List.rotate_zero", "code": "@[simp]\ntheorem rotate_zero (l : List \u03b1) : l.rotate 0 = l", "start": [42, 1], "end": [43, 70], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_nil", "code": "theorem rotate'_nil (n : \u2115) : ([] : List \u03b1).rotate' n = []", "start": [47, 1], "end": [47, 81], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_zero", "code": "@[simp]\ntheorem rotate'_zero (l : List \u03b1) : l.rotate' 0 = l", "start": [50, 1], "end": [51, 74], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_cons_succ", "code": "theorem rotate'_cons_succ (l : List \u03b1) (a : \u03b1) (n : \u2115) :\n    (a :: l : List \u03b1).rotate' n.succ = (l ++ [a]).rotate' n", "start": [54, 1], "end": [55, 81], "kind": "commanddeclaration"}, {"full_name": "List.length_rotate'", "code": "@[simp]\ntheorem length_rotate' : \u2200 (l : List \u03b1) (n : \u2115), (l.rotate' n).length = l.length", "start": [58, 1], "end": [62, 77], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_eq_drop_append_take", "code": "theorem rotate'_eq_drop_append_take :\n    \u2200 {l : List \u03b1} {n : \u2115}, n \u2264 l.length \u2192 l.rotate' n = l.drop n ++ l.take n", "start": [65, 1], "end": [74, 74], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_rotate'", "code": "theorem rotate'_rotate' : \u2200 (l : List \u03b1) (n m : \u2115), (l.rotate' n).rotate' m = l.rotate' (n + m)", "start": [77, 1], "end": [81, 85], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_length", "code": "@[simp]\ntheorem rotate'_length (l : List \u03b1) : rotate' l l.length = l", "start": [84, 1], "end": [86, 48], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_length_mul", "code": "@[simp]\ntheorem rotate'_length_mul (l : List \u03b1) : \u2200 n : \u2115, l.rotate' (l.length * n) = l", "start": [89, 1], "end": [97, 62], "kind": "commanddeclaration"}, {"full_name": "List.rotate'_mod", "code": "theorem rotate'_mod (l : List \u03b1) (n : \u2115) : l.rotate' (n % l.length) = l.rotate' n", "start": [100, 1], "end": [105, 80], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_rotate'", "code": "theorem rotate_eq_rotate' (l : List \u03b1) (n : \u2115) : l.rotate n = l.rotate' n", "start": [108, 1], "end": [113, 20], "kind": "commanddeclaration"}, {"full_name": "List.rotate_cons_succ", "code": "theorem rotate_cons_succ (l : List \u03b1) (a : \u03b1) (n : \u2115) :\n    (a :: l : List \u03b1).rotate n.succ = (l ++ [a]).rotate n", "start": [116, 1], "end": [118, 63], "kind": "commanddeclaration"}, {"full_name": "List.mem_rotate", "code": "@[simp]\ntheorem mem_rotate : \u2200 {l : List \u03b1} {a : \u03b1} {n : \u2115}, a \u2208 l.rotate n \u2194 a \u2208 l", "start": [121, 1], "end": [125, 72], "kind": "commanddeclaration"}, {"full_name": "List.length_rotate", "code": "@[simp]\ntheorem length_rotate (l : List \u03b1) (n : \u2115) : (l.rotate n).length = l.length", "start": [128, 1], "end": [130, 41], "kind": "commanddeclaration"}, {"full_name": "List.rotate_replicate", "code": "theorem rotate_replicate (a : \u03b1) (n : \u2115) (k : \u2115) : (replicate n a).rotate k = replicate n a", "start": [134, 1], "end": [136, 44], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_drop_append_take", "code": "theorem rotate_eq_drop_append_take {l : List \u03b1} {n : \u2115} :\n    n \u2264 l.length \u2192 l.rotate n = l.drop n ++ l.take n", "start": [139, 1], "end": [141, 60], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_drop_append_take_mod", "code": "theorem rotate_eq_drop_append_take_mod {l : List \u03b1} {n : \u2115} :\n    l.rotate n = l.drop (n % l.length) ++ l.take (n % l.length)", "start": [144, 1], "end": [148, 65], "kind": "commanddeclaration"}, {"full_name": "List.rotate_append_length_eq", "code": "@[simp]\ntheorem rotate_append_length_eq (l l' : List \u03b1) : (l ++ l').rotate l.length = l' ++ l", "start": [151, 1], "end": [156, 23], "kind": "commanddeclaration"}, {"full_name": "List.rotate_rotate", "code": "theorem rotate_rotate (l : List \u03b1) (n m : \u2115) : (l.rotate n).rotate m = l.rotate (n + m)", "start": [159, 1], "end": [160, 80], "kind": "commanddeclaration"}, {"full_name": "List.rotate_length", "code": "@[simp]\ntheorem rotate_length (l : List \u03b1) : rotate l l.length = l", "start": [163, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "List.rotate_length_mul", "code": "@[simp]\ntheorem rotate_length_mul (l : List \u03b1) (n : \u2115) : l.rotate (l.length * n) = l", "start": [168, 1], "end": [170, 45], "kind": "commanddeclaration"}, {"full_name": "List.prod_rotate_eq_one_of_prod_eq_one", "code": "theorem prod_rotate_eq_one_of_prod_eq_one [Group \u03b1] :\n    \u2200 {l : List \u03b1} (_ : l.prod = 1) (n : \u2115), (l.rotate n).prod = 1", "start": [173, 1], "end": [180, 91], "kind": "commanddeclaration"}, {"full_name": "List.rotate_perm", "code": "theorem rotate_perm (l : List \u03b1) (n : \u2115) : l.rotate n ~ l", "start": [183, 1], "end": [190, 53], "kind": "commanddeclaration"}, {"full_name": "List.nodup_rotate", "code": "@[simp]\ntheorem nodup_rotate {l : List \u03b1} {n : \u2115} : Nodup (l.rotate n) \u2194 Nodup l", "start": [193, 1], "end": [195, 30], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_nil_iff", "code": "@[simp]\ntheorem rotate_eq_nil_iff {l : List \u03b1} {n : \u2115} : l.rotate n = [] \u2194 l = []", "start": [198, 1], "end": [204, 34], "kind": "commanddeclaration"}, {"full_name": "List.nil_eq_rotate_iff", "code": "@[simp]\ntheorem nil_eq_rotate_iff {l : List \u03b1} {n : \u2115} : [] = l.rotate n \u2194 [] = l", "start": [207, 1], "end": [209, 43], "kind": "commanddeclaration"}, {"full_name": "List.rotate_singleton", "code": "@[simp]\ntheorem rotate_singleton (x : \u03b1) (n : \u2115) : [x].rotate n = [x]", "start": [212, 1], "end": [214, 25], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_rotate_distrib", "code": "theorem zipWith_rotate_distrib {\u03b1 \u03b2 \u03b3 : Type*} (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b1) (l' : List \u03b2) (n : \u2115)\n    (h : l.length = l'.length) :\n    (zipWith f l l').rotate n = zipWith f (l.rotate n) (l'.rotate n)", "start": [217, 1], "end": [223, 35], "kind": "commanddeclaration"}, {"full_name": "List.zipWith_rotate_one", "code": "theorem zipWith_rotate_one {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (x y : \u03b1) (l : List \u03b1) :\n    zipWith f (x :: y :: l) ((x :: y :: l).rotate 1) = f x y :: zipWith f (y :: l) (l ++ [x])", "start": [229, 1], "end": [231, 7], "kind": "commanddeclaration"}, {"full_name": "List.get?_rotate", "code": "theorem get?_rotate {l : List \u03b1} {n m : \u2115} (hml : m < l.length) :\n    (l.rotate n).get? m = l.get? ((m + n) % l.length)", "start": [234, 1], "end": [253, 75], "kind": "commanddeclaration"}, {"full_name": "List.get_rotate", "code": "theorem get_rotate (l : List \u03b1) (n : \u2115) (k : Fin (l.rotate n).length) :\n    (l.rotate n).get k =\n      l.get \u27e8(k + n) % l.length, mod_lt _ (length_rotate l n \u25b8 k.1.zero_le.trans_lt k.2)\u27e9", "start": [257, 1], "end": [261, 41], "kind": "commanddeclaration"}, {"full_name": "List.head?_rotate", "code": "theorem head?_rotate {l : List \u03b1} {n : \u2115} (h : n < l.length) : head? (l.rotate n) = l.get? n", "start": [263, 1], "end": [264, 85], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_rotate", "code": "@[deprecated get_rotate]\ntheorem nthLe_rotate (l : List \u03b1) (n k : \u2115) (hk : k < (l.rotate n).length) :\n    (l.rotate n).nthLe k hk =\n      l.nthLe ((k + n) % l.length) (mod_lt _ (length_rotate l n \u25b8 k.zero_le.trans_lt hk))", "start": [270, 1], "end": [274, 25], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_rotate_one", "code": "theorem nthLe_rotate_one (l : List \u03b1) (k : \u2115) (hk : k < (l.rotate 1).length) :\n    (l.rotate 1).nthLe k hk =\n      l.nthLe ((k + 1) % l.length) (mod_lt _ (length_rotate l 1 \u25b8 k.zero_le.trans_lt hk))", "start": [278, 1], "end": [281, 24], "kind": "commanddeclaration"}, {"full_name": "List.get_eq_get_rotate", "code": "theorem get_eq_get_rotate (l : List \u03b1) (n : \u2115) (k : Fin l.length) :\n    l.get k = (l.rotate n).get \u27e8(l.length - n % l.length + k) % l.length,\n      (Nat.mod_lt _ (k.1.zero_le.trans_lt k.2)).trans_eq (length_rotate _ _).symm\u27e9", "start": [285, 1], "end": [295, 57], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_rotate'", "code": "@[deprecated get_eq_get_rotate]\ntheorem nthLe_rotate' (l : List \u03b1) (n k : \u2115) (hk : k < l.length) :\n    (l.rotate n).nthLe ((l.length - n % l.length + k) % l.length)\n        ((Nat.mod_lt _ (k.zero_le.trans_lt hk)).trans_le (length_rotate _ _).ge) =\n      l.nthLe k hk", "start": [298, 1], "end": [304, 39], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_self_iff_eq_replicate", "code": "theorem rotate_eq_self_iff_eq_replicate [h\u03b1 : Nonempty \u03b1] :\n    \u2200 {l : List \u03b1}, (\u2200 n, l.rotate n = l) \u2194 \u2203 a, l = replicate l.length a", "start": [307, 1], "end": [312, 51], "kind": "commanddeclaration"}, {"full_name": "List.rotate_one_eq_self_iff_eq_replicate", "code": "theorem rotate_one_eq_self_iff_eq_replicate [Nonempty \u03b1] {l : List \u03b1} :\n    l.rotate 1 = l \u2194 \u2203 a : \u03b1, l = List.replicate l.length a", "start": [315, 1], "end": [320, 54], "kind": "commanddeclaration"}, {"full_name": "List.rotate_injective", "code": "theorem rotate_injective (n : \u2115) : Function.Injective fun l : List \u03b1 => l.rotate n", "start": [323, 1], "end": [328, 56], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_rotate", "code": "@[simp]\ntheorem rotate_eq_rotate {l l' : List \u03b1} {n : \u2115} : l.rotate n = l'.rotate n \u2194 l = l'", "start": [331, 1], "end": [333, 30], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_iff", "code": "theorem rotate_eq_iff {l l' : List \u03b1} {n : \u2115} :\n    l.rotate n = l' \u2194 l = l'.rotate (l'.length - n % l'.length)", "start": [336, 1], "end": [344, 33], "kind": "commanddeclaration"}, {"full_name": "List.rotate_eq_singleton_iff", "code": "@[simp]\ntheorem rotate_eq_singleton_iff {l : List \u03b1} {n : \u2115} {x : \u03b1} : l.rotate n = [x] \u2194 l = [x]", "start": [347, 1], "end": [349, 39], "kind": "commanddeclaration"}, {"full_name": "List.singleton_eq_rotate_iff", "code": "@[simp]\ntheorem singleton_eq_rotate_iff {l : List \u03b1} {n : \u2115} {x : \u03b1} : [x] = l.rotate n \u2194 [x] = l", "start": [352, 1], "end": [354, 49], "kind": "commanddeclaration"}, {"full_name": "List.reverse_rotate", "code": "theorem reverse_rotate (l : List \u03b1) (n : \u2115) :\n    (l.rotate n).reverse = l.reverse.rotate (l.length - n % l.length)", "start": [357, 1], "end": [365, 11], "kind": "commanddeclaration"}, {"full_name": "List.rotate_reverse", "code": "theorem rotate_reverse (l : List \u03b1) (n : \u2115) :\n    l.reverse.rotate n = (l.rotate (l.length - n % l.length)).reverse", "start": [368, 1], "end": [381, 52], "kind": "commanddeclaration"}, {"full_name": "List.map_rotate", "code": "theorem map_rotate {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) (n : \u2115) :\n    map f (l.rotate n) = (map f l).rotate n", "start": [384, 1], "end": [390, 16], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.rotate_eq_self_iff", "code": "theorem Nodup.rotate_eq_self_iff {l : List \u03b1} (hl : l.Nodup) {n : \u2115} :\n    l.rotate n = l \u2194 n % l.length = 0 \u2228 l = []", "start": [394, 1], "end": [408, 15], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.rotate_congr", "code": "theorem Nodup.rotate_congr {l : List \u03b1} (hl : l.Nodup) (hn : l \u2260 []) (i j : \u2115)\n    (h : l.rotate i = l.rotate j) : i % l.length = j % l.length", "start": [412, 1], "end": [418, 48], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated", "code": "def IsRotated : Prop :=\n  \u2203 n, l.rotate n = l'", "start": [425, 1], "end": [428, 23], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.refl", "code": "@[refl]\ntheorem IsRotated.refl (l : List \u03b1) : l ~r l", "start": [436, 1], "end": [438, 15], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.symm", "code": "@[symm]\ntheorem IsRotated.symm (h : l ~r l') : l' ~r l", "start": [441, 1], "end": [448, 43], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_comm", "code": "theorem isRotated_comm : l ~r l' \u2194 l' ~r l", "start": [451, 1], "end": [452, 35], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.forall", "code": "@[simp]\nprotected theorem IsRotated.forall (l : List \u03b1) (n : \u2115) : l.rotate n ~r l", "start": [455, 1], "end": [457, 26], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.trans", "code": "@[trans]\ntheorem IsRotated.trans : \u2200 {l l' l'' : List \u03b1}, l ~r l' \u2192 l' ~r l'' \u2192 l ~r l''", "start": [460, 1], "end": [462, 66], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.eqv", "code": "theorem IsRotated.eqv : Equivalence (@IsRotated \u03b1)", "start": [465, 1], "end": [466, 63], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.setoid", "code": "def IsRotated.setoid (\u03b1 : Type*) : Setoid (List \u03b1) where\n  r := IsRotated\n  iseqv := IsRotated.eqv", "start": [469, 1], "end": [472, 25], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.perm", "code": "theorem IsRotated.perm (h : l ~r l') : l ~ l'", "start": [475, 1], "end": [476, 56], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.nodup_iff", "code": "theorem IsRotated.nodup_iff (h : l ~r l') : Nodup l \u2194 Nodup l'", "start": [479, 1], "end": [480, 19], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.mem_iff", "code": "theorem IsRotated.mem_iff (h : l ~r l') {a : \u03b1} : a \u2208 l \u2194 a \u2208 l'", "start": [483, 1], "end": [484, 17], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_nil_iff", "code": "@[simp]\ntheorem isRotated_nil_iff : l ~r [] \u2194 l = []", "start": [487, 1], "end": [489, 58], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_nil_iff'", "code": "@[simp]\ntheorem isRotated_nil_iff' : [] ~r l \u2194 [] = l", "start": [492, 1], "end": [494, 50], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_singleton_iff", "code": "@[simp]\ntheorem isRotated_singleton_iff {x : \u03b1} : l ~r [x] \u2194 l = [x]", "start": [497, 1], "end": [499, 58], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_singleton_iff'", "code": "@[simp]\ntheorem isRotated_singleton_iff' {x : \u03b1} : [x] ~r l \u2194 [x] = l", "start": [502, 1], "end": [504, 56], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_concat", "code": "theorem isRotated_concat (hd : \u03b1) (tl : List \u03b1) : (tl ++ [hd]) ~r (hd :: tl)", "start": [507, 1], "end": [508, 30], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_append", "code": "theorem isRotated_append : (l ++ l') ~r (l' ++ l)", "start": [511, 1], "end": [512, 22], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.reverse", "code": "theorem IsRotated.reverse (h : l ~r l') : l.reverse ~r l'.reverse", "start": [515, 1], "end": [517, 39], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_reverse_comm_iff", "code": "theorem isRotated_reverse_comm_iff : l.reverse ~r l' \u2194 l ~r l'.reverse", "start": [520, 1], "end": [523, 28], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_reverse_iff", "code": "@[simp]\ntheorem isRotated_reverse_iff : l.reverse ~r l'.reverse \u2194 l ~r l'", "start": [526, 1], "end": [528, 36], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_iff_mod", "code": "theorem isRotated_iff_mod : l ~r l' \u2194 \u2203 n \u2264 l.length, l.rotate n = l'", "start": [531, 1], "end": [538, 9], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_iff_mem_map_range", "code": "theorem isRotated_iff_mem_map_range : l ~r l' \u2194 l' \u2208 (List.range (l.length + 1)).map l.rotate", "start": [541, 1], "end": [545, 54], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.map", "code": "theorem IsRotated.map {\u03b2 : Type*} {l\u2081 l\u2082 : List \u03b1} (h : l\u2081 ~r l\u2082) (f : \u03b1 \u2192 \u03b2) :\n    map f l\u2081 ~r map f l\u2082", "start": [550, 1], "end": [554, 8], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations", "code": "def cyclicPermutations : List \u03b1 \u2192 List (List \u03b1)\n  | [] => [[]]\n  | l@(_ :: _) => dropLast (zipWith (\u00b7 ++ \u00b7) (tails l) (inits l))", "start": [557, 1], "end": [568, 66], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_nil", "code": "@[simp]\ntheorem cyclicPermutations_nil : cyclicPermutations ([] : List \u03b1) = [[]]", "start": [571, 1], "end": [573, 6], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_cons", "code": "theorem cyclicPermutations_cons (x : \u03b1) (l : List \u03b1) :\n    cyclicPermutations (x :: l) = dropLast (zipWith (\u00b7 ++ \u00b7) (tails (x :: l)) (inits (x :: l)))", "start": [576, 1], "end": [578, 6], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_of_ne_nil", "code": "theorem cyclicPermutations_of_ne_nil (l : List \u03b1) (h : l \u2260 []) :\n    cyclicPermutations l = dropLast (zipWith (\u00b7 ++ \u00b7) (tails l) (inits l))", "start": [581, 1], "end": [584, 36], "kind": "commanddeclaration"}, {"full_name": "List.length_cyclicPermutations_cons", "code": "theorem length_cyclicPermutations_cons (x : \u03b1) (l : List \u03b1) :\n    length (cyclicPermutations (x :: l)) = length l + 1", "start": [587, 1], "end": [588, 93], "kind": "commanddeclaration"}, {"full_name": "List.length_cyclicPermutations_of_ne_nil", "code": "@[simp]\ntheorem length_cyclicPermutations_of_ne_nil (l : List \u03b1) (h : l \u2260 []) :\n    length (cyclicPermutations l) = length l", "start": [591, 1], "end": [593, 91], "kind": "commanddeclaration"}, {"full_name": "List.nthLe_cyclicPermutations", "code": "@[simp]\ntheorem nthLe_cyclicPermutations (l : List \u03b1) (n : \u2115) (hn : n < length (cyclicPermutations l)) :\n    nthLe (cyclicPermutations l) n hn = l.rotate n", "start": [597, 1], "end": [604, 40], "kind": "commanddeclaration"}, {"full_name": "List.mem_cyclicPermutations_self", "code": "theorem mem_cyclicPermutations_self (l : List \u03b1) : l \u2208 cyclicPermutations l", "start": [608, 1], "end": [613, 9], "kind": "commanddeclaration"}, {"full_name": "List.length_mem_cyclicPermutations", "code": "theorem length_mem_cyclicPermutations (l : List \u03b1) (h : l' \u2208 cyclicPermutations l) :\n    length l' = length l", "start": [617, 1], "end": [620, 7], "kind": "commanddeclaration"}, {"full_name": "List.mem_cyclicPermutations_iff", "code": "@[simp]\ntheorem mem_cyclicPermutations_iff {l l' : List \u03b1} : l \u2208 cyclicPermutations l' \u2194 l ~r l'", "start": [624, 1], "end": [637, 48], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_eq_nil_iff", "code": "@[simp]\ntheorem cyclicPermutations_eq_nil_iff {l : List \u03b1} : cyclicPermutations l = [[]] \u2194 l = []", "start": [640, 1], "end": [643, 85], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_eq_singleton_iff", "code": "@[simp]\ntheorem cyclicPermutations_eq_singleton_iff {l : List \u03b1} {x : \u03b1} :\n    cyclicPermutations l = [[x]] \u2194 l = [x]", "start": [646, 1], "end": [650, 91], "kind": "commanddeclaration"}, {"full_name": "List.Nodup.cyclicPermutations", "code": "theorem Nodup.cyclicPermutations {l : List \u03b1} (hn : Nodup l) : Nodup (cyclicPermutations l)", "start": [654, 1], "end": [664, 18], "kind": "commanddeclaration"}, {"full_name": "List.cyclicPermutations_rotate", "code": "@[simp]\ntheorem cyclicPermutations_rotate (l : List \u03b1) (k : \u2115) :\n    (l.rotate k).cyclicPermutations = l.cyclicPermutations.rotate k", "start": [668, 1], "end": [677, 19], "kind": "commanddeclaration"}, {"full_name": "List.IsRotated.cyclicPermutations", "code": "theorem IsRotated.cyclicPermutations {l l' : List \u03b1} (h : l ~r l') :\n    l.cyclicPermutations ~r l'.cyclicPermutations", "start": [680, 1], "end": [683, 21], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_cyclicPermutations_iff", "code": "@[simp]\ntheorem isRotated_cyclicPermutations_iff {l l' : List \u03b1} :\n    l.cyclicPermutations ~r l'.cyclicPermutations \u2194 l ~r l'", "start": [687, 1], "end": [698, 47], "kind": "commanddeclaration"}, {"full_name": "List.isRotatedDecidable", "code": "instance isRotatedDecidable (l l' : List \u03b1) : Decidable (l ~r l') :=\n  decidable_of_iff' _ isRotated_iff_mem_map_range", "start": [705, 1], "end": [706, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Constructions.lean", "imports": ["Mathlib/Topology/Homeomorph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MulOpposite.instTopologicalSpaceMulOpposite", "code": "@[to_additive \"Put the same topological space structure on the opposite monoid as on the original\nspace.\"]\ninstance instTopologicalSpaceMulOpposite [TopologicalSpace M] : TopologicalSpace M\u1d50\u1d52\u1d56 :=\n  TopologicalSpace.induced (unop : M\u1d50\u1d52\u1d56 \u2192 M) \u2039_\u203a", "start": [29, 1], "end": [33, 49], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.continuous_unop", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_unop : Continuous (unop : M\u1d50\u1d52\u1d56 \u2192 M)", "start": [37, 1], "end": [39, 25], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.continuous_op", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_op : Continuous (op : M \u2192 M\u1d50\u1d52\u1d56)", "start": [43, 1], "end": [45, 41], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.opHomeomorph", "code": "@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M \u2243\u209c M\u1d50\u1d52\u1d56 where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop", "start": [49, 1], "end": [54, 39], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instT2Space", "code": "@[to_additive]\ninstance instT2Space [T2Space M] : T2Space M\u1d50\u1d52\u1d56 :=\n  opHomeomorph.symm.embedding.t2Space", "start": [58, 1], "end": [60, 38], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instDiscreteTopology", "code": "@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology M\u1d50\u1d52\u1d56 :=\n  opHomeomorph.symm.embedding.discreteTopology", "start": [62, 1], "end": [64, 47], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.map_op_nhds", "code": "@[to_additive (attr := simp)]\ntheorem map_op_nhds (x : M) : map (op : M \u2192 M\u1d50\u1d52\u1d56) (\ud835\udcdd x) = \ud835\udcdd (op x)", "start": [66, 1], "end": [68, 29], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.map_unop_nhds", "code": "@[to_additive (attr := simp)]\ntheorem map_unop_nhds (x : M\u1d50\u1d52\u1d56) : map (unop : M\u1d50\u1d52\u1d56 \u2192 M) (\ud835\udcdd x) = \ud835\udcdd (unop x)", "start": [72, 1], "end": [74, 34], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.comap_op_nhds", "code": "@[to_additive (attr := simp)]\ntheorem comap_op_nhds (x : M\u1d50\u1d52\u1d56) : comap (op : M \u2192 M\u1d50\u1d52\u1d56) (\ud835\udcdd x) = \ud835\udcdd (unop x)", "start": [78, 1], "end": [80, 31], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.comap_unop_nhds", "code": "@[to_additive (attr := simp)]\ntheorem comap_unop_nhds (x : M) : comap (unop : M\u1d50\u1d52\u1d56 \u2192 M) (\ud835\udcdd x) = \ud835\udcdd (op x)", "start": [84, 1], "end": [86, 36], "kind": "commanddeclaration"}, {"full_name": "Units.instTopologicalSpaceUnits", "code": "@[to_additive \"The additive units of a monoid are equipped with a topology, via the embedding into\n`M \u00d7 M`.\"]\ninstance instTopologicalSpaceUnits : TopologicalSpace M\u02e3 :=\n  TopologicalSpace.induced (embedProduct M) inferInstance", "start": [98, 1], "end": [102, 58], "kind": "commanddeclaration"}, {"full_name": "Units.inducing_embedProduct", "code": "@[to_additive]\ntheorem inducing_embedProduct : Inducing (embedProduct M)", "start": [104, 1], "end": [106, 8], "kind": "commanddeclaration"}, {"full_name": "Units.embedding_embedProduct", "code": "@[to_additive]\ntheorem embedding_embedProduct : Embedding (embedProduct M)", "start": [110, 1], "end": [112, 52], "kind": "commanddeclaration"}, {"full_name": "Units.instT2Space", "code": "@[to_additive]\ninstance instT2Space [T2Space M] : T2Space M\u02e3 :=\n  embedding_embedProduct.t2Space", "start": [116, 1], "end": [118, 33], "kind": "commanddeclaration"}, {"full_name": "Units.instDiscreteTopology", "code": "@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology M\u02e3 :=\n  embedding_embedProduct.discreteTopology", "start": [120, 1], "end": [122, 42], "kind": "commanddeclaration"}, {"full_name": "Units.topology_eq_inf", "code": "@[to_additive] lemma topology_eq_inf :\n    instTopologicalSpaceUnits =\n      .induced (val : M\u02e3 \u2192 M) \u2039_\u203a \u2293 .induced (fun u \u21a6 \u2191u\u207b\u00b9 : M\u02e3 \u2192 M) \u2039_\u203a := by\n  simp only [inducing_embedProduct.1, instTopologicalSpaceProd, induced_inf,\n    instTopologicalSpaceMulOpposite, induced_compose]; rfl", "start": [124, 1], "end": [128, 59], "kind": "mathlibtacticlemma"}, {"full_name": "Units.embedding_val_mk'", "code": "@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M \u2192 M` is a\ntopological embedding. Use `AddUnits.embedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk' {M : Type*} [Monoid M] [TopologicalSpace M] {f : M \u2192 M}\n    (hc : ContinuousOn f {x : M | IsUnit x}) (hf : \u2200 u : M\u02e3, f u.1 = \u2191u\u207b\u00b9) :\n    Embedding (val : M\u02e3 \u2192 M) := by\n  refine \u27e8\u27e8?_\u27e9, ext\u27e9\n  rw [topology_eq_inf, inf_eq_left, \u2190 continuous_iff_le_induced,\n    @continuous_iff_continuousAt _ _ (.induced _ _)]\n  intros u s hs\n  simp only [\u2190 hf, nhds_induced, Filter.mem_map] at hs \u22a2\n  exact \u27e8_, mem_inf_principal.1 (hc u u.isUnit hs), fun u' hu' \u21a6 hu' u'.isUnit\u27e9", "start": [132, 1], "end": [144, 80], "kind": "mathlibtacticlemma"}, {"full_name": "Units.embedding_val_mk", "code": "@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M \u2192 M` is a\ntopological embedding. Use `AddUnits.embedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk {M : Type*} [DivisionMonoid M] [TopologicalSpace M]\n    (h : ContinuousOn Inv.inv {x : M | IsUnit x}) : Embedding (val : M\u02e3 \u2192 M) :=\n  embedding_val_mk' h fun u \u21a6 (val_inv_eq_inv_val u).symm", "start": [146, 1], "end": [152, 58], "kind": "mathlibtacticlemma"}, {"full_name": "Units.continuous_embedProduct", "code": "@[to_additive]\ntheorem continuous_embedProduct : Continuous (embedProduct M)", "start": [156, 1], "end": [158, 25], "kind": "commanddeclaration"}, {"full_name": "Units.continuous_val", "code": "@[to_additive]\ntheorem continuous_val : Continuous ((\u2191) : M\u02e3 \u2192 M)", "start": [162, 1], "end": [164, 39], "kind": "commanddeclaration"}, {"full_name": "Units.continuous_iff", "code": "@[to_additive]\nprotected theorem continuous_iff {f : X \u2192 M\u02e3} :\n    Continuous f \u2194 Continuous (val \u2218 f) \u2227 Continuous (fun x => \u2191(f x)\u207b\u00b9 : X \u2192 M)", "start": [168, 1], "end": [173, 13], "kind": "commanddeclaration"}, {"full_name": "Units.continuous_coe_inv", "code": "@[to_additive]\ntheorem continuous_coe_inv : Continuous (fun u => \u2191u\u207b\u00b9 : M\u02e3 \u2192 M)", "start": [177, 1], "end": [179, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CategoryTheory/Reassoc.lean", "imports": ["Mathlib/Util/AddRelatedDecl.lean", "Mathlib/Lean/Meta/Simp.lean", "Mathlib/CategoryTheory/Functor/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.eq_whisker'", "code": "theorem eq_whisker' {X Y : C} {f g : X \u27f6 Y} (w : f = g) {Z : C} (h : Y \u27f6 Z) :\n    f \u226b h = g \u226b h", "start": [33, 1], "end": [35, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.categorySimp", "code": "def categorySimp (e : Expr) : MetaM Simp.Result :=\n  simpOnlyNames [``Category.comp_id, ``Category.id_comp, ``Category.assoc,\n    ``Functor.id_obj, ``Functor.id_map, ``Functor.comp_obj, ``Functor.comp_map] e\n    (config := { decide := false })", "start": [37, 1], "end": [41, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.reassocExpr", "code": "def reassocExpr (e : Expr) : MetaM Expr := do\n  mapForallTelescope (fun e => do simpType categorySimp (\u2190 mkAppM ``eq_whisker' #[e])) e", "start": [43, 1], "end": [49, 89], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Basic.lean", "imports": ["Mathlib/Algebra/Star/BigOperators.lean", "Mathlib/Algebra/Star/Module.lean", "Mathlib/Algebra/Module/LinearMap.lean", "Mathlib/Algebra/BigOperators/RingEquiv.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/Algebra/Star/Pi.lean", "Mathlib/Algebra/Algebra/Pi.lean", "Mathlib/Algebra/Module/Pi.lean", "Mathlib/Algebra/Algebra/Opposite.lean"], "premises": [{"full_name": "Matrix", "code": "def Matrix (m : Type u) (n : Type u') (\u03b1 : Type v) : Type max u u' v :=\n  m \u2192 n \u2192 \u03b1", "start": [55, 1], "end": [58, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.ext_iff", "code": "theorem ext_iff : (\u2200 i j, M i j = N i j) \u2194 M = N", "start": [71, 1], "end": [72, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.ext", "code": "theorem ext : (\u2200 i j, M i j = N i j) \u2192 M = N", "start": [77, 1], "end": [78, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.ext'", "code": "@[ext]\ntheorem ext' : (\u2200 i, M i = N i) \u2192 M = N", "start": [94, 1], "end": [96, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.of", "code": "def of : (m \u2192 n \u2192 \u03b1) \u2243 Matrix m n \u03b1 :=\n  Equiv.refl _", "start": [100, 1], "end": [115, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.of_apply", "code": "@[simp]\ntheorem of_apply (f : m \u2192 n \u2192 \u03b1) (i j) : of f i j = f i j", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.of_symm_apply", "code": "@[simp]\ntheorem of_symm_apply (f : Matrix m n \u03b1) (i j) : of.symm f i j = f i j", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.map", "code": "def map (M : Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) : Matrix m n \u03b2 :=\n  of fun i j => f (M i j)", "start": [128, 1], "end": [142, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_apply", "code": "@[simp]\ntheorem map_apply {M : Matrix m n \u03b1} {f : \u03b1 \u2192 \u03b2} {i : m} {j : n} : M.map f i j = f (M i j)", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_id", "code": "@[simp]\ntheorem map_id (M : Matrix m n \u03b1) : M.map id = M", "start": [150, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_map", "code": "@[simp]\ntheorem map_map {M : Matrix m n \u03b1} {\u03b2 \u03b3 : Type*} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    (M.map f).map g = M.map (g \u2218 f)", "start": [156, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_injective", "code": "theorem map_injective {f : \u03b1 \u2192 \u03b2} (hf : Function.Injective f) :\n    Function.Injective fun M : Matrix m n \u03b1 => M.map f", "start": [163, 1], "end": [165, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose", "code": "def transpose (M : Matrix m n \u03b1) : Matrix n m \u03b1 :=\n  of fun x y => M y x", "start": [168, 1], "end": [170, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_apply", "code": "@[simp]\ntheorem transpose_apply (M : Matrix m n \u03b1) (i j) : transpose M i j = M j i", "start": [174, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose", "code": "def conjTranspose [Star \u03b1] (M : Matrix m n \u03b1) : Matrix n m \u03b1 :=\n  M.transpose.map star", "start": [182, 1], "end": [184, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.col", "code": "def col (w : m \u2192 \u03b1) : Matrix m Unit \u03b1 :=\n  of fun x _ => w x", "start": [190, 1], "end": [192, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_apply", "code": "@[simp]\ntheorem col_apply (w : m \u2192 \u03b1) (i j) : col w i j = w i", "start": [196, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row", "code": "def row (v : n \u2192 \u03b1) : Matrix Unit n \u03b1 :=\n  of fun _ y => v y", "start": [201, 1], "end": [203, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_apply", "code": "@[simp]\ntheorem row_apply (v : n \u2192 \u03b1) (i j) : row v i j = v j", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.inhabited", "code": "instance inhabited [Inhabited \u03b1] : Inhabited (Matrix m n \u03b1) :=\n  instInhabitedForAll_1 _", "start": [212, 1], "end": [215, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.decidableEq", "code": "instance decidableEq [DecidableEq \u03b1] [Fintype m] [Fintype n] : DecidableEq (Matrix m n \u03b1) :=\n  Fintype.decidablePiFintype", "start": [218, 1], "end": [219, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.add", "code": "instance add [Add \u03b1] : Add (Matrix m n \u03b1) :=\n  Pi.instAdd", "start": [221, 1], "end": [222, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.addSemigroup", "code": "instance addSemigroup [AddSemigroup \u03b1] : AddSemigroup (Matrix m n \u03b1) :=\n  Pi.addSemigroup", "start": [224, 1], "end": [225, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.addCommSemigroup", "code": "instance addCommSemigroup [AddCommSemigroup \u03b1] : AddCommSemigroup (Matrix m n \u03b1) :=\n  Pi.addCommSemigroup", "start": [227, 1], "end": [228, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero", "code": "instance zero [Zero \u03b1] : Zero (Matrix m n \u03b1) :=\n  Pi.instZero", "start": [230, 1], "end": [231, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.addZeroClass", "code": "instance addZeroClass [AddZeroClass \u03b1] : AddZeroClass (Matrix m n \u03b1) :=\n  Pi.addZeroClass", "start": [233, 1], "end": [234, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.addMonoid", "code": "instance addMonoid [AddMonoid \u03b1] : AddMonoid (Matrix m n \u03b1) :=\n  Pi.addMonoid", "start": [236, 1], "end": [237, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.addCommMonoid", "code": "instance addCommMonoid [AddCommMonoid \u03b1] : AddCommMonoid (Matrix m n \u03b1) :=\n  Pi.addCommMonoid", "start": [239, 1], "end": [240, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg", "code": "instance neg [Neg \u03b1] : Neg (Matrix m n \u03b1) :=\n  Pi.instNeg", "start": [242, 1], "end": [243, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub", "code": "instance sub [Sub \u03b1] : Sub (Matrix m n \u03b1) :=\n  Pi.instSub", "start": [245, 1], "end": [246, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.addGroup", "code": "instance addGroup [AddGroup \u03b1] : AddGroup (Matrix m n \u03b1) :=\n  Pi.addGroup", "start": [248, 1], "end": [249, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.addCommGroup", "code": "instance addCommGroup [AddCommGroup \u03b1] : AddCommGroup (Matrix m n \u03b1) :=\n  Pi.addCommGroup", "start": [251, 1], "end": [252, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.unique", "code": "instance unique [Unique \u03b1] : Unique (Matrix m n \u03b1) :=\n  Pi.unique", "start": [254, 1], "end": [255, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.subsingleton", "code": "instance subsingleton [Subsingleton \u03b1] : Subsingleton (Matrix m n \u03b1) :=\n  instSubsingletonForAll", "start": [257, 1], "end": [258, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonempty", "code": "instance nonempty [Nonempty m] [Nonempty n] [Nontrivial \u03b1] : Nontrivial (Matrix m n \u03b1) :=\n  Function.nontrivial", "start": [261, 1], "end": [262, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul", "code": "instance smul [SMul R \u03b1] : SMul R (Matrix m n \u03b1) :=\n  Pi.instSMul", "start": [264, 1], "end": [265, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.smulCommClass", "code": "instance smulCommClass [SMul R \u03b1] [SMul S \u03b1] [SMulCommClass R S \u03b1] :\n    SMulCommClass R S (Matrix m n \u03b1) :=\n  Pi.smulCommClass", "start": [267, 1], "end": [269, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.isScalarTower", "code": "instance isScalarTower [SMul R S] [SMul R \u03b1] [SMul S \u03b1] [IsScalarTower R S \u03b1] :\n    IsScalarTower R S (Matrix m n \u03b1) :=\n  Pi.isScalarTower", "start": [271, 1], "end": [273, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.isCentralScalar", "code": "instance isCentralScalar [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar R \u03b1] :\n    IsCentralScalar R (Matrix m n \u03b1) :=\n  Pi.isCentralScalar", "start": [275, 1], "end": [277, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulAction", "code": "instance mulAction [Monoid R] [MulAction R \u03b1] : MulAction R (Matrix m n \u03b1) :=\n  Pi.mulAction _", "start": [279, 1], "end": [280, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.distribMulAction", "code": "instance distribMulAction [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] :\n    DistribMulAction R (Matrix m n \u03b1) :=\n  Pi.distribMulAction _", "start": [282, 1], "end": [284, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.module", "code": "instance module [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] : Module R (Matrix m n \u03b1) :=\n  Pi.module _ _ _", "start": [286, 1], "end": [287, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_apply", "code": "@[simp]\ntheorem zero_apply [Zero \u03b1] (i : m) (j : n) : (0 : Matrix m n \u03b1) i j = 0", "start": [294, 1], "end": [295, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_apply", "code": "@[simp]\ntheorem add_apply [Add \u03b1] (A B : Matrix m n \u03b1) (i : m) (j : n) :\n    (A + B) i j = (A i j) + (B i j)", "start": [297, 1], "end": [299, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_apply", "code": "@[simp]\ntheorem smul_apply [SMul \u03b2 \u03b1] (r : \u03b2) (A : Matrix m n \u03b1) (i : m) (j : n) :\n    (r \u2022 A) i j = r \u2022 (A i j)", "start": [301, 1], "end": [303, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub_apply", "code": "@[simp]\ntheorem sub_apply [Sub \u03b1] (A B : Matrix m n \u03b1) (i : m) (j : n) :\n    (A - B) i j = (A i j) - (B i j)", "start": [305, 1], "end": [307, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_apply", "code": "@[simp]\ntheorem neg_apply [Neg \u03b1] (A : Matrix m n \u03b1) (i : m) (j : n) :\n    (-A) i j = -(A i j)", "start": [309, 1], "end": [311, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.of_zero", "code": "@[simp]\ntheorem of_zero [Zero \u03b1] : of (0 : m \u2192 n \u2192 \u03b1) = 0", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.of_add_of", "code": "@[simp]\ntheorem of_add_of [Add \u03b1] (f g : m \u2192 n \u2192 \u03b1) : of f + of g = of (f + g)", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.of_sub_of", "code": "@[simp]\ntheorem of_sub_of [Sub \u03b1] (f g : m \u2192 n \u2192 \u03b1) : of f - of g = of (f - g)", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_of", "code": "@[simp]\ntheorem neg_of [Neg \u03b1] (f : m \u2192 n \u2192 \u03b1) : -of f = of (-f)", "start": [332, 1], "end": [334, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_of", "code": "@[simp]\ntheorem smul_of [SMul R \u03b1] (r : R) (f : m \u2192 n \u2192 \u03b1) : r \u2022 of f = of (r \u2022 f)", "start": [337, 1], "end": [339, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_zero", "code": "@[simp]\nprotected theorem map_zero [Zero \u03b1] [Zero \u03b2] (f : \u03b1 \u2192 \u03b2) (h : f 0 = 0) :\n    (0 : Matrix m n \u03b1).map f = 0", "start": [342, 1], "end": [346, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_add", "code": "protected theorem map_add [Add \u03b1] [Add \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a\u2081 a\u2082, f (a\u2081 + a\u2082) = f a\u2081 + f a\u2082)\n    (M N : Matrix m n \u03b1) : (M + N).map f = M.map f + N.map f", "start": [349, 1], "end": [351, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_sub", "code": "protected theorem map_sub [Sub \u03b1] [Sub \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a\u2081 a\u2082, f (a\u2081 - a\u2082) = f a\u2081 - f a\u2082)\n    (M N : Matrix m n \u03b1) : (M - N).map f = M.map f - N.map f", "start": [354, 1], "end": [356, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_smul", "code": "theorem map_smul [SMul R \u03b1] [SMul R \u03b2] (f : \u03b1 \u2192 \u03b2) (r : R) (hf : \u2200 a, f (r \u2022 a) = r \u2022 f a)\n    (M : Matrix m n \u03b1) : (r \u2022 M).map f = r \u2022 M.map f", "start": [359, 1], "end": [361, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_smul'", "code": "theorem map_smul' [Mul \u03b1] [Mul \u03b2] (f : \u03b1 \u2192 \u03b2) (r : \u03b1) (A : Matrix n n \u03b1)\n    (hf : \u2200 a\u2081 a\u2082, f (a\u2081 * a\u2082) = f a\u2081 * f a\u2082) : (r \u2022 A).map f = f r \u2022 A.map f", "start": [364, 1], "end": [368, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_op_smul'", "code": "theorem map_op_smul' [Mul \u03b1] [Mul \u03b2] (f : \u03b1 \u2192 \u03b2) (r : \u03b1) (A : Matrix n n \u03b1)\n    (hf : \u2200 a\u2081 a\u2082, f (a\u2081 * a\u2082) = f a\u2081 * f a\u2082) :\n    (MulOpposite.op r \u2022 A).map f = MulOpposite.op (f r) \u2022 A.map f", "start": [371, 1], "end": [376, 24], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.matrix", "code": "theorem _root_.IsSMulRegular.matrix [SMul R S] {k : R} (hk : IsSMulRegular S k) :\n    IsSMulRegular (Matrix m n S) k", "start": [379, 1], "end": [381, 57], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.matrix", "code": "theorem _root_.IsLeftRegular.matrix [Mul \u03b1] {k : \u03b1} (hk : IsLeftRegular k) :\n    IsSMulRegular (Matrix m n \u03b1) k", "start": [384, 1], "end": [386, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.subsingleton_of_empty_left", "code": "instance subsingleton_of_empty_left [IsEmpty m] : Subsingleton (Matrix m n \u03b1) :=\n  \u27e8fun M N => by\n    ext i\n    exact isEmptyElim i\u27e9", "start": [389, 1], "end": [392, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.subsingleton_of_empty_right", "code": "instance subsingleton_of_empty_right [IsEmpty n] : Subsingleton (Matrix m n \u03b1) :=\n  \u27e8fun M N => by\n    ext i j\n    exact isEmptyElim j\u27e9", "start": [395, 1], "end": [398, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal", "code": "def diagonal [Zero \u03b1] (d : n \u2192 \u03b1) : Matrix n n \u03b1 :=\n  of fun i j => if i = j then d i else 0", "start": [411, 1], "end": [421, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_apply", "code": "theorem diagonal_apply [Zero \u03b1] (d : n \u2192 \u03b1) (i j) : diagonal d i j = if i = j then d i else 0", "start": [425, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_apply_eq", "code": "@[simp]\ntheorem diagonal_apply_eq [Zero \u03b1] (d : n \u2192 \u03b1) (i : n) : (diagonal d) i i = d i", "start": [429, 1], "end": [431, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_apply_ne", "code": "@[simp]\ntheorem diagonal_apply_ne [Zero \u03b1] (d : n \u2192 \u03b1) {i j : n} (h : i \u2260 j) : (diagonal d) i j = 0", "start": [434, 1], "end": [436, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_apply_ne'", "code": "theorem diagonal_apply_ne' [Zero \u03b1] (d : n \u2192 \u03b1) {i j : n} (h : j \u2260 i) : (diagonal d) i j = 0", "start": [439, 1], "end": [440, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_eq_diagonal_iff", "code": "@[simp]\ntheorem diagonal_eq_diagonal_iff [Zero \u03b1] {d\u2081 d\u2082 : n \u2192 \u03b1} :\n    diagonal d\u2081 = diagonal d\u2082 \u2194 \u2200 i, d\u2081 i = d\u2082 i", "start": [443, 1], "end": [447, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_injective", "code": "theorem diagonal_injective [Zero \u03b1] : Function.Injective (diagonal : (n \u2192 \u03b1) \u2192 Matrix n n \u03b1)", "start": [450, 1], "end": [451, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_zero", "code": "@[simp]\ntheorem diagonal_zero [Zero \u03b1] : (diagonal fun _ => 0 : Matrix n n \u03b1) = 0", "start": [454, 1], "end": [457, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_transpose", "code": "@[simp]\ntheorem diagonal_transpose [Zero \u03b1] (v : n \u2192 \u03b1) : (diagonal v)\u1d40 = diagonal v", "start": [460, 1], "end": [465, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_add", "code": "@[simp]\ntheorem diagonal_add [AddZeroClass \u03b1] (d\u2081 d\u2082 : n \u2192 \u03b1) :\n    diagonal d\u2081 + diagonal d\u2082 = diagonal fun i => d\u2081 i + d\u2082 i", "start": [468, 1], "end": [473, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_smul", "code": "@[simp]\ntheorem diagonal_smul [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] (r : R) (d : n \u2192 \u03b1) :\n    diagonal (r \u2022 d) = r \u2022 diagonal d", "start": [476, 1], "end": [481, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalAddMonoidHom", "code": "@[simps]\ndef diagonalAddMonoidHom [AddZeroClass \u03b1] : (n \u2192 \u03b1) \u2192+ Matrix n n \u03b1 where\n  toFun := diagonal\n  map_zero' := diagonal_zero\n  map_add' x y := (diagonal_add x y).symm", "start": [486, 1], "end": [491, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalLinearMap", "code": "@[simps]\ndef diagonalLinearMap [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] : (n \u2192 \u03b1) \u2192\u2097[R] Matrix n n \u03b1 :=\n  { diagonalAddMonoidHom n \u03b1 with map_smul' := diagonal_smul }", "start": [496, 1], "end": [499, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_map", "code": "@[simp]\ntheorem diagonal_map [Zero \u03b1] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : f 0 = 0) {d : n \u2192 \u03b1} :\n    (diagonal d).map f = diagonal fun m => f (d m)", "start": [504, 1], "end": [509, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_conjTranspose", "code": "@[simp]\ntheorem diagonal_conjTranspose [AddMonoid \u03b1] [StarAddMonoid \u03b1] (v : n \u2192 \u03b1) :\n    (diagonal v)\u1d34 = diagonal (star v)", "start": [512, 1], "end": [516, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.one", "code": "instance one : One (Matrix n n \u03b1) :=\n  \u27e8diagonal fun _ => 1\u27e9", "start": [523, 1], "end": [524, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_one", "code": "@[simp]\ntheorem diagonal_one : (diagonal fun _ => 1 : Matrix n n \u03b1) = 1", "start": [526, 1], "end": [528, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_apply", "code": "theorem one_apply {i j} : (1 : Matrix n n \u03b1) i j = if i = j then 1 else 0", "start": [531, 1], "end": [532, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_apply_eq", "code": "@[simp]\ntheorem one_apply_eq (i) : (1 : Matrix n n \u03b1) i i = 1", "start": [535, 1], "end": [537, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_apply_ne", "code": "@[simp]\ntheorem one_apply_ne {i j} : i \u2260 j \u2192 (1 : Matrix n n \u03b1) i j = 0", "start": [540, 1], "end": [542, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_apply_ne'", "code": "theorem one_apply_ne' {i j} : j \u2260 i \u2192 (1 : Matrix n n \u03b1) i j = 0", "start": [545, 1], "end": [546, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_one", "code": "@[simp]\ntheorem map_one [Zero \u03b2] [One \u03b2] (f : \u03b1 \u2192 \u03b2) (h\u2080 : f 0 = 0) (h\u2081 : f 1 = 1) :\n    (1 : Matrix n n \u03b1).map f = (1 : Matrix n n \u03b2)", "start": [549, 1], "end": [554, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_eq_pi_single", "code": "theorem one_eq_pi_single {i j} : (1 : Matrix n n \u03b1) i j = Pi.single (f := fun _ => \u03b1) i 1 j", "start": [558, 1], "end": [559, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.bit0_apply", "code": "@[deprecated, simp]\ntheorem bit0_apply [Add \u03b1] (M : Matrix m m \u03b1) (i : m) (j : m) : (bit0 M) i j = bit0 (M i j)", "start": [568, 1], "end": [570, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.bit1_apply", "code": "@[deprecated]\ntheorem bit1_apply (M : Matrix n n \u03b1) (i : n) (j : n) :\n    (bit1 M) i j = if i = j then bit1 (M i j) else bit0 (M i j)", "start": [575, 1], "end": [580, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.bit1_apply_eq", "code": "@[deprecated, simp]\ntheorem bit1_apply_eq (M : Matrix n n \u03b1) (i : n) : (bit1 M) i i = bit1 (M i i)", "start": [583, 1], "end": [585, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.bit1_apply_ne", "code": "@[deprecated, simp]\ntheorem bit1_apply_ne (M : Matrix n n \u03b1) {i j : n} (h : i \u2260 j) : (bit1 M) i j = bit0 (M i j)", "start": [588, 1], "end": [590, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag", "code": "def diag (A : Matrix n n \u03b1) (i : n) : \u03b1 :=\n  A i i", "start": [599, 1], "end": [602, 8], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_apply", "code": "@[simp]\ntheorem diag_apply (A : Matrix n n \u03b1) (i) : diag A i = A i i", "start": [607, 1], "end": [609, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_diagonal", "code": "@[simp]\ntheorem diag_diagonal [DecidableEq n] [Zero \u03b1] (a : n \u2192 \u03b1) : diag (diagonal a) = a", "start": [611, 1], "end": [613, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_transpose", "code": "@[simp]\ntheorem diag_transpose (A : Matrix n n \u03b1) : diag A\u1d40 = diag A", "start": [616, 1], "end": [618, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_zero", "code": "@[simp]\ntheorem diag_zero [Zero \u03b1] : diag (0 : Matrix n n \u03b1) = 0", "start": [621, 1], "end": [623, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_add", "code": "@[simp]\ntheorem diag_add [Add \u03b1] (A B : Matrix n n \u03b1) : diag (A + B) = diag A + diag B", "start": [626, 1], "end": [628, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_sub", "code": "@[simp]\ntheorem diag_sub [Sub \u03b1] (A B : Matrix n n \u03b1) : diag (A - B) = diag A - diag B", "start": [631, 1], "end": [633, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_neg", "code": "@[simp]\ntheorem diag_neg [Neg \u03b1] (A : Matrix n n \u03b1) : diag (-A) = -diag A", "start": [636, 1], "end": [638, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_smul", "code": "@[simp]\ntheorem diag_smul [SMul R \u03b1] (r : R) (A : Matrix n n \u03b1) : diag (r \u2022 A) = r \u2022 diag A", "start": [641, 1], "end": [643, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_one", "code": "@[simp]\ntheorem diag_one [DecidableEq n] [Zero \u03b1] [One \u03b1] : diag (1 : Matrix n n \u03b1) = 1", "start": [646, 1], "end": [648, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagAddMonoidHom", "code": "@[simps]\ndef diagAddMonoidHom [AddZeroClass \u03b1] : Matrix n n \u03b1 \u2192+ n \u2192 \u03b1 where\n  toFun := diag\n  map_zero' := diag_zero\n  map_add' := diag_add", "start": [653, 1], "end": [658, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagLinearMap", "code": "@[simps]\ndef diagLinearMap [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] : Matrix n n \u03b1 \u2192\u2097[R] n \u2192 \u03b1 :=\n  { diagAddMonoidHom n \u03b1 with map_smul' := diag_smul }", "start": [663, 1], "end": [666, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_map", "code": "theorem diag_map {f : \u03b1 \u2192 \u03b2} {A : Matrix n n \u03b1} : diag (A.map f) = f \u2218 diag A", "start": [671, 1], "end": [672, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_conjTranspose", "code": "@[simp]\ntheorem diag_conjTranspose [AddMonoid \u03b1] [StarAddMonoid \u03b1] (A : Matrix n n \u03b1) :\n    diag A\u1d34 = star (diag A)", "start": [675, 1], "end": [678, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_list_sum", "code": "@[simp]\ntheorem diag_list_sum [AddMonoid \u03b1] (l : List (Matrix n n \u03b1)) : diag l.sum = (l.map diag).sum", "start": [681, 1], "end": [683, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_multiset_sum", "code": "@[simp]\ntheorem diag_multiset_sum [AddCommMonoid \u03b1] (s : Multiset (Matrix n n \u03b1)) :\n    diag s.sum = (s.map diag).sum", "start": [686, 1], "end": [689, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_sum", "code": "@[simp]\ntheorem diag_sum {\u03b9} [AddCommMonoid \u03b1] (s : Finset \u03b9) (f : \u03b9 \u2192 Matrix n n \u03b1) :\n    diag (\u2211 i in s, f i) = \u2211 i in s, diag (f i)", "start": [692, 1], "end": [695, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct", "code": "def dotProduct [Mul \u03b1] [AddCommMonoid \u03b1] (v w : m \u2192 \u03b1) : \u03b1 :=\n  \u2211 i, v i * w i", "start": [704, 1], "end": [706, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_assoc", "code": "theorem dotProduct_assoc [NonUnitalSemiring \u03b1] (u : m \u2192 \u03b1) (w : n \u2192 \u03b1) (v : Matrix m n \u03b1) :\n    (fun j => u \u2b1d\u1d65 fun i => v i j) \u2b1d\u1d65 w = u \u2b1d\u1d65 fun i => v i \u2b1d\u1d65 w", "start": [714, 1], "end": [716, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_comm", "code": "theorem dotProduct_comm [AddCommMonoid \u03b1] [CommSemigroup \u03b1] (v w : m \u2192 \u03b1) : v \u2b1d\u1d65 w = w \u2b1d\u1d65 v", "start": [719, 1], "end": [720, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_pUnit", "code": "@[simp]\ntheorem dotProduct_pUnit [AddCommMonoid \u03b1] [Mul \u03b1] (v w : PUnit \u2192 \u03b1) : v \u2b1d\u1d65 w = v \u27e8\u27e9 * w \u27e8\u27e9", "start": [723, 1], "end": [725, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_one", "code": "theorem dotProduct_one (v : n \u2192 \u03b1) : v \u2b1d\u1d65 1 = \u2211 i, v i", "start": [732, 1], "end": [732, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_dotProduct", "code": "theorem one_dotProduct (v : n \u2192 \u03b1) : 1 \u2b1d\u1d65 v = \u2211 i, v i", "start": [735, 1], "end": [735, 77], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_zero", "code": "@[simp]\ntheorem dotProduct_zero : v \u2b1d\u1d65 0 = 0", "start": [744, 1], "end": [745, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_zero'", "code": "@[simp]\ntheorem dotProduct_zero' : (v \u2b1d\u1d65 fun _ => 0) = 0", "start": [748, 1], "end": [750, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_dotProduct", "code": "@[simp]\ntheorem zero_dotProduct : 0 \u2b1d\u1d65 v = 0", "start": [753, 1], "end": [754, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_dotProduct'", "code": "@[simp]\ntheorem zero_dotProduct' : (fun _ => (0 : \u03b1)) \u2b1d\u1d65 v = 0", "start": [757, 1], "end": [759, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_dotProduct", "code": "@[simp]\ntheorem add_dotProduct : (u + v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w + v \u2b1d\u1d65 w", "start": [762, 1], "end": [764, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_add", "code": "@[simp]\ntheorem dotProduct_add : u \u2b1d\u1d65 (v + w) = u \u2b1d\u1d65 v + u \u2b1d\u1d65 w", "start": [767, 1], "end": [769, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_elim_dotProduct_sum_elim", "code": "@[simp]\ntheorem sum_elim_dotProduct_sum_elim : Sum.elim u x \u2b1d\u1d65 Sum.elim v y = u \u2b1d\u1d65 v + x \u2b1d\u1d65 y", "start": [772, 1], "end": [774, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.comp_equiv_symm_dotProduct", "code": "@[simp]\ntheorem comp_equiv_symm_dotProduct (e : m \u2243 n) : u \u2218 e.symm \u2b1d\u1d65 x = u \u2b1d\u1d65 x \u2218 e", "start": [777, 1], "end": [781, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_comp_equiv_symm", "code": "@[simp]\ntheorem dotProduct_comp_equiv_symm (e : n \u2243 m) : u \u2b1d\u1d65 x \u2218 e.symm = u \u2218 e \u2b1d\u1d65 x", "start": [784, 1], "end": [787, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.comp_equiv_dotProduct_comp_equiv", "code": "@[simp]\ntheorem comp_equiv_dotProduct_comp_equiv (e : m \u2243 n) : x \u2218 e \u2b1d\u1d65 y \u2218 e = x \u2b1d\u1d65 y", "start": [790, 1], "end": [794, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_dotProduct", "code": "@[simp]\ntheorem diagonal_dotProduct (i : m) : diagonal v i \u2b1d\u1d65 w = v i * w i", "start": [803, 1], "end": [807, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_diagonal", "code": "@[simp]\ntheorem dotProduct_diagonal (i : m) : v \u2b1d\u1d65 diagonal w i = v i * w i", "start": [810, 1], "end": [814, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_diagonal'", "code": "@[simp]\ntheorem dotProduct_diagonal' (i : m) : (v \u2b1d\u1d65 fun j => diagonal w j i) = v i * w i", "start": [817, 1], "end": [821, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.single_dotProduct", "code": "@[simp]\ntheorem single_dotProduct (x : \u03b1) (i : m) : Pi.single i x \u2b1d\u1d65 v = x * v i", "start": [824, 1], "end": [829, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_single", "code": "@[simp]\ntheorem dotProduct_single (x : \u03b1) (i : m) : v \u2b1d\u1d65 Pi.single i x = v i * x", "start": [832, 1], "end": [837, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_dotProduct_one", "code": "@[simp]\ntheorem one_dotProduct_one : (1 : n \u2192 \u03b1) \u2b1d\u1d65 1 = Fintype.card n", "start": [846, 1], "end": [848, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_dotProduct", "code": "@[simp]\ntheorem neg_dotProduct : -v \u2b1d\u1d65 w = -(v \u2b1d\u1d65 w)", "start": [857, 1], "end": [858, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_neg", "code": "@[simp]\ntheorem dotProduct_neg : v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w)", "start": [861, 1], "end": [862, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub_dotProduct", "code": "@[simp]\ntheorem sub_dotProduct : (u - v) \u2b1d\u1d65 w = u \u2b1d\u1d65 w - v \u2b1d\u1d65 w", "start": [865, 1], "end": [866, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_sub", "code": "@[simp]\ntheorem dotProduct_sub : u \u2b1d\u1d65 (v - w) = u \u2b1d\u1d65 v - u \u2b1d\u1d65 w", "start": [869, 1], "end": [870, 84], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_dotProduct", "code": "@[simp]\ntheorem smul_dotProduct [IsScalarTower R \u03b1 \u03b1] (x : R) (v w : m \u2192 \u03b1) : x \u2022 v \u2b1d\u1d65 w = x \u2022 (v \u2b1d\u1d65 w)", "start": [879, 1], "end": [881, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_smul", "code": "@[simp]\ntheorem dotProduct_smul [SMulCommClass R \u03b1 \u03b1] (x : R) (v w : m \u2192 \u03b1) : v \u2b1d\u1d65 x \u2022 w = x \u2022 (v \u2b1d\u1d65 w)", "start": [884, 1], "end": [886, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_dotProduct_star", "code": "theorem star_dotProduct_star : star v \u2b1d\u1d65 star w = star (w \u2b1d\u1d65 v)", "start": [895, 1], "end": [895, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_dotProduct", "code": "theorem star_dotProduct : star v \u2b1d\u1d65 w = star (star w \u2b1d\u1d65 v)", "start": [898, 1], "end": [898, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_star", "code": "theorem dotProduct_star : v \u2b1d\u1d65 star w = star (w \u2b1d\u1d65 star v)", "start": [901, 1], "end": [901, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_apply", "code": "theorem mul_apply [Fintype m] [Mul \u03b1] [AddCommMonoid \u03b1] {M : Matrix l m \u03b1} {N : Matrix m n \u03b1}\n    {i k} : (M * N) i k = \u2211 j, M i j * N j k", "start": [921, 1], "end": [923, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_apply'", "code": "theorem mul_apply' [Fintype m] [Mul \u03b1] [AddCommMonoid \u03b1] {M : Matrix l m \u03b1} {N : Matrix m n \u03b1}\n    {i k} : (M * N) i k = (fun j => M i j) \u2b1d\u1d65 fun j => N j k", "start": [930, 1], "end": [932, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_neg", "code": "@[simp]\ntheorem diagonal_neg [DecidableEq n] [AddGroup \u03b1] (d : n \u2192 \u03b1) :\n    -diagonal d = diagonal fun i => -d i", "start": [935, 1], "end": [938, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_apply", "code": "theorem sum_apply [AddCommMonoid \u03b1] (i : m) (j : n) (s : Finset \u03b2) (g : \u03b2 \u2192 Matrix m n \u03b1) :\n    (\u2211 c in s, g c) i j = \u2211 c in s, g c i j", "start": [941, 1], "end": [943, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.two_mul_expl", "code": "theorem two_mul_expl {R : Type*} [CommRing R] (A B : Matrix (Fin 2) (Fin 2) R) :\n    (A * B) 0 0 = A 0 0 * B 0 0 + A 0 1 * B 1 0 \u2227\n    (A * B) 0 1 = A 0 0 * B 0 1 + A 0 1 * B 1 1 \u2227\n    (A * B) 1 0 = A 1 0 * B 0 0 + A 1 1 * B 1 0 \u2227\n    (A * B) 1 1 = A 1 0 * B 0 1 + A 1 1 * B 1 1", "start": [946, 1], "end": [953, 9], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_mul", "code": "@[simp]\ntheorem smul_mul [Fintype n] [Monoid R] [DistribMulAction R \u03b1] [IsScalarTower R \u03b1 \u03b1] (a : R)\n    (M : Matrix m n \u03b1) (N : Matrix n l \u03b1) : (a \u2022 M) * N = a \u2022 (M * N)", "start": [960, 1], "end": [964, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_smul", "code": "@[simp]\ntheorem mul_smul [Fintype n] [Monoid R] [DistribMulAction R \u03b1] [SMulCommClass R \u03b1 \u03b1]\n    (M : Matrix m n \u03b1) (a : R) (N : Matrix n l \u03b1) : M * (a \u2022 N) = a \u2022 (M * N)", "start": [967, 1], "end": [971, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_zero", "code": "@[simp]\nprotected theorem mul_zero [Fintype n] (M : Matrix m n \u03b1) : M * (0 : Matrix n o \u03b1) = 0", "start": [980, 1], "end": [983, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_mul", "code": "@[simp]\nprotected theorem zero_mul [Fintype m] (M : Matrix m n \u03b1) : (0 : Matrix l m \u03b1) * M = 0", "start": [986, 1], "end": [989, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_add", "code": "protected theorem mul_add [Fintype n] (L : Matrix m n \u03b1) (M N : Matrix n o \u03b1) :\n    L * (M + N) = L * M + L * N", "start": [992, 1], "end": [995, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_mul", "code": "protected theorem add_mul [Fintype m] (L M : Matrix l m \u03b1) (N : Matrix m n \u03b1) :\n    (L + M) * N = L * N + M * N", "start": [998, 1], "end": [1001, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring [Fintype n] : NonUnitalNonAssocSemiring (Matrix n n \u03b1) :=\n  { Matrix.addCommMonoid with\n    mul_zero := Matrix.mul_zero\n    zero_mul := Matrix.zero_mul\n    left_distrib := Matrix.mul_add\n    right_distrib := Matrix.add_mul }", "start": [1004, 1], "end": [1009, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_mul", "code": "@[simp]\ntheorem diagonal_mul [Fintype m] [DecidableEq m] (d : m \u2192 \u03b1) (M : Matrix m n \u03b1) (i j) :\n    (diagonal d * M) i j = d i * M i j", "start": [1011, 1], "end": [1014, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_diagonal", "code": "@[simp]\ntheorem mul_diagonal [Fintype n] [DecidableEq n] (d : n \u2192 \u03b1) (M : Matrix m n \u03b1) (i j) :\n    (M * diagonal d) i j = M i j * d j", "start": [1017, 1], "end": [1021, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_mul_diagonal", "code": "@[simp]\ntheorem diagonal_mul_diagonal [Fintype n] [DecidableEq n] (d\u2081 d\u2082 : n \u2192 \u03b1) :\n    diagonal d\u2081 * diagonal d\u2082 = diagonal fun i => d\u2081 i * d\u2082 i", "start": [1024, 1], "end": [1029, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_mul_diagonal'", "code": "theorem diagonal_mul_diagonal' [Fintype n] [DecidableEq n] (d\u2081 d\u2082 : n \u2192 \u03b1) :\n    diagonal d\u2081 * diagonal d\u2082 = diagonal fun i => d\u2081 i * d\u2082 i", "start": [1032, 1], "end": [1034, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_eq_diagonal_mul", "code": "theorem smul_eq_diagonal_mul [Fintype m] [DecidableEq m] (M : Matrix m n \u03b1) (a : \u03b1) :\n    a \u2022 M = (diagonal fun _ => a) * M", "start": [1037, 1], "end": [1040, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_col_mul_row", "code": "@[simp]\ntheorem diag_col_mul_row (a b : n \u2192 \u03b1) : diag (col a * row b) = a * b", "start": [1043, 1], "end": [1046, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.addMonoidHomMulLeft", "code": "@[simps]\ndef addMonoidHomMulLeft [Fintype m] (M : Matrix l m \u03b1) : Matrix m n \u03b1 \u2192+ Matrix l n \u03b1 where\n  toFun x := M * x\n  map_zero' := Matrix.mul_zero _\n  map_add' := Matrix.mul_add _", "start": [1049, 1], "end": [1054, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.addMonoidHomMulRight", "code": "@[simps]\ndef addMonoidHomMulRight [Fintype m] (M : Matrix m n \u03b1) : Matrix l m \u03b1 \u2192+ Matrix l n \u03b1 where\n  toFun x := x * M\n  map_zero' := Matrix.zero_mul _\n  map_add' _ _ := Matrix.add_mul _ _ _", "start": [1057, 1], "end": [1062, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.sum_mul", "code": "protected theorem sum_mul [Fintype m] (s : Finset \u03b2) (f : \u03b2 \u2192 Matrix l m \u03b1) (M : Matrix m n \u03b1) :\n    (\u2211 a in s, f a) * M = \u2211 a in s, f a * M", "start": [1065, 1], "end": [1067, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_sum", "code": "protected theorem mul_sum [Fintype m] (s : Finset \u03b2) (f : \u03b2 \u2192 Matrix m n \u03b1) (M : Matrix l m \u03b1) :\n    (M * \u2211 a in s, f a) = \u2211 a in s, M * f a", "start": [1070, 1], "end": [1072, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.Semiring.isScalarTower", "code": "instance Semiring.isScalarTower [Fintype n] [Monoid R] [DistribMulAction R \u03b1]\n    [IsScalarTower R \u03b1 \u03b1] : IsScalarTower R (Matrix n n \u03b1) (Matrix n n \u03b1) :=\n  \u27e8fun r m n => Matrix.smul_mul r m n\u27e9", "start": [1075, 1], "end": [1078, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.Semiring.smulCommClass", "code": "instance Semiring.smulCommClass [Fintype n] [Monoid R] [DistribMulAction R \u03b1]\n    [SMulCommClass R \u03b1 \u03b1] : SMulCommClass R (Matrix n n \u03b1) (Matrix n n \u03b1) :=\n  \u27e8fun r m n => (Matrix.mul_smul m r n).symm\u27e9", "start": [1081, 1], "end": [1084, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_mul", "code": "@[simp]\nprotected theorem one_mul [Fintype m] [DecidableEq m] (M : Matrix m n \u03b1) :\n    (1 : Matrix m m \u03b1) * M = M", "start": [1093, 1], "end": [1097, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_one", "code": "@[simp]\nprotected theorem mul_one [Fintype n] [DecidableEq n] (M : Matrix m n \u03b1) :\n    M * (1 : Matrix n n \u03b1) = M", "start": [1100, 1], "end": [1104, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonAssocSemiring", "code": "instance nonAssocSemiring [Fintype n] [DecidableEq n] : NonAssocSemiring (Matrix n n \u03b1) :=\n  { Matrix.nonUnitalNonAssocSemiring with\n    one := 1\n    one_mul := Matrix.one_mul\n    mul_one := Matrix.mul_one\n    natCast := fun n => diagonal fun _ => n\n    natCast_zero := by\n      ext\n      simp [Nat.cast]\n    natCast_succ := fun n => by\n      ext i j\n      by_cases i = j <;>\n      simp [Nat.cast, *]}", "start": [1107, 1], "end": [1119, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_mul", "code": "@[simp]\ntheorem map_mul [Fintype n] {L : Matrix m n \u03b1} {M : Matrix n o \u03b1} [NonAssocSemiring \u03b2]\n    {f : \u03b1 \u2192+* \u03b2} : (L * M).map f = L.map f * M.map f", "start": [1121, 1], "end": [1125, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalRingHom", "code": "@[simps]\ndef diagonalRingHom [Fintype n] [DecidableEq n] : (n \u2192 \u03b1) \u2192+* Matrix n n \u03b1 :=\n  { diagonalAddMonoidHom n \u03b1 with\n    toFun := diagonal\n    map_one' := diagonal_one\n    map_mul' := fun _ _ => (diagonal_mul_diagonal' _ _).symm }", "start": [1130, 1], "end": [1136, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_assoc", "code": "protected theorem mul_assoc (L : Matrix l m \u03b1) (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) :\n    L * M * N = L * (M * N)", "start": [1145, 1], "end": [1148, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonUnitalSemiring", "code": "instance nonUnitalSemiring : NonUnitalSemiring (Matrix n n \u03b1) :=\n  { Matrix.nonUnitalNonAssocSemiring with mul_assoc := Matrix.mul_assoc }", "start": [1151, 1], "end": [1152, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.semiring", "code": "instance semiring [Fintype n] [DecidableEq n] : Semiring (Matrix n n \u03b1) :=\n  { Matrix.nonUnitalSemiring, Matrix.nonAssocSemiring with }", "start": [1160, 1], "end": [1161, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_mul", "code": "@[simp]\nprotected theorem neg_mul (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) : (-M) * N = -(M * N)", "start": [1169, 1], "end": [1172, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_neg", "code": "@[simp]\nprotected theorem mul_neg (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) : M * (-N) = -(M * N)", "start": [1175, 1], "end": [1178, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub_mul", "code": "protected theorem sub_mul (M M' : Matrix m n \u03b1) (N : Matrix n o \u03b1) :\n    (M - M') * N = M * N - M' * N", "start": [1181, 1], "end": [1183, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_sub", "code": "protected theorem mul_sub (M : Matrix m n \u03b1) (N N' : Matrix n o \u03b1) :\n    M * (N - N') = M * N - M * N'", "start": [1186, 1], "end": [1188, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing : NonUnitalNonAssocRing (Matrix n n \u03b1) :=\n  { Matrix.nonUnitalNonAssocSemiring, Matrix.addCommGroup with }", "start": [1191, 1], "end": [1192, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.instNonUnitalRing", "code": "instance instNonUnitalRing [Fintype n] [NonUnitalRing \u03b1] : NonUnitalRing (Matrix n n \u03b1) :=\n  { Matrix.nonUnitalSemiring, Matrix.addCommGroup with }", "start": [1196, 1], "end": [1197, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.instNonAssocRing", "code": "instance instNonAssocRing [Fintype n] [DecidableEq n] [NonAssocRing \u03b1] :\n    NonAssocRing (Matrix n n \u03b1) :=\n  { Matrix.nonAssocSemiring, Matrix.addCommGroup with }", "start": [1200, 1], "end": [1202, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.instRing", "code": "instance instRing [Fintype n] [DecidableEq n] [Ring \u03b1] : Ring (Matrix n n \u03b1) :=\n  { Matrix.semiring, Matrix.addCommGroup with }", "start": [1205, 1], "end": [1206, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_pow", "code": "theorem diagonal_pow [Fintype n] [DecidableEq n] (v : n \u2192 \u03b1) (k : \u2115) :\n    diagonal v ^ k = diagonal (v ^ k)", "start": [1213, 1], "end": [1215, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_mul_left", "code": "@[simp]\ntheorem mul_mul_left [Fintype n] (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) (a : \u03b1) :\n    (of fun i j => a * M i j) * N = a \u2022 (M * N)", "start": [1218, 1], "end": [1221, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.scalar", "code": "def scalar (n : Type u) [DecidableEq n] [Fintype n] : \u03b1 \u2192+* Matrix n n \u03b1 :=\n  { (smulAddHom \u03b1 _).flip (1 : Matrix n n \u03b1) with\n    toFun := fun a => a \u2022 (1 : Matrix n n \u03b1)\n    map_one' := by simp\n    map_mul' := by\n      intros\n      ext\n      simp [mul_assoc] }", "start": [1224, 1], "end": [1234, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.coe_scalar", "code": "@[simp]\ntheorem coe_scalar : (scalar n : \u03b1 \u2192 Matrix n n \u03b1) = fun a => a \u2022 (1 : Matrix n n \u03b1)", "start": [1241, 1], "end": [1243, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.scalar_apply_eq", "code": "theorem scalar_apply_eq (a : \u03b1) (i : n) : scalar n a i i = a", "start": [1246, 1], "end": [1248, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.scalar_apply_ne", "code": "theorem scalar_apply_ne (a : \u03b1) (i j : n) (h : i \u2260 j) : scalar n a i j = 0", "start": [1251, 1], "end": [1253, 95], "kind": "commanddeclaration"}, {"full_name": "Matrix.scalar_inj", "code": "theorem scalar_inj [Nonempty n] {r s : \u03b1} : scalar n r = scalar n s \u2194 r = s", "start": [1256, 1], "end": [1263, 8], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_eq_mul_diagonal", "code": "theorem smul_eq_mul_diagonal [DecidableEq n] (M : Matrix m n \u03b1) (a : \u03b1) :\n    a \u2022 M = M * diagonal fun _ => a", "start": [1274, 1], "end": [1277, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_mul_right", "code": "@[simp]\ntheorem mul_mul_right (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) (a : \u03b1) :\n    (M * of fun i j => a * N i j) = a \u2022 (M * N)", "start": [1280, 1], "end": [1283, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.scalar.commute", "code": "theorem scalar.commute [DecidableEq n] (r : \u03b1) (M : Matrix n n \u03b1) : Commute (scalar n r) M", "start": [1286, 1], "end": [1287, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.instAlgebra", "code": "instance instAlgebra : Algebra R (Matrix n n \u03b1) :=\n  { (Matrix.scalar n).comp (algebraMap R \u03b1) with\n    commutes' := fun r x => by\n      ext\n      simp [Matrix.scalar, Matrix.mul_apply, Matrix.one_apply, Algebra.commutes, smul_ite]\n    smul_def' := fun r x => by ext; simp [Matrix.scalar, Algebra.smul_def r] }", "start": [1298, 1], "end": [1303, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.algebraMap_matrix_apply", "code": "theorem algebraMap_matrix_apply {r : R} {i j : n} :\n    algebraMap R (Matrix n n \u03b1) r i j = if i = j then algebraMap R \u03b1 r else 0", "start": [1306, 1], "end": [1309, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.algebraMap_eq_diagonal", "code": "theorem algebraMap_eq_diagonal (r : R) :\n    algebraMap R (Matrix n n \u03b1) r = diagonal (algebraMap R (n \u2192 \u03b1) r)", "start": [1312, 1], "end": [1314, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.algebraMap_eq_smul", "code": "@[simp]\ntheorem algebraMap_eq_smul (r : R) : algebraMap R (Matrix n n R) r = r \u2022 (1 : Matrix n n R)", "start": [1317, 1], "end": [1319, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.algebraMap_eq_diagonalRingHom", "code": "theorem algebraMap_eq_diagonalRingHom :\n    algebraMap R (Matrix n n \u03b1) = (diagonalRingHom n \u03b1).comp (algebraMap R _)", "start": [1322, 1], "end": [1324, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_algebraMap", "code": "@[simp]\ntheorem map_algebraMap (r : R) (f : \u03b1 \u2192 \u03b2) (hf : f 0 = 0)\n    (hf\u2082 : f (algebraMap R \u03b1 r) = algebraMap R \u03b2 r) :\n    (algebraMap R (Matrix n n \u03b1) r).map f = algebraMap R (Matrix n n \u03b2) r", "start": [1327, 1], "end": [1340, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonalAlgHom", "code": "@[simps]\ndef diagonalAlgHom : (n \u2192 \u03b1) \u2192\u2090[R] Matrix n n \u03b1 :=\n  { diagonalRingHom n \u03b1 with\n    toFun := diagonal\n    commutes' := fun r => (algebraMap_eq_diagonal r).symm }", "start": [1345, 1], "end": [1350, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.mapMatrix", "code": "@[simps apply]\ndef mapMatrix (f : \u03b1 \u2243 \u03b2) : Matrix m n \u03b1 \u2243 Matrix m n \u03b2 where\n  toFun M := M.map f\n  invFun M := M.map f.symm\n  left_inv _ := Matrix.ext fun _ _ => f.symm_apply_apply _\n  right_inv _ := Matrix.ext fun _ _ => f.apply_symm_apply _", "start": [1364, 1], "end": [1371, 60], "kind": "commanddeclaration"}, {"full_name": "Equiv.mapMatrix_refl", "code": "@[simp]\ntheorem mapMatrix_refl : (Equiv.refl \u03b1).mapMatrix = Equiv.refl (Matrix m n \u03b1)", "start": [1374, 1], "end": [1376, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mapMatrix_symm", "code": "@[simp]\ntheorem mapMatrix_symm (f : \u03b1 \u2243 \u03b2) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n \u03b2 \u2243 _)", "start": [1379, 1], "end": [1381, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.mapMatrix_trans", "code": "@[simp]\ntheorem mapMatrix_trans (f : \u03b1 \u2243 \u03b2) (g : \u03b2 \u2243 \u03b3) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n \u03b1 \u2243 _)", "start": [1384, 1], "end": [1387, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mapMatrix", "code": "@[simps]\ndef mapMatrix (f : \u03b1 \u2192+ \u03b2) : Matrix m n \u03b1 \u2192+ Matrix m n \u03b2 where\n  toFun M := M.map f\n  map_zero' := Matrix.map_zero f f.map_zero\n  map_add' := Matrix.map_add f f.map_add", "start": [1396, 1], "end": [1402, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mapMatrix_id", "code": "@[simp]\ntheorem mapMatrix_id : (AddMonoidHom.id \u03b1).mapMatrix = AddMonoidHom.id (Matrix m n \u03b1)", "start": [1405, 1], "end": [1407, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.mapMatrix_comp", "code": "@[simp]\ntheorem mapMatrix_comp (f : \u03b2 \u2192+ \u03b3) (g : \u03b1 \u2192+ \u03b2) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m n \u03b1 \u2192+ _)", "start": [1410, 1], "end": [1413, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mapMatrix", "code": "@[simps apply]\ndef mapMatrix (f : \u03b1 \u2243+ \u03b2) : Matrix m n \u03b1 \u2243+ Matrix m n \u03b2 :=\n  { f.toEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm\n    map_add' := Matrix.map_add f f.map_add }", "start": [1422, 1], "end": [1429, 45], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mapMatrix_refl", "code": "@[simp]\ntheorem mapMatrix_refl : (AddEquiv.refl \u03b1).mapMatrix = AddEquiv.refl (Matrix m n \u03b1)", "start": [1432, 1], "end": [1434, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mapMatrix_symm", "code": "@[simp]\ntheorem mapMatrix_symm (f : \u03b1 \u2243+ \u03b2) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n \u03b2 \u2243+ _)", "start": [1437, 1], "end": [1439, 6], "kind": "commanddeclaration"}, {"full_name": "AddEquiv.mapMatrix_trans", "code": "@[simp]\ntheorem mapMatrix_trans (f : \u03b1 \u2243+ \u03b2) (g : \u03b2 \u2243+ \u03b3) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n \u03b1 \u2243+ _)", "start": [1442, 1], "end": [1445, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mapMatrix", "code": "@[simps]\ndef mapMatrix (f : \u03b1 \u2192\u2097[R] \u03b2) : Matrix m n \u03b1 \u2192\u2097[R] Matrix m n \u03b2 where\n  toFun M := M.map f\n  map_add' := Matrix.map_add f f.map_add\n  map_smul' r := Matrix.map_smul f r (f.map_smul r)", "start": [1456, 1], "end": [1462, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mapMatrix_id", "code": "@[simp]\ntheorem mapMatrix_id : LinearMap.id.mapMatrix = (LinearMap.id : Matrix m n \u03b1 \u2192\u2097[R] _)", "start": [1465, 1], "end": [1467, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.mapMatrix_comp", "code": "@[simp]\ntheorem mapMatrix_comp (f : \u03b2 \u2192\u2097[R] \u03b3) (g : \u03b1 \u2192\u2097[R] \u03b2) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m n \u03b1 \u2192\u2097[R] _)", "start": [1470, 1], "end": [1473, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mapMatrix", "code": "@[simps apply]\ndef mapMatrix (f : \u03b1 \u2243\u2097[R] \u03b2) : Matrix m n \u03b1 \u2243\u2097[R] Matrix m n \u03b2 :=\n  { f.toEquiv.mapMatrix,\n    f.toLinearMap.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }", "start": [1484, 1], "end": [1491, 38], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mapMatrix_refl", "code": "@[simp]\ntheorem mapMatrix_refl : (LinearEquiv.refl R \u03b1).mapMatrix = LinearEquiv.refl R (Matrix m n \u03b1)", "start": [1494, 1], "end": [1496, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mapMatrix_symm", "code": "@[simp]\ntheorem mapMatrix_symm (f : \u03b1 \u2243\u2097[R] \u03b2) :\n    f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m n \u03b2 \u2243\u2097[R] _)", "start": [1499, 1], "end": [1502, 6], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.mapMatrix_trans", "code": "@[simp]\ntheorem mapMatrix_trans (f : \u03b1 \u2243\u2097[R] \u03b2) (g : \u03b2 \u2243\u2097[R] \u03b3) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m n \u03b1 \u2243\u2097[R] _)", "start": [1505, 1], "end": [1508, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mapMatrix", "code": "@[simps]\ndef mapMatrix (f : \u03b1 \u2192+* \u03b2) : Matrix m m \u03b1 \u2192+* Matrix m m \u03b2 :=\n  { f.toAddMonoidHom.mapMatrix with\n    toFun := fun M => M.map f\n    map_one' := by simp\n    map_mul' := fun L M => Matrix.map_mul }", "start": [1519, 1], "end": [1526, 44], "kind": "commanddeclaration"}, {"full_name": "RingHom.mapMatrix_id", "code": "@[simp]\ntheorem mapMatrix_id : (RingHom.id \u03b1).mapMatrix = RingHom.id (Matrix m m \u03b1)", "start": [1529, 1], "end": [1531, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mapMatrix_comp", "code": "@[simp]\ntheorem mapMatrix_comp (f : \u03b2 \u2192+* \u03b3) (g : \u03b1 \u2192+* \u03b2) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m m \u03b1 \u2192+* _)", "start": [1534, 1], "end": [1537, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mapMatrix", "code": "@[simps apply]\ndef mapMatrix (f : \u03b1 \u2243+* \u03b2) : Matrix m m \u03b1 \u2243+* Matrix m m \u03b2 :=\n  { f.toRingHom.mapMatrix,\n    f.toAddEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }", "start": [1548, 1], "end": [1555, 38], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mapMatrix_refl", "code": "@[simp]\ntheorem mapMatrix_refl : (RingEquiv.refl \u03b1).mapMatrix = RingEquiv.refl (Matrix m m \u03b1)", "start": [1558, 1], "end": [1560, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mapMatrix_symm", "code": "@[simp]\ntheorem mapMatrix_symm (f : \u03b1 \u2243+* \u03b2) : f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m m \u03b2 \u2243+* _)", "start": [1563, 1], "end": [1565, 6], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.mapMatrix_trans", "code": "@[simp]\ntheorem mapMatrix_trans (f : \u03b1 \u2243+* \u03b2) (g : \u03b2 \u2243+* \u03b3) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m m \u03b1 \u2243+* _)", "start": [1568, 1], "end": [1571, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mapMatrix", "code": "@[simps]\ndef mapMatrix (f : \u03b1 \u2192\u2090[R] \u03b2) : Matrix m m \u03b1 \u2192\u2090[R] Matrix m m \u03b2 :=\n  { f.toRingHom.mapMatrix with\n    toFun := fun M => M.map f\n    commutes' := fun r => Matrix.map_algebraMap r f f.map_zero (f.commutes r) }", "start": [1584, 1], "end": [1590, 80], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mapMatrix_id", "code": "@[simp]\ntheorem mapMatrix_id : (AlgHom.id R \u03b1).mapMatrix = AlgHom.id R (Matrix m m \u03b1)", "start": [1593, 1], "end": [1595, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mapMatrix_comp", "code": "@[simp]\ntheorem mapMatrix_comp (f : \u03b2 \u2192\u2090[R] \u03b3) (g : \u03b1 \u2192\u2090[R] \u03b2) :\n    f.mapMatrix.comp g.mapMatrix = ((f.comp g).mapMatrix : Matrix m m \u03b1 \u2192\u2090[R] _)", "start": [1598, 1], "end": [1601, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mapMatrix", "code": "@[simps apply]\ndef mapMatrix (f : \u03b1 \u2243\u2090[R] \u03b2) : Matrix m m \u03b1 \u2243\u2090[R] Matrix m m \u03b2 :=\n  { f.toAlgHom.mapMatrix,\n    f.toRingEquiv.mapMatrix with\n    toFun := fun M => M.map f\n    invFun := fun M => M.map f.symm }", "start": [1614, 1], "end": [1621, 38], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mapMatrix_refl", "code": "@[simp]\ntheorem mapMatrix_refl : AlgEquiv.refl.mapMatrix = (AlgEquiv.refl : Matrix m m \u03b1 \u2243\u2090[R] _)", "start": [1624, 1], "end": [1626, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mapMatrix_symm", "code": "@[simp]\ntheorem mapMatrix_symm (f : \u03b1 \u2243\u2090[R] \u03b2) :\n    f.mapMatrix.symm = (f.symm.mapMatrix : Matrix m m \u03b2 \u2243\u2090[R] _)", "start": [1629, 1], "end": [1632, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.mapMatrix_trans", "code": "@[simp]\ntheorem mapMatrix_trans (f : \u03b1 \u2243\u2090[R] \u03b2) (g : \u03b2 \u2243\u2090[R] \u03b3) :\n    f.mapMatrix.trans g.mapMatrix = ((f.trans g).mapMatrix : Matrix m m \u03b1 \u2243\u2090[R] _)", "start": [1635, 1], "end": [1638, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMulVec", "code": "def vecMulVec [Mul \u03b1] (w : m \u2192 \u03b1) (v : n \u2192 \u03b1) : Matrix m n \u03b1 :=\n  of fun x y => w x * v y", "start": [1647, 1], "end": [1650, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMulVec_apply", "code": "theorem vecMulVec_apply [Mul \u03b1] (w : m \u2192 \u03b1) (v : n \u2192 \u03b1) (i j) : vecMulVec w v i j = w i * v j", "start": [1654, 1], "end": [1655, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMulVec_eq", "code": "theorem vecMulVec_eq [Mul \u03b1] [AddCommMonoid \u03b1] (w : m \u2192 \u03b1) (v : n \u2192 \u03b1) :\n    vecMulVec w v = col w * row v", "start": [1658, 1], "end": [1662, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec", "code": "def mulVec [Fintype n] (M : Matrix m n \u03b1) (v : n \u2192 \u03b1) : m \u2192 \u03b1\n  | i => (fun j => M i j) \u2b1d\u1d65 v", "start": [1669, 1], "end": [1673, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul", "code": "def vecMul [Fintype m] (v : m \u2192 \u03b1) (M : Matrix m n \u03b1) : n \u2192 \u03b1\n  | j => v \u2b1d\u1d65 fun i => M i j", "start": [1676, 1], "end": [1680, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec.addMonoidHomLeft", "code": "@[simps]\ndef mulVec.addMonoidHomLeft [Fintype n] (v : n \u2192 \u03b1) : Matrix m n \u03b1 \u2192+ m \u2192 \u03b1 where\n  toFun M := mulVec M v\n  map_zero' := by\n    ext\n    simp [mulVec]\n  map_add' x y := by\n    ext m\n    apply add_dotProduct", "start": [1683, 1], "end": [1692, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_diagonal", "code": "theorem mulVec_diagonal [Fintype m] [DecidableEq m] (v w : m \u2192 \u03b1) (x : m) :\n    mulVec (diagonal v) w x = v x * w x", "start": [1695, 1], "end": [1697, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_diagonal", "code": "theorem vecMul_diagonal [Fintype m] [DecidableEq m] (v w : m \u2192 \u03b1) (x : m) :\n    vecMul v (diagonal w) x = v x * w x", "start": [1700, 1], "end": [1702, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_mulVec", "code": "theorem dotProduct_mulVec [Fintype n] [Fintype m] [NonUnitalSemiring R] (v : m \u2192 R)\n    (A : Matrix m n R) (w : n \u2192 R) : v \u2b1d\u1d65 mulVec A w = vecMul v A \u2b1d\u1d65 w", "start": [1705, 1], "end": [1709, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_zero", "code": "@[simp]\ntheorem mulVec_zero [Fintype n] (A : Matrix m n \u03b1) : mulVec A 0 = 0", "start": [1712, 1], "end": [1715, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_vecMul", "code": "@[simp]\ntheorem zero_vecMul [Fintype m] (A : Matrix m n \u03b1) : vecMul 0 A = 0", "start": [1718, 1], "end": [1721, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.zero_mulVec", "code": "@[simp]\ntheorem zero_mulVec [Fintype n] (v : n \u2192 \u03b1) : mulVec (0 : Matrix m n \u03b1) v = 0", "start": [1724, 1], "end": [1727, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_zero", "code": "@[simp]\ntheorem vecMul_zero [Fintype m] (v : m \u2192 \u03b1) : vecMul v (0 : Matrix m n \u03b1) = 0", "start": [1730, 1], "end": [1733, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_mulVec_assoc", "code": "theorem smul_mulVec_assoc [Fintype n] [Monoid R] [DistribMulAction R \u03b1] [IsScalarTower R \u03b1 \u03b1]\n    (a : R) (A : Matrix m n \u03b1) (b : n \u2192 \u03b1) : (a \u2022 A).mulVec b = a \u2022 A.mulVec b", "start": [1736, 1], "end": [1739, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_add", "code": "theorem mulVec_add [Fintype n] (A : Matrix m n \u03b1) (x y : n \u2192 \u03b1) :\n    A.mulVec (x + y) = A.mulVec x + A.mulVec y", "start": [1742, 1], "end": [1745, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_mulVec", "code": "theorem add_mulVec [Fintype n] (A B : Matrix m n \u03b1) (x : n \u2192 \u03b1) :\n    (A + B).mulVec x = A.mulVec x + B.mulVec x", "start": [1748, 1], "end": [1751, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_add", "code": "theorem vecMul_add [Fintype m] (A B : Matrix m n \u03b1) (x : m \u2192 \u03b1) :\n    vecMul x (A + B) = vecMul x A + vecMul x B", "start": [1754, 1], "end": [1757, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.add_vecMul", "code": "theorem add_vecMul [Fintype m] (A : Matrix m n \u03b1) (x y : m \u2192 \u03b1) :\n    vecMul (x + y) A = vecMul x A + vecMul y A", "start": [1760, 1], "end": [1763, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_smul", "code": "theorem vecMul_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [IsScalarTower R S S] (M : Matrix n m S) (b : R) (v : n \u2192 S) :\n    M.vecMul (b \u2022 v) = b \u2022 M.vecMul v", "start": [1766, 1], "end": [1770, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_smul", "code": "theorem mulVec_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n    [SMulCommClass R S S] (M : Matrix m n S) (b : R) (v : n \u2192 S) :\n    M.mulVec (b \u2022 v) = b \u2022 M.mulVec v", "start": [1773, 1], "end": [1777, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_single", "code": "@[simp]\ntheorem mulVec_single [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (M : Matrix m n R)\n    (j : n) (x : R) : M.mulVec (Pi.single j x) = fun i => M i j * x", "start": [1780, 1], "end": [1783, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.single_vecMul", "code": "@[simp]\ntheorem single_vecMul [Fintype m] [DecidableEq m] [NonUnitalNonAssocSemiring R] (M : Matrix m n R)\n    (i : m) (x : R) : vecMul (Pi.single i x) M = fun j => x * M i j", "start": [1786, 1], "end": [1789, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_mulVec_single", "code": "theorem diagonal_mulVec_single [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n \u2192 R)\n    (j : n) (x : R) : (diagonal v).mulVec (Pi.single j x) = Pi.single j (v j * x)", "start": [1793, 1], "end": [1797, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.single_vecMul_diagonal", "code": "theorem single_vecMul_diagonal [Fintype n] [DecidableEq n] [NonUnitalNonAssocSemiring R] (v : n \u2192 R)\n    (j : n) (x : R) : vecMul (Pi.single j x) (diagonal v) = Pi.single j (x * v j)", "start": [1801, 1], "end": [1805, 73], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_vecMul", "code": "@[simp]\ntheorem vecMul_vecMul [Fintype n] [Fintype m] (v : m \u2192 \u03b1) (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) :\n    vecMul (vecMul v M) N = vecMul v (M * N)", "start": [1814, 1], "end": [1818, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_mulVec", "code": "@[simp]\ntheorem mulVec_mulVec [Fintype n] [Fintype o] (v : o \u2192 \u03b1) (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) :\n    mulVec M (mulVec N v) = mulVec (M * N) v", "start": [1821, 1], "end": [1826, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_mulVec", "code": "theorem star_mulVec [Fintype n] [StarRing \u03b1] (M : Matrix m n \u03b1) (v : n \u2192 \u03b1) :\n    star (M.mulVec v) = vecMul (star v) M\u1d34", "start": [1829, 1], "end": [1831, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_vecMul", "code": "theorem star_vecMul [Fintype m] [StarRing \u03b1] (M : Matrix m n \u03b1) (v : m \u2192 \u03b1) :\n    star (M.vecMul v) = M\u1d34.mulVec (star v)", "start": [1834, 1], "end": [1836, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_conjTranspose", "code": "theorem mulVec_conjTranspose [Fintype m] [StarRing \u03b1] (A : Matrix m n \u03b1) (x : m \u2192 \u03b1) :\n    mulVec A\u1d34 x = star (vecMul (star x) A)", "start": [1839, 1], "end": [1841, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_conjTranspose", "code": "theorem vecMul_conjTranspose [Fintype n] [StarRing \u03b1] (A : Matrix m n \u03b1) (x : n \u2192 \u03b1) :\n    vecMul x A\u1d34 = star (mulVec A (star x))", "start": [1844, 1], "end": [1846, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_mul_apply", "code": "theorem mul_mul_apply [Fintype n] (A B C : Matrix n n \u03b1) (i j : n) :\n    (A * B * C) i j = A i \u2b1d\u1d65 B.mulVec (C\u1d40 j)", "start": [1849, 1], "end": [1853, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_one", "code": "theorem mulVec_one [Fintype n] (A : Matrix m n \u03b1) : mulVec A 1 = fun i => \u2211 j, A i j", "start": [1862, 1], "end": [1863, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec_one_mul", "code": "theorem vec_one_mul [Fintype m] (A : Matrix m n \u03b1) : vecMul 1 A = fun j => \u2211 i, A i j", "start": [1866, 1], "end": [1867, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_mulVec", "code": "@[simp]\ntheorem one_mulVec (v : m \u2192 \u03b1) : mulVec 1 v = v", "start": [1872, 1], "end": [1875, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_one", "code": "@[simp]\ntheorem vecMul_one (v : m \u2192 \u03b1) : vecMul v 1 = v", "start": [1878, 1], "end": [1881, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_vecMul", "code": "theorem neg_vecMul [Fintype m] (v : m \u2192 \u03b1) (A : Matrix m n \u03b1) : vecMul (-v) A = -vecMul v A", "start": [1890, 1], "end": [1892, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_neg", "code": "theorem vecMul_neg [Fintype m] (v : m \u2192 \u03b1) (A : Matrix m n \u03b1) : vecMul v (-A) = -vecMul v A", "start": [1895, 1], "end": [1897, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.neg_mulVec", "code": "theorem neg_mulVec [Fintype n] (v : n \u2192 \u03b1) (A : Matrix m n \u03b1) : mulVec (-A) v = -mulVec A v", "start": [1900, 1], "end": [1902, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_neg", "code": "theorem mulVec_neg [Fintype n] (v : n \u2192 \u03b1) (A : Matrix m n \u03b1) : mulVec A (-v) = -mulVec A v", "start": [1905, 1], "end": [1907, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.sub_mulVec", "code": "theorem sub_mulVec [Fintype n] (A B : Matrix m n \u03b1) (x : n \u2192 \u03b1) :\n    mulVec (A - B) x = mulVec A x - mulVec B x", "start": [1910, 1], "end": [1911, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_sub", "code": "theorem vecMul_sub [Fintype m] (A B : Matrix m n \u03b1) (x : m \u2192 \u03b1) :\n    vecMul x (A - B) = vecMul x A - vecMul x B", "start": [1914, 1], "end": [1915, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_transpose", "code": "theorem mulVec_transpose [Fintype m] (A : Matrix m n \u03b1) (x : m \u2192 \u03b1) : mulVec A\u1d40 x = vecMul x A", "start": [1924, 1], "end": [1926, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_transpose", "code": "theorem vecMul_transpose [Fintype n] (A : Matrix m n \u03b1) (x : n \u2192 \u03b1) : vecMul x A\u1d40 = mulVec A x", "start": [1929, 1], "end": [1931, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_vecMul", "code": "theorem mulVec_vecMul [Fintype n] [Fintype o] (A : Matrix m n \u03b1) (B : Matrix o n \u03b1) (x : o \u2192 \u03b1) :\n    mulVec A (vecMul x B) = mulVec (A * B\u1d40) x", "start": [1934, 1], "end": [1935, 91], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_mulVec", "code": "theorem vecMul_mulVec [Fintype m] [Fintype n] (A : Matrix m n \u03b1) (B : Matrix m o \u03b1) (x : n \u2192 \u03b1) :\n    vecMul (mulVec A x) B = vecMul x (A\u1d40 * B)", "start": [1938, 1], "end": [1939, 91], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_smul_assoc", "code": "theorem mulVec_smul_assoc [Fintype n] (A : Matrix m n \u03b1) (b : n \u2192 \u03b1) (a : \u03b1) :\n    A.mulVec (a \u2022 b) = a \u2022 A.mulVec b", "start": [1948, 1], "end": [1951, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_transpose", "code": "@[simp]\ntheorem transpose_transpose (M : Matrix m n \u03b1) : M\u1d40\u1d40 = M", "start": [1960, 1], "end": [1963, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_injective", "code": "theorem transpose_injective : Function.Injective (transpose : Matrix m n \u03b1 \u2192 Matrix n m \u03b1)", "start": [1966, 1], "end": [1967, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_inj", "code": "@[simp] theorem transpose_inj {A B : Matrix m n \u03b1} : A\u1d40 = B\u1d40 \u2194 A = B", "start": [1969, 1], "end": [1969, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_zero", "code": "@[simp]\ntheorem transpose_zero [Zero \u03b1] : (0 : Matrix m n \u03b1)\u1d40 = 0", "start": [1971, 1], "end": [1974, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_eq_zero", "code": "@[simp]\ntheorem transpose_eq_zero [Zero \u03b1] {M : Matrix m n \u03b1} : M\u1d40 = 0 \u2194 M = 0", "start": [1977, 1], "end": [1978, 88], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_one", "code": "@[simp]\ntheorem transpose_one [DecidableEq n] [Zero \u03b1] [One \u03b1] : (1 : Matrix n n \u03b1)\u1d40 = 1", "start": [1980, 1], "end": [1986, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_eq_one", "code": "@[simp]\ntheorem transpose_eq_one [DecidableEq n] [Zero \u03b1] [One \u03b1] {M : Matrix n n \u03b1} : M\u1d40 = 1 \u2194 M = 1", "start": [1989, 1], "end": [1991, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_add", "code": "@[simp]\ntheorem transpose_add [Add \u03b1] (M : Matrix m n \u03b1) (N : Matrix m n \u03b1) : (M + N)\u1d40 = M\u1d40 + N\u1d40", "start": [1993, 1], "end": [1996, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_sub", "code": "@[simp]\ntheorem transpose_sub [Sub \u03b1] (M : Matrix m n \u03b1) (N : Matrix m n \u03b1) : (M - N)\u1d40 = M\u1d40 - N\u1d40", "start": [1999, 1], "end": [2002, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_mul", "code": "@[simp]\ntheorem transpose_mul [AddCommMonoid \u03b1] [CommSemigroup \u03b1] [Fintype n] (M : Matrix m n \u03b1)\n    (N : Matrix n l \u03b1) : (M * N)\u1d40 = N\u1d40 * M\u1d40", "start": [2005, 1], "end": [2009, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_smul", "code": "@[simp]\ntheorem transpose_smul {R : Type*} [SMul R \u03b1] (c : R) (M : Matrix m n \u03b1) : (c \u2022 M)\u1d40 = c \u2022 M\u1d40", "start": [2012, 1], "end": [2015, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_neg", "code": "@[simp]\ntheorem transpose_neg [Neg \u03b1] (M : Matrix m n \u03b1) : (-M)\u1d40 = -M\u1d40", "start": [2018, 1], "end": [2021, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_map", "code": "theorem transpose_map {f : \u03b1 \u2192 \u03b2} {M : Matrix m n \u03b1} : M\u1d40.map f = (M.map f)\u1d40", "start": [2024, 1], "end": [2026, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeAddEquiv", "code": "@[simps apply]\ndef transposeAddEquiv [Add \u03b1] : Matrix m n \u03b1 \u2243+ Matrix n m \u03b1 where\n  toFun := transpose\n  invFun := transpose\n  left_inv := transpose_transpose\n  right_inv := transpose_transpose\n  map_add' := transpose_add", "start": [2031, 1], "end": [2038, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeAddEquiv_symm", "code": "@[simp]\ntheorem transposeAddEquiv_symm [Add \u03b1] : (transposeAddEquiv m n \u03b1).symm = transposeAddEquiv n m \u03b1", "start": [2041, 1], "end": [2043, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_list_sum", "code": "theorem transpose_list_sum [AddMonoid \u03b1] (l : List (Matrix m n \u03b1)) :\n    l.sum\u1d40 = (l.map transpose).sum", "start": [2048, 1], "end": [2050, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_multiset_sum", "code": "theorem transpose_multiset_sum [AddCommMonoid \u03b1] (s : Multiset (Matrix m n \u03b1)) :\n    s.sum\u1d40 = (s.map transpose).sum", "start": [2053, 1], "end": [2055, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_sum", "code": "theorem transpose_sum [AddCommMonoid \u03b1] {\u03b9 : Type*} (s : Finset \u03b9) (M : \u03b9 \u2192 Matrix m n \u03b1) :\n    (\u2211 i in s, M i)\u1d40 = \u2211 i in s, (M i)\u1d40", "start": [2058, 1], "end": [2060, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeLinearEquiv", "code": "@[simps apply]\ndef transposeLinearEquiv [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] :\n    Matrix m n \u03b1 \u2243\u2097[R] Matrix n m \u03b1 :=\n  { transposeAddEquiv m n \u03b1 with map_smul' := transpose_smul }", "start": [2065, 1], "end": [2069, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeLinearEquiv_symm", "code": "@[simp]\ntheorem transposeLinearEquiv_symm [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] :\n    (transposeLinearEquiv m n R \u03b1).symm = transposeLinearEquiv n m R \u03b1", "start": [2072, 1], "end": [2075, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeRingEquiv", "code": "@[simps]\ndef transposeRingEquiv [AddCommMonoid \u03b1] [CommSemigroup \u03b1] [Fintype m] :\n    Matrix m m \u03b1 \u2243+* (Matrix m m \u03b1)\u1d50\u1d52\u1d56 :=\n  { (transposeAddEquiv m m \u03b1).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op M\u1d40\n    invFun := fun M => M.unop\u1d40\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (transpose_mul M N)).trans (MulOpposite.op_mul _ _)\n    left_inv := fun M => transpose_transpose M\n    right_inv := fun M => MulOpposite.unop_injective <| transpose_transpose M.unop }", "start": [2082, 1], "end": [2092, 85], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_pow", "code": "@[simp]\ntheorem transpose_pow [CommSemiring \u03b1] [Fintype m] [DecidableEq m] (M : Matrix m m \u03b1) (k : \u2115) :\n    (M ^ k)\u1d40 = M\u1d40 ^ k", "start": [2097, 1], "end": [2100, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_list_prod", "code": "theorem transpose_list_prod [CommSemiring \u03b1] [Fintype m] [DecidableEq m] (l : List (Matrix m m \u03b1)) :\n    l.prod\u1d40 = (l.map transpose).reverse.prod", "start": [2103, 1], "end": [2105, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.transposeAlgEquiv", "code": "@[simps]\ndef transposeAlgEquiv [CommSemiring R] [CommSemiring \u03b1] [Fintype m] [DecidableEq m] [Algebra R \u03b1] :\n    Matrix m m \u03b1 \u2243\u2090[R] (Matrix m m \u03b1)\u1d50\u1d52\u1d56 :=\n  { (transposeAddEquiv m m \u03b1).trans MulOpposite.opAddEquiv,\n    transposeRingEquiv m \u03b1 with\n    toFun := fun M => MulOpposite.op M\u1d40\n    commutes' := fun r => by\n      simp only [algebraMap_eq_diagonal, diagonal_transpose, MulOpposite.algebraMap_apply] }", "start": [2110, 1], "end": [2118, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_apply", "code": "@[simp]\ntheorem conjTranspose_apply [Star \u03b1] (M : Matrix m n \u03b1) (i j) :\n    M.conjTranspose j i = star (M i j)", "start": [2129, 1], "end": [2136, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_conjTranspose", "code": "@[simp]\ntheorem conjTranspose_conjTranspose [InvolutiveStar \u03b1] (M : Matrix m n \u03b1) : M\u1d34\u1d34 = M", "start": [2139, 1], "end": [2141, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_injective", "code": "theorem conjTranspose_injective [InvolutiveStar \u03b1] :\n    Function.Injective (conjTranspose : Matrix m n \u03b1 \u2192 Matrix n m \u03b1)", "start": [2144, 1], "end": [2146, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_inj", "code": "@[simp] theorem conjTranspose_inj [InvolutiveStar \u03b1] {A B : Matrix m n \u03b1} : A\u1d34 = B\u1d34 \u2194 A = B", "start": [2148, 1], "end": [2149, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_zero", "code": "@[simp]\ntheorem conjTranspose_zero [AddMonoid \u03b1] [StarAddMonoid \u03b1] : (0 : Matrix m n \u03b1)\u1d34 = 0", "start": [2151, 1], "end": [2153, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_eq_zero", "code": "@[simp]\ntheorem conjTranspose_eq_zero [AddMonoid \u03b1] [StarAddMonoid \u03b1] {M : Matrix m n \u03b1} :\n    M\u1d34 = 0 \u2194 M = 0", "start": [2156, 1], "end": [2159, 58], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_one", "code": "@[simp]\ntheorem conjTranspose_one [DecidableEq n] [Semiring \u03b1] [StarRing \u03b1] : (1 : Matrix n n \u03b1)\u1d34 = 1", "start": [2161, 1], "end": [2163, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_eq_one", "code": "@[simp]\ntheorem conjTranspose_eq_one [DecidableEq n] [Semiring \u03b1] [StarRing \u03b1] {M : Matrix n n \u03b1} :\n    M\u1d34 = 1 \u2194 M = 1", "start": [2166, 1], "end": [2170, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_add", "code": "@[simp]\ntheorem conjTranspose_add [AddMonoid \u03b1] [StarAddMonoid \u03b1] (M N : Matrix m n \u03b1) :\n    (M + N)\u1d34 = M\u1d34 + N\u1d34", "start": [2172, 1], "end": [2175, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_sub", "code": "@[simp]\ntheorem conjTranspose_sub [AddGroup \u03b1] [StarAddMonoid \u03b1] (M N : Matrix m n \u03b1) :\n    (M - N)\u1d34 = M\u1d34 - N\u1d34", "start": [2178, 1], "end": [2181, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_smul", "code": "@[simp]\ntheorem conjTranspose_smul [Star R] [Star \u03b1] [SMul R \u03b1] [StarModule R \u03b1] (c : R)\n    (M : Matrix m n \u03b1) : (c \u2022 M)\u1d34 = star c \u2022 M\u1d34", "start": [2184, 1], "end": [2199, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_smul_non_comm", "code": "@[simp]\ntheorem conjTranspose_smul_non_comm [Star R] [Star \u03b1] [SMul R \u03b1] [SMul R\u1d50\u1d52\u1d56 \u03b1] (c : R)\n    (M : Matrix m n \u03b1) (h : \u2200 (r : R) (a : \u03b1), star (r \u2022 a) = MulOpposite.op (star r) \u2022 star a) :\n    (c \u2022 M)\u1d34 = MulOpposite.op (star c) \u2022 M\u1d34", "start": [2202, 1], "end": [2206, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_smul_self", "code": "theorem conjTranspose_smul_self [Mul \u03b1] [StarMul \u03b1] (c : \u03b1) (M : Matrix m n \u03b1) :\n    (c \u2022 M)\u1d34 = MulOpposite.op (star c) \u2022 M\u1d34", "start": [2210, 1], "end": [2212, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_nsmul", "code": "@[simp]\ntheorem conjTranspose_nsmul [AddMonoid \u03b1] [StarAddMonoid \u03b1] (c : \u2115) (M : Matrix m n \u03b1) :\n    (c \u2022 M)\u1d34 = c \u2022 M\u1d34", "start": [2215, 1], "end": [2218, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_zsmul", "code": "@[simp]\ntheorem conjTranspose_zsmul [AddGroup \u03b1] [StarAddMonoid \u03b1] (c : \u2124) (M : Matrix m n \u03b1) :\n    (c \u2022 M)\u1d34 = c \u2022 M\u1d34", "start": [2221, 1], "end": [2224, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_natCast_smul", "code": "@[simp]\ntheorem conjTranspose_natCast_smul [Semiring R] [AddCommMonoid \u03b1] [StarAddMonoid \u03b1] [Module R \u03b1]\n    (c : \u2115) (M : Matrix m n \u03b1) : ((c : R) \u2022 M)\u1d34 = (c : R) \u2022 M\u1d34", "start": [2227, 1], "end": [2230, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_intCast_smul", "code": "@[simp]\ntheorem conjTranspose_intCast_smul [Ring R] [AddCommGroup \u03b1] [StarAddMonoid \u03b1] [Module R \u03b1] (c : \u2124)\n    (M : Matrix m n \u03b1) : ((c : R) \u2022 M)\u1d34 = (c : R) \u2022 M\u1d34", "start": [2233, 1], "end": [2236, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_inv_natCast_smul", "code": "@[simp]\ntheorem conjTranspose_inv_natCast_smul [DivisionSemiring R] [AddCommMonoid \u03b1] [StarAddMonoid \u03b1]\n    [Module R \u03b1] (c : \u2115) (M : Matrix m n \u03b1) : ((c : R)\u207b\u00b9 \u2022 M)\u1d34 = (c : R)\u207b\u00b9 \u2022 M\u1d34", "start": [2239, 1], "end": [2242, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_inv_intCast_smul", "code": "@[simp]\ntheorem conjTranspose_inv_intCast_smul [DivisionRing R] [AddCommGroup \u03b1] [StarAddMonoid \u03b1]\n    [Module R \u03b1] (c : \u2124) (M : Matrix m n \u03b1) : ((c : R)\u207b\u00b9 \u2022 M)\u1d34 = (c : R)\u207b\u00b9 \u2022 M\u1d34", "start": [2245, 1], "end": [2248, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_ratCast_smul", "code": "@[simp]\ntheorem conjTranspose_ratCast_smul [DivisionRing R] [AddCommGroup \u03b1] [StarAddMonoid \u03b1] [Module R \u03b1]\n    (c : \u211a) (M : Matrix m n \u03b1) : ((c : R) \u2022 M)\u1d34 = (c : R) \u2022 M\u1d34", "start": [2251, 1], "end": [2254, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_rat_smul", "code": "@[simp]\ntheorem conjTranspose_rat_smul [AddCommGroup \u03b1] [StarAddMonoid \u03b1] [Module \u211a \u03b1] (c : \u211a)\n    (M : Matrix m n \u03b1) : (c \u2022 M)\u1d34 = c \u2022 M\u1d34", "start": [2257, 1], "end": [2260, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_mul", "code": "@[simp]\ntheorem conjTranspose_mul [Fintype n] [NonUnitalSemiring \u03b1] [StarRing \u03b1] (M : Matrix m n \u03b1)\n    (N : Matrix n l \u03b1) : (M * N)\u1d34 = N\u1d34 * M\u1d34", "start": [2263, 1], "end": [2266, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_neg", "code": "@[simp]\ntheorem conjTranspose_neg [AddGroup \u03b1] [StarAddMonoid \u03b1] (M : Matrix m n \u03b1) : (-M)\u1d34 = -M\u1d34", "start": [2269, 1], "end": [2271, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_map", "code": "theorem conjTranspose_map [Star \u03b1] [Star \u03b2] {A : Matrix m n \u03b1} (f : \u03b1 \u2192 \u03b2)\n    (hf : Function.Semiconj f star star) : A\u1d34.map f = (A.map f)\u1d34", "start": [2274, 1], "end": [2276, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_eq_transpose_of_trivial", "code": "@[simp]\ntheorem conjTranspose_eq_transpose_of_trivial [Star \u03b1] [TrivialStar \u03b1] (A : Matrix m n \u03b1) :\n    A\u1d34 = A\u1d40", "start": [2279, 1], "end": [2283, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTransposeAddEquiv", "code": "@[simps apply]\ndef conjTransposeAddEquiv [AddMonoid \u03b1] [StarAddMonoid \u03b1] : Matrix m n \u03b1 \u2243+ Matrix n m \u03b1 where\n  toFun := conjTranspose\n  invFun := conjTranspose\n  left_inv := conjTranspose_conjTranspose\n  right_inv := conjTranspose_conjTranspose\n  map_add' := conjTranspose_add", "start": [2287, 1], "end": [2294, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTransposeAddEquiv_symm", "code": "@[simp]\ntheorem conjTransposeAddEquiv_symm [AddMonoid \u03b1] [StarAddMonoid \u03b1] :\n    (conjTransposeAddEquiv m n \u03b1).symm = conjTransposeAddEquiv n m \u03b1", "start": [2297, 1], "end": [2300, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_list_sum", "code": "theorem conjTranspose_list_sum [AddMonoid \u03b1] [StarAddMonoid \u03b1] (l : List (Matrix m n \u03b1)) :\n    l.sum\u1d34 = (l.map conjTranspose).sum", "start": [2305, 1], "end": [2307, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_multiset_sum", "code": "theorem conjTranspose_multiset_sum [AddCommMonoid \u03b1] [StarAddMonoid \u03b1]\n    (s : Multiset (Matrix m n \u03b1)) : s.sum\u1d34 = (s.map conjTranspose).sum", "start": [2310, 1], "end": [2312, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_sum", "code": "theorem conjTranspose_sum [AddCommMonoid \u03b1] [StarAddMonoid \u03b1] {\u03b9 : Type*} (s : Finset \u03b9)\n    (M : \u03b9 \u2192 Matrix m n \u03b1) : (\u2211 i in s, M i)\u1d34 = \u2211 i in s, (M i)\u1d34", "start": [2315, 1], "end": [2317, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTransposeLinearEquiv", "code": "@[simps apply]\ndef conjTransposeLinearEquiv [CommSemiring R] [StarRing R] [AddCommMonoid \u03b1] [StarAddMonoid \u03b1]\n    [Module R \u03b1] [StarModule R \u03b1] : Matrix m n \u03b1 \u2243\u2097\u22c6[R] Matrix n m \u03b1 :=\n  { conjTransposeAddEquiv m n \u03b1 with map_smul' := conjTranspose_smul }", "start": [2322, 1], "end": [2326, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTransposeLinearEquiv_symm", "code": "@[simp]\ntheorem conjTransposeLinearEquiv_symm [CommSemiring R] [StarRing R] [AddCommMonoid \u03b1]\n    [StarAddMonoid \u03b1] [Module R \u03b1] [StarModule R \u03b1] :\n    (conjTransposeLinearEquiv m n R \u03b1).symm = conjTransposeLinearEquiv n m R \u03b1", "start": [2329, 1], "end": [2333, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTransposeRingEquiv", "code": "@[simps]\ndef conjTransposeRingEquiv [Semiring \u03b1] [StarRing \u03b1] [Fintype m] :\n    Matrix m m \u03b1 \u2243+* (Matrix m m \u03b1)\u1d50\u1d52\u1d56 :=\n  { (conjTransposeAddEquiv m m \u03b1).trans MulOpposite.opAddEquiv with\n    toFun := fun M => MulOpposite.op M\u1d34\n    invFun := fun M => M.unop\u1d34\n    map_mul' := fun M N =>\n      (congr_arg MulOpposite.op (conjTranspose_mul M N)).trans (MulOpposite.op_mul _ _) }", "start": [2340, 1], "end": [2348, 90], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_pow", "code": "@[simp]\ntheorem conjTranspose_pow [Semiring \u03b1] [StarRing \u03b1] [Fintype m] [DecidableEq m] (M : Matrix m m \u03b1)\n    (k : \u2115) : (M ^ k)\u1d34 = M\u1d34 ^ k", "start": [2353, 1], "end": [2356, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_list_prod", "code": "theorem conjTranspose_list_prod [Semiring \u03b1] [StarRing \u03b1] [Fintype m] [DecidableEq m]\n    (l : List (Matrix m m \u03b1)) : l.prod\u1d34 = (l.map conjTranspose).reverse.prod", "start": [2359, 1], "end": [2361, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_eq_conjTranspose", "code": "theorem star_eq_conjTranspose [Star \u03b1] (M : Matrix m m \u03b1) : star M = M\u1d34", "start": [2372, 1], "end": [2373, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_apply", "code": "@[simp]\ntheorem star_apply [Star \u03b1] (M : Matrix n n \u03b1) (i j) : (star M) i j = star (M j i)", "start": [2376, 1], "end": [2378, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.star_mul", "code": "theorem star_mul [Fintype n] [NonUnitalSemiring \u03b1] [StarRing \u03b1] (M N : Matrix n n \u03b1) :\n    star (M * N) = star N * star M", "start": [2396, 1], "end": [2399, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix", "code": "def submatrix (A : Matrix m n \u03b1) (r_reindex : l \u2192 m) (c_reindex : o \u2192 n) : Matrix l o \u03b1 :=\n  of fun i j => A (r_reindex i) (c_reindex j)", "start": [2404, 1], "end": [2409, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_apply", "code": "@[simp]\ntheorem submatrix_apply (A : Matrix m n \u03b1) (r_reindex : l \u2192 m) (c_reindex : o \u2192 n) (i j) :\n    A.submatrix r_reindex c_reindex i j = A (r_reindex i) (c_reindex j)", "start": [2412, 1], "end": [2415, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_id_id", "code": "@[simp]\ntheorem submatrix_id_id (A : Matrix m n \u03b1) : A.submatrix id id = A", "start": [2418, 1], "end": [2420, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_submatrix", "code": "@[simp]\ntheorem submatrix_submatrix {l\u2082 o\u2082 : Type*} (A : Matrix m n \u03b1) (r\u2081 : l \u2192 m) (c\u2081 : o \u2192 n)\n    (r\u2082 : l\u2082 \u2192 l) (c\u2082 : o\u2082 \u2192 o) :\n    (A.submatrix r\u2081 c\u2081).submatrix r\u2082 c\u2082 = A.submatrix (r\u2081 \u2218 r\u2082) (c\u2081 \u2218 c\u2082)", "start": [2423, 1], "end": [2427, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_submatrix", "code": "@[simp]\ntheorem transpose_submatrix (A : Matrix m n \u03b1) (r_reindex : l \u2192 m) (c_reindex : o \u2192 n) :\n    (A.submatrix r_reindex c_reindex)\u1d40 = A\u1d40.submatrix c_reindex r_reindex", "start": [2430, 1], "end": [2433, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_submatrix", "code": "@[simp]\ntheorem conjTranspose_submatrix [Star \u03b1] (A : Matrix m n \u03b1) (r_reindex : l \u2192 m)\n    (c_reindex : o \u2192 n) : (A.submatrix r_reindex c_reindex)\u1d34 = A\u1d34.submatrix c_reindex r_reindex", "start": [2436, 1], "end": [2439, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_add", "code": "theorem submatrix_add [Add \u03b1] (A B : Matrix m n \u03b1) :\n    ((A + B).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = A.submatrix + B.submatrix", "start": [2442, 1], "end": [2444, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_neg", "code": "theorem submatrix_neg [Neg \u03b1] (A : Matrix m n \u03b1) :\n    ((-A).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = -A.submatrix", "start": [2447, 1], "end": [2449, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_sub", "code": "theorem submatrix_sub [Sub \u03b1] (A B : Matrix m n \u03b1) :\n    ((A - B).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = A.submatrix - B.submatrix", "start": [2452, 1], "end": [2454, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_zero", "code": "@[simp]\ntheorem submatrix_zero [Zero \u03b1] :\n    ((0 : Matrix m n \u03b1).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = 0", "start": [2457, 1], "end": [2460, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_smul", "code": "theorem submatrix_smul {R : Type*} [SMul R \u03b1] (r : R) (A : Matrix m n \u03b1) :\n    ((r \u2022 A : Matrix m n \u03b1).submatrix : (l \u2192 m) \u2192 (o \u2192 n) \u2192 Matrix l o \u03b1) = r \u2022 A.submatrix", "start": [2463, 1], "end": [2465, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_map", "code": "theorem submatrix_map (f : \u03b1 \u2192 \u03b2) (e\u2081 : l \u2192 m) (e\u2082 : o \u2192 n) (A : Matrix m n \u03b1) :\n    (A.map f).submatrix e\u2081 e\u2082 = (A.submatrix e\u2081 e\u2082).map f", "start": [2468, 1], "end": [2470, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_diagonal", "code": "theorem submatrix_diagonal [Zero \u03b1] [DecidableEq m] [DecidableEq l] (d : m \u2192 \u03b1) (e : l \u2192 m)\n    (he : Function.Injective e) : (diagonal d).submatrix e e = diagonal (d \u2218 e)", "start": [2473, 1], "end": [2482, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_one", "code": "theorem submatrix_one [Zero \u03b1] [One \u03b1] [DecidableEq m] [DecidableEq l] (e : l \u2192 m)\n    (he : Function.Injective e) : (1 : Matrix m m \u03b1).submatrix e e = 1", "start": [2485, 1], "end": [2487, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_mul", "code": "theorem submatrix_mul [Fintype n] [Fintype o] [Mul \u03b1] [AddCommMonoid \u03b1] {p q : Type*}\n    (M : Matrix m n \u03b1) (N : Matrix n p \u03b1) (e\u2081 : l \u2192 m) (e\u2082 : o \u2192 n) (e\u2083 : q \u2192 p)\n    (he\u2082 : Function.Bijective e\u2082) :\n    (M * N).submatrix e\u2081 e\u2083 = M.submatrix e\u2081 e\u2082 * N.submatrix e\u2082 e\u2083", "start": [2490, 1], "end": [2494, 39], "kind": "commanddeclaration"}, {"full_name": "Matrix.diag_submatrix", "code": "theorem diag_submatrix (A : Matrix m m \u03b1) (e : l \u2192 m) : diag (A.submatrix e e) = A.diag \u2218 e", "start": [2497, 1], "end": [2498, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_diagonal_embedding", "code": "@[simp]\ntheorem submatrix_diagonal_embedding [Zero \u03b1] [DecidableEq m] [DecidableEq l] (d : m \u2192 \u03b1)\n    (e : l \u21aa m) : (diagonal d).submatrix e e = diagonal (d \u2218 e)", "start": [2505, 1], "end": [2508, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_diagonal_equiv", "code": "@[simp]\ntheorem submatrix_diagonal_equiv [Zero \u03b1] [DecidableEq m] [DecidableEq l] (d : m \u2192 \u03b1) (e : l \u2243 m) :\n    (diagonal d).submatrix e e = diagonal (d \u2218 e)", "start": [2511, 1], "end": [2514, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_one_embedding", "code": "@[simp]\ntheorem submatrix_one_embedding [Zero \u03b1] [One \u03b1] [DecidableEq m] [DecidableEq l] (e : l \u21aa m) :\n    (1 : Matrix m m \u03b1).submatrix e e = 1", "start": [2517, 1], "end": [2520, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_one_equiv", "code": "@[simp]\ntheorem submatrix_one_equiv [Zero \u03b1] [One \u03b1] [DecidableEq m] [DecidableEq l] (e : l \u2243 m) :\n    (1 : Matrix m m \u03b1).submatrix e e = 1", "start": [2523, 1], "end": [2526, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_mul_equiv", "code": "@[simp]\ntheorem submatrix_mul_equiv [Fintype n] [Fintype o] [AddCommMonoid \u03b1] [Mul \u03b1] {p q : Type*}\n    (M : Matrix m n \u03b1) (N : Matrix n p \u03b1) (e\u2081 : l \u2192 m) (e\u2082 : o \u2243 n) (e\u2083 : q \u2192 p) :\n    M.submatrix e\u2081 e\u2082 * N.submatrix e\u2082 e\u2083 = (M * N).submatrix e\u2081 e\u2083", "start": [2529, 1], "end": [2533, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_mulVec_equiv", "code": "theorem submatrix_mulVec_equiv [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring \u03b1]\n    (M : Matrix m n \u03b1) (v : o \u2192 \u03b1) (e\u2081 : l \u2192 m) (e\u2082 : o \u2243 n) :\n    (M.submatrix e\u2081 e\u2082).mulVec v = M.mulVec (v \u2218 e\u2082.symm) \u2218 e\u2081", "start": [2536, 1], "end": [2539, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_vecMul_equiv", "code": "theorem submatrix_vecMul_equiv [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring \u03b1]\n    (M : Matrix m n \u03b1) (v : l \u2192 \u03b1) (e\u2081 : l \u2243 m) (e\u2082 : o \u2192 n) :\n    vecMul v (M.submatrix e\u2081 e\u2082) = vecMul (v \u2218 e\u2081.symm) M \u2218 e\u2082", "start": [2542, 1], "end": [2545, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_submatrix_one", "code": "theorem mul_submatrix_one [Fintype n] [Finite o] [NonAssocSemiring \u03b1] [DecidableEq o] (e\u2081 : n \u2243 o)\n    (e\u2082 : l \u2192 o) (M : Matrix m n \u03b1) :\n    M * (1 : Matrix o o \u03b1).submatrix e\u2081 e\u2082 = submatrix M id (e\u2081.symm \u2218 e\u2082)", "start": [2548, 1], "end": [2557, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_submatrix_mul", "code": "theorem one_submatrix_mul [Fintype m] [Finite o] [NonAssocSemiring \u03b1] [DecidableEq o] (e\u2081 : l \u2192 o)\n    (e\u2082 : m \u2243 o) (M : Matrix m n \u03b1) :\n    ((1 : Matrix o o \u03b1).submatrix e\u2081 e\u2082) * M = submatrix M (e\u2082.symm \u2218 e\u2081) id", "start": [2560, 1], "end": [2569, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex", "code": "def reindex (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) : Matrix m n \u03b1 \u2243 Matrix l o \u03b1 where\n  toFun M := M.submatrix e\u2098.symm e\u2099.symm\n  invFun M := M.submatrix e\u2098 e\u2099\n  left_inv M := by simp\n  right_inv M := by simp", "start": [2572, 1], "end": [2578, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_apply", "code": "@[simp]\ntheorem reindex_apply (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (M : Matrix m n \u03b1) :\n    reindex e\u2098 e\u2099 M = M.submatrix e\u2098.symm e\u2099.symm", "start": [2581, 1], "end": [2584, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_refl_refl", "code": "theorem reindex_refl_refl (A : Matrix m n \u03b1) : reindex (Equiv.refl _) (Equiv.refl _) A = A", "start": [2588, 1], "end": [2589, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_symm", "code": "@[simp]\ntheorem reindex_symm (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) :\n    (reindex e\u2098 e\u2099).symm = (reindex e\u2098.symm e\u2099.symm : Matrix l o \u03b1 \u2243 _)", "start": [2592, 1], "end": [2595, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_trans", "code": "@[simp]\ntheorem reindex_trans {l\u2082 o\u2082 : Type*} (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (e\u2098\u2082 : l \u2243 l\u2082) (e\u2099\u2082 : o \u2243 o\u2082) :\n    (reindex e\u2098 e\u2099).trans (reindex e\u2098\u2082 e\u2099\u2082) =\n      (reindex (e\u2098.trans e\u2098\u2082) (e\u2099.trans e\u2099\u2082) : Matrix m n \u03b1 \u2243 _)", "start": [2598, 1], "end": [2602, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_reindex", "code": "theorem transpose_reindex (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (M : Matrix m n \u03b1) :\n    (reindex e\u2098 e\u2099 M)\u1d40 = reindex e\u2099 e\u2098 M\u1d40", "start": [2605, 1], "end": [2607, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_reindex", "code": "theorem conjTranspose_reindex [Star \u03b1] (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (M : Matrix m n \u03b1) :\n    (reindex e\u2098 e\u2099 M)\u1d34 = reindex e\u2099 e\u2098 M\u1d34", "start": [2610, 1], "end": [2612, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_mul_transpose_submatrix", "code": "theorem submatrix_mul_transpose_submatrix [Fintype m] [Fintype n] [AddCommMonoid \u03b1] [Mul \u03b1]\n    (e : m \u2243 n) (M : Matrix m n \u03b1) : M.submatrix id e * M\u1d40.submatrix e id = M * M\u1d40", "start": [2616, 1], "end": [2618, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.subLeft", "code": "@[reducible]\ndef subLeft {m l r : Nat} (A : Matrix (Fin m) (Fin (l + r)) \u03b1) : Matrix (Fin m) (Fin l) \u03b1 :=\n  submatrix A id (Fin.castAdd r)", "start": [2621, 1], "end": [2624, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.subRight", "code": "@[reducible]\ndef subRight {m l r : Nat} (A : Matrix (Fin m) (Fin (l + r)) \u03b1) : Matrix (Fin m) (Fin r) \u03b1 :=\n  submatrix A id (Fin.natAdd l)", "start": [2627, 1], "end": [2630, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.subUp", "code": "@[reducible]\ndef subUp {d u n : Nat} (A : Matrix (Fin (u + d)) (Fin n) \u03b1) : Matrix (Fin u) (Fin n) \u03b1 :=\n  submatrix A (Fin.castAdd d) id", "start": [2633, 1], "end": [2636, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.subDown", "code": "@[reducible]\ndef subDown {d u n : Nat} (A : Matrix (Fin (u + d)) (Fin n) \u03b1) : Matrix (Fin d) (Fin n) \u03b1 :=\n  submatrix A (Fin.natAdd u) id", "start": [2639, 1], "end": [2642, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.subUpRight", "code": "@[reducible]\ndef subUpRight {d u l r : Nat} (A : Matrix (Fin (u + d)) (Fin (l + r)) \u03b1) :\n    Matrix (Fin u) (Fin r) \u03b1 :=\n  subUp (subRight A)", "start": [2645, 1], "end": [2649, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.subDownRight", "code": "@[reducible]\ndef subDownRight {d u l r : Nat} (A : Matrix (Fin (u + d)) (Fin (l + r)) \u03b1) :\n    Matrix (Fin d) (Fin r) \u03b1 :=\n  subDown (subRight A)", "start": [2652, 1], "end": [2656, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.subUpLeft", "code": "@[reducible]\ndef subUpLeft {d u l r : Nat} (A : Matrix (Fin (u + d)) (Fin (l + r)) \u03b1) :\n    Matrix (Fin u) (Fin l) \u03b1 :=\n  subUp (subLeft A)", "start": [2659, 1], "end": [2663, 20], "kind": "commanddeclaration"}, {"full_name": "Matrix.subDownLeft", "code": "@[reducible]\ndef subDownLeft {d u l r : Nat} (A : Matrix (Fin (u + d)) (Fin (l + r)) \u03b1) :\n    Matrix (Fin d) (Fin l) \u03b1 :=\n  subDown (subLeft A)", "start": [2666, 1], "end": [2670, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_injective", "code": "theorem col_injective : Function.Injective (col : (m \u2192 \u03b1) \u2192 _)", "start": [2684, 1], "end": [2685, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_inj", "code": "@[simp] theorem col_inj {v w : m \u2192 \u03b1} : col v = col w \u2194 v = w", "start": [2687, 1], "end": [2687, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_zero", "code": "@[simp] theorem col_zero [Zero \u03b1] : col (0 : m \u2192 \u03b1) = 0", "start": [2689, 1], "end": [2689, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_eq_zero", "code": "@[simp] theorem col_eq_zero [Zero \u03b1] (v : m \u2192 \u03b1) : col v = 0 \u2194 v = 0", "start": [2691, 1], "end": [2691, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_add", "code": "@[simp]\ntheorem col_add [Add \u03b1] (v w : m \u2192 \u03b1) : col (v + w) = col v + col w", "start": [2693, 1], "end": [2696, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_smul", "code": "@[simp]\ntheorem col_smul [SMul R \u03b1] (x : R) (v : m \u2192 \u03b1) : col (x \u2022 v) = x \u2022 col v", "start": [2699, 1], "end": [2702, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_injective", "code": "theorem row_injective : Function.Injective (row : (n \u2192 \u03b1) \u2192 _)", "start": [2705, 1], "end": [2706, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_inj", "code": "@[simp] theorem row_inj {v w : n \u2192 \u03b1} : row v = row w \u2194 v = w", "start": [2708, 1], "end": [2708, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_zero", "code": "@[simp] theorem row_zero [Zero \u03b1] : row (0 : n \u2192 \u03b1) = 0", "start": [2710, 1], "end": [2710, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_eq_zero", "code": "@[simp] theorem row_eq_zero [Zero \u03b1] (v : n \u2192 \u03b1) : row v = 0 \u2194 v = 0", "start": [2712, 1], "end": [2712, 80], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_add", "code": "@[simp]\ntheorem row_add [Add \u03b1] (v w : m \u2192 \u03b1) : row (v + w) = row v + row w", "start": [2714, 1], "end": [2717, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_smul", "code": "@[simp]\ntheorem row_smul [SMul R \u03b1] (x : R) (v : m \u2192 \u03b1) : row (x \u2022 v) = x \u2022 row v", "start": [2720, 1], "end": [2723, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_col", "code": "@[simp]\ntheorem transpose_col (v : m \u2192 \u03b1) : (Matrix.col v)\u1d40 = Matrix.row v", "start": [2726, 1], "end": [2729, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_row", "code": "@[simp]\ntheorem transpose_row (v : m \u2192 \u03b1) : (Matrix.row v)\u1d40 = Matrix.col v", "start": [2732, 1], "end": [2735, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_col", "code": "@[simp]\ntheorem conjTranspose_col [Star \u03b1] (v : m \u2192 \u03b1) : (col v)\u1d34 = row (star v)", "start": [2738, 1], "end": [2741, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.conjTranspose_row", "code": "@[simp]\ntheorem conjTranspose_row [Star \u03b1] (v : m \u2192 \u03b1) : (row v)\u1d34 = col (star v)", "start": [2744, 1], "end": [2747, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_vecMul", "code": "theorem row_vecMul [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (M : Matrix m n \u03b1) (v : m \u2192 \u03b1) :\n    Matrix.row (Matrix.vecMul v M) = Matrix.row v * M", "start": [2750, 1], "end": [2753, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_vecMul", "code": "theorem col_vecMul [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (M : Matrix m n \u03b1) (v : m \u2192 \u03b1) :\n    Matrix.col (Matrix.vecMul v M) = (Matrix.row v * M)\u1d40", "start": [2756, 1], "end": [2759, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_mulVec", "code": "theorem col_mulVec [Fintype n] [NonUnitalNonAssocSemiring \u03b1] (M : Matrix m n \u03b1) (v : n \u2192 \u03b1) :\n    Matrix.col (Matrix.mulVec M v) = M * Matrix.col v", "start": [2762, 1], "end": [2765, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_mulVec", "code": "theorem row_mulVec [Fintype n] [NonUnitalNonAssocSemiring \u03b1] (M : Matrix m n \u03b1) (v : n \u2192 \u03b1) :\n    Matrix.row (Matrix.mulVec M v) = (M * Matrix.col v)\u1d40", "start": [2768, 1], "end": [2771, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_mul_col_apply", "code": "@[simp]\ntheorem row_mul_col_apply [Fintype m] [Mul \u03b1] [AddCommMonoid \u03b1] (v w : m \u2192 \u03b1) (i j) :\n    (row v * col w) i j = v \u2b1d\u1d65 w", "start": [2774, 1], "end": [2777, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow", "code": "def updateRow [DecidableEq m] (M : Matrix m n \u03b1) (i : m) (b : n \u2192 \u03b1) : Matrix m n \u03b1 :=\n  of <| Function.update M i b", "start": [2784, 1], "end": [2786, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn", "code": "def updateColumn [DecidableEq n] (M : Matrix m n \u03b1) (j : n) (b : m \u2192 \u03b1) : Matrix m n \u03b1 :=\n  of fun i => Function.update (M i) j (b i)", "start": [2789, 1], "end": [2791, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_self", "code": "@[simp]\ntheorem updateRow_self [DecidableEq m] : updateRow M i b i = b", "start": [2796, 1], "end": [2799, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_self", "code": "@[simp]\ntheorem updateColumn_self [DecidableEq n] : updateColumn M j c i j = c i", "start": [2802, 1], "end": [2805, 55], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_ne", "code": "@[simp]\ntheorem updateRow_ne [DecidableEq m] {i' : m} (i_ne : i' \u2260 i) : updateRow M i b i' = M i'", "start": [2808, 1], "end": [2811, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_ne", "code": "@[simp]\ntheorem updateColumn_ne [DecidableEq n] {j' : n} (j_ne : j' \u2260 j) :\n    updateColumn M j c i j' = M i j'", "start": [2814, 1], "end": [2818, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_apply", "code": "theorem updateRow_apply [DecidableEq m] {i' : m} :\n    updateRow M i b i' j = if i' = i then b j else M i' j", "start": [2821, 1], "end": [2825, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_apply", "code": "theorem updateColumn_apply [DecidableEq n] {j' : n} :\n    updateColumn M j c i j' = if j' = j then c i else M i j'", "start": [2828, 1], "end": [2832, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_subsingleton", "code": "@[simp]\ntheorem updateColumn_subsingleton [Subsingleton n] (A : Matrix m n R) (i : n) (b : m \u2192 R) :\n    A.updateColumn i b = (col b).submatrix id (Function.const n ())", "start": [2835, 1], "end": [2839, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_subsingleton", "code": "@[simp]\ntheorem updateRow_subsingleton [Subsingleton m] (A : Matrix m n R) (i : m) (b : n \u2192 R) :\n    A.updateRow i b = (row b).submatrix (Function.const m ()) id", "start": [2842, 1], "end": [2846, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_updateRow", "code": "theorem map_updateRow [DecidableEq m] (f : \u03b1 \u2192 \u03b2) :\n    map (updateRow M i b) f = updateRow (M.map f) i (f \u2218 b)", "start": [2849, 1], "end": [2853, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.map_updateColumn", "code": "theorem map_updateColumn [DecidableEq n] (f : \u03b1 \u2192 \u03b2) :\n    map (updateColumn M j c) f = updateColumn (M.map f) j (f \u2218 c)", "start": [2856, 1], "end": [2860, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_transpose", "code": "theorem updateRow_transpose [DecidableEq n] : updateRow M\u1d40 j c = (updateColumn M j c)\u1d40", "start": [2863, 1], "end": [2866, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_transpose", "code": "theorem updateColumn_transpose [DecidableEq m] : updateColumn M\u1d40 i b = (updateRow M i b)\u1d40", "start": [2869, 1], "end": [2872, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_conjTranspose", "code": "theorem updateRow_conjTranspose [DecidableEq n] [Star \u03b1] :\n    updateRow M\u1d34 j (star c) = (updateColumn M j c)\u1d34", "start": [2875, 1], "end": [2879, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_conjTranspose", "code": "theorem updateColumn_conjTranspose [DecidableEq m] [Star \u03b1] :\n    updateColumn M\u1d34 i (star b) = (updateRow M i b)\u1d34", "start": [2882, 1], "end": [2886, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_eq_self", "code": "@[simp]\ntheorem updateRow_eq_self [DecidableEq m] (A : Matrix m n \u03b1) (i : m) : A.updateRow i (A i) = A", "start": [2889, 1], "end": [2891, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_eq_self", "code": "@[simp]\ntheorem updateColumn_eq_self [DecidableEq n] (A : Matrix m n \u03b1) (i : n) :\n    (A.updateColumn i fun j => A j i) = A", "start": [2894, 1], "end": [2897, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_updateColumn_single", "code": "theorem diagonal_updateColumn_single [DecidableEq n] [Zero \u03b1] (v : n \u2192 \u03b1) (i : n) (x : \u03b1) :\n    (diagonal v).updateColumn i (Pi.single i x) = diagonal (Function.update v i x)", "start": [2900, 1], "end": [2911, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.diagonal_updateRow_single", "code": "theorem diagonal_updateRow_single [DecidableEq n] [Zero \u03b1] (v : n \u2192 \u03b1) (i : n) (x : \u03b1) :\n    (diagonal v).updateRow i (Pi.single i x) = diagonal (Function.update v i x)", "start": [2914, 1], "end": [2916, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_submatrix_equiv", "code": "theorem updateRow_submatrix_equiv [DecidableEq l] [DecidableEq m] (A : Matrix m n \u03b1) (i : l)\n    (r : o \u2192 \u03b1) (e : l \u2243 m) (f : o \u2243 n) :\n    updateRow (A.submatrix e f) i r = (A.updateRow (e i) fun j => r (f.symm j)).submatrix e f", "start": [2922, 1], "end": [2926, 94], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_updateRow_equiv", "code": "theorem submatrix_updateRow_equiv [DecidableEq l] [DecidableEq m] (A : Matrix m n \u03b1) (i : m)\n    (r : n \u2192 \u03b1) (e : l \u2243 m) (f : o \u2243 n) :\n    (A.updateRow i r).submatrix e f = updateRow (A.submatrix e f) (e.symm i) fun i => r (f i)", "start": [2929, 1], "end": [2932, 92], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_submatrix_equiv", "code": "theorem updateColumn_submatrix_equiv [DecidableEq o] [DecidableEq n] (A : Matrix m n \u03b1) (j : o)\n    (c : l \u2192 \u03b1) (e : l \u2243 m) (f : o \u2243 n) : updateColumn (A.submatrix e f) j c =\n    (A.updateColumn (f j) fun i => c (e.symm i)).submatrix e f", "start": [2935, 1], "end": [2939, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_updateColumn_equiv", "code": "theorem submatrix_updateColumn_equiv [DecidableEq o] [DecidableEq n] (A : Matrix m n \u03b1) (j : n)\n    (c : m \u2192 \u03b1) (e : l \u2243 m) (f : o \u2243 n) : (A.updateColumn j c).submatrix e f =\n    updateColumn (A.submatrix e f) (f.symm j) fun i => c (e i)", "start": [2942, 1], "end": [2945, 95], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateRow_reindex", "code": "theorem updateRow_reindex [DecidableEq l] [DecidableEq m] (A : Matrix m n \u03b1) (i : l) (r : o \u2192 \u03b1)\n    (e : m \u2243 l) (f : n \u2243 o) :\n    updateRow (reindex e f A) i r = reindex e f (A.updateRow (e.symm i) fun j => r (f j))", "start": [2951, 1], "end": [2954, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_updateRow", "code": "theorem reindex_updateRow [DecidableEq l] [DecidableEq m] (A : Matrix m n \u03b1) (i : m) (r : n \u2192 \u03b1)\n    (e : m \u2243 l) (f : n \u2243 o) :\n    reindex e f (A.updateRow i r) = updateRow (reindex e f A) (e i) fun i => r (f.symm i)", "start": [2957, 1], "end": [2960, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.updateColumn_reindex", "code": "theorem updateColumn_reindex [DecidableEq o] [DecidableEq n] (A : Matrix m n \u03b1) (j : o) (c : l \u2192 \u03b1)\n    (e : m \u2243 l) (f : n \u2243 o) :\n    updateColumn (reindex e f A) j c = reindex e f (A.updateColumn (f.symm j) fun i => c (e i))", "start": [2963, 1], "end": [2966, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.reindex_updateColumn", "code": "theorem reindex_updateColumn [DecidableEq o] [DecidableEq n] (A : Matrix m n \u03b1) (j : n) (c : m \u2192 \u03b1)\n    (e : m \u2243 l) (f : n \u2243 o) :\n    reindex e f (A.updateColumn j c) = updateColumn (reindex e f A) (f j) fun i => c (e.symm i)", "start": [2969, 1], "end": [2972, 41], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_matrix_mul", "code": "theorem map_matrix_mul (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) (i : m) (j : o) (f : \u03b1 \u2192+* \u03b2) :\n    f ((M * N) i j) = (M.map f * N.map f) i j", "start": [2983, 1], "end": [2985, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_dotProduct", "code": "theorem map_dotProduct [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (v w : n \u2192 R) :\n    f (v \u2b1d\u1d65 w) = f \u2218 v \u2b1d\u1d65 f \u2218 w", "start": [2988, 1], "end": [2990, 69], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_vecMul", "code": "theorem map_vecMul [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (M : Matrix n m R)\n    (v : n \u2192 R) (i : m) : f (M.vecMul v i) = (M.map f).vecMul (f \u2218 v) i", "start": [2993, 1], "end": [2995, 85], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_mulVec", "code": "theorem map_mulVec [NonAssocSemiring R] [NonAssocSemiring S] (f : R \u2192+* S) (M : Matrix m n R)\n    (v : n \u2192 R) (i : m) : f (M.mulVec v i) = (M.map f).mulVec (f \u2218 v) i", "start": [2998, 1], "end": [3000, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/NonZeroDivisors.lean", "imports": ["Mathlib/GroupTheory/Submonoid/Operations.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nonZeroDivisors", "code": "def nonZeroDivisors (R : Type*) [MonoidWithZero R] : Submonoid R where\n  carrier := { x | \u2200 z, z * x = 0 \u2192 z = 0 }\n  one_mem' _ hz := by rwa [mul_one] at hz\n  mul_mem' hx\u2081 hx\u2082 _ hz := by\n    rw [\u2190 mul_assoc] at hz\n    exact hx\u2081 _ (hx\u2082 _ hz)", "start": [28, 1], "end": [34, 27], "kind": "commanddeclaration"}, {"full_name": "mem_nonZeroDivisors_iff", "code": "theorem mem_nonZeroDivisors_iff {r : M} : r \u2208 M\u2070 \u2194 \u2200 x, x * r = 0 \u2192 x = 0", "start": [45, 1], "end": [45, 85], "kind": "commanddeclaration"}, {"full_name": "mul_right_mem_nonZeroDivisors_eq_zero_iff", "code": "theorem mul_right_mem_nonZeroDivisors_eq_zero_iff {x r : M} (hr : r \u2208 M\u2070) : x * r = 0 \u2194 x = 0", "start": [48, 1], "end": [49, 53], "kind": "commanddeclaration"}, {"full_name": "mul_right_coe_nonZeroDivisors_eq_zero_iff", "code": "@[simp]\ntheorem mul_right_coe_nonZeroDivisors_eq_zero_iff {x : M} {c : M\u2070} : x * c = 0 \u2194 x = 0", "start": [51, 1], "end": [53, 51], "kind": "commanddeclaration"}, {"full_name": "mul_left_mem_nonZeroDivisors_eq_zero_iff", "code": "theorem mul_left_mem_nonZeroDivisors_eq_zero_iff {r x : M\u2081} (hr : r \u2208 M\u2081\u2070) : r * x = 0 \u2194 x = 0", "start": [56, 1], "end": [57, 62], "kind": "commanddeclaration"}, {"full_name": "mul_left_coe_nonZeroDivisors_eq_zero_iff", "code": "@[simp]\ntheorem mul_left_coe_nonZeroDivisors_eq_zero_iff {c : M\u2081\u2070} {x : M\u2081} : (c : M\u2081) * x = 0 \u2194 x = 0", "start": [60, 1], "end": [62, 50], "kind": "commanddeclaration"}, {"full_name": "mul_cancel_right_mem_nonZeroDivisors", "code": "theorem mul_cancel_right_mem_nonZeroDivisors {x y r : R} (hr : r \u2208 R\u2070) : x * r = y * r \u2194 x = y", "start": [65, 1], "end": [67, 91], "kind": "commanddeclaration"}, {"full_name": "mul_cancel_right_coe_nonZeroDivisors", "code": "theorem mul_cancel_right_coe_nonZeroDivisors {x y : R} {c : R\u2070} : x * c = y * c \u2194 x = y", "start": [70, 1], "end": [71, 46], "kind": "commanddeclaration"}, {"full_name": "mul_cancel_left_mem_nonZeroDivisors", "code": "@[simp]\ntheorem mul_cancel_left_mem_nonZeroDivisors {x y r : R'} (hr : r \u2208 R'\u2070) : r * x = r * y \u2194 x = y", "start": [74, 1], "end": [76, 67], "kind": "commanddeclaration"}, {"full_name": "mul_cancel_left_coe_nonZeroDivisors", "code": "theorem mul_cancel_left_coe_nonZeroDivisors {x y : R'} {c : R'\u2070} : (c : R') * x = c * y \u2194 x = y", "start": [79, 1], "end": [80, 45], "kind": "commanddeclaration"}, {"full_name": "nonZeroDivisors.ne_zero", "code": "theorem nonZeroDivisors.ne_zero [Nontrivial M] {x} (hx : x \u2208 M\u2070) : x \u2260 0", "start": [83, 1], "end": [84, 44], "kind": "commanddeclaration"}, {"full_name": "nonZeroDivisors.coe_ne_zero", "code": "theorem nonZeroDivisors.coe_ne_zero [Nontrivial M] (x : M\u2070) : (x : M) \u2260 0", "start": [87, 1], "end": [88, 30], "kind": "commanddeclaration"}, {"full_name": "mul_mem_nonZeroDivisors", "code": "theorem mul_mem_nonZeroDivisors {a b : M\u2081} : a * b \u2208 M\u2081\u2070 \u2194 a \u2208 M\u2081\u2070 \u2227 b \u2208 M\u2081\u2070", "start": [91, 1], "end": [100, 23], "kind": "commanddeclaration"}, {"full_name": "isUnit_of_mem_nonZeroDivisors", "code": "theorem isUnit_of_mem_nonZeroDivisors {G\u2080 : Type*} [GroupWithZero G\u2080] {x : G\u2080}\n    (hx : x \u2208 nonZeroDivisors G\u2080) : IsUnit x", "start": [103, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_ne_zero_of_mul_right_eq_zero", "code": "theorem eq_zero_of_ne_zero_of_mul_right_eq_zero [NoZeroDivisors M] {x y : M} (hnx : x \u2260 0)\n    (hxy : y * x = 0) : y = 0", "start": [109, 1], "end": [111, 63], "kind": "commanddeclaration"}, {"full_name": "eq_zero_of_ne_zero_of_mul_left_eq_zero", "code": "theorem eq_zero_of_ne_zero_of_mul_left_eq_zero [NoZeroDivisors M] {x y : M} (hnx : x \u2260 0)\n    (hxy : x * y = 0) : y = 0", "start": [114, 1], "end": [116, 62], "kind": "commanddeclaration"}, {"full_name": "mem_nonZeroDivisors_of_ne_zero", "code": "theorem mem_nonZeroDivisors_of_ne_zero [NoZeroDivisors M] {x : M} (hx : x \u2260 0) : x \u2208 M\u2070", "start": [119, 1], "end": [120, 45], "kind": "commanddeclaration"}, {"full_name": "mem_nonZeroDivisors_iff_ne_zero", "code": "theorem mem_nonZeroDivisors_iff_ne_zero [NoZeroDivisors M] [Nontrivial M] {x : M} :\n    x \u2208 M\u2070 \u2194 x \u2260 0", "start": [123, 1], "end": [124, 80], "kind": "commanddeclaration"}, {"full_name": "map_ne_zero_of_mem_nonZeroDivisors", "code": "theorem map_ne_zero_of_mem_nonZeroDivisors [Nontrivial M] [ZeroHomClass F M M'] (g : F)\n    (hg : Function.Injective (g : M \u2192 M')) {x : M} (h : x \u2208 M\u2070) : g x \u2260 0", "start": [127, 1], "end": [129, 73], "kind": "commanddeclaration"}, {"full_name": "map_mem_nonZeroDivisors", "code": "theorem map_mem_nonZeroDivisors [Nontrivial M] [NoZeroDivisors M'] [ZeroHomClass F M M'] (g : F)\n    (hg : Function.Injective g) {x : M} (h : x \u2208 M\u2070) : g x \u2208 M'\u2070", "start": [132, 1], "end": [134, 89], "kind": "commanddeclaration"}, {"full_name": "le_nonZeroDivisors_of_noZeroDivisors", "code": "theorem le_nonZeroDivisors_of_noZeroDivisors [NoZeroDivisors M] {S : Submonoid M}\n    (hS : (0 : M) \u2209 S) : S \u2264 M\u2070", "start": [137, 1], "end": [140, 37], "kind": "commanddeclaration"}, {"full_name": "powers_le_nonZeroDivisors_of_noZeroDivisors", "code": "theorem powers_le_nonZeroDivisors_of_noZeroDivisors [NoZeroDivisors M] {a : M} (ha : a \u2260 0) :\n    Submonoid.powers a \u2264 M\u2070", "start": [143, 1], "end": [145, 93], "kind": "commanddeclaration"}, {"full_name": "map_le_nonZeroDivisors_of_injective", "code": "theorem map_le_nonZeroDivisors_of_injective [NoZeroDivisors M'] [MonoidWithZeroHomClass F M M']\n    (f : F) (hf : Function.Injective f) {S : Submonoid M} (hS : S \u2264 M\u2070) : S.map f \u2264 M'\u2070", "start": [148, 1], "end": [154, 91], "kind": "commanddeclaration"}, {"full_name": "nonZeroDivisors_le_comap_nonZeroDivisors_of_injective", "code": "theorem nonZeroDivisors_le_comap_nonZeroDivisors_of_injective [NoZeroDivisors M']\n    [MonoidWithZeroHomClass F M M'] (f : F) (hf : Function.Injective f) : M\u2070 \u2264 M'\u2070.comap f", "start": [157, 1], "end": [159, 83], "kind": "commanddeclaration"}, {"full_name": "prod_zero_iff_exists_zero", "code": "theorem prod_zero_iff_exists_zero [NoZeroDivisors M\u2081] [Nontrivial M\u2081] {s : Multiset M\u2081} :\n    s.prod = 0 \u2194 \u2203 (r : M\u2081) (_ : r \u2208 s), r = 0", "start": [162, 1], "end": [177, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Operations.lean", "imports": ["Mathlib/Data/Finset/Pointwise.lean", "Mathlib/Data/Set/Semiring.lean", "Mathlib/GroupTheory/GroupAction/SubMulAction/Pointwise.lean", "Mathlib/Algebra/Module/Submodule/Pointwise.lean", "Mathlib/Algebra/Order/Kleene.lean", "Mathlib/Algebra/Module/Opposites.lean", "Mathlib/Algebra/Algebra/Opposite.lean", "Mathlib/Data/Set/Pointwise/BigOperators.lean", "Mathlib/Algebra/Algebra/Bilinear.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Module/Submodule/Bilinear.lean", "Mathlib/Algebra/Algebra/Equiv.lean"], "premises": [{"full_name": "SubMulAction.algebraMap_mem", "code": "theorem algebraMap_mem (r : R) : algebraMap R A r \u2208 (1 : SubMulAction R A)", "start": [58, 1], "end": [59, 39], "kind": "commanddeclaration"}, {"full_name": "SubMulAction.mem_one'", "code": "theorem mem_one' {x : A} : x \u2208 (1 : SubMulAction R A) \u2194 \u2203 y, algebraMap R A y = x", "start": [62, 1], "end": [63, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.one", "code": "instance one : One (Submodule R A) :=\n  \u27e8LinearMap.range (Algebra.linearMap R A)\u27e9", "start": [80, 1], "end": [83, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_eq_range", "code": "theorem one_eq_range : (1 : Submodule R A) = LinearMap.range (Algebra.linearMap R A)", "start": [86, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_one_toAddSubmonoid", "code": "theorem le_one_toAddSubmonoid : 1 \u2264 (1 : Submodule R A).toAddSubmonoid", "start": [90, 1], "end": [92, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.algebraMap_mem", "code": "theorem algebraMap_mem (r : R) : algebraMap R A r \u2208 (1 : Submodule R A)", "start": [95, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_one", "code": "@[simp]\ntheorem mem_one {x : A} : x \u2208 (1 : Submodule R A) \u2194 \u2203 y, algebraMap R A y = x", "start": [99, 1], "end": [101, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubMulAction_one", "code": "@[simp]\ntheorem toSubMulAction_one : (1 : Submodule R A).toSubMulAction = 1", "start": [104, 1], "end": [106, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_eq_span", "code": "theorem one_eq_span : (1 : Submodule R A) = R \u2219 1", "start": [109, 1], "end": [112, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_eq_span_one_set", "code": "theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1", "start": [115, 1], "end": [116, 14], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_le", "code": "theorem one_le : (1 : Submodule R A) \u2264 P \u2194 (1 : A) \u2208 P", "start": [119, 1], "end": [121, 78], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_one", "code": "protected theorem map_one {A'} [Semiring A'] [Algebra R A'] (f : A \u2192\u2090[R] A') :\n    map f.toLinearMap (1 : Submodule R A) = 1", "start": [124, 1], "end": [127, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_op_one", "code": "@[simp]\ntheorem map_op_one :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (1 : Submodule R A) = 1", "start": [130, 1], "end": [135, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_op_one", "code": "@[simp]\ntheorem comap_op_one :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (1 : Submodule R A\u1d50\u1d52\u1d56) = 1", "start": [138, 1], "end": [142, 7], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_unop_one", "code": "@[simp]\ntheorem map_unop_one :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (1 : Submodule R A\u1d50\u1d52\u1d56) = 1", "start": [145, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_unop_one", "code": "@[simp]\ntheorem comap_unop_one :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (1 : Submodule R A) = 1", "start": [151, 1], "end": [154, 45], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul", "code": "instance mul : Mul (Submodule R A) :=\n  \u27e8Submodule.map\u2082 <| LinearMap.mul R A\u27e9", "start": [157, 1], "end": [160, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_mem_mul", "code": "theorem mul_mem_mul (hm : m \u2208 M) (hn : n \u2208 N) : m * n \u2208 M * N", "start": [163, 1], "end": [164, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_le", "code": "theorem mul_le : M * N \u2264 P \u2194 \u2200 m \u2208 M, \u2200 n \u2208 N, m * n \u2208 P", "start": [167, 1], "end": [168, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_toAddSubmonoid", "code": "theorem mul_toAddSubmonoid (M N : Submodule R A) :\n    (M * N).toAddSubmonoid = M.toAddSubmonoid * N.toAddSubmonoid", "start": [171, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_induction_on", "code": "@[elab_as_elim]\nprotected theorem mul_induction_on {C : A \u2192 Prop} {r : A} (hr : r \u2208 M * N)\n    (hm : \u2200 m \u2208 M, \u2200 n \u2208 N, C (m * n)) (ha : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) : C r", "start": [178, 1], "end": [182, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_induction_on'", "code": "@[elab_as_elim]\nprotected theorem mul_induction_on' {C : \u2200 r, r \u2208 M * N \u2192 Prop}\n    (hm : \u2200 m (_ : m \u2208 M), \u2200 n (_ : n \u2208 N), C (m * n) (mul_mem_mul \u2039_\u203a \u2039_\u203a))\n    (ha : \u2200 x hx y hy, C x hx \u2192 C y hy \u2192 C (x + y) (add_mem \u2039_\u203a \u2039_\u203a)) {r : A} (hr : r \u2208 M * N) :\n    C r hr", "start": [185, 1], "end": [194, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_mul_span", "code": "theorem span_mul_span : span R S * span R T = span R (S * T)", "start": [199, 1], "end": [200, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_bot", "code": "@[simp]\ntheorem mul_bot : M * \u22a5 = \u22a5", "start": [207, 1], "end": [209, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.bot_mul", "code": "@[simp]\ntheorem bot_mul : \u22a5 * M = \u22a5", "start": [212, 1], "end": [214, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_mul", "code": "protected theorem one_mul : (1 : Submodule R A) * M = M", "start": [218, 1], "end": [220, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_one", "code": "protected theorem mul_one : M * 1 = M", "start": [224, 1], "end": [226, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_le_mul", "code": "@[mono]\ntheorem mul_le_mul (hmp : M \u2264 P) (hnq : N \u2264 Q) : M * N \u2264 P * Q", "start": [231, 1], "end": [233, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_le_mul_left", "code": "theorem mul_le_mul_left (h : M \u2264 N) : M * P \u2264 N * P", "start": [236, 1], "end": [237, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_le_mul_right", "code": "theorem mul_le_mul_right (h : N \u2264 P) : M * N \u2264 M * P", "start": [240, 1], "end": [241, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_sup", "code": "theorem mul_sup : M * (N \u2294 P) = M * N \u2294 M * P", "start": [246, 1], "end": [247, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_mul", "code": "theorem sup_mul : (M \u2294 N) * P = M * P \u2294 N * P", "start": [250, 1], "end": [251, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_subset_mul", "code": "theorem mul_subset_mul : (\u2191M : Set A) * (\u2191N : Set A) \u2286 (\u2191(M * N) : Set A)", "start": [254, 1], "end": [255, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_mul", "code": "protected theorem map_mul {A'} [Semiring A'] [Algebra R A'] (f : A \u2192\u2090[R] A') :\n    map f.toLinearMap (M * N) = map f.toLinearMap M * map f.toLinearMap N", "start": [258, 1], "end": [276, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_op_mul", "code": "theorem map_op_mul :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (M * N) =\n      map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) N *\n        map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) M", "start": [279, 1], "end": [291, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_unop_mul", "code": "theorem comap_unop_mul :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (M * N) =\n      comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) N *\n        comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) M", "start": [294, 1], "end": [298, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_unop_mul", "code": "theorem map_unop_mul (M N : Submodule R A\u1d50\u1d52\u1d56) :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (M * N) =\n      map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) N *\n        map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) M", "start": [301, 1], "end": [309, 89], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_op_mul", "code": "theorem comap_op_mul (M N : Submodule R A\u1d50\u1d52\u1d56) :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (M * N) =\n      comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) N *\n        comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) M", "start": [312, 1], "end": [316, 53], "kind": "commanddeclaration"}, {"full_name": "Submodule.hasDistribPointwiseNeg", "code": "protected def hasDistribPointwiseNeg {A} [Ring A] [Algebra R A] : HasDistribNeg (Submodule R A) :=\n  toAddSubmonoid_injective.hasDistribNeg _ neg_toAddSubmonoid mul_toAddSubmonoid", "start": [323, 1], "end": [327, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_mul_finite_of_mem_span_mul", "code": "theorem mem_span_mul_finite_of_mem_span_mul {R A} [Semiring R] [AddCommMonoid A] [Mul A]\n    [Module R A] {S : Set A} {S' : Set A} {x : A} (hx : x \u2208 span R (S * S')) :\n    \u2203 T T' : Finset A, \u2191T \u2286 S \u2227 \u2191T' \u2286 S' \u2227 x \u2208 span R (T * T' : Set A)", "start": [338, 1], "end": [346, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_eq_span_mul_set", "code": "theorem mul_eq_span_mul_set (s t : Submodule R A) : s * t = span R ((s : Set A) * (t : Set A))", "start": [351, 1], "end": [352, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_mul", "code": "theorem iSup_mul (s : \u03b9 \u2192 Submodule R A) (t : Submodule R A) : (\u2a06 i, s i) * t = \u2a06 i, s i * t", "start": [355, 1], "end": [356, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_iSup", "code": "theorem mul_iSup (t : Submodule R A) (s : \u03b9 \u2192 Submodule R A) : (t * \u2a06 i, s i) = \u2a06 i, t * s i", "start": [359, 1], "end": [360, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_mul_finite_of_mem_mul", "code": "theorem mem_span_mul_finite_of_mem_mul {P Q : Submodule R A} {x : A} (hx : x \u2208 P * Q) :\n    \u2203 T T' : Finset A, (T : Set A) \u2286 P \u2227 (T' : Set A) \u2286 Q \u2227 x \u2208 span R (T * T' : Set A)", "start": [363, 1], "end": [366, 91], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_span_singleton_mul", "code": "theorem mem_span_singleton_mul {x y : A} : x \u2208 span R {y} * P \u2194 \u2203 z \u2208 P, y * z = x", "start": [371, 1], "end": [374, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_mul_span_singleton", "code": "theorem mem_mul_span_singleton {x y : A} : x \u2208 P * span R {y} \u2194 \u2203 z \u2208 P, z * y = x", "start": [377, 1], "end": [380, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.idemSemiring", "code": "instance idemSemiring : IdemSemiring (Submodule R A) :=\n  { toAddSubmonoid_injective.semigroup _ fun m n : Submodule R A => mul_toAddSubmonoid m n,\n    AddMonoidWithOne.unary, Submodule.pointwiseAddCommMonoid,\n    (by infer_instance :\n      Lattice (Submodule R A)) with\n    one_mul := Submodule.one_mul\n    mul_one := Submodule.mul_one\n    zero_mul := bot_mul\n    mul_zero := mul_bot\n    left_distrib := mul_sup\n    right_distrib := sup_mul,\n    bot_le := fun _ => bot_le }", "start": [383, 1], "end": [396, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_pow", "code": "theorem span_pow (s : Set A) : \u2200 n : \u2115, span R s ^ n = span R (s ^ n)", "start": [400, 1], "end": [402, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_eq_span_pow_set", "code": "theorem pow_eq_span_pow_set (n : \u2115) : M ^ n = span R ((M : Set A) ^ n)", "start": [405, 1], "end": [406, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_subset_pow", "code": "theorem pow_subset_pow {n : \u2115} : (\u2191M : Set A) ^ n \u2286 \u2191(M ^ n : Submodule R A)", "start": [409, 1], "end": [410, 47], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_mem_pow", "code": "theorem pow_mem_pow {x : A} (hx : x \u2208 M) (n : \u2115) : x ^ n \u2208 M ^ n", "start": [413, 1], "end": [414, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_toAddSubmonoid", "code": "theorem pow_toAddSubmonoid {n : \u2115} (h : n \u2260 0) : (M ^ n).toAddSubmonoid = M.toAddSubmonoid ^ n", "start": [417, 1], "end": [423, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_pow_toAddSubmonoid", "code": "theorem le_pow_toAddSubmonoid {n : \u2115} : M.toAddSubmonoid ^ n \u2264 (M ^ n).toAddSubmonoid", "start": [426, 1], "end": [430, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_induction_on_left'", "code": "@[elab_as_elim]\nprotected theorem pow_induction_on_left' {C : \u2200 (n : \u2115) (x), x \u2208 M ^ n \u2192 Prop}\n    (hr : \u2200 r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (hadd : \u2200 x y i hx hy, C i x hx \u2192 C i y hy \u2192 C i (x + y) (add_mem \u2039_\u203a \u2039_\u203a))\n    (hmul : \u2200 m (hm : m \u2208 M), \u2200 (i x hx), C i x hx \u2192 C i.succ (m * x) (mul_mem_mul hm hx))\n    {n : \u2115} {x : A}\n    (hx : x \u2208 M ^ n) : C n x hx", "start": [433, 1], "end": [448, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_induction_on_right'", "code": "@[elab_as_elim]\nprotected theorem pow_induction_on_right' {C : \u2200 (n : \u2115) (x), x \u2208 M ^ n \u2192 Prop}\n    (hr : \u2200 r : R, C 0 (algebraMap _ _ r) (algebraMap_mem r))\n    (hadd : \u2200 x y i hx hy, C i x hx \u2192 C i y hy \u2192 C i (x + y) (add_mem \u2039_\u203a \u2039_\u203a))\n    (hmul :\n      \u2200 i x hx, C i x hx \u2192\n        \u2200 m (hm : m \u2208 M), C i.succ (x * m) ((pow_succ' M i).symm \u25b8 mul_mem_mul hx hm))\n    {n : \u2115} {x : A} (hx : x \u2208 M ^ n) : C n x hx", "start": [451, 1], "end": [473, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_induction_on_left", "code": "@[elab_as_elim]\nprotected theorem pow_induction_on_left {C : A \u2192 Prop} (hr : \u2200 r : R, C (algebraMap _ _ r))\n    (hadd : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) (hmul : \u2200 m \u2208 M, \u2200 (x), C x \u2192 C (m * x)) {x : A} {n : \u2115}\n    (hx : x \u2208 M ^ n) : C x", "start": [476, 1], "end": [485, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.pow_induction_on_right", "code": "@[elab_as_elim]\nprotected theorem pow_induction_on_right {C : A \u2192 Prop} (hr : \u2200 r : R, C (algebraMap _ _ r))\n    (hadd : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) (hmul : \u2200 x, C x \u2192 \u2200 m \u2208 M, C (x * m)) {x : A} {n : \u2115}\n    (hx : x \u2208 M ^ n) : C x", "start": [488, 1], "end": [496, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.mapHom", "code": "@[simps]\ndef mapHom {A'} [Semiring A'] [Algebra R A'] (f : A \u2192\u2090[R] A') : Submodule R A \u2192*\u2080 Submodule R A'\n    where\n  toFun := map f.toLinearMap\n  map_zero' := Submodule.map_bot _\n  map_one' := Submodule.map_one _\n  map_mul' _ _ := Submodule.map_mul _ _ _", "start": [499, 1], "end": [506, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.equivOpposite", "code": "@[simps apply symm_apply]\ndef equivOpposite : Submodule R A\u1d50\u1d52\u1d56 \u2243+* (Submodule R A)\u1d50\u1d52\u1d56 where\n  toFun p := op <| p.comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56)\n  invFun p := p.unop.comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A)\n  left_inv p := SetLike.coe_injective <| rfl\n  right_inv p := unop_injective <| SetLike.coe_injective rfl\n  map_add' p q := by simp [comap_equiv_eq_map_symm, \u2190 op_add]\n  map_mul' p q := congr_arg op <| comap_op_mul _ _", "start": [509, 1], "end": [518, 51], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_pow", "code": "protected theorem map_pow {A'} [Semiring A'] [Algebra R A'] (f : A \u2192\u2090[R] A') (n : \u2115) :\n    map f.toLinearMap (M ^ n) = map f.toLinearMap M ^ n", "start": [521, 1], "end": [523, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_unop_pow", "code": "theorem comap_unop_pow (n : \u2115) :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (M ^ n) =\n      comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) M ^ n", "start": [526, 1], "end": [529, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.comap_op_pow", "code": "theorem comap_op_pow (n : \u2115) (M : Submodule R A\u1d50\u1d52\u1d56) :\n    comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (M ^ n) =\n      comap (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) M ^ n", "start": [532, 1], "end": [535, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_op_pow", "code": "theorem map_op_pow (n : \u2115) :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) (M ^ n) =\n      map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56) : A \u2192\u2097[R] A\u1d50\u1d52\u1d56) M ^ n", "start": [538, 1], "end": [541, 75], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_unop_pow", "code": "theorem map_unop_pow (n : \u2115) (M : Submodule R A\u1d50\u1d52\u1d56) :\n    map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) (M ^ n) =\n      map (\u2191(opLinearEquiv R : A \u2243\u2097[R] A\u1d50\u1d52\u1d56).symm : A\u1d50\u1d52\u1d56 \u2192\u2097[R] A) M ^ n", "start": [544, 1], "end": [547, 77], "kind": "commanddeclaration"}, {"full_name": "Submodule.span.ringHom", "code": "@[simps]\ndef span.ringHom : SetSemiring A \u2192+* Submodule R A where\n  toFun s := Submodule.span R (SetSemiring.down s)\n  map_zero' := span_empty\n  map_one' := one_eq_span.symm\n  map_add' := span_union\n  map_mul' s t := by\n    dsimp only rw [SetSemiring.down_mul, span_mul_span, \u2190 image_mul_prod]", "start": [550, 1], "end": [560, 63], "kind": "commanddeclaration"}, {"full_name": "Submodule.pointwiseMulSemiringAction", "code": "protected def pointwiseMulSemiringAction : MulSemiringAction \u03b1 (Submodule R A) :=\n  {\n    Submodule.pointwiseDistribMulAction with\n    smul_mul := fun r x y => Submodule.map_mul x y <| MulSemiringAction.toAlgHom R A r\n    smul_one := fun r => Submodule.map_one <| MulSemiringAction.toAlgHom R A r }", "start": [567, 1], "end": [576, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_mem_mul_rev", "code": "theorem mul_mem_mul_rev (hm : m \u2208 M) (hn : n \u2208 N) : n * m \u2208 M * N", "start": [591, 1], "end": [592, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_comm", "code": "protected theorem mul_comm : M * N = N * M", "start": [597, 1], "end": [599, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_span", "code": "theorem prod_span {\u03b9 : Type*} (s : Finset \u03b9) (M : \u03b9 \u2192 Set A) :\n    (\u220f i in s, Submodule.span R (M i)) = Submodule.span R (\u220f i in s, M i)", "start": [606, 1], "end": [612, 71], "kind": "commanddeclaration"}, {"full_name": "Submodule.prod_span_singleton", "code": "theorem prod_span_singleton {\u03b9 : Type*} (s : Finset \u03b9) (x : \u03b9 \u2192 A) :\n    (\u220f i in s, span R ({x i} : Set A)) = span R {\u220f i in s, x i}", "start": [615, 1], "end": [617, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.moduleSet", "code": "instance moduleSet : Module (SetSemiring A) (Submodule R A) where\n  smul s P := span R (SetSemiring.down s) * P\n  smul_add _ _ _ := mul_add _ _ _\n  add_smul s t P := by\n    simp_rw [HSMul.hSMul, SetSemiring.down_add, span_union, sup_mul, add_eq_sup]\n  mul_smul s t P := by\n    simp_rw [HSMul.hSMul, SetSemiring.down_mul, \u2190 mul_assoc, span_mul_span]\n  one_smul P := by\n    simp_rw [HSMul.hSMul, SetSemiring.down_one, \u2190one_eq_span_one_set, one_mul]\n  zero_smul P := by\n    simp_rw [HSMul.hSMul, SetSemiring.down_zero, span_empty, bot_mul, bot_eq_zero]\n  smul_zero _ := mul_bot _", "start": [622, 1], "end": [635, 27], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_def", "code": "theorem smul_def (s : SetSemiring A) (P : Submodule R A) :\n    s \u2022 P = span R (SetSemiring.down s) * P", "start": [640, 1], "end": [642, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_le_smul", "code": "theorem smul_le_smul {s t : SetSemiring A} {M N : Submodule R A}\n    (h\u2081 : SetSemiring.down s \u2286 SetSemiring.down t)\n    (h\u2082 : M \u2264 N) : s \u2022 M \u2264 t \u2022 N", "start": [645, 1], "end": [648, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_singleton", "code": "theorem smul_singleton (a : A) (M : Submodule R A) :\n    Set.up ({a} : Set A) \u2022 M = M.map (LinearMap.mulLeft R a)", "start": [651, 1], "end": [662, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_div_iff_forall_mul_mem", "code": "theorem mem_div_iff_forall_mul_mem {x : A} {I J : Submodule R A} : x \u2208 I / J \u2194 \u2200 y \u2208 J, x * y \u2208 I", "start": [687, 1], "end": [688, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_div_iff_smul_subset", "code": "theorem mem_div_iff_smul_subset {x : A} {I J : Submodule R A} : x \u2208 I / J \u2194 x \u2022 (J : Set A) \u2286 I", "start": [691, 1], "end": [695, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_div_iff", "code": "theorem le_div_iff {I J K : Submodule R A} : I \u2264 J / K \u2194 \u2200 x \u2208 I, \u2200 z \u2208 K, x * z \u2208 J", "start": [698, 1], "end": [699, 13], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_div_iff_mul_le", "code": "theorem le_div_iff_mul_le {I J K : Submodule R A} : I \u2264 J / K \u2194 I * K \u2264 J", "start": [702, 1], "end": [703, 26], "kind": "commanddeclaration"}, {"full_name": "Submodule.one_le_one_div", "code": "@[simp]\ntheorem one_le_one_div {I : Submodule R A} : 1 \u2264 1 / I \u2194 I \u2264 1", "start": [706, 1], "end": [710, 37], "kind": "commanddeclaration"}, {"full_name": "Submodule.le_self_mul_one_div", "code": "theorem le_self_mul_one_div {I : Submodule R A} (hI : I \u2264 1) : I \u2264 I * (1 / I)", "start": [713, 1], "end": [715, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_one_div_le_one", "code": "theorem mul_one_div_le_one {I : Submodule R A} : I * (1 / I) \u2264 1", "start": [718, 1], "end": [723, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_div", "code": "@[simp]\nprotected theorem map_div {B : Type*} [CommSemiring B] [Algebra R B] (I J : Submodule R A)\n    (h : A \u2243\u2090[R] B) : (I / J).map h.toLinearMap = I.map h.toLinearMap / J.map h.toLinearMap", "start": [726, 1], "end": [739, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Basis/Bilinear.lean", "imports": ["Mathlib/LinearAlgebra/BilinearMap.lean", "Mathlib/LinearAlgebra/Basis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.ext_basis", "code": "theorem ext_basis {B B' : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} (h : \u2200 i j, B (b\u2081 i) (b\u2082 j) = B' (b\u2081 i) (b\u2082 j)) :\n    B = B'", "start": [42, 1], "end": [45, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sum_repr_mul_repr_mul\u209b\u2097", "code": "theorem sum_repr_mul_repr_mul\u209b\u2097 {B : M \u2192\u209b\u2097[\u03c1\u2081\u2082] N \u2192\u209b\u2097[\u03c3\u2081\u2082] P} (x y) :\n    ((b\u2081.repr x).sum fun i xi => (b\u2082.repr y).sum fun j yj => \u03c1\u2081\u2082 xi \u2022 \u03c3\u2081\u2082 yj \u2022 B (b\u2081 i) (b\u2082 j)) =\n      B x y", "start": [48, 1], "end": [56, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.sum_repr_mul_repr_mul", "code": "theorem sum_repr_mul_repr_mul {B : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097} (x y) :\n    ((b\u2081'.repr x).sum fun i xi => (b\u2082'.repr y).sum fun j yj => xi \u2022 yj \u2022 B (b\u2081' i) (b\u2082' j)) =\n      B x y", "start": [59, 1], "end": [67, 24], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Coprime/Lemmas.lean", "imports": ["Mathlib/Data/Int/GCD.lean", "Mathlib/RingTheory/Coprime/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Basic.lean", "Mathlib/Algebra/BigOperators/Ring.lean"], "premises": [{"full_name": "Int.isCoprime_iff_gcd_eq_one", "code": "theorem Int.isCoprime_iff_gcd_eq_one {m n : \u2124} : IsCoprime m n \u2194 Int.gcd m n = 1", "start": [33, 1], "end": [40, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.isCoprime_iff_coprime", "code": "theorem Nat.isCoprime_iff_coprime {m n : \u2115} : IsCoprime (m : \u2124) n \u2194 Nat.Coprime m n", "start": [42, 1], "end": [43, 53], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.nat_coprime", "code": "alias \u27e8IsCoprime.nat_coprime, Nat.Coprime.isCoprime\u27e9 := Nat.isCoprime_iff_coprime", "start": [46, 1], "end": [46, 82], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.Coprime.isCoprime", "code": "alias \u27e8IsCoprime.nat_coprime, Nat.Coprime.isCoprime\u27e9 := Nat.isCoprime_iff_coprime", "start": [46, 1], "end": [46, 82], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.Coprime.cast", "code": "theorem Nat.Coprime.cast {R : Type*} [CommRing R] {a b : \u2115} (h : Nat.Coprime a b) :\n    IsCoprime (a : R) (b : R)", "start": [50, 1], "end": [54, 28], "kind": "commanddeclaration"}, {"full_name": "ne_zero_or_ne_zero_of_nat_coprime", "code": "theorem ne_zero_or_ne_zero_of_nat_coprime {A : Type u} [CommRing A] [Nontrivial A] {a b : \u2115}\n    (h : Nat.Coprime a b) : (a : A) \u2260 0 \u2228 (b : A) \u2260 0", "start": [56, 1], "end": [59, 95], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.prod_left", "code": "theorem IsCoprime.prod_left : (\u2200 i \u2208 t, IsCoprime (s i) x) \u2192 IsCoprime (\u220f i in t, s i) x", "start": [61, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.prod_right", "code": "theorem IsCoprime.prod_right : (\u2200 i \u2208 t, IsCoprime x (s i)) \u2192 IsCoprime x (\u220f i in t, s i)", "start": [68, 1], "end": [69, 65], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.prod_left_iff", "code": "theorem IsCoprime.prod_left_iff : IsCoprime (\u220f i in t, s i) x \u2194 \u2200 i \u2208 t, IsCoprime (s i) x", "start": [72, 1], "end": [74, 86], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.prod_right_iff", "code": "theorem IsCoprime.prod_right_iff : IsCoprime x (\u220f i in t, s i) \u2194 \u2200 i \u2208 t, IsCoprime x (s i)", "start": [77, 1], "end": [78, 69], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_prod_left", "code": "theorem IsCoprime.of_prod_left (H1 : IsCoprime (\u220f i in t, s i) x) (i : I) (hit : i \u2208 t) :\n    IsCoprime (s i) x", "start": [81, 1], "end": [83, 37], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.of_prod_right", "code": "theorem IsCoprime.of_prod_right (H1 : IsCoprime x (\u220f i in t, s i)) (i : I) (hit : i \u2208 t) :\n    IsCoprime x (s i)", "start": [86, 1], "end": [88, 38], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_dvd_of_coprime", "code": "theorem Finset.prod_dvd_of_coprime :\n    \u2200 (_ : (t : Set I).Pairwise (IsCoprime on s)) (_ : \u2200 i \u2208 t, s i \u2223 z), (\u220f x in t, s x) \u2223 z", "start": [92, 1], "end": [105, 56], "kind": "commanddeclaration"}, {"full_name": "Fintype.prod_dvd_of_coprime", "code": "theorem Fintype.prod_dvd_of_coprime [Fintype I] (Hs : Pairwise (IsCoprime on s))\n    (Hs1 : \u2200 i, s i \u2223 z) : (\u220f x, s x) \u2223 z", "start": [108, 1], "end": [110, 65], "kind": "commanddeclaration"}, {"full_name": "exists_sum_eq_one_iff_pairwise_coprime", "code": "theorem exists_sum_eq_one_iff_pairwise_coprime [DecidableEq I] (h : t.Nonempty) :\n    (\u2203 \u03bc : I \u2192 R, (\u2211 i in t, \u03bc i * \u220f j in t \\ {i}, s j) = 1) \u2194\n      Pairwise (IsCoprime on fun i : t \u21a6 s i)", "start": [117, 1], "end": [175, 72], "kind": "commanddeclaration"}, {"full_name": "exists_sum_eq_one_iff_pairwise_coprime'", "code": "theorem exists_sum_eq_one_iff_pairwise_coprime' [Fintype I] [Nonempty I] [DecidableEq I] :\n    (\u2203 \u03bc : I \u2192 R, (\u2211 i : I, \u03bc i * \u220f j in {i}\u1d9c, s j) = 1) \u2194 Pairwise (IsCoprime on s)", "start": [178, 1], "end": [181, 97], "kind": "commanddeclaration"}, {"full_name": "pairwise_coprime_iff_coprime_prod", "code": "theorem pairwise_coprime_iff_coprime_prod [DecidableEq I] :\n    Pairwise (IsCoprime on fun i : t \u21a6 s i) \u2194 \u2200 i \u2208 t, IsCoprime (s i) (\u220f j in t \\ {i}, s j)", "start": [185, 1], "end": [194, 95], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow_left", "code": "theorem IsCoprime.pow_left (H : IsCoprime x y) : IsCoprime (x ^ m) y", "start": [199, 1], "end": [201, 40], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow_right", "code": "theorem IsCoprime.pow_right (H : IsCoprime x y) : IsCoprime x (y ^ n)", "start": [204, 1], "end": [206, 41], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow", "code": "theorem IsCoprime.pow (H : IsCoprime x y) : IsCoprime (x ^ m) (y ^ n)", "start": [209, 1], "end": [210, 23], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow_left_iff", "code": "theorem IsCoprime.pow_left_iff (hm : 0 < m) : IsCoprime (x ^ m) y \u2194 IsCoprime x y", "start": [213, 1], "end": [216, 51], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow_right_iff", "code": "theorem IsCoprime.pow_right_iff (hm : 0 < m) : IsCoprime x (y ^ m) \u2194 IsCoprime x y", "start": [221, 1], "end": [222, 78], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.pow_iff", "code": "theorem IsCoprime.pow_iff (hm : 0 < m) (hn : 0 < n) : IsCoprime (x ^ m) (y ^ n) \u2194 IsCoprime x y", "start": [225, 1], "end": [226, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/Basic.lean", "imports": ["Mathlib/Tactic/Abel.lean", "Mathlib/LinearAlgebra/Basic.lean", "Mathlib/Order/Atoms.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Associated.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "Ideal", "code": "@[reducible]\ndef Ideal (R : Type u) [Semiring R] :=\n  Submodule R R", "start": [40, 1], "end": [44, 16], "kind": "commanddeclaration"}, {"full_name": "Ideal.zero_mem", "code": "protected theorem zero_mem : (0 : \u03b1) \u2208 I", "start": [53, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.add_mem", "code": "protected theorem add_mem : a \u2208 I \u2192 b \u2208 I \u2192 a + b \u2208 I", "start": [57, 1], "end": [58, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mem_left", "code": "theorem mul_mem_left : b \u2208 I \u2192 a * b \u2208 I", "start": [63, 1], "end": [64, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.ext", "code": "@[ext]\ntheorem ext {I J : Ideal \u03b1} (h : \u2200 x, x \u2208 I \u2194 x \u2208 J) : I = J", "start": [69, 1], "end": [71, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.sum_mem", "code": "theorem sum_mem (I : Ideal \u03b1) {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 \u03b1} :\n    (\u2200 c \u2208 t, f c \u2208 I) \u2192 (\u2211 i in t, f i) \u2208 I", "start": [74, 1], "end": [76, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_top_of_unit_mem", "code": "theorem eq_top_of_unit_mem (x y : \u03b1) (hx : x \u2208 I) (h : y * x = 1) : I = \u22a4", "start": [79, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_top_of_isUnit_mem", "code": "theorem eq_top_of_isUnit_mem {x} (hx : x \u2208 I) (h : IsUnit x) : I = \u22a4", "start": [87, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_top_iff_one", "code": "theorem eq_top_iff_one : I = \u22a4 \u2194 (1 : \u03b1) \u2208 I", "start": [92, 1], "end": [93, 74], "kind": "commanddeclaration"}, {"full_name": "Ideal.ne_top_iff_one", "code": "theorem ne_top_iff_one : I \u2260 \u22a4 \u2194 (1 : \u03b1) \u2209 I", "start": [96, 1], "end": [97, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.unit_mul_mem_iff_mem", "code": "@[simp]\ntheorem unit_mul_mem_iff_mem {x y : \u03b1} (hy : IsUnit y) : y * x \u2208 I \u2194 x \u2208 I", "start": [100, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.span", "code": "def span (s : Set \u03b1) : Ideal \u03b1 :=\n  Submodule.span \u03b1 s", "start": [108, 1], "end": [110, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.submodule_span_eq", "code": "@[simp]\ntheorem submodule_span_eq {s : Set \u03b1} : Submodule.span \u03b1 s = Ideal.span s", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_empty", "code": "@[simp]\ntheorem span_empty : span (\u2205 : Set \u03b1) = \u22a5", "start": [118, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_univ", "code": "@[simp]\ntheorem span_univ : span (Set.univ : Set \u03b1) = \u22a4", "start": [123, 1], "end": [125, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_union", "code": "theorem span_union (s t : Set \u03b1) : span (s \u222a t) = span s \u2294 span t", "start": [128, 1], "end": [129, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_iUnion", "code": "theorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set \u03b1) : span (\u22c3 i, s i) = \u2a06 i, span (s i)", "start": [132, 1], "end": [133, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span", "code": "theorem mem_span {s : Set \u03b1} (x) : x \u2208 span s \u2194 \u2200 p : Ideal \u03b1, s \u2286 p \u2192 x \u2208 p", "start": [136, 1], "end": [137, 14], "kind": "commanddeclaration"}, {"full_name": "Ideal.subset_span", "code": "theorem subset_span {s : Set \u03b1} : s \u2286 span s", "start": [140, 1], "end": [141, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_le", "code": "theorem span_le {s : Set \u03b1} {I} : span s \u2264 I \u2194 s \u2286 I", "start": [144, 1], "end": [145, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_mono", "code": "theorem span_mono {s t : Set \u03b1} : s \u2286 t \u2192 span s \u2264 span t", "start": [148, 1], "end": [149, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_eq", "code": "@[simp]\ntheorem span_eq : span (I : Set \u03b1) = I", "start": [152, 1], "end": [154, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_one", "code": "@[simp]\ntheorem span_singleton_one : span ({1} : Set \u03b1) = \u22a4", "start": [157, 1], "end": [159, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCompactElement_top", "code": "theorem isCompactElement_top : CompleteLattice.IsCompactElement (\u22a4 : Ideal \u03b1)", "start": [162, 1], "end": [163, 86], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_insert", "code": "theorem mem_span_insert {s : Set \u03b1} {x y} :\n    x \u2208 span (insert y s) \u2194 \u2203 a, \u2203 z \u2208 span s, x = a * y + z", "start": [165, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_singleton'", "code": "theorem mem_span_singleton' {x y : \u03b1} : x \u2208 span ({y} : Set \u03b1) \u2194 \u2203 a, a * y = x", "start": [170, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_le_iff_mem", "code": "theorem span_singleton_le_iff_mem {x : \u03b1} : span {x} \u2264 I \u2194 x \u2208 I", "start": [174, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_left_unit", "code": "theorem span_singleton_mul_left_unit {a : \u03b1} (h2 : IsUnit a) (x : \u03b1) :\n    span ({a * x} : Set \u03b1) = span {x}", "start": [178, 1], "end": [181, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_insert", "code": "theorem span_insert (x) (s : Set \u03b1) : span (insert x s) = span ({x} : Set \u03b1) \u2294 span s", "start": [184, 1], "end": [185, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_eq_bot", "code": "theorem span_eq_bot {s : Set \u03b1} : span s = \u22a5 \u2194 \u2200 x \u2208 s, (x : \u03b1) = 0", "start": [188, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_eq_bot", "code": "@[simp]\ntheorem span_singleton_eq_bot {x} : span ({x} : Set \u03b1) = \u22a5 \u2194 x = 0", "start": [192, 1], "end": [194, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_ne_top", "code": "theorem span_singleton_ne_top {\u03b1 : Type*} [CommSemiring \u03b1] {x : \u03b1} (hx : \u00acIsUnit x) :\n    Ideal.span ({x} : Set \u03b1) \u2260 \u22a4", "start": [197, 1], "end": [201, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_zero", "code": "@[simp]\ntheorem span_zero : span (0 : Set \u03b1) = \u22a5", "start": [204, 1], "end": [205, 96], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_one", "code": "@[simp]\ntheorem span_one : span (1 : Set \u03b1) = \u22a4", "start": [208, 1], "end": [209, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_eq_top_iff_finite", "code": "theorem span_eq_top_iff_finite (s : Set \u03b1) :\n    span s = \u22a4 \u2194 \u2203 s' : Finset \u03b1, \u2191s' \u2286 s \u2227 span (s' : Set \u03b1) = \u22a4", "start": [212, 1], "end": [215, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_singleton_sup", "code": "theorem mem_span_singleton_sup {S : Type*} [CommSemiring S] {x y : S} {I : Ideal S} :\n    x \u2208 Ideal.span {y} \u2294 I \u2194 \u2203 a : S, \u2203 b \u2208 I, a * y + b = x", "start": [218, 1], "end": [226, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.ofRel", "code": "def ofRel (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Ideal \u03b1 :=\n  Submodule.span \u03b1 { x | \u2203 (a b : _) (_h : r a b), x + b = a }", "start": [229, 1], "end": [232, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime", "code": "class IsPrime (I : Ideal \u03b1) : Prop where\n  \n  ne_top' : I \u2260 \u22a4\n  \n  mem_or_mem' : \u2200 {x y : \u03b1}, x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [235, 1], "end": [240, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrime_iff", "code": "theorem isPrime_iff {I : Ideal \u03b1} : IsPrime I \u2194 I \u2260 \u22a4 \u2227 \u2200 {x y : \u03b1}, x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [243, 1], "end": [244, 45], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.ne_top", "code": "theorem IsPrime.ne_top {I : Ideal \u03b1} (hI : I.IsPrime) : I \u2260 \u22a4", "start": [247, 1], "end": [248, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.mem_or_mem", "code": "theorem IsPrime.mem_or_mem {I : Ideal \u03b1} (hI : I.IsPrime) {x y : \u03b1} : x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 I", "start": [251, 1], "end": [252, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.mem_or_mem_of_mul_eq_zero", "code": "theorem IsPrime.mem_or_mem_of_mul_eq_zero {I : Ideal \u03b1} (hI : I.IsPrime) {x y : \u03b1} (h : x * y = 0) :\n    x \u2208 I \u2228 y \u2208 I", "start": [255, 1], "end": [257, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.mem_of_pow_mem", "code": "theorem IsPrime.mem_of_pow_mem {I : Ideal \u03b1} (hI : I.IsPrime) {r : \u03b1} (n : \u2115) (H : r ^ n \u2208 I) :\n    r \u2208 I", "start": [260, 1], "end": [266, 45], "kind": "commanddeclaration"}, {"full_name": "Ideal.not_isPrime_iff", "code": "theorem not_isPrime_iff {I : Ideal \u03b1} :\n    \u00acI.IsPrime \u2194 I = \u22a4 \u2228 \u2203 (x : \u03b1) (_hx : x \u2209 I) (y : \u03b1) (_hy : y \u2209 I), x * y \u2208 I", "start": [269, 1], "end": [275, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.zero_ne_one_of_proper", "code": "theorem zero_ne_one_of_proper {I : Ideal \u03b1} (h : I \u2260 \u22a4) : (0 : \u03b1) \u2260 1", "start": [278, 1], "end": [279, 42], "kind": "commanddeclaration"}, {"full_name": "Ideal.bot_prime", "code": "theorem bot_prime {R : Type*} [Ring R] [IsDomain R] : (\u22a5 : Ideal R).IsPrime", "start": [282, 1], "end": [284, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal", "code": "class IsMaximal (I : Ideal \u03b1) : Prop where\n  \n  out : IsCoatom I", "start": [287, 1], "end": [291, 19], "kind": "commanddeclaration"}, {"full_name": "Ideal.isMaximal_def", "code": "theorem isMaximal_def {I : Ideal \u03b1} : I.IsMaximal \u2194 IsCoatom I", "start": [294, 1], "end": [295, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.ne_top", "code": "theorem IsMaximal.ne_top {I : Ideal \u03b1} (h : I.IsMaximal) : I \u2260 \u22a4", "start": [298, 1], "end": [299, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.isMaximal_iff", "code": "theorem isMaximal_iff {I : Ideal \u03b1} :\n    I.IsMaximal \u2194 (1 : \u03b1) \u2209 I \u2227 \u2200 (J : Ideal \u03b1) (x), I \u2264 J \u2192 x \u2209 I \u2192 x \u2208 J \u2192 (1 : \u03b1) \u2208 J", "start": [302, 1], "end": [312, 50], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.eq_of_le", "code": "theorem IsMaximal.eq_of_le {I J : Ideal \u03b1} (hI : I.IsMaximal) (hJ : J \u2260 \u22a4) (IJ : I \u2264 J) : I = J", "start": [315, 1], "end": [316, 52], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.coprime_of_ne", "code": "theorem IsMaximal.coprime_of_ne {M M' : Ideal \u03b1} (hM : M.IsMaximal) (hM' : M'.IsMaximal)\n    (hne : M \u2260 M') : M \u2294 M' = \u22a4", "start": [324, 1], "end": [327, 89], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_le_maximal", "code": "theorem exists_le_maximal (I : Ideal \u03b1) (hI : I \u2260 \u22a4) : \u2203 M : Ideal \u03b1, M.IsMaximal \u2227 I \u2264 M", "start": [330, 1], "end": [334, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_maximal", "code": "theorem exists_maximal [Nontrivial \u03b1] : \u2203 M : Ideal \u03b1, M.IsMaximal", "start": [339, 1], "end": [342, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.maximal_of_no_maximal", "code": "theorem maximal_of_no_maximal {R : Type u} [Semiring R] {P : Ideal R}\n    (hmax : \u2200 m : Ideal R, P < m \u2192 \u00acIsMaximal m) (J : Ideal R) (hPJ : P < J) : J = \u22a4", "start": [351, 1], "end": [357, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_pair_comm", "code": "theorem span_pair_comm {x y : \u03b1} : (span {x, y} : Ideal \u03b1) = span {y, x}", "start": [360, 1], "end": [361, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_pair", "code": "theorem mem_span_pair {x y z : \u03b1} : z \u2208 span ({x, y} : Set \u03b1) \u2194 \u2203 a b, a * x + b * y = z", "start": [364, 1], "end": [365, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_pair_add_mul_left", "code": "@[simp]\ntheorem span_pair_add_mul_left {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x + y * z, y} : Ideal R) = span {x, y}", "start": [368, 1], "end": [381, 16], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_pair_add_mul_right", "code": "@[simp]\ntheorem span_pair_add_mul_right {R : Type u} [CommRing R] {x y : R} (z : R) :\n    (span {x, y + x * z} : Ideal R) = span {x, y}", "start": [384, 1], "end": [387, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.exists_inv", "code": "theorem IsMaximal.exists_inv {I : Ideal \u03b1} (hI : I.IsMaximal) {x} (hx : x \u2209 I) :\n    \u2203 y, \u2203 i \u2208 I, y * x + i = 1", "start": [390, 1], "end": [398, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_sup_left", "code": "theorem mem_sup_left {S T : Ideal R} : \u2200 {x : R}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [406, 1], "end": [407, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_sup_right", "code": "theorem mem_sup_right {S T : Ideal R} : \u2200 {x : R}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [410, 1], "end": [411, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_iSup_of_mem", "code": "theorem mem_iSup_of_mem {\u03b9 : Sort*} {S : \u03b9 \u2192 Ideal R} (i : \u03b9) : \u2200 {x : R}, x \u2208 S i \u2192 x \u2208 iSup S", "start": [414, 1], "end": [415, 21], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_sSup_of_mem", "code": "theorem mem_sSup_of_mem {S : Set (Ideal R)} {s : Ideal R} (hs : s \u2208 S) :\n    \u2200 {x : R}, x \u2208 s \u2192 x \u2208 sSup S", "start": [418, 1], "end": [420, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_sInf", "code": "theorem mem_sInf {s : Set (Ideal R)} {x : R} : x \u2208 sInf s \u2194 \u2200 \u2983I\u2984, I \u2208 s \u2192 x \u2208 I", "start": [423, 1], "end": [424, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_inf", "code": "@[simp 1001] theorem mem_inf {I J : Ideal R} {x : R} : x \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J", "start": [427, 1], "end": [429, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_iInf", "code": "@[simp 1001] theorem mem_iInf {\u03b9 : Sort*} {I : \u03b9 \u2192 Ideal R} {x : R} : x \u2208 iInf I \u2194 \u2200 i, x \u2208 I i", "start": [432, 1], "end": [434, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_bot", "code": "@[simp 1001] theorem mem_bot {x : R} : x \u2208 (\u22a5 : Ideal R) \u2194 x = 0", "start": [437, 1], "end": [439, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.pi", "code": "def pi : Ideal (\u03b9 \u2192 \u03b1) where\n  carrier := { x | \u2200 i, x i \u2208 I }\n  zero_mem' _i := I.zero_mem\n  add_mem' ha hb i := I.add_mem (ha i) (hb i)\n  smul_mem' a _b hb i := I.mul_mem_left (a i) (hb i)", "start": [448, 1], "end": [453, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_pi", "code": "theorem mem_pi (x : \u03b9 \u2192 \u03b1) : x \u2208 I.pi \u03b9 \u2194 \u2200 i, x i \u2208 I", "start": [456, 1], "end": [457, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.sInf_isPrime_of_isChain", "code": "theorem sInf_isPrime_of_isChain {s : Set (Ideal \u03b1)} (hs : s.Nonempty) (hs' : IsChain (\u00b7 \u2264 \u00b7) s)\n    (H : \u2200 p \u2208 s, Ideal.IsPrime p) : (sInf s).IsPrime", "start": [462, 1], "end": [475, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_unit_mem_iff_mem", "code": "@[simp]\ntheorem mul_unit_mem_iff_mem {x y : \u03b1} (hy : IsUnit y) : x * y \u2208 I \u2194 x \u2208 I", "start": [492, 1], "end": [494, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_singleton", "code": "theorem mem_span_singleton {x y : \u03b1} : x \u2208 span ({y} : Set \u03b1) \u2194 y \u2223 x", "start": [497, 1], "end": [498, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_singleton_self", "code": "theorem mem_span_singleton_self (x : \u03b1) : x \u2208 span ({x} : Set \u03b1)", "start": [501, 1], "end": [502, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_le_span_singleton", "code": "theorem span_singleton_le_span_singleton {x y : \u03b1} :\n    span ({x} : Set \u03b1) \u2264 span ({y} : Set \u03b1) \u2194 y \u2223 x", "start": [505, 1], "end": [507, 65], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_eq_span_singleton", "code": "theorem span_singleton_eq_span_singleton {\u03b1 : Type u} [CommRing \u03b1] [IsDomain \u03b1] {x y : \u03b1} :\n    span ({x} : Set \u03b1) = span ({y} : Set \u03b1) \u2194 Associated x y", "start": [510, 1], "end": [513, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_right_unit", "code": "theorem span_singleton_mul_right_unit {a : \u03b1} (h2 : IsUnit a) (x : \u03b1) :\n    span ({x * a} : Set \u03b1) = span {x}", "start": [516, 1], "end": [517, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_eq_top", "code": "theorem span_singleton_eq_top {x} : span ({x} : Set \u03b1) = \u22a4 \u2194 IsUnit x", "start": [520, 1], "end": [521, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_prime", "code": "theorem span_singleton_prime {p : \u03b1} (hp : p \u2260 0) : IsPrime (span ({p} : Set \u03b1)) \u2194 Prime p", "start": [524, 1], "end": [525, 75], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.isPrime", "code": "theorem IsMaximal.isPrime {I : Ideal \u03b1} (H : I.IsMaximal) : I.IsPrime", "start": [528, 1], "end": [540, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsMaximal.isPrime'", "code": "instance (priority := 100) IsMaximal.isPrime' (I : Ideal \u03b1) : \u2200 [_H : I.IsMaximal], I.IsPrime :=\n  @IsMaximal.isPrime _ _ _", "start": [544, 1], "end": [545, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_lt_span_singleton", "code": "theorem span_singleton_lt_span_singleton [CommRing \u03b2] [IsDomain \u03b2] {x y : \u03b2} :\n    span ({x} : Set \u03b2) < span ({y} : Set \u03b2) \u2194 DvdNotUnit y x", "start": [548, 1], "end": [551, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.factors_decreasing", "code": "theorem factors_decreasing [CommRing \u03b2] [IsDomain \u03b2] (b\u2081 b\u2082 : \u03b2) (h\u2081 : b\u2081 \u2260 0) (h\u2082 : \u00acIsUnit b\u2082) :\n    span ({b\u2081 * b\u2082} : Set \u03b2) < span {b\u2081}", "start": [554, 1], "end": [559, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mem_right", "code": "theorem mul_mem_right (h : a \u2208 I) : a * b \u2208 I", "start": [564, 1], "end": [565, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_mem_of_mem", "code": "theorem pow_mem_of_mem (ha : a \u2208 I) (n : \u2115) (hn : 0 < n) : a ^ n \u2208 I", "start": [570, 1], "end": [572, 71], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.mul_mem_iff_mem_or_mem", "code": "theorem IsPrime.mul_mem_iff_mem_or_mem {I : Ideal \u03b1} (hI : I.IsPrime) :\n    \u2200 {x y : \u03b1}, x * y \u2208 I \u2194 x \u2208 I \u2228 y \u2208 I", "start": [575, 1], "end": [579, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.pow_mem_iff_mem", "code": "theorem IsPrime.pow_mem_iff_mem {I : Ideal \u03b1} (hI : I.IsPrime) {r : \u03b1} (n : \u2115) (hn : 0 < n) :\n    r ^ n \u2208 I \u2194 r \u2208 I", "start": [582, 1], "end": [584, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_multiset_sum_mem_span_pow", "code": "theorem pow_multiset_sum_mem_span_pow [DecidableEq \u03b1] (s : Multiset \u03b1) (n : \u2115) :\n    s.sum ^ (Multiset.card s * n + 1) \u2208\n    span ((s.map fun (x:\u03b1) \u21a6 x ^ (n + 1)).toFinset : Set \u03b1)", "start": [587, 1], "end": [611, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.sum_pow_mem_span_pow", "code": "theorem sum_pow_mem_span_pow {\u03b9} (s : Finset \u03b9) (f : \u03b9 \u2192 \u03b1) (n : \u2115) :\n    (\u2211 i in s, f i) ^ (s.card * n + 1) \u2208 span ((fun i => f i ^ (n + 1)) '' s)", "start": [614, 1], "end": [618, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_pow_eq_top", "code": "theorem span_pow_eq_top (s : Set \u03b1) (hs : span s = \u22a4) (n : \u2115) :\n    span ((fun (x : \u03b1) => x ^ n) '' s) = \u22a4", "start": [621, 1], "end": [643, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.neg_mem_iff", "code": "protected theorem neg_mem_iff : -a \u2208 I \u2194 a \u2208 I", "start": [656, 1], "end": [657, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.add_mem_iff_left", "code": "protected theorem add_mem_iff_left : b \u2208 I \u2192 (a + b \u2208 I \u2194 a \u2208 I)", "start": [660, 1], "end": [661, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.add_mem_iff_right", "code": "protected theorem add_mem_iff_right : a \u2208 I \u2192 (a + b \u2208 I \u2194 b \u2208 I)", "start": [664, 1], "end": [665, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.sub_mem", "code": "protected theorem sub_mem : a \u2208 I \u2192 b \u2208 I \u2192 a - b \u2208 I", "start": [668, 1], "end": [669, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_insert'", "code": "theorem mem_span_insert' {s : Set \u03b1} {x y} : x \u2208 span (insert y s) \u2194 \u2203 a, x + a * y \u2208 span s", "start": [672, 1], "end": [673, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_neg", "code": "@[simp]\ntheorem span_singleton_neg (x : \u03b1) : (span {-x} : Ideal \u03b1) = span {x}", "start": [676, 1], "end": [680, 92], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_bot_or_top", "code": "theorem eq_bot_or_top : I = \u22a5 \u2228 I = \u22a4", "start": [693, 1], "end": [702, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.isSimpleOrder", "code": "instance isSimpleOrder : IsSimpleOrder (Ideal K) :=\n  \u27e8eq_bot_or_top\u27e9", "start": [705, 1], "end": [708, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_bot_of_prime", "code": "theorem eq_bot_of_prime [h : I.IsPrime] : I = \u22a5", "start": [711, 1], "end": [712, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.bot_isMaximal", "code": "theorem bot_isMaximal : IsMaximal (\u22a5 : Ideal K)", "start": [715, 1], "end": [717, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_sub_mul_mem", "code": "theorem mul_sub_mul_mem {R : Type*} [CommRing R] (I : Ideal R) {a b c d : R} (h1 : a - b \u2208 I)\n    (h2 : c - d \u2208 I) : a * c - b * d \u2208 I", "start": [728, 1], "end": [731, 63], "kind": "commanddeclaration"}, {"full_name": "Ring.exists_not_isUnit_of_not_isField", "code": "theorem exists_not_isUnit_of_not_isField [Nontrivial R] (hf : \u00acIsField R) :\n    \u2203 (x : R) (_hx : x \u2260 (0 : R)), \u00acIsUnit x", "start": [744, 1], "end": [750, 26], "kind": "commanddeclaration"}, {"full_name": "Ring.not_isField_iff_exists_ideal_bot_lt_and_lt_top", "code": "theorem not_isField_iff_exists_ideal_bot_lt_and_lt_top [Nontrivial R] :\n    \u00acIsField R \u2194 \u2203 I : Ideal R, \u22a5 < I \u2227 I < \u22a4", "start": [753, 1], "end": [766, 41], "kind": "commanddeclaration"}, {"full_name": "Ring.not_isField_iff_exists_prime", "code": "theorem not_isField_iff_exists_prime [Nontrivial R] :\n    \u00acIsField R \u2194 \u2203 p : Ideal R, p \u2260 \u22a5 \u2227 p.IsPrime", "start": [769, 1], "end": [775, 98], "kind": "commanddeclaration"}, {"full_name": "Ring.isField_iff_isSimpleOrder_ideal", "code": "theorem isField_iff_isSimpleOrder_ideal : IsField R \u2194 IsSimpleOrder (Ideal R)", "start": [778, 1], "end": [790, 37], "kind": "commanddeclaration"}, {"full_name": "Ring.ne_bot_of_isMaximal_of_not_isField", "code": "theorem ne_bot_of_isMaximal_of_not_isField [Nontrivial R] {M : Ideal R} (max : M.IsMaximal)\n    (not_field : \u00acIsField R) : M \u2260 \u22a5", "start": [793, 1], "end": [800, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.bot_lt_of_maximal", "code": "theorem bot_lt_of_maximal (M : Ideal R) [hm : M.IsMaximal] (non_field : \u00acIsField R) : \u22a5 < M", "start": [809, 1], "end": [816, 30], "kind": "commanddeclaration"}, {"full_name": "nonunits", "code": "def nonunits (\u03b1 : Type u) [Monoid \u03b1] : Set \u03b1 :=\n  { a | \u00acIsUnit a }", "start": [823, 1], "end": [825, 20], "kind": "commanddeclaration"}, {"full_name": "mem_nonunits_iff", "code": "@[simp]\ntheorem mem_nonunits_iff [Monoid \u03b1] : a \u2208 nonunits \u03b1 \u2194 \u00acIsUnit a", "start": [828, 1], "end": [830, 10], "kind": "commanddeclaration"}, {"full_name": "mul_mem_nonunits_right", "code": "theorem mul_mem_nonunits_right [CommMonoid \u03b1] : b \u2208 nonunits \u03b1 \u2192 a * b \u2208 nonunits \u03b1", "start": [833, 1], "end": [834, 32], "kind": "commanddeclaration"}, {"full_name": "mul_mem_nonunits_left", "code": "theorem mul_mem_nonunits_left [CommMonoid \u03b1] : a \u2208 nonunits \u03b1 \u2192 a * b \u2208 nonunits \u03b1", "start": [837, 1], "end": [838, 31], "kind": "commanddeclaration"}, {"full_name": "zero_mem_nonunits", "code": "theorem zero_mem_nonunits [Semiring \u03b1] : 0 \u2208 nonunits \u03b1 \u2194 (0 : \u03b1) \u2260 1", "start": [841, 1], "end": [842, 28], "kind": "commanddeclaration"}, {"full_name": "one_not_mem_nonunits", "code": "@[simp 1001] theorem one_not_mem_nonunits [Monoid \u03b1] : (1 : \u03b1) \u2209 nonunits \u03b1", "start": [845, 1], "end": [847, 27], "kind": "commanddeclaration"}, {"full_name": "coe_subset_nonunits", "code": "theorem coe_subset_nonunits [Semiring \u03b1] {I : Ideal \u03b1} (h : I \u2260 \u22a4) : (I : Set \u03b1) \u2286 nonunits \u03b1", "start": [850, 1], "end": [851, 52], "kind": "commanddeclaration"}, {"full_name": "exists_max_ideal_of_mem_nonunits", "code": "theorem exists_max_ideal_of_mem_nonunits [CommSemiring \u03b1] (h : a \u2208 nonunits \u03b1) :\n    \u2203 I : Ideal \u03b1, I.IsMaximal \u2227 a \u2208 I", "start": [854, 1], "end": [864, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Basic.lean", "imports": ["Mathlib/Tactic/Monotonicity.lean", "Mathlib/Topology/Compactness/Compact.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Filter/SmallSets.lean", "Mathlib/Topology/NhdsSet.lean"], "premises": [{"full_name": "idRel", "code": "def idRel {\u03b1 : Type*} :=\n  { p : \u03b1 \u00d7 \u03b1 | p.1 = p.2 }", "start": [131, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "mem_idRel", "code": "@[simp]\ntheorem mem_idRel {a b : \u03b1} : (a, b) \u2208 @idRel \u03b1 \u2194 a = b", "start": [136, 1], "end": [138, 10], "kind": "commanddeclaration"}, {"full_name": "idRel_subset", "code": "@[simp]\ntheorem idRel_subset {s : Set (\u03b1 \u00d7 \u03b1)} : idRel \u2286 s \u2194 \u2200 a, (a, a) \u2208 s", "start": [141, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "compRel", "code": "def compRel (r\u2081 r\u2082 : Set (\u03b1 \u00d7 \u03b1)) :=\n  { p : \u03b1 \u00d7 \u03b1 | \u2203 z : \u03b1, (p.1, z) \u2208 r\u2081 \u2227 (z, p.2) \u2208 r\u2082 }", "start": [146, 1], "end": [148, 57], "kind": "commanddeclaration"}, {"full_name": "mem_compRel", "code": "@[simp]\ntheorem mem_compRel {\u03b1 : Type u} {r\u2081 r\u2082 : Set (\u03b1 \u00d7 \u03b1)} {x y : \u03b1} :\n    (x, y) \u2208 r\u2081 \u25cb r\u2082 \u2194 \u2203 z, (x, z) \u2208 r\u2081 \u2227 (z, y) \u2208 r\u2082", "start": [155, 1], "end": [158, 10], "kind": "commanddeclaration"}, {"full_name": "swap_idRel", "code": "@[simp]\ntheorem swap_idRel : Prod.swap '' idRel = @idRel \u03b1", "start": [161, 1], "end": [163, 77], "kind": "commanddeclaration"}, {"full_name": "Monotone.compRel", "code": "theorem Monotone.compRel [Preorder \u03b2] {f g : \u03b2 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hf : Monotone f) (hg : Monotone g) :\n    Monotone fun x => f x \u25cb g x", "start": [166, 1], "end": [167, 84], "kind": "commanddeclaration"}, {"full_name": "compRel_mono", "code": "@[mono]\ntheorem compRel_mono {f g h k : Set (\u03b1 \u00d7 \u03b1)} (h\u2081 : f \u2286 h) (h\u2082 : g \u2286 k) : f \u25cb g \u2286 h \u25cb k", "start": [170, 1], "end": [172, 39], "kind": "commanddeclaration"}, {"full_name": "prod_mk_mem_compRel", "code": "theorem prod_mk_mem_compRel {a b c : \u03b1} {s t : Set (\u03b1 \u00d7 \u03b1)} (h\u2081 : (a, c) \u2208 s) (h\u2082 : (c, b) \u2208 t) :\n    (a, b) \u2208 s \u25cb t", "start": [175, 1], "end": [177, 14], "kind": "commanddeclaration"}, {"full_name": "id_compRel", "code": "@[simp]\ntheorem id_compRel {r : Set (\u03b1 \u00d7 \u03b1)} : idRel \u25cb r = r", "start": [180, 1], "end": [182, 32], "kind": "commanddeclaration"}, {"full_name": "compRel_assoc", "code": "theorem compRel_assoc {r s t : Set (\u03b1 \u00d7 \u03b1)} : r \u25cb s \u25cb t = r \u25cb (s \u25cb t)", "start": [185, 1], "end": [186, 45], "kind": "commanddeclaration"}, {"full_name": "left_subset_compRel", "code": "theorem left_subset_compRel {s t : Set (\u03b1 \u00d7 \u03b1)} (h : idRel \u2286 t) : s \u2286 s \u25cb t", "start": [189, 1], "end": [190, 23], "kind": "commanddeclaration"}, {"full_name": "right_subset_compRel", "code": "theorem right_subset_compRel {s t : Set (\u03b1 \u00d7 \u03b1)} (h : idRel \u2286 s) : t \u2286 s \u25cb t", "start": [193, 1], "end": [194, 23], "kind": "commanddeclaration"}, {"full_name": "subset_comp_self", "code": "theorem subset_comp_self {s : Set (\u03b1 \u00d7 \u03b1)} (h : idRel \u2286 s) : s \u2286 s \u25cb s", "start": [197, 1], "end": [198, 24], "kind": "commanddeclaration"}, {"full_name": "subset_iterate_compRel", "code": "theorem subset_iterate_compRel {s t : Set (\u03b1 \u00d7 \u03b1)} (h : idRel \u2286 s) (n : \u2115) :\n    t \u2286 (s \u25cb \u00b7)^[n] t", "start": [201, 1], "end": [204, 58], "kind": "commanddeclaration"}, {"full_name": "SymmetricRel", "code": "def SymmetricRel (V : Set (\u03b1 \u00d7 \u03b1)) : Prop :=\n  Prod.swap \u207b\u00b9' V = V", "start": [207, 1], "end": [209, 22], "kind": "commanddeclaration"}, {"full_name": "symmetrizeRel", "code": "def symmetrizeRel (V : Set (\u03b1 \u00d7 \u03b1)) : Set (\u03b1 \u00d7 \u03b1) :=\n  V \u2229 Prod.swap \u207b\u00b9' V", "start": [212, 1], "end": [214, 22], "kind": "commanddeclaration"}, {"full_name": "symmetric_symmetrizeRel", "code": "theorem symmetric_symmetrizeRel (V : Set (\u03b1 \u00d7 \u03b1)) : SymmetricRel (symmetrizeRel V)", "start": [217, 1], "end": [218, 82], "kind": "commanddeclaration"}, {"full_name": "symmetrizeRel_subset_self", "code": "theorem symmetrizeRel_subset_self (V : Set (\u03b1 \u00d7 \u03b1)) : symmetrizeRel V \u2286 V", "start": [221, 1], "end": [222, 17], "kind": "commanddeclaration"}, {"full_name": "symmetrize_mono", "code": "@[mono]\ntheorem symmetrize_mono {V W : Set (\u03b1 \u00d7 \u03b1)} (h : V \u2286 W) : symmetrizeRel V \u2286 symmetrizeRel W", "start": [225, 1], "end": [227, 42], "kind": "commanddeclaration"}, {"full_name": "SymmetricRel.mk_mem_comm", "code": "theorem SymmetricRel.mk_mem_comm {V : Set (\u03b1 \u00d7 \u03b1)} (hV : SymmetricRel V) {x y : \u03b1} :\n    (x, y) \u2208 V \u2194 (y, x) \u2208 V", "start": [230, 1], "end": [232, 26], "kind": "commanddeclaration"}, {"full_name": "SymmetricRel.eq", "code": "theorem SymmetricRel.eq {U : Set (\u03b1 \u00d7 \u03b1)} (hU : SymmetricRel U) : Prod.swap \u207b\u00b9' U = U", "start": [235, 1], "end": [236, 5], "kind": "commanddeclaration"}, {"full_name": "SymmetricRel.inter", "code": "theorem SymmetricRel.inter {U V : Set (\u03b1 \u00d7 \u03b1)} (hU : SymmetricRel U) (hV : SymmetricRel V) :\n    SymmetricRel (U \u2229 V)", "start": [239, 1], "end": [240, 79], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core", "code": "structure UniformSpace.Core (\u03b1 : Type u) where\n  \n  uniformity : Filter (\u03b1 \u00d7 \u03b1)\n  \n  refl : \ud835\udcdf idRel \u2264 uniformity\n  \n  symm : Tendsto Prod.swap uniformity uniformity\n  \n  comp : (uniformity.lift' fun s => s \u25cb s) \u2264 uniformity", "start": [243, 1], "end": [254, 56], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core.mk'", "code": "def UniformSpace.Core.mk' {\u03b1 : Type u} (U : Filter (\u03b1 \u00d7 \u03b1)) (refl : \u2200 r \u2208 U, \u2200 (x), (x, x) \u2208 r)\n    (symm : \u2200 r \u2208 U, Prod.swap \u207b\u00b9' r \u2208 U) (comp : \u2200 r \u2208 U, \u2203 t \u2208 U, t \u25cb t \u2286 r) :\n    UniformSpace.Core \u03b1 :=\n  \u27e8U, fun _r ru => idRel_subset.2 (refl _ ru), symm, fun _r ru =>\n    let \u27e8_s, hs, hsr\u27e9 := comp _ ru\n    mem_of_superset (mem_lift' hs) hsr\u27e9", "start": [257, 1], "end": [264, 40], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core.mkOfBasis", "code": "def UniformSpace.Core.mkOfBasis {\u03b1 : Type u} (B : FilterBasis (\u03b1 \u00d7 \u03b1))\n    (refl : \u2200 r \u2208 B, \u2200 (x), (x, x) \u2208 r) (symm : \u2200 r \u2208 B, \u2203 t \u2208 B, t \u2286 Prod.swap \u207b\u00b9' r)\n    (comp : \u2200 r \u2208 B, \u2203 t \u2208 B, t \u25cb t \u2286 r) : UniformSpace.Core \u03b1\n    where\n  uniformity := B.filter\n  refl := B.hasBasis.ge_iff.mpr fun _r ru => idRel_subset.2 <| refl _ ru\n  symm := (B.hasBasis.tendsto_iff B.hasBasis).mpr symm\n  comp := (HasBasis.le_basis_iff (B.hasBasis.lift' (monotone_id.compRel monotone_id))\n    B.hasBasis).2 comp", "start": [267, 1], "end": [276, 23], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core.toTopologicalSpace", "code": "def UniformSpace.Core.toTopologicalSpace {\u03b1 : Type u} (u : UniformSpace.Core \u03b1) :\n    TopologicalSpace \u03b1 where\n  IsOpen s := \u2200 x \u2208 s, { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 u.uniformity\n  isOpen_univ := by simp\n  isOpen_inter := fun s t hs ht x \u27e8xs, xt\u27e9 => by\n    filter_upwards [hs x xs, ht x xt] with x hxs hxt hx using \u27e8hxs hx, hxt hx\u27e9\n  isOpen_sUnion := fun s hs x \u27e8t, ts, xt\u27e9 => by\n    filter_upwards [hs t ts x xt] with p ph h using \u27e8t, ts, ph h\u27e9", "start": [280, 1], "end": [288, 66], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core.ext", "code": "theorem UniformSpace.Core.ext :\n    \u2200 {u\u2081 u\u2082 : UniformSpace.Core \u03b1}, u\u2081.uniformity = u\u2082.uniformity \u2192 u\u2081 = u\u2082", "start": [291, 1], "end": [293, 43], "kind": "commanddeclaration"}, {"full_name": "UniformSpace", "code": "class UniformSpace (\u03b1 : Type u) extends TopologicalSpace \u03b1, UniformSpace.Core \u03b1 where\n  \n  isOpen_uniformity :\n    \u2200 s, IsOpen[toTopologicalSpace] s \u2194 \u2200 x \u2208 s, { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 uniformity", "start": [298, 1], "end": [309, 96], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mk'", "code": "@[match_pattern, reducible]\ndef UniformSpace.mk' {\u03b1} (t : TopologicalSpace \u03b1) (c : UniformSpace.Core \u03b1)\n    (isOpen_uniformity :\n      \u2200 s : Set \u03b1, IsOpen[t] s \u2194 \u2200 x \u2208 s, { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 c.uniformity) :\n    UniformSpace \u03b1 :=\n  \u27e8c, isOpen_uniformity\u27e9", "start": [312, 1], "end": [318, 25], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ofCore", "code": "@[reducible]\ndef UniformSpace.ofCore {\u03b1 : Type u} (u : UniformSpace.Core \u03b1) : UniformSpace \u03b1 where\n  toCore := u\n  toTopologicalSpace := u.toTopologicalSpace\n  isOpen_uniformity _ := Iff.rfl", "start": [321, 1], "end": [326, 33], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ofCoreEq", "code": "@[reducible]\ndef UniformSpace.ofCoreEq {\u03b1 : Type u} (u : UniformSpace.Core \u03b1) (t : TopologicalSpace \u03b1)\n    (h : t = u.toTopologicalSpace) : UniformSpace \u03b1 where\n  toCore := u\n  toTopologicalSpace := t\n  isOpen_uniformity _ := h.symm \u25b8 Iff.rfl", "start": [329, 1], "end": [336, 42], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.toCore_toTopologicalSpace", "code": "theorem UniformSpace.toCore_toTopologicalSpace (u : UniformSpace \u03b1) :\n    u.toCore.toTopologicalSpace = u.toTopologicalSpace", "start": [339, 1], "end": [341, 90], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ofNhdsEqComap", "code": "@[reducible]\ndef UniformSpace.ofNhdsEqComap (u : UniformSpace.Core \u03b1) (t : TopologicalSpace \u03b1)\n    (h : \u2200 x, \ud835\udcdd x = u.uniformity.comap (Prod.mk x)) : UniformSpace \u03b1 where\n  toCore := u\n  toTopologicalSpace := t\n  isOpen_uniformity := fun u => by simp only [isOpen_iff_mem_nhds, h, mem_comap_prod_mk]", "start": [345, 1], "end": [352, 89], "kind": "commanddeclaration"}, {"full_name": "uniformity", "code": "def uniformity (\u03b1 : Type u) [UniformSpace \u03b1] : Filter (\u03b1 \u00d7 \u03b1) :=\n  (@UniformSpace.toCore \u03b1 _).uniformity", "start": [354, 1], "end": [357, 40], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ext", "code": "@[ext]\nprotected theorem UniformSpace.ext : \u2200 {u\u2081 u\u2082 : UniformSpace \u03b1}, \ud835\udce4[u\u2081] = \ud835\udce4[u\u2082] \u2192 u\u2081 = u\u2082", "start": [363, 1], "end": [368, 8], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ext_iff", "code": "protected theorem UniformSpace.ext_iff {u\u2081 u\u2082 : UniformSpace \u03b1} :\n    u\u2081 = u\u2082 \u2194 \u2200 s, s \u2208 \ud835\udce4[u\u2081] \u2194 s \u2208 \ud835\udce4[u\u2082]", "start": [371, 1], "end": [373, 55], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ofCoreEq_toCore", "code": "theorem UniformSpace.ofCoreEq_toCore (u : UniformSpace \u03b1) (t : TopologicalSpace \u03b1)\n    (h : t = u.toCore.toTopologicalSpace) : UniformSpace.ofCoreEq u.toCore t h = u", "start": [375, 1], "end": [377, 23], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.replaceTopology", "code": "@[reducible]\ndef UniformSpace.replaceTopology {\u03b1 : Type*} [i : TopologicalSpace \u03b1] (u : UniformSpace \u03b1)\n    (h : i = u.toTopologicalSpace) : UniformSpace \u03b1 :=\n  UniformSpace.ofCoreEq u.toCore i <| h.trans u.toCore_toTopologicalSpace.symm", "start": [380, 1], "end": [385, 79], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.replaceTopology_eq", "code": "theorem UniformSpace.replaceTopology_eq {\u03b1 : Type*} [i : TopologicalSpace \u03b1] (u : UniformSpace \u03b1)\n    (h : i = u.toTopologicalSpace) : u.replaceTopology h = u", "start": [388, 1], "end": [390, 24], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ofFun", "code": "def UniformSpace.ofFun {\u03b1 : Type u} {\u03b2 : Type v} [OrderedAddCommMonoid \u03b2]\n    (d : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (refl : \u2200 x, d x x = 0) (symm : \u2200 x y, d x y = d y x)\n    (triangle : \u2200 x y z, d x z \u2264 d x y + d y z)\n    (half : \u2200 \u03b5 > (0 : \u03b2), \u2203 \u03b4 > (0 : \u03b2), \u2200 x < \u03b4, \u2200 y < \u03b4, x + y < \u03b5) :\n    UniformSpace \u03b1 :=\n.ofCore\n  { uniformity := \u2a05 r > 0, \ud835\udcdf { x | d x.1 x.2 < r }\n    refl := le_iInf\u2082 fun r hr => principal_mono.2 <| idRel_subset.2 fun x => by simpa [refl]\n    symm := tendsto_iInf_iInf fun r => tendsto_iInf_iInf fun _ => tendsto_principal_principal.2\n      fun x hx => by rwa [mem_setOf, symm]\n    comp := le_iInf\u2082 fun r hr => let \u27e8\u03b4, h0, h\u03b4r\u27e9 := half r hr; le_principal_iff.2 <|\n      mem_of_superset (mem_lift' <| mem_iInf_of_mem \u03b4 <| mem_iInf_of_mem h0 <| mem_principal_self _)\n        fun (x, z) \u27e8y, h\u2081, h\u2082\u27e9 => (triangle _ _ _).trans_lt (h\u03b4r _ h\u2081 _ h\u2082) }", "start": [394, 1], "end": [408, 78], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.hasBasis_ofFun", "code": "theorem UniformSpace.hasBasis_ofFun {\u03b1 : Type u} {\u03b2 : Type v} [LinearOrderedAddCommMonoid \u03b2]\n    (h\u2080 : \u2203 x : \u03b2, 0 < x) (d : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (refl : \u2200 x, d x x = 0) (symm : \u2200 x y, d x y = d y x)\n    (triangle : \u2200 x y z, d x z \u2264 d x y + d y z)\n    (half : \u2200 \u03b5 > (0 : \u03b2), \u2203 \u03b4 > (0 : \u03b2), \u2200 x < \u03b4, \u2200 y < \u03b4, x + y < \u03b5) :\n    \ud835\udce4[.ofFun d refl symm triangle half].HasBasis ((0 : \u03b2) < \u00b7) (fun \u03b5 => { x | d x.1 x.2 < \u03b5 })", "start": [411, 1], "end": [418, 61], "kind": "commanddeclaration"}, {"full_name": "isOpen_uniformity", "code": "theorem isOpen_uniformity {s : Set \u03b1} :\n    IsOpen s \u2194 \u2200 x \u2208 s, { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 \ud835\udce4 \u03b1", "start": [428, 1], "end": [430, 35], "kind": "commanddeclaration"}, {"full_name": "refl_le_uniformity", "code": "theorem refl_le_uniformity : \ud835\udcdf idRel \u2264 \ud835\udce4 \u03b1", "start": [433, 1], "end": [434, 34], "kind": "commanddeclaration"}, {"full_name": "uniformity.neBot", "code": "instance uniformity.neBot [Nonempty \u03b1] : NeBot (\ud835\udce4 \u03b1) :=\n  diagonal_nonempty.principal_neBot.mono refl_le_uniformity", "start": [437, 1], "end": [438, 60], "kind": "commanddeclaration"}, {"full_name": "refl_mem_uniformity", "code": "theorem refl_mem_uniformity {x : \u03b1} {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) : (x, x) \u2208 s", "start": [441, 1], "end": [442, 27], "kind": "commanddeclaration"}, {"full_name": "mem_uniformity_of_eq", "code": "theorem mem_uniformity_of_eq {x y : \u03b1} {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) (hx : x = y) : (x, y) \u2208 s", "start": [445, 1], "end": [446, 26], "kind": "commanddeclaration"}, {"full_name": "symm_le_uniformity", "code": "theorem symm_le_uniformity : map (@Prod.swap \u03b1 \u03b1) (\ud835\udce4 _) \u2264 \ud835\udce4 _", "start": [449, 1], "end": [450, 34], "kind": "commanddeclaration"}, {"full_name": "comp_le_uniformity", "code": "theorem comp_le_uniformity : ((\ud835\udce4 \u03b1).lift' fun s : Set (\u03b1 \u00d7 \u03b1) => s \u25cb s) \u2264 \ud835\udce4 \u03b1", "start": [453, 1], "end": [454, 34], "kind": "commanddeclaration"}, {"full_name": "tendsto_swap_uniformity", "code": "theorem tendsto_swap_uniformity : Tendsto (@Prod.swap \u03b1 \u03b1) (\ud835\udce4 \u03b1) (\ud835\udce4 \u03b1)", "start": [457, 1], "end": [458, 21], "kind": "commanddeclaration"}, {"full_name": "comp_mem_uniformity_sets", "code": "theorem comp_mem_uniformity_sets {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) : \u2203 t \u2208 \ud835\udce4 \u03b1, t \u25cb t \u2286 s", "start": [461, 1], "end": [463, 62], "kind": "commanddeclaration"}, {"full_name": "eventually_uniformity_iterate_comp_subset", "code": "theorem eventually_uniformity_iterate_comp_subset {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) (n : \u2115) :\n    \u2200\u1da0 t in (\ud835\udce4 \u03b1).smallSets, (t \u25cb \u00b7)^[n] t \u2286 s", "start": [466, 1], "end": [478, 42], "kind": "commanddeclaration"}, {"full_name": "eventually_uniformity_comp_subset", "code": "theorem eventually_uniformity_comp_subset {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2200\u1da0 t in (\ud835\udce4 \u03b1).smallSets, t \u25cb t \u2286 s", "start": [481, 1], "end": [485, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.uniformity_trans", "code": "theorem Filter.Tendsto.uniformity_trans {l : Filter \u03b2} {f\u2081 f\u2082 f\u2083 : \u03b2 \u2192 \u03b1}\n    (h\u2081\u2082 : Tendsto (fun x => (f\u2081 x, f\u2082 x)) l (\ud835\udce4 \u03b1))\n    (h\u2082\u2083 : Tendsto (fun x => (f\u2082 x, f\u2083 x)) l (\ud835\udce4 \u03b1)) : Tendsto (fun x => (f\u2081 x, f\u2083 x)) l (\ud835\udce4 \u03b1)", "start": [488, 1], "end": [493, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.uniformity_symm", "code": "theorem Filter.Tendsto.uniformity_symm {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1 \u00d7 \u03b1} (h : Tendsto f l (\ud835\udce4 \u03b1)) :\n    Tendsto (fun x => ((f x).2, (f x).1)) l (\ud835\udce4 \u03b1)", "start": [496, 1], "end": [499, 33], "kind": "commanddeclaration"}, {"full_name": "tendsto_diag_uniformity", "code": "theorem tendsto_diag_uniformity (f : \u03b2 \u2192 \u03b1) (l : Filter \u03b2) :\n    Tendsto (fun x => (f x, f x)) l (\ud835\udce4 \u03b1)", "start": [502, 1], "end": [505, 57], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_uniformity", "code": "theorem tendsto_const_uniformity {a : \u03b1} {f : Filter \u03b2} : Tendsto (fun _ => (a, a)) f (\ud835\udce4 \u03b1)", "start": [508, 1], "end": [509, 41], "kind": "commanddeclaration"}, {"full_name": "symm_of_uniformity", "code": "theorem symm_of_uniformity {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t \u2208 \ud835\udce4 \u03b1, (\u2200 a b, (a, b) \u2208 t \u2192 (b, a) \u2208 t) \u2227 t \u2286 s", "start": [512, 1], "end": [515, 101], "kind": "commanddeclaration"}, {"full_name": "comp_symm_of_uniformity", "code": "theorem comp_symm_of_uniformity {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t \u2208 \ud835\udce4 \u03b1, (\u2200 {a b}, (a, b) \u2208 t \u2192 (b, a) \u2208 t) \u2227 t \u25cb t \u2286 s", "start": [518, 1], "end": [522, 79], "kind": "commanddeclaration"}, {"full_name": "uniformity_le_symm", "code": "theorem uniformity_le_symm : \ud835\udce4 \u03b1 \u2264 @Prod.swap \u03b1 \u03b1 <$> \ud835\udce4 \u03b1", "start": [525, 1], "end": [526, 70], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_symm", "code": "theorem uniformity_eq_symm : \ud835\udce4 \u03b1 = @Prod.swap \u03b1 \u03b1 <$> \ud835\udce4 \u03b1", "start": [529, 1], "end": [530, 52], "kind": "commanddeclaration"}, {"full_name": "comap_swap_uniformity", "code": "@[simp]\ntheorem comap_swap_uniformity : comap (@Prod.swap \u03b1 \u03b1) (\ud835\udce4 \u03b1) = \ud835\udce4 \u03b1", "start": [533, 1], "end": [535, 74], "kind": "commanddeclaration"}, {"full_name": "symmetrize_mem_uniformity", "code": "theorem symmetrize_mem_uniformity {V : Set (\u03b1 \u00d7 \u03b1)} (h : V \u2208 \ud835\udce4 \u03b1) : symmetrizeRel V \u2208 \ud835\udce4 \u03b1", "start": [538, 1], "end": [541, 24], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.hasBasis_symmetric", "code": "theorem UniformSpace.hasBasis_symmetric :\n    (\ud835\udce4 \u03b1).HasBasis (fun s : Set (\u03b1 \u00d7 \u03b1) => s \u2208 \ud835\udce4 \u03b1 \u2227 SymmetricRel s) id", "start": [544, 1], "end": [549, 35], "kind": "commanddeclaration"}, {"full_name": "uniformity_lift_le_swap", "code": "theorem uniformity_lift_le_swap {g : Set (\u03b1 \u00d7 \u03b1) \u2192 Filter \u03b2} {f : Filter \u03b2} (hg : Monotone g)\n    (h : ((\ud835\udce4 \u03b1).lift fun s => g (preimage Prod.swap s)) \u2264 f) : (\ud835\udce4 \u03b1).lift g \u2264 f", "start": [552, 1], "end": [557, 75], "kind": "commanddeclaration"}, {"full_name": "uniformity_lift_le_comp", "code": "theorem uniformity_lift_le_comp {f : Set (\u03b1 \u00d7 \u03b1) \u2192 Filter \u03b2} (h : Monotone f) :\n    ((\ud835\udce4 \u03b1).lift fun s => f (s \u25cb s)) \u2264 (\ud835\udce4 \u03b1).lift f", "start": [560, 1], "end": [567, 60], "kind": "commanddeclaration"}, {"full_name": "comp3_mem_uniformity", "code": "theorem comp3_mem_uniformity {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) : \u2203 t \u2208 \ud835\udce4 \u03b1, t \u25cb (t \u25cb t) \u2286 s", "start": [571, 1], "end": [574, 98], "kind": "commanddeclaration"}, {"full_name": "comp_le_uniformity3", "code": "theorem comp_le_uniformity3 : ((\ud835\udce4 \u03b1).lift' fun s : Set (\u03b1 \u00d7 \u03b1) => s \u25cb (s \u25cb s)) \u2264 \ud835\udce4 \u03b1", "start": [576, 1], "end": [579, 37], "kind": "commanddeclaration"}, {"full_name": "comp_symm_mem_uniformity_sets", "code": "theorem comp_symm_mem_uniformity_sets {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t \u2208 \ud835\udce4 \u03b1, SymmetricRel t \u2227 t \u25cb t \u2286 s", "start": [582, 1], "end": [590, 23], "kind": "commanddeclaration"}, {"full_name": "subset_comp_self_of_mem_uniformity", "code": "theorem subset_comp_self_of_mem_uniformity {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) : s \u2286 s \u25cb s", "start": [593, 1], "end": [594, 42], "kind": "commanddeclaration"}, {"full_name": "comp_comp_symm_mem_uniformity_sets", "code": "theorem comp_comp_symm_mem_uniformity_sets {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t \u2208 \ud835\udce4 \u03b1, SymmetricRel t \u2227 t \u25cb t \u25cb t \u2286 s", "start": [597, 1], "end": [610, 19], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ball", "code": "def UniformSpace.ball (x : \u03b2) (V : Set (\u03b2 \u00d7 \u03b2)) : Set \u03b2 :=\n  Prod.mk x \u207b\u00b9' V", "start": [617, 1], "end": [621, 18], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mem_ball_self", "code": "theorem UniformSpace.mem_ball_self (x : \u03b1) {V : Set (\u03b1 \u00d7 \u03b1)} (hV : V \u2208 \ud835\udce4 \u03b1) : x \u2208 ball x V", "start": [626, 1], "end": [627, 25], "kind": "commanddeclaration"}, {"full_name": "mem_ball_comp", "code": "theorem mem_ball_comp {V W : Set (\u03b2 \u00d7 \u03b2)} {x y z} (h : y \u2208 ball x V) (h' : z \u2208 ball y W) :\n    z \u2208 ball x (V \u25cb W)", "start": [630, 1], "end": [633, 27], "kind": "commanddeclaration"}, {"full_name": "ball_subset_of_comp_subset", "code": "theorem ball_subset_of_comp_subset {V W : Set (\u03b2 \u00d7 \u03b2)} {x y} (h : x \u2208 ball y W) (h' : W \u25cb W \u2286 V) :\n    ball x W \u2286 ball y V", "start": [636, 1], "end": [637, 68], "kind": "commanddeclaration"}, {"full_name": "ball_mono", "code": "theorem ball_mono {V W : Set (\u03b2 \u00d7 \u03b2)} (h : V \u2286 W) (x : \u03b2) : ball x V \u2286 ball x W", "start": [640, 1], "end": [641, 18], "kind": "commanddeclaration"}, {"full_name": "ball_inter", "code": "theorem ball_inter (x : \u03b2) (V W : Set (\u03b2 \u00d7 \u03b2)) : ball x (V \u2229 W) = ball x V \u2229 ball x W", "start": [644, 1], "end": [645, 17], "kind": "commanddeclaration"}, {"full_name": "ball_inter_left", "code": "theorem ball_inter_left (x : \u03b2) (V W : Set (\u03b2 \u00d7 \u03b2)) : ball x (V \u2229 W) \u2286 ball x V", "start": [648, 1], "end": [649, 38], "kind": "commanddeclaration"}, {"full_name": "ball_inter_right", "code": "theorem ball_inter_right (x : \u03b2) (V W : Set (\u03b2 \u00d7 \u03b2)) : ball x (V \u2229 W) \u2286 ball x W", "start": [652, 1], "end": [653, 39], "kind": "commanddeclaration"}, {"full_name": "mem_ball_symmetry", "code": "theorem mem_ball_symmetry {V : Set (\u03b2 \u00d7 \u03b2)} (hV : SymmetricRel V) {x y} :\n    x \u2208 ball y V \u2194 y \u2208 ball x V", "start": [656, 1], "end": [660, 12], "kind": "commanddeclaration"}, {"full_name": "ball_eq_of_symmetry", "code": "theorem ball_eq_of_symmetry {V : Set (\u03b2 \u00d7 \u03b2)} (hV : SymmetricRel V) {x} :\n    ball x V = { y | (y, x) \u2208 V }", "start": [663, 1], "end": [667, 16], "kind": "commanddeclaration"}, {"full_name": "mem_comp_of_mem_ball", "code": "theorem mem_comp_of_mem_ball {V W : Set (\u03b2 \u00d7 \u03b2)} {x y z : \u03b2} (hV : SymmetricRel V)\n    (hx : x \u2208 ball z V) (hy : y \u2208 ball z W) : (x, y) \u2208 V \u25cb W", "start": [670, 1], "end": [673, 20], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.isOpen_ball", "code": "theorem UniformSpace.isOpen_ball (x : \u03b1) {V : Set (\u03b1 \u00d7 \u03b1)} (hV : IsOpen V) : IsOpen (ball x V)", "start": [676, 1], "end": [677, 56], "kind": "commanddeclaration"}, {"full_name": "mem_comp_comp", "code": "theorem mem_comp_comp {V W M : Set (\u03b2 \u00d7 \u03b2)} (hW' : SymmetricRel W) {p : \u03b2 \u00d7 \u03b2} :\n    p \u2208 V \u25cb M \u25cb W \u2194 (ball p.1 V \u00d7\u02e2 ball p.2 W \u2229 M).Nonempty", "start": [680, 1], "end": [688, 36], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_uniformity_iff_right", "code": "theorem mem_nhds_uniformity_iff_right {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 { p : \u03b1 \u00d7 \u03b1 | p.1 = x \u2192 p.2 \u2208 s } \u2208 \ud835\udce4 \u03b1", "start": [695, 1], "end": [709, 44], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_uniformity_iff_left", "code": "theorem mem_nhds_uniformity_iff_left {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 { p : \u03b1 \u00d7 \u03b1 | p.2 = x \u2192 p.1 \u2208 s } \u2208 \ud835\udce4 \u03b1", "start": [712, 1], "end": [715, 80], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_comap_uniformity", "code": "theorem nhds_eq_comap_uniformity {x : \u03b1} : \ud835\udcdd x = (\ud835\udce4 \u03b1).comap (Prod.mk x)", "start": [718, 1], "end": [720, 56], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_ball_subset", "code": "theorem isOpen_iff_ball_subset {s : Set \u03b1} : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s", "start": [723, 1], "end": [725, 75], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_uniformity'", "code": "theorem nhds_basis_uniformity' {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s)\n    {x : \u03b1} : (\ud835\udcdd x).HasBasis p fun i => ball x (s i)", "start": [728, 1], "end": [731, 28], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_uniformity", "code": "theorem nhds_basis_uniformity {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s)\n    {x : \u03b1} : (\ud835\udcdd x).HasBasis p fun i => { y | (y, x) \u2208 s i }", "start": [734, 1], "end": [738, 33], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_comap_uniformity'", "code": "theorem nhds_eq_comap_uniformity' {x : \u03b1} : \ud835\udcdd x = (\ud835\udce4 \u03b1).comap fun y => (y, x)", "start": [741, 1], "end": [742, 88], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mem_nhds_iff", "code": "theorem UniformSpace.mem_nhds_iff {x : \u03b1} {s : Set \u03b1} : s \u2208 \ud835\udcdd x \u2194 \u2203 V \u2208 \ud835\udce4 \u03b1, ball x V \u2286 s", "start": [745, 1], "end": [747, 17], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.ball_mem_nhds", "code": "theorem UniformSpace.ball_mem_nhds (x : \u03b1) \u2983V : Set (\u03b1 \u00d7 \u03b1)\u2984 (V_in : V \u2208 \ud835\udce4 \u03b1) : ball x V \u2208 \ud835\udcdd x", "start": [750, 1], "end": [752, 30], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mem_nhds_iff_symm", "code": "theorem UniformSpace.mem_nhds_iff_symm {x : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd x \u2194 \u2203 V \u2208 \ud835\udce4 \u03b1, SymmetricRel V \u2227 ball x V \u2286 s", "start": [755, 1], "end": [763, 27], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.hasBasis_nhds", "code": "theorem UniformSpace.hasBasis_nhds (x : \u03b1) :\n    HasBasis (\ud835\udcdd x) (fun s : Set (\u03b1 \u00d7 \u03b1) => s \u2208 \ud835\udce4 \u03b1 \u2227 SymmetricRel s) fun s => ball x s", "start": [766, 1], "end": [768, 65], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mem_closure_iff_symm_ball", "code": "theorem UniformSpace.mem_closure_iff_symm_ball {s : Set \u03b1} {x} :\n    x \u2208 closure s \u2194 \u2200 {V}, V \u2208 \ud835\udce4 \u03b1 \u2192 SymmetricRel V \u2192 (s \u2229 ball x V).Nonempty", "start": [773, 1], "end": [775, 68], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.mem_closure_iff_ball", "code": "theorem UniformSpace.mem_closure_iff_ball {s : Set \u03b1} {x} :\n    x \u2208 closure s \u2194 \u2200 {V}, V \u2208 \ud835\udce4 \u03b1 \u2192 (ball x V \u2229 s).Nonempty", "start": [778, 1], "end": [780, 79], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.hasBasis_nhds_prod", "code": "theorem UniformSpace.hasBasis_nhds_prod (x y : \u03b1) :\n    HasBasis (\ud835\udcdd (x, y)) (fun s => s \u2208 \ud835\udce4 \u03b1 \u2227 SymmetricRel s) fun s => ball x s \u00d7\u02e2 ball y s", "start": [783, 1], "end": [790, 30], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_uniformity", "code": "theorem nhds_eq_uniformity {x : \u03b1} : \ud835\udcdd x = (\ud835\udce4 \u03b1).lift' (ball x)", "start": [793, 1], "end": [794, 53], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_uniformity'", "code": "theorem nhds_eq_uniformity' {x : \u03b1} : \ud835\udcdd x = (\ud835\udce4 \u03b1).lift' fun s => { y | (y, x) \u2208 s }", "start": [797, 1], "end": [798, 52], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_left", "code": "theorem mem_nhds_left (x : \u03b1) {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) : { y : \u03b1 | (x, y) \u2208 s } \u2208 \ud835\udcdd x", "start": [801, 1], "end": [802, 20], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_right", "code": "theorem mem_nhds_right (y : \u03b1) {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) : { x : \u03b1 | (x, y) \u2208 s } \u2208 \ud835\udcdd y", "start": [805, 1], "end": [806, 41], "kind": "commanddeclaration"}, {"full_name": "exists_mem_nhds_ball_subset_of_mem_nhds", "code": "theorem exists_mem_nhds_ball_subset_of_mem_nhds {a : \u03b1} {U : Set \u03b1} (h : U \u2208 \ud835\udcdd a) :\n    \u2203 V \u2208 \ud835\udcdd a, \u2203 t \u2208 \ud835\udce4 \u03b1, \u2200 a' \u2208 V, UniformSpace.ball a' t \u2286 U", "start": [809, 1], "end": [812, 83], "kind": "commanddeclaration"}, {"full_name": "IsCompact.nhdsSet_basis_uniformity", "code": "theorem IsCompact.nhdsSet_basis_uniformity {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (hU : (\ud835\udce4 \u03b1).HasBasis p s) {K : Set \u03b1} (hK : IsCompact K) :\n    (\ud835\udcdd\u02e2 K).HasBasis p fun i => \u22c3 x \u2208 K, ball x (s i)", "start": [815, 1], "end": [839, 30], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_uniform_thickening", "code": "theorem Disjoint.exists_uniform_thickening {A B : Set \u03b1} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : \u2203 V \u2208 \ud835\udce4 \u03b1, Disjoint (\u22c3 x \u2208 A, ball x V) (\u22c3 x \u2208 B, ball x V)", "start": [842, 1], "end": [852, 86], "kind": "commanddeclaration"}, {"full_name": "Disjoint.exists_uniform_thickening_of_basis", "code": "theorem Disjoint.exists_uniform_thickening_of_basis {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (hU : (\ud835\udce4 \u03b1).HasBasis p s) {A B : Set \u03b1} (hA : IsCompact A) (hB : IsClosed B)\n    (h : Disjoint A B) : \u2203 i, p i \u2227 Disjoint (\u22c3 x \u2208 A, ball x (s i)) (\u22c3 x \u2208 B, ball x (s i))", "start": [855, 1], "end": [861, 47], "kind": "commanddeclaration"}, {"full_name": "tendsto_right_nhds_uniformity", "code": "theorem tendsto_right_nhds_uniformity {a : \u03b1} : Tendsto (fun a' => (a', a)) (\ud835\udcdd a) (\ud835\udce4 \u03b1)", "start": [864, 1], "end": [865, 19], "kind": "commanddeclaration"}, {"full_name": "tendsto_left_nhds_uniformity", "code": "theorem tendsto_left_nhds_uniformity {a : \u03b1} : Tendsto (fun a' => (a, a')) (\ud835\udcdd a) (\ud835\udce4 \u03b1)", "start": [868, 1], "end": [869, 18], "kind": "commanddeclaration"}, {"full_name": "lift_nhds_left", "code": "theorem lift_nhds_left {x : \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} (hg : Monotone g) :\n    (\ud835\udcdd x).lift g = (\ud835\udce4 \u03b1).lift fun s : Set (\u03b1 \u00d7 \u03b1) => g (ball x s)", "start": [872, 1], "end": [875, 32], "kind": "commanddeclaration"}, {"full_name": "lift_nhds_right", "code": "theorem lift_nhds_right {x : \u03b1} {g : Set \u03b1 \u2192 Filter \u03b2} (hg : Monotone g) :\n    (\ud835\udcdd x).lift g = (\ud835\udce4 \u03b1).lift fun s : Set (\u03b1 \u00d7 \u03b1) => g { y | (y, x) \u2208 s }", "start": [878, 1], "end": [881, 36], "kind": "commanddeclaration"}, {"full_name": "nhds_nhds_eq_uniformity_uniformity_prod", "code": "theorem nhds_nhds_eq_uniformity_uniformity_prod {a b : \u03b1} :\n    \ud835\udcdd a \u00d7\u02e2 \ud835\udcdd b = (\ud835\udce4 \u03b1).lift fun s : Set (\u03b1 \u00d7 \u03b1) =>\n      (\ud835\udce4 \u03b1).lift' fun t => { y : \u03b1 | (y, a) \u2208 s } \u00d7\u02e2 { y : \u03b1 | (b, y) \u2208 t }", "start": [884, 1], "end": [888, 53], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_uniformity_prod", "code": "theorem nhds_eq_uniformity_prod {a b : \u03b1} :\n    \ud835\udcdd (a, b) =\n      (\ud835\udce4 \u03b1).lift' fun s : Set (\u03b1 \u00d7 \u03b1) => { y : \u03b1 | (y, a) \u2208 s } \u00d7\u02e2 { y : \u03b1 | (b, y) \u2208 s }", "start": [891, 1], "end": [897, 51], "kind": "commanddeclaration"}, {"full_name": "nhdset_of_mem_uniformity", "code": "theorem nhdset_of_mem_uniformity {d : Set (\u03b1 \u00d7 \u03b1)} (s : Set (\u03b1 \u00d7 \u03b1)) (hd : d \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t : Set (\u03b1 \u00d7 \u03b1), IsOpen t \u2227 s \u2286 t \u2227\n      t \u2286 { p | \u2203 x y, (p.1, x) \u2208 d \u2227 (x, y) \u2208 s \u2227 (y, p.2) \u2208 d }", "start": [900, 1], "end": [915, 67], "kind": "commanddeclaration"}, {"full_name": "nhds_le_uniformity", "code": "theorem nhds_le_uniformity (x : \u03b1) : \ud835\udcdd (x, x) \u2264 \ud835\udce4 \u03b1", "start": [918, 1], "end": [927, 54], "kind": "commanddeclaration"}, {"full_name": "iSup_nhds_le_uniformity", "code": "theorem iSup_nhds_le_uniformity : \u2a06 x : \u03b1, \ud835\udcdd (x, x) \u2264 \ud835\udce4 \u03b1", "start": [930, 1], "end": [932, 29], "kind": "commanddeclaration"}, {"full_name": "nhdsSet_diagonal_le_uniformity", "code": "theorem nhdsSet_diagonal_le_uniformity : \ud835\udcdd\u02e2 (diagonal \u03b1) \u2264 \ud835\udce4 \u03b1", "start": [935, 1], "end": [937, 56], "kind": "commanddeclaration"}, {"full_name": "closure_eq_uniformity", "code": "theorem closure_eq_uniformity (s : Set <| \u03b1 \u00d7 \u03b1) :\n    closure s = \u22c2 V \u2208 { V | V \u2208 \ud835\udce4 \u03b1 \u2227 SymmetricRel V }, V \u25cb s \u25cb V", "start": [944, 1], "end": [949, 86], "kind": "commanddeclaration"}, {"full_name": "uniformity_hasBasis_closed", "code": "theorem uniformity_hasBasis_closed :\n    HasBasis (\ud835\udce4 \u03b1) (fun V : Set (\u03b1 \u00d7 \u03b1) => V \u2208 \ud835\udce4 \u03b1 \u2227 IsClosed V) id", "start": [952, 1], "end": [961, 23], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_uniformity_closure", "code": "theorem uniformity_eq_uniformity_closure : \ud835\udce4 \u03b1 = (\ud835\udce4 \u03b1).lift' closure", "start": [964, 1], "end": [965, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformity_closure", "code": "theorem Filter.HasBasis.uniformity_closure {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : (\ud835\udce4 \u03b1).HasBasis p U) : (\ud835\udce4 \u03b1).HasBasis p fun i => closure (U i)", "start": [968, 1], "end": [970, 65], "kind": "commanddeclaration"}, {"full_name": "uniformity_hasBasis_closure", "code": "theorem uniformity_hasBasis_closure : HasBasis (\ud835\udce4 \u03b1) (fun V : Set (\u03b1 \u00d7 \u03b1) => V \u2208 \ud835\udce4 \u03b1) closure", "start": [973, 1], "end": [975, 38], "kind": "commanddeclaration"}, {"full_name": "closure_eq_inter_uniformity", "code": "theorem closure_eq_inter_uniformity {t : Set (\u03b1 \u00d7 \u03b1)} : closure t = \u22c2 d \u2208 \ud835\udce4 \u03b1, d \u25cb (t \u25cb d)", "start": [978, 1], "end": [985, 63], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_uniformity_interior", "code": "theorem uniformity_eq_uniformity_interior : \ud835\udce4 \u03b1 = (\ud835\udce4 \u03b1).lift' interior", "start": [988, 1], "end": [1002, 87], "kind": "commanddeclaration"}, {"full_name": "interior_mem_uniformity", "code": "theorem interior_mem_uniformity {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) : interior s \u2208 \ud835\udce4 \u03b1", "start": [1005, 1], "end": [1006, 61], "kind": "commanddeclaration"}, {"full_name": "mem_uniformity_isClosed", "code": "theorem mem_uniformity_isClosed {s : Set (\u03b1 \u00d7 \u03b1)} (h : s \u2208 \ud835\udce4 \u03b1) : \u2203 t \u2208 \ud835\udce4 \u03b1, IsClosed t \u2227 t \u2286 s", "start": [1009, 1], "end": [1011, 24], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_open_ball_subset", "code": "theorem isOpen_iff_open_ball_subset {s : Set \u03b1} :\n    IsOpen s \u2194 \u2200 x \u2208 s, \u2203 V \u2208 \ud835\udce4 \u03b1, IsOpen V \u2227 ball x V \u2286 s", "start": [1014, 1], "end": [1023, 23], "kind": "commanddeclaration"}, {"full_name": "Dense.biUnion_uniformity_ball", "code": "theorem Dense.biUnion_uniformity_ball {s : Set \u03b1} {U : Set (\u03b1 \u00d7 \u03b1)} (hs : Dense s) (hU : U \u2208 \ud835\udce4 \u03b1) :\n    \u22c3 x \u2208 s, ball x U = univ", "start": [1026, 1], "end": [1031, 22], "kind": "commanddeclaration"}, {"full_name": "uniformity_hasBasis_open", "code": "theorem uniformity_hasBasis_open : HasBasis (\ud835\udce4 \u03b1) (fun V : Set (\u03b1 \u00d7 \u03b1) => V \u2208 \ud835\udce4 \u03b1 \u2227 IsOpen V) id", "start": [1039, 1], "end": [1042, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.mem_uniformity_iff", "code": "theorem Filter.HasBasis.mem_uniformity_iff {p : \u03b2 \u2192 Prop} {s : \u03b2 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) {t : Set (\u03b1 \u00d7 \u03b1)} :\n    t \u2208 \ud835\udce4 \u03b1 \u2194 \u2203 i, p i \u2227 \u2200 a b, (a, b) \u2208 s i \u2192 (a, b) \u2208 t", "start": [1045, 1], "end": [1048, 60], "kind": "commanddeclaration"}, {"full_name": "uniformity_hasBasis_open_symmetric", "code": "theorem uniformity_hasBasis_open_symmetric :\n    HasBasis (\ud835\udce4 \u03b1) (fun V : Set (\u03b1 \u00d7 \u03b1) => V \u2208 \ud835\udce4 \u03b1 \u2227 IsOpen V \u2227 SymmetricRel V) id", "start": [1051, 1], "end": [1059, 62], "kind": "commanddeclaration"}, {"full_name": "comp_open_symm_mem_uniformity_sets", "code": "theorem comp_open_symm_mem_uniformity_sets {s : Set (\u03b1 \u00d7 \u03b1)} (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t \u2208 \ud835\udce4 \u03b1, IsOpen t \u2227 SymmetricRel t \u2227 t \u25cb t \u2286 s", "start": [1062, 1], "end": [1066, 61], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.has_seq_basis", "code": "theorem UniformSpace.has_seq_basis [IsCountablyGenerated <| \ud835\udce4 \u03b1] :\n    \u2203 V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1), HasAntitoneBasis (\ud835\udce4 \u03b1) V \u2227 \u2200 n, SymmetricRel (V n)", "start": [1073, 1], "end": [1076, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.biInter_biUnion_ball", "code": "theorem Filter.HasBasis.biInter_biUnion_ball {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : HasBasis (\ud835\udce4 \u03b1) p U) (s : Set \u03b1) :\n    (\u22c2 (i) (_ : p i), \u22c3 x \u2208 s, ball x (U i)) = closure s", "start": [1081, 1], "end": [1085, 68], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous", "code": "def UniformContinuous [UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :=\n  Tendsto (fun x : \u03b1 \u00d7 \u03b1 => (f x.1, f x.2)) (\ud835\udce4 \u03b1) (\ud835\udce4 \u03b2)", "start": [1091, 1], "end": [1095, 56], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousOn", "code": "def UniformContinuousOn [UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2) (s : Set \u03b1) : Prop :=\n  Tendsto (fun x : \u03b1 \u00d7 \u03b1 => (f x.1, f x.2)) (\ud835\udce4 \u03b1 \u2293 \ud835\udcdf (s \u00d7\u02e2 s)) (\ud835\udce4 \u03b2)", "start": [1101, 1], "end": [1106, 69], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_def", "code": "theorem uniformContinuous_def [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 r \u2208 \ud835\udce4 \u03b2, { x : \u03b1 \u00d7 \u03b1 | (f x.1, f x.2) \u2208 r } \u2208 \ud835\udce4 \u03b1", "start": [1109, 1], "end": [1111, 10], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_iff_eventually", "code": "theorem uniformContinuous_iff_eventually [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 r \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 x : \u03b1 \u00d7 \u03b1 in \ud835\udce4 \u03b1, (f x.1, f x.2) \u2208 r", "start": [1114, 1], "end": [1116, 10], "kind": "commanddeclaration"}, {"full_name": "uniformContinuousOn_univ", "code": "theorem uniformContinuousOn_univ [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuousOn f univ \u2194 UniformContinuous f", "start": [1119, 1], "end": [1121, 90], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_of_const", "code": "theorem uniformContinuous_of_const [UniformSpace \u03b2] {c : \u03b1 \u2192 \u03b2} (h : \u2200 a b, c a = c b) :\n    UniformContinuous c", "start": [1124, 1], "end": [1128, 99], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_id", "code": "theorem uniformContinuous_id : UniformContinuous (@id \u03b1)", "start": [1131, 1], "end": [1131, 71], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_const", "code": "theorem uniformContinuous_const [UniformSpace \u03b2] {b : \u03b2} : UniformContinuous fun _ : \u03b1 => b", "start": [1134, 1], "end": [1135, 44], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp", "code": "nonrec theorem UniformContinuous.comp [UniformSpace \u03b2] [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2}\n    (hg : UniformContinuous g) (hf : UniformContinuous f) : UniformContinuous (g \u2218 f)", "start": [1138, 1], "end": [1140, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformContinuous_iff", "code": "theorem Filter.HasBasis.uniformContinuous_iff {\u03b9'} [UniformSpace \u03b2] {p : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (ha : (\ud835\udce4 \u03b1).HasBasis p s) {q : \u03b9' \u2192 Prop} {t : \u03b9' \u2192 Set (\u03b2 \u00d7 \u03b2)}\n    (hb : (\ud835\udce4 \u03b2).HasBasis q t) {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 i, q i \u2192 \u2203 j, p j \u2227 \u2200 x y, (x, y) \u2208 s j \u2192 (f x, f y) \u2208 t i", "start": [1143, 1], "end": [1147, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformContinuousOn_iff", "code": "theorem Filter.HasBasis.uniformContinuousOn_iff {\u03b9'} [UniformSpace \u03b2] {p : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (ha : (\ud835\udce4 \u03b1).HasBasis p s) {q : \u03b9' \u2192 Prop} {t : \u03b9' \u2192 Set (\u03b2 \u00d7 \u03b2)}\n    (hb : (\ud835\udce4 \u03b2).HasBasis q t) {f : \u03b1 \u2192 \u03b2} {S : Set \u03b1} :\n    UniformContinuousOn f S \u2194\n      \u2200 i, q i \u2192 \u2203 j, p j \u2227 \u2200 x, x \u2208 S \u2192 \u2200 y, y \u2208 S \u2192 (x, y) \u2208 s j \u2192 (f x, f y) \u2208 t i", "start": [1150, 1], "end": [1156, 97], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.sInf_le", "code": "protected theorem UniformSpace.sInf_le {tt : Set (UniformSpace \u03b1)} {t : UniformSpace \u03b1}\n    (h : t \u2208 tt) : sInf tt \u2264 t", "start": [1178, 1], "end": [1180, 47], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.le_sInf", "code": "protected theorem UniformSpace.le_sInf {tt : Set (UniformSpace \u03b1)} {t : UniformSpace \u03b1}\n    (h : \u2200 t' \u2208 tt, t \u2264 t') : t \u2264 sInf tt", "start": [1182, 1], "end": [1184, 45], "kind": "commanddeclaration"}, {"full_name": "iInf_uniformity", "code": "theorem iInf_uniformity {\u03b9 : Sort*} {u : \u03b9 \u2192 UniformSpace \u03b1} : \ud835\udce4[iInf u] = \u2a05 i, \ud835\udce4[u i]", "start": [1235, 1], "end": [1236, 13], "kind": "commanddeclaration"}, {"full_name": "inf_uniformity", "code": "theorem inf_uniformity {u v : UniformSpace \u03b1} : \ud835\udce4[u \u2293 v] = \ud835\udce4[u] \u2293 \ud835\udce4[v]", "start": [1239, 1], "end": [1240, 6], "kind": "commanddeclaration"}, {"full_name": "inhabitedUniformSpace", "code": "instance inhabitedUniformSpace : Inhabited (UniformSpace \u03b1) :=\n  \u27e8\u22a5\u27e9", "start": [1243, 1], "end": [1244, 6], "kind": "commanddeclaration"}, {"full_name": "inhabitedUniformSpaceCore", "code": "instance inhabitedUniformSpaceCore : Inhabited (UniformSpace.Core \u03b1) :=\n  \u27e8@UniformSpace.toCore _ default\u27e9", "start": [1247, 1], "end": [1248, 35], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap", "code": "def UniformSpace.comap (f : \u03b1 \u2192 \u03b2) (u : UniformSpace \u03b2) : UniformSpace \u03b1 :=\n  .ofNhdsEqComap\n    { uniformity := \ud835\udce4[u].comap fun p : \u03b1 \u00d7 \u03b1 => (f p.1, f p.2)\n      refl := le_trans (by simp) (comap_mono u.refl)\n      symm := by\n        simp only [tendsto_comap_iff, Prod.swap, (\u00b7 \u2218 \u00b7)]\n        exact tendsto_swap_uniformity.comp tendsto_comap\n      comp := le_trans\n        (by\n          rw [comap_lift'_eq, comap_lift'_eq2]\n          exact lift'_mono' fun s _ \u27e8a\u2081, a\u2082\u27e9 \u27e8x, h\u2081, h\u2082\u27e9 => \u27e8f x, h\u2081, h\u2082\u27e9\n          exact monotone_id.compRel monotone_id)\n        (comap_mono u.comp) }\n    (u.toTopologicalSpace.induced f) fun x => by\n      simp only [nhds_induced, nhds_eq_comap_uniformity, comap_comap, Function.comp]", "start": [1251, 1], "end": [1267, 85], "kind": "commanddeclaration"}, {"full_name": "uniformity_comap", "code": "theorem uniformity_comap {_ : UniformSpace \u03b2} (f : \u03b1 \u2192 \u03b2) :\n    \ud835\udce4[UniformSpace.comap f \u2039_\u203a] = comap (Prod.map f f) (\ud835\udce4 \u03b2)", "start": [1270, 1], "end": [1272, 6], "kind": "commanddeclaration"}, {"full_name": "uniformSpace_comap_id", "code": "@[simp]\ntheorem uniformSpace_comap_id {\u03b1 : Type*} : UniformSpace.comap (id : \u03b1 \u2192 \u03b1) = id", "start": [1275, 1], "end": [1278, 47], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_comap", "code": "theorem UniformSpace.comap_comap {\u03b1 \u03b2 \u03b3} {u\u03b3 : UniformSpace \u03b3} {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} :\n    UniformSpace.comap (g \u2218 f) u\u03b3 = UniformSpace.comap f (UniformSpace.comap g u\u03b3)", "start": [1281, 1], "end": [1284, 70], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_inf", "code": "theorem UniformSpace.comap_inf {\u03b1 \u03b3} {u\u2081 u\u2082 : UniformSpace \u03b3} {f : \u03b1 \u2192 \u03b3} :\n    (u\u2081 \u2293 u\u2082).comap f = u\u2081.comap f \u2293 u\u2082.comap f", "start": [1287, 1], "end": [1289, 36], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_iInf", "code": "theorem UniformSpace.comap_iInf {\u03b9 \u03b1 \u03b3} {u : \u03b9 \u2192 UniformSpace \u03b3} {f : \u03b1 \u2192 \u03b3} :\n    (\u2a05 i, u i).comap f = \u2a05 i, (u i).comap f", "start": [1292, 1], "end": [1295, 43], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_mono", "code": "theorem UniformSpace.comap_mono {\u03b1 \u03b3} {f : \u03b1 \u2192 \u03b3} :\n    Monotone fun u : UniformSpace \u03b3 => u.comap f", "start": [1298, 1], "end": [1300, 23], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_iff", "code": "theorem uniformContinuous_iff {\u03b1 \u03b2} {u\u03b1 : UniformSpace \u03b1} {u\u03b2 : UniformSpace \u03b2} {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 u\u03b1 \u2264 u\u03b2.comap f", "start": [1303, 1], "end": [1305, 29], "kind": "commanddeclaration"}, {"full_name": "le_iff_uniformContinuous_id", "code": "theorem le_iff_uniformContinuous_id {u v : UniformSpace \u03b1} :\n    u \u2264 v \u2194 @UniformContinuous _ _ u v id", "start": [1308, 1], "end": [1310, 56], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_comap", "code": "theorem uniformContinuous_comap {f : \u03b1 \u2192 \u03b2} [u : UniformSpace \u03b2] :\n    @UniformContinuous \u03b1 \u03b2 (UniformSpace.comap f u) u f", "start": [1313, 1], "end": [1315, 16], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_comap", "code": "theorem toTopologicalSpace_comap {f : \u03b1 \u2192 \u03b2} {u : UniformSpace \u03b2} :\n    @UniformSpace.toTopologicalSpace _ (UniformSpace.comap f u) =\n      TopologicalSpace.induced f (@UniformSpace.toTopologicalSpace \u03b2 u)", "start": [1318, 1], "end": [1321, 6], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_comap'", "code": "theorem uniformContinuous_comap' {f : \u03b3 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} [v : UniformSpace \u03b2] [u : UniformSpace \u03b1]\n    (h : UniformContinuous (f \u2218 g)) : @UniformContinuous \u03b1 \u03b3 u (UniformSpace.comap f v) g", "start": [1324, 1], "end": [1326, 24], "kind": "commanddeclaration"}, {"full_name": "to_nhds_mono", "code": "theorem to_nhds_mono {u\u2081 u\u2082 : UniformSpace \u03b1} (h : u\u2081 \u2264 u\u2082) (a : \u03b1) :\n    @nhds _ (@UniformSpace.toTopologicalSpace _ u\u2081) a \u2264\n      @nhds _ (@UniformSpace.toTopologicalSpace _ u\u2082) a", "start": [1329, 1], "end": [1332, 92], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_mono", "code": "theorem toTopologicalSpace_mono {u\u2081 u\u2082 : UniformSpace \u03b1} (h : u\u2081 \u2264 u\u2082) :\n    @UniformSpace.toTopologicalSpace _ u\u2081 \u2264 @UniformSpace.toTopologicalSpace _ u\u2082", "start": [1335, 1], "end": [1337, 39], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.continuous", "code": "theorem UniformContinuous.continuous [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : UniformContinuous f) : Continuous f", "start": [1340, 1], "end": [1342, 89], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_bot", "code": "theorem toTopologicalSpace_bot : @UniformSpace.toTopologicalSpace \u03b1 \u22a5 = \u22a5", "start": [1345, 1], "end": [1346, 6], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_top", "code": "theorem toTopologicalSpace_top : @UniformSpace.toTopologicalSpace \u03b1 \u22a4 = \u22a4", "start": [1349, 1], "end": [1353, 35], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_iInf", "code": "theorem toTopologicalSpace_iInf {\u03b9 : Sort*} {u : \u03b9 \u2192 UniformSpace \u03b1} :\n    (iInf u).toTopologicalSpace = \u2a05 i, (u i).toTopologicalSpace", "start": [1356, 1], "end": [1359, 68], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_sInf", "code": "theorem toTopologicalSpace_sInf {s : Set (UniformSpace \u03b1)} :\n    (sInf s).toTopologicalSpace = \u2a05 i \u2208 s, @UniformSpace.toTopologicalSpace \u03b1 i", "start": [1362, 1], "end": [1365, 40], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_inf", "code": "theorem toTopologicalSpace_inf {u v : UniformSpace \u03b1} :\n    (u \u2293 v).toTopologicalSpace = u.toTopologicalSpace \u2293 v.toTopologicalSpace", "start": [1368, 1], "end": [1370, 6], "kind": "commanddeclaration"}, {"full_name": "ULift.uniformSpace", "code": "instance ULift.uniformSpace [UniformSpace \u03b1] : UniformSpace (ULift \u03b1) :=\n  UniformSpace.comap ULift.down \u2039_\u203a", "start": [1373, 1], "end": [1375, 36], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.inf_rng", "code": "theorem UniformContinuous.inf_rng {f : \u03b1 \u2192 \u03b2} {u\u2081 : UniformSpace \u03b1} {u\u2082 u\u2083 : UniformSpace \u03b2}\n    (h\u2081 : UniformContinuous[u\u2081, u\u2082] f) (h\u2082 : UniformContinuous[u\u2081, u\u2083] f) :\n    UniformContinuous[u\u2081, u\u2082 \u2293 u\u2083] f", "start": [1381, 1], "end": [1384, 27], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.inf_dom_left", "code": "theorem UniformContinuous.inf_dom_left {f : \u03b1 \u2192 \u03b2} {u\u2081 u\u2082 : UniformSpace \u03b1} {u\u2083 : UniformSpace \u03b2}\n    (hf : UniformContinuous[u\u2081, u\u2083] f) : UniformContinuous[u\u2081 \u2293 u\u2082, u\u2083] f", "start": [1388, 1], "end": [1390, 22], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.inf_dom_right", "code": "theorem UniformContinuous.inf_dom_right {f : \u03b1 \u2192 \u03b2} {u\u2081 u\u2082 : UniformSpace \u03b1} {u\u2083 : UniformSpace \u03b2}\n    (hf : UniformContinuous[u\u2082, u\u2083] f) : UniformContinuous[u\u2081 \u2293 u\u2082, u\u2083] f", "start": [1394, 1], "end": [1396, 23], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_sInf_dom", "code": "theorem uniformContinuous_sInf_dom {f : \u03b1 \u2192 \u03b2} {u\u2081 : Set (UniformSpace \u03b1)} {u\u2082 : UniformSpace \u03b2}\n    {u : UniformSpace \u03b1} (h\u2081 : u \u2208 u\u2081) (hf : UniformContinuous[u, u\u2082] f) :\n    UniformContinuous[sInf u\u2081, u\u2082] f", "start": [1399, 1], "end": [1404, 33], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_sInf_rng", "code": "theorem uniformContinuous_sInf_rng {f : \u03b1 \u2192 \u03b2} {u\u2081 : UniformSpace \u03b1} {u\u2082 : Set (UniformSpace \u03b2)} :\n    UniformContinuous[u\u2081, sInf u\u2082] f \u2194 \u2200 u \u2208 u\u2082, UniformContinuous[u\u2081, u] f", "start": [1407, 1], "end": [1410, 67], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_iInf_dom", "code": "theorem uniformContinuous_iInf_dom {f : \u03b1 \u2192 \u03b2} {u\u2081 : \u03b9 \u2192 UniformSpace \u03b1} {u\u2082 : UniformSpace \u03b2}\n    {i : \u03b9} (hf : UniformContinuous[u\u2081 i, u\u2082] f) : UniformContinuous[iInf u\u2081, u\u2082] f", "start": [1413, 1], "end": [1417, 27], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_iInf_rng", "code": "theorem uniformContinuous_iInf_rng {f : \u03b1 \u2192 \u03b2} {u\u2081 : UniformSpace \u03b1} {u\u2082 : \u03b9 \u2192 UniformSpace \u03b2} :\n    UniformContinuous[u\u2081, iInf u\u2082] f \u2194 \u2200 i, UniformContinuous[u\u2081, u\u2082 i] f", "start": [1420, 1], "end": [1423, 37], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_of_discrete_uniformity", "code": "theorem discreteTopology_of_discrete_uniformity [h\u03b1 : UniformSpace \u03b1] (h : uniformity \u03b1 = \ud835\udcdf idRel) :\n    DiscreteTopology \u03b1", "start": [1428, 1], "end": [1431, 45], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_ofMul", "code": "theorem uniformContinuous_ofMul : UniformContinuous (ofMul : \u03b1 \u2192 Additive \u03b1)", "start": [1449, 1], "end": [1450, 23], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_toMul", "code": "theorem uniformContinuous_toMul : UniformContinuous (toMul : Additive \u03b1 \u2192 \u03b1)", "start": [1453, 1], "end": [1454, 23], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_ofAdd", "code": "theorem uniformContinuous_ofAdd : UniformContinuous (ofAdd : \u03b1 \u2192 Multiplicative \u03b1)", "start": [1457, 1], "end": [1458, 23], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_toAdd", "code": "theorem uniformContinuous_toAdd : UniformContinuous (toAdd : Multiplicative \u03b1 \u2192 \u03b1)", "start": [1461, 1], "end": [1462, 23], "kind": "commanddeclaration"}, {"full_name": "uniformity_additive", "code": "theorem uniformity_additive : \ud835\udce4 (Additive \u03b1) = (\ud835\udce4 \u03b1).map (Prod.map ofMul ofMul)", "start": [1465, 1], "end": [1465, 87], "kind": "commanddeclaration"}, {"full_name": "uniformity_multiplicative", "code": "theorem uniformity_multiplicative : \ud835\udce4 (Multiplicative \u03b1) = (\ud835\udce4 \u03b1).map (Prod.map ofAdd ofAdd)", "start": [1468, 1], "end": [1468, 99], "kind": "commanddeclaration"}, {"full_name": "instUniformSpaceSubtype", "code": "instance instUniformSpaceSubtype {p : \u03b1 \u2192 Prop} [t : UniformSpace \u03b1] : UniformSpace (Subtype p) :=\n  UniformSpace.comap Subtype.val t", "start": [1473, 1], "end": [1474, 35], "kind": "commanddeclaration"}, {"full_name": "uniformity_subtype", "code": "theorem uniformity_subtype {p : \u03b1 \u2192 Prop} [UniformSpace \u03b1] :\n    \ud835\udce4 (Subtype p) = comap (fun q : Subtype p \u00d7 Subtype p => (q.1.1, q.2.1)) (\ud835\udce4 \u03b1)", "start": [1476, 1], "end": [1478, 6], "kind": "commanddeclaration"}, {"full_name": "uniformity_setCoe", "code": "theorem uniformity_setCoe {s : Set \u03b1} [UniformSpace \u03b1] :\n    \ud835\udce4 s = comap (Prod.map ((\u2191) : s \u2192 \u03b1) ((\u2191) : s \u2192 \u03b1)) (\ud835\udce4 \u03b1)", "start": [1481, 1], "end": [1483, 6], "kind": "commanddeclaration"}, {"full_name": "map_uniformity_set_coe", "code": "theorem map_uniformity_set_coe {s : Set \u03b1} [UniformSpace \u03b1] :\n    map (Prod.map (\u2191) (\u2191)) (\ud835\udce4 s) = \ud835\udce4 \u03b1 \u2293 \ud835\udcdf (s \u00d7\u02e2 s)", "start": [1487, 1], "end": [1489, 71], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_subtype_val", "code": "theorem uniformContinuous_subtype_val {p : \u03b1 \u2192 Prop} [UniformSpace \u03b1] :\n    UniformContinuous (Subtype.val : { a : \u03b1 // p a } \u2192 \u03b1)", "start": [1491, 1], "end": [1493, 26], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.subtype_mk", "code": "theorem UniformContinuous.subtype_mk {p : \u03b1 \u2192 Prop} [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : UniformContinuous f) (h : \u2200 x, p (f x)) :\n    UniformContinuous (fun x => \u27e8f x, h x\u27e9 : \u03b2 \u2192 Subtype p)", "start": [1497, 1], "end": [1500, 30], "kind": "commanddeclaration"}, {"full_name": "uniformContinuousOn_iff_restrict", "code": "theorem uniformContinuousOn_iff_restrict [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    UniformContinuousOn f s \u2194 UniformContinuous (s.restrict f)", "start": [1503, 1], "end": [1506, 55], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_uniformContinuous_subtype", "code": "theorem tendsto_of_uniformContinuous_subtype [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {s : Set \u03b1} {a : \u03b1} (hf : UniformContinuous fun x : s => f x.val) (ha : s \u2208 \ud835\udcdd a) :\n    Tendsto f (\ud835\udcdd a) (\ud835\udcdd (f a))", "start": [1509, 1], "end": [1513, 48], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousOn.continuousOn", "code": "theorem UniformContinuousOn.continuousOn [UniformSpace \u03b1] [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (h : UniformContinuousOn f s) : ContinuousOn f s", "start": [1516, 1], "end": [1520, 21], "kind": "commanddeclaration"}, {"full_name": "uniformity_mulOpposite", "code": "@[to_additive]\ntheorem uniformity_mulOpposite [UniformSpace \u03b1] :\n    \ud835\udce4 \u03b1\u1d50\u1d52\u1d56 = comap (fun q : \u03b1\u1d50\u1d52\u1d56 \u00d7 \u03b1\u1d50\u1d52\u1d56 => (q.1.unop, q.2.unop)) (\ud835\udce4 \u03b1)", "start": [1527, 1], "end": [1530, 6], "kind": "commanddeclaration"}, {"full_name": "comap_uniformity_mulOpposite", "code": "@[to_additive (attr := simp)]\ntheorem comap_uniformity_mulOpposite [UniformSpace \u03b1] :\n    comap (fun p : \u03b1 \u00d7 \u03b1 => (MulOpposite.op p.1, MulOpposite.op p.2)) (\ud835\udce4 \u03b1\u1d50\u1d52\u1d56) = \ud835\udce4 \u03b1", "start": [1534, 1], "end": [1537, 70], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.uniformContinuous_unop", "code": "@[to_additive]\ntheorem uniformContinuous_unop [UniformSpace \u03b1] : UniformContinuous (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)", "start": [1543, 1], "end": [1545, 26], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.uniformContinuous_op", "code": "@[to_additive]\ntheorem uniformContinuous_op [UniformSpace \u03b1] : UniformContinuous (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56)", "start": [1549, 1], "end": [1551, 48], "kind": "commanddeclaration"}, {"full_name": "instUniformSpaceProd", "code": "instance instUniformSpaceProd [u\u2081 : UniformSpace \u03b1] [u\u2082 : UniformSpace \u03b2] : UniformSpace (\u03b1 \u00d7 \u03b2) :=\n  u\u2081.comap Prod.fst \u2293 u\u2082.comap Prod.snd", "start": [1561, 1], "end": [1562, 40], "kind": "commanddeclaration"}, {"full_name": "uniformity_prod", "code": "theorem uniformity_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) =\n      ((\ud835\udce4 \u03b1).comap fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => (p.1.1, p.2.1)) \u2293\n        (\ud835\udce4 \u03b2).comap fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => (p.1.2, p.2.2)", "start": [1569, 1], "end": [1573, 6], "kind": "commanddeclaration"}, {"full_name": "uniformity_prod_eq_comap_prod", "code": "theorem uniformity_prod_eq_comap_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) =\n      comap (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (\ud835\udce4 \u03b1 \u00d7\u02e2 \ud835\udce4 \u03b2)", "start": [1576, 1], "end": [1580, 78], "kind": "commanddeclaration"}, {"full_name": "uniformity_prod_eq_prod", "code": "theorem uniformity_prod_eq_prod [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    \ud835\udce4 (\u03b1 \u00d7 \u03b2) = map (fun p : (\u03b1 \u00d7 \u03b1) \u00d7 \u03b2 \u00d7 \u03b2 => ((p.1.1, p.2.1), (p.1.2, p.2.2))) (\ud835\udce4 \u03b1 \u00d7\u02e2 \ud835\udce4 \u03b2)", "start": [1583, 1], "end": [1585, 57], "kind": "commanddeclaration"}, {"full_name": "mem_uniformity_of_uniformContinuous_invariant", "code": "theorem mem_uniformity_of_uniformContinuous_invariant [UniformSpace \u03b1] [UniformSpace \u03b2]\n    {s : Set (\u03b2 \u00d7 \u03b2)} {f : \u03b1 \u2192 \u03b1 \u2192 \u03b2} (hf : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => f p.1 p.2)\n    (hs : s \u2208 \ud835\udce4 \u03b2) : \u2203 u \u2208 \ud835\udce4 \u03b1, \u2200 a b c, (a, b) \u2208 u \u2192 (f a c, f b c) \u2208 s", "start": [1588, 1], "end": [1593, 87], "kind": "commanddeclaration"}, {"full_name": "mem_uniform_prod", "code": "theorem mem_uniform_prod [t\u2081 : UniformSpace \u03b1] [t\u2082 : UniformSpace \u03b2] {a : Set (\u03b1 \u00d7 \u03b1)}\n    {b : Set (\u03b2 \u00d7 \u03b2)} (ha : a \u2208 \ud835\udce4 \u03b1) (hb : b \u2208 \ud835\udce4 \u03b2) :\n    { p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 | (p.1.1, p.2.1) \u2208 a \u2227 (p.1.2, p.2.2) \u2208 b } \u2208 \ud835\udce4 (\u03b1 \u00d7 \u03b2)", "start": [1596, 1], "end": [1599, 92], "kind": "commanddeclaration"}, {"full_name": "tendsto_prod_uniformity_fst", "code": "theorem tendsto_prod_uniformity_fst [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    Tendsto (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => (p.1.1, p.2.1)) (\ud835\udce4 (\u03b1 \u00d7 \u03b2)) (\ud835\udce4 \u03b1)", "start": [1602, 1], "end": [1604, 47], "kind": "commanddeclaration"}, {"full_name": "tendsto_prod_uniformity_snd", "code": "theorem tendsto_prod_uniformity_snd [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    Tendsto (fun p : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b1 \u00d7 \u03b2 => (p.1.2, p.2.2)) (\ud835\udce4 (\u03b1 \u00d7 \u03b2)) (\ud835\udce4 \u03b2)", "start": [1607, 1], "end": [1609, 48], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_fst", "code": "theorem uniformContinuous_fst [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => p.1", "start": [1612, 1], "end": [1614, 30], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_snd", "code": "theorem uniformContinuous_snd [UniformSpace \u03b1] [UniformSpace \u03b2] :\n    UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => p.2", "start": [1617, 1], "end": [1619, 30], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.prod_mk", "code": "theorem UniformContinuous.prod_mk {f\u2081 : \u03b1 \u2192 \u03b2} {f\u2082 : \u03b1 \u2192 \u03b3} (h\u2081 : UniformContinuous f\u2081)\n    (h\u2082 : UniformContinuous f\u2082) : UniformContinuous fun a => (f\u2081 a, f\u2082 a)", "start": [1624, 1], "end": [1627, 71], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.prod_mk_left", "code": "theorem UniformContinuous.prod_mk_left {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (h : UniformContinuous f) (b) :\n    UniformContinuous fun a => f (a, b)", "start": [1630, 1], "end": [1632, 64], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.prod_mk_right", "code": "theorem UniformContinuous.prod_mk_right {f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3} (h : UniformContinuous f) (a) :\n    UniformContinuous fun b => f (a, b)", "start": [1635, 1], "end": [1637, 64], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.prod_map", "code": "theorem UniformContinuous.prod_map [UniformSpace \u03b4] {f : \u03b1 \u2192 \u03b3} {g : \u03b2 \u2192 \u03b4}\n    (hf : UniformContinuous f) (hg : UniformContinuous g) : UniformContinuous (Prod.map f g)", "start": [1640, 1], "end": [1642, 74], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_prod", "code": "theorem toTopologicalSpace_prod {\u03b1} {\u03b2} [u : UniformSpace \u03b1] [v : UniformSpace \u03b2] :\n    @UniformSpace.toTopologicalSpace (\u03b1 \u00d7 \u03b2) instUniformSpaceProd =\n      @instTopologicalSpaceProd \u03b1 \u03b2 u.toTopologicalSpace v.toTopologicalSpace", "start": [1645, 1], "end": [1648, 6], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_inf_dom_left\u2082", "code": "theorem uniformContinuous_inf_dom_left\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ua1 ua2 : UniformSpace \u03b1}\n    {ub1 ub2 : UniformSpace \u03b2} {uc1 : UniformSpace \u03b3}\n    (h : by haveI := ua1; haveI := ub1; exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := ua1 \u2293 ua2; haveI := ub1 \u2293 ub2;\n        exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [1651, 1], "end": [1662, 75], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_inf_dom_right\u2082", "code": "theorem uniformContinuous_inf_dom_right\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ua1 ua2 : UniformSpace \u03b1}\n    {ub1 ub2 : UniformSpace \u03b2} {uc1 : UniformSpace \u03b3}\n    (h : by haveI := ua2; haveI := ub2; exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := ua1 \u2293 ua2; haveI := ub1 \u2293 ub2;\n        exact UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [1665, 1], "end": [1676, 75], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_sInf_dom\u2082", "code": "theorem uniformContinuous_sInf_dom\u2082 {\u03b1 \u03b2 \u03b3} {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {uas : Set (UniformSpace \u03b1)}\n    {ubs : Set (UniformSpace \u03b2)} {ua : UniformSpace \u03b1} {ub : UniformSpace \u03b2} {uc : UniformSpace \u03b3}\n    (ha : ua \u2208 uas) (hb : ub \u2208 ubs) (hf : UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) : by\n      haveI := sInf uas; haveI := sInf ubs;\n        exact @UniformContinuous _ _ _ uc fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2", "start": [1679, 1], "end": [1690, 76], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous\u2082", "code": "def UniformContinuous\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :=\n  UniformContinuous (uncurry f)", "start": [1703, 1], "end": [1705, 32], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous\u2082_def", "code": "theorem uniformContinuous\u2082_def (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) :\n    UniformContinuous\u2082 f \u2194 UniformContinuous (uncurry f)", "start": [1708, 1], "end": [1710, 10], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous\u2082.uniformContinuous", "code": "theorem UniformContinuous\u2082.uniformContinuous {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (h : UniformContinuous\u2082 f) :\n    UniformContinuous (uncurry f)", "start": [1713, 1], "end": [1715, 4], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous\u2082_curry", "code": "theorem uniformContinuous\u2082_curry (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) :\n    UniformContinuous\u2082 (Function.curry f) \u2194 UniformContinuous f", "start": [1718, 1], "end": [1720, 41], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous\u2082.comp", "code": "theorem UniformContinuous\u2082.comp {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {g : \u03b3 \u2192 \u03b4} (hg : UniformContinuous g)\n    (hf : UniformContinuous\u2082 f) : UniformContinuous\u2082 (g \u2218\u2082 f)", "start": [1723, 1], "end": [1725, 13], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous\u2082.bicompl", "code": "theorem UniformContinuous\u2082.bicompl {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {ga : \u03b4 \u2192 \u03b1} {gb : \u03b4' \u2192 \u03b2}\n    (hf : UniformContinuous\u2082 f) (hga : UniformContinuous ga) (hgb : UniformContinuous gb) :\n    UniformContinuous\u2082 (bicompl f ga gb)", "start": [1728, 1], "end": [1731, 47], "kind": "commanddeclaration"}, {"full_name": "toTopologicalSpace_subtype", "code": "theorem toTopologicalSpace_subtype [u : UniformSpace \u03b1] {p : \u03b1 \u2192 Prop} :\n    @UniformSpace.toTopologicalSpace (Subtype p) instUniformSpaceSubtype =\n      @instTopologicalSpaceSubtype \u03b1 p u.toTopologicalSpace", "start": [1736, 1], "end": [1739, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Core.sum", "code": "def UniformSpace.Core.sum : UniformSpace.Core (Sum \u03b1 \u03b2) :=\n  UniformSpace.Core.mk'\n    (map (fun p : \u03b1 \u00d7 \u03b1 => (inl p.1, inl p.2)) (\ud835\udce4 \u03b1) \u2294\n      map (fun p : \u03b2 \u00d7 \u03b2 => (inr p.1, inr p.2)) (\ud835\udce4 \u03b2))\n    (fun r \u27e8H\u2081, H\u2082\u27e9 x => by\n      cases x <;> [apply refl_mem_uniformity H\u2081; apply refl_mem_uniformity H\u2082])\n    (fun r \u27e8H\u2081, H\u2082\u27e9 => \u27e8symm_le_uniformity H\u2081, symm_le_uniformity H\u2082\u27e9)\n    (fun r \u27e8Hr\u03b1, Hr\u03b2\u27e9 => by\n      rcases comp_mem_uniformity_sets Hr\u03b1 with \u27e8t\u03b1, ht\u03b1, Ht\u03b1\u27e9\n      rcases comp_mem_uniformity_sets Hr\u03b2 with \u27e8t\u03b2, ht\u03b2, Ht\u03b2\u27e9\n      refine' \u27e8_, \u27e8mem_map_iff_exists_image.2 \u27e8t\u03b1, ht\u03b1, subset_union_left _ _\u27e9,\n        mem_map_iff_exists_image.2 \u27e8t\u03b2, ht\u03b2, subset_union_right _ _\u27e9\u27e9, _\u27e9\n      rintro \u27e8_, _\u27e9 \u27e8z, \u27e8\u27e8a, b\u27e9, hab, \u27e8\u27e9\u27e9 | \u27e8\u27e8a, b\u27e9, hab, \u27e8\u27e9\u27e9,\n          \u27e8\u27e8_, c\u27e9, hbc, \u27e8\u27e9\u27e9 | \u27e8\u27e8_, c\u27e9, hbc, \u27e8\u27e9\u27e9\u27e9\n      \u00b7 have A : (a, c) \u2208 t\u03b1 \u25cb t\u03b1 := \u27e8b, hab, hbc\u27e9\n        exact Ht\u03b1 A\n      \u00b7 have A : (a, c) \u2208 t\u03b2 \u25cb t\u03b2 := \u27e8b, hab, hbc\u27e9\n        exact Ht\u03b2 A)", "start": [1748, 1], "end": [1768, 21], "kind": "commanddeclaration"}, {"full_name": "union_mem_uniformity_sum", "code": "theorem union_mem_uniformity_sum {a : Set (\u03b1 \u00d7 \u03b1)} (ha : a \u2208 \ud835\udce4 \u03b1) {b : Set (\u03b2 \u00d7 \u03b2)} (hb : b \u2208 \ud835\udce4 \u03b2) :\n    (fun p : \u03b1 \u00d7 \u03b1 => (inl p.1, inl p.2)) '' a \u222a (fun p : \u03b2 \u00d7 \u03b2 => (inr p.1, inr p.2)) '' b \u2208\n      (@UniformSpace.Core.sum \u03b1 \u03b2 _ _).uniformity", "start": [1771, 1], "end": [1777, 64], "kind": "commanddeclaration"}, {"full_name": "uniformity_sum_of_open_aux", "code": "theorem uniformity_sum_of_open_aux {s : Set (Sum \u03b1 \u03b2)} (hs : IsOpen s) {x : Sum \u03b1 \u03b2} (xs : x \u2208 s) :\n    { p : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2) | p.1 = x \u2192 p.2 \u2208 s } \u2208\n    (@UniformSpace.Core.sum \u03b1 \u03b2 _ _).uniformity", "start": [1783, 1], "end": [1794, 16], "kind": "commanddeclaration"}, {"full_name": "open_of_uniformity_sum_aux", "code": "theorem open_of_uniformity_sum_aux {s : Set (Sum \u03b1 \u03b2)}\n    (hs : \u2200 x \u2208 s,\n      { p : (\u03b1 \u2295 \u03b2) \u00d7 (\u03b1 \u2295 \u03b2) | p.1 = x \u2192 p.2 \u2208 s } \u2208 (@UniformSpace.Core.sum \u03b1 \u03b2 _ _).uniformity) :\n    IsOpen s", "start": [1797, 1], "end": [1811, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.uniformSpace", "code": "instance Sum.uniformSpace : UniformSpace (Sum \u03b1 \u03b2) where\n  toCore := UniformSpace.Core.sum\n  isOpen_uniformity _ := \u27e8uniformity_sum_of_open_aux, open_of_uniformity_sum_aux\u27e9", "start": [1815, 1], "end": [1817, 82], "kind": "commanddeclaration"}, {"full_name": "Sum.uniformity", "code": "theorem Sum.uniformity :\n    \ud835\udce4 (Sum \u03b1 \u03b2) =\n      map (fun p : \u03b1 \u00d7 \u03b1 => (inl p.1, inl p.2)) (\ud835\udce4 \u03b1) \u2294\n        map (fun p : \u03b2 \u00d7 \u03b2 => (inr p.1, inr p.2)) (\ud835\udce4 \u03b2)", "start": [1820, 1], "end": [1824, 6], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_inl", "code": "lemma uniformContinuous_inl : UniformContinuous (Sum.inl : \u03b1 \u2192 \u03b1 \u2295 \u03b2) := le_sup_left", "start": [1828, 1], "end": [1828, 85], "kind": "mathlibtacticlemma"}, {"full_name": "uniformContinuous_inr", "code": "lemma uniformContinuous_inr : UniformContinuous (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2) := le_sup_right", "start": [1829, 1], "end": [1829, 86], "kind": "mathlibtacticlemma"}, {"full_name": "lebesgue_number_lemma", "code": "theorem lebesgue_number_lemma {\u03b1 : Type u} [UniformSpace \u03b1] {s : Set \u03b1} {\u03b9} {c : \u03b9 \u2192 Set \u03b1}\n    (hs : IsCompact s) (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i, c i) :\n    \u2203 n \u2208 \ud835\udce4 \u03b1, \u2200 x \u2208 s, \u2203 i, { y | (x, y) \u2208 n } \u2286 c i", "start": [1835, 1], "end": [1859, 83], "kind": "commanddeclaration"}, {"full_name": "lebesgue_number_lemma_sUnion", "code": "theorem lebesgue_number_lemma_sUnion {\u03b1 : Type u} [UniformSpace \u03b1] {s : Set \u03b1} {c : Set (Set \u03b1)}\n    (hs : IsCompact s) (hc\u2081 : \u2200 t \u2208 c, IsOpen t) (hc\u2082 : s \u2286 \u22c3\u2080 c) :\n    \u2203 n \u2208 \ud835\udce4 \u03b1, \u2200 x \u2208 s, \u2203 t \u2208 c, \u2200 y, (x, y) \u2208 n \u2192 y \u2208 t", "start": [1862, 1], "end": [1867, 84], "kind": "commanddeclaration"}, {"full_name": "lebesgue_number_of_compact_open", "code": "theorem lebesgue_number_of_compact_open [UniformSpace \u03b1] {K U : Set \u03b1} (hK : IsCompact K)\n    (hU : IsOpen U) (hKU : K \u2286 U) : \u2203 V \u2208 \ud835\udce4 \u03b1, IsOpen V \u2227 \u2200 x \u2208 K, UniformSpace.ball x V \u2286 U", "start": [1870, 1], "end": [1892, 65], "kind": "commanddeclaration"}, {"full_name": "Uniform.tendsto_nhds_right", "code": "theorem tendsto_nhds_right {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u f (\ud835\udcdd a) \u2194 Tendsto (fun x => (a, u x)) f (\ud835\udce4 \u03b1)", "start": [1915, 1], "end": [1917, 56], "kind": "commanddeclaration"}, {"full_name": "Uniform.tendsto_nhds_left", "code": "theorem tendsto_nhds_left {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u f (\ud835\udcdd a) \u2194 Tendsto (fun x => (u x, a)) f (\ud835\udce4 \u03b1)", "start": [1920, 1], "end": [1922, 57], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousAt_iff'_right", "code": "theorem continuousAt_iff'_right [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} :\n    ContinuousAt f b \u2194 Tendsto (fun x => (f b, f x)) (\ud835\udcdd b) (\ud835\udce4 \u03b1)", "start": [1925, 1], "end": [1927, 40], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousAt_iff'_left", "code": "theorem continuousAt_iff'_left [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} :\n    ContinuousAt f b \u2194 Tendsto (fun x => (f x, f b)) (\ud835\udcdd b) (\ud835\udce4 \u03b1)", "start": [1930, 1], "end": [1932, 39], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousAt_iff_prod", "code": "theorem continuousAt_iff_prod [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} :\n    ContinuousAt f b \u2194 Tendsto (fun x : \u03b2 \u00d7 \u03b2 => (f x.1, f x.2)) (\ud835\udcdd (b, b)) (\ud835\udce4 \u03b1)", "start": [1935, 1], "end": [1938, 86], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousWithinAt_iff'_right", "code": "theorem continuousWithinAt_iff'_right [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2} :\n    ContinuousWithinAt f s b \u2194 Tendsto (fun x => (f b, f x)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1)", "start": [1941, 1], "end": [1943, 46], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousWithinAt_iff'_left", "code": "theorem continuousWithinAt_iff'_left [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2} :\n    ContinuousWithinAt f s b \u2194 Tendsto (fun x => (f x, f b)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1)", "start": [1946, 1], "end": [1948, 45], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousOn_iff'_right", "code": "theorem continuousOn_iff'_right [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f b, f x)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1)", "start": [1951, 1], "end": [1953, 53], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuousOn_iff'_left", "code": "theorem continuousOn_iff'_left [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, Tendsto (fun x => (f x, f b)) (\ud835\udcdd[s] b) (\ud835\udce4 \u03b1)", "start": [1956, 1], "end": [1958, 52], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuous_iff'_right", "code": "theorem continuous_iff'_right [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} :\n    Continuous f \u2194 \u2200 b, Tendsto (fun x => (f b, f x)) (\ud835\udcdd b) (\ud835\udce4 \u03b1)", "start": [1961, 1], "end": [1963, 81], "kind": "commanddeclaration"}, {"full_name": "Uniform.continuous_iff'_left", "code": "theorem continuous_iff'_left [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} :\n    Continuous f \u2194 \u2200 b, Tendsto (fun x => (f x, f b)) (\ud835\udcdd b) (\ud835\udce4 \u03b1)", "start": [1966, 1], "end": [1968, 80], "kind": "commanddeclaration"}, {"full_name": "Uniform.exists_is_open_mem_uniformity_of_forall_mem_eq", "code": "lemma exists_is_open_mem_uniformity_of_forall_mem_eq\n    [TopologicalSpace \u03b2] {r : Set (\u03b1 \u00d7 \u03b1)} {s : Set \u03b2}\n    {f g : \u03b2 \u2192 \u03b1} (hf : \u2200 x \u2208 s, ContinuousAt f x) (hg : \u2200 x \u2208 s, ContinuousAt g x)\n    (hfg : s.EqOn f g) (hr : r \u2208 \ud835\udce4 \u03b1) :\n    \u2203 t, IsOpen t \u2227 s \u2286 t \u2227 \u2200 x \u2208 t, (f x, g x) \u2208 r := by\n  have A : \u2200 x \u2208 s, \u2203 t, IsOpen t \u2227 x \u2208 t \u2227 \u2200 z \u2208 t, (f z, g z) \u2208 r := by\n    intro x hx\n    obtain \u27e8t, ht, htsymm, htr\u27e9 := comp_symm_mem_uniformity_sets hr\n    have A : {z | (f x, f z) \u2208 t} \u2208 \ud835\udcdd x := (hf x hx).preimage_mem_nhds (mem_nhds_left (f x) ht)\n    have B : {z | (g x, g z) \u2208 t} \u2208 \ud835\udcdd x := (hg x hx).preimage_mem_nhds (mem_nhds_left (g x) ht)\n    rcases _root_.mem_nhds_iff.1 (inter_mem A B) with \u27e8u, hu, u_open, xu\u27e9\n    refine \u27e8u, u_open, xu, fun y hy \u21a6 ?_\u27e9\n    have I1 : (f y, f x) \u2208 t :=  (htsymm.mk_mem_comm).2 (hu hy).1\n    have I2 : (g x, g y) \u2208 t := (hu hy).2\n    rw [hfg hx] at I1\n    exact htr (prod_mk_mem_compRel I1 I2)\n  choose! t t_open xt ht using A\n  refine \u27e8\u22c3 x \u2208 s, t x, isOpen_biUnion t_open, fun x hx \u21a6 mem_biUnion hx (xt x hx), ?_\u27e9\n  rintro x hx\n  simp only [mem_iUnion, exists_prop] at hx\n  rcases hx with \u27e8y, ys, hy\u27e9\n  exact ht y ys x hy", "start": [1971, 1], "end": [1994, 21], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.Tendsto.congr_uniformity", "code": "theorem Filter.Tendsto.congr_uniformity {\u03b1 \u03b2} [UniformSpace \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} {b : \u03b2}\n    (hf : Tendsto f l (\ud835\udcdd b)) (hg : Tendsto (fun x => (f x, g x)) l (\ud835\udce4 \u03b2)) : Tendsto g l (\ud835\udcdd b)", "start": [1998, 1], "end": [2000, 88], "kind": "commanddeclaration"}, {"full_name": "Uniform.tendsto_congr", "code": "theorem Uniform.tendsto_congr {\u03b1 \u03b2} [UniformSpace \u03b2] {f g : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} {b : \u03b2}\n    (hfg : Tendsto (fun x => (f x, g x)) l (\ud835\udce4 \u03b2)) : Tendsto f l (\ud835\udcdd b) \u2194 Tendsto g l (\ud835\udcdd b)", "start": [2003, 1], "end": [2005, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Archimedean.lean", "imports": ["Mathlib/Data/Int/LeastGreatest.lean", "Mathlib/Algebra/Order/Field/Power.lean", "Mathlib/Data/Rat/Floor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Archimedean", "code": "class Archimedean (\u03b1) [OrderedAddCommMonoid \u03b1] : Prop where\n  \n  arch : \u2200 (x : \u03b1) {y : \u03b1}, 0 < y \u2192 \u2203 n : \u2115, x \u2264 n \u2022 y", "start": [37, 1], "end": [42, 55], "kind": "commanddeclaration"}, {"full_name": "OrderDual.archimedean", "code": "instance OrderDual.archimedean [OrderedAddCommGroup \u03b1] [Archimedean \u03b1] : Archimedean \u03b1\u1d52\u1d48 :=\n  \u27e8fun x y hy =>\n    let \u27e8n, hn\u27e9 := Archimedean.arch (-ofDual x) (neg_pos.2 hy)\n    \u27e8n, by rwa [neg_nsmul, neg_le_neg_iff] at hn\u27e9\u27e9", "start": [45, 1], "end": [48, 51], "kind": "commanddeclaration"}, {"full_name": "exists_lt_nsmul", "code": "theorem exists_lt_nsmul [OrderedAddCommMonoid M] [Archimedean M]\n    [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] {a : M} (ha : 0 < a) (b : M) :\n    \u2203 n : \u2115, b < n \u2022 a", "start": [51, 1], "end": [54, 97], "kind": "commanddeclaration"}, {"full_name": "existsUnique_zsmul_near_of_pos", "code": "theorem existsUnique_zsmul_near_of_pos {a : \u03b1} (ha : 0 < a) (g : \u03b1) :\n    \u2203! k : \u2124, k \u2022 a \u2264 g \u2227 g < (k + 1) \u2022 a", "start": [60, 1], "end": [79, 31], "kind": "commanddeclaration"}, {"full_name": "existsUnique_zsmul_near_of_pos'", "code": "theorem existsUnique_zsmul_near_of_pos' {a : \u03b1} (ha : 0 < a) (g : \u03b1) :\n    \u2203! k : \u2124, 0 \u2264 g - k \u2022 a \u2227 g - k \u2022 a < a", "start": [82, 1], "end": [85, 40], "kind": "commanddeclaration"}, {"full_name": "existsUnique_sub_zsmul_mem_Ico", "code": "theorem existsUnique_sub_zsmul_mem_Ico {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b - m \u2022 a \u2208 Set.Ico c (c + a)", "start": [88, 1], "end": [91, 47], "kind": "commanddeclaration"}, {"full_name": "existsUnique_add_zsmul_mem_Ico", "code": "theorem existsUnique_add_zsmul_mem_Ico {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b + m \u2022 a \u2208 Set.Ico c (c + a)", "start": [94, 1], "end": [98, 98], "kind": "commanddeclaration"}, {"full_name": "existsUnique_add_zsmul_mem_Ioc", "code": "theorem existsUnique_add_zsmul_mem_Ioc {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b + m \u2022 a \u2208 Set.Ioc c (c + a)", "start": [101, 1], "end": [106, 48], "kind": "commanddeclaration"}, {"full_name": "existsUnique_sub_zsmul_mem_Ioc", "code": "theorem existsUnique_sub_zsmul_mem_Ioc {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n    \u2203! m : \u2124, b - m \u2022 a \u2208 Set.Ioc c (c + a)", "start": [109, 1], "end": [113, 44], "kind": "commanddeclaration"}, {"full_name": "exists_nat_gt", "code": "theorem exists_nat_gt [StrictOrderedSemiring \u03b1] [Archimedean \u03b1] (x : \u03b1) : \u2203 n : \u2115, x < n", "start": [118, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "exists_nat_ge", "code": "theorem exists_nat_ge [OrderedSemiring \u03b1] [Archimedean \u03b1] (x : \u03b1) : \u2203 n : \u2115, x \u2264 n", "start": [122, 1], "end": [124, 73], "kind": "commanddeclaration"}, {"full_name": "add_one_pow_unbounded_of_pos", "code": "theorem add_one_pow_unbounded_of_pos [StrictOrderedSemiring \u03b1] [Archimedean \u03b1] (x : \u03b1) {y : \u03b1}\n    (hy : 0 < y) : \u2203 n : \u2115, x < (y + 1) ^ n", "start": [127, 1], "end": [138, 42], "kind": "commanddeclaration"}, {"full_name": "pow_unbounded_of_one_lt", "code": "theorem pow_unbounded_of_one_lt (x : \u03b1) {y : \u03b1} (hy1 : 1 < y) : \u2203 n : \u2115, x < y ^ n", "start": [145, 1], "end": [146, 70], "kind": "commanddeclaration"}, {"full_name": "exists_int_gt", "code": "theorem exists_int_gt (x : \u03b1) : \u2203 n : \u2124, x < n", "start": [149, 1], "end": [151, 31], "kind": "commanddeclaration"}, {"full_name": "exists_int_lt", "code": "theorem exists_int_lt (x : \u03b1) : \u2203 n : \u2124, (n : \u03b1) < x", "start": [154, 1], "end": [156, 47], "kind": "commanddeclaration"}, {"full_name": "exists_floor", "code": "theorem exists_floor (x : \u03b1) : \u2203 fl : \u2124, \u2200 z : \u2124, z \u2264 fl \u2194 (z : \u03b1) \u2264 x", "start": [159, 1], "end": [169, 55], "kind": "commanddeclaration"}, {"full_name": "exists_nat_pow_near", "code": "theorem exists_nat_pow_near {x : \u03b1} {y : \u03b1} (hx : 1 \u2264 x) (hy : 1 < y) :\n    \u2203 n : \u2115, y ^ n \u2264 x \u2227 x < y ^ (n + 1)", "start": [178, 1], "end": [190, 70], "kind": "commanddeclaration"}, {"full_name": "exists_mem_Ico_zpow", "code": "theorem exists_mem_Ico_zpow (hx : 0 < x) (hy : 1 < y) : \u2203 n : \u2124, x \u2208 Ico (y ^ n) (y ^ (n + 1))", "start": [199, 1], "end": [218, 81], "kind": "commanddeclaration"}, {"full_name": "exists_mem_Ioc_zpow", "code": "theorem exists_mem_Ioc_zpow (hx : 0 < x) (hy : 1 < y) : \u2203 n : \u2124, x \u2208 Ioc (y ^ n) (y ^ (n + 1))", "start": [221, 1], "end": [228, 86], "kind": "commanddeclaration"}, {"full_name": "exists_pow_lt_of_lt_one", "code": "theorem exists_pow_lt_of_lt_one (hx : 0 < x) (hy : y < 1) : \u2203 n : \u2115, y ^ n < x", "start": [231, 1], "end": [239, 69], "kind": "commanddeclaration"}, {"full_name": "exists_nat_pow_near_of_lt_one", "code": "theorem exists_nat_pow_near_of_lt_one (xpos : 0 < x) (hx : x \u2264 1) (ypos : 0 < y) (hy : y < 1) :\n    \u2203 n : \u2115, y ^ (n + 1) < x \u2227 x \u2264 y ^ n", "start": [242, 1], "end": [250, 58], "kind": "commanddeclaration"}, {"full_name": "exists_rat_gt", "code": "theorem exists_rat_gt (x : \u03b1) : \u2203 q : \u211a, x < q", "start": [253, 1], "end": [255, 33], "kind": "commanddeclaration"}, {"full_name": "exists_rat_lt", "code": "theorem exists_rat_lt (x : \u03b1) : \u2203 q : \u211a, (q : \u03b1) < x", "start": [258, 1], "end": [260, 33], "kind": "commanddeclaration"}, {"full_name": "exists_rat_btwn", "code": "theorem exists_rat_btwn {x y : \u03b1} (h : x < y) : \u2203 q : \u211a, x < q \u2227 (q : \u03b1) < y", "start": [263, 1], "end": [281, 22], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_rat_lt_imp_le", "code": "theorem le_of_forall_rat_lt_imp_le (h : \u2200 q : \u211a, (q : \u03b1) < x \u2192 (q : \u03b1) \u2264 y) : x \u2264 y", "start": [284, 1], "end": [287, 24], "kind": "commanddeclaration"}, {"full_name": "le_of_forall_lt_rat_imp_le", "code": "theorem le_of_forall_lt_rat_imp_le (h : \u2200 q : \u211a, y < q \u2192 x \u2264 q) : x \u2264 y", "start": [290, 1], "end": [293, 24], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_rat_lt_imp_le", "code": "theorem le_iff_forall_rat_lt_imp_le : x \u2264 y \u2194 \u2200 q : \u211a, (q : \u03b1) < x \u2192 (q : \u03b1) \u2264 y", "start": [296, 1], "end": [297, 65], "kind": "commanddeclaration"}, {"full_name": "le_iff_forall_lt_rat_imp_le", "code": "theorem le_iff_forall_lt_rat_imp_le : x \u2264 y \u2194 \u2200 q : \u211a, y < q \u2192 x \u2264 q", "start": [299, 1], "end": [300, 65], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_rat_lt_iff_lt", "code": "theorem eq_of_forall_rat_lt_iff_lt (h : \u2200 q : \u211a, (q : \u03b1) < x \u2194 (q : \u03b1) < y) : x = y", "start": [302, 1], "end": [304, 59], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_lt_rat_iff_lt", "code": "theorem eq_of_forall_lt_rat_iff_lt (h : \u2200 q : \u211a, x < q \u2194 y < q) : x = y", "start": [307, 1], "end": [309, 59], "kind": "commanddeclaration"}, {"full_name": "exists_nat_one_div_lt", "code": "theorem exists_nat_one_div_lt {\u03b5 : \u03b1} (h\u03b5 : 0 < \u03b5) : \u2203 n : \u2115, 1 / (n + 1 : \u03b1) < \u03b5", "start": [312, 1], "end": [318, 29], "kind": "commanddeclaration"}, {"full_name": "exists_pos_rat_lt", "code": "theorem exists_pos_rat_lt {x : \u03b1} (x0 : 0 < x) : \u2203 q : \u211a, 0 < q \u2227 (q : \u03b1) < x", "start": [321, 1], "end": [322, 53], "kind": "commanddeclaration"}, {"full_name": "exists_rat_near", "code": "theorem exists_rat_near (x : \u03b1) (\u03b50 : 0 < \u03b5) : \u2203 q : \u211a, |x - q| < \u03b5", "start": [325, 1], "end": [328, 67], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_nat_lt", "code": "theorem archimedean_iff_nat_lt : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 n : \u2115, x < n", "start": [337, 1], "end": [340, 91], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_nat_le", "code": "theorem archimedean_iff_nat_le : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 n : \u2115, x \u2264 n", "start": [343, 1], "end": [347, 64], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_int_lt", "code": "theorem archimedean_iff_int_lt : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 n : \u2124, x < n", "start": [350, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_int_le", "code": "theorem archimedean_iff_int_le : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 n : \u2124, x \u2264 n", "start": [359, 1], "end": [363, 64], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_rat_lt", "code": "theorem archimedean_iff_rat_lt : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 q : \u211a, x < q", "start": [366, 1], "end": [372, 89], "kind": "commanddeclaration"}, {"full_name": "archimedean_iff_rat_le", "code": "theorem archimedean_iff_rat_le : Archimedean \u03b1 \u2194 \u2200 x : \u03b1, \u2203 q : \u211a, x \u2264 q", "start": [375, 1], "end": [379, 64], "kind": "commanddeclaration"}, {"full_name": "Archimedean.floorRing", "code": "noncomputable def Archimedean.floorRing (\u03b1) [LinearOrderedRing \u03b1] [Archimedean \u03b1] : FloorRing \u03b1 :=\n  FloorRing.ofFloor \u03b1 (fun a => Classical.choose (exists_floor a)) fun z a =>\n    (Classical.choose_spec (exists_floor a) z).symm", "start": [399, 1], "end": [403, 52], "kind": "commanddeclaration"}, {"full_name": "FloorRing.archimedean", "code": "instance (priority := 100) FloorRing.archimedean (\u03b1) [LinearOrderedField \u03b1] [FloorRing \u03b1] :\n    Archimedean \u03b1 := by\n  rw [archimedean_iff_int_le]\n  exact fun x => \u27e8\u2308x\u2309, Int.le_ceil x\u27e9", "start": [407, 1], "end": [411, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/CauSeqCompletion.lean", "imports": ["Mathlib/Data/Real/CauSeq.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CauSeq.Completion.Cauchy", "code": "def Cauchy :=\n  @Quotient (CauSeq _ abv) CauSeq.equiv", "start": [29, 1], "end": [31, 40], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk", "code": "def mk : CauSeq _ abv \u2192 Cauchy abv :=\n  Quotient.mk''", "start": [37, 1], "end": [39, 16], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_eq_mk", "code": "@[simp]\ntheorem mk_eq_mk (f : CauSeq _ abv) : @Eq (Cauchy abv) \u27e6f\u27e7 (mk f)", "start": [42, 1], "end": [44, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_eq", "code": "theorem mk_eq {f g : CauSeq _ abv} : mk f = mk g \u2194 f \u2248 g", "start": [47, 1], "end": [48, 14], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat", "code": "def ofRat (x : \u03b2) : Cauchy abv :=\n  mk (const abv x)", "start": [51, 1], "end": [53, 19], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_zero", "code": "theorem ofRat_zero : (ofRat 0 : Cauchy abv) = 0", "start": [65, 1], "end": [66, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_one", "code": "theorem ofRat_one : (ofRat 1 : Cauchy abv) = 1", "start": [69, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_eq_zero", "code": "@[simp]\ntheorem mk_eq_zero {f : CauSeq _ abv} : mk f = 0 \u2194 LimZero f", "start": [73, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_add", "code": "@[simp]\ntheorem mk_add (f g : CauSeq \u03b2 abv) : mk f + mk g = mk (f + g)", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_neg", "code": "@[simp]\ntheorem mk_neg (f : CauSeq \u03b2 abv) : -mk f = mk (-f)", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_mul", "code": "@[simp]\ntheorem mk_mul (f g : CauSeq \u03b2 abv) : mk f * mk g = mk (f * g)", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_sub", "code": "@[simp]\ntheorem mk_sub (f g : CauSeq \u03b2 abv) : mk f - mk g = mk (f - g)", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_smul", "code": "@[simp]\ntheorem mk_smul {\u03b3 : Type*} [SMul \u03b3 \u03b2] [IsScalarTower \u03b3 \u03b2 \u03b2] (c : \u03b3) (f : CauSeq \u03b2 abv) :\n    c \u2022 mk f = mk (c \u2022 f)", "start": [114, 1], "end": [117, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mk_pow", "code": "@[simp]\ntheorem mk_pow (n : \u2115) (f : CauSeq \u03b2 abv) : mk f ^ n = mk (f ^ n)", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_natCast", "code": "@[simp]\ntheorem ofRat_natCast (n : \u2115) : (ofRat n : Cauchy abv) = n", "start": [134, 1], "end": [136, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_intCast", "code": "@[simp]\ntheorem ofRat_intCast (z : \u2124) : (ofRat z : Cauchy abv) = z", "start": [139, 1], "end": [141, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_add", "code": "theorem ofRat_add (x y : \u03b2) :\n    ofRat (x + y) = (ofRat x + ofRat y : Cauchy abv)", "start": [144, 1], "end": [146, 31], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_neg", "code": "theorem ofRat_neg (x : \u03b2) : ofRat (-x) = (-ofRat x : Cauchy abv)", "start": [149, 1], "end": [150, 29], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_mul", "code": "theorem ofRat_mul (x y : \u03b2) :\n    ofRat (x * y) = (ofRat x * ofRat y : Cauchy abv)", "start": [153, 1], "end": [155, 31], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.zero_def", "code": "private theorem zero_def : 0 = @mk _ _ _ _ abv _ 0", "start": [158, 1], "end": [159, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.one_def", "code": "private theorem one_def : 1 = @mk _ _ _ _ abv _ 1", "start": [161, 1], "end": [162, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.Cauchy.ring", "code": "instance Cauchy.ring : Ring (Cauchy abv) :=\n  Function.Surjective.ring mk (surjective_quotient_mk' _) zero_def.symm one_def.symm\n    (fun _ _ => (mk_add _ _).symm) (fun _ _ => (mk_mul _ _).symm) (fun _ => (mk_neg _).symm)\n    (fun _ _ => (mk_sub _ _).symm) (fun _ _ => (mk_smul _ _).symm) (fun _ _ => (mk_smul _ _).symm)\n    (fun _ _ => (mk_pow _ _).symm) (fun _ => rfl) fun _ => rfl", "start": [164, 1], "end": [168, 63], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRatRingHom", "code": "@[simps]\ndef ofRatRingHom : \u03b2 \u2192+* (Cauchy abv) where\n  toFun := ofRat\n  map_zero' := ofRat_zero\n  map_one' := ofRat_one\n  map_add' := ofRat_add\n  map_mul' := ofRat_mul", "start": [170, 1], "end": [177, 24], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_sub", "code": "theorem ofRat_sub (x y : \u03b2) : ofRat (x - y) = (ofRat x - ofRat y : Cauchy abv)", "start": [181, 1], "end": [182, 31], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.Cauchy.commRing", "code": "instance Cauchy.commRing : CommRing (Cauchy abv) :=\n  Function.Surjective.commRing mk (surjective_quotient_mk' _) zero_def.symm one_def.symm\n    (fun _ _ => (mk_add _ _).symm) (fun _ _ => (mk_mul _ _).symm) (fun _ => (mk_neg _).symm)\n    (fun _ _ => (mk_sub _ _).symm) (fun _ _ => (mk_smul _ _).symm) (fun _ _ => (mk_smul _ _).symm)\n    (fun _ _ => (mk_pow _ _).symm) (fun _ => rfl) fun _ => rfl", "start": [193, 1], "end": [197, 63], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_ratCast", "code": "@[simp, coe]\ntheorem ofRat_ratCast (q : \u211a) : ofRat (\u2191q : \u03b2) = (q : (Cauchy abv))", "start": [212, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.inv_zero", "code": "theorem inv_zero : (0 : (Cauchy abv))\u207b\u00b9 = 0", "start": [233, 1], "end": [234, 64], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.inv_mk", "code": "@[simp]\ntheorem inv_mk {f} (hf) : (@mk \u03b1 _ \u03b2 _ abv _ f)\u207b\u00b9 = mk (inv f hf)", "start": [237, 1], "end": [239, 34], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.cau_seq_zero_ne_one", "code": "theorem cau_seq_zero_ne_one : \u00ac(0 : CauSeq _ abv) \u2248 1", "start": [242, 1], "end": [245, 47], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.zero_ne_one", "code": "theorem zero_ne_one : (0 : (Cauchy abv)) \u2260 1", "start": [248, 1], "end": [248, 90], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.inv_mul_cancel", "code": "protected theorem inv_mul_cancel {x : (Cauchy abv)} : x \u2260 0 \u2192 x\u207b\u00b9 * x = 1", "start": [251, 1], "end": [255, 52], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.mul_inv_cancel", "code": "protected theorem mul_inv_cancel {x : (Cauchy abv)} : x \u2260 0 \u2192 x * x\u207b\u00b9 = 1", "start": [258, 1], "end": [262, 52], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_inv", "code": "theorem ofRat_inv (x : \u03b2) : ofRat x\u207b\u00b9 = ((ofRat x)\u207b\u00b9 : (Cauchy abv))", "start": [265, 1], "end": [266, 74], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.Cauchy.divisionRing", "code": "noncomputable instance Cauchy.divisionRing : DivisionRing (Cauchy abv) where\n  exists_pair_ne := \u27e80, 1, zero_ne_one\u27e9\n  inv_zero := inv_zero\n  mul_inv_cancel x := CauSeq.Completion.mul_inv_cancel\n  ratCast q := ofRat q\n  ratCast_mk n d hd hnd := by rw [\u2190 ofRat_ratCast, Rat.cast_mk', ofRat_mul, ofRat_inv]; rfl", "start": [271, 1], "end": [277, 92], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_div", "code": "theorem ofRat_div (x y : \u03b2) : ofRat (x / y) = (ofRat x / ofRat y : Cauchy abv)", "start": [279, 1], "end": [280, 51], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.Cauchy.field", "code": "noncomputable instance Cauchy.field : Field (Cauchy abv) :=\n  { Cauchy.divisionRing, Cauchy.commRing with }", "start": [302, 1], "end": [304, 48], "kind": "commanddeclaration"}, {"full_name": "CauSeq.IsComplete", "code": "class IsComplete : Prop where\n  \n  isComplete : \u2200 s : CauSeq \u03b2 abv, \u2203 b : \u03b2, s \u2248 const abv b", "start": [318, 1], "end": [322, 60], "kind": "commanddeclaration"}, {"full_name": "CauSeq.complete", "code": "theorem complete : \u2200 s : CauSeq \u03b2 abv, \u2203 b : \u03b2, s \u2248 const abv b", "start": [334, 1], "end": [335, 24], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim", "code": "noncomputable def lim (s : CauSeq \u03b2 abv) : \u03b2 :=\n  Classical.choose (complete s)", "start": [338, 1], "end": [340, 32], "kind": "commanddeclaration"}, {"full_name": "CauSeq.equiv_lim", "code": "theorem equiv_lim (s : CauSeq \u03b2 abv) : s \u2248 const abv (lim s)", "start": [343, 1], "end": [344, 37], "kind": "commanddeclaration"}, {"full_name": "CauSeq.eq_lim_of_const_equiv", "code": "theorem eq_lim_of_const_equiv {f : CauSeq \u03b2 abv} {x : \u03b2} (h : CauSeq.const abv x \u2248 f) : x = lim f", "start": [347, 1], "end": [348, 50], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_eq_of_equiv_const", "code": "theorem lim_eq_of_equiv_const {f : CauSeq \u03b2 abv} {x : \u03b2} (h : f \u2248 CauSeq.const abv x) : lim f = x", "start": [351, 1], "end": [352, 48], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_eq_lim_of_equiv", "code": "theorem lim_eq_lim_of_equiv {f g : CauSeq \u03b2 abv} (h : f \u2248 g) : lim f = lim g", "start": [355, 1], "end": [356, 57], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_const", "code": "@[simp]\ntheorem lim_const (x : \u03b2) : lim (const abv x) = x", "start": [359, 1], "end": [361, 41], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_add", "code": "theorem lim_add (f g : CauSeq \u03b2 abv) : lim f + lim g = lim (f + g)", "start": [364, 1], "end": [368, 80], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_mul_lim", "code": "theorem lim_mul_lim (f g : CauSeq \u03b2 abv) : lim f * lim g = lim (f * g)", "start": [371, 1], "end": [383, 60], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_mul", "code": "theorem lim_mul (f : CauSeq \u03b2 abv) (x : \u03b2) : lim f * x = lim (f * const abv x)", "start": [386, 1], "end": [387, 32], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_neg", "code": "theorem lim_neg (f : CauSeq \u03b2 abv) : lim (-f) = -lim f", "start": [390, 1], "end": [394, 39], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_eq_zero_iff", "code": "theorem lim_eq_zero_iff (f : CauSeq \u03b2 abv) : lim f = 0 \u2194 LimZero f", "start": [397, 1], "end": [405, 35], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_inv", "code": "theorem lim_inv {f : CauSeq \u03b2 abv} (hf : \u00acLimZero f) : lim (inv f hf) = (lim f)\u207b\u00b9", "start": [414, 1], "end": [437, 79], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_le", "code": "theorem lim_le {f : CauSeq \u03b1 abs} {x : \u03b1} (h : f \u2264 CauSeq.const abs x) : lim f \u2264 x", "start": [446, 1], "end": [447, 75], "kind": "commanddeclaration"}, {"full_name": "CauSeq.le_lim", "code": "theorem le_lim {f : CauSeq \u03b1 abs} {x : \u03b1} (h : CauSeq.const abs x \u2264 f) : x \u2264 lim f", "start": [450, 1], "end": [451, 61], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lt_lim", "code": "theorem lt_lim {f : CauSeq \u03b1 abs} {x : \u03b1} (h : CauSeq.const abs x < f) : x < lim f", "start": [454, 1], "end": [455, 61], "kind": "commanddeclaration"}, {"full_name": "CauSeq.lim_lt", "code": "theorem lim_lt {f : CauSeq \u03b1 abs} {x : \u03b1} (h : f < CauSeq.const abs x) : lim f < x", "start": [458, 1], "end": [459, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Bounds.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/Bounds/OrderIso.lean", "Mathlib/Algebra/Order/Group/OrderIso.lean", "Mathlib/Algebra/Order/Monoid/OrderDual.lean", "Mathlib/Data/Set/Pointwise/Basic.lean"], "premises": [{"full_name": "bddAbove_inv", "code": "@[to_additive (attr := simp)]\ntheorem bddAbove_inv : BddAbove s\u207b\u00b9 \u2194 BddBelow s", "start": [31, 1], "end": [33, 37], "kind": "commanddeclaration"}, {"full_name": "bddBelow_inv", "code": "@[to_additive (attr := simp)]\ntheorem bddBelow_inv : BddBelow s\u207b\u00b9 \u2194 BddAbove s", "start": [37, 1], "end": [39, 37], "kind": "commanddeclaration"}, {"full_name": "BddAbove.inv", "code": "@[to_additive]\ntheorem BddAbove.inv (h : BddAbove s) : BddBelow s\u207b\u00b9", "start": [43, 1], "end": [45, 19], "kind": "commanddeclaration"}, {"full_name": "BddBelow.inv", "code": "@[to_additive]\ntheorem BddBelow.inv (h : BddBelow s) : BddAbove s\u207b\u00b9", "start": [49, 1], "end": [51, 19], "kind": "commanddeclaration"}, {"full_name": "isLUB_inv", "code": "@[to_additive (attr := simp)]\ntheorem isLUB_inv : IsLUB s\u207b\u00b9 a \u2194 IsGLB s a\u207b\u00b9", "start": [55, 1], "end": [57, 34], "kind": "commanddeclaration"}, {"full_name": "isLUB_inv'", "code": "@[to_additive]\ntheorem isLUB_inv' : IsLUB s\u207b\u00b9 a\u207b\u00b9 \u2194 IsGLB s a", "start": [61, 1], "end": [63, 35], "kind": "commanddeclaration"}, {"full_name": "IsGLB.inv", "code": "@[to_additive]\ntheorem IsGLB.inv (h : IsGLB s a) : IsLUB s\u207b\u00b9 a\u207b\u00b9", "start": [67, 1], "end": [69, 17], "kind": "commanddeclaration"}, {"full_name": "isGLB_inv", "code": "@[to_additive (attr := simp)]\ntheorem isGLB_inv : IsGLB s\u207b\u00b9 a \u2194 IsLUB s a\u207b\u00b9", "start": [73, 1], "end": [75, 34], "kind": "commanddeclaration"}, {"full_name": "isGLB_inv'", "code": "@[to_additive]\ntheorem isGLB_inv' : IsGLB s\u207b\u00b9 a\u207b\u00b9 \u2194 IsLUB s a", "start": [79, 1], "end": [81, 35], "kind": "commanddeclaration"}, {"full_name": "IsLUB.inv", "code": "@[to_additive]\ntheorem IsLUB.inv (h : IsLUB s a) : IsGLB s\u207b\u00b9 a\u207b\u00b9", "start": [85, 1], "end": [87, 17], "kind": "commanddeclaration"}, {"full_name": "mul_mem_upperBounds_mul", "code": "@[to_additive]\ntheorem mul_mem_upperBounds_mul {s t : Set M} {a b : M} (ha : a \u2208 upperBounds s)\n    (hb : b \u2208 upperBounds t) : a * b \u2208 upperBounds (s * t)", "start": [98, 1], "end": [101, 67], "kind": "commanddeclaration"}, {"full_name": "subset_upperBounds_mul", "code": "@[to_additive]\ntheorem subset_upperBounds_mul (s t : Set M) :\n    upperBounds s * upperBounds t \u2286 upperBounds (s * t)", "start": [105, 1], "end": [108, 69], "kind": "commanddeclaration"}, {"full_name": "mul_mem_lowerBounds_mul", "code": "@[to_additive]\ntheorem mul_mem_lowerBounds_mul {s t : Set M} {a b : M} (ha : a \u2208 lowerBounds s)\n    (hb : b \u2208 lowerBounds t) : a * b \u2208 lowerBounds (s * t)", "start": [112, 1], "end": [115, 53], "kind": "commanddeclaration"}, {"full_name": "subset_lowerBounds_mul", "code": "@[to_additive]\ntheorem subset_lowerBounds_mul (s t : Set M) :\n    lowerBounds s * lowerBounds t \u2286 lowerBounds (s * t)", "start": [119, 1], "end": [122, 42], "kind": "commanddeclaration"}, {"full_name": "BddAbove.mul", "code": "@[to_additive]\ntheorem BddAbove.mul {s t : Set M} (hs : BddAbove s) (ht : BddAbove t) : BddAbove (s * t)", "start": [126, 1], "end": [128, 57], "kind": "commanddeclaration"}, {"full_name": "BddBelow.mul", "code": "@[to_additive]\ntheorem BddBelow.mul {s t : Set M} (hs : BddBelow s) (ht : BddBelow t) : BddBelow (s * t)", "start": [132, 1], "end": [134, 57], "kind": "commanddeclaration"}, {"full_name": "ciSup_mul", "code": "@[to_additive]\ntheorem ciSup_mul (hf : BddAbove (Set.range f)) (a : G) : (\u2a06 i, f i) * a = \u2a06 i, f i * a", "start": [147, 1], "end": [149, 37], "kind": "commanddeclaration"}, {"full_name": "ciSup_div", "code": "@[to_additive]\ntheorem ciSup_div (hf : BddAbove (Set.range f)) (a : G) : (\u2a06 i, f i) / a = \u2a06 i, f i / a", "start": [153, 1], "end": [155, 43], "kind": "commanddeclaration"}, {"full_name": "mul_ciSup", "code": "@[to_additive]\ntheorem mul_ciSup (hf : BddAbove (Set.range f)) (a : G) : (a * \u2a06 i, f i) = \u2a06 i, a * f i", "start": [166, 1], "end": [168, 36], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/SMul.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Algebra/Module/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Algebra/Module/Pi.lean", "Mathlib/Algebra/Order/Pi.lean", "Mathlib/Algebra/Order/Monoid/Prod.lean"], "premises": [{"full_name": "OrderedSMul", "code": "class OrderedSMul (R M : Type*) [OrderedSemiring R] [OrderedAddCommMonoid M] [SMulWithZero R M] :\n  Prop where\n  \n  protected smul_lt_smul_of_pos : \u2200 {a b : M}, \u2200 {c : R}, a < b \u2192 0 < c \u2192 c \u2022 a < c \u2022 b\n  \n  protected lt_of_smul_lt_smul_of_pos : \u2200 {a b : M}, \u2200 {c : R}, c \u2022 a < c \u2022 b \u2192 0 < c \u2192 a < b", "start": [45, 1], "end": [53, 94], "kind": "commanddeclaration"}, {"full_name": "OrderDual.OrderDual.instSMulWithZero", "code": "instance OrderDual.instSMulWithZero [Zero R] [AddZeroClass M] [SMulWithZero R M] :\n    SMulWithZero R M\u1d52\u1d48 :=\n  { OrderDual.instSMul with\n    zero_smul := fun m => OrderDual.rec (zero_smul _) m\n    smul_zero := fun r => OrderDual.rec (@smul_zero R M _ _) r }", "start": [60, 1], "end": [64, 65], "kind": "commanddeclaration"}, {"full_name": "OrderDual.OrderDual.instMulAction", "code": "instance OrderDual.instMulAction [Monoid R] [MulAction R M] : MulAction R M\u1d52\u1d48 :=\n  { OrderDual.instSMul with\n    one_smul := fun m => OrderDual.rec (one_smul _) m\n    mul_smul := fun r => OrderDual.rec (@mul_smul R M _ _) r }", "start": [66, 1], "end": [69, 63], "kind": "commanddeclaration"}, {"full_name": "smul_lt_smul_of_pos", "code": "@[gcongr] theorem smul_lt_smul_of_pos : a < b \u2192 0 < c \u2192 c \u2022 a < c \u2022 b", "start": [90, 1], "end": [91, 34], "kind": "commanddeclaration"}, {"full_name": "smul_le_smul_of_nonneg", "code": "@[gcongr] theorem smul_le_smul_of_nonneg (h\u2081 : a \u2264 b) (h\u2082 : 0 \u2264 c) : c \u2022 a \u2264 c \u2022 b", "start": [94, 1], "end": [99, 44], "kind": "commanddeclaration"}, {"full_name": "smul_nonneg", "code": "theorem smul_nonneg (hc : 0 \u2264 c) (ha : 0 \u2264 a) : 0 \u2264 c \u2022 a", "start": [102, 1], "end": [105, 46], "kind": "commanddeclaration"}, {"full_name": "smul_nonpos_of_nonneg_of_nonpos", "code": "theorem smul_nonpos_of_nonneg_of_nonpos (hc : 0 \u2264 c) (ha : a \u2264 0) : c \u2022 a \u2264 0", "start": [108, 1], "end": [109, 39], "kind": "commanddeclaration"}, {"full_name": "eq_of_smul_eq_smul_of_pos_of_le", "code": "theorem eq_of_smul_eq_smul_of_pos_of_le (h\u2081 : c \u2022 a = c \u2022 b) (hc : 0 < c) (hle : a \u2264 b) : a = b", "start": [112, 1], "end": [113, 74], "kind": "commanddeclaration"}, {"full_name": "lt_of_smul_lt_smul_of_nonneg", "code": "theorem lt_of_smul_lt_smul_of_nonneg (h : c \u2022 a < c \u2022 b) (hc : 0 \u2264 c) : a < b", "start": [116, 1], "end": [119, 46], "kind": "commanddeclaration"}, {"full_name": "smul_lt_smul_iff_of_pos", "code": "theorem smul_lt_smul_iff_of_pos (hc : 0 < c) : c \u2022 a < c \u2022 b \u2194 a < b", "start": [122, 1], "end": [123, 85], "kind": "commanddeclaration"}, {"full_name": "smul_pos_iff_of_pos", "code": "theorem smul_pos_iff_of_pos (hc : 0 < c) : 0 < c \u2022 a \u2194 0 < a", "start": [126, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "smul_pos", "code": "alias \u27e8_, smul_pos\u27e9 := smul_pos_iff_of_pos", "start": [132, 1], "end": [132, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "monotone_smul_left", "code": "theorem monotone_smul_left (hc : 0 \u2264 c) : Monotone (SMul.smul c : M \u2192 M)", "start": [135, 1], "end": [136, 30], "kind": "commanddeclaration"}, {"full_name": "strictMono_smul_left", "code": "theorem strictMono_smul_left (hc : 0 < c) : StrictMono (SMul.smul c : M \u2192 M)", "start": [139, 1], "end": [140, 27], "kind": "commanddeclaration"}, {"full_name": "smul_lowerBounds_subset_lowerBounds_smul", "code": "theorem smul_lowerBounds_subset_lowerBounds_smul (hc : 0 \u2264 c) :\n    c \u2022 lowerBounds s \u2286 lowerBounds (c \u2022 s)", "start": [143, 1], "end": [145, 69], "kind": "commanddeclaration"}, {"full_name": "smul_upperBounds_subset_upperBounds_smul", "code": "theorem smul_upperBounds_subset_upperBounds_smul (hc : 0 \u2264 c) :\n    c \u2022 upperBounds s \u2286 upperBounds (c \u2022 s)", "start": [148, 1], "end": [150, 69], "kind": "commanddeclaration"}, {"full_name": "BddBelow.smul_of_nonneg", "code": "theorem BddBelow.smul_of_nonneg (hs : BddBelow s) (hc : 0 \u2264 c) : BddBelow (c \u2022 s)", "start": [153, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "BddAbove.smul_of_nonneg", "code": "theorem BddAbove.smul_of_nonneg (hs : BddAbove s) (hc : 0 \u2264 c) : BddAbove (c \u2022 s)", "start": [157, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "OrderedSMul.mk''", "code": "theorem OrderedSMul.mk'' [OrderedSemiring \ud835\udd5c] [LinearOrderedAddCommMonoid M] [SMulWithZero \ud835\udd5c M]\n    (h : \u2200 \u2983c : \ud835\udd5c\u2984, 0 < c \u2192 StrictMono fun a : M => c \u2022 a) : OrderedSMul \ud835\udd5c M", "start": [163, 1], "end": [168, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.orderedSMul", "code": "instance Nat.orderedSMul [LinearOrderedCancelAddCommMonoid M] : OrderedSMul \u2115 M :=\n  OrderedSMul.mk'' fun n hn a b hab => by\n    cases n with\n    | zero => cases hn\n    | succ n =>\n      induction n with\n      | zero => dsimp; rwa [one_nsmul, one_nsmul]\n      | succ n ih => simp only [succ_nsmul _ n.succ, _root_.add_lt_add hab (ih n.succ_pos)]", "start": [171, 1], "end": [178, 92], "kind": "commanddeclaration"}, {"full_name": "Int.orderedSMul", "code": "instance Int.orderedSMul [LinearOrderedAddCommGroup M] : OrderedSMul \u2124 M :=\n  OrderedSMul.mk'' fun n hn => by\n    cases n\n    \u00b7 simp only [Int.ofNat_eq_coe, Int.coe_nat_pos, coe_nat_zsmul] at hn \u22a2\n      exact strictMono_smul_left hn\n    \u00b7 cases (Int.negSucc_not_pos _).1 hn", "start": [181, 1], "end": [186, 41], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemiring.toOrderedSMul", "code": "instance LinearOrderedSemiring.toOrderedSMul : OrderedSMul R R :=\n  OrderedSMul.mk'' fun _ => strictMono_mul_left_of_pos", "start": [194, 1], "end": [195, 55], "kind": "commanddeclaration"}, {"full_name": "smul_max", "code": "theorem smul_max (ha : 0 \u2264 a) (b\u2081 b\u2082 : M) : a \u2022 max b\u2081 b\u2082 = max (a \u2022 b\u2081) (a \u2022 b\u2082)", "start": [198, 1], "end": [199, 57], "kind": "commanddeclaration"}, {"full_name": "smul_min", "code": "theorem smul_min (ha : 0 \u2264 a) (b\u2081 b\u2082 : M) : a \u2022 min b\u2081 b\u2082 = min (a \u2022 b\u2081) (a \u2022 b\u2082)", "start": [202, 1], "end": [203, 57], "kind": "commanddeclaration"}, {"full_name": "OrderedSMul.mk'", "code": "theorem OrderedSMul.mk' (h : \u2200 \u2983a b : M\u2984 \u2983c : \ud835\udd5c\u2984, a < b \u2192 0 < c \u2192 c \u2022 a \u2264 c \u2022 b) :\n    OrderedSMul \ud835\udd5c M", "start": [213, 1], "end": [226, 37], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedSMul", "code": "instance Pi.orderedSMul {M : \u03b9 \u2192 Type*} [\u2200 i, OrderedAddCommMonoid (M i)]\n    [\u2200 i, MulActionWithZero \ud835\udd5c (M i)] [\u2200 i, OrderedSMul \ud835\udd5c (M i)] : OrderedSMul \ud835\udd5c (\u2200 i, M i) :=\n  OrderedSMul.mk' fun _ _ _ h hc i => smul_le_smul_of_nonneg (h.le i) hc.le", "start": [233, 1], "end": [235, 76], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedSMul'", "code": "instance Pi.orderedSMul' [OrderedSMul \ud835\udd5c M] : OrderedSMul \ud835\udd5c (\u03b9 \u2192 M) :=\n  Pi.orderedSMul", "start": [240, 1], "end": [241, 17], "kind": "commanddeclaration"}, {"full_name": "Pi.orderedSMul''", "code": "instance Pi.orderedSMul'' : OrderedSMul \ud835\udd5c (\u03b9 \u2192 \ud835\udd5c) :=\n  @Pi.orderedSMul' \u03b9 \ud835\udd5c \ud835\udd5c _ _ _ _", "start": [245, 1], "end": [246, 33], "kind": "commanddeclaration"}, {"full_name": "smul_le_smul_iff_of_pos", "code": "theorem smul_le_smul_iff_of_pos (hc : 0 < c) : c \u2022 a \u2264 c \u2022 b \u2194 a \u2264 b", "start": [251, 1], "end": [255, 45], "kind": "commanddeclaration"}, {"full_name": "inv_smul_le_iff", "code": "theorem inv_smul_le_iff (h : 0 < c) : c\u207b\u00b9 \u2022 a \u2264 b \u2194 a \u2264 c \u2022 b", "start": [258, 1], "end": [259, 57], "kind": "commanddeclaration"}, {"full_name": "inv_smul_lt_iff", "code": "theorem inv_smul_lt_iff (h : 0 < c) : c\u207b\u00b9 \u2022 a < b \u2194 a < c \u2022 b", "start": [262, 1], "end": [263, 57], "kind": "commanddeclaration"}, {"full_name": "le_inv_smul_iff", "code": "theorem le_inv_smul_iff (h : 0 < c) : a \u2264 c\u207b\u00b9 \u2022 b \u2194 c \u2022 a \u2264 b", "start": [266, 1], "end": [267, 57], "kind": "commanddeclaration"}, {"full_name": "lt_inv_smul_iff", "code": "theorem lt_inv_smul_iff (h : 0 < c) : a < c\u207b\u00b9 \u2022 b \u2194 c \u2022 a < b", "start": [270, 1], "end": [271, 57], "kind": "commanddeclaration"}, {"full_name": "OrderIso.smulLeft", "code": "@[simps]\ndef OrderIso.smulLeft (hc : 0 < c) : M \u2243o M where\n  toFun b := c \u2022 b\n  invFun b := c\u207b\u00b9 \u2022 b\n  left_inv := inv_smul_smul\u2080 hc.ne'\n  right_inv := smul_inv_smul\u2080 hc.ne'\n  map_rel_iff' := smul_le_smul_iff_of_pos hc", "start": [276, 1], "end": [283, 45], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_smul_of_pos", "code": "@[simp]\ntheorem lowerBounds_smul_of_pos (hc : 0 < c) : lowerBounds (c \u2022 s) = c \u2022 lowerBounds s", "start": [290, 1], "end": [292, 45], "kind": "commanddeclaration"}, {"full_name": "upperBounds_smul_of_pos", "code": "@[simp]\ntheorem upperBounds_smul_of_pos (hc : 0 < c) : upperBounds (c \u2022 s) = c \u2022 upperBounds s", "start": [295, 1], "end": [297, 45], "kind": "commanddeclaration"}, {"full_name": "bddBelow_smul_iff_of_pos", "code": "@[simp]\ntheorem bddBelow_smul_iff_of_pos (hc : 0 < c) : BddBelow (c \u2022 s) \u2194 BddBelow s", "start": [300, 1], "end": [302, 42], "kind": "commanddeclaration"}, {"full_name": "bddAbove_smul_iff_of_pos", "code": "@[simp]\ntheorem bddAbove_smul_iff_of_pos (hc : 0 < c) : BddAbove (c \u2022 s) \u2194 BddAbove s", "start": [305, 1], "end": [307, 42], "kind": "commanddeclaration"}, {"full_name": "Tactic.smul_nonneg_of_pos_of_nonneg", "code": "private theorem smul_nonneg_of_pos_of_nonneg (ha : 0 < a) (hb : 0 \u2264 b) : 0 \u2264 a \u2022 b", "start": [319, 1], "end": [320, 23], "kind": "commanddeclaration"}, {"full_name": "Tactic.smul_nonneg_of_nonneg_of_pos", "code": "private theorem smul_nonneg_of_nonneg_of_pos (ha : 0 \u2264 a) (hb : 0 < b) : 0 \u2264 a \u2022 b", "start": [322, 1], "end": [323, 23], "kind": "commanddeclaration"}, {"full_name": "Tactic.smul_ne_zero_of_pos_of_ne_zero", "code": "private theorem smul_ne_zero_of_pos_of_ne_zero [Preorder R] (ha : 0 < a) (hb : b \u2260 0) : a \u2022 b \u2260 0", "start": [331, 1], "end": [332, 25], "kind": "commanddeclaration"}, {"full_name": "Tactic.smul_ne_zero_of_ne_zero_of_pos", "code": "private theorem smul_ne_zero_of_ne_zero_of_pos [Preorder M] (ha : a \u2260 0) (hb : 0 < b) : a \u2022 b \u2260 0", "start": [334, 1], "end": [335, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/CompleteLatticeIntervals.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Order/LatticeIntervals.lean", "Mathlib/Data/Set/Intervals/OrdConnected.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "subsetSupSet", "code": "noncomputable def subsetSupSet [Inhabited s] : SupSet s where\n  sSup t :=\n    if ht : t.Nonempty \u2227 BddAbove t \u2227 sSup ((\u2191) '' t : Set \u03b1) \u2208 s\n    then \u27e8sSup ((\u2191) '' t : Set \u03b1), ht.2.2\u27e9\n    else default", "start": [36, 1], "end": [43, 17], "kind": "commanddeclaration"}, {"full_name": "subset_sSup_def", "code": "@[simp]\ntheorem subset_sSup_def [Inhabited s] :\n    @sSup s _ = fun t =>\n      if ht : t.Nonempty \u2227 BddAbove t \u2227 sSup ((\u2191) '' t : Set \u03b1) \u2208 s\n      then \u27e8sSup ((\u2191) '' t : Set \u03b1), ht.2.2\u27e9\n      else default", "start": [48, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "subset_sSup_of_within", "code": "theorem subset_sSup_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddAbove t)  (h : sSup ((\u2191) '' t : Set \u03b1) \u2208 s) :\n    sSup ((\u2191) '' t : Set \u03b1) = (@sSup s _ t : \u03b1)", "start": [57, 1], "end": [59, 81], "kind": "commanddeclaration"}, {"full_name": "subset_sSup_emptyset", "code": "theorem subset_sSup_emptyset [Inhabited s] :\n    sSup (\u2205 : Set s) = default", "start": [62, 1], "end": [64, 14], "kind": "commanddeclaration"}, {"full_name": "subset_sSup_of_not_bddAbove", "code": "theorem subset_sSup_of_not_bddAbove [Inhabited s] {t : Set s} (ht : \u00acBddAbove t) :\n    sSup t = default", "start": [66, 1], "end": [68, 18], "kind": "commanddeclaration"}, {"full_name": "subsetInfSet", "code": "noncomputable def subsetInfSet [Inhabited s] : InfSet s where\n  sInf t :=\n    if ht : t.Nonempty \u2227 BddBelow t \u2227 sInf ((\u2191) '' t : Set \u03b1) \u2208 s\n    then \u27e8sInf ((\u2191) '' t : Set \u03b1), ht.2.2\u27e9\n    else default", "start": [76, 1], "end": [83, 17], "kind": "commanddeclaration"}, {"full_name": "subset_sInf_def", "code": "@[simp]\ntheorem subset_sInf_def [Inhabited s] :\n    @sInf s _ = fun t =>\n      if ht : t.Nonempty \u2227 BddBelow t \u2227 sInf ((\u2191) '' t : Set \u03b1) \u2208 s\n      then \u27e8sInf ((\u2191) '' t : Set \u03b1), ht.2.2\u27e9 else\n      default", "start": [88, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "subset_sInf_of_within", "code": "theorem subset_sInf_of_within [Inhabited s] {t : Set s}\n    (h' : t.Nonempty) (h'' : BddBelow t) (h : sInf ((\u2191) '' t : Set \u03b1) \u2208 s) :\n    sInf ((\u2191) '' t : Set \u03b1) = (@sInf s _ t : \u03b1)", "start": [97, 1], "end": [99, 81], "kind": "commanddeclaration"}, {"full_name": "subset_sInf_emptyset", "code": "theorem subset_sInf_emptyset [Inhabited s] :\n    sInf (\u2205 : Set s) = default", "start": [102, 1], "end": [104, 14], "kind": "commanddeclaration"}, {"full_name": "subset_sInf_of_not_bddBelow", "code": "theorem subset_sInf_of_not_bddBelow [Inhabited s] {t : Set s} (ht : \u00acBddBelow t) :\n    sInf t = default", "start": [106, 1], "end": [108, 18], "kind": "commanddeclaration"}, {"full_name": "subsetConditionallyCompleteLinearOrder", "code": "@[reducible]\nnoncomputable def subsetConditionallyCompleteLinearOrder [Inhabited s]\n    (h_Sup : \u2200 {t : Set s} (_ : t.Nonempty) (_h_bdd : BddAbove t), sSup ((\u2191) '' t : Set \u03b1) \u2208 s)\n    (h_Inf : \u2200 {t : Set s} (_ : t.Nonempty) (_h_bdd : BddBelow t), sInf ((\u2191) '' t : Set \u03b1) \u2208 s) :\n    ConditionallyCompleteLinearOrder s :=\n  { subsetSupSet s, subsetInfSet s, DistribLattice.toLattice, (inferInstance : LinearOrder s) with\n    le_csSup := by\n      rintro t c h_bdd hct\n      rw [\u2190 Subtype.coe_le_coe, \u2190 subset_sSup_of_within s \u27e8c, hct\u27e9 h_bdd (h_Sup \u27e8c, hct\u27e9 h_bdd)]\n      exact (Subtype.mono_coe _).le_csSup_image hct h_bdd\n    csSup_le := by\n      rintro t B ht hB\n      rw [\u2190 Subtype.coe_le_coe, \u2190 subset_sSup_of_within s ht \u27e8B, hB\u27e9 (h_Sup ht \u27e8B, hB\u27e9)]\n      exact (Subtype.mono_coe s).csSup_image_le ht hB\n    le_csInf := by\n      intro t B ht hB\n      rw [\u2190 Subtype.coe_le_coe, \u2190 subset_sInf_of_within s ht \u27e8B, hB\u27e9 (h_Inf ht \u27e8B, hB\u27e9)]\n      exact (Subtype.mono_coe s).le_csInf_image ht hB\n    csInf_le := by\n      rintro t c h_bdd hct\n      rw [\u2190 Subtype.coe_le_coe, \u2190 subset_sInf_of_within s \u27e8c, hct\u27e9 h_bdd (h_Inf \u27e8c, hct\u27e9 h_bdd)]\n      exact (Subtype.mono_coe s).csInf_image_le hct h_bdd\n    csSup_of_not_bddAbove := fun t ht \u21a6 by simp [ht]\n    csInf_of_not_bddBelow := fun t ht \u21a6 by simp [ht] }", "start": [120, 1], "end": [147, 55], "kind": "commanddeclaration"}, {"full_name": "sSup_within_of_ordConnected", "code": "theorem sSup_within_of_ordConnected {s : Set \u03b1} [hs : OrdConnected s] \u2983t : Set s\u2984 (ht : t.Nonempty)\n    (h_bdd : BddAbove t) : sSup ((\u2191) '' t : Set \u03b1) \u2208 s", "start": [150, 1], "end": [158, 58], "kind": "commanddeclaration"}, {"full_name": "sInf_within_of_ordConnected", "code": "theorem sInf_within_of_ordConnected {s : Set \u03b1} [hs : OrdConnected s] \u2983t : Set s\u2984 (ht : t.Nonempty)\n    (h_bdd : BddBelow t) : sInf ((\u2191) '' t : Set \u03b1) \u2208 s", "start": [161, 1], "end": [169, 58], "kind": "commanddeclaration"}, {"full_name": "ordConnectedSubsetConditionallyCompleteLinearOrder", "code": "noncomputable instance ordConnectedSubsetConditionallyCompleteLinearOrder [Inhabited s]\n    [OrdConnected s] : ConditionallyCompleteLinearOrder s :=\n  subsetConditionallyCompleteLinearOrder s\n    (fun h => sSup_within_of_ordConnected h)\n    (fun h => sInf_within_of_ordConnected h)", "start": [172, 1], "end": [178, 45], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.completeLattice", "code": "noncomputable def Set.Icc.completeLattice [ConditionallyCompleteLattice \u03b1]\n    {a b : \u03b1} (h : a \u2264 b) : CompleteLattice (Set.Icc a b) where\n  __ := Set.Icc.boundedOrder h\n  sSup S := if hS : S = \u2205 then \u27e8a, le_rfl, h\u27e9 else \u27e8sSup ((\u2191) '' S), by\n    rw [\u2190Set.not_nonempty_iff_eq_empty, not_not] at hS\n    refine' \u27e8_, csSup_le (hS.image (\u2191)) (fun _ \u27e8c, _, hc\u27e9 \u21a6 hc \u25b8 c.2.2)\u27e9\n    obtain \u27e8c, hc\u27e9 := hS\n    exact c.2.1.trans (le_csSup \u27e8b, fun _ \u27e8d, _, hd\u27e9 \u21a6 hd \u25b8 d.2.2\u27e9 \u27e8c, hc, rfl\u27e9)\u27e9\n  le_sSup S c hc := by\n    by_cases hS : S = \u2205 <;> simp only [hS, dite_true, dite_false]\n    \u00b7 simp [hS] at hc\n    \u00b7 exact le_csSup \u27e8b, fun _ \u27e8d, _, hd\u27e9 \u21a6 hd \u25b8 d.2.2\u27e9 \u27e8c, hc, rfl\u27e9\n  sSup_le S c hc := by\n    by_cases hS : S = \u2205 <;> simp only [hS, dite_true, dite_false]\n    \u00b7 exact c.2.1\n    \u00b7 exact csSup_le ((Set.nonempty_iff_ne_empty.mpr hS).image (\u2191))\n        (fun _ \u27e8d, h, hd\u27e9 \u21a6 hd \u25b8 hc d h)\n  sInf S := if hS : S = \u2205 then \u27e8b, h, le_rfl\u27e9 else \u27e8sInf ((\u2191) '' S), by\n    rw [\u2190Set.not_nonempty_iff_eq_empty, not_not] at hS\n    refine' \u27e8le_csInf (hS.image (\u2191)) (fun _ \u27e8c, _, hc\u27e9 \u21a6 hc \u25b8 c.2.1), _\u27e9\n    obtain \u27e8c, hc\u27e9 := hS\n    exact le_trans (csInf_le \u27e8a, fun _ \u27e8d, _, hd\u27e9 \u21a6 hd \u25b8 d.2.1\u27e9 \u27e8c, hc, rfl\u27e9) c.2.2\u27e9\n  sInf_le S c hc := by\n    by_cases hS : S = \u2205 <;> simp only [hS, dite_true, dite_false]\n    \u00b7 simp [hS] at hc\n    \u00b7 exact csInf_le \u27e8a, fun _ \u27e8d, _, hd\u27e9 \u21a6 hd \u25b8 d.2.1\u27e9 \u27e8c, hc, rfl\u27e9\n  le_sInf S c hc := by\n    by_cases hS : S = \u2205 <;> simp only [hS, dite_true, dite_false]\n    \u00b7 exact c.2.2\n    \u00b7 exact le_csInf ((Set.nonempty_iff_ne_empty.mpr hS).image (\u2191))\n        (fun _ \u27e8d, h, hd\u27e9 \u21a6 hd \u25b8 hc d h)", "start": [185, 1], "end": [216, 41], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.completeLinearOrder", "code": "noncomputable def Set.Icc.completeLinearOrder [ConditionallyCompleteLinearOrder \u03b1]\n    {a b : \u03b1} (h : a \u2264 b) : CompleteLinearOrder (Set.Icc a b) :=\n  { Set.Icc.completeLattice h, Subtype.linearOrder _ with }", "start": [218, 1], "end": [221, 60], "kind": "commanddeclaration"}, {"full_name": "Set.Icc.coe_sSup", "code": "lemma Set.Icc.coe_sSup [ConditionallyCompleteLattice \u03b1] {a b : \u03b1} (h : a \u2264 b)\n    {S : Set (Set.Icc a b)} (hS : S.Nonempty) : letI := Set.Icc.completeLattice h\n    \u2191(sSup S) = sSup ((\u2191) '' S : Set \u03b1) :=\n  congrArg Subtype.val (dif_neg hS.ne_empty)", "start": [223, 1], "end": [226, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc.coe_sInf", "code": "lemma Set.Icc.coe_sInf [ConditionallyCompleteLattice \u03b1] {a b : \u03b1} (h : a \u2264 b)\n    {S : Set (Set.Icc a b)} (hS : S.Nonempty) : letI := Set.Icc.completeLattice h\n    \u2191(sInf S) = sInf ((\u2191) '' S : Set \u03b1) :=\n  congrArg Subtype.val (dif_neg hS.ne_empty)", "start": [228, 1], "end": [231, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc.coe_iSup", "code": "lemma Set.Icc.coe_iSup [ConditionallyCompleteLattice \u03b1] {a b : \u03b1} (h : a \u2264 b)\n    {\u03b9 : Sort*} [Nonempty \u03b9] {S : \u03b9 \u2192 Set.Icc a b} : letI := Set.Icc.completeLattice h\n    \u2191(iSup S) = (\u2a06 i, S i : \u03b1) :=\n  (Set.Icc.coe_sSup h (range_nonempty S)).trans (congrArg sSup (range_comp Subtype.val S).symm)", "start": [233, 1], "end": [236, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Set.Icc.coe_iInf", "code": "lemma Set.Icc.coe_iInf [ConditionallyCompleteLattice \u03b1] {a b : \u03b1} (h : a \u2264 b)\n    {\u03b9 : Sort*} [Nonempty \u03b9] {S : \u03b9 \u2192 Set.Icc a b} : letI := Set.Icc.completeLattice h\n    \u2191(iInf S) = (\u2a05 i, S i : \u03b1) :=\n  (Set.Icc.coe_sInf h (range_nonempty S)).trans (congrArg sInf (range_comp Subtype.val S).symm)", "start": [238, 1], "end": [241, 96], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Tactic/Group.lean", "imports": ["Mathlib/Tactic/FailIfNoProgress.lean", "Mathlib/Tactic/Ring.lean", "Mathlib/Algebra/Group/Commutator.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Mathlib.Tactic.Group.zpow_trick", "code": "@[to_additive]\ntheorem zpow_trick {G : Type*} [Group G] (a b : G) (n m : \u2124) :\n    a * b ^ n * b ^ m = a * b ^ (n + m)", "start": [36, 1], "end": [38, 73], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Group.zpow_trick_one", "code": "@[to_additive]\ntheorem zpow_trick_one {G : Type*} [Group G] (a b : G) (m : \u2124) :\n    a * b * b ^ m = a * b ^ (m + 1)", "start": [42, 1], "end": [44, 72], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Tactic.Group.zpow_trick_one'", "code": "@[to_additive]\ntheorem zpow_trick_one' {G : Type*} [Group G] (a b : G) (n : \u2124) :\n    a * b ^ n * b = a * b ^ (n + 1)", "start": [48, 1], "end": [50, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Fintype/Units.lean", "imports": ["Mathlib/Data/Int/Units.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/Prod.lean", "Mathlib/Data/Fintype/Sum.lean", "Mathlib/SetTheory/Cardinal/Finite.lean"], "premises": [{"full_name": "UnitsInt.fintype", "code": "instance UnitsInt.fintype : Fintype \u2124\u02e3 :=\n  \u27e8{1, -1}, fun x \u21a6 by cases Int.units_eq_one_or x <;> simp [*]\u27e9", "start": [20, 1], "end": [21, 65], "kind": "commanddeclaration"}, {"full_name": "UnitsInt.univ", "code": "@[simp]\ntheorem UnitsInt.univ : (Finset.univ : Finset \u2124\u02e3) = {1, -1}", "start": [24, 1], "end": [25, 67], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_units_int", "code": "@[simp]\ntheorem Fintype.card_units_int : Fintype.card \u2124\u02e3 = 2", "start": [28, 1], "end": [29, 60], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_eq_card_units_add_one", "code": "theorem Fintype.card_eq_card_units_add_one [GroupWithZero \u03b1] [Fintype \u03b1] [DecidableEq \u03b1] :\n    Fintype.card \u03b1 = Fintype.card \u03b1\u02e3 + 1", "start": [37, 1], "end": [41, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.card_eq_card_units_add_one", "code": "theorem Nat.card_eq_card_units_add_one [GroupWithZero \u03b1] [Finite \u03b1] :\n    Nat.card \u03b1 = Nat.card \u03b1\u02e3 + 1", "start": [43, 1], "end": [47, 96], "kind": "commanddeclaration"}, {"full_name": "Fintype.card_units", "code": "theorem Fintype.card_units [GroupWithZero \u03b1] [Fintype \u03b1] [DecidableEq \u03b1] :\n    Fintype.card \u03b1\u02e3 = Fintype.card \u03b1 - 1", "start": [49, 1], "end": [51, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Prime.lean", "imports": ["Mathlib/Data/Nat/Factorial/Basic.lean", "Mathlib/Algebra/Parity.lean", "Mathlib/Order/Bounds/Basic.lean", "Mathlib/Data/Nat/Sqrt.lean", "Mathlib/Data/Int/Dvd/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Associated.lean", "Mathlib/Data/Nat/GCD/Basic.lean", "Mathlib/Data/Int/Units.lean"], "premises": [{"full_name": "Nat.Prime", "code": "def Prime (p : \u2115) :=\n  Irreducible p", "start": [43, 1], "end": [47, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.irreducible_iff_nat_prime", "code": "theorem irreducible_iff_nat_prime (a : \u2115) : Irreducible a \u2194 Nat.Prime a", "start": [50, 1], "end": [51, 10], "kind": "commanddeclaration"}, {"full_name": "Nat.not_prime_zero", "code": "theorem not_prime_zero : \u00acPrime 0", "start": [54, 1], "end": [55, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.not_prime_one", "code": "theorem not_prime_one : \u00acPrime 1", "start": [58, 1], "end": [59, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.ne_zero", "code": "theorem Prime.ne_zero {n : \u2115} (h : Prime n) : n \u2260 0", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pos", "code": "theorem Prime.pos {p : \u2115} (pp : Prime p) : 0 < p", "start": [66, 1], "end": [67, 32], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.two_le", "code": "theorem Prime.two_le : \u2200 {p : \u2115}, Prime p \u2192 2 \u2264 p", "start": [70, 1], "end": [73, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.one_lt", "code": "theorem Prime.one_lt {p : \u2115} : Prime p \u2192 1 < p", "start": [76, 1], "end": [77, 15], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.one_lt'", "code": "instance Prime.one_lt' (p : \u2115) [hp : Fact p.Prime] : Fact (1 < p) :=\n  \u27e8hp.1.one_lt\u27e9", "start": [80, 1], "end": [81, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.ne_one", "code": "theorem Prime.ne_one {p : \u2115} (hp : p.Prime) : p \u2260 1", "start": [84, 1], "end": [85, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.eq_one_or_self_of_dvd", "code": "theorem Prime.eq_one_or_self_of_dvd {p : \u2115} (pp : p.Prime) (m : \u2115) (hm : m \u2223 p) :\n    m = 1 \u2228 m = p", "start": [88, 1], "end": [95, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_def_lt''", "code": "theorem prime_def_lt'' {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 (m) (_ : m \u2223 p), m = 1 \u2228 m = p", "start": [98, 1], "end": [108, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_def_lt", "code": "theorem prime_def_lt {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m < p, m \u2223 p \u2192 m = 1", "start": [111, 1], "end": [116, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_def_lt'", "code": "theorem prime_def_lt' {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m, 2 \u2264 m \u2192 m < p \u2192 \u00acm \u2223 p", "start": [119, 1], "end": [129, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_def_le_sqrt", "code": "theorem prime_def_le_sqrt {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 \u2200 m, 2 \u2264 m \u2192 m \u2264 sqrt p \u2192 \u00acm \u2223 p", "start": [132, 1], "end": [143, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_of_coprime", "code": "theorem prime_of_coprime (n : \u2115) (h1 : 1 < n) (h : \u2200 m < n, m \u2260 0 \u2192 n.Coprime m) : Prime n", "start": [146, 1], "end": [152, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.decidablePrime1", "code": "@[local instance]\ndef decidablePrime1 (p : \u2115) : Decidable (Prime p) :=\n  decidable_of_iff' _ prime_def_lt'", "start": [157, 1], "end": [166, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_two", "code": "theorem prime_two : Prime 2", "start": [169, 1], "end": [169, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_three", "code": "theorem prime_three : Prime 3", "start": [172, 1], "end": [172, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.five_le_of_ne_two_of_ne_three", "code": "theorem Prime.five_le_of_ne_two_of_ne_three {p : \u2115} (hp : p.Prime) (h_two : p \u2260 2)\n    (h_three : p \u2260 3) : 5 \u2264 p", "start": [175, 1], "end": [186, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pred_pos", "code": "theorem Prime.pred_pos {p : \u2115} (pp : Prime p) : 0 < pred p", "start": [191, 1], "end": [192, 26], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_pred_prime", "code": "theorem succ_pred_prime {p : \u2115} (pp : Prime p) : succ (pred p) = p", "start": [195, 1], "end": [196, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_prime", "code": "theorem dvd_prime {p m : \u2115} (pp : Prime p) : m \u2223 p \u2194 m = 1 \u2228 m = p", "start": [199, 1], "end": [201, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_prime_two_le", "code": "theorem dvd_prime_two_le {p m : \u2115} (pp : Prime p) (H : 2 \u2264 m) : m \u2223 p \u2194 m = p", "start": [204, 1], "end": [205, 72], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_dvd_prime_iff_eq", "code": "theorem prime_dvd_prime_iff_eq {p q : \u2115} (pp : p.Prime) (qp : q.Prime) : p \u2223 q \u2194 p = q", "start": [208, 1], "end": [209, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.not_dvd_one", "code": "theorem Prime.not_dvd_one {p : \u2115} (pp : Prime p) : \u00acp \u2223 1", "start": [212, 1], "end": [213, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.not_prime_mul", "code": "theorem not_prime_mul {a b : \u2115} (a1 : 1 < a) (b1 : 1 < b) : \u00acPrime (a * b)", "start": [216, 1], "end": [218, 62], "kind": "commanddeclaration"}, {"full_name": "Nat.not_prime_mul'", "code": "theorem not_prime_mul' {a b n : \u2115} (h : a * b = n) (h\u2081 : 1 < a) (h\u2082 : 1 < b) : \u00acPrime n", "start": [221, 1], "end": [223, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_mul_iff", "code": "theorem prime_mul_iff {a b : \u2115} : Nat.Prime (a * b) \u2194 a.Prime \u2227 b = 1 \u2228 b.Prime \u2227 a = 1", "start": [226, 1], "end": [227, 93], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_iff_eq", "code": "theorem Prime.dvd_iff_eq {p a : \u2115} (hp : p.Prime) (a1 : a \u2260 1) : a \u2223 p \u2194 p = a", "start": [230, 1], "end": [238, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_lemma", "code": "theorem minFac_lemma (n k : \u2115) (h : \u00acn < k * k) : sqrt n - k < sqrt n + 2 - k", "start": [243, 1], "end": [244, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.minFacAux", "code": "def minFacAux (n : \u2115) : \u2115 \u2192 \u2115\n  | k =>\n    if h : n < k * k then n\n    else\n      if k \u2223 n then k\n      else\n        have := minFac_lemma n k h\n        minFacAux n (k + 2)\ntermination_by _ n k => sqrt n + 2 - k", "start": [247, 1], "end": [258, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac", "code": "def minFac (n : \u2115) : \u2115 :=\n  if 2 \u2223 n then 2 else minFacAux n 3", "start": [261, 1], "end": [263, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_zero", "code": "@[simp]\ntheorem minFac_zero : minFac 0 = 2", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_one", "code": "@[simp]\ntheorem minFac_one : minFac 1 = 1", "start": [271, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_eq", "code": "theorem minFac_eq (n : \u2115) : minFac n = if 2 \u2223 n then 2 else minFacAux n 3", "start": [276, 1], "end": [276, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.minFacProp", "code": "private def minFacProp (n k : \u2115) :=\n  2 \u2264 k \u2227 k \u2223 n \u2227 \u2200 m, 2 \u2264 m \u2192 m \u2223 n \u2192 k \u2264 m", "start": [279, 1], "end": [280, 45], "kind": "commanddeclaration"}, {"full_name": "Nat.minFacAux_has_prop", "code": "theorem minFacAux_has_prop {n : \u2115} (n2 : 2 \u2264 n) :\n    \u2200 k i, k = 2 * i + 3 \u2192 (\u2200 m, 2 \u2264 m \u2192 m \u2223 n \u2192 k \u2264 m) \u2192 minFacProp n (minFacAux n k)", "start": [282, 1], "end": [309, 43], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_has_prop", "code": "theorem minFac_has_prop {n : \u2115} (n1 : n \u2260 1) : minFacProp n (minFac n)", "start": [312, 1], "end": [323, 30], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_dvd", "code": "theorem minFac_dvd (n : \u2115) : minFac n \u2223 n", "start": [326, 1], "end": [327, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_prime", "code": "theorem minFac_prime {n : \u2115} (n1 : n \u2260 1) : Prime (minFac n)", "start": [330, 1], "end": [332, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_le_of_dvd", "code": "theorem minFac_le_of_dvd {n : \u2115} : \u2200 {m : \u2115}, 2 \u2264 m \u2192 m \u2223 n \u2192 minFac n \u2264 m", "start": [335, 1], "end": [337, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_pos", "code": "theorem minFac_pos (n : \u2115) : 0 < minFac n", "start": [340, 1], "end": [341, 85], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_le", "code": "theorem minFac_le {n : \u2115} (H : 0 < n) : minFac n \u2264 n", "start": [344, 1], "end": [345, 29], "kind": "commanddeclaration"}, {"full_name": "Nat.le_minFac", "code": "theorem le_minFac {m n : \u2115} : n = 1 \u2228 m \u2264 minFac n \u2194 \u2200 p, Prime p \u2192 p \u2223 n \u2192 m \u2264 p", "start": [348, 1], "end": [352, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.le_minFac'", "code": "theorem le_minFac' {m n : \u2115} : n = 1 \u2228 m \u2264 minFac n \u2194 \u2200 p, 2 \u2264 p \u2192 p \u2223 n \u2192 m \u2264 p", "start": [355, 1], "end": [359, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_def_minFac", "code": "theorem prime_def_minFac {p : \u2115} : Prime p \u2194 2 \u2264 p \u2227 minFac p = p", "start": [362, 1], "end": [367, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.minFac_eq", "code": "@[simp]\ntheorem Prime.minFac_eq {p : \u2115} (hp : Prime p) : minFac p = p", "start": [370, 1], "end": [372, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.decidablePrime", "code": "instance decidablePrime (p : \u2115) : Decidable (Prime p) :=\n  decidable_of_iff' _ prime_def_minFac", "start": [375, 1], "end": [383, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.not_prime_iff_minFac_lt", "code": "theorem not_prime_iff_minFac_lt {n : \u2115} (n2 : 2 \u2264 n) : \u00acPrime n \u2194 minFac n < n", "start": [386, 1], "end": [388, 84], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_le_div", "code": "theorem minFac_le_div {n : \u2115} (pos : 0 < n) (np : \u00acPrime n) : minFac n \u2264 n / minFac n", "start": [391, 1], "end": [404, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_sq_le_self", "code": "theorem minFac_sq_le_self {n : \u2115} (w : 0 < n) (h : \u00acPrime n) : minFac n ^ 2 \u2264 n", "start": [407, 1], "end": [414, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_eq_one_iff", "code": "@[simp]\ntheorem minFac_eq_one_iff {n : \u2115} : minFac n = 1 \u2194 n = 1", "start": [417, 1], "end": [426, 8], "kind": "commanddeclaration"}, {"full_name": "Nat.minFac_eq_two_iff", "code": "@[simp]\ntheorem minFac_eq_two_iff (n : \u2115) : minFac n = 2 \u2194 2 \u2223 n", "start": [429, 1], "end": [442, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_dvd_of_not_prime", "code": "theorem exists_dvd_of_not_prime {n : \u2115} (n2 : 2 \u2264 n) (np : \u00acPrime n) : \u2203 m, m \u2223 n \u2227 m \u2260 1 \u2227 m \u2260 n", "start": [447, 1], "end": [449, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_dvd_of_not_prime2", "code": "theorem exists_dvd_of_not_prime2 {n : \u2115} (n2 : 2 \u2264 n) (np : \u00acPrime n) :\n    \u2203 m, m \u2223 n \u2227 2 \u2264 m \u2227 m < n", "start": [452, 1], "end": [455, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_prime_and_dvd", "code": "theorem exists_prime_and_dvd {n : \u2115} (hn : n \u2260 1) : \u2203 p, Prime p \u2227 p \u2223 n", "start": [458, 1], "end": [459, 44], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_of_forall_prime_mul_dvd", "code": "theorem dvd_of_forall_prime_mul_dvd {a b : \u2115}\n    (hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 a \u2192 p * a \u2223 b) : a \u2223 b", "start": [462, 1], "end": [467, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.exists_infinite_primes", "code": "theorem exists_infinite_primes (n : \u2115) : \u2203 p, n \u2264 p \u2227 Prime p", "start": [470, 1], "end": [481, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.not_bddAbove_setOf_prime", "code": "theorem not_bddAbove_setOf_prime : \u00acBddAbove { p | Prime p }", "start": [484, 1], "end": [489, 20], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.eq_two_or_odd", "code": "theorem Prime.eq_two_or_odd {p : \u2115} (hp : Prime p) : p = 2 \u2228 p % 2 = 1", "start": [492, 1], "end": [494, 88], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.eq_two_or_odd'", "code": "theorem Prime.eq_two_or_odd' {p : \u2115} (hp : Prime p) : p = 2 \u2228 Odd p", "start": [497, 1], "end": [498, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.even_iff", "code": "theorem Prime.even_iff {p : \u2115} (hp : Prime p) : Even p \u2194 p = 2", "start": [501, 1], "end": [502, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.odd_of_ne_two", "code": "theorem Prime.odd_of_ne_two {p : \u2115} (hp : p.Prime) (h_two : p \u2260 2) : Odd p", "start": [505, 1], "end": [506, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.even_sub_one", "code": "theorem Prime.even_sub_one {p : \u2115} (hp : p.Prime) (h2 : p \u2260 2) : Even (p - 1)", "start": [509, 1], "end": [510, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.mod_two_eq_one_iff_ne_two", "code": "theorem Prime.mod_two_eq_one_iff_ne_two {p : \u2115} [Fact p.Prime] : p % 2 = 1 \u2194 p \u2260 2", "start": [513, 1], "end": [517, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_dvd", "code": "theorem coprime_of_dvd {m n : \u2115} (H : \u2200 k, Prime k \u2192 k \u2223 m \u2192 \u00ack \u2223 n) : Coprime m n", "start": [520, 1], "end": [526, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_dvd'", "code": "theorem coprime_of_dvd' {m n : \u2115} (H : \u2200 k, Prime k \u2192 k \u2223 m \u2192 k \u2223 n \u2192 k \u2223 1) : Coprime m n", "start": [529, 1], "end": [530, 99], "kind": "commanddeclaration"}, {"full_name": "Nat.factors_lemma", "code": "theorem factors_lemma {k} : (k + 2) / minFac (k + 2) < k + 2", "start": [533, 1], "end": [538, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.coprime_iff_not_dvd", "code": "theorem Prime.coprime_iff_not_dvd {p n : \u2115} (pp : Prime p) : Coprime p n \u2194 \u00acp \u2223 n", "start": [541, 1], "end": [543, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_iff_not_coprime", "code": "theorem Prime.dvd_iff_not_coprime {p n : \u2115} (pp : Prime p) : p \u2223 n \u2194 \u00acCoprime p n", "start": [546, 1], "end": [547, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.not_coprime_iff_dvd", "code": "theorem Prime.not_coprime_iff_dvd {m n : \u2115} : \u00acCoprime m n \u2194 \u2203 p, Prime p \u2227 p \u2223 m \u2227 p \u2223 n", "start": [550, 1], "end": [558, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_mul", "code": "theorem Prime.dvd_mul {p m n : \u2115} (pp : Prime p) : p \u2223 m * n \u2194 p \u2223 m \u2228 p \u2223 n", "start": [561, 1], "end": [563, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.not_dvd_mul", "code": "theorem Prime.not_dvd_mul {p m n : \u2115} (pp : Prime p) (Hm : \u00acp \u2223 m) (Hn : \u00acp \u2223 n) : \u00acp \u2223 m * n", "start": [566, 1], "end": [567, 38], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_iff", "code": "theorem prime_iff {p : \u2115} : p.Prime \u2194 _root_.Prime p", "start": [570, 1], "end": [571, 81], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.prime", "code": "alias \u27e8Prime.prime, _root_.Prime.nat_prime\u27e9 := prime_iff", "start": [574, 1], "end": [574, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Prime.nat_prime", "code": "alias \u27e8Prime.prime, _root_.Prime.nat_prime\u27e9 := prime_iff", "start": [574, 1], "end": [574, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Nat.irreducible_iff_prime", "code": "theorem irreducible_iff_prime {p : \u2115} : Irreducible p \u2194 _root_.Prime p", "start": [580, 1], "end": [581, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_of_dvd_pow", "code": "theorem Prime.dvd_of_dvd_pow {p m n : \u2115} (pp : Prime p) (h : p \u2223 m ^ n) : p \u2223 m", "start": [584, 1], "end": [585, 28], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_not_prime'", "code": "theorem Prime.pow_not_prime' {x n : \u2115} (hn : n \u2260 1) : \u00ac(x ^ n).Prime", "start": [588, 1], "end": [589, 37], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_not_prime", "code": "theorem Prime.pow_not_prime {x n : \u2115} (hn : 2 \u2264 n) : \u00ac(x ^ n).Prime", "start": [592, 1], "end": [593, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.eq_one_of_pow", "code": "theorem Prime.eq_one_of_pow {x n : \u2115} (h : (x ^ n).Prime) : n = 1", "start": [596, 1], "end": [597, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_eq_iff", "code": "theorem Prime.pow_eq_iff {p a k : \u2115} (hp : p.Prime) : a ^ k = p \u2194 a = p \u2227 k = 1", "start": [600, 1], "end": [603, 70], "kind": "commanddeclaration"}, {"full_name": "Nat.pow_minFac", "code": "theorem pow_minFac {n k : \u2115} (hk : k \u2260 0) : (n ^ k).minFac = n.minFac", "start": [606, 1], "end": [613, 57], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.pow_minFac", "code": "theorem Prime.pow_minFac {p k : \u2115} (hp : p.Prime) (hk : k \u2260 0) : (p ^ k).minFac = p", "start": [616, 1], "end": [617, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.mul_eq_prime_sq_iff", "code": "theorem Prime.mul_eq_prime_sq_iff {x y p : \u2115} (hp : p.Prime) (hx : x \u2260 1) (hy : y \u2260 1) :\n    x * y = p ^ 2 \u2194 x = p \u2227 y = p", "start": [620, 1], "end": [644, 12], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_factorial", "code": "theorem Prime.dvd_factorial : \u2200 {n p : \u2115} (_ : Prime p), p \u2223 n ! \u2194 p \u2264 n", "start": [647, 1], "end": [653, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.coprime_pow_of_not_dvd", "code": "theorem Prime.coprime_pow_of_not_dvd {p m a : \u2115} (pp : Prime p) (h : \u00acp \u2223 a) : Coprime a (p ^ m)", "start": [656, 1], "end": [657, 48], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_primes", "code": "theorem coprime_primes {p q : \u2115} (pp : Prime p) (pq : Prime q) : Coprime p q \u2194 p \u2260 q", "start": [660, 1], "end": [661, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_pow_primes", "code": "theorem coprime_pow_primes {p q : \u2115} (n m : \u2115) (pp : Prime p) (pq : Prime q) (h : p \u2260 q) :\n    Coprime (p ^ n) (q ^ m)", "start": [664, 1], "end": [666, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_or_dvd_of_prime", "code": "theorem coprime_or_dvd_of_prime {p} (pp : Prime p) (i : \u2115) : Coprime p i \u2228 p \u2223 i", "start": [669, 1], "end": [670, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.coprime_of_lt_prime", "code": "theorem coprime_of_lt_prime {n p} (n_pos : 0 < n) (hlt : n < p) (pp : Prime p) : Coprime p n", "start": [673, 1], "end": [674, 95], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_or_coprime_of_le_prime", "code": "theorem eq_or_coprime_of_le_prime {n p} (n_pos : 0 < n) (hle : n \u2264 p) (pp : Prime p) :\n    p = n \u2228 Coprime p n", "start": [677, 1], "end": [679, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.dvd_prime_pow", "code": "theorem dvd_prime_pow {p : \u2115} (pp : Prime p) {m i : \u2115} : i \u2223 p ^ m \u2194 \u2203 k \u2264 m, i = p ^ k", "start": [682, 1], "end": [683, 71], "kind": "commanddeclaration"}, {"full_name": "Nat.Prime.dvd_mul_of_dvd_ne", "code": "theorem Prime.dvd_mul_of_dvd_ne {p1 p2 n : \u2115} (h_neq : p1 \u2260 p2) (pp1 : Prime p1) (pp2 : Prime p2)\n    (h1 : p1 \u2223 n) (h2 : p2 \u2223 n) : p1 * p2 \u2223 n", "start": [686, 1], "end": [688, 75], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_prime_pow_of_dvd_least_prime_pow", "code": "theorem eq_prime_pow_of_dvd_least_prime_pow {a p k : \u2115} (pp : Prime p) (h\u2081 : \u00aca \u2223 p ^ k)\n    (h\u2082 : a \u2223 p ^ (k + 1)) : a = p ^ (k + 1)", "start": [691, 1], "end": [699, 97], "kind": "commanddeclaration"}, {"full_name": "Nat.ne_one_iff_exists_prime_dvd", "code": "theorem ne_one_iff_exists_prime_dvd : \u2200 {n}, n \u2260 1 \u2194 \u2203 p : \u2115, p.Prime \u2227 p \u2223 n", "start": [702, 1], "end": [709, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.eq_one_iff_not_exists_prime_dvd", "code": "theorem eq_one_iff_not_exists_prime_dvd {n : \u2115} : n = 1 \u2194 \u2200 p : \u2115, p.Prime \u2192 \u00acp \u2223 n", "start": [712, 1], "end": [713, 58], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul", "code": "theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul {p : \u2115} (p_prime : Prime p) {m n k l : \u2115}\n    (hpm : p ^ k \u2223 m) (hpn : p ^ l \u2223 n) (hpmn : p ^ (k + l + 1) \u2223 m * n) :\n    p ^ (k + 1) \u2223 m \u2228 p ^ (l + 1) \u2223 n", "start": [716, 1], "end": [729, 64], "kind": "commanddeclaration"}, {"full_name": "Nat.prime_iff_prime_int", "code": "theorem prime_iff_prime_int {p : \u2115} : p.Prime \u2194 _root_.Prime (p : \u2124)", "start": [732, 1], "end": [741, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes", "code": "def Primes :=\n  { p : \u2115 // p.Prime }\n  deriving DecidableEq", "start": [744, 1], "end": [747, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.inhabitedPrimes", "code": "instance inhabitedPrimes : Inhabited Primes :=\n  \u27e8\u27e82, prime_two\u27e9\u27e9", "start": [755, 1], "end": [756, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.coeNat", "code": "instance coeNat : Coe Nat.Primes \u2115 :=\n  \u27e8Subtype.val\u27e9", "start": [759, 1], "end": [760, 16], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.coe_nat_injective", "code": "theorem coe_nat_injective : Function.Injective (fun (a : Nat.Primes) \u21a6 (a : \u2115))", "start": [764, 1], "end": [765, 24], "kind": "commanddeclaration"}, {"full_name": "Nat.Primes.coe_nat_inj", "code": "theorem coe_nat_inj (p q : Nat.Primes) : (p : \u2115) = (q : \u2115) \u2194 p = q", "start": [768, 1], "end": [769, 23], "kind": "commanddeclaration"}, {"full_name": "Nat.monoid.primePow", "code": "instance monoid.primePow {\u03b1 : Type*} [Monoid \u03b1] : Pow \u03b1 Primes :=\n  \u27e8fun x p => x ^ (p : \u2115)\u27e9", "start": [774, 1], "end": [775, 27], "kind": "commanddeclaration"}, {"full_name": "Nat.fact_prime_two", "code": "instance fact_prime_two : Fact (Prime 2) :=\n  \u27e8prime_two\u27e9", "start": [782, 1], "end": [783, 14], "kind": "commanddeclaration"}, {"full_name": "Nat.fact_prime_three", "code": "instance fact_prime_three : Fact (Prime 3) :=\n  \u27e8prime_three\u27e9", "start": [786, 1], "end": [787, 16], "kind": "commanddeclaration"}, {"full_name": "Int.prime_two", "code": "theorem prime_two : Prime (2 : \u2124)", "start": [794, 1], "end": [795, 43], "kind": "commanddeclaration"}, {"full_name": "Int.prime_three", "code": "theorem prime_three : Prime (3 : \u2124)", "start": [798, 1], "end": [799, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/List/Cycle.lean", "imports": ["Mathlib/Data/List/Rotate.lean", "Mathlib/Data/Multiset/Sort.lean", "Mathlib/Data/Fintype/List.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.nextOr", "code": "def nextOr : \u2200 (_ : List \u03b1) (_ _ : \u03b1), \u03b1\n  | [], _, default => default\n  | [_], _, default => default\n  | y :: z :: xs, x, default => if x = y then z else nextOr (z :: xs) x default", "start": [32, 1], "end": [37, 80], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_nil", "code": "@[simp]\ntheorem nextOr_nil (x d : \u03b1) : nextOr [] x d = d", "start": [40, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_singleton", "code": "@[simp]\ntheorem nextOr_singleton (x y d : \u03b1) : nextOr [y] x d = d", "start": [45, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_self_cons_cons", "code": "@[simp]\ntheorem nextOr_self_cons_cons (xs : List \u03b1) (x y d : \u03b1) : nextOr (x :: y :: xs) x d = y", "start": [50, 1], "end": [52, 13], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_cons_of_ne", "code": "theorem nextOr_cons_of_ne (xs : List \u03b1) (y x d : \u03b1) (h : x \u2260 y) :\n    nextOr (y :: xs) x d = nextOr xs x d", "start": [55, 1], "end": [59, 19], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_eq_nextOr_of_mem_of_ne", "code": "theorem nextOr_eq_nextOr_of_mem_of_ne (xs : List \u03b1) (x d d' : \u03b1) (x_mem : x \u2208 xs)\n    (x_ne : x \u2260 xs.getLast (ne_nil_of_mem x_mem)) : nextOr xs x d = nextOr xs x d'", "start": [62, 1], "end": [74, 23], "kind": "commanddeclaration"}, {"full_name": "List.mem_of_nextOr_ne", "code": "theorem mem_of_nextOr_ne {xs : List \u03b1} {x d : \u03b1} (h : nextOr xs x d \u2260 d) : x \u2208 xs", "start": [77, 1], "end": [85, 28], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_concat", "code": "theorem nextOr_concat {xs : List \u03b1} {x : \u03b1} (d : \u03b1) (h : x \u2209 xs) : nextOr (xs ++ [x]) x d = d", "start": [88, 1], "end": [92, 59], "kind": "commanddeclaration"}, {"full_name": "List.nextOr_mem", "code": "theorem nextOr_mem {xs : List \u03b1} {x d : \u03b1} (hd : d \u2208 xs) : nextOr xs x d \u2208 xs", "start": [95, 1], "end": [107, 53], "kind": "commanddeclaration"}, {"full_name": "List.next", "code": "def next (l : List \u03b1) (x : \u03b1) (h : x \u2208 l) : \u03b1 :=\n  nextOr l x (l.get \u27e80, length_pos_of_mem h\u27e9)", "start": [110, 1], "end": [122, 46], "kind": "commanddeclaration"}, {"full_name": "List.prev", "code": "def prev : \u2200 (l : List \u03b1) (x : \u03b1) (_h : x \u2208 l), \u03b1\n  | [], _, h => by simp at h\n  | [y], _, _ => y\n  | y :: z :: xs, x, h =>\n    if hx : x = y then getLast (z :: xs) (cons_ne_nil _ _)\n    else if x = z then y else prev (z :: xs) x (by simpa [hx] using h)", "start": [125, 1], "end": [140, 71], "kind": "commanddeclaration"}, {"full_name": "List.next_singleton", "code": "@[simp]\ntheorem next_singleton (x y : \u03b1) (h : x \u2208 [y]) : next [y] x h = y", "start": [145, 1], "end": [147, 6], "kind": "commanddeclaration"}, {"full_name": "List.prev_singleton", "code": "@[simp]\ntheorem prev_singleton (x y : \u03b1) (h : x \u2208 [y]) : prev [y] x h = y", "start": [150, 1], "end": [152, 6], "kind": "commanddeclaration"}, {"full_name": "List.next_cons_cons_eq'", "code": "theorem next_cons_cons_eq' (y z : \u03b1) (h : x \u2208 y :: z :: l) (hx : x = y) :\n    next (y :: z :: l) x h = z", "start": [155, 1], "end": [156, 66], "kind": "commanddeclaration"}, {"full_name": "List.next_cons_cons_eq", "code": "@[simp]\ntheorem next_cons_cons_eq (z : \u03b1) (h : x \u2208 x :: z :: l) : next (x :: z :: l) x h = z", "start": [159, 1], "end": [161, 35], "kind": "commanddeclaration"}, {"full_name": "List.next_ne_head_ne_getLast", "code": "theorem next_ne_head_ne_getLast (h : x \u2208 l) (y : \u03b1) (h : x \u2208 y :: l) (hy : x \u2260 y)\n    (hx : x \u2260 getLast (y :: l) (cons_ne_nil _ _)) :\n    next (y :: l) x h = next l x (by simpa [hy] using h)", "start": [164, 1], "end": [170, 29], "kind": "commanddeclaration"}, {"full_name": "List.next_cons_concat", "code": "theorem next_cons_concat (y : \u03b1) (hy : x \u2260 y) (hx : x \u2209 l)\n    (h : x \u2208 y :: l ++ [x] := mem_append_right _ (mem_singleton_self x)) :\n    next (y :: l ++ [x]) x h = y", "start": [173, 1], "end": [178, 18], "kind": "commanddeclaration"}, {"full_name": "List.next_getLast_cons", "code": "theorem next_getLast_cons (h : x \u2208 l) (y : \u03b1) (h : x \u2208 y :: l) (hy : x \u2260 y)\n    (hx : x = getLast (y :: l) (cons_ne_nil _ _)) (hl : Nodup l) : next (y :: l) x h = y", "start": [181, 1], "end": [204, 19], "kind": "commanddeclaration"}, {"full_name": "List.prev_getLast_cons'", "code": "theorem prev_getLast_cons' (y : \u03b1) (hxy : x \u2208 y :: l) (hx : x = y) :\n    prev (y :: l) x hxy = getLast (y :: l) (cons_ne_nil _ _)", "start": [207, 1], "end": [208, 95], "kind": "commanddeclaration"}, {"full_name": "List.prev_getLast_cons", "code": "@[simp]\ntheorem prev_getLast_cons (h : x \u2208 x :: l) :\n    prev (x :: l) x h = getLast (x :: l) (cons_ne_nil _ _)", "start": [211, 1], "end": [214, 33], "kind": "commanddeclaration"}, {"full_name": "List.prev_cons_cons_eq'", "code": "theorem prev_cons_cons_eq' (y z : \u03b1) (h : x \u2208 y :: z :: l) (hx : x = y) :\n    prev (y :: z :: l) x h = getLast (z :: l) (cons_ne_nil _ _)", "start": [217, 1], "end": [218, 92], "kind": "commanddeclaration"}, {"full_name": "List.prev_cons_cons_eq", "code": "theorem prev_cons_cons_eq (z : \u03b1) (h : x \u2208 x :: z :: l) :\n    prev (x :: z :: l) x h = getLast (z :: l) (cons_ne_nil _ _)", "start": [222, 1], "end": [224, 35], "kind": "commanddeclaration"}, {"full_name": "List.prev_cons_cons_of_ne'", "code": "theorem prev_cons_cons_of_ne' (y z : \u03b1) (h : x \u2208 y :: z :: l) (hy : x \u2260 y) (hz : x = z) :\n    prev (y :: z :: l) x h = y", "start": [227, 1], "end": [231, 37], "kind": "commanddeclaration"}, {"full_name": "List.prev_cons_cons_of_ne", "code": "theorem prev_cons_cons_of_ne (y : \u03b1) (h : x \u2208 y :: x :: l) (hy : x \u2260 y) :\n    prev (y :: x :: l) x h = y", "start": [234, 1], "end": [236, 41], "kind": "commanddeclaration"}, {"full_name": "List.prev_ne_cons_cons", "code": "theorem prev_ne_cons_cons (y z : \u03b1) (h : x \u2208 y :: z :: l) (hy : x \u2260 y) (hz : x \u2260 z) :\n    prev (y :: z :: l) x h = prev (z :: l) x (by simpa [hy] using h)", "start": [239, 1], "end": [243, 37], "kind": "commanddeclaration"}, {"full_name": "List.next_mem", "code": "theorem next_mem (h : x \u2208 l) : l.next x h \u2208 l", "start": [246, 1], "end": [247, 29], "kind": "commanddeclaration"}, {"full_name": "List.prev_mem", "code": "theorem prev_mem (h : x \u2208 l) : l.prev x h \u2208 l", "start": [250, 1], "end": [261, 41], "kind": "commanddeclaration"}, {"full_name": "List.next_get", "code": "theorem next_get : \u2200 (l : List \u03b1) (_h : Nodup l) (i : Fin l.length),\n    next l (l.get i) (get_mem _ _ _) = l.get \u27e8(i + 1) % l.length,\n      Nat.mod_lt _ (i.1.zero_le.trans_lt i.2)\u27e9", "start": [265, 1], "end": [303, 48], "kind": "commanddeclaration"}, {"full_name": "List.next_nthLe", "code": "@[deprecated next_get]\ntheorem next_nthLe (l : List \u03b1) (h : Nodup l) (n : \u2115) (hn : n < l.length) :\n    next l (l.nthLe n hn) (nthLe_mem _ _ _) =\n      l.nthLe ((n + 1) % l.length) (Nat.mod_lt _ (n.zero_le.trans_lt hn))", "start": [306, 1], "end": [310, 23], "kind": "commanddeclaration"}, {"full_name": "List.prev_nthLe", "code": "theorem prev_nthLe (l : List \u03b1) (h : Nodup l) (n : \u2115) (hn : n < l.length) :\n    prev l (l.nthLe n hn) (nthLe_mem _ _ _) =\n      l.nthLe ((n + (l.length - 1)) % l.length) (Nat.mod_lt _ (n.zero_le.trans_lt hn))", "start": [314, 1], "end": [353, 22], "kind": "commanddeclaration"}, {"full_name": "List.pmap_next_eq_rotate_one", "code": "theorem pmap_next_eq_rotate_one (h : Nodup l) : (l.pmap l.next fun _ h => h) = l.rotate 1", "start": [357, 1], "end": [361, 50], "kind": "commanddeclaration"}, {"full_name": "List.pmap_prev_eq_rotate_length_sub_one", "code": "theorem pmap_prev_eq_rotate_length_sub_one (h : Nodup l) :\n    (l.pmap l.prev fun _ h => h) = l.rotate (l.length - 1)", "start": [365, 1], "end": [370, 50], "kind": "commanddeclaration"}, {"full_name": "List.prev_next", "code": "theorem prev_next (l : List \u03b1) (h : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    prev l (next l x hx) (next_mem _ _ _) = x", "start": [374, 1], "end": [383, 92], "kind": "commanddeclaration"}, {"full_name": "List.next_prev", "code": "theorem next_prev (l : List \u03b1) (h : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    next l (prev l x hx) (prev_mem _ _ _) = x", "start": [387, 1], "end": [396, 16], "kind": "commanddeclaration"}, {"full_name": "List.prev_reverse_eq_next", "code": "theorem prev_reverse_eq_next (l : List \u03b1) (h : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    prev l.reverse x (mem_reverse.mpr hx) = next l x hx", "start": [400, 1], "end": [415, 12], "kind": "commanddeclaration"}, {"full_name": "List.next_reverse_eq_prev", "code": "theorem next_reverse_eq_prev (l : List \u03b1) (h : Nodup l) (x : \u03b1) (hx : x \u2208 l) :\n    next l.reverse x (mem_reverse.mpr hx) = prev l x hx", "start": [418, 1], "end": [421, 33], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_next_eq", "code": "theorem isRotated_next_eq {l l' : List \u03b1} (h : l ~r l') (hn : Nodup l) {x : \u03b1} (hx : x \u2208 l) :\n    l.next x hx = l'.next x (h.mem_iff.mp hx)", "start": [425, 1], "end": [432, 19], "kind": "commanddeclaration"}, {"full_name": "List.isRotated_prev_eq", "code": "theorem isRotated_prev_eq {l l' : List \u03b1} (h : l ~r l') (hn : Nodup l) {x : \u03b1} (hx : x \u2208 l) :\n    l.prev x hx = l'.prev x (h.mem_iff.mp hx)", "start": [435, 1], "end": [438, 61], "kind": "commanddeclaration"}, {"full_name": "Cycle", "code": "def Cycle (\u03b1 : Type*) : Type _ :=\n  Quotient (IsRotated.setoid \u03b1)", "start": [445, 1], "end": [449, 32], "kind": "commanddeclaration"}, {"full_name": "Cycle.ofList", "code": "@[coe] def ofList : List \u03b1 \u2192 Cycle \u03b1 :=\n  Quot.mk _", "start": [457, 1], "end": [459, 12], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_eq_coe", "code": "@[simp]\ntheorem coe_eq_coe {l\u2081 l\u2082 : List \u03b1} : (l\u2081 : Cycle \u03b1) = (l\u2082 : Cycle \u03b1) \u2194 l\u2081 ~r l\u2082", "start": [464, 1], "end": [466, 42], "kind": "commanddeclaration"}, {"full_name": "Cycle.mk_eq_coe", "code": "@[simp]\ntheorem mk_eq_coe (l : List \u03b1) : Quot.mk _ l = (l : Cycle \u03b1)", "start": [469, 1], "end": [471, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.mk''_eq_coe", "code": "@[simp]\ntheorem mk''_eq_coe (l : List \u03b1) : Quotient.mk'' l = (l : Cycle \u03b1)", "start": [474, 1], "end": [476, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_cons_eq_coe_append", "code": "theorem coe_cons_eq_coe_append (l : List \u03b1) (a : \u03b1) :\n    (\u2191(a :: l) : Cycle \u03b1) = (\u2191(l ++ [a]) : Cycle \u03b1)", "start": [479, 1], "end": [481, 56], "kind": "commanddeclaration"}, {"full_name": "Cycle.nil", "code": "def nil : Cycle \u03b1 :=\n  ([] : List \u03b1)", "start": [484, 1], "end": [486, 16], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_nil", "code": "@[simp]\ntheorem coe_nil : \u2191([] : List \u03b1) = @nil \u03b1", "start": [489, 1], "end": [491, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_eq_nil", "code": "@[simp]\ntheorem coe_eq_nil (l : List \u03b1) : (l : Cycle \u03b1) = nil \u2194 l = []", "start": [494, 1], "end": [496, 37], "kind": "commanddeclaration"}, {"full_name": "Cycle.empty_eq", "code": "@[simp]\ntheorem empty_eq : \u2205 = @nil \u03b1", "start": [503, 1], "end": [505, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {C : Cycle \u03b1 \u2192 Prop} (s : Cycle \u03b1) (H0 : C nil)\n    (HI : \u2200 (a) (l : List \u03b1), C \u2191l \u2192 C \u2191(a :: l)) : C s", "start": [511, 1], "end": [517, 16], "kind": "commanddeclaration"}, {"full_name": "Cycle.Mem", "code": "def Mem (a : \u03b1) (s : Cycle \u03b1) : Prop :=\n  Quot.liftOn s (fun l => a \u2208 l) fun _ _ e => propext <| e.mem_iff", "start": [520, 1], "end": [522, 67], "kind": "commanddeclaration"}, {"full_name": "Cycle.mem_coe_iff", "code": "@[simp]\ntheorem mem_coe_iff {a : \u03b1} {l : List \u03b1} : a \u2208 (\u2191l : Cycle \u03b1) \u2194 a \u2208 l", "start": [528, 1], "end": [530, 10], "kind": "commanddeclaration"}, {"full_name": "Cycle.not_mem_nil", "code": "@[simp]\ntheorem not_mem_nil : \u2200 a, a \u2209 @nil \u03b1", "start": [533, 1], "end": [535, 19], "kind": "commanddeclaration"}, {"full_name": "Cycle.reverse", "code": "nonrec def reverse (s : Cycle \u03b1) : Cycle \u03b1 :=\n  Quot.map reverse (fun _ _ => IsRotated.reverse) s", "start": [544, 1], "end": [546, 52], "kind": "commanddeclaration"}, {"full_name": "Cycle.reverse_coe", "code": "@[simp]\ntheorem reverse_coe (l : List \u03b1) : (l : Cycle \u03b1).reverse = l.reverse", "start": [549, 1], "end": [551, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.mem_reverse_iff", "code": "@[simp]\ntheorem mem_reverse_iff {a : \u03b1} {s : Cycle \u03b1} : a \u2208 s.reverse \u2194 a \u2208 s", "start": [554, 1], "end": [556, 42], "kind": "commanddeclaration"}, {"full_name": "Cycle.reverse_reverse", "code": "@[simp]\ntheorem reverse_reverse (s : Cycle \u03b1) : s.reverse.reverse = s", "start": [559, 1], "end": [561, 38], "kind": "commanddeclaration"}, {"full_name": "Cycle.reverse_nil", "code": "@[simp]\ntheorem reverse_nil : nil.reverse = @nil \u03b1", "start": [564, 1], "end": [566, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.length", "code": "def length (s : Cycle \u03b1) : \u2115 :=\n  Quot.liftOn s List.length fun _ _ e => e.perm.length_eq", "start": [569, 1], "end": [571, 58], "kind": "commanddeclaration"}, {"full_name": "Cycle.length_coe", "code": "@[simp]\ntheorem length_coe (l : List \u03b1) : length (l : Cycle \u03b1) = l.length", "start": [574, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.length_nil", "code": "@[simp]\ntheorem length_nil : length (@nil \u03b1) = 0", "start": [579, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.length_reverse", "code": "@[simp]\ntheorem length_reverse (s : Cycle \u03b1) : s.reverse.length = s.length", "start": [584, 1], "end": [586, 41], "kind": "commanddeclaration"}, {"full_name": "Cycle.Subsingleton", "code": "def Subsingleton (s : Cycle \u03b1) : Prop :=\n  s.length \u2264 1", "start": [589, 1], "end": [591, 15], "kind": "commanddeclaration"}, {"full_name": "Cycle.subsingleton_nil", "code": "theorem subsingleton_nil : Subsingleton (@nil \u03b1)", "start": [594, 1], "end": [595, 14], "kind": "commanddeclaration"}, {"full_name": "Cycle.length_subsingleton_iff", "code": "theorem length_subsingleton_iff {s : Cycle \u03b1} : Subsingleton s \u2194 length s \u2264 1", "start": [598, 1], "end": [599, 10], "kind": "commanddeclaration"}, {"full_name": "Cycle.subsingleton_reverse_iff", "code": "@[simp]\ntheorem subsingleton_reverse_iff {s : Cycle \u03b1} : s.reverse.Subsingleton \u2194 s.Subsingleton", "start": [602, 1], "end": [604, 33], "kind": "commanddeclaration"}, {"full_name": "Cycle.Subsingleton.congr", "code": "theorem Subsingleton.congr {s : Cycle \u03b1} (h : Subsingleton s) :\n    \u2200 \u2983x\u2984 (_hx : x \u2208 s) \u2983y\u2984 (_hy : y \u2208 s), x = y", "start": [607, 1], "end": [612, 42], "kind": "commanddeclaration"}, {"full_name": "Cycle.Nontrivial", "code": "def Nontrivial (s : Cycle \u03b1) : Prop :=\n  \u2203 (x y : \u03b1) (_h : x \u2260 y), x \u2208 s \u2227 y \u2208 s", "start": [615, 1], "end": [617, 42], "kind": "commanddeclaration"}, {"full_name": "Cycle.nontrivial_coe_nodup_iff", "code": "@[simp]\ntheorem nontrivial_coe_nodup_iff {l : List \u03b1} (hl : l.Nodup) :\n    Nontrivial (l : Cycle \u03b1) \u2194 2 \u2264 l.length", "start": [620, 1], "end": [631, 23], "kind": "commanddeclaration"}, {"full_name": "Cycle.nontrivial_reverse_iff", "code": "@[simp]\ntheorem nontrivial_reverse_iff {s : Cycle \u03b1} : s.reverse.Nontrivial \u2194 s.Nontrivial", "start": [634, 1], "end": [636, 20], "kind": "commanddeclaration"}, {"full_name": "Cycle.length_nontrivial", "code": "theorem length_nontrivial {s : Cycle \u03b1} (h : Nontrivial s) : 2 \u2264 length s", "start": [639, 1], "end": [646, 32], "kind": "commanddeclaration"}, {"full_name": "Cycle.Nodup", "code": "nonrec def Nodup (s : Cycle \u03b1) : Prop :=\n  Quot.liftOn s Nodup fun _l\u2081 _l\u2082 e => propext <| e.nodup_iff", "start": [649, 1], "end": [651, 62], "kind": "commanddeclaration"}, {"full_name": "Cycle.nodup_nil", "code": "@[simp]\nnonrec theorem nodup_nil : Nodup (@nil \u03b1)", "start": [654, 1], "end": [656, 12], "kind": "commanddeclaration"}, {"full_name": "Cycle.nodup_coe_iff", "code": "@[simp]\ntheorem nodup_coe_iff {l : List \u03b1} : Nodup (l : Cycle \u03b1) \u2194 l.Nodup", "start": [659, 1], "end": [661, 10], "kind": "commanddeclaration"}, {"full_name": "Cycle.nodup_reverse_iff", "code": "@[simp]\ntheorem nodup_reverse_iff {s : Cycle \u03b1} : s.reverse.Nodup \u2194 s.Nodup", "start": [664, 1], "end": [666, 44], "kind": "commanddeclaration"}, {"full_name": "Cycle.Subsingleton.nodup", "code": "theorem Subsingleton.nodup {s : Cycle \u03b1} (h : Subsingleton s) : Nodup s", "start": [669, 1], "end": [674, 16], "kind": "commanddeclaration"}, {"full_name": "Cycle.Nodup.nontrivial_iff", "code": "theorem Nodup.nontrivial_iff {s : Cycle \u03b1} (h : Nodup s) : Nontrivial s \u2194 \u00acSubsingleton s", "start": [677, 1], "end": [681, 28], "kind": "commanddeclaration"}, {"full_name": "Cycle.toMultiset", "code": "def toMultiset (s : Cycle \u03b1) : Multiset \u03b1 :=\n  Quotient.liftOn' s (\u2191) fun _ _ h => Multiset.coe_eq_coe.mpr h.perm", "start": [684, 1], "end": [687, 69], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_toMultiset", "code": "@[simp]\ntheorem coe_toMultiset (l : List \u03b1) : (l : Cycle \u03b1).toMultiset = l", "start": [690, 1], "end": [692, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.nil_toMultiset", "code": "@[simp]\ntheorem nil_toMultiset : nil.toMultiset = (0 : Multiset \u03b1)", "start": [695, 1], "end": [697, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.card_toMultiset", "code": "@[simp]\ntheorem card_toMultiset (s : Cycle \u03b1) : Multiset.card s.toMultiset = s.length", "start": [700, 1], "end": [702, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.toMultiset_eq_nil", "code": "@[simp]\ntheorem toMultiset_eq_nil {s : Cycle \u03b1} : s.toMultiset = 0 \u2194 s = Cycle.nil", "start": [705, 1], "end": [707, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.map", "code": "def map {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) : Cycle \u03b1 \u2192 Cycle \u03b2 :=\n  Quotient.map' (List.map f) fun _ _ h => h.map _", "start": [710, 1], "end": [712, 50], "kind": "commanddeclaration"}, {"full_name": "Cycle.map_nil", "code": "@[simp]\ntheorem map_nil {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) : map f nil = nil", "start": [715, 1], "end": [717, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.map_coe", "code": "@[simp]\ntheorem map_coe {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (l : List \u03b1) : map f \u2191l = List.map f l", "start": [720, 1], "end": [722, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.map_eq_nil", "code": "@[simp]\ntheorem map_eq_nil {\u03b2 : Type*} (f : \u03b1 \u2192 \u03b2) (s : Cycle \u03b1) : map f s = nil \u2194 s = nil", "start": [725, 1], "end": [727, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.mem_map", "code": "@[simp]\ntheorem mem_map {\u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} {b : \u03b2} {s : Cycle \u03b1} :\n    b \u2208 s.map f \u2194 \u2203 a, a \u2208 s \u2227 f a = b", "start": [730, 1], "end": [733, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.lists", "code": "def lists (s : Cycle \u03b1) : Multiset (List \u03b1) :=\n  Quotient.liftOn' s (fun l => (l.cyclicPermutations : Multiset (List \u03b1))) fun l\u2081 l\u2082 h => by\n    simpa using h.cyclicPermutations.perm", "start": [736, 1], "end": [739, 42], "kind": "commanddeclaration"}, {"full_name": "Cycle.lists_coe", "code": "@[simp]\ntheorem lists_coe (l : List \u03b1) : lists (l : Cycle \u03b1) = \u2191l.cyclicPermutations", "start": [742, 1], "end": [744, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.mem_lists_iff_coe_eq", "code": "@[simp]\ntheorem mem_lists_iff_coe_eq {s : Cycle \u03b1} {l : List \u03b1} : l \u2208 s.lists \u2194 (l : Cycle \u03b1) = s", "start": [747, 1], "end": [751, 9], "kind": "commanddeclaration"}, {"full_name": "Cycle.lists_nil", "code": "@[simp]\ntheorem lists_nil : lists (@nil \u03b1) = [([] : List \u03b1)]", "start": [754, 1], "end": [756, 46], "kind": "commanddeclaration"}, {"full_name": "Cycle.decidableNontrivialCoe", "code": "def decidableNontrivialCoe : \u2200 l : List \u03b1, Decidable (Nontrivial (l : Cycle \u03b1))\n  | [] => isFalse (by simp [Nontrivial])\n  | [x] => isFalse (by simp [Nontrivial])\n  | x :: y :: l =>\n    if h : x = y then\n      @decidable_of_iff' _ (Nontrivial (x :: l : Cycle \u03b1)) (by simp [h, Nontrivial])\n        (decidableNontrivialCoe (x :: l))\n    else isTrue \u27e8x, y, h, by simp, by simp\u27e9", "start": [763, 1], "end": [772, 44], "kind": "commanddeclaration"}, {"full_name": "Cycle.fintypeNodupCycle", "code": "instance fintypeNodupCycle [Fintype \u03b1] : Fintype { s : Cycle \u03b1 // s.Nodup } :=\n  Fintype.ofSurjective (fun l : { l : List \u03b1 // l.Nodup } => \u27e8l.val, by simpa using l.prop\u27e9)\n    fun \u27e8s, hs\u27e9 => by\n    induction' s using Quotient.inductionOn' with s hs\n    exact \u27e8\u27e8s, hs\u27e9, by simp\u27e9", "start": [781, 1], "end": [785, 29], "kind": "commanddeclaration"}, {"full_name": "Cycle.fintypeNodupNontrivialCycle", "code": "instance fintypeNodupNontrivialCycle [Fintype \u03b1] :\n    Fintype { s : Cycle \u03b1 // s.Nodup \u2227 s.Nontrivial } :=\n  Fintype.subtype\n    (((Finset.univ : Finset { s : Cycle \u03b1 // s.Nodup }).map (Function.Embedding.subtype _)).filter\n      Cycle.Nontrivial)\n    (by simp)", "start": [788, 1], "end": [793, 14], "kind": "commanddeclaration"}, {"full_name": "Cycle.toFinset", "code": "def toFinset (s : Cycle \u03b1) : Finset \u03b1 :=\n  s.toMultiset.toFinset", "start": [796, 1], "end": [798, 24], "kind": "commanddeclaration"}, {"full_name": "Cycle.toFinset_toMultiset", "code": "@[simp]\ntheorem toFinset_toMultiset (s : Cycle \u03b1) : s.toMultiset.toFinset = s.toFinset", "start": [801, 1], "end": [803, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.coe_toFinset", "code": "@[simp]\ntheorem coe_toFinset (l : List \u03b1) : (l : Cycle \u03b1).toFinset = l.toFinset", "start": [806, 1], "end": [808, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.nil_toFinset", "code": "@[simp]\ntheorem nil_toFinset : (@nil \u03b1).toFinset = \u2205", "start": [811, 1], "end": [813, 6], "kind": "commanddeclaration"}, {"full_name": "Cycle.toFinset_eq_nil", "code": "@[simp]\ntheorem toFinset_eq_nil {s : Cycle \u03b1} : s.toFinset = \u2205 \u2194 s = Cycle.nil", "start": [816, 1], "end": [818, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.next", "code": "nonrec def next : \u2200 (s : Cycle \u03b1) (_hs : Nodup s) (x : \u03b1) (_hx : x \u2208 s), \u03b1 := fun s =>\n  Quot.hrecOn (motive := fun (s : Cycle \u03b1) => \u2200 (_hs : Cycle.Nodup s) (x : \u03b1) (_hx : x \u2208 s), \u03b1) s\n  (fun l _hn x hx => next l x hx) fun l\u2081 l\u2082 h =>\n    Function.hfunext (propext h.nodup_iff) fun h\u2081 h\u2082 _he =>\n      Function.hfunext rfl fun x y hxy =>\n        Function.hfunext (propext (by rw [eq_of_heq hxy]; simpa [eq_of_heq hxy] using h.mem_iff))\n  fun hm hm' he' => heq_of_eq\n    (by rw [heq_iff_eq] at hxy; subst x; simpa using isRotated_next_eq h h\u2081 _)", "start": [821, 1], "end": [829, 79], "kind": "commanddeclaration"}, {"full_name": "Cycle.prev", "code": "nonrec def prev : \u2200 (s : Cycle \u03b1) (_hs : Nodup s) (x : \u03b1) (_hx : x \u2208 s), \u03b1 := fun s =>\n  Quot.hrecOn (motive := fun (s : Cycle \u03b1) => \u2200 (_hs : Cycle.Nodup s) (x : \u03b1) (_hx : x \u2208 s), \u03b1) s\n  (fun l _hn x hx => prev l x hx) fun l\u2081 l\u2082 h =>\n    Function.hfunext (propext h.nodup_iff) fun h\u2081 h\u2082 _he =>\n      Function.hfunext rfl fun x y hxy =>\n        Function.hfunext (propext (by rw [eq_of_heq hxy]; simpa [eq_of_heq hxy] using h.mem_iff))\n  fun hm hm' he' => heq_of_eq\n    (by rw [heq_iff_eq] at hxy; subst x; simpa using isRotated_prev_eq h h\u2081 _)", "start": [832, 1], "end": [840, 79], "kind": "commanddeclaration"}, {"full_name": "Cycle.prev_reverse_eq_next", "code": "nonrec theorem prev_reverse_eq_next (s : Cycle \u03b1) : \u2200 (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s),\n    s.reverse.prev (nodup_reverse_iff.mpr hs) x (mem_reverse_iff.mpr hx) = s.next hs x hx", "start": [844, 1], "end": [846, 47], "kind": "commanddeclaration"}, {"full_name": "Cycle.prev_reverse_eq_next'", "code": "@[simp]\nnonrec theorem prev_reverse_eq_next' (s : Cycle \u03b1) (hs : Nodup s.reverse) (x : \u03b1)\n    (hx : x \u2208 s.reverse) :\n    s.reverse.prev hs x hx = s.next (nodup_reverse_iff.mp hs) x (mem_reverse_iff.mp hx)", "start": [850, 1], "end": [854, 77], "kind": "commanddeclaration"}, {"full_name": "Cycle.next_reverse_eq_prev", "code": "theorem next_reverse_eq_prev (s : Cycle \u03b1) (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s) :\n    s.reverse.next (nodup_reverse_iff.mpr hs) x (mem_reverse_iff.mpr hx) = s.prev hs x hx", "start": [857, 1], "end": [859, 32], "kind": "commanddeclaration"}, {"full_name": "Cycle.next_reverse_eq_prev'", "code": "@[simp]\ntheorem next_reverse_eq_prev' (s : Cycle \u03b1) (hs : Nodup s.reverse) (x : \u03b1) (hx : x \u2208 s.reverse) :\n    s.reverse.next hs x hx = s.prev (nodup_reverse_iff.mp hs) x (mem_reverse_iff.mp hx)", "start": [863, 1], "end": [866, 32], "kind": "commanddeclaration"}, {"full_name": "Cycle.next_mem", "code": "@[simp]\nnonrec theorem next_mem (s : Cycle \u03b1) (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s) : s.next hs x hx \u2208 s", "start": [868, 1], "end": [871, 29], "kind": "commanddeclaration"}, {"full_name": "Cycle.prev_mem", "code": "theorem prev_mem (s : Cycle \u03b1) (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s) : s.prev hs x hx \u2208 s", "start": [874, 1], "end": [876, 17], "kind": "commanddeclaration"}, {"full_name": "Cycle.prev_next", "code": "@[simp]\nnonrec theorem prev_next (s : Cycle \u03b1) : \u2200 (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s),\n    s.prev hs (s.next hs x hx) (next_mem s hs x hx) = x", "start": [879, 1], "end": [882, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.next_prev", "code": "@[simp]\nnonrec theorem next_prev (s : Cycle \u03b1) : \u2200 (hs : Nodup s) (x : \u03b1) (hx : x \u2208 s),\n    s.next hs (s.prev hs x hx) (prev_mem s hs x hx) = x", "start": [885, 1], "end": [888, 36], "kind": "commanddeclaration"}, {"full_name": "Cycle.Chain", "code": "nonrec def Chain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (c : Cycle \u03b1) : Prop :=\n  Quotient.liftOn' c\n    (fun l =>\n      match l with\n      | [] => True\n      | a :: m => Chain r a (m ++ [a]))\n    fun a b hab =>\n    propext <| by\n      cases' a with a l <;> cases' b with b m\n      \u00b7 rfl\n      \u00b7 have := isRotated_nil_iff'.1 hab\n        contradiction\n      \u00b7 have := isRotated_nil_iff.1 hab\n        contradiction\n      \u00b7 dsimp only\n        cases' hab with n hn\n        induction' n with d hd generalizing a b l m\n        \u00b7 simp only [Nat.zero_eq, rotate_zero, cons.injEq] at hn\n          rw [hn.1, hn.2]\n        \u00b7 cases' l with c s\n          \u00b7 simp only [rotate_cons_succ, nil_append, rotate_singleton, cons.injEq] at hn\n            rw [hn.1, hn.2]\n          \u00b7 rw [Nat.succ_eq_one_add, \u2190 rotate_rotate, rotate_cons_succ, rotate_zero,\n              cons_append] at hn\n            rw [\u2190 hd c _ _ _ hn]\n            simp [and_comm]", "start": [901, 1], "end": [929, 28], "kind": "commanddeclaration"}, {"full_name": "Cycle.Chain.nil", "code": "@[simp]\ntheorem Chain.nil (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Cycle.Chain r (@nil \u03b1)", "start": [932, 1], "end": [933, 76], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_coe_cons", "code": "@[simp]\ntheorem chain_coe_cons (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) (l : List \u03b1) :\n    Chain r (a :: l) \u2194 List.Chain r a (l ++ [a])", "start": [936, 1], "end": [939, 10], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_singleton", "code": "theorem chain_singleton (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : Chain r [a] \u2194 r a a", "start": [943, 1], "end": [944, 56], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_ne_nil", "code": "theorem chain_ne_nil (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {l : List \u03b1} :\n    \u2200 hl : l \u2260 [], Chain r l \u2194 List.Chain r (getLast l hl) l", "start": [947, 1], "end": [951, 77], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_map", "code": "theorem chain_map {\u03b2 : Type*} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (f : \u03b2 \u2192 \u03b1) {s : Cycle \u03b2} :\n    Chain r (s.map f) \u2194 Chain (fun a b => r (f a) (f b)) s", "start": [954, 1], "end": [962, 9], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_range_succ", "code": "nonrec theorem chain_range_succ (r : \u2115 \u2192 \u2115 \u2192 Prop) (n : \u2115) :\n    Chain r (List.range n.succ) \u2194 r n 0 \u2227 \u2200 m < n, r m m.succ", "start": [965, 1], "end": [967, 92], "kind": "commanddeclaration"}, {"full_name": "Cycle.Chain.imp", "code": "theorem Chain.imp {r\u2081 r\u2082 : \u03b1 \u2192 \u03b1 \u2192 Prop} (H : \u2200 a b, r\u2081 a b \u2192 r\u2082 a b) (p : Chain r\u2081 s) :\n    Chain r\u2082 s", "start": [972, 1], "end": [977, 18], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_mono", "code": "theorem chain_mono : Monotone (Chain : (\u03b1 \u2192 \u03b1 \u2192 Prop) \u2192 Cycle \u03b1 \u2192 Prop)", "start": [980, 1], "end": [982, 16], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_of_pairwise", "code": "theorem chain_of_pairwise : (\u2200 a \u2208 s, \u2200 b \u2208 s, r a b) \u2192 Chain r s", "start": [985, 1], "end": [1007, 28], "kind": "commanddeclaration"}, {"full_name": "Cycle.chain_iff_pairwise", "code": "theorem chain_iff_pairwise [IsTrans \u03b1 r] : Chain r s \u2194 \u2200 a \u2208 s, \u2200 b \u2208 s, r a b", "start": [1010, 1], "end": [1023, 86], "kind": "commanddeclaration"}, {"full_name": "Cycle.Chain.eq_nil_of_irrefl", "code": "theorem Chain.eq_nil_of_irrefl [IsTrans \u03b1 r] [IsIrrefl \u03b1 r] (h : Chain r s) : s = Cycle.nil", "start": [1026, 1], "end": [1030, 67], "kind": "commanddeclaration"}, {"full_name": "Cycle.Chain.eq_nil_of_well_founded", "code": "theorem Chain.eq_nil_of_well_founded [IsWellFounded \u03b1 r] (h : Chain r s) : s = Cycle.nil", "start": [1033, 1], "end": [1034, 70], "kind": "commanddeclaration"}, {"full_name": "Cycle.forall_eq_of_chain", "code": "theorem forall_eq_of_chain [IsTrans \u03b1 r] [IsAntisymm \u03b1 r] (hs : Chain r s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) : a = b", "start": [1037, 1], "end": [1040, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/ConstMulAction.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/GroupTheory/GroupAction/Basic.lean", "Mathlib/Topology/Algebra/Constructions.lean", "Mathlib/Topology/Homeomorph.lean", "Mathlib/Topology/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousConstSMul", "code": "class ContinuousConstSMul (\u0393 : Type*) (T : Type*) [TopologicalSpace T] [SMul \u0393 T] : Prop where\n  \n  continuous_const_smul : \u2200 \u03b3 : \u0393, Continuous fun x : T => \u03b3 \u2022 x", "start": [47, 1], "end": [55, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousConstVAdd", "code": "class ContinuousConstVAdd (\u0393 : Type*) (T : Type*) [TopologicalSpace T] [VAdd \u0393 T] : Prop where\n  \n  continuous_const_vadd : \u2200 \u03b3 : \u0393, Continuous fun x : T => \u03b3 +\u1d65 x", "start": [58, 1], "end": [66, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_smul", "code": "@[to_additive]\ntheorem Filter.Tendsto.const_smul {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} (hf : Tendsto f l (\ud835\udcdd a))\n    (c : M) : Tendsto (fun x => c \u2022 f x) l (\ud835\udcdd (c \u2022 a))", "start": [80, 1], "end": [83, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.const_smul", "code": "@[to_additive]\nnonrec theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :\n    ContinuousWithinAt (fun x => c \u2022 g x) s b", "start": [89, 1], "end": [92, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.const_smul", "code": "@[to_additive]\nnonrec theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) :\n    ContinuousAt (fun x => c \u2022 g x) b", "start": [96, 1], "end": [99, 18], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.const_smul", "code": "@[to_additive]\ntheorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) :\n    ContinuousOn (fun x => c \u2022 g x) s", "start": [103, 1], "end": [105, 76], "kind": "commanddeclaration"}, {"full_name": "Continuous.const_smul", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c \u2022 g x", "start": [109, 1], "end": [111, 36], "kind": "commanddeclaration"}, {"full_name": "ContinuousConstSMul.op", "code": "@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousConstSMul.op [SMul M\u1d50\u1d52\u1d56 \u03b1] [IsCentralScalar M \u03b1] :\n    ContinuousConstSMul M\u1d50\u1d52\u1d56 \u03b1 :=\n  \u27e8MulOpposite.rec' fun c => by simpa only [op_smul_eq_smul] using continuous_const_smul c\u27e9", "start": [115, 1], "end": [120, 92], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.continuousConstSMul", "code": "@[to_additive]\ninstance MulOpposite.continuousConstSMul : ContinuousConstSMul M \u03b1\u1d50\u1d52\u1d56 :=\n  \u27e8fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul c\u27e9", "start": [124, 1], "end": [126, 88], "kind": "commanddeclaration"}, {"full_name": "OrderDual.continuousConstSMul'", "code": "@[to_additive]\ninstance OrderDual.continuousConstSMul' : ContinuousConstSMul M\u1d52\u1d48 \u03b1 :=\n  \u2039ContinuousConstSMul M \u03b1\u203a", "start": [133, 1], "end": [135, 28], "kind": "commanddeclaration"}, {"full_name": "Prod.continuousConstSMul", "code": "@[to_additive]\ninstance Prod.continuousConstSMul [SMul M \u03b2] [ContinuousConstSMul M \u03b2] :\n    ContinuousConstSMul M (\u03b1 \u00d7 \u03b2) :=\n  \u27e8fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)\u27e9", "start": [139, 1], "end": [142, 81], "kind": "commanddeclaration"}, {"full_name": "IsCompact.smul", "code": "@[to_additive]\ntheorem IsCompact.smul {\u03b1 \u03b2} [SMul \u03b1 \u03b2] [TopologicalSpace \u03b2] [ContinuousConstSMul \u03b1 \u03b2] (a : \u03b1)\n    {s : Set \u03b2} (hs : IsCompact s) : IsCompact (a \u2022 s)", "start": [149, 1], "end": [152, 40], "kind": "commanddeclaration"}, {"full_name": "Units.continuousConstSMul", "code": "@[to_additive]\ninstance Units.continuousConstSMul : ContinuousConstSMul M\u02e3 \u03b1 where\n  continuous_const_smul m := (continuous_const_smul (m : M) : _)", "start": [164, 1], "end": [166, 65], "kind": "commanddeclaration"}, {"full_name": "smul_closure_subset", "code": "@[to_additive]\ntheorem smul_closure_subset (c : M) (s : Set \u03b1) : c \u2022 closure s \u2286 closure (c \u2022 s)", "start": [170, 1], "end": [172, 75], "kind": "commanddeclaration"}, {"full_name": "smul_closure_orbit_subset", "code": "@[to_additive]\ntheorem smul_closure_orbit_subset (c : M) (x : \u03b1) :\n    c \u2022 closure (MulAction.orbit M x) \u2286 closure (MulAction.orbit M x)", "start": [176, 1], "end": [179, 85], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_map_smul", "code": "theorem isClosed_setOf_map_smul [Monoid N] (\u03b1 \u03b2) [MulAction M \u03b1] [MulAction N \u03b2]\n    [TopologicalSpace \u03b2] [T2Space \u03b2] [ContinuousConstSMul N \u03b2] (\u03c3 : M \u2192 N) :\n    IsClosed { f : \u03b1 \u2192 \u03b2 | \u2200 c x, f (c \u2022 x) = \u03c3 c \u2022 f x }", "start": [183, 1], "end": [188, 73], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_smul_iff", "code": "@[to_additive]\ntheorem tendsto_const_smul_iff {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} (c : G) :\n    Tendsto (fun x => c \u2022 f x) l (\ud835\udcdd <| c \u2022 a) \u2194 Tendsto f l (\ud835\udcdd a)", "start": [197, 1], "end": [200, 91], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_const_smul_iff", "code": "@[to_additive]\ntheorem continuousWithinAt_const_smul_iff (c : G) :\n    ContinuousWithinAt (fun x => c \u2022 f x) s b \u2194 ContinuousWithinAt f s b", "start": [206, 1], "end": [209, 27], "kind": "commanddeclaration"}, {"full_name": "continuousOn_const_smul_iff", "code": "@[to_additive]\ntheorem continuousOn_const_smul_iff (c : G) :\n    ContinuousOn (fun x => c \u2022 f x) s \u2194 ContinuousOn f s", "start": [213, 1], "end": [216, 63], "kind": "commanddeclaration"}, {"full_name": "continuousAt_const_smul_iff", "code": "@[to_additive]\ntheorem continuousAt_const_smul_iff (c : G) :\n    ContinuousAt (fun x => c \u2022 f x) b \u2194 ContinuousAt f b", "start": [220, 1], "end": [223, 27], "kind": "commanddeclaration"}, {"full_name": "continuous_const_smul_iff", "code": "@[to_additive]\ntheorem continuous_const_smul_iff (c : G) : (Continuous fun x => c \u2022 f x) \u2194 Continuous f", "start": [227, 1], "end": [229, 71], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.smul", "code": "@[to_additive]\ndef Homeomorph.smul (\u03b3 : G) : \u03b1 \u2243\u209c \u03b1 where\n  toEquiv := MulAction.toPerm \u03b3\n  continuous_toFun := continuous_const_smul \u03b3\n  continuous_invFun := continuous_const_smul \u03b3\u207b\u00b9", "start": [233, 1], "end": [239, 49], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_smul", "code": "@[to_additive]\ntheorem isOpenMap_smul (c : G) : IsOpenMap fun x : \u03b1 => c \u2022 x", "start": [247, 1], "end": [249, 32], "kind": "commanddeclaration"}, {"full_name": "IsOpen.smul", "code": "@[to_additive]\ntheorem IsOpen.smul {s : Set \u03b1} (hs : IsOpen s) (c : G) : IsOpen (c \u2022 s)", "start": [253, 1], "end": [255, 24], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_smul", "code": "@[to_additive]\ntheorem isClosedMap_smul (c : G) : IsClosedMap fun x : \u03b1 => c \u2022 x", "start": [259, 1], "end": [261, 34], "kind": "commanddeclaration"}, {"full_name": "IsClosed.smul", "code": "@[to_additive]\ntheorem IsClosed.smul {s : Set \u03b1} (hs : IsClosed s) (c : G) : IsClosed (c \u2022 s)", "start": [265, 1], "end": [267, 26], "kind": "commanddeclaration"}, {"full_name": "closure_smul", "code": "@[to_additive]\ntheorem closure_smul (c : G) (s : Set \u03b1) : closure (c \u2022 s) = c \u2022 closure s", "start": [271, 1], "end": [273, 45], "kind": "commanddeclaration"}, {"full_name": "Dense.smul", "code": "@[to_additive]\ntheorem Dense.smul (c : G) {s : Set \u03b1} (hs : Dense s) : Dense (c \u2022 s)", "start": [277, 1], "end": [279, 74], "kind": "commanddeclaration"}, {"full_name": "interior_smul", "code": "@[to_additive]\ntheorem interior_smul (c : G) (s : Set \u03b1) : interior (c \u2022 s) = c \u2022 interior s", "start": [283, 1], "end": [285, 46], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_smul_iff\u2080", "code": "theorem tendsto_const_smul_iff\u2080 {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} {c : G\u2080} (hc : c \u2260 0) :\n    Tendsto (fun x => c \u2022 f x) l (\ud835\udcdd <| c \u2022 a) \u2194 Tendsto f l (\ud835\udcdd a)", "start": [296, 1], "end": [298, 42], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_const_smul_iff\u2080", "code": "theorem continuousWithinAt_const_smul_iff\u2080 (hc : c \u2260 0) :\n    ContinuousWithinAt (fun x => c \u2022 f x) s b \u2194 ContinuousWithinAt f s b", "start": [303, 1], "end": [305, 42], "kind": "commanddeclaration"}, {"full_name": "continuousOn_const_smul_iff\u2080", "code": "theorem continuousOn_const_smul_iff\u2080 (hc : c \u2260 0) :\n    ContinuousOn (fun x => c \u2022 f x) s \u2194 ContinuousOn f s", "start": [308, 1], "end": [310, 47], "kind": "commanddeclaration"}, {"full_name": "continuousAt_const_smul_iff\u2080", "code": "theorem continuousAt_const_smul_iff\u2080 (hc : c \u2260 0) :\n    ContinuousAt (fun x => c \u2022 f x) b \u2194 ContinuousAt f b", "start": [313, 1], "end": [315, 47], "kind": "commanddeclaration"}, {"full_name": "continuous_const_smul_iff\u2080", "code": "theorem continuous_const_smul_iff\u2080 (hc : c \u2260 0) : (Continuous fun x => c \u2022 f x) \u2194 Continuous f", "start": [318, 1], "end": [319, 45], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.smulOfNeZero", "code": "@[simps! (config := .asFn) apply]\nprotected def Homeomorph.smulOfNeZero (c : G\u2080) (hc : c \u2260 0) : \u03b1 \u2243\u209c \u03b1 :=\n  Homeomorph.smul (Units.mk0 c hc)", "start": [322, 1], "end": [326, 35], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.smulOfNeZero_symm_apply", "code": "@[simp]\ntheorem Homeomorph.smulOfNeZero_symm_apply {c : G\u2080} (hc : c \u2260 0) :\n    \u21d1(Homeomorph.smulOfNeZero c hc).symm = (c\u207b\u00b9 \u2022 \u00b7 : \u03b1 \u2192 \u03b1)", "start": [329, 1], "end": [332, 6], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_smul\u2080", "code": "theorem isOpenMap_smul\u2080 {c : G\u2080} (hc : c \u2260 0) : IsOpenMap fun x : \u03b1 => c \u2022 x", "start": [334, 1], "end": [335, 43], "kind": "commanddeclaration"}, {"full_name": "IsOpen.smul\u2080", "code": "theorem IsOpen.smul\u2080 {c : G\u2080} {s : Set \u03b1} (hs : IsOpen s) (hc : c \u2260 0) : IsOpen (c \u2022 s)", "start": [338, 1], "end": [339, 26], "kind": "commanddeclaration"}, {"full_name": "interior_smul\u2080", "code": "theorem interior_smul\u2080 {c : G\u2080} (hc : c \u2260 0) (s : Set \u03b1) : interior (c \u2022 s) = c \u2022 interior s", "start": [342, 1], "end": [343, 57], "kind": "commanddeclaration"}, {"full_name": "closure_smul\u2080", "code": "theorem closure_smul\u2080 {E} [Zero E] [MulActionWithZero G\u2080 E] [TopologicalSpace E] [T1Space E]\n    [ContinuousConstSMul G\u2080 E] (c : G\u2080) (s : Set E) : closure (c \u2022 s) = c \u2022 closure s", "start": [346, 1], "end": [353, 64], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_smul_of_ne_zero", "code": "theorem isClosedMap_smul_of_ne_zero {c : G\u2080} (hc : c \u2260 0) : IsClosedMap fun x : \u03b1 => c \u2022 x", "start": [356, 1], "end": [361, 45], "kind": "commanddeclaration"}, {"full_name": "IsClosed.smul_of_ne_zero", "code": "theorem IsClosed.smul_of_ne_zero {c : G\u2080} {s : Set \u03b1} (hs : IsClosed s) (hc : c \u2260 0) :\n    IsClosed (c \u2022 s)", "start": [364, 1], "end": [366, 38], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_smul\u2080", "code": "theorem isClosedMap_smul\u2080 {\ud835\udd5c M : Type*} [DivisionRing \ud835\udd5c] [AddCommMonoid M] [TopologicalSpace M]\n    [T1Space M] [Module \ud835\udd5c M] [ContinuousConstSMul \ud835\udd5c M] (c : \ud835\udd5c) :\n    IsClosedMap fun x : M => c \u2022 x", "start": [369, 1], "end": [379, 54], "kind": "commanddeclaration"}, {"full_name": "IsClosed.smul\u2080", "code": "theorem IsClosed.smul\u2080 {\ud835\udd5c M : Type*} [DivisionRing \ud835\udd5c] [AddCommMonoid M] [TopologicalSpace M]\n    [T1Space M] [Module \ud835\udd5c M] [ContinuousConstSMul \ud835\udd5c M] (c : \ud835\udd5c) {s : Set M} (hs : IsClosed s) :\n    IsClosed (c \u2022 s)", "start": [382, 1], "end": [385, 27], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.comp_smul", "code": "theorem HasCompactMulSupport.comp_smul {\u03b2 : Type*} [One \u03b2] {f : \u03b1 \u2192 \u03b2} (h : HasCompactMulSupport f)\n    {c : G\u2080} (hc : c \u2260 0) : HasCompactMulSupport fun x => f (c \u2022 x)", "start": [388, 1], "end": [390, 51], "kind": "commanddeclaration"}, {"full_name": "HasCompactSupport.comp_smul", "code": "theorem HasCompactSupport.comp_smul {\u03b2 : Type*} [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : HasCompactSupport f)\n    {c : G\u2080} (hc : c \u2260 0) : HasCompactSupport fun x => f (c \u2022 x)", "start": [393, 1], "end": [395, 51], "kind": "commanddeclaration"}, {"full_name": "IsUnit.tendsto_const_smul_iff", "code": "nonrec theorem tendsto_const_smul_iff {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} {a : \u03b1} {c : M} (hc : IsUnit c) :\n    Tendsto (fun x => c \u2022 f x) l (\ud835\udcdd <| c \u2022 a) \u2194 Tendsto f l (\ud835\udcdd a)", "start": [406, 1], "end": [409, 32], "kind": "commanddeclaration"}, {"full_name": "IsUnit.continuousWithinAt_const_smul_iff", "code": "nonrec theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousWithinAt (fun x => c \u2022 f x) s b \u2194 ContinuousWithinAt f s b", "start": [414, 1], "end": [417, 43], "kind": "commanddeclaration"}, {"full_name": "IsUnit.continuousOn_const_smul_iff", "code": "nonrec theorem continuousOn_const_smul_iff (hc : IsUnit c) :\n    ContinuousOn (fun x => c \u2022 f x) s \u2194 ContinuousOn f s", "start": [420, 1], "end": [423, 37], "kind": "commanddeclaration"}, {"full_name": "IsUnit.continuousAt_const_smul_iff", "code": "nonrec theorem continuousAt_const_smul_iff (hc : IsUnit c) :\n    ContinuousAt (fun x => c \u2022 f x) b \u2194 ContinuousAt f b", "start": [426, 1], "end": [429, 37], "kind": "commanddeclaration"}, {"full_name": "IsUnit.continuous_const_smul_iff", "code": "nonrec theorem continuous_const_smul_iff (hc : IsUnit c) :\n    (Continuous fun x => c \u2022 f x) \u2194 Continuous f", "start": [432, 1], "end": [435, 35], "kind": "commanddeclaration"}, {"full_name": "IsUnit.isOpenMap_smul", "code": "nonrec theorem isOpenMap_smul (hc : IsUnit c) : IsOpenMap fun x : \u03b1 => c \u2022 x", "start": [438, 1], "end": [440, 24], "kind": "commanddeclaration"}, {"full_name": "IsUnit.isClosedMap_smul", "code": "nonrec theorem isClosedMap_smul (hc : IsUnit c) : IsClosedMap fun x : \u03b1 => c \u2022 x", "start": [443, 1], "end": [445, 26], "kind": "commanddeclaration"}, {"full_name": "ProperlyDiscontinuousSMul", "code": "class ProperlyDiscontinuousSMul (\u0393 : Type*) (T : Type*) [TopologicalSpace T] [SMul \u0393 T] :\n    Prop where\n  \n  finite_disjoint_inter_image :\n    \u2200 {K L : Set T}, IsCompact K \u2192 IsCompact L \u2192 Set.Finite { \u03b3 : \u0393 | (\u03b3 \u2022 \u00b7) '' K \u2229 L \u2260 \u2205 }", "start": [451, 1], "end": [459, 93], "kind": "commanddeclaration"}, {"full_name": "ProperlyDiscontinuousVAdd", "code": "class ProperlyDiscontinuousVAdd (\u0393 : Type*) (T : Type*) [TopologicalSpace T] [VAdd \u0393 T] :\n  Prop where\n  \n  finite_disjoint_inter_image :\n    \u2200 {K L : Set T}, IsCompact K \u2192 IsCompact L \u2192 Set.Finite { \u03b3 : \u0393 | (\u03b3 +\u1d65 \u00b7) '' K \u2229 L \u2260 \u2205 }", "start": [462, 1], "end": [470, 94], "kind": "commanddeclaration"}, {"full_name": "Finite.to_properlyDiscontinuousSMul", "code": "@[to_additive \"A finite group action is always properly discontinuous.\"]\ninstance (priority := 100) Finite.to_properlyDiscontinuousSMul [Finite \u0393] :\n    ProperlyDiscontinuousSMul \u0393 T where finite_disjoint_inter_image _ _ := Set.toFinite _", "start": [477, 1], "end": [480, 90], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_quotient_mk'_mul", "code": "@[to_additive \"The quotient map by a group action is open, i.e. the quotient by a group\naction is an open quotient. \"]\ntheorem isOpenMap_quotient_mk'_mul [ContinuousConstSMul \u0393 T] :\n    letI := MulAction.orbitRel \u0393 T\n    IsOpenMap (Quotient.mk' : T \u2192 Quotient (MulAction.orbitRel \u0393 T))", "start": [487, 1], "end": [495, 53], "kind": "commanddeclaration"}, {"full_name": "t2Space_of_properlyDiscontinuousSMul_of_t2Space", "code": "@[to_additive \"The quotient by a discontinuous group action of a locally compact t2\nspace is t2.\"]\ninstance (priority := 100) t2Space_of_properlyDiscontinuousSMul_of_t2Space [T2Space T]\n    [LocallyCompactSpace T] [ContinuousConstSMul \u0393 T] [ProperlyDiscontinuousSMul \u0393 T] :\n    T2Space (Quotient (MulAction.orbitRel \u0393 T)) := by\n  letI := MulAction.orbitRel \u0393 T\n  set Q := Quotient (MulAction.orbitRel \u0393 T)\n  rw [t2Space_iff_nhds]\n  let f : T \u2192 Q := Quotient.mk'\n  have f_op : IsOpenMap f := isOpenMap_quotient_mk'_mul\n  rintro \u27e8x\u2080\u27e9 \u27e8y\u2080\u27e9 (hxy : f x\u2080 \u2260 f y\u2080)\n  show \u2203 U \u2208 \ud835\udcdd (f x\u2080), \u2203 V \u2208 \ud835\udcdd (f y\u2080), _\n  have h\u03b3x\u2080y\u2080 : \u2200 \u03b3 : \u0393, \u03b3 \u2022 x\u2080 \u2260 y\u2080 := not_exists.mp (mt Quotient.sound hxy.symm : _)\n  obtain \u27e8K\u2080, hK\u2080, K\u2080_in\u27e9 := exists_compact_mem_nhds x\u2080\n  obtain \u27e8L\u2080, hL\u2080, L\u2080_in\u27e9 := exists_compact_mem_nhds y\u2080\n  let bad_\u0393_set := { \u03b3 : \u0393 | (\u03b3 \u2022 \u00b7) '' K\u2080 \u2229 L\u2080 \u2260 \u2205 }\n  have bad_\u0393_finite : bad_\u0393_set.Finite := finite_disjoint_inter_image (\u0393 := \u0393) hK\u2080 hL\u2080\n  choose u v hu hv u_v_disjoint using fun \u03b3 => t2_separation_nhds (h\u03b3x\u2080y\u2080 \u03b3)\n  let U\u2080\u2080 := \u22c2 \u03b3 \u2208 bad_\u0393_set, (\u03b3 \u2022 \u00b7) \u207b\u00b9' u \u03b3\n  let U\u2080 := U\u2080\u2080 \u2229 K\u2080\n  let V\u2080\u2080 := \u22c2 \u03b3 \u2208 bad_\u0393_set, v \u03b3\n  let V\u2080 := V\u2080\u2080 \u2229 L\u2080\n  have U_nhds : f '' U\u2080 \u2208 \ud835\udcdd (f x\u2080) := by\n    refine f_op.image_mem_nhds (inter_mem ((biInter_mem bad_\u0393_finite).mpr fun \u03b3 _ => ?_) K\u2080_in)\n    exact (continuous_const_smul _).continuousAt (hu \u03b3)\n  have V_nhds : f '' V\u2080 \u2208 \ud835\udcdd (f y\u2080) :=\n    f_op.image_mem_nhds (inter_mem ((biInter_mem bad_\u0393_finite).mpr fun \u03b3 _ => hv \u03b3) L\u2080_in)\n  refine' \u27e8f '' U\u2080, U_nhds, f '' V\u2080, V_nhds, MulAction.disjoint_image_image_iff.2 _\u27e9\n  rintro x \u27e8x_in_U\u2080\u2080, x_in_K\u2080\u27e9 \u03b3\n  by_cases H : \u03b3 \u2208 bad_\u0393_set\n  \u00b7 exact fun h => (u_v_disjoint \u03b3).le_bot \u27e8mem_iInter\u2082.mp x_in_U\u2080\u2080 \u03b3 H, mem_iInter\u2082.mp h.1 \u03b3 H\u27e9\n  \u00b7 rintro \u27e8-, h'\u27e9\n    simp only [image_smul, Classical.not_not, mem_setOf_eq, Ne.def] at H\n    exact eq_empty_iff_forall_not_mem.mp H (\u03b3 \u2022 x) \u27e8mem_image_of_mem _ x_in_K\u2080, h'\u27e9", "start": [499, 1], "end": [533, 84], "kind": "commanddeclaration"}, {"full_name": "ContinuousConstSMul.secondCountableTopology", "code": "@[to_additive \"The quotient of a second countable space by an additive group action is second\ncountable.\"]\ntheorem ContinuousConstSMul.secondCountableTopology [SecondCountableTopology T]\n    [ContinuousConstSMul \u0393 T] : SecondCountableTopology (Quotient (MulAction.orbitRel \u0393 T))", "start": [537, 1], "end": [542, 79], "kind": "commanddeclaration"}, {"full_name": "set_smul_mem_nhds_smul", "code": "theorem set_smul_mem_nhds_smul {c : G\u2080} {s : Set \u03b1} {x : \u03b1} (hs : s \u2208 \ud835\udcdd x) (hc : c \u2260 0) :\n    c \u2022 s \u2208 \ud835\udcdd (c \u2022 x : \u03b1)", "start": [554, 1], "end": [559, 79], "kind": "commanddeclaration"}, {"full_name": "set_smul_mem_nhds_smul_iff", "code": "theorem set_smul_mem_nhds_smul_iff {c : G\u2080} {s : Set \u03b1} {x : \u03b1} (hc : c \u2260 0) :\n    c \u2022 s \u2208 \ud835\udcdd (c \u2022 x : \u03b1) \u2194 s \u2208 \ud835\udcdd x", "start": [562, 1], "end": [566, 50], "kind": "commanddeclaration"}, {"full_name": "set_smul_mem_nhds_zero_iff", "code": "theorem set_smul_mem_nhds_zero_iff {s : Set \u03b1} {c : G\u2080} (hc : c \u2260 0) :\n    c \u2022 s \u2208 \ud835\udcdd (0 : \u03b1) \u2194 s \u2208 \ud835\udcdd (0 : \u03b1)", "start": [576, 1], "end": [579, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/AddTorsor.lean", "imports": ["Mathlib/Data/Set/Pointwise/SMul.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddTorsor", "code": "class AddTorsor (G : outParam (Type*)) (P : Type*) [outParam <| AddGroup G] extends AddAction G P,\n  VSub G P where\n  [Nonempty : Nonempty P]\n  \n  vsub_vadd' : \u2200 p1 p2 : P, (p1 -\u1d65 p2 : G) +\u1d65 p2 = p1\n  \n  vadd_vsub' : \u2200 (g : G) (p : P), g +\u1d65 p -\u1d65 p = g", "start": [45, 1], "end": [56, 50], "kind": "commanddeclaration"}, {"full_name": "addGroupIsAddTorsor", "code": "instance addGroupIsAddTorsor (G : Type*) [AddGroup G] : AddTorsor G G\n    where\n  vsub := Sub.sub\n  vsub_vadd' := sub_add_cancel\n  vadd_vsub' := add_sub_cancel", "start": [64, 1], "end": [70, 31], "kind": "commanddeclaration"}, {"full_name": "vsub_eq_sub", "code": "@[simp]\ntheorem vsub_eq_sub {G : Type*} [AddGroup G] (g1 g2 : G) : g1 -\u1d65 g2 = g1 - g2", "start": [73, 1], "end": [77, 6], "kind": "commanddeclaration"}, {"full_name": "vsub_vadd", "code": "@[simp]\ntheorem vsub_vadd (p1 p2 : P) : p1 -\u1d65 p2 +\u1d65 p2 = p1", "start": [84, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "vadd_vsub", "code": "@[simp]\ntheorem vadd_vsub (g : G) (p : P) : g +\u1d65 p -\u1d65 p = g", "start": [91, 1], "end": [95, 27], "kind": "commanddeclaration"}, {"full_name": "vadd_right_cancel", "code": "theorem vadd_right_cancel {g1 g2 : G} (p : P) (h : g1 +\u1d65 p = g2 +\u1d65 p) : g1 = g2", "start": [98, 1], "end": [102, 38], "kind": "commanddeclaration"}, {"full_name": "vadd_right_cancel_iff", "code": "@[simp]\ntheorem vadd_right_cancel_iff {g1 g2 : G} (p : P) : g1 +\u1d65 p = g2 +\u1d65 p \u2194 g1 = g2", "start": [105, 1], "end": [107, 42], "kind": "commanddeclaration"}, {"full_name": "vadd_right_injective", "code": "theorem vadd_right_injective (p : P) : Function.Injective ((\u00b7 +\u1d65 p) : G \u2192 P)", "start": [110, 1], "end": [113, 22], "kind": "commanddeclaration"}, {"full_name": "vadd_vsub_assoc", "code": "theorem vadd_vsub_assoc (g : G) (p1 p2 : P) : g +\u1d65 p1 -\u1d65 p2 = g + (p1 -\u1d65 p2)", "start": [116, 1], "end": [121, 38], "kind": "commanddeclaration"}, {"full_name": "vsub_self", "code": "@[simp]\ntheorem vsub_self (p : P) : p -\u1d65 p = (0 : G)", "start": [124, 1], "end": [127, 57], "kind": "commanddeclaration"}, {"full_name": "eq_of_vsub_eq_zero", "code": "theorem eq_of_vsub_eq_zero {p1 p2 : P} (h : p1 -\u1d65 p2 = (0 : G)) : p1 = p2", "start": [130, 1], "end": [132, 39], "kind": "commanddeclaration"}, {"full_name": "vsub_eq_zero_iff_eq", "code": "@[simp]\ntheorem vsub_eq_zero_iff_eq {p1 p2 : P} : p1 -\u1d65 p2 = (0 : G) \u2194 p1 = p2", "start": [135, 1], "end": [139, 56], "kind": "commanddeclaration"}, {"full_name": "vsub_ne_zero", "code": "theorem vsub_ne_zero {p q : P} : p -\u1d65 q \u2260 (0 : G) \u2194 p \u2260 q", "start": [142, 1], "end": [143, 32], "kind": "commanddeclaration"}, {"full_name": "vsub_add_vsub_cancel", "code": "@[simp]\ntheorem vsub_add_vsub_cancel (p1 p2 p3 : P) : p1 -\u1d65 p2 + (p2 -\u1d65 p3) = p1 -\u1d65 p3", "start": [146, 1], "end": [150, 49], "kind": "commanddeclaration"}, {"full_name": "neg_vsub_eq_vsub_rev", "code": "@[simp]\ntheorem neg_vsub_eq_vsub_rev (p1 p2 : P) : -(p1 -\u1d65 p2) = p2 -\u1d65 p1", "start": [153, 1], "end": [158, 39], "kind": "commanddeclaration"}, {"full_name": "vadd_vsub_eq_sub_vsub", "code": "theorem vadd_vsub_eq_sub_vsub (g : G) (p q : P) : g +\u1d65 p -\u1d65 q = g - (q -\u1d65 p)", "start": [161, 1], "end": [162, 61], "kind": "commanddeclaration"}, {"full_name": "vsub_vadd_eq_vsub_sub", "code": "theorem vsub_vadd_eq_vsub_sub (p1 p2 : P) (g : G) : p1 -\u1d65 (g +\u1d65 p2) = p1 -\u1d65 p2 - g", "start": [165, 1], "end": [169, 67], "kind": "commanddeclaration"}, {"full_name": "vsub_sub_vsub_cancel_right", "code": "@[simp]\ntheorem vsub_sub_vsub_cancel_right (p1 p2 p3 : P) : p1 -\u1d65 p3 - (p2 -\u1d65 p3) = p1 -\u1d65 p2", "start": [172, 1], "end": [175, 42], "kind": "commanddeclaration"}, {"full_name": "eq_vadd_iff_vsub_eq", "code": "theorem eq_vadd_iff_vsub_eq (p1 : P) (g : G) (p2 : P) : p1 = g +\u1d65 p2 \u2194 p1 -\u1d65 p2 = g", "start": [178, 1], "end": [182, 71], "kind": "commanddeclaration"}, {"full_name": "vadd_eq_vadd_iff_neg_add_eq_vsub", "code": "theorem vadd_eq_vadd_iff_neg_add_eq_vsub {v\u2081 v\u2082 : G} {p\u2081 p\u2082 : P} :\n    v\u2081 +\u1d65 p\u2081 = v\u2082 +\u1d65 p\u2082 \u2194 -v\u2081 + v\u2082 = p\u2081 -\u1d65 p\u2082", "start": [185, 1], "end": [187, 97], "kind": "commanddeclaration"}, {"full_name": "Set.singleton_vsub_self", "code": "theorem singleton_vsub_self (p : P) : ({p} : Set P) -\u1d65 {p} = {(0 : G)}", "start": [196, 1], "end": [197, 47], "kind": "commanddeclaration"}, {"full_name": "vadd_vsub_vadd_cancel_right", "code": "@[simp]\ntheorem vadd_vsub_vadd_cancel_right (v\u2081 v\u2082 : G) (p : P) : v\u2081 +\u1d65 p -\u1d65 (v\u2082 +\u1d65 p) = v\u2081 - v\u2082", "start": [202, 1], "end": [204, 67], "kind": "commanddeclaration"}, {"full_name": "vsub_left_cancel", "code": "theorem vsub_left_cancel {p1 p2 p : P} (h : p1 -\u1d65 p = p2 -\u1d65 p) : p1 = p2", "start": [207, 1], "end": [210, 76], "kind": "commanddeclaration"}, {"full_name": "vsub_left_cancel_iff", "code": "@[simp]\ntheorem vsub_left_cancel_iff {p1 p2 p : P} : p1 -\u1d65 p = p2 -\u1d65 p \u2194 p1 = p2", "start": [213, 1], "end": [217, 39], "kind": "commanddeclaration"}, {"full_name": "vsub_left_injective", "code": "theorem vsub_left_injective (p : P) : Function.Injective ((\u00b7 -\u1d65 p) : P \u2192 G)", "start": [220, 1], "end": [222, 19], "kind": "commanddeclaration"}, {"full_name": "vsub_right_cancel", "code": "theorem vsub_right_cancel {p1 p2 p : P} (h : p -\u1d65 p1 = p -\u1d65 p2) : p1 = p2", "start": [225, 1], "end": [229, 33], "kind": "commanddeclaration"}, {"full_name": "vsub_right_cancel_iff", "code": "@[simp]\ntheorem vsub_right_cancel_iff {p1 p2 p : P} : p -\u1d65 p1 = p -\u1d65 p2 \u2194 p1 = p2", "start": [232, 1], "end": [236, 40], "kind": "commanddeclaration"}, {"full_name": "vsub_right_injective", "code": "theorem vsub_right_injective (p : P) : Function.Injective ((p -\u1d65 \u00b7) : P \u2192 G)", "start": [239, 1], "end": [242, 20], "kind": "commanddeclaration"}, {"full_name": "vsub_sub_vsub_cancel_left", "code": "@[simp]\ntheorem vsub_sub_vsub_cancel_left (p1 p2 p3 : P) : p3 -\u1d65 p2 - (p3 -\u1d65 p1) = p1 -\u1d65 p2", "start": [254, 1], "end": [257, 76], "kind": "commanddeclaration"}, {"full_name": "vadd_vsub_vadd_cancel_left", "code": "@[simp]\ntheorem vadd_vsub_vadd_cancel_left (v : G) (p1 p2 : P) : v +\u1d65 p1 -\u1d65 (v +\u1d65 p2) = p1 -\u1d65 p2", "start": [260, 1], "end": [262, 63], "kind": "commanddeclaration"}, {"full_name": "vsub_vadd_comm", "code": "theorem vsub_vadd_comm (p1 p2 p3 : P) : (p1 -\u1d65 p2 : G) +\u1d65 p3 = p3 -\u1d65 p2 +\u1d65 p1", "start": [265, 1], "end": [267, 7], "kind": "commanddeclaration"}, {"full_name": "vadd_eq_vadd_iff_sub_eq_vsub", "code": "theorem vadd_eq_vadd_iff_sub_eq_vsub {v\u2081 v\u2082 : G} {p\u2081 p\u2082 : P} :\n    v\u2081 +\u1d65 p\u2081 = v\u2082 +\u1d65 p\u2082 \u2194 v\u2082 - v\u2081 = p\u2081 -\u1d65 p\u2082", "start": [270, 1], "end": [272, 56], "kind": "commanddeclaration"}, {"full_name": "vsub_sub_vsub_comm", "code": "theorem vsub_sub_vsub_comm (p\u2081 p\u2082 p\u2083 p\u2084 : P) : p\u2081 -\u1d65 p\u2082 - (p\u2083 -\u1d65 p\u2084) = p\u2081 -\u1d65 p\u2083 - (p\u2082 -\u1d65 p\u2084)", "start": [275, 1], "end": [276, 70], "kind": "commanddeclaration"}, {"full_name": "Prod.instAddTorsor", "code": "instance instAddTorsor : AddTorsor (G \u00d7 G') (P \u00d7 P') where\n  vadd v p := (v.1 +\u1d65 p.1, v.2 +\u1d65 p.2)\n  zero_vadd _ := Prod.ext (zero_vadd _ _) (zero_vadd _ _)\n  add_vadd _ _ _ := Prod.ext (add_vadd _ _ _) (add_vadd _ _ _)\n  vsub p\u2081 p\u2082 := (p\u2081.1 -\u1d65 p\u2082.1, p\u2081.2 -\u1d65 p\u2082.2)\n  Nonempty := Prod.Nonempty\n  vsub_vadd' _ _ := Prod.ext (vsub_vadd _ _) (vsub_vadd _ _)\n  vadd_vsub' _ _ := Prod.ext (vadd_vsub _ _) (vadd_vsub _ _)", "start": [285, 1], "end": [292, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_vadd", "code": "@[simp]\ntheorem fst_vadd (v : G \u00d7 G') (p : P \u00d7 P') : (v +\u1d65 p).1 = v.1 +\u1d65 p.1", "start": [303, 1], "end": [305, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_vadd", "code": "@[simp]\ntheorem snd_vadd (v : G \u00d7 G') (p : P \u00d7 P') : (v +\u1d65 p).2 = v.2 +\u1d65 p.2", "start": [308, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_vadd_mk", "code": "@[simp]\ntheorem mk_vadd_mk (v : G) (v' : G') (p : P) (p' : P') : (v, v') +\u1d65 (p, p') = (v +\u1d65 p, v' +\u1d65 p')", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.fst_vsub", "code": "@[simp]\ntheorem fst_vsub (p\u2081 p\u2082 : P \u00d7 P') : (p\u2081 -\u1d65 p\u2082 : G \u00d7 G').1 = p\u2081.1 -\u1d65 p\u2082.1", "start": [318, 1], "end": [320, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_vsub", "code": "@[simp]\ntheorem snd_vsub (p\u2081 p\u2082 : P \u00d7 P') : (p\u2081 -\u1d65 p\u2082 : G \u00d7 G').2 = p\u2081.2 -\u1d65 p\u2082.2", "start": [323, 1], "end": [325, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.mk_vsub_mk", "code": "@[simp]\ntheorem mk_vsub_mk (p\u2081 p\u2082 : P) (p\u2081' p\u2082' : P') :\n    ((p\u2081, p\u2081') -\u1d65 (p\u2082, p\u2082') : G \u00d7 G') = (p\u2081 -\u1d65 p\u2082, p\u2081' -\u1d65 p\u2082')", "start": [328, 1], "end": [331, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.instAddTorsor", "code": "instance instAddTorsor [T : \u2200 i, AddTorsor (fg i) (fp i)] : AddTorsor (\u2200 i, fg i) (\u2200 i, fp i) where\n  vadd g p i := g i +\u1d65 p i\n  zero_vadd p := funext fun i => zero_vadd (fg i) (p i)\n  add_vadd g\u2081 g\u2082 p := funext fun i => add_vadd (g\u2081 i) (g\u2082 i) (p i)\n  vsub p\u2081 p\u2082 i := p\u2081 i -\u1d65 p\u2082 i\n  Nonempty := \u27e8fun i => Classical.choice (T i).Nonempty\u27e9\n  vsub_vadd' p\u2081 p\u2082 := funext fun i => vsub_vadd (p\u2081 i) (p\u2082 i)\n  vadd_vsub' g p := funext fun i => vadd_vsub (g i) (p i)", "start": [344, 1], "end": [352, 58], "kind": "commanddeclaration"}, {"full_name": "Equiv.vaddConst", "code": "def vaddConst (p : P) : G \u2243 P where\n  toFun v := v +\u1d65 p\n  invFun p' := p' -\u1d65 p\n  left_inv _ := vadd_vsub _ _\n  right_inv _ := vsub_vadd _ _", "start": [363, 1], "end": [368, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_vaddConst", "code": "@[simp]\ntheorem coe_vaddConst (p : P) : \u21d1(vaddConst p) = fun v => v +\u1d65 p", "start": [371, 1], "end": [373, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_vaddConst_symm", "code": "@[simp]\ntheorem coe_vaddConst_symm (p : P) : \u21d1(vaddConst p).symm = fun p' => p' -\u1d65 p", "start": [376, 1], "end": [378, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.constVSub", "code": "def constVSub (p : P) : P \u2243 G where\n  toFun := (\u00b7 -\u1d65 \u00b7) p\n  invFun v := -v +\u1d65 p\n  left_inv p' := by simp\n  right_inv v := by simp [vsub_vadd_eq_vsub_sub]", "start": [381, 1], "end": [386, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_constVSub", "code": "@[simp]\ntheorem coe_constVSub (p : P) : \u21d1(constVSub p) = (\u00b7 -\u1d65 \u00b7) p", "start": [389, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_constVSub_symm", "code": "@[simp]\ntheorem coe_constVSub_symm (p : P) : \u21d1(constVSub p).symm = fun (v : G) => -v +\u1d65 p", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.constVAdd", "code": "def constVAdd (v : G) : Equiv.Perm P where\n  toFun := (\u00b7 +\u1d65 \u00b7) v\n  invFun := (\u00b7 +\u1d65 \u00b7) (-v)\n  left_inv p := by simp [vadd_vadd]\n  right_inv p := by simp [vadd_vadd]", "start": [401, 1], "end": [406, 37], "kind": "commanddeclaration"}, {"full_name": "Equiv.coe_constVAdd", "code": "@[simp]\ntheorem coe_constVAdd (v : G) : \u21d1(constVAdd P v) = (\u00b7 +\u1d65 \u00b7) v", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.constVAdd_zero", "code": "@[simp]\ntheorem constVAdd_zero : constVAdd P (0 : G) = 1", "start": [416, 1], "end": [418, 21], "kind": "commanddeclaration"}, {"full_name": "Equiv.constVAdd_add", "code": "@[simp]\ntheorem constVAdd_add (v\u2081 v\u2082 : G) : constVAdd P (v\u2081 + v\u2082) = constVAdd P v\u2081 * constVAdd P v\u2082", "start": [423, 1], "end": [425, 24], "kind": "commanddeclaration"}, {"full_name": "Equiv.constVAddHom", "code": "def constVAddHom : Multiplicative G \u2192* Equiv.Perm P where\n  toFun v := constVAdd P (Multiplicative.toAdd v)\n  map_one' := constVAdd_zero G P\n  map_mul' := constVAdd_add P", "start": [428, 1], "end": [432, 30], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection", "code": "def pointReflection (x : P) : Perm P :=\n  (constVSub x).trans (vaddConst x)", "start": [441, 1], "end": [443, 36], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_apply", "code": "theorem pointReflection_apply (x y : P) : pointReflection x y = x -\u1d65 y +\u1d65 x", "start": [446, 1], "end": [447, 6], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_vsub_left", "code": "@[simp]\ntheorem pointReflection_vsub_left (x y : P) : pointReflection x y -\u1d65 x = x -\u1d65 y", "start": [450, 1], "end": [452, 15], "kind": "commanddeclaration"}, {"full_name": "Equiv.left_vsub_pointReflection", "code": "@[simp]\ntheorem left_vsub_pointReflection (x y : P) : x -\u1d65 pointReflection x y = y -\u1d65 x", "start": [454, 1], "end": [456, 27], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_vsub_right", "code": "@[simp]\ntheorem pointReflection_vsub_right (x y : P) : pointReflection x y -\u1d65 y = 2 \u2022 (x -\u1d65 y)", "start": [458, 1], "end": [460, 53], "kind": "commanddeclaration"}, {"full_name": "Equiv.right_vsub_pointReflection", "code": "@[simp]\ntheorem right_vsub_pointReflection (x y : P) : y -\u1d65 pointReflection x y = 2 \u2022 (y -\u1d65 x)", "start": [462, 1], "end": [464, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_symm", "code": "@[simp]\ntheorem pointReflection_symm (x : P) : (pointReflection x).symm = pointReflection x", "start": [466, 1], "end": [468, 35], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_self", "code": "@[simp]\ntheorem pointReflection_self (x : P) : pointReflection x x = x", "start": [471, 1], "end": [473, 16], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_involutive", "code": "theorem pointReflection_involutive (x : P) : Involutive (pointReflection x : P \u2192 P)", "start": [476, 1], "end": [477, 73], "kind": "commanddeclaration"}, {"full_name": "Equiv.pointReflection_fixed_iff_of_injective_bit0", "code": "theorem pointReflection_fixed_iff_of_injective_bit0 {x y : P} (h : Injective (bit0 : G \u2192 G)) :\n    pointReflection x y = y \u2194 y = x", "start": [481, 1], "end": [486, 89], "kind": "commanddeclaration"}, {"full_name": "Equiv.injective_pointReflection_left_of_injective_bit0", "code": "theorem injective_pointReflection_left_of_injective_bit0 {G P : Type*} [AddCommGroup G]\n    [AddTorsor G P] (h : Injective (bit0 : G \u2192 G)) (y : P) :\n    Injective fun x : P => pointReflection x y", "start": [493, 1], "end": [499, 41], "kind": "commanddeclaration"}, {"full_name": "AddTorsor.subsingleton_iff", "code": "theorem AddTorsor.subsingleton_iff (G P : Type*) [AddGroup G] [AddTorsor G P] :\n    Subsingleton G \u2194 Subsingleton P", "start": [504, 1], "end": [507, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/NAry.lean", "imports": ["Mathlib/Order/Filter/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.map\u2082", "code": "def map\u2082 (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) : Filter \u03b3\n    where\n  sets := { s | \u2203 u v, u \u2208 f \u2227 v \u2208 g \u2227 image2 m u v \u2286 s }\n  univ_sets := \u27e8univ, univ, univ_sets _, univ_sets _, subset_univ _\u27e9\n  sets_of_superset hs hst :=\n    Exists\u2082.imp (fun u v => And.imp_right <| And.imp_right fun h => Subset.trans h hst) hs\n  inter_sets := by\n    simp only [exists_prop, Set.mem_setOf_eq, subset_inter_iff]\n    rintro _ _ \u27e8s\u2081, s\u2082, hs\u2081, hs\u2082, hs\u27e9 \u27e8t\u2081, t\u2082, ht\u2081, ht\u2082, ht\u27e9\n    exact\n      \u27e8s\u2081 \u2229 t\u2081, s\u2082 \u2229 t\u2082, inter_sets f hs\u2081 ht\u2081, inter_sets g hs\u2082 ht\u2082,\n        (image2_subset (inter_subset_left _ _) <| inter_subset_left _ _).trans hs,\n        (image2_subset (inter_subset_right _ _) <| inter_subset_right _ _).trans ht\u27e9", "start": [38, 1], "end": [52, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_map\u2082_iff", "code": "@[simp 900]\ntheorem mem_map\u2082_iff : u \u2208 map\u2082 m f g \u2194 \u2203 s t, s \u2208 f \u2227 t \u2208 g \u2227 image2 m s t \u2286 u", "start": [55, 1], "end": [57, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.image2_mem_map\u2082", "code": "theorem image2_mem_map\u2082 (hs : s \u2208 f) (ht : t \u2208 g) : image2 m s t \u2208 map\u2082 m f g", "start": [60, 1], "end": [61, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map_prod_eq_map\u2082", "code": "theorem map_prod_eq_map\u2082 (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    Filter.map (fun p : \u03b1 \u00d7 \u03b2 => m p.1 p.2) (f \u00d7\u02e2 g) = map\u2082 m f g", "start": [64, 1], "end": [67, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.map_prod_eq_map\u2082'", "code": "theorem map_prod_eq_map\u2082' (m : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    Filter.map m (f \u00d7\u02e2 g) = map\u2082 (fun a b => m (a, b)) f g", "start": [70, 1], "end": [72, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_mk_eq_prod", "code": "@[simp]\ntheorem map\u2082_mk_eq_prod (f : Filter \u03b1) (g : Filter \u03b2) : map\u2082 Prod.mk f g = f \u00d7\u02e2 g", "start": [75, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_mono", "code": "theorem map\u2082_mono (hf : f\u2081 \u2264 f\u2082) (hg : g\u2081 \u2264 g\u2082) : map\u2082 m f\u2081 g\u2081 \u2264 map\u2082 m f\u2082 g\u2082", "start": [83, 1], "end": [84, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_mono_left", "code": "theorem map\u2082_mono_left (h : g\u2081 \u2264 g\u2082) : map\u2082 m f g\u2081 \u2264 map\u2082 m f g\u2082", "start": [87, 1], "end": [88, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_mono_right", "code": "theorem map\u2082_mono_right (h : f\u2081 \u2264 f\u2082) : map\u2082 m f\u2081 g \u2264 map\u2082 m f\u2082 g", "start": [91, 1], "end": [92, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.le_map\u2082_iff", "code": "@[simp]\ntheorem le_map\u2082_iff {h : Filter \u03b3} :\n    h \u2264 map\u2082 m f g \u2194 \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2200 \u2983t\u2984, t \u2208 g \u2192 image2 m s t \u2208 h", "start": [95, 1], "end": [99, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_bot_left", "code": "@[simp]\ntheorem map\u2082_bot_left : map\u2082 m \u22a5 g = \u22a5", "start": [102, 1], "end": [104, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_bot_right", "code": "@[simp]\ntheorem map\u2082_bot_right : map\u2082 m f \u22a5 = \u22a5", "start": [107, 1], "end": [109, 78], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_eq_bot_iff", "code": "@[simp]\ntheorem map\u2082_eq_bot_iff : map\u2082 m f g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [112, 1], "end": [121, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_neBot_iff", "code": "@[simp]\ntheorem map\u2082_neBot_iff : (map\u2082 m f g).NeBot \u2194 f.NeBot \u2227 g.NeBot", "start": [124, 1], "end": [127, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.map\u2082", "code": "theorem NeBot.map\u2082 (hf : f.NeBot) (hg : g.NeBot) : (map\u2082 m f g).NeBot", "start": [130, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_map\u2082_left", "code": "theorem NeBot.of_map\u2082_left (h : (Filter.map\u2082 m f g).NeBot) : f.NeBot", "start": [135, 1], "end": [136, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_map\u2082_right", "code": "theorem NeBot.of_map\u2082_right (h : (Filter.map\u2082 m f g).NeBot) : g.NeBot", "start": [139, 1], "end": [140, 25], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_sup_left", "code": "theorem map\u2082_sup_left : map\u2082 m (f\u2081 \u2294 f\u2082) g = map\u2082 m f\u2081 g \u2294 map\u2082 m f\u2082 g", "start": [143, 1], "end": [153, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_sup_right", "code": "theorem map\u2082_sup_right : map\u2082 m f (g\u2081 \u2294 g\u2082) = map\u2082 m f g\u2081 \u2294 map\u2082 m f g\u2082", "start": [156, 1], "end": [166, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_inf_subset_left", "code": "theorem map\u2082_inf_subset_left : map\u2082 m (f\u2081 \u2293 f\u2082) g \u2264 map\u2082 m f\u2081 g \u2293 map\u2082 m f\u2082 g", "start": [169, 1], "end": [170, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_inf_subset_right", "code": "theorem map\u2082_inf_subset_right : map\u2082 m f (g\u2081 \u2293 g\u2082) \u2264 map\u2082 m f g\u2081 \u2293 map\u2082 m f g\u2082", "start": [173, 1], "end": [174, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_pure_left", "code": "@[simp]\ntheorem map\u2082_pure_left : map\u2082 m (pure a) g = g.map fun b => m a b", "start": [177, 1], "end": [182, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_pure_right", "code": "@[simp]\ntheorem map\u2082_pure_right : map\u2082 m f (pure b) = f.map fun a => m a b", "start": [185, 1], "end": [190, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_pure", "code": "theorem map\u2082_pure : map\u2082 m (pure a) (pure b) = pure (m a b)", "start": [193, 1], "end": [193, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_swap", "code": "theorem map\u2082_swap (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    map\u2082 m f g = map\u2082 (fun a b => m b a) g f", "start": [196, 1], "end": [199, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_left", "code": "@[simp]\ntheorem map\u2082_left (h : g.NeBot) : map\u2082 (fun x _ => x) f g = f", "start": [202, 1], "end": [208, 30], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_right", "code": "@[simp]\ntheorem map\u2082_right (h : f.NeBot) : map\u2082 (fun _ y => y) f g = g", "start": [211, 1], "end": [212, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2083", "code": "def map\u2083 (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3 \u2192 \u03b4) (f : Filter \u03b1) (g : Filter \u03b2) (h : Filter \u03b3) : Filter \u03b4\n    where\n  sets := { s | \u2203 u v w, u \u2208 f \u2227 v \u2208 g \u2227 w \u2208 h \u2227 image3 m u v w \u2286 s }\n  univ_sets := \u27e8univ, univ, univ, univ_sets _, univ_sets _, univ_sets _, subset_univ _\u27e9\n  sets_of_superset hs hst :=\n    Exists\u2083.imp\n      (fun u v w => And.imp_right <| And.imp_right <| And.imp_right fun h => Subset.trans h hst) hs\n  inter_sets := by\n    simp only [exists_prop, mem_setOf_eq, subset_inter_iff]\n    rintro _ _ \u27e8s\u2081, s\u2082, s\u2083, hs\u2081, hs\u2082, hs\u2083, hs\u27e9 \u27e8t\u2081, t\u2082, t\u2083, ht\u2081, ht\u2082, ht\u2083, ht\u27e9\n    exact\n      \u27e8s\u2081 \u2229 t\u2081, s\u2082 \u2229 t\u2082, s\u2083 \u2229 t\u2083, inter_mem hs\u2081 ht\u2081, inter_mem hs\u2082 ht\u2082, inter_mem hs\u2083 ht\u2083,\n        (image3_mono (inter_subset_left _ _) (inter_subset_left _ _) <| inter_subset_left _ _).trans\n          hs,\n        (image3_mono (inter_subset_right _ _) (inter_subset_right _ _) <|\n              inter_subset_right _ _).trans\n          ht\u27e9", "start": [215, 1], "end": [234, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map\u2082_left", "code": "theorem map\u2082_map\u2082_left (m : \u03b4 \u2192 \u03b3 \u2192 \u03b5) (n : \u03b1 \u2192 \u03b2 \u2192 \u03b4) :\n    map\u2082 m (map\u2082 n f g) h = map\u2083 (fun a b c => m (n a b) c) f g h", "start": [237, 1], "end": [246, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map\u2082_right", "code": "theorem map\u2082_map\u2082_right (m : \u03b1 \u2192 \u03b4 \u2192 \u03b5) (n : \u03b2 \u2192 \u03b3 \u2192 \u03b4) :\n    map\u2082 m f (map\u2082 n g h) = map\u2083 (fun a b c => m a (n b c)) f g h", "start": [249, 1], "end": [258, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082", "code": "theorem map_map\u2082 (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (n : \u03b3 \u2192 \u03b4) :\n    (map\u2082 m f g).map n = map\u2082 (fun a b => n (m a b)) f g", "start": [261, 1], "end": [263, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map_left", "code": "theorem map\u2082_map_left (m : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (n : \u03b1 \u2192 \u03b3) :\n    map\u2082 m (f.map n) g = map\u2082 (fun a b => m (n a) b) f g", "start": [266, 1], "end": [268, 100], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map_right", "code": "theorem map\u2082_map_right (m : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (n : \u03b2 \u2192 \u03b3) :\n    map\u2082 m f (g.map n) = map\u2082 (fun a b => m a (n b)) f g", "start": [271, 1], "end": [273, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_curry", "code": "@[simp]\ntheorem map\u2082_curry (m : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    map\u2082 (curry m) f g = (f \u00d7\u02e2 g).map m", "start": [276, 1], "end": [279, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map_uncurry_prod", "code": "@[simp]\ntheorem map_uncurry_prod (m : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (f : Filter \u03b1) (g : Filter \u03b2) :\n    (f \u00d7\u02e2 g).map (uncurry m) = map\u2082 m f g", "start": [282, 1], "end": [285, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_assoc", "code": "theorem map\u2082_assoc {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b5' \u2192 \u03b5} {n' : \u03b2 \u2192 \u03b3 \u2192 \u03b5'}\n    {h : Filter \u03b3} (h_assoc : \u2200 a b c, m (n a b) c = m' a (n' b c)) :\n    map\u2082 m (map\u2082 n f g) h = map\u2082 m' f (map\u2082 n' g h)", "start": [299, 1], "end": [302, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_comm", "code": "theorem map\u2082_comm {n : \u03b2 \u2192 \u03b1 \u2192 \u03b3} (h_comm : \u2200 a b, m a b = n b a) : map\u2082 m f g = map\u2082 n g f", "start": [305, 1], "end": [306, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_left_comm", "code": "theorem map\u2082_left_comm {m : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {n : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {n' : \u03b2 \u2192 \u03b4' \u2192 \u03b5}\n    (h_left_comm : \u2200 a b c, m a (n b c) = n' b (m' a c)) :\n    map\u2082 m f (map\u2082 n g h) = map\u2082 n' g (map\u2082 m' f h)", "start": [309, 1], "end": [313, 50], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_right_comm", "code": "theorem map\u2082_right_comm {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b3 \u2192 \u03b4'} {n' : \u03b4' \u2192 \u03b2 \u2192 \u03b5}\n    (h_right_comm : \u2200 a b c, m (n a b) c = n' (m' a c) b) :\n    map\u2082 m (map\u2082 n f g) h = map\u2082 n' (map\u2082 m' f h) g", "start": [316, 1], "end": [320, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_distrib", "code": "theorem map_map\u2082_distrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b1' \u2192 \u03b2' \u2192 \u03b4} {n\u2081 : \u03b1 \u2192 \u03b1'} {n\u2082 : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, n (m a b) = m' (n\u2081 a) (n\u2082 b)) :\n    (map\u2082 m f g).map n = map\u2082 m' (f.map n\u2081) (g.map n\u2082)", "start": [323, 1], "end": [326, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_distrib_left", "code": "theorem map_map\u2082_distrib_left {n : \u03b3 \u2192 \u03b4} {m' : \u03b1' \u2192 \u03b2 \u2192 \u03b4} {n' : \u03b1 \u2192 \u03b1'}\n    (h_distrib : \u2200 a b, n (m a b) = m' (n' a) b) : (map\u2082 m f g).map n = map\u2082 m' (f.map n') g", "start": [329, 1], "end": [332, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_distrib_right", "code": "theorem map_map\u2082_distrib_right {n : \u03b3 \u2192 \u03b4} {m' : \u03b1 \u2192 \u03b2' \u2192 \u03b4} {n' : \u03b2 \u2192 \u03b2'}\n    (h_distrib : \u2200 a b, n (m a b) = m' a (n' b)) : (map\u2082 m f g).map n = map\u2082 m' f (g.map n')", "start": [335, 1], "end": [338, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map_left_comm", "code": "theorem map\u2082_map_left_comm {m : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {n : \u03b1 \u2192 \u03b1'} {m' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {n' : \u03b4 \u2192 \u03b3}\n    (h_left_comm : \u2200 a b, m (n a) b = n' (m' a b)) : map\u2082 m (f.map n) g = (map\u2082 m' f g).map n'", "start": [341, 1], "end": [344, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_right_comm", "code": "theorem map_map\u2082_right_comm {m : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {n : \u03b2 \u2192 \u03b2'} {m' : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {n' : \u03b4 \u2192 \u03b3}\n    (h_right_comm : \u2200 a b, m a (n b) = n' (m' a b)) : map\u2082 m f (g.map n) = (map\u2082 m' f g).map n'", "start": [347, 1], "end": [350, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_distrib_le_left", "code": "theorem map\u2082_distrib_le_left {m : \u03b1 \u2192 \u03b4 \u2192 \u03b5} {n : \u03b2 \u2192 \u03b3 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b2 \u2192 \u03b2'} {m\u2082 : \u03b1 \u2192 \u03b3 \u2192 \u03b3'}\n    {n' : \u03b2' \u2192 \u03b3' \u2192 \u03b5} (h_distrib : \u2200 a b c, m a (n b c) = n' (m\u2081 a b) (m\u2082 a c)) :\n    map\u2082 m f (map\u2082 n g h) \u2264 map\u2082 n' (map\u2082 m\u2081 f g) (map\u2082 m\u2082 f h)", "start": [353, 1], "end": [361, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_distrib_le_right", "code": "theorem map\u2082_distrib_le_right {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'} {m\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'}\n    {n' : \u03b1' \u2192 \u03b2' \u2192 \u03b5} (h_distrib : \u2200 a b c, m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)) :\n    map\u2082 m (map\u2082 n f g) h \u2264 map\u2082 n' (map\u2082 m\u2081 f h) (map\u2082 m\u2082 g h)", "start": [364, 1], "end": [372, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_antidistrib", "code": "theorem map_map\u2082_antidistrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {n\u2081 : \u03b2 \u2192 \u03b2'} {n\u2082 : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' (n\u2081 b) (n\u2082 a)) :\n    (map\u2082 m f g).map n = map\u2082 m' (g.map n\u2081) (f.map n\u2082)", "start": [375, 1], "end": [379, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_antidistrib_left", "code": "theorem map_map\u2082_antidistrib_left {n : \u03b3 \u2192 \u03b4} {m' : \u03b2' \u2192 \u03b1 \u2192 \u03b4} {n' : \u03b2 \u2192 \u03b2'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' (n' b) a) : (map\u2082 m f g).map n = map\u2082 m' (g.map n') f", "start": [382, 1], "end": [385, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_antidistrib_right", "code": "theorem map_map\u2082_antidistrib_right {n : \u03b3 \u2192 \u03b4} {m' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {n' : \u03b1 \u2192 \u03b1'}\n    (h_antidistrib : \u2200 a b, n (m a b) = m' b (n' a)) : (map\u2082 m f g).map n = map\u2082 m' g (f.map n')", "start": [388, 1], "end": [391, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_map_left_anticomm", "code": "theorem map\u2082_map_left_anticomm {m : \u03b1' \u2192 \u03b2 \u2192 \u03b3} {n : \u03b1 \u2192 \u03b1'} {m' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {n' : \u03b4 \u2192 \u03b3}\n    (h_left_anticomm : \u2200 a b, m (n a) b = n' (m' b a)) :\n    map\u2082 m (f.map n) g = (map\u2082 m' g f).map n'", "start": [394, 1], "end": [398, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.map_map\u2082_right_anticomm", "code": "theorem map_map\u2082_right_anticomm {m : \u03b1 \u2192 \u03b2' \u2192 \u03b3} {n : \u03b2 \u2192 \u03b2'} {m' : \u03b2 \u2192 \u03b1 \u2192 \u03b4} {n' : \u03b4 \u2192 \u03b3}\n    (h_right_anticomm : \u2200 a b, m a (n b) = n' (m' b a)) :\n    map\u2082 m f (g.map n) = (map\u2082 m' g f).map n'", "start": [401, 1], "end": [405, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_left_identity", "code": "theorem map\u2082_left_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b2} {a : \u03b1} (h : \u2200 b, f a b = b) (l : Filter \u03b2) :\n    map\u2082 f (pure a) l = l", "start": [408, 1], "end": [411, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_right_identity", "code": "theorem map\u2082_right_identity {f : \u03b1 \u2192 \u03b2 \u2192 \u03b1} {b : \u03b2} (h : \u2200 a, f a b = a) (l : Filter \u03b1) :\n    map\u2082 f l (pure b) = l", "start": [414, 1], "end": [417, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/UnionLift.lean", "imports": ["Mathlib/Data/Set/Lattice.lean", "Mathlib/Order/Directed.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.iUnionLift", "code": "@[nolint unusedArguments]\nnoncomputable def iUnionLift (S : \u03b9 \u2192 Set \u03b1) (f : \u2200 (i) (_ : S i), \u03b2)\n    (_ : \u2200 (i j) (x : \u03b1) (hxi : x \u2208 S i) (hxj : x \u2208 S j), f i \u27e8x, hxi\u27e9 = f j \u27e8x, hxj\u27e9) (T : Set \u03b1)\n    (hT : T \u2286 iUnion S) (x : T) : \u03b2 :=\n  let i := Classical.indefiniteDescription _ (mem_iUnion.1 (hT x.prop))\n  f i \u27e8x, i.prop\u27e9", "start": [50, 1], "end": [57, 18], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_mk", "code": "@[simp]\ntheorem iUnionLift_mk {i : \u03b9} (x : S i) (hx : (x : \u03b1) \u2208 T) :\n    iUnionLift S f hf T hT \u27e8x, hx\u27e9 = f i x", "start": [64, 1], "end": [66, 59], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_inclusion", "code": "@[simp]\ntheorem iUnionLift_inclusion {i : \u03b9} (x : S i) (h : S i \u2286 T) :\n    iUnionLift S f hf T hT (Set.inclusion h x) = f i x", "start": [69, 1], "end": [72, 20], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_of_mem", "code": "theorem iUnionLift_of_mem (x : T) {i : \u03b9} (hx : (x : \u03b1) \u2208 S i) :\n    iUnionLift S f hf T hT x = f i \u27e8x, hx\u27e9", "start": [75, 1], "end": [76, 88], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_iUnionLift", "code": "theorem preimage_iUnionLift (t : Set \u03b2) :\n    iUnionLift S f hf T hT \u207b\u00b9' t =\n      inclusion hT \u207b\u00b9' (\u22c3 i, inclusion (subset_iUnion S i) '' (f i \u207b\u00b9' t))", "start": [79, 1], "end": [90, 33], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_const", "code": "theorem iUnionLift_const (c : T) (ci : \u2200 i, S i) (hci : \u2200 i, (ci i : \u03b1) = c) (c\u03b2 : \u03b2)\n    (h : \u2200 i, f i (ci i) = c\u03b2) : iUnionLift S f hf T hT c = c\u03b2", "start": [92, 1], "end": [100, 41], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_unary", "code": "theorem iUnionLift_unary (u : T \u2192 T) (ui : \u2200 i, S i \u2192 S i)\n    (hui :\n      \u2200 (i) (x : S i),\n        u (Set.inclusion (show S i \u2286 T from hT'.symm \u25b8 Set.subset_iUnion S i) x) =\n          Set.inclusion (show S i \u2286 T from hT'.symm \u25b8 Set.subset_iUnion S i) (ui i x))\n    (u\u03b2 : \u03b2 \u2192 \u03b2) (h : \u2200 (i) (x : S i), f i (ui i x) = u\u03b2 (f i x)) (x : T) :\n    iUnionLift S f hf T (le_of_eq hT') (u x) = u\u03b2 (iUnionLift S f hf T (le_of_eq hT') x)", "start": [103, 1], "end": [120, 51], "kind": "commanddeclaration"}, {"full_name": "Set.iUnionLift_binary", "code": "theorem iUnionLift_binary (dir : Directed (\u00b7 \u2264 \u00b7) S) (op : T \u2192 T \u2192 T) (opi : \u2200 i, S i \u2192 S i \u2192 S i)\n    (hopi :\n      \u2200 i x y,\n        Set.inclusion (show S i \u2286 T from hT'.symm \u25b8 Set.subset_iUnion S i) (opi i x y) =\n          op (Set.inclusion (show S i \u2286 T from hT'.symm \u25b8 Set.subset_iUnion S i) x)\n            (Set.inclusion (show S i \u2286 T from hT'.symm \u25b8 Set.subset_iUnion S i) y))\n    (op\u03b2 : \u03b2 \u2192 \u03b2 \u2192 \u03b2) (h : \u2200 (i) (x y : S i), f i (opi i x y) = op\u03b2 (f i x) (f i y)) (x y : T) :\n    iUnionLift S f hf T (le_of_eq hT') (op x y) =\n      op\u03b2 (iUnionLift S f hf T (le_of_eq hT') x) (iUnionLift S f hf T (le_of_eq hT') y)", "start": [123, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "Set.liftCover", "code": "noncomputable def liftCover (S : \u03b9 \u2192 Set \u03b1) (f : \u2200 (i) (_ : S i), \u03b2)\n    (hf : \u2200 (i j) (x : \u03b1) (hxi : x \u2208 S i) (hxj : x \u2208 S j), f i \u27e8x, hxi\u27e9 = f j \u27e8x, hxj\u27e9)\n    (hS : iUnion S = univ) (a : \u03b1) : \u03b2 :=\n  iUnionLift S f hf univ hS.symm.subset \u27e8a, trivial\u27e9", "start": [158, 1], "end": [163, 53], "kind": "commanddeclaration"}, {"full_name": "Set.liftCover_coe", "code": "@[simp]\ntheorem liftCover_coe {i : \u03b9} (x : S i) : liftCover S f hf hS x = f i x", "start": [166, 1], "end": [168, 20], "kind": "commanddeclaration"}, {"full_name": "Set.liftCover_of_mem", "code": "theorem liftCover_of_mem {i : \u03b9} {x : \u03b1} (hx : (x : \u03b1) \u2208 S i) :\n    liftCover S f hf hS x = f i \u27e8x, hx\u27e9", "start": [171, 1], "end": [173, 53], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_liftCover", "code": "theorem preimage_liftCover (t : Set \u03b2) : liftCover S f hf hS \u207b\u00b9' t = \u22c3 i, (\u2191) '' (f i \u207b\u00b9' t)", "start": [176, 1], "end": [179, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Iso.lean", "imports": ["Mathlib/Tactic/CategoryTheory/Reassoc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Iso", "code": "structure Iso {C : Type u} [Category.{v} C] (X Y : C) where\n  \n  hom : X \u27f6 Y\n  \n  inv : Y \u27f6 X\n  \n  hom_inv_id : hom \u226b inv = \ud835\udfd9 X := by aesop_cat\n  \n  inv_hom_id : inv \u226b hom = \ud835\udfd9 Y := by aesop_cat", "start": [43, 1], "end": [60, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.ext", "code": "@[ext]\ntheorem ext \u2983\u03b1 \u03b2 : X \u2245 Y\u2984 (w : \u03b1.hom = \u03b2.hom) : \u03b1 = \u03b2", "start": [81, 1], "end": [92, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm", "code": "@[symm, pp_dot]\ndef symm (I : X \u2245 Y) : Y \u2245 X where\n  hom := I.inv\n  inv := I.hom", "start": [95, 1], "end": [99, 15], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_hom", "code": "@[simp]\ntheorem symm_hom (\u03b1 : X \u2245 Y) : \u03b1.symm.hom = \u03b1.inv", "start": [102, 1], "end": [104, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_inv", "code": "@[simp]\ntheorem symm_inv (\u03b1 : X \u2245 Y) : \u03b1.symm.inv = \u03b1.hom", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_mk", "code": "@[simp]\ntheorem symm_mk {X Y : C} (hom : X \u27f6 Y) (inv : Y \u27f6 X) (hom_inv_id) (inv_hom_id) :\n    Iso.symm { hom, inv, hom_inv_id := hom_inv_id, inv_hom_id := inv_hom_id } =\n      { hom := inv, inv := hom, hom_inv_id := inv_hom_id, inv_hom_id := hom_inv_id }", "start": [112, 1], "end": [116, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_symm_eq", "code": "@[simp]\ntheorem symm_symm_eq {X Y : C} (\u03b1 : X \u2245 Y) : \u03b1.symm.symm = \u03b1", "start": [119, 1], "end": [120, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_eq_iff", "code": "@[simp]\ntheorem symm_eq_iff {X Y : C} {\u03b1 \u03b2 : X \u2245 Y} : \u03b1.symm = \u03b2.symm \u2194 \u03b1 = \u03b2", "start": [123, 1], "end": [125, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.nonempty_iso_symm", "code": "theorem nonempty_iso_symm (X Y : C) : Nonempty (X \u2245 Y) \u2194 Nonempty (Y \u2245 X)", "start": [128, 1], "end": [129, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.refl", "code": "@[refl, simps]\ndef refl (X : C) : X \u2245 X where\n  hom := \ud835\udfd9 X\n  inv := \ud835\udfd9 X", "start": [132, 1], "end": [136, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.nonempty_iso_refl", "code": "theorem nonempty_iso_refl (X : C) : Nonempty (X \u2245 X)", "start": [143, 1], "end": [143, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.refl_symm", "code": "@[simp]\ntheorem refl_symm (X : C) : (Iso.refl X).symm = Iso.refl X", "start": [145, 1], "end": [146, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans", "code": "@[trans, simps]\ndef trans (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 Z) : X \u2245 Z where\n  hom := \u03b1.hom \u226b \u03b2.hom\n  inv := \u03b2.inv \u226b \u03b1.inv", "start": [151, 1], "end": [155, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.instTransIso", "code": "@[simps]\ninstance instTransIso : Trans (\u03b1 := C) (\u00b7 \u2245 \u00b7) (\u00b7 \u2245 \u00b7) (\u00b7 \u2245 \u00b7) where\n  trans := trans", "start": [160, 1], "end": [162, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_mk", "code": "@[simp]\ntheorem trans_mk {X Y Z : C} (hom : X \u27f6 Y) (inv : Y \u27f6 X) (hom_inv_id) (inv_hom_id)\n    (hom' : Y \u27f6 Z) (inv' : Z \u27f6 Y) (hom_inv_id') (inv_hom_id') (hom_inv_id'') (inv_hom_id'') :\n    Iso.trans \u27e8hom, inv, hom_inv_id, inv_hom_id\u27e9 \u27e8hom', inv', hom_inv_id', inv_hom_id'\u27e9 =\n     \u27e8hom \u226b hom', inv' \u226b inv, hom_inv_id'', inv_hom_id''\u27e9", "start": [167, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_symm", "code": "@[simp]\ntheorem trans_symm (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 Z) : (\u03b1 \u226a\u226b \u03b2).symm = \u03b2.symm \u226a\u226b \u03b1.symm", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_assoc", "code": "@[simp]\ntheorem trans_assoc {Z' : C} (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 Z) (\u03b3 : Z \u2245 Z') :\n    (\u03b1 \u226a\u226b \u03b2) \u226a\u226b \u03b3 = \u03b1 \u226a\u226b \u03b2 \u226a\u226b \u03b3", "start": [180, 1], "end": [183, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.refl_trans", "code": "@[simp]\ntheorem refl_trans (\u03b1 : X \u2245 Y) : Iso.refl X \u226a\u226b \u03b1 = \u03b1", "start": [186, 1], "end": [187, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.trans_refl", "code": "@[simp]\ntheorem trans_refl (\u03b1 : X \u2245 Y) : \u03b1 \u226a\u226b Iso.refl Y = \u03b1", "start": [190, 1], "end": [191, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_self_id", "code": "@[simp]\ntheorem symm_self_id (\u03b1 : X \u2245 Y) : \u03b1.symm \u226a\u226b \u03b1 = Iso.refl Y", "start": [194, 1], "end": [196, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.self_symm_id", "code": "@[simp]\ntheorem self_symm_id (\u03b1 : X \u2245 Y) : \u03b1 \u226a\u226b \u03b1.symm = Iso.refl X", "start": [199, 1], "end": [201, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.symm_self_id_assoc", "code": "@[simp]\ntheorem symm_self_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 Z) : \u03b1.symm \u226a\u226b \u03b1 \u226a\u226b \u03b2 = \u03b2", "start": [204, 1], "end": [206, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.self_symm_id_assoc", "code": "@[simp]\ntheorem self_symm_id_assoc (\u03b1 : X \u2245 Y) (\u03b2 : X \u2245 Z) : \u03b1 \u226a\u226b \u03b1.symm \u226a\u226b \u03b2 = \u03b2", "start": [209, 1], "end": [211, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_comp_eq", "code": "theorem inv_comp_eq (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : \u03b1.inv \u226b f = g \u2194 f = \u03b1.hom \u226b g", "start": [214, 1], "end": [215, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.eq_inv_comp", "code": "theorem eq_inv_comp (\u03b1 : X \u2245 Y) {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = \u03b1.inv \u226b f \u2194 \u03b1.hom \u226b g = f", "start": [218, 1], "end": [219, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.comp_inv_eq", "code": "theorem comp_inv_eq (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b \u03b1.inv = g \u2194 f = g \u226b \u03b1.hom", "start": [222, 1], "end": [223, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.eq_comp_inv", "code": "theorem eq_comp_inv (\u03b1 : X \u2245 Y) {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b \u03b1.inv \u2194 g \u226b \u03b1.hom = f", "start": [226, 1], "end": [227, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_eq_inv", "code": "theorem inv_eq_inv (f g : X \u2245 Y) : f.inv = g.inv \u2194 f.hom = g.hom", "start": [230, 1], "end": [232, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.hom_comp_eq_id", "code": "theorem hom_comp_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : \u03b1.hom \u226b f = \ud835\udfd9 X \u2194 f = \u03b1.inv", "start": [235, 1], "end": [236, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.comp_hom_eq_id", "code": "theorem comp_hom_eq_id (\u03b1 : X \u2245 Y) {f : Y \u27f6 X} : f \u226b \u03b1.hom = \ud835\udfd9 Y \u2194 f = \u03b1.inv", "start": [239, 1], "end": [240, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_comp_eq_id", "code": "theorem inv_comp_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : \u03b1.inv \u226b f = \ud835\udfd9 Y \u2194 f = \u03b1.hom", "start": [243, 1], "end": [244, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.comp_inv_eq_id", "code": "theorem comp_inv_eq_id (\u03b1 : X \u2245 Y) {f : X \u27f6 Y} : f \u226b \u03b1.inv = \ud835\udfd9 X \u2194 f = \u03b1.hom", "start": [247, 1], "end": [248, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.hom_eq_inv", "code": "theorem hom_eq_inv (\u03b1 : X \u2245 Y) (\u03b2 : Y \u2245 X) : \u03b1.hom = \u03b2.inv \u2194 \u03b2.hom = \u03b1.inv", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso", "code": "class IsIso (f : X \u27f6 Y) : Prop where\n  \n  out : \u2203 inv : Y \u27f6 X, f \u226b inv = \ud835\udfd9 X \u2227 inv \u226b f = \ud835\udfd9 Y", "start": [258, 1], "end": [261, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv", "code": "noncomputable def inv (f : X \u27f6 Y) [I : IsIso f] : Y \u27f6 X :=\n  Classical.choose I.1", "start": [264, 1], "end": [267, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.hom_inv_id", "code": "@[simp]\ntheorem hom_inv_id (f : X \u27f6 Y) [I : IsIso f] : f \u226b inv f = \ud835\udfd9 X", "start": [272, 1], "end": [274, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_hom_id", "code": "@[simp]\ntheorem inv_hom_id (f : X \u27f6 Y) [I : IsIso f] : inv f \u226b f = \ud835\udfd9 Y", "start": [277, 1], "end": [279, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.hom_inv_id_assoc", "code": "@[simp]\ntheorem hom_inv_id_assoc (f : X \u27f6 Y) [I : IsIso f] {Z} (g : X \u27f6 Z) : f \u226b inv f \u226b g = g", "start": [292, 1], "end": [294, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_hom_id_assoc", "code": "@[simp]\ntheorem inv_hom_id_assoc (f : X \u27f6 Y) [I : IsIso f] {Z} (g : Y \u27f6 Z) : inv f \u226b f \u226b g = g", "start": [297, 1], "end": [299, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.asIso", "code": "noncomputable def asIso (f : X \u27f6 Y) [IsIso f] : X \u2245 Y :=\n  \u27e8f, inv f, hom_inv_id f, inv_hom_id f\u27e9", "start": [306, 1], "end": [308, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.asIso_hom", "code": "@[simp]\ntheorem asIso_hom (f : X \u27f6 Y) {_ : IsIso f} : (asIso f).hom = f", "start": [314, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.asIso_inv", "code": "@[simp]\ntheorem asIso_inv (f : X \u27f6 Y) {_ : IsIso f} : (asIso f).inv = inv f", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.epi_of_iso", "code": "instance (priority := 100) epi_of_iso (f : X \u27f6 Y) [IsIso f] : Epi f where\n  left_cancellation g h w := by\n    rw [\u2190 IsIso.inv_hom_id_assoc f g, w, IsIso.inv_hom_id_assoc f h]", "start": [330, 1], "end": [332, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.mono_of_iso", "code": "instance (priority := 100) mono_of_iso (f : X \u27f6 Y) [IsIso f] : Mono f where\n  right_cancellation g h w := by\n    rw [\u2190 Category.comp_id g, \u2190 Category.comp_id h, \u2190 IsIso.hom_inv_id f,\n      \u2190 Category.assoc, w, \u2190 Category.assoc]", "start": [336, 1], "end": [339, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_eq_of_hom_inv_id", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\ntheorem inv_eq_of_hom_inv_id {f : X \u27f6 Y} [IsIso f] {g : Y \u27f6 X} (hom_inv_id : f \u226b g = \ud835\udfd9 X) :\n    inv f = g", "start": [343, 1], "end": [347, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_eq_of_inv_hom_id", "code": "theorem inv_eq_of_inv_hom_id {f : X \u27f6 Y} [IsIso f] {g : Y \u27f6 X} (inv_hom_id : g \u226b f = \ud835\udfd9 Y) :\n    inv f = g", "start": [350, 1], "end": [353, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.eq_inv_of_hom_inv_id", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\ntheorem eq_inv_of_hom_inv_id {f : X \u27f6 Y} [IsIso f] {g : Y \u27f6 X} (hom_inv_id : f \u226b g = \ud835\udfd9 X) :\n    g = inv f", "start": [357, 1], "end": [360, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.eq_inv_of_inv_hom_id", "code": "theorem eq_inv_of_inv_hom_id {f : X \u27f6 Y} [IsIso f] {g : Y \u27f6 X} (inv_hom_id : g \u226b f = \ud835\udfd9 Y) :\n    g = inv f", "start": [363, 1], "end": [365, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.id", "code": "instance id (X : C) : IsIso (\ud835\udfd9 X) := \u27e8\u27e8\ud835\udfd9 X, by simp\u27e9\u27e9", "start": [368, 1], "end": [368, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_iso", "code": "instance of_iso (f : X \u2245 Y) : IsIso f.hom := \u27e8\u27e8f.inv, by simp\u27e9\u27e9", "start": [371, 1], "end": [371, 64], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_iso_inv", "code": "instance of_iso_inv (f : X \u2245 Y) : IsIso f.inv := IsIso.of_iso f.symm", "start": [374, 1], "end": [374, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_isIso", "code": "instance inv_isIso [IsIso f] : IsIso (inv f) :=\n  IsIso.of_iso_inv (asIso f)", "start": [379, 1], "end": [380, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.comp_isIso", "code": "instance (priority := 900) comp_isIso [IsIso f] [IsIso h] : IsIso (f \u226b h) :=\n  IsIso.of_iso <| asIso f \u226a\u226b asIso h", "start": [387, 1], "end": [388, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_id", "code": "@[simp]\ntheorem inv_id : inv (\ud835\udfd9 X) = \ud835\udfd9 X", "start": [391, 1], "end": [394, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_comp", "code": "@[simp]\ntheorem inv_comp [IsIso f] [IsIso h] : inv (f \u226b h) = inv h \u226b inv f", "start": [397, 1], "end": [400, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_inv", "code": "@[simp]\ntheorem inv_inv [IsIso f] : inv (inv f) = f", "start": [403, 1], "end": [406, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.Iso.inv_inv", "code": "@[simp]\ntheorem Iso.inv_inv (f : X \u2245 Y) : inv f.inv = f.hom", "start": [409, 1], "end": [412, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.Iso.inv_hom", "code": "@[simp]\ntheorem Iso.inv_hom (f : X \u2245 Y) : inv f.hom = f.inv", "start": [415, 1], "end": [418, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_comp_eq", "code": "@[simp]\ntheorem inv_comp_eq (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : inv \u03b1 \u226b f = g \u2194 f = \u03b1 \u226b g", "start": [421, 1], "end": [423, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.eq_inv_comp", "code": "@[simp]\ntheorem eq_inv_comp (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : X \u27f6 Z} {g : Y \u27f6 Z} : g = inv \u03b1 \u226b f \u2194 \u03b1 \u226b g = f", "start": [426, 1], "end": [428, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.comp_inv_eq", "code": "@[simp]\ntheorem comp_inv_eq (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : Z \u27f6 Y} {g : Z \u27f6 X} : f \u226b inv \u03b1 = g \u2194 f = g \u226b \u03b1", "start": [431, 1], "end": [433, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.eq_comp_inv", "code": "@[simp]\ntheorem eq_comp_inv (\u03b1 : X \u27f6 Y) [IsIso \u03b1] {f : Z \u27f6 Y} {g : Z \u27f6 X} : g = f \u226b inv \u03b1 \u2194 g \u226b \u03b1 = f", "start": [436, 1], "end": [438, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_isIso_comp_left", "code": "theorem of_isIso_comp_left {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso f] [IsIso (f \u226b g)] :\n    IsIso g", "start": [441, 1], "end": [444, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_isIso_comp_right", "code": "theorem of_isIso_comp_right {X Y Z : C} (f : X \u27f6 Y) (g : Y \u27f6 Z) [IsIso g] [IsIso (f \u226b g)] :\n    IsIso f", "start": [447, 1], "end": [450, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_isIso_fac_left", "code": "theorem of_isIso_fac_left {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {h : X \u27f6 Z} [IsIso f]\n    [hh : IsIso h] (w : f \u226b g = h) : IsIso g", "start": [453, 1], "end": [457, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.of_isIso_fac_right", "code": "theorem of_isIso_fac_right {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} {h : X \u27f6 Z} [IsIso g]\n    [hh : IsIso h] (w : f \u226b g = h) : IsIso f", "start": [460, 1], "end": [464, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_of_inv_eq_inv", "code": "theorem eq_of_inv_eq_inv {f g : X \u27f6 Y} [IsIso f] [IsIso g] (p : inv f = inv g) : f = g", "start": [471, 1], "end": [473, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsIso.inv_eq_inv", "code": "theorem IsIso.inv_eq_inv {f g : X \u27f6 Y} [IsIso f] [IsIso g] : inv f = inv g \u2194 f = g", "start": [476, 1], "end": [477, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.hom_comp_eq_id", "code": "theorem hom_comp_eq_id (g : X \u27f6 Y) [IsIso g] {f : Y \u27f6 X} : g \u226b f = \ud835\udfd9 X \u2194 f = inv g", "start": [480, 1], "end": [481, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_hom_eq_id", "code": "theorem comp_hom_eq_id (g : X \u27f6 Y) [IsIso g] {f : Y \u27f6 X} : f \u226b g = \ud835\udfd9 Y \u2194 f = inv g", "start": [484, 1], "end": [485, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv_comp_eq_id", "code": "theorem inv_comp_eq_id (g : X \u27f6 Y) [IsIso g] {f : X \u27f6 Y} : inv g \u226b f = \ud835\udfd9 Y \u2194 f = g", "start": [488, 1], "end": [489, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_inv_eq_id", "code": "theorem comp_inv_eq_id (g : X \u27f6 Y) [IsIso g] {f : X \u27f6 Y} : f \u226b inv g = \ud835\udfd9 X \u2194 f = g", "start": [492, 1], "end": [493, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_hom_comp_eq_id", "code": "theorem isIso_of_hom_comp_eq_id (g : X \u27f6 Y) [IsIso g] {f : Y \u27f6 X} (h : g \u226b f = \ud835\udfd9 X) : IsIso f", "start": [496, 1], "end": [498, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_comp_hom_eq_id", "code": "theorem isIso_of_comp_hom_eq_id (g : X \u27f6 Y) [IsIso g] {f : Y \u27f6 X} (h : f \u226b g = \ud835\udfd9 Y) : IsIso f", "start": [501, 1], "end": [503, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_ext", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\ntheorem inv_ext {f : X \u2245 Y} {g : Y \u27f6 X} (hom_inv_id : f.hom \u226b g = \ud835\udfd9 X) : f.inv = g", "start": [509, 1], "end": [511, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_ext'", "code": "@[aesop apply safe (rule_sets [CategoryTheory])]\ntheorem inv_ext' {f : X \u2245 Y} {g : Y \u27f6 X} (hom_inv_id : f.hom \u226b g = \ud835\udfd9 X) : g = f.inv", "start": [515, 1], "end": [517, 34], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_hom_left", "code": "@[simp]\ntheorem cancel_iso_hom_left {X Y Z : C} (f : X \u2245 Y) (g g' : Y \u27f6 Z) :\n    f.hom \u226b g = f.hom \u226b g' \u2194 g = g'", "start": [534, 1], "end": [537, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_inv_left", "code": "@[simp]\ntheorem cancel_iso_inv_left {X Y Z : C} (f : Y \u2245 X) (g g' : Y \u27f6 Z) :\n    f.inv \u226b g = f.inv \u226b g' \u2194 g = g'", "start": [540, 1], "end": [543, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_hom_right", "code": "@[simp]\ntheorem cancel_iso_hom_right {X Y Z : C} (f f' : X \u27f6 Y) (g : Y \u2245 Z) :\n    f \u226b g.hom = f' \u226b g.hom \u2194 f = f'", "start": [546, 1], "end": [549, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_inv_right", "code": "@[simp]\ntheorem cancel_iso_inv_right {X Y Z : C} (f f' : X \u27f6 Y) (g : Z \u2245 Y) :\n    f \u226b g.inv = f' \u226b g.inv \u2194 f = f'", "start": [552, 1], "end": [555, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_hom_right_assoc", "code": "@[simp]\ntheorem cancel_iso_hom_right_assoc {W X X' Y Z : C} (f : W \u27f6 X) (g : X \u27f6 Y) (f' : W \u27f6 X')\n    (g' : X' \u27f6 Y) (h : Y \u2245 Z) : f \u226b g \u226b h.hom = f' \u226b g' \u226b h.hom \u2194 f \u226b g = f' \u226b g'", "start": [565, 1], "end": [568, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.cancel_iso_inv_right_assoc", "code": "@[simp]\ntheorem cancel_iso_inv_right_assoc {W X X' Y Z : C} (f : W \u27f6 X) (g : X \u27f6 Y) (f' : W \u27f6 X')\n    (g' : X' \u27f6 Y) (h : Z \u2245 Y) : f \u226b g \u226b h.inv = f' \u226b g' \u226b h.inv \u2194 f \u226b g = f' \u226b g'", "start": [571, 1], "end": [574, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapIso", "code": "@[simps, pp_dot]\ndef mapIso (F : C \u2964 D) {X Y : C} (i : X \u2245 Y) : F.obj X \u2245 F.obj Y where\n  hom := F.map i.hom\n  inv := F.map i.inv\n  hom_inv_id := by rw [\u2190 map_comp, Iso.hom_inv_id, \u2190 map_id]\n  inv_hom_id := by rw [\u2190 map_comp, Iso.inv_hom_id, \u2190 map_id]", "start": [587, 1], "end": [593, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapIso_symm", "code": "@[simp]\ntheorem mapIso_symm (F : C \u2964 D) {X Y : C} (i : X \u2245 Y) : F.mapIso i.symm = (F.mapIso i).symm", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapIso_trans", "code": "@[simp]\ntheorem mapIso_trans (F : C \u2964 D) {X Y Z : C} (i : X \u2245 Y) (j : Y \u2245 Z) :\n    F.mapIso (i \u226a\u226b j) = F.mapIso i \u226a\u226b F.mapIso j", "start": [603, 1], "end": [606, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapIso_refl", "code": "@[simp]\ntheorem mapIso_refl (F : C \u2964 D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X)", "start": [609, 1], "end": [611, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_isIso", "code": "instance map_isIso (F : C \u2964 D) (f : X \u27f6 Y) [IsIso f] : IsIso (F.map f) :=\n  IsIso.of_iso <| F.mapIso (asIso f)", "start": [614, 1], "end": [615, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_inv", "code": "@[simp]\ntheorem map_inv (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) [IsIso f] : F.map (inv f) = inv (F.map f)", "start": [618, 1], "end": [621, 22], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_hom_inv", "code": "theorem map_hom_inv (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) [IsIso f] :\n    F.map f \u226b F.map (inv f) = \ud835\udfd9 (F.obj X)", "start": [624, 1], "end": [625, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_inv_hom", "code": "theorem map_inv_hom (F : C \u2964 D) {X Y : C} (f : X \u27f6 Y) [IsIso f] :\n    F.map (inv f) \u226b F.map f = \ud835\udfd9 (F.obj Y)", "start": [628, 1], "end": [629, 53], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/NatTrans.lean", "imports": ["Mathlib/Tactic/CategoryTheory/Reassoc.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.NatTrans", "code": "@[ext, pp_dot]\nstructure NatTrans (F G : C \u2964 D) : Type max u\u2081 v\u2082 where\n  \n  app : \u2200 X : C, F.obj X \u27f6 G.obj X\n  \n  naturality : \u2200 \u2983X Y : C\u2984 (f : X \u27f6 Y), F.map f \u226b app Y = app X \u226b G.map f := by aesop_cat", "start": [41, 1], "end": [52, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congr_app", "code": "theorem congr_app {F G : C \u2964 D} {\u03b1 \u03b2 : NatTrans F G} (h : \u03b1 = \u03b2) (X : C) : \u03b1.app X = \u03b2.app X", "start": [63, 1], "end": [64, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.id", "code": "protected def id (F : C \u2964 D) : NatTrans F F where app X := \ud835\udfd9 (F.obj X)", "start": [71, 1], "end": [72, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.id_app'", "code": "@[simp]\ntheorem id_app' (F : C \u2964 D) (X : C) : (NatTrans.id F).app X = \ud835\udfd9 (F.obj X)", "start": [75, 1], "end": [76, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.vcomp", "code": "def vcomp (\u03b1 : NatTrans F G) (\u03b2 : NatTrans G H) : NatTrans F H where\n  app X := \u03b1.app X \u226b \u03b2.app X", "start": [89, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.vcomp_app", "code": "theorem vcomp_app (\u03b1 : NatTrans F G) (\u03b2 : NatTrans G H) (X : C) :\n    (vcomp \u03b1 \u03b2).app X = \u03b1.app X \u226b \u03b2.app X", "start": [96, 1], "end": [97, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/Trace.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.trace", "code": "def trace (A : Matrix n n R) : R :=\n  \u2211 i, diag A i", "start": [37, 1], "end": [42, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_diagonal", "code": "lemma trace_diagonal {o} [Fintype o] [DecidableEq o] (d : o \u2192 R) :\n    trace (diagonal d) = \u2211 i, d i := by\n  simp only [trace, diag_apply, diagonal_apply_eq]", "start": [45, 1], "end": [47, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.trace_zero", "code": "@[simp]\ntheorem trace_zero : trace (0 : Matrix n n R) = 0", "start": [51, 1], "end": [53, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_eq_zero_of_isEmpty", "code": "@[simp]\nlemma trace_eq_zero_of_isEmpty [IsEmpty n] (A : Matrix n n R) : trace A = 0 := by simp [trace]", "start": [58, 1], "end": [59, 95], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.trace_add", "code": "@[simp]\ntheorem trace_add (A B : Matrix n n R) : trace (A + B) = trace A + trace B", "start": [61, 1], "end": [63, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_smul", "code": "@[simp]\ntheorem trace_smul [Monoid \u03b1] [DistribMulAction \u03b1 R] (r : \u03b1) (A : Matrix n n R) :\n    trace (r \u2022 A) = r \u2022 trace A", "start": [66, 1], "end": [69, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_transpose", "code": "@[simp]\ntheorem trace_transpose (A : Matrix n n R) : trace A\u1d40 = trace A", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_conjTranspose", "code": "@[simp]\ntheorem trace_conjTranspose [StarAddMonoid R] (A : Matrix n n R) : trace A\u1d34 = star (trace A)", "start": [77, 1], "end": [79, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.traceAddMonoidHom", "code": "@[simps]\ndef traceAddMonoidHom : Matrix n n R \u2192+ R where\n  toFun := trace\n  map_zero' := trace_zero n R\n  map_add' := trace_add", "start": [84, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.traceLinearMap", "code": "@[simps]\ndef traceLinearMap [Semiring \u03b1] [Module \u03b1 R] : Matrix n n R \u2192\u2097[\u03b1] R where\n  toFun := trace\n  map_add' := trace_add\n  map_smul' := trace_smul", "start": [92, 1], "end": [97, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_list_sum", "code": "@[simp]\ntheorem trace_list_sum (l : List (Matrix n n R)) : trace l.sum = (l.map trace).sum", "start": [102, 1], "end": [104, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_multiset_sum", "code": "@[simp]\ntheorem trace_multiset_sum (s : Multiset (Matrix n n R)) : trace s.sum = (s.map trace).sum", "start": [107, 1], "end": [109, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_sum", "code": "@[simp]\ntheorem trace_sum (s : Finset \u03b9) (f : \u03b9 \u2192 Matrix n n R) :\n    trace (\u2211 i in s, f i) = \u2211 i in s, trace (f i)", "start": [112, 1], "end": [115, 38], "kind": "commanddeclaration"}, {"full_name": "AddMonoidHom.map_trace", "code": "theorem _root_.AddMonoidHom.map_trace [AddCommMonoid S] (f : R \u2192+ S) (A : Matrix n n R) :\n    f (trace A)  = trace (f.mapMatrix A)", "start": [118, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_sub", "code": "@[simp]\ntheorem trace_sub (A B : Matrix n n R) : trace (A - B) = trace A - trace B", "start": [128, 1], "end": [130, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_neg", "code": "@[simp]\ntheorem trace_neg (A : Matrix n n R) : trace (-A) = -trace A", "start": [133, 1], "end": [135, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_one", "code": "@[simp]\ntheorem trace_one : trace (1 : Matrix n n R) = Fintype.card n", "start": [144, 1], "end": [146, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_transpose_mul", "code": "@[simp]\ntheorem trace_transpose_mul [AddCommMonoid R] [Mul R] (A : Matrix m n R) (B : Matrix n m R) :\n    trace (A\u1d40 * B\u1d40) = trace (A * B)", "start": [153, 1], "end": [156, 18], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_mul_comm", "code": "theorem trace_mul_comm [AddCommMonoid R] [CommSemigroup R] (A : Matrix m n R) (B : Matrix n m R) :\n    trace (A * B) = trace (B * A)", "start": [159, 1], "end": [160, 101], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_mul_cycle", "code": "theorem trace_mul_cycle [NonUnitalCommSemiring R] (A : Matrix m n R) (B : Matrix n p R)\n    (C : Matrix p m R) : trace (A * B * C) = trace (C * A * B)", "start": [163, 1], "end": [165, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_mul_cycle'", "code": "theorem trace_mul_cycle' [NonUnitalCommSemiring R] (A : Matrix m n R) (B : Matrix n p R)\n    (C : Matrix p m R) : trace (A * (B * C)) = trace (C * (A * B))", "start": [168, 1], "end": [170, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_col_mul_row", "code": "@[simp]\ntheorem trace_col_mul_row [NonUnitalNonAssocSemiring R] (a b : n \u2192 R) :\n    trace (col a * row b) = dotProduct a b", "start": [173, 1], "end": [177, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_fin_zero", "code": "theorem trace_fin_zero (A : Matrix (Fin 0) (Fin 0) R) : trace A = 0", "start": [193, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_fin_one", "code": "theorem trace_fin_one (A : Matrix (Fin 1) (Fin 1) R) : trace A = A 0 0", "start": [197, 1], "end": [198, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_fin_two", "code": "theorem trace_fin_two (A : Matrix (Fin 2) (Fin 2) R) : trace A = A 0 0 + A 1 1", "start": [201, 1], "end": [202, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.trace_fin_three", "code": "theorem trace_fin_three (A : Matrix (Fin 3) (Fin 3) R) : trace A = A 0 0 + A 1 1 + A 2 2", "start": [205, 1], "end": [207, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/Operations.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/RingTheory/Coprime/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Basis/Bilinear.lean", "Mathlib/Algebra/Algebra/Operations.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/RingTheory/NonZeroDivisors.lean"], "premises": [{"full_name": "Submodule.hasSMul'", "code": "instance hasSMul' : SMul (Ideal R) (Submodule R M) :=\n  \u27e8Submodule.map\u2082 (LinearMap.lsmul R M)\u27e9", "start": [34, 1], "end": [35, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.smul_eq_mul", "code": "protected theorem _root_.Ideal.smul_eq_mul (I J : Ideal R) : I \u2022 J = I * J", "start": [38, 1], "end": [41, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator", "code": "def annihilator (N : Submodule R M) : Ideal R :=\n  LinearMap.ker (LinearMap.lsmul R N)", "start": [44, 1], "end": [46, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_annihilator", "code": "theorem mem_annihilator {r} : r \u2208 N.annihilator \u2194 \u2200 n \u2208 N, r \u2022 n = (0 : M)", "start": [51, 1], "end": [53, 84], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_annihilator'", "code": "theorem mem_annihilator' {r} : r \u2208 N.annihilator \u2194 N \u2264 comap (r \u2022 (LinearMap.id : M \u2192\u2097[R] M)) \u22a5", "start": [56, 1], "end": [57, 101], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_annihilator_span", "code": "theorem mem_annihilator_span (s : Set M) (r : R) :\n    r \u2208 (Submodule.span R s).annihilator \u2194 \u2200 n : s, r \u2022 (n : M) = 0", "start": [60, 1], "end": [74, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_annihilator_span_singleton", "code": "theorem mem_annihilator_span_singleton (g : M) (r : R) :\n    r \u2208 (Submodule.span R ({g} : Set M)).annihilator \u2194 r \u2022 g = 0", "start": [77, 1], "end": [78, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_bot", "code": "theorem annihilator_bot : (\u22a5 : Submodule R M).annihilator = \u22a4", "start": [81, 1], "end": [82, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_eq_top_iff", "code": "theorem annihilator_eq_top_iff : N.annihilator = \u22a4 \u2194 N = \u22a5", "start": [85, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_mono", "code": "theorem annihilator_mono (h : N \u2264 P) : P.annihilator \u2264 N.annihilator", "start": [92, 1], "end": [93, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_iSup", "code": "theorem annihilator_iSup (\u03b9 : Sort w) (f : \u03b9 \u2192 Submodule R M) :\n    annihilator (\u2a06 i, f i) = \u2a05 i, annihilator (f i)", "start": [96, 1], "end": [102, 32], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_smul", "code": "theorem smul_mem_smul {r} {n} (hr : r \u2208 I) (hn : n \u2208 N) : r \u2022 n \u2208 I \u2022 N", "start": [105, 1], "end": [106, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_le", "code": "theorem smul_le {P : Submodule R M} : I \u2022 N \u2264 P \u2194 \u2200 r \u2208 I, \u2200 n \u2208 N, r \u2022 n \u2208 P", "start": [109, 1], "end": [110, 10], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_induction_on", "code": "@[elab_as_elim]\ntheorem smul_induction_on {p : M \u2192 Prop} {x} (H : x \u2208 I \u2022 N) (Hb : \u2200 r \u2208 I, \u2200 n \u2208 N, p (r \u2022 n))\n    (H1 : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) : p x", "start": [113, 1], "end": [120, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_induction_on'", "code": "@[elab_as_elim]\ntheorem smul_induction_on' {x : M} (hx : x \u2208 I \u2022 N) {p : \u2200 x, x \u2208 I \u2022 N \u2192 Prop}\n    (Hb : \u2200 (r : R) (hr : r \u2208 I) (n : M) (hn : n \u2208 N), p (r \u2022 n) (smul_mem_smul hr hn))\n    (H1 : \u2200 x hx y hy, p x hx \u2192 p y hy \u2192 p (x + y) (Submodule.add_mem _ \u2039_\u203a \u2039_\u203a)) : p x hx", "start": [123, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_smul_span_singleton", "code": "theorem mem_smul_span_singleton {I : Ideal R} {m : M} {x : M} :\n    x \u2208 I \u2022 span R ({m} : Set M) \u2194 \u2203 y \u2208 I, y \u2022 m = x", "start": [134, 1], "end": [143, 85], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_le_right", "code": "theorem smul_le_right : I \u2022 N \u2264 N", "start": [146, 1], "end": [147, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mono", "code": "theorem smul_mono (hij : I \u2264 J) (hnp : N \u2264 P) : I \u2022 N \u2264 J \u2022 P", "start": [150, 1], "end": [151, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mono_left", "code": "theorem smul_mono_left (h : I \u2264 J) : I \u2022 N \u2264 J \u2022 N", "start": [154, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mono_right", "code": "theorem smul_mono_right (h : N \u2264 P) : I \u2022 N \u2264 I \u2022 P", "start": [158, 1], "end": [159, 23], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_le_smul_top", "code": "theorem map_le_smul_top (I : Ideal R) (f : R \u2192\u2097[R] M) :\n    Submodule.map f I \u2264 I \u2022 (\u22a4 : Submodule R M)", "start": [162, 1], "end": [166, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_smul", "code": "@[simp]\ntheorem annihilator_smul (N : Submodule R M) : annihilator N \u2022 N = \u22a5", "start": [169, 1], "end": [171, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.annihilator_mul", "code": "@[simp]\ntheorem annihilator_mul (I : Ideal R) : annihilator I * I = \u22a5", "start": [174, 1], "end": [176, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.mul_annihilator", "code": "@[simp]\ntheorem mul_annihilator (I : Ideal R) : I * annihilator I = \u22a5", "start": [179, 1], "end": [180, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_bot", "code": "@[simp]\ntheorem smul_bot : I \u2022 (\u22a5 : Submodule R M) = \u22a5", "start": [185, 1], "end": [187, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.bot_smul", "code": "@[simp]\ntheorem bot_smul : (\u22a5 : Ideal R) \u2022 N = \u22a5", "start": [190, 1], "end": [192, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.top_smul", "code": "@[simp]\ntheorem top_smul : (\u22a4 : Ideal R) \u2022 N = N", "start": [195, 1], "end": [197, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_sup", "code": "theorem smul_sup : I \u2022 (N \u2294 P) = I \u2022 N \u2294 I \u2022 P", "start": [200, 1], "end": [201, 25], "kind": "commanddeclaration"}, {"full_name": "Submodule.sup_smul", "code": "theorem sup_smul : (I \u2294 J) \u2022 N = I \u2022 N \u2294 J \u2022 N", "start": [204, 1], "end": [205, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_assoc", "code": "protected theorem smul_assoc : (I \u2022 J) \u2022 N = I \u2022 J \u2022 N", "start": [208, 1], "end": [218, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_inf_le", "code": "theorem smul_inf_le (M\u2081 M\u2082 : Submodule R M) : I \u2022 (M\u2081 \u2293 M\u2082) \u2264 I \u2022 M\u2081 \u2293 I \u2022 M\u2082", "start": [221, 1], "end": [222, 90], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_iSup", "code": "theorem smul_iSup {\u03b9 : Sort*} {I : Ideal R} {t : \u03b9 \u2192 Submodule R M} : I \u2022 iSup t = \u2a06 i, I \u2022 t i", "start": [225, 1], "end": [226, 24], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_iInf_le", "code": "theorem smul_iInf_le {\u03b9 : Sort*} {I : Ideal R} {t : \u03b9 \u2192 Submodule R M} :\n    I \u2022 iInf t \u2264 \u2a05 i, I \u2022 t i", "start": [229, 1], "end": [231, 49], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_smul_span", "code": "theorem span_smul_span : Ideal.span S \u2022 span R T = span R (\u22c3 (s \u2208 S) (t \u2208 T), {s \u2022 t})", "start": [236, 1], "end": [237, 78], "kind": "commanddeclaration"}, {"full_name": "Submodule.ideal_span_singleton_smul", "code": "theorem ideal_span_singleton_smul (r : R) (N : Submodule R M) :\n    (Ideal.span {r} : Ideal R) \u2022 N = r \u2022 N", "start": [240, 1], "end": [246, 8], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_of_span_top_of_smul_mem", "code": "theorem mem_of_span_top_of_smul_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = \u22a4) (x : M)\n    (H : \u2200 r : s, (r : R) \u2022 x \u2208 M') : x \u2208 M'", "start": [249, 1], "end": [255, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_of_span_eq_top_of_smul_pow_mem", "code": "theorem mem_of_span_eq_top_of_smul_pow_mem (M' : Submodule R M) (s : Set R) (hs : Ideal.span s = \u22a4)\n    (x : M) (H : \u2200 r : s, \u2203 n : \u2115, ((r : R) ^ n : R) \u2022 x \u2208 M') : x \u2208 M'", "start": [258, 1], "end": [271, 80], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_smul''", "code": "theorem map_smul'' (f : M \u2192\u2097[R] M') : (I \u2022 N).map f = I \u2022 N.map f", "start": [276, 1], "end": [284, 66], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_smul_span", "code": "theorem mem_smul_span {s : Set M} {x : M} :\n    x \u2208 I \u2022 Submodule.span R s \u2194 x \u2208 Submodule.span R (\u22c3 (a \u2208 I) (b \u2208 s), ({a \u2022 b} : Set M))", "start": [289, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_ideal_smul_span_iff_exists_sum", "code": "theorem mem_ideal_smul_span_iff_exists_sum {\u03b9 : Type*} (f : \u03b9 \u2192 M) (x : M) :\n    x \u2208 I \u2022 span R (Set.range f) \u2194\n      \u2203 (a : \u03b9 \u2192\u2080 R) (_ : \u2200 i, a i \u2208 I), (a.sum fun i c => c \u2022 f i) = x", "start": [297, 1], "end": [322, 97], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_ideal_smul_span_iff_exists_sum'", "code": "theorem mem_ideal_smul_span_iff_exists_sum' {\u03b9 : Type*} (s : Set \u03b9) (f : \u03b9 \u2192 M) (x : M) :\n    x \u2208 I \u2022 span R (f '' s) \u2194 \u2203 (a : s \u2192\u2080 R) (_ : \u2200 i, a i \u2208 I), (a.sum fun i c => c \u2022 f i) = x", "start": [325, 1], "end": [327, 79], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_smul_top_iff", "code": "theorem mem_smul_top_iff (N : Submodule R M) (x : N) :\n    x \u2208 I \u2022 (\u22a4 : Submodule R N) \u2194 (x : M) \u2208 I \u2022 N", "start": [330, 1], "end": [336, 68], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_comap_le_comap_smul", "code": "@[simp]\ntheorem smul_comap_le_comap_smul (f : M \u2192\u2097[R] M') (S : Submodule R M') (I : Ideal R) :\n    I \u2022 S.comap f \u2264 (I \u2022 S).comap f", "start": [339, 1], "end": [345, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.colon", "code": "def colon (N P : Submodule R M) : Ideal R :=\n  annihilator (P.map N.mkQ)", "start": [356, 1], "end": [358, 28], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_colon", "code": "theorem mem_colon {r} : r \u2208 N.colon P \u2194 \u2200 p \u2208 P, r \u2022 p \u2208 N", "start": [361, 1], "end": [364, 97], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_colon'", "code": "theorem mem_colon' {r} : r \u2208 N.colon P \u2194 P \u2264 comap (r \u2022 (LinearMap.id : M \u2192\u2097[R] M)) N", "start": [367, 1], "end": [368, 12], "kind": "commanddeclaration"}, {"full_name": "Submodule.colon_mono", "code": "theorem colon_mono (hn : N\u2081 \u2264 N\u2082) (hp : P\u2081 \u2264 P\u2082) : N\u2081.colon P\u2082 \u2264 N\u2082.colon P\u2081", "start": [371, 1], "end": [372, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.iInf_colon_iSup", "code": "theorem iInf_colon_iSup (\u03b9\u2081 : Sort w) (f : \u03b9\u2081 \u2192 Submodule R M) (\u03b9\u2082 : Sort x)\n    (g : \u03b9\u2082 \u2192 Submodule R M) : (\u2a05 i, f i).colon (\u2a06 j, g j) = \u2a05 (i) (j), (f i).colon (g j)", "start": [375, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_colon_singleton", "code": "@[simp]\ntheorem mem_colon_singleton {N : Submodule R M} {x : M} {r : R} :\n    r \u2208 N.colon (Submodule.span R {x}) \u2194 r \u2022 x \u2208 N", "start": [389, 1], "end": [395, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_colon_singleton", "code": "@[simp]\ntheorem _root_.Ideal.mem_colon_singleton {I : Ideal R} {x r : R} :\n    r \u2208 I.colon (Ideal.span {x}) \u2194 r * x \u2208 I", "start": [398, 1], "end": [401, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.add_eq_sup", "code": "@[simp]\ntheorem add_eq_sup {I J : Ideal R} : I + J = I \u2294 J", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.zero_eq_bot", "code": "@[simp]\ntheorem zero_eq_bot : (0 : Ideal R) = \u22a5", "start": [419, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.sum_eq_sup", "code": "@[simp]\ntheorem sum_eq_sup {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 Ideal R) : s.sum f = s.sup f", "start": [424, 1], "end": [426, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.one_eq_top", "code": "@[simp]\ntheorem one_eq_top : (1 : Ideal R) = \u22a4", "start": [440, 1], "end": [441, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.add_eq_one_iff", "code": "theorem add_eq_one_iff : I + J = 1 \u2194 \u2203 i \u2208 I, \u2203 j \u2208 J, i + j = 1", "start": [444, 1], "end": [445, 65], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mem_mul", "code": "theorem mul_mem_mul {r s} (hr : r \u2208 I) (hs : s \u2208 J) : r * s \u2208 I * J", "start": [447, 1], "end": [448, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mem_mul_rev", "code": "theorem mul_mem_mul_rev {r s} (hr : r \u2208 I) (hs : s \u2208 J) : s * r \u2208 I * J", "start": [451, 1], "end": [452, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_mem_pow", "code": "theorem pow_mem_pow {x : R} (hx : x \u2208 I) (n : \u2115) : x ^ n \u2208 I ^ n", "start": [455, 1], "end": [456, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_mem_prod", "code": "theorem prod_mem_prod {\u03b9 : Type*} {s : Finset \u03b9} {I : \u03b9 \u2192 Ideal R} {x : \u03b9 \u2192 R} :\n    (\u2200 i \u2208 s, x i \u2208 I i) \u2192 (\u220f i in s, x i) \u2208 \u220f i in s, I i", "start": [459, 1], "end": [470, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_le", "code": "theorem mul_le : I * J \u2264 K \u2194 \u2200 r \u2208 I, \u2200 s \u2208 J, r * s \u2208 K", "start": [473, 1], "end": [474, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_le_left", "code": "theorem mul_le_left : I * J \u2264 J", "start": [477, 1], "end": [478, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_le_right", "code": "theorem mul_le_right : I * J \u2264 I", "start": [481, 1], "end": [482, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_mul_right_self", "code": "@[simp]\ntheorem sup_mul_right_self : I \u2294 I * J = I", "start": [485, 1], "end": [487, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_mul_left_self", "code": "@[simp]\ntheorem sup_mul_left_self : I \u2294 J * I = I", "start": [490, 1], "end": [492, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_right_self_sup", "code": "@[simp]\ntheorem mul_right_self_sup : I * J \u2294 I = I", "start": [495, 1], "end": [497, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_left_self_sup", "code": "@[simp]\ntheorem mul_left_self_sup : J * I \u2294 I = I", "start": [500, 1], "end": [502, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_comm", "code": "protected theorem mul_comm : I * J = J * I", "start": [507, 1], "end": [509, 58], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_assoc", "code": "protected theorem mul_assoc : I * J * K = I * (J * K)", "start": [512, 1], "end": [513, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_mul_span", "code": "theorem span_mul_span (S T : Set R) : span S * span T = span (\u22c3 (s \u2208 S) (t \u2208 T), {s * t})", "start": [516, 1], "end": [517, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_mul_span'", "code": "theorem span_mul_span' (S T : Set R) : span S * span T = span (S * T)", "start": [522, 1], "end": [524, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_span_singleton", "code": "theorem span_singleton_mul_span_singleton (r s : R) :\n    span {r} * span {s} = (span {r * s} : Ideal R)", "start": [527, 1], "end": [530, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_pow", "code": "theorem span_singleton_pow (s : R) (n : \u2115) : span {s} ^ n = (span {s ^ n} : Ideal R)", "start": [533, 1], "end": [535, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_mul_span_singleton", "code": "theorem mem_mul_span_singleton {x y : R} {I : Ideal R} : x \u2208 I * span {y} \u2194 \u2203 z \u2208 I, z * y = x", "start": [538, 1], "end": [539, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_span_singleton_mul", "code": "theorem mem_span_singleton_mul {x y : R} {I : Ideal R} : x \u2208 span {y} * I \u2194 \u2203 z \u2208 I, y * z = x", "start": [542, 1], "end": [543, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_span_singleton_mul_iff", "code": "theorem le_span_singleton_mul_iff {x : R} {I J : Ideal R} :\n    I \u2264 span {x} * J \u2194 \u2200 zI \u2208 I, \u2203 zJ \u2208 J, x * zJ = zI", "start": [546, 1], "end": [549, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_le_iff", "code": "theorem span_singleton_mul_le_iff {x : R} {I J : Ideal R} :\n    span {x} * I \u2264 J \u2194 \u2200 z \u2208 I, x * z \u2208 J", "start": [552, 1], "end": [560, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_le_span_singleton_mul", "code": "theorem span_singleton_mul_le_span_singleton_mul {x y : R} {I J : Ideal R} :\n    span {x} * I \u2264 span {y} * J \u2194 \u2200 zI \u2208 I, \u2203 zJ \u2208 J, x * zI = y * zJ", "start": [563, 1], "end": [565, 73], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_right_mono", "code": "theorem span_singleton_mul_right_mono [IsDomain R] {x : R} (hx : x \u2260 0) :\n    span {x} * I \u2264 span {x} * J \u2194 I \u2264 J", "start": [568, 1], "end": [571, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_left_mono", "code": "theorem span_singleton_mul_left_mono [IsDomain R] {x : R} (hx : x \u2260 0) :\n    I * span {x} \u2264 J * span {x} \u2194 I \u2264 J", "start": [574, 1], "end": [576, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_right_inj", "code": "theorem span_singleton_mul_right_inj [IsDomain R] {x : R} (hx : x \u2260 0) :\n    span {x} * I = span {x} * J \u2194 I = J", "start": [579, 1], "end": [581, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_left_inj", "code": "theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x \u2260 0) :\n    I * span {x} = J * span {x} \u2194 I = J", "start": [584, 1], "end": [586, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_right_injective", "code": "theorem span_singleton_mul_right_injective [IsDomain R] {x : R} (hx : x \u2260 0) :\n    Function.Injective ((\u00b7 * \u00b7) (span {x} : Ideal R))", "start": [589, 1], "end": [591, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_left_injective", "code": "theorem span_singleton_mul_left_injective [IsDomain R] {x : R} (hx : x \u2260 0) :\n    Function.Injective fun I : Ideal R => I * span {x}", "start": [594, 1], "end": [596, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.eq_span_singleton_mul", "code": "theorem eq_span_singleton_mul {x : R} (I J : Ideal R) :\n    I = span {x} * J \u2194 (\u2200 zI \u2208 I, \u2203 zJ \u2208 J, x * zJ = zI) \u2227 \u2200 z \u2208 J, x * z \u2208 I", "start": [599, 1], "end": [601, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_mul_eq_span_singleton_mul", "code": "theorem span_singleton_mul_eq_span_singleton_mul {x y : R} (I J : Ideal R) :\n    span {x} * I = span {y} * J \u2194\n      (\u2200 zI \u2208 I, \u2203 zJ \u2208 J, x * zI = y * zJ) \u2227 \u2200 zJ \u2208 J, \u2203 zI \u2208 I, x * zI = y * zJ", "start": [604, 1], "end": [607, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_span", "code": "theorem prod_span {\u03b9 : Type*} (s : Finset \u03b9) (I : \u03b9 \u2192 Set R) :\n    (\u220f i in s, Ideal.span (I i)) = Ideal.span (\u220f i in s, I i)", "start": [610, 1], "end": [612, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_span_singleton", "code": "theorem prod_span_singleton {\u03b9 : Type*} (s : Finset \u03b9) (I : \u03b9 \u2192 R) :\n    (\u220f i in s, Ideal.span ({I i} : Set R)) = Ideal.span {\u220f i in s, I i}", "start": [615, 1], "end": [617, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.multiset_prod_span_singleton", "code": "@[simp]\ntheorem multiset_prod_span_singleton (m : Multiset R) :\n    (m.map fun x => Ideal.span {x}).prod = Ideal.span ({Multiset.prod m} : Set R)", "start": [620, 1], "end": [624, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.finset_inf_span_singleton", "code": "theorem finset_inf_span_singleton {\u03b9 : Type*} (s : Finset \u03b9) (I : \u03b9 \u2192 R)\n    (hI : Set.Pairwise (\u2191s) (IsCoprime on I)) :\n    (s.inf fun i => Ideal.span ({I i} : Set R)) = Ideal.span {\u220f i in s, I i}", "start": [627, 1], "end": [632, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_span_singleton", "code": "theorem iInf_span_singleton {\u03b9 : Type*} [Fintype \u03b9] {I : \u03b9 \u2192 R}\n    (hI : \u2200 (i j) (_ : i \u2260 j), IsCoprime (I i) (I j)) :\n    \u2a05 i, span ({I i} : Set R) = span {\u220f i, I i}", "start": [635, 1], "end": [639, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_span_singleton_natCast", "code": "theorem iInf_span_singleton_natCast {R : Type*} [CommRing R] {\u03b9 : Type*} [Fintype \u03b9]\n    {I : \u03b9 \u2192 \u2115} (hI : \u2200 (i j : \u03b9), i \u2260 j \u2192 (I i).Coprime (I j)) :\n    \u2a05 (i : \u03b9), span {(I i : R)} = span {((\u220f i : \u03b9, I i : \u2115) : R)}", "start": [642, 1], "end": [646, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_eq_top_iff_isCoprime", "code": "theorem sup_eq_top_iff_isCoprime {R : Type*} [CommSemiring R] (x y : R) :\n    span ({x} : Set R) \u2294 span {y} = \u22a4 \u2194 IsCoprime x y", "start": [648, 1], "end": [657, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_le_inf", "code": "theorem mul_le_inf : I * J \u2264 I \u2293 J", "start": [660, 1], "end": [661, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.multiset_prod_le_inf", "code": "theorem multiset_prod_le_inf {s : Multiset (Ideal R)} : s.prod \u2264 s.inf", "start": [664, 1], "end": [671, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_le_inf", "code": "theorem prod_le_inf {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} : s.prod f \u2264 s.inf f", "start": [674, 1], "end": [675, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_eq_inf_of_coprime", "code": "theorem mul_eq_inf_of_coprime (h : I \u2294 J = \u22a4) : I * J = I \u2293 J", "start": [678, 1], "end": [683, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_mul_eq_of_coprime_left", "code": "theorem sup_mul_eq_of_coprime_left (h : I \u2294 J = \u22a4) : I \u2294 J * K = I \u2294 K", "start": [686, 1], "end": [691, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_mul_eq_of_coprime_right", "code": "theorem sup_mul_eq_of_coprime_right (h : I \u2294 K = \u22a4) : I \u2294 J * K = I \u2294 J", "start": [694, 1], "end": [696, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_sup_eq_of_coprime_left", "code": "theorem mul_sup_eq_of_coprime_left (h : I \u2294 J = \u22a4) : I * K \u2294 J = K \u2294 J", "start": [699, 1], "end": [701, 56], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_sup_eq_of_coprime_right", "code": "theorem mul_sup_eq_of_coprime_right (h : K \u2294 J = \u22a4) : I * K \u2294 J = I \u2294 J", "start": [704, 1], "end": [706, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_prod_eq_top", "code": "theorem sup_prod_eq_top {s : Finset \u03b9} {J : \u03b9 \u2192 Ideal R} (h : \u2200 i, i \u2208 s \u2192 I \u2294 J i = \u22a4) :\n    (I \u2294 \u220f i in s, J i) = \u22a4", "start": [709, 1], "end": [713, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_iInf_eq_top", "code": "theorem sup_iInf_eq_top {s : Finset \u03b9} {J : \u03b9 \u2192 Ideal R} (h : \u2200 i, i \u2208 s \u2192 I \u2294 J i = \u22a4) :\n    (I \u2294 \u2a05 i \u2208 s, J i) = \u22a4", "start": [716, 1], "end": [720, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_sup_eq_top", "code": "theorem prod_sup_eq_top {s : Finset \u03b9} {J : \u03b9 \u2192 Ideal R} (h : \u2200 i, i \u2208 s \u2192 J i \u2294 I = \u22a4) :\n    (\u220f i in s, J i) \u2294 I = \u22a4", "start": [723, 1], "end": [725, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.iInf_sup_eq_top", "code": "theorem iInf_sup_eq_top {s : Finset \u03b9} {J : \u03b9 \u2192 Ideal R} (h : \u2200 i, i \u2208 s \u2192 J i \u2294 I = \u22a4) :\n    (\u2a05 i \u2208 s, J i) \u2294 I = \u22a4", "start": [728, 1], "end": [730, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_pow_eq_top", "code": "theorem sup_pow_eq_top {n : \u2115} (h : I \u2294 J = \u22a4) : I \u2294 J ^ n = \u22a4", "start": [733, 1], "end": [735, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_sup_eq_top", "code": "theorem pow_sup_eq_top {n : \u2115} (h : I \u2294 J = \u22a4) : I ^ n \u2294 J = \u22a4", "start": [738, 1], "end": [740, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_sup_pow_eq_top", "code": "theorem pow_sup_pow_eq_top {m n : \u2115} (h : I \u2294 J = \u22a4) : I ^ m \u2294 J ^ n = \u22a4", "start": [743, 1], "end": [744, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_bot", "code": "theorem mul_bot : I * \u22a5 = \u22a5", "start": [750, 1], "end": [750, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.bot_mul", "code": "theorem bot_mul : \u22a5 * I = \u22a5", "start": [754, 1], "end": [754, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_top", "code": "@[simp]\ntheorem mul_top : I * \u22a4 = I", "start": [757, 1], "end": [759, 44], "kind": "commanddeclaration"}, {"full_name": "Ideal.top_mul", "code": "@[simp]\ntheorem top_mul : \u22a4 * I = I", "start": [762, 1], "end": [764, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mono", "code": "theorem mul_mono (hik : I \u2264 K) (hjl : J \u2264 L) : I * J \u2264 K * L", "start": [769, 1], "end": [770, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mono_left", "code": "theorem mul_mono_left (h : I \u2264 J) : I * K \u2264 J * K", "start": [773, 1], "end": [774, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_mono_right", "code": "theorem mul_mono_right (h : J \u2264 K) : I * J \u2264 I * K", "start": [777, 1], "end": [778, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_sup", "code": "theorem mul_sup : I * (J \u2294 K) = I * J \u2294 I * K", "start": [783, 1], "end": [784, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.sup_mul", "code": "theorem sup_mul : (I \u2294 J) * K = I * K \u2294 J * K", "start": [787, 1], "end": [788, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_le_pow", "code": "theorem pow_le_pow {m n : \u2115} (h : m \u2264 n) : I ^ n \u2264 I ^ m", "start": [793, 1], "end": [796, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_le_self", "code": "theorem pow_le_self {n : \u2115} (hn : n \u2260 0) : I ^ n \u2264 I", "start": [799, 1], "end": [802, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.pow_mono", "code": "theorem pow_mono {I J : Ideal R} (e : I \u2264 J) (n : \u2115) : I ^ n \u2264 J ^ n", "start": [805, 1], "end": [809, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.mul_eq_bot", "code": "theorem mul_eq_bot {R : Type*} [CommSemiring R] [NoZeroDivisors R] {I J : Ideal R} :\n    I * J = \u22a5 \u2194 I = \u22a5 \u2228 J = \u22a5", "start": [812, 1], "end": [819, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.prod_eq_bot", "code": "theorem prod_eq_bot {R : Type*} [CommRing R] [IsDomain R] {s : Multiset (Ideal R)} :\n    s.prod = \u22a5 \u2194 \u2203 I \u2208 s, I = \u22a5", "start": [825, 1], "end": [829, 7], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_pair_mul_span_pair", "code": "theorem span_pair_mul_span_pair (w x y z : R) :\n    (span {w, x} : Ideal R) * span {y, z} = span {w * y, w * z, x * y, x * z}", "start": [832, 1], "end": [834, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_iff_codisjoint", "code": "theorem isCoprime_iff_codisjoint : IsCoprime I J \u2194 Codisjoint I J", "start": [837, 1], "end": [848, 59], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_iff_add", "code": "theorem isCoprime_iff_add : IsCoprime I J \u2194 I + J = 1", "start": [850, 1], "end": [851, 72], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_iff_exists", "code": "theorem isCoprime_iff_exists : IsCoprime I J \u2194 \u2203 i \u2208 I, \u2203 j \u2208 J, i + j = 1", "start": [853, 1], "end": [854, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_iff_sup_eq", "code": "theorem isCoprime_iff_sup_eq : IsCoprime I J \u2194 I \u2294 J = \u22a4", "start": [856, 1], "end": [857, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_tfae", "code": "theorem isCoprime_tfae : TFAE [IsCoprime I J, Codisjoint I J, I + J = 1,\n    \u2203 i \u2208 I, \u2203 j \u2208 J, i + j = 1, I \u2294 J = \u22a4]", "start": [860, 1], "end": [864, 7], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.codisjoint", "code": "theorem _root_.IsCoprime.codisjoint (h : IsCoprime I J) : Codisjoint I J", "start": [866, 1], "end": [867, 32], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.add_eq", "code": "theorem _root_.IsCoprime.add_eq (h : IsCoprime I J) : I + J = 1", "start": [869, 1], "end": [869, 90], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.exists", "code": "theorem _root_.IsCoprime.exists (h : IsCoprime I J) : \u2203 i \u2208 I, \u2203 j \u2208 J, i + j = 1", "start": [871, 1], "end": [872, 28], "kind": "commanddeclaration"}, {"full_name": "IsCoprime.sup_eq", "code": "theorem _root_.IsCoprime.sup_eq (h : IsCoprime I J) : I \u2294 J = \u22a4", "start": [874, 1], "end": [874, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_span_singleton_iff", "code": "theorem isCoprime_span_singleton_iff (x y : R) :\n    IsCoprime (span <| singleton x) (span <| singleton y) \u2194 IsCoprime x y", "start": [876, 1], "end": [882, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.isCoprime_biInf", "code": "theorem isCoprime_biInf {J : \u03b9 \u2192 Ideal R} {s : Finset \u03b9}\n    (hf : \u2200 j \u2208 s, IsCoprime I (J j)) : IsCoprime I (\u2a05 j \u2208 s, J j)", "start": [884, 1], "end": [898, 66], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical", "code": "def radical (I : Ideal R) : Ideal R where\n  carrier := { r | \u2203 n : \u2115, r ^ n \u2208 I }\n  zero_mem' := \u27e81, (pow_one (0 : R)).symm \u25b8 I.zero_mem\u27e9\n  add_mem' :=\n  fun {x y} \u27e8m, hxmi\u27e9 \u27e8n, hyni\u27e9 =>\n    \u27e8m + n,\n      (add_pow x y (m + n)).symm \u25b8 I.sum_mem <|\n        show\n          \u2200 c \u2208 Finset.range (Nat.succ (m + n)), x ^ c * y ^ (m + n - c) * Nat.choose (m + n) c \u2208 I\n          from fun c _ =>\n          Or.casesOn (le_total c m) (fun hcm =>\n              I.mul_mem_right _ <|\n                I.mul_mem_left _ <|\n                  Nat.add_comm n m \u25b8\n                    (add_tsub_assoc_of_le hcm n).symm \u25b8\n                      (pow_add y n (m - c)).symm \u25b8 I.mul_mem_right _ hyni) (fun hmc =>\n               I.mul_mem_right _ <|\n                I.mul_mem_right _ <|\n                  add_tsub_cancel_of_le hmc \u25b8 (pow_add x m (c - m)).symm \u25b8 I.mul_mem_right _ hxmi)\u27e9\nsmul_mem' {r s} := by exact fun \u27e8n, h\u27e9 \u21a6 \u27e8n, (mul_pow r s n).symm \u25b8 I.mul_mem_left (r ^ n) h\u27e9", "start": [900, 1], "end": [921, 96], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsRadical", "code": "def IsRadical (I : Ideal R) : Prop :=\n  I.radical \u2264 I", "start": [924, 1], "end": [926, 16], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_radical", "code": "theorem le_radical : I \u2264 radical I", "start": [929, 1], "end": [929, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_eq_iff", "code": "theorem radical_eq_iff : I.radical = I \u2194 I.IsRadical", "start": [932, 1], "end": [934, 59], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsRadical.radical", "code": "alias \u27e8_, IsRadical.radical\u27e9 := radical_eq_iff", "start": [937, 1], "end": [937, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Ideal.radical_top", "code": "theorem radical_top : (radical \u22a4 : Ideal R) = \u22a4", "start": [942, 1], "end": [943, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_mono", "code": "theorem radical_mono (H : I \u2264 J) : radical I \u2264 radical J", "start": [948, 1], "end": [948, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_isRadical", "code": "theorem radical_isRadical : (radical I).IsRadical", "start": [953, 1], "end": [954, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_idem", "code": "@[simp]\ntheorem radical_idem : radical (radical I) = radical I", "start": [957, 1], "end": [959, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsRadical.radical_le_iff", "code": "theorem IsRadical.radical_le_iff (hJ : J.IsRadical) : I.radical \u2264 J \u2194 I \u2264 J", "start": [964, 1], "end": [965, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_le_radical_iff", "code": "theorem radical_le_radical_iff : radical I \u2264 radical J \u2194 I \u2264 radical J", "start": [968, 1], "end": [969, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_eq_top", "code": "theorem radical_eq_top : radical I = \u22a4 \u2194 I = \u22a4", "start": [972, 1], "end": [977, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.isRadical", "code": "theorem IsPrime.isRadical (H : IsPrime I) : I.IsRadical", "start": [980, 1], "end": [981, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.radical", "code": "theorem IsPrime.radical (H : IsPrime I) : radical I = I", "start": [984, 1], "end": [985, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_sup", "code": "theorem radical_sup : radical (I \u2294 J) = radical (radical I \u2294 radical J)", "start": [990, 1], "end": [992, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_inf", "code": "theorem radical_inf : radical (I \u2293 J) = radical I \u2293 radical J", "start": [995, 1], "end": [999, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_mul", "code": "theorem radical_mul : radical (I * J) = radical I \u2293 radical J", "start": [1002, 1], "end": [1007, 13], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.radical_le_iff", "code": "theorem IsPrime.radical_le_iff (hJ : IsPrime J) : I.radical \u2264 J \u2194 I \u2264 J", "start": [1012, 1], "end": [1013, 40], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_eq_sInf", "code": "theorem radical_eq_sInf (I : Ideal R) : radical I = sInf { J : Ideal R | I \u2264 J \u2227 IsPrime J }", "start": [1016, 1], "end": [1050, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.isRadical_bot_of_noZeroDivisors", "code": "theorem isRadical_bot_of_noZeroDivisors {R} [CommSemiring R] [NoZeroDivisors R] :\n    (\u22a5 : Ideal R).IsRadical", "start": [1053, 1], "end": [1054, 79], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_bot_of_noZeroDivisors", "code": "@[simp]\ntheorem radical_bot_of_noZeroDivisors {R : Type u} [CommSemiring R] [NoZeroDivisors R] :\n    radical (\u22a5 : Ideal R) = \u22a5", "start": [1057, 1], "end": [1060, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.top_pow", "code": "theorem top_pow (n : \u2115) : (\u22a4 ^ n : Ideal R) = \u22a4", "start": [1068, 1], "end": [1069, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.radical_pow", "code": "theorem radical_pow (n : \u2115) (H : n > 0) : radical (I ^ n) = radical I", "start": [1076, 1], "end": [1089, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.mul_le", "code": "theorem IsPrime.mul_le {I J P : Ideal R} (hp : IsPrime P) : I * J \u2264 P \u2194 I \u2264 P \u2228 J \u2264 P", "start": [1092, 1], "end": [1099, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.inf_le", "code": "theorem IsPrime.inf_le {I J P : Ideal R} (hp : IsPrime P) : I \u2293 J \u2264 P \u2194 I \u2264 P \u2228 J \u2264 P", "start": [1102, 1], "end": [1104, 65], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.multiset_prod_le", "code": "theorem IsPrime.multiset_prod_le {s : Multiset (Ideal R)} {P : Ideal R} (hp : IsPrime P)\n    (hne : s \u2260 0) : s.prod \u2264 P \u2194 \u2203 I \u2208 s, I \u2264 P", "start": [1107, 1], "end": [1124, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.multiset_prod_map_le", "code": "theorem IsPrime.multiset_prod_map_le {s : Multiset \u03b9} (f : \u03b9 \u2192 Ideal R) {P : Ideal R}\n    (hp : IsPrime P) (hne : s \u2260 0) : (s.map f).prod \u2264 P \u2194 \u2203 i \u2208 s, f i \u2264 P", "start": [1127, 1], "end": [1130, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.prod_le", "code": "theorem IsPrime.prod_le {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} {P : Ideal R} (hp : IsPrime P)\n    (hne : s.Nonempty) : s.prod f \u2264 P \u2194 \u2203 i \u2208 s, f i \u2264 P", "start": [1133, 1], "end": [1135, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.inf_le'", "code": "theorem IsPrime.inf_le' {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} {P : Ideal R} (hp : IsPrime P)\n    (hsne : s.Nonempty) : s.inf f \u2264 P \u2194 \u2203 i \u2208 s, f i \u2264 P", "start": [1138, 1], "end": [1141, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.subset_union", "code": "theorem subset_union {R : Type u} [Ring R] {I J K : Ideal R} :\n    (I : Set R) \u2286 J \u222a K \u2194 I \u2264 J \u2228 I \u2264 K", "start": [1145, 1], "end": [1156, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.subset_union_prime'", "code": "theorem subset_union_prime' {R : Type u} [CommRing R] {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} {a b : \u03b9}\n    (hp : \u2200 i \u2208 s, IsPrime (f i)) {I : Ideal R} :\n    ((I : Set R) \u2286 f a \u222a f b \u222a \u22c3 i \u2208 (\u2191s : Set \u03b9), f i) \u2194 I \u2264 f a \u2228 I \u2264 f b \u2228 \u2203 i \u2208 s, I \u2264 f i", "start": [1159, 1], "end": [1264, 101], "kind": "commanddeclaration"}, {"full_name": "Ideal.subset_union_prime", "code": "theorem subset_union_prime {R : Type u} [CommRing R] {s : Finset \u03b9} {f : \u03b9 \u2192 Ideal R} (a b : \u03b9)\n    (hp : \u2200 i \u2208 s, i \u2260 a \u2192 i \u2260 b \u2192 IsPrime (f i)) {I : Ideal R} :\n    ((I : Set R) \u2286 \u22c3 i \u2208 (\u2191s : Set \u03b9), f i) \u2194 \u2203 i \u2208 s, I \u2264 f i", "start": [1267, 1], "end": [1323, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_of_dvd", "code": "theorem le_of_dvd {I J : Ideal R} : I \u2223 J \u2192 J \u2264 I", "start": [1328, 1], "end": [1333, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.isUnit_iff", "code": "theorem isUnit_iff {I : Ideal R} : IsUnit I \u2194 I = \u22a4", "start": [1336, 1], "end": [1339, 87], "kind": "commanddeclaration"}, {"full_name": "Ideal.uniqueUnits", "code": "instance uniqueUnits : Unique (Ideal R)\u02e3 where\n  default := 1\n  uniq u := Units.ext (show (u : Ideal R) = 1 by rw [isUnit_iff.mp u.isUnit, one_eq_top])", "start": [1342, 1], "end": [1344, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.map", "code": "def map (I : Ideal R) : Ideal S :=\n  span (f '' I)", "start": [1365, 1], "end": [1368, 16], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap", "code": "def comap (I : Ideal S) : Ideal R where\n  carrier := f \u207b\u00b9' I\n  add_mem' {x y} hx hy := by\n    simp only [Set.mem_preimage, SetLike.mem_coe, map_add] at hx hy \u22a2\n    exact add_mem hx hy\n  zero_mem' := by simp only [Set.mem_preimage, map_zero, SetLike.mem_coe, Submodule.zero_mem]\n  smul_mem' c x hx := by\n    simp only [smul_eq_mul, Set.mem_preimage, map_mul, SetLike.mem_coe] at *\n    exact mul_mem_left I _ hx", "start": [1371, 1], "end": [1380, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.coe_comap", "code": "theorem coe_comap (I : Ideal S) : (comap f I : Set R) = f \u207b\u00b9' I", "start": [1385, 1], "end": [1385, 71], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_mono", "code": "theorem map_mono (h : I \u2264 J) : map f I \u2264 map f J", "start": [1389, 1], "end": [1390, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_map_of_mem", "code": "theorem mem_map_of_mem (f : F) {I : Ideal R} {x : R} (h : x \u2208 I) : f x \u2208 map f I", "start": [1393, 1], "end": [1394, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.apply_coe_mem_map", "code": "theorem apply_coe_mem_map (f : F) (I : Ideal R) (x : I) : f x \u2208 I.map f", "start": [1397, 1], "end": [1398, 23], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap : map f I \u2264 K \u2194 I \u2264 comap f K", "start": [1401, 1], "end": [1402, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_comap", "code": "@[simp]\ntheorem mem_comap {x} : x \u2208 comap f K \u2194 f x \u2208 K", "start": [1405, 1], "end": [1407, 10], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_mono", "code": "theorem comap_mono (h : K \u2264 L) : comap f K \u2264 comap f L", "start": [1410, 1], "end": [1411, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_ne_top", "code": "theorem comap_ne_top (hK : K \u2260 \u22a4) : comap f K \u2260 \u22a4", "start": [1416, 1], "end": [1417, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_le_comap_of_inv_on", "code": "theorem map_le_comap_of_inv_on (g : G) (I : Ideal R) (hf : Set.LeftInvOn g f I) :\n    I.map f \u2264 I.comap g", "start": [1422, 1], "end": [1427, 11], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_le_map_of_inv_on", "code": "theorem comap_le_map_of_inv_on (g : G) (I : Ideal S) (hf : Set.LeftInvOn g f (f \u207b\u00b9' I)) :\n    I.comap f \u2264 I.map g", "start": [1430, 1], "end": [1431, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_le_comap_of_inverse", "code": "theorem map_le_comap_of_inverse (g : G) (I : Ideal R) (h : Function.LeftInverse g f) :\n    I.map f \u2264 I.comap g", "start": [1434, 1], "end": [1437, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_le_map_of_inverse", "code": "theorem comap_le_map_of_inverse (g : G) (I : Ideal S) (h : Function.LeftInverse g f) :\n    I.comap f \u2264 I.map g", "start": [1440, 1], "end": [1443, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.comap", "code": "instance IsPrime.comap [hK : K.IsPrime] : (comap f K).IsPrime :=\n  \u27e8comap_ne_top _ hK.1, fun {x y} => by simp only [mem_comap, map_mul]; apply hK.2\u27e9", "start": [1446, 1], "end": [1447, 84], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_top", "code": "theorem map_top : map f \u22a4 = \u22a4", "start": [1452, 1], "end": [1453, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.gc_map_comap", "code": "theorem gc_map_comap : GaloisConnection (Ideal.map f) (Ideal.comap f)", "start": [1456, 1], "end": [1457, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_id", "code": "@[simp]\ntheorem comap_id : I.comap (RingHom.id R) = I", "start": [1460, 1], "end": [1462, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_id", "code": "@[simp]\ntheorem map_id : I.map (RingHom.id R) = I", "start": [1465, 1], "end": [1467, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_comap", "code": "theorem comap_comap {T : Type*} [Semiring T] {I : Ideal T} (f : R \u2192+* S) (g : S \u2192+* T) :\n    (I.comap g).comap f = I.comap (g.comp f)", "start": [1470, 1], "end": [1472, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_map", "code": "theorem map_map {T : Type*} [Semiring T] {I : Ideal R} (f : R \u2192+* S) (g : S \u2192+* T) :\n    (I.map f).map g = I.map (g.comp f)", "start": [1475, 1], "end": [1478, 20], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_span", "code": "theorem map_span (f : F) (s : Set R) : map f (span s) = span (f '' s)", "start": [1481, 1], "end": [1485, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_le_of_le_comap", "code": "theorem map_le_of_le_comap : I \u2264 K.comap f \u2192 I.map f \u2264 K", "start": [1490, 1], "end": [1491, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_of_map_le", "code": "theorem le_comap_of_map_le : I.map f \u2264 K \u2192 I \u2264 K.comap f", "start": [1494, 1], "end": [1495, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_map", "code": "theorem le_comap_map : I \u2264 (I.map f).comap f", "start": [1498, 1], "end": [1499, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_comap_le", "code": "theorem map_comap_le : (K.comap f).map f \u2264 K", "start": [1502, 1], "end": [1503, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_top", "code": "@[simp]\ntheorem comap_top : (\u22a4 : Ideal S).comap f = \u22a4", "start": [1506, 1], "end": [1508, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_eq_top_iff", "code": "@[simp]\ntheorem comap_eq_top_iff {I : Ideal S} : I.comap f = \u22a4 \u2194 I = \u22a4", "start": [1511, 1], "end": [1514, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_bot", "code": "@[simp]\ntheorem map_bot : (\u22a5 : Ideal R).map f = \u22a5", "start": [1517, 1], "end": [1519, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_comap_map", "code": "@[simp]\ntheorem map_comap_map : ((I.map f).comap f).map f = I.map f", "start": [1524, 1], "end": [1526, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_map_comap", "code": "@[simp]\ntheorem comap_map_comap : ((K.comap f).map f).comap f = K.comap f", "start": [1529, 1], "end": [1531, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_sup", "code": "theorem map_sup : (I \u2294 J).map f = I.map f \u2294 J.map f", "start": [1534, 1], "end": [1535, 62], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_inf", "code": "theorem comap_inf : comap f (K \u2293 L) = comap f K \u2293 comap f L", "start": [1538, 1], "end": [1539, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_iSup", "code": "theorem map_iSup (K : \u03b9 \u2192 Ideal R) : (iSup K).map f = \u2a06 i, (K i).map f", "start": [1544, 1], "end": [1545, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_iInf", "code": "theorem comap_iInf (K : \u03b9 \u2192 Ideal S) : (iInf K).comap f = \u2a05 i, (K i).comap f", "start": [1548, 1], "end": [1549, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_sSup", "code": "theorem map_sSup (s : Set (Ideal R)) : (sSup s).map f = \u2a06 I \u2208 s, (I : Ideal R).map f", "start": [1552, 1], "end": [1553, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_sInf", "code": "theorem comap_sInf (s : Set (Ideal S)) : (sInf s).comap f = \u2a05 I \u2208 s, (I : Ideal S).comap f", "start": [1556, 1], "end": [1557, 63], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_sInf'", "code": "theorem comap_sInf' (s : Set (Ideal S)) : (sInf s).comap f = \u2a05 I \u2208 comap f '' s, I", "start": [1560, 1], "end": [1561, 53], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_isPrime", "code": "theorem comap_isPrime [H : IsPrime K] : IsPrime (comap f K)", "start": [1564, 1], "end": [1565, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_inf_le", "code": "theorem map_inf_le : map f (I \u2293 J) \u2264 map f I \u2293 map f J", "start": [1570, 1], "end": [1571, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_sup", "code": "theorem le_comap_sup : comap f K \u2294 comap f L \u2264 comap f (K \u2294 L)", "start": [1574, 1], "end": [1575, 82], "kind": "commanddeclaration"}, {"full_name": "Ideal.smul_top_eq_map", "code": "@[simp]\ntheorem smul_top_eq_map {R S : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]\n    (I : Ideal R) : I \u2022 (\u22a4 : Submodule R S) = (I.map (algebraMap R S)).restrictScalars R", "start": [1578, 1], "end": [1599, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars {R S : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    (I : Ideal S) : (I.restrictScalars R : Set S) = \u2191I", "start": [1602, 1], "end": [1605, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.restrictScalars_mul", "code": "@[simp]\ntheorem restrictScalars_mul {R S : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]\n    (I J : Ideal S) : (I * J).restrictScalars R = I.restrictScalars R * J.restrictScalars R", "start": [1608, 1], "end": [1617, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_comap_of_surjective", "code": "theorem map_comap_of_surjective (I : Ideal S) : map f (comap f I) = I", "start": [1626, 1], "end": [1629, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.giMapComap", "code": "def giMapComap : GaloisInsertion (map f) (comap f) :=\n  GaloisInsertion.monotoneIntro (gc_map_comap f).monotone_u (gc_map_comap f).monotone_l\n    (fun _ => le_comap_map) (map_comap_of_surjective _ hf)", "start": [1632, 1], "end": [1636, 59], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_surjective_of_surjective", "code": "theorem map_surjective_of_surjective : Surjective (map f)", "start": [1639, 1], "end": [1640, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_injective_of_surjective", "code": "theorem comap_injective_of_surjective : Injective (comap f)", "start": [1643, 1], "end": [1644, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_sup_comap_of_surjective", "code": "theorem map_sup_comap_of_surjective (I J : Ideal S) : (I.comap f \u2294 J.comap f).map f = I \u2294 J", "start": [1647, 1], "end": [1648, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_iSup_comap_of_surjective", "code": "theorem map_iSup_comap_of_surjective (K : \u03b9 \u2192 Ideal S) : (\u2a06 i, (K i).comap f).map f = iSup K", "start": [1651, 1], "end": [1652, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_inf_comap_of_surjective", "code": "theorem map_inf_comap_of_surjective (I J : Ideal S) : (I.comap f \u2293 J.comap f).map f = I \u2293 J", "start": [1655, 1], "end": [1656, 32], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_iInf_comap_of_surjective", "code": "theorem map_iInf_comap_of_surjective (K : \u03b9 \u2192 Ideal S) : (\u2a05 i, (K i).comap f).map f = iInf K", "start": [1659, 1], "end": [1660, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_image_of_mem_map_of_surjective", "code": "theorem mem_image_of_mem_map_of_surjective {I : Ideal R} {y} (H : y \u2208 map f I) : y \u2208 f '' I", "start": [1663, 1], "end": [1669, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_map_iff_of_surjective", "code": "theorem mem_map_iff_of_surjective {I : Ideal R} {y} : y \u2208 map f I \u2194 \u2203 x, x \u2208 I \u2227 f x = y", "start": [1672, 1], "end": [1674, 41], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_map_of_comap_le_of_surjective", "code": "theorem le_map_of_comap_le_of_surjective : comap f K \u2264 I \u2192 K \u2264 map f I", "start": [1677, 1], "end": [1678, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_eq_submodule_map", "code": "theorem map_eq_submodule_map (f : R \u2192+* S) [h : RingHomSurjective f] (I : Ideal R) :\n    I.map f = Submodule.map f.toSemilinearMap I", "start": [1681, 1], "end": [1683, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_bot_le_of_injective", "code": "theorem comap_bot_le_of_injective : comap f \u22a5 \u2264 I", "start": [1692, 1], "end": [1695, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_bot_of_injective", "code": "theorem comap_bot_of_injective : Ideal.comap f \u22a5 = \u22a5", "start": [1698, 1], "end": [1699, 55], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_map_of_surjective", "code": "theorem comap_map_of_surjective (I : Ideal R) : comap f (map f I) = I \u2294 comap f \u22a5", "start": [1716, 1], "end": [1723, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.relIsoOfSurjective", "code": "def relIsoOfSurjective : Ideal S \u2243o { p : Ideal R // comap f \u22a5 \u2264 p } where\n  toFun J := \u27e8comap f J, comap_mono bot_le\u27e9\n  invFun I := map f I.1\n  left_inv J := map_comap_of_surjective f hf J\n  right_inv I :=\n    Subtype.eq <|\n      show comap f (map f I.1) = I.1 from\n        (comap_map_of_surjective f hf I).symm \u25b8 le_antisymm (sup_le le_rfl I.2) le_sup_left\n  map_rel_iff' {I1 I2} :=\n    \u27e8fun H => map_comap_of_surjective f hf I1 \u25b8 map_comap_of_surjective f hf I2 \u25b8 map_mono H,\n      comap_mono\u27e9", "start": [1726, 1], "end": [1737, 18], "kind": "commanddeclaration"}, {"full_name": "Ideal.orderEmbeddingOfSurjective", "code": "def orderEmbeddingOfSurjective : Ideal S \u21aao Ideal R :=\n  (relIsoOfSurjective f hf).toRelEmbedding.trans (Subtype.relEmbedding (fun x y => x \u2264 y) _)", "start": [1740, 1], "end": [1742, 93], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_eq_top_or_isMaximal_of_surjective", "code": "theorem map_eq_top_or_isMaximal_of_surjective {I : Ideal R} (H : IsMaximal I) :\n    map f I = \u22a4 \u2228 IsMaximal (map f I)", "start": [1745, 1], "end": [1752, 88], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_isMaximal_of_surjective", "code": "theorem comap_isMaximal_of_surjective {K : Ideal S} [H : IsMaximal K] : IsMaximal (comap f K)", "start": [1755, 1], "end": [1767, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_le_comap_iff_of_surjective", "code": "theorem comap_le_comap_iff_of_surjective (I J : Ideal S) : comap f I \u2264 comap f J \u2194 I \u2264 J", "start": [1770, 1], "end": [1772, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_of_equiv", "code": "@[simp]\ntheorem map_of_equiv (I : Ideal R) (f : R \u2243+* S) :\n    (I.map (f : R \u2192+* S)).map (f.symm : S \u2192+* R) = I", "start": [1777, 1], "end": [1782, 89], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_of_equiv", "code": "@[simp]\ntheorem comap_of_equiv (I : Ideal R) (f : R \u2243+* S) :\n    (I.comap (f.symm : S \u2192+* R)).comap (f : R \u2192+* S) = I", "start": [1785, 1], "end": [1790, 91], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_comap_of_equiv", "code": "theorem map_comap_of_equiv (I : Ideal R) (f : R \u2243+* S) : I.map (f : R \u2192+* S) = I.comap f.symm", "start": [1793, 1], "end": [1796, 78], "kind": "commanddeclaration"}, {"full_name": "Ideal.relIsoOfBijective", "code": "def relIsoOfBijective : Ideal S \u2243o Ideal R where\n  toFun := comap f\n  invFun := map f\n  left_inv := (relIsoOfSurjective f hf.right).left_inv\n  right_inv J :=\n    Subtype.ext_iff.1\n      ((relIsoOfSurjective f hf.right).right_inv \u27e8J, comap_bot_le_of_injective f hf.left\u27e9)\n  map_rel_iff' {_ _} := (relIsoOfSurjective f hf.right).map_rel_iff'", "start": [1803, 1], "end": [1811, 69], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_le_iff_le_map", "code": "theorem comap_le_iff_le_map {I : Ideal R} {K : Ideal S} : comap f K \u2264 I \u2194 K \u2264 map f I", "start": [1814, 1], "end": [1816, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.map.isMaximal", "code": "theorem map.isMaximal {I : Ideal R} (H : IsMaximal I) : IsMaximal (map f I)", "start": [1819, 1], "end": [1825, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.RingEquiv.bot_maximal_iff", "code": "theorem RingEquiv.bot_maximal_iff (e : R \u2243+* S) :\n    (\u22a5 : Ideal R).IsMaximal \u2194 (\u22a5 : Ideal S).IsMaximal", "start": [1830, 1], "end": [1833, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_mul", "code": "theorem map_mul : map f (I * J) = map f I * map f J", "start": [1850, 1], "end": [1860, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.mapHom", "code": "@[simps]\ndef mapHom : Ideal R \u2192*\u2080 Ideal S where\n  toFun := map f\n  map_mul' I J := Ideal.map_mul f I J\n  map_one' := by simp only [one_eq_top]; exact Ideal.map_top f\n  map_zero' := Ideal.map_bot", "start": [1863, 1], "end": [1869, 29], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_pow", "code": "protected theorem map_pow (n : \u2115) : map f (I ^ n) = map f I ^ n", "start": [1872, 1], "end": [1873, 25], "kind": "commanddeclaration"}, {"full_name": "Ideal.comap_radical", "code": "theorem comap_radical : comap f (radical K) = radical (comap f K)", "start": [1876, 1], "end": [1878, 17], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsRadical.comap", "code": "theorem IsRadical.comap (hK : K.IsRadical) : (comap f K).IsRadical", "start": [1883, 1], "end": [1885, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_radical_le", "code": "theorem map_radical_le : map f (radical I) \u2264 radical (map f I)", "start": [1890, 1], "end": [1891, 86], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_mul", "code": "theorem le_comap_mul : comap f K * comap f L \u2264 comap f (K * L)", "start": [1894, 1], "end": [1897, 83], "kind": "commanddeclaration"}, {"full_name": "Ideal.le_comap_pow", "code": "theorem le_comap_pow (n : \u2115) : K.comap f ^ n \u2264 (K ^ n).comap f", "start": [1900, 1], "end": [1905, 67], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrimary", "code": "def IsPrimary (I : Ideal R) : Prop :=\n  I \u2260 \u22a4 \u2227 \u2200 {x y : R}, x * y \u2208 I \u2192 x \u2208 I \u2228 y \u2208 radical I", "start": [1916, 1], "end": [1918, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrime.isPrimary", "code": "theorem IsPrime.isPrimary {I : Ideal R} (hi : IsPrime I) : IsPrimary I", "start": [1921, 1], "end": [1922, 80], "kind": "commanddeclaration"}, {"full_name": "Ideal.mem_radical_of_pow_mem", "code": "theorem mem_radical_of_pow_mem {I : Ideal R} {x : R} {m : \u2115} (hx : x ^ m \u2208 radical I) :\n    x \u2208 radical I", "start": [1925, 1], "end": [1927, 27], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrime_radical", "code": "theorem isPrime_radical {I : Ideal R} (hi : IsPrimary I) : IsPrime (radical I)", "start": [1930, 1], "end": [1935, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.isPrimary_inf", "code": "theorem isPrimary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J)\n    (hij : radical I = radical J) : IsPrimary (I \u2293 J)", "start": [1938, 1], "end": [1947, 24], "kind": "commanddeclaration"}, {"full_name": "Ideal.finsuppTotal", "code": "noncomputable def finsuppTotal : (\u03b9 \u2192\u2080 I) \u2192\u2097[R] M :=\n  (Finsupp.total \u03b9 M R v).comp (Finsupp.mapRange.linearMap I.subtype)", "start": [1962, 1], "end": [1964, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.finsuppTotal_apply", "code": "theorem finsuppTotal_apply (f : \u03b9 \u2192\u2080 I) :\n    finsuppTotal \u03b9 M I v f = f.sum fun i x => (x : R) \u2022 v i", "start": [1969, 1], "end": [1973, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.finsuppTotal_apply_eq_of_fintype", "code": "theorem finsuppTotal_apply_eq_of_fintype [Fintype \u03b9] (f : \u03b9 \u2192\u2080 I) :\n    finsuppTotal \u03b9 M I v f = \u2211 i, (f i : R) \u2022 v i", "start": [1976, 1], "end": [1979, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.range_finsuppTotal", "code": "theorem range_finsuppTotal :\n    LinearMap.range (finsuppTotal \u03b9 M I v) = I \u2022 Submodule.span R (Set.range v)", "start": [1982, 1], "end": [1994, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.basisSpanSingleton", "code": "noncomputable def basisSpanSingleton (b : Basis \u03b9 R S) {x : S} (hx : x \u2260 0) :\n    Basis \u03b9 R (span ({x} : Set S)) :=\n  b.map <|\n    LinearEquiv.ofInjective (Algebra.lmul R S x) (LinearMap.mul_injective hx) \u226a\u226b\u2097\n        LinearEquiv.ofEq _ _\n          (by\n            ext\n            simp [mem_span_singleton', mul_comm]) \u226a\u226b\u2097\n      (Submodule.restrictScalarsEquiv R S S (Ideal.span ({x} : Set S))).restrictScalars R", "start": [2003, 1], "end": [2012, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.basisSpanSingleton_apply", "code": "@[simp]\ntheorem basisSpanSingleton_apply (b : Basis \u03b9 R S) {x : S} (hx : x \u2260 0) (i : \u03b9) :\n    (basisSpanSingleton b hx i : S) = x * b i", "start": [2015, 1], "end": [2023, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.constr_basisSpanSingleton", "code": "@[simp]\ntheorem constr_basisSpanSingleton {N : Type*} [Semiring N] [Module N S] [SMulCommClass R N S]\n    (b : Basis \u03b9 R S) {x : S} (hx : x \u2260 0) :\n    (b.constr N).toFun (((\u2191) : _ \u2192 S) \u2218 (basisSpanSingleton b hx)) = Algebra.lmul R S x", "start": [2026, 1], "end": [2031, 98], "kind": "commanddeclaration"}, {"full_name": "Associates.mk_ne_zero'", "code": "theorem Associates.mk_ne_zero' {R : Type*} [CommSemiring R] {r : R} :\n    Associates.mk (Ideal.span {r} : Ideal R) \u2260 0 \u2194 r \u2260 0", "start": [2038, 1], "end": [2040, 85], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_ideal_iff", "code": "theorem Basis.mem_ideal_iff {\u03b9 R S : Type*} [CommRing R] [CommRing S] [Algebra R S] {I : Ideal S}\n    (b : Basis \u03b9 R I) {x : S} : x \u2208 I \u2194 \u2203 c : \u03b9 \u2192\u2080 R, x = Finsupp.sum c fun i x => x \u2022 (b i : S)", "start": [2044, 1], "end": [2048, 84], "kind": "commanddeclaration"}, {"full_name": "Basis.mem_ideal_iff'", "code": "theorem Basis.mem_ideal_iff' {\u03b9 R S : Type*} [Fintype \u03b9] [CommRing R] [CommRing S] [Algebra R S]\n    {I : Ideal S} (b : Basis \u03b9 R I) {x : S} : x \u2208 I \u2194 \u2203 c : \u03b9 \u2192 R, x = \u2211 i, c i \u2022 (b i : S)", "start": [2051, 1], "end": [2055, 85], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker", "code": "def ker : Ideal R :=\n  Ideal.comap f \u22a5", "start": [2068, 1], "end": [2070, 18], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_ker", "code": "theorem mem_ker {r} : r \u2208 ker f \u2194 f r = 0", "start": [2073, 1], "end": [2074, 93], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_eq", "code": "theorem ker_eq : (ker f : Set R) = Set.preimage f {0}", "start": [2077, 1], "end": [2078, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_eq_comap_bot", "code": "theorem ker_eq_comap_bot (f : F) : ker f = Ideal.comap f \u22a5", "start": [2081, 1], "end": [2082, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.comap_ker", "code": "theorem comap_ker (f : S \u2192+* R) (g : T \u2192+* S) : f.ker.comap g = ker (f.comp g)", "start": [2085, 1], "end": [2086, 77], "kind": "commanddeclaration"}, {"full_name": "RingHom.not_one_mem_ker", "code": "theorem not_one_mem_ker [Nontrivial S] (f : F) : (1 : R) \u2209 ker f", "start": [2089, 1], "end": [2092, 20], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_ne_top", "code": "theorem ker_ne_top [Nontrivial S] (f : F) : ker f \u2260 \u22a4", "start": [2095, 1], "end": [2096, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.ker_ringHom", "code": "lemma _root_.Pi.ker_ringHom {\u03b9 : Type*} {R : \u03b9 \u2192 Type*} [\u2200 i, Semiring (R i)]\n    (\u03c6 : \u2200 i, S \u2192+* R i) : ker (Pi.ringHom \u03c6) = \u2a05 i, ker (\u03c6 i) := by\n  ext x\n  simp [mem_ker, Ideal.mem_iInf, Function.funext_iff]", "start": [2099, 1], "end": [2102, 54], "kind": "mathlibtacticlemma"}, {"full_name": "RingHom.injective_iff_ker_eq_bot", "code": "theorem injective_iff_ker_eq_bot : Function.Injective f \u2194 ker f = \u22a5", "start": [2110, 1], "end": [2112, 37], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_eq_bot_iff_eq_zero", "code": "theorem ker_eq_bot_iff_eq_zero : ker f = \u22a5 \u2194 \u2200 x, f x = 0 \u2192 x = 0", "start": [2115, 1], "end": [2116, 63], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_coe_equiv", "code": "@[simp]\ntheorem ker_coe_equiv (f : R \u2243+* S) : ker (f : R \u2192+* S) = \u22a5", "start": [2119, 1], "end": [2121, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_equiv", "code": "@[simp]\ntheorem ker_equiv {F' : Type*} [RingEquivClass F' R S] (f : F') : ker f = \u22a5", "start": [2124, 1], "end": [2126, 70], "kind": "commanddeclaration"}, {"full_name": "RingHom.sub_mem_ker_iff", "code": "theorem sub_mem_ker_iff {x y} : x - y \u2208 ker f \u2194 f x = f y", "start": [2135, 1], "end": [2135, 99], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_rangeRestrict", "code": "@[simp]\ntheorem ker_rangeRestrict (f : R \u2192+* S) : ker f.rangeRestrict = ker f", "start": [2138, 1], "end": [2140, 36], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_isPrime", "code": "theorem ker_isPrime {F : Type*} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) :\n    (ker f).IsPrime", "start": [2144, 1], "end": [2151, 88], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_isMaximal_of_surjective", "code": "theorem ker_isMaximal_of_surjective {R K F : Type*} [Ring R] [Field K] [RingHomClass F R K] (f : F)\n    (hf : Function.Surjective f) : (ker f).IsMaximal", "start": [2154, 1], "end": [2165, 95], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_eq_bot_iff_le_ker", "code": "theorem map_eq_bot_iff_le_ker {I : Ideal R} (f : F) : I.map f = \u22a5 \u2194 I \u2264 RingHom.ker f", "start": [2178, 1], "end": [2179, 52], "kind": "commanddeclaration"}, {"full_name": "Ideal.ker_le_comap", "code": "theorem ker_le_comap {K : Ideal S} (f : F) : RingHom.ker f \u2264 comap f K", "start": [2182, 1], "end": [2183, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_sInf", "code": "theorem map_sInf {A : Set (Ideal R)} {f : F} (hf : Function.Surjective f) :\n    (\u2200 J \u2208 A, RingHom.ker f \u2264 J) \u2192 map f (sInf A) = sInf (map f '' A)", "start": [2192, 1], "end": [2210, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_isPrime_of_surjective", "code": "theorem map_isPrime_of_surjective {f : F} (hf : Function.Surjective f) {I : Ideal R} [H : IsPrime I]\n    (hk : RingHom.ker f \u2264 I) : IsPrime (map f I)", "start": [2213, 1], "end": [2227, 98], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_eq_bot_iff_of_injective", "code": "theorem map_eq_bot_iff_of_injective {I : Ideal R} {f : F} (hf : Function.Injective f) :\n    I.map f = \u22a5 \u2194 I = \u22a5", "start": [2230, 1], "end": [2232, 85], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_isPrime_of_equiv", "code": "theorem map_isPrime_of_equiv {F' : Type*} [RingEquivClass F' R S] (f : F') {I : Ideal R}\n    [IsPrime I] : IsPrime (map f I)", "start": [2235, 1], "end": [2237, 97], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_eq_iff_sup_ker_eq_of_surjective", "code": "theorem map_eq_iff_sup_ker_eq_of_surjective {I J : Ideal R} (f : R \u2192+* S)\n    (hf : Function.Surjective f) : map f I = map f J \u2194 I \u2294 RingHom.ker f = J \u2294 RingHom.ker f", "start": [2246, 1], "end": [2249, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_radical_of_surjective", "code": "theorem map_radical_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f) {I : Ideal R}\n    (h : RingHom.ker f \u2264 I) : map f I.radical = (map f I).radical", "start": [2252, 1], "end": [2264, 94], "kind": "commanddeclaration"}, {"full_name": "Submodule.moduleSubmodule", "code": "instance moduleSubmodule : Module (Ideal R) (Submodule R M) where\n  smul_add := smul_sup\n  add_smul := sup_smul\n  mul_smul := Submodule.smul_assoc\n  one_smul := by simp\n  zero_smul := bot_smul\n  smul_zero := smul_bot", "start": [2278, 1], "end": [2284, 24], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfRightInverseAux", "code": "def liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : A \u2192+* C)\n    (hg : RingHom.ker f \u2264 RingHom.ker g) :\n    B \u2192+* C :=\n  { AddMonoidHom.liftOfRightInverse f.toAddMonoidHom f_inv hf \u27e8g.toAddMonoidHom, hg\u27e9 with\n    toFun := fun b => g (f_inv b)\n    map_one' := by\n      rw [\u2190 map_one g, \u2190 sub_eq_zero, \u2190 map_sub g, \u2190 mem_ker g]\n      apply hg\n      rw [mem_ker f, map_sub f, sub_eq_zero, map_one f]\n      exact hf 1\n    map_mul' := by\n      intro x y\n      rw [\u2190 map_mul g, \u2190 sub_eq_zero, \u2190 map_sub g, \u2190 mem_ker g]\n      apply hg\n      rw [mem_ker f, map_sub f, sub_eq_zero, map_mul f]\n      simp only [hf _] }", "start": [2295, 1], "end": [2311, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfRightInverseAux_comp_apply", "code": "@[simp]\ntheorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : A \u2192+* C)\n    (hg : RingHom.ker f \u2264 RingHom.ker g) (a : A) :\n    (f.liftOfRightInverseAux f_inv hf g hg) (f a) = g a", "start": [2314, 1], "end": [2318, 83], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfRightInverse", "code": "def liftOfRightInverse (hf : Function.RightInverse f_inv f) :\n    { g : A \u2192+* C // RingHom.ker f \u2264 RingHom.ker g } \u2243 (B \u2192+* C) where\n  toFun g := f.liftOfRightInverseAux f_inv hf g.1 g.2\n  invFun \u03c6 := \u27e8\u03c6.comp f, fun x hx => (mem_ker _).mpr <| by simp [(mem_ker _).mp hx]\u27e9\n  left_inv g := by\n    ext\n    simp only [comp_apply, liftOfRightInverseAux_comp_apply, Subtype.coe_mk]\n  right_inv \u03c6 := by\n    ext b\n    simp [liftOfRightInverseAux, hf b]", "start": [2321, 1], "end": [2348, 39], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfSurjective", "code": "@[simp]\nnoncomputable abbrev liftOfSurjective (hf : Function.Surjective f) :\n    { g : A \u2192+* C // RingHom.ker f \u2264 RingHom.ker g } \u2243 (B \u2192+* C) :=\n  f.liftOfRightInverse (Function.surjInv hf) (Function.rightInverse_surjInv hf)", "start": [2351, 1], "end": [2356, 80], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfRightInverse_comp_apply", "code": "theorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)\n    (g : { g : A \u2192+* C // RingHom.ker f \u2264 RingHom.ker g }) (x : A) :\n    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x", "start": [2359, 1], "end": [2362, 56], "kind": "commanddeclaration"}, {"full_name": "RingHom.liftOfRightInverse_comp", "code": "theorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)\n    (g : { g : A \u2192+* C // RingHom.ker f \u2264 RingHom.ker g }) :\n    (f.liftOfRightInverse f_inv hf g).comp f = g", "start": [2365, 1], "end": [2368, 60], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_liftOfRightInverse", "code": "theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : A \u2192+* C)\n    (hg : RingHom.ker f \u2264 RingHom.ker g) (h : B \u2192+* C) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf \u27e8g, hg\u27e9", "start": [2371, 1], "end": [2375, 66], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_ker", "code": "lemma coe_ker : RingHom.ker f = RingHom.ker (f : A \u2192+* B) := rfl", "start": [2385, 1], "end": [2385, 65], "kind": "mathlibtacticlemma"}, {"full_name": "AlgHom.coe_ideal_map", "code": "lemma coe_ideal_map (I : Ideal A) :\n    Ideal.map f I = Ideal.map (f : A \u2192+* B) I := rfl", "start": [2387, 1], "end": [2388, 53], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/UniformSpace/Separation.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Tactic/ApplyFun.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformSpace.to_regularSpace", "code": "instance (priority := 100) UniformSpace.to_regularSpace : RegularSpace \u03b1 :=\n  RegularSpace.ofBasis\n    (fun a => by\n      rw [nhds_eq_comap_uniformity]\n      exact uniformity_hasBasis_closed.comap _)\n    fun a V hV => by exact hV.2.preimage <| continuous_const.prod_mk continuous_id", "start": [83, 1], "end": [88, 83], "kind": "commanddeclaration"}, {"full_name": "separationRel", "code": "def separationRel (\u03b1 : Type u) [UniformSpace \u03b1] := (\ud835\udce4 \u03b1).ker", "start": [92, 1], "end": [95, 61], "kind": "commanddeclaration"}, {"full_name": "separated_equiv", "code": "theorem separated_equiv : Equivalence fun x y => (x, y) \u2208 \ud835\udce2 \u03b1", "start": [101, 1], "end": [105, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.mem_separationRel", "code": "theorem Filter.HasBasis.mem_separationRel {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) {a : \u03b1 \u00d7 \u03b1} : a \u2208 \ud835\udce2 \u03b1 \u2194 \u2200 i, p i \u2192 a \u2208 s i", "start": [108, 1], "end": [110, 19], "kind": "commanddeclaration"}, {"full_name": "separationRel_iff_specializes", "code": "theorem separationRel_iff_specializes {a b : \u03b1} : (a, b) \u2208 \ud835\udce2 \u03b1 \u2194 a \u2933 b", "start": [113, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "separationRel_iff_inseparable", "code": "theorem separationRel_iff_inseparable {a b : \u03b1} : (a, b) \u2208 \ud835\udce2 \u03b1 \u2194 Inseparable a b", "start": [118, 1], "end": [119, 66], "kind": "commanddeclaration"}, {"full_name": "SeparatedSpace", "code": "class SeparatedSpace (\u03b1 : Type u) [UniformSpace \u03b1] : Prop where\n  \n  out : \ud835\udce2 \u03b1 = idRel", "start": [122, 1], "end": [126, 20], "kind": "commanddeclaration"}, {"full_name": "separatedSpace_iff", "code": "theorem separatedSpace_iff {\u03b1 : Type u} [UniformSpace \u03b1] : SeparatedSpace \u03b1 \u2194 \ud835\udce2 \u03b1 = idRel", "start": [129, 1], "end": [130, 31], "kind": "commanddeclaration"}, {"full_name": "separated_def", "code": "theorem separated_def {\u03b1 : Type u} [UniformSpace \u03b1] :\n    SeparatedSpace \u03b1 \u2194 \u2200 x y, (\u2200 r \u2208 \ud835\udce4 \u03b1, (x, y) \u2208 r) \u2192 x = y", "start": [133, 1], "end": [136, 98], "kind": "commanddeclaration"}, {"full_name": "separated_def'", "code": "theorem separated_def' {\u03b1 : Type u} [UniformSpace \u03b1] :\n    SeparatedSpace \u03b1 \u2194 \u2200 x y, x \u2260 y \u2192 \u2203 r \u2208 \ud835\udce4 \u03b1, (x, y) \u2209 r", "start": [139, 1], "end": [141, 91], "kind": "commanddeclaration"}, {"full_name": "eq_of_uniformity", "code": "theorem eq_of_uniformity {\u03b1 : Type*} [UniformSpace \u03b1] [SeparatedSpace \u03b1] {x y : \u03b1}\n    (h : \u2200 {V}, V \u2208 \ud835\udce4 \u03b1 \u2192 (x, y) \u2208 V) : x = y", "start": [144, 1], "end": [146, 53], "kind": "commanddeclaration"}, {"full_name": "eq_of_uniformity_basis", "code": "theorem eq_of_uniformity_basis {\u03b1 : Type*} [UniformSpace \u03b1] [SeparatedSpace \u03b1] {\u03b9 : Type*}\n    {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hs : (\ud835\udce4 \u03b1).HasBasis p s) {x y : \u03b1}\n    (h : \u2200 {i}, p i \u2192 (x, y) \u2208 s i) : x = y", "start": [149, 1], "end": [152, 78], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_symmetric", "code": "theorem eq_of_forall_symmetric {\u03b1 : Type*} [UniformSpace \u03b1] [SeparatedSpace \u03b1] {x y : \u03b1}\n    (h : \u2200 {V}, V \u2208 \ud835\udce4 \u03b1 \u2192 SymmetricRel V \u2192 (x, y) \u2208 V) : x = y", "start": [155, 1], "end": [157, 65], "kind": "commanddeclaration"}, {"full_name": "eq_of_clusterPt_uniformity", "code": "theorem eq_of_clusterPt_uniformity [SeparatedSpace \u03b1] {x y : \u03b1} (h : ClusterPt (x, y) (\ud835\udce4 \u03b1)) :\n    x = y", "start": [160, 1], "end": [163, 70], "kind": "commanddeclaration"}, {"full_name": "idRel_sub_separationRel", "code": "theorem idRel_sub_separationRel (\u03b1 : Type*) [UniformSpace \u03b1] : idRel \u2286 \ud835\udce2 \u03b1", "start": [166, 1], "end": [171, 37], "kind": "commanddeclaration"}, {"full_name": "separationRel_comap", "code": "theorem separationRel_comap {f : \u03b1 \u2192 \u03b2}\n    (h : \u2039UniformSpace \u03b1\u203a = UniformSpace.comap f \u2039UniformSpace \u03b2\u203a) :\n    \ud835\udce2 \u03b1 = Prod.map f f \u207b\u00b9' \ud835\udce2 \u03b2", "start": [174, 1], "end": [179, 98], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.separationRel", "code": "protected theorem Filter.HasBasis.separationRel {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (h : HasBasis (\ud835\udce4 \u03b1) p s) : \ud835\udce2 \u03b1 = \u22c2 (i) (_ : p i), s i", "start": [182, 1], "end": [185, 13], "kind": "commanddeclaration"}, {"full_name": "separationRel_eq_inter_closure", "code": "theorem separationRel_eq_inter_closure : \ud835\udce2 \u03b1 = \u22c2\u2080 (closure '' (\ud835\udce4 \u03b1).sets)", "start": [188, 1], "end": [189, 51], "kind": "commanddeclaration"}, {"full_name": "isClosed_separationRel", "code": "theorem isClosed_separationRel : IsClosed (\ud835\udce2 \u03b1)", "start": [192, 1], "end": [196, 25], "kind": "commanddeclaration"}, {"full_name": "separated_iff_t2", "code": "theorem separated_iff_t2 : SeparatedSpace \u03b1 \u2194 T2Space \u03b1", "start": [199, 1], "end": [207, 49], "kind": "commanddeclaration"}, {"full_name": "separated_t3", "code": "instance (priority := 100) separated_t3 [SeparatedSpace \u03b1] : T3Space \u03b1 :=\n  haveI := separated_iff_t2.mp \u2039_\u203a\n  \u27e8\u27e9", "start": [211, 1], "end": [213, 5], "kind": "commanddeclaration"}, {"full_name": "Subtype.separatedSpace", "code": "instance Subtype.separatedSpace [SeparatedSpace \u03b1] (s : Set \u03b1) : SeparatedSpace s :=\n  separated_iff_t2.mpr inferInstance", "start": [216, 1], "end": [217, 37], "kind": "commanddeclaration"}, {"full_name": "isClosed_of_spaced_out", "code": "theorem isClosed_of_spaced_out [SeparatedSpace \u03b1] {V\u2080 : Set (\u03b1 \u00d7 \u03b1)} (V\u2080_in : V\u2080 \u2208 \ud835\udce4 \u03b1) {s : Set \u03b1}\n    (hs : s.Pairwise fun x y => (x, y) \u2209 V\u2080) : IsClosed s", "start": [220, 1], "end": [234, 34], "kind": "commanddeclaration"}, {"full_name": "isClosed_range_of_spaced_out", "code": "theorem isClosed_range_of_spaced_out {\u03b9} [SeparatedSpace \u03b1] {V\u2080 : Set (\u03b1 \u00d7 \u03b1)} (V\u2080_in : V\u2080 \u2208 \ud835\udce4 \u03b1)\n    {f : \u03b9 \u2192 \u03b1} (hf : Pairwise fun x y => (f x, f y) \u2209 V\u2080) : IsClosed (range f)", "start": [237, 1], "end": [241, 34], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.separationSetoid", "code": "def separationSetoid (\u03b1 : Type u) [UniformSpace \u03b1] : Setoid \u03b1 :=\n  \u27e8fun x y => (x, y) \u2208 \ud835\udce2 \u03b1, separated_equiv\u27e9", "start": [250, 1], "end": [252, 45], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.separationSetoid.uniformSpace", "code": "instance separationSetoid.uniformSpace {\u03b1 : Type u} [UniformSpace \u03b1] :\n    UniformSpace (Quotient (separationSetoid \u03b1)) where\n  toTopologicalSpace := instTopologicalSpaceQuotient\n  uniformity := map (fun p : \u03b1 \u00d7 \u03b1 => (\u27e6p.1\u27e7, \u27e6p.2\u27e7)) (\ud835\udce4 \u03b1)\n  refl := le_trans (by simp [Quotient.exists_rep]) (Filter.map_mono refl_le_uniformity)\n  symm := tendsto_map' <| tendsto_map.comp tendsto_swap_uniformity\n  comp s hs := by\n    rcases comp_open_symm_mem_uniformity_sets hs with \u27e8U, hU, hUo, -, hUs\u27e9\n    refine' mem_of_superset (mem_lift' <| image_mem_map hU) ?_\n    simp only [subset_def, Prod.forall, mem_compRel, mem_image, Prod.ext_iff]\n    rintro _ _ \u27e8_, \u27e8\u27e8x, y\u27e9, hxyU, rfl, rfl\u27e9, \u27e8\u27e8y', z\u27e9, hyzU, hy, rfl\u27e9\u27e9\n    have : y' \u2933 y := separationRel_iff_specializes.1 (Quotient.exact hy)\n    exact @hUs (x, z) \u27e8y', this.mem_open (UniformSpace.isOpen_ball _ hUo) hxyU, hyzU\u27e9\n  isOpen_uniformity s := isOpen_coinduced.trans <| by\n    simp only [_root_.isOpen_uniformity, Quotient.forall, mem_map', mem_setOf_eq]\n    refine forall\u2082_congr fun x _ => \u27e8fun h => ?_, fun h => mem_of_superset h ?_\u27e9\n    \u00b7 rcases comp_mem_uniformity_sets h with \u27e8t, ht, hts\u27e9\n      refine mem_of_superset ht fun (y, z) hyz hyx => @hts (x, z) \u27e8y, ?_, hyz\u27e9 rfl\n      exact Quotient.exact hyx.symm _ ht\n    \u00b7 exact fun y hy hyx => hy <| congr_arg _ hyx", "start": [257, 1], "end": [276, 50], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformity_quotient", "code": "theorem uniformity_quotient :\n    \ud835\udce4 (Quotient (separationSetoid \u03b1)) = (\ud835\udce4 \u03b1).map fun p : \u03b1 \u00d7 \u03b1 => (\u27e6p.1\u27e7, \u27e6p.2\u27e7)", "start": [279, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformContinuous_quotient_mk'", "code": "theorem uniformContinuous_quotient_mk' :\n    UniformContinuous (Quotient.mk' : \u03b1 \u2192 Quotient (separationSetoid \u03b1))", "start": [284, 1], "end": [286, 9], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformContinuous_quotient_mk", "code": "theorem uniformContinuous_quotient_mk : UniformContinuous (Quotient.mk (separationSetoid \u03b1))", "start": [289, 1], "end": [290, 9], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformContinuous_quotient", "code": "theorem uniformContinuous_quotient {f : Quotient (separationSetoid \u03b1) \u2192 \u03b2}\n    (hf : UniformContinuous fun x => f \u27e6x\u27e7) : UniformContinuous f", "start": [292, 1], "end": [294, 5], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformContinuous_quotient_lift", "code": "theorem uniformContinuous_quotient_lift {f : \u03b1 \u2192 \u03b2} {h : \u2200 a b, (a, b) \u2208 \ud835\udce2 \u03b1 \u2192 f a = f b}\n    (hf : UniformContinuous f) : UniformContinuous fun a => Quotient.lift f h a", "start": [297, 1], "end": [299, 32], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.uniformContinuous_quotient_lift\u2082", "code": "theorem uniformContinuous_quotient_lift\u2082 {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n    {h : \u2200 a c b d, (a, b) \u2208 \ud835\udce2 \u03b1 \u2192 (c, d) \u2208 \ud835\udce2 \u03b2 \u2192 f a c = f b d}\n    (hf : UniformContinuous fun p : \u03b1 \u00d7 \u03b2 => f p.1 p.2) :\n    UniformContinuous fun p : _ \u00d7 _ => Quotient.lift\u2082 f h p.1 p.2", "start": [302, 1], "end": [308, 82], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_quotient_le_uniformity", "code": "theorem comap_quotient_le_uniformity :\n    ((\ud835\udce4 <| Quotient <| separationSetoid \u03b1).comap fun p : \u03b1 \u00d7 \u03b1 => (\u27e6p.fst\u27e7, \u27e6p.snd\u27e7)) \u2264 \ud835\udce4 \u03b1", "start": [311, 1], "end": [317, 73], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.comap_quotient_eq_uniformity", "code": "theorem comap_quotient_eq_uniformity :\n    ((\ud835\udce4 <| Quotient <| separationSetoid \u03b1).comap fun p : \u03b1 \u00d7 \u03b1 => (\u27e6p.fst\u27e7, \u27e6p.snd\u27e7)) = \ud835\udce4 \u03b1", "start": [320, 1], "end": [322, 56], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.separated_separation", "code": "instance separated_separation : SeparatedSpace (Quotient (separationSetoid \u03b1)) :=\n  \u27e8Set.ext fun \u27e8a, b\u27e9 =>\n      Quotient.inductionOn\u2082 a b fun a b =>\n        \u27e8fun h =>\n          have : a \u2248 b := fun s hs =>\n            have :\n              s \u2208 (\ud835\udce4 <| Quotient <| separationSetoid \u03b1).comap fun p : \u03b1 \u00d7 \u03b1 => (\u27e6p.1\u27e7, \u27e6p.2\u27e7) :=\n              comap_quotient_le_uniformity hs\n            let \u27e8t, ht, hts\u27e9 := this\n            hts (by dsimp [preimage]; exact h t ht)\n          show \u27e6a\u27e7 = \u27e6b\u27e7 from Quotient.sound this,\n          fun heq : \u27e6a\u27e7 = \u27e6b\u27e7 => fun h hs => heq \u25b8 refl_mem_uniformity hs\u27e9\u27e9", "start": [325, 1], "end": [336, 76], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.separated_of_uniformContinuous", "code": "theorem separated_of_uniformContinuous {f : \u03b1 \u2192 \u03b2} {x y : \u03b1} (H : UniformContinuous f) (h : x \u2248 y) :\n    f x \u2248 f y", "start": [339, 1], "end": [340, 40], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.eq_of_separated_of_uniformContinuous", "code": "theorem eq_of_separated_of_uniformContinuous [SeparatedSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {x y : \u03b1}\n    (H : UniformContinuous f) (h : x \u2248 y) : f x = f y", "start": [343, 1], "end": [345, 80], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient", "code": "def SeparationQuotient (\u03b1 : Type*) [UniformSpace \u03b1] :=\n  Quotient (separationSetoid \u03b1)", "start": [348, 1], "end": [350, 32], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.mk_eq_mk", "code": "lemma mk_eq_mk {x y : \u03b1} : (\u27e6x\u27e7 : SeparationQuotient \u03b1) = \u27e6y\u27e7 \u2194 Inseparable x y :=\n  Quotient.eq'.trans separationRel_iff_inseparable", "start": [364, 1], "end": [365, 51], "kind": "mathlibtacticlemma"}, {"full_name": "UniformSpace.SeparationQuotient.lift", "code": "def lift [SeparatedSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : SeparationQuotient \u03b1 \u2192 \u03b2 :=\n  if h : UniformContinuous f then Quotient.lift f fun _ _ => eq_of_separated_of_uniformContinuous h\n  else fun x => f (Nonempty.some \u27e8x.out\u27e9)", "start": [368, 1], "end": [371, 42], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.lift_mk", "code": "theorem lift_mk [SeparatedSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (h : UniformContinuous f) (a : \u03b1) :\n    lift f \u27e6a\u27e7 = f a", "start": [374, 1], "end": [375, 53], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.uniformContinuous_lift", "code": "theorem uniformContinuous_lift [SeparatedSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : UniformContinuous (lift f)", "start": [378, 1], "end": [383, 52], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.map", "code": "def map (f : \u03b1 \u2192 \u03b2) : SeparationQuotient \u03b1 \u2192 SeparationQuotient \u03b2 :=\n  lift (Quotient.mk' \u2218 f)", "start": [386, 1], "end": [388, 26], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.map_mk", "code": "theorem map_mk {f : \u03b1 \u2192 \u03b2} (h : UniformContinuous f) (a : \u03b1) : map f \u27e6a\u27e7 = \u27e6f a\u27e7", "start": [391, 1], "end": [392, 65], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.uniformContinuous_map", "code": "theorem uniformContinuous_map (f : \u03b1 \u2192 \u03b2) : UniformContinuous (map f)", "start": [395, 1], "end": [396, 44], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.map_unique", "code": "theorem map_unique {f : \u03b1 \u2192 \u03b2} (hf : UniformContinuous f)\n    {g : SeparationQuotient \u03b1 \u2192 SeparationQuotient \u03b2}\n    (comm : Quotient.mk _ \u2218 f = g \u2218 Quotient.mk _) : map f = g", "start": [399, 1], "end": [405, 34], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.map_id", "code": "theorem map_id : map (@id \u03b1) = id", "start": [408, 1], "end": [409, 38], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.map_comp", "code": "theorem map_comp {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : UniformContinuous f) (hg : UniformContinuous g) :\n    map g \u2218 map f = map (g \u2218 f)", "start": [412, 1], "end": [414, 81], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.separation_prod", "code": "theorem separation_prod {a\u2081 a\u2082 : \u03b1} {b\u2081 b\u2082 : \u03b2} : (a\u2081, b\u2081) \u2248 (a\u2082, b\u2082) \u2194 a\u2081 \u2248 a\u2082 \u2227 b\u2081 \u2248 b\u2082", "start": [419, 1], "end": [432, 33], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Separated.prod", "code": "instance Separated.prod [SeparatedSpace \u03b1] [SeparatedSpace \u03b2] : SeparatedSpace (\u03b1 \u00d7 \u03b2) :=\n  separated_def.2 fun _ _ H =>\n    Prod.ext (eq_of_separated_of_uniformContinuous uniformContinuous_fst H)\n      (eq_of_separated_of_uniformContinuous uniformContinuous_snd H)", "start": [435, 1], "end": [438, 69], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Cauchy.lean", "imports": ["Mathlib/Topology/Bases.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "Mathlib/Topology/Algebra/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Cauchy", "code": "def Cauchy (f : Filter \u03b1) :=\n  NeBot f \u2227 f \u00d7\u02e2 f \u2264 \ud835\udce4 \u03b1", "start": [25, 1], "end": [30, 25], "kind": "commanddeclaration"}, {"full_name": "IsComplete", "code": "def IsComplete (s : Set \u03b1) :=\n  \u2200 f, Cauchy f \u2192 f \u2264 \ud835\udcdf s \u2192 \u2203 x \u2208 s, f \u2264 \ud835\udcdd x", "start": [33, 1], "end": [36, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.cauchy_iff", "code": "theorem Filter.HasBasis.cauchy_iff {\u03b9} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s)\n    {f : Filter \u03b1} :\n    Cauchy f \u2194 NeBot f \u2227 \u2200 i, p i \u2192 \u2203 t \u2208 f, \u2200 x \u2208 t, \u2200 y \u2208 t, (x, y) \u2208 s i", "start": [39, 1], "end": [44, 83], "kind": "commanddeclaration"}, {"full_name": "cauchy_iff'", "code": "theorem cauchy_iff' {f : Filter \u03b1} :\n    Cauchy f \u2194 NeBot f \u2227 \u2200 s \u2208 \ud835\udce4 \u03b1, \u2203 t \u2208 f, \u2200 x \u2208 t, \u2200 y \u2208 t, (x, y) \u2208 s", "start": [47, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "cauchy_iff", "code": "theorem cauchy_iff {f : Filter \u03b1} : Cauchy f \u2194 NeBot f \u2227 \u2200 s \u2208 \ud835\udce4 \u03b1, \u2203 t \u2208 f, t \u00d7\u02e2 t \u2286 s", "start": [52, 1], "end": [54, 81], "kind": "commanddeclaration"}, {"full_name": "cauchy_iff_le", "code": "lemma cauchy_iff_le {l : Filter \u03b1} [hl : l.NeBot] :\n    Cauchy l \u2194 l \u00d7\u02e2 l \u2264 \ud835\udce4 \u03b1 := by\n  simp only [Cauchy, hl, true_and]", "start": [57, 1], "end": [59, 35], "kind": "mathlibtacticlemma"}, {"full_name": "Cauchy.ultrafilter_of", "code": "theorem Cauchy.ultrafilter_of {l : Filter \u03b1} (h : Cauchy l) :\n    Cauchy (@Ultrafilter.of _ l h.1 : Filter \u03b1)", "start": [61, 1], "end": [65, 70], "kind": "commanddeclaration"}, {"full_name": "cauchy_map_iff", "code": "theorem cauchy_map_iff {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    Cauchy (l.map f) \u2194 NeBot l \u2227 Tendsto (fun p : \u03b2 \u00d7 \u03b2 => (f p.1, f p.2)) (l \u00d7\u02e2 l) (\ud835\udce4 \u03b1)", "start": [68, 1], "end": [70, 55], "kind": "commanddeclaration"}, {"full_name": "cauchy_map_iff'", "code": "theorem cauchy_map_iff' {l : Filter \u03b2} [hl : NeBot l] {f : \u03b2 \u2192 \u03b1} :\n    Cauchy (l.map f) \u2194 Tendsto (fun p : \u03b2 \u00d7 \u03b2 => (f p.1, f p.2)) (l \u00d7\u02e2 l) (\ud835\udce4 \u03b1)", "start": [73, 1], "end": [75, 43], "kind": "commanddeclaration"}, {"full_name": "Cauchy.mono", "code": "theorem Cauchy.mono {f g : Filter \u03b1} [hg : NeBot g] (h_c : Cauchy f) (h_le : g \u2264 f) : Cauchy g", "start": [78, 1], "end": [79, 56], "kind": "commanddeclaration"}, {"full_name": "Cauchy.mono'", "code": "theorem Cauchy.mono' {f g : Filter \u03b1} (h_c : Cauchy f) (_ : NeBot g) (h_le : g \u2264 f) : Cauchy g", "start": [82, 1], "end": [83, 16], "kind": "commanddeclaration"}, {"full_name": "cauchy_nhds", "code": "theorem cauchy_nhds {a : \u03b1} : Cauchy (\ud835\udcdd a)", "start": [86, 1], "end": [87, 66], "kind": "commanddeclaration"}, {"full_name": "cauchy_pure", "code": "theorem cauchy_pure {a : \u03b1} : Cauchy (pure a)", "start": [90, 1], "end": [91, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.cauchy_map", "code": "theorem Filter.Tendsto.cauchy_map {l : Filter \u03b2} [NeBot l] {f : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (h : Tendsto f l (\ud835\udcdd a)) : Cauchy (map f l)", "start": [94, 1], "end": [96, 21], "kind": "commanddeclaration"}, {"full_name": "Cauchy.mono_uniformSpace", "code": "lemma Cauchy.mono_uniformSpace {u v : UniformSpace \u03b2} {F : Filter \u03b2} (huv : u \u2264 v)\n    (hF : Cauchy (uniformSpace := u) F) : Cauchy (uniformSpace := v) F :=\n  \u27e8hF.1, hF.2.trans huv\u27e9", "start": [99, 1], "end": [101, 25], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_inf_uniformSpace", "code": "lemma cauchy_inf_uniformSpace {u v : UniformSpace \u03b2} {F : Filter \u03b2} :\n    Cauchy (uniformSpace := u \u2293 v) F \u2194\n    Cauchy (uniformSpace := u) F \u2227 Cauchy (uniformSpace := v) F := by\n  unfold Cauchy\n  rw [inf_uniformity (u := u), le_inf_iff, and_and_left]", "start": [103, 1], "end": [107, 57], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_iInf_uniformSpace", "code": "lemma cauchy_iInf_uniformSpace {\u03b9 : Sort*} [Nonempty \u03b9] {u : \u03b9 \u2192 UniformSpace \u03b2}\n    {l : Filter \u03b2} :\n    Cauchy (uniformSpace := \u2a05 i, u i) l \u2194 \u2200 i, Cauchy (uniformSpace := u i) l := by\n  unfold Cauchy\n  rw [iInf_uniformity, le_iInf_iff, forall_and, forall_const]", "start": [109, 1], "end": [113, 62], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_iInf_uniformSpace'", "code": "lemma cauchy_iInf_uniformSpace' {\u03b9 : Sort*} {u : \u03b9 \u2192 UniformSpace \u03b2}\n    {l : Filter \u03b2} [l.NeBot] :\n    Cauchy (uniformSpace := \u2a05 i, u i) l \u2194 \u2200 i, Cauchy (uniformSpace := u i) l := by\n  simp_rw [cauchy_iff_le (uniformSpace := _), iInf_uniformity, le_iInf_iff]", "start": [115, 1], "end": [118, 76], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_comap_uniformSpace", "code": "lemma cauchy_comap_uniformSpace {u : UniformSpace \u03b2} {f : \u03b1 \u2192 \u03b2} {l : Filter \u03b1} :\n    Cauchy (uniformSpace := comap f u) l \u2194 Cauchy (map f l) := by\n  simp only [Cauchy, map_neBot_iff, prod_map_map_eq, map_le_iff_le_comap]\n  rfl", "start": [120, 1], "end": [123, 6], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_prod_iff", "code": "lemma cauchy_prod_iff [UniformSpace \u03b2] {F : Filter (\u03b1 \u00d7 \u03b2)} :\n    Cauchy F \u2194 Cauchy (map Prod.fst F) \u2227 Cauchy (map Prod.snd F) := by\n  simp_rw [instUniformSpaceProd, \u2190 cauchy_comap_uniformSpace, \u2190 cauchy_inf_uniformSpace]", "start": [125, 1], "end": [127, 89], "kind": "mathlibtacticlemma"}, {"full_name": "Cauchy.prod", "code": "theorem Cauchy.prod [UniformSpace \u03b2] {f : Filter \u03b1} {g : Filter \u03b2} (hf : Cauchy f) (hg : Cauchy g) :\n    Cauchy (f \u00d7\u02e2 g)", "start": [129, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "le_nhds_of_cauchy_adhp_aux", "code": "theorem le_nhds_of_cauchy_adhp_aux {f : Filter \u03b1} {x : \u03b1}\n    (adhs : \u2200 s \u2208 \ud835\udce4 \u03b1, \u2203 t \u2208 f, t \u00d7\u02e2 t \u2286 s \u2227 \u2203 y, (x, y) \u2208 s \u2227 y \u2208 t) : f \u2264 \ud835\udcdd x", "start": [135, 1], "end": [149, 79], "kind": "commanddeclaration"}, {"full_name": "le_nhds_of_cauchy_adhp", "code": "theorem le_nhds_of_cauchy_adhp {f : Filter \u03b1} {x : \u03b1} (hf : Cauchy f) (adhs : ClusterPt x f) :\n    f \u2264 \ud835\udcdd x", "start": [152, 1], "end": [160, 95], "kind": "commanddeclaration"}, {"full_name": "le_nhds_iff_adhp_of_cauchy", "code": "theorem le_nhds_iff_adhp_of_cauchy {f : Filter \u03b1} {x : \u03b1} (hf : Cauchy f) :\n    f \u2264 \ud835\udcdd x \u2194 ClusterPt x f", "start": [163, 1], "end": [165, 69], "kind": "commanddeclaration"}, {"full_name": "Cauchy.map", "code": "nonrec theorem Cauchy.map [UniformSpace \u03b2] {f : Filter \u03b1} {m : \u03b1 \u2192 \u03b2} (hf : Cauchy f)\n    (hm : UniformContinuous m) : Cauchy (map m f)", "start": [168, 1], "end": [174, 21], "kind": "commanddeclaration"}, {"full_name": "Cauchy.comap", "code": "nonrec theorem Cauchy.comap [UniformSpace \u03b2] {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : Cauchy f)\n    (hm : comap (fun p : \u03b1 \u00d7 \u03b1 => (m p.1, m p.2)) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1) [NeBot (comap m f)] :\n    Cauchy (comap m f)", "start": [177, 1], "end": [184, 21], "kind": "commanddeclaration"}, {"full_name": "Cauchy.comap'", "code": "theorem Cauchy.comap' [UniformSpace \u03b2] {f : Filter \u03b2} {m : \u03b1 \u2192 \u03b2} (hf : Cauchy f)\n    (hm : Filter.comap (fun p : \u03b1 \u00d7 \u03b1 => (m p.1, m p.2)) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1)\n    (_ : NeBot (Filter.comap m f)) : Cauchy (Filter.comap m f)", "start": [187, 1], "end": [190, 14], "kind": "commanddeclaration"}, {"full_name": "CauchySeq", "code": "def CauchySeq [SemilatticeSup \u03b2] (u : \u03b2 \u2192 \u03b1) :=\n  Cauchy (atTop.map u)", "start": [193, 1], "end": [197, 23], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.tendsto_uniformity", "code": "theorem CauchySeq.tendsto_uniformity [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} (h : CauchySeq u) :\n    Tendsto (Prod.map u u) atTop (\ud835\udce4 \u03b1)", "start": [200, 1], "end": [202, 76], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.nonempty", "code": "theorem CauchySeq.nonempty [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} (hu : CauchySeq u) : Nonempty \u03b2", "start": [205, 1], "end": [206, 53], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.mem_entourage", "code": "theorem CauchySeq.mem_entourage {\u03b2 : Type*} [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} (h : CauchySeq u)\n    {V : Set (\u03b1 \u00d7 \u03b1)} (hV : V \u2208 \ud835\udce4 \u03b1) : \u2203 k\u2080, \u2200 i j, k\u2080 \u2264 i \u2192 k\u2080 \u2264 j \u2192 (u i, u j) \u2208 V", "start": [209, 1], "end": [213, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.cauchySeq", "code": "theorem Filter.Tendsto.cauchySeq [SemilatticeSup \u03b2] [Nonempty \u03b2] {f : \u03b2 \u2192 \u03b1} {x}\n    (hx : Tendsto f atTop (\ud835\udcdd x)) : CauchySeq f", "start": [216, 1], "end": [218, 16], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_const", "code": "theorem cauchySeq_const [SemilatticeSup \u03b2] [Nonempty \u03b2] (x : \u03b1) : CauchySeq fun _ : \u03b2 => x", "start": [221, 1], "end": [222, 31], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_iff_tendsto", "code": "theorem cauchySeq_iff_tendsto [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 Tendsto (Prod.map u u) atTop (\ud835\udce4 \u03b1)", "start": [225, 1], "end": [227, 76], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.comp_tendsto", "code": "theorem CauchySeq.comp_tendsto {\u03b3} [SemilatticeSup \u03b2] [SemilatticeSup \u03b3] [Nonempty \u03b3] {f : \u03b2 \u2192 \u03b1}\n    (hf : CauchySeq f) {g : \u03b3 \u2192 \u03b2} (hg : Tendsto g atTop atTop) : CauchySeq (f \u2218 g)", "start": [230, 1], "end": [232, 75], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.comp_injective", "code": "theorem CauchySeq.comp_injective [SemilatticeSup \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2] {u : \u2115 \u2192 \u03b1}\n    (hu : CauchySeq u) {f : \u03b2 \u2192 \u2115} (hf : Injective f) : CauchySeq (u \u2218 f)", "start": [235, 1], "end": [237, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Bijective.cauchySeq_comp_iff", "code": "theorem Function.Bijective.cauchySeq_comp_iff {f : \u2115 \u2192 \u2115} (hf : Bijective f) (u : \u2115 \u2192 \u03b1) :\n    CauchySeq (u \u2218 f) \u2194 CauchySeq u", "start": [240, 1], "end": [244, 83], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.subseq_subseq_mem", "code": "theorem CauchySeq.subseq_subseq_mem {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    (hu : CauchySeq u) {f g : \u2115 \u2192 \u2115} (hf : Tendsto f atTop atTop) (hg : Tendsto g atTop atTop) :\n    \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, ((u \u2218 f \u2218 \u03c6) n, (u \u2218 g \u2218 \u03c6) n) \u2208 V n", "start": [247, 1], "end": [251, 82], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_iff'", "code": "theorem cauchySeq_iff' {u : \u2115 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 V \u2208 \ud835\udce4 \u03b1, \u2200\u1da0 k in atTop, k \u2208 Prod.map u u \u207b\u00b9' V", "start": [255, 1], "end": [257, 24], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_iff", "code": "theorem cauchySeq_iff {u : \u2115 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 V \u2208 \ud835\udce4 \u03b1, \u2203 N, \u2200 k \u2265 N, \u2200 l \u2265 N, (u k, u l) \u2208 V", "start": [260, 1], "end": [262, 89], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.prod_map", "code": "theorem CauchySeq.prod_map {\u03b3 \u03b4} [UniformSpace \u03b2] [SemilatticeSup \u03b3] [SemilatticeSup \u03b4] {u : \u03b3 \u2192 \u03b1}\n    {v : \u03b4 \u2192 \u03b2} (hu : CauchySeq u) (hv : CauchySeq v) : CauchySeq (Prod.map u v)", "start": [265, 1], "end": [267, 81], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.prod", "code": "theorem CauchySeq.prod {\u03b3} [UniformSpace \u03b2] [SemilatticeSup \u03b3] {u : \u03b3 \u2192 \u03b1} {v : \u03b3 \u2192 \u03b2}\n    (hu : CauchySeq u) (hv : CauchySeq v) : CauchySeq fun x => (u x, v x)", "start": [270, 1], "end": [273, 59], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.eventually_eventually", "code": "theorem CauchySeq.eventually_eventually [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} (hu : CauchySeq u)\n    {V : Set (\u03b1 \u00d7 \u03b1)} (hV : V \u2208 \ud835\udce4 \u03b1) : \u2200\u1da0 k in atTop, \u2200\u1da0 l in atTop, (u k, u l) \u2208 V", "start": [276, 1], "end": [278, 53], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp_cauchySeq", "code": "theorem UniformContinuous.comp_cauchySeq {\u03b3} [UniformSpace \u03b2] [SemilatticeSup \u03b3] {f : \u03b1 \u2192 \u03b2}\n    (hf : UniformContinuous f) {u : \u03b3 \u2192 \u03b1} (hu : CauchySeq u) : CauchySeq (f \u2218 u)", "start": [281, 1], "end": [283, 12], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.subseq_mem", "code": "theorem CauchySeq.subseq_mem {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    (hu : CauchySeq u) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 \u2200 n, (u <| \u03c6 (n + 1), u <| \u03c6 n) \u2208 V n", "start": [286, 1], "end": [294, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.subseq_mem_entourage", "code": "theorem Filter.Tendsto.subseq_mem_entourage {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n    {a : \u03b1} (hu : Tendsto u atTop (\ud835\udcdd a)) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 (u (\u03c6 0), a) \u2208 V 0 \u2227\n      \u2200 n, (u <| \u03c6 (n + 1), u <| \u03c6 n) \u2208 V (n + 1)", "start": [297, 1], "end": [303, 70], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_of_cauchySeq_of_subseq", "code": "theorem tendsto_nhds_of_cauchySeq_of_subseq [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} (hu : CauchySeq u)\n    {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b2} {p : Filter \u03b9} [NeBot p] (hf : Tendsto f p atTop) {a : \u03b1}\n    (ha : Tendsto (u \u2218 f) p (\ud835\udcdd a)) : Tendsto u atTop (\ud835\udcdd a)", "start": [306, 1], "end": [310, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.cauchySeq_iff", "code": "theorem Filter.HasBasis.cauchySeq_iff {\u03b3} [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} {p : \u03b3 \u2192 Prop}\n    {s : \u03b3 \u2192 Set (\u03b1 \u00d7 \u03b1)} (h : (\ud835\udce4 \u03b1).HasBasis p s) :\n    CauchySeq u \u2194 \u2200 i, p i \u2192 \u2203 N, \u2200 m, N \u2264 m \u2192 \u2200 n, N \u2264 n \u2192 (u m, u n) \u2208 s i", "start": [313, 1], "end": [319, 81], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.cauchySeq_iff'", "code": "theorem Filter.HasBasis.cauchySeq_iff' {\u03b3} [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1}\n    {p : \u03b3 \u2192 Prop} {s : \u03b3 \u2192 Set (\u03b1 \u00d7 \u03b1)} (H : (\ud835\udce4 \u03b1).HasBasis p s) :\n    CauchySeq u \u2194 \u2200 i, p i \u2192 \u2203 N, \u2200 n \u2265 N, (u n, u N) \u2208 s i", "start": [322, 1], "end": [330, 30], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_controlled", "code": "theorem cauchySeq_of_controlled [SemilatticeSup \u03b2] [Nonempty \u03b2] (U : \u03b2 \u2192 Set (\u03b1 \u00d7 \u03b1))\n    (hU : \u2200 s \u2208 \ud835\udce4 \u03b1, \u2203 n, U n \u2286 s) {f : \u03b2 \u2192 \u03b1}\n    (hf : \u2200 \u2983N m n : \u03b2\u2984, N \u2264 m \u2192 N \u2264 n \u2192 (f m, f n) \u2208 U N) : CauchySeq f", "start": [333, 1], "end": [344, 33], "kind": "commanddeclaration"}, {"full_name": "isComplete_iff_clusterPt", "code": "theorem isComplete_iff_clusterPt {s : Set \u03b1} :\n    IsComplete s \u2194 \u2200 l, Cauchy l \u2192 l \u2264 \ud835\udcdf s \u2192 \u2203 x \u2208 s, ClusterPt x l", "start": [347, 1], "end": [350, 34], "kind": "commanddeclaration"}, {"full_name": "isComplete_iff_ultrafilter", "code": "theorem isComplete_iff_ultrafilter {s : Set \u03b1} :\n    IsComplete s \u2194 \u2200 l : Ultrafilter \u03b1, Cauchy (l : Filter \u03b1) \u2192 \u2191l \u2264 \ud835\udcdf s \u2192 \u2203 x \u2208 s, \u2191l \u2264 \ud835\udcdd x", "start": [353, 1], "end": [358, 72], "kind": "commanddeclaration"}, {"full_name": "isComplete_iff_ultrafilter'", "code": "theorem isComplete_iff_ultrafilter' {s : Set \u03b1} :\n    IsComplete s \u2194 \u2200 l : Ultrafilter \u03b1, Cauchy (l : Filter \u03b1) \u2192 s \u2208 l \u2192 \u2203 x \u2208 s, \u2191l \u2264 \ud835\udcdd x", "start": [361, 1], "end": [363, 91], "kind": "commanddeclaration"}, {"full_name": "IsComplete.union", "code": "protected theorem IsComplete.union {s t : Set \u03b1} (hs : IsComplete s) (ht : IsComplete t) :\n    IsComplete (s \u222a t)", "start": [366, 1], "end": [371, 57], "kind": "commanddeclaration"}, {"full_name": "isComplete_iUnion_separated", "code": "theorem isComplete_iUnion_separated {\u03b9 : Sort*} {s : \u03b9 \u2192 Set \u03b1} (hs : \u2200 i, IsComplete (s i))\n    {U : Set (\u03b1 \u00d7 \u03b1)} (hU : U \u2208 \ud835\udce4 \u03b1) (hd : \u2200 (i j : \u03b9), \u2200 x \u2208 s i, \u2200 y \u2208 s j, (x, y) \u2208 U \u2192 i = j) :\n    IsComplete (\u22c3 i, s i)", "start": [374, 1], "end": [392, 40], "kind": "commanddeclaration"}, {"full_name": "CompleteSpace", "code": "class CompleteSpace (\u03b1 : Type u) [UniformSpace \u03b1] : Prop where\n  \n  complete : \u2200 {f : Filter \u03b1}, Cauchy f \u2192 \u2203 x, f \u2264 \ud835\udcdd x", "start": [395, 1], "end": [399, 55], "kind": "commanddeclaration"}, {"full_name": "complete_univ", "code": "theorem complete_univ {\u03b1 : Type u} [UniformSpace \u03b1] [CompleteSpace \u03b1] :\n    IsComplete (univ : Set \u03b1)", "start": [402, 1], "end": [405, 28], "kind": "commanddeclaration"}, {"full_name": "CompleteSpace.prod", "code": "instance CompleteSpace.prod [UniformSpace \u03b2] [CompleteSpace \u03b1] [CompleteSpace \u03b2] :\n    CompleteSpace (\u03b1 \u00d7 \u03b2) where\n  complete hf :=\n    let \u27e8x1, hx1\u27e9 := CompleteSpace.complete <| hf.map uniformContinuous_fst\n    let \u27e8x2, hx2\u27e9 := CompleteSpace.complete <| hf.map uniformContinuous_snd\n    \u27e8(x1, x2), by rw [nhds_prod_eq, le_prod]; constructor <;> assumption\u27e9", "start": [408, 1], "end": [413, 74], "kind": "commanddeclaration"}, {"full_name": "CompleteSpace.fst_of_prod", "code": "lemma CompleteSpace.fst_of_prod [UniformSpace \u03b2] [CompleteSpace (\u03b1 \u00d7 \u03b2)] [h : Nonempty \u03b2] :\n    CompleteSpace \u03b1 where\n  complete hf :=\n    let \u27e8y\u27e9 := h\n    let \u27e8(a, b), hab\u27e9 := CompleteSpace.complete <| hf.prod <| cauchy_pure (a := y)\n    \u27e8a, by simpa only [map_fst_prod, nhds_prod_eq] using map_mono (m := Prod.fst) hab\u27e9", "start": [416, 1], "end": [421, 87], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteSpace.snd_of_prod", "code": "lemma CompleteSpace.snd_of_prod [UniformSpace \u03b2] [CompleteSpace (\u03b1 \u00d7 \u03b2)] [h : Nonempty \u03b1] :\n    CompleteSpace \u03b2 where\n  complete hf :=\n    let \u27e8x\u27e9 := h\n    let \u27e8(a, b), hab\u27e9 := CompleteSpace.complete <| (cauchy_pure (a := x)).prod hf\n    \u27e8b, by simpa only [map_snd_prod, nhds_prod_eq] using map_mono (m := Prod.snd) hab\u27e9", "start": [423, 1], "end": [428, 87], "kind": "mathlibtacticlemma"}, {"full_name": "completeSpace_prod_of_nonempty", "code": "lemma completeSpace_prod_of_nonempty [UniformSpace \u03b2] [Nonempty \u03b1] [Nonempty \u03b2] :\n    CompleteSpace (\u03b1 \u00d7 \u03b2) \u2194 CompleteSpace \u03b1 \u2227 CompleteSpace \u03b2 :=\n  \u27e8fun _ \u21a6 \u27e8.fst_of_prod (\u03b2 := \u03b2), .snd_of_prod (\u03b1 := \u03b1)\u27e9, fun \u27e8_, _\u27e9 \u21a6 .prod\u27e9", "start": [430, 1], "end": [432, 79], "kind": "mathlibtacticlemma"}, {"full_name": "CompleteSpace.mulOpposite", "code": "@[to_additive]\ninstance CompleteSpace.mulOpposite [CompleteSpace \u03b1] : CompleteSpace \u03b1\u1d50\u1d52\u1d56 where\n  complete hf :=\n    MulOpposite.op_surjective.exists.mpr <|\n      let \u27e8x, hx\u27e9 := CompleteSpace.complete (hf.map MulOpposite.uniformContinuous_unop)\n      \u27e8x, (map_le_iff_le_comap.mp hx).trans_eq <| MulOpposite.comap_unop_nhds _\u27e9", "start": [434, 1], "end": [439, 81], "kind": "commanddeclaration"}, {"full_name": "completeSpace_of_isComplete_univ", "code": "theorem completeSpace_of_isComplete_univ (h : IsComplete (univ : Set \u03b1)) : CompleteSpace \u03b1", "start": [443, 1], "end": [445, 84], "kind": "commanddeclaration"}, {"full_name": "completeSpace_iff_isComplete_univ", "code": "theorem completeSpace_iff_isComplete_univ : CompleteSpace \u03b1 \u2194 IsComplete (univ : Set \u03b1)", "start": [448, 1], "end": [449, 57], "kind": "commanddeclaration"}, {"full_name": "completeSpace_iff_ultrafilter", "code": "theorem completeSpace_iff_ultrafilter :\n    CompleteSpace \u03b1 \u2194 \u2200 l : Ultrafilter \u03b1, Cauchy (l : Filter \u03b1) \u2192 \u2203 x : \u03b1, \u2191l \u2264 \ud835\udcdd x", "start": [452, 1], "end": [454, 71], "kind": "commanddeclaration"}, {"full_name": "cauchy_iff_exists_le_nhds", "code": "theorem cauchy_iff_exists_le_nhds [CompleteSpace \u03b1] {l : Filter \u03b1} [NeBot l] :\n    Cauchy l \u2194 \u2203 x, l \u2264 \ud835\udcdd x", "start": [457, 1], "end": [459, 63], "kind": "commanddeclaration"}, {"full_name": "cauchy_map_iff_exists_tendsto", "code": "theorem cauchy_map_iff_exists_tendsto [CompleteSpace \u03b1] {l : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} [NeBot l] :\n    Cauchy (l.map f) \u2194 \u2203 x, Tendsto f l (\ud835\udcdd x)", "start": [462, 1], "end": [464, 28], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_tendsto_of_complete", "code": "theorem cauchySeq_tendsto_of_complete [SemilatticeSup \u03b2] [CompleteSpace \u03b1] {u : \u03b2 \u2192 \u03b1}\n    (H : CauchySeq u) : \u2203 x, Tendsto u atTop (\ud835\udcdd x)", "start": [467, 1], "end": [470, 27], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_tendsto_of_isComplete", "code": "theorem cauchySeq_tendsto_of_isComplete [SemilatticeSup \u03b2] {K : Set \u03b1} (h\u2081 : IsComplete K)\n    {u : \u03b2 \u2192 \u03b1} (h\u2082 : \u2200 n, u n \u2208 K) (h\u2083 : CauchySeq u) : \u2203 v \u2208 K, Tendsto u atTop (\ud835\udcdd v)", "start": [473, 1], "end": [477, 60], "kind": "commanddeclaration"}, {"full_name": "Cauchy.le_nhds_lim", "code": "theorem Cauchy.le_nhds_lim [CompleteSpace \u03b1] [Nonempty \u03b1] {f : Filter \u03b1} (hf : Cauchy f) :\n    f \u2264 \ud835\udcdd (lim f)", "start": [480, 1], "end": [482, 49], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.tendsto_limUnder", "code": "theorem CauchySeq.tendsto_limUnder [SemilatticeSup \u03b2] [CompleteSpace \u03b1] [Nonempty \u03b1] {u : \u03b2 \u2192 \u03b1}\n    (h : CauchySeq u) : Tendsto u atTop (\ud835\udcdd <| limUnder atTop u)", "start": [486, 1], "end": [488, 16], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isComplete", "code": "theorem IsClosed.isComplete [CompleteSpace \u03b1] {s : Set \u03b1} (h : IsClosed s) : IsComplete s", "start": [491, 1], "end": [494, 71], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded", "code": "def TotallyBounded (s : Set \u03b1) : Prop :=\n  \u2200 d \u2208 \ud835\udce4 \u03b1, \u2203 t : Set \u03b1, t.Finite \u2227 s \u2286 \u22c3 y \u2208 t, { x | (x, y) \u2208 d }", "start": [497, 1], "end": [500, 69], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded.exists_subset", "code": "theorem TotallyBounded.exists_subset {s : Set \u03b1} (hs : TotallyBounded s) {U : Set (\u03b1 \u00d7 \u03b1)}\n    (hU : U \u2208 \ud835\udce4 \u03b1) : \u2203 t, t \u2286 s \u2227 Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, { x | (x, y) \u2208 U }", "start": [503, 1], "end": [517, 55], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_iff_subset", "code": "theorem totallyBounded_iff_subset {s : Set \u03b1} :\n    TotallyBounded s \u2194\n      \u2200 d \u2208 \ud835\udce4 \u03b1, \u2203 t, t \u2286 s \u2227 Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, { x | (x, y) \u2208 d }", "start": [520, 1], "end": [525, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.totallyBounded_iff", "code": "theorem Filter.HasBasis.totallyBounded_iff {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    (H : (\ud835\udce4 \u03b1).HasBasis p U) {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 i, p i \u2192 \u2203 t : Set \u03b1, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, { x | (x, y) \u2208 U i }", "start": [528, 1], "end": [532, 80], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_of_forall_symm", "code": "theorem totallyBounded_of_forall_symm {s : Set \u03b1}\n    (h : \u2200 V \u2208 \ud835\udce4 \u03b1, SymmetricRel V \u2192 \u2203 t : Set \u03b1, Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, ball y V) :\n    TotallyBounded s", "start": [535, 1], "end": [539, 62], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_subset", "code": "theorem totallyBounded_subset {s\u2081 s\u2082 : Set \u03b1} (hs : s\u2081 \u2286 s\u2082) (h : TotallyBounded s\u2082) :\n    TotallyBounded s\u2081", "start": [542, 1], "end": [545, 32], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_empty", "code": "theorem totallyBounded_empty : TotallyBounded (\u2205 : Set \u03b1)", "start": [548, 1], "end": [549, 36], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded.closure", "code": "theorem TotallyBounded.closure {s : Set \u03b1} (h : TotallyBounded s) : TotallyBounded (closure s)", "start": [552, 1], "end": [558, 96], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded.image", "code": "theorem TotallyBounded.image [UniformSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hs : TotallyBounded s)\n    (hf : UniformContinuous f) : TotallyBounded (f '' s)", "start": [561, 1], "end": [571, 20], "kind": "commanddeclaration"}, {"full_name": "Ultrafilter.cauchy_of_totallyBounded", "code": "theorem Ultrafilter.cauchy_of_totallyBounded {s : Set \u03b1} (f : Ultrafilter \u03b1) (hs : TotallyBounded s)\n    (h : \u2191f \u2264 \ud835\udcdf s) : Cauchy (f : Filter \u03b1)", "start": [574, 1], "end": [584, 71], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_iff_filter", "code": "theorem totallyBounded_iff_filter {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 f, NeBot f \u2192 f \u2264 \ud835\udcdf s \u2192 \u2203 c \u2264 f, Cauchy c", "start": [587, 1], "end": [610, 42], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_iff_ultrafilter", "code": "theorem totallyBounded_iff_ultrafilter {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 f : Ultrafilter \u03b1, \u2191f \u2264 \ud835\udcdf s \u2192 Cauchy (f : Filter \u03b1)", "start": [613, 1], "end": [617, 87], "kind": "commanddeclaration"}, {"full_name": "isCompact_iff_totallyBounded_isComplete", "code": "theorem isCompact_iff_totallyBounded_isComplete {s : Set \u03b1} :\n    IsCompact s \u2194 TotallyBounded s \u2227 IsComplete s", "start": [620, 1], "end": [631, 58], "kind": "commanddeclaration"}, {"full_name": "IsCompact.totallyBounded", "code": "protected theorem IsCompact.totallyBounded {s : Set \u03b1} (h : IsCompact s) : TotallyBounded s", "start": [634, 1], "end": [635, 50], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isComplete", "code": "protected theorem IsCompact.isComplete {s : Set \u03b1} (h : IsCompact s) : IsComplete s", "start": [638, 1], "end": [639, 50], "kind": "commanddeclaration"}, {"full_name": "complete_of_compact", "code": "instance (priority := 100) complete_of_compact {\u03b1 : Type u} [UniformSpace \u03b1] [CompactSpace \u03b1] :\n    CompleteSpace \u03b1 :=\n  \u27e8fun hf => by simpa using (isCompact_iff_totallyBounded_isComplete.1 isCompact_univ).2 _ hf\u27e9", "start": [643, 1], "end": [645, 95], "kind": "commanddeclaration"}, {"full_name": "isCompact_of_totallyBounded_isClosed", "code": "theorem isCompact_of_totallyBounded_isClosed [CompleteSpace \u03b1] {s : Set \u03b1} (ht : TotallyBounded s)\n    (hc : IsClosed s) : IsCompact s", "start": [648, 1], "end": [650, 73], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.totallyBounded_range", "code": "theorem CauchySeq.totallyBounded_range {s : \u2115 \u2192 \u03b1} (hs : CauchySeq s) :\n    TotallyBounded (range s)", "start": [653, 1], "end": [663, 77], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeqAux", "code": "def setSeqAux (n : \u2115) : { s : Set \u03b1 // s \u2208 f \u2227 s \u00d7\u02e2 s \u2286 U n } :=\n  indefiniteDescription _ <| (cauchy_iff.1 hf).2 (U n) (U_mem n)", "start": [689, 1], "end": [692, 65], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeq", "code": "def setSeq (n : \u2115) : Set \u03b1 :=\n  \u22c2 m \u2208 Set.Iic n, (setSeqAux hf U_mem m).val", "start": [695, 1], "end": [698, 46], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeq_mem", "code": "theorem setSeq_mem (n : \u2115) : setSeq hf U_mem n \u2208 f", "start": [701, 1], "end": [702, 74], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeq_mono", "code": "theorem setSeq_mono \u2983m n : \u2115\u2984 (h : m \u2264 n) : setSeq hf U_mem n \u2286 setSeq hf U_mem m", "start": [705, 1], "end": [706, 52], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeq_sub_aux", "code": "theorem setSeq_sub_aux (n : \u2115) : setSeq hf U_mem n \u2286 setSeqAux hf U_mem n", "start": [709, 1], "end": [710, 38], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.setSeq_prod_subset", "code": "theorem setSeq_prod_subset {N m n} (hm : N \u2264 m) (hn : N \u2264 n) :\n    setSeq hf U_mem m \u00d7\u02e2 setSeq hf U_mem n \u2286 U N", "start": [713, 1], "end": [717, 37], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.seq", "code": "def seq (n : \u2115) : \u03b1 :=\n  choose <| hf.1.nonempty_of_mem (setSeq_mem hf U_mem n)", "start": [720, 1], "end": [724, 57], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.seq_mem", "code": "theorem seq_mem (n : \u2115) : seq hf U_mem n \u2208 setSeq hf U_mem n", "start": [727, 1], "end": [728, 62], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.seq_pair_mem", "code": "theorem seq_pair_mem \u2983N m n : \u2115\u2984 (hm : N \u2264 m) (hn : N \u2264 n) :\n    (seq hf U_mem m, seq hf U_mem n) \u2208 U N", "start": [731, 1], "end": [733, 77], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.seq_is_cauchySeq", "code": "theorem seq_is_cauchySeq : CauchySeq <| seq hf U_mem", "start": [736, 1], "end": [737, 58], "kind": "commanddeclaration"}, {"full_name": "SequentiallyComplete.le_nhds_of_seq_tendsto_nhds", "code": "theorem le_nhds_of_seq_tendsto_nhds \u2983a : \u03b1\u2984 (ha : Tendsto (seq hf U_mem) atTop (\ud835\udcdd a)) : f \u2264 \ud835\udcdd a", "start": [740, 1], "end": [751, 45], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.complete_of_convergent_controlled_sequences", "code": "theorem complete_of_convergent_controlled_sequences (U : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)) (U_mem : \u2200 n, U n \u2208 \ud835\udce4 \u03b1)\n    (HU : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N m n, N \u2264 m \u2192 N \u2264 n \u2192 (u m, u n) \u2208 U N) \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1", "start": [764, 1], "end": [775, 56], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.complete_of_cauchySeq_tendsto", "code": "theorem complete_of_cauchySeq_tendsto (H' : \u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) :\n    CompleteSpace \u03b1", "start": [778, 1], "end": [784, 65], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.firstCountableTopology", "code": "instance (priority := 100) firstCountableTopology : FirstCountableTopology \u03b1 :=\n  \u27e8fun a => by rw [nhds_eq_comap_uniformity]; infer_instance\u27e9", "start": [790, 1], "end": [791, 62], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.secondCountable_of_separable", "code": "theorem secondCountable_of_separable [SeparableSpace \u03b1] : SecondCountableTopology \u03b1", "start": [794, 1], "end": [820, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Basic.lean", "imports": ["Mathlib/Algebra/Bounds.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Real/CauSeqCompletion.lean", "Mathlib/Algebra/Order/Archimedean.lean"], "premises": [{"full_name": "Real", "code": "structure Real where ofCauchy ::\n  \n  cauchy : CauSeq.Completion.Cauchy (abs : \u211a \u2192 \u211a)", "start": [28, 1], "end": [32, 50], "kind": "commanddeclaration"}, {"full_name": "CauSeq.Completion.ofRat_rat", "code": "@[simp]\ntheorem ofRat_rat {abv : \u211a \u2192 \u211a} [IsAbsoluteValue abv] (q : \u211a) :\n    ofRat (q : \u211a) = (q : Cauchy abv)", "start": [44, 1], "end": [47, 6], "kind": "commanddeclaration"}, {"full_name": "Real.ext_cauchy_iff", "code": "theorem ext_cauchy_iff : \u2200 {x y : Real}, x = y \u2194 x.cauchy = y.cauchy", "start": [58, 1], "end": [59, 39], "kind": "commanddeclaration"}, {"full_name": "Real.ext_cauchy", "code": "theorem ext_cauchy {x y : Real} : x.cauchy = y.cauchy \u2192 x = y", "start": [62, 1], "end": [63, 19], "kind": "commanddeclaration"}, {"full_name": "Real.equivCauchy", "code": "def equivCauchy : \u211d \u2243 CauSeq.Completion.Cauchy (abs : \u211a \u2192 \u211a) :=\n  \u27e8Real.cauchy, Real.ofCauchy, fun \u27e8_\u27e9 => rfl, fun _ => rfl\u27e9", "start": [66, 1], "end": [68, 61], "kind": "commanddeclaration"}, {"full_name": "Real.zero", "code": "private irreducible_def zero : \u211d :=\n  \u27e80\u27e9", "start": [73, 1], "end": [74, 6], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.one", "code": "private irreducible_def one : \u211d :=\n  \u27e81\u27e9", "start": [76, 1], "end": [77, 6], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.add", "code": "private irreducible_def add : \u211d \u2192 \u211d \u2192 \u211d\n  | \u27e8a\u27e9, \u27e8b\u27e9 => \u27e8a + b\u27e9", "start": [79, 1], "end": [80, 24], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.neg", "code": "private irreducible_def neg : \u211d \u2192 \u211d\n  | \u27e8a\u27e9 => \u27e8-a\u27e9", "start": [82, 1], "end": [83, 16], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.mul", "code": "private irreducible_def mul : \u211d \u2192 \u211d \u2192 \u211d\n  | \u27e8a\u27e9, \u27e8b\u27e9 => \u27e8a * b\u27e9", "start": [85, 1], "end": [86, 24], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.inv'", "code": "private noncomputable irreducible_def inv' : \u211d \u2192 \u211d\n  | \u27e8a\u27e9 => \u27e8a\u207b\u00b9\u27e9", "start": [88, 1], "end": [89, 17], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.ofCauchy_zero", "code": "theorem ofCauchy_zero : (\u27e80\u27e9 : \u211d) = 0", "start": [112, 1], "end": [113, 16], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_one", "code": "theorem ofCauchy_one : (\u27e81\u27e9 : \u211d) = 1", "start": [116, 1], "end": [117, 15], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_add", "code": "theorem ofCauchy_add (a b) : (\u27e8a + b\u27e9 : \u211d) = \u27e8a\u27e9 + \u27e8b\u27e9", "start": [120, 1], "end": [121, 21], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_neg", "code": "theorem ofCauchy_neg (a) : (\u27e8-a\u27e9 : \u211d) = -\u27e8a\u27e9", "start": [124, 1], "end": [125, 19], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_sub", "code": "theorem ofCauchy_sub (a b) : (\u27e8a - b\u27e9 : \u211d) = \u27e8a\u27e9 - \u27e8b\u27e9", "start": [128, 1], "end": [130, 6], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_mul", "code": "theorem ofCauchy_mul (a b) : (\u27e8a * b\u27e9 : \u211d) = \u27e8a\u27e9 * \u27e8b\u27e9", "start": [133, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_inv", "code": "theorem ofCauchy_inv {f} : (\u27e8f\u207b\u00b9\u27e9 : \u211d) = \u27e8f\u27e9\u207b\u00b9", "start": [137, 1], "end": [138, 31], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_zero", "code": "theorem cauchy_zero : (0 : \u211d).cauchy = 0", "start": [141, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_one", "code": "theorem cauchy_one : (1 : \u211d).cauchy = 1", "start": [145, 1], "end": [146, 38], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_add", "code": "theorem cauchy_add : \u2200 a b, (a + b : \u211d).cauchy = a.cauchy + b.cauchy", "start": [149, 1], "end": [150, 58], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_neg", "code": "theorem cauchy_neg : \u2200 a, (-a : \u211d).cauchy = -a.cauchy", "start": [153, 1], "end": [154, 51], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_mul", "code": "theorem cauchy_mul : \u2200 a b, (a * b : \u211d).cauchy = a.cauchy * b.cauchy", "start": [157, 1], "end": [158, 58], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_sub", "code": "theorem cauchy_sub : \u2200 a b, (a - b : \u211d).cauchy = a.cauchy - b.cauchy", "start": [161, 1], "end": [164, 8], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_inv", "code": "theorem cauchy_inv : \u2200 f, (f\u207b\u00b9 : \u211d).cauchy = f.cauchy\u207b\u00b9", "start": [167, 1], "end": [168, 49], "kind": "commanddeclaration"}, {"full_name": "Real.natCast", "code": "instance natCast : NatCast \u211d where natCast n := \u27e8n\u27e9", "start": [171, 1], "end": [171, 52], "kind": "commanddeclaration"}, {"full_name": "Real.intCast", "code": "instance intCast : IntCast \u211d where intCast z := \u27e8z\u27e9", "start": [173, 1], "end": [173, 52], "kind": "commanddeclaration"}, {"full_name": "Real.ratCast", "code": "instance ratCast : RatCast \u211d where ratCast q := \u27e8q\u27e9", "start": [175, 1], "end": [175, 52], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_natCast", "code": "theorem ofCauchy_natCast (n : \u2115) : (\u27e8n\u27e9 : \u211d) = n", "start": [177, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_intCast", "code": "theorem ofCauchy_intCast (z : \u2124) : (\u27e8z\u27e9 : \u211d) = z", "start": [181, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "Real.ofCauchy_ratCast", "code": "theorem ofCauchy_ratCast (q : \u211a) : (\u27e8q\u27e9 : \u211d) = q", "start": [185, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_natCast", "code": "theorem cauchy_natCast (n : \u2115) : (n : \u211d).cauchy = n", "start": [189, 1], "end": [190, 6], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_intCast", "code": "theorem cauchy_intCast (z : \u2124) : (z : \u211d).cauchy = z", "start": [193, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "Real.cauchy_ratCast", "code": "theorem cauchy_ratCast (q : \u211a) : (q : \u211d).cauchy = q", "start": [197, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Real.commRing", "code": "instance commRing : CommRing \u211d := by\n  refine' { natCast := fun n => \u27e8n\u27e9\n            intCast := fun z => \u27e8z\u27e9\n            zero := (0 : \u211d)\n            one := (1 : \u211d)\n            mul := (\u00b7 * \u00b7)\n            add := (\u00b7 + \u00b7)\n            neg := @Neg.neg \u211d _\n            sub := @Sub.sub \u211d _\n            npow := @npowRec \u211d \u27e81\u27e9 \u27e8(\u00b7 * \u00b7)\u27e9\n            nsmul := @nsmulRec \u211d \u27e80\u27e9 \u27e8(\u00b7 + \u00b7)\u27e9\n            zsmul := @zsmulRec \u211d \u27e80\u27e9 \u27e8(\u00b7 + \u00b7)\u27e9 \u27e8@Neg.neg \u211d _\u27e9,\n            .. }\n  all_goals\n    intros\n    first\n    | rfl\n    | apply ext_cauchy\n      simp [cauchy_add, cauchy_zero, cauchy_one, cauchy_neg, cauchy_mul,\n        cauchy_natCast, cauchy_intCast]\n      first\n        | done\n        | apply add_assoc\n        | apply add_comm\n        | apply left_distrib\n        | apply right_distrib\n        | apply mul_assoc\n        | apply mul_comm", "start": [203, 1], "end": [230, 25], "kind": "commanddeclaration"}, {"full_name": "Real.ringEquivCauchy", "code": "@[simps]\ndef ringEquivCauchy : \u211d \u2243+* CauSeq.Completion.Cauchy (abs : \u211a \u2192 \u211a) :=\n  { equivCauchy with\n    toFun := cauchy\n    invFun := ofCauchy\n    map_add' := cauchy_add\n    map_mul' := cauchy_mul }", "start": [232, 1], "end": [239, 29], "kind": "commanddeclaration"}, {"full_name": "Real.semiring", "code": "instance semiring : Semiring \u211d := by infer_instance", "start": [257, 1], "end": [257, 52], "kind": "commanddeclaration"}, {"full_name": "Real.mk", "code": "def mk (x : CauSeq \u211a abs) : \u211d :=\n  \u27e8CauSeq.Completion.mk x\u27e9", "start": [297, 1], "end": [299, 27], "kind": "commanddeclaration"}, {"full_name": "Real.mk_eq", "code": "theorem mk_eq {f g : CauSeq \u211a abs} : mk f = mk g \u2194 f \u2248 g", "start": [302, 1], "end": [303, 47], "kind": "commanddeclaration"}, {"full_name": "Real.lt", "code": "private irreducible_def lt : \u211d \u2192 \u211d \u2192 Prop\n  | \u27e8x\u27e9, \u27e8y\u27e9 =>\n    (Quotient.liftOn\u2082 x y (\u00b7 < \u00b7)) fun _ _ _ _ hf hg =>\n      propext <|\n        \u27e8fun h => lt_of_eq_of_lt (Setoid.symm hf) (lt_of_lt_of_eq h hg), fun h =>\n          lt_of_eq_of_lt hf (lt_of_lt_of_eq h (Setoid.symm hg))\u27e9", "start": [306, 1], "end": [311, 65], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.lt_cauchy", "code": "theorem lt_cauchy {f g} : (\u27e8\u27e6f\u27e7\u27e9 : \u211d) < \u27e8\u27e6g\u27e7\u27e9 \u2194 f < g", "start": [316, 1], "end": [317, 38], "kind": "commanddeclaration"}, {"full_name": "Real.mk_lt", "code": "@[simp]\ntheorem mk_lt {f g : CauSeq \u211a abs} : mk f < mk g \u2194 f < g", "start": [320, 1], "end": [322, 12], "kind": "commanddeclaration"}, {"full_name": "Real.mk_zero", "code": "theorem mk_zero : mk 0 = 0", "start": [325, 1], "end": [325, 59], "kind": "commanddeclaration"}, {"full_name": "Real.mk_one", "code": "theorem mk_one : mk 1 = 1", "start": [328, 1], "end": [328, 57], "kind": "commanddeclaration"}, {"full_name": "Real.mk_add", "code": "theorem mk_add {f g : CauSeq \u211a abs} : mk (f + g) = mk f + mk g", "start": [331, 1], "end": [331, 95], "kind": "commanddeclaration"}, {"full_name": "Real.mk_mul", "code": "theorem mk_mul {f g : CauSeq \u211a abs} : mk (f * g) = mk f * mk g", "start": [334, 1], "end": [334, 95], "kind": "commanddeclaration"}, {"full_name": "Real.mk_neg", "code": "theorem mk_neg {f : CauSeq \u211a abs} : mk (-f) = -mk f", "start": [337, 1], "end": [337, 84], "kind": "commanddeclaration"}, {"full_name": "Real.mk_pos", "code": "@[simp]\ntheorem mk_pos {f : CauSeq \u211a abs} : 0 < mk f \u2194 Pos f", "start": [340, 1], "end": [343, 47], "kind": "commanddeclaration"}, {"full_name": "Real.le", "code": "private irreducible_def le (x y : \u211d) : Prop :=\n  x < y \u2228 x = y", "start": [346, 1], "end": [347, 16], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.le_def'", "code": "private theorem le_def' {x y : \u211d} : x \u2264 y \u2194 x < y \u2228 x = y", "start": [352, 1], "end": [353, 33], "kind": "commanddeclaration"}, {"full_name": "Real.mk_le", "code": "@[simp]\ntheorem mk_le {f g : CauSeq \u211a abs} : mk f \u2264 mk g \u2194 f \u2264 g", "start": [355, 1], "end": [356, 90], "kind": "commanddeclaration"}, {"full_name": "Real.ind_mk", "code": "@[elab_as_elim]\nprotected theorem ind_mk {C : Real \u2192 Prop} (x : Real) (h : \u2200 y, C (mk y)) : C x", "start": [359, 1], "end": [363, 12], "kind": "commanddeclaration"}, {"full_name": "Real.add_lt_add_iff_left", "code": "theorem add_lt_add_iff_left {a b : \u211d} (c : \u211d) : c + a < c + b \u2194 a < b", "start": [366, 1], "end": [371, 51], "kind": "commanddeclaration"}, {"full_name": "Real.partialOrder", "code": "instance partialOrder : PartialOrder \u211d where\n  le := (\u00b7 \u2264 \u00b7)\n  lt := (\u00b7 < \u00b7)\n  lt_iff_le_not_le a b := by\n    induction' a using Real.ind_mk with a\n    induction' b using Real.ind_mk with b\n    simpa using lt_iff_le_not_le\n  le_refl a := by\n    induction' a using Real.ind_mk with a\n    rw [mk_le]\n  le_trans a b c := by\n    induction' a using Real.ind_mk with a\n    induction' b using Real.ind_mk with b\n    induction' c using Real.ind_mk with c\n    simpa using le_trans\n  le_antisymm a b := by\n    induction' a using Real.ind_mk with a\n    induction' b using Real.ind_mk with b\n    simpa [mk_eq] using @CauSeq.le_antisymm _ _ a b", "start": [374, 1], "end": [392, 52], "kind": "commanddeclaration"}, {"full_name": "Real.ratCast_lt", "code": "theorem ratCast_lt {x y : \u211a} : (x : \u211d) < (y : \u211d) \u2194 x < y", "start": [396, 1], "end": [398, 17], "kind": "commanddeclaration"}, {"full_name": "Real.zero_lt_one", "code": "protected theorem zero_lt_one : (0 : \u211d) < 1", "start": [401, 1], "end": [402, 94], "kind": "commanddeclaration"}, {"full_name": "Real.fact_zero_lt_one", "code": "protected theorem fact_zero_lt_one : Fact ((0 : \u211d) < 1)", "start": [405, 1], "end": [406, 21], "kind": "commanddeclaration"}, {"full_name": "Real.mul_pos", "code": "protected theorem mul_pos {a b : \u211d} : 0 < a \u2192 0 < b \u2192 0 < a * b", "start": [409, 1], "end": [412, 60], "kind": "commanddeclaration"}, {"full_name": "Real.strictOrderedRing", "code": "instance strictOrderedRing : StrictOrderedRing \u211d :=\n  inferInstance", "start": [427, 1], "end": [428, 16], "kind": "commanddeclaration"}, {"full_name": "Real.strictOrderedCommSemiring", "code": "instance strictOrderedCommSemiring : StrictOrderedCommSemiring \u211d :=\n  inferInstance", "start": [430, 1], "end": [431, 16], "kind": "commanddeclaration"}, {"full_name": "Real.strictOrderedSemiring", "code": "instance strictOrderedSemiring : StrictOrderedSemiring \u211d :=\n  inferInstance", "start": [433, 1], "end": [434, 16], "kind": "commanddeclaration"}, {"full_name": "Real.orderedRing", "code": "instance orderedRing : OrderedRing \u211d :=\n  inferInstance", "start": [436, 1], "end": [437, 16], "kind": "commanddeclaration"}, {"full_name": "Real.orderedSemiring", "code": "instance orderedSemiring : OrderedSemiring \u211d :=\n  inferInstance", "start": [439, 1], "end": [440, 16], "kind": "commanddeclaration"}, {"full_name": "Real.orderedAddCommGroup", "code": "instance orderedAddCommGroup : OrderedAddCommGroup \u211d :=\n  inferInstance", "start": [442, 1], "end": [443, 16], "kind": "commanddeclaration"}, {"full_name": "Real.orderedCancelAddCommMonoid", "code": "instance orderedCancelAddCommMonoid : OrderedCancelAddCommMonoid \u211d :=\n  inferInstance", "start": [445, 1], "end": [446, 16], "kind": "commanddeclaration"}, {"full_name": "Real.orderedAddCommMonoid", "code": "instance orderedAddCommMonoid : OrderedAddCommMonoid \u211d :=\n  inferInstance", "start": [448, 1], "end": [449, 16], "kind": "commanddeclaration"}, {"full_name": "Real.nontrivial", "code": "instance nontrivial : Nontrivial \u211d :=\n  inferInstance", "start": [451, 1], "end": [452, 16], "kind": "commanddeclaration"}, {"full_name": "Real.sup", "code": "private irreducible_def sup : \u211d \u2192 \u211d \u2192 \u211d\n  | \u27e8x\u27e9, \u27e8y\u27e9 => \u27e8Quotient.map\u2082 (\u00b7 \u2294 \u00b7) (fun _ _ hx _ _ hy => sup_equiv_sup hx hy) x y\u27e9", "start": [454, 1], "end": [455, 87], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.ofCauchy_sup", "code": "theorem ofCauchy_sup (a b) : (\u27e8\u27e6a \u2294 b\u27e7\u27e9 : \u211d) = \u27e8\u27e6a\u27e7\u27e9 \u2294 \u27e8\u27e6b\u27e7\u27e9", "start": [460, 1], "end": [463, 8], "kind": "commanddeclaration"}, {"full_name": "Real.mk_sup", "code": "@[simp]\ntheorem mk_sup (a b) : (mk (a \u2294 b) : \u211d) = mk a \u2294 mk b", "start": [466, 1], "end": [468, 19], "kind": "commanddeclaration"}, {"full_name": "Real.inf", "code": "private irreducible_def inf : \u211d \u2192 \u211d \u2192 \u211d\n  | \u27e8x\u27e9, \u27e8y\u27e9 => \u27e8Quotient.map\u2082 (\u00b7 \u2293 \u00b7) (fun _ _ hx _ _ hy => inf_equiv_inf hx hy) x y\u27e9", "start": [471, 1], "end": [472, 87], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Real.ofCauchy_inf", "code": "theorem ofCauchy_inf (a b) : (\u27e8\u27e6a \u2293 b\u27e7\u27e9 : \u211d) = \u27e8\u27e6a\u27e7\u27e9 \u2293 \u27e8\u27e6b\u27e7\u27e9", "start": [477, 1], "end": [480, 8], "kind": "commanddeclaration"}, {"full_name": "Real.mk_inf", "code": "@[simp]\ntheorem mk_inf (a b) : (mk (a \u2293 b) : \u211d) = mk a \u2293 mk b", "start": [483, 1], "end": [485, 19], "kind": "commanddeclaration"}, {"full_name": "Real.lattice", "code": "instance lattice : Lattice \u211d :=\n  inferInstance", "start": [541, 1], "end": [542, 16], "kind": "commanddeclaration"}, {"full_name": "Real.linearOrder", "code": "noncomputable instance linearOrder : LinearOrder \u211d :=\n  Lattice.toLinearOrder _", "start": [559, 1], "end": [560, 26], "kind": "commanddeclaration"}, {"full_name": "Real.linearOrderedCommRing", "code": "noncomputable instance linearOrderedCommRing : LinearOrderedCommRing \u211d :=\n  { Real.nontrivial, Real.strictOrderedRing, Real.commRing, Real.linearOrder with }", "start": [562, 1], "end": [563, 84], "kind": "commanddeclaration"}, {"full_name": "Real.field", "code": "noncomputable instance field : Field \u211d := by infer_instance", "start": [591, 1], "end": [591, 60], "kind": "commanddeclaration"}, {"full_name": "Real.decidableLT", "code": "noncomputable instance decidableLT (a b : \u211d) : Decidable (a < b) := by infer_instance", "start": [596, 1], "end": [596, 86], "kind": "commanddeclaration"}, {"full_name": "Real.decidableLE", "code": "noncomputable instance decidableLE (a b : \u211d) : Decidable (a \u2264 b) := by infer_instance", "start": [599, 1], "end": [599, 86], "kind": "commanddeclaration"}, {"full_name": "Real.decidableEq", "code": "noncomputable instance decidableEq (a b : \u211d) : Decidable (a = b) := by infer_instance", "start": [602, 1], "end": [602, 86], "kind": "commanddeclaration"}, {"full_name": "Real.le_mk_of_forall_le", "code": "theorem le_mk_of_forall_le {f : CauSeq \u211a abs} : (\u2203 i, \u2200 j \u2265 i, x \u2264 f j) \u2192 x \u2264 mk f", "start": [612, 1], "end": [623, 82], "kind": "commanddeclaration"}, {"full_name": "Real.mk_le_of_forall_le", "code": "theorem mk_le_of_forall_le {f : CauSeq \u211a abs} {x : \u211d} (h : \u2203 i, \u2200 j \u2265 i, (f j : \u211d) \u2264 x) :\n    mk f \u2264 x", "start": [626, 1], "end": [630, 61], "kind": "commanddeclaration"}, {"full_name": "Real.mk_near_of_forall_near", "code": "theorem mk_near_of_forall_near {f : CauSeq \u211a abs} {x : \u211d} {\u03b5 : \u211d}\n    (H : \u2203 i, \u2200 j \u2265 i, |(f j : \u211d) - x| \u2264 \u03b5) : |mk f - x| \u2264 \u03b5", "start": [633, 1], "end": [640, 98], "kind": "commanddeclaration"}, {"full_name": "Real.instArchimedean", "code": "instance instArchimedean : Archimedean \u211d :=\n  archimedean_iff_rat_le.2 fun x =>\n    Real.ind_mk x fun f =>\n      let \u27e8M, _, H\u27e9 := f.bounded' 0\n      \u27e8M, mk_le_of_forall_le \u27e80, fun i _ => Rat.cast_le.2 <| le_of_lt (abs_lt.1 (H i)).2\u27e9\u27e9", "start": [643, 1], "end": [647, 91], "kind": "commanddeclaration"}, {"full_name": "Real.isCauSeq_iff_lift", "code": "theorem isCauSeq_iff_lift {f : \u2115 \u2192 \u211a} : IsCauSeq abs f \u2194 IsCauSeq abs fun i => (f i : \u211d)", "start": [653, 1], "end": [659, 58], "kind": "commanddeclaration"}, {"full_name": "Real.of_near", "code": "theorem of_near (f : \u2115 \u2192 \u211a) (x : \u211d) (h : \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, |(f j : \u211d) - x| < \u03b5) :\n    \u2203 h', Real.mk \u27e8f, h'\u27e9 = x", "start": [662, 1], "end": [668, 85], "kind": "commanddeclaration"}, {"full_name": "Real.exists_floor", "code": "theorem exists_floor (x : \u211d) : \u2203 ub : \u2124, (ub : \u211d) \u2264 x \u2227 \u2200 z : \u2124, (z : \u211d) \u2264 x \u2192 z \u2264 ub", "start": [671, 1], "end": [676, 22], "kind": "commanddeclaration"}, {"full_name": "Real.exists_isLUB", "code": "theorem exists_isLUB (S : Set \u211d) (hne : S.Nonempty) (hbdd : BddAbove S) : \u2203 x, IsLUB S x", "start": [679, 1], "end": [727, 30], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_def", "code": "theorem sSup_def (S : Set \u211d) :\n    sSup S = if h : S.Nonempty \u2227 BddAbove S then Classical.choose (exists_isLUB S h.1 h.2) else 0", "start": [733, 1], "end": [735, 6], "kind": "commanddeclaration"}, {"full_name": "Real.isLUB_sSup", "code": "protected theorem isLUB_sSup (S : Set \u211d) (h\u2081 : S.Nonempty) (h\u2082 : BddAbove S) :\n    IsLUB S (sSup S)", "start": [738, 1], "end": [741, 30], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_def", "code": "theorem sInf_def (S : Set \u211d) : sInf S = -sSup (-S)", "start": [747, 1], "end": [748, 6], "kind": "commanddeclaration"}, {"full_name": "Real.is_glb_sInf", "code": "protected theorem is_glb_sInf (S : Set \u211d) (h\u2081 : S.Nonempty) (h\u2082 : BddBelow S) :\n    IsGLB S (sInf S)", "start": [751, 1], "end": [754, 40], "kind": "commanddeclaration"}, {"full_name": "Real.lt_sInf_add_pos", "code": "theorem lt_sInf_add_pos {s : Set \u211d} (h : s.Nonempty) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 a \u2208 s, a < sInf s + \u03b5", "start": [768, 1], "end": [770, 54], "kind": "commanddeclaration"}, {"full_name": "Real.add_neg_lt_sSup", "code": "theorem add_neg_lt_sSup {s : Set \u211d} (h : s.Nonempty) {\u03b5 : \u211d} (h\u03b5 : \u03b5 < 0) :\n    \u2203 a \u2208 s, sSup s + \u03b5 < a", "start": [773, 1], "end": [775, 54], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_le_iff", "code": "theorem sInf_le_iff {s : Set \u211d} (h : BddBelow s) (h' : s.Nonempty) {a : \u211d} :\n    sInf s \u2264 a \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 x \u2208 s, x < a + \u03b5", "start": [778, 1], "end": [784, 35], "kind": "commanddeclaration"}, {"full_name": "Real.le_sSup_iff", "code": "theorem le_sSup_iff {s : Set \u211d} (h : BddAbove s) (h' : s.Nonempty) {a : \u211d} :\n    a \u2264 sSup s \u2194 \u2200 \u03b5, \u03b5 < 0 \u2192 \u2203 x \u2208 s, a + \u03b5 < x", "start": [787, 1], "end": [793, 58], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_empty", "code": "@[simp]\ntheorem sSup_empty : sSup (\u2205 : Set \u211d) = 0", "start": [796, 1], "end": [798, 21], "kind": "commanddeclaration"}, {"full_name": "Real.ciSup_empty", "code": "theorem ciSup_empty {\u03b1 : Sort*} [IsEmpty \u03b1] (f : \u03b1 \u2192 \u211d) : \u2a06 i, f i = 0", "start": [801, 1], "end": [805, 17], "kind": "commanddeclaration"}, {"full_name": "Real.ciSup_const_zero", "code": "@[simp]\ntheorem ciSup_const_zero {\u03b1 : Sort*} : \u2a06 _ : \u03b1, (0 : \u211d) = 0", "start": [808, 1], "end": [812, 22], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_of_not_bddAbove", "code": "theorem sSup_of_not_bddAbove {s : Set \u211d} (hs : \u00acBddAbove s) : sSup s = 0", "start": [815, 1], "end": [816, 26], "kind": "commanddeclaration"}, {"full_name": "Real.iSup_of_not_bddAbove", "code": "theorem iSup_of_not_bddAbove {\u03b1 : Sort*} {f : \u03b1 \u2192 \u211d} (hf : \u00acBddAbove (Set.range f)) :\n    \u2a06 i, f i = 0", "start": [819, 1], "end": [821, 26], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_univ", "code": "theorem sSup_univ : sSup (@Set.univ \u211d) = 0", "start": [824, 1], "end": [825, 92], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf (\u2205 : Set \u211d) = 0", "start": [828, 1], "end": [829, 76], "kind": "commanddeclaration"}, {"full_name": "Real.ciInf_empty", "code": "theorem ciInf_empty {\u03b1 : Sort*} [IsEmpty \u03b1] (f : \u03b1 \u2192 \u211d) : \u2a05 i, f i = 0", "start": [832, 1], "end": [833, 34], "kind": "commanddeclaration"}, {"full_name": "Real.ciInf_const_zero", "code": "@[simp]\ntheorem ciInf_const_zero {\u03b1 : Sort*} : \u2a05 _ : \u03b1, (0 : \u211d) = 0", "start": [836, 1], "end": [840, 22], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_of_not_bddBelow", "code": "theorem sInf_of_not_bddBelow {s : Set \u211d} (hs : \u00acBddBelow s) : sInf s = 0", "start": [843, 1], "end": [844, 64], "kind": "commanddeclaration"}, {"full_name": "Real.iInf_of_not_bddBelow", "code": "theorem iInf_of_not_bddBelow {\u03b1 : Sort*} {f : \u03b1 \u2192 \u211d} (hf : \u00acBddBelow (Set.range f)) :\n    \u2a05 i, f i = 0", "start": [847, 1], "end": [849, 26], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_nonneg", "code": "theorem sSup_nonneg (S : Set \u211d) (hS : \u2200 x \u2208 S, (0 : \u211d) \u2264 x) : 0 \u2264 sSup S", "start": [852, 1], "end": [859, 96], "kind": "commanddeclaration"}, {"full_name": "Real.iSup_nonneg", "code": "protected theorem iSup_nonneg {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} (hf : \u2200 i, 0 \u2264 f i) : 0 \u2264 \u2a06 i, f i", "start": [862, 1], "end": [867, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_le", "code": "protected theorem sSup_le {S : Set \u211d} {a : \u211d} (hS : \u2200 x \u2208 S, x \u2264 a) (ha : 0 \u2264 a) : sSup S \u2264 a", "start": [870, 1], "end": [877, 51], "kind": "commanddeclaration"}, {"full_name": "Real.iSup_le", "code": "protected theorem iSup_le {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d} {a : \u211d} (hS : \u2200 i, f i \u2264 a) (ha : 0 \u2264 a) :\n    \u2a06 i, f i \u2264 a", "start": [880, 1], "end": [882, 46], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_nonpos", "code": "theorem sSup_nonpos (S : Set \u211d) (hS : \u2200 x \u2208 S, x \u2264 (0 : \u211d)) : sSup S \u2264 0", "start": [885, 1], "end": [889, 25], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_nonneg", "code": "theorem sInf_nonneg (S : Set \u211d) (hS : \u2200 x \u2208 S, (0 : \u211d) \u2264 x) : 0 \u2264 sInf S", "start": [892, 1], "end": [897, 42], "kind": "commanddeclaration"}, {"full_name": "Real.iInf_nonneg", "code": "theorem iInf_nonneg {\u03b9} {f : \u03b9 \u2192 \u211d} (hf : \u2200 i, 0 \u2264 f i) : 0 \u2264 iInf f", "start": [900, 1], "end": [904, 45], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_nonpos", "code": "theorem sInf_nonpos (S : Set \u211d) (hS : \u2200 x \u2208 S, x \u2264 (0 : \u211d)) : sInf S \u2264 0", "start": [906, 1], "end": [913, 96], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_le_sSup", "code": "theorem sInf_le_sSup (s : Set \u211d) (h\u2081 : BddBelow s) (h\u2082 : BddAbove s) : sInf s \u2264 sSup s", "start": [916, 1], "end": [919, 35], "kind": "commanddeclaration"}, {"full_name": "Real.cauSeq_converges", "code": "theorem cauSeq_converges (f : CauSeq \u211d abs) : \u2203 x, f \u2248 const abs x", "start": [922, 1], "end": [938, 18], "kind": "commanddeclaration"}, {"full_name": "Real.iInf_Ioi_eq_iInf_rat_gt", "code": "theorem iInf_Ioi_eq_iInf_rat_gt {f : \u211d \u2192 \u211d} (x : \u211d) (hf : BddBelow (f '' Ioi x))\n    (hf_mono : Monotone f) : \u2a05 r : Ioi x, f r = \u2a05 q : { q' : \u211a // x < q' }, f q", "start": [946, 1], "end": [967, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Module.lean", "imports": ["Mathlib/Algebra/Order/SMul.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "instModuleOrderDual", "code": "instance instModuleOrderDual [Semiring k] [OrderedAddCommMonoid M] [Module k M] : Module k M\u1d52\u1d48\n    where\n  add_smul _ _ x := OrderDual.rec (add_smul _ _) x\n  zero_smul m := OrderDual.rec (zero_smul _) m", "start": [29, 1], "end": [32, 47], "kind": "commanddeclaration"}, {"full_name": "smul_neg_iff_of_pos", "code": "theorem smul_neg_iff_of_pos (hc : 0 < c) : c \u2022 a < 0 \u2194 a < 0", "start": [42, 1], "end": [44, 31], "kind": "commanddeclaration"}, {"full_name": "smul_lt_smul_of_neg", "code": "theorem smul_lt_smul_of_neg (h : a < b) (hc : c < 0) : c \u2022 b < c \u2022 a", "start": [53, 1], "end": [55, 50], "kind": "commanddeclaration"}, {"full_name": "smul_le_smul_of_nonpos", "code": "theorem smul_le_smul_of_nonpos (h : a \u2264 b) (hc : c \u2264 0) : c \u2022 b \u2264 c \u2022 a", "start": [58, 1], "end": [60, 59], "kind": "commanddeclaration"}, {"full_name": "eq_of_smul_eq_smul_of_neg_of_le", "code": "theorem eq_of_smul_eq_smul_of_neg_of_le (hab : c \u2022 a = c \u2022 b) (hc : c < 0) (h : a \u2264 b) : a = b", "start": [63, 1], "end": [65, 66], "kind": "commanddeclaration"}, {"full_name": "lt_of_smul_lt_smul_of_nonpos", "code": "theorem lt_of_smul_lt_smul_of_nonpos (h : c \u2022 a < c \u2022 b) (hc : c \u2264 0) : b < a", "start": [68, 1], "end": [70, 65], "kind": "commanddeclaration"}, {"full_name": "smul_lt_smul_iff_of_neg", "code": "theorem smul_lt_smul_iff_of_neg (hc : c < 0) : c \u2022 a < c \u2022 b \u2194 b < a", "start": [73, 1], "end": [75, 52], "kind": "commanddeclaration"}, {"full_name": "smul_neg_iff_of_neg", "code": "theorem smul_neg_iff_of_neg (hc : c < 0) : c \u2022 a < 0 \u2194 0 < a", "start": [78, 1], "end": [80, 48], "kind": "commanddeclaration"}, {"full_name": "smul_pos_iff_of_neg", "code": "theorem smul_pos_iff_of_neg (hc : c < 0) : 0 < c \u2022 a \u2194 a < 0", "start": [83, 1], "end": [85, 48], "kind": "commanddeclaration"}, {"full_name": "smul_nonpos_of_nonpos_of_nonneg", "code": "theorem smul_nonpos_of_nonpos_of_nonneg (hc : c \u2264 0) (ha : 0 \u2264 a) : c \u2022 a \u2264 0", "start": [88, 1], "end": [91, 25], "kind": "commanddeclaration"}, {"full_name": "smul_nonneg_of_nonpos_of_nonpos", "code": "theorem smul_nonneg_of_nonpos_of_nonpos (hc : c \u2264 0) (ha : a \u2264 0) : 0 \u2264 c \u2022 a", "start": [94, 1], "end": [95, 59], "kind": "commanddeclaration"}, {"full_name": "smul_pos_of_neg_of_neg", "code": "alias \u27e8_, smul_pos_of_neg_of_neg\u27e9 := smul_pos_iff_of_neg", "start": [98, 1], "end": [98, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "smul_neg_of_pos_of_neg", "code": "alias \u27e8_, smul_neg_of_pos_of_neg\u27e9 := smul_neg_iff_of_pos", "start": [101, 1], "end": [101, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "smul_neg_of_neg_of_pos", "code": "alias \u27e8_, smul_neg_of_neg_of_pos\u27e9 := smul_neg_iff_of_neg", "start": [104, 1], "end": [104, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "antitone_smul_left", "code": "theorem antitone_smul_left (hc : c \u2264 0) : Antitone (SMul.smul c : M \u2192 M)", "start": [107, 1], "end": [108, 30], "kind": "commanddeclaration"}, {"full_name": "strict_anti_smul_left", "code": "theorem strict_anti_smul_left (hc : c < 0) : StrictAnti (SMul.smul c : M \u2192 M)", "start": [111, 1], "end": [112, 27], "kind": "commanddeclaration"}, {"full_name": "smul_add_smul_le_smul_add_smul", "code": "theorem smul_add_smul_le_smul_add_smul [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {a b : k} {c d : M}\n    (hab : a \u2264 b) (hcd : c \u2264 d) : a \u2022 d + b \u2022 c \u2264 a \u2022 c + b \u2022 d", "start": [115, 1], "end": [122, 74], "kind": "commanddeclaration"}, {"full_name": "smul_add_smul_le_smul_add_smul'", "code": "theorem smul_add_smul_le_smul_add_smul' [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {a b : k} {c d : M}\n    (hba : b \u2264 a) (hdc : d \u2264 c) : a \u2022 d + b \u2022 c \u2264 a \u2022 c + b \u2022 d", "start": [125, 1], "end": [129, 47], "kind": "commanddeclaration"}, {"full_name": "smul_add_smul_lt_smul_add_smul", "code": "theorem smul_add_smul_lt_smul_add_smul [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] {a b : k} {c d : M} (hab : a < b) (hcd : c < d) :\n    a \u2022 d + b \u2022 c < a \u2022 c + b \u2022 d", "start": [132, 1], "end": [140, 70], "kind": "commanddeclaration"}, {"full_name": "smul_add_smul_lt_smul_add_smul'", "code": "theorem smul_add_smul_lt_smul_add_smul' [CovariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n    [ContravariantClass M M (\u00b7 + \u00b7) (\u00b7 < \u00b7)] {a b : k} {c d : M} (hba : b < a) (hdc : d < c) :\n    a \u2022 d + b \u2022 c < a \u2022 c + b \u2022 d", "start": [143, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "smul_le_smul_iff_of_neg", "code": "theorem smul_le_smul_iff_of_neg (hc : c < 0) : c \u2022 a \u2264 c \u2022 b \u2194 b \u2264 a", "start": [158, 1], "end": [160, 52], "kind": "commanddeclaration"}, {"full_name": "inv_smul_le_iff_of_neg", "code": "theorem inv_smul_le_iff_of_neg (h : c < 0) : c\u207b\u00b9 \u2022 a \u2264 b \u2194 c \u2022 b \u2264 a", "start": [163, 1], "end": [164, 56], "kind": "commanddeclaration"}, {"full_name": "inv_smul_lt_iff_of_neg", "code": "theorem inv_smul_lt_iff_of_neg (h : c < 0) : c\u207b\u00b9 \u2022 a < b \u2194 c \u2022 b < a", "start": [167, 1], "end": [168, 56], "kind": "commanddeclaration"}, {"full_name": "smul_inv_le_iff_of_neg", "code": "theorem smul_inv_le_iff_of_neg (h : c < 0) : a \u2264 c\u207b\u00b9 \u2022 b \u2194 b \u2264 c \u2022 a", "start": [171, 1], "end": [172, 56], "kind": "commanddeclaration"}, {"full_name": "smul_inv_lt_iff_of_neg", "code": "theorem smul_inv_lt_iff_of_neg (h : c < 0) : a < c\u207b\u00b9 \u2022 b \u2194 b < c \u2022 a", "start": [175, 1], "end": [176, 56], "kind": "commanddeclaration"}, {"full_name": "OrderIso.smulLeftDual", "code": "@[simps]\ndef OrderIso.smulLeftDual {c : k} (hc : c < 0) : M \u2243o M\u1d52\u1d48 where\n  toFun b := OrderDual.toDual (c \u2022 b)\n  invFun b := c\u207b\u00b9 \u2022 OrderDual.ofDual b\n  left_inv := inv_smul_smul\u2080 hc.ne\n  right_inv := smul_inv_smul\u2080 hc.ne\n  map_rel_iff' := (@OrderDual.toDual_le_toDual M).trans <| smul_le_smul_iff_of_neg hc", "start": [181, 1], "end": [188, 86], "kind": "commanddeclaration"}, {"full_name": "smul_lowerBounds_subset_upperBounds_smul", "code": "theorem smul_lowerBounds_subset_upperBounds_smul (hc : c \u2264 0) :\n    c \u2022 lowerBounds s \u2286 upperBounds (c \u2022 s)", "start": [200, 1], "end": [202, 69], "kind": "commanddeclaration"}, {"full_name": "smul_upperBounds_subset_lowerBounds_smul", "code": "theorem smul_upperBounds_subset_lowerBounds_smul (hc : c \u2264 0) :\n    c \u2022 upperBounds s \u2286 lowerBounds (c \u2022 s)", "start": [205, 1], "end": [207, 69], "kind": "commanddeclaration"}, {"full_name": "BddBelow.smul_of_nonpos", "code": "theorem BddBelow.smul_of_nonpos (hc : c \u2264 0) (hs : BddBelow s) : BddAbove (c \u2022 s)", "start": [210, 1], "end": [211, 42], "kind": "commanddeclaration"}, {"full_name": "BddAbove.smul_of_nonpos", "code": "theorem BddAbove.smul_of_nonpos (hc : c \u2264 0) (hs : BddAbove s) : BddBelow (c \u2022 s)", "start": [214, 1], "end": [215, 42], "kind": "commanddeclaration"}, {"full_name": "smul_max_of_nonpos", "code": "theorem smul_max_of_nonpos (ha : a \u2264 0) (b\u2081 b\u2082 : M) : a \u2022 max b\u2081 b\u2082 = min (a \u2022 b\u2081) (a \u2022 b\u2082)", "start": [223, 1], "end": [224, 57], "kind": "commanddeclaration"}, {"full_name": "smul_min_of_nonpos", "code": "theorem smul_min_of_nonpos (ha : a \u2264 0) (b\u2081 b\u2082 : M) : a \u2022 min b\u2081 b\u2082 = max (a \u2022 b\u2081) (a \u2022 b\u2082)", "start": [227, 1], "end": [228, 57], "kind": "commanddeclaration"}, {"full_name": "lowerBounds_smul_of_neg", "code": "@[simp]\ntheorem lowerBounds_smul_of_neg (hc : c < 0) : lowerBounds (c \u2022 s) = c \u2022 upperBounds s", "start": [238, 1], "end": [240, 49], "kind": "commanddeclaration"}, {"full_name": "upperBounds_smul_of_neg", "code": "@[simp]\ntheorem upperBounds_smul_of_neg (hc : c < 0) : upperBounds (c \u2022 s) = c \u2022 lowerBounds s", "start": [243, 1], "end": [245, 49], "kind": "commanddeclaration"}, {"full_name": "bddBelow_smul_iff_of_neg", "code": "@[simp]\ntheorem bddBelow_smul_iff_of_neg (hc : c < 0) : BddBelow (c \u2022 s) \u2194 BddAbove s", "start": [248, 1], "end": [250, 46], "kind": "commanddeclaration"}, {"full_name": "bddAbove_smul_iff_of_neg", "code": "@[simp]\ntheorem bddAbove_smul_iff_of_neg (hc : c < 0) : BddAbove (c \u2022 s) \u2194 BddBelow s", "start": [253, 1], "end": [255, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/TypeTags.lean", "imports": ["Mathlib/Algebra/Order/Monoid/TypeTags.lean", "Mathlib/Algebra/Order/Group/Instances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Multiplicative.orderedCommGroup", "code": "instance Multiplicative.orderedCommGroup [OrderedAddCommGroup \u03b1] :\n    OrderedCommGroup (Multiplicative \u03b1) :=\n  { Multiplicative.commGroup, Multiplicative.orderedCommMonoid with }", "start": [16, 1], "end": [18, 70], "kind": "commanddeclaration"}, {"full_name": "Additive.orderedAddCommGroup", "code": "instance Additive.orderedAddCommGroup [OrderedCommGroup \u03b1] :\n    OrderedAddCommGroup (Additive \u03b1) :=\n  { Additive.addCommGroup, Additive.orderedAddCommMonoid with }", "start": [20, 1], "end": [22, 64], "kind": "commanddeclaration"}, {"full_name": "Multiplicative.linearOrderedCommGroup", "code": "instance Multiplicative.linearOrderedCommGroup [LinearOrderedAddCommGroup \u03b1] :\n    LinearOrderedCommGroup (Multiplicative \u03b1) :=\n  { Multiplicative.linearOrder, Multiplicative.orderedCommGroup with }", "start": [24, 1], "end": [26, 71], "kind": "commanddeclaration"}, {"full_name": "Additive.linearOrderedAddCommGroup", "code": "instance Additive.linearOrderedAddCommGroup [LinearOrderedCommGroup \u03b1] :\n    LinearOrderedAddCommGroup (Additive \u03b1) :=\n  { Additive.linearOrder, Additive.orderedAddCommGroup with }", "start": [28, 1], "end": [30, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Nonneg/Ring.lean", "imports": ["Mathlib/Order/CompleteLatticeIntervals.lean", "Mathlib/Data/Nat/Cast/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Order/LatticeIntervals.lean", "Mathlib/Algebra/Order/Ring/InjSurj.lean", "Mathlib/Algebra/GroupPower/Order.lean", "Mathlib/Algebra/Order/Ring/Defs.lean"], "premises": [{"full_name": "Nonneg.orderBot", "code": "instance orderBot [Preorder \u03b1] {a : \u03b1} : OrderBot { x : \u03b1 // a \u2264 x } :=\n  { Set.Ici.orderBot with }", "start": [46, 1], "end": [50, 28], "kind": "commanddeclaration"}, {"full_name": "Nonneg.bot_eq", "code": "theorem bot_eq [Preorder \u03b1] {a : \u03b1} : (\u22a5 : { x : \u03b1 // a \u2264 x }) = \u27e8a, le_rfl\u27e9", "start": [53, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.noMaxOrder", "code": "instance noMaxOrder [PartialOrder \u03b1] [NoMaxOrder \u03b1] {a : \u03b1} : NoMaxOrder { x : \u03b1 // a \u2264 x } :=\n  show NoMaxOrder (Ici a) by infer_instance", "start": [57, 1], "end": [58, 44], "kind": "commanddeclaration"}, {"full_name": "Nonneg.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] {a : \u03b1} : SemilatticeSup { x : \u03b1 // a \u2264 x } :=\n  Set.Ici.semilatticeSup", "start": [61, 1], "end": [62, 25], "kind": "commanddeclaration"}, {"full_name": "Nonneg.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] {a : \u03b1} : SemilatticeInf { x : \u03b1 // a \u2264 x } :=\n  Set.Ici.semilatticeInf", "start": [65, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "Nonneg.distribLattice", "code": "instance distribLattice [DistribLattice \u03b1] {a : \u03b1} : DistribLattice { x : \u03b1 // a \u2264 x } :=\n  Set.Ici.distribLattice", "start": [69, 1], "end": [70, 25], "kind": "commanddeclaration"}, {"full_name": "Nonneg.densely_ordered", "code": "instance densely_ordered [Preorder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1} :\n    DenselyOrdered { x : \u03b1 // a \u2264 x } :=\n  show DenselyOrdered (Ici a) from Set.instDenselyOrdered", "start": [73, 1], "end": [75, 58], "kind": "commanddeclaration"}, {"full_name": "Nonneg.conditionallyCompleteLinearOrder", "code": "@[reducible]\nprotected noncomputable def conditionallyCompleteLinearOrder [ConditionallyCompleteLinearOrder \u03b1]\n    {a : \u03b1} : ConditionallyCompleteLinearOrder { x : \u03b1 // a \u2264 x } :=\n  { @ordConnectedSubsetConditionallyCompleteLinearOrder \u03b1 (Set.Ici a) _ \u27e8\u27e8a, le_rfl\u27e9\u27e9 _ with }", "start": [78, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "Nonneg.conditionallyCompleteLinearOrderBot", "code": "@[reducible]\nprotected noncomputable def conditionallyCompleteLinearOrderBot [ConditionallyCompleteLinearOrder \u03b1]\n    (a : \u03b1) : ConditionallyCompleteLinearOrderBot { x : \u03b1 // a \u2264 x } :=\n  { Nonneg.orderBot, Nonneg.conditionallyCompleteLinearOrder with\n    csSup_empty := by\n      rw [@subset_sSup_def \u03b1 (Set.Ici a) _ _ \u27e8\u27e8a, le_rfl\u27e9\u27e9]; simp [bot_eq] }", "start": [85, 1], "end": [95, 77], "kind": "commanddeclaration"}, {"full_name": "Nonneg.inhabited", "code": "instance inhabited [Preorder \u03b1] {a : \u03b1} : Inhabited { x : \u03b1 // a \u2264 x } :=\n  \u27e8\u27e8a, le_rfl\u27e9\u27e9", "start": [98, 1], "end": [99, 16], "kind": "commanddeclaration"}, {"full_name": "Nonneg.zero", "code": "instance zero [Zero \u03b1] [Preorder \u03b1] : Zero { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8\u27e80, le_rfl\u27e9\u27e9", "start": [102, 1], "end": [103, 16], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_zero", "code": "@[simp, norm_cast]\nprotected theorem coe_zero [Zero \u03b1] [Preorder \u03b1] : ((0 : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = 0", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_eq_zero", "code": "@[simp]\ntheorem mk_eq_zero [Zero \u03b1] [Preorder \u03b1] {x : \u03b1} (hx : 0 \u2264 x) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) = 0 \u2194 x = 0", "start": [111, 1], "end": [114, 18], "kind": "commanddeclaration"}, {"full_name": "Nonneg.add", "code": "instance add [AddZeroClass \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    Add { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun x y => \u27e8x + y, add_nonneg x.2 y.2\u27e9\u27e9", "start": [117, 1], "end": [119, 43], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_add_mk", "code": "@[simp]\ntheorem mk_add_mk [AddZeroClass \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {x y : \u03b1}\n    (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) + \u27e8y, hy\u27e9 = \u27e8x + y, add_nonneg hx hy\u27e9", "start": [122, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_add", "code": "@[simp, norm_cast]\nprotected theorem coe_add [AddZeroClass \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    (a b : { x : \u03b1 // 0 \u2264 x }) : ((a + b : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = a + b", "start": [129, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nsmul", "code": "instance nsmul [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    SMul \u2115 { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun n x => \u27e8n \u2022 (x : \u03b1), nsmul_nonneg x.prop n\u27e9\u27e9", "start": [135, 1], "end": [137, 52], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nsmul_mk", "code": "@[simp]\ntheorem nsmul_mk [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (n : \u2115) {x : \u03b1}\n    (hx : 0 \u2264 x) : (n \u2022 (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x })) = \u27e8n \u2022 x, nsmul_nonneg hx n\u27e9", "start": [140, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_nsmul", "code": "@[simp, norm_cast]\nprotected theorem coe_nsmul [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)]\n    (n : \u2115) (a : { x : \u03b1 // 0 \u2264 x }) : ((n \u2022 a : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = n \u2022 (a : \u03b1)", "start": [146, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.orderedAddCommMonoid", "code": "instance orderedAddCommMonoid [OrderedAddCommMonoid \u03b1] : OrderedAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.orderedAddCommMonoid _ Nonneg.coe_zero (fun _ _ => rfl) fun _ _ => rfl", "start": [152, 1], "end": [153, 95], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedAddCommMonoid", "code": "instance linearOrderedAddCommMonoid [LinearOrderedAddCommMonoid \u03b1] :\n    LinearOrderedAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.linearOrderedAddCommMonoid _ Nonneg.coe_zero\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [156, 1], "end": [160, 36], "kind": "commanddeclaration"}, {"full_name": "Nonneg.orderedCancelAddCommMonoid", "code": "instance orderedCancelAddCommMonoid [OrderedCancelAddCommMonoid \u03b1] :\n    OrderedCancelAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.orderedCancelAddCommMonoid _ Nonneg.coe_zero (fun _ _ => rfl) fun _ _ => rfl", "start": [163, 1], "end": [165, 101], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedCancelAddCommMonoid", "code": "instance linearOrderedCancelAddCommMonoid [LinearOrderedCancelAddCommMonoid \u03b1] :\n    LinearOrderedCancelAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.linearOrderedCancelAddCommMonoid _ Nonneg.coe_zero\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ _ => rfl", "start": [168, 1], "end": [172, 36], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coeAddMonoidHom", "code": "def coeAddMonoidHom [OrderedAddCommMonoid \u03b1] : { x : \u03b1 // 0 \u2264 x } \u2192+ \u03b1 :=\n  { toFun := ((\u2191) : { x : \u03b1 // 0 \u2264 x } \u2192 \u03b1)\n    map_zero' := Nonneg.coe_zero\n    map_add' := Nonneg.coe_add }", "start": [175, 1], "end": [179, 33], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nsmul_coe", "code": "@[norm_cast]\ntheorem nsmul_coe [OrderedAddCommMonoid \u03b1] (n : \u2115) (r : { x : \u03b1 // 0 \u2264 x }) :\n    \u2191(n \u2022 r) = n \u2022 (r : \u03b1)", "start": [182, 1], "end": [185, 39], "kind": "commanddeclaration"}, {"full_name": "Nonneg.one", "code": "instance one [OrderedSemiring \u03b1] : One { x : \u03b1 // 0 \u2264 x } where one := \u27e81, zero_le_one\u27e9", "start": [188, 1], "end": [188, 88], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_one", "code": "@[simp, norm_cast]\nprotected theorem coe_one [OrderedSemiring \u03b1] : ((1 : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = 1", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_eq_one", "code": "@[simp]\ntheorem mk_eq_one [OrderedSemiring \u03b1] {x : \u03b1} (hx : 0 \u2264 x) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) = 1 \u2194 x = 1", "start": [196, 1], "end": [199, 18], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mul", "code": "instance mul [OrderedSemiring \u03b1] : Mul { x : \u03b1 // 0 \u2264 x } where\n  mul x y := \u27e8x * y, mul_nonneg x.2 y.2\u27e9", "start": [202, 1], "end": [203, 41], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_mul", "code": "@[simp, norm_cast]\nprotected theorem coe_mul [OrderedSemiring \u03b1] (a b : { x : \u03b1 // 0 \u2264 x }) :\n    ((a * b : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = a * b", "start": [206, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_mul_mk", "code": "@[simp]\ntheorem mk_mul_mk [OrderedSemiring \u03b1] {x y : \u03b1} (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) * \u27e8y, hy\u27e9 = \u27e8x * y, mul_nonneg hx hy\u27e9", "start": [212, 1], "end": [215, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.addMonoidWithOne", "code": "instance addMonoidWithOne [OrderedSemiring \u03b1] : AddMonoidWithOne { x : \u03b1 // 0 \u2264 x } :=\n  { Nonneg.one,\n    Nonneg.orderedAddCommMonoid with\n    natCast := fun n => \u27e8n, Nat.cast_nonneg n\u27e9\n    natCast_zero := by simp\n    natCast_succ := fun _ => by simp; rfl }", "start": [218, 1], "end": [223, 44], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_nat_cast", "code": "@[simp, norm_cast]\nprotected theorem coe_nat_cast [OrderedSemiring \u03b1] (n : \u2115) : ((\u2191n : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = n", "start": [226, 1], "end": [228, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_nat_cast", "code": "@[simp]\ntheorem mk_nat_cast [OrderedSemiring \u03b1] (n : \u2115) : (\u27e8n, n.cast_nonneg\u27e9 : { x : \u03b1 // 0 \u2264 x }) = n", "start": [231, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.pow", "code": "instance pow [OrderedSemiring \u03b1] : Pow { x : \u03b1 // 0 \u2264 x } \u2115 where\n  pow x n := \u27e8(x : \u03b1) ^ n, pow_nonneg x.2 n\u27e9", "start": [236, 1], "end": [237, 45], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_pow", "code": "@[simp, norm_cast]\nprotected theorem coe_pow [OrderedSemiring \u03b1] (a : { x : \u03b1 // 0 \u2264 x }) (n : \u2115) :\n    (\u2191(a ^ n) : \u03b1) = (a : \u03b1) ^ n", "start": [240, 1], "end": [243, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_pow", "code": "@[simp]\ntheorem mk_pow [OrderedSemiring \u03b1] {x : \u03b1} (hx : 0 \u2264 x) (n : \u2115) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) ^ n = \u27e8x ^ n, pow_nonneg hx n\u27e9", "start": [246, 1], "end": [249, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.orderedSemiring", "code": "instance orderedSemiring [OrderedSemiring \u03b1] : OrderedSemiring { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.orderedSemiring _ Nonneg.coe_zero Nonneg.coe_one\n    (fun _ _ => rfl) (fun _ _=> rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) fun _ => rfl", "start": [252, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "Nonneg.strictOrderedSemiring", "code": "instance strictOrderedSemiring [StrictOrderedSemiring \u03b1] :\n    StrictOrderedSemiring { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.strictOrderedSemiring _ Nonneg.coe_zero Nonneg.coe_one\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [258, 1], "end": [262, 51], "kind": "commanddeclaration"}, {"full_name": "Nonneg.orderedCommSemiring", "code": "instance orderedCommSemiring [OrderedCommSemiring \u03b1] : OrderedCommSemiring { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.orderedCommSemiring _ Nonneg.coe_zero Nonneg.coe_one\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [265, 1], "end": [268, 51], "kind": "commanddeclaration"}, {"full_name": "Nonneg.strictOrderedCommSemiring", "code": "instance strictOrderedCommSemiring [StrictOrderedCommSemiring \u03b1] :\n    StrictOrderedCommSemiring { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.strictOrderedCommSemiring _ Nonneg.coe_zero Nonneg.coe_one\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) fun _ => rfl", "start": [271, 1], "end": [275, 51], "kind": "commanddeclaration"}, {"full_name": "Nonneg.monoidWithZero", "code": "instance monoidWithZero [OrderedSemiring \u03b1] : MonoidWithZero { x : \u03b1 // 0 \u2264 x } := by infer_instance", "start": [280, 1], "end": [280, 101], "kind": "commanddeclaration"}, {"full_name": "Nonneg.commMonoidWithZero", "code": "instance commMonoidWithZero [OrderedCommSemiring \u03b1] : CommMonoidWithZero { x : \u03b1 // 0 \u2264 x } := by\n  infer_instance", "start": [283, 1], "end": [284, 17], "kind": "commanddeclaration"}, {"full_name": "Nonneg.semiring", "code": "instance semiring [OrderedSemiring \u03b1] : Semiring { x : \u03b1 // 0 \u2264 x } :=\n  inferInstance", "start": [287, 1], "end": [288, 16], "kind": "commanddeclaration"}, {"full_name": "Nonneg.commSemiring", "code": "instance commSemiring [OrderedCommSemiring \u03b1] : CommSemiring { x : \u03b1 // 0 \u2264 x } :=\n  inferInstance", "start": [291, 1], "end": [292, 16], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nontrivial", "code": "instance nontrivial [LinearOrderedSemiring \u03b1] : Nontrivial { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8\u27e80, 1, fun h => zero_ne_one (congr_arg Subtype.val h)\u27e9\u27e9", "start": [295, 1], "end": [296, 59], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedSemiring", "code": "instance linearOrderedSemiring [LinearOrderedSemiring \u03b1] :\n    LinearOrderedSemiring { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.linearOrderedSemiring _ Nonneg.coe_zero Nonneg.coe_one\n    (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [299, 1], "end": [303, 85], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedCommMonoidWithZero", "code": "instance linearOrderedCommMonoidWithZero [LinearOrderedCommRing \u03b1] :\n    LinearOrderedCommMonoidWithZero { x : \u03b1 // 0 \u2264 x } :=\n  { Nonneg.linearOrderedSemiring, Nonneg.orderedCommSemiring with\n    mul_le_mul_left := fun _ _ h c \u21a6 mul_le_mul_of_nonneg_left h c.prop }", "start": [306, 1], "end": [309, 74], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coeRingHom", "code": "def coeRingHom [OrderedSemiring \u03b1] : { x : \u03b1 // 0 \u2264 x } \u2192+* \u03b1 :=\n  { toFun := ((\u2191) : { x : \u03b1 // 0 \u2264 x } \u2192 \u03b1)\n    map_one' := Nonneg.coe_one\n    map_mul' := Nonneg.coe_mul\n    map_zero' := Nonneg.coe_zero,\n    map_add' := Nonneg.coe_add }", "start": [312, 1], "end": [318, 33], "kind": "commanddeclaration"}, {"full_name": "Nonneg.canonicallyOrderedAddCommMonoid", "code": "instance canonicallyOrderedAddCommMonoid [OrderedRing \u03b1] :\n    CanonicallyOrderedAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  { Nonneg.orderedAddCommMonoid, Nonneg.orderBot with\n    le_self_add := fun _ b => le_add_of_nonneg_right b.2\n    exists_add_of_le := fun {a b} h =>\n      \u27e8\u27e8b - a, sub_nonneg_of_le h\u27e9, Subtype.ext (add_sub_cancel'_right _ _).symm\u27e9 }", "start": [321, 1], "end": [326, 84], "kind": "commanddeclaration"}, {"full_name": "Nonneg.canonicallyOrderedCommSemiring", "code": "instance canonicallyOrderedCommSemiring [OrderedCommRing \u03b1] [NoZeroDivisors \u03b1] :\n    CanonicallyOrderedCommSemiring { x : \u03b1 // 0 \u2264 x } :=\n  { Nonneg.canonicallyOrderedAddCommMonoid, Nonneg.orderedCommSemiring with\n    eq_zero_or_eq_zero_of_mul_eq_zero := by\n      rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9\n      simp only [mk_mul_mk, mk_eq_zero, mul_eq_zero, imp_self]}", "start": [329, 1], "end": [334, 64], "kind": "commanddeclaration"}, {"full_name": "Nonneg.canonicallyLinearOrderedAddCommMonoid", "code": "instance canonicallyLinearOrderedAddCommMonoid [LinearOrderedRing \u03b1] :\n    CanonicallyLinearOrderedAddCommMonoid { x : \u03b1 // 0 \u2264 x } :=\n  { Subtype.linearOrder _, Nonneg.canonicallyOrderedAddCommMonoid with }", "start": [337, 1], "end": [339, 73], "kind": "commanddeclaration"}, {"full_name": "Nonneg.toNonneg", "code": "def toNonneg (a : \u03b1) : { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8max a 0, le_max_right _ _\u27e9", "start": [346, 1], "end": [348, 30], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_toNonneg", "code": "@[simp]\ntheorem coe_toNonneg {a : \u03b1} : (toNonneg a : \u03b1) = max a 0", "start": [351, 1], "end": [353, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.toNonneg_of_nonneg", "code": "@[simp]\ntheorem toNonneg_of_nonneg {a : \u03b1} (h : 0 \u2264 a) : toNonneg a = \u27e8a, h\u27e9", "start": [356, 1], "end": [357, 94], "kind": "commanddeclaration"}, {"full_name": "Nonneg.toNonneg_coe", "code": "@[simp]\ntheorem toNonneg_coe {a : { x : \u03b1 // 0 \u2264 x }} : toNonneg (a : \u03b1) = a", "start": [360, 1], "end": [362, 25], "kind": "commanddeclaration"}, {"full_name": "Nonneg.toNonneg_le", "code": "@[simp]\ntheorem toNonneg_le {a : \u03b1} {b : { x : \u03b1 // 0 \u2264 x }} : toNonneg a \u2264 b \u2194 a \u2264 b", "start": [365, 1], "end": [368, 22], "kind": "commanddeclaration"}, {"full_name": "Nonneg.toNonneg_lt", "code": "@[simp]\ntheorem toNonneg_lt {a : { x : \u03b1 // 0 \u2264 x }} {b : \u03b1} : a < toNonneg b \u2194 \u2191a < b", "start": [371, 1], "end": [374, 29], "kind": "commanddeclaration"}, {"full_name": "Nonneg.sub", "code": "instance sub [Sub \u03b1] : Sub { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun x y => toNonneg (x - y)\u27e9", "start": [377, 1], "end": [378, 32], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_sub_mk", "code": "@[simp]\ntheorem mk_sub_mk [Sub \u03b1] {x y : \u03b1} (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) - \u27e8y, hy\u27e9 = toNonneg (x - y)", "start": [381, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.orderedSub", "code": "instance orderedSub [LinearOrderedRing \u03b1] : OrderedSub { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8by\n    rintro \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 \u27e8c, hc\u27e9\n    simp only [sub_le_iff_le_add, Subtype.mk_le_mk, mk_sub_mk, mk_add_mk, toNonneg_le,\n      Subtype.coe_mk]\u27e9", "start": [389, 1], "end": [393, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/Canonical/Defs.lean", "imports": ["Mathlib/Algebra/Order/Ring/Canonical.lean", "Mathlib/Algebra/Order/WithZero.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CanonicallyLinearOrderedSemifield", "code": "class CanonicallyLinearOrderedSemifield (\u03b1 : Type*) extends CanonicallyOrderedCommSemiring \u03b1,\n  LinearOrderedSemifield \u03b1", "start": [19, 1], "end": [22, 27], "kind": "commanddeclaration"}, {"full_name": "CanonicallyLinearOrderedSemifield.toLinearOrderedCommGroupWithZero", "code": "instance (priority := 100) CanonicallyLinearOrderedSemifield.toLinearOrderedCommGroupWithZero\n    [CanonicallyLinearOrderedSemifield \u03b1] : LinearOrderedCommGroupWithZero \u03b1 :=\n  { \u2039CanonicallyLinearOrderedSemifield \u03b1\u203a with\n    mul_le_mul_left := fun a b h c \u21a6 mul_le_mul_of_nonneg_left h <| zero_le _ }", "start": [26, 1], "end": [29, 80], "kind": "commanddeclaration"}, {"full_name": "CanonicallyLinearOrderedSemifield.toCanonicallyLinearOrderedAddCommMonoid", "code": "instance (priority := 100) CanonicallyLinearOrderedSemifield.toCanonicallyLinearOrderedAddCommMonoid\n    [CanonicallyLinearOrderedSemifield \u03b1] : CanonicallyLinearOrderedAddCommMonoid \u03b1 :=\n  { \u2039CanonicallyLinearOrderedSemifield \u03b1\u203a with }", "start": [33, 1], "end": [35, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/InjSurj.lean", "imports": ["Mathlib/Algebra/Field/Basic.lean", "Mathlib/Algebra/Order/Ring/InjSurj.lean", "Mathlib/Algebra/Order/Field/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Function.Injective.linearOrderedSemifield", "code": "@[reducible]\ndef Injective.linearOrderedSemifield [LinearOrderedSemifield \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2]\n    [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [NatCast \u03b2] [Inv \u03b2] [Div \u03b2] [Pow \u03b2 \u2124] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1)\n    (hf : Injective f) (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y))\n    (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) : LinearOrderedSemifield \u03b2 :=\n  { hf.linearOrderedSemiring f zero one add mul nsmul npow nat_cast hsup hinf,\n    hf.semifield f zero one add mul inv div nsmul npow zpow nat_cast with }", "start": [25, 1], "end": [36, 76], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.linearOrderedField", "code": "@[reducible]\ndef Injective.linearOrderedField [LinearOrderedField \u03b1] [Zero \u03b2] [One \u03b2] [Add \u03b2] [Mul \u03b2] [Neg \u03b2]\n    [Sub \u03b2] [Pow \u03b2 \u2115] [SMul \u2115 \u03b2] [SMul \u2124 \u03b2] [SMul \u211a \u03b2] [NatCast \u03b2] [IntCast \u03b2]\n    [RatCast \u03b2] [Inv \u03b2] [Div \u03b2] [Pow \u03b2 \u2124] [Sup \u03b2] [Inf \u03b2] (f : \u03b2 \u2192 \u03b1) (hf : Injective f)\n    (zero : f 0 = 0) (one : f 1 = 1) (add : \u2200 x y, f (x + y) = f x + f y)\n    (mul : \u2200 x y, f (x * y) = f x * f y) (neg : \u2200 x, f (-x) = -f x)\n    (sub : \u2200 x y, f (x - y) = f x - f y) (inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9)\n    (div : \u2200 x y, f (x / y) = f x / f y) (nsmul : \u2200 (x) (n : \u2115), f (n \u2022 x) = n \u2022 f x)\n    (zsmul : \u2200 (x) (n : \u2124), f (n \u2022 x) = n \u2022 f x) (qsmul : \u2200 (x) (n : \u211a), f (n \u2022 x) = n \u2022 f x)\n    (npow : \u2200 (x) (n : \u2115), f (x ^ n) = f x ^ n) (zpow : \u2200 (x) (n : \u2124), f (x ^ n) = f x ^ n)\n    (nat_cast : \u2200 n : \u2115, f n = n) (int_cast : \u2200 n : \u2124, f n = n) (rat_cast : \u2200 n : \u211a, f n = n)\n    (hsup : \u2200 x y, f (x \u2294 y) = max (f x) (f y)) (hinf : \u2200 x y, f (x \u2293 y) = min (f x) (f y)) :\n    LinearOrderedField \u03b2 :=\n  { hf.linearOrderedRing f zero one add mul neg sub nsmul zsmul npow nat_cast int_cast hsup hinf,\n    hf.field f zero one add mul neg sub inv div nsmul zsmul qsmul npow zpow nat_cast int_cast\n      rat_cast with }", "start": [41, 1], "end": [57, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Commutator.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Subgroup/Finite.lean", "Mathlib/Tactic/Group.lean", "Mathlib/Data/Bracket.lean", "Mathlib/Algebra/Group/Commutator.lean"], "premises": [{"full_name": "commutatorElement_eq_one_iff_mul_comm", "code": "theorem commutatorElement_eq_one_iff_mul_comm : \u2045g\u2081, g\u2082\u2046 = 1 \u2194 g\u2081 * g\u2082 = g\u2082 * g\u2081", "start": [29, 1], "end": [30, 68], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_eq_one_iff_commute", "code": "theorem commutatorElement_eq_one_iff_commute : \u2045g\u2081, g\u2082\u2046 = 1 \u2194 Commute g\u2081 g\u2082", "start": [33, 1], "end": [34, 40], "kind": "commanddeclaration"}, {"full_name": "Commute.commutator_eq", "code": "theorem Commute.commutator_eq (h : Commute g\u2081 g\u2082) : \u2045g\u2081, g\u2082\u2046 = 1", "start": [37, 1], "end": [38, 45], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_one_right", "code": "@[simp]\ntheorem commutatorElement_one_right : \u2045g, (1 : G)\u2046 = 1", "start": [43, 1], "end": [45, 38], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_one_left", "code": "@[simp]\ntheorem commutatorElement_one_left : \u2045(1 : G), g\u2046 = 1", "start": [48, 1], "end": [50, 37], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_self", "code": "@[simp]\ntheorem commutatorElement_self : \u2045g, g\u2046 = 1", "start": [53, 1], "end": [55, 33], "kind": "commanddeclaration"}, {"full_name": "commutatorElement_inv", "code": "@[simp]\ntheorem commutatorElement_inv : \u2045g\u2081, g\u2082\u2046\u207b\u00b9 = \u2045g\u2082, g\u2081\u2046", "start": [58, 1], "end": [60, 67], "kind": "commanddeclaration"}, {"full_name": "map_commutatorElement", "code": "theorem map_commutatorElement : (f \u2045g\u2081, g\u2082\u2046 : G') = \u2045f g\u2081, f g\u2082\u2046", "start": [63, 1], "end": [64, 56], "kind": "commanddeclaration"}, {"full_name": "conjugate_commutatorElement", "code": "theorem conjugate_commutatorElement : g\u2083 * \u2045g\u2081, g\u2082\u2046 * g\u2083\u207b\u00b9 = \u2045g\u2083 * g\u2081 * g\u2083\u207b\u00b9, g\u2083 * g\u2082 * g\u2083\u207b\u00b9\u2046", "start": [67, 1], "end": [68, 59], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator", "code": "instance commutator : Bracket (Subgroup G) (Subgroup G) :=\n  \u27e8fun H\u2081 H\u2082 => closure { g | \u2203 g\u2081 \u2208 H\u2081, \u2203 g\u2082 \u2208 H\u2082, \u2045g\u2081, g\u2082\u2046 = g }\u27e9", "start": [73, 1], "end": [75, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_def", "code": "theorem commutator_def (H\u2081 H\u2082 : Subgroup G) :\n    \u2045H\u2081, H\u2082\u2046 = closure { g | \u2203 g\u2081 \u2208 H\u2081, \u2203 g\u2082 \u2208 H\u2082, \u2045g\u2081, g\u2082\u2046 = g }", "start": [78, 1], "end": [80, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_mem_commutator", "code": "theorem commutator_mem_commutator (h\u2081 : g\u2081 \u2208 H\u2081) (h\u2082 : g\u2082 \u2208 H\u2082) : \u2045g\u2081, g\u2082\u2046 \u2208 \u2045H\u2081, H\u2082\u2046", "start": [85, 1], "end": [86, 39], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_le", "code": "theorem commutator_le : \u2045H\u2081, H\u2082\u2046 \u2264 H\u2083 \u2194 \u2200 g\u2081 \u2208 H\u2081, \u2200 g\u2082 \u2208 H\u2082, \u2045g\u2081, g\u2082\u2046 \u2208 H\u2083", "start": [89, 1], "end": [91, 92], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_mono", "code": "theorem commutator_mono (h\u2081 : H\u2081 \u2264 K\u2081) (h\u2082 : H\u2082 \u2264 K\u2082) : \u2045H\u2081, H\u2082\u2046 \u2264 \u2045K\u2081, K\u2082\u2046", "start": [94, 1], "end": [95, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_eq_bot_iff_le_centralizer", "code": "theorem commutator_eq_bot_iff_le_centralizer : \u2045H\u2081, H\u2082\u2046 = \u22a5 \u2194 H\u2081 \u2264 centralizer H\u2082", "start": [98, 1], "end": [102, 63], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_commutator_eq_bot_of_rotate", "code": "theorem commutator_commutator_eq_bot_of_rotate (h1 : \u2045\u2045H\u2082, H\u2083\u2046, H\u2081\u2046 = \u22a5) (h2 : \u2045\u2045H\u2083, H\u2081\u2046, H\u2082\u2046 = \u22a5) :\n    \u2045\u2045H\u2081, H\u2082\u2046, H\u2083\u2046 = \u22a5", "start": [105, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_comm_le", "code": "theorem commutator_comm_le : \u2045H\u2081, H\u2082\u2046 \u2264 \u2045H\u2082, H\u2081\u2046", "start": [119, 1], "end": [121, 93], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_comm", "code": "theorem commutator_comm : \u2045H\u2081, H\u2082\u2046 = \u2045H\u2082, H\u2081\u2046", "start": [124, 1], "end": [125, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_normal", "code": "instance commutator_normal [h\u2081 : H\u2081.Normal] [h\u2082 : H\u2082.Normal] : Normal \u2045H\u2081, H\u2082\u2046 := by\n  let base : Set G := { x | \u2203 g\u2081 \u2208 H\u2081, \u2203 g\u2082 \u2208 H\u2082, \u2045g\u2081, g\u2082\u2046 = x }\n  change (closure base).Normal\n  suffices h_base : base = Group.conjugatesOfSet base\n  \u00b7 rw [h_base]\n    exact Subgroup.normalClosure_normal\n  refine' Set.Subset.antisymm Group.subset_conjugatesOfSet fun a h => _\n  simp_rw [Group.mem_conjugatesOfSet_iff, isConj_iff] at h\n  rcases h with \u27e8b, \u27e8c, hc, e, he, rfl\u27e9, d, rfl\u27e9\n  exact \u27e8_, h\u2081.conj_mem c hc d, _, h\u2082.conj_mem e he d, (conjugate_commutatorElement c e d).symm\u27e9", "start": [130, 1], "end": [139, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_def'", "code": "theorem commutator_def' [H\u2081.Normal] [H\u2082.Normal] :\n    \u2045H\u2081, H\u2082\u2046 = normalClosure { g | \u2203 g\u2081 \u2208 H\u2081, \u2203 g\u2082 \u2208 H\u2082, \u2045g\u2081, g\u2082\u2046 = g }", "start": [142, 1], "end": [144, 80], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_le_right", "code": "theorem commutator_le_right [h : H\u2082.Normal] : \u2045H\u2081, H\u2082\u2046 \u2264 H\u2082", "start": [147, 1], "end": [148, 89], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_le_left", "code": "theorem commutator_le_left [H\u2081.Normal] : \u2045H\u2081, H\u2082\u2046 \u2264 H\u2081", "start": [151, 1], "end": [152, 52], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_bot_left", "code": "@[simp]\ntheorem commutator_bot_left : \u2045(\u22a5 : Subgroup G), H\u2081\u2046 = \u22a5", "start": [155, 1], "end": [157, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_bot_right", "code": "@[simp]\ntheorem commutator_bot_right : \u2045H\u2081, \u22a5\u2046 = (\u22a5 : Subgroup G)", "start": [160, 1], "end": [162, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_le_inf", "code": "theorem commutator_le_inf [Normal H\u2081] [Normal H\u2082] : \u2045H\u2081, H\u2082\u2046 \u2264 H\u2081 \u2293 H\u2082", "start": [165, 1], "end": [166, 64], "kind": "commanddeclaration"}, {"full_name": "Subgroup.map_commutator", "code": "theorem map_commutator (f : G \u2192* G') : map f \u2045H\u2081, H\u2082\u2046 = \u2045map f H\u2081, map f H\u2082\u2046", "start": [171, 1], "end": [178, 61], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_le_map_commutator", "code": "theorem commutator_le_map_commutator {f : G \u2192* G'} {K\u2081 K\u2082 : Subgroup G'} (h\u2081 : K\u2081 \u2264 H\u2081.map f)\n    (h\u2082 : K\u2082 \u2264 H\u2082.map f) : \u2045K\u2081, K\u2082\u2046 \u2264 \u2045H\u2081, H\u2082\u2046.map f", "start": [183, 1], "end": [185, 68], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_characteristic", "code": "instance commutator_characteristic [h\u2081 : Characteristic H\u2081] [h\u2082 : Characteristic H\u2082] :\n    Characteristic \u2045H\u2081, H\u2082\u2046 :=\n  characteristic_iff_le_map.mpr fun \u03d5 =>\n    commutator_le_map_commutator (characteristic_iff_le_map.mp h\u2081 \u03d5)\n      (characteristic_iff_le_map.mp h\u2082 \u03d5)", "start": [190, 1], "end": [194, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_prod_prod", "code": "theorem commutator_prod_prod (K\u2081 K\u2082 : Subgroup G') :\n    \u2045H\u2081.prod K\u2081, H\u2082.prod K\u2082\u2046 = \u2045H\u2081, H\u2082\u2046.prod \u2045K\u2081, K\u2082\u2046", "start": [197, 1], "end": [208, 60], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_pi_pi_le", "code": "theorem commutator_pi_pi_le {\u03b7 : Type*} {Gs : \u03b7 \u2192 Type*} [\u2200 i, Group (Gs i)]\n    (H K : \u2200 i, Subgroup (Gs i)) :\n    \u2045Subgroup.pi Set.univ H, Subgroup.pi Set.univ K\u2046 \u2264 Subgroup.pi Set.univ fun i => \u2045H i, K i\u2046", "start": [211, 1], "end": [218, 90], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commutator_pi_pi_of_finite", "code": "theorem commutator_pi_pi_of_finite {\u03b7 : Type*} [Finite \u03b7] {Gs : \u03b7 \u2192 Type*} [\u2200 i, Group (Gs i)]\n    (H K : \u2200 i, Subgroup (Gs i)) : \u2045Subgroup.pi Set.univ H, Subgroup.pi Set.univ K\u2046 =\n    Subgroup.pi Set.univ fun i => \u2045H i, K i\u2046", "start": [221, 1], "end": [238, 30], "kind": "commanddeclaration"}, {"full_name": "commutatorSet", "code": "def commutatorSet : Set G :=\n  { g | \u2203 g\u2081 g\u2082 : G, \u2045g\u2081, g\u2082\u2046 = g }", "start": [245, 1], "end": [247, 36], "kind": "commanddeclaration"}, {"full_name": "commutatorSet_def", "code": "theorem commutatorSet_def : commutatorSet G = { g | \u2203 g\u2081 g\u2082 : G, \u2045g\u2081, g\u2082\u2046 = g }", "start": [250, 1], "end": [251, 6], "kind": "commanddeclaration"}, {"full_name": "one_mem_commutatorSet", "code": "theorem one_mem_commutatorSet : (1 : G) \u2208 commutatorSet G", "start": [254, 1], "end": [255, 35], "kind": "commanddeclaration"}, {"full_name": "mem_commutatorSet_iff", "code": "theorem mem_commutatorSet_iff : g \u2208 commutatorSet G \u2194 \u2203 g\u2081 g\u2082 : G, \u2045g\u2081, g\u2082\u2046 = g", "start": [263, 1], "end": [264, 10], "kind": "commanddeclaration"}, {"full_name": "commutator_mem_commutatorSet", "code": "theorem commutator_mem_commutatorSet : \u2045g\u2081, g\u2082\u2046 \u2208 commutatorSet G", "start": [267, 1], "end": [268, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Group/ConjFinite.lean", "imports": ["Mathlib/Data/Finite/Basic.lean", "Mathlib/Algebra/Group/Conj.lean", "Mathlib/Data/Fintype/Units.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "conjugatesOf.fintype", "code": "instance conjugatesOf.fintype [Fintype \u03b1] [DecidableRel (IsConj : \u03b1 \u2192 \u03b1 \u2192 Prop)] {a : \u03b1} :\n  Fintype (conjugatesOf a) :=\n  @Subtype.fintype _ _ (\u2039DecidableRel IsConj\u203a a) _", "start": [30, 1], "end": [32, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Dynamics/PeriodicPts.lean", "imports": ["Mathlib/Data/List/Cycle.lean", "Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/PNat/Basic.lean", "Mathlib/GroupTheory/GroupAction/Group.lean", "Mathlib/Dynamics/FixedPoints/Basic.lean", "Mathlib/Algebra/Hom/Iterate.lean"], "premises": [{"full_name": "Function.IsPeriodicPt", "code": "def IsPeriodicPt (f : \u03b1 \u2192 \u03b1) (n : \u2115) (x : \u03b1) :=\n  IsFixedPt f^[n] x", "start": [53, 1], "end": [57, 20], "kind": "commanddeclaration"}, {"full_name": "Function.IsFixedPt.isPeriodicPt", "code": "theorem IsFixedPt.isPeriodicPt (hf : IsFixedPt f x) (n : \u2115) : IsPeriodicPt f n x", "start": [60, 1], "end": [62, 15], "kind": "commanddeclaration"}, {"full_name": "Function.is_periodic_id", "code": "theorem is_periodic_id (n : \u2115) (x : \u03b1) : IsPeriodicPt id n x", "start": [65, 1], "end": [67, 34], "kind": "commanddeclaration"}, {"full_name": "Function.isPeriodicPt_zero", "code": "theorem isPeriodicPt_zero (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : IsPeriodicPt f 0 x", "start": [70, 1], "end": [72, 17], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.isFixedPt", "code": "protected theorem isFixedPt (hf : IsPeriodicPt f n x) : IsFixedPt f^[n] x", "start": [80, 1], "end": [81, 5], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.map", "code": "protected theorem map (hx : IsPeriodicPt fa n x) {g : \u03b1 \u2192 \u03b2} (hg : Semiconj g fa fb) :\n    IsPeriodicPt fb n (g x)", "start": [84, 1], "end": [86, 40], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.apply_iterate", "code": "theorem apply_iterate (hx : IsPeriodicPt f n x) (m : \u2115) : IsPeriodicPt f n (f^[m] x)", "start": [89, 1], "end": [90, 37], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.apply", "code": "protected theorem apply (hx : IsPeriodicPt f n x) : IsPeriodicPt f n (f x)", "start": [93, 1], "end": [94, 21], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.add", "code": "protected theorem add (hn : IsPeriodicPt f n x) (hm : IsPeriodicPt f m x) :\n    IsPeriodicPt f (n + m) x", "start": [97, 1], "end": [100, 19], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.left_of_add", "code": "theorem left_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f m x) :\n    IsPeriodicPt f n x", "start": [103, 1], "end": [106, 27], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.right_of_add", "code": "theorem right_of_add (hn : IsPeriodicPt f (n + m) x) (hm : IsPeriodicPt f n x) :\n    IsPeriodicPt f m x", "start": [109, 1], "end": [112, 26], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.sub", "code": "protected theorem sub (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m - n) x", "start": [115, 1], "end": [121, 28], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.mul_const", "code": "protected theorem mul_const (hm : IsPeriodicPt f m x) (n : \u2115) : IsPeriodicPt f (m * n) x", "start": [124, 1], "end": [125, 64], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.const_mul", "code": "protected theorem const_mul (hm : IsPeriodicPt f m x) (n : \u2115) : IsPeriodicPt f (n * m) x", "start": [128, 1], "end": [129, 41], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.trans_dvd", "code": "theorem trans_dvd (hm : IsPeriodicPt f m x) {n : \u2115} (hn : m \u2223 n) : IsPeriodicPt f n x", "start": [132, 1], "end": [134, 27], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.iterate", "code": "protected theorem iterate (hf : IsPeriodicPt f n x) (m : \u2115) : IsPeriodicPt f^[m] n x", "start": [137, 1], "end": [139, 31], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.comp", "code": "theorem comp {g : \u03b1 \u2192 \u03b1} (hco : Commute f g) (hf : IsPeriodicPt f n x) (hg : IsPeriodicPt g n x) :\n    IsPeriodicPt (f \u2218 g) n x", "start": [142, 1], "end": [145, 29], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.comp_lcm", "code": "theorem comp_lcm {g : \u03b1 \u2192 \u03b1} (hco : Commute f g) (hf : IsPeriodicPt f m x)\n    (hg : IsPeriodicPt g n x) : IsPeriodicPt (f \u2218 g) (Nat.lcm m n) x", "start": [148, 1], "end": [150, 90], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.left_of_comp", "code": "theorem left_of_comp {g : \u03b1 \u2192 \u03b1} (hco : Commute f g) (hfg : IsPeriodicPt (f \u2218 g) n x)\n    (hg : IsPeriodicPt g n x) : IsPeriodicPt f n x", "start": [153, 1], "end": [156, 28], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.iterate_mod_apply", "code": "theorem iterate_mod_apply (h : IsPeriodicPt f n x) (m : \u2115) : f^[m % n] x = f^[m] x", "start": [159, 1], "end": [160, 80], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.mod", "code": "protected theorem mod (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m % n) x", "start": [163, 1], "end": [165, 36], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.gcd", "code": "protected theorem gcd (hm : IsPeriodicPt f m x) (hn : IsPeriodicPt f n x) :\n    IsPeriodicPt f (m.gcd n) x", "start": [168, 1], "end": [174, 28], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.eq_of_apply_eq_same", "code": "theorem eq_of_apply_eq_same (hx : IsPeriodicPt f n x) (hy : IsPeriodicPt f n y) (hn : 0 < n)\n    (h : f x = f y) : x = y", "start": [177, 1], "end": [181, 84], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.eq_of_apply_eq", "code": "theorem eq_of_apply_eq (hx : IsPeriodicPt f m x) (hy : IsPeriodicPt f n y) (hm : 0 < m) (hn : 0 < n)\n    (h : f x = f y) : x = y", "start": [184, 1], "end": [188, 74], "kind": "commanddeclaration"}, {"full_name": "Function.ptsOfPeriod", "code": "def ptsOfPeriod (f : \u03b1 \u2192 \u03b1) (n : \u2115) : Set \u03b1 :=\n  { x : \u03b1 | IsPeriodicPt f n x }", "start": [193, 1], "end": [195, 33], "kind": "commanddeclaration"}, {"full_name": "Function.mem_ptsOfPeriod", "code": "@[simp]\ntheorem mem_ptsOfPeriod : x \u2208 ptsOfPeriod f n \u2194 IsPeriodicPt f n x", "start": [198, 1], "end": [200, 10], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_ptsOfPeriod", "code": "theorem Semiconj.mapsTo_ptsOfPeriod {g : \u03b1 \u2192 \u03b2} (h : Semiconj g fa fb) (n : \u2115) :\n    MapsTo g (ptsOfPeriod fa n) (ptsOfPeriod fb n)", "start": [203, 1], "end": [205, 41], "kind": "commanddeclaration"}, {"full_name": "Function.bijOn_ptsOfPeriod", "code": "theorem bijOn_ptsOfPeriod (f : \u03b1 \u2192 \u03b1) {n : \u2115} (hn : 0 < n) :\n    BijOn f (ptsOfPeriod f n) (ptsOfPeriod f n)", "start": [208, 1], "end": [213, 73], "kind": "commanddeclaration"}, {"full_name": "Function.directed_ptsOfPeriod_pNat", "code": "theorem directed_ptsOfPeriod_pNat (f : \u03b1 \u2192 \u03b1) : Directed (\u00b7 \u2286 \u00b7) fun n : \u2115+ => ptsOfPeriod f n", "start": [216, 1], "end": [217, 77], "kind": "commanddeclaration"}, {"full_name": "Function.periodicPts", "code": "def periodicPts (f : \u03b1 \u2192 \u03b1) : Set \u03b1 :=\n  { x : \u03b1 | \u2203 n > 0, IsPeriodicPt f n x }", "start": [220, 1], "end": [222, 42], "kind": "commanddeclaration"}, {"full_name": "Function.mk_mem_periodicPts", "code": "theorem mk_mem_periodicPts (hn : 0 < n) (hx : IsPeriodicPt f n x) : x \u2208 periodicPts f", "start": [225, 1], "end": [226, 14], "kind": "commanddeclaration"}, {"full_name": "Function.mem_periodicPts", "code": "theorem mem_periodicPts : x \u2208 periodicPts f \u2194 \u2203 n > 0, IsPeriodicPt f n x", "start": [229, 1], "end": [230, 10], "kind": "commanddeclaration"}, {"full_name": "Function.isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate", "code": "theorem isPeriodicPt_of_mem_periodicPts_of_isPeriodicPt_iterate (hx : x \u2208 periodicPts f)\n    (hm : IsPeriodicPt f m (f^[n] x)) : IsPeriodicPt f m x", "start": [233, 1], "end": [242, 35], "kind": "commanddeclaration"}, {"full_name": "Function.bUnion_ptsOfPeriod", "code": "theorem bUnion_ptsOfPeriod : \u22c3 n > 0, ptsOfPeriod f n = periodicPts f", "start": [247, 1], "end": [248, 45], "kind": "commanddeclaration"}, {"full_name": "Function.iUnion_pNat_ptsOfPeriod", "code": "theorem iUnion_pNat_ptsOfPeriod : \u22c3 n : \u2115+, ptsOfPeriod f n = periodicPts f", "start": [251, 1], "end": [252, 45], "kind": "commanddeclaration"}, {"full_name": "Function.bijOn_periodicPts", "code": "theorem bijOn_periodicPts : BijOn f (periodicPts f) (periodicPts f)", "start": [255, 1], "end": [257, 94], "kind": "commanddeclaration"}, {"full_name": "Function.Semiconj.mapsTo_periodicPts", "code": "theorem Semiconj.mapsTo_periodicPts {g : \u03b1 \u2192 \u03b2} (h : Semiconj g fa fb) :\n    MapsTo g (periodicPts fa) (periodicPts fb)", "start": [262, 1], "end": [263, 89], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod", "code": "def minimalPeriod (f : \u03b1 \u2192 \u03b1) (x : \u03b1) :=\n  if h : x \u2208 periodicPts f then Nat.find h else 0", "start": [270, 1], "end": [273, 50], "kind": "commanddeclaration"}, {"full_name": "Function.isPeriodicPt_minimalPeriod", "code": "theorem isPeriodicPt_minimalPeriod (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : IsPeriodicPt f (minimalPeriod f x) x", "start": [276, 1], "end": [280, 32], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_minimalPeriod", "code": "@[simp]\ntheorem iterate_minimalPeriod : f^[minimalPeriod f x] x = x", "start": [283, 1], "end": [285, 33], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_add_minimalPeriod_eq", "code": "@[simp]\ntheorem iterate_add_minimalPeriod_eq : f^[n + minimalPeriod f x] x = f^[n] x", "start": [288, 1], "end": [292, 39], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_mod_minimalPeriod_eq", "code": "@[simp]\ntheorem iterate_mod_minimalPeriod_eq : f^[n % minimalPeriod f x] x = f^[n] x", "start": [295, 1], "end": [297, 55], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_pos_of_mem_periodicPts", "code": "theorem minimalPeriod_pos_of_mem_periodicPts (hx : x \u2208 periodicPts f) : 0 < minimalPeriod f x", "start": [300, 1], "end": [301, 65], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_zero_of_nmem_periodicPts", "code": "theorem minimalPeriod_eq_zero_of_nmem_periodicPts (hx : x \u2209 periodicPts f) :\n    minimalPeriod f x = 0", "start": [304, 1], "end": [305, 70], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.minimalPeriod_pos", "code": "theorem IsPeriodicPt.minimalPeriod_pos (hn : 0 < n) (hx : IsPeriodicPt f n x) :\n    0 < minimalPeriod f x", "start": [308, 1], "end": [310, 67], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_pos_iff_mem_periodicPts", "code": "theorem minimalPeriod_pos_iff_mem_periodicPts : 0 < minimalPeriod f x \u2194 x \u2208 periodicPts f", "start": [313, 1], "end": [315, 42], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_zero_iff_nmem_periodicPts", "code": "theorem minimalPeriod_eq_zero_iff_nmem_periodicPts : minimalPeriod f x = 0 \u2194 x \u2209 periodicPts f", "start": [318, 1], "end": [319, 75], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.minimalPeriod_le", "code": "theorem IsPeriodicPt.minimalPeriod_le (hn : 0 < n) (hx : IsPeriodicPt f n x) :\n    minimalPeriod f x \u2264 n", "start": [322, 1], "end": [325, 58], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_apply_iterate", "code": "theorem minimalPeriod_apply_iterate (hx : x \u2208 periodicPts f) (n : \u2115) :\n    minimalPeriod f (f^[n] x) = minimalPeriod f x", "start": [328, 1], "end": [337, 38], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_apply", "code": "theorem minimalPeriod_apply (hx : x \u2208 periodicPts f) : minimalPeriod f (f x) = minimalPeriod f x", "start": [340, 1], "end": [341, 35], "kind": "commanddeclaration"}, {"full_name": "Function.le_of_lt_minimalPeriod_of_iterate_eq", "code": "theorem le_of_lt_minimalPeriod_of_iterate_eq {m n : \u2115} (hm : m < minimalPeriod f x)\n    (hmn : f^[m] x = f^[n] x) : m \u2264 n", "start": [344, 1], "end": [353, 9], "kind": "commanddeclaration"}, {"full_name": "Function.eq_of_lt_minimalPeriod_of_iterate_eq", "code": "theorem eq_of_lt_minimalPeriod_of_iterate_eq {m n : \u2115} (hm : m < minimalPeriod f x)\n    (hn : n < minimalPeriod f x) (hmn : f^[m] x = f^[n] x) : m = n", "start": [356, 1], "end": [359, 55], "kind": "commanddeclaration"}, {"full_name": "Function.eq_iff_lt_minimalPeriod_of_iterate_eq", "code": "theorem eq_iff_lt_minimalPeriod_of_iterate_eq {m n : \u2115} (hm : m < minimalPeriod f x)\n    (hn : n < minimalPeriod f x) : f^[m] x = f^[n] x \u2194 m = n", "start": [362, 1], "end": [364, 78], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_id", "code": "theorem minimalPeriod_id : minimalPeriod id x = 1", "start": [367, 1], "end": [369, 77], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_one_iff_isFixedPt", "code": "theorem minimalPeriod_eq_one_iff_isFixedPt : minimalPeriod f x = 1 \u2194 IsFixedPt f x", "start": [372, 1], "end": [380, 79], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.eq_zero_of_lt_minimalPeriod", "code": "theorem IsPeriodicPt.eq_zero_of_lt_minimalPeriod (hx : IsPeriodicPt f n x)\n    (hn : n < minimalPeriod f x) : n = 0", "start": [383, 1], "end": [386, 97], "kind": "commanddeclaration"}, {"full_name": "Function.not_isPeriodicPt_of_pos_of_lt_minimalPeriod", "code": "theorem not_isPeriodicPt_of_pos_of_lt_minimalPeriod :\n    \u2200 {n : \u2115} (_ : n \u2260 0) (_ : n < minimalPeriod f x), \u00acIsPeriodicPt f n x", "start": [389, 1], "end": [392, 85], "kind": "commanddeclaration"}, {"full_name": "Function.IsPeriodicPt.minimalPeriod_dvd", "code": "theorem IsPeriodicPt.minimalPeriod_dvd (hx : IsPeriodicPt f n x) : minimalPeriod f x \u2223 n", "start": [395, 1], "end": [400, 49], "kind": "commanddeclaration"}, {"full_name": "Function.isPeriodicPt_iff_minimalPeriod_dvd", "code": "theorem isPeriodicPt_iff_minimalPeriod_dvd : IsPeriodicPt f n x \u2194 minimalPeriod f x \u2223 n", "start": [403, 1], "end": [404, 90], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_minimalPeriod_iff", "code": "theorem minimalPeriod_eq_minimalPeriod_iff {g : \u03b2 \u2192 \u03b2} {y : \u03b2} :\n    minimalPeriod f x = minimalPeriod g y \u2194 \u2200 n, IsPeriodicPt f n x \u2194 IsPeriodicPt g n y", "start": [409, 1], "end": [411, 65], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_prime", "code": "theorem minimalPeriod_eq_prime {p : \u2115} [hp : Fact p.Prime] (hper : IsPeriodicPt f p x)\n    (hfix : \u00acIsFixedPt f x) : minimalPeriod f x = p", "start": [414, 1], "end": [417, 51], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_eq_prime_pow", "code": "theorem minimalPeriod_eq_prime_pow {p k : \u2115} [hp : Fact p.Prime] (hk : \u00acIsPeriodicPt f (p ^ k) x)\n    (hk1 : IsPeriodicPt f (p ^ (k + 1)) x) : minimalPeriod f x = p ^ (k + 1)", "start": [420, 1], "end": [423, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.minimalPeriod_of_comp_dvd_lcm", "code": "theorem Commute.minimalPeriod_of_comp_dvd_lcm {g : \u03b1 \u2192 \u03b1} (h : Commute f g) :\n    minimalPeriod (f \u2218 g) x \u2223 Nat.lcm (minimalPeriod f x) (minimalPeriod g x)", "start": [426, 1], "end": [429, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.minimalPeriod_of_comp_dvd_mul", "code": "theorem Commute.minimalPeriod_of_comp_dvd_mul {g : \u03b1 \u2192 \u03b1} (h : Commute f g) :\n    minimalPeriod (f \u2218 g) x \u2223 minimalPeriod f x * minimalPeriod g x", "start": [432, 1], "end": [434, 62], "kind": "commanddeclaration"}, {"full_name": "Function.Commute.minimalPeriod_of_comp_eq_mul_of_coprime", "code": "theorem Commute.minimalPeriod_of_comp_eq_mul_of_coprime {g : \u03b1 \u2192 \u03b1} (h : Commute f g)\n    (hco : Coprime (minimalPeriod f x) (minimalPeriod g x)) :\n    minimalPeriod (f \u2218 g) x = minimalPeriod f x * minimalPeriod g x", "start": [437, 1], "end": [450, 55], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_iterate_eq_div_gcd_aux", "code": "private theorem minimalPeriod_iterate_eq_div_gcd_aux (h : 0 < gcd (minimalPeriod f x) n) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n", "start": [453, 1], "end": [466, 41], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_iterate_eq_div_gcd", "code": "theorem minimalPeriod_iterate_eq_div_gcd (h : n \u2260 0) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n", "start": [468, 1], "end": [470, 88], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_iterate_eq_div_gcd'", "code": "theorem minimalPeriod_iterate_eq_div_gcd' (h : x \u2208 periodicPts f) :\n    minimalPeriod f^[n] x = minimalPeriod f x / Nat.gcd (minimalPeriod f x) n", "start": [473, 1], "end": [476, 72], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit", "code": "def periodicOrbit (f : \u03b1 \u2192 \u03b1) (x : \u03b1) : Cycle \u03b1 :=\n  (List.range (minimalPeriod f x)).map fun n => f^[n] x", "start": [479, 1], "end": [484, 56], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_def", "code": "theorem periodicOrbit_def (f : \u03b1 \u2192 \u03b1) (x : \u03b1) :\n    periodicOrbit f x = (List.range (minimalPeriod f x)).map fun n => f^[n] x", "start": [487, 1], "end": [490, 6], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_eq_cycle_map", "code": "theorem periodicOrbit_eq_cycle_map (f : \u03b1 \u2192 \u03b1) (x : \u03b1) :\n    periodicOrbit f x = (List.range (minimalPeriod f x) : Cycle \u2115).map fun n => f^[n] x", "start": [493, 1], "end": [496, 6], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_length", "code": "@[simp]\ntheorem periodicOrbit_length : (periodicOrbit f x).length = minimalPeriod f x", "start": [499, 1], "end": [501, 75], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_eq_nil_iff_not_periodic_pt", "code": "@[simp]\ntheorem periodicOrbit_eq_nil_iff_not_periodic_pt :\n    periodicOrbit f x = Cycle.nil \u2194 x \u2209 periodicPts f", "start": [504, 1], "end": [508, 51], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_eq_nil_of_not_periodic_pt", "code": "theorem periodicOrbit_eq_nil_of_not_periodic_pt (h : x \u2209 periodicPts f) :\n    periodicOrbit f x = Cycle.nil", "start": [511, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "Function.mem_periodicOrbit_iff", "code": "@[simp]\ntheorem mem_periodicOrbit_iff (hx : x \u2208 periodicPts f) :\n    y \u2208 periodicOrbit f x \u2194 \u2203 n, f^[n] x = y", "start": [516, 1], "end": [523, 36], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_mem_periodicOrbit", "code": "@[simp]\ntheorem iterate_mem_periodicOrbit (hx : x \u2208 periodicPts f) (n : \u2115) :\n    f^[n] x \u2208 periodicOrbit f x", "start": [526, 1], "end": [529, 40], "kind": "commanddeclaration"}, {"full_name": "Function.self_mem_periodicOrbit", "code": "@[simp]\ntheorem self_mem_periodicOrbit (hx : x \u2208 periodicPts f) : x \u2208 periodicOrbit f x", "start": [532, 1], "end": [534, 33], "kind": "commanddeclaration"}, {"full_name": "Function.nodup_periodicOrbit", "code": "theorem nodup_periodicOrbit : (periodicOrbit f x).Nodup", "start": [537, 1], "end": [541, 59], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_apply_iterate_eq", "code": "theorem periodicOrbit_apply_iterate_eq (hx : x \u2208 periodicPts f) (n : \u2115) :\n    periodicOrbit f (f^[n] x) = periodicOrbit f x", "start": [545, 1], "end": [552, 55], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_apply_eq", "code": "theorem periodicOrbit_apply_eq (hx : x \u2208 periodicPts f) :\n    periodicOrbit f (f x) = periodicOrbit f x", "start": [555, 1], "end": [557, 38], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_chain", "code": "theorem periodicOrbit_chain (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {f : \u03b1 \u2192 \u03b1} {x : \u03b1} :\n    (periodicOrbit f x).Chain r \u2194 \u2200 n < minimalPeriod f x, r (f^[n] x) (f^[n + 1] x)", "start": [560, 1], "end": [576, 9], "kind": "commanddeclaration"}, {"full_name": "Function.periodicOrbit_chain'", "code": "theorem periodicOrbit_chain' (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {f : \u03b1 \u2192 \u03b1} {x : \u03b1} (hx : x \u2208 periodicPts f) :\n    (periodicOrbit f x).Chain r \u2194 \u2200 n, r (f^[n] x) (f^[n + 1] x)", "start": [579, 1], "end": [585, 65], "kind": "commanddeclaration"}, {"full_name": "Function.iterate_prod_map", "code": "@[simp]\ntheorem iterate_prod_map (f : \u03b1 \u2192 \u03b1) (g : \u03b2 \u2192 \u03b2) (n : \u2115) :\n    (Prod.map f g)^[n] = Prod.map (f^[n]) (g^[n])", "start": [596, 1], "end": [598, 100], "kind": "commanddeclaration"}, {"full_name": "Function.isFixedPt_prod_map", "code": "@[simp]\ntheorem isFixedPt_prod_map (x : \u03b1 \u00d7 \u03b2) :\n    IsFixedPt (Prod.map f g) x \u2194 IsFixedPt f x.1 \u2227 IsFixedPt g x.2", "start": [601, 1], "end": [604, 15], "kind": "commanddeclaration"}, {"full_name": "Function.isPeriodicPt_prod_map", "code": "@[simp]\ntheorem isPeriodicPt_prod_map (x : \u03b1 \u00d7 \u03b2) :\n    IsPeriodicPt (Prod.map f g) n x \u2194 IsPeriodicPt f n x.1 \u2227 IsPeriodicPt g n x.2", "start": [607, 1], "end": [610, 22], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_prod_map", "code": "theorem minimalPeriod_prod_map (f : \u03b1 \u2192 \u03b1) (g : \u03b2 \u2192 \u03b2) (x : \u03b1 \u00d7 \u03b2) :\n    minimalPeriod (Prod.map f g) x = (minimalPeriod f x.1).lcm (minimalPeriod g x.2)", "start": [613, 1], "end": [615, 95], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_fst_dvd", "code": "theorem minimalPeriod_fst_dvd : minimalPeriod f x.1 \u2223 minimalPeriod (Prod.map f g) x", "start": [618, 1], "end": [619, 58], "kind": "commanddeclaration"}, {"full_name": "Function.minimalPeriod_snd_dvd", "code": "theorem minimalPeriod_snd_dvd : minimalPeriod g x.2 \u2223 minimalPeriod (Prod.map f g) x", "start": [622, 1], "end": [623, 59], "kind": "commanddeclaration"}, {"full_name": "MulAction.pow_smul_eq_iff_minimalPeriod_dvd", "code": "@[to_additive]\ntheorem pow_smul_eq_iff_minimalPeriod_dvd {n : \u2115} :\n    a ^ n \u2022 b = b \u2194 Function.minimalPeriod ((\u00b7 \u2022 \u00b7) a) b \u2223 n", "start": [634, 1], "end": [637, 83], "kind": "commanddeclaration"}, {"full_name": "MulAction.zpow_smul_eq_iff_minimalPeriod_dvd", "code": "@[to_additive]\ntheorem zpow_smul_eq_iff_minimalPeriod_dvd {n : \u2124} :\n    a ^ n \u2022 b = b \u2194 (Function.minimalPeriod ((\u00b7 \u2022 \u00b7) a) b : \u2124) \u2223 n", "start": [641, 1], "end": [647, 41], "kind": "commanddeclaration"}, {"full_name": "MulAction.pow_smul_mod_minimalPeriod", "code": "@[to_additive (attr := simp)]\ntheorem pow_smul_mod_minimalPeriod (n : \u2115) :\n    a ^ (n % Function.minimalPeriod ((\u00b7 \u2022 \u00b7) a) b) \u2022 b = a ^ n \u2022 b", "start": [653, 1], "end": [658, 65], "kind": "commanddeclaration"}, {"full_name": "MulAction.zpow_smul_mod_minimalPeriod", "code": "@[to_additive (attr := simp)]\ntheorem zpow_smul_mod_minimalPeriod (n : \u2124) :\n    a ^ (n % (Function.minimalPeriod ((\u00b7 \u2022 \u00b7) a) b : \u2124)) \u2022 b = a ^ n \u2022 b", "start": [662, 1], "end": [667, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/MulAction.lean", "imports": ["Mathlib/Algebra/AddTorsor.lean", "Mathlib/GroupTheory/GroupAction/Prod.lean", "Mathlib/Topology/Algebra/Constructions.lean", "Mathlib/Topology/Algebra/ConstMulAction.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousSMul", "code": "class ContinuousSMul (M X : Type*) [SMul M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  \n  continuous_smul : Continuous fun p : M \u00d7 X => p.1 \u2022 p.2", "start": [44, 1], "end": [50, 58], "kind": "commanddeclaration"}, {"full_name": "ContinuousVAdd", "code": "class ContinuousVAdd (M X : Type*) [VAdd M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  \n  continuous_vadd : Continuous fun p : M \u00d7 X => p.1 +\u1d65 p.2", "start": [55, 1], "end": [61, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousSMul.continuousConstSMul", "code": "@[to_additive]\ninstance (priority := 100) ContinuousSMul.continuousConstSMul : ContinuousConstSMul M X where\n  continuous_const_smul _ := continuous_smul.comp (continuous_const.prod_mk continuous_id)", "start": [76, 1], "end": [78, 91], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.smul", "code": "@[to_additive]\ntheorem Filter.Tendsto.smul {f : \u03b1 \u2192 M} {g : \u03b1 \u2192 X} {l : Filter \u03b1} {c : M} {a : X}\n    (hf : Tendsto f l (\ud835\udcdd c)) (hg : Tendsto g l (\ud835\udcdd a)) :\n    Tendsto (fun x => f x \u2022 g x) l (\ud835\udcdd <| c \u2022 a)", "start": [82, 1], "end": [86, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.smul_const", "code": "@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : \u03b1 \u2192 M} {l : Filter \u03b1} {c : M} (hf : Tendsto f l (\ud835\udcdd c))\n    (a : X) : Tendsto (fun x => f x \u2022 a) l (\ud835\udcdd (c \u2022 a))", "start": [90, 1], "end": [93, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.smul", "code": "@[to_additive]\ntheorem ContinuousWithinAt.smul (hf : ContinuousWithinAt f s b) (hg : ContinuousWithinAt g s b) :\n    ContinuousWithinAt (fun x => f x \u2022 g x) s b", "start": [99, 1], "end": [102, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.smul", "code": "@[to_additive]\ntheorem ContinuousAt.smul (hf : ContinuousAt f b) (hg : ContinuousAt g b) :\n    ContinuousAt (fun x => f x \u2022 g x) b", "start": [106, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.smul", "code": "@[to_additive]\ntheorem ContinuousOn.smul (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x \u2022 g x) s", "start": [113, 1], "end": [115, 80], "kind": "commanddeclaration"}, {"full_name": "Continuous.smul", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x \u2022 g x", "start": [119, 1], "end": [121, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousSMul.op", "code": "@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousSMul.op [SMul M\u1d50\u1d52\u1d56 X] [IsCentralScalar M X] : ContinuousSMul M\u1d50\u1d52\u1d56 X :=\n  \u27e8by\n    suffices Continuous fun p : M \u00d7 X => MulOpposite.op p.fst \u2022 p.snd from\n      this.comp (MulOpposite.continuous_unop.prod_map continuous_id)\n    simpa only [op_smul_eq_smul] using (continuous_smul : Continuous fun p : M \u00d7 X => _)\u27e9", "start": [125, 1], "end": [132, 90], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.continuousSMul", "code": "@[to_additive]\ninstance MulOpposite.continuousSMul : ContinuousSMul M X\u1d50\u1d52\u1d56 :=\n  \u27e8MulOpposite.continuous_op.comp <|\n      continuous_smul.comp <| continuous_id.prod_map MulOpposite.continuous_unop\u27e9", "start": [136, 1], "end": [139, 82], "kind": "commanddeclaration"}, {"full_name": "Units.continuousSMul", "code": "@[to_additive]\ninstance Units.continuousSMul : ContinuousSMul M\u02e3 X where\n  continuous_smul :=\n    show Continuous ((fun p : M \u00d7 X => p.fst \u2022 p.snd) \u2218 fun p : M\u02e3 \u00d7 X => (p.1, p.2)) from\n      continuous_smul.comp ((Units.continuous_val.comp continuous_fst).prod_mk continuous_snd)", "start": [149, 1], "end": [153, 95], "kind": "commanddeclaration"}, {"full_name": "MulAction.continuousSMul_compHom", "code": "@[to_additive]\ntheorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N \u2192* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X", "start": [157, 1], "end": [165, 55], "kind": "commanddeclaration"}, {"full_name": "Submonoid.continuousSMul", "code": "@[to_additive]\ninstance Submonoid.continuousSMul {S : Submonoid M} : ContinuousSMul S X where\n  continuous_smul := (continuous_subtype_val.comp continuous_fst).smul continuous_snd", "start": [173, 1], "end": [175, 86], "kind": "commanddeclaration"}, {"full_name": "Subgroup.continuousSMul", "code": "@[to_additive]\ninstance Subgroup.continuousSMul {S : Subgroup M} : ContinuousSMul S X where\n  continuous_smul := (continuous_subtype_val.comp continuous_fst).smul continuous_snd", "start": [177, 1], "end": [179, 86], "kind": "commanddeclaration"}, {"full_name": "Prod.continuousSMul", "code": "@[to_additive]\ninstance Prod.continuousSMul [SMul M X] [SMul M Y] [ContinuousSMul M X] [ContinuousSMul M Y] :\n    ContinuousSMul M (X \u00d7 Y) :=\n  \u27e8(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk\n      (continuous_fst.smul (continuous_snd.comp continuous_snd))\u27e9", "start": [183, 1], "end": [187, 66], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_sInf", "code": "@[to_additive]\ntheorem continuousSMul_sInf {ts : Set (TopologicalSpace X)}\n    (h : \u2200 t \u2208 ts, @ContinuousSMul M X _ _ t) : @ContinuousSMul M X _ _ (sInf ts)", "start": [202, 1], "end": [213, 65], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_iInf", "code": "@[to_additive]\ntheorem continuousSMul_iInf {ts' : \u03b9 \u2192 TopologicalSpace X}\n    (h : \u2200 i, @ContinuousSMul M X _ _ (ts' i)) : @ContinuousSMul M X _ _ (\u2a05 i, ts' i)", "start": [217, 1], "end": [220, 52], "kind": "commanddeclaration"}, {"full_name": "continuousSMul_inf", "code": "@[to_additive]\ntheorem continuousSMul_inf {t\u2081 t\u2082 : TopologicalSpace X} [@ContinuousSMul M X _ _ t\u2081]\n    [@ContinuousSMul M X _ _ t\u2082] : @ContinuousSMul M X _ _ (t\u2081 \u2293 t\u2082)", "start": [224, 1], "end": [229, 25], "kind": "commanddeclaration"}, {"full_name": "AddTorsor.connectedSpace", "code": "protected theorem AddTorsor.connectedSpace : ConnectedSpace P", "start": [241, 1], "end": [249, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Pointwise.lean", "imports": ["Mathlib/Order/Filter/NAry.lean", "Mathlib/Data/Set/Pointwise/SMul.lean", "Mathlib/Order/Filter/Ultrafilter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.instOne", "code": "@[to_additive\n      \"`0 : Filter \u03b1` is defined as the filter of sets containing `0 : \u03b1` in locale `Pointwise`.\"]\nprotected def instOne : One (Filter \u03b1) :=\n  \u27e8pure 1\u27e9", "start": [71, 1], "end": [75, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_one", "code": "@[to_additive (attr := simp)]\ntheorem mem_one : s \u2208 (1 : Filter \u03b1) \u2194 (1 : \u03b1) \u2208 s", "start": [81, 1], "end": [83, 11], "kind": "commanddeclaration"}, {"full_name": "Filter.one_mem_one", "code": "@[to_additive]\ntheorem one_mem_one : (1 : Set \u03b1) \u2208 (1 : Filter \u03b1)", "start": [87, 1], "end": [89, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_one", "code": "@[to_additive (attr := simp)]\ntheorem pure_one : pure 1 = (1 : Filter \u03b1)", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.principal_one", "code": "@[to_additive (attr := simp)]\ntheorem principal_one : \ud835\udcdf 1 = (1 : Filter \u03b1)", "start": [99, 1], "end": [101, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.one_neBot", "code": "@[to_additive] theorem one_neBot : (1 : Filter \u03b1).NeBot", "start": [105, 1], "end": [107, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.map_one'", "code": "@[to_additive (attr := simp)]\nprotected theorem map_one' (f : \u03b1 \u2192 \u03b2) : (1 : Filter \u03b1).map f = pure (f 1)", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.le_one_iff", "code": "@[to_additive (attr := simp)]\ntheorem le_one_iff : f \u2264 1 \u2194 (1 : Set \u03b1) \u2208 f", "start": [119, 1], "end": [121, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.le_one_iff", "code": "@[to_additive]\nprotected theorem NeBot.le_one_iff (h : f.NeBot) : f \u2264 1 \u2194 f = 1", "start": [125, 1], "end": [127, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.eventually_one", "code": "@[to_additive (attr := simp)]\ntheorem eventually_one {p : \u03b1 \u2192 Prop} : (\u2200\u1da0 x in 1, p x) \u2194 p 1", "start": [131, 1], "end": [133, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_one", "code": "@[to_additive (attr := simp)]\ntheorem tendsto_one {a : Filter \u03b2} {f : \u03b2 \u2192 \u03b1} : Tendsto f a 1 \u2194 \u2200\u1da0 x in a, f x = 1", "start": [137, 1], "end": [139, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.one_prod_one", "code": "@[to_additive (attr := simp)]\ntheorem one_prod_one [One \u03b2] : (1 : Filter \u03b1) \u00d7\u02e2 (1 : Filter \u03b2) = 1", "start": [143, 1], "end": [145, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.pureOneHom", "code": "@[to_additive \"`pure` as a `ZeroHom`.\"]\ndef pureOneHom : OneHom \u03b1 (Filter \u03b1) where\n  toFun := pure; map_one' := pure_one", "start": [149, 1], "end": [152, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.coe_pureOneHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_pureOneHom : (pureOneHom : \u03b1 \u2192 Filter \u03b1) = pure", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.pureOneHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem pureOneHom_apply (a : \u03b1) : pureOneHom a = pure a", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.map_one", "code": "@[to_additive] protected theorem map_one [OneHomClass F \u03b1 \u03b2] (\u03c6 : F) : map \u03c6 1 = 1", "start": [170, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.instInv", "code": "@[to_additive \"The negation of a filter is the pointwise preimage under `-` of its sets.\"]\ninstance instInv : Inv (Filter \u03b1) :=\n  \u27e8map Inv.inv\u27e9", "start": [185, 1], "end": [188, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inv", "code": "@[to_additive (attr := simp)]\nprotected theorem map_inv : f.map Inv.inv = f\u207b\u00b9", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_inv", "code": "@[to_additive]\ntheorem mem_inv : s \u2208 f\u207b\u00b9 \u2194 Inv.inv \u207b\u00b9' s \u2208 f", "start": [196, 1], "end": [198, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_le_inv", "code": "@[to_additive]\nprotected theorem inv_le_inv (hf : f \u2264 g) : f\u207b\u00b9 \u2264 g\u207b\u00b9", "start": [202, 1], "end": [204, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_pure", "code": "@[to_additive (attr := simp)]\ntheorem inv_pure : (pure a : Filter \u03b1)\u207b\u00b9 = pure a\u207b\u00b9", "start": [208, 1], "end": [210, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_eq_bot_iff", "code": "@[to_additive (attr := simp)]\ntheorem inv_eq_bot_iff : f\u207b\u00b9 = \u22a5 \u2194 f = \u22a5", "start": [214, 1], "end": [216, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.neBot_inv_iff", "code": "@[to_additive (attr := simp)]\ntheorem neBot_inv_iff : f\u207b\u00b9.NeBot \u2194 NeBot f", "start": [220, 1], "end": [222, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.inv", "code": "@[to_additive]\ntheorem NeBot.inv : f.NeBot \u2192 f\u207b\u00b9.NeBot", "start": [226, 1], "end": [227, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_mem_inv", "code": "@[to_additive]\ntheorem inv_mem_inv (hs : s \u2208 f) : s\u207b\u00b9 \u2208 f\u207b\u00b9", "start": [237, 1], "end": [238, 88], "kind": "commanddeclaration"}, {"full_name": "Filter.instInvolutiveInv", "code": "@[to_additive \"Negation is involutive on `Filter \u03b1` if it is on `\u03b1`.\"]\nprotected def instInvolutiveInv : InvolutiveInv (Filter \u03b1) :=\n  { Filter.instInv with\n    inv_inv := fun f => map_map.trans <| by rw [inv_involutive.comp_self, map_id] }", "start": [242, 1], "end": [246, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_le_inv_iff", "code": "@[to_additive (attr := simp)]\nprotected theorem inv_le_inv_iff : f\u207b\u00b9 \u2264 g\u207b\u00b9 \u2194 f \u2264 g", "start": [252, 1], "end": [254, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_le_iff_le_inv", "code": "@[to_additive]\ntheorem inv_le_iff_le_inv : f\u207b\u00b9 \u2264 g \u2194 f \u2264 g\u207b\u00b9", "start": [258, 1], "end": [259, 90], "kind": "commanddeclaration"}, {"full_name": "Filter.inv_le_self", "code": "@[to_additive (attr := simp)]\ntheorem inv_le_self : f\u207b\u00b9 \u2264 f \u2194 f\u207b\u00b9 = f", "start": [263, 1], "end": [265, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.instMul", "code": "@[to_additive \"The filter `f + g` is generated by `{s + t | s \u2208 f, t \u2208 g}` in locale `Pointwise`.\"]\nprotected def instMul : Mul (Filter \u03b1) :=\n  \u27e8\n  fun f g => { map\u2082 (\u00b7 * \u00b7) f g with sets := { s | \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 * t\u2082 \u2286 s } }\u27e9", "start": [278, 1], "end": [283, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_mul", "code": "@[to_additive (attr := simp)]\ntheorem map\u2082_mul : map\u2082 (\u00b7 * \u00b7) f g = f * g", "start": [289, 1], "end": [291, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_mul", "code": "@[to_additive]\ntheorem mem_mul : s \u2208 f * g \u2194 \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 * t\u2082 \u2286 s", "start": [295, 1], "end": [297, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_mem_mul", "code": "@[to_additive]\ntheorem mul_mem_mul : s \u2208 f \u2192 t \u2208 g \u2192 s * t \u2208 f * g", "start": [301, 1], "end": [303, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_mul", "code": "@[to_additive (attr := simp)]\ntheorem bot_mul : \u22a5 * g = \u22a5", "start": [307, 1], "end": [309, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_bot", "code": "@[to_additive (attr := simp)]\ntheorem mul_bot : f * \u22a5 = \u22a5", "start": [313, 1], "end": [315, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_eq_bot_iff", "code": "@[to_additive (attr := simp)]\ntheorem mul_eq_bot_iff : f * g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [319, 1], "end": [321, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_neBot_iff", "code": "@[to_additive (attr := simp)] lemma mul_neBot_iff : (f * g).NeBot \u2194 f.NeBot \u2227 g.NeBot :=\n  map\u2082_neBot_iff", "start": [325, 1], "end": [327, 17], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.NeBot.mul", "code": "@[to_additive]\ntheorem NeBot.mul : NeBot f \u2192 NeBot g \u2192 NeBot (f * g)", "start": [331, 1], "end": [333, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_mul_left", "code": "@[to_additive]\ntheorem NeBot.of_mul_left : (f * g).NeBot \u2192 f.NeBot", "start": [337, 1], "end": [339, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_mul_right", "code": "@[to_additive]\ntheorem NeBot.of_mul_right : (f * g).NeBot \u2192 g.NeBot", "start": [343, 1], "end": [345, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_mul", "code": "@[to_additive (attr := simp)]\ntheorem pure_mul : pure a * g = g.map ((\u00b7 * \u00b7) a)", "start": [349, 1], "end": [351, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_pure", "code": "@[to_additive (attr := simp)]\ntheorem mul_pure : f * pure b = f.map (\u00b7 * b)", "start": [355, 1], "end": [357, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_mul_pure", "code": "@[to_additive] theorem pure_mul_pure : (pure a : Filter \u03b1) * pure b = pure (a * b)", "start": [361, 1], "end": [363, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.le_mul_iff", "code": "@[to_additive (attr := simp)]\ntheorem le_mul_iff : h \u2264 f * g \u2194 \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2200 \u2983t\u2984, t \u2208 g \u2192 s * t \u2208 h", "start": [367, 1], "end": [369, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_mul", "code": "@[to_additive]\ninstance covariant_mul : CovariantClass (Filter \u03b1) (Filter \u03b1) (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => map\u2082_mono_left\u27e9", "start": [373, 1], "end": [375, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_swap_mul", "code": "@[to_additive]\ninstance covariant_swap_mul : CovariantClass (Filter \u03b1) (Filter \u03b1) (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => map\u2082_mono_right\u27e9", "start": [379, 1], "end": [381, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map_mul", "code": "@[to_additive]\nprotected theorem map_mul [MulHomClass F \u03b1 \u03b2] (m : F) : (f\u2081 * f\u2082).map m = f\u2081.map m * f\u2082.map m", "start": [385, 1], "end": [387, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.pureMulHom", "code": "@[to_additive \"The singleton operation as an `AddHom`.\"]\ndef pureMulHom : \u03b1 \u2192\u2099* Filter \u03b1 where\n  toFun := pure; map_mul' _ _ := pure_mul_pure.symm", "start": [391, 1], "end": [394, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.coe_pureMulHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_pureMulHom : (pureMulHom : \u03b1 \u2192 Filter \u03b1) = pure", "start": [398, 1], "end": [400, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.pureMulHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem pureMulHom_apply (a : \u03b1) : pureMulHom a = pure a", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.instDiv", "code": "@[to_additive \"The filter `f - g` is generated by `{s - t | s \u2208 f, t \u2208 g}` in locale `Pointwise`.\"]\nprotected def instDiv : Div (Filter \u03b1) :=\n  \u27e8\n  fun f g => { map\u2082 (\u00b7 / \u00b7) f g with sets := { s | \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 / t\u2082 \u2286 s } }\u27e9", "start": [419, 1], "end": [424, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_div", "code": "@[to_additive (attr := simp)]\ntheorem map\u2082_div : map\u2082 (\u00b7 / \u00b7) f g = f / g", "start": [430, 1], "end": [432, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_div", "code": "@[to_additive]\ntheorem mem_div : s \u2208 f / g \u2194 \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 / t\u2082 \u2286 s", "start": [436, 1], "end": [438, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.div_mem_div", "code": "@[to_additive]\ntheorem div_mem_div : s \u2208 f \u2192 t \u2208 g \u2192 s / t \u2208 f / g", "start": [442, 1], "end": [444, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_div", "code": "@[to_additive (attr := simp)]\ntheorem bot_div : \u22a5 / g = \u22a5", "start": [448, 1], "end": [450, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.div_bot", "code": "@[to_additive (attr := simp)]\ntheorem div_bot : f / \u22a5 = \u22a5", "start": [454, 1], "end": [456, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.div_eq_bot_iff", "code": "@[to_additive (attr := simp)]\ntheorem div_eq_bot_iff : f / g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [460, 1], "end": [462, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.div_neBot_iff", "code": "@[to_additive (attr := simp)] theorem div_neBot_iff : (f / g).NeBot \u2194 f.NeBot \u2227 g.NeBot", "start": [466, 1], "end": [468, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.div", "code": "@[to_additive]\ntheorem NeBot.div : NeBot f \u2192 NeBot g \u2192 NeBot (f / g)", "start": [472, 1], "end": [474, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_div_left", "code": "@[to_additive]\ntheorem NeBot.of_div_left : (f / g).NeBot \u2192 f.NeBot", "start": [478, 1], "end": [480, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_div_right", "code": "@[to_additive]\ntheorem NeBot.of_div_right : (f / g).NeBot \u2192 g.NeBot", "start": [484, 1], "end": [486, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_div", "code": "@[to_additive (attr := simp)]\ntheorem pure_div : pure a / g = g.map ((\u00b7 / \u00b7) a)", "start": [490, 1], "end": [492, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.div_pure", "code": "@[to_additive (attr := simp)]\ntheorem div_pure : f / pure b = f.map (\u00b7 / b)", "start": [496, 1], "end": [498, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_div_pure", "code": "@[to_additive] theorem pure_div_pure : (pure a : Filter \u03b1) / pure b = pure (a / b)", "start": [502, 1], "end": [504, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.div_le_div", "code": "@[to_additive]\nprotected theorem div_le_div : f\u2081 \u2264 f\u2082 \u2192 g\u2081 \u2264 g\u2082 \u2192 f\u2081 / g\u2081 \u2264 f\u2082 / g\u2082", "start": [508, 1], "end": [510, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.div_le_div_left", "code": "@[to_additive]\nprotected theorem div_le_div_left : g\u2081 \u2264 g\u2082 \u2192 f / g\u2081 \u2264 f / g\u2082", "start": [514, 1], "end": [516, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.div_le_div_right", "code": "@[to_additive]\nprotected theorem div_le_div_right : f\u2081 \u2264 f\u2082 \u2192 f\u2081 / g \u2264 f\u2082 / g", "start": [520, 1], "end": [522, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.le_div_iff", "code": "@[to_additive (attr := simp)]\nprotected theorem le_div_iff : h \u2264 f / g \u2194 \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2200 \u2983t\u2984, t \u2208 g \u2192 s / t \u2208 h", "start": [526, 1], "end": [528, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_div", "code": "@[to_additive]\ninstance covariant_div : CovariantClass (Filter \u03b1) (Filter \u03b1) (\u00b7 / \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => map\u2082_mono_left\u27e9", "start": [532, 1], "end": [534, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_swap_div", "code": "@[to_additive]\ninstance covariant_swap_div : CovariantClass (Filter \u03b1) (Filter \u03b1) (swap (\u00b7 / \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => map\u2082_mono_right\u27e9", "start": [538, 1], "end": [540, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.instNSMul", "code": "protected def instNSMul [Zero \u03b1] [Add \u03b1] : SMul \u2115 (Filter \u03b1) :=\n  \u27e8nsmulRec\u27e9", "start": [548, 1], "end": [551, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.instNPow", "code": "@[to_additive existing]\nprotected def instNPow [One \u03b1] [Mul \u03b1] : Pow (Filter \u03b1) \u2115 :=\n  \u27e8fun s n => npowRec n s\u27e9", "start": [554, 1], "end": [558, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.instZSMul", "code": "protected def instZSMul [Zero \u03b1] [Add \u03b1] [Neg \u03b1] : SMul \u2124 (Filter \u03b1) :=\n  \u27e8zsmulRec\u27e9", "start": [561, 1], "end": [564, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.instZPow", "code": "@[to_additive existing]\nprotected def instZPow [One \u03b1] [Mul \u03b1] [Inv \u03b1] : Pow (Filter \u03b1) \u2124 :=\n  \u27e8fun s n => zpowRec n s\u27e9", "start": [567, 1], "end": [571, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.semigroup", "code": "@[to_additive \"`Filter \u03b1` is an `AddSemigroup` under pointwise operations if `\u03b1` is.\"]\nprotected def semigroup [Semigroup \u03b1] : Semigroup (Filter \u03b1) where\n  mul := (\u00b7 * \u00b7)\n  mul_assoc _ _ _ := map\u2082_assoc mul_assoc", "start": [577, 1], "end": [581, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.commSemigroup", "code": "@[to_additive \"`Filter \u03b1` is an `AddCommSemigroup` under pointwise operations if `\u03b1` is.\"]\nprotected def commSemigroup [CommSemigroup \u03b1] : CommSemigroup (Filter \u03b1) :=\n  { Filter.semigroup with mul_comm := fun _ _ => map\u2082_comm mul_comm }", "start": [585, 1], "end": [588, 70], "kind": "commanddeclaration"}, {"full_name": "Filter.mulOneClass", "code": "@[to_additive \"`Filter \u03b1` is an `AddZeroClass` under pointwise operations if `\u03b1` is.\"]\nprotected def mulOneClass : MulOneClass (Filter \u03b1) where\n  one := 1\n  mul := (\u00b7 * \u00b7)\n  one_mul := map\u2082_left_identity one_mul\n  mul_one := map\u2082_right_identity mul_one", "start": [596, 1], "end": [602, 41], "kind": "commanddeclaration"}, {"full_name": "Filter.mapMonoidHom", "code": "@[to_additive \"If `\u03c6 : \u03b1 \u2192+ \u03b2` then `mapAddMonoidHom \u03c6` is the monoid homomorphism\n `Filter \u03b1 \u2192+ Filter \u03b2` induced by `map \u03c6`.\"]\ndef mapMonoidHom [MonoidHomClass F \u03b1 \u03b2] (\u03c6 : F) : Filter \u03b1 \u2192* Filter \u03b2 where\n  toFun := map \u03c6\n  map_one' := Filter.map_one \u03c6\n  map_mul' _ _ := Filter.map_mul \u03c6", "start": [609, 1], "end": [616, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.comap_mul_comap_le", "code": "@[to_additive]\ntheorem comap_mul_comap_le [MulHomClass F \u03b1 \u03b2] (m : F) {f g : Filter \u03b2} :\n    f.comap m * g.comap m \u2264 (f * g).comap m", "start": [621, 1], "end": [625, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mul_mul", "code": "@[to_additive]\ntheorem Tendsto.mul_mul [MulHomClass F \u03b1 \u03b2] (m : F) {f\u2081 g\u2081 : Filter \u03b1} {f\u2082 g\u2082 : Filter \u03b2} :\n    Tendsto m f\u2081 f\u2082 \u2192 Tendsto m g\u2081 g\u2082 \u2192 Tendsto m (f\u2081 * g\u2081) (f\u2082 * g\u2082)", "start": [629, 1], "end": [632, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.pureMonoidHom", "code": "@[to_additive \"`pure` as an `AddMonoidHom`.\"]\ndef pureMonoidHom : \u03b1 \u2192* Filter \u03b1 :=\n  { pureMulHom, pureOneHom with }", "start": [636, 1], "end": [639, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.coe_pureMonoidHom", "code": "@[to_additive (attr := simp)]\ntheorem coe_pureMonoidHom : (pureMonoidHom : \u03b1 \u2192 Filter \u03b1) = pure", "start": [643, 1], "end": [645, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.pureMonoidHom_apply", "code": "@[to_additive (attr := simp)]\ntheorem pureMonoidHom_apply (a : \u03b1) : pureMonoidHom a = pure a", "start": [649, 1], "end": [651, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.monoid", "code": "@[to_additive \"`Filter \u03b1` is an `AddMonoid` under pointwise operations if `\u03b1` is.\"]\nprotected def monoid : Monoid (Filter \u03b1) :=\n  { Filter.mulOneClass, Filter.semigroup, @Filter.instNPow \u03b1 _ _ with }", "start": [661, 1], "end": [664, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.pow_mem_pow", "code": "@[to_additive]\ntheorem pow_mem_pow (hs : s \u2208 f) : \u2200 n : \u2115, s ^ n \u2208 f ^ n", "start": [670, 1], "end": [677, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_pow", "code": "@[to_additive (attr := simp) nsmul_bot]\ntheorem bot_pow {n : \u2115} (hn : n \u2260 0) : (\u22a5 : Filter \u03b1) ^ n = \u22a5", "start": [681, 1], "end": [683, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_top_of_one_le", "code": "@[to_additive]\ntheorem mul_top_of_one_le (hf : 1 \u2264 f) : f * \u22a4 = \u22a4", "start": [687, 1], "end": [692, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.top_mul_of_one_le", "code": "@[to_additive]\ntheorem top_mul_of_one_le (hf : 1 \u2264 f) : \u22a4 * f = \u22a4", "start": [696, 1], "end": [701, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.top_mul_top", "code": "@[to_additive (attr := simp)]\ntheorem top_mul_top : (\u22a4 : Filter \u03b1) * \u22a4 = \u22a4", "start": [705, 1], "end": [707, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.top_pow", "code": "@[to_additive nsmul_top]\ntheorem top_pow : \u2200 {n : \u2115}, n \u2260 0 \u2192 (\u22a4 : Filter \u03b1) ^ n = \u22a4", "start": [711, 1], "end": [715, 76], "kind": "commanddeclaration"}, {"full_name": "IsUnit.filter", "code": "@[to_additive]\nprotected theorem _root_.IsUnit.filter : IsUnit a \u2192 IsUnit (pure a : Filter \u03b1)", "start": [719, 1], "end": [721, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.commMonoid", "code": "@[to_additive \"`Filter \u03b1` is an `AddCommMonoid` under pointwise operations if `\u03b1` is.\"]\nprotected def commMonoid [CommMonoid \u03b1] : CommMonoid (Filter \u03b1) :=\n  { Filter.mulOneClass, Filter.commSemigroup with }", "start": [727, 1], "end": [730, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_eq_one_iff", "code": "@[to_additive]\nprotected theorem mul_eq_one_iff : f * g = 1 \u2194 \u2203 a b, f = pure a \u2227 g = pure b \u2227 a * b = 1", "start": [740, 1], "end": [751, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.divisionMonoid", "code": "@[to_additive subtractionMonoid \"`Filter \u03b1` is a subtraction monoid under pointwise operations if\n `\u03b1` is.\"]\nprotected def divisionMonoid : DivisionMonoid (Filter \u03b1) :=\n  { Filter.monoid, Filter.instInvolutiveInv, Filter.instDiv, Filter.instZPow (\u03b1 := \u03b1) with\n    mul_inv_rev := fun s t => map_map\u2082_antidistrib mul_inv_rev\n    inv_eq_of_mul := fun s t h => by\n      obtain \u27e8a, b, rfl, rfl, hab\u27e9 := Filter.mul_eq_one_iff.1 h\n      rw [inv_pure, inv_eq_of_mul_eq_one_right hab]\n    div_eq_mul_inv := fun f g => map_map\u2082_distrib_right div_eq_mul_inv }", "start": [755, 1], "end": [765, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.isUnit_iff", "code": "@[to_additive]\ntheorem isUnit_iff : IsUnit f \u2194 \u2203 a, f = pure a \u2227 IsUnit a", "start": [769, 1], "end": [778, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.divisionCommMonoid", "code": "@[to_additive subtractionCommMonoid\n      \"`Filter \u03b1` is a commutative subtraction monoid under pointwise operations if `\u03b1` is.\"]\nprotected def divisionCommMonoid [DivisionCommMonoid \u03b1] : DivisionCommMonoid (Filter \u03b1) :=\n  { Filter.divisionMonoid, Filter.commSemigroup with }", "start": [784, 1], "end": [788, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.instDistribNeg", "code": "protected def instDistribNeg [Mul \u03b1] [HasDistribNeg \u03b1] : HasDistribNeg (Filter \u03b1) :=\n  { Filter.instInvolutiveNeg with\n    neg_mul := fun _ _ => map\u2082_map_left_comm neg_mul\n    mul_neg := fun _ _ => map_map\u2082_right_comm mul_neg }", "start": [792, 1], "end": [796, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.mul_add_subset", "code": "theorem mul_add_subset : f * (g + h) \u2264 f * g + f * h", "start": [812, 1], "end": [813, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.add_mul_subset", "code": "theorem add_mul_subset : (f + g) * h \u2264 f * h + g * h", "start": [816, 1], "end": [817, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.mul_zero_nonneg", "code": "theorem NeBot.mul_zero_nonneg (hf : f.NeBot) : 0 \u2264 f * 0", "start": [829, 1], "end": [832, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.zero_mul_nonneg", "code": "theorem NeBot.zero_mul_nonneg (hg : g.NeBot) : 0 \u2264 0 * g", "start": [835, 1], "end": [838, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.one_le_div_iff", "code": "@[to_additive (attr := simp 1100)]\nprotected theorem one_le_div_iff : 1 \u2264 f / g \u2194 \u00acDisjoint f g", "start": [851, 1], "end": [857, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.not_one_le_div_iff", "code": "@[to_additive]\ntheorem not_one_le_div_iff : \u00ac1 \u2264 f / g \u2194 Disjoint f g", "start": [861, 1], "end": [863, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.one_le_div", "code": "@[to_additive]\ntheorem NeBot.one_le_div (h : f.NeBot) : 1 \u2264 f / f", "start": [867, 1], "end": [872, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.isUnit_pure", "code": "@[to_additive]\ntheorem isUnit_pure (a : \u03b1) : IsUnit (pure a : Filter \u03b1)", "start": [876, 1], "end": [878, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.isUnit_iff_singleton", "code": "@[simp]\ntheorem isUnit_iff_singleton : IsUnit f \u2194 \u2203 a, f = pure a", "start": [882, 1], "end": [884, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.map_inv'", "code": "@[to_additive]\ntheorem map_inv' : f\u207b\u00b9.map m = (f.map m)\u207b\u00b9", "start": [887, 1], "end": [889, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inv_inv", "code": "@[to_additive]\nprotected theorem Tendsto.inv_inv : Tendsto m f\u2081 f\u2082 \u2192 Tendsto m f\u2081\u207b\u00b9 f\u2082\u207b\u00b9", "start": [893, 1], "end": [895, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.map_div", "code": "@[to_additive]\nprotected theorem map_div : (f / g).map m = f.map m / g.map m", "start": [899, 1], "end": [901, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.div_div", "code": "@[to_additive]\nprotected theorem Tendsto.div_div (hf : Tendsto m f\u2081 f\u2082) (hg : Tendsto m g\u2081 g\u2082) :\n    Tendsto m (f\u2081 / g\u2081) (f\u2082 / g\u2082)", "start": [905, 1], "end": [908, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.div_zero_nonneg", "code": "theorem NeBot.div_zero_nonneg (hf : f.NeBot) : 0 \u2264 f / 0", "start": [920, 1], "end": [923, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.zero_div_nonneg", "code": "theorem NeBot.zero_div_nonneg (hg : g.NeBot) : 0 \u2264 0 / g", "start": [926, 1], "end": [929, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.instSMul", "code": "@[to_additive \"The filter `f +\u1d65 g` is generated by `{s +\u1d65 t | s \u2208 f, t \u2208 g}` in locale\n `Pointwise`.\"]\nprotected def instSMul : SMul (Filter \u03b1) (Filter \u03b2) :=\n  \u27e8\n  fun f g => { map\u2082 (\u00b7 \u2022 \u00b7) f g with sets := { s | \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 \u2022 t\u2082 \u2286 s } }\u27e9", "start": [942, 1], "end": [948, 95], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_smul", "code": "@[to_additive (attr := simp)]\ntheorem map\u2082_smul : map\u2082 (\u00b7 \u2022 \u00b7) f g = f \u2022 g", "start": [954, 1], "end": [956, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_smul", "code": "@[to_additive]\ntheorem mem_smul : t \u2208 f \u2022 g \u2194 \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 \u2022 t\u2082 \u2286 t", "start": [960, 1], "end": [962, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_mem_smul", "code": "@[to_additive]\ntheorem smul_mem_smul : s \u2208 f \u2192 t \u2208 g \u2192 s \u2022 t \u2208 f \u2022 g", "start": [966, 1], "end": [968, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_smul", "code": "@[to_additive (attr := simp)]\ntheorem bot_smul : (\u22a5 : Filter \u03b1) \u2022 g = \u22a5", "start": [972, 1], "end": [974, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_bot", "code": "@[to_additive (attr := simp)]\ntheorem smul_bot : f \u2022 (\u22a5 : Filter \u03b2) = \u22a5", "start": [978, 1], "end": [980, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_eq_bot_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_eq_bot_iff : f \u2022 g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [984, 1], "end": [986, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_neBot_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_neBot_iff : (f \u2022 g).NeBot \u2194 f.NeBot \u2227 g.NeBot", "start": [990, 1], "end": [992, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.smul", "code": "@[to_additive]\ntheorem NeBot.smul : NeBot f \u2192 NeBot g \u2192 NeBot (f \u2022 g)", "start": [996, 1], "end": [998, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_smul_left", "code": "@[to_additive]\ntheorem NeBot.of_smul_left : (f \u2022 g).NeBot \u2192 f.NeBot", "start": [1002, 1], "end": [1004, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_smul_right", "code": "@[to_additive]\ntheorem NeBot.of_smul_right : (f \u2022 g).NeBot \u2192 g.NeBot", "start": [1008, 1], "end": [1010, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_smul", "code": "@[to_additive (attr := simp)]\ntheorem pure_smul : (pure a : Filter \u03b1) \u2022 g = g.map ((\u00b7 \u2022 \u00b7) a)", "start": [1014, 1], "end": [1016, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_pure", "code": "@[to_additive (attr := simp)]\ntheorem smul_pure : f \u2022 pure b = f.map (\u00b7 \u2022 b)", "start": [1020, 1], "end": [1022, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_smul_pure", "code": "@[to_additive] theorem pure_smul_pure : (pure a : Filter \u03b1) \u2022 (pure b : Filter \u03b2) = pure (a \u2022 b)", "start": [1026, 1], "end": [1028, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_le_smul", "code": "@[to_additive]\ntheorem smul_le_smul : f\u2081 \u2264 f\u2082 \u2192 g\u2081 \u2264 g\u2082 \u2192 f\u2081 \u2022 g\u2081 \u2264 f\u2082 \u2022 g\u2082", "start": [1032, 1], "end": [1034, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_le_smul_left", "code": "@[to_additive]\ntheorem smul_le_smul_left : g\u2081 \u2264 g\u2082 \u2192 f \u2022 g\u2081 \u2264 f \u2022 g\u2082", "start": [1038, 1], "end": [1040, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_le_smul_right", "code": "@[to_additive]\ntheorem smul_le_smul_right : f\u2081 \u2264 f\u2082 \u2192 f\u2081 \u2022 g \u2264 f\u2082 \u2022 g", "start": [1044, 1], "end": [1046, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.le_smul_iff", "code": "@[to_additive (attr := simp)]\ntheorem le_smul_iff : h \u2264 f \u2022 g \u2194 \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2200 \u2983t\u2984, t \u2208 g \u2192 s \u2022 t \u2208 h", "start": [1050, 1], "end": [1052, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_smul", "code": "@[to_additive]\ninstance covariant_smul : CovariantClass (Filter \u03b1) (Filter \u03b2) (\u00b7 \u2022 \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ _ _ => map\u2082_mono_left\u27e9", "start": [1056, 1], "end": [1058, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.instVSub", "code": "protected def instVSub : VSub (Filter \u03b1) (Filter \u03b2) :=\n  \u27e8\n  fun f g => { map\u2082 (\u00b7 -\u1d65 \u00b7) f g with sets := { s | \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 -\u1d65 t\u2082 \u2286 s } }\u27e9", "start": [1071, 1], "end": [1075, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.map\u2082_vsub", "code": "@[simp]\ntheorem map\u2082_vsub : map\u2082 (\u00b7 -\u1d65 \u00b7) f g = f -\u1d65 g", "start": [1080, 1], "end": [1082, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_vsub", "code": "theorem mem_vsub {s : Set \u03b1} : s \u2208 f -\u1d65 g \u2194 \u2203 t\u2081 t\u2082, t\u2081 \u2208 f \u2227 t\u2082 \u2208 g \u2227 t\u2081 -\u1d65 t\u2082 \u2286 s", "start": [1085, 1], "end": [1086, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_mem_vsub", "code": "theorem vsub_mem_vsub : s \u2208 f \u2192 t \u2208 g \u2192 s -\u1d65 t \u2208 f -\u1d65 g", "start": [1089, 1], "end": [1090, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.bot_vsub", "code": "@[simp]\ntheorem bot_vsub : (\u22a5 : Filter \u03b2) -\u1d65 g = \u22a5", "start": [1093, 1], "end": [1095, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_bot", "code": "@[simp]\ntheorem vsub_bot : f -\u1d65 (\u22a5 : Filter \u03b2) = \u22a5", "start": [1098, 1], "end": [1100, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_eq_bot_iff", "code": "@[simp]\ntheorem vsub_eq_bot_iff : f -\u1d65 g = \u22a5 \u2194 f = \u22a5 \u2228 g = \u22a5", "start": [1103, 1], "end": [1105, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_neBot_iff", "code": "@[simp]\ntheorem vsub_neBot_iff : (f -\u1d65 g : Filter \u03b1).NeBot \u2194 f.NeBot \u2227 g.NeBot", "start": [1108, 1], "end": [1110, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.vsub", "code": "theorem NeBot.vsub : NeBot f \u2192 NeBot g \u2192 NeBot (f -\u1d65 g)", "start": [1113, 1], "end": [1114, 13], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_vsub_left", "code": "theorem NeBot.of_vsub_left : (f -\u1d65 g : Filter \u03b1).NeBot \u2192 f.NeBot", "start": [1117, 1], "end": [1118, 21], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_vsub_right", "code": "theorem NeBot.of_vsub_right : (f -\u1d65 g : Filter \u03b1).NeBot \u2192 g.NeBot", "start": [1121, 1], "end": [1122, 22], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_vsub", "code": "@[simp]\ntheorem pure_vsub : (pure a : Filter \u03b2) -\u1d65 g = g.map ((\u00b7 -\u1d65 \u00b7) a)", "start": [1125, 1], "end": [1127, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_pure", "code": "@[simp]\ntheorem vsub_pure : f -\u1d65 pure b = f.map (\u00b7 -\u1d65 b)", "start": [1130, 1], "end": [1132, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.pure_vsub_pure", "code": "theorem pure_vsub_pure : (pure a : Filter \u03b2) -\u1d65 pure b = (pure (a -\u1d65 b) : Filter \u03b1)", "start": [1136, 1], "end": [1137, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_le_vsub", "code": "theorem vsub_le_vsub : f\u2081 \u2264 f\u2082 \u2192 g\u2081 \u2264 g\u2082 \u2192 f\u2081 -\u1d65 g\u2081 \u2264 f\u2082 -\u1d65 g\u2082", "start": [1140, 1], "end": [1141, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_le_vsub_left", "code": "theorem vsub_le_vsub_left : g\u2081 \u2264 g\u2082 \u2192 f -\u1d65 g\u2081 \u2264 f -\u1d65 g\u2082", "start": [1144, 1], "end": [1145, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.vsub_le_vsub_right", "code": "theorem vsub_le_vsub_right : f\u2081 \u2264 f\u2082 \u2192 f\u2081 -\u1d65 g \u2264 f\u2082 -\u1d65 g", "start": [1148, 1], "end": [1149, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.le_vsub_iff", "code": "@[simp]\ntheorem le_vsub_iff : h \u2264 f -\u1d65 g \u2194 \u2200 \u2983s\u2984, s \u2208 f \u2192 \u2200 \u2983t\u2984, t \u2208 g \u2192 s -\u1d65 t \u2208 h", "start": [1152, 1], "end": [1154, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.instSMulFilter", "code": "@[to_additive \"`a +\u1d65 f` is the map of `f` under `a +\u1d65` in locale `Pointwise`.\"]\nprotected def instSMulFilter : SMul \u03b1 (Filter \u03b2) :=\n  \u27e8fun a => map ((\u00b7 \u2022 \u00b7) a)\u27e9", "start": [1166, 1], "end": [1169, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.map_smul", "code": "@[to_additive (attr := simp)]\ntheorem map_smul : map (fun b => a \u2022 b) f = a \u2022 f", "start": [1175, 1], "end": [1177, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.mem_smul_filter", "code": "@[to_additive]\ntheorem mem_smul_filter : s \u2208 a \u2022 f \u2194 (\u00b7 \u2022 \u00b7) a \u207b\u00b9' s \u2208 f", "start": [1181, 1], "end": [1183, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_set_mem_smul_filter", "code": "@[to_additive]\ntheorem smul_set_mem_smul_filter : s \u2208 f \u2192 a \u2022 s \u2208 a \u2022 f", "start": [1187, 1], "end": [1189, 16], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_filter_bot", "code": "@[to_additive (attr := simp)]\ntheorem smul_filter_bot : a \u2022 (\u22a5 : Filter \u03b2) = \u22a5", "start": [1193, 1], "end": [1195, 10], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_filter_eq_bot_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_filter_eq_bot_iff : a \u2022 f = \u22a5 \u2194 f = \u22a5", "start": [1199, 1], "end": [1201, 17], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_filter_neBot_iff", "code": "@[to_additive (attr := simp)]\ntheorem smul_filter_neBot_iff : (a \u2022 f).NeBot \u2194 f.NeBot", "start": [1205, 1], "end": [1207, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.smul_filter", "code": "@[to_additive]\ntheorem NeBot.smul_filter : f.NeBot \u2192 (a \u2022 f).NeBot", "start": [1211, 1], "end": [1212, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.of_smul_filter", "code": "@[to_additive]\ntheorem NeBot.of_smul_filter : (a \u2022 f).NeBot \u2192 f.NeBot", "start": [1216, 1], "end": [1218, 15], "kind": "commanddeclaration"}, {"full_name": "Filter.smul_filter_le_smul_filter", "code": "@[to_additive]\ntheorem smul_filter_le_smul_filter (hf : f\u2081 \u2264 f\u2082) : a \u2022 f\u2081 \u2264 a \u2022 f\u2082", "start": [1222, 1], "end": [1224, 14], "kind": "commanddeclaration"}, {"full_name": "Filter.covariant_smul_filter", "code": "@[to_additive]\ninstance covariant_smul_filter : CovariantClass \u03b1 (Filter \u03b2) (\u00b7 \u2022 \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _ => @map_mono \u03b2 \u03b2 _\u27e9", "start": [1228, 1], "end": [1230, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.smulCommClass_filter", "code": "@[to_additive]\ninstance smulCommClass_filter [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 \u03b2 (Filter \u03b3) :=\n  \u27e8fun _ _ _ => map_comm (funext <| smul_comm _ _) _\u27e9", "start": [1238, 1], "end": [1241, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.smulCommClass_filter'", "code": "@[to_additive]\ninstance smulCommClass_filter' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass \u03b1 (Filter \u03b2) (Filter \u03b3) :=\n  \u27e8fun a _ _ => map_map\u2082_distrib_right <| smul_comm a\u27e9", "start": [1245, 1], "end": [1248, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.smulCommClass_filter''", "code": "@[to_additive]\ninstance smulCommClass_filter'' [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Filter \u03b1) \u03b2 (Filter \u03b3) :=\n  haveI := SMulCommClass.symm \u03b1 \u03b2 \u03b3\n  SMulCommClass.symm _ _ _", "start": [1252, 1], "end": [1256, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.smulCommClass", "code": "@[to_additive]\ninstance smulCommClass [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [SMulCommClass \u03b1 \u03b2 \u03b3] :\n    SMulCommClass (Filter \u03b1) (Filter \u03b2) (Filter \u03b3) :=\n  \u27e8fun _ _ _ => map\u2082_left_comm smul_comm\u27e9", "start": [1260, 1], "end": [1263, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.isScalarTower", "code": "@[to_additive vaddAssocClass]\ninstance isScalarTower [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 \u03b2 (Filter \u03b3) :=\n  \u27e8fun a b f => by simp only [\u2190 map_smul, map_map, smul_assoc]; rfl\u27e9", "start": [1267, 1], "end": [1270, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.isScalarTower'", "code": "@[to_additive vaddAssocClass']\ninstance isScalarTower' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower \u03b1 (Filter \u03b2) (Filter \u03b3) :=\n  \u27e8fun a f g => by\n    refine' (map_map\u2082_distrib_left fun _ _ => _).symm\n    exact (smul_assoc a _ _).symm\u27e9", "start": [1274, 1], "end": [1279, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.isScalarTower''", "code": "@[to_additive vaddAssocClass'']\ninstance isScalarTower'' [SMul \u03b1 \u03b2] [SMul \u03b1 \u03b3] [SMul \u03b2 \u03b3] [IsScalarTower \u03b1 \u03b2 \u03b3] :\n    IsScalarTower (Filter \u03b1) (Filter \u03b2) (Filter \u03b3) :=\n  \u27e8fun _ _ _ => map\u2082_assoc smul_assoc\u27e9", "start": [1283, 1], "end": [1286, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.isCentralScalar", "code": "@[to_additive]\ninstance isCentralScalar [SMul \u03b1 \u03b2] [SMul \u03b1\u1d50\u1d52\u1d56 \u03b2] [IsCentralScalar \u03b1 \u03b2] :\n    IsCentralScalar \u03b1 (Filter \u03b2) :=\n  \u27e8fun _ f => (congr_arg fun m => map m f) <| funext fun _ => op_smul_eq_smul _ _\u27e9", "start": [1290, 1], "end": [1293, 83], "kind": "commanddeclaration"}, {"full_name": "Filter.mulAction", "code": "@[to_additive \"An additive action of an additive monoid `\u03b1` on a type `\u03b2` gives an additive action\n of `Filter \u03b1` on `Filter \u03b2`\"]\nprotected def mulAction [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction (Filter \u03b1) (Filter \u03b2) where\n  one_smul f := map\u2082_pure_left.trans <| by simp_rw [one_smul, map_id']\n  mul_smul f g h := map\u2082_assoc mul_smul", "start": [1297, 1], "end": [1303, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.mulActionFilter", "code": "@[to_additive \"An additive action of an additive monoid on a type `\u03b2` gives an additive action on\n `Filter \u03b2`.\"]\nprotected def mulActionFilter [Monoid \u03b1] [MulAction \u03b1 \u03b2] : MulAction \u03b1 (Filter \u03b2) where\n  mul_smul a b f := by simp only [\u2190 map_smul, map_map, Function.comp, \u2190 mul_smul]\n  one_smul f := by simp only [\u2190 map_smul, one_smul, map_id']", "start": [1307, 1], "end": [1313, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.distribMulActionFilter", "code": "protected def distribMulActionFilter [Monoid \u03b1] [AddMonoid \u03b2] [DistribMulAction \u03b1 \u03b2] :\n    DistribMulAction \u03b1 (Filter \u03b2) where\n  smul_add _ _ _ := map_map\u2082_distrib <| smul_add _\n  smul_zero _ := (map_pure _ _).trans <| by dsimp only; rw [smul_zero, pure_zero]", "start": [1320, 1], "end": [1325, 82], "kind": "commanddeclaration"}, {"full_name": "Filter.mulDistribMulActionFilter", "code": "protected def mulDistribMulActionFilter [Monoid \u03b1] [Monoid \u03b2] [MulDistribMulAction \u03b1 \u03b2] :\n    MulDistribMulAction \u03b1 (Set \u03b2) where\n  smul_mul _ _ _ := image_image2_distrib <| smul_mul' _\n  smul_one _ := image_singleton.trans <| by rw [smul_one, singleton_one]", "start": [1328, 1], "end": [1332, 73], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.smul_zero_nonneg", "code": "theorem NeBot.smul_zero_nonneg (hf : f.NeBot) : 0 \u2264 f \u2022 (0 : Filter \u03b2)", "start": [1348, 1], "end": [1351, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.NeBot.zero_smul_nonneg", "code": "theorem NeBot.zero_smul_nonneg (hg : g.NeBot) : 0 \u2264 (0 : Filter \u03b1) \u2022 g", "start": [1354, 1], "end": [1357, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.zero_smul_filter_nonpos", "code": "theorem zero_smul_filter_nonpos : (0 : \u03b1) \u2022 g \u2264 0", "start": [1360, 1], "end": [1365, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.zero_smul_filter", "code": "theorem zero_smul_filter (hg : g.NeBot) : (0 : \u03b1) \u2022 g = 0", "start": [1368, 1], "end": [1372, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/ContinuousFunction/Basic.lean", "imports": ["Mathlib/Data/Set/UnionLift.lean", "Mathlib/Topology/Homeomorph.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "ContinuousMap", "code": "structure ContinuousMap (\u03b1 \u03b2 : Type*) [TopologicalSpace \u03b1] [TopologicalSpace \u03b2] where\n  \n  protected toFun : \u03b1 \u2192 \u03b2\n  \n  protected continuous_toFun : Continuous toFun := by continuity", "start": [23, 1], "end": [33, 65], "kind": "commanddeclaration"}, {"full_name": "ContinuousMapClass", "code": "class ContinuousMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [TopologicalSpace \u03b1]\n  [TopologicalSpace \u03b2] extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  map_continuous (f : F) : Continuous f", "start": [41, 1], "end": [47, 40], "kind": "commanddeclaration"}, {"full_name": "map_continuousAt", "code": "theorem map_continuousAt (f : F) (a : \u03b1) : ContinuousAt f a", "start": [60, 1], "end": [61, 34], "kind": "commanddeclaration"}, {"full_name": "map_continuousWithinAt", "code": "theorem map_continuousWithinAt (f : F) (s : Set \u03b1) (a : \u03b1) : ContinuousWithinAt f s a", "start": [64, 1], "end": [65, 40], "kind": "commanddeclaration"}, {"full_name": "toContinuousMap", "code": "@[coe] def toContinuousMap (f : F) : C(\u03b1, \u03b2) := \u27e8f, map_continuous f\u27e9", "start": [68, 1], "end": [69, 70], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toContinuousMapClass", "code": "instance toContinuousMapClass : ContinuousMapClass C(\u03b1, \u03b2) \u03b1 \u03b2 where\n  coe := ContinuousMap.toFun\n  coe_injective' f g h := by cases f; cases g; congr\n  map_continuous := ContinuousMap.continuous_toFun", "start": [83, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe {f : C(\u03b1, \u03b2)} : f.toFun = (f : \u03b1 \u2192 \u03b2)", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.Simps.apply", "code": "def Simps.apply (f : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2 := f", "start": [101, 1], "end": [102, 43], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_coe", "code": "@[simp] protected theorem coe_coe {F : Type*} [ContinuousMapClass F \u03b1 \u03b2] (f : F) : \u21d1(f : C(\u03b1, \u03b2)) = f", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.ext", "code": "@[ext]\ntheorem ext {f g : C(\u03b1, \u03b2)} (h : \u2200 a, f a = g a) : f = g", "start": [112, 1], "end": [114, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.copy", "code": "protected def copy (f : C(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : C(\u03b1, \u03b2) where\n  toFun := f'\n  continuous_toFun := h.symm \u25b8 f.continuous_toFun", "start": [117, 1], "end": [121, 50], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : C(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.copy_eq", "code": "theorem copy_eq (f : C(\u03b1, \u03b2)) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [129, 1], "end": [130, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous", "code": "protected theorem continuous (f : C(\u03b1, \u03b2)) : Continuous f", "start": [135, 1], "end": [137, 21], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuous_set_coe", "code": "@[continuity]\ntheorem continuous_set_coe (s : Set C(\u03b1, \u03b2)) (f : s) : Continuous (f : \u03b1 \u2192 \u03b2)", "start": [140, 1], "end": [142, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.continuousAt", "code": "protected theorem continuousAt (f : C(\u03b1, \u03b2)) (x : \u03b1) : ContinuousAt f x", "start": [145, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.congr_fun", "code": "protected theorem congr_fun {f g : C(\u03b1, \u03b2)} (H : f = g) (x : \u03b1) : f x = g x", "start": [150, 1], "end": [152, 10], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.congr_arg", "code": "protected theorem congr_arg (f : C(\u03b1, \u03b2)) {x y : \u03b1} (h : x = y) : f x = f y", "start": [155, 1], "end": [157, 10], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_injective", "code": "theorem coe_injective : @Function.Injective C(\u03b1, \u03b2) (\u03b1 \u2192 \u03b2) (\u2191)", "start": [160, 1], "end": [161, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : \u03b1 \u2192 \u03b2) (h : Continuous f) : \u21d1(\u27e8f, h\u27e9 : C(\u03b1, \u03b2)) = f", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.map_specializes", "code": "theorem map_specializes (f : C(\u03b1, \u03b2)) {x y : \u03b1} (h : x \u2933 y) : f x \u2933 f y", "start": [169, 1], "end": [170, 12], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.equivFnOfDiscrete", "code": "@[simps]\ndef equivFnOfDiscrete [DiscreteTopology \u03b1] : C(\u03b1, \u03b2) \u2243 (\u03b1 \u2192 \u03b2) :=\n  \u27e8fun f => f,\n    fun f => \u27e8f, continuous_of_discreteTopology\u27e9,\n    fun _ => by ext; rfl,\n    fun _ => by ext; rfl\u27e9", "start": [177, 1], "end": [185, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.id", "code": "protected def id : C(\u03b1, \u03b1) where\n  toFun := id", "start": [192, 1], "end": [194, 14], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(ContinuousMap.id \u03b1) = id", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.const", "code": "def const (b : \u03b2) : C(\u03b1, \u03b2) where\n  toFun := fun _ : \u03b1 => b", "start": [202, 1], "end": [204, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_const", "code": "@[simp]\ntheorem coe_const (b : \u03b2) : \u21d1(const \u03b1 b) = Function.const \u03b1 b", "start": [207, 1], "end": [209, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.constPi", "code": "@[simps (config := .asFn)]\ndef constPi : C(\u03b2, \u03b1 \u2192 \u03b2) where\n  toFun b := Function.const \u03b1 b", "start": [212, 1], "end": [215, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : ContinuousMap.id \u03b1 a = a", "start": [222, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.const_apply", "code": "@[simp]\ntheorem const_apply (b : \u03b2) (a : \u03b1) : const \u03b1 b a = b", "start": [227, 1], "end": [229, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.comp", "code": "def comp (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) : C(\u03b1, \u03b3) where\n  toFun := f \u2218 g", "start": [232, 1], "end": [234, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) : \u21d1(comp f g) = f \u2218 g", "start": [237, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : C(\u03b2, \u03b3)) (g : C(\u03b1, \u03b2)) (a : \u03b1) : comp f g a = f (g a)", "start": [242, 1], "end": [244, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : C(\u03b3, \u03b4)) (g : C(\u03b2, \u03b3)) (h : C(\u03b1, \u03b2)) :\n    (f.comp g).comp h = f.comp (g.comp h)", "start": [247, 1], "end": [250, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : C(\u03b1, \u03b2)) : (ContinuousMap.id _).comp f = f", "start": [253, 1], "end": [255, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : C(\u03b1, \u03b2)) : f.comp (ContinuousMap.id _) = f", "start": [258, 1], "end": [260, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.const_comp", "code": "@[simp]\ntheorem const_comp (c : \u03b3) (f : C(\u03b1, \u03b2)) : (const \u03b2 c).comp f = const \u03b1 c", "start": [263, 1], "end": [265, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.comp_const", "code": "@[simp]\ntheorem comp_const (f : C(\u03b2, \u03b3)) (b : \u03b2) : f.comp (const \u03b1 b) = const \u03b1 (f b)", "start": [268, 1], "end": [270, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.cancel_right", "code": "@[simp]\ntheorem cancel_right {f\u2081 f\u2082 : C(\u03b2, \u03b3)} {g : C(\u03b1, \u03b2)} (hg : Surjective g) :\n    f\u2081.comp g = f\u2082.comp g \u2194 f\u2081 = f\u2082", "start": [273, 1], "end": [276, 91], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.cancel_left", "code": "@[simp]\ntheorem cancel_left {f : C(\u03b2, \u03b3)} {g\u2081 g\u2082 : C(\u03b1, \u03b2)} (hf : Injective f) :\n    f.comp g\u2081 = f.comp g\u2082 \u2194 g\u2081 = g\u2082", "start": [279, 1], "end": [282, 81], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.fst", "code": "@[simps (config := .asFn)]\ndef fst : C(\u03b1 \u00d7 \u03b2, \u03b1) where\n  toFun := Prod.fst", "start": [294, 1], "end": [297, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.snd", "code": "@[simps (config := .asFn)]\ndef snd : C(\u03b1 \u00d7 \u03b2, \u03b2) where\n  toFun := Prod.snd", "start": [299, 1], "end": [302, 20], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.prodMk", "code": "def prodMk (f : C(\u03b1, \u03b2\u2081)) (g : C(\u03b1, \u03b2\u2082)) : C(\u03b1, \u03b2\u2081 \u00d7 \u03b2\u2082) where\n  toFun x := (f x, g x)", "start": [304, 1], "end": [306, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.prodMap", "code": "@[simps]\ndef prodMap (f : C(\u03b1\u2081, \u03b1\u2082)) (g : C(\u03b2\u2081, \u03b2\u2082)) : C(\u03b1\u2081 \u00d7 \u03b2\u2081, \u03b1\u2082 \u00d7 \u03b2\u2082) where\n  toFun := Prod.map f g\n  continuous_toFun := f.continuous.prod_map g.continuous", "start": [309, 1], "end": [313, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.prod_eval", "code": "@[simp]\ntheorem prod_eval (f : C(\u03b1, \u03b2\u2081)) (g : C(\u03b1, \u03b2\u2082)) (a : \u03b1) : (prodMk f g) a = (f a, g a)", "start": [317, 1], "end": [319, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.prodSwap", "code": "@[simps!]\ndef prodSwap : C(\u03b1 \u00d7 \u03b2, \u03b2 \u00d7 \u03b1) := .prodMk .snd .fst", "start": [322, 1], "end": [324, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.sigmaMk", "code": "@[simps apply]\ndef sigmaMk {\u03b9 : Type*} {Y : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (Y i)] (i : \u03b9) :\n    C(Y i, \u03a3 i, Y i) where\n  toFun := Sigma.mk i", "start": [328, 1], "end": [332, 22], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.pi", "code": "def pi (f : \u2200 i, C(A, X i)) : C(A, \u2200 i, X i) where\n  toFun (a : A) (i : I) := f i a", "start": [339, 1], "end": [341, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.pi_eval", "code": "@[simp]\ntheorem pi_eval (f : \u2200 i, C(A, X i)) (a : A) : (pi f) a = fun i : I => (f i) a", "start": [344, 1], "end": [346, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.eval", "code": "@[simps (config := .asFn)]\ndef eval (i : I) : C(\u2200 j, X j, X i) where\n  toFun := Function.eval i", "start": [349, 1], "end": [352, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.piMap", "code": "@[simps!]\ndef piMap (f : \u2200 i, C(X i, Y i)) : C((i : I) \u2192 X i, (i : I) \u2192 Y i) :=\n  .pi fun i \u21a6 (f i).comp (eval i)", "start": [354, 1], "end": [358, 34], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.precomp", "code": "def precomp {\u03b9 : Type*} (\u03c6 : \u03b9 \u2192 I) : C((i : I) \u2192 X i, (i : \u03b9) \u2192 X (\u03c6 i)) :=\n  \u27e8_, Pi.continuous_precomp' \u03c6\u27e9", "start": [360, 1], "end": [362, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.restrict", "code": "def restrict (f : C(\u03b1, \u03b2)) : C(s, \u03b2) where\n  toFun := f \u2218 ((\u2191) : s \u2192 \u03b1)", "start": [370, 1], "end": [372, 29], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_restrict", "code": "@[simp]\ntheorem coe_restrict (f : C(\u03b1, \u03b2)) : \u21d1(f.restrict s) = f \u2218 ((\u2191) : s \u2192 \u03b1)", "start": [375, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.restrict_apply", "code": "@[simp]\ntheorem restrict_apply (f : C(\u03b1, \u03b2)) (s : Set \u03b1) (x : s) : f.restrict s x = f x", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.restrict_apply_mk", "code": "@[simp]\ntheorem restrict_apply_mk (f : C(\u03b1, \u03b2)) (s : Set \u03b1) (x : \u03b1) (hx : x \u2208 s) :\n    f.restrict s \u27e8x, hx\u27e9 = f x", "start": [385, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.injective_restrict", "code": "theorem injective_restrict [T2Space \u03b2] {s : Set \u03b1} (hs : Dense s) :\n    Injective (restrict s : C(\u03b1, \u03b2) \u2192 C(s, \u03b2))", "start": [391, 1], "end": [394, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.restrictPreimage", "code": "@[simps]\ndef restrictPreimage (f : C(\u03b1, \u03b2)) (s : Set \u03b2) : C(f \u207b\u00b9' s, s) :=\n  \u27e8s.restrictPreimage f, continuous_iff_continuousAt.mpr fun _ => f.2.continuousAt.restrictPreimage\u27e9", "start": [396, 1], "end": [399, 101], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover", "code": "noncomputable def liftCover : C(\u03b1, \u03b2) :=\n  haveI H : \u22c3 i, S i = Set.univ :=\n    Set.iUnion_eq_univ_iff.2 fun x \u21a6 (hS x).imp fun _ \u21a6 mem_of_mem_nhds\n  mk (Set.liftCover S (fun i \u21a6 \u03c6 i) h\u03c6 H) <| continuous_of_cover_nhds hS fun i \u21a6 by\n    rw [continuousOn_iff_continuous_restrict]\n    simpa only [Set.restrict, Set.liftCover_coe] using (\u03c6 i).continuous", "start": [410, 1], "end": [418, 72], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover_coe", "code": "@[simp]\ntheorem liftCover_coe {i : \u03b9} (x : S i) : liftCover S \u03c6 h\u03c6 hS x = \u03c6 i x", "start": [423, 1], "end": [425, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover_restrict", "code": "theorem liftCover_restrict {i : \u03b9} : (liftCover S \u03c6 h\u03c6 hS).restrict (S i) = \u03c6 i", "start": [429, 1], "end": [431, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover'", "code": "noncomputable def liftCover' : C(\u03b1, \u03b2) := by\n  let S : A \u2192 Set \u03b1 := (\u2191)\n  let F : \u2200 i : A, C(i, \u03b2) := fun i => F i i.prop\n  refine' liftCover S F (fun i j => hF i i.prop j j.prop) _\n  intro x\n  obtain \u27e8s, hs, hsx\u27e9 := hA x\n  exact \u27e8\u27e8s, hs\u27e9, hsx\u27e9", "start": [439, 1], "end": [448, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover_coe'", "code": "@[simp]\ntheorem liftCover_coe' {s : Set \u03b1} {hs : s \u2208 A} (x : s) : liftCover' A F hF hA x = F s hs x", "start": [456, 1], "end": [459, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.liftCover_restrict'", "code": "@[simp]\ntheorem liftCover_restrict' {s : Set \u03b1} {hs : s \u2208 A} :\n    (liftCover' A F hF hA).restrict s = F s hs", "start": [463, 1], "end": [465, 94], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toContinuousMap", "code": "@[simps]\ndef toContinuousMap (e : \u03b1 \u2243\u209c \u03b2) : C(\u03b1, \u03b2) :=\n  \u27e8e, e.continuous_toFun\u27e9", "start": [478, 1], "end": [481, 26], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_refl", "code": "@[simp]\ntheorem coe_refl : (Homeomorph.refl \u03b1 : C(\u03b1, \u03b1)) = ContinuousMap.id \u03b1", "start": [495, 1], "end": [497, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_trans", "code": "@[simp]\ntheorem coe_trans : (f.trans g : C(\u03b1, \u03b3)) = (g : C(\u03b2, \u03b3)).comp f", "start": [500, 1], "end": [502, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.symm_comp_toContinuousMap", "code": "@[simp]\ntheorem symm_comp_toContinuousMap : (f.symm : C(\u03b2, \u03b1)).comp (f : C(\u03b1, \u03b2)) = ContinuousMap.id \u03b1", "start": [505, 1], "end": [508, 49], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.toContinuousMap_comp_symm", "code": "@[simp]\ntheorem toContinuousMap_comp_symm : (f : C(\u03b1, \u03b2)).comp (f.symm : C(\u03b2, \u03b1)) = ContinuousMap.id \u03b2", "start": [511, 1], "end": [514, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/Category.lean", "imports": ["Mathlib/CategoryTheory/NatTrans.lean", "Mathlib/CategoryTheory/Iso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.category", "code": "instance Functor.category : Category.{max u\u2081 v\u2082} (C \u2964 D) where\n  Hom F G := NatTrans F G\n  id F := NatTrans.id F\n  comp \u03b1 \u03b2 := vcomp \u03b1 \u03b2", "start": [38, 1], "end": [49, 24], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.ext'", "code": "@[ext]\ntheorem ext' {\u03b1 \u03b2 : F \u27f6 G} (w : \u03b1.app = \u03b2.app) : \u03b1 = \u03b2", "start": [58, 1], "end": [59, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.vcomp_eq_comp", "code": "@[simp]\ntheorem vcomp_eq_comp (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) : vcomp \u03b1 \u03b2 = \u03b1 \u226b \u03b2", "start": [61, 1], "end": [62, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.vcomp_app'", "code": "theorem vcomp_app' (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) (X : C) : (\u03b1 \u226b \u03b2).app X = \u03b1.app X \u226b \u03b2.app X", "start": [65, 1], "end": [65, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.congr_app", "code": "theorem congr_app {\u03b1 \u03b2 : F \u27f6 G} (h : \u03b1 = \u03b2) (X : C) : \u03b1.app X = \u03b2.app X", "start": [68, 1], "end": [68, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.id_app", "code": "@[simp]\ntheorem id_app (F : C \u2964 D) (X : C) : (\ud835\udfd9 F : F \u27f6 F).app X = \ud835\udfd9 (F.obj X)", "start": [71, 1], "end": [72, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.comp_app", "code": "@[simp]\ntheorem comp_app {F G H : C \u2964 D} (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) (X : C) :\n    (\u03b1 \u226b \u03b2).app X = \u03b1.app X \u226b \u03b2.app X", "start": [75, 1], "end": [77, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.app_naturality", "code": "theorem app_naturality {F G : C \u2964 D \u2964 E} (T : F \u27f6 G) (X : C) {Y Z : D} (f : Y \u27f6 Z) :\n    (F.obj X).map f \u226b (T.app X).app Z = (T.app X).app Y \u226b (G.obj X).map f", "start": [82, 1], "end": [84, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.naturality_app", "code": "theorem naturality_app {F G : C \u2964 D \u2964 E} (T : F \u27f6 G) (Z : D) {X Y : C} (f : X \u27f6 Y) :\n    (F.map f).app Z \u226b (T.app Y).app Z = (T.app X).app Z \u226b (G.map f).app Z", "start": [87, 1], "end": [89, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.mono_of_mono_app", "code": "theorem mono_of_mono_app (\u03b1 : F \u27f6 G) [\u2200 X : C, Mono (\u03b1.app X)] : Mono \u03b1", "start": [92, 1], "end": [96, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.epi_of_epi_app", "code": "theorem epi_of_epi_app (\u03b1 : F \u27f6 G) [\u2200 X : C, Epi (\u03b1.app X)] : Epi \u03b1", "start": [99, 1], "end": [103, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.hcomp", "code": "@[simps]\ndef hcomp {H I : D \u2964 E} (\u03b1 : F \u27f6 G) (\u03b2 : H \u27f6 I) : F \u22d9 H \u27f6 G \u22d9 I where\n  app := fun X : C => \u03b2.app (F.obj X) \u226b I.map (\u03b1.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, \u2190 assoc, naturality, assoc, \u2190 map_comp I, naturality,\n      map_comp, assoc]", "start": [106, 1], "end": [112, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.hcomp_id_app", "code": "theorem hcomp_id_app {H : D \u2964 E} (\u03b1 : F \u27f6 G) (X : C) : (\u03b1 \u25eb \ud835\udfd9 H).app X = H.map (\u03b1.app X)", "start": [119, 1], "end": [120, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.id_hcomp_app", "code": "theorem id_hcomp_app {H : E \u2964 C} (\u03b1 : F \u27f6 G) (X : E) : (\ud835\udfd9 H \u25eb \u03b1).app X = \u03b1.app _", "start": [123, 1], "end": [123, 92], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.exchange", "code": "theorem exchange {I J K : D \u2964 E} (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) (\u03b3 : I \u27f6 J) (\u03b4 : J \u27f6 K) :\n    (\u03b1 \u226b \u03b2) \u25eb (\u03b3 \u226b \u03b4) = (\u03b1 \u25eb \u03b3) \u226b \u03b2 \u25eb \u03b4", "start": [130, 1], "end": [132, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.flip", "code": "@[simps]\nprotected def flip (F : C \u2964 D \u2964 E) : D \u2964 C \u2964 E where\n  obj k :=\n    { obj := fun j => (F.obj j).obj k,\n      map := fun f => (F.map f).app k, }\n  map f := { app := fun j => (F.obj j).map f }", "start": [141, 1], "end": [147, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.map_hom_inv_app", "code": "@[reassoc (attr := simp)]\ntheorem map_hom_inv_app (F : C \u2964 D \u2964 E) {X Y : C} (e : X \u2245 Y) (Z : D) :\n    (F.map e.hom).app Z \u226b (F.map e.inv).app Z = \ud835\udfd9 _", "start": [155, 1], "end": [158, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.map_inv_hom_app", "code": "@[reassoc (attr := simp)]\ntheorem map_inv_hom_app (F : C \u2964 D \u2964 E) {X Y : C} (e : X \u2245 Y) (Z : D) :\n    (F.map e.inv).app Z \u226b (F.map e.hom).app Z = \ud835\udfd9 _", "start": [162, 1], "end": [165, 49], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/BigOperators.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "Mathlib/GroupTheory/GroupAction/BigOperators.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "List.sum_smul", "code": "theorem List.sum_smul {l : List R} {x : M} : l.sum \u2022 x = (l.map fun r \u21a6 r \u2022 x).sum", "start": [23, 1], "end": [24, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_smul", "code": "theorem Multiset.sum_smul {l : Multiset R} {x : M} : l.sum \u2022 x = (l.map fun r \u21a6 r \u2022 x).sum", "start": [27, 1], "end": [28, 47], "kind": "commanddeclaration"}, {"full_name": "Multiset.sum_smul_sum", "code": "theorem Multiset.sum_smul_sum {s : Multiset R} {t : Multiset M} :\n    s.sum \u2022 t.sum = ((s \u00d7\u02e2 t).map fun p : R \u00d7 M \u21a6 p.fst \u2022 p.snd).sum", "start": [31, 1], "end": [35, 45], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul", "code": "theorem Finset.sum_smul {f : \u03b9 \u2192 R} {s : Finset \u03b9} {x : M} :\n    (\u2211 i in s, f i) \u2022 x = \u2211 i in s, f i \u2022 x", "start": [38, 1], "end": [39, 85], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_smul_sum", "code": "theorem Finset.sum_smul_sum {f : \u03b1 \u2192 R} {g : \u03b2 \u2192 M} {s : Finset \u03b1} {t : Finset \u03b2} :\n    ((\u2211 i in s, f i) \u2022 \u2211 i in t, g i) = \u2211 p in s \u00d7\u02e2 t, f p.fst \u2022 g p.snd", "start": [42, 1], "end": [46, 23], "kind": "commanddeclaration"}, {"full_name": "Finset.cast_card", "code": "theorem Finset.cast_card [CommSemiring R] (s : Finset \u03b1) : (s.card : R) = \u2211 a in s, 1", "start": [51, 1], "end": [52, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Tower.lean", "imports": ["Mathlib/LinearAlgebra/Span.lean", "Mathlib/Algebra/Algebra/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.lsmul", "code": "def lsmul : A \u2192\u2090[R] Module.End B M where\n  toFun := DistribMulAction.toLinearMap B M\n  map_one' := LinearMap.ext fun _ => one_smul A _\n  map_mul' a b := LinearMap.ext <| smul_assoc a b\n  map_zero' := LinearMap.ext fun _ => zero_smul A _\n  map_add' _a _b := LinearMap.ext fun _ => add_smul _ _ _\n  commutes' r := LinearMap.ext <| algebraMap_smul A r", "start": [40, 1], "end": [72, 54], "kind": "commanddeclaration"}, {"full_name": "Algebra.lsmul_coe", "code": "@[simp]\ntheorem lsmul_coe (a : A) : (lsmul R B M a : M \u2192 M) = (\u00b7 \u2022 \u00b7) a", "start": [75, 1], "end": [76, 71], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.algebraMap_smul", "code": "theorem algebraMap_smul (r : R) (x : M) : algebraMap R A r \u2022 x = r \u2022 x", "start": [91, 1], "end": [92, 60], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.of_algebraMap_eq", "code": "theorem of_algebraMap_eq [Algebra R A]\n    (h : \u2200 x, algebraMap R A x = algebraMap S A (algebraMap R S x)) : IsScalarTower R S A", "start": [105, 1], "end": [107, 78], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.of_algebraMap_eq'", "code": "theorem of_algebraMap_eq' [Algebra R A]\n    (h : algebraMap R A = (algebraMap S A).comp (algebraMap R S)) : IsScalarTower R S A", "start": [110, 1], "end": [113, 42], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.algebraMap_eq", "code": "theorem algebraMap_eq : algebraMap R A = (algebraMap S A).comp (algebraMap R S)", "start": [122, 1], "end": [124, 87], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.algebraMap_apply", "code": "theorem algebraMap_apply (x : R) : algebraMap R A x = algebraMap S A (algebraMap R S x)", "start": [127, 1], "end": [128, 47], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.Algebra.ext", "code": "@[ext]\ntheorem Algebra.ext {S : Type u} {A : Type v} [CommSemiring S] [Semiring A] (h1 h2 : Algebra S A)\n    (h : \u2200 (r : S) (x : A), (by have I := h1; exact r \u2022 x) = r \u2022 x) : h1 = h2", "start": [131, 1], "end": [135, 97], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.toAlgHom", "code": "def toAlgHom : S \u2192\u2090[R] A :=\n  { algebraMap S A with commutes' := fun _ => (algebraMap_apply _ _ _ _).symm }", "start": [138, 1], "end": [141, 80], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.toAlgHom_apply", "code": "theorem toAlgHom_apply (y : S) : toAlgHom R S A y = algebraMap S A y", "start": [144, 1], "end": [144, 76], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.coe_toAlgHom", "code": "@[simp]\ntheorem coe_toAlgHom : \u2191(toAlgHom R S A) = algebraMap S A", "start": [147, 1], "end": [149, 27], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.coe_toAlgHom'", "code": "@[simp]\ntheorem coe_toAlgHom' : (toAlgHom R S A : S \u2192 A) = algebraMap S A", "start": [152, 1], "end": [153, 73], "kind": "commanddeclaration"}, {"full_name": "AlgHom.map_algebraMap", "code": "@[simp]\ntheorem _root_.AlgHom.map_algebraMap (f : A \u2192\u2090[S] B) (r : R) :\n    f (algebraMap R A r) = algebraMap R B r", "start": [158, 1], "end": [161, 73], "kind": "commanddeclaration"}, {"full_name": "AlgHom.comp_algebraMap_of_tower", "code": "@[simp]\ntheorem _root_.AlgHom.comp_algebraMap_of_tower (f : A \u2192\u2090[S] B) :\n    (f : A \u2192+* B).comp (algebraMap R A) = algebraMap R B", "start": [166, 1], "end": [169, 40], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.subsemiring", "code": "instance (priority := 999) subsemiring (U : Subsemiring S) : IsScalarTower U S A :=\n  of_algebraMap_eq fun _x => rfl", "start": [173, 1], "end": [174, 33], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.of_ring_hom", "code": "instance (priority := 999) of_ring_hom {R A B : Type*} [CommSemiring R] [CommSemiring A]\n    [CommSemiring B] [Algebra R A] [Algebra R B] (f : A \u2192\u2090[R] B) :\n    @IsScalarTower R A B _ f.toRingHom.toAlgebra.toSMul _ :=\n  letI := (f : A \u2192+* B).toAlgebra\n  of_algebraMap_eq fun x => (f.commutes x).symm", "start": [178, 1], "end": [182, 48], "kind": "commanddeclaration"}, {"full_name": "AlgHom.restrictScalars", "code": "def restrictScalars (f : A \u2192\u2090[S] B) : A \u2192\u2090[R] B :=\n  { (f : A \u2192+* B) with\n    commutes' := fun r => by\n      rw [algebraMap_apply R S A, algebraMap_apply R S B]\n      exact f.commutes (algebraMap R S r) }", "start": [205, 1], "end": [210, 44], "kind": "commanddeclaration"}, {"full_name": "AlgHom.restrictScalars_apply", "code": "theorem restrictScalars_apply (f : A \u2192\u2090[S] B) (x : A) : f.restrictScalars R x = f x", "start": [213, 1], "end": [213, 91], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (f : A \u2192\u2090[S] B) : (f.restrictScalars R : A \u2192+* B) = f", "start": [216, 1], "end": [217, 89], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_restrictScalars'", "code": "@[simp]\ntheorem coe_restrictScalars' (f : A \u2192\u2090[S] B) : (restrictScalars R f : A \u2192 B) = f", "start": [220, 1], "end": [221, 88], "kind": "commanddeclaration"}, {"full_name": "AlgHom.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A \u2192\u2090[S] B) \u2192 A \u2192\u2090[R] B)", "start": [224, 1], "end": [226, 38], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.restrictScalars", "code": "def restrictScalars (f : A \u2243\u2090[S] B) : A \u2243\u2090[R] B :=\n  { (f : A \u2243+* B) with\n    commutes' := fun r => by\n      rw [algebraMap_apply R S A, algebraMap_apply R S B]\n      exact f.commutes (algebraMap R S r) }", "start": [233, 1], "end": [238, 44], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.restrictScalars_apply", "code": "theorem restrictScalars_apply (f : A \u2243\u2090[S] B) (x : A) : f.restrictScalars R x = f x", "start": [241, 1], "end": [241, 91], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars (f : A \u2243\u2090[S] B) : (f.restrictScalars R : A \u2243+* B) = f", "start": [244, 1], "end": [245, 89], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.coe_restrictScalars'", "code": "@[simp]\ntheorem coe_restrictScalars' (f : A \u2243\u2090[S] B) : (restrictScalars R f : A \u2192 B) = f", "start": [248, 1], "end": [249, 88], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A \u2243\u2090[S] B) \u2192 A \u2243\u2090[R] B)", "start": [252, 1], "end": [254, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.restrictScalars_span", "code": "theorem restrictScalars_span (hsur : Function.Surjective (algebraMap R A)) (X : Set M) :\n    restrictScalars R (span A X) = span R X", "start": [269, 1], "end": [276, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_span_eq_span_of_surjective", "code": "theorem coe_span_eq_span_of_surjective (h : Function.Surjective (algebraMap R A)) (s : Set M) :\n    (Submodule.span A s : Set M) = Submodule.span R s", "start": [279, 1], "end": [281, 83], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_span_smul_of_mem", "code": "theorem smul_mem_span_smul_of_mem {s : Set S} {t : Set A} {k : S} (hks : k \u2208 span R s) {x : A}\n    (hx : x \u2208 t) : k \u2022 x \u2208 span R (s \u2022 t)", "start": [300, 1], "end": [305, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_span_smul", "code": "theorem smul_mem_span_smul {s : Set S} (hs : span R s = \u22a4) {t : Set A} {k : S} {x : A}\n    (hx : x \u2208 span R t) : k \u2022 x \u2208 span R (s \u2022 t)", "start": [310, 1], "end": [315, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.smul_mem_span_smul'", "code": "theorem smul_mem_span_smul' {s : Set S} (hs : span R s = \u22a4) {t : Set A} {k : S} {x : A}\n    (hx : x \u2208 span R (s \u2022 t)) : k \u2022 x \u2208 span R (s \u2022 t)", "start": [318, 1], "end": [327, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_smul_of_span_eq_top", "code": "theorem span_smul_of_span_eq_top {s : Set S} (hs : span R s = \u22a4) (t : Set A) :\n    span R (s \u2022 t) = (span S t).restrictScalars R", "start": [330, 1], "end": [338, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_algebraMap_image", "code": "theorem span_algebraMap_image (a : Set R) :\n    Submodule.span R (algebraMap R S '' a) = (Submodule.span R a).map (Algebra.linearMap R S)", "start": [349, 1], "end": [352, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.span_algebraMap_image_of_tower", "code": "theorem span_algebraMap_image_of_tower {S T : Type*} [CommSemiring S] [Semiring T] [Module R S]\n    [IsScalarTower R S S] [Algebra R T] [Algebra S T] [IsScalarTower R S T] (a : Set S) :\n    Submodule.span R (algebraMap S T '' a) =\n      (Submodule.span R a).map ((Algebra.linearMap S T).restrictScalars R)", "start": [355, 1], "end": [359, 80], "kind": "commanddeclaration"}, {"full_name": "Submodule.map_mem_span_algebraMap_image", "code": "theorem map_mem_span_algebraMap_image {S T : Type*} [CommSemiring S] [Semiring T] [Algebra R S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] (x : S) (a : Set S)\n    (hx : x \u2208 Submodule.span R a) : algebraMap S T x \u2208 Submodule.span R (algebraMap S T '' a)", "start": [362, 1], "end": [366, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.lsmul_injective", "code": "theorem lsmul_injective [NoZeroSMulDivisors A M] {x : A} (hx : x \u2260 0) :\n    Function.Injective (lsmul R B M x)", "start": [383, 1], "end": [385, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Basis.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "Mathlib/LinearAlgebra/Matrix/Trace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.stdBasisMatrix", "code": "def stdBasisMatrix (i : m) (j : n) (a : \u03b1) : Matrix m n \u03b1 := fun i' j' =>\n  if i = i' \u2227 j = j' then a else 0", "start": [33, 1], "end": [37, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_stdBasisMatrix", "code": "@[simp]\ntheorem smul_stdBasisMatrix (i : m) (j : n) (a b : \u03b1) :\n    b \u2022 stdBasisMatrix i j a = stdBasisMatrix i j (b \u2022 a)", "start": [40, 1], "end": [45, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.stdBasisMatrix_zero", "code": "@[simp]\ntheorem stdBasisMatrix_zero (i : m) (j : n) : stdBasisMatrix i j (0 : \u03b1) = 0", "start": [48, 1], "end": [52, 7], "kind": "commanddeclaration"}, {"full_name": "Matrix.stdBasisMatrix_add", "code": "theorem stdBasisMatrix_add (i : m) (j : n) (a b : \u03b1) :\n    stdBasisMatrix i j (a + b) = stdBasisMatrix i j a + stdBasisMatrix i j b", "start": [55, 1], "end": [58, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.matrix_eq_sum_std_basis", "code": "theorem matrix_eq_sum_std_basis [Fintype m] [Fintype n] (x : Matrix m n \u03b1) :\n    x = \u2211 i : m, \u2211 j : n, stdBasisMatrix i j (x i j)", "start": [61, 1], "end": [75, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.std_basis_eq_basis_mul_basis", "code": "theorem std_basis_eq_basis_mul_basis (i : m) (j : n) :\n    stdBasisMatrix i j 1 = vecMulVec (fun i' => ite (i = i') 1 0) fun j' => ite (j = j') 1 0", "start": [81, 1], "end": [89, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.induction_on'", "code": "@[elab_as_elim]\nprotected theorem induction_on' [Fintype m] [Fintype n] {P : Matrix m n \u03b1 \u2192 Prop} (M : Matrix m n \u03b1)\n    (h_zero : P 0) (h_add : \u2200 p q, P p \u2192 P q \u2192 P (p + q))\n    (h_std_basis : \u2200 (i : m) (j : n) (x : \u03b1), P (stdBasisMatrix i j x)) : P M", "start": [93, 1], "end": [100, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on [Fintype m] [Fintype n] [Nonempty m] [Nonempty n]\n    {P : Matrix m n \u03b1 \u2192 Prop} (M : Matrix m n \u03b1) (h_add : \u2200 p q, P p \u2192 P q \u2192 P (p + q))\n    (h_std_basis : \u2200 i j x, P (stdBasisMatrix i j x)) : P M", "start": [103, 1], "end": [112, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.apply_same", "code": "@[simp]\ntheorem apply_same : stdBasisMatrix i j c i j = c", "start": [121, 1], "end": [123, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.apply_of_ne", "code": "@[simp]\ntheorem apply_of_ne (h : \u00ac(i = i' \u2227 j = j')) : stdBasisMatrix i j c i' j' = 0", "start": [126, 1], "end": [129, 8], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.apply_of_row_ne", "code": "@[simp]\ntheorem apply_of_row_ne {i i' : m} (hi : i \u2260 i') (j j' : n) (a : \u03b1) :\n    stdBasisMatrix i j a i' j' = 0", "start": [132, 1], "end": [134, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.apply_of_col_ne", "code": "@[simp]\ntheorem apply_of_col_ne (i i' : m) {j j' : n} (hj : j \u2260 j') (a : \u03b1) :\n    stdBasisMatrix i j a i' j' = 0", "start": [137, 1], "end": [139, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.diag_zero", "code": "@[simp]\ntheorem diag_zero (h : j \u2260 i) : diag (stdBasisMatrix i j c) = 0", "start": [148, 1], "end": [150, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.diag_same", "code": "@[simp]\ntheorem diag_same : diag (stdBasisMatrix i i c) = Pi.single i c", "start": [153, 1], "end": [156, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.trace_zero", "code": "@[simp]\ntheorem trace_zero (h : j \u2260 i) : trace (stdBasisMatrix i j c) = 0", "start": [161, 1], "end": [164, 31], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.trace_eq", "code": "@[simp]\ntheorem trace_eq : trace (stdBasisMatrix i i c) = c", "start": [167, 1], "end": [170, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_left_apply_same", "code": "@[simp]\ntheorem mul_left_apply_same (b : n) (M : Matrix n n \u03b1) :\n    (stdBasisMatrix i j c * M) i b = c * M j b", "start": [173, 1], "end": [175, 86], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_right_apply_same", "code": "@[simp]\ntheorem mul_right_apply_same (a : n) (M : Matrix n n \u03b1) :\n    (M * stdBasisMatrix i j c) a j = M a i * c", "start": [178, 1], "end": [180, 96], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_left_apply_of_ne", "code": "@[simp]\ntheorem mul_left_apply_of_ne (a b : n) (h : a \u2260 i) (M : Matrix n n \u03b1) :\n    (stdBasisMatrix i j c * M) a b = 0", "start": [183, 1], "end": [185, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_right_apply_of_ne", "code": "@[simp]\ntheorem mul_right_apply_of_ne (a b : n) (hbj : b \u2260 j) (M : Matrix n n \u03b1) :\n    (M * stdBasisMatrix i j c) a b = 0", "start": [188, 1], "end": [190, 72], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_same", "code": "@[simp]\ntheorem mul_same (k : n) (d : \u03b1) :\n    stdBasisMatrix i j c * stdBasisMatrix j k d = stdBasisMatrix i k (c * d)", "start": [193, 1], "end": [198, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.StdBasisMatrix.mul_of_ne", "code": "@[simp]\ntheorem mul_of_ne {k l : n} (h : j \u2260 k) (d : \u03b1) :\n    stdBasisMatrix i j c * stdBasisMatrix k l d = 0", "start": [201, 1], "end": [214, 41], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/UnionLift.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/RingTheory/Ideal/Operations.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "Subalgebra", "code": "structure Subalgebra (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] extends\n  Subsemiring A : Type v where\n  \n  algebraMap_mem' : \u2200 r, algebraMap R A r \u2208 carrier\n  zero_mem' := (algebraMap R A).map_zero \u25b8 algebraMap_mem' 0\n  one_mem' := (algebraMap R A).map_one \u25b8 algebraMap_mem' 1", "start": [26, 1], "end": [32, 59], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.SubsemiringClass", "code": "instance SubsemiringClass : SubsemiringClass (Subalgebra R A) A where\n  add_mem {s} := add_mem (s := s.toSubsemiring)\n  mul_mem {s} := mul_mem (s := s.toSubsemiring)\n  one_mem {s} := one_mem s.toSubsemiring\n  zero_mem {s} := zero_mem s.toSubsemiring", "start": [50, 1], "end": [54, 43], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_toSubsemiring", "code": "@[simp]\ntheorem mem_toSubsemiring {S : Subalgebra R A} {x} : x \u2208 S.toSubsemiring \u2194 x \u2208 S", "start": [56, 1], "end": [58, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_carrier", "code": "theorem mem_carrier {s : Subalgebra R A} {x : A} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [62, 1], "end": [63, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.ext", "code": "@[ext]\ntheorem ext {S T : Subalgebra R A} (h : \u2200 x : A, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [66, 1], "end": [68, 16], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_toSubsemiring", "code": "@[simp]\ntheorem coe_toSubsemiring (S : Subalgebra R A) : (\u2191S.toSubsemiring : Set A) = S", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubsemiring_injective", "code": "theorem toSubsemiring_injective :\n    Function.Injective (toSubsemiring : Subalgebra R A \u2192 Subsemiring A)", "start": [76, 1], "end": [78, 67], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubsemiring_inj", "code": "theorem toSubsemiring_inj {S U : Subalgebra R A} : S.toSubsemiring = U.toSubsemiring \u2194 S = U", "start": [81, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.copy", "code": "protected def copy (S : Subalgebra R A) (s : Set A) (hs : s = \u2191S) : Subalgebra R A :=\n  { S.toSubsemiring.copy s hs with\n    carrier := s\n    algebraMap_mem' := hs.symm \u25b8 S.algebraMap_mem' }", "start": [85, 1], "end": [90, 53], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : Subalgebra R A) (s : Set A) (hs : s = \u2191S) : (S.copy s hs : Set A) = s", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.copy_eq", "code": "theorem copy_eq (S : Subalgebra R A) (s : Set A) (hs : s = \u2191S) : S.copy s hs = S", "start": [98, 1], "end": [99, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.instSMulMemClass", "code": "instance instSMulMemClass : SMulMemClass (Subalgebra R A) R A where\n  smul_mem {S} r x hx := (Algebra.smul_def r x).symm \u25b8 mul_mem (S.algebraMap_mem' r) hx", "start": [104, 1], "end": [105, 88], "kind": "commanddeclaration"}, {"full_name": "algebraMap_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem _root_.algebraMap_mem {S R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A]\n    [SetLike S A] [OneMemClass S A] [SMulMemClass S R A] (s : S) (r : R) :\n    algebraMap R A r \u2208 s", "start": [107, 1], "end": [111, 82], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.algebraMap_mem", "code": "protected theorem algebraMap_mem (r : R) : algebraMap R A r \u2208 S", "start": [113, 1], "end": [114, 21], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rangeS_le", "code": "theorem rangeS_le : (algebraMap R A).rangeS \u2264 S.toSubsemiring", "start": [117, 1], "end": [118, 26], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.range_subset", "code": "theorem range_subset : Set.range (algebraMap R A) \u2286 S", "start": [121, 1], "end": [121, 99], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.range_le", "code": "theorem range_le : Set.range (algebraMap R A) \u2264 S", "start": [124, 1], "end": [125, 17], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.smul_mem", "code": "theorem smul_mem {x : A} (hx : x \u2208 S) (r : R) : r \u2022 x \u2208 S", "start": [128, 1], "end": [129, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.one_mem", "code": "protected theorem one_mem : (1 : A) \u2208 S", "start": [132, 1], "end": [133, 12], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mul_mem", "code": "protected theorem mul_mem {x y : A} (hx : x \u2208 S) (hy : y \u2208 S) : x * y \u2208 S", "start": [136, 1], "end": [137, 16], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.pow_mem", "code": "protected theorem pow_mem {x : A} (hx : x \u2208 S) (n : \u2115) : x ^ n \u2208 S", "start": [140, 1], "end": [141, 15], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.zero_mem", "code": "protected theorem zero_mem : (0 : A) \u2208 S", "start": [144, 1], "end": [145, 13], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.add_mem", "code": "protected theorem add_mem {x y : A} (hx : x \u2208 S) (hy : y \u2208 S) : x + y \u2208 S", "start": [148, 1], "end": [149, 16], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.nsmul_mem", "code": "protected theorem nsmul_mem {x : A} (hx : x \u2208 S) (n : \u2115) : n \u2022 x \u2208 S", "start": [152, 1], "end": [153, 17], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_nat_mem", "code": "protected theorem coe_nat_mem (n : \u2115) : (n : A) \u2208 S", "start": [156, 1], "end": [157, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.list_prod_mem", "code": "protected theorem list_prod_mem {L : List A} (h : \u2200 x \u2208 L, x \u2208 S) : L.prod \u2208 S", "start": [160, 1], "end": [161, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.list_sum_mem", "code": "protected theorem list_sum_mem {L : List A} (h : \u2200 x \u2208 L, x \u2208 S) : L.sum \u2208 S", "start": [164, 1], "end": [165, 17], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.multiset_sum_mem", "code": "protected theorem multiset_sum_mem {m : Multiset A} (h : \u2200 x \u2208 m, x \u2208 S) : m.sum \u2208 S", "start": [168, 1], "end": [169, 23], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.sum_mem", "code": "protected theorem sum_mem {\u03b9 : Type w} {t : Finset \u03b9} {f : \u03b9 \u2192 A} (h : \u2200 x \u2208 t, f x \u2208 S) :\n    (\u2211 x in t, f x) \u2208 S", "start": [172, 1], "end": [174, 12], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.multiset_prod_mem", "code": "protected theorem multiset_prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A]\n    [Algebra R A] (S : Subalgebra R A) {m : Multiset A} (h : \u2200 x \u2208 m, x \u2208 S) : m.prod \u2208 S", "start": [177, 1], "end": [179, 24], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod_mem", "code": "protected theorem prod_mem {R : Type u} {A : Type v} [CommSemiring R] [CommSemiring A] [Algebra R A]\n    (S : Subalgebra R A) {\u03b9 : Type w} {t : Finset \u03b9} {f : \u03b9 \u2192 A} (h : \u2200 x \u2208 t, f x \u2208 S) :\n    (\u220f x in t, f x) \u2208 S", "start": [182, 1], "end": [185, 13], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.neg_mem", "code": "protected theorem neg_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    (S : Subalgebra R A) {x : A} (hx : x \u2208 S) : -x \u2208 S", "start": [192, 1], "end": [194, 13], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.sub_mem", "code": "protected theorem sub_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    (S : Subalgebra R A) {x y : A} (hx : x \u2208 S) (hy : y \u2208 S) : x - y \u2208 S", "start": [197, 1], "end": [199, 16], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.zsmul_mem", "code": "protected theorem zsmul_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    (S : Subalgebra R A) {x : A} (hx : x \u2208 S) (n : \u2124) : n \u2022 x \u2208 S", "start": [202, 1], "end": [204, 17], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_int_mem", "code": "protected theorem coe_int_mem {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    (S : Subalgebra R A) (n : \u2124) : (n : A) \u2208 S", "start": [207, 1], "end": [209, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toAddSubmonoid", "code": "def toAddSubmonoid {R : Type u} {A : Type v} [CommSemiring R] [Semiring A] [Algebra R A]\n    (S : Subalgebra R A) : AddSubmonoid A :=\n  S.toSubsemiring.toAddSubmonoid", "start": [212, 1], "end": [215, 33], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubring", "code": "def toSubring {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) :\n    Subring A :=\n  { S.toSubsemiring with neg_mem' := S.neg_mem }", "start": [226, 1], "end": [229, 49], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_toSubring", "code": "@[simp]\ntheorem mem_toSubring {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : Subalgebra R A} {x} : x \u2208 S.toSubring \u2194 x \u2208 S", "start": [232, 1], "end": [235, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_toSubring", "code": "@[simp]\ntheorem coe_toSubring {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    (S : Subalgebra R A) : (\u2191S.toSubring : Set A) = S", "start": [238, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubring_injective", "code": "theorem toSubring_injective {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A] :\n    Function.Injective (toSubring : Subalgebra R A \u2192 Subring A)", "start": [244, 1], "end": [246, 59], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubring_inj", "code": "theorem toSubring_inj {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S U : Subalgebra R A} : S.toSubring = U.toSubring \u2194 S = U", "start": [249, 1], "end": [251, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSemiring", "code": "instance toSemiring {R A} [CommSemiring R] [Semiring A] [Algebra R A] (S : Subalgebra R A) :\n    Semiring S :=\n  S.toSubsemiring.toSemiring", "start": [262, 1], "end": [264, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toCommSemiring", "code": "instance toCommSemiring {R A} [CommSemiring R] [CommSemiring A] [Algebra R A] (S : Subalgebra R A) :\n    CommSemiring S :=\n  S.toSubsemiring.toCommSemiring", "start": [267, 1], "end": [269, 33], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toRing", "code": "instance toRing {R A} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) : Ring S :=\n  S.toSubring.toRing", "start": [272, 1], "end": [273, 21], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toCommRing", "code": "instance toCommRing {R A} [CommRing R] [CommRing A] [Algebra R A] (S : Subalgebra R A) :\n    CommRing S :=\n  S.toSubring.toCommRing", "start": [276, 1], "end": [278, 25], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toOrderedSemiring", "code": "instance toOrderedSemiring {R A} [CommSemiring R] [OrderedSemiring A] [Algebra R A]\n    (S : Subalgebra R A) : OrderedSemiring S :=\n  S.toSubsemiring.toOrderedSemiring", "start": [281, 1], "end": [283, 36], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toStrictOrderedSemiring", "code": "instance toStrictOrderedSemiring {R A} [CommSemiring R] [StrictOrderedSemiring A] [Algebra R A]\n    (S : Subalgebra R A) : StrictOrderedSemiring S :=\n  S.toSubsemiring.toStrictOrderedSemiring", "start": [286, 1], "end": [288, 42], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toOrderedCommSemiring", "code": "instance toOrderedCommSemiring {R A} [CommSemiring R] [OrderedCommSemiring A] [Algebra R A]\n    (S : Subalgebra R A) : OrderedCommSemiring S :=\n  S.toSubsemiring.toOrderedCommSemiring", "start": [291, 1], "end": [293, 40], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toStrictOrderedCommSemiring", "code": "instance toStrictOrderedCommSemiring {R A} [CommSemiring R] [StrictOrderedCommSemiring A]\n    [Algebra R A] (S : Subalgebra R A) : StrictOrderedCommSemiring S :=\n  S.toSubsemiring.toStrictOrderedCommSemiring", "start": [296, 1], "end": [298, 46], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toOrderedRing", "code": "instance toOrderedRing {R A} [CommRing R] [OrderedRing A] [Algebra R A] (S : Subalgebra R A) :\n    OrderedRing S :=\n  S.toSubring.toOrderedRing", "start": [301, 1], "end": [303, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toOrderedCommRing", "code": "instance toOrderedCommRing {R A} [CommRing R] [OrderedCommRing A] [Algebra R A]\n    (S : Subalgebra R A) : OrderedCommRing S :=\n  S.toSubring.toOrderedCommRing", "start": [306, 1], "end": [308, 32], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toLinearOrderedSemiring", "code": "instance toLinearOrderedSemiring {R A} [CommSemiring R] [LinearOrderedSemiring A] [Algebra R A]\n    (S : Subalgebra R A) : LinearOrderedSemiring S :=\n  S.toSubsemiring.toLinearOrderedSemiring", "start": [311, 1], "end": [313, 42], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toLinearOrderedCommSemiring", "code": "instance toLinearOrderedCommSemiring {R A} [CommSemiring R] [LinearOrderedCommSemiring A]\n    [Algebra R A] (S : Subalgebra R A) : LinearOrderedCommSemiring S :=\n  S.toSubsemiring.toLinearOrderedCommSemiring", "start": [316, 1], "end": [318, 46], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toLinearOrderedRing", "code": "instance toLinearOrderedRing {R A} [CommRing R] [LinearOrderedRing A] [Algebra R A]\n    (S : Subalgebra R A) : LinearOrderedRing S :=\n  S.toSubring.toLinearOrderedRing", "start": [321, 1], "end": [323, 34], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toLinearOrderedCommRing", "code": "instance toLinearOrderedCommRing {R A} [CommRing R] [LinearOrderedCommRing A] [Algebra R A]\n    (S : Subalgebra R A) : LinearOrderedCommRing S :=\n  S.toSubring.toLinearOrderedCommRing", "start": [326, 1], "end": [328, 38], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubmodule", "code": "def toSubmodule : Subalgebra R A \u21aao Submodule R A where\n  toEmbedding :=\n    { toFun := fun S =>\n        { S with\n          carrier := S\n          smul_mem' := fun c {x} hx \u21a6\n            (Algebra.smul_def c x).symm \u25b8 mul_mem (S.range_le \u27e8c, rfl\u27e9) hx }\n      inj' := fun _ _ h \u21a6 ext <| fun x \u21a6 SetLike.ext_iff.mp h x }\n  map_rel_iff' := SetLike.coe_subset_coe.symm.trans SetLike.coe_subset_coe", "start": [333, 1], "end": [342, 75], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_toSubmodule", "code": "@[simp]\ntheorem mem_toSubmodule {x} : x \u2208 (toSubmodule S) \u2194 x \u2208 S", "start": [347, 1], "end": [348, 69], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_toSubmodule", "code": "@[simp]\ntheorem coe_toSubmodule (S : Subalgebra R A) : (toSubmodule S : Set A) = S", "start": [351, 1], "end": [352, 82], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.module'", "code": "instance module' [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] : Module R' S :=\n  S.toSubmodule.module'", "start": [360, 1], "end": [361, 24], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.algebra'", "code": "instance algebra' [CommSemiring R'] [SMul R' R] [Algebra R' A] [IsScalarTower R' R A] :\n    Algebra R' S :=\n  { (algebraMap R' A).codRestrict S fun x => by\n      rw [Algebra.algebraMap_eq_smul_one, \u2190 smul_one_smul R x (1 : A), \u2190\n        Algebra.algebraMap_eq_smul_one]\n      exact algebraMap_mem S\n          _ with\n    commutes' := fun c x => Subtype.eq <| Algebra.commutes _ _\n    smul_def' := fun c x => Subtype.eq <| Algebra.smul_def _ _ }", "start": [370, 1], "end": [378, 65], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.algebra", "code": "instance algebra : Algebra R S := S.algebra'", "start": [381, 1], "end": [381, 45], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.noZeroSMulDivisors_bot", "code": "instance noZeroSMulDivisors_bot [NoZeroSMulDivisors R A] : NoZeroSMulDivisors R S :=\n  \u27e8fun {c} {x : S} h =>\n    have : c = 0 \u2228 (x : A) = 0 := eq_zero_or_eq_zero_of_smul_eq_zero (congr_arg Subtype.val h)\n    this.imp_right (@Subtype.ext_iff _ _ x 0).mpr\u27e9", "start": [386, 1], "end": [389, 51], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_add", "code": "protected theorem coe_add (x y : S) : (\u2191(x + y) : A) = \u2191x + \u2191y", "start": [392, 1], "end": [392, 70], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_mul", "code": "protected theorem coe_mul (x y : S) : (\u2191(x * y) : A) = \u2191x * \u2191y", "start": [395, 1], "end": [395, 70], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_zero", "code": "protected theorem coe_zero : ((0 : S) : A) = 0", "start": [398, 1], "end": [398, 54], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_one", "code": "protected theorem coe_one : ((1 : S) : A) = 1", "start": [401, 1], "end": [401, 53], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_neg", "code": "protected theorem coe_neg {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : Subalgebra R A} (x : S) : (\u2191(-x) : A) = -\u2191x", "start": [404, 1], "end": [405, 60], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_sub", "code": "protected theorem coe_sub {R : Type u} {A : Type v} [CommRing R] [Ring A] [Algebra R A]\n    {S : Subalgebra R A} (x y : S) : (\u2191(x - y) : A) = \u2191x - \u2191y", "start": [408, 1], "end": [409, 69], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul [Semiring R'] [SMul R' R] [Module R' A] [IsScalarTower R' R A] (r : R') (x : S) :\n    (\u2191(r \u2022 x) : A) = r \u2022 (x : A)", "start": [412, 1], "end": [414, 40], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_algebraMap", "code": "@[simp, norm_cast]\ntheorem coe_algebraMap [CommSemiring R'] [SMul R' R] [Algebra R' A] [IsScalarTower R' R A]\n    (r : R') : \u2191(algebraMap R' S r) = algebraMap R' A r", "start": [417, 1], "end": [419, 63], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_pow", "code": "protected theorem coe_pow (x : S) (n : \u2115) : (\u2191(x ^ n) : A) = (x : A) ^ n", "start": [422, 1], "end": [423, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_eq_zero", "code": "protected theorem coe_eq_zero {x : S} : (x : A) = 0 \u2194 x = 0", "start": [426, 1], "end": [427, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_eq_one", "code": "protected theorem coe_eq_one {x : S} : (x : A) = 1 \u2194 x = 1", "start": [430, 1], "end": [431, 25], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.val", "code": "def val : S \u2192\u2090[R] A :=\n  { toFun := ((\u2191) : S \u2192 A)\n    map_zero' := rfl\n    map_one' := rfl\n    map_add' := fun _ _ \u21a6 rfl\n    map_mul' := fun _ _ \u21a6 rfl\n    commutes' := fun _ \u21a6 rfl }", "start": [436, 1], "end": [443, 31], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_val", "code": "@[simp]\ntheorem coe_val : (S.val : S \u2192 A) = ((\u2191) : S \u2192 A)", "start": [446, 1], "end": [447, 57], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.val_apply", "code": "theorem val_apply (x : S) : S.val x = (x : A)", "start": [450, 1], "end": [450, 53], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubsemiring_subtype", "code": "@[simp]\ntheorem toSubsemiring_subtype : S.toSubsemiring.subtype = (S.val : S \u2192+* A)", "start": [453, 1], "end": [454, 83], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubring_subtype", "code": "@[simp]\ntheorem toSubring_subtype {R A : Type*} [CommRing R] [Ring A] [Algebra R A] (S : Subalgebra R A) :\n    S.toSubring.subtype = (S.val : S \u2192+* A)", "start": [457, 1], "end": [459, 51], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubmoduleEquiv", "code": "def toSubmoduleEquiv (S : Subalgebra R A) : toSubmodule S \u2243\u2097[R] S :=\n  LinearEquiv.ofEq _ _ rfl", "start": [462, 1], "end": [465, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map", "code": "def map (f : A \u2192\u2090[R] B) (S : Subalgebra R A) : Subalgebra R B :=\n  { S.toSubsemiring.map (f : A \u2192+* B) with\n    algebraMap_mem' := fun r => f.commutes r \u25b8 Set.mem_image_of_mem _ (S.algebraMap_mem r) }", "start": [468, 1], "end": [471, 93], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_mono", "code": "theorem map_mono {S\u2081 S\u2082 : Subalgebra R A} {f : A \u2192\u2090[R] B} : S\u2081 \u2264 S\u2082 \u2192 S\u2081.map f \u2264 S\u2082.map f", "start": [474, 1], "end": [475, 21], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_injective", "code": "theorem map_injective {f : A \u2192\u2090[R] B} (hf : Function.Injective f) : Function.Injective (map f)", "start": [478, 1], "end": [480, 87], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_id", "code": "@[simp]\ntheorem map_id (S : Subalgebra R A) : S.map (AlgHom.id R A) = S", "start": [483, 1], "end": [485, 42], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_map", "code": "theorem map_map (S : Subalgebra R A) (g : B \u2192\u2090[R] C) (f : A \u2192\u2090[R] B) :\n    (S.map f).map g = S.map (g.comp f)", "start": [488, 1], "end": [490, 49], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_map", "code": "@[simp]\ntheorem mem_map {S : Subalgebra R A} {f : A \u2192\u2090[R] B} {y : B} : y \u2208 map f S \u2194 \u2203 x \u2208 S, f x = y", "start": [493, 1], "end": [495, 22], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_toSubmodule", "code": "theorem map_toSubmodule {S : Subalgebra R A} {f : A \u2192\u2090[R] B} :\n    (toSubmodule $ S.map f) = S.toSubmodule.map f.toLinearMap", "start": [498, 1], "end": [500, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_toSubsemiring", "code": "theorem map_toSubsemiring {S : Subalgebra R A} {f : A \u2192\u2090[R] B} :\n    (S.map f).toSubsemiring = S.toSubsemiring.map f.toRingHom", "start": [503, 1], "end": [505, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_map", "code": "@[simp]\ntheorem coe_map (S : Subalgebra R A) (f : A \u2192\u2090[R] B) : (S.map f : Set B) = f '' S", "start": [508, 1], "end": [509, 89], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.comap", "code": "def comap (f : A \u2192\u2090[R] B) (S : Subalgebra R B) : Subalgebra R A :=\n  { S.toSubsemiring.comap (f : A \u2192+* B) with\n    algebraMap_mem' := fun r =>\n      show f (algebraMap R A r) \u2208 S from (f.commutes r).symm \u25b8 S.algebraMap_mem r }", "start": [512, 1], "end": [516, 84], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.map_le", "code": "theorem map_le {S : Subalgebra R A} {f : A \u2192\u2090[R] B} {U : Subalgebra R B} :\n    map f S \u2264 U \u2194 S \u2264 comap f U", "start": [519, 1], "end": [521, 23], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.gc_map_comap", "code": "theorem gc_map_comap (f : A \u2192\u2090[R] B) : GaloisConnection (map f) (comap f)", "start": [524, 1], "end": [524, 97], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_comap", "code": "@[simp]\ntheorem mem_comap (S : Subalgebra R B) (f : A \u2192\u2090[R] B) (x : A) : x \u2208 S.comap f \u2194 f x \u2208 S", "start": [527, 1], "end": [529, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_comap", "code": "@[simp, norm_cast]\ntheorem coe_comap (S : Subalgebra R B) (f : A \u2192\u2090[R] B) : (S.comap f : Set A) = f \u207b\u00b9' (S : Set B)", "start": [532, 1], "end": [534, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.noZeroDivisors", "code": "instance noZeroDivisors {R A : Type*} [CommSemiring R] [Semiring A] [NoZeroDivisors A]\n    [Algebra R A] (S : Subalgebra R A) : NoZeroDivisors S :=\n  inferInstanceAs (NoZeroDivisors S.toSubsemiring)", "start": [537, 1], "end": [539, 51], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isDomain", "code": "instance isDomain {R A : Type*} [CommRing R] [Ring A] [IsDomain A] [Algebra R A]\n    (S : Subalgebra R A) : IsDomain S :=\n  inferInstanceAs (IsDomain S.toSubring)", "start": [542, 1], "end": [544, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubalgebra", "code": "def toSubalgebra (p : Submodule R A) (h_one : (1 : A) \u2208 p)\n    (h_mul : \u2200 x y, x \u2208 p \u2192 y \u2208 p \u2192 x * y \u2208 p) : Subalgebra R A :=\n  { p with\n    mul_mem' := fun hx hy \u21a6 h_mul _ _ hx hy\n    one_mem' := h_one\n    algebraMap_mem' := fun r => by\n      rw [Algebra.algebraMap_eq_smul_one]\n      exact p.smul_mem _ h_one }", "start": [555, 1], "end": [563, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_toSubalgebra", "code": "@[simp]\ntheorem mem_toSubalgebra {p : Submodule R A} {h_one h_mul} {x} :\n    x \u2208 p.toSubalgebra h_one h_mul \u2194 x \u2208 p", "start": [566, 1], "end": [568, 54], "kind": "commanddeclaration"}, {"full_name": "Submodule.coe_toSubalgebra", "code": "@[simp]\ntheorem coe_toSubalgebra (p : Submodule R A) (h_one h_mul) :\n    (p.toSubalgebra h_one h_mul : Set A) = p", "start": [571, 1], "end": [573, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubalgebra_mk", "code": "theorem toSubalgebra_mk (s : Submodule R A) (h1 hmul) :\n    s.toSubalgebra h1 hmul =\n      Subalgebra.mk \u27e8\u27e8\u27e8s, @hmul\u27e9, h1\u27e9, s.add_mem, s.zero_mem\u27e9\n        (by intro r; rw [Algebra.algebraMap_eq_smul_one]; apply s.smul_mem _ h1)", "start": [578, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "Submodule.toSubalgebra_toSubmodule", "code": "@[simp]\ntheorem toSubalgebra_toSubmodule (p : Submodule R A) (h_one h_mul) :\n    Subalgebra.toSubmodule (p.toSubalgebra h_one h_mul) = p", "start": [585, 1], "end": [588, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toSubmodule_toSubalgebra", "code": "@[simp]\ntheorem _root_.Subalgebra.toSubmodule_toSubalgebra (S : Subalgebra R A) :\n    (S.toSubmodule.toSubalgebra S.one_mem fun _ _ => S.mul_mem) = S", "start": [591, 1], "end": [594, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.range", "code": "protected def range (\u03c6 : A \u2192\u2090[R] B) : Subalgebra R B :=\n  { \u03c6.toRingHom.rangeS with algebraMap_mem' := fun r => \u27e8algebraMap R A r, \u03c6.commutes r\u27e9 }", "start": [609, 1], "end": [611, 91], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mem_range", "code": "@[simp]\ntheorem mem_range (\u03c6 : A \u2192\u2090[R] B) {y : B} : y \u2208 \u03c6.range \u2194 \u2203 x, \u03c6 x = y", "start": [614, 1], "end": [616, 21], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mem_range_self", "code": "theorem mem_range_self (\u03c6 : A \u2192\u2090[R] B) (x : A) : \u03c6 x \u2208 \u03c6.range", "start": [619, 1], "end": [620, 25], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_range", "code": "@[simp]\ntheorem coe_range (\u03c6 : A \u2192\u2090[R] B) : (\u03c6.range : Set B) = Set.range \u03c6", "start": [623, 1], "end": [627, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.range_comp", "code": "theorem range_comp (f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C) : (g.comp f).range = f.range.map g", "start": [630, 1], "end": [631, 45], "kind": "commanddeclaration"}, {"full_name": "AlgHom.range_comp_le_range", "code": "theorem range_comp_le_range (f : A \u2192\u2090[R] B) (g : B \u2192\u2090[R] C) : (g.comp f).range \u2264 g.range", "start": [634, 1], "end": [635, 53], "kind": "commanddeclaration"}, {"full_name": "AlgHom.codRestrict", "code": "def codRestrict (f : A \u2192\u2090[R] B) (S : Subalgebra R B) (hf : \u2200 x, f x \u2208 S) : A \u2192\u2090[R] S :=\n  { RingHom.codRestrict (f : A \u2192+* B) S hf with commutes' := fun r => Subtype.eq <| f.commutes r }", "start": [638, 1], "end": [640, 99], "kind": "commanddeclaration"}, {"full_name": "AlgHom.val_comp_codRestrict", "code": "@[simp]\ntheorem val_comp_codRestrict (f : A \u2192\u2090[R] B) (S : Subalgebra R B) (hf : \u2200 x, f x \u2208 S) :\n    S.val.comp (f.codRestrict S hf) = f", "start": [643, 1], "end": [646, 26], "kind": "commanddeclaration"}, {"full_name": "AlgHom.coe_codRestrict", "code": "@[simp]\ntheorem coe_codRestrict (f : A \u2192\u2090[R] B) (S : Subalgebra R B) (hf : \u2200 x, f x \u2208 S) (x : A) :\n    \u2191(f.codRestrict S hf x) = f x", "start": [649, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "AlgHom.injective_codRestrict", "code": "theorem injective_codRestrict (f : A \u2192\u2090[R] B) (S : Subalgebra R B) (hf : \u2200 x, f x \u2208 S) :\n    Function.Injective (f.codRestrict S hf) \u2194 Function.Injective f", "start": [655, 1], "end": [657, 97], "kind": "commanddeclaration"}, {"full_name": "AlgHom.rangeRestrict", "code": "@[reducible]\ndef rangeRestrict (f : A \u2192\u2090[R] B) : A \u2192\u2090[R] f.range :=\n  f.codRestrict f.range f.mem_range_self", "start": [660, 1], "end": [665, 41], "kind": "commanddeclaration"}, {"full_name": "AlgHom.equalizer", "code": "def equalizer (\u03d5 \u03c8 : A \u2192\u2090[R] B) : Subalgebra R A where\n  carrier := { a | \u03d5 a = \u03c8 a }\n  zero_mem' := by simp only [Set.mem_setOf_eq, map_zero]\n  one_mem' := by simp only [Set.mem_setOf_eq, map_one]\n  add_mem' {x y} (hx : \u03d5 x = \u03c8 x) (hy : \u03d5 y = \u03c8 y) := by\n    rw [Set.mem_setOf_eq, \u03d5.map_add, \u03c8.map_add, hx, hy]\n  mul_mem' {x y} (hx : \u03d5 x = \u03c8 x) (hy : \u03d5 y = \u03c8 y) := by\n    rw [Set.mem_setOf_eq, \u03d5.map_mul, \u03c8.map_mul, hx, hy]\n  algebraMap_mem' x := by rw [Set.mem_setOf_eq, AlgHom.commutes, AlgHom.commutes]", "start": [668, 1], "end": [677, 82], "kind": "commanddeclaration"}, {"full_name": "AlgHom.mem_equalizer", "code": "@[simp]\ntheorem mem_equalizer (\u03d5 \u03c8 : A \u2192\u2090[R] B) (x : A) : x \u2208 \u03d5.equalizer \u03c8 \u2194 \u03d5 x = \u03c8 x", "start": [680, 1], "end": [682, 10], "kind": "commanddeclaration"}, {"full_name": "AlgHom.fintypeRange", "code": "instance fintypeRange [Fintype A] [DecidableEq B] (\u03c6 : A \u2192\u2090[R] B) : Fintype \u03c6.range :=\n  Set.fintypeRange \u03c6", "start": [685, 1], "end": [689, 21], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLeftInverse", "code": "def ofLeftInverse {g : B \u2192 A} {f : A \u2192\u2090[R] B} (h : Function.LeftInverse g f) : A \u2243\u2090[R] f.range :=\n  { f.rangeRestrict with\n    toFun := f.rangeRestrict\n    invFun := g \u2218 f.range.val\n    left_inv := h\n    right_inv := fun x =>\n      Subtype.ext <|\n        let \u27e8x', hx'\u27e9 := f.mem_range.mp x.prop\n        show f (g x) = x by rw [\u2190 hx', h x'] }", "start": [700, 1], "end": [711, 47], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLeftInverse_apply", "code": "@[simp]\ntheorem ofLeftInverse_apply {g : B \u2192 A} {f : A \u2192\u2090[R] B} (h : Function.LeftInverse g f) (x : A) :\n    \u2191(ofLeftInverse h x) = f x", "start": [714, 1], "end": [717, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofLeftInverse_symm_apply", "code": "@[simp]\ntheorem ofLeftInverse_symm_apply {g : B \u2192 A} {f : A \u2192\u2090[R] B} (h : Function.LeftInverse g f)\n    (x : f.range) : (ofLeftInverse h).symm x = g x", "start": [720, 1], "end": [723, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofInjective", "code": "noncomputable def ofInjective (f : A \u2192\u2090[R] B) (hf : Function.Injective f) : A \u2243\u2090[R] f.range :=\n  ofLeftInverse (Classical.choose_spec hf.hasLeftInverse)", "start": [726, 1], "end": [728, 58], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofInjective_apply", "code": "@[simp]\ntheorem ofInjective_apply (f : A \u2192\u2090[R] B) (hf : Function.Injective f) (x : A) :\n    \u2191(ofInjective f hf x) = f x", "start": [731, 1], "end": [734, 6], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.ofInjectiveField", "code": "noncomputable def ofInjectiveField {E F : Type*} [DivisionRing E] [Semiring F] [Nontrivial F]\n    [Algebra R E] [Algebra R F] (f : E \u2192\u2090[R] F) : E \u2243\u2090[R] f.range :=\n  ofInjective f f.toRingHom.injective", "start": [737, 1], "end": [740, 38], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.subalgebraMap", "code": "@[simps!]\ndef subalgebraMap (e : A \u2243\u2090[R] B) (S : Subalgebra R A) : S \u2243\u2090[R] S.map e.toAlgHom :=\n  { e.toRingEquiv.subsemiringMap S.toSubsemiring with\n    commutes' := fun r => by\n      ext; dsimp only; erw [RingEquiv.subsemiringMap_apply_coe]\n      exact e.commutes _ }", "start": [743, 1], "end": [750, 27], "kind": "commanddeclaration"}, {"full_name": "Algebra.adjoin", "code": "def adjoin (s : Set A) : Subalgebra R A :=\n  { Subsemiring.closure (Set.range (algebraMap R A) \u222a s) with\n    algebraMap_mem' := fun r => Subsemiring.subset_closure <| Or.inl \u27e8r, rfl\u27e9 }", "start": [764, 1], "end": [767, 80], "kind": "commanddeclaration"}, {"full_name": "Algebra.gc", "code": "protected theorem gc : GaloisConnection (adjoin R : Set A \u2192 Subalgebra R A) (\u2191)", "start": [772, 1], "end": [775, 69], "kind": "commanddeclaration"}, {"full_name": "Algebra.gi", "code": "protected def gi : GaloisInsertion (adjoin R : Set A \u2192 Subalgebra R A) (\u2191) where\n  choice s hs := (adjoin R s).copy s <| le_antisymm (Algebra.gc.le_u_l s) hs\n  gc := Algebra.gc\n  le_l_u S := (Algebra.gc (S : Set A) (adjoin R S)).1 <| le_rfl\n  choice_eq _ _ := Subalgebra.copy_eq _ _ _", "start": [778, 1], "end": [783, 44], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_top", "code": "@[simp]\ntheorem coe_top : (\u2191(\u22a4 : Subalgebra R A) : Set A) = Set.univ", "start": [789, 1], "end": [790, 68], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_top", "code": "@[simp]\ntheorem mem_top {x : A} : x \u2208 (\u22a4 : Subalgebra R A)", "start": [793, 1], "end": [794, 69], "kind": "commanddeclaration"}, {"full_name": "Algebra.top_toSubmodule", "code": "@[simp]\ntheorem top_toSubmodule : Subalgebra.toSubmodule (\u22a4 : Subalgebra R A) = \u22a4", "start": [797, 1], "end": [798, 81], "kind": "commanddeclaration"}, {"full_name": "Algebra.top_toSubsemiring", "code": "@[simp]\ntheorem top_toSubsemiring : (\u22a4 : Subalgebra R A).toSubsemiring = \u22a4", "start": [801, 1], "end": [802, 74], "kind": "commanddeclaration"}, {"full_name": "Algebra.top_toSubring", "code": "@[simp]\ntheorem top_toSubring {R A : Type*} [CommRing R] [Ring A] [Algebra R A] :\n    (\u22a4 : Subalgebra R A).toSubring = \u22a4", "start": [805, 1], "end": [807, 46], "kind": "commanddeclaration"}, {"full_name": "Algebra.toSubmodule_eq_top", "code": "@[simp]\ntheorem toSubmodule_eq_top {S : Subalgebra R A} : Subalgebra.toSubmodule S = \u22a4 \u2194 S = \u22a4", "start": [810, 1], "end": [812, 59], "kind": "commanddeclaration"}, {"full_name": "Algebra.toSubsemiring_eq_top", "code": "@[simp]\ntheorem toSubsemiring_eq_top {S : Subalgebra R A} : S.toSubsemiring = \u22a4 \u2194 S = \u22a4", "start": [815, 1], "end": [817, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.toSubring_eq_top", "code": "@[simp]\ntheorem toSubring_eq_top {R A : Type*} [CommRing R] [Ring A] [Algebra R A] {S : Subalgebra R A} :\n    S.toSubring = \u22a4 \u2194 S = \u22a4", "start": [820, 1], "end": [823, 55], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_sup_left", "code": "theorem mem_sup_left {S T : Subalgebra R A} : \u2200 {x : A}, x \u2208 S \u2192 x \u2208 S \u2294 T", "start": [826, 1], "end": [827, 44], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_sup_right", "code": "theorem mem_sup_right {S T : Subalgebra R A} : \u2200 {x : A}, x \u2208 T \u2192 x \u2208 S \u2294 T", "start": [830, 1], "end": [831, 45], "kind": "commanddeclaration"}, {"full_name": "Algebra.mul_mem_sup", "code": "theorem mul_mem_sup {S T : Subalgebra R A} {x y : A} (hx : x \u2208 S) (hy : y \u2208 T) : x * y \u2208 S \u2294 T", "start": [834, 1], "end": [835, 55], "kind": "commanddeclaration"}, {"full_name": "Algebra.map_sup", "code": "theorem map_sup (f : A \u2192\u2090[R] B) (S T : Subalgebra R A) : (S \u2294 T).map f = S.map f \u2294 T.map f", "start": [838, 1], "end": [839, 36], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_inf", "code": "@[simp, norm_cast]\ntheorem coe_inf (S T : Subalgebra R A) : (\u2191(S \u2293 T) : Set A) = (S \u2229 T : Set A)", "start": [842, 1], "end": [843, 85], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_inf", "code": "@[simp]\ntheorem mem_inf {S T : Subalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T", "start": [846, 1], "end": [847, 86], "kind": "commanddeclaration"}, {"full_name": "Algebra.inf_toSubmodule", "code": "@[simp]\ntheorem inf_toSubmodule (S T : Subalgebra R A) :\n    toSubmodule (S \u2293 T) = toSubmodule S \u2293 toSubmodule T", "start": [851, 1], "end": [853, 63], "kind": "commanddeclaration"}, {"full_name": "Algebra.inf_toSubsemiring", "code": "@[simp]\ntheorem inf_toSubsemiring (S T : Subalgebra R A) :\n    (S \u2293 T).toSubsemiring = S.toSubsemiring \u2293 T.toSubsemiring", "start": [856, 1], "end": [859, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subalgebra R A)) : (\u2191(sInf S) : Set A) = \u22c2 s \u2208 S, \u2191s", "start": [862, 1], "end": [864, 13], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_sInf", "code": "theorem mem_sInf {S : Set (Subalgebra R A)} {x : A} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [867, 1], "end": [868, 59], "kind": "commanddeclaration"}, {"full_name": "Algebra.sInf_toSubmodule", "code": "@[simp]\ntheorem sInf_toSubmodule (S : Set (Subalgebra R A)) :\n    Subalgebra.toSubmodule (sInf S) = sInf (Subalgebra.toSubmodule '' S)", "start": [871, 1], "end": [874, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.sInf_toSubsemiring", "code": "@[simp]\ntheorem sInf_toSubsemiring (S : Set (Subalgebra R A)) :\n    (sInf S).toSubsemiring = sInf (Subalgebra.toSubsemiring '' S)", "start": [877, 1], "end": [880, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_iInf", "code": "@[simp, norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subalgebra R A} : (\u2191(\u2a05 i, S i) : Set A) = \u22c2 i, S i", "start": [883, 1], "end": [885, 14], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_iInf", "code": "theorem mem_iInf {\u03b9 : Sort*} {S : \u03b9 \u2192 Subalgebra R A} {x : A} : (x \u2208 \u2a05 i, S i) \u2194 \u2200 i, x \u2208 S i", "start": [888, 1], "end": [889, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.iInf_toSubmodule", "code": "@[simp]\ntheorem iInf_toSubmodule {\u03b9 : Sort*} (S : \u03b9 \u2192 Subalgebra R A) :\n    toSubmodule (\u2a05 i, S i) = \u2a05 i, toSubmodule (S i)", "start": [893, 1], "end": [896, 35], "kind": "commanddeclaration"}, {"full_name": "Algebra.mem_bot", "code": "theorem mem_bot {x : A} : x \u2208 (\u22a5 : Subalgebra R A) \u2194 x \u2208 Set.range (algebraMap R A)", "start": [901, 1], "end": [905, 78], "kind": "commanddeclaration"}, {"full_name": "Algebra.toSubmodule_bot", "code": "theorem toSubmodule_bot : Subalgebra.toSubmodule (\u22a5 : Subalgebra R A) = R \u2219 1", "start": [908, 1], "end": [910, 65], "kind": "commanddeclaration"}, {"full_name": "Algebra.coe_bot", "code": "@[simp]\ntheorem coe_bot : ((\u22a5 : Subalgebra R A) : Set A) = Set.range (algebraMap R A)", "start": [913, 1], "end": [915, 38], "kind": "commanddeclaration"}, {"full_name": "Algebra.eq_top_iff", "code": "theorem eq_top_iff {S : Subalgebra R A} : S = \u22a4 \u2194 \u2200 x : A, x \u2208 S", "start": [918, 1], "end": [920, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.range_top_iff_surjective", "code": "theorem range_top_iff_surjective (f : A \u2192\u2090[R] B) :\n    f.range = (\u22a4 : Subalgebra R B) \u2194 Function.Surjective f", "start": [923, 1], "end": [925, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.range_id", "code": "@[simp]\ntheorem range_id : (AlgHom.id R A).range = \u22a4", "start": [928, 1], "end": [930, 37], "kind": "commanddeclaration"}, {"full_name": "Algebra.map_top", "code": "@[simp]\ntheorem map_top (f : A \u2192\u2090[R] B) : (\u22a4 : Subalgebra R A).map f = f.range", "start": [933, 1], "end": [935, 39], "kind": "commanddeclaration"}, {"full_name": "Algebra.map_bot", "code": "@[simp]\ntheorem map_bot (f : A \u2192\u2090[R] B) : (\u22a5 : Subalgebra R A).map f = \u22a5", "start": [938, 1], "end": [941, 91], "kind": "commanddeclaration"}, {"full_name": "Algebra.comap_top", "code": "@[simp]\ntheorem comap_top (f : A \u2192\u2090[R] B) : (\u22a4 : Subalgebra R B).comap f = \u22a4", "start": [944, 1], "end": [946, 33], "kind": "commanddeclaration"}, {"full_name": "Algebra.toTop", "code": "def toTop : A \u2192\u2090[R] (\u22a4 : Subalgebra R A) :=\n  (AlgHom.id R A).codRestrict \u22a4 fun _ => mem_top", "start": [949, 1], "end": [951, 49], "kind": "commanddeclaration"}, {"full_name": "Algebra.surjective_algebraMap_iff", "code": "theorem surjective_algebraMap_iff :\n    Function.Surjective (algebraMap R A) \u2194 (\u22a4 : Subalgebra R A) = \u22a5", "start": [954, 1], "end": [960, 78], "kind": "commanddeclaration"}, {"full_name": "Algebra.bijective_algebraMap_iff", "code": "theorem bijective_algebraMap_iff {R A : Type*} [Field R] [Semiring A] [Nontrivial A]\n    [Algebra R A] : Function.Bijective (algebraMap R A) \u2194 (\u22a4 : Subalgebra R A) = \u22a5", "start": [963, 1], "end": [966, 65], "kind": "commanddeclaration"}, {"full_name": "Algebra.botEquivOfInjective", "code": "noncomputable def botEquivOfInjective (h : Function.Injective (algebraMap R A)) :\n    (\u22a5 : Subalgebra R A) \u2243\u2090[R] R :=\n  AlgEquiv.symm <|\n    AlgEquiv.ofBijective (Algebra.ofId R _)\n      \u27e8fun _x _y hxy => h (congr_arg Subtype.val hxy : _), fun \u27e8_y, hy\u27e9 =>\n        let \u27e8x, hx\u27e9 := Algebra.mem_bot.1 hy\n        \u27e8x, Subtype.eq hx\u27e9\u27e9", "start": [969, 1], "end": [976, 28], "kind": "commanddeclaration"}, {"full_name": "Algebra.botEquiv", "code": "@[simps! symm_apply]\nnoncomputable def botEquiv (F R : Type*) [Field F] [Semiring R] [Nontrivial R] [Algebra F R] :\n    (\u22a5 : Subalgebra F R) \u2243\u2090[F] F :=\n  botEquivOfInjective (RingHom.injective _)", "start": [979, 1], "end": [983, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.topEquiv", "code": "@[simps!]\ndef topEquiv : (\u22a4 : Subalgebra R A) \u2243\u2090[R] A :=\n  AlgEquiv.ofAlgHom (Subalgebra.val \u22a4) toTop rfl <| AlgHom.ext fun _ => Subtype.ext rfl", "start": [998, 1], "end": [1003, 88], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.subsingleton_of_subsingleton", "code": "instance subsingleton_of_subsingleton [Subsingleton A] : Subsingleton (Subalgebra R A) :=\n  \u27e8fun B C => ext fun x => by simp only [Subsingleton.elim x 0, zero_mem B, zero_mem C]\u27e9", "start": [1006, 1], "end": [1007, 89], "kind": "commanddeclaration"}, {"full_name": "AlgHom.subsingleton", "code": "instance _root_.AlgHom.subsingleton [Subsingleton (Subalgebra R A)] : Subsingleton (A \u2192\u2090[R] B) :=\n  \u27e8fun f g =>\n    AlgHom.ext fun a =>\n      have : a \u2208 (\u22a5 : Subalgebra R A) := Subsingleton.elim (\u22a4 : Subalgebra R A) \u22a5 \u25b8 mem_top\n      let \u27e8_x, hx\u27e9 := Set.mem_range.mp (mem_bot.mp this)\n      hx \u25b8 (f.commutes _).trans (g.commutes _).symm\u27e9", "start": [1010, 1], "end": [1015, 53], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.subsingleton_left", "code": "instance _root_.AlgEquiv.subsingleton_left [Subsingleton (Subalgebra R A)] :\n    Subsingleton (A \u2243\u2090[R] B) :=\n  \u27e8fun f g => AlgEquiv.ext fun x => AlgHom.ext_iff.mp (Subsingleton.elim f.toAlgHom g.toAlgHom) x\u27e9", "start": [1018, 1], "end": [1020, 99], "kind": "commanddeclaration"}, {"full_name": "AlgEquiv.subsingleton_right", "code": "instance _root_.AlgEquiv.subsingleton_right [Subsingleton (Subalgebra R B)] :\n    Subsingleton (A \u2243\u2090[R] B) :=\n  \u27e8fun f g => by rw [\u2190 f.symm_symm, Subsingleton.elim f.symm g.symm, g.symm_symm]\u27e9", "start": [1023, 1], "end": [1025, 83], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.range_val", "code": "theorem range_val : S.val.range = S", "start": [1028, 1], "end": [1029, 66], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion", "code": "def inclusion {S T : Subalgebra R A} (h : S \u2264 T) : S \u2192\u2090[R] T\n    where\n  toFun := Set.inclusion h\n  map_one' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl\n  map_zero' := rfl\n  commutes' _ := rfl", "start": [1040, 1], "end": [1050, 21], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion_injective", "code": "theorem inclusion_injective {S T : Subalgebra R A} (h : S \u2264 T) : Function.Injective (inclusion h)", "start": [1053, 1], "end": [1054, 42], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion_self", "code": "@[simp]\ntheorem inclusion_self {S : Subalgebra R A} : inclusion (le_refl S) = AlgHom.id R S", "start": [1057, 1], "end": [1059, 39], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion_mk", "code": "@[simp]\ntheorem inclusion_mk {S T : Subalgebra R A} (h : S \u2264 T) (x : A) (hx : x \u2208 S) :\n    inclusion h \u27e8x, hx\u27e9 = \u27e8x, h hx\u27e9", "start": [1062, 1], "end": [1065, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion_right", "code": "theorem inclusion_right {S T : Subalgebra R A} (h : S \u2264 T) (x : T) (m : (x : A) \u2208 S) :\n    inclusion h \u27e8x, m\u27e9 = x", "start": [1068, 1], "end": [1070, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.inclusion_inclusion", "code": "@[simp]\ntheorem inclusion_inclusion {S T U : Subalgebra R A} (hst : S \u2264 T) (htu : T \u2264 U) (x : S) :\n    inclusion htu (inclusion hst x) = inclusion (le_trans hst htu) x", "start": [1073, 1], "end": [1076, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_inclusion", "code": "@[simp]\ntheorem coe_inclusion {S T : Subalgebra R A} (h : S \u2264 T) (s : S) : (inclusion h s : A) = s", "start": [1079, 1], "end": [1081, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.equivOfEq", "code": "@[simps apply]\ndef equivOfEq (S T : Subalgebra R A) (h : S = T) : S \u2243\u2090[R] T :=\n  { LinearEquiv.ofEq _ _ (congr_arg toSubmodule h) with\n    toFun := fun x => \u27e8x, h \u25b8 x.2\u27e9\n    invFun := fun x => \u27e8x, h.symm \u25b8 x.2\u27e9\n    map_mul' := fun _ _ => rfl\n    commutes' := fun _ => rfl }", "start": [1084, 1], "end": [1093, 32], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.equivOfEq_symm", "code": "@[simp]\ntheorem equivOfEq_symm (S T : Subalgebra R A) (h : S = T) :\n    (equivOfEq S T h).symm = equivOfEq T S h.symm", "start": [1096, 1], "end": [1098, 57], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.equivOfEq_rfl", "code": "@[simp]\ntheorem equivOfEq_rfl (S : Subalgebra R A) : equivOfEq S S rfl = AlgEquiv.refl", "start": [1101, 1], "end": [1102, 94], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.equivOfEq_trans", "code": "@[simp]\ntheorem equivOfEq_trans (S T U : Subalgebra R A) (hST : S = T) (hTU : T = U) :\n    (equivOfEq S T hST).trans (equivOfEq T U hTU) = equivOfEq S U (hST.trans hTU)", "start": [1105, 1], "end": [1107, 89], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod", "code": "def prod : Subalgebra R (A \u00d7 B) :=\n  { S.toSubsemiring.prod S\u2081.toSubsemiring with\n    carrier := S \u00d7\u02e2 S\u2081\n    algebraMap_mem' := fun _ => \u27e8algebraMap_mem _ _, algebraMap_mem _ _\u27e9 }", "start": [1114, 1], "end": [1118, 75], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_prod", "code": "@[simp]\ntheorem coe_prod : (prod S S\u2081 : Set (A \u00d7 B)) = (S : Set A) \u00d7\u02e2 (S\u2081 : Set B)", "start": [1121, 1], "end": [1123, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod_toSubmodule", "code": "theorem prod_toSubmodule : toSubmodule (S.prod S\u2081) = (toSubmodule S).prod (toSubmodule S\u2081)", "start": [1127, 1], "end": [1127, 98], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_prod", "code": "@[simp]\ntheorem mem_prod {S : Subalgebra R A} {S\u2081 : Subalgebra R B} {x : A \u00d7 B} :\n    x \u2208 prod S S\u2081 \u2194 x.1 \u2208 S \u2227 x.2 \u2208 S\u2081", "start": [1130, 1], "end": [1132, 55], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod_top", "code": "@[simp]\ntheorem prod_top : (prod \u22a4 \u22a4 : Subalgebra R (A \u00d7 B)) = \u22a4", "start": [1135, 1], "end": [1136, 73], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod_mono", "code": "theorem prod_mono {S T : Subalgebra R A} {S\u2081 T\u2081 : Subalgebra R B} :\n    S \u2264 T \u2192 S\u2081 \u2264 T\u2081 \u2192 prod S S\u2081 \u2264 prod T T\u2081", "start": [1139, 1], "end": [1141, 16], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.prod_inf_prod", "code": "@[simp]\ntheorem prod_inf_prod {S T : Subalgebra R A} {S\u2081 T\u2081 : Subalgebra R B} :\n    S.prod S\u2081 \u2293 T.prod T\u2081 = (S \u2293 T).prod (S\u2081 \u2293 T\u2081)", "start": [1144, 1], "end": [1147, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed [Nonempty \u03b9] {S : \u03b9 \u2192 Subalgebra R A} (dir : Directed (\u00b7 \u2264 \u00b7) S) :\n    \u2191(iSup S) = \u22c3 i, (S i : Set A)", "start": [1156, 1], "end": [1180, 18], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.iSupLift", "code": "noncomputable def iSupLift [Nonempty \u03b9] (K : \u03b9 \u2192 Subalgebra R A) (dir : Directed (\u00b7 \u2264 \u00b7) K)\n    (f : \u2200 i, K i \u2192\u2090[R] B) (hf : \u2200 (i j : \u03b9) (h : K i \u2264 K j), f i = (f j).comp (inclusion h))\n    (T : Subalgebra R A) (hT : T = iSup K) : \u21a5T \u2192\u2090[R] B :=\n  { toFun := Set.iUnionLift (fun i => \u2191(K i)) (fun i x => f i x)\n        (fun i j x hxi hxj => by\n          let \u27e8k, hik, hjk\u27e9 := dir i j\n          dsimp\n          rw [hf i k hik, hf j k hjk]\n          rfl)\n        T (by rw [hT, coe_iSup_of_directed dir])\n    map_one' := by apply Set.iUnionLift_const _ (fun _ => 1) <;> simp\n    map_zero' := by dsimp; apply Set.iUnionLift_const _ (fun _ => 0) <;> simp\n    map_mul' := by\n      subst hT; dsimp\n      apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 * \u00b7))\n      on_goal 3 => rw [coe_iSup_of_directed dir]\n      all_goals simp\n    map_add' := by\n      subst hT; dsimp\n      apply Set.iUnionLift_binary (coe_iSup_of_directed dir) dir _ (fun _ => (\u00b7 + \u00b7))\n      on_goal 3 => rw [coe_iSup_of_directed dir]\n      all_goals simp\n    commutes' := fun r => by\n      dsimp\n      apply Set.iUnionLift_const _ (fun _ => algebraMap R _ r) <;> simp }", "start": [1185, 1], "end": [1211, 74], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.iSupLift_inclusion", "code": "@[simp]\ntheorem iSupLift_inclusion {i : \u03b9} (x : K i) (h : K i \u2264 T) :\n    iSupLift K dir f hf T hT (inclusion h x) = f i x", "start": [1218, 1], "end": [1222, 32], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.iSupLift_comp_inclusion", "code": "@[simp]\ntheorem iSupLift_comp_inclusion {i : \u03b9} (h : K i \u2264 T) :\n    (iSupLift K dir f hf T hT).comp (inclusion h) = f i", "start": [1225, 1], "end": [1227, 72], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.iSupLift_mk", "code": "@[simp]\ntheorem iSupLift_mk {i : \u03b9} (x : K i) (hx : (x : A) \u2208 T) :\n    iSupLift K dir f hf T hT \u27e8x, hx\u27e9 = f i x", "start": [1230, 1], "end": [1234, 25], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.iSupLift_of_mem", "code": "theorem iSupLift_of_mem {i : \u03b9} (x : T) (hx : (x : A) \u2208 K i) :\n    iSupLift K dir f hf T hT x = f i \u27e8x, hx\u27e9", "start": [1237, 1], "end": [1240, 29], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.smul_def", "code": "theorem smul_def [SMul A \u03b1] {S : Subalgebra R A} (g : S) (m : \u03b1) : g \u2022 m = (g : A) \u2022 m", "start": [1260, 1], "end": [1260, 94], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.smulCommClass_left", "code": "instance smulCommClass_left [SMul A \u03b2] [SMul \u03b1 \u03b2] [SMulCommClass A \u03b1 \u03b2] (S : Subalgebra R A) :\n    SMulCommClass S \u03b1 \u03b2 :=\n  S.toSubsemiring.smulCommClass_left", "start": [1263, 1], "end": [1265, 37], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.smulCommClass_right", "code": "instance smulCommClass_right [SMul \u03b1 \u03b2] [SMul A \u03b2] [SMulCommClass \u03b1 A \u03b2] (S : Subalgebra R A) :\n    SMulCommClass \u03b1 S \u03b2 :=\n  S.toSubsemiring.smulCommClass_right", "start": [1268, 1], "end": [1270, 38], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isScalarTower_left", "code": "instance isScalarTower_left [SMul \u03b1 \u03b2] [SMul A \u03b1] [SMul A \u03b2] [IsScalarTower A \u03b1 \u03b2]\n    (S : Subalgebra R A) : IsScalarTower S \u03b1 \u03b2 :=\n  inferInstanceAs (IsScalarTower S.toSubsemiring \u03b1 \u03b2)", "start": [1273, 1], "end": [1276, 54], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.isScalarTower_mid", "code": "instance isScalarTower_mid {R S T : Type*} [CommSemiring R] [Semiring S] [AddCommMonoid T]\n    [Algebra R S] [Module R T] [Module S T] [IsScalarTower R S T] (S' : Subalgebra R S) :\n    IsScalarTower R S' T :=\n  \u27e8fun _x y _z => (smul_assoc _ (y : S) _ : _)\u27e9", "start": [1279, 1], "end": [1282, 48], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.moduleLeft", "code": "instance moduleLeft [AddCommMonoid \u03b1] [Module A \u03b1] (S : Subalgebra R A) : Module S \u03b1 :=\n  inferInstanceAs (Module S.toSubsemiring \u03b1)", "start": [1304, 1], "end": [1306, 45], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.toAlgebra", "code": "instance toAlgebra {R A : Type*} [CommSemiring R] [CommSemiring A] [Semiring \u03b1] [Algebra R A]\n    [Algebra A \u03b1] (S : Subalgebra R A) : Algebra S \u03b1 :=\n  Algebra.ofSubsemiring S.toSubsemiring", "start": [1309, 1], "end": [1312, 40], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.algebraMap_eq", "code": "theorem algebraMap_eq {R A : Type*} [CommSemiring R] [CommSemiring A] [Semiring \u03b1] [Algebra R A]\n    [Algebra A \u03b1] (S : Subalgebra R A) : algebraMap S \u03b1 = (algebraMap A \u03b1).comp S.val", "start": [1315, 1], "end": [1317, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.rangeS_algebraMap", "code": "@[simp]\ntheorem rangeS_algebraMap {R A : Type*} [CommSemiring R] [CommSemiring A] [Algebra R A]\n    (S : Subalgebra R A) : (algebraMap S A).rangeS = S.toSubsemiring", "start": [1320, 1], "end": [1324, 32], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.range_algebraMap", "code": "@[simp]\ntheorem range_algebraMap {R A : Type*} [CommRing R] [CommRing A] [Algebra R A]\n    (S : Subalgebra R A) : (algebraMap S A).range = S.toSubring", "start": [1327, 1], "end": [1331, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.noZeroSMulDivisors_top", "code": "instance noZeroSMulDivisors_top [NoZeroDivisors A] (S : Subalgebra R A) : NoZeroSMulDivisors S A :=\n  \u27e8fun {c} x h =>\n    have : (c : A) = 0 \u2228 x = 0 := eq_zero_or_eq_zero_of_mul_eq_zero h\n    this.imp_left (@Subtype.ext_iff _ _ c 0).mpr\u27e9", "start": [1334, 1], "end": [1337, 50], "kind": "commanddeclaration"}, {"full_name": "Set.algebraMap_mem_center", "code": "theorem _root_.Set.algebraMap_mem_center (r : R) : algebraMap R A r \u2208 Set.center A", "start": [1344, 1], "end": [1345, 46], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.center", "code": "def center : Subalgebra R A :=\n  { Subsemiring.center A with algebraMap_mem' := Set.algebraMap_mem_center }", "start": [1350, 1], "end": [1353, 77], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_center", "code": "theorem coe_center : (center R A : Set A) = Set.center A", "start": [1356, 1], "end": [1357, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.center_toSubsemiring", "code": "@[simp]\ntheorem center_toSubsemiring : (center R A).toSubsemiring = Subsemiring.center A", "start": [1360, 1], "end": [1362, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.center_toSubring", "code": "@[simp]\ntheorem center_toSubring (R A : Type*) [CommRing R] [Ring A] [Algebra R A] :\n    (center R A).toSubring = Subring.center A", "start": [1365, 1], "end": [1368, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.center_eq_top", "code": "@[simp]\ntheorem center_eq_top (A : Type*) [CommSemiring A] [Algebra R A] : center R A = \u22a4", "start": [1371, 1], "end": [1373, 47], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_center_iff", "code": "theorem mem_center_iff {a : A} : a \u2208 center R A \u2194 \u2200 b : A, b * a = a * b", "start": [1384, 1], "end": [1385, 10], "kind": "commanddeclaration"}, {"full_name": "Set.algebraMap_mem_centralizer", "code": "@[simp]\ntheorem _root_.Set.algebraMap_mem_centralizer {s : Set A} (r : R) :\n    algebraMap R A r \u2208 s.centralizer", "start": [1392, 1], "end": [1395, 43], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.centralizer", "code": "def centralizer (s : Set A) : Subalgebra R A :=\n  { Subsemiring.centralizer s with algebraMap_mem' := Set.algebraMap_mem_centralizer }", "start": [1400, 1], "end": [1402, 87], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_centralizer", "code": "@[simp, norm_cast]\ntheorem coe_centralizer (s : Set A) : (centralizer R s : Set A) = s.centralizer", "start": [1405, 1], "end": [1407, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_centralizer_iff", "code": "theorem mem_centralizer_iff {s : Set A} {z : A} : z \u2208 centralizer R s \u2194 \u2200 g \u2208 s, g * z = z * g", "start": [1410, 1], "end": [1411, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.center_le_centralizer", "code": "theorem center_le_centralizer (s) : center R A \u2264 centralizer R s", "start": [1414, 1], "end": [1415, 30], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.centralizer_le", "code": "theorem centralizer_le (s t : Set A) (h : s \u2286 t) : centralizer R t \u2264 centralizer R s", "start": [1418, 1], "end": [1419, 27], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.centralizer_eq_top_iff_subset", "code": "@[simp]\ntheorem centralizer_eq_top_iff_subset {s : Set A} : centralizer R s = \u22a4 \u2194 s \u2286 center R A", "start": [1422, 1], "end": [1424, 59], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.centralizer_univ", "code": "@[simp]\ntheorem centralizer_univ : centralizer R Set.univ = center R A", "start": [1427, 1], "end": [1429, 40], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_of_finset_sum_eq_one_of_pow_smul_mem", "code": "theorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type*} [CommRing S] [Algebra R S]\n    (S' : Subalgebra R S) {\u03b9 : Type*} (\u03b9' : Finset \u03b9) (s : \u03b9 \u2192 S) (l : \u03b9 \u2192 S)\n    (e : \u2211 i in \u03b9', l i * s i = 1) (hs : \u2200 i, s i \u2208 S') (hl : \u2200 i, l i \u2208 S') (x : S)\n    (H : \u2200 i, \u2203 n : \u2115, (s i ^ n : S) \u2022 x \u2208 S') : x \u2208 S'", "start": [1434, 1], "end": [1465, 25], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_of_span_eq_top_of_smul_pow_mem", "code": "theorem mem_of_span_eq_top_of_smul_pow_mem {S : Type*} [CommRing S] [Algebra R S]\n    (S' : Subalgebra R S) (s : Set S) (l : s \u2192\u2080 S) (hs : Finsupp.total s S S (\u2191) l = 1)\n    (hs' : s \u2286 S') (hl : \u2200 i, l i \u2208 S') (x : S) (H : \u2200 r : s, \u2203 n : \u2115, (r : S) ^ n \u2022 x \u2208 S') :\n    x \u2208 S'", "start": [1468, 1], "end": [1472, 91], "kind": "commanddeclaration"}, {"full_name": "subalgebraOfSubsemiring", "code": "def subalgebraOfSubsemiring (S : Subsemiring R) : Subalgebra \u2115 R :=\n  { S with algebraMap_mem' := fun i => coe_nat_mem S i }", "start": [1481, 1], "end": [1483, 57], "kind": "commanddeclaration"}, {"full_name": "mem_subalgebraOfSubsemiring", "code": "@[simp]\ntheorem mem_subalgebraOfSubsemiring {x : R} {S : Subsemiring R} :\n    x \u2208 subalgebraOfSubsemiring S \u2194 x \u2208 S", "start": [1486, 1], "end": [1489, 10], "kind": "commanddeclaration"}, {"full_name": "subalgebraOfSubring", "code": "def subalgebraOfSubring (S : Subring R) : Subalgebra \u2124 R :=\n  { S with\n    algebraMap_mem' := fun i =>\n      Int.induction_on i (by simpa using S.zero_mem)\n        (fun i ih => by simpa using S.add_mem ih S.one_mem) fun i ih =>\n        show ((-i - 1 : \u2124) : R) \u2208 S by\n          rw [Int.cast_sub, Int.cast_one]\n          exact S.sub_mem ih S.one_mem }", "start": [1498, 1], "end": [1506, 41], "kind": "commanddeclaration"}, {"full_name": "mem_subalgebraOfSubring", "code": "@[simp]\ntheorem mem_subalgebraOfSubring {x : R} {S : Subring R} : x \u2208 subalgebraOfSubring S \u2194 x \u2208 S", "start": [1511, 1], "end": [1513, 10], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/InitialSeg.lean", "imports": ["Mathlib/Logic/Equiv/Set.lean", "Mathlib/Order/RelIso/Set.lean", "Mathlib/Order/WellFounded.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "InitialSeg", "code": "structure InitialSeg {\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) extends r \u21aar s where\n  \n  init' : \u2200 a b, s b (toRelEmbedding a) \u2192 \u2203 a', toRelEmbedding a' = b", "start": [50, 1], "end": [55, 70], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ext", "code": "@[ext] lemma ext {f g : r \u227ci s} (h : \u2200 x, f x = g x) : f = g :=\n  FunLike.ext f g h", "start": [77, 1], "end": [78, 20], "kind": "mathlibtacticlemma"}, {"full_name": "InitialSeg.coe_coe_fn", "code": "@[simp]\ntheorem coe_coe_fn (f : r \u227ci s) : ((f : r \u21aar s) : \u03b1 \u2192 \u03b2) = f", "start": [81, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.init", "code": "theorem init (f : r \u227ci s) {a : \u03b1} {b : \u03b2} : s b (f a) \u2192 \u2203 a', f a' = b", "start": [86, 1], "end": [87, 14], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.map_rel_iff", "code": "theorem map_rel_iff (f : r \u227ci s) : s (f a) (f b) \u2194 r a b", "start": [90, 1], "end": [91, 17], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.init_iff", "code": "theorem init_iff (f : r \u227ci s) {a : \u03b1} {b : \u03b2} : s b (f a) \u2194 \u2203 a', f a' = b \u2227 r a' a", "start": [94, 1], "end": [98, 45], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ofIso", "code": "def ofIso (f : r \u2243r s) : r \u227ci s :=\n  \u27e8f, fun _ b _ => \u27e8f.symm b, RelIso.apply_symm_apply f _\u27e9\u27e9", "start": [101, 1], "end": [103, 60], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.refl", "code": "@[refl]\nprotected def refl (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : r \u227ci r :=\n  \u27e8RelEmbedding.refl _, fun _ _ _ => \u27e8_, rfl\u27e9\u27e9", "start": [106, 1], "end": [109, 47], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.trans", "code": "@[trans]\nprotected def trans (f : r \u227ci s) (g : s \u227ci t) : r \u227ci t :=\n  \u27e8f.1.trans g.1, fun a c h => by\n    simp at h \u22a2\n    rcases g.2 _ _ h with \u27e8b, rfl\u27e9; have h := g.map_rel_iff.1 h\n    rcases f.2 _ _ h with \u27e8a', rfl\u27e9; exact \u27e8a', rfl\u27e9\u27e9", "start": [115, 1], "end": [121, 54], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.refl_apply", "code": "@[simp]\ntheorem refl_apply (x : \u03b1) : InitialSeg.refl r x = x", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.trans_apply", "code": "@[simp]\ntheorem trans_apply (f : r \u227ci s) (g : s \u227ci t) (a : \u03b1) : (f.trans g) a = g (f a)", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.subsingleton_of_trichotomous_of_irrefl", "code": "instance subsingleton_of_trichotomous_of_irrefl [IsTrichotomous \u03b2 s] [IsIrrefl \u03b2 s]\n    [IsWellFounded \u03b1 r] : Subsingleton (r \u227ci s) :=\n  \u27e8fun f g => by\n    ext a\n    refine' IsWellFounded.induction r a fun b IH =>\n      extensional_of_trichotomous_of_irrefl s fun x => _\n    rw [f.init_iff, g.init_iff]\n    exact exists_congr fun x => and_congr_left fun hx => IH _ hx \u25b8 Iff.rfl\u27e9", "start": [134, 1], "end": [141, 76], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.eq", "code": "protected theorem eq [IsWellOrder \u03b2 s] (f g : r \u227ci s) (a) : f a = g a", "start": [147, 1], "end": [148, 29], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.Antisymm.aux", "code": "theorem Antisymm.aux [IsWellOrder \u03b1 r] (f : r \u227ci s) (g : s \u227ci r) : LeftInverse g f", "start": [151, 1], "end": [152, 48], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.antisymm", "code": "def antisymm [IsWellOrder \u03b2 s] (f : r \u227ci s) (g : s \u227ci r) : r \u2243r s :=\n  haveI := f.toRelEmbedding.isWellOrder\n  \u27e8\u27e8f, g, Antisymm.aux f g, Antisymm.aux g f\u27e9, f.map_rel_iff'\u27e9", "start": [155, 1], "end": [159, 63], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.antisymm_toFun", "code": "@[simp]\ntheorem antisymm_toFun [IsWellOrder \u03b2 s] (f : r \u227ci s) (g : s \u227ci r) : (antisymm f g : \u03b1 \u2192 \u03b2) = f", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.antisymm_symm", "code": "@[simp]\ntheorem antisymm_symm [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] (f : r \u227ci s) (g : s \u227ci r) :\n    (antisymm f g).symm = antisymm g f", "start": [167, 1], "end": [170, 30], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.eq_or_principal", "code": "theorem eq_or_principal [IsWellOrder \u03b2 s] (f : r \u227ci s) :\n    Surjective f \u2228 \u2203 b, \u2200 x, s x b \u2194 \u2203 y, f y = x", "start": [173, 1], "end": [184, 83], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.codRestrict", "code": "def codRestrict (p : Set \u03b2) (f : r \u227ci s) (H : \u2200 a, f a \u2208 p) : r \u227ci Subrel s p :=\n  \u27e8RelEmbedding.codRestrict p f H, fun a \u27e8b, m\u27e9 h =>\n    let \u27e8a', e\u27e9 := f.init h\n    \u27e8a', by subst e; rfl\u27e9\u27e9", "start": [187, 1], "end": [191, 27], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.codRestrict_apply", "code": "@[simp]\ntheorem codRestrict_apply (p) (f : r \u227ci s) (H a) : codRestrict p f H a = \u27e8f a, H a\u27e9", "start": [194, 1], "end": [196, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ofIsEmpty", "code": "def ofIsEmpty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsEmpty \u03b1] : r \u227ci s :=\n  \u27e8RelEmbedding.ofIsEmpty r s, isEmptyElim\u27e9", "start": [199, 1], "end": [201, 44], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.leAdd", "code": "def leAdd (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) : r \u227ci Sum.Lex r s :=\n  \u27e8\u27e8\u27e8Sum.inl, fun _ _ => Sum.inl.inj\u27e9, Sum.lex_inl_inl\u27e9, fun a b => by\n    cases b <;> [exact fun _ => \u27e8_, rfl\u27e9; exact False.elim \u2218 Sum.lex_inr_inl]\u27e9", "start": [204, 1], "end": [207, 79], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.leAdd_apply", "code": "@[simp]\ntheorem leAdd_apply (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) (a) : leAdd r s a = Sum.inl a", "start": [210, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.acc", "code": "protected theorem acc (f : r \u227ci s) (a : \u03b1) : Acc r a \u2194 Acc s (f a)", "start": [215, 1], "end": [219, 62], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg", "code": "structure PrincipalSeg {\u03b1 \u03b2 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) extends r \u21aar s where\n  \n  top : \u03b2\n  \n  down' : \u2200 b, s b top \u2194 \u2203 a, toRelEmbedding a = b", "start": [234, 1], "end": [241, 51], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.coe_fn_mk", "code": "@[simp]\ntheorem coe_fn_mk (f : r \u21aar s) (t o) : (@PrincipalSeg.mk _ _ r s f t o : \u03b1 \u2192 \u03b2) = f", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.down", "code": "theorem down (f : r \u227ai s) : \u2200 {b : \u03b2}, s b f.top \u2194 \u2203 a, f a = b", "start": [263, 1], "end": [264, 12], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.lt_top", "code": "theorem lt_top (f : r \u227ai s) (a : \u03b1) : s (f a) f.top", "start": [267, 1], "end": [268, 20], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.init", "code": "theorem init [IsTrans \u03b2 s] (f : r \u227ai s) {a : \u03b1} {b : \u03b2} (h : s b (f a)) : \u2203 a', f a' = b", "start": [271, 1], "end": [272, 43], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.hasCoeInitialSeg", "code": "instance hasCoeInitialSeg [IsTrans \u03b2 s] : Coe (r \u227ai s) (r \u227ci s) :=\n  \u27e8fun f => \u27e8f.toRelEmbedding, fun _ _ => f.init\u27e9\u27e9", "start": [275, 1], "end": [277, 51], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.coe_coe_fn'", "code": "theorem coe_coe_fn' [IsTrans \u03b2 s] (f : r \u227ai s) : ((f : r \u227ci s) : \u03b1 \u2192 \u03b2) = f", "start": [280, 1], "end": [281, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.init_iff", "code": "theorem init_iff [IsTrans \u03b2 s] (f : r \u227ai s) {a : \u03b1} {b : \u03b2} : s b (f a) \u2194 \u2203 a', f a' = b \u2227 r a' a", "start": [284, 1], "end": [285, 37], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.irrefl", "code": "theorem irrefl {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] (f : r \u227ai r) : False", "start": [288, 1], "end": [291, 26], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ltLe", "code": "def ltLe (f : r \u227ai s) (g : s \u227ci t) : r \u227ai t :=\n  \u27e8@RelEmbedding.trans _ _ _ r s t f g, g f.top, fun a => by\n    simp only [g.init_iff, PrincipalSeg.down, exists_and_left.symm, exists_swap,\n        RelEmbedding.trans_apply, exists_eq_right', InitialSeg.coe_coe_fn]\u27e9", "start": [297, 1], "end": [301, 76], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.lt_le_apply", "code": "@[simp]\ntheorem lt_le_apply (f : r \u227ai s) (g : s \u227ci t) (a : \u03b1) : (f.ltLe g) a = g (f a)", "start": [304, 1], "end": [306, 33], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.lt_le_top", "code": "@[simp]\ntheorem lt_le_top (f : r \u227ai s) (g : s \u227ci t) : (f.ltLe g).top = g f.top", "start": [309, 1], "end": [311, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.trans", "code": "@[trans]\nprotected def trans [IsTrans \u03b3 t] (f : r \u227ai s) (g : s \u227ai t) : r \u227ai t :=\n  ltLe f g", "start": [314, 1], "end": [317, 11], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.trans_apply", "code": "@[simp]\ntheorem trans_apply [IsTrans \u03b3 t] (f : r \u227ai s) (g : s \u227ai t) (a : \u03b1) : (f.trans g) a = g (f a)", "start": [320, 1], "end": [322, 20], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.trans_top", "code": "@[simp]\ntheorem trans_top [IsTrans \u03b3 t] (f : r \u227ai s) (g : s \u227ai t) : (f.trans g).top = g f.top", "start": [325, 1], "end": [327, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.equivLT", "code": "def equivLT (f : r \u2243r s) (g : s \u227ai t) : r \u227ai t :=\n  \u27e8@RelEmbedding.trans _ _ _ r s t f g, g.top, fun c =>\n    suffices (\u2203 a : \u03b2, g a = c) \u2194 \u2203 a : \u03b1, g (f a) = c by simpa [PrincipalSeg.down]\n    \u27e8fun \u27e8b, h\u27e9 => \u27e8f.symm b, by simp only [h, RelIso.apply_symm_apply]\u27e9,\n      fun \u27e8a, h\u27e9 => \u27e8f a, h\u27e9\u27e9\u27e9", "start": [330, 1], "end": [335, 31], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ltEquiv", "code": "def ltEquiv {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop} (f : PrincipalSeg r s)\n    (g : s \u2243r t) : PrincipalSeg r t :=\n  \u27e8@RelEmbedding.trans _ _ _ r s t f g, g f.top, by\n    intro x\n    rw [\u2190 g.apply_symm_apply x, g.map_rel_iff, f.down', exists_congr]\n    intro y; exact \u27e8congr_arg g, fun h => g.toEquiv.bijective.1 h\u27e9\u27e9", "start": [338, 1], "end": [344, 68], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.equivLT_apply", "code": "@[simp]\ntheorem equivLT_apply (f : r \u2243r s) (g : s \u227ai t) (a : \u03b1) : (equivLT f g) a = g (f a)", "start": [347, 1], "end": [349, 33], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.equivLT_top", "code": "@[simp]\ntheorem equivLT_top (f : r \u2243r s) (g : s \u227ai t) : (equivLT f g).top = g.top", "start": [352, 1], "end": [354, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.top_eq", "code": "theorem top_eq [IsWellOrder \u03b3 t] (e : r \u2243r s) (f : r \u227ai t) (g : s \u227ai t) : f.top = g.top", "start": [370, 1], "end": [371, 59], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.topLTTop", "code": "theorem topLTTop {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} {t : \u03b3 \u2192 \u03b3 \u2192 Prop} [IsWellOrder \u03b3 t]\n    (f : PrincipalSeg r s) (g : PrincipalSeg s t) (h : PrincipalSeg r t) : t h.top g.top", "start": [374, 1], "end": [377, 28], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ofElement", "code": "def ofElement {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : Subrel r { b | r b a } \u227ai r :=\n  \u27e8Subrel.relEmbedding _ _, a, fun _ => \u27e8fun h => \u27e8\u27e8_, h\u27e9, rfl\u27e9, fun \u27e8\u27e8_, h\u27e9, rfl\u27e9 => h\u27e9\u27e9", "start": [380, 1], "end": [382, 90], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ofElement_apply", "code": "@[simp, nolint simpNF]\ntheorem ofElement_apply {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) (b) : ofElement r a b = b.1", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ofElement_top", "code": "@[simp]\ntheorem ofElement_top {\u03b1 : Type*} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (a : \u03b1) : (ofElement r a).top = a", "start": [391, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.subrelIso", "code": "@[simps! symm_apply]\nnoncomputable def subrelIso (f : r \u227ai s) : Subrel s {b | s b f.top} \u2243r r :=\n  RelIso.symm\n  { toEquiv := ((Equiv.ofInjective f f.injective).trans (Equiv.setCongr\n      (funext fun _ \u21a6 propext f.down.symm))),\n    map_rel_iff' := f.map_rel_iff }", "start": [396, 1], "end": [402, 36], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.apply_subrelIso", "code": "@[simp, nolint simpNF]\ntheorem apply_subrelIso (f : r \u227ai s) (b : {b | s b f.top}) :\n    f (f.subrelIso b) = b", "start": [408, 1], "end": [411, 45], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.subrelIso_apply", "code": "@[simp, nolint simpNF]\ntheorem subrelIso_apply (f : r \u227ai s) (a : \u03b1) :\n    f.subrelIso \u27e8f a, f.down.mpr \u27e8a, rfl\u27e9\u27e9 = a", "start": [414, 1], "end": [417, 45], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.codRestrict", "code": "def codRestrict (p : Set \u03b2) (f : r \u227ai s) (H : \u2200 a, f a \u2208 p) (H\u2082 : f.top \u2208 p) : r \u227ai Subrel s p :=\n  \u27e8RelEmbedding.codRestrict p f H, \u27e8f.top, H\u2082\u27e9, fun \u27e8_, _\u27e9 =>\n    f.down.trans <|\n      exists_congr fun a => show (\u27e8f a, H a\u27e9 : p).1 = _ \u2194 _ from \u27e8Subtype.eq, congr_arg _\u27e9\u27e9", "start": [419, 1], "end": [423, 92], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.codRestrict_apply", "code": "@[simp]\ntheorem codRestrict_apply (p) (f : r \u227ai s) (H H\u2082 a) : codRestrict p f H H\u2082 a = \u27e8f a, H a\u27e9", "start": [426, 1], "end": [428, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.codRestrict_top", "code": "@[simp]\ntheorem codRestrict_top (p) (f : r \u227ai s) (H H\u2082) : (codRestrict p f H H\u2082).top = \u27e8f.top, H\u2082\u27e9", "start": [431, 1], "end": [433, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ofIsEmpty", "code": "def ofIsEmpty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsEmpty \u03b1] {b : \u03b2} (H : \u2200 b', \u00acs b' b) : r \u227ai s :=\n  { RelEmbedding.ofIsEmpty r s with\n    top := b\n    down' := by simp [H] }", "start": [436, 1], "end": [440, 27], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ofIsEmpty_top", "code": "@[simp]\ntheorem ofIsEmpty_top (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsEmpty \u03b1] {b : \u03b2} (H : \u2200 b', \u00acs b' b) :\n    (ofIsEmpty r H).top = b", "start": [443, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.pemptyToPunit", "code": "@[reducible]\ndef pemptyToPunit : @EmptyRelation PEmpty \u227ai @EmptyRelation PUnit :=\n  (@ofIsEmpty _ _ EmptyRelation _ _ PUnit.unit) fun _ => not_false", "start": [449, 1], "end": [452, 67], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.acc", "code": "protected theorem acc [IsTrans \u03b2 s] (f : r \u227ai s) (a : \u03b1) : Acc r a \u2194 Acc s (f a)", "start": [455, 1], "end": [456, 21], "kind": "commanddeclaration"}, {"full_name": "wellFounded_iff_wellFounded_subrel", "code": "theorem wellFounded_iff_wellFounded_subrel {\u03b2 : Type*} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsTrans \u03b2 s] :\n    WellFounded s \u2194 \u2200 b, WellFounded (Subrel s { b' | s b' b })", "start": [461, 1], "end": [473, 40], "kind": "commanddeclaration"}, {"full_name": "wellFounded_iff_principalSeg", "code": "theorem wellFounded_iff_principalSeg.{u} {\u03b2 : Type u} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsTrans \u03b2 s] :\n    WellFounded s \u2194 \u2200 (\u03b1 : Type u) (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (_ : r \u227ai s), WellFounded r", "start": [476, 1], "end": [479, 88], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ltOrEq", "code": "noncomputable def InitialSeg.ltOrEq [IsWellOrder \u03b2 s] (f : r \u227ci s) : Sum (r \u227ai s) (r \u2243r s) := by\n  by_cases h : Surjective f\n  \u00b7 exact Sum.inr (RelIso.ofSurjective f h)\n  \u00b7 have h' : _ := (InitialSeg.eq_or_principal f).resolve_left h\n    exact Sum.inl \u27e8f, Classical.choose h', Classical.choose_spec h'\u27e9", "start": [485, 1], "end": [492, 69], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ltOrEq_apply_left", "code": "theorem InitialSeg.ltOrEq_apply_left [IsWellOrder \u03b2 s] (f : r \u227ci s) (g : r \u227ai s) (a : \u03b1) :\n    g a = f a", "start": [495, 1], "end": [497, 33], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ltOrEq_apply_right", "code": "theorem InitialSeg.ltOrEq_apply_right [IsWellOrder \u03b2 s] (f : r \u227ci s) (g : r \u2243r s) (a : \u03b1) :\n    g a = f a", "start": [500, 1], "end": [502, 41], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.leLT", "code": "noncomputable def InitialSeg.leLT [IsWellOrder \u03b2 s] [IsTrans \u03b3 t] (f : r \u227ci s) (g : s \u227ai t) :\n    r \u227ai t :=\n  match f.ltOrEq with\n  | Sum.inl f' => f'.trans g\n  | Sum.inr f' => PrincipalSeg.equivLT f' g", "start": [505, 1], "end": [510, 44], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.leLT_apply", "code": "@[simp]\ntheorem InitialSeg.leLT_apply [IsWellOrder \u03b2 s] [IsTrans \u03b3 t] (f : r \u227ci s) (g : s \u227ai t) (a : \u03b1) :\n    (f.leLT g) a = g (f a)", "start": [513, 1], "end": [518, 65], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.collapseF", "code": "noncomputable def collapseF [IsWellOrder \u03b2 s] (f : r \u21aar s) : \u2200 a, { b // \u00acs (f a) b } :=\n  (RelEmbedding.wellFounded f <| IsWellFounded.wf).fix fun a IH => by\n    let S := { b | \u2200 a h, s (IH a h).1 b }\n    have : f a \u2208 S := fun a' h =>\n      ((trichotomous _ _).resolve_left fun h' =>\n            (IH a' h).2 <| _root_.trans (f.map_rel_iff.2 h) h').resolve_left\n        fun h' => (IH a' h).2 <| h' \u25b8 f.map_rel_iff.2 h\n    exact \u27e8_, IsWellFounded.wf.not_lt_min _ \u27e8_, this\u27e9 this\u27e9", "start": [523, 1], "end": [533, 60], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.collapseF.lt", "code": "theorem collapseF.lt [IsWellOrder \u03b2 s] (f : r \u21aar s) {a : \u03b1} :\n    \u2200 {a'}, r a' a \u2192 s (collapseF f a').1 (collapseF f a).1", "start": [537, 1], "end": [543, 32], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.collapseF.not_lt", "code": "theorem collapseF.not_lt [IsWellOrder \u03b2 s] (f : r \u21aar s) (a : \u03b1) {b}\n    (h : \u2200 a' (_ : r a' a), s (collapseF f a').1 b) : \u00acs b (collapseF f a).1", "start": [547, 1], "end": [551, 39], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.collapse", "code": "noncomputable def collapse [IsWellOrder \u03b2 s] (f : r \u21aar s) : r \u227ci s :=\n  haveI := RelEmbedding.isWellOrder f\n  \u27e8RelEmbedding.ofMonotone (fun a => (collapseF f a).1) fun a b => collapseF.lt f, fun a b =>\n    Acc.recOn (IsWellFounded.wf.apply b : Acc s b)\n      (fun b _ _ a h => by\n        rcases (@IsWellFounded.wf _ r).has_min { a | \u00acs (collapseF f a).1 b }\n          \u27e8_, asymm h\u27e9 with \u27e8m, hm, hm'\u27e9\n        refine' \u27e8m, ((@trichotomous _ s _ _ _).resolve_left hm).resolve_right\n          (collapseF.not_lt f _ fun a' h' => _)\u27e9\n        by_contra hn\n        exact hm' _ hn h')\n      a\u27e9", "start": [555, 1], "end": [568, 9], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.collapse_apply", "code": "theorem collapse_apply [IsWellOrder \u03b2 s] (f : r \u21aar s) (a) : collapse f a = (collapseF f a).1", "start": [571, 1], "end": [572, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Sum/Order.lean", "imports": ["Mathlib/Order/Hom/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Sum.LiftRel.refl", "code": "@[refl]\ntheorem LiftRel.refl [IsRefl \u03b1 r] [IsRefl \u03b2 s] : \u2200 x, LiftRel r s x x", "start": [41, 1], "end": [44, 41], "kind": "commanddeclaration"}, {"full_name": "Sum.LiftRel.trans", "code": "@[trans]\ntheorem LiftRel.trans [IsTrans \u03b1 r] [IsTrans \u03b2 s] :\n    \u2200 {a b c}, LiftRel r s a b \u2192 LiftRel r s b c \u2192 LiftRel r s a c", "start": [53, 1], "end": [57, 85], "kind": "commanddeclaration"}, {"full_name": "Sum.instLESum", "code": "instance instLESum [LE \u03b1] [LE \u03b2] : LE (Sum \u03b1 \u03b2) :=\n  \u27e8LiftRel (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)\u27e9", "start": [114, 1], "end": [115, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.instLTSum", "code": "instance instLTSum [LT \u03b1] [LT \u03b2] : LT (Sum \u03b1 \u03b2) :=\n  \u27e8LiftRel (\u00b7 < \u00b7) (\u00b7 < \u00b7)\u27e9", "start": [117, 1], "end": [118, 28], "kind": "commanddeclaration"}, {"full_name": "Sum.le_def", "code": "theorem le_def [LE \u03b1] [LE \u03b2] {a b : Sum \u03b1 \u03b2} : a \u2264 b \u2194 LiftRel (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7) a b", "start": [120, 1], "end": [121, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.lt_def", "code": "theorem lt_def [LT \u03b1] [LT \u03b2] {a b : Sum \u03b1 \u03b2} : a < b \u2194 LiftRel (\u00b7 < \u00b7) (\u00b7 < \u00b7) a b", "start": [124, 1], "end": [125, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_le_inl_iff", "code": "@[simp]\ntheorem inl_le_inl_iff [LE \u03b1] [LE \u03b2] {a b : \u03b1} : (inl a : Sum \u03b1 \u03b2) \u2264 inl b \u2194 a \u2264 b", "start": [128, 1], "end": [130, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_le_inr_iff", "code": "@[simp]\ntheorem inr_le_inr_iff [LE \u03b1] [LE \u03b2] {a b : \u03b2} : (inr a : Sum \u03b1 \u03b2) \u2264 inr b \u2194 a \u2264 b", "start": [133, 1], "end": [135, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_lt_inl_iff", "code": "@[simp]\ntheorem inl_lt_inl_iff [LT \u03b1] [LT \u03b2] {a b : \u03b1} : (inl a : Sum \u03b1 \u03b2) < inl b \u2194 a < b", "start": [138, 1], "end": [140, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_lt_inr_iff", "code": "@[simp]\ntheorem inr_lt_inr_iff [LT \u03b1] [LT \u03b2] {a b : \u03b2} : (inr a : Sum \u03b1 \u03b2) < inr b \u2194 a < b", "start": [143, 1], "end": [145, 18], "kind": "commanddeclaration"}, {"full_name": "Sum.not_inl_le_inr", "code": "@[simp]\ntheorem not_inl_le_inr [LE \u03b1] [LE \u03b2] {a : \u03b1} {b : \u03b2} : \u00acinl b \u2264 inr a", "start": [148, 1], "end": [150, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.not_inl_lt_inr", "code": "@[simp]\ntheorem not_inl_lt_inr [LT \u03b1] [LT \u03b2] {a : \u03b1} {b : \u03b2} : \u00acinl b < inr a", "start": [153, 1], "end": [155, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.not_inr_le_inl", "code": "@[simp]\ntheorem not_inr_le_inl [LE \u03b1] [LE \u03b2] {a : \u03b1} {b : \u03b2} : \u00acinr b \u2264 inl a", "start": [158, 1], "end": [160, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.not_inr_lt_inl", "code": "@[simp]\ntheorem not_inr_lt_inl [LT \u03b1] [LT \u03b2] {a : \u03b1} {b : \u03b2} : \u00acinr b < inl a", "start": [163, 1], "end": [165, 22], "kind": "commanddeclaration"}, {"full_name": "Sum.instPreorderSum", "code": "instance instPreorderSum : Preorder (Sum \u03b1 \u03b2) :=\n  { instLESum, instLTSum with\n    le_refl := fun x => LiftRel.refl _ _ _,\n    le_trans := fun _ _ _ => LiftRel.trans _ _,\n    lt_iff_le_not_le := fun a b => by\n      refine' \u27e8fun hab => \u27e8hab.mono (fun _ _ => le_of_lt) fun _ _ => le_of_lt, _\u27e9, _\u27e9\n      \u00b7 rintro (\u27e8hba\u27e9 | \u27e8hba\u27e9)\n        \u00b7 exact hba.not_lt (inl_lt_inl_iff.1 hab)\n        \u00b7 exact hba.not_lt (inr_lt_inr_iff.1 hab)\n      \u00b7 rintro \u27e8\u27e8hab\u27e9 | \u27e8hab\u27e9, hba\u27e9\n        \u00b7 exact LiftRel.inl (hab.lt_of_not_le fun h => hba <| LiftRel.inl h)\n        \u00b7 exact LiftRel.inr (hab.lt_of_not_le fun h => hba <| LiftRel.inr h) }", "start": [172, 1], "end": [183, 79], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_mono", "code": "theorem inl_mono : Monotone (inl : \u03b1 \u2192 Sum \u03b1 \u03b2)", "start": [185, 1], "end": [185, 74], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_mono", "code": "theorem inr_mono : Monotone (inr : \u03b2 \u2192 Sum \u03b1 \u03b2)", "start": [188, 1], "end": [188, 74], "kind": "commanddeclaration"}, {"full_name": "Sum.inl_strictMono", "code": "theorem inl_strictMono : StrictMono (inl : \u03b1 \u2192 Sum \u03b1 \u03b2)", "start": [191, 1], "end": [191, 82], "kind": "commanddeclaration"}, {"full_name": "Sum.inr_strictMono", "code": "theorem inr_strictMono : StrictMono (inr : \u03b2 \u2192 Sum \u03b1 \u03b2)", "start": [194, 1], "end": [194, 82], "kind": "commanddeclaration"}, {"full_name": "Sum.noMinOrder", "code": "instance noMinOrder [LT \u03b1] [LT \u03b2] [NoMinOrder \u03b1] [NoMinOrder \u03b2] : NoMinOrder (Sum \u03b1 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl a =>\n      let \u27e8b, h\u27e9 := exists_lt a\n      \u27e8inl b, inl_lt_inl_iff.2 h\u27e9\n    | inr a =>\n      let \u27e8b, h\u27e9 := exists_lt a\n      \u27e8inr b, inr_lt_inr_iff.2 h\u27e9\u27e9", "start": [203, 1], "end": [211, 35], "kind": "commanddeclaration"}, {"full_name": "Sum.noMaxOrder", "code": "instance noMaxOrder [LT \u03b1] [LT \u03b2] [NoMaxOrder \u03b1] [NoMaxOrder \u03b2] : NoMaxOrder (Sum \u03b1 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl a =>\n      let \u27e8b, h\u27e9 := exists_gt a\n      \u27e8inl b, inl_lt_inl_iff.2 h\u27e9\n    | inr a =>\n      let \u27e8b, h\u27e9 := exists_gt a\n      \u27e8inr b, inr_lt_inr_iff.2 h\u27e9\u27e9", "start": [214, 1], "end": [222, 35], "kind": "commanddeclaration"}, {"full_name": "Sum.noMinOrder_iff", "code": "@[simp]\ntheorem noMinOrder_iff [LT \u03b1] [LT \u03b2] : NoMinOrder (Sum \u03b1 \u03b2) \u2194 NoMinOrder \u03b1 \u2227 NoMinOrder \u03b2", "start": [225, 1], "end": [236, 46], "kind": "commanddeclaration"}, {"full_name": "Sum.noMaxOrder_iff", "code": "@[simp]\ntheorem noMaxOrder_iff [LT \u03b1] [LT \u03b2] : NoMaxOrder (Sum \u03b1 \u03b2) \u2194 NoMaxOrder \u03b1 \u2227 NoMaxOrder \u03b2", "start": [239, 1], "end": [250, 46], "kind": "commanddeclaration"}, {"full_name": "Sum.denselyOrdered", "code": "instance denselyOrdered [LT \u03b1] [LT \u03b2] [DenselyOrdered \u03b1] [DenselyOrdered \u03b2] :\n    DenselyOrdered (Sum \u03b1 \u03b2) :=\n  \u27e8fun a b h =>\n    match a, b, h with\n    | inl _, inl _, LiftRel.inl h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inl c), LiftRel.inl ha, LiftRel.inl hb\u27e9\n    | inr _, inr _, LiftRel.inr h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inr c), LiftRel.inr ha, LiftRel.inr hb\u27e9\u27e9", "start": [253, 1], "end": [262, 55], "kind": "commanddeclaration"}, {"full_name": "Sum.denselyOrdered_iff", "code": "@[simp]\ntheorem denselyOrdered_iff [LT \u03b1] [LT \u03b2] :\n    DenselyOrdered (Sum \u03b1 \u03b2) \u2194 DenselyOrdered \u03b1 \u2227 DenselyOrdered \u03b2", "start": [265, 1], "end": [277, 50], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_le_swap_iff", "code": "@[simp]\ntheorem swap_le_swap_iff [LE \u03b1] [LE \u03b2] {a b : Sum \u03b1 \u03b2} : a.swap \u2264 b.swap \u2194 a \u2264 b", "start": [280, 1], "end": [282, 19], "kind": "commanddeclaration"}, {"full_name": "Sum.swap_lt_swap_iff", "code": "@[simp]\ntheorem swap_lt_swap_iff [LT \u03b1] [LT \u03b2] {a b : Sum \u03b1 \u03b2} : a.swap < b.swap \u2194 a < b", "start": [285, 1], "end": [287, 19], "kind": "commanddeclaration"}, {"full_name": "Sum.inl\u2097", "code": "@[match_pattern]\nabbrev _root_.Sum.inl\u2097 (x : \u03b1) : \u03b1 \u2295\u2097 \u03b2 :=\n  toLex (Sum.inl x)", "start": [302, 1], "end": [305, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.inr\u2097", "code": "@[match_pattern]\nabbrev _root_.Sum.inr\u2097 (x : \u03b2) : \u03b1 \u2295\u2097 \u03b2 :=\n  toLex (Sum.inr x)", "start": [308, 1], "end": [311, 20], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.LE", "code": "protected instance LE [LE \u03b1] [LE \u03b2] : LE (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)\u27e9", "start": [314, 1], "end": [316, 24], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.LT", "code": "protected instance LT [LT \u03b1] [LT \u03b2] : LT (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7)\u27e9", "start": [319, 1], "end": [321, 24], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.toLex_le_toLex", "code": "@[simp]\ntheorem toLex_le_toLex [LE \u03b1] [LE \u03b2] {a b : Sum \u03b1 \u03b2} :\n    toLex a \u2264 toLex b \u2194 Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7) a b", "start": [324, 1], "end": [327, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.toLex_lt_toLex", "code": "@[simp]\ntheorem toLex_lt_toLex [LT \u03b1] [LT \u03b2] {a b : Sum \u03b1 \u03b2} :\n    toLex a < toLex b \u2194 Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7) a b", "start": [330, 1], "end": [333, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.le_def", "code": "theorem le_def [LE \u03b1] [LE \u03b2] {a b : \u03b1 \u2295\u2097 \u03b2} : a \u2264 b \u2194 Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7) (ofLex a) (ofLex b)", "start": [336, 1], "end": [337, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.lt_def", "code": "theorem lt_def [LT \u03b1] [LT \u03b2] {a b : \u03b1 \u2295\u2097 \u03b2} : a < b \u2194 Lex (\u00b7 < \u00b7) (\u00b7 < \u00b7) (ofLex a) (ofLex b)", "start": [340, 1], "end": [341, 10], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_le_inl_iff", "code": "theorem inl_le_inl_iff [LE \u03b1] [LE \u03b2] {a b : \u03b1} : toLex (inl a : Sum \u03b1 \u03b2) \u2264 toLex (inl b) \u2194 a \u2264 b", "start": [344, 1], "end": [345, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inr_le_inr_iff", "code": "theorem inr_le_inr_iff [LE \u03b1] [LE \u03b2] {a b : \u03b2} : toLex (inr a : Sum \u03b1 \u03b2) \u2264 toLex (inr b) \u2194 a \u2264 b", "start": [348, 1], "end": [349, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_lt_inl_iff", "code": "theorem inl_lt_inl_iff [LT \u03b1] [LT \u03b2] {a b : \u03b1} : toLex (inl a : Sum \u03b1 \u03b2) < toLex (inl b) \u2194 a < b", "start": [352, 1], "end": [353, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inr_lt_inr_iff", "code": "theorem inr_lt_inr_iff [LT \u03b1] [LT \u03b2] {a b : \u03b2} : toLex (inr a : \u03b1 \u2295\u2097 \u03b2) < toLex (inr b) \u2194 a < b", "start": [356, 1], "end": [357, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_le_inr", "code": "theorem inl_le_inr [LE \u03b1] [LE \u03b2] (a : \u03b1) (b : \u03b2) : toLex (inl a) \u2264 toLex (inr b)", "start": [360, 1], "end": [361, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_lt_inr", "code": "theorem inl_lt_inr [LT \u03b1] [LT \u03b2] (a : \u03b1) (b : \u03b2) : toLex (inl a) < toLex (inr b)", "start": [364, 1], "end": [365, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.not_inr_le_inl", "code": "theorem not_inr_le_inl [LE \u03b1] [LE \u03b2] {a : \u03b1} {b : \u03b2} : \u00actoLex (inr b) \u2264 toLex (inl a)", "start": [368, 1], "end": [369, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.not_inr_lt_inl", "code": "theorem not_inr_lt_inl [LT \u03b1] [LT \u03b2] {a : \u03b1} {b : \u03b2} : \u00actoLex (inr b) < toLex (inl a)", "start": [372, 1], "end": [373, 14], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.preorder", "code": "instance preorder : Preorder (\u03b1 \u2295\u2097 \u03b2) :=\n  { Lex.LE, Lex.LT with\n    le_refl := refl_of (Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)),\n    le_trans := fun _ _ _ => trans_of (Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)),\n    lt_iff_le_not_le := fun a b => by\n      refine' \u27e8fun hab => \u27e8hab.mono (fun _ _ => le_of_lt) fun _ _ => le_of_lt, _\u27e9, _\u27e9\n      \u00b7 rintro (\u27e8hba\u27e9 | \u27e8hba\u27e9 | \u27e8b, a\u27e9)\n        \u00b7 exact hba.not_lt (inl_lt_inl_iff.1 hab)\n        \u00b7 exact hba.not_lt (inr_lt_inr_iff.1 hab)\n        \u00b7 exact not_inr_lt_inl hab\n      \u00b7 rintro \u27e8\u27e8hab\u27e9 | \u27e8hab\u27e9 | \u27e8a, b\u27e9, hba\u27e9\n        \u00b7 exact Lex.inl (hab.lt_of_not_le fun h => hba <| Lex.inl h)\n        \u00b7 exact Lex.inr (hab.lt_of_not_le fun h => hba <| Lex.inr h)\n        \u00b7 exact Lex.sep _ _ }", "start": [380, 1], "end": [393, 30], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.toLex_mono", "code": "theorem toLex_mono : Monotone (@toLex (Sum \u03b1 \u03b2))", "start": [396, 1], "end": [396, 71], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.toLex_strictMono", "code": "theorem toLex_strictMono : StrictMono (@toLex (Sum \u03b1 \u03b2))", "start": [399, 1], "end": [399, 79], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_mono", "code": "theorem inl_mono : Monotone (toLex \u2218 inl : \u03b1 \u2192 \u03b1 \u2295\u2097 \u03b2)", "start": [402, 1], "end": [403, 31], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inr_mono", "code": "theorem inr_mono : Monotone (toLex \u2218 inr : \u03b2 \u2192 \u03b1 \u2295\u2097 \u03b2)", "start": [406, 1], "end": [407, 31], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_strictMono", "code": "theorem inl_strictMono : StrictMono (toLex \u2218 inl : \u03b1 \u2192 \u03b1 \u2295\u2097 \u03b2)", "start": [410, 1], "end": [411, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inr_strictMono", "code": "theorem inr_strictMono : StrictMono (toLex \u2218 inr : \u03b2 \u2192 \u03b1 \u2295\u2097 \u03b2)", "start": [414, 1], "end": [415, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.partialOrder", "code": "instance partialOrder [PartialOrder \u03b1] [PartialOrder \u03b2] : PartialOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  { Lex.preorder with le_antisymm := fun _ _ => antisymm_of (Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)) }", "start": [420, 1], "end": [421, 84], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.linearOrder", "code": "instance linearOrder [LinearOrder \u03b1] [LinearOrder \u03b2] : LinearOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  { Lex.partialOrder with\n    le_total := total_of (Lex (\u00b7 \u2264 \u00b7) (\u00b7 \u2264 \u00b7)),\n    decidableLE := instDecidableRelSumLex,\n    decidableEq := instDecidableEqSum }", "start": [424, 1], "end": [428, 40], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.orderBot", "code": "instance orderBot [LE \u03b1] [OrderBot \u03b1] [LE \u03b2] :\n    OrderBot (\u03b1 \u2295\u2097 \u03b2) where\n  bot := inl \u22a5\n  bot_le := by\n    rintro (a | b)\n    \u00b7 exact Lex.inl bot_le\n    \u00b7 exact Lex.sep _ _", "start": [431, 1], "end": [438, 24], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inl_bot", "code": "@[simp]\ntheorem inl_bot [LE \u03b1] [OrderBot \u03b1] [LE \u03b2] : toLex (inl \u22a5 : Sum \u03b1 \u03b2) = \u22a5", "start": [441, 1], "end": [443, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.orderTop", "code": "instance orderTop [LE \u03b1] [LE \u03b2] [OrderTop \u03b2] :\n    OrderTop (\u03b1 \u2295\u2097 \u03b2) where\n  top := inr \u22a4\n  le_top := by\n    rintro (a | b)\n    \u00b7 exact Lex.sep _ _\n    \u00b7 exact Lex.inr le_top", "start": [446, 1], "end": [453, 27], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.inr_top", "code": "@[simp]\ntheorem inr_top [LE \u03b1] [LE \u03b2] [OrderTop \u03b2] : toLex (inr \u22a4 : Sum \u03b1 \u03b2) = \u22a4", "start": [456, 1], "end": [458, 6], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.boundedOrder", "code": "instance boundedOrder [LE \u03b1] [LE \u03b2] [OrderBot \u03b1] [OrderTop \u03b2] : BoundedOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  { Lex.orderBot, Lex.orderTop with }", "start": [461, 1], "end": [462, 38], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.noMinOrder", "code": "instance noMinOrder [LT \u03b1] [LT \u03b2] [NoMinOrder \u03b1] [NoMinOrder \u03b2] : NoMinOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl a =>\n      let \u27e8b, h\u27e9 := exists_lt a\n      \u27e8toLex (inl b), inl_lt_inl_iff.2 h\u27e9\n    | inr a =>\n      let \u27e8b, h\u27e9 := exists_lt a\n      \u27e8toLex (inr b), inr_lt_inr_iff.2 h\u27e9\u27e9", "start": [465, 1], "end": [473, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.noMaxOrder", "code": "instance noMaxOrder [LT \u03b1] [LT \u03b2] [NoMaxOrder \u03b1] [NoMaxOrder \u03b2] : NoMaxOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl a =>\n      let \u27e8b, h\u27e9 := exists_gt a\n      \u27e8toLex (inl b), inl_lt_inl_iff.2 h\u27e9\n    | inr a =>\n      let \u27e8b, h\u27e9 := exists_gt a\n      \u27e8toLex (inr b), inr_lt_inr_iff.2 h\u27e9\u27e9", "start": [476, 1], "end": [484, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.noMinOrder_of_nonempty", "code": "instance noMinOrder_of_nonempty [LT \u03b1] [LT \u03b2] [NoMinOrder \u03b1] [Nonempty \u03b1] : NoMinOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl a =>\n      let \u27e8b, h\u27e9 := exists_lt a\n      \u27e8toLex (inl b), inl_lt_inl_iff.2 h\u27e9\n    | inr _ => \u27e8toLex (inl <| Classical.arbitrary \u03b1), inl_lt_inr _ _\u27e9\u27e9", "start": [487, 1], "end": [493, 71], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.noMaxOrder_of_nonempty", "code": "instance noMaxOrder_of_nonempty [LT \u03b1] [LT \u03b2] [NoMaxOrder \u03b2] [Nonempty \u03b2] : NoMaxOrder (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a =>\n    match a with\n    | inl _ => \u27e8toLex (inr <| Classical.arbitrary \u03b2), inl_lt_inr _ _\u27e9\n    | inr a =>\n      let \u27e8b, h\u27e9 := exists_gt a\n      \u27e8toLex (inr b), inr_lt_inr_iff.2 h\u27e9\u27e9", "start": [496, 1], "end": [502, 43], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.denselyOrdered_of_noMaxOrder", "code": "instance denselyOrdered_of_noMaxOrder [LT \u03b1] [LT \u03b2] [DenselyOrdered \u03b1] [DenselyOrdered \u03b2]\n    [NoMaxOrder \u03b1] : DenselyOrdered (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a b h =>\n    match a, b, h with\n    | inl _, inl _, Lex.inl h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb\u27e9\n    | inl a, inr _, Lex.sep _ _ =>\n      let \u27e8c, h\u27e9 := exists_gt a\n      \u27e8toLex (inl c), inl_lt_inl_iff.2 h, inl_lt_inr _ _\u27e9\n    | inr _, inr _, Lex.inr h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb\u27e9\u27e9", "start": [505, 1], "end": [517, 65], "kind": "commanddeclaration"}, {"full_name": "Sum.Lex.denselyOrdered_of_noMinOrder", "code": "instance denselyOrdered_of_noMinOrder [LT \u03b1] [LT \u03b2] [DenselyOrdered \u03b1] [DenselyOrdered \u03b2]\n    [NoMinOrder \u03b2] : DenselyOrdered (\u03b1 \u2295\u2097 \u03b2) :=\n  \u27e8fun a b h =>\n    match a, b, h with\n    | inl _, inl _, Lex.inl h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inl c), inl_lt_inl_iff.2 ha, inl_lt_inl_iff.2 hb\u27e9\n    | inl _, inr b, Lex.sep _ _ =>\n      let \u27e8c, h\u27e9 := exists_lt b\n      \u27e8toLex (inr c), inl_lt_inr _ _, inr_lt_inr_iff.2 h\u27e9\n    | inr _, inr _, Lex.inr h =>\n      let \u27e8c, ha, hb\u27e9 := exists_between h\n      \u27e8toLex (inr c), inr_lt_inr_iff.2 ha, inr_lt_inr_iff.2 hb\u27e9\u27e9", "start": [520, 1], "end": [532, 65], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumComm", "code": "@[simps! apply]\ndef sumComm (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] : Sum \u03b1 \u03b2 \u2243o Sum \u03b2 \u03b1 :=\n  { Equiv.sumComm \u03b1 \u03b2 with map_rel_iff' := swap_le_swap_iff }", "start": [548, 1], "end": [551, 62], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumComm_symm", "code": "@[simp]\ntheorem sumComm_symm (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] :\n    (OrderIso.sumComm \u03b1 \u03b2).symm = OrderIso.sumComm \u03b2 \u03b1", "start": [555, 1], "end": [558, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc", "code": "def sumAssoc (\u03b1 \u03b2 \u03b3 : Type*) [LE \u03b1] [LE \u03b2] [LE \u03b3] : Sum (Sum \u03b1 \u03b2) \u03b3 \u2243o Sum \u03b1 (Sum \u03b2 \u03b3) :=\n  { Equiv.sumAssoc \u03b1 \u03b2 \u03b3 with\n    map_rel_iff' := @fun a b => by\n      rcases a with ((_ | _) | _) <;> rcases b with ((_ | _) | _) <;>\n      simp [Equiv.sumAssoc] }", "start": [561, 1], "end": [566, 30], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_apply_inl_inl", "code": "@[simp]\ntheorem sumAssoc_apply_inl_inl : sumAssoc \u03b1 \u03b2 \u03b3 (inl (inl a)) = inl a", "start": [569, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_apply_inl_inr", "code": "@[simp]\ntheorem sumAssoc_apply_inl_inr : sumAssoc \u03b1 \u03b2 \u03b3 (inl (inr b)) = inr (inl b)", "start": [574, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_apply_inr", "code": "@[simp]\ntheorem sumAssoc_apply_inr : sumAssoc \u03b1 \u03b2 \u03b3 (inr c) = inr (inr c)", "start": [579, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_symm_apply_inl", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inl : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inl a) = inl (inl a)", "start": [584, 1], "end": [586, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_symm_apply_inr_inl", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inr_inl : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inl b)) = inl (inr b)", "start": [589, 1], "end": [591, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumAssoc_symm_apply_inr_inr", "code": "@[simp]\ntheorem sumAssoc_symm_apply_inr_inr : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c", "start": [594, 1], "end": [596, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumDualDistrib", "code": "def sumDualDistrib (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] : (Sum \u03b1 \u03b2)\u1d52\u1d48 \u2243o Sum \u03b1\u1d52\u1d48 \u03b2\u1d52\u1d48 :=\n  { Equiv.refl _ with\n    map_rel_iff' := by\n      rintro (a | a) (b | b)\n      \u00b7 change inl (toDual a) \u2264 inl (toDual b) \u2194 toDual (inl a) \u2264 toDual (inl b)\n        simp [toDual_le_toDual, inl_le_inl_iff]\n      \u00b7 exact iff_of_false (@not_inl_le_inr (OrderDual \u03b2) (OrderDual \u03b1) _ _ _ _) not_inr_le_inl\n      \u00b7 exact iff_of_false (@not_inr_le_inl (OrderDual \u03b1) (OrderDual \u03b2) _ _ _ _) not_inl_le_inr\n      \u00b7 change inr (toDual a) \u2264 inr (toDual b) \u2194 toDual (inr a) \u2264 toDual (inr b)\n        simp [toDual_le_toDual, inr_le_inr_iff] }", "start": [599, 1], "end": [609, 50], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumDualDistrib_inl", "code": "@[simp]\ntheorem sumDualDistrib_inl : sumDualDistrib \u03b1 \u03b2 (toDual (inl a)) = inl (toDual a)", "start": [612, 1], "end": [614, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumDualDistrib_inr", "code": "@[simp]\ntheorem sumDualDistrib_inr : sumDualDistrib \u03b1 \u03b2 (toDual (inr b)) = inr (toDual b)", "start": [617, 1], "end": [619, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumDualDistrib_symm_inl", "code": "@[simp]\ntheorem sumDualDistrib_symm_inl : (sumDualDistrib \u03b1 \u03b2).symm (inl (toDual a)) = toDual (inl a)", "start": [622, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumDualDistrib_symm_inr", "code": "@[simp]\ntheorem sumDualDistrib_symm_inr : (sumDualDistrib \u03b1 \u03b2).symm (inr (toDual b)) = toDual (inr b)", "start": [627, 1], "end": [629, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc", "code": "def sumLexAssoc (\u03b1 \u03b2 \u03b3 : Type*) [LE \u03b1] [LE \u03b2] [LE \u03b3] : (\u03b1 \u2295\u2097 \u03b2) \u2295\u2097 \u03b3 \u2243o \u03b1 \u2295\u2097 \u03b2 \u2295\u2097 \u03b3 :=\n  { Equiv.sumAssoc \u03b1 \u03b2 \u03b3 with\n    map_rel_iff' := @fun a b =>\n      \u27e8fun h =>\n        match a, b, h with\n        | inl\u2097 (inl\u2097 _), inl\u2097 (inl\u2097 _), Lex.inl h => Lex.inl <| Lex.inl h\n        | inl\u2097 (inl\u2097 _), inl\u2097 (inr\u2097 _), Lex.sep _ _ => Lex.inl <| Lex.sep _ _\n        | inl\u2097 (inl\u2097 _), inr\u2097 _, Lex.sep _ _ => Lex.sep _ _\n        | inl\u2097 (inr\u2097 _), inl\u2097 (inr\u2097 _), Lex.inr (Lex.inl h) => Lex.inl <| Lex.inr h\n        | inl\u2097 (inr\u2097 _), inr\u2097 _, Lex.inr (Lex.sep _ _) => Lex.sep _ _\n        | inr\u2097 _, inr\u2097 _, Lex.inr (Lex.inr h) => Lex.inr h,\n        fun h =>\n        match a, b, h with\n        | inl\u2097 (inl\u2097 _), inl\u2097 (inl\u2097 _), Lex.inl (Lex.inl h) => Lex.inl h\n        | inl\u2097 (inl\u2097 _), inl\u2097 (inr\u2097 _), Lex.inl (Lex.sep _ _) => Lex.sep _ _\n        | inl\u2097 (inl\u2097 _), inr\u2097 _, Lex.sep _ _ => Lex.sep _ _\n        | inl\u2097 (inr\u2097 _), inl\u2097 (inr\u2097 _), Lex.inl (Lex.inr h) => Lex.inr <| Lex.inl h\n        | inl\u2097 (inr\u2097 _), inr\u2097 _, Lex.sep _ _ => Lex.inr <| Lex.sep _ _\n        | inr\u2097 _, inr\u2097 _, Lex.inr h => Lex.inr <| Lex.inr h\u27e9 }", "start": [632, 1], "end": [651, 63], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_apply_inl_inl", "code": "@[simp]\ntheorem sumLexAssoc_apply_inl_inl :\n    sumLexAssoc \u03b1 \u03b2 \u03b3 (toLex <| inl <| toLex <| inl a) = toLex (inl a)", "start": [654, 1], "end": [657, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_apply_inl_inr", "code": "@[simp]\ntheorem sumLexAssoc_apply_inl_inr :\n    sumLexAssoc \u03b1 \u03b2 \u03b3 (toLex <| inl <| toLex <| inr b) = toLex (inr <| toLex <| inl b)", "start": [660, 1], "end": [663, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_apply_inr", "code": "@[simp]\ntheorem sumLexAssoc_apply_inr :\n    sumLexAssoc \u03b1 \u03b2 \u03b3 (toLex <| inr c) = toLex (inr <| toLex <| inr c)", "start": [666, 1], "end": [669, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_symm_apply_inl", "code": "@[simp]\ntheorem sumLexAssoc_symm_apply_inl : (sumLexAssoc \u03b1 \u03b2 \u03b3).symm (inl a) = inl (inl a)", "start": [672, 1], "end": [674, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_symm_apply_inr_inl", "code": "@[simp]\ntheorem sumLexAssoc_symm_apply_inr_inl : (sumLexAssoc \u03b1 \u03b2 \u03b3).symm (inr (inl b)) = inl (inr b)", "start": [677, 1], "end": [679, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexAssoc_symm_apply_inr_inr", "code": "@[simp]\ntheorem sumLexAssoc_symm_apply_inr_inr : (sumLexAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c", "start": [682, 1], "end": [684, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexDualAntidistrib", "code": "def sumLexDualAntidistrib (\u03b1 \u03b2 : Type*) [LE \u03b1] [LE \u03b2] : (\u03b1 \u2295\u2097 \u03b2)\u1d52\u1d48 \u2243o \u03b2\u1d52\u1d48 \u2295\u2097 \u03b1\u1d52\u1d48 :=\n  { Equiv.sumComm \u03b1 \u03b2 with\n    map_rel_iff' := @fun a b => by\n      rcases a with (a | a) <;> rcases b with (b | b); simp\n      \u00b7 change\n          toLex (inr <| toDual a) \u2264 toLex (inr <| toDual b) \u2194\n            toDual (toLex <| inl a) \u2264 toDual (toLex <| inl b)\n        simp [toDual_le_toDual, Lex.inl_le_inl_iff, Lex.inr_le_inr_iff]\n      \u00b7 exact iff_of_false (@Lex.not_inr_le_inl (OrderDual \u03b2) (OrderDual \u03b1) _ _ _ _)\n          Lex.not_inr_le_inl\n      \u00b7 exact iff_of_true (@Lex.inl_le_inr (OrderDual \u03b2) (OrderDual \u03b1) _ _ _ _)\n          (Lex.inl_le_inr _ _)\n      \u00b7 change\n          toLex (inl <| toDual a) \u2264 toLex (inl <| toDual b) \u2194\n            toDual (toLex <| inr a) \u2264 toDual (toLex <| inr b)\n        simp [toDual_le_toDual, Lex.inl_le_inl_iff, Lex.inr_le_inr_iff] }", "start": [687, 1], "end": [703, 74], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexDualAntidistrib_inl", "code": "@[simp]\ntheorem sumLexDualAntidistrib_inl :\n    sumLexDualAntidistrib \u03b1 \u03b2 (toDual (inl a)) = inr (toDual a)", "start": [706, 1], "end": [709, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexDualAntidistrib_inr", "code": "@[simp]\ntheorem sumLexDualAntidistrib_inr :\n    sumLexDualAntidistrib \u03b1 \u03b2 (toDual (inr b)) = inl (toDual b)", "start": [712, 1], "end": [715, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexDualAntidistrib_symm_inl", "code": "@[simp]\ntheorem sumLexDualAntidistrib_symm_inl :\n    (sumLexDualAntidistrib \u03b1 \u03b2).symm (inl (toDual b)) = toDual (inr b)", "start": [718, 1], "end": [721, 6], "kind": "commanddeclaration"}, {"full_name": "OrderIso.sumLexDualAntidistrib_symm_inr", "code": "@[simp]\ntheorem sumLexDualAntidistrib_symm_inr :\n    (sumLexDualAntidistrib \u03b1 \u03b2).symm (inr (toDual a)) = toDual (inl a)", "start": [724, 1], "end": [727, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderIsoPUnitSumLex", "code": "def orderIsoPUnitSumLex : WithBot \u03b1 \u2243o PUnit \u2295\u2097 \u03b1 :=\n  \u27e8(Equiv.optionEquivSumPUnit \u03b1).trans <| (Equiv.sumComm _ _).trans toLex, @fun a b => by\n    simp only [Equiv.optionEquivSumPUnit, Option.elim, Equiv.trans_apply, Equiv.coe_fn_mk,\n      Equiv.sumComm_apply, swap, Lex.toLex_le_toLex, le_refl]\n    rcases a with (a | _) <;> rcases b with (b | _)\n    \u00b7 simp only [elim_inr, lex_inl_inl, none_le]\n    \u00b7 simp only [elim_inr, elim_inl, Lex.sep, none_le]\n    \u00b7 simp only [elim_inl, elim_inr, lex_inr_inl, false_iff]\n      exact not_coe_le_bot _\n    \u00b7 simp only [elim_inl, lex_inr_inr, some_le_some]\n  \u27e9", "start": [736, 1], "end": [748, 4], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderIsoPUnitSumLex_bot", "code": "@[simp]\ntheorem orderIsoPUnitSumLex_bot : @orderIsoPUnitSumLex \u03b1 _ \u22a5 = toLex (inl PUnit.unit)", "start": [753, 1], "end": [755, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderIsoPUnitSumLex_toLex", "code": "@[simp]\ntheorem orderIsoPUnitSumLex_toLex (a : \u03b1) : orderIsoPUnitSumLex \u2191a = toLex (inr a)", "start": [758, 1], "end": [760, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderIsoPUnitSumLex_symm_inl", "code": "@[simp]\ntheorem orderIsoPUnitSumLex_symm_inl (x : PUnit) :\n    (@orderIsoPUnitSumLex \u03b1 _).symm (toLex <| inl x) = \u22a5", "start": [763, 1], "end": [766, 6], "kind": "commanddeclaration"}, {"full_name": "WithBot.orderIsoPUnitSumLex_symm_inr", "code": "@[simp]\ntheorem orderIsoPUnitSumLex_symm_inr (a : \u03b1) : orderIsoPUnitSumLex.symm (toLex <| inr a) = a", "start": [769, 1], "end": [771, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderIsoSumLexPUnit", "code": "def orderIsoSumLexPUnit : WithTop \u03b1 \u2243o \u03b1 \u2295\u2097 PUnit :=\n  \u27e8(Equiv.optionEquivSumPUnit \u03b1).trans toLex, @fun a b => by\n    simp only [Equiv.optionEquivSumPUnit, Option.elim, Equiv.trans_apply, Equiv.coe_fn_mk,\n      ge_iff_le, Lex.toLex_le_toLex, le_refl, lex_inr_inr, le_none]\n    rcases a with (a | _) <;> rcases b with (b | _)\n    \u00b7 simp only [lex_inr_inr, le_none]\n    \u00b7 simp only [lex_inr_inl, false_iff]\n      exact not_top_le_coe _\n    \u00b7 simp only [Lex.sep, le_none]\n    \u00b7 simp only [lex_inl_inl, some_le_some]\n\n  \u27e9", "start": [778, 1], "end": [791, 4], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderIsoSumLexPUnit_top", "code": "@[simp]\ntheorem orderIsoSumLexPUnit_top : @orderIsoSumLexPUnit \u03b1 _ \u22a4 = toLex (inr PUnit.unit)", "start": [794, 1], "end": [796, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderIsoSumLexPUnit_toLex", "code": "@[simp]\ntheorem orderIsoSumLexPUnit_toLex (a : \u03b1) : orderIsoSumLexPUnit \u2191a = toLex (inl a)", "start": [799, 1], "end": [801, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderIsoSumLexPUnit_symm_inr", "code": "@[simp]\ntheorem orderIsoSumLexPUnit_symm_inr (x : PUnit) :\n    (@orderIsoSumLexPUnit \u03b1 _).symm (toLex <| inr x) = \u22a4", "start": [804, 1], "end": [807, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.orderIsoSumLexPUnit_symm_inl", "code": "@[simp]\ntheorem orderIsoSumLexPUnit_symm_inl (a : \u03b1) : orderIsoSumLexPUnit.symm (toLex <| inl a) = a", "start": [810, 1], "end": [812, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Pi.lean", "imports": ["Mathlib/Topology/UniformSpace/Cauchy.lean", "Mathlib/Topology/UniformSpace/Separation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Pi.uniformSpace", "code": "instance Pi.uniformSpace : UniformSpace (\u2200 i, \u03b1 i) :=\n  UniformSpace.ofCoreEq (\u2a05 i, UniformSpace.comap (fun a : \u2200 i, \u03b1 i => a i) (U i)).toCore\n      Pi.topologicalSpace <|\n    Eq.symm toTopologicalSpace_iInf", "start": [28, 1], "end": [31, 36], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformSpace_eq", "code": "lemma Pi.uniformSpace_eq :\n    Pi.uniformSpace \u03b1 = \u2a05 i, UniformSpace.comap (fun a : (\u2200 i, \u03b1 i) \u21a6 a i) (U i) := by\n  ext : 1; rfl", "start": [34, 1], "end": [36, 15], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.uniformity", "code": "theorem Pi.uniformity :\n    \ud835\udce4 (\u2200 i, \u03b1 i) = \u2a05 i : \u03b9, (Filter.comap fun a => (a.1 i, a.2 i)) (\ud835\udce4 (\u03b1 i))", "start": [38, 1], "end": [40, 18], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_pi", "code": "theorem uniformContinuous_pi {\u03b2 : Type*} [UniformSpace \u03b2] {f : \u03b2 \u2192 \u2200 i, \u03b1 i} :\n    UniformContinuous f \u2194 \u2200 i, UniformContinuous fun x => f x i", "start": [45, 1], "end": [48, 95], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformContinuous_proj", "code": "theorem Pi.uniformContinuous_proj (i : \u03b9) : UniformContinuous fun a : \u2200 i : \u03b9, \u03b1 i => a i", "start": [53, 1], "end": [54, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformContinuous_precomp'", "code": "theorem Pi.uniformContinuous_precomp' (\u03c6 : \u03b9' \u2192 \u03b9) :\n    UniformContinuous (fun (f : (\u2200 i, \u03b1 i)) (j : \u03b9') \u21a6 f (\u03c6 j))", "start": [57, 1], "end": [59, 66], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformContinuous_precomp", "code": "theorem Pi.uniformContinuous_precomp (\u03c6 : \u03b9' \u2192 \u03b9) :\n    UniformContinuous (\u00b7 \u2218 \u03c6 : (\u03b9 \u2192 \u03b2) \u2192 (\u03b9' \u2192 \u03b2))", "start": [61, 1], "end": [63, 36], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformContinuous_postcomp'", "code": "theorem Pi.uniformContinuous_postcomp' {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, UniformSpace (\u03b2 i)]\n    {g : \u2200 i, \u03b1 i \u2192 \u03b2 i} (hg : \u2200 i, UniformContinuous (g i)) :\n    UniformContinuous (fun (f : (\u2200 i, \u03b1 i)) (i : \u03b9) \u21a6 g i (f i))", "start": [65, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformContinuous_postcomp", "code": "theorem Pi.uniformContinuous_postcomp {\u03b1 : Type*} [UniformSpace \u03b1] {g : \u03b1 \u2192 \u03b2}\n    (hg : UniformContinuous g) : UniformContinuous (g \u2218 \u00b7 : (\u03b9 \u2192 \u03b1) \u2192 (\u03b9 \u2192 \u03b2))", "start": [70, 1], "end": [72, 46], "kind": "commanddeclaration"}, {"full_name": "Pi.uniformSpace_comap_precomp'", "code": "lemma Pi.uniformSpace_comap_precomp' (\u03c6 : \u03b9' \u2192 \u03b9) :\n    UniformSpace.comap (fun g i' \u21a6 g (\u03c6 i')) (Pi.uniformSpace (fun i' \u21a6 \u03b1 (\u03c6 i'))) =\n    \u2a05 i', UniformSpace.comap (eval (\u03c6 i')) (U (\u03c6 i')) := by\n  simp [Pi.uniformSpace_eq, UniformSpace.comap_iInf, \u2190 UniformSpace.comap_comap, comp]", "start": [74, 1], "end": [77, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.uniformSpace_comap_precomp", "code": "lemma Pi.uniformSpace_comap_precomp (\u03c6 : \u03b9' \u2192 \u03b9) :\n    UniformSpace.comap (\u00b7 \u2218 \u03c6) (Pi.uniformSpace (fun _ \u21a6 \u03b2)) =\n    \u2a05 i', UniformSpace.comap (eval (\u03c6 i')) \u2039UniformSpace \u03b2\u203a :=\n  uniformSpace_comap_precomp' (fun _ \u21a6 \u03b2) \u03c6", "start": [79, 1], "end": [82, 44], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.uniformContinuous_restrict", "code": "lemma Pi.uniformContinuous_restrict (S : Set \u03b9) :\n    UniformContinuous (S.restrict : (\u2200 i : \u03b9, \u03b1 i) \u2192 (\u2200 i : S, \u03b1 i)) :=\n  Pi.uniformContinuous_precomp' _ ((\u2191) : S \u2192 \u03b9)", "start": [84, 1], "end": [86, 48], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.uniformSpace_comap_restrict", "code": "lemma Pi.uniformSpace_comap_restrict (S : Set \u03b9) :\n    UniformSpace.comap (S.restrict) (Pi.uniformSpace (fun i : S \u21a6 \u03b1 i)) =\n    \u2a05 i \u2208 S, UniformSpace.comap (eval i) (U i) := by\n  simp [\u2190 iInf_subtype'', \u2190 uniformSpace_comap_precomp' _ ((\u2191) : S \u2192 \u03b9), Set.restrict]", "start": [88, 1], "end": [91, 87], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_pi_iff", "code": "lemma cauchy_pi_iff [Nonempty \u03b9] {l : Filter (\u2200 i, \u03b1 i)} :\n    Cauchy l \u2194 \u2200 i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace, cauchy_comap_uniformSpace]", "start": [93, 1], "end": [95, 84], "kind": "mathlibtacticlemma"}, {"full_name": "cauchy_pi_iff'", "code": "lemma cauchy_pi_iff' {l : Filter (\u2200 i, \u03b1 i)} [l.NeBot] :\n    Cauchy l \u2194 \u2200 i, Cauchy (map (eval i) l) := by\n  simp_rw [Pi.uniformSpace_eq, cauchy_iInf_uniformSpace', cauchy_comap_uniformSpace]", "start": [97, 1], "end": [99, 85], "kind": "mathlibtacticlemma"}, {"full_name": "Cauchy.pi", "code": "lemma Cauchy.pi [Nonempty \u03b9] {l : \u2200 i, Filter (\u03b1 i)} (hl : \u2200 i, Cauchy (l i)) :\n    Cauchy (Filter.pi l) := by\n  have := fun i \u21a6 (hl i).1\n  simpa [cauchy_pi_iff]", "start": [101, 1], "end": [104, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Pi.complete", "code": "instance Pi.complete [\u2200 i, CompleteSpace (\u03b1 i)] : CompleteSpace (\u2200 i, \u03b1 i) where\n  complete {f} hf := by\n    have := hf.1\n    simp_rw [cauchy_pi_iff', cauchy_iff_exists_le_nhds] at hf\n    choose x hx using hf\n    use x\n    rwa [nhds_pi, le_pi]", "start": [106, 1], "end": [112, 25], "kind": "commanddeclaration"}, {"full_name": "Pi.separated", "code": "instance Pi.separated [\u2200 i, SeparatedSpace (\u03b1 i)] : SeparatedSpace (\u2200 i, \u03b1 i) :=\n  separated_def.2 fun x y H => by\n    ext i\n    apply eq_of_separated_of_uniformContinuous (Pi.uniformContinuous_proj \u03b1 i)\n    apply H", "start": [115, 1], "end": [120, 12], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "imports": ["Mathlib/Topology/UniformSpace/Cauchy.lean", "Mathlib/Topology/UniformSpace/Separation.lean", "Mathlib/Topology/DenseEmbedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformInducing", "code": "@[mk_iff uniformInducing_iff]\nstructure UniformInducing (f : \u03b1 \u2192 \u03b2) : Prop where\n  \n  comap_uniformity : comap (fun x : \u03b1 \u00d7 \u03b1 => (f x.1, f x.2)) (\ud835\udce4 \u03b2) = \ud835\udce4 \u03b1", "start": [30, 1], "end": [37, 73], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.comap_uniformSpace", "code": "protected lemma UniformInducing.comap_uniformSpace {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) :\n    \u2039UniformSpace \u03b2\u203a.comap f = \u2039UniformSpace \u03b1\u203a :=\n  UniformSpace.ext hf.1", "start": [41, 1], "end": [43, 24], "kind": "mathlibtacticlemma"}, {"full_name": "uniformInducing_iff'", "code": "lemma uniformInducing_iff' {f : \u03b1 \u2192 \u03b2} :\n    UniformInducing f \u2194 UniformContinuous f \u2227 comap (Prod.map f f) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1 := by\n  rw [uniformInducing_iff, UniformContinuous, tendsto_iff_comap, le_antisymm_iff, and_comm]; rfl", "start": [46, 1], "end": [48, 97], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.HasBasis.uniformInducing_iff", "code": "protected lemma Filter.HasBasis.uniformInducing_iff {\u03b9 \u03b9'} {p : \u03b9 \u2192 Prop} {p' : \u03b9' \u2192 Prop} {s s'}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) (h' : (\ud835\udce4 \u03b2).HasBasis p' s') {f : \u03b1 \u2192 \u03b2} :\n    UniformInducing f \u2194\n      (\u2200 i, p' i \u2192 \u2203 j, p j \u2227 \u2200 x y, (x, y) \u2208 s j \u2192 (f x, f y) \u2208 s' i) \u2227\n        (\u2200 j, p j \u2192 \u2203 i, p' i \u2227 \u2200 x y, (f x, f y) \u2208 s' i \u2192 (x, y) \u2208 s j) := by\n  simp [uniformInducing_iff', h.uniformContinuous_iff h', (h'.comap _).le_basis_iff h, subset_def]", "start": [51, 1], "end": [56, 99], "kind": "mathlibtacticlemma"}, {"full_name": "UniformInducing.mk'", "code": "theorem UniformInducing.mk' {f : \u03b1 \u2192 \u03b2}\n    (h : \u2200 s, s \u2208 \ud835\udce4 \u03b1 \u2194 \u2203 t \u2208 \ud835\udce4 \u03b2, \u2200 x y : \u03b1, (f x, f y) \u2208 t \u2192 (x, y) \u2208 s) : UniformInducing f", "start": [59, 1], "end": [61, 53], "kind": "commanddeclaration"}, {"full_name": "uniformInducing_id", "code": "theorem uniformInducing_id : UniformInducing (@id \u03b1)", "start": [64, 1], "end": [65, 50], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.comp", "code": "theorem UniformInducing.comp {g : \u03b2 \u2192 \u03b3} (hg : UniformInducing g) {f : \u03b1 \u2192 \u03b2}\n    (hf : UniformInducing f) : UniformInducing (g \u2218 f)", "start": [68, 1], "end": [70, 45], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.basis_uniformity", "code": "theorem UniformInducing.basis_uniformity {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) {\u03b9 : Sort*}\n    {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)} (H : (\ud835\udce4 \u03b2).HasBasis p s) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => Prod.map f f \u207b\u00b9' s i", "start": [73, 1], "end": [76, 19], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.cauchy_map_iff", "code": "theorem UniformInducing.cauchy_map_iff {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) {F : Filter \u03b1} :\n    Cauchy (map f F) \u2194 Cauchy F", "start": [79, 1], "end": [81, 97], "kind": "commanddeclaration"}, {"full_name": "uniformInducing_of_compose", "code": "theorem uniformInducing_of_compose {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) (hgf : UniformInducing (g \u2218 f)) : UniformInducing f", "start": [84, 1], "end": [88, 31], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.uniformContinuous", "code": "theorem UniformInducing.uniformContinuous {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) :\n    UniformContinuous f", "start": [91, 1], "end": [92, 57], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.uniformContinuous_iff", "code": "theorem UniformInducing.uniformContinuous_iff {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : UniformInducing g) :\n    UniformContinuous f \u2194 UniformContinuous (g \u2218 f)", "start": [95, 1], "end": [98, 73], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.inducing", "code": "theorem UniformInducing.inducing {f : \u03b1 \u2192 \u03b2} (h : UniformInducing f) : Inducing f", "start": [101, 1], "end": [103, 27], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.prod", "code": "theorem UniformInducing.prod {\u03b1' : Type*} {\u03b2' : Type*} [UniformSpace \u03b1'] [UniformSpace \u03b2']\n    {e\u2081 : \u03b1 \u2192 \u03b1'} {e\u2082 : \u03b2 \u2192 \u03b2'} (h\u2081 : UniformInducing e\u2081) (h\u2082 : UniformInducing e\u2082) :\n    UniformInducing fun p : \u03b1 \u00d7 \u03b2 => (e\u2081 p.1, e\u2082 p.2)", "start": [106, 1], "end": [109, 79], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.denseInducing", "code": "theorem UniformInducing.denseInducing {f : \u03b1 \u2192 \u03b2} (h : UniformInducing f) (hd : DenseRange f) :\n    DenseInducing f", "start": [112, 1], "end": [115, 36], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.injective", "code": "protected theorem UniformInducing.injective [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2} (h : UniformInducing f) :\n    Injective f", "start": [118, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding", "code": "@[mk_iff uniformEmbedding_iff]\nstructure UniformEmbedding (f : \u03b1 \u2192 \u03b2) extends UniformInducing f : Prop where\n  \n  inj : Function.Injective f", "start": [126, 1], "end": [131, 29], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_iff'", "code": "theorem uniformEmbedding_iff' {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 Injective f \u2227 UniformContinuous f \u2227 comap (Prod.map f f) (\ud835\udce4 \u03b2) \u2264 \ud835\udce4 \u03b1", "start": [135, 1], "end": [137, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformEmbedding_iff'", "code": "theorem Filter.HasBasis.uniformEmbedding_iff' {\u03b9 \u03b9'} {p : \u03b9 \u2192 Prop} {p' : \u03b9' \u2192 Prop} {s s'}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) (h' : (\ud835\udce4 \u03b2).HasBasis p' s') {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 Injective f \u2227\n      (\u2200 i, p' i \u2192 \u2203 j, p j \u2227 \u2200 x y, (x, y) \u2208 s j \u2192 (f x, f y) \u2208 s' i) \u2227\n        (\u2200 j, p j \u2192 \u2203 i, p' i \u2227 \u2200 x y, (f x, f y) \u2208 s' i \u2192 (x, y) \u2208 s j)", "start": [140, 1], "end": [145, 64], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformEmbedding_iff", "code": "theorem Filter.HasBasis.uniformEmbedding_iff {\u03b9 \u03b9'} {p : \u03b9 \u2192 Prop} {p' : \u03b9' \u2192 Prop} {s s'}\n    (h : (\ud835\udce4 \u03b1).HasBasis p s) (h' : (\ud835\udce4 \u03b2).HasBasis p' s') {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 Injective f \u2227 UniformContinuous f \u2227\n      (\u2200 j, p j \u2192 \u2203 i, p' i \u2227 \u2200 x y, (f x, f y) \u2208 s' i \u2192 (x, y) \u2208 s j)", "start": [148, 1], "end": [152, 69], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_subtype_val", "code": "theorem uniformEmbedding_subtype_val {p : \u03b1 \u2192 Prop} :\n    UniformEmbedding (Subtype.val : Subtype p \u2192 \u03b1)", "start": [155, 1], "end": [158, 35], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_set_inclusion", "code": "theorem uniformEmbedding_set_inclusion {s t : Set \u03b1} (hst : s \u2286 t) :\n    UniformEmbedding (inclusion hst) where", "start": [162, 1], "end": [165, 33], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.comp", "code": "theorem UniformEmbedding.comp {g : \u03b2 \u2192 \u03b3} (hg : UniformEmbedding g) {f : \u03b1 \u2192 \u03b2}\n    (hf : UniformEmbedding f) : UniformEmbedding (g \u2218 f)", "start": [168, 1], "end": [170, 84], "kind": "commanddeclaration"}, {"full_name": "Equiv.uniformEmbedding", "code": "theorem Equiv.uniformEmbedding {\u03b1 \u03b2 : Type*} [UniformSpace \u03b1] [UniformSpace \u03b2] (f : \u03b1 \u2243 \u03b2)\n    (h\u2081 : UniformContinuous f) (h\u2082 : UniformContinuous f.symm) : UniformEmbedding f", "start": [173, 1], "end": [175, 96], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_inl", "code": "theorem uniformEmbedding_inl : UniformEmbedding (Sum.inl : \u03b1 \u2192 \u03b1 \u2295 \u03b2)", "start": [178, 1], "end": [181, 84], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_inr", "code": "theorem uniformEmbedding_inr : UniformEmbedding (Sum.inr : \u03b2 \u2192 \u03b1 \u2295 \u03b2)", "start": [184, 1], "end": [187, 84], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.uniformEmbedding", "code": "protected theorem UniformInducing.uniformEmbedding [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (hf : UniformInducing f) : UniformEmbedding f", "start": [190, 1], "end": [194, 30], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_iff_uniformInducing", "code": "theorem uniformEmbedding_iff_uniformInducing [T0Space \u03b1] {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 UniformInducing f", "start": [197, 1], "end": [199, 73], "kind": "commanddeclaration"}, {"full_name": "comap_uniformity_of_spaced_out", "code": "theorem comap_uniformity_of_spaced_out {\u03b1} {f : \u03b1 \u2192 \u03b2} {s : Set (\u03b2 \u00d7 \u03b2)} (hs : s \u2208 \ud835\udce4 \u03b2)\n    (hf : Pairwise fun x y => (f x, f y) \u2209 s) : comap (Prod.map f f) (\ud835\udce4 \u03b2) = \ud835\udcdf idRel", "start": [202, 1], "end": [213, 51], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_of_spaced_out", "code": "theorem uniformEmbedding_of_spaced_out {\u03b1} {f : \u03b1 \u2192 \u03b2} {s : Set (\u03b2 \u00d7 \u03b2)} (hs : s \u2208 \ud835\udce4 \u03b2)\n    (hf : Pairwise fun x y => (f x, f y) \u2209 s) : @UniformEmbedding \u03b1 \u03b2 \u22a5 \u2039_\u203a f", "start": [216, 1], "end": [221, 80], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.embedding", "code": "protected theorem UniformEmbedding.embedding {f : \u03b1 \u2192 \u03b2} (h : UniformEmbedding f) : Embedding f", "start": [224, 1], "end": [226, 19], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.denseEmbedding", "code": "theorem UniformEmbedding.denseEmbedding {f : \u03b1 \u2192 \u03b2} (h : UniformEmbedding f) (hd : DenseRange f) :\n    DenseEmbedding f", "start": [229, 1], "end": [231, 35], "kind": "commanddeclaration"}, {"full_name": "closedEmbedding_of_spaced_out", "code": "theorem closedEmbedding_of_spaced_out {\u03b1} [TopologicalSpace \u03b1] [DiscreteTopology \u03b1]\n    [SeparatedSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set (\u03b2 \u00d7 \u03b2)} (hs : s \u2208 \ud835\udce4 \u03b2)\n    (hf : Pairwise fun x y => (f x, f y) \u2209 s) : ClosedEmbedding f", "start": [234, 1], "end": [240, 59], "kind": "commanddeclaration"}, {"full_name": "closure_image_mem_nhds_of_uniformInducing", "code": "theorem closure_image_mem_nhds_of_uniformInducing {s : Set (\u03b1 \u00d7 \u03b1)} {e : \u03b1 \u2192 \u03b2} (b : \u03b2)\n    (he\u2081 : UniformInducing e) (he\u2082 : DenseInducing e) (hs : s \u2208 \ud835\udce4 \u03b1) :\n    \u2203 a, closure (e '' { a' | (a, a') \u2208 s }) \u2208 \ud835\udcdd b", "start": [243, 1], "end": [255, 43], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_subtypeEmb", "code": "theorem uniformEmbedding_subtypeEmb (p : \u03b1 \u2192 Prop) {e : \u03b1 \u2192 \u03b2} (ue : UniformEmbedding e)\n    (de : DenseEmbedding e) : UniformEmbedding (DenseEmbedding.subtypeEmb p e)", "start": [258, 1], "end": [263, 32], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.prod", "code": "theorem UniformEmbedding.prod {\u03b1' : Type*} {\u03b2' : Type*} [UniformSpace \u03b1'] [UniformSpace \u03b2']\n    {e\u2081 : \u03b1 \u2192 \u03b1'} {e\u2082 : \u03b2 \u2192 \u03b2'} (h\u2081 : UniformEmbedding e\u2081) (h\u2082 : UniformEmbedding e\u2082) :\n    UniformEmbedding fun p : \u03b1 \u00d7 \u03b2 => (e\u2081 p.1, e\u2082 p.2)", "start": [266, 1], "end": [269, 88], "kind": "commanddeclaration"}, {"full_name": "isComplete_of_complete_image", "code": "theorem isComplete_of_complete_image {m : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hm : UniformInducing m)\n    (hs : IsComplete (m '' s)) : IsComplete s", "start": [272, 1], "end": [279, 21], "kind": "commanddeclaration"}, {"full_name": "IsComplete.completeSpace_coe", "code": "theorem IsComplete.completeSpace_coe {s : Set \u03b1} (hs : IsComplete s) : CompleteSpace s", "start": [282, 1], "end": [284, 96], "kind": "commanddeclaration"}, {"full_name": "isComplete_image_iff", "code": "theorem isComplete_image_iff {m : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hm : UniformInducing m) :\n    IsComplete (m '' s) \u2194 IsComplete s", "start": [287, 1], "end": [301, 37], "kind": "commanddeclaration"}, {"full_name": "completeSpace_iff_isComplete_range", "code": "theorem completeSpace_iff_isComplete_range {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) :\n    CompleteSpace \u03b1 \u2194 IsComplete (range f)", "start": [304, 1], "end": [306, 80], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.isComplete_range", "code": "theorem UniformInducing.isComplete_range [CompleteSpace \u03b1] {f : \u03b1 \u2192 \u03b2} (hf : UniformInducing f) :\n    IsComplete (range f)", "start": [309, 1], "end": [311, 48], "kind": "commanddeclaration"}, {"full_name": "completeSpace_congr", "code": "theorem completeSpace_congr {e : \u03b1 \u2243 \u03b2} (he : UniformEmbedding e) :\n    CompleteSpace \u03b1 \u2194 CompleteSpace \u03b2", "start": [314, 1], "end": [317, 39], "kind": "commanddeclaration"}, {"full_name": "completeSpace_coe_iff_isComplete", "code": "theorem completeSpace_coe_iff_isComplete {s : Set \u03b1} : CompleteSpace s \u2194 IsComplete s", "start": [320, 1], "end": [322, 27], "kind": "commanddeclaration"}, {"full_name": "IsClosed.completeSpace_coe", "code": "theorem IsClosed.completeSpace_coe [CompleteSpace \u03b1] {s : Set \u03b1} (hs : IsClosed s) :\n    CompleteSpace s", "start": [325, 1], "end": [327, 34], "kind": "commanddeclaration"}, {"full_name": "ULift.completeSpace", "code": "instance ULift.completeSpace [h : CompleteSpace \u03b1] : CompleteSpace (ULift \u03b1) :=\n  haveI : UniformEmbedding (@Equiv.ulift \u03b1) := \u27e8\u27e8rfl\u27e9, ULift.down_injective\u27e9\n  (completeSpace_congr this).2 h", "start": [330, 1], "end": [333, 33], "kind": "commanddeclaration"}, {"full_name": "completeSpace_extension", "code": "theorem completeSpace_extension {m : \u03b2 \u2192 \u03b1} (hm : UniformInducing m) (dense : DenseRange m)\n    (h : \u2200 f : Filter \u03b2, Cauchy f \u2192 \u2203 x : \u03b1, map m f \u2264 \ud835\udcdd x) : CompleteSpace \u03b1", "start": [336, 1], "end": [380, 11], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_preimage", "code": "theorem totallyBounded_preimage {f : \u03b1 \u2192 \u03b2} {s : Set \u03b2} (hf : UniformEmbedding f)\n    (hs : TotallyBounded s) : TotallyBounded (f \u207b\u00b9' s)", "start": [383, 1], "end": [393, 23], "kind": "commanddeclaration"}, {"full_name": "CompleteSpace.sum", "code": "instance CompleteSpace.sum [CompleteSpace \u03b1] [CompleteSpace \u03b2] : CompleteSpace (Sum \u03b1 \u03b2) := by\n  rw [completeSpace_iff_isComplete_univ, \u2190 range_inl_union_range_inr]\n  exact uniformEmbedding_inl.toUniformInducing.isComplete_range.union\n    uniformEmbedding_inr.toUniformInducing.isComplete_range", "start": [396, 1], "end": [399, 60], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_comap", "code": "theorem uniformEmbedding_comap {\u03b1 : Type*} {\u03b2 : Type*} {f : \u03b1 \u2192 \u03b2} [u : UniformSpace \u03b2]\n    (hf : Function.Injective f) : @UniformEmbedding \u03b1 \u03b2 (UniformSpace.comap f u) u f", "start": [404, 1], "end": [407, 66], "kind": "commanddeclaration"}, {"full_name": "Embedding.comapUniformSpace", "code": "def Embedding.comapUniformSpace {\u03b1 \u03b2} [TopologicalSpace \u03b1] [u : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : Embedding f) : UniformSpace \u03b1 :=\n  (u.comap f).replaceTopology h.induced", "start": [410, 1], "end": [414, 40], "kind": "commanddeclaration"}, {"full_name": "Embedding.to_uniformEmbedding", "code": "theorem Embedding.to_uniformEmbedding {\u03b1 \u03b2} [TopologicalSpace \u03b1] [u : UniformSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : Embedding f) : @UniformEmbedding \u03b1 \u03b2 (h.comapUniformSpace f) u f", "start": [417, 1], "end": [421, 19], "kind": "commanddeclaration"}, {"full_name": "uniformly_extend_exists", "code": "theorem uniformly_extend_exists [CompleteSpace \u03b3] (a : \u03b1) : \u2203 c, Tendsto f (comap e (\ud835\udcdd a)) (\ud835\udcdd c)", "start": [432, 1], "end": [438, 30], "kind": "commanddeclaration"}, {"full_name": "uniform_extend_subtype", "code": "theorem uniform_extend_subtype [CompleteSpace \u03b3] {p : \u03b1 \u2192 Prop} {e : \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b3} {b : \u03b2}\n    {s : Set \u03b1} (hf : UniformContinuous fun x : Subtype p => f x.val) (he : UniformEmbedding e)\n    (hd : \u2200 x : \u03b2, x \u2208 closure (range e)) (hb : closure (e '' s) \u2208 \ud835\udcdd b) (hs : IsClosed s)\n    (hp : \u2200 x \u2208 s, p x) : \u2203 c, Tendsto f (comap e (\ud835\udcdd b)) (\ud835\udcdd c)", "start": [441, 1], "end": [455, 91], "kind": "commanddeclaration"}, {"full_name": "uniformly_extend_spec", "code": "theorem uniformly_extend_spec [CompleteSpace \u03b3] (a : \u03b1) : Tendsto f (comap e (\ud835\udcdd a)) (\ud835\udcdd (\u03c8 a))", "start": [458, 1], "end": [460, 66], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_uniformly_extend", "code": "theorem uniformContinuous_uniformly_extend [CompleteSpace \u03b3] : UniformContinuous \u03c8", "start": [463, 1], "end": [487, 49], "kind": "commanddeclaration"}, {"full_name": "uniformly_extend_of_ind", "code": "theorem uniformly_extend_of_ind (b : \u03b2) : \u03c8 (e b) = f b", "start": [492, 1], "end": [493, 59], "kind": "commanddeclaration"}, {"full_name": "uniformly_extend_unique", "code": "theorem uniformly_extend_unique {g : \u03b1 \u2192 \u03b3} (hg : \u2200 b, g (e b) = f b) (hc : Continuous g) : \u03c8 = g", "start": [496, 1], "end": [497, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/LeftRight.lean", "imports": ["Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "continuousWithinAt_Ioi_iff_Ici", "code": "theorem continuousWithinAt_Ioi_iff_Ici {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousWithinAt f (Ioi a) a \u2194 ContinuousWithinAt f (Ici a) a", "start": [34, 1], "end": [36, 60], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Iio_iff_Iic", "code": "theorem continuousWithinAt_Iio_iff_Iic {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousWithinAt f (Iio a) a \u2194 ContinuousWithinAt f (Iic a) a", "start": [39, 1], "end": [41, 50], "kind": "commanddeclaration"}, {"full_name": "nhds_left'_le_nhds_ne", "code": "theorem nhds_left'_le_nhds_ne (a : \u03b1) : \ud835\udcdd[<] a \u2264 \ud835\udcdd[\u2260] a", "start": [44, 1], "end": [45, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_right'_le_nhds_ne", "code": "theorem nhds_right'_le_nhds_ne (a : \u03b1) : \ud835\udcdd[>] a \u2264 \ud835\udcdd[\u2260] a", "start": [48, 1], "end": [49, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_left_sup_nhds_right", "code": "theorem nhds_left_sup_nhds_right (a : \u03b1) : \ud835\udcdd[\u2264] a \u2294 \ud835\udcdd[\u2265] a = \ud835\udcdd a", "start": [58, 1], "end": [59, 58], "kind": "commanddeclaration"}, {"full_name": "nhds_left'_sup_nhds_right", "code": "theorem nhds_left'_sup_nhds_right (a : \u03b1) : \ud835\udcdd[<] a \u2294 \ud835\udcdd[\u2265] a = \ud835\udcdd a", "start": [62, 1], "end": [63, 58], "kind": "commanddeclaration"}, {"full_name": "nhds_left_sup_nhds_right'", "code": "theorem nhds_left_sup_nhds_right' (a : \u03b1) : \ud835\udcdd[\u2264] a \u2294 \ud835\udcdd[>] a = \ud835\udcdd a", "start": [66, 1], "end": [67, 58], "kind": "commanddeclaration"}, {"full_name": "nhds_left'_sup_nhds_right'", "code": "theorem nhds_left'_sup_nhds_right' (a : \u03b1) : \ud835\udcdd[<] a \u2294 \ud835\udcdd[>] a = \ud835\udcdd[\u2260] a", "start": [70, 1], "end": [71, 41], "kind": "commanddeclaration"}, {"full_name": "continuousAt_iff_continuous_left_right", "code": "theorem continuousAt_iff_continuous_left_right {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousAt f a \u2194 ContinuousWithinAt f (Iic a) a \u2227 ContinuousWithinAt f (Ici a) a", "start": [74, 1], "end": [76, 88], "kind": "commanddeclaration"}, {"full_name": "continuousAt_iff_continuous_left'_right'", "code": "theorem continuousAt_iff_continuous_left'_right' {a : \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    ContinuousAt f a \u2194 ContinuousWithinAt f (Iio a) a \u2227 ContinuousWithinAt f (Ioi a) a", "start": [79, 1], "end": [82, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Pointwise/Interval.lean", "imports": ["Mathlib/Algebra/Order/Group/MinMax.lean", "Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "Mathlib/Data/Set/Intervals/Monoid.lean", "Mathlib/Data/Set/Pointwise/Basic.lean"], "premises": [{"full_name": "Set.preimage_const_add_Ici", "code": "@[simp]\ntheorem preimage_const_add_Ici : (fun x => a + x) \u207b\u00b9' Ici b = Ici (b - a)", "start": [39, 1], "end": [41, 40], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Ioi", "code": "@[simp]\ntheorem preimage_const_add_Ioi : (fun x => a + x) \u207b\u00b9' Ioi b = Ioi (b - a)", "start": [44, 1], "end": [46, 40], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Iic", "code": "@[simp]\ntheorem preimage_const_add_Iic : (fun x => a + x) \u207b\u00b9' Iic b = Iic (b - a)", "start": [49, 1], "end": [51, 40], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Iio", "code": "@[simp]\ntheorem preimage_const_add_Iio : (fun x => a + x) \u207b\u00b9' Iio b = Iio (b - a)", "start": [54, 1], "end": [56, 40], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Icc", "code": "@[simp]\ntheorem preimage_const_add_Icc : (fun x => a + x) \u207b\u00b9' Icc b c = Icc (b - a) (c - a)", "start": [59, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Ico", "code": "@[simp]\ntheorem preimage_const_add_Ico : (fun x => a + x) \u207b\u00b9' Ico b c = Ico (b - a) (c - a)", "start": [64, 1], "end": [66, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Ioc", "code": "@[simp]\ntheorem preimage_const_add_Ioc : (fun x => a + x) \u207b\u00b9' Ioc b c = Ioc (b - a) (c - a)", "start": [69, 1], "end": [71, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_Ioo", "code": "@[simp]\ntheorem preimage_const_add_Ioo : (fun x => a + x) \u207b\u00b9' Ioo b c = Ioo (b - a) (c - a)", "start": [74, 1], "end": [76, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Ici", "code": "@[simp]\ntheorem preimage_add_const_Ici : (fun x => x + a) \u207b\u00b9' Ici b = Ici (b - a)", "start": [84, 1], "end": [86, 39], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Ioi", "code": "@[simp]\ntheorem preimage_add_const_Ioi : (fun x => x + a) \u207b\u00b9' Ioi b = Ioi (b - a)", "start": [89, 1], "end": [91, 39], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Iic", "code": "@[simp]\ntheorem preimage_add_const_Iic : (fun x => x + a) \u207b\u00b9' Iic b = Iic (b - a)", "start": [94, 1], "end": [96, 39], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Iio", "code": "@[simp]\ntheorem preimage_add_const_Iio : (fun x => x + a) \u207b\u00b9' Iio b = Iio (b - a)", "start": [99, 1], "end": [101, 39], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Icc", "code": "@[simp]\ntheorem preimage_add_const_Icc : (fun x => x + a) \u207b\u00b9' Icc b c = Icc (b - a) (c - a)", "start": [104, 1], "end": [106, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Ico", "code": "@[simp]\ntheorem preimage_add_const_Ico : (fun x => x + a) \u207b\u00b9' Ico b c = Ico (b - a) (c - a)", "start": [109, 1], "end": [111, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Ioc", "code": "@[simp]\ntheorem preimage_add_const_Ioc : (fun x => x + a) \u207b\u00b9' Ioc b c = Ioc (b - a) (c - a)", "start": [114, 1], "end": [116, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_Ioo", "code": "@[simp]\ntheorem preimage_add_const_Ioo : (fun x => x + a) \u207b\u00b9' Ioo b c = Ioo (b - a) (c - a)", "start": [119, 1], "end": [121, 25], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Ici", "code": "@[simp]\ntheorem preimage_neg_Ici : -Ici a = Iic (-a)", "start": [129, 1], "end": [131, 23], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Iic", "code": "@[simp]\ntheorem preimage_neg_Iic : -Iic a = Ici (-a)", "start": [134, 1], "end": [136, 23], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Ioi", "code": "@[simp]\ntheorem preimage_neg_Ioi : -Ioi a = Iio (-a)", "start": [139, 1], "end": [141, 23], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Iio", "code": "@[simp]\ntheorem preimage_neg_Iio : -Iio a = Ioi (-a)", "start": [144, 1], "end": [146, 23], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Icc", "code": "@[simp]\ntheorem preimage_neg_Icc : -Icc a b = Icc (-b) (-a)", "start": [149, 1], "end": [150, 93], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Ico", "code": "@[simp]\ntheorem preimage_neg_Ico : -Ico a b = Ioc (-b) (-a)", "start": [153, 1], "end": [155, 54], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Ioc", "code": "@[simp]\ntheorem preimage_neg_Ioc : -Ioc a b = Ico (-b) (-a)", "start": [158, 1], "end": [160, 54], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_Ioo", "code": "@[simp]\ntheorem preimage_neg_Ioo : -Ioo a b = Ioo (-b) (-a)", "start": [163, 1], "end": [164, 93], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Ici", "code": "@[simp]\ntheorem preimage_sub_const_Ici : (fun x => x - a) \u207b\u00b9' Ici b = Ici (b + a)", "start": [172, 1], "end": [174, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Ioi", "code": "@[simp]\ntheorem preimage_sub_const_Ioi : (fun x => x - a) \u207b\u00b9' Ioi b = Ioi (b + a)", "start": [177, 1], "end": [179, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Iic", "code": "@[simp]\ntheorem preimage_sub_const_Iic : (fun x => x - a) \u207b\u00b9' Iic b = Iic (b + a)", "start": [182, 1], "end": [184, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Iio", "code": "@[simp]\ntheorem preimage_sub_const_Iio : (fun x => x - a) \u207b\u00b9' Iio b = Iio (b + a)", "start": [187, 1], "end": [189, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Icc", "code": "@[simp]\ntheorem preimage_sub_const_Icc : (fun x => x - a) \u207b\u00b9' Icc b c = Icc (b + a) (c + a)", "start": [192, 1], "end": [194, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Ico", "code": "@[simp]\ntheorem preimage_sub_const_Ico : (fun x => x - a) \u207b\u00b9' Ico b c = Ico (b + a) (c + a)", "start": [197, 1], "end": [199, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Ioc", "code": "@[simp]\ntheorem preimage_sub_const_Ioc : (fun x => x - a) \u207b\u00b9' Ioc b c = Ioc (b + a) (c + a)", "start": [202, 1], "end": [204, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_Ioo", "code": "@[simp]\ntheorem preimage_sub_const_Ioo : (fun x => x - a) \u207b\u00b9' Ioo b c = Ioo (b + a) (c + a)", "start": [207, 1], "end": [209, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Ici", "code": "@[simp]\ntheorem preimage_const_sub_Ici : (fun x => a - x) \u207b\u00b9' Ici b = Iic (a - b)", "start": [217, 1], "end": [219, 28], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Iic", "code": "@[simp]\ntheorem preimage_const_sub_Iic : (fun x => a - x) \u207b\u00b9' Iic b = Ici (a - b)", "start": [222, 1], "end": [224, 28], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Ioi", "code": "@[simp]\ntheorem preimage_const_sub_Ioi : (fun x => a - x) \u207b\u00b9' Ioi b = Iio (a - b)", "start": [227, 1], "end": [229, 28], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Iio", "code": "@[simp]\ntheorem preimage_const_sub_Iio : (fun x => a - x) \u207b\u00b9' Iio b = Ioi (a - b)", "start": [232, 1], "end": [234, 28], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Icc", "code": "@[simp]\ntheorem preimage_const_sub_Icc : (fun x => a - x) \u207b\u00b9' Icc b c = Icc (a - c) (a - b)", "start": [237, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Ico", "code": "@[simp]\ntheorem preimage_const_sub_Ico : (fun x => a - x) \u207b\u00b9' Ico b c = Ioc (a - c) (a - b)", "start": [242, 1], "end": [244, 54], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Ioc", "code": "@[simp]\ntheorem preimage_const_sub_Ioc : (fun x => a - x) \u207b\u00b9' Ioc b c = Ico (a - c) (a - b)", "start": [247, 1], "end": [249, 54], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_Ioo", "code": "@[simp]\ntheorem preimage_const_sub_Ioo : (fun x => a - x) \u207b\u00b9' Ioo b c = Ioo (a - c) (a - b)", "start": [252, 1], "end": [254, 37], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Iic", "code": "theorem image_const_add_Iic : (fun x => a + x) '' Iic b = Iic (a + b)", "start": [263, 1], "end": [263, 92], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_Iio", "code": "theorem image_const_add_Iio : (fun x => a + x) '' Iio b = Iio (a + b)", "start": [267, 1], "end": [267, 92], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Iic", "code": "theorem image_add_const_Iic : (fun x => x + a) '' Iic b = Iic (b + a)", "start": [276, 1], "end": [276, 81], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_Iio", "code": "theorem image_add_const_Iio : (fun x => x + a) '' Iio b = Iio (b + a)", "start": [280, 1], "end": [280, 81], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Ici", "code": "theorem image_neg_Ici : Neg.neg '' Ici a = Iic (-a)", "start": [288, 1], "end": [288, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Iic", "code": "theorem image_neg_Iic : Neg.neg '' Iic a = Ici (-a)", "start": [291, 1], "end": [291, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Ioi", "code": "theorem image_neg_Ioi : Neg.neg '' Ioi a = Iio (-a)", "start": [294, 1], "end": [294, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Iio", "code": "theorem image_neg_Iio : Neg.neg '' Iio a = Ioi (-a)", "start": [297, 1], "end": [297, 63], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Icc", "code": "theorem image_neg_Icc : Neg.neg '' Icc a b = Icc (-b) (-a)", "start": [300, 1], "end": [300, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Ico", "code": "theorem image_neg_Ico : Neg.neg '' Ico a b = Ioc (-b) (-a)", "start": [303, 1], "end": [303, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Ioc", "code": "theorem image_neg_Ioc : Neg.neg '' Ioc a b = Ico (-b) (-a)", "start": [306, 1], "end": [306, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_Ioo", "code": "theorem image_neg_Ioo : Neg.neg '' Ioo a b = Ioo (-b) (-a)", "start": [309, 1], "end": [309, 70], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Ici", "code": "@[simp]\ntheorem image_const_sub_Ici : (fun x => a - x) '' Ici b = Iic (a - b)", "start": [317, 1], "end": [320, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Iic", "code": "@[simp]\ntheorem image_const_sub_Iic : (fun x => a - x) '' Iic b = Ici (a - b)", "start": [323, 1], "end": [326, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Ioi", "code": "@[simp]\ntheorem image_const_sub_Ioi : (fun x => a - x) '' Ioi b = Iio (a - b)", "start": [329, 1], "end": [332, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Iio", "code": "@[simp]\ntheorem image_const_sub_Iio : (fun x => a - x) '' Iio b = Ioi (a - b)", "start": [335, 1], "end": [338, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Icc", "code": "@[simp]\ntheorem image_const_sub_Icc : (fun x => a - x) '' Icc b c = Icc (a - c) (a - b)", "start": [341, 1], "end": [344, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Ico", "code": "@[simp]\ntheorem image_const_sub_Ico : (fun x => a - x) '' Ico b c = Ioc (a - c) (a - b)", "start": [347, 1], "end": [350, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Ioc", "code": "@[simp]\ntheorem image_const_sub_Ioc : (fun x => a - x) '' Ioc b c = Ico (a - c) (a - b)", "start": [353, 1], "end": [356, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_Ioo", "code": "@[simp]\ntheorem image_const_sub_Ioo : (fun x => a - x) '' Ioo b c = Ioo (a - c) (a - b)", "start": [359, 1], "end": [362, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Ici", "code": "@[simp]\ntheorem image_sub_const_Ici : (fun x => x - a) '' Ici b = Ici (b - a)", "start": [370, 1], "end": [371, 98], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Iic", "code": "@[simp]\ntheorem image_sub_const_Iic : (fun x => x - a) '' Iic b = Iic (b - a)", "start": [374, 1], "end": [375, 98], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Ioi", "code": "@[simp]\ntheorem image_sub_const_Ioi : (fun x => x - a) '' Ioi b = Ioi (b - a)", "start": [378, 1], "end": [379, 98], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Iio", "code": "@[simp]\ntheorem image_sub_const_Iio : (fun x => x - a) '' Iio b = Iio (b - a)", "start": [382, 1], "end": [383, 98], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Icc", "code": "@[simp]\ntheorem image_sub_const_Icc : (fun x => x - a) '' Icc b c = Icc (b - a) (c - a)", "start": [386, 1], "end": [388, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Ico", "code": "@[simp]\ntheorem image_sub_const_Ico : (fun x => x - a) '' Ico b c = Ico (b - a) (c - a)", "start": [391, 1], "end": [393, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Ioc", "code": "@[simp]\ntheorem image_sub_const_Ioc : (fun x => x - a) '' Ioc b c = Ioc (b - a) (c - a)", "start": [396, 1], "end": [398, 24], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_Ioo", "code": "@[simp]\ntheorem image_sub_const_Ioo : (fun x => x - a) '' Ioo b c = Ioo (b - a) (c - a)", "start": [401, 1], "end": [403, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Iic_add_bij", "code": "theorem Iic_add_bij : BijOn (\u00b7 + a) (Iic b) (Iic (b + a))", "start": [411, 1], "end": [412, 73], "kind": "commanddeclaration"}, {"full_name": "Set.Iio_add_bij", "code": "theorem Iio_add_bij : BijOn (\u00b7 + a) (Iio b) (Iio (b + a))", "start": [415, 1], "end": [416, 73], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_add_uIcc", "code": "@[simp]\ntheorem preimage_const_add_uIcc : (fun x => a + x) \u207b\u00b9' [[b, c]] = [[b - a, c - a]]", "start": [425, 1], "end": [427, 90], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_add_const_uIcc", "code": "@[simp]\ntheorem preimage_add_const_uIcc : (fun x => x + a) \u207b\u00b9' [[b, c]] = [[b - a, c - a]]", "start": [430, 1], "end": [432, 60], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_neg_uIcc", "code": "@[simp]\ntheorem preimage_neg_uIcc : @Neg.neg (Set \u03b1) Set.neg [[a, b]] = [[-a, -b]]", "start": [436, 1], "end": [438, 72], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_sub_const_uIcc", "code": "@[simp]\ntheorem preimage_sub_const_uIcc : (fun x => x - a) \u207b\u00b9' [[b, c]] = [[b + a, c + a]]", "start": [441, 1], "end": [443, 24], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_sub_uIcc", "code": "@[simp]\ntheorem preimage_const_sub_uIcc : (fun x => a - x) \u207b\u00b9' [[b, c]] = [[a - b, a - c]]", "start": [446, 1], "end": [449, 91], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_add_uIcc", "code": "theorem image_const_add_uIcc : (fun x => a + x) '' [[b, c]] = [[a + b, a + c]]", "start": [453, 1], "end": [453, 101], "kind": "commanddeclaration"}, {"full_name": "Set.image_add_const_uIcc", "code": "theorem image_add_const_uIcc : (fun x => x + a) '' [[b, c]] = [[b + a, c + a]]", "start": [457, 1], "end": [457, 90], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_sub_uIcc", "code": "@[simp]\ntheorem image_const_sub_uIcc : (fun x => a - x) '' [[b, c]] = [[a - b, a - c]]", "start": [460, 1], "end": [463, 40], "kind": "commanddeclaration"}, {"full_name": "Set.image_sub_const_uIcc", "code": "@[simp]\ntheorem image_sub_const_uIcc : (fun x => x - a) '' [[b, c]] = [[b - a, c - a]]", "start": [466, 1], "end": [468, 34], "kind": "commanddeclaration"}, {"full_name": "Set.image_neg_uIcc", "code": "theorem image_neg_uIcc : Neg.neg '' [[a, b]] = [[-a, -b]]", "start": [471, 1], "end": [471, 69], "kind": "commanddeclaration"}, {"full_name": "Set.abs_sub_le_of_uIcc_subset_uIcc", "code": "theorem abs_sub_le_of_uIcc_subset_uIcc (h : [[c, d]] \u2286 [[a, b]]) : |d - c| \u2264 |b - a|", "start": [476, 1], "end": [481, 27], "kind": "commanddeclaration"}, {"full_name": "Set.abs_sub_left_of_mem_uIcc", "code": "theorem abs_sub_left_of_mem_uIcc (h : c \u2208 [[a, b]]) : |c - a| \u2264 |b - a|", "start": [484, 1], "end": [487, 60], "kind": "commanddeclaration"}, {"full_name": "Set.abs_sub_right_of_mem_uIcc", "code": "theorem abs_sub_right_of_mem_uIcc (h : c \u2208 [[a, b]]) : |b - c| \u2264 |b - a|", "start": [490, 1], "end": [493, 61], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Iio", "code": "@[simp]\ntheorem preimage_mul_const_Iio (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Iio a = Iio (a / c)", "start": [507, 1], "end": [510, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioi", "code": "@[simp]\ntheorem preimage_mul_const_Ioi (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ioi a = Ioi (a / c)", "start": [513, 1], "end": [516, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Iic", "code": "@[simp]\ntheorem preimage_mul_const_Iic (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Iic a = Iic (a / c)", "start": [519, 1], "end": [522, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ici", "code": "@[simp]\ntheorem preimage_mul_const_Ici (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ici a = Ici (a / c)", "start": [525, 1], "end": [528, 36], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioo", "code": "@[simp]\ntheorem preimage_mul_const_Ioo (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ioo a b = Ioo (a / c) (b / c)", "start": [531, 1], "end": [533, 87], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioc", "code": "@[simp]\ntheorem preimage_mul_const_Ioc (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ioc a b = Ioc (a / c) (b / c)", "start": [536, 1], "end": [538, 87], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ico", "code": "@[simp]\ntheorem preimage_mul_const_Ico (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Ico a b = Ico (a / c) (b / c)", "start": [541, 1], "end": [543, 87], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Icc", "code": "@[simp]\ntheorem preimage_mul_const_Icc (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) \u207b\u00b9' Icc a b = Icc (a / c) (b / c)", "start": [546, 1], "end": [548, 87], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Iio_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Iio_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Iio a = Ioi (a / c)", "start": [551, 1], "end": [554, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioi_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Ioi_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ioi a = Iio (a / c)", "start": [557, 1], "end": [560, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Iic_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Iic_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Iic a = Ici (a / c)", "start": [563, 1], "end": [566, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ici_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Ici_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ici a = Iic (a / c)", "start": [569, 1], "end": [572, 43], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioo_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Ioo_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ioo a b = Ioo (b / c) (a / c)", "start": [575, 1], "end": [577, 99], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ioc_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Ioc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ioc a b = Ico (b / c) (a / c)", "start": [580, 1], "end": [583, 57], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Ico_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Ico_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Ico a b = Ioc (b / c) (a / c)", "start": [586, 1], "end": [589, 57], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_Icc_of_neg", "code": "@[simp]\ntheorem preimage_mul_const_Icc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (fun x => x * c) \u207b\u00b9' Icc a b = Icc (b / c) (a / c)", "start": [592, 1], "end": [594, 99], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Iio", "code": "@[simp]\ntheorem preimage_const_mul_Iio (a : \u03b1) {c : \u03b1} (h : 0 < c) : (\u00b7 * \u00b7) c \u207b\u00b9' Iio a = Iio (a / c)", "start": [597, 1], "end": [599, 37], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioi", "code": "@[simp]\ntheorem preimage_const_mul_Ioi (a : \u03b1) {c : \u03b1} (h : 0 < c) : (\u00b7 * \u00b7) c \u207b\u00b9' Ioi a = Ioi (a / c)", "start": [602, 1], "end": [604, 37], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Iic", "code": "@[simp]\ntheorem preimage_const_mul_Iic (a : \u03b1) {c : \u03b1} (h : 0 < c) : (\u00b7 * \u00b7) c \u207b\u00b9' Iic a = Iic (a / c)", "start": [607, 1], "end": [609, 37], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ici", "code": "@[simp]\ntheorem preimage_const_mul_Ici (a : \u03b1) {c : \u03b1} (h : 0 < c) : (\u00b7 * \u00b7) c \u207b\u00b9' Ici a = Ici (a / c)", "start": [612, 1], "end": [614, 37], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioo", "code": "@[simp]\ntheorem preimage_const_mul_Ioo (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ioo a b = Ioo (a / c) (b / c)", "start": [617, 1], "end": [619, 80], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioc", "code": "@[simp]\ntheorem preimage_const_mul_Ioc (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ioc a b = Ioc (a / c) (b / c)", "start": [622, 1], "end": [624, 80], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ico", "code": "@[simp]\ntheorem preimage_const_mul_Ico (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ico a b = Ico (a / c) (b / c)", "start": [627, 1], "end": [629, 80], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Icc", "code": "@[simp]\ntheorem preimage_const_mul_Icc (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Icc a b = Icc (a / c) (b / c)", "start": [632, 1], "end": [634, 80], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Iio_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Iio_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Iio a = Ioi (a / c)", "start": [637, 1], "end": [640, 64], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioi_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Ioi_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ioi a = Iio (a / c)", "start": [643, 1], "end": [646, 64], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Iic_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Iic_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Iic a = Ici (a / c)", "start": [649, 1], "end": [652, 64], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ici_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Ici_of_neg (a : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ici a = Iic (a / c)", "start": [655, 1], "end": [658, 64], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioo_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Ioo_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ioo a b = Ioo (b / c) (a / c)", "start": [661, 1], "end": [664, 66], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ioc_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Ioc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ioc a b = Ico (b / c) (a / c)", "start": [667, 1], "end": [670, 66], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Ico_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Ico_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Ico a b = Ioc (b / c) (a / c)", "start": [673, 1], "end": [676, 66], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_Icc_of_neg", "code": "@[simp]\ntheorem preimage_const_mul_Icc_of_neg (a b : \u03b1) {c : \u03b1} (h : c < 0) :\n    (\u00b7 * \u00b7) c \u207b\u00b9' Icc a b = Icc (b / c) (a / c)", "start": [679, 1], "end": [682, 66], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_mul_const_uIcc", "code": "@[simp]\ntheorem preimage_mul_const_uIcc (ha : a \u2260 0) (b c : \u03b1) :\n    (fun x => x * a) \u207b\u00b9' [[b, c]] = [[b / a, c / a]]", "start": [685, 1], "end": [691, 95], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_const_mul_uIcc", "code": "@[simp]\ntheorem preimage_const_mul_uIcc (ha : a \u2260 0) (b c : \u03b1) :\n    (fun x => a * x) \u207b\u00b9' [[b, c]] = [[b / a, c / a]]", "start": [694, 1], "end": [697, 53], "kind": "commanddeclaration"}, {"full_name": "Set.preimage_div_const_uIcc", "code": "@[simp]\ntheorem preimage_div_const_uIcc (ha : a \u2260 0) (b c : \u03b1) :\n    (fun x => x / a) \u207b\u00b9' [[b, c]] = [[b * a, c * a]]", "start": [700, 1], "end": [703, 80], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_const_uIcc", "code": "@[simp]\ntheorem image_mul_const_uIcc (a b c : \u03b1) : (fun x => x * a) '' [[b, c]] = [[b * a, c * a]]", "start": [706, 1], "end": [713, 59], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_mul_uIcc", "code": "@[simp]\ntheorem image_const_mul_uIcc (a b c : \u03b1) : (fun x => a * x) '' [[b, c]] = [[a * b, a * c]]", "start": [716, 1], "end": [718, 57], "kind": "commanddeclaration"}, {"full_name": "Set.image_div_const_uIcc", "code": "@[simp]\ntheorem image_div_const_uIcc (a b c : \u03b1) : (fun x => x / a) '' [[b, c]] = [[b / a, c / a]]", "start": [721, 1], "end": [723, 51], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_right_Icc'", "code": "theorem image_mul_right_Icc' (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) '' Icc a b = Icc (a * c) (b * c)", "start": [726, 1], "end": [728, 87], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_right_Icc", "code": "theorem image_mul_right_Icc {a b c : \u03b1} (hab : a \u2264 b) (hc : 0 \u2264 c) :\n    (fun x => x * c) '' Icc a b = Icc (a * c) (b * c)", "start": [731, 1], "end": [736, 41], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_left_Icc'", "code": "theorem image_mul_left_Icc' {a : \u03b1} (h : 0 < a) (b c : \u03b1) :\n    (\u00b7 * \u00b7) a '' Icc b c = Icc (a * b) (a * c)", "start": [739, 1], "end": [741, 74], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_left_Icc", "code": "theorem image_mul_left_Icc {a b c : \u03b1} (ha : 0 \u2264 a) (hbc : b \u2264 c) :\n    (\u00b7 * \u00b7) a '' Icc b c = Icc (a * b) (a * c)", "start": [744, 1], "end": [746, 74], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_right_Ioo", "code": "theorem image_mul_right_Ioo (a b : \u03b1) {c : \u03b1} (h : 0 < c) :\n    (fun x => x * c) '' Ioo a b = Ioo (a * c) (b * c)", "start": [749, 1], "end": [751, 87], "kind": "commanddeclaration"}, {"full_name": "Set.image_mul_left_Ioo", "code": "theorem image_mul_left_Ioo {a : \u03b1} (h : 0 < a) (b c : \u03b1) :\n    (\u00b7 * \u00b7) a '' Ioo b c = Ioo (a * b) (a * c)", "start": [754, 1], "end": [756, 73], "kind": "commanddeclaration"}, {"full_name": "Set.inv_Ioo_0_left", "code": "theorem inv_Ioo_0_left {a : \u03b1} (ha : 0 < a) : (Ioo 0 a)\u207b\u00b9 = Ioi a\u207b\u00b9", "start": [759, 1], "end": [765, 79], "kind": "commanddeclaration"}, {"full_name": "Set.inv_Ioi", "code": "theorem inv_Ioi {a : \u03b1} (ha : 0 < a) : (Ioi a)\u207b\u00b9 = Ioo 0 a\u207b\u00b9", "start": [768, 1], "end": [769, 65], "kind": "commanddeclaration"}, {"full_name": "Set.image_const_mul_Ioi_zero", "code": "theorem image_const_mul_Ioi_zero {k : Type*} [LinearOrderedField k] {x : k} (hx : 0 < x) :\n    (fun y => x * y) '' Ioi (0 : k) = Ioi 0", "start": [772, 1], "end": [775, 14], "kind": "commanddeclaration"}, {"full_name": "Set.image_affine_Icc'", "code": "@[simp]\ntheorem image_affine_Icc' {a : \u03b1} (h : 0 < a) (b c d : \u03b1) :\n    (fun x => a * x + b) '' Icc c d = Icc (a * c + b) (a * d + b)", "start": [783, 1], "end": [788, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/Pi.lean", "imports": ["Mathlib/Data/Pi/Algebra.lean", "Mathlib/Data/Set/Lattice.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/UnorderedInterval.lean", "Mathlib/Data/Set/Intervals/Basic.lean"], "premises": [{"full_name": "Set.pi_univ_Ici", "code": "@[simp]\ntheorem pi_univ_Ici : (pi univ fun i \u21a6 Ici (x i)) = Ici x", "start": [32, 1], "end": [34, 34], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Iic", "code": "@[simp]\ntheorem pi_univ_Iic : (pi univ fun i \u21a6 Iic (x i)) = Iic x", "start": [37, 1], "end": [39, 34], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Icc", "code": "@[simp]\ntheorem pi_univ_Icc : (pi univ fun i \u21a6 Icc (x i) (y i)) = Icc x y", "start": [42, 1], "end": [44, 46], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_mem_Icc", "code": "theorem piecewise_mem_Icc {s : Set \u03b9} [\u2200 j, Decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, \u03b1 i}\n    (h\u2081 : \u2200 i \u2208 s, f\u2081 i \u2208 Icc (g\u2081 i) (g\u2082 i)) (h\u2082 : \u2200 (i) (_ : i \u2209 s), f\u2082 i \u2208 Icc (g\u2081 i) (g\u2082 i)) :\n    s.piecewise f\u2081 f\u2082 \u2208 Icc g\u2081 g\u2082", "start": [47, 1], "end": [51, 66], "kind": "commanddeclaration"}, {"full_name": "Set.piecewise_mem_Icc'", "code": "theorem piecewise_mem_Icc' {s : Set \u03b9} [\u2200 j, Decidable (j \u2208 s)] {f\u2081 f\u2082 g\u2081 g\u2082 : \u2200 i, \u03b1 i}\n    (h\u2081 : f\u2081 \u2208 Icc g\u2081 g\u2082) (h\u2082 : f\u2082 \u2208 Icc g\u2081 g\u2082) : s.piecewise f\u2081 f\u2082 \u2208 Icc g\u2081 g\u2082", "start": [54, 1], "end": [56, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioi_subset", "code": "theorem pi_univ_Ioi_subset : (pi univ fun i \u21a6 Ioi (x i)) \u2286 Ioi x", "start": [63, 1], "end": [65, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Iio_subset", "code": "theorem pi_univ_Iio_subset : (pi univ fun i \u21a6 Iio (x i)) \u2286 Iio x", "start": [68, 1], "end": [69, 48], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioo_subset", "code": "theorem pi_univ_Ioo_subset : (pi univ fun i \u21a6 Ioo (x i) (y i)) \u2286 Ioo x y", "start": [72, 1], "end": [73, 97], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioc_subset", "code": "theorem pi_univ_Ioc_subset : (pi univ fun i \u21a6 Ioc (x i) (y i)) \u2286 Ioc x y", "start": [76, 1], "end": [77, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ico_subset", "code": "theorem pi_univ_Ico_subset : (pi univ fun i \u21a6 Ico (x i) (y i)) \u2286 Ico x y", "start": [80, 1], "end": [81, 76], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioc_update_left", "code": "theorem pi_univ_Ioc_update_left {x y : \u2200 i, \u03b1 i} {i\u2080 : \u03b9} {m : \u03b1 i\u2080} (hm : x i\u2080 \u2264 m) :\n    (pi univ fun i \u21a6 Ioc (update x i\u2080 m i) (y i)) =\n      { z | m < z i\u2080 } \u2229 pi univ fun i \u21a6 Ioc (x i) (y i)", "start": [90, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioc_update_right", "code": "theorem pi_univ_Ioc_update_right {x y : \u2200 i, \u03b1 i} {i\u2080 : \u03b9} {m : \u03b1 i\u2080} (hm : m \u2264 y i\u2080) :\n    (pi univ fun i \u21a6 Ioc (x i) (update y i\u2080 m i)) =\n      { z | z i\u2080 \u2264 m } \u2229 pi univ fun i \u21a6 Ioc (x i) (y i)", "start": [101, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "Set.disjoint_pi_univ_Ioc_update_left_right", "code": "theorem disjoint_pi_univ_Ioc_update_left_right {x y : \u2200 i, \u03b1 i} {i\u2080 : \u03b9} {m : \u03b1 i\u2080} :\n    Disjoint (pi univ fun i \u21a6 Ioc (x i) (update y i\u2080 m i))\n    (pi univ fun i \u21a6 Ioc (update x i\u2080 m i) (y i))", "start": [112, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Icc", "code": "theorem image_update_Icc (f : \u2200 i, \u03b1 i) (i : \u03b9) (a b : \u03b1 i) :\n    update f i '' Icc a b = Icc (update f i a) (update f i b)", "start": [128, 1], "end": [139, 90], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ico", "code": "theorem image_update_Ico (f : \u2200 i, \u03b1 i) (i : \u03b9) (a b : \u03b1 i) :\n    update f i '' Ico a b = Ico (update f i a) (update f i b)", "start": [142, 1], "end": [145, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioc", "code": "theorem image_update_Ioc (f : \u2200 i, \u03b1 i) (i : \u03b9) (a b : \u03b1 i) :\n    update f i '' Ioc a b = Ioc (update f i a) (update f i b)", "start": [148, 1], "end": [151, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioo", "code": "theorem image_update_Ioo (f : \u2200 i, \u03b1 i) (i : \u03b9) (a b : \u03b1 i) :\n    update f i '' Ioo a b = Ioo (update f i a) (update f i b)", "start": [154, 1], "end": [157, 22], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Icc_left", "code": "theorem image_update_Icc_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Icc a (f i) = Icc (update f i a) f", "start": [160, 1], "end": [161, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ico_left", "code": "theorem image_update_Ico_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ico a (f i) = Ico (update f i a) f", "start": [164, 1], "end": [165, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioc_left", "code": "theorem image_update_Ioc_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ioc a (f i) = Ioc (update f i a) f", "start": [168, 1], "end": [169, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioo_left", "code": "theorem image_update_Ioo_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' Ioo a (f i) = Ioo (update f i a) f", "start": [172, 1], "end": [173, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Icc_right", "code": "theorem image_update_Icc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Icc (f i) b = Icc f (update f i b)", "start": [176, 1], "end": [177, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ico_right", "code": "theorem image_update_Ico_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ico (f i) b = Ico f (update f i b)", "start": [180, 1], "end": [181, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioc_right", "code": "theorem image_update_Ioc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ioc (f i) b = Ioc f (update f i b)", "start": [184, 1], "end": [185, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_Ioo_right", "code": "theorem image_update_Ioo_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' Ioo (f i) b = Ioo f (update f i b)", "start": [188, 1], "end": [189, 100], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Icc", "code": "@[to_additive]\ntheorem image_mulSingle_Icc (i : \u03b9) (a b : \u03b1 i) :\n    Pi.mulSingle i '' Icc a b = Icc (Pi.mulSingle i a) (Pi.mulSingle i b)", "start": [194, 1], "end": [197, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ico", "code": "@[to_additive]\ntheorem image_mulSingle_Ico (i : \u03b9) (a b : \u03b1 i) :\n    Pi.mulSingle i '' Ico a b = Ico (Pi.mulSingle i a) (Pi.mulSingle i b)", "start": [201, 1], "end": [204, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioc", "code": "@[to_additive]\ntheorem image_mulSingle_Ioc (i : \u03b9) (a b : \u03b1 i) :\n    Pi.mulSingle i '' Ioc a b = Ioc (Pi.mulSingle i a) (Pi.mulSingle i b)", "start": [208, 1], "end": [211, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioo", "code": "@[to_additive]\ntheorem image_mulSingle_Ioo (i : \u03b9) (a b : \u03b1 i) :\n    Pi.mulSingle i '' Ioo a b = Ioo (Pi.mulSingle i a) (Pi.mulSingle i b)", "start": [215, 1], "end": [218, 27], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Icc_left", "code": "@[to_additive]\ntheorem image_mulSingle_Icc_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' Icc a 1 = Icc (Pi.mulSingle i a) 1", "start": [222, 1], "end": [225, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ico_left", "code": "@[to_additive]\ntheorem image_mulSingle_Ico_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' Ico a 1 = Ico (Pi.mulSingle i a) 1", "start": [229, 1], "end": [232, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioc_left", "code": "@[to_additive]\ntheorem image_mulSingle_Ioc_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' Ioc a 1 = Ioc (Pi.mulSingle i a) 1", "start": [236, 1], "end": [239, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioo_left", "code": "@[to_additive]\ntheorem image_mulSingle_Ioo_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' Ioo a 1 = Ioo (Pi.mulSingle i a) 1", "start": [243, 1], "end": [246, 30], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Icc_right", "code": "@[to_additive]\ntheorem image_mulSingle_Icc_right (i : \u03b9) (b : \u03b1 i) :\n    Pi.mulSingle i '' Icc 1 b = Icc 1 (Pi.mulSingle i b)", "start": [250, 1], "end": [253, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ico_right", "code": "@[to_additive]\ntheorem image_mulSingle_Ico_right (i : \u03b9) (b : \u03b1 i) :\n    Pi.mulSingle i '' Ico 1 b = Ico 1 (Pi.mulSingle i b)", "start": [257, 1], "end": [260, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioc_right", "code": "@[to_additive]\ntheorem image_mulSingle_Ioc_right (i : \u03b9) (b : \u03b1 i) :\n    Pi.mulSingle i '' Ioc 1 b = Ioc 1 (Pi.mulSingle i b)", "start": [264, 1], "end": [267, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_Ioo_right", "code": "@[to_additive]\ntheorem image_mulSingle_Ioo_right (i : \u03b9) (b : \u03b1 i) :\n    Pi.mulSingle i '' Ioo 1 b = Ioo 1 (Pi.mulSingle i b)", "start": [271, 1], "end": [274, 31], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_uIcc", "code": "@[simp]\ntheorem pi_univ_uIcc (a b : \u2200 i, \u03b1 i) : (pi univ fun i => uIcc (a i) (b i)) = uIcc a b", "start": [284, 1], "end": [286, 18], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_uIcc", "code": "theorem image_update_uIcc (f : \u2200 i, \u03b1 i) (i : \u03b9) (a b : \u03b1 i) :\n    update f i '' uIcc a b = uIcc (update f i a) (update f i b)", "start": [291, 1], "end": [293, 80], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_uIcc_left", "code": "theorem image_update_uIcc_left (f : \u2200 i, \u03b1 i) (i : \u03b9) (a : \u03b1 i) :\n    update f i '' uIcc a (f i) = uIcc (update f i a) f", "start": [296, 1], "end": [298, 44], "kind": "commanddeclaration"}, {"full_name": "Set.image_update_uIcc_right", "code": "theorem image_update_uIcc_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\n    update f i '' uIcc (f i) b = uIcc f (update f i b)", "start": [301, 1], "end": [303, 44], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_uIcc", "code": "@[to_additive]\ntheorem image_mulSingle_uIcc (i : \u03b9) (a b : \u03b1 i) :\n    Pi.mulSingle i '' uIcc a b = uIcc (Pi.mulSingle i a) (Pi.mulSingle i b)", "start": [308, 1], "end": [311, 28], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_uIcc_left", "code": "@[to_additive]\ntheorem image_mulSingle_uIcc_left (i : \u03b9) (a : \u03b1 i) :\n    Pi.mulSingle i '' uIcc a 1 = uIcc (Pi.mulSingle i a) 1", "start": [315, 1], "end": [318, 31], "kind": "commanddeclaration"}, {"full_name": "Set.image_mulSingle_uIcc_right", "code": "@[to_additive]\ntheorem image_mulSingle_uIcc_right (i : \u03b9) (b : \u03b1 i) :\n    Pi.mulSingle i '' uIcc 1 b = uIcc 1 (Pi.mulSingle i b)", "start": [322, 1], "end": [325, 32], "kind": "commanddeclaration"}, {"full_name": "Set.pi_univ_Ioc_update_union", "code": "theorem pi_univ_Ioc_update_union (x y : \u2200 i, \u03b1 i) (i\u2080 : \u03b9) (m : \u03b1 i\u2080) (hm : m \u2208 Icc (x i\u2080) (y i\u2080)) :\n    ((pi univ fun i \u21a6 Ioc (x i) (update y i\u2080 m i)) \u222a\n        pi univ fun i \u21a6 Ioc (update x i\u2080 m i) (y i)) =\n      pi univ fun i \u21a6 Ioc (x i) (y i)", "start": [335, 1], "end": [340, 50], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_pi_univ_Ioo_subset", "code": "theorem Icc_diff_pi_univ_Ioo_subset (x y x' y' : \u2200 i, \u03b1 i) :\n    (Icc x y \\ pi univ fun i \u21a6 Ioo (x' i) (y' i)) \u2286\n    (\u22c3 i : \u03b9, Icc x (update y i (x' i))) \u222a \u22c3 i : \u03b9, Icc (update x i (y' i)) y", "start": [343, 1], "end": [361, 43], "kind": "commanddeclaration"}, {"full_name": "Set.Icc_diff_pi_univ_Ioc_subset", "code": "theorem Icc_diff_pi_univ_Ioc_subset (x y z : \u2200 i, \u03b1 i) :\n    (Icc x z \\ pi univ fun i \u21a6 Ioc (y i) (z i)) \u2286 \u22c3 i : \u03b9, Icc x (update z i (y i))", "start": [364, 1], "end": [374, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Interval.lean", "imports": ["Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Order/Filter/SmallSets.lean", "Mathlib/Data/Set/Intervals/OrdConnected.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.TendstoIxxClass", "code": "class TendstoIxxClass (Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1) (l\u2081 : Filter \u03b1) (l\u2082 : outParam <| Filter \u03b1) : Prop where\n  \n  tendsto_Ixx : Tendsto (fun p : \u03b1 \u00d7 \u03b1 => Ixx p.1 p.2) (l\u2081 \u00d7\u02e2 l\u2081) l\u2082.smallSets", "start": [57, 1], "end": [72, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.Icc", "code": "protected theorem Tendsto.Icc {l\u2081 l\u2082 : Filter \u03b1} [TendstoIxxClass Icc l\u2081 l\u2082] {lb : Filter \u03b2}\n    {u\u2081 u\u2082 : \u03b2 \u2192 \u03b1} (h\u2081 : Tendsto u\u2081 lb l\u2081) (h\u2082 : Tendsto u\u2082 lb l\u2081) :\n    Tendsto (fun x => Icc (u\u2081 x) (u\u2082 x)) lb l\u2082.smallSets", "start": [75, 1], "end": [78, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.Ioc", "code": "protected theorem Tendsto.Ioc {l\u2081 l\u2082 : Filter \u03b1} [TendstoIxxClass Ioc l\u2081 l\u2082] {lb : Filter \u03b2}\n    {u\u2081 u\u2082 : \u03b2 \u2192 \u03b1} (h\u2081 : Tendsto u\u2081 lb l\u2081) (h\u2082 : Tendsto u\u2082 lb l\u2081) :\n    Tendsto (fun x => Ioc (u\u2081 x) (u\u2082 x)) lb l\u2082.smallSets", "start": [81, 1], "end": [84, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.Ico", "code": "protected theorem Tendsto.Ico {l\u2081 l\u2082 : Filter \u03b1} [TendstoIxxClass Ico l\u2081 l\u2082] {lb : Filter \u03b2}\n    {u\u2081 u\u2082 : \u03b2 \u2192 \u03b1} (h\u2081 : Tendsto u\u2081 lb l\u2081) (h\u2082 : Tendsto u\u2082 lb l\u2081) :\n    Tendsto (fun x => Ico (u\u2081 x) (u\u2082 x)) lb l\u2082.smallSets", "start": [87, 1], "end": [90, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.Ioo", "code": "protected theorem Tendsto.Ioo {l\u2081 l\u2082 : Filter \u03b1} [TendstoIxxClass Ioo l\u2081 l\u2082] {lb : Filter \u03b2}\n    {u\u2081 u\u2082 : \u03b2 \u2192 \u03b1} (h\u2081 : Tendsto u\u2081 lb l\u2081) (h\u2082 : Tendsto u\u2082 lb l\u2081) :\n    Tendsto (fun x => Ioo (u\u2081 x) (u\u2082 x)) lb l\u2082.smallSets", "start": [93, 1], "end": [96, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.tendstoIxxClass_principal", "code": "theorem tendstoIxxClass_principal {s t : Set \u03b1} {Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1} :\n    TendstoIxxClass Ixx (\ud835\udcdf s) (\ud835\udcdf t) \u2194 \u2200 (x) (_ : x \u2208 s) (y) (_ : y \u2208 s), Ixx x y \u2286 t", "start": [99, 1], "end": [103, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendstoIxxClass_inf", "code": "theorem tendstoIxxClass_inf {l\u2081 l\u2081' l\u2082 l\u2082' : Filter \u03b1} {Ixx} [h : TendstoIxxClass Ixx l\u2081 l\u2082]\n    [h' : TendstoIxxClass Ixx l\u2081' l\u2082'] : TendstoIxxClass Ixx (l\u2081 \u2293 l\u2081') (l\u2082 \u2293 l\u2082')", "start": [106, 1], "end": [108, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.tendstoIxxClass_of_subset", "code": "theorem tendstoIxxClass_of_subset {l\u2081 l\u2082 : Filter \u03b1} {Ixx Ixx' : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1}\n    (h : \u2200 a b, Ixx a b \u2286 Ixx' a b) [h' : TendstoIxxClass Ixx' l\u2081 l\u2082] : TendstoIxxClass Ixx l\u2081 l\u2082", "start": [111, 1], "end": [113, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.tendstoIxxClass", "code": "theorem HasBasis.tendstoIxxClass {\u03b9 : Type*} {p : \u03b9 \u2192 Prop} {s} {l : Filter \u03b1}\n    (hl : l.HasBasis p s) {Ixx : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1}\n    (H : \u2200 i, p i \u2192 \u2200 x \u2208 s i, \u2200 y \u2208 s i, Ixx x y \u2286 s i) : TendstoIxxClass Ixx l l", "start": [116, 1], "end": [119, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Icc_atTop_atTop", "code": "instance tendsto_Icc_atTop_atTop : TendstoIxxClass Icc (atTop : Filter \u03b1) atTop :=\n  (hasBasis_iInf_principal_finite _).tendstoIxxClass fun _ _ =>\n    Set.OrdConnected.out <| ordConnected_biInter fun _ _ => ordConnected_Ici", "start": [122, 1], "end": [124, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_atTop_atTop", "code": "instance tendsto_Ico_atTop_atTop : TendstoIxxClass Ico (atTop : Filter \u03b1) atTop :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [127, 1], "end": [128, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_atTop_atTop", "code": "instance tendsto_Ioc_atTop_atTop : TendstoIxxClass Ioc (atTop : Filter \u03b1) atTop :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [131, 1], "end": [132, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_atTop_atTop", "code": "instance tendsto_Ioo_atTop_atTop : TendstoIxxClass Ioo (atTop : Filter \u03b1) atTop :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self", "start": [135, 1], "end": [136, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Icc_atBot_atBot", "code": "instance tendsto_Icc_atBot_atBot : TendstoIxxClass Icc (atBot : Filter \u03b1) atBot :=\n  (hasBasis_iInf_principal_finite _).tendstoIxxClass fun _ _ =>\n    Set.OrdConnected.out <| ordConnected_biInter fun _ _ => ordConnected_Iic", "start": [139, 1], "end": [141, 77], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_atBot_atBot", "code": "instance tendsto_Ico_atBot_atBot : TendstoIxxClass Ico (atBot : Filter \u03b1) atBot :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [144, 1], "end": [145, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_atBot_atBot", "code": "instance tendsto_Ioc_atBot_atBot : TendstoIxxClass Ioc (atBot : Filter \u03b1) atBot :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [148, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_atBot_atBot", "code": "instance tendsto_Ioo_atBot_atBot : TendstoIxxClass Ioo (atBot : Filter \u03b1) atBot :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self", "start": [152, 1], "end": [153, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.OrdConnected.tendsto_Icc", "code": "instance OrdConnected.tendsto_Icc {s : Set \u03b1} [hs : OrdConnected s] :\n    TendstoIxxClass Icc (\ud835\udcdf s) (\ud835\udcdf s) :=\n  tendstoIxxClass_principal.2 hs.out", "start": [156, 1], "end": [158, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_Ici_Ici", "code": "instance tendsto_Ico_Ici_Ici {a : \u03b1} : TendstoIxxClass Ico (\ud835\udcdf (Ici a)) (\ud835\udcdf (Ici a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [161, 1], "end": [162, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_Ioi_Ioi", "code": "instance tendsto_Ico_Ioi_Ioi {a : \u03b1} : TendstoIxxClass Ico (\ud835\udcdf (Ioi a)) (\ud835\udcdf (Ioi a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [165, 1], "end": [166, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_Iic_Iio", "code": "instance tendsto_Ico_Iic_Iio {a : \u03b1} : TendstoIxxClass Ico (\ud835\udcdf (Iic a)) (\ud835\udcdf (Iio a)) :=\n  tendstoIxxClass_principal.2 fun _ _ _ h\u2081 _ h\u2082 => lt_of_lt_of_le h\u2082.2 h\u2081", "start": [169, 1], "end": [170, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_Iio_Iio", "code": "instance tendsto_Ico_Iio_Iio {a : \u03b1} : TendstoIxxClass Ico (\ud835\udcdf (Iio a)) (\ud835\udcdf (Iio a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [173, 1], "end": [174, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_Ici_Ioi", "code": "instance tendsto_Ioc_Ici_Ioi {a : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf (Ici a)) (\ud835\udcdf (Ioi a)) :=\n  tendstoIxxClass_principal.2 fun _ h\u2081 _ _ _ h\u2082 => lt_of_le_of_lt h\u2081 h\u2082.1", "start": [177, 1], "end": [178, 74], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_Iic_Iic", "code": "instance tendsto_Ioc_Iic_Iic {a : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf (Iic a)) (\ud835\udcdf (Iic a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [181, 1], "end": [182, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_Iio_Iio", "code": "instance tendsto_Ioc_Iio_Iio {a : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf (Iio a)) (\ud835\udcdf (Iio a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [185, 1], "end": [186, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_Ioi_Ioi", "code": "instance tendsto_Ioc_Ioi_Ioi {a : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf (Ioi a)) (\ud835\udcdf (Ioi a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [189, 1], "end": [190, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_Ici_Ioi", "code": "instance tendsto_Ioo_Ici_Ioi {a : \u03b1} : TendstoIxxClass Ioo (\ud835\udcdf (Ici a)) (\ud835\udcdf (Ioi a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Ioc_self", "start": [193, 1], "end": [194, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_Iic_Iio", "code": "instance tendsto_Ioo_Iic_Iio {a : \u03b1} : TendstoIxxClass Ioo (\ud835\udcdf (Iic a)) (\ud835\udcdf (Iio a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Ico_self", "start": [197, 1], "end": [198, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_Ioi_Ioi", "code": "instance tendsto_Ioo_Ioi_Ioi {a : \u03b1} : TendstoIxxClass Ioo (\ud835\udcdf (Ioi a)) (\ud835\udcdf (Ioi a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Ioc_self", "start": [201, 1], "end": [202, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_Iio_Iio", "code": "instance tendsto_Ioo_Iio_Iio {a : \u03b1} : TendstoIxxClass Ioo (\ud835\udcdf (Iio a)) (\ud835\udcdf (Iio a)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Ioc_self", "start": [205, 1], "end": [206, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Icc_Icc_Icc", "code": "instance tendsto_Icc_Icc_Icc {a b : \u03b1} : TendstoIxxClass Icc (\ud835\udcdf (Icc a b)) (\ud835\udcdf (Icc a b)) :=\n  tendstoIxxClass_principal.mpr fun _x hx _y hy => Icc_subset_Icc hx.1 hy.2", "start": [209, 1], "end": [210, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_Icc_Icc", "code": "instance tendsto_Ioc_Icc_Icc {a b : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf (Icc a b)) (\ud835\udcdf (Icc a b)) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [213, 1], "end": [214, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Icc_pure_pure", "code": "instance tendsto_Icc_pure_pure {a : \u03b1} : TendstoIxxClass Icc (pure a) (pure a : Filter \u03b1) := by\n  rw [\u2190 principal_singleton]\n  exact tendstoIxxClass_principal.2 ordConnected_singleton.out", "start": [223, 1], "end": [225, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ico_pure_bot", "code": "instance tendsto_Ico_pure_bot {a : \u03b1} : TendstoIxxClass Ico (pure a) \u22a5 :=\n  \u27e8by simp\u27e9", "start": [228, 1], "end": [229, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_pure_bot", "code": "instance tendsto_Ioc_pure_bot {a : \u03b1} : TendstoIxxClass Ioc (pure a) \u22a5 :=\n  \u27e8by simp\u27e9", "start": [232, 1], "end": [233, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioo_pure_bot", "code": "instance tendsto_Ioo_pure_bot {a : \u03b1} : TendstoIxxClass Ioo (pure a) \u22a5 :=\n  \u27e8by simp\u27e9", "start": [236, 1], "end": [237, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Icc_uIcc_uIcc", "code": "instance tendsto_Icc_uIcc_uIcc {a b : \u03b1} : TendstoIxxClass Icc (\ud835\udcdf [[a, b]]) (\ud835\udcdf [[a, b]]) :=\n  Filter.tendsto_Icc_Icc_Icc", "start": [248, 1], "end": [249, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_Ioc_uIcc_uIcc", "code": "instance tendsto_Ioc_uIcc_uIcc {a b : \u03b1} : TendstoIxxClass Ioc (\ud835\udcdf [[a, b]]) (\ud835\udcdf [[a, b]]) :=\n  Filter.tendsto_Ioc_Icc_Icc", "start": [252, 1], "end": [253, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_uIcc_of_Icc", "code": "instance tendsto_uIcc_of_Icc {l : Filter \u03b1} [TendstoIxxClass Icc l l] :\n    TendstoIxxClass uIcc l l := by\n  refine' \u27e8fun s hs => mem_map.2 <| mem_prod_self_iff.2 _\u27e9\n  obtain \u27e8t, htl, hts\u27e9 : \u2203 t \u2208 l, \u2200 p \u2208 (t : Set \u03b1) \u00d7\u02e2 t, Icc (p : \u03b1 \u00d7 \u03b1).1 p.2 \u2208 s\n  exact mem_prod_self_iff.1 (mem_map.1 (tendsto_fst.Icc tendsto_snd hs))\n  refine' \u27e8t, htl, fun p hp => _\u27e9\n  cases' le_total p.1 p.2 with h h\n  \u00b7 rw [mem_preimage, uIcc_of_le h]\n    exact hts p hp\n  \u00b7 rw [mem_preimage, uIcc_of_ge h]\n    exact hts \u27e8p.2, p.1\u27e9 \u27e8hp.2, hp.1\u27e9", "start": [256, 1], "end": [266, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.uIcc", "code": "protected theorem Tendsto.uIcc {l : Filter \u03b1} [TendstoIxxClass Icc l l] {f g : \u03b2 \u2192 \u03b1}\n    {lb : Filter \u03b2} (hf : Tendsto f lb l) (hg : Tendsto g lb l) :\n    Tendsto (fun x => [[f x, g x]]) lb l.smallSets", "start": [269, 1], "end": [272, 72], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/Pointwise.lean", "imports": ["Mathlib/Algebra/Order/Module.lean", "Mathlib/Data/Real/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Real.sInf_smul_of_nonneg", "code": "theorem Real.sInf_smul_of_nonneg (ha : 0 \u2264 a) (s : Set \u211d) : sInf (a \u2022 s) = a \u2022 sInf s", "start": [36, 1], "end": [45, 48], "kind": "commanddeclaration"}, {"full_name": "Real.smul_iInf_of_nonneg", "code": "theorem Real.smul_iInf_of_nonneg (ha : 0 \u2264 a) (f : \u03b9 \u2192 \u211d) : (a \u2022 \u2a05 i, f i) = \u2a05 i, a \u2022 f i", "start": [48, 1], "end": [49, 88], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_smul_of_nonneg", "code": "theorem Real.sSup_smul_of_nonneg (ha : 0 \u2264 a) (s : Set \u211d) : sSup (a \u2022 s) = a \u2022 sSup s", "start": [52, 1], "end": [61, 48], "kind": "commanddeclaration"}, {"full_name": "Real.smul_iSup_of_nonneg", "code": "theorem Real.smul_iSup_of_nonneg (ha : 0 \u2264 a) (f : \u03b9 \u2192 \u211d) : (a \u2022 \u2a06 i, f i) = \u2a06 i, a \u2022 f i", "start": [64, 1], "end": [65, 88], "kind": "commanddeclaration"}, {"full_name": "Real.sInf_smul_of_nonpos", "code": "theorem Real.sInf_smul_of_nonpos (ha : a \u2264 0) (s : Set \u211d) : sInf (a \u2022 s) = a \u2022 sSup s", "start": [74, 1], "end": [83, 48], "kind": "commanddeclaration"}, {"full_name": "Real.smul_iSup_of_nonpos", "code": "theorem Real.smul_iSup_of_nonpos (ha : a \u2264 0) (f : \u03b9 \u2192 \u211d) : (a \u2022 \u2a06 i, f i) = \u2a05 i, a \u2022 f i", "start": [86, 1], "end": [87, 88], "kind": "commanddeclaration"}, {"full_name": "Real.sSup_smul_of_nonpos", "code": "theorem Real.sSup_smul_of_nonpos (ha : a \u2264 0) (s : Set \u211d) : sSup (a \u2022 s) = a \u2022 sInf s", "start": [90, 1], "end": [99, 48], "kind": "commanddeclaration"}, {"full_name": "Real.smul_iInf_of_nonpos", "code": "theorem Real.smul_iInf_of_nonpos (ha : a \u2264 0) (f : \u03b9 \u2192 \u211d) : (a \u2022 \u2a05 i, f i) = \u2a06 i, a \u2022 f i", "start": [102, 1], "end": [103, 88], "kind": "commanddeclaration"}, {"full_name": "Real.mul_iInf_of_nonneg", "code": "theorem Real.mul_iInf_of_nonneg (ha : 0 \u2264 r) (f : \u03b9 \u2192 \u211d) : (r * \u2a05 i, f i) = \u2a05 i, r * f i", "start": [115, 1], "end": [116, 32], "kind": "commanddeclaration"}, {"full_name": "Real.mul_iSup_of_nonneg", "code": "theorem Real.mul_iSup_of_nonneg (ha : 0 \u2264 r) (f : \u03b9 \u2192 \u211d) : (r * \u2a06 i, f i) = \u2a06 i, r * f i", "start": [119, 1], "end": [120, 32], "kind": "commanddeclaration"}, {"full_name": "Real.mul_iInf_of_nonpos", "code": "theorem Real.mul_iInf_of_nonpos (ha : r \u2264 0) (f : \u03b9 \u2192 \u211d) : (r * \u2a05 i, f i) = \u2a06 i, r * f i", "start": [123, 1], "end": [124, 32], "kind": "commanddeclaration"}, {"full_name": "Real.mul_iSup_of_nonpos", "code": "theorem Real.mul_iSup_of_nonpos (ha : r \u2264 0) (f : \u03b9 \u2192 \u211d) : (r * \u2a06 i, f i) = \u2a05 i, r * f i", "start": [127, 1], "end": [128, 32], "kind": "commanddeclaration"}, {"full_name": "Real.iInf_mul_of_nonneg", "code": "theorem Real.iInf_mul_of_nonneg (ha : 0 \u2264 r) (f : \u03b9 \u2192 \u211d) : (\u2a05 i, f i) * r = \u2a05 i, f i * r", "start": [131, 1], "end": [132, 51], "kind": "commanddeclaration"}, {"full_name": "Real.iSup_mul_of_nonneg", "code": "theorem Real.iSup_mul_of_nonneg (ha : 0 \u2264 r) (f : \u03b9 \u2192 \u211d) : (\u2a06 i, f i) * r = \u2a06 i, f i * r", "start": [135, 1], "end": [136, 51], "kind": "commanddeclaration"}, {"full_name": "Real.iInf_mul_of_nonpos", "code": "theorem Real.iInf_mul_of_nonpos (ha : r \u2264 0) (f : \u03b9 \u2192 \u211d) : (\u2a05 i, f i) * r = \u2a06 i, f i * r", "start": [139, 1], "end": [140, 51], "kind": "commanddeclaration"}, {"full_name": "Real.iSup_mul_of_nonpos", "code": "theorem Real.iSup_mul_of_nonpos (ha : r \u2264 0) (f : \u03b9 \u2192 \u211d) : (\u2a06 i, f i) * r = \u2a05 i, f i * r", "start": [143, 1], "end": [144, 51], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/ConditionallyCompleteLattice/Group.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Algebra/Order/Group/TypeTags.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "le_mul_ciInf", "code": "@[to_additive]\ntheorem le_mul_ciInf [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b1} {h : \u03b9 \u2192 \u03b1}\n    (H : \u2200 j, a \u2264 g * h j) : a \u2264 g * iInf h", "start": [22, 1], "end": [25, 81], "kind": "commanddeclaration"}, {"full_name": "mul_ciSup_le", "code": "@[to_additive]\ntheorem mul_ciSup_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b1} {h : \u03b9 \u2192 \u03b1}\n    (H : \u2200 j, g * h j \u2264 a) : g * iSup h \u2264 a", "start": [29, 1], "end": [32, 38], "kind": "commanddeclaration"}, {"full_name": "le_ciInf_mul", "code": "@[to_additive]\ntheorem le_ciInf_mul [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b9 \u2192 \u03b1}\n    {h : \u03b1} (H : \u2200 i, a \u2264 g i * h) : a \u2264 iInf g * h", "start": [36, 1], "end": [39, 81], "kind": "commanddeclaration"}, {"full_name": "ciSup_mul_le", "code": "@[to_additive]\ntheorem ciSup_mul_le [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b9 \u2192 \u03b1}\n    {h : \u03b1} (H : \u2200 i, g i * h \u2264 a) : iSup g * h \u2264 a", "start": [43, 1], "end": [46, 38], "kind": "commanddeclaration"}, {"full_name": "le_ciInf_mul_ciInf", "code": "@[to_additive]\ntheorem le_ciInf_mul_ciInf [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b9 \u2192 \u03b1} {h : \u03b9' \u2192 \u03b1}\n    (H : \u2200 i j, a \u2264 g i * h j) : a \u2264 iInf g * iInf h", "start": [50, 1], "end": [54, 44], "kind": "commanddeclaration"}, {"full_name": "ciSup_mul_ciSup_le", "code": "@[to_additive]\ntheorem ciSup_mul_ciSup_le [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n    [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a : \u03b1} {g : \u03b9 \u2192 \u03b1} {h : \u03b9' \u2192 \u03b1}\n    (H : \u2200 i j, g i * h j \u2264 a) : iSup g * iSup h \u2264 a", "start": [58, 1], "end": [62, 44], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Nonneg/Floor.lean", "imports": ["Mathlib/Algebra/Order/Nonneg/Ring.lean", "Mathlib/Algebra/Order/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nonneg.archimedean", "code": "instance archimedean [OrderedAddCommMonoid \u03b1] [Archimedean \u03b1] : Archimedean { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun x y hy =>\n    let \u27e8n, hr\u27e9 := Archimedean.arch (x : \u03b1) (hy : (0 : \u03b1) < y)\n    \u27e8n, show (x : \u03b1) \u2264 (n \u2022 y : { x : \u03b1 // 0 \u2264 x }) by simp [*, -nsmul_eq_mul, nsmul_coe]\u27e9\u27e9", "start": [28, 1], "end": [31, 92], "kind": "commanddeclaration"}, {"full_name": "Nonneg.floorSemiring", "code": "instance floorSemiring [OrderedSemiring \u03b1] [FloorSemiring \u03b1] :\n    FloorSemiring { r : \u03b1 // 0 \u2264 r } where\n  floor a := \u230a(a : \u03b1)\u230b\u208a\n  ceil a := \u2308(a : \u03b1)\u2309\u208a\n  floor_of_neg ha := FloorSemiring.floor_of_neg ha\n  gc_floor ha := FloorSemiring.gc_floor (Subtype.coe_le_coe.2 ha)\n  gc_ceil a n := FloorSemiring.gc_ceil (a : \u03b1) n", "start": [34, 1], "end": [40, 49], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nat_floor_coe", "code": "@[norm_cast]\ntheorem nat_floor_coe [OrderedSemiring \u03b1] [FloorSemiring \u03b1] (a : { r : \u03b1 // 0 \u2264 r }) :\n    \u230a(a : \u03b1)\u230b\u208a = \u230aa\u230b\u208a", "start": [43, 1], "end": [46, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.nat_ceil_coe", "code": "@[norm_cast]\ntheorem nat_ceil_coe [OrderedSemiring \u03b1] [FloorSemiring \u03b1] (a : { r : \u03b1 // 0 \u2264 r }) :\n    \u2308(a : \u03b1)\u2309\u208a = \u2308a\u2309\u208a", "start": [49, 1], "end": [52, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Nonneg/Field.lean", "imports": ["Mathlib/Algebra/Order/Field/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Order/Nonneg/Ring.lean", "Mathlib/Algebra/Order/Field/InjSurj.lean", "Mathlib/Algebra/Order/Field/Canonical/Defs.lean"], "premises": [{"full_name": "Nonneg.inv", "code": "instance inv : Inv { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun x => \u27e8x\u207b\u00b9, inv_nonneg.2 x.2\u27e9\u27e9", "start": [37, 1], "end": [38, 37], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_inv", "code": "@[simp, norm_cast]\nprotected theorem coe_inv (a : { x : \u03b1 // 0 \u2264 x }) : ((a\u207b\u00b9 : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = (a : \u03b1)\u207b\u00b9", "start": [41, 1], "end": [43, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.inv_mk", "code": "@[simp]\ntheorem inv_mk (hx : 0 \u2264 x) : (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x })\u207b\u00b9 = \u27e8x\u207b\u00b9, inv_nonneg.2 hx\u27e9", "start": [46, 1], "end": [48, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.div", "code": "instance div : Div { x : \u03b1 // 0 \u2264 x } :=\n  \u27e8fun x y => \u27e8x / y, div_nonneg x.2 y.2\u27e9\u27e9", "start": [51, 1], "end": [52, 43], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_div", "code": "@[simp, norm_cast]\nprotected theorem coe_div (a b : { x : \u03b1 // 0 \u2264 x }) : ((a / b : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = a / b", "start": [55, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_div_mk", "code": "@[simp]\ntheorem mk_div_mk (hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) / \u27e8y, hy\u27e9 = \u27e8x / y, div_nonneg hx hy\u27e9", "start": [60, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.zpow", "code": "instance zpow : Pow { x : \u03b1 // 0 \u2264 x } \u2124 :=\n  \u27e8fun a n => \u27e8(a : \u03b1) ^ n, zpow_nonneg a.2 _\u27e9\u27e9", "start": [66, 1], "end": [67, 48], "kind": "commanddeclaration"}, {"full_name": "Nonneg.coe_zpow", "code": "@[simp, norm_cast]\nprotected theorem coe_zpow (a : { x : \u03b1 // 0 \u2264 x }) (n : \u2124) :\n    ((a ^ n : { x : \u03b1 // 0 \u2264 x }) : \u03b1) = (a : \u03b1) ^ n", "start": [70, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.mk_zpow", "code": "@[simp]\ntheorem mk_zpow (hx : 0 \u2264 x) (n : \u2124) :\n    (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) ^ n = \u27e8x ^ n, zpow_nonneg hx n\u27e9", "start": [76, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedSemifield", "code": "instance linearOrderedSemifield : LinearOrderedSemifield { x : \u03b1 // 0 \u2264 x } :=\n  Subtype.coe_injective.linearOrderedSemifield _ Nonneg.coe_zero Nonneg.coe_one Nonneg.coe_add\n    Nonneg.coe_mul Nonneg.coe_inv Nonneg.coe_div (fun _ _ => rfl) Nonneg.coe_pow Nonneg.coe_zpow\n    Nonneg.coe_nat_cast (fun _ _ => rfl) fun _ _ => rfl", "start": [82, 1], "end": [85, 56], "kind": "commanddeclaration"}, {"full_name": "Nonneg.canonicallyLinearOrderedSemifield", "code": "instance canonicallyLinearOrderedSemifield [LinearOrderedField \u03b1] :\n    CanonicallyLinearOrderedSemifield { x : \u03b1 // 0 \u2264 x } :=\n  { Nonneg.linearOrderedSemifield, Nonneg.canonicallyOrderedCommSemiring with }", "start": [90, 1], "end": [92, 80], "kind": "commanddeclaration"}, {"full_name": "Nonneg.linearOrderedCommGroupWithZero", "code": "instance linearOrderedCommGroupWithZero [LinearOrderedField \u03b1] :\n    LinearOrderedCommGroupWithZero { x : \u03b1 // 0 \u2264 x } :=\n  inferInstance", "start": [95, 1], "end": [97, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Field/Canonical/Basic.lean", "imports": ["Mathlib/Algebra/Order/Field/Canonical/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tsub_div", "code": "theorem tsub_div (a b c : \u03b1) : (a - b) / c = a / c - b / c", "start": [22, 1], "end": [22, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/GroupAction/Quotient.lean", "imports": ["Mathlib/GroupTheory/Coset.lean", "Mathlib/Dynamics/PeriodicPts.lean", "Mathlib/Algebra/Group/ConjFinite.lean", "Mathlib/GroupTheory/Commutator.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Fintype/BigOperators.lean", "Mathlib/Algebra/Hom/GroupAction.lean"], "premises": [{"full_name": "MulAction.QuotientAction", "code": "class QuotientAction : Prop where\n  \n  inv_mul_mem : \u2200 (b : \u03b2) {a a' : \u03b1}, a\u207b\u00b9 * a' \u2208 H \u2192 (b \u2022 a)\u207b\u00b9 * b \u2022 a' \u2208 H", "start": [44, 1], "end": [48, 76], "kind": "commanddeclaration"}, {"full_name": "AddAction.QuotientAction", "code": "class _root_.AddAction.QuotientAction {\u03b1 : Type u} (\u03b2 : Type v) [AddGroup \u03b1] [AddMonoid \u03b2]\n  [AddAction \u03b2 \u03b1] (H : AddSubgroup \u03b1) : Prop where\n  \n  inv_mul_mem : \u2200 (b : \u03b2) {a a' : \u03b1}, -a + a' \u2208 H \u2192 -(b +\u1d65 a) + (b +\u1d65 a') \u2208 H", "start": [51, 1], "end": [56, 78], "kind": "commanddeclaration"}, {"full_name": "MulAction.left_quotientAction", "code": "@[to_additive]\ninstance left_quotientAction : QuotientAction \u03b1 H :=\n  \u27e8fun _ _ _ _ => by rwa [smul_eq_mul, smul_eq_mul, mul_inv_rev, mul_assoc, inv_mul_cancel_left]\u27e9", "start": [61, 1], "end": [63, 98], "kind": "commanddeclaration"}, {"full_name": "MulAction.right_quotientAction", "code": "@[to_additive]\ninstance right_quotientAction : QuotientAction (normalizer H).op H :=\n  \u27e8fun b c _ _ => by\n    rwa [smul_def, smul_def, smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, \u2190 mul_assoc,\n      mem_normalizer_iff'.mp b.prop, mul_assoc, mul_inv_cancel_left]\u27e9", "start": [67, 1], "end": [71, 70], "kind": "commanddeclaration"}, {"full_name": "MulAction.right_quotientAction'", "code": "@[to_additive]\ninstance right_quotientAction' [hH : H.Normal] : QuotientAction \u03b1\u1d50\u1d52\u1d56 H :=\n  \u27e8fun _ _ _ _ => by\n    rwa [smul_eq_mul_unop, smul_eq_mul_unop, mul_inv_rev, mul_assoc, hH.mem_comm_iff, mul_assoc,\n      mul_inv_cancel_right]\u27e9", "start": [75, 1], "end": [79, 29], "kind": "commanddeclaration"}, {"full_name": "MulAction.quotient", "code": "@[to_additive]\ninstance quotient [QuotientAction \u03b2 H] : MulAction \u03b2 (\u03b1 \u29f8 H) where\n  smul b :=\n    Quotient.map' ((\u00b7 \u2022 \u00b7) b) fun _ _ h =>\n      leftRel_apply.mpr <| QuotientAction.inv_mul_mem b <| leftRel_apply.mp h\n  one_smul q := Quotient.inductionOn' q fun a => congr_arg Quotient.mk'' (one_smul \u03b2 a)\n  mul_smul b b' q := Quotient.inductionOn' q fun a => congr_arg Quotient.mk'' (mul_smul b b' a)", "start": [83, 1], "end": [89, 96], "kind": "commanddeclaration"}, {"full_name": "MulAction.Quotient.smul_mk", "code": "@[to_additive (attr := simp)]\ntheorem Quotient.smul_mk [QuotientAction \u03b2 H] (b : \u03b2) (a : \u03b1) :\n    (b \u2022 QuotientGroup.mk a : \u03b1 \u29f8 H) = QuotientGroup.mk (b \u2022 a)", "start": [95, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.Quotient.smul_coe", "code": "@[to_additive (attr := simp)]\ntheorem Quotient.smul_coe [QuotientAction \u03b2 H] (b : \u03b2) (a : \u03b1) :\n    b \u2022 (a : \u03b1 \u29f8 H) = (b \u2022 a : \u03b1 \u29f8 H)", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.Quotient.mk_smul_out'", "code": "@[to_additive (attr := simp)]\ntheorem Quotient.mk_smul_out' [QuotientAction \u03b2 H] (b : \u03b2) (q : \u03b1 \u29f8 H) :\n    QuotientGroup.mk (b \u2022 q.out') = b \u2022 q", "start": [109, 1], "end": [111, 95], "kind": "commanddeclaration"}, {"full_name": "MulAction.Quotient.coe_smul_out'", "code": "@[to_additive]\ntheorem Quotient.coe_smul_out' [QuotientAction \u03b2 H] (b : \u03b2) (q : \u03b1 \u29f8 H) : \u2191(b \u2022 q.out') = b \u2022 q", "start": [116, 1], "end": [118, 30], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.out'_conj_pow_minimalPeriod_mem", "code": "theorem _root_.QuotientGroup.out'_conj_pow_minimalPeriod_mem (a : \u03b1) (q : \u03b1 \u29f8 H) :\n    q.out'\u207b\u00b9 * a ^ Function.minimalPeriod ((\u00b7 \u2022 \u00b7) a) q * q.out' \u2208 H", "start": [122, 1], "end": [125, 48], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.toQuotient", "code": "def _root_.MulActionHom.toQuotient (H : Subgroup \u03b1) : \u03b1 \u2192[\u03b1] \u03b1 \u29f8 H where\n  toFun := (\u2191); map_smul' := Quotient.smul_coe H", "start": [132, 1], "end": [134, 49], "kind": "commanddeclaration"}, {"full_name": "MulActionHom.toQuotient_apply", "code": "@[simp]\ntheorem _root_.MulActionHom.toQuotient_apply (H : Subgroup \u03b1) (g : \u03b1) :\n    MulActionHom.toQuotient H g = g", "start": [137, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.mulLeftCosetsCompSubtypeVal", "code": "@[to_additive]\ninstance mulLeftCosetsCompSubtypeVal (H I : Subgroup \u03b1) : MulAction I (\u03b1 \u29f8 H) :=\n  MulAction.compHom (\u03b1 \u29f8 H) (Subgroup.subtype I)", "start": [143, 1], "end": [145, 49], "kind": "commanddeclaration"}, {"full_name": "MulAction.ofQuotientStabilizer", "code": "@[to_additive \"The canonical map from the quotient of the stabilizer to the set. \"]\ndef ofQuotientStabilizer (g : \u03b1 \u29f8 MulAction.stabilizer \u03b1 x) : \u03b2 :=\n  Quotient.liftOn' g (\u00b7 \u2022 x) fun g1 g2 H =>\n    calc\n      g1 \u2022 x = g1 \u2022 (g1\u207b\u00b9 * g2) \u2022 x := congr_arg _ (leftRel_apply.mp H).symm\n      _ = g2 \u2022 x := by rw [smul_smul, mul_inv_cancel_left]", "start": [152, 1], "end": [158, 59], "kind": "commanddeclaration"}, {"full_name": "MulAction.ofQuotientStabilizer_mk", "code": "@[to_additive (attr := simp)]\ntheorem ofQuotientStabilizer_mk (g : \u03b1) : ofQuotientStabilizer \u03b1 x (QuotientGroup.mk g) = g \u2022 x", "start": [162, 1], "end": [164, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.ofQuotientStabilizer_mem_orbit", "code": "@[to_additive]\ntheorem ofQuotientStabilizer_mem_orbit (g) : ofQuotientStabilizer \u03b1 x g \u2208 orbit \u03b1 x", "start": [168, 1], "end": [170, 44], "kind": "commanddeclaration"}, {"full_name": "MulAction.ofQuotientStabilizer_smul", "code": "@[to_additive]\ntheorem ofQuotientStabilizer_smul (g : \u03b1) (g' : \u03b1 \u29f8 MulAction.stabilizer \u03b1 x) :\n    ofQuotientStabilizer \u03b1 x (g \u2022 g') = g \u2022 ofQuotientStabilizer \u03b1 x g'", "start": [174, 1], "end": [177, 51], "kind": "commanddeclaration"}, {"full_name": "MulAction.injective_ofQuotientStabilizer", "code": "@[to_additive]\ntheorem injective_ofQuotientStabilizer : Function.Injective (ofQuotientStabilizer \u03b1 x)", "start": [181, 1], "end": [188, 40], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitEquivQuotientStabilizer", "code": "@[to_additive \"Orbit-stabilizer theorem.\"]\nnoncomputable def orbitEquivQuotientStabilizer (b : \u03b2) : orbit \u03b1 b \u2243 \u03b1 \u29f8 stabilizer \u03b1 b :=\n  Equiv.symm <|\n    Equiv.ofBijective (fun g => \u27e8ofQuotientStabilizer \u03b1 b g, ofQuotientStabilizer_mem_orbit \u03b1 b g\u27e9)\n      \u27e8fun x y hxy => injective_ofQuotientStabilizer \u03b1 b (by convert congr_arg Subtype.val hxy),\n        fun \u27e8b, \u27e8g, hgb\u27e9\u27e9 => \u27e8g, Subtype.eq hgb\u27e9\u27e9", "start": [192, 1], "end": [198, 50], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitProdStabilizerEquivGroup", "code": "@[to_additive \"Orbit-stabilizer theorem.\"]\nnoncomputable def orbitProdStabilizerEquivGroup (b : \u03b2) : orbit \u03b1 b \u00d7 stabilizer \u03b1 b \u2243 \u03b1 :=\n  (Equiv.prodCongr (orbitEquivQuotientStabilizer \u03b1 _) (Equiv.refl _)).trans\n    Subgroup.groupEquivQuotientProdSubgroup.symm", "start": [202, 1], "end": [206, 49], "kind": "commanddeclaration"}, {"full_name": "MulAction.card_orbit_mul_card_stabilizer_eq_card_group", "code": "@[to_additive \"Orbit-stabilizer theorem.\"]\ntheorem card_orbit_mul_card_stabilizer_eq_card_group (b : \u03b2) [Fintype \u03b1] [Fintype <| orbit \u03b1 b]\n    [Fintype <| stabilizer \u03b1 b] :\n    Fintype.card (orbit \u03b1 b) * Fintype.card (stabilizer \u03b1 b) = Fintype.card \u03b1", "start": [210, 1], "end": [215, 83], "kind": "commanddeclaration"}, {"full_name": "MulAction.orbitEquivQuotientStabilizer_symm_apply", "code": "@[to_additive (attr := simp)]\ntheorem orbitEquivQuotientStabilizer_symm_apply (b : \u03b2) (a : \u03b1) :\n    ((orbitEquivQuotientStabilizer \u03b1 b).symm a : \u03b2) = a \u2022 b", "start": [219, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "MulAction.stabilizer_quotient", "code": "@[to_additive (attr := simp)]\ntheorem stabilizer_quotient {G} [Group G] (H : Subgroup G) :\n    MulAction.stabilizer G ((1 : G) : G \u29f8 H) = H", "start": [226, 1], "end": [230, 26], "kind": "commanddeclaration"}, {"full_name": "MulAction.selfEquivSigmaOrbitsQuotientStabilizer'", "code": "@[to_additive\n      \"**Class formula** : given `G` an additive group acting on `X` and `\u03c6` a function\n      mapping each orbit of `X` under this action (that is, each element of the quotient of `X` by\n      the relation `orbit_rel G X`) to an element in this orbit, this gives a (noncomputable)\n      bijection between `X` and the disjoint union of `G/Stab(\u03c6(\u03c9))` over all orbits `\u03c9`. In most\n      cases you'll want `\u03c6` to be `Quotient.out'`, so we provide\n      `AddAction.selfEquivSigmaOrbitsQuotientStabilizer'` as a special case. \"]\nnoncomputable def selfEquivSigmaOrbitsQuotientStabilizer' {\u03c6 : \u03a9 \u2192 \u03b2}\n    (h\u03c6 : LeftInverse Quotient.mk'' \u03c6) : \u03b2 \u2243 \u03a3\u03c9 : \u03a9, \u03b1 \u29f8 stabilizer \u03b1 (\u03c6 \u03c9) :=\n  calc\n    \u03b2 \u2243 \u03a3\u03c9 : \u03a9, orbitRel.Quotient.orbit \u03c9 := selfEquivSigmaOrbits' \u03b1 \u03b2\n    _ \u2243 \u03a3\u03c9 : \u03a9, \u03b1 \u29f8 stabilizer \u03b1 (\u03c6 \u03c9) :=\n      Equiv.sigmaCongrRight fun \u03c9 =>\n        (Equiv.Set.ofEq <| orbitRel.Quotient.orbit_eq_orbit_out _ h\u03c6).trans <|\n          orbitEquivQuotientStabilizer \u03b1 (\u03c6 \u03c9)", "start": [239, 1], "end": [258, 47], "kind": "commanddeclaration"}, {"full_name": "MulAction.card_eq_sum_card_group_div_card_stabilizer'", "code": "@[to_additive\n      \"**Class formula** for a finite group acting on a finite type. See\n      `AddAction.card_eq_sum_card_addGroup_div_card_stabilizer` for a specialized version using\n      `Quotient.out'`.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer' [Fintype \u03b1] [Fintype \u03b2] [Fintype \u03a9]\n    [\u2200 b : \u03b2, Fintype <| stabilizer \u03b1 b] {\u03c6 : \u03a9 \u2192 \u03b2} (h\u03c6 : LeftInverse Quotient.mk'' \u03c6) :\n    Fintype.card \u03b2 = \u2211 \u03c9 : \u03a9, Fintype.card \u03b1 / Fintype.card (stabilizer \u03b1 (\u03c6 \u03c9))", "start": [262, 1], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "MulAction.selfEquivSigmaOrbitsQuotientStabilizer", "code": "@[to_additive\n      \"**Class formula**. This is a special case of\n      `AddAction.self_equiv_sigma_orbits_quotient_stabilizer'` with `\u03c6 = Quotient.out'`. \"]\nnoncomputable def selfEquivSigmaOrbitsQuotientStabilizer : \u03b2 \u2243 \u03a3\u03c9 : \u03a9, \u03b1 \u29f8 stabilizer \u03b1 \u03c9.out' :=\n  selfEquivSigmaOrbitsQuotientStabilizer' \u03b1 \u03b2 Quotient.out_eq'", "start": [284, 1], "end": [290, 63], "kind": "commanddeclaration"}, {"full_name": "MulAction.card_eq_sum_card_group_div_card_stabilizer", "code": "@[to_additive \"**Class formula** for a finite group acting on a finite type.\"]\ntheorem card_eq_sum_card_group_div_card_stabilizer [Fintype \u03b1] [Fintype \u03b2] [Fintype \u03a9]\n    [\u2200 b : \u03b2, Fintype <| stabilizer \u03b1 b] :\n    Fintype.card \u03b2 = \u2211 \u03c9 : \u03a9, Fintype.card \u03b1 / Fintype.card (stabilizer \u03b1 \u03c9.out')", "start": [294, 1], "end": [299, 67], "kind": "commanddeclaration"}, {"full_name": "MulAction.sigmaFixedByEquivOrbitsProdGroup", "code": "@[to_additive\n      \"**Burnside's lemma** : a (noncomputable) bijection between the disjoint union of all\n      `{x \u2208 X | g \u2022 x = x}` for `g \u2208 G` and the product `G \u00d7 X/G`, where `G` is an additive group\n      acting on `X` and `X/G`denotes the quotient of `X` by the relation `orbitRel G X`. \"]\nnoncomputable def sigmaFixedByEquivOrbitsProdGroup : (\u03a3a : \u03b1, fixedBy \u03b1 \u03b2 a) \u2243 \u03a9 \u00d7 \u03b1 :=\n  calc\n    (\u03a3a : \u03b1, fixedBy \u03b1 \u03b2 a) \u2243 { ab : \u03b1 \u00d7 \u03b2 // ab.1 \u2022 ab.2 = ab.2 } :=\n      (Equiv.subtypeProdEquivSigmaSubtype _).symm\n    _ \u2243 { ba : \u03b2 \u00d7 \u03b1 // ba.2 \u2022 ba.1 = ba.1 } := (Equiv.prodComm \u03b1 \u03b2).subtypeEquiv fun _ => Iff.rfl\n    _ \u2243 \u03a3b : \u03b2, stabilizer \u03b1 b :=\n      Equiv.subtypeProdEquivSigmaSubtype fun (b : \u03b2) a => a \u2208 stabilizer \u03b1 b\n    _ \u2243 \u03a3\u03c9b : \u03a3\u03c9 : \u03a9, orbit \u03b1 \u03c9.out', stabilizer \u03b1 (\u03c9b.2 : \u03b2) :=\n      (selfEquivSigmaOrbits \u03b1 \u03b2).sigmaCongrLeft'\n    _ \u2243 \u03a3\u03c9 : \u03a9, \u03a3b : orbit \u03b1 \u03c9.out', stabilizer \u03b1 (b : \u03b2) :=\n      Equiv.sigmaAssoc fun (\u03c9 : \u03a9) (b : orbit \u03b1 \u03c9.out') => stabilizer \u03b1 (b : \u03b2)\n    _ \u2243 \u03a3\u03c9 : \u03a9, \u03a3 _ : orbit \u03b1 \u03c9.out', stabilizer \u03b1 \u03c9.out' :=\n      Equiv.sigmaCongrRight fun _ =>\n        Equiv.sigmaCongrRight fun \u27e8_, hb\u27e9 => (stabilizerEquivStabilizerOfOrbitRel hb).toEquiv\n    _ \u2243 \u03a3\u03c9 : \u03a9, orbit \u03b1 \u03c9.out' \u00d7 stabilizer \u03b1 \u03c9.out' :=\n      Equiv.sigmaCongrRight fun _ => Equiv.sigmaEquivProd _ _\n    _ \u2243 \u03a3 _ : \u03a9, \u03b1 := Equiv.sigmaCongrRight fun \u03c9 => orbitProdStabilizerEquivGroup \u03b1 \u03c9.out'\n    _ \u2243 \u03a9 \u00d7 \u03b1 := Equiv.sigmaEquivProd \u03a9 \u03b1", "start": [303, 1], "end": [327, 42], "kind": "commanddeclaration"}, {"full_name": "MulAction.sum_card_fixedBy_eq_card_orbits_mul_card_group", "code": "@[to_additive\n      \"**Burnside's lemma** : given a finite additive group `G` acting on a set `X`,\n      the average number of elements fixed by each `g \u2208 G` is the number of orbits. \"]\ntheorem sum_card_fixedBy_eq_card_orbits_mul_card_group [Fintype \u03b1] [\u2200 a, Fintype <| fixedBy \u03b1 \u03b2 a]\n    [Fintype \u03a9] : (\u2211 a : \u03b1, Fintype.card (fixedBy \u03b1 \u03b2 a)) = Fintype.card \u03a9 * Fintype.card \u03b1", "start": [331, 1], "end": [339, 63], "kind": "commanddeclaration"}, {"full_name": "MulAction.isPretransitive_quotient", "code": "@[to_additive]\ninstance isPretransitive_quotient (G) [Group G] (H : Subgroup G) : IsPretransitive G (G \u29f8 H) where\n  exists_smul_eq := by\n    { rintro \u27e8x\u27e9 \u27e8y\u27e9\n      refine' \u27e8y * x\u207b\u00b9, QuotientGroup.eq.mpr _\u27e9\n      simp only [smul_eq_mul, H.one_mem, mul_left_inv, inv_mul_cancel_right]}", "start": [343, 1], "end": [348, 78], "kind": "commanddeclaration"}, {"full_name": "ConjClasses.card_carrier", "code": "theorem ConjClasses.card_carrier [Group G] [Fintype G] (g : G) [Fintype (ConjClasses.mk g).carrier]\n    [Fintype <| MulAction.stabilizer (ConjAct G) g] : Fintype.card (ConjClasses.mk g).carrier =\n      Fintype.card G / Fintype.card (MulAction.stabilizer (ConjAct G) g)", "start": [355, 1], "end": [362, 47], "kind": "commanddeclaration"}, {"full_name": "Subgroup.normalCore_eq_ker", "code": "theorem normalCore_eq_ker : H.normalCore = (MulAction.toPermHom G (G \u29f8 H)).ker", "start": [368, 1], "end": [378, 91], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientCentralizerEmbedding", "code": "noncomputable def quotientCentralizerEmbedding (g : G) :\n    G \u29f8 centralizer (zpowers (g : G)) \u21aa commutatorSet G :=\n  ((MulAction.orbitEquivQuotientStabilizer (ConjAct G) g).trans\n            (quotientEquivOfEq (ConjAct.stabilizer_eq_centralizer g))).symm.toEmbedding.trans\n    \u27e8fun x =>\n      \u27e8x * g\u207b\u00b9,\n        let \u27e8_, x, rfl\u27e9 := x\n        \u27e8x, g, rfl\u27e9\u27e9,\n      fun _ _ => Subtype.ext \u2218 mul_right_cancel \u2218 Subtype.ext_iff.mp\u27e9", "start": [383, 1], "end": [392, 70], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientCentralizerEmbedding_apply", "code": "theorem quotientCentralizerEmbedding_apply (g : G) (x : G) :\n    quotientCentralizerEmbedding g x = \u27e8\u2045x, g\u2046, x, g, rfl\u27e9", "start": [395, 1], "end": [397, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientCenterEmbedding", "code": "noncomputable def quotientCenterEmbedding {S : Set G} (hS : closure S = \u22a4) :\n    G \u29f8 center G \u21aa S \u2192 commutatorSet G :=\n  (quotientEquivOfEq (center_eq_infi' S hS)).toEmbedding.trans\n    ((quotientiInfEmbedding _).trans\n      (Function.Embedding.piCongrRight fun g => quotientCentralizerEmbedding (g : G)))", "start": [400, 1], "end": [406, 87], "kind": "commanddeclaration"}, {"full_name": "Subgroup.quotientCenterEmbedding_apply", "code": "theorem quotientCenterEmbedding_apply {S : Set G} (hS : closure S = \u22a4) (g : G) (s : S) :\n    quotientCenterEmbedding hS g s = \u27e8\u2045g, s\u2046, g, s, rfl\u27e9", "start": [409, 1], "end": [411, 6], "kind": "commanddeclaration"}, {"full_name": "card_comm_eq_card_conjClasses_mul_card", "code": "theorem card_comm_eq_card_conjClasses_mul_card (G : Type*) [Group G] :\n    Nat.card { p : G \u00d7 G // Commute p.1 p.2 } = Nat.card (ConjClasses G) * Nat.card G", "start": [420, 1], "end": [433, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Monoid.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Order/Filter/Pointwise.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Pi.lean", "Mathlib/Algebra/BigOperators/Finprod.lean", "Mathlib/Topology/Algebra/MulAction.lean"], "premises": [{"full_name": "continuous_one", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_one [TopologicalSpace M] [One M] : Continuous (1 : X \u2192 M)", "start": [31, 1], "end": [33, 30], "kind": "commanddeclaration"}, {"full_name": "ContinuousAdd", "code": "class ContinuousAdd (M : Type u) [TopologicalSpace M] [Add M] : Prop where\n  continuous_add : Continuous fun p : M \u00d7 M => p.1 + p.2", "start": [37, 1], "end": [44, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul", "code": "@[to_additive]\nclass ContinuousMul (M : Type u) [TopologicalSpace M] [Mul M] : Prop where\n  continuous_mul : Continuous fun p : M \u00d7 M => p.1 * p.2", "start": [47, 1], "end": [55, 57], "kind": "commanddeclaration"}, {"full_name": "continuous_mul", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_mul : Continuous fun p : M \u00d7 M => p.1 * p.2", "start": [66, 1], "end": [68, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul.to_continuousSMul", "code": "@[to_additive]\ninstance ContinuousMul.to_continuousSMul : ContinuousSMul M M :=\n  \u27e8continuous_mul\u27e9", "start": [72, 1], "end": [74, 19], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul.to_continuousSMul_op", "code": "@[to_additive]\ninstance ContinuousMul.to_continuousSMul_op : ContinuousSMul M\u1d50\u1d52\u1d56 M :=\n  \u27e8show Continuous ((fun p : M \u00d7 M => p.1 * p.2) \u2218 Prod.swap \u2218 Prod.map MulOpposite.unop id) from\n      continuous_mul.comp <|\n        continuous_swap.comp <| Continuous.prod_map MulOpposite.continuous_unop continuous_id\u27e9", "start": [78, 1], "end": [82, 95], "kind": "commanddeclaration"}, {"full_name": "Continuous.mul", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.mul {f g : X \u2192 M} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => f x * g x", "start": [86, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "continuous_mul_left", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_mul_left (a : M) : Continuous fun b : M => a * b", "start": [93, 1], "end": [95, 37], "kind": "commanddeclaration"}, {"full_name": "continuous_mul_right", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_mul_right (a : M) : Continuous fun b : M => b * a", "start": [99, 1], "end": [101, 37], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.mul", "code": "@[to_additive]\ntheorem ContinuousOn.mul {f g : X \u2192 M} {s : Set X} (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x * g x) s", "start": [105, 1], "end": [108, 54], "kind": "commanddeclaration"}, {"full_name": "tendsto_mul", "code": "@[to_additive]\ntheorem tendsto_mul {a b : M} : Tendsto (fun p : M \u00d7 M => p.fst * p.snd) (\ud835\udcdd (a, b)) (\ud835\udcdd (a * b))", "start": [112, 1], "end": [114, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mul", "code": "@[to_additive]\ntheorem Filter.Tendsto.mul {f g : \u03b1 \u2192 M} {x : Filter \u03b1} {a b : M} (hf : Tendsto f x (\ud835\udcdd a))\n    (hg : Tendsto g x (\ud835\udcdd b)) : Tendsto (fun x => f x * g x) x (\ud835\udcdd (a * b))", "start": [118, 1], "end": [121, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_mul", "code": "@[to_additive]\ntheorem Filter.Tendsto.const_mul (b : M) {c : M} {f : \u03b1 \u2192 M} {l : Filter \u03b1}\n    (h : Tendsto (fun k : \u03b1 => f k) l (\ud835\udcdd c)) : Tendsto (fun k : \u03b1 => b * f k) l (\ud835\udcdd (b * c))", "start": [125, 1], "end": [128, 27], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mul_const", "code": "@[to_additive]\ntheorem Filter.Tendsto.mul_const (b : M) {c : M} {f : \u03b1 \u2192 M} {l : Filter \u03b1}\n    (h : Tendsto (fun k : \u03b1 => f k) l (\ud835\udcdd c)) : Tendsto (fun k : \u03b1 => f k * b) l (\ud835\udcdd (c * b))", "start": [132, 1], "end": [135, 27], "kind": "commanddeclaration"}, {"full_name": "le_nhds_mul", "code": "@[to_additive]\ntheorem le_nhds_mul (a b : M) : \ud835\udcdd a * \ud835\udcdd b \u2264 \ud835\udcdd (a * b)", "start": [139, 1], "end": [142, 33], "kind": "commanddeclaration"}, {"full_name": "nhds_one_mul_nhds", "code": "@[to_additive (attr := simp)]\ntheorem nhds_one_mul_nhds {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    \ud835\udcdd (1 : M) * \ud835\udcdd a = \ud835\udcdd a", "start": [146, 1], "end": [150, 45], "kind": "commanddeclaration"}, {"full_name": "nhds_mul_nhds_one", "code": "@[to_additive (attr := simp)]\ntheorem nhds_mul_nhds_one {M} [MulOneClass M] [TopologicalSpace M] [ContinuousMul M] (a : M) :\n    \ud835\udcdd a * \ud835\udcdd 1 = \ud835\udcdd a", "start": [154, 1], "end": [158, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.TendstoNhdsWithinIoi.const_mul", "code": "theorem Filter.TendstoNhdsWithinIoi.const_mul [PosMulStrictMono \ud835\udd5c] [PosMulReflectLT \ud835\udd5c]\n    (h : Tendsto f l (\ud835\udcdd[>] c)) : Tendsto (fun a => b * f a) l (\ud835\udcdd[>] (b * c))", "start": [167, 1], "end": [171, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.TendstoNhdsWithinIio.const_mul", "code": "theorem Filter.TendstoNhdsWithinIio.const_mul [PosMulStrictMono \ud835\udd5c] [PosMulReflectLT \ud835\udd5c]\n    (h : Tendsto f l (\ud835\udcdd[<] c)) : Tendsto (fun a => b * f a) l (\ud835\udcdd[<] (b * c))", "start": [174, 1], "end": [178, 75], "kind": "commanddeclaration"}, {"full_name": "Filter.TendstoNhdsWithinIoi.mul_const", "code": "theorem Filter.TendstoNhdsWithinIoi.mul_const [MulPosStrictMono \ud835\udd5c] [MulPosReflectLT \ud835\udd5c]\n    (h : Tendsto f l (\ud835\udcdd[>] c)) : Tendsto (fun a => f a * b) l (\ud835\udcdd[>] (c * b))", "start": [181, 1], "end": [185, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.TendstoNhdsWithinIio.mul_const", "code": "theorem Filter.TendstoNhdsWithinIio.mul_const [MulPosStrictMono \ud835\udd5c] [MulPosReflectLT \ud835\udd5c]\n    (h : Tendsto f l (\ud835\udcdd[<] c)) : Tendsto (fun a => f a * b) l (\ud835\udcdd[<] (c * b))", "start": [188, 1], "end": [192, 76], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.units", "code": "@[to_additive (attr := simps)\n  \"Construct an additive unit from limits of additive units and their negatives.\"]\ndef Filter.Tendsto.units [TopologicalSpace N] [Monoid N] [ContinuousMul N] [T2Space N]\n    {f : \u03b9 \u2192 N\u02e3} {r\u2081 r\u2082 : N} {l : Filter \u03b9} [l.NeBot] (h\u2081 : Tendsto (fun x => \u2191(f x)) l (\ud835\udcdd r\u2081))\n    (h\u2082 : Tendsto (fun x => \u2191(f x)\u207b\u00b9) l (\ud835\udcdd r\u2082)) : N\u02e3\n    where\n  val := r\u2081\n  inv := r\u2082\n  val_inv := by\n    symm\n    simpa using h\u2081.mul h\u2082\n  inv_val := by\n    symm\n    simpa using h\u2082.mul h\u2081", "start": [197, 1], "end": [211, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.mul", "code": "@[to_additive]\ntheorem ContinuousAt.mul {f g : X \u2192 M} {x : X} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x * g x) x", "start": [215, 1], "end": [218, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.mul", "code": "@[to_additive]\ntheorem ContinuousWithinAt.mul {f g : X \u2192 M} {s : Set X} {x : X} (hf : ContinuousWithinAt f s x)\n    (hg : ContinuousWithinAt g s x) : ContinuousWithinAt (fun x => f x * g x) s x", "start": [222, 1], "end": [225, 27], "kind": "commanddeclaration"}, {"full_name": "Prod.continuousMul", "code": "@[to_additive]\ninstance Prod.continuousMul [TopologicalSpace N] [Mul N] [ContinuousMul N] :\n    ContinuousMul (M \u00d7 N) :=\n  \u27e8(continuous_fst.fst'.mul continuous_fst.snd').prod_mk\n      (continuous_snd.fst'.mul continuous_snd.snd')\u27e9", "start": [229, 1], "end": [233, 53], "kind": "commanddeclaration"}, {"full_name": "Pi.continuousMul", "code": "@[to_additive]\ninstance Pi.continuousMul {C : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (C i)] [\u2200 i, Mul (C i)]\n    [\u2200 i, ContinuousMul (C i)] : ContinuousMul (\u2200 i, C i) where\n  continuous_mul :=\n    continuous_pi fun i => (continuous_apply i).fst'.mul (continuous_apply i).snd'", "start": [235, 1], "end": [239, 83], "kind": "commanddeclaration"}, {"full_name": "Pi.continuousMul'", "code": "@[to_additive \"A version of `Pi.continuousAdd` for non-dependent functions. It is needed\nbecause sometimes Lean fails to use `Pi.continuousAdd` for non-dependent functions.\"]\ninstance Pi.continuousMul' : ContinuousMul (\u03b9 \u2192 M) :=\n  Pi.continuousMul", "start": [243, 1], "end": [248, 19], "kind": "commanddeclaration"}, {"full_name": "continuousMul_of_discreteTopology", "code": "@[to_additive]\ninstance (priority := 100) continuousMul_of_discreteTopology [TopologicalSpace N] [Mul N]\n    [DiscreteTopology N] : ContinuousMul N :=\n  \u27e8continuous_of_discreteTopology\u27e9", "start": [252, 1], "end": [255, 35], "kind": "commanddeclaration"}, {"full_name": "ContinuousMul.of_nhds_one", "code": "@[to_additive]\ntheorem ContinuousMul.of_nhds_one {M : Type u} [Monoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : M \u2192 M \u2192 M)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) <| \ud835\udcdd 1)\n    (hleft : \u2200 x\u2080 : M, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n    (hright : \u2200 x\u2080 : M, \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)) : ContinuousMul M", "start": [263, 1], "end": [291, 82], "kind": "commanddeclaration"}, {"full_name": "continuousMul_of_comm_of_nhds_one", "code": "@[to_additive]\ntheorem continuousMul_of_comm_of_nhds_one (M : Type u) [CommMonoid M] [TopologicalSpace M]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : M \u2192 M \u2192 M)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : M, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)) : ContinuousMul M", "start": [295, 1], "end": [301, 31], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_map_one", "code": "@[to_additive]\ntheorem isClosed_setOf_map_one [One M\u2081] [One M\u2082] : IsClosed { f : M\u2081 \u2192 M\u2082 | f 1 = 1 }", "start": [311, 1], "end": [313, 52], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_map_mul", "code": "@[to_additive]\ntheorem isClosed_setOf_map_mul [Mul M\u2081] [Mul M\u2082] [ContinuousMul M\u2082] :\n    IsClosed { f : M\u2081 \u2192 M\u2082 | \u2200 x y, f (x * y) = f x * f y }", "start": [317, 1], "end": [327, 26], "kind": "commanddeclaration"}, {"full_name": "monoidHomOfMemClosureRangeCoe", "code": "@[to_additive (attr := simps (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism `M\u2081 \u2192+ M\u2082` from a function `f`\nand a proof that it belongs to the closure of the range of the coercion from `M\u2081 \u2192+ M\u2082` (or another\ntype of bundled homomorphisms that has an `AddMonoidHomClass` instance) to `M\u2081 \u2192 M\u2082`.\"]\ndef monoidHomOfMemClosureRangeCoe (f : M\u2081 \u2192 M\u2082)\n    (hf : f \u2208 closure (range fun (f : F) (x : M\u2081) => f x)) : M\u2081 \u2192* M\u2082\n    where\n  toFun := f\n  map_one' := (isClosed_setOf_map_one M\u2081 M\u2082).closure_subset_iff.2 (range_subset_iff.2 map_one) hf\n  map_mul' := (isClosed_setOf_map_mul M\u2081 M\u2082).closure_subset_iff.2 (range_subset_iff.2 map_mul) hf", "start": [337, 1], "end": [349, 98], "kind": "commanddeclaration"}, {"full_name": "monoidHomOfTendsto", "code": "@[to_additive (attr := simps! (config := .asFn))\n  \"Construct a bundled additive monoid homomorphism from a pointwise limit of additive\nmonoid homomorphisms\"]\ndef monoidHomOfTendsto (f : M\u2081 \u2192 M\u2082) (g : \u03b1 \u2192 F) [l.NeBot]\n    (h : Tendsto (fun a x => g a x) l (\ud835\udcdd f)) : M\u2081 \u2192* M\u2082 :=\n  monoidHomOfMemClosureRangeCoe f <|\n    mem_closure_of_tendsto h <| eventually_of_forall fun _ => mem_range_self _", "start": [353, 1], "end": [360, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.isClosed_range_coe", "code": "@[to_additive]\ntheorem MonoidHom.isClosed_range_coe : IsClosed (Set.range ((\u2191) : (M\u2081 \u2192* M\u2082) \u2192 M\u2081 \u2192 M\u2082))", "start": [366, 1], "end": [368, 83], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousMul", "code": "@[to_additive]\ntheorem Inducing.continuousMul {M N F : Type*} [Mul M] [Mul N] [MulHomClass F M N]\n    [TopologicalSpace M] [TopologicalSpace N] [ContinuousMul N] (f : F) (hf : Inducing f) :\n    ContinuousMul M", "start": [374, 1], "end": [379, 87], "kind": "commanddeclaration"}, {"full_name": "continuousMul_induced", "code": "@[to_additive]\ntheorem continuousMul_induced {M N F : Type*} [Mul M] [Mul N] [MulHomClass F M N]\n    [TopologicalSpace N] [ContinuousMul N] (f : F) : @ContinuousMul M (induced f \u2039_\u203a) _", "start": [383, 1], "end": [387, 33], "kind": "commanddeclaration"}, {"full_name": "Subsemigroup.continuousMul", "code": "@[to_additive]\ninstance Subsemigroup.continuousMul [TopologicalSpace M] [Semigroup M] [ContinuousMul M]\n    (S : Subsemigroup M) : ContinuousMul S :=\n  Inducing.continuousMul ({ toFun := (\u2191), map_mul' := fun _ _ => rfl} : MulHom S M) \u27e8rfl\u27e9", "start": [391, 1], "end": [394, 90], "kind": "commanddeclaration"}, {"full_name": "Submonoid.continuousMul", "code": "@[to_additive]\ninstance Submonoid.continuousMul [TopologicalSpace M] [Monoid M] [ContinuousMul M]\n    (S : Submonoid M) : ContinuousMul S :=\n  S.toSubsemigroup.continuousMul", "start": [398, 1], "end": [401, 33], "kind": "commanddeclaration"}, {"full_name": "Submonoid.top_closure_mul_self_subset", "code": "@[to_additive]\ntheorem Submonoid.top_closure_mul_self_subset (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s \u2286 _root_.closure s", "start": [409, 1], "end": [413, 75], "kind": "commanddeclaration"}, {"full_name": "Submonoid.top_closure_mul_self_eq", "code": "@[to_additive]\ntheorem Submonoid.top_closure_mul_self_eq (s : Submonoid M) :\n    _root_.closure (s : Set M) * _root_.closure s = _root_.closure s", "start": [417, 1], "end": [421, 59], "kind": "commanddeclaration"}, {"full_name": "Submonoid.topologicalClosure", "code": "@[to_additive \"The (topological-space) closure of an additive submonoid of a space `M` with\n`ContinuousAdd` is itself an additive submonoid.\"]\ndef Submonoid.topologicalClosure (s : Submonoid M) : Submonoid M where\n  carrier := _root_.closure (s : Set M)\n  one_mem' := _root_.subset_closure s.one_mem\n  mul_mem' ha hb := s.top_closure_mul_self_subset \u27e8_, _, ha, hb, rfl\u27e9", "start": [425, 1], "end": [432, 70], "kind": "commanddeclaration"}, {"full_name": "Submonoid.coe_topologicalClosure", "code": "@[to_additive]\ntheorem Submonoid.coe_topologicalClosure (s : Submonoid M) :\n    (s.topologicalClosure : Set M) = _root_.closure (s : Set M)", "start": [437, 1], "end": [439, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.le_topologicalClosure", "code": "@[to_additive]\ntheorem Submonoid.le_topologicalClosure (s : Submonoid M) : s \u2264 s.topologicalClosure", "start": [441, 1], "end": [443, 24], "kind": "commanddeclaration"}, {"full_name": "Submonoid.isClosed_topologicalClosure", "code": "@[to_additive]\ntheorem Submonoid.isClosed_topologicalClosure (s : Submonoid M) :\n    IsClosed (s.topologicalClosure : Set M)", "start": [447, 1], "end": [449, 64], "kind": "commanddeclaration"}, {"full_name": "Submonoid.topologicalClosure_minimal", "code": "@[to_additive]\ntheorem Submonoid.topologicalClosure_minimal (s : Submonoid M) {t : Submonoid M} (h : s \u2264 t)\n    (ht : IsClosed (t : Set M)) : s.topologicalClosure \u2264 t", "start": [453, 1], "end": [455, 83], "kind": "commanddeclaration"}, {"full_name": "Submonoid.commMonoidTopologicalClosure", "code": "@[to_additive \"If a submonoid of an additive topological monoid is commutative, then so is its\ntopological closure.\"]\ndef Submonoid.commMonoidTopologicalClosure [T2Space M] (s : Submonoid M)\n    (hs : \u2200 x y : s, x * y = y * x) : CommMonoid s.topologicalClosure :=\n  { s.topologicalClosure.toMonoid with\n    mul_comm :=\n      have : \u2200 x \u2208 s, \u2200 y \u2208 s, x * y = y * x := fun x hx y hy =>\n        congr_arg Subtype.val (hs \u27e8x, hx\u27e9 \u27e8y, hy\u27e9)\n      fun \u27e8x, hx\u27e9 \u27e8y, hy\u27e9 =>\n      Subtype.ext <|\n        eqOn_closure\u2082 this continuous_mul (continuous_snd.mul continuous_fst) x hx y hy }", "start": [459, 1], "end": [470, 90], "kind": "commanddeclaration"}, {"full_name": "exists_open_nhds_one_split", "code": "@[to_additive exists_open_nhds_zero_half]\ntheorem exists_open_nhds_one_split {s : Set M} (hs : s \u2208 \ud835\udcdd (1 : M)) :\n    \u2203 V : Set M, IsOpen V \u2227 (1 : M) \u2208 V \u2227 \u2200 v \u2208 V, \u2200 w \u2208 V, v * w \u2208 s", "start": [474, 1], "end": [479, 61], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_one_split", "code": "@[to_additive exists_nhds_zero_half]\ntheorem exists_nhds_one_split {s : Set M} (hs : s \u2208 \ud835\udcdd (1 : M)) :\n    \u2203 V \u2208 \ud835\udcdd (1 : M), \u2200 v \u2208 V, \u2200 w \u2208 V, v * w \u2208 s", "start": [483, 1], "end": [487, 33], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_one_split4", "code": "@[to_additive exists_nhds_zero_quarter]\ntheorem exists_nhds_one_split4 {u : Set M} (hu : u \u2208 \ud835\udcdd (1 : M)) :\n    \u2203 V \u2208 \ud835\udcdd (1 : M), \u2200 {v w s t}, v \u2208 V \u2192 w \u2208 V \u2192 s \u2208 V \u2192 t \u2208 V \u2192 v * w * s * t \u2208 u", "start": [491, 1], "end": [498, 75], "kind": "commanddeclaration"}, {"full_name": "exists_open_nhds_one_mul_subset", "code": "@[to_additive \"Given an open neighborhood `U` of `0` there is an open neighborhood `V` of `0`\n  such that `V + V \u2286 U`.\"]\ntheorem exists_open_nhds_one_mul_subset {U : Set M} (hU : U \u2208 \ud835\udcdd (1 : M)) :\n    \u2203 V : Set M, IsOpen V \u2227 (1 : M) \u2208 V \u2227 V * V \u2286 U", "start": [502, 1], "end": [511, 21], "kind": "commanddeclaration"}, {"full_name": "IsCompact.mul", "code": "@[to_additive]\ntheorem IsCompact.mul {s t : Set M} (hs : IsCompact s) (ht : IsCompact t) : IsCompact (s * t)", "start": [515, 1], "end": [518, 42], "kind": "commanddeclaration"}, {"full_name": "tendsto_list_prod", "code": "@[to_additive]\ntheorem tendsto_list_prod {f : \u03b9 \u2192 \u03b1 \u2192 M} {x : Filter \u03b1} {a : \u03b9 \u2192 M} :\n    \u2200 l : List \u03b9,\n      (\u2200 i \u2208 l, Tendsto (f i) x (\ud835\udcdd (a i))) \u2192\n        Tendsto (fun b => (l.map fun c => f c b).prod) x (\ud835\udcdd (l.map a).prod)", "start": [522, 1], "end": [532, 74], "kind": "commanddeclaration"}, {"full_name": "continuous_list_prod", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_list_prod {f : \u03b9 \u2192 X \u2192 M} (l : List \u03b9) (h : \u2200 i \u2208 l, Continuous (f i)) :\n    Continuous fun a => (l.map fun i => f i a).prod", "start": [536, 1], "end": [540, 77], "kind": "commanddeclaration"}, {"full_name": "continuousOn_list_prod", "code": "@[to_additive]\ntheorem continuousOn_list_prod {f : \u03b9 \u2192 X \u2192 M} (l : List \u03b9) {t : Set X}\n    (h : \u2200 i \u2208 l, ContinuousOn (f i) t) :\n    ContinuousOn (fun a => (l.map fun i => f i a).prod) t", "start": [544, 1], "end": [553, 10], "kind": "commanddeclaration"}, {"full_name": "continuous_pow", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_pow : \u2200 n : \u2115, Continuous fun a : M => a ^ n", "start": [557, 1], "end": [562, 47], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.continuousConstSMul_nat", "code": "instance AddMonoid.continuousConstSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousConstSMul \u2115 A :=\n  \u27e8continuous_nsmul\u27e9", "start": [566, 1], "end": [568, 21], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.continuousSMul_nat", "code": "instance AddMonoid.continuousSMul_nat {A} [AddMonoid A] [TopologicalSpace A]\n    [ContinuousAdd A] : ContinuousSMul \u2115 A :=\n  \u27e8continuous_prod_of_discrete_left.mpr continuous_nsmul\u27e9", "start": [571, 1], "end": [573, 58], "kind": "commanddeclaration"}, {"full_name": "Continuous.pow", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.pow {f : X \u2192 M} (h : Continuous f) (n : \u2115) : Continuous fun b => f b ^ n", "start": [576, 1], "end": [578, 28], "kind": "commanddeclaration"}, {"full_name": "continuousOn_pow", "code": "@[to_additive]\ntheorem continuousOn_pow {s : Set M} (n : \u2115) : ContinuousOn (fun (x : M) => x ^ n) s", "start": [582, 1], "end": [584, 34], "kind": "commanddeclaration"}, {"full_name": "continuousAt_pow", "code": "@[to_additive]\ntheorem continuousAt_pow (x : M) (n : \u2115) : ContinuousAt (fun (x : M) => x ^ n) x", "start": [588, 1], "end": [590, 34], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.pow", "code": "@[to_additive]\ntheorem Filter.Tendsto.pow {l : Filter \u03b1} {f : \u03b1 \u2192 M} {x : M} (hf : Tendsto f l (\ud835\udcdd x)) (n : \u2115) :\n    Tendsto (fun x => f x ^ n) l (\ud835\udcdd (x ^ n))", "start": [594, 1], "end": [597, 41], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.pow", "code": "@[to_additive]\ntheorem ContinuousWithinAt.pow {f : X \u2192 M} {x : X} {s : Set X} (hf : ContinuousWithinAt f s x)\n    (n : \u2115) : ContinuousWithinAt (fun x => f x ^ n) s x", "start": [601, 1], "end": [604, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.pow", "code": "@[to_additive]\ntheorem ContinuousAt.pow {f : X \u2192 M} {x : X} (hf : ContinuousAt f x) (n : \u2115) :\n    ContinuousAt (fun x => f x ^ n) x", "start": [608, 1], "end": [611, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.pow", "code": "@[to_additive]\ntheorem ContinuousOn.pow {f : X \u2192 M} {s : Set X} (hf : ContinuousOn f s) (n : \u2115) :\n    ContinuousOn (fun x => f x ^ n) s", "start": [615, 1], "end": [617, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_cocompact_mul_left", "code": "theorem Filter.tendsto_cocompact_mul_left {a b : M} (ha : b * a = 1) :\n    Filter.Tendsto (fun x : M => a * x) (Filter.cocompact M) (Filter.cocompact M)", "start": [621, 1], "end": [627, 26], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_cocompact_mul_right", "code": "theorem Filter.tendsto_cocompact_mul_right {a b : M} (ha : a * b = 1) :\n    Filter.Tendsto (fun x : M => x * a) (Filter.cocompact M) (Filter.cocompact M)", "start": [635, 1], "end": [641, 26], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.continuousConstSMul", "code": "@[to_additive \"If `R` acts on `A` via `A`, then continuous addition implies\ncontinuous affine addition by constants.\"]\ninstance (priority := 100) IsScalarTower.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [IsScalarTower R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [\u2190 smul_one_mul q (_ : A)]\n    exact continuous_const.mul continuous_id", "start": [645, 1], "end": [655, 45], "kind": "commanddeclaration"}, {"full_name": "SMulCommClass.continuousConstSMul", "code": "@[to_additive \"If the action of `R` on `A` commutes with left-addition, then\ncontinuous addition implies continuous affine addition by constants.\n\nNotably, this instances applies when `R = A\u1d43\u1d52\u1d56`.\"]\ninstance (priority := 100) SMulCommClass.continuousConstSMul {R A : Type*} [Monoid A] [SMul R A]\n    [SMulCommClass R A A] [TopologicalSpace A] [ContinuousMul A] : ContinuousConstSMul R A where\n  continuous_const_smul q := by\n    simp (config := { singlePass := true }) only [\u2190 mul_smul_one q (_ : A)]\n    exact continuous_id.mul continuous_const", "start": [659, 1], "end": [671, 45], "kind": "commanddeclaration"}, {"full_name": "Continuous.units_map", "code": "@[to_additive]\ntheorem Continuous.units_map [Monoid M] [Monoid N] [TopologicalSpace M] [TopologicalSpace N]\n    (f : M \u2192* N) (hf : Continuous f) : Continuous (Units.map f)", "start": [707, 1], "end": [710, 90], "kind": "commanddeclaration"}, {"full_name": "Submonoid.mem_nhds_one", "code": "@[to_additive]\ntheorem Submonoid.mem_nhds_one (S : Submonoid M) (oS : IsOpen (S : Set M)) :\n    (S : Set M) \u2208 \ud835\udcdd (1 : M)", "start": [718, 1], "end": [721, 31], "kind": "commanddeclaration"}, {"full_name": "tendsto_multiset_prod", "code": "@[to_additive]\ntheorem tendsto_multiset_prod {f : \u03b9 \u2192 \u03b1 \u2192 M} {x : Filter \u03b1} {a : \u03b9 \u2192 M} (s : Multiset \u03b9) :\n    (\u2200 i \u2208 s, Tendsto (f i) x (\ud835\udcdd (a i))) \u2192\n      Tendsto (fun b => (s.map fun c => f c b).prod) x (\ud835\udcdd (s.map a).prod)", "start": [727, 1], "end": [732, 34], "kind": "commanddeclaration"}, {"full_name": "tendsto_finset_prod", "code": "@[to_additive]\ntheorem tendsto_finset_prod {f : \u03b9 \u2192 \u03b1 \u2192 M} {x : Filter \u03b1} {a : \u03b9 \u2192 M} (s : Finset \u03b9) :\n    (\u2200 i \u2208 s, Tendsto (f i) x (\ud835\udcdd (a i))) \u2192\n      Tendsto (fun b => \u220f c in s, f c b) x (\ud835\udcdd (\u220f c in s, a c))", "start": [736, 1], "end": [740, 26], "kind": "commanddeclaration"}, {"full_name": "continuous_multiset_prod", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_multiset_prod {f : \u03b9 \u2192 X \u2192 M} (s : Multiset \u03b9) :\n    (\u2200 i \u2208 s, Continuous (f i)) \u2192 Continuous fun a => (s.map fun i => f i a).prod", "start": [744, 1], "end": [748, 37], "kind": "commanddeclaration"}, {"full_name": "continuousOn_multiset_prod", "code": "@[to_additive]\ntheorem continuousOn_multiset_prod {f : \u03b9 \u2192 X \u2192 M} (s : Multiset \u03b9) {t : Set X} :\n    (\u2200 i \u2208 s, ContinuousOn (f i) t) \u2192 ContinuousOn (fun a => (s.map fun i => f i a).prod) t", "start": [752, 1], "end": [756, 39], "kind": "commanddeclaration"}, {"full_name": "continuous_finset_prod", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_finset_prod {f : \u03b9 \u2192 X \u2192 M} (s : Finset \u03b9) :\n    (\u2200 i \u2208 s, Continuous (f i)) \u2192 Continuous fun a => \u220f i in s, f i a", "start": [760, 1], "end": [763, 29], "kind": "commanddeclaration"}, {"full_name": "continuousOn_finset_prod", "code": "@[to_additive]\ntheorem continuousOn_finset_prod {f : \u03b9 \u2192 X \u2192 M} (s : Finset \u03b9) {t : Set X} :\n    (\u2200 i \u2208 s, ContinuousOn (f i) t) \u2192 ContinuousOn (fun a => \u220f i in s, f i a) t", "start": [767, 1], "end": [770, 31], "kind": "commanddeclaration"}, {"full_name": "eventuallyEq_prod", "code": "@[to_additive]\ntheorem eventuallyEq_prod {X M : Type*} [CommMonoid M] {s : Finset \u03b9} {l : Filter X}\n    {f g : \u03b9 \u2192 X \u2192 M} (hs : \u2200 i \u2208 s, f i =\u1da0[l] g i) : \u220f i in s, f i =\u1da0[l] \u220f i in s, g i", "start": [774, 1], "end": [780, 58], "kind": "commanddeclaration"}, {"full_name": "LocallyFinite.exists_finset_mulSupport", "code": "@[to_additive]\ntheorem LocallyFinite.exists_finset_mulSupport {M : Type*} [CommMonoid M] {f : \u03b9 \u2192 X \u2192 M}\n    (hf : LocallyFinite fun i => mulSupport <| f i) (x\u2080 : X) :\n    \u2203 I : Finset \u03b9, \u2200\u1da0 x in \ud835\udcdd x\u2080, (mulSupport fun i => f i x) \u2286 I", "start": [786, 1], "end": [793, 20], "kind": "commanddeclaration"}, {"full_name": "finprod_eventually_eq_prod", "code": "@[to_additive]\ntheorem finprod_eventually_eq_prod {M : Type*} [CommMonoid M] {f : \u03b9 \u2192 X \u2192 M}\n    (hf : LocallyFinite fun i => mulSupport (f i)) (x : X) :\n    \u2203 s : Finset \u03b9, \u2200\u1da0 y in \ud835\udcdd x, \u220f\u1da0 i, f i y = \u220f i in s, f i y", "start": [797, 1], "end": [802, 84], "kind": "commanddeclaration"}, {"full_name": "continuous_finprod", "code": "@[to_additive]\ntheorem continuous_finprod {f : \u03b9 \u2192 X \u2192 M} (hc : \u2200 i, Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) : Continuous fun x => \u220f\u1da0 i, f i x", "start": [806, 1], "end": [812, 61], "kind": "commanddeclaration"}, {"full_name": "continuous_finprod_cond", "code": "@[to_additive]\ntheorem continuous_finprod_cond {f : \u03b9 \u2192 X \u2192 M} {p : \u03b9 \u2192 Prop} (hc : \u2200 i, p i \u2192 Continuous (f i))\n    (hf : LocallyFinite fun i => mulSupport (f i)) :\n    Continuous fun x => \u220f\u1da0 (i) (_ : p i), f i x", "start": [816, 1], "end": [821, 89], "kind": "commanddeclaration"}, {"full_name": "continuousMul_sInf", "code": "@[to_additive]\ntheorem continuousMul_sInf {ts : Set (TopologicalSpace M)}\n    (h : \u2200 t \u2208 ts, @ContinuousMul M t _) : @ContinuousMul M (sInf ts) _", "start": [837, 1], "end": [843, 84], "kind": "commanddeclaration"}, {"full_name": "continuousMul_iInf", "code": "@[to_additive]\ntheorem continuousMul_iInf {ts : \u03b9' \u2192 TopologicalSpace M}\n    (h' : \u2200 i, @ContinuousMul M (ts i) _) : @ContinuousMul M (\u2a05 i, ts i) _", "start": [847, 1], "end": [851, 57], "kind": "commanddeclaration"}, {"full_name": "continuousMul_inf", "code": "@[to_additive]\ntheorem continuousMul_inf {t\u2081 t\u2082 : TopologicalSpace M} (h\u2081 : @ContinuousMul M t\u2081 _)\n    (h\u2082 : @ContinuousMul M t\u2082 _) : @ContinuousMul M (t\u2081 \u2293 t\u2082) _", "start": [855, 1], "end": [860, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mulRight", "code": "@[to_additive \"The continuous map `fun y => y + x`\"]\nprotected def mulRight (x : X) : C(X, X) :=\n  mk _ (continuous_mul_right x)", "start": [870, 1], "end": [873, 32], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_mulRight", "code": "@[to_additive (attr := simp)]\ntheorem coe_mulRight (x : X) : \u21d1(ContinuousMap.mulRight x) = fun y => y * x", "start": [877, 1], "end": [879, 6], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.mulLeft", "code": "@[to_additive \"The continuous map `fun y => x + y`\"]\nprotected def mulLeft (x : X) : C(X, X) :=\n  mk _ (continuous_mul_left x)", "start": [883, 1], "end": [886, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousMap.coe_mulLeft", "code": "@[to_additive (attr := simp)]\ntheorem coe_mulLeft (x : X) : \u21d1(ContinuousMap.mulLeft x) = fun y => x * y", "start": [890, 1], "end": [892, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/NatIso.lean", "imports": ["Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/CategoryTheory/Iso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Iso.app", "code": "@[simps, pp_dot]\ndef app {F G : C \u2964 D} (\u03b1 : F \u2245 G) (X : C) :\n    F.obj X \u2245 G.obj X where\n  hom := \u03b1.hom.app X\n  inv := \u03b1.inv.app X\n  hom_inv_id := by rw [\u2190 comp_app, Iso.hom_inv_id]; rfl\n  inv_hom_id := by rw [\u2190 comp_app, Iso.inv_hom_id]; rfl", "start": [50, 1], "end": [58, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.hom_inv_id_app", "code": "@[reassoc (attr := simp)]\ntheorem hom_inv_id_app {F G : C \u2964 D} (\u03b1 : F \u2245 G) (X : C) :\n    \u03b1.hom.app X \u226b \u03b1.inv.app X = \ud835\udfd9 (F.obj X)", "start": [63, 1], "end": [66, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.inv_hom_id_app", "code": "@[reassoc (attr := simp)]\ntheorem inv_hom_id_app {F G : C \u2964 D} (\u03b1 : F \u2245 G) (X : C) :\n    \u03b1.inv.app X \u226b \u03b1.hom.app X = \ud835\udfd9 (G.obj X)", "start": [70, 1], "end": [73, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.trans_app", "code": "@[simp]\ntheorem trans_app {F G H : C \u2964 D} (\u03b1 : F \u2245 G) (\u03b2 : G \u2245 H) (X : C) :\n    (\u03b1 \u226a\u226b \u03b2).app X = \u03b1.app X \u226a\u226b \u03b2.app X", "start": [83, 1], "end": [86, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.app_hom", "code": "theorem app_hom {F G : C \u2964 D} (\u03b1 : F \u2245 G) (X : C) : (\u03b1.app X).hom = \u03b1.hom.app X", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.app_inv", "code": "theorem app_inv {F G : C \u2964 D} (\u03b1 : F \u2245 G) (X : C) : (\u03b1.app X).inv = \u03b1.inv.app X", "start": [93, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.hom_app_isIso", "code": "instance hom_app_isIso (\u03b1 : F \u2245 G) (X : C) : IsIso (\u03b1.hom.app X) :=\n  \u27e8\u27e8\u03b1.inv.app X,\n    \u27e8by rw [\u2190 comp_app, Iso.hom_inv_id, \u2190 id_app], by rw [\u2190 comp_app, Iso.inv_hom_id, \u2190 id_app]\u27e9\u27e9\u27e9", "start": [99, 1], "end": [101, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.inv_app_isIso", "code": "instance inv_app_isIso (\u03b1 : F \u2245 G) (X : C) : IsIso (\u03b1.inv.app X) :=\n  \u27e8\u27e8\u03b1.hom.app X,\n    \u27e8by rw [\u2190 comp_app, Iso.inv_hom_id, \u2190 id_app], by rw [\u2190 comp_app, Iso.hom_inv_id, \u2190 id_app]\u27e9\u27e9\u27e9", "start": [104, 1], "end": [106, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_hom_left", "code": "@[simp]\ntheorem cancel_natIso_hom_left {X : C} {Z : D} (g g' : G.obj X \u27f6 Z) :\n    \u03b1.hom.app X \u226b g = \u03b1.hom.app X \u226b g' \u2194 g = g'", "start": [125, 1], "end": [127, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_inv_left", "code": "@[simp]\ntheorem cancel_natIso_inv_left {X : C} {Z : D} (g g' : F.obj X \u27f6 Z) :\n    \u03b1.inv.app X \u226b g = \u03b1.inv.app X \u226b g' \u2194 g = g'", "start": [130, 1], "end": [132, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_hom_right", "code": "@[simp]\ntheorem cancel_natIso_hom_right {X : D} {Y : C} (f f' : X \u27f6 F.obj Y) :\n    f \u226b \u03b1.hom.app Y = f' \u226b \u03b1.hom.app Y \u2194 f = f'", "start": [135, 1], "end": [137, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_inv_right", "code": "@[simp]\ntheorem cancel_natIso_inv_right {X : D} {Y : C} (f f' : X \u27f6 G.obj Y) :\n    f \u226b \u03b1.inv.app Y = f' \u226b \u03b1.inv.app Y \u2194 f = f'", "start": [140, 1], "end": [142, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_hom_right_assoc", "code": "@[simp]\ntheorem cancel_natIso_hom_right_assoc {W X X' : D} {Y : C} (f : W \u27f6 X) (g : X \u27f6 F.obj Y)\n    (f' : W \u27f6 X') (g' : X' \u27f6 F.obj Y) :\n    f \u226b g \u226b \u03b1.hom.app Y = f' \u226b g' \u226b \u03b1.hom.app Y \u2194 f \u226b g = f' \u226b g'", "start": [145, 1], "end": [149, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.cancel_natIso_inv_right_assoc", "code": "@[simp]\ntheorem cancel_natIso_inv_right_assoc {W X X' : D} {Y : C} (f : W \u27f6 X) (g : X \u27f6 G.obj Y)\n    (f' : W \u27f6 X') (g' : X' \u27f6 G.obj Y) :\n    f \u226b g \u226b \u03b1.inv.app Y = f' \u226b g' \u226b \u03b1.inv.app Y \u2194 f \u226b g = f' \u226b g'", "start": [152, 1], "end": [156, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.inv_inv_app", "code": "@[simp]\ntheorem inv_inv_app {F G : C \u2964 D} (e : F \u2245 G) (X : C) : inv (e.inv.app X) = e.hom.app X", "start": [159, 1], "end": [161, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.naturality_1", "code": "theorem naturality_1 (\u03b1 : F \u2245 G) (f : X \u27f6 Y) : \u03b1.inv.app X \u226b F.map f \u226b \u03b1.hom.app Y = G.map f", "start": [168, 1], "end": [169, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.naturality_2", "code": "theorem naturality_2 (\u03b1 : F \u2245 G) (f : X \u27f6 Y) : \u03b1.hom.app X \u226b G.map f \u226b \u03b1.inv.app Y = F.map f", "start": [172, 1], "end": [173, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.naturality_1'", "code": "theorem naturality_1' (\u03b1 : F \u27f6 G) (f : X \u27f6 Y) {_ : IsIso (\u03b1.app X)} :\n    inv (\u03b1.app X) \u226b F.map f \u226b \u03b1.app Y = G.map f", "start": [176, 1], "end": [177, 59], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.naturality_2'", "code": "@[reassoc (attr := simp)]\ntheorem naturality_2' (\u03b1 : F \u27f6 G) (f : X \u27f6 Y) {_ : IsIso (\u03b1.app Y)} :\n    \u03b1.app X \u226b G.map f \u226b inv (\u03b1.app Y) = F.map f", "start": [180, 1], "end": [183, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.isIso_app_of_isIso", "code": "instance isIso_app_of_isIso (\u03b1 : F \u27f6 G) [IsIso \u03b1] (X) : IsIso (\u03b1.app X) :=\n  \u27e8\u27e8(inv \u03b1).app X,\n      \u27e8congr_fun (congr_arg NatTrans.app (IsIso.hom_inv_id \u03b1)) X,\n        congr_fun (congr_arg NatTrans.app (IsIso.inv_hom_id \u03b1)) X\u27e9\u27e9\u27e9", "start": [187, 1], "end": [192, 69], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.isIso_inv_app", "code": "@[simp]\ntheorem isIso_inv_app (\u03b1 : F \u27f6 G) {_ : IsIso \u03b1} (X) : (inv \u03b1).app X = inv (\u03b1.app X)", "start": [195, 1], "end": [202, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.inv_map_inv_app", "code": "@[simp]\ntheorem inv_map_inv_app (F : C \u2964 D \u2964 E) {X Y : C} (e : X \u2245 Y) (Z : D) :\n    inv ((F.map e.inv).app Z) = (F.map e.hom).app Z", "start": [205, 1], "end": [208, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.ofComponents", "code": "@[simps]\ndef ofComponents (app : \u2200 X : C, F.obj X \u2245 G.obj X)\n    (naturality : \u2200 {X Y : C} (f : X \u27f6 Y),\n      F.map f \u226b (app Y).hom = (app X).hom \u226b G.map f := by aesop_cat) :\n    F \u2245 G where\n  hom := { app := fun X => (app X).hom }\n  inv :=\n    { app := fun X => (app X).inv,\n      naturality := fun X Y f => by\n        have h := congr_arg (fun f => (app X).inv \u226b f \u226b (app Y).inv) (naturality f).symm\n        simp only [Iso.inv_hom_id_assoc, Iso.hom_inv_id, assoc, comp_id, cancel_mono] at h\n        exact h }", "start": [211, 1], "end": [225, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.ofComponents.app", "code": "@[simp]\ntheorem ofComponents.app (app' : \u2200 X : C, F.obj X \u2245 G.obj X) (naturality) (X) :\n    (ofComponents app' naturality).app X = app' X", "start": [230, 1], "end": [232, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.isIso_of_isIso_app", "code": "theorem isIso_of_isIso_app (\u03b1 : F \u27f6 G) [\u2200 X : C, IsIso (\u03b1.app X)] : IsIso \u03b1", "start": [236, 1], "end": [239, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.hcomp", "code": "@[simps]\ndef hcomp {F G : C \u2964 D} {H I : D \u2964 E} (\u03b1 : F \u2245 G) (\u03b2 : H \u2245 I) : F \u22d9 H \u2245 G \u22d9 I := by\n  refine' \u27e8\u03b1.hom \u25eb \u03b2.hom, \u03b1.inv \u25eb \u03b2.inv, _, _\u27e9\n  \u00b7 ext\n    rw [\u2190 NatTrans.exchange]\n    simp\n  ext; rw [\u2190 NatTrans.exchange]; simp", "start": [242, 1], "end": [249, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.isIso_map_iff", "code": "theorem isIso_map_iff {F\u2081 F\u2082 : C \u2964 D} (e : F\u2081 \u2245 F\u2082) {X Y : C} (f : X \u27f6 Y) :\n    IsIso (F\u2081.map f) \u2194 IsIso (F\u2082.map f)", "start": [254, 1], "end": [262, 86], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/DFinsupp.lean", "imports": ["Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DFinsupp.lmk", "code": "def lmk (s : Finset \u03b9) : (\u2200 i : (\u2191s : Set \u03b9), M i) \u2192\u2097[R] \u03a0\u2080 i, M i where\n  toFun := mk s\n  map_add' _ _ := mk_add\n  map_smul' c x := mk_smul c x", "start": [48, 1], "end": [52, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lsingle", "code": "def lsingle (i) : M i \u2192\u2097[R] \u03a0\u2080 i, M i :=\n  { DFinsupp.singleAddHom _ _ with\n    toFun := single i\n    map_smul' := single_smul }", "start": [55, 1], "end": [59, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lhom_ext", "code": "theorem lhom_ext \u2983\u03c6 \u03c8 : (\u03a0\u2080 i, M i) \u2192\u2097[R] N\u2984 (h : \u2200 i x, \u03c6 (single i x) = \u03c8 (single i x)) : \u03c6 = \u03c8", "start": [62, 1], "end": [64, 53], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lhom_ext'", "code": "@[ext 1100]\ntheorem lhom_ext' \u2983\u03c6 \u03c8 : (\u03a0\u2080 i, M i) \u2192\u2097[R] N\u2984 (h : \u2200 i, \u03c6.comp (lsingle i) = \u03c8.comp (lsingle i)) :\n    \u03c6 = \u03c8", "start": [67, 1], "end": [74, 46], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lapply", "code": "def lapply (i : \u03b9) : (\u03a0\u2080 i, M i) \u2192\u2097[R] M i where\n  toFun f := f i\n  map_add' f g := add_apply f g i\n  map_smul' c f := smul_apply c f i", "start": [77, 1], "end": [81, 36], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lmk_apply", "code": "@[simp, nolint simpNF]\ntheorem lmk_apply (s : Finset \u03b9) (x) : (lmk s : _ \u2192\u2097[R] \u03a0\u2080 i, M i) x = mk s x", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lsingle_apply", "code": "@[simp]\ntheorem lsingle_apply (i : \u03b9) (x : M i) : (lsingle i : (M i) \u2192\u2097[R] _) x = single i x", "start": [90, 1], "end": [92, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lapply_apply", "code": "@[simp]\ntheorem lapply_apply (i : \u03b9) (f : \u03a0\u2080 i, M i) : (lapply i : (\u03a0\u2080 i, M i) \u2192\u2097[R] _) f = f i", "start": [95, 1], "end": [97, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.addCommMonoidOfLinearMap", "code": "instance addCommMonoidOfLinearMap : AddCommMonoid (\u03a0\u2080 i : \u03b9, M i \u2192\u2097[R] N) :=\n  inferInstance", "start": [103, 1], "end": [107, 16], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.moduleOfLinearMap", "code": "instance moduleOfLinearMap [Semiring S] [Module S N] [SMulCommClass R S N] :\n    Module S (\u03a0\u2080 i : \u03b9, M i \u2192\u2097[R] N) :=\n  DFinsupp.module", "start": [110, 1], "end": [118, 18], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lsum", "code": "@[simps]\ndef lsum [Semiring S] [Module S N] [SMulCommClass R S N] :\n    (\u2200 i, M i \u2192\u2097[R] N) \u2243\u2097[S] (\u03a0\u2080 i, M i) \u2192\u2097[R] N where\n  toFun F :=\n    { toFun := sumAddHom fun i => (F i).toAddMonoidHom\n      map_add' := (DFinsupp.liftAddHom (\u03b2 := M) (fun (i : \u03b9) => (F i).toAddMonoidHom)).map_add\n      map_smul' := fun c f => by\n        dsimp\n        apply DFinsupp.induction f\n        \u00b7 rw [smul_zero, AddMonoidHom.map_zero, smul_zero]\n        \u00b7 intro a b f _ _ hf\n          rw [smul_add, AddMonoidHom.map_add, AddMonoidHom.map_add, smul_add, hf, \u2190 single_smul,\n            sumAddHom_single, sumAddHom_single, LinearMap.toAddMonoidHom_coe,\n            LinearMap.map_smul] }\n  invFun F i := F.comp (lsingle i)\n  left_inv F := by\n    ext\n    simp\n  right_inv F := by\n    refine DFinsupp.lhom_ext' (fun i \u21a6 ?_)\n    ext\n    simp\n  map_add' F G := by\n    refine DFinsupp.lhom_ext' (fun i \u21a6 ?_)\n    ext\n    simp\n  map_smul' c F := by\n    refine DFinsupp.lhom_ext' (fun i \u21a6 ?_)\n    ext\n    simp", "start": [132, 1], "end": [165, 9], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.lsum_single", "code": "theorem lsum_single [Semiring S] [Module S N] [SMulCommClass R S N] (F : \u2200 i, M i \u2192\u2097[R] N) (i)\n    (x : M i) : lsum S (M := M) F (single i x) = F i x", "start": [168, 1], "end": [172, 7], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange_smul", "code": "theorem mapRange_smul (f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i) (hf : \u2200 i, f i 0 = 0) (r : R)\n    (hf' : \u2200 i x, f i (r \u2022 x) = r \u2022 f i x) (g : \u03a0\u2080 i, \u03b2\u2081 i) :\n    mapRange f hf (r \u2022 g) = r \u2022 mapRange f hf g", "start": [191, 1], "end": [195, 61], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearMap", "code": "@[simps! apply]\ndef mapRange.linearMap (f : \u2200 i, \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i) : (\u03a0\u2080 i, \u03b2\u2081 i) \u2192\u2097[R] \u03a0\u2080 i, \u03b2\u2082 i :=\n  { mapRange.addMonoidHom fun i => (f i).toAddMonoidHom with\n    toFun := mapRange (fun i x => f i x) fun i => (f i).map_zero\n    map_smul' := fun r => mapRange_smul _ (fun i => (f i).map_zero) _ fun i => (f i).map_smul r }", "start": [198, 1], "end": [203, 98], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearMap_id", "code": "@[simp]\ntheorem mapRange.linearMap_id :\n    (mapRange.linearMap fun i => (LinearMap.id : \u03b2\u2082 i \u2192\u2097[R] _)) = LinearMap.id", "start": [206, 1], "end": [210, 19], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearMap_comp", "code": "theorem mapRange.linearMap_comp (f : \u2200 i, \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i) (f\u2082 : \u2200 i, \u03b2 i \u2192\u2097[R] \u03b2\u2081 i) :\n    (mapRange.linearMap fun i => (f i).comp (f\u2082 i)) =\n      (mapRange.linearMap f).comp (mapRange.linearMap f\u2082)", "start": [213, 1], "end": [217, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.sum_mapRange_index.linearMap", "code": "theorem sum_mapRange_index.linearMap [\u2200 (i : \u03b9) (x : \u03b2\u2081 i), Decidable (x \u2260 0)]\n    [\u2200 (i : \u03b9) (x : \u03b2\u2082 i), Decidable (x \u2260 0)] {f : \u2200 i, \u03b2\u2081 i \u2192\u2097[R] \u03b2\u2082 i} {h : \u2200 i, \u03b2\u2082 i \u2192\u2097[R] N}\n    {l : \u03a0\u2080 i, \u03b2\u2081 i} :\n    (DFinsupp.lsum \u2115 (M := \u03b2\u2082)) h (mapRange.linearMap f l)\n      = (DFinsupp.lsum \u2115 (M := \u03b2\u2081)) (fun i => (h i).comp (f i)) l", "start": [220, 1], "end": [226, 77], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearEquiv", "code": "@[simps apply]\ndef mapRange.linearEquiv (e : \u2200 i, \u03b2\u2081 i \u2243\u2097[R] \u03b2\u2082 i) : (\u03a0\u2080 i, \u03b2\u2081 i) \u2243\u2097[R] \u03a0\u2080 i, \u03b2\u2082 i :=\n  { mapRange.addEquiv fun i => (e i).toAddEquiv,\n    mapRange.linearMap fun i => (e i).toLinearMap with\n    toFun := mapRange (fun i x => e i x) fun i => (e i).map_zero\n    invFun := mapRange (fun i x => (e i).symm x) fun i => (e i).symm.map_zero }", "start": [229, 1], "end": [235, 80], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearEquiv_refl", "code": "@[simp]\ntheorem mapRange.linearEquiv_refl :\n    (mapRange.linearEquiv fun i => LinearEquiv.refl R (\u03b2\u2081 i)) = LinearEquiv.refl _ _", "start": [238, 1], "end": [241, 30], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearEquiv_trans", "code": "theorem mapRange.linearEquiv_trans (f : \u2200 i, \u03b2 i \u2243\u2097[R] \u03b2\u2081 i) (f\u2082 : \u2200 i, \u03b2\u2081 i \u2243\u2097[R] \u03b2\u2082 i) :\n    (mapRange.linearEquiv fun i => (f i).trans (f\u2082 i)) =\n      (mapRange.linearEquiv f).trans (mapRange.linearEquiv f\u2082)", "start": [244, 1], "end": [248, 67], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.mapRange.linearEquiv_symm", "code": "@[simp]\ntheorem mapRange.linearEquiv_symm (e : \u2200 i, \u03b2\u2081 i \u2243\u2097[R] \u03b2\u2082 i) :\n    (mapRange.linearEquiv e).symm = mapRange.linearEquiv fun i => (e i).symm", "start": [251, 1], "end": [254, 6], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coprodMap", "code": "def coprodMap (f : \u2200 i : \u03b9, M i \u2192\u2097[R] N) : (\u03a0\u2080 i, M i) \u2192\u2097[R] N :=\n  (DFinsupp.lsum \u2115 fun _ : \u03b9 => LinearMap.id) \u2218\u2097 DFinsupp.mapRange.linearMap f", "start": [263, 1], "end": [268, 79], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coprodMap_apply", "code": "theorem coprodMap_apply (f : \u2200 i : \u03b9, M i \u2192\u2097[R] N) (x : \u03a0\u2080 i, M i) :\n    coprodMap f x =\n      DFinsupp.sum (mapRange (fun i => f i) (fun _ => LinearMap.map_zero _) x) fun _ =>\n        id", "start": [271, 1], "end": [275, 31], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.coprodMap_apply_single", "code": "theorem coprodMap_apply_single (f : \u2200 i : \u03b9, M i \u2192\u2097[R] N) (i : \u03b9) (x : M i) :\n    coprodMap f (single i x) = f i x", "start": [278, 1], "end": [280, 19], "kind": "commanddeclaration"}, {"full_name": "Submodule.dfinsupp_sum_mem", "code": "theorem dfinsupp_sum_mem {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, Zero (\u03b2 i)] [\u2200 (i) (x : \u03b2 i), Decidable (x \u2260 0)]\n    (S : Submodule R N) (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192 N) (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 S) :\n    f.sum g \u2208 S", "start": [292, 1], "end": [295, 34], "kind": "commanddeclaration"}, {"full_name": "Submodule.dfinsupp_sumAddHom_mem", "code": "theorem dfinsupp_sumAddHom_mem {\u03b2 : \u03b9 \u2192 Type*} [\u2200 i, AddZeroClass (\u03b2 i)] (S : Submodule R N)\n    (f : \u03a0\u2080 i, \u03b2 i) (g : \u2200 i, \u03b2 i \u2192+ N) (h : \u2200 c, f c \u2260 0 \u2192 g c (f c) \u2208 S) :\n    DFinsupp.sumAddHom g f \u2208 S", "start": [298, 1], "end": [301, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.iSup_eq_range_dfinsupp_lsum", "code": "theorem iSup_eq_range_dfinsupp_lsum (p : \u03b9 \u2192 Submodule R N) :\n    iSup p = LinearMap.range (DFinsupp.lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) fun i => (p i).subtype)", "start": [304, 1], "end": [315, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.biSup_eq_range_dfinsupp_lsum", "code": "theorem biSup_eq_range_dfinsupp_lsum (p : \u03b9 \u2192 Prop) [DecidablePred p] (S : \u03b9 \u2192 Submodule R N) :\n    \u2a06 (i) (_ : p i), S i =\n      LinearMap.range\n        (LinearMap.comp\n          (DFinsupp.lsum \u2115 (M := fun i \u21a6 \u21a5(S i)) (fun i => (S i).subtype))\n            (DFinsupp.filterLinearMap R _ p))", "start": [318, 1], "end": [337, 16], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_iff_exists_dfinsupp", "code": "theorem mem_iSup_iff_exists_dfinsupp (p : \u03b9 \u2192 Submodule R N) (x : N) :\n    x \u2208 iSup p \u2194\n      \u2203 f : \u03a0\u2080 i, p i, DFinsupp.lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) (fun i => (p i).subtype) f = x", "start": [340, 1], "end": [343, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_iff_exists_dfinsupp'", "code": "theorem mem_iSup_iff_exists_dfinsupp' (p : \u03b9 \u2192 Submodule R N) [\u2200 (i) (x : p i), Decidable (x \u2260 0)]\n    (x : N) : x \u2208 iSup p \u2194 \u2203 f : \u03a0\u2080 i, p i, (f.sum fun i xi => \u2191xi) = x", "start": [346, 1], "end": [351, 46], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_biSup_iff_exists_dfinsupp", "code": "theorem mem_biSup_iff_exists_dfinsupp (p : \u03b9 \u2192 Prop) [DecidablePred p] (S : \u03b9 \u2192 Submodule R N)\n    (x : N) :\n    (x \u2208 \u2a06 (i) (_ : p i), S i) \u2194\n      \u2203 f : \u03a0\u2080 i, S i,\n        DFinsupp.lsum \u2115 (M := fun i \u21a6 \u21a5(S i)) (fun i => (S i).subtype) (f.filter p) = x", "start": [354, 1], "end": [359, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.mem_iSup_finset_iff_exists_sum", "code": "theorem mem_iSup_finset_iff_exists_sum {s : Finset \u03b9} (p : \u03b9 \u2192 Submodule R N) (a : N) :\n    (a \u2208 \u2a06 i \u2208 s, p i) \u2194 \u2203 \u03bc : \u2200 i, p i, (\u2211 i in s, (\u03bc i : N)) = a", "start": [364, 1], "end": [398, 12], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_iff_forall_dfinsupp", "code": "theorem independent_iff_forall_dfinsupp (p : \u03b9 \u2192 Submodule R N) :\n    Independent p \u2194\n      \u2200 (i) (x : p i) (v : \u03a0\u2080 i : \u03b9, \u21a5(p i)),\n        lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) (fun i => (p i).subtype) (erase i v) = x \u2192 x = 0", "start": [411, 1], "end": [423, 34], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_of_dfinsupp_lsum_injective", "code": "theorem independent_of_dfinsupp_lsum_injective (p : \u03b9 \u2192 Submodule R N)\n    (h : Function.Injective (lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) fun i => (p i).subtype)) :\n    Independent p", "start": [428, 1], "end": [438, 29], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_of_dfinsupp_sumAddHom_injective", "code": "theorem independent_of_dfinsupp_sumAddHom_injective (p : \u03b9 \u2192 AddSubmonoid N)\n    (h : Function.Injective (sumAddHom fun i => (p i).subtype)) : Independent p", "start": [443, 1], "end": [446, 51], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.lsum_comp_mapRange_toSpanSingleton", "code": "theorem lsum_comp_mapRange_toSpanSingleton [\u2200 m : R, Decidable (m \u2260 0)] (p : \u03b9 \u2192 Submodule R N)\n    {v : \u03b9 \u2192 N} (hv : \u2200 i : \u03b9, v i \u2208 p i) :\n    (lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) fun i => (p i).subtype : _ \u2192\u2097[R] _).comp\n        ((mapRange.linearMap fun i => LinearMap.toSpanSingleton R (\u21a5(p i)) \u27e8v i, hv i\u27e9 :\n              _ \u2192\u2097[R] _).comp\n          (finsuppLequivDFinsupp R : (\u03b9 \u2192\u2080 R) \u2243\u2097[R] _).toLinearMap) =\n      Finsupp.total \u03b9 N R v", "start": [449, 1], "end": [458, 7], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_of_dfinsupp_sumAddHom_injective'", "code": "theorem independent_of_dfinsupp_sumAddHom_injective' (p : \u03b9 \u2192 AddSubgroup N)\n    (h : Function.Injective (sumAddHom fun i => (p i).subtype)) : Independent p", "start": [469, 1], "end": [472, 51], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.dfinsupp_lsum_injective", "code": "theorem Independent.dfinsupp_lsum_injective {p : \u03b9 \u2192 Submodule R N} (h : Independent p) :\n    Function.Injective (lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) fun i => (p i).subtype)", "start": [475, 1], "end": [498, 55], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.dfinsupp_sumAddHom_injective", "code": "theorem Independent.dfinsupp_sumAddHom_injective {p : \u03b9 \u2192 AddSubgroup N} (h : Independent p) :\n    Function.Injective (sumAddHom fun i => (p i).subtype)", "start": [501, 1], "end": [506, 34], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_iff_dfinsupp_lsum_injective", "code": "theorem independent_iff_dfinsupp_lsum_injective (p : \u03b9 \u2192 Submodule R N) :\n    Independent p \u2194 Function.Injective (lsum \u2115 (M := fun i \u21a6 \u21a5(p i)) fun i => (p i).subtype)", "start": [509, 1], "end": [516, 82], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_iff_dfinsupp_sumAddHom_injective", "code": "theorem independent_iff_dfinsupp_sumAddHom_injective (p : \u03b9 \u2192 AddSubgroup N) :\n    Independent p \u2194 Function.Injective (sumAddHom fun i => (p i).subtype)", "start": [519, 1], "end": [523, 93], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.Independent.linearIndependent", "code": "theorem Independent.linearIndependent [NoZeroSMulDivisors R N] (p : \u03b9 \u2192 Submodule R N)\n    (hp : Independent p) {v : \u03b9 \u2192 N} (hv : \u2200 i, v i \u2208 p i) (hv' : \u2200 i, v i \u2260 0) :\n    LinearIndependent R v", "start": [526, 1], "end": [547, 8], "kind": "commanddeclaration"}, {"full_name": "CompleteLattice.independent_iff_linearIndependent_of_ne_zero", "code": "theorem independent_iff_linearIndependent_of_ne_zero [NoZeroSMulDivisors R N] {v : \u03b9 \u2192 N}\n    (h_ne_zero : \u2200 i, v i \u2260 0) : (Independent fun i => R \u2219 v i) \u2194 LinearIndependent R v", "start": [550, 1], "end": [554, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/DirectSum/Basic.lean", "imports": ["Mathlib/Data/DFinsupp/Basic.lean", "Mathlib/GroupTheory/Submonoid/Operations.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DirectSum", "code": "def DirectSum [\u2200 i, AddCommMonoid (\u03b2 i)] : Type _ :=\n  \u03a0\u2080 i, \u03b2 i", "start": [32, 1], "end": [39, 12], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sub_apply", "code": "@[simp]\ntheorem sub_apply (g\u2081 g\u2082 : \u2a01 i, \u03b2 i) (i : \u03b9) : (g\u2081 - g\u2082) i = g\u2081 i - g\u2082 i", "start": [85, 1], "end": [87, 6], "kind": "commanddeclaration"}, {"full_name": "DirectSum.zero_apply", "code": "@[simp]\ntheorem zero_apply (i : \u03b9) : (0 : \u2a01 i, \u03b2 i) i = 0", "start": [94, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "DirectSum.add_apply", "code": "@[simp]\ntheorem add_apply (g\u2081 g\u2082 : \u2a01 i, \u03b2 i) (i : \u03b9) : (g\u2081 + g\u2082) i = g\u2081 i + g\u2082 i", "start": [101, 1], "end": [103, 6], "kind": "commanddeclaration"}, {"full_name": "DirectSum.mk", "code": "def mk (s : Finset \u03b9) : (\u2200 i : (\u2191s : Set \u03b9), \u03b2 i.1) \u2192+ \u2a01 i, \u03b2 i\n    where\n  toFun := DFinsupp.mk s\n  map_add' _ _ := DFinsupp.mk_add\n  map_zero' := DFinsupp.mk_zero", "start": [111, 1], "end": [117, 32], "kind": "commanddeclaration"}, {"full_name": "DirectSum.of", "code": "def of (i : \u03b9) : \u03b2 i \u2192+ \u2a01 i, \u03b2 i :=\n  DFinsupp.singleAddHom \u03b2 i", "start": [120, 1], "end": [122, 28], "kind": "commanddeclaration"}, {"full_name": "DirectSum.of_eq_same", "code": "@[simp]\ntheorem of_eq_same (i : \u03b9) (x : \u03b2 i) : (of _ i x) i = x", "start": [125, 1], "end": [127, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.of_eq_of_ne", "code": "theorem of_eq_of_ne (i j : \u03b9) (x : \u03b2 i) (h : i \u2260 j) : (of _ i x) j = 0", "start": [130, 1], "end": [131, 29], "kind": "commanddeclaration"}, {"full_name": "DirectSum.support_zero", "code": "@[simp]\ntheorem support_zero [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)] : (0 : \u2a01 i, \u03b2 i).support = \u2205", "start": [134, 1], "end": [136, 24], "kind": "commanddeclaration"}, {"full_name": "DirectSum.support_of", "code": "@[simp]\ntheorem support_of [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)] (i : \u03b9) (x : \u03b2 i) (h : x \u2260 0) :\n    (of _ i x).support = {i}", "start": [139, 1], "end": [142, 36], "kind": "commanddeclaration"}, {"full_name": "DirectSum.support_of_subset", "code": "theorem support_of_subset [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)] {i : \u03b9} {b : \u03b2 i} :\n    (of _ i b).support \u2286 {i}", "start": [145, 1], "end": [147, 33], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sum_support_of", "code": "theorem sum_support_of [\u2200 (i : \u03b9) (x : \u03b2 i), Decidable (x \u2260 0)] (x : \u2a01 i, \u03b2 i) :\n    (\u2211 i in x.support, of \u03b2 i (x i)) = x", "start": [150, 1], "end": [152, 22], "kind": "commanddeclaration"}, {"full_name": "DirectSum.mk_injective", "code": "theorem mk_injective (s : Finset \u03b9) : Function.Injective (mk \u03b2 s)", "start": [157, 1], "end": [158, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.of_injective", "code": "theorem of_injective (i : \u03b9) : Function.Injective (of \u03b2 i)", "start": [161, 1], "end": [162, 28], "kind": "commanddeclaration"}, {"full_name": "DirectSum.induction_on", "code": "@[elab_as_elim]\nprotected theorem induction_on {C : (\u2a01 i, \u03b2 i) \u2192 Prop} (x : \u2a01 i, \u03b2 i) (H_zero : C 0)\n    (H_basic : \u2200 (i : \u03b9) (x : \u03b2 i), C (of \u03b2 i x))\n    (H_plus : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) : C x", "start": [165, 1], "end": [171, 16], "kind": "commanddeclaration"}, {"full_name": "DirectSum.addHom_ext", "code": "theorem addHom_ext {\u03b3 : Type*} [AddMonoid \u03b3] \u2983f g : (\u2a01 i, \u03b2 i) \u2192+ \u03b3\u2984\n    (H : \u2200 (i : \u03b9) (y : \u03b2 i), f (of _ i y) = g (of _ i y)) : f = g", "start": [174, 1], "end": [178, 24], "kind": "commanddeclaration"}, {"full_name": "DirectSum.addHom_ext'", "code": "@[ext high]\ntheorem addHom_ext' {\u03b3 : Type*} [AddMonoid \u03b3] \u2983f g : (\u2a01 i, \u03b2 i) \u2192+ \u03b3\u2984\n    (H : \u2200 i : \u03b9, f.comp (of _ i) = g.comp (of _ i)) : f = g", "start": [181, 1], "end": [188, 47], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoid", "code": "def toAddMonoid : (\u2a01 i, \u03b2 i) \u2192+ \u03b3 :=\n  DFinsupp.liftAddHom (\u03b2 := \u03b2) \u03c6", "start": [200, 1], "end": [203, 33], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoid_of", "code": "@[simp]\ntheorem toAddMonoid_of (i) (x : \u03b2 i) : toAddMonoid \u03c6 (of \u03b2 i x) = \u03c6 i x", "start": [206, 1], "end": [208, 41], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toAddMonoid.unique", "code": "theorem toAddMonoid.unique (f : \u2a01 i, \u03b2 i) : \u03c8 f = toAddMonoid (fun i => \u03c8.comp (of \u03b2 i)) f", "start": [211, 1], "end": [215, 25], "kind": "commanddeclaration"}, {"full_name": "DirectSum.fromAddMonoid", "code": "def fromAddMonoid : (\u2a01 i, \u03b3 \u2192+ \u03b2 i) \u2192+ \u03b3 \u2192+ \u2a01 i, \u03b2 i :=\n  toAddMonoid fun i => AddMonoidHom.compHom (of \u03b2 i)", "start": [222, 1], "end": [227, 53], "kind": "commanddeclaration"}, {"full_name": "DirectSum.fromAddMonoid_of", "code": "@[simp]\ntheorem fromAddMonoid_of (i : \u03b9) (f : \u03b3 \u2192+ \u03b2 i) : fromAddMonoid (of _ i f) = (of _ i).comp f", "start": [230, 1], "end": [233, 6], "kind": "commanddeclaration"}, {"full_name": "DirectSum.fromAddMonoid_of_apply", "code": "theorem fromAddMonoid_of_apply (i : \u03b9) (f : \u03b3 \u2192+ \u03b2 i) (x : \u03b3) :\n    fromAddMonoid (of _ i f) x = of _ i (f x)", "start": [236, 1], "end": [238, 66], "kind": "commanddeclaration"}, {"full_name": "DirectSum.setToSet", "code": "def setToSet (S T : Set \u03b9) (H : S \u2286 T) : (\u2a01 i : S, \u03b2 i) \u2192+ \u2a01 i : T, \u03b2 i :=\n  toAddMonoid fun i => of (fun i : Subtype T => \u03b2 i) \u27e8\u2191i, H i.2\u27e9", "start": [246, 1], "end": [249, 65], "kind": "commanddeclaration"}, {"full_name": "DirectSum.unique", "code": "instance unique [\u2200 i, Subsingleton (\u03b2 i)] : Unique (\u2a01 i, \u03b2 i) :=\n  DFinsupp.unique", "start": [257, 1], "end": [258, 18], "kind": "commanddeclaration"}, {"full_name": "DirectSum.uniqueOfIsEmpty", "code": "instance uniqueOfIsEmpty [IsEmpty \u03b9] : Unique (\u2a01 i, \u03b2 i) :=\n  DFinsupp.uniqueOfIsEmpty", "start": [261, 1], "end": [263, 27], "kind": "commanddeclaration"}, {"full_name": "DirectSum.id", "code": "protected def id (M : Type v) (\u03b9 : Type* := PUnit) [AddCommMonoid M] [Unique \u03b9] :\n    (\u2a01 _ : \u03b9, M) \u2243+ M :=\n  {\n    DirectSum.toAddMonoid fun _ =>\n      AddMonoidHom.id\n        M with\n    toFun := DirectSum.toAddMonoid fun _ => AddMonoidHom.id M\n    invFun := of (fun _ => M) default\n    left_inv := fun x =>\n      DirectSum.induction_on x (by rw [AddMonoidHom.map_zero, AddMonoidHom.map_zero])\n        (fun p x => by rw [Unique.default_eq p, toAddMonoid_of]; rfl) fun x y ihx ihy => by\n        rw [AddMonoidHom.map_add, AddMonoidHom.map_add, ihx, ihy]\n    right_inv := fun x => toAddMonoid_of _ _ _ }", "start": [266, 1], "end": [279, 49], "kind": "commanddeclaration"}, {"full_name": "DirectSum.equivCongrLeft", "code": "def equivCongrLeft (h : \u03b9 \u2243 \u03ba) : (\u2a01 i, \u03b2 i) \u2243+ \u2a01 k, \u03b2 (h.symm k) :=\n  { DFinsupp.equivCongrLeft h with map_add' := DFinsupp.comapDomain'_add _ h.right_inv}", "start": [286, 1], "end": [288, 88], "kind": "commanddeclaration"}, {"full_name": "DirectSum.equivCongrLeft_apply", "code": "@[simp]\ntheorem equivCongrLeft_apply (h : \u03b9 \u2243 \u03ba) (f : \u2a01 i, \u03b2 i) (k : \u03ba) :\n    equivCongrLeft h f k = f (h.symm k)", "start": [291, 1], "end": [294, 54], "kind": "commanddeclaration"}, {"full_name": "DirectSum.addEquivProdDirectSum", "code": "@[simps]\nnoncomputable def addEquivProdDirectSum : (\u2a01 i, \u03b1 i) \u2243+ \u03b1 none \u00d7 \u2a01 i, \u03b1 (some i) :=\n  { DFinsupp.equivProdDFinsupp with map_add' := DFinsupp.equivProdDFinsupp_add }", "start": [306, 1], "end": [309, 81], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaCurry", "code": "def sigmaCurry : (\u2a01 i : \u03a3 _i, _, \u03b4 i.1 i.2) \u2192+ \u2a01 (i) (j), \u03b4 i j\n    where\n  toFun := DFinsupp.sigmaCurry (\u03b4 := \u03b4)\n  map_zero' := DFinsupp.sigmaCurry_zero\n  map_add' f g := DFinsupp.sigmaCurry_add f g", "start": [318, 1], "end": [323, 46], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaCurry_apply", "code": "@[simp]\ntheorem sigmaCurry_apply (f : \u2a01 i : \u03a3 _i, _, \u03b4 i.1 i.2) (i : \u03b9) (j : \u03b1 i) :\n    sigmaCurry f i j = f \u27e8i, j\u27e9", "start": [326, 1], "end": [329, 43], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaUncurry", "code": "def sigmaUncurry [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)] :\n    (\u2a01 (i) (j), \u03b4 i j) \u2192+ \u2a01 i : \u03a3 _i, _, \u03b4 i.1 i.2\n    where\n  toFun := DFinsupp.sigmaUncurry\n  map_zero' := DFinsupp.sigmaUncurry_zero\n  map_add' := DFinsupp.sigmaUncurry_add", "start": [332, 1], "end": [339, 40], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaUncurry_apply", "code": "@[simp]\ntheorem sigmaUncurry_apply [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)]\n    (f : \u2a01 (i) (j), \u03b4 i j) (i : \u03b9) (j : \u03b1 i) : sigmaUncurry f \u27e8i, j\u27e9 = f i j", "start": [342, 1], "end": [345, 36], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaCurryEquiv", "code": "def sigmaCurryEquiv [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)] :\n    (\u2a01 i : \u03a3 _i, _, \u03b4 i.1 i.2) \u2243+ \u2a01 (i) (j), \u03b4 i j :=\n  { sigmaCurry, DFinsupp.sigmaCurryEquiv with }", "start": [348, 1], "end": [351, 48], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coeAddMonoidHom", "code": "protected def coeAddMonoidHom {M S : Type*} [DecidableEq \u03b9] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] (A : \u03b9 \u2192 S) : (\u2a01 i, A i) \u2192+ M :=\n  toAddMonoid fun i => AddSubmonoidClass.subtype (A i)", "start": [356, 1], "end": [362, 55], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coeAddMonoidHom_of", "code": "@[simp]\ntheorem coeAddMonoidHom_of {M S : Type*} [DecidableEq \u03b9] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] (A : \u03b9 \u2192 S) (i : \u03b9) (x : A i) :\n    DirectSum.coeAddMonoidHom A (of (fun i => A i) i x) = x", "start": [365, 1], "end": [369, 23], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coe_of_apply", "code": "theorem coe_of_apply {M S : Type*} [DecidableEq \u03b9] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] {A : \u03b9 \u2192 S} (i j : \u03b9) (x : A i) :\n    (of (fun i \u21a6 {x // x \u2208 A i}) i x j : M) = if i = j then x else 0", "start": [372, 1], "end": [377, 97], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal", "code": "def IsInternal {M S : Type*} [DecidableEq \u03b9] [AddCommMonoid M] [SetLike S M]\n    [AddSubmonoidClass S M] (A : \u03b9 \u2192 S) : Prop :=\n  Function.Bijective (DirectSum.coeAddMonoidHom A)", "start": [380, 1], "end": [388, 51], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.addSubmonoid_iSup_eq_top", "code": "theorem IsInternal.addSubmonoid_iSup_eq_top {M : Type*} [DecidableEq \u03b9] [AddCommMonoid M]\n    (A : \u03b9 \u2192 AddSubmonoid M) (h : IsInternal A) : iSup A = \u22a4", "start": [391, 1], "end": [394, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Notation.lean", "imports": ["lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/Algebra/BigOperators/Fin.lean", "Mathlib/Data/Matrix/Basic.lean", "Mathlib/Data/Fin/VecNotation.lean"], "premises": [{"full_name": "Matrix.toExpr", "code": "protected instance toExpr [ToLevel.{u}] [ToLevel.{u\u2098}] [ToLevel.{u\u2099}]\n    [Lean.ToExpr \u03b1] [Lean.ToExpr m'] [Lean.ToExpr n'] [Lean.ToExpr (m' \u2192 n' \u2192 \u03b1)] :\n    Lean.ToExpr (Matrix m' n' \u03b1) :=\n  have e\u03b1 : Q(Type $(toLevel.{u})) := toTypeExpr \u03b1\n  have em' : Q(Type $(toLevel.{u\u2098})) := toTypeExpr m'\n  have en' : Q(Type $(toLevel.{u\u2099})) := toTypeExpr n'\n  { toTypeExpr :=\n    q(Matrix $e\u03b1 $em' $en')\n    toExpr := fun M =>\n      have eM : Q($em' \u2192 $en' \u2192 $e\u03b1) := toExpr (show m' \u2192 n' \u2192 \u03b1 from M)\n      q(Matrix.of $eM) }", "start": [55, 1], "end": [67, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.repr", "code": "instance repr [Repr \u03b1] : Repr (Matrix (Fin m) (Fin n) \u03b1) where\n  reprPrec f _p :=\n    (Std.Format.bracket \"!![\" \u00b7 \"]\") <|\n      (Std.Format.joinSep \u00b7 (\";\" ++ Std.Format.line)) <|\n        (List.finRange m).map fun i =>\n          Std.Format.fill <|  (Std.Format.joinSep \u00b7 (\",\" ++ Std.Format.line)) <|\n            (List.finRange n).map fun j => _root_.repr (f i j)", "start": [121, 1], "end": [134, 63], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_val'", "code": "@[simp]\ntheorem cons_val' (v : n' \u2192 \u03b1) (B : Fin m \u2192 n' \u2192 \u03b1) (i j) :\n    vecCons v B i j = vecCons (v j) (fun i => B i j) i", "start": [137, 1], "end": [139, 94], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_val'", "code": "@[simp, nolint simpNF] theorem head_val' (B : Fin m.succ \u2192 n' \u2192 \u03b1) (j : n') : (vecHead fun i => B i j) = vecHead B j", "start": [142, 1], "end": [144, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_val'", "code": "@[simp, nolint simpNF] theorem tail_val' (B : Fin m.succ \u2192 n' \u2192 \u03b1) (j : n') :\n    (vecTail fun i => B i j) = fun i => vecTail B i j", "start": [147, 1], "end": [151, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_empty", "code": "@[simp]\ntheorem dotProduct_empty (v w : Fin 0 \u2192 \u03b1) : dotProduct v w = 0", "start": [158, 1], "end": [160, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_dotProduct", "code": "@[simp]\ntheorem cons_dotProduct (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : Fin n.succ \u2192 \u03b1) :\n    dotProduct (vecCons x v) w = x * vecHead w + dotProduct v (vecTail w)", "start": [163, 1], "end": [166, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.dotProduct_cons", "code": "@[simp]\ntheorem dotProduct_cons (v : Fin n.succ \u2192 \u03b1) (x : \u03b1) (w : Fin n \u2192 \u03b1) :\n    dotProduct v (vecCons x w) = vecHead v * x + dotProduct (vecTail v) w", "start": [169, 1], "end": [172, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_dotProduct_cons", "code": "theorem cons_dotProduct_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (y : \u03b1) (w : Fin n \u2192 \u03b1) :\n    dotProduct (vecCons x v) (vecCons y w) = x * y + dotProduct v w", "start": [176, 1], "end": [177, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_empty", "code": "@[simp]\ntheorem col_empty (v : Fin 0 \u2192 \u03b1) : col v = vecEmpty", "start": [184, 1], "end": [186, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.col_cons", "code": "@[simp]\ntheorem col_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : col (vecCons x u) = vecCons (fun _ => x) (col u)", "start": [189, 1], "end": [192, 54], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_empty", "code": "@[simp]\ntheorem row_empty : row (vecEmpty : Fin 0 \u2192 \u03b1) = fun _ => vecEmpty", "start": [195, 1], "end": [198, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.row_cons", "code": "@[simp]\ntheorem row_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : row (vecCons x u) = fun _ => vecCons x u", "start": [201, 1], "end": [204, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_empty_rows", "code": "@[simp]\ntheorem transpose_empty_rows (A : Matrix m' (Fin 0) \u03b1) : A\u1d40 = of ![]", "start": [211, 1], "end": [213, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.transpose_empty_cols", "code": "@[simp]\ntheorem transpose_empty_cols (A : Matrix (Fin 0) m' \u03b1) : A\u1d40 = of fun _ => ![]", "start": [216, 1], "end": [218, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_transpose", "code": "@[simp]\ntheorem cons_transpose (v : n' \u2192 \u03b1) (A : Matrix (Fin m) n' \u03b1) :\n    (of (vecCons v A))\u1d40 = of fun i => vecCons (v i) (A\u1d40 i)", "start": [221, 1], "end": [225, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.head_transpose", "code": "@[simp]\ntheorem head_transpose (A : Matrix m' (Fin n.succ) \u03b1) :\n    vecHead (of.symm A\u1d40) = vecHead \u2218 of.symm A", "start": [228, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.tail_transpose", "code": "@[simp]\ntheorem tail_transpose (A : Matrix m' (Fin n.succ) \u03b1) : vecTail (of.symm A\u1d40) = (vecTail \u2218 A)\u1d40", "start": [234, 1], "end": [237, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_mul", "code": "@[simp]\ntheorem empty_mul [Fintype n'] (A : Matrix (Fin 0) n' \u03b1) (B : Matrix n' o' \u03b1) : A * B = of ![]", "start": [246, 1], "end": [248, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_mul_empty", "code": "@[simp]\ntheorem empty_mul_empty (A : Matrix m' (Fin 0) \u03b1) (B : Matrix (Fin 0) o' \u03b1) : A * B = 0", "start": [251, 1], "end": [253, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_empty", "code": "@[simp]\ntheorem mul_empty [Fintype n'] (A : Matrix m' n' \u03b1) (B : Matrix n' (Fin 0) \u03b1) :\n    A * B = of fun _ => ![]", "start": [256, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_val_succ", "code": "theorem mul_val_succ [Fintype n'] (A : Matrix (Fin m.succ) n' \u03b1) (B : Matrix n' o' \u03b1) (i : Fin m)\n    (j : o') : (A * B) i.succ j = (of (vecTail (of.symm A)) * B) i j", "start": [262, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_mul", "code": "@[simp]\ntheorem cons_mul [Fintype n'] (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) (B : Matrix n' o' \u03b1) :\n    of (vecCons v A) * B = of (vecCons (vecMul v B) (of.symm (of A * B)))", "start": [267, 1], "end": [273, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_vecMul", "code": "@[simp]\ntheorem empty_vecMul (v : Fin 0 \u2192 \u03b1) (B : Matrix (Fin 0) o' \u03b1) : vecMul v B = 0", "start": [282, 1], "end": [284, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_empty", "code": "@[simp]\ntheorem vecMul_empty [Fintype n'] (v : n' \u2192 \u03b1) (B : Matrix n' (Fin 0) \u03b1) : vecMul v B = ![]", "start": [287, 1], "end": [289, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecMul", "code": "@[simp]\ntheorem cons_vecMul (x : \u03b1) (v : Fin n \u2192 \u03b1) (B : Fin n.succ \u2192 o' \u2192 \u03b1) :\n    vecMul (vecCons x v) (of B) = x \u2022 vecHead B + vecMul v (of <| vecTail B)", "start": [292, 1], "end": [296, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_cons", "code": "@[simp]\ntheorem vecMul_cons (v : Fin n.succ \u2192 \u03b1) (w : o' \u2192 \u03b1) (B : Fin n \u2192 o' \u2192 \u03b1) :\n    vecMul v (of <| vecCons w B) = vecHead v \u2022 w + vecMul (vecTail v) (of B)", "start": [299, 1], "end": [303, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecMul_cons", "code": "theorem cons_vecMul_cons (x : \u03b1) (v : Fin n \u2192 \u03b1) (w : o' \u2192 \u03b1) (B : Fin n \u2192 o' \u2192 \u03b1) :\n    vecMul (vecCons x v) (of <| vecCons w B) = x \u2022 w + vecMul v (of B)", "start": [307, 1], "end": [308, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_mulVec", "code": "@[simp]\ntheorem empty_mulVec [Fintype n'] (A : Matrix (Fin 0) n' \u03b1) (v : n' \u2192 \u03b1) : mulVec A v = ![]", "start": [317, 1], "end": [319, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_empty", "code": "@[simp]\ntheorem mulVec_empty (A : Matrix m' (Fin 0) \u03b1) (v : Fin 0 \u2192 \u03b1) : mulVec A v = 0", "start": [322, 1], "end": [324, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_mulVec", "code": "@[simp]\ntheorem cons_mulVec [Fintype n'] (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) (w : n' \u2192 \u03b1) :\n    mulVec (of <| vecCons v A) w = vecCons (dotProduct v w) (mulVec (of A) w)", "start": [327, 1], "end": [331, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_cons", "code": "@[simp]\ntheorem mulVec_cons {\u03b1} [CommSemiring \u03b1] (A : m' \u2192 Fin n.succ \u2192 \u03b1) (x : \u03b1) (v : Fin n \u2192 \u03b1) :\n    mulVec (of A) (vecCons x v) = x \u2022 vecHead \u2218 A + mulVec (of (vecTail \u2218 A)) v", "start": [334, 1], "end": [338, 26], "kind": "commanddeclaration"}, {"full_name": "Matrix.empty_vecMulVec", "code": "@[simp]\ntheorem empty_vecMulVec (v : Fin 0 \u2192 \u03b1) (w : n' \u2192 \u03b1) : vecMulVec v w = ![]", "start": [347, 1], "end": [349, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMulVec_empty", "code": "@[simp]\ntheorem vecMulVec_empty (v : m' \u2192 \u03b1) (w : Fin 0 \u2192 \u03b1) : vecMulVec v w = fun _ => ![]", "start": [352, 1], "end": [354, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.cons_vecMulVec", "code": "@[simp]\ntheorem cons_vecMulVec (x : \u03b1) (v : Fin m \u2192 \u03b1) (w : n' \u2192 \u03b1) :\n    vecMulVec (vecCons x v) w = vecCons (x \u2022 w) (vecMulVec v w)", "start": [357, 1], "end": [361, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMulVec_cons", "code": "@[simp]\ntheorem vecMulVec_cons (v : m' \u2192 \u03b1) (x : \u03b1) (w : Fin n \u2192 \u03b1) :\n    vecMulVec v (vecCons x w) = fun i => v i \u2022 vecCons x w", "start": [364, 1], "end": [368, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_mat_empty", "code": "theorem smul_mat_empty {m' : Type*} (x : \u03b1) (A : Fin 0 \u2192 m' \u2192 \u03b1) : x \u2022 A = ![]", "start": [378, 1], "end": [379, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_mat_cons", "code": "theorem smul_mat_cons (x : \u03b1) (v : n' \u2192 \u03b1) (A : Fin m \u2192 n' \u2192 \u03b1) :\n    x \u2022 vecCons v A = vecCons (x \u2022 v) (x \u2022 A)", "start": [383, 1], "end": [386, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_empty", "code": "@[simp]\ntheorem submatrix_empty (A : Matrix m' n' \u03b1) (row : Fin 0 \u2192 m') (col : o' \u2192 n') :\n    submatrix A row col = ![]", "start": [393, 1], "end": [396, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_cons_row", "code": "@[simp]\ntheorem submatrix_cons_row (A : Matrix m' n' \u03b1) (i : m') (row : Fin m \u2192 m') (col : o' \u2192 n') :\n    submatrix A (vecCons i row) col = vecCons (fun j => A i (col j)) (submatrix A row col)", "start": [399, 1], "end": [403, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_updateRow_succAbove", "code": "@[simp]\ntheorem submatrix_updateRow_succAbove (A : Matrix (Fin m.succ) n' \u03b1) (v : n' \u2192 \u03b1) (f : o' \u2192 n')\n    (i : Fin m.succ) : (A.updateRow i v).submatrix i.succAbove f = A.submatrix i.succAbove f", "start": [406, 1], "end": [410, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.submatrix_updateColumn_succAbove", "code": "@[simp]\ntheorem submatrix_updateColumn_succAbove (A : Matrix m' (Fin n.succ) \u03b1) (v : m' \u2192 \u03b1) (f : o' \u2192 m')\n    (i : Fin n.succ) : (A.updateColumn i v).submatrix f i.succAbove = A.submatrix f i.succAbove", "start": [413, 1], "end": [417, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_fin_two", "code": "theorem one_fin_two : (1 : Matrix (Fin 2) (Fin 2) \u03b1) = !![1, 0; 0, 1]", "start": [428, 1], "end": [430, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.one_fin_three", "code": "theorem one_fin_three : (1 : Matrix (Fin 3) (Fin 3) \u03b1) = !![1, 0, 0; 0, 1, 0; 0, 0, 1]", "start": [433, 1], "end": [435, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.eta_fin_two", "code": "theorem eta_fin_two (A : Matrix (Fin 2) (Fin 2) \u03b1) : A = !![A 0 0, A 0 1; A 1 0, A 1 1]", "start": [440, 1], "end": [442, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.eta_fin_three", "code": "theorem eta_fin_three (A : Matrix (Fin 3) (Fin 3) \u03b1) :\n    A = !![A 0 0, A 0 1, A 0 2;\n           A 1 0, A 1 1, A 1 2;\n           A 2 0, A 2 1, A 2 2]", "start": [445, 1], "end": [450, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_fin_two", "code": "theorem mul_fin_two [AddCommMonoid \u03b1] [Mul \u03b1] (a\u2081\u2081 a\u2081\u2082 a\u2082\u2081 a\u2082\u2082 b\u2081\u2081 b\u2081\u2082 b\u2082\u2081 b\u2082\u2082 : \u03b1) :\n    !![a\u2081\u2081, a\u2081\u2082;\n       a\u2082\u2081, a\u2082\u2082] * !![b\u2081\u2081, b\u2081\u2082;\n                      b\u2082\u2081, b\u2082\u2082] = !![a\u2081\u2081 * b\u2081\u2081 + a\u2081\u2082 * b\u2082\u2081, a\u2081\u2081 * b\u2081\u2082 + a\u2081\u2082 * b\u2082\u2082;\n                                     a\u2082\u2081 * b\u2081\u2081 + a\u2082\u2082 * b\u2082\u2081, a\u2082\u2081 * b\u2081\u2082 + a\u2082\u2082 * b\u2082\u2082]", "start": [453, 1], "end": [459, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.mul_fin_three", "code": "theorem mul_fin_three [AddCommMonoid \u03b1] [Mul \u03b1]\n    (a\u2081\u2081 a\u2081\u2082 a\u2081\u2083 a\u2082\u2081 a\u2082\u2082 a\u2082\u2083 a\u2083\u2081 a\u2083\u2082 a\u2083\u2083 b\u2081\u2081 b\u2081\u2082 b\u2081\u2083 b\u2082\u2081 b\u2082\u2082 b\u2082\u2083 b\u2083\u2081 b\u2083\u2082 b\u2083\u2083 : \u03b1) :\n    !![a\u2081\u2081, a\u2081\u2082, a\u2081\u2083;\n       a\u2082\u2081, a\u2082\u2082, a\u2082\u2083;\n       a\u2083\u2081, a\u2083\u2082, a\u2083\u2083] * !![b\u2081\u2081, b\u2081\u2082, b\u2081\u2083;\n                           b\u2082\u2081, b\u2082\u2082, b\u2082\u2083;\n                           b\u2083\u2081, b\u2083\u2082, b\u2083\u2083] =\n    !![a\u2081\u2081*b\u2081\u2081 + a\u2081\u2082*b\u2082\u2081 + a\u2081\u2083*b\u2083\u2081, a\u2081\u2081*b\u2081\u2082 + a\u2081\u2082*b\u2082\u2082 + a\u2081\u2083*b\u2083\u2082, a\u2081\u2081*b\u2081\u2083 + a\u2081\u2082*b\u2082\u2083 + a\u2081\u2083*b\u2083\u2083;\n       a\u2082\u2081*b\u2081\u2081 + a\u2082\u2082*b\u2082\u2081 + a\u2082\u2083*b\u2083\u2081, a\u2082\u2081*b\u2081\u2082 + a\u2082\u2082*b\u2082\u2082 + a\u2082\u2083*b\u2083\u2082, a\u2082\u2081*b\u2081\u2083 + a\u2082\u2082*b\u2082\u2083 + a\u2082\u2083*b\u2083\u2083;\n       a\u2083\u2081*b\u2081\u2081 + a\u2083\u2082*b\u2082\u2081 + a\u2083\u2083*b\u2083\u2081, a\u2083\u2081*b\u2081\u2082 + a\u2083\u2082*b\u2082\u2082 + a\u2083\u2083*b\u2083\u2082, a\u2083\u2081*b\u2081\u2083 + a\u2083\u2082*b\u2082\u2083 + a\u2083\u2083*b\u2083\u2083]", "start": [462, 1], "end": [474, 76], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec2_eq", "code": "theorem vec2_eq {a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1} (h\u2080 : a\u2080 = b\u2080) (h\u2081 : a\u2081 = b\u2081) : ![a\u2080, a\u2081] = ![b\u2080, b\u2081]", "start": [477, 1], "end": [479, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec3_eq", "code": "theorem vec3_eq {a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1} (h\u2080 : a\u2080 = b\u2080) (h\u2081 : a\u2081 = b\u2081) (h\u2082 : a\u2082 = b\u2082) :\n    ![a\u2080, a\u2081, a\u2082] = ![b\u2080, b\u2081, b\u2082]", "start": [482, 1], "end": [485, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec2_add", "code": "theorem vec2_add [Add \u03b1] (a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1) : ![a\u2080, a\u2081] + ![b\u2080, b\u2081] = ![a\u2080 + b\u2080, a\u2081 + b\u2081]", "start": [488, 1], "end": [489, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec3_add", "code": "theorem vec3_add [Add \u03b1] (a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1) :\n    ![a\u2080, a\u2081, a\u2082] + ![b\u2080, b\u2081, b\u2082] = ![a\u2080 + b\u2080, a\u2081 + b\u2081, a\u2082 + b\u2082]", "start": [492, 1], "end": [494, 68], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_vec2", "code": "theorem smul_vec2 {R : Type*} [SMul R \u03b1] (x : R) (a\u2080 a\u2081 : \u03b1) :\n    x \u2022 ![a\u2080, a\u2081] = ![x \u2022 a\u2080, x \u2022 a\u2081]", "start": [497, 1], "end": [498, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.smul_vec3", "code": "theorem smul_vec3 {R : Type*} [SMul R \u03b1] (x : R) (a\u2080 a\u2081 a\u2082 : \u03b1) :\n    x \u2022 ![a\u2080, a\u2081, a\u2082] = ![x \u2022 a\u2080, x \u2022 a\u2081, x \u2022 a\u2082]", "start": [501, 1], "end": [503, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec2_dotProduct'", "code": "theorem vec2_dotProduct' {a\u2080 a\u2081 b\u2080 b\u2081 : \u03b1} : ![a\u2080, a\u2081] \u2b1d\u1d65 ![b\u2080, b\u2081] = a\u2080 * b\u2080 + a\u2081 * b\u2081", "start": [508, 1], "end": [509, 78], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec2_dotProduct", "code": "@[simp]\ntheorem vec2_dotProduct (v w : Fin 2 \u2192 \u03b1) : v \u2b1d\u1d65 w = v 0 * w 0 + v 1 * w 1", "start": [512, 1], "end": [514, 19], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec3_dotProduct'", "code": "theorem vec3_dotProduct' {a\u2080 a\u2081 a\u2082 b\u2080 b\u2081 b\u2082 : \u03b1} :\n    ![a\u2080, a\u2081, a\u2082] \u2b1d\u1d65 ![b\u2080, b\u2081, b\u2082] = a\u2080 * b\u2080 + a\u2081 * b\u2081 + a\u2082 * b\u2082", "start": [517, 1], "end": [520, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.vec3_dotProduct", "code": "@[simp]\ntheorem vec3_dotProduct (v w : Fin 3 \u2192 \u03b1) : v \u2b1d\u1d65 w = v 0 * w 0 + v 1 * w 1 + v 2 * w 2", "start": [523, 1], "end": [525, 19], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/AlgebraTower.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/LinearAlgebra/Basis.lean", "Mathlib/Algebra/Module/BigOperators.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsScalarTower.Invertible.algebraTower", "code": "def Invertible.algebraTower (r : R) [Invertible (algebraMap R S r)] :\n    Invertible (algebraMap R A r) :=\n  Invertible.copy (Invertible.map (algebraMap S A) (algebraMap R S r)) (algebraMap R A r)\n    (IsScalarTower.algebraMap_apply R S A r)", "start": [47, 1], "end": [52, 45], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.invertibleAlgebraCoeNat", "code": "def invertibleAlgebraCoeNat (n : \u2115) [inv : Invertible (n : R)] : Invertible (n : A) :=\n  haveI : Invertible (algebraMap \u2115 R n) := inv\n  Invertible.algebraTower \u2115 R A n", "start": [55, 1], "end": [59, 34], "kind": "commanddeclaration"}, {"full_name": "Basis.algebraMapCoeffs", "code": "@[simps! repr_apply_support_val repr_apply_toFun]\nnoncomputable def Basis.algebraMapCoeffs : Basis \u03b9 A M :=\n  b.mapCoeffs (RingEquiv.ofBijective _ h) fun c x => by simp", "start": [82, 1], "end": [86, 61], "kind": "commanddeclaration"}, {"full_name": "Basis.algebraMapCoeffs_apply", "code": "theorem Basis.algebraMapCoeffs_apply (i : \u03b9) : b.algebraMapCoeffs A h i = b i", "start": [90, 1], "end": [91, 26], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_algebraMapCoeffs", "code": "@[simp]\ntheorem Basis.coe_algebraMapCoeffs : (b.algebraMapCoeffs A h : \u03b9 \u2192 M) = b", "start": [94, 1], "end": [96, 22], "kind": "commanddeclaration"}, {"full_name": "linearIndependent_smul", "code": "theorem linearIndependent_smul {\u03b9 : Type v\u2081} {b : \u03b9 \u2192 S} {\u03b9' : Type w\u2081} {c : \u03b9' \u2192 A}\n    (hb : LinearIndependent R b) (hc : LinearIndependent S c) :\n    LinearIndependent R fun p : \u03b9 \u00d7 \u03b9' => b p.1 \u2022 c p.2", "start": [115, 1], "end": [128, 17], "kind": "commanddeclaration"}, {"full_name": "Basis.smul", "code": "noncomputable def Basis.smul {\u03b9 : Type v\u2081} {\u03b9' : Type w\u2081} (b : Basis \u03b9 R S) (c : Basis \u03b9' S A) :\n    Basis (\u03b9 \u00d7 \u03b9') R A :=\n  .ofRepr\n    (c.repr.restrictScalars R \u226a\u226b\u2097\n      (Finsupp.lcongr (Equiv.refl _) b.repr \u226a\u226b\u2097\n        ((finsuppProdLEquiv R).symm \u226a\u226b\u2097\n          Finsupp.lcongr (Equiv.prodComm \u03b9' \u03b9) (LinearEquiv.refl _ _))))", "start": [131, 1], "end": [139, 73], "kind": "commanddeclaration"}, {"full_name": "Basis.smul_repr", "code": "@[simp]\ntheorem Basis.smul_repr {\u03b9 : Type v\u2081} {\u03b9' : Type w\u2081} (b : Basis \u03b9 R S) (c : Basis \u03b9' S A) (x ij) :\n    (b.smul c).repr x ij = b.repr (c.repr x ij.2) ij.1", "start": [142, 1], "end": [144, 79], "kind": "commanddeclaration"}, {"full_name": "Basis.smul_repr_mk", "code": "theorem Basis.smul_repr_mk {\u03b9 : Type v\u2081} {\u03b9' : Type w\u2081} (b : Basis \u03b9 R S) (c : Basis \u03b9' S A)\n    (x i j) : (b.smul c).repr x (i, j) = b.repr (c.repr x j) i", "start": [147, 1], "end": [149, 25], "kind": "commanddeclaration"}, {"full_name": "Basis.smul_apply", "code": "@[simp]\ntheorem Basis.smul_apply {\u03b9 : Type v\u2081} {\u03b9' : Type w\u2081} (b : Basis \u03b9 R S) (c : Basis \u03b9' S A) (ij) :\n    (b.smul c) ij = b ij.1 \u2022 c ij.2", "start": [152, 1], "end": [163, 14], "kind": "commanddeclaration"}, {"full_name": "Basis.algebraMap_injective", "code": "theorem Basis.algebraMap_injective {\u03b9 : Type*} [NoZeroDivisors R] [Nontrivial S]\n    (b : @Basis \u03b9 R S _ _ Algebra.toModule) : Function.Injective (algebraMap R S)", "start": [175, 1], "end": [178, 46], "kind": "commanddeclaration"}, {"full_name": "AlgHom.restrictDomain", "code": "def AlgHom.restrictDomain : B \u2192\u2090[A] D :=\n  f.comp (IsScalarTower.toAlgHom A B C)", "start": [191, 1], "end": [193, 40], "kind": "commanddeclaration"}, {"full_name": "AlgHom.extendScalars", "code": "def AlgHom.extendScalars : @AlgHom B C D _ _ _ _ (f.restrictDomain B).toRingHom.toAlgebra where\n  toFun := f.toFun\n  map_one' := by simp only [toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe,\n    map_one]\n  map_mul' := by simp only [toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe,\n    MonoidHom.toOneHom_coe, map_mul, MonoidHom.coe_coe, RingHom.coe_coe, forall_const]\n  map_zero' := by simp only [toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe,\n    MonoidHom.toOneHom_coe, MonoidHom.coe_coe, map_zero]\n  map_add' := by simp only [toRingHom_eq_coe, RingHom.toMonoidHom_eq_coe, OneHom.toFun_eq_coe,\n    MonoidHom.toOneHom_coe, MonoidHom.coe_coe, map_add, RingHom.coe_coe, forall_const]\n  commutes' := fun _ \u21a6 rfl\n  __ := (f.restrictDomain B).toRingHom.toAlgebra", "start": [200, 1], "end": [212, 49], "kind": "commanddeclaration"}, {"full_name": "algHomEquivSigma", "code": "def algHomEquivSigma : (C \u2192\u2090[A] D) \u2243 \u03a3f : B \u2192\u2090[A] D, @AlgHom B C D _ _ _ _ f.toRingHom.toAlgebra\n    where\n  toFun f := \u27e8f.restrictDomain B, f.extendScalars B\u27e9\n  invFun fg :=\n    let _ := fg.1.toRingHom.toAlgebra\n    fg.2.restrictScalars A\n  left_inv f := by\n    dsimp only\n    ext\n    rfl\n  right_inv := by\n    rintro \u27e8\u27e8\u27e8\u27e8\u27e8f, _\u27e9, _\u27e9, _\u27e9, _\u27e9, \u27e8\u27e8\u27e8\u27e8g, _\u27e9, _\u27e9, _\u27e9, hg\u27e9\u27e9\n    obtain rfl : f = fun x => g (algebraMap B C x) := by\n      ext x\n      exact (hg x).symm\n    rfl", "start": [217, 1], "end": [233, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/StdBasis.lean", "imports": ["Mathlib/LinearAlgebra/Basis.lean", "Mathlib/Data/Matrix/Basis.lean", "Mathlib/LinearAlgebra/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.stdBasis", "code": "def stdBasis : \u2200 i : \u03b9, \u03c6 i \u2192\u2097[R] \u2200 i, \u03c6 i :=\n  single", "start": [47, 1], "end": [49, 9], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_apply", "code": "theorem stdBasis_apply (i : \u03b9) (b : \u03c6 i) : stdBasis R \u03c6 i b = update (0 : (a : \u03b9) \u2192 \u03c6 a) i b", "start": [52, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_apply'", "code": "@[simp]\ntheorem stdBasis_apply' (i i' : \u03b9) : (stdBasis R (fun _x : \u03b9 => R) i) 1 i' = ite (i = i') 1 0", "start": [56, 1], "end": [59, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_stdBasis", "code": "theorem coe_stdBasis (i : \u03b9) : \u21d1(stdBasis R \u03c6 i) = Pi.single i", "start": [62, 1], "end": [63, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_same", "code": "@[simp]\ntheorem stdBasis_same (i : \u03b9) (b : \u03c6 i) : stdBasis R \u03c6 i b i = b", "start": [66, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_ne", "code": "theorem stdBasis_ne (i j : \u03b9) (h : j \u2260 i) (b : \u03c6 i) : stdBasis R \u03c6 i b j = 0", "start": [71, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_eq_pi_diag", "code": "theorem stdBasis_eq_pi_diag (i : \u03b9) : stdBasis R \u03c6 i = pi (diag i)", "start": [75, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.ker_stdBasis", "code": "theorem ker_stdBasis (i : \u03b9) : ker (stdBasis R \u03c6 i) = \u22a5", "start": [82, 1], "end": [83, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj_comp_stdBasis", "code": "theorem proj_comp_stdBasis (i j : \u03b9) : (proj i).comp (stdBasis R \u03c6 j) = diag j i", "start": [86, 1], "end": [87, 36], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj_stdBasis_same", "code": "theorem proj_stdBasis_same (i : \u03b9) : (proj i).comp (stdBasis R \u03c6 i) = id", "start": [90, 1], "end": [91, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.proj_stdBasis_ne", "code": "theorem proj_stdBasis_ne (i j : \u03b9) (h : i \u2260 j) : (proj i).comp (stdBasis R \u03c6 j) = 0", "start": [94, 1], "end": [95, 41], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iSup_range_stdBasis_le_iInf_ker_proj", "code": "theorem iSup_range_stdBasis_le_iInf_ker_proj (I J : Set \u03b9) (h : Disjoint I J) :\n    \u2a06 i \u2208 I, range (stdBasis R \u03c6 i) \u2264 \u2a05 i \u2208 J, ker (proj i : (\u2200 i, \u03c6 i) \u2192\u2097[R] \u03c6 i)", "start": [98, 1], "end": [105, 26], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iInf_ker_proj_le_iSup_range_stdBasis", "code": "theorem iInf_ker_proj_le_iSup_range_stdBasis {I : Finset \u03b9} {J : Set \u03b9} (hu : Set.univ \u2286 \u2191I \u222a J) :\n    \u2a05 i \u2208 J, ker (proj i : (\u2200 i, \u03c6 i) \u2192\u2097[R] \u03c6 i) \u2264 \u2a06 i \u2208 I, range (stdBasis R \u03c6 i)", "start": [108, 1], "end": [122, 76], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iSup_range_stdBasis_eq_iInf_ker_proj", "code": "theorem iSup_range_stdBasis_eq_iInf_ker_proj {I J : Set \u03b9} (hd : Disjoint I J)\n    (hu : Set.univ \u2286 I \u222a J) (hI : Set.Finite I) :\n    \u2a06 i \u2208 I, range (stdBasis R \u03c6 i) = \u2a05 i \u2208 J, ker (proj i : (\u2200 i, \u03c6 i) \u2192\u2097[R] \u03c6 i)", "start": [125, 1], "end": [131, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.iSup_range_stdBasis", "code": "theorem iSup_range_stdBasis [Finite \u03b9] : \u2a06 i, range (stdBasis R \u03c6 i) = \u22a4", "start": [134, 1], "end": [139, 42], "kind": "commanddeclaration"}, {"full_name": "LinearMap.disjoint_stdBasis_stdBasis", "code": "theorem disjoint_stdBasis_stdBasis (I J : Set \u03b9) (h : Disjoint I J) :\n    Disjoint (\u2a06 i \u2208 I, range (stdBasis R \u03c6 i)) (\u2a06 i \u2208 J, range (stdBasis R \u03c6 i))", "start": [142, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "LinearMap.stdBasis_eq_single", "code": "theorem stdBasis_eq_single {a : R} :\n    (fun i : \u03b9 => (stdBasis R (fun _ : \u03b9 => R) i) a) = fun i : \u03b9 => \u2191(Finsupp.single i a)", "start": [158, 1], "end": [160, 57], "kind": "commanddeclaration"}, {"full_name": "Pi.linearIndependent_stdBasis", "code": "theorem linearIndependent_stdBasis [Ring R] [\u2200 i, AddCommGroup (Ms i)] [\u2200 i, Module R (Ms i)]\n    [DecidableEq \u03b7] (v : \u2200 j, \u03b9s j \u2192 Ms j) (hs : \u2200 i, LinearIndependent R (v i)) :\n    LinearIndependent R fun ji : \u03a3j, \u03b9s j => stdBasis R Ms ji.1 (v ji.1 ji.2)", "start": [177, 1], "end": [203, 61], "kind": "commanddeclaration"}, {"full_name": "Pi.basis", "code": "protected noncomputable def basis (s : \u2200 j, Basis (\u03b9s j) R (Ms j)) :\n    Basis (\u03a3j, \u03b9s j) R (\u2200 j, Ms j) :=\n  Basis.ofRepr\n    ((LinearEquiv.piCongrRight fun j => (s j).repr) \u226a\u226b\u2097\n      (Finsupp.sigmaFinsuppLEquivPiFinsupp R).symm)", "start": [214, 1], "end": [223, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.basis_repr_stdBasis", "code": "@[simp]\ntheorem basis_repr_stdBasis [DecidableEq \u03b7] (s : \u2200 j, Basis (\u03b9s j) R (Ms j)) (j i) :\n    (Pi.basis s).repr (stdBasis R _ j (s j i)) = Finsupp.single \u27e8j, i\u27e9 1", "start": [232, 1], "end": [253, 16], "kind": "commanddeclaration"}, {"full_name": "Pi.basis_apply", "code": "@[simp]\ntheorem basis_apply [DecidableEq \u03b7] (s : \u2200 j, Basis (\u03b9s j) R (Ms j)) (ji) :\n    Pi.basis s ji = stdBasis R _ ji.1 (s ji.1 ji.2)", "start": [256, 1], "end": [259, 35], "kind": "commanddeclaration"}, {"full_name": "Pi.basis_repr", "code": "@[simp]\ntheorem basis_repr (s : \u2200 j, Basis (\u03b9s j) R (Ms j)) (x) (ji) :\n    (Pi.basis s).repr x ji = (s ji.1).repr (x ji.1) ji.2", "start": [262, 1], "end": [265, 6], "kind": "commanddeclaration"}, {"full_name": "Pi.basisFun", "code": "noncomputable def basisFun : Basis \u03b7 R (\u2200 _ : \u03b7, R) :=\n  Basis.ofEquivFun (LinearEquiv.refl _ _)", "start": [274, 1], "end": [276, 42], "kind": "commanddeclaration"}, {"full_name": "Pi.basisFun_apply", "code": "@[simp]\ntheorem basisFun_apply [DecidableEq \u03b7] (i) : basisFun R \u03b7 i = stdBasis R (fun _ : \u03b7 => R) i 1", "start": [279, 1], "end": [282, 20], "kind": "commanddeclaration"}, {"full_name": "Pi.basisFun_repr", "code": "@[simp]\ntheorem basisFun_repr (x : \u03b7 \u2192 R) (i : \u03b7) : (Pi.basisFun R \u03b7).repr x i = x i", "start": [285, 1], "end": [286, 99], "kind": "commanddeclaration"}, {"full_name": "Pi.basisFun_equivFun", "code": "@[simp]\ntheorem basisFun_equivFun : (Pi.basisFun R \u03b7).equivFun = LinearEquiv.refl _ _", "start": [289, 1], "end": [291, 30], "kind": "commanddeclaration"}, {"full_name": "Module.piEquiv", "code": "noncomputable def piEquiv : (\u03b9 \u2192 M) \u2243\u2097[R] ((\u03b9 \u2192 R) \u2192\u2097[R] M) := Basis.constr (Pi.basisFun R \u03b9) R", "start": [305, 1], "end": [306, 96], "kind": "commanddeclaration"}, {"full_name": "Module.piEquiv_apply_apply", "code": "lemma piEquiv_apply_apply (v : \u03b9 \u2192 M) (w : \u03b9 \u2192 R) :\n    piEquiv \u03b9 R M v w = \u2211 i, w i \u2022 v i := by\n  simp only [piEquiv, Basis.constr_apply_fintype, Basis.equivFun_apply]\n  congr", "start": [308, 1], "end": [311, 8], "kind": "mathlibtacticlemma"}, {"full_name": "Module.range_piEquiv", "code": "@[simp] lemma range_piEquiv (v : \u03b9 \u2192 M) :\n    LinearMap.range (piEquiv \u03b9 R M v) = span R (range v) :=\n  Basis.constr_range _ _", "start": [313, 1], "end": [315, 25], "kind": "mathlibtacticlemma"}, {"full_name": "Module.surjective_piEquiv_apply_iff", "code": "@[simp] lemma surjective_piEquiv_apply_iff (v : \u03b9 \u2192 M) :\n    Surjective (piEquiv \u03b9 R M v) \u2194 span R (range v) = \u22a4 := by\n  rw [\u2190 LinearMap.range_eq_top, range_piEquiv]", "start": [317, 1], "end": [319, 47], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.stdBasis", "code": "noncomputable def stdBasis : Basis (m \u00d7 n) R (Matrix m n R) :=\n  Basis.reindex (Pi.basis fun _ : m => Pi.basisFun R n) (Equiv.sigmaEquivProd _ _)", "start": [327, 1], "end": [329, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.stdBasis_eq_stdBasisMatrix", "code": "theorem stdBasis_eq_stdBasisMatrix (i : n) (j : m) [DecidableEq n] [DecidableEq m] :\n    stdBasis R n m (i, j) = stdBasisMatrix i j (1 : R)", "start": [334, 1], "end": [354, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Algebra/Subalgebra/Tower.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Algebra.lmul_algebraMap", "code": "theorem lmul_algebraMap (x : R) : Algebra.lmul R A (algebraMap R A x) = Algebra.lsmul R R A x", "start": [46, 1], "end": [47, 41], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.subalgebra", "code": "instance subalgebra (S\u2080 : Subalgebra R S) : IsScalarTower S\u2080 S A :=\n  of_algebraMap_eq fun _ \u21a6 rfl", "start": [60, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "IsScalarTower.subalgebra'", "code": "instance subalgebra' (S\u2080 : Subalgebra R S) : IsScalarTower R S\u2080 A :=\n  @IsScalarTower.of_algebraMap_eq R S\u2080 A _ _ _ _ _ _ fun _ \u21a6\n    (IsScalarTower.algebraMap_apply R S A _ : _)", "start": [66, 1], "end": [68, 49], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.restrictScalars", "code": "def restrictScalars (U : Subalgebra S A) : Subalgebra R A :=\n  { U with\n    algebraMap_mem' := fun x \u21a6 by\n      rw [algebraMap_apply R S A]\n      exact U.algebraMap_mem _ }", "start": [87, 1], "end": [93, 33], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.coe_restrictScalars", "code": "@[simp]\ntheorem coe_restrictScalars {U : Subalgebra S A} : (restrictScalars R U : Set A) = (U : Set A)", "start": [96, 1], "end": [98, 6], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.restrictScalars_top", "code": "@[simp]\ntheorem restrictScalars_top : restrictScalars R (\u22a4 : Subalgebra S A) = \u22a4", "start": [101, 1], "end": [103, 35], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.restrictScalars_toSubmodule", "code": "@[simp]\ntheorem restrictScalars_toSubmodule {U : Subalgebra S A} :\n    Subalgebra.toSubmodule (U.restrictScalars R) = U.toSubmodule.restrictScalars R", "start": [106, 1], "end": [109, 28], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.mem_restrictScalars", "code": "@[simp]\ntheorem mem_restrictScalars {U : Subalgebra S A} {x : A} : x \u2208 restrictScalars R U \u2194 x \u2208 U", "start": [112, 1], "end": [114, 10], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.restrictScalars_injective", "code": "theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : Subalgebra S A \u2192 Subalgebra R A)", "start": [117, 1], "end": [119, 70], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.ofRestrictScalars", "code": "@[simp]\ndef ofRestrictScalars (U : Subalgebra S A) (f : U \u2192\u2090[S] B) : U.restrictScalars R \u2192\u2090[R] B :=\n  f.restrictScalars R", "start": [122, 1], "end": [127, 22], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.range_isScalarTower_toAlgHom", "code": "@[simp]\nlemma range_isScalarTower_toAlgHom [CommSemiring R] [CommSemiring A]\n    [Algebra R A] (S : Subalgebra R A) :\n    LinearMap.range (IsScalarTower.toAlgHom R S A) = Subalgebra.toSubmodule S := by\n  ext\n  simp only [\u2190 Submodule.range_subtype (Subalgebra.toSubmodule S), LinearMap.mem_range,\n    IsScalarTower.coe_toAlgHom', Subalgebra.mem_toSubmodule]\n  rfl", "start": [134, 1], "end": [141, 6], "kind": "mathlibtacticlemma"}, {"full_name": "IsScalarTower.adjoin_range_toAlgHom", "code": "theorem adjoin_range_toAlgHom (t : Set A) :\n    (Algebra.adjoin (toAlgHom R S A).range t).restrictScalars R =\n      (Algebra.adjoin S t).restrictScalars R", "start": [155, 1], "end": [164, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Matrix/Block.lean", "imports": ["Mathlib/Data/Matrix/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.dotProduct_block", "code": "theorem dotProduct_block [Fintype m] [Fintype n] [Mul \u03b1] [AddCommMonoid \u03b1] (v w : Sum m n \u2192 \u03b1) :\n    v \u2b1d\u1d65 w = v \u2218 Sum.inl \u2b1d\u1d65 w \u2218 Sum.inl + v \u2218 Sum.inr \u2b1d\u1d65 w \u2218 Sum.inr", "start": [35, 1], "end": [37, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks", "code": "def fromBlocks (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) :\n    Matrix (Sum n o) (Sum l m) \u03b1 :=\n  of <| Sum.elim (fun i => Sum.elim (A i) (B i)) fun i => Sum.elim (C i) (D i)", "start": [42, 1], "end": [47, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_apply\u2081\u2081", "code": "@[simp]\ntheorem fromBlocks_apply\u2081\u2081 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (i : n) (j : l) : fromBlocks A B C D (Sum.inl i) (Sum.inl j) = A i j", "start": [50, 1], "end": [53, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_apply\u2081\u2082", "code": "@[simp]\ntheorem fromBlocks_apply\u2081\u2082 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (i : n) (j : m) : fromBlocks A B C D (Sum.inl i) (Sum.inr j) = B i j", "start": [56, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_apply\u2082\u2081", "code": "@[simp]\ntheorem fromBlocks_apply\u2082\u2081 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (i : o) (j : l) : fromBlocks A B C D (Sum.inr i) (Sum.inl j) = C i j", "start": [62, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_apply\u2082\u2082", "code": "@[simp]\ntheorem fromBlocks_apply\u2082\u2082 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (i : o) (j : m) : fromBlocks A B C D (Sum.inr i) (Sum.inr j) = D i j", "start": [68, 1], "end": [71, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks\u2081\u2081", "code": "def toBlocks\u2081\u2081 (M : Matrix (Sum n o) (Sum l m) \u03b1) : Matrix n l \u03b1 :=\n  of fun i j => M (Sum.inl i) (Sum.inl j)", "start": [74, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks\u2081\u2082", "code": "def toBlocks\u2081\u2082 (M : Matrix (Sum n o) (Sum l m) \u03b1) : Matrix n m \u03b1 :=\n  of fun i j => M (Sum.inl i) (Sum.inr j)", "start": [80, 1], "end": [83, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks\u2082\u2081", "code": "def toBlocks\u2082\u2081 (M : Matrix (Sum n o) (Sum l m) \u03b1) : Matrix o l \u03b1 :=\n  of fun i j => M (Sum.inr i) (Sum.inl j)", "start": [86, 1], "end": [89, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks\u2082\u2082", "code": "def toBlocks\u2082\u2082 (M : Matrix (Sum n o) (Sum l m) \u03b1) : Matrix o m \u03b1 :=\n  of fun i j => M (Sum.inr i) (Sum.inr j)", "start": [92, 1], "end": [95, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_toBlocks", "code": "theorem fromBlocks_toBlocks (M : Matrix (Sum n o) (Sum l m) \u03b1) :\n    fromBlocks M.toBlocks\u2081\u2081 M.toBlocks\u2081\u2082 M.toBlocks\u2082\u2081 M.toBlocks\u2082\u2082 = M", "start": [98, 1], "end": [101, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks_fromBlocks\u2081\u2081", "code": "@[simp]\ntheorem toBlocks_fromBlocks\u2081\u2081 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D).toBlocks\u2081\u2081 = A", "start": [104, 1], "end": [107, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks_fromBlocks\u2081\u2082", "code": "@[simp]\ntheorem toBlocks_fromBlocks\u2081\u2082 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D).toBlocks\u2081\u2082 = B", "start": [110, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks_fromBlocks\u2082\u2081", "code": "@[simp]\ntheorem toBlocks_fromBlocks\u2082\u2081 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D).toBlocks\u2082\u2081 = C", "start": [116, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks_fromBlocks\u2082\u2082", "code": "@[simp]\ntheorem toBlocks_fromBlocks\u2082\u2082 (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D).toBlocks\u2082\u2082 = D", "start": [122, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.ext_iff_blocks", "code": "theorem ext_iff_blocks {A B : Matrix (Sum n o) (Sum l m) \u03b1} :\n    A = B \u2194\n      A.toBlocks\u2081\u2081 = B.toBlocks\u2081\u2081 \u2227\n        A.toBlocks\u2081\u2082 = B.toBlocks\u2081\u2082 \u2227 A.toBlocks\u2082\u2081 = B.toBlocks\u2082\u2081 \u2227 A.toBlocks\u2082\u2082 = B.toBlocks\u2082\u2082", "start": [128, 1], "end": [134, 79], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_inj", "code": "@[simp]\ntheorem fromBlocks_inj {A : Matrix n l \u03b1} {B : Matrix n m \u03b1} {C : Matrix o l \u03b1} {D : Matrix o m \u03b1}\n    {A' : Matrix n l \u03b1} {B' : Matrix n m \u03b1} {C' : Matrix o l \u03b1} {D' : Matrix o m \u03b1} :\n    fromBlocks A B C D = fromBlocks A' B' C' D' \u2194 A = A' \u2227 B = B' \u2227 C = C' \u2227 D = D'", "start": [137, 1], "end": [141, 17], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_map", "code": "theorem fromBlocks_map (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1)\n    (f : \u03b1 \u2192 \u03b2) : (fromBlocks A B C D).map f = fromBlocks (A.map f) (B.map f) (C.map f) (D.map f)", "start": [144, 1], "end": [146, 74], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_transpose", "code": "theorem fromBlocks_transpose (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D)\u1d40 = fromBlocks A\u1d40 C\u1d40 B\u1d40 D\u1d40", "start": [149, 1], "end": [152, 62], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_conjTranspose", "code": "theorem fromBlocks_conjTranspose [Star \u03b1] (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : (fromBlocks A B C D)\u1d34 = fromBlocks A\u1d34 C\u1d34 B\u1d34 D\u1d34", "start": [155, 1], "end": [157, 66], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_submatrix_sum_swap_left", "code": "@[simp]\ntheorem fromBlocks_submatrix_sum_swap_left (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (f : p \u2192 Sum l m) :\n    (fromBlocks A B C D).submatrix Sum.swap f = (fromBlocks C D A B).submatrix id f", "start": [160, 1], "end": [165, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_submatrix_sum_swap_right", "code": "@[simp]\ntheorem fromBlocks_submatrix_sum_swap_right (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (f : p \u2192 Sum n o) :\n    (fromBlocks A B C D).submatrix f Sum.swap = (fromBlocks B A D C).submatrix f id", "start": [168, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_submatrix_sum_swap_sum_swap", "code": "theorem fromBlocks_submatrix_sum_swap_sum_swap {l m n o \u03b1 : Type*} (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) :\n    (fromBlocks A B C D).submatrix Sum.swap Sum.swap = fromBlocks D C B A", "start": [176, 1], "end": [178, 85], "kind": "commanddeclaration"}, {"full_name": "Matrix.IsTwoBlockDiagonal", "code": "def IsTwoBlockDiagonal [Zero \u03b1] (A : Matrix (Sum n o) (Sum l m) \u03b1) : Prop :=\n  toBlocks\u2081\u2082 A = 0 \u2227 toBlocks\u2082\u2081 A = 0", "start": [181, 1], "end": [183, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock", "code": "def toBlock (M : Matrix m n \u03b1) (p : m \u2192 Prop) (q : n \u2192 Prop) : Matrix { a // p a } { a // q a } \u03b1 :=\n  M.submatrix (\u2191) (\u2191)", "start": [186, 1], "end": [189, 22], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_apply", "code": "@[simp]\ntheorem toBlock_apply (M : Matrix m n \u03b1) (p : m \u2192 Prop) (q : n \u2192 Prop) (i : { a // p a })\n    (j : { a // q a }) : toBlock M p q i j = M \u2191i \u2191j", "start": [192, 1], "end": [195, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toSquareBlockProp", "code": "def toSquareBlockProp (M : Matrix m m \u03b1) (p : m \u2192 Prop) : Matrix { a // p a } { a // p a } \u03b1 :=\n  toBlock M _ _", "start": [198, 1], "end": [201, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.toSquareBlockProp_def", "code": "theorem toSquareBlockProp_def (M : Matrix m m \u03b1) (p : m \u2192 Prop) :\n    toSquareBlockProp M p = of (fun i j : { a // p a } => M \u2191i \u2191j)", "start": [204, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toSquareBlock", "code": "def toSquareBlock (M : Matrix m m \u03b1) (b : m \u2192 \u03b2) (k : \u03b2) :\n    Matrix { a // b a = k } { a // b a = k } \u03b1 :=\n  toSquareBlockProp M _", "start": [210, 1], "end": [214, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.toSquareBlock_def", "code": "theorem toSquareBlock_def (M : Matrix m m \u03b1) (b : m \u2192 \u03b2) (k : \u03b2) :\n    toSquareBlock M b k = of (fun i j : { a // b a = k } => M \u2191i \u2191j)", "start": [217, 1], "end": [220, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_smul", "code": "theorem fromBlocks_smul [SMul R \u03b1] (x : R) (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) : x \u2022 fromBlocks A B C D = fromBlocks (x \u2022 A) (x \u2022 B) (x \u2022 C) (x \u2022 D)", "start": [223, 1], "end": [225, 71], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_neg", "code": "theorem fromBlocks_neg [Neg R] (A : Matrix n l R) (B : Matrix n m R) (C : Matrix o l R)\n    (D : Matrix o m R) : -fromBlocks A B C D = fromBlocks (-A) (-B) (-C) (-D)", "start": [228, 1], "end": [231, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_zero", "code": "@[simp]\ntheorem fromBlocks_zero [Zero \u03b1] : fromBlocks (0 : Matrix n l \u03b1) 0 0 (0 : Matrix o m \u03b1) = 0", "start": [234, 1], "end": [237, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_add", "code": "theorem fromBlocks_add [Add \u03b1] (A : Matrix n l \u03b1) (B : Matrix n m \u03b1) (C : Matrix o l \u03b1)\n    (D : Matrix o m \u03b1) (A' : Matrix n l \u03b1) (B' : Matrix n m \u03b1) (C' : Matrix o l \u03b1)\n    (D' : Matrix o m \u03b1) :\n    fromBlocks A B C D + fromBlocks A' B' C' D' = fromBlocks (A + A') (B + B') (C + C') (D + D')", "start": [240, 1], "end": [244, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_multiply", "code": "theorem fromBlocks_multiply [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (A' : Matrix l p \u03b1) (B' : Matrix l q \u03b1)\n    (C' : Matrix m p \u03b1) (D' : Matrix m q \u03b1) :\n    fromBlocks A B C D * fromBlocks A' B' C' D' =\n      fromBlocks (A * A' + B * C') (A * B' + B * D') (C * A' + D * C') (C * B' + D * D')", "start": [247, 1], "end": [254, 67], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_mulVec", "code": "theorem fromBlocks_mulVec [Fintype l] [Fintype m] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (x : Sum l m \u2192 \u03b1) :\n    mulVec (fromBlocks A B C D) x =\n      Sum.elim (mulVec A (x \u2218 Sum.inl) + mulVec B (x \u2218 Sum.inr))\n        (mulVec C (x \u2218 Sum.inl) + mulVec D (x \u2218 Sum.inr))", "start": [257, 1], "end": [263, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_fromBlocks", "code": "theorem vecMul_fromBlocks [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring \u03b1] (A : Matrix n l \u03b1)\n    (B : Matrix n m \u03b1) (C : Matrix o l \u03b1) (D : Matrix o m \u03b1) (x : Sum n o \u2192 \u03b1) :\n    vecMul x (fromBlocks A B C D) =\n      Sum.elim (vecMul (x \u2218 Sum.inl) A + vecMul (x \u2218 Sum.inr) C)\n        (vecMul (x \u2218 Sum.inl) B + vecMul (x \u2218 Sum.inr) D)", "start": [266, 1], "end": [272, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_diagonal_self", "code": "theorem toBlock_diagonal_self (d : m \u2192 \u03b1) (p : m \u2192 Prop) :\n    Matrix.toBlock (diagonal d) p p = diagonal fun i : Subtype p => d \u2191i", "start": [281, 1], "end": [286, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_diagonal_disjoint", "code": "theorem toBlock_diagonal_disjoint (d : m \u2192 \u03b1) {p q : m \u2192 Prop} (hpq : Disjoint p q) :\n    Matrix.toBlock (diagonal d) p q = 0", "start": [289, 1], "end": [293, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.fromBlocks_diagonal", "code": "@[simp]\ntheorem fromBlocks_diagonal (d\u2081 : l \u2192 \u03b1) (d\u2082 : m \u2192 \u03b1) :\n    fromBlocks (diagonal d\u2081) 0 0 (diagonal d\u2082) = diagonal (Sum.elim d\u2081 d\u2082)", "start": [296, 1], "end": [300, 60], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlocks\u2081\u2081_diagonal", "code": "@[simp]\nlemma toBlocks\u2081\u2081_diagonal (v : l \u2295 m \u2192 \u03b1) :\n    toBlocks\u2081\u2081 (diagonal v) = diagonal (fun i => v (Sum.inl i)) := by\n  unfold toBlocks\u2081\u2081\n  funext i j\n  simp only [ne_eq, Sum.inl.injEq, of_apply, diagonal_apply]", "start": [303, 1], "end": [308, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toBlocks\u2082\u2082_diagonal", "code": "@[simp]\nlemma toBlocks\u2082\u2082_diagonal (v : l \u2295 m \u2192 \u03b1) :\n    toBlocks\u2082\u2082 (diagonal v) = diagonal (fun i => v (Sum.inr i)) := by\n  unfold toBlocks\u2082\u2082\n  funext i j\n  simp only [ne_eq, Sum.inr.injEq, of_apply, diagonal_apply]", "start": [310, 1], "end": [315, 61], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toBlocks\u2081\u2082_diagonal", "code": "@[simp]\nlemma toBlocks\u2081\u2082_diagonal (v : l \u2295 m \u2192 \u03b1) : toBlocks\u2081\u2082 (diagonal v) = 0 := rfl", "start": [317, 1], "end": [318, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.toBlocks\u2082\u2081_diagonal", "code": "@[simp]\nlemma toBlocks\u2082\u2081_diagonal (v : l \u2295 m \u2192 \u03b1) : toBlocks\u2082\u2081 (diagonal v) = 0 := rfl", "start": [320, 1], "end": [321, 79], "kind": "mathlibtacticlemma"}, {"full_name": "Matrix.fromBlocks_one", "code": "@[simp]\ntheorem fromBlocks_one : fromBlocks (1 : Matrix l l \u03b1) 0 0 (1 : Matrix m m \u03b1) = 1", "start": [329, 1], "end": [332, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_one_self", "code": "@[simp]\ntheorem toBlock_one_self (p : m \u2192 Prop) : Matrix.toBlock (1 : Matrix m m \u03b1) p p = 1", "start": [335, 1], "end": [337, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_one_disjoint", "code": "theorem toBlock_one_disjoint {p q : m \u2192 Prop} (hpq : Disjoint p q) :\n    Matrix.toBlock (1 : Matrix m m \u03b1) p q = 0", "start": [340, 1], "end": [342, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal", "code": "def blockDiagonal (M : o \u2192 Matrix m n \u03b1) : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1 :=\n  of <| (fun \u27e8i, k\u27e9 \u27e8j, k'\u27e9 => if k = k' then M k i j else 0 : m \u00d7 o \u2192 n \u00d7 o \u2192 \u03b1)", "start": [357, 1], "end": [364, 82], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_apply'", "code": "theorem blockDiagonal_apply' (M : o \u2192 Matrix m n \u03b1) (i k j k') :\n    blockDiagonal M \u27e8i, k\u27e9 \u27e8j, k'\u27e9 = if k = k' then M k i j else 0", "start": [368, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_apply", "code": "theorem blockDiagonal_apply (M : o \u2192 Matrix m n \u03b1) (ik jk) :\n    blockDiagonal M ik jk = if ik.2 = jk.2 then M ik.2 ik.1 jk.1 else 0", "start": [373, 1], "end": [377, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_apply_eq", "code": "@[simp]\ntheorem blockDiagonal_apply_eq (M : o \u2192 Matrix m n \u03b1) (i j k) :\n    blockDiagonal M (i, k) (j, k) = M k i j", "start": [380, 1], "end": [383, 13], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_apply_ne", "code": "theorem blockDiagonal_apply_ne (M : o \u2192 Matrix m n \u03b1) (i j) {k k'} (h : k \u2260 k') :\n    blockDiagonal M (i, k) (j, k') = 0", "start": [386, 1], "end": [388, 11], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_map", "code": "theorem blockDiagonal_map (M : o \u2192 Matrix m n \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : f 0 = 0) :\n    (blockDiagonal M).map f = blockDiagonal fun k => (M k).map f", "start": [391, 1], "end": [395, 23], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_transpose", "code": "@[simp]\ntheorem blockDiagonal_transpose (M : o \u2192 Matrix m n \u03b1) :\n    (blockDiagonal M)\u1d40 = blockDiagonal fun k => (M k)\u1d40", "start": [398, 1], "end": [405, 8], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_conjTranspose", "code": "@[simp]\ntheorem blockDiagonal_conjTranspose {\u03b1 : Type*} [AddMonoid \u03b1] [StarAddMonoid \u03b1]\n    (M : o \u2192 Matrix m n \u03b1) : (blockDiagonal M)\u1d34 = blockDiagonal fun k => (M k)\u1d34", "start": [408, 1], "end": [412, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_zero", "code": "@[simp]\ntheorem blockDiagonal_zero : blockDiagonal (0 : o \u2192 Matrix m n \u03b1) = 0", "start": [415, 1], "end": [418, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_diagonal", "code": "@[simp]\ntheorem blockDiagonal_diagonal [DecidableEq m] (d : o \u2192 m \u2192 \u03b1) :\n    (blockDiagonal fun k => diagonal (d k)) = diagonal fun ik => d ik.2 ik.1", "start": [421, 1], "end": [427, 16], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_one", "code": "@[simp]\ntheorem blockDiagonal_one [DecidableEq m] [One \u03b1] : blockDiagonal (1 : o \u2192 Matrix m m \u03b1) = 1", "start": [430, 1], "end": [433, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_add", "code": "@[simp]\ntheorem blockDiagonal_add [AddZeroClass \u03b1] (M N : o \u2192 Matrix m n \u03b1) :\n    blockDiagonal (M + N) = blockDiagonal M + blockDiagonal N", "start": [438, 1], "end": [443, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonalAddMonoidHom", "code": "@[simps]\ndef blockDiagonalAddMonoidHom [AddZeroClass \u03b1] : (o \u2192 Matrix m n \u03b1) \u2192+ Matrix (m \u00d7 o) (n \u00d7 o) \u03b1\n    where\n  toFun := blockDiagonal\n  map_zero' := blockDiagonal_zero\n  map_add' := blockDiagonal_add", "start": [450, 1], "end": [456, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_neg", "code": "@[simp]\ntheorem blockDiagonal_neg [AddGroup \u03b1] (M : o \u2192 Matrix m n \u03b1) :\n    blockDiagonal (-M) = -blockDiagonal M", "start": [461, 1], "end": [464, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_sub", "code": "@[simp]\ntheorem blockDiagonal_sub [AddGroup \u03b1] (M N : o \u2192 Matrix m n \u03b1) :\n    blockDiagonal (M - N) = blockDiagonal M - blockDiagonal N", "start": [467, 1], "end": [470, 50], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_mul", "code": "@[simp]\ntheorem blockDiagonal_mul [Fintype n] [Fintype o] [NonUnitalNonAssocSemiring \u03b1]\n    (M : o \u2192 Matrix m n \u03b1) (N : o \u2192 Matrix n p \u03b1) :\n    (blockDiagonal fun k => M k * N k) = blockDiagonal M * blockDiagonal N", "start": [473, 1], "end": [479, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonalRingHom", "code": "@[simps]\ndef blockDiagonalRingHom [DecidableEq m] [Fintype o] [Fintype m] [NonAssocSemiring \u03b1] :\n    (o \u2192 Matrix m m \u03b1) \u2192+* Matrix (m \u00d7 o) (m \u00d7 o) \u03b1 :=\n  { blockDiagonalAddMonoidHom m m o \u03b1 with\n    toFun := blockDiagonal\n    map_one' := blockDiagonal_one\n    map_mul' := blockDiagonal_mul }", "start": [486, 1], "end": [493, 36], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_pow", "code": "@[simp]\ntheorem blockDiagonal_pow [DecidableEq m] [Fintype o] [Fintype m] [Semiring \u03b1]\n    (M : o \u2192 Matrix m m \u03b1) (n : \u2115) : blockDiagonal (M ^ n) = blockDiagonal M ^ n", "start": [498, 1], "end": [501, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_smul", "code": "@[simp]\ntheorem blockDiagonal_smul {R : Type*} [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] (x : R)\n    (M : o \u2192 Matrix m n \u03b1) : blockDiagonal (x \u2022 M) = x \u2022 blockDiagonal M", "start": [504, 1], "end": [509, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag", "code": "def blockDiag (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) (k : o) : Matrix m n \u03b1 :=\n  of fun i j => M (i, k) (j, k)", "start": [516, 1], "end": [520, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_apply", "code": "theorem blockDiag_apply (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) (k : o) (i j) :\n    blockDiag M k i j = M (i, k) (j, k)", "start": [524, 1], "end": [526, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_map", "code": "theorem blockDiag_map (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    blockDiag (M.map f) = fun k => (blockDiag M k).map f", "start": [529, 1], "end": [531, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_transpose", "code": "@[simp]\ntheorem blockDiag_transpose (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) (k : o) :\n    blockDiag M\u1d40 k = (blockDiag M k)\u1d40", "start": [534, 1], "end": [537, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_conjTranspose", "code": "@[simp]\ntheorem blockDiag_conjTranspose {\u03b1 : Type*} [AddMonoid \u03b1] [StarAddMonoid \u03b1]\n    (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) (k : o) : blockDiag M\u1d34 k = (blockDiag M k)\u1d34", "start": [540, 1], "end": [543, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_zero", "code": "@[simp]\ntheorem blockDiag_zero : blockDiag (0 : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) = 0", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_diagonal", "code": "@[simp]\ntheorem blockDiag_diagonal [DecidableEq o] [DecidableEq m] (d : m \u00d7 o \u2192 \u03b1) (k : o) :\n    blockDiag (diagonal d) k = diagonal fun i => d (i, k)", "start": [555, 1], "end": [562, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_blockDiagonal", "code": "@[simp]\ntheorem blockDiag_blockDiagonal [DecidableEq o] (M : o \u2192 Matrix m n \u03b1) :\n    blockDiag (blockDiagonal M) = M", "start": [565, 1], "end": [568, 64], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_injective", "code": "theorem blockDiagonal_injective [DecidableEq o] :\n    Function.Injective (blockDiagonal : (o \u2192 Matrix m n \u03b1) \u2192 Matrix _ _ \u03b1)", "start": [571, 1], "end": [573, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal_inj", "code": "@[simp]\ntheorem blockDiagonal_inj [DecidableEq o] {M N : o \u2192 Matrix m n \u03b1} :\n    blockDiagonal M = blockDiagonal N \u2194 M = N", "start": [576, 1], "end": [579, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_one", "code": "@[simp]\ntheorem blockDiag_one [DecidableEq o] [DecidableEq m] [One \u03b1] :\n    blockDiag (1 : Matrix (m \u00d7 o) (m \u00d7 o) \u03b1) = 1", "start": [582, 1], "end": [585, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_add", "code": "@[simp]\ntheorem blockDiag_add [AddZeroClass \u03b1] (M N : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) :\n    blockDiag (M + N) = blockDiag M + blockDiag N", "start": [590, 1], "end": [593, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagAddMonoidHom", "code": "@[simps]\ndef blockDiagAddMonoidHom [AddZeroClass \u03b1] : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1 \u2192+ o \u2192 Matrix m n \u03b1 where\n  toFun := blockDiag\n  map_zero' := blockDiag_zero\n  map_add' := blockDiag_add", "start": [600, 1], "end": [605, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_neg", "code": "@[simp]\ntheorem blockDiag_neg [AddGroup \u03b1] (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) : blockDiag (-M) = -blockDiag M", "start": [610, 1], "end": [612, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_sub", "code": "@[simp]\ntheorem blockDiag_sub [AddGroup \u03b1] (M N : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) :\n    blockDiag (M - N) = blockDiag M - blockDiag N", "start": [615, 1], "end": [618, 46], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag_smul", "code": "@[simp]\ntheorem blockDiag_smul {R : Type*} [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] (x : R)\n    (M : Matrix (m \u00d7 o) (n \u00d7 o) \u03b1) : blockDiag (x \u2022 M) = x \u2022 blockDiag M", "start": [621, 1], "end": [624, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'", "code": "def blockDiagonal' (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1 :=\n  of <|\n    (fun \u27e8k, i\u27e9 \u27e8k', j\u27e9 => if h : k = k' then M k i (cast (congr_arg n' h.symm) j) else 0 :\n      (\u03a3i, m' i) \u2192 (\u03a3i, n' i) \u2192 \u03b1)", "start": [637, 1], "end": [645, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_apply'", "code": "theorem blockDiagonal'_apply' (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (k i k' j) :\n    blockDiagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9 =\n      if h : k = k' then M k i (cast (congr_arg n' h.symm) j) else 0", "start": [649, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_eq_blockDiagonal", "code": "theorem blockDiagonal'_eq_blockDiagonal (M : o \u2192 Matrix m n \u03b1) {k k'} (i j) :\n    blockDiagonal M (i, k) (j, k') = blockDiagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9", "start": [655, 1], "end": [657, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_submatrix_eq_blockDiagonal", "code": "theorem blockDiagonal'_submatrix_eq_blockDiagonal (M : o \u2192 Matrix m n \u03b1) :\n    (blockDiagonal' M).submatrix (Prod.toSigma \u2218 Prod.swap) (Prod.toSigma \u2218 Prod.swap) =\n      blockDiagonal M", "start": [660, 1], "end": [663, 38], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_apply", "code": "theorem blockDiagonal'_apply (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (ik jk) :\n    blockDiagonal' M ik jk =\n      if h : ik.1 = jk.1 then M ik.1 ik.2 (cast (congr_arg n' h.symm) jk.2) else 0", "start": [666, 1], "end": [671, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_apply_eq", "code": "@[simp]\ntheorem blockDiagonal'_apply_eq (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (k i j) :\n    blockDiagonal' M \u27e8k, i\u27e9 \u27e8k, j\u27e9 = M k i j", "start": [674, 1], "end": [677, 14], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_apply_ne", "code": "theorem blockDiagonal'_apply_ne (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) {k k'} (i j) (h : k \u2260 k') :\n    blockDiagonal' M \u27e8k, i\u27e9 \u27e8k', j\u27e9 = 0", "start": [680, 1], "end": [682, 12], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_map", "code": "theorem blockDiagonal'_map (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (f : \u03b1 \u2192 \u03b2) (hf : f 0 = 0) :\n    (blockDiagonal' M).map f = blockDiagonal' fun k => (M k).map f", "start": [685, 1], "end": [689, 24], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_transpose", "code": "@[simp]\ntheorem blockDiagonal'_transpose (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    (blockDiagonal' M)\u1d40 = blockDiagonal' fun k => (M k)\u1d40", "start": [692, 1], "end": [701, 8], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_conjTranspose", "code": "@[simp]\ntheorem blockDiagonal'_conjTranspose {\u03b1} [AddMonoid \u03b1] [StarAddMonoid \u03b1]\n    (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) : (blockDiagonal' M)\u1d34 = blockDiagonal' fun k => (M k)\u1d34", "start": [704, 1], "end": [708, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_zero", "code": "@[simp]\ntheorem blockDiagonal'_zero : blockDiagonal' (0 : \u2200 i, Matrix (m' i) (n' i) \u03b1) = 0", "start": [711, 1], "end": [714, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_diagonal", "code": "@[simp]\ntheorem blockDiagonal'_diagonal [\u2200 i, DecidableEq (m' i)] (d : \u2200 i, m' i \u2192 \u03b1) :\n    (blockDiagonal' fun k => diagonal (d k)) = diagonal fun ik => d ik.1 ik.2", "start": [717, 1], "end": [724, 15], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_one", "code": "@[simp]\ntheorem blockDiagonal'_one [\u2200 i, DecidableEq (m' i)] [One \u03b1] :\n    blockDiagonal' (1 : \u2200 i, Matrix (m' i) (m' i) \u03b1) = 1", "start": [727, 1], "end": [731, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_add", "code": "@[simp]\ntheorem blockDiagonal'_add [AddZeroClass \u03b1] (M N : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    blockDiagonal' (M + N) = blockDiagonal' M + blockDiagonal' N", "start": [736, 1], "end": [741, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'AddMonoidHom", "code": "@[simps]\ndef blockDiagonal'AddMonoidHom [AddZeroClass \u03b1] :\n    (\u2200 i, Matrix (m' i) (n' i) \u03b1) \u2192+ Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1 where\n  toFun := blockDiagonal'\n  map_zero' := blockDiagonal'_zero\n  map_add' := blockDiagonal'_add", "start": [748, 1], "end": [754, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_neg", "code": "@[simp]\ntheorem blockDiagonal'_neg [AddGroup \u03b1] (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    blockDiagonal' (-M) = -blockDiagonal' M", "start": [759, 1], "end": [762, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_sub", "code": "@[simp]\ntheorem blockDiagonal'_sub [AddGroup \u03b1] (M N : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    blockDiagonal' (M - N) = blockDiagonal' M - blockDiagonal' N", "start": [765, 1], "end": [768, 51], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_mul", "code": "@[simp]\ntheorem blockDiagonal'_mul [NonUnitalNonAssocSemiring \u03b1] [\u2200 i, Fintype (n' i)] [Fintype o]\n    (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) (N : \u2200 i, Matrix (n' i) (p' i) \u03b1) :\n    (blockDiagonal' fun k => M k * N k) = blockDiagonal' M * blockDiagonal' N", "start": [771, 1], "end": [781, 75], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'RingHom", "code": "@[simps]\ndef blockDiagonal'RingHom [\u2200 i, DecidableEq (m' i)] [Fintype o] [\u2200 i, Fintype (m' i)]\n    [NonAssocSemiring \u03b1] : (\u2200 i, Matrix (m' i) (m' i) \u03b1) \u2192+* Matrix (\u03a3i, m' i) (\u03a3i, m' i) \u03b1 :=\n  { blockDiagonal'AddMonoidHom m' m' \u03b1 with\n    toFun := blockDiagonal'\n    map_one' := blockDiagonal'_one\n    map_mul' := blockDiagonal'_mul }", "start": [788, 1], "end": [795, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_pow", "code": "@[simp]\ntheorem blockDiagonal'_pow [\u2200 i, DecidableEq (m' i)] [Fintype o] [\u2200 i, Fintype (m' i)] [Semiring \u03b1]\n    (M : \u2200 i, Matrix (m' i) (m' i) \u03b1) (n : \u2115) : blockDiagonal' (M ^ n) = blockDiagonal' M ^ n", "start": [800, 1], "end": [803, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_smul", "code": "@[simp]\ntheorem blockDiagonal'_smul {R : Type*} [Semiring R] [AddCommMonoid \u03b1] [Module R \u03b1] (x : R)\n    (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) : blockDiagonal' (x \u2022 M) = x \u2022 blockDiagonal' M", "start": [806, 1], "end": [811, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'", "code": "def blockDiag' (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) (k : o) : Matrix (m' k) (n' k) \u03b1 :=\n  of fun i j => M \u27e8k, i\u27e9 \u27e8k, j\u27e9", "start": [818, 1], "end": [822, 32], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_apply", "code": "theorem blockDiag'_apply (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) (k : o) (i j) :\n    blockDiag' M k i j = M \u27e8k, i\u27e9 \u27e8k, j\u27e9", "start": [826, 1], "end": [828, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_map", "code": "theorem blockDiag'_map (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) (f : \u03b1 \u2192 \u03b2) :\n    blockDiag' (M.map f) = fun k => (blockDiag' M k).map f", "start": [831, 1], "end": [833, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_transpose", "code": "@[simp]\ntheorem blockDiag'_transpose (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) (k : o) :\n    blockDiag' M\u1d40 k = (blockDiag' M k)\u1d40", "start": [836, 1], "end": [839, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_conjTranspose", "code": "@[simp]\ntheorem blockDiag'_conjTranspose {\u03b1 : Type*} [AddMonoid \u03b1] [StarAddMonoid \u03b1]\n    (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) (k : o) : blockDiag' M\u1d34 k = (blockDiag' M k)\u1d34", "start": [842, 1], "end": [845, 21], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_zero", "code": "@[simp]\ntheorem blockDiag'_zero : blockDiag' (0 : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) = 0", "start": [852, 1], "end": [854, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_diagonal", "code": "@[simp]\ntheorem blockDiag'_diagonal [DecidableEq o] [\u2200 i, DecidableEq (m' i)] (d : (\u03a3i, m' i) \u2192 \u03b1) (k : o) :\n    blockDiag' (diagonal d) k = diagonal fun i => d \u27e8k, i\u27e9", "start": [857, 1], "end": [865, 10], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_blockDiagonal'", "code": "@[simp]\ntheorem blockDiag'_blockDiagonal' [DecidableEq o] (M : \u2200 i, Matrix (m' i) (n' i) \u03b1) :\n    blockDiag' (blockDiagonal' M) = M", "start": [868, 1], "end": [871, 65], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_injective", "code": "theorem blockDiagonal'_injective [DecidableEq o] :\n    Function.Injective (blockDiagonal' : (\u2200 i, Matrix (m' i) (n' i) \u03b1) \u2192 Matrix _ _ \u03b1)", "start": [874, 1], "end": [876, 59], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiagonal'_inj", "code": "@[simp]\ntheorem blockDiagonal'_inj [DecidableEq o] {M N : \u2200 i, Matrix (m' i) (n' i) \u03b1} :\n    blockDiagonal' M = blockDiagonal' N \u2194 M = N", "start": [879, 1], "end": [882, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_one", "code": "@[simp]\ntheorem blockDiag'_one [DecidableEq o] [\u2200 i, DecidableEq (m' i)] [One \u03b1] :\n    blockDiag' (1 : Matrix (\u03a3i, m' i) (\u03a3i, m' i) \u03b1) = 1", "start": [885, 1], "end": [888, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_add", "code": "@[simp]\ntheorem blockDiag'_add [AddZeroClass \u03b1] (M N : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) :\n    blockDiag' (M + N) = blockDiag' M + blockDiag' N", "start": [893, 1], "end": [896, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'AddMonoidHom", "code": "@[simps]\ndef blockDiag'AddMonoidHom [AddZeroClass \u03b1] :\n    Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1 \u2192+ \u2200 i, Matrix (m' i) (n' i) \u03b1 where\n  toFun := blockDiag'\n  map_zero' := blockDiag'_zero\n  map_add' := blockDiag'_add", "start": [903, 1], "end": [909, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_neg", "code": "@[simp]\ntheorem blockDiag'_neg [AddGroup \u03b1] (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) :\n    blockDiag' (-M) = -blockDiag' M", "start": [914, 1], "end": [917, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_sub", "code": "@[simp]\ntheorem blockDiag'_sub [AddGroup \u03b1] (M N : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) :\n    blockDiag' (M - N) = blockDiag' M - blockDiag' N", "start": [920, 1], "end": [923, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.blockDiag'_smul", "code": "@[simp]\ntheorem blockDiag'_smul {R : Type*} [Monoid R] [AddMonoid \u03b1] [DistribMulAction R \u03b1] (x : R)\n    (M : Matrix (\u03a3i, m' i) (\u03a3i, n' i) \u03b1) : blockDiag' (x \u2022 M) = x \u2022 blockDiag' M", "start": [926, 1], "end": [929, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_mul_eq_mul", "code": "theorem toBlock_mul_eq_mul {m n k : Type*} [Fintype n] (p : m \u2192 Prop) (q : k \u2192 Prop)\n    (A : Matrix m n R) (B : Matrix n k R) :\n    (A * B).toBlock p q = A.toBlock p \u22a4 * B.toBlock \u22a4 q", "start": [938, 1], "end": [944, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.toBlock_mul_eq_add", "code": "theorem toBlock_mul_eq_add {m n k : Type*} [Fintype n] (p : m \u2192 Prop) (q : n \u2192 Prop)\n    [DecidablePred q] (r : k \u2192 Prop) (A : Matrix m n R) (B : Matrix n k R) : (A * B).toBlock p r =\n    A.toBlock p q * B.toBlock q r + (A.toBlock p fun i => \u00acq i) * B.toBlock (fun i => \u00acq i) r", "start": [947, 1], "end": [953, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Module/Algebra.lean", "imports": ["Mathlib/Algebra/Module/Basic.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.restrictScalarsLinearMap", "code": "@[simps]\ndef restrictScalarsLinearMap : (M \u2192\u2097[A] N) \u2192\u2097[k] M \u2192\u2097[k] N where\n  toFun := LinearMap.restrictScalars k\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl", "start": [26, 1], "end": [32, 23], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Nat/Parity.lean", "imports": ["Mathlib/Algebra/Parity.lean", "Mathlib/Data/Nat/ModEq.lean", "Mathlib/Data/Nat/Prime.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.mod_two_ne_one", "code": "@[simp]\ntheorem mod_two_ne_one : \u00acn % 2 = 1 \u2194 n % 2 = 0", "start": [27, 1], "end": [29, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_two_ne_zero", "code": "@[simp]\ntheorem mod_two_ne_zero : \u00acn % 2 = 0 \u2194 n % 2 = 1", "start": [32, 1], "end": [34, 56], "kind": "commanddeclaration"}, {"full_name": "Nat.even_iff", "code": "theorem even_iff : Even n \u2194 n % 2 = 0", "start": [37, 1], "end": [39, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_iff", "code": "theorem odd_iff : Odd n \u2194 n % 2 = 1", "start": [44, 1], "end": [46, 74], "kind": "commanddeclaration"}, {"full_name": "Nat.not_even_iff", "code": "theorem not_even_iff : \u00acEven n \u2194 n % 2 = 1", "start": [51, 1], "end": [51, 80], "kind": "commanddeclaration"}, {"full_name": "Nat.not_odd_iff", "code": "theorem not_odd_iff : \u00acOdd n \u2194 n % 2 = 0", "start": [54, 1], "end": [54, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.even_iff_not_odd", "code": "theorem even_iff_not_odd : Even n \u2194 \u00acOdd n", "start": [57, 1], "end": [57, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_iff_not_even", "code": "@[simp]\ntheorem odd_iff_not_even : Odd n \u2194 \u00acEven n", "start": [60, 1], "end": [61, 76], "kind": "commanddeclaration"}, {"full_name": "Odd.not_two_dvd_nat", "code": "theorem _root_.Odd.not_two_dvd_nat (h : Odd n) : \u00ac(2 \u2223 n)", "start": [64, 1], "end": [65, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.isCompl_even_odd", "code": "theorem isCompl_even_odd : IsCompl { n : \u2115 | Even n } { n | Odd n }", "start": [67, 1], "end": [68, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.even_xor_odd", "code": "theorem even_xor_odd (n : \u2115) : Xor' (Even n) (Odd n)", "start": [71, 1], "end": [72, 55], "kind": "commanddeclaration"}, {"full_name": "Nat.even_or_odd", "code": "theorem even_or_odd (n : \u2115) : Even n \u2228 Odd n", "start": [75, 1], "end": [76, 22], "kind": "commanddeclaration"}, {"full_name": "Nat.even_or_odd'", "code": "theorem even_or_odd' (n : \u2115) : \u2203 k, n = 2 * k \u2228 n = 2 * k + 1", "start": [79, 1], "end": [80, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.even_xor_odd'", "code": "theorem even_xor_odd' (n : \u2115) : \u2203 k, Xor' (n = 2 * k) (n = 2 * k + 1)", "start": [83, 1], "end": [86, 59], "kind": "commanddeclaration"}, {"full_name": "Nat.two_dvd_ne_zero", "code": "@[simp] theorem two_dvd_ne_zero : \u00ac2 \u2223 n \u2194 n % 2 = 1", "start": [89, 1], "end": [90, 47], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_two_add_add_odd_mod_two", "code": "theorem mod_two_add_add_odd_mod_two (m : \u2115) {n : \u2115} (hn : Odd n) : m % 2 + (m + n) % 2 = 1", "start": [93, 1], "end": [95, 50], "kind": "commanddeclaration"}, {"full_name": "Nat.mod_two_add_succ_mod_two", "code": "@[simp]\ntheorem mod_two_add_succ_mod_two (m : \u2115) : m % 2 + (m + 1) % 2 = 1", "start": [98, 1], "end": [100, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.succ_mod_two_add_mod_two", "code": "@[simp]\ntheorem succ_mod_two_add_mod_two (m : \u2115) : (m + 1) % 2 + m % 2 = 1", "start": [103, 1], "end": [105, 42], "kind": "commanddeclaration"}, {"full_name": "Nat.not_even_one", "code": "@[simp] theorem not_even_one : \u00acEven 1", "start": [108, 1], "end": [108, 69], "kind": "commanddeclaration"}, {"full_name": "Nat.even_add", "code": "@[parity_simps]\ntheorem even_add : Even (m + n) \u2194 (Even m \u2194 Even n)", "start": [111, 1], "end": [114, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.even_add'", "code": "theorem even_add' : Even (m + n) \u2194 (Odd m \u2194 Odd n)", "start": [117, 1], "end": [118, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.even_add_one", "code": "@[parity_simps]\ntheorem even_add_one : Even (n + 1) \u2194 \u00acEven n", "start": [121, 1], "end": [122, 68], "kind": "commanddeclaration"}, {"full_name": "Nat.not_even_bit1", "code": "@[simp]\ntheorem not_even_bit1 (n : \u2115) : \u00acEven (bit1 n)", "start": [126, 1], "end": [127, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.two_not_dvd_two_mul_add_one", "code": "theorem two_not_dvd_two_mul_add_one (n : \u2115) : \u00ac2 \u2223 2 * n + 1", "start": [130, 1], "end": [130, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.two_not_dvd_two_mul_sub_one", "code": "theorem two_not_dvd_two_mul_sub_one : \u2200 {n}, 0 < n \u2192 \u00ac2 \u2223 2 * n - 1", "start": [133, 1], "end": [134, 46], "kind": "commanddeclaration"}, {"full_name": "Nat.even_sub", "code": "@[parity_simps]\ntheorem even_sub (h : n \u2264 m) : Even (m - n) \u2194 (Even m \u2194 Even n)", "start": [137, 1], "end": [140, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.even_sub'", "code": "theorem even_sub' (h : n \u2264 m) : Even (m - n) \u2194 (Odd m \u2194 Odd n)", "start": [143, 1], "end": [144, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.Odd.sub_odd", "code": "theorem Odd.sub_odd (hm : Odd m) (hn : Odd n) : Even (m - n)", "start": [147, 1], "end": [149, 53], "kind": "commanddeclaration"}, {"full_name": "Nat.even_mul", "code": "@[parity_simps]\ntheorem even_mul : Even (m * n) \u2194 Even m \u2228 Even n", "start": [152, 1], "end": [155, 41], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_mul", "code": "theorem odd_mul : Odd (m * n) \u2194 Odd m \u2227 Odd n", "start": [158, 1], "end": [158, 76], "kind": "commanddeclaration"}, {"full_name": "Nat.Odd.of_mul_left", "code": "theorem Odd.of_mul_left (h : Odd (m * n)) : Odd m", "start": [161, 1], "end": [162, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.Odd.of_mul_right", "code": "theorem Odd.of_mul_right (h : Odd (m * n)) : Odd n", "start": [165, 1], "end": [166, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.even_pow", "code": "@[parity_simps] theorem even_pow : Even (m ^ n) \u2194 Even m \u2227 n \u2260 0", "start": [169, 1], "end": [172, 94], "kind": "commanddeclaration"}, {"full_name": "Nat.even_pow'", "code": "theorem even_pow' (h : n \u2260 0) : Even (m ^ n) \u2194 Even m", "start": [175, 1], "end": [176, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.even_div", "code": "theorem even_div : Even (m / n) \u2194 m % (2 * n) / n = 0", "start": [179, 1], "end": [180, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_add", "code": "@[parity_simps] theorem odd_add : Odd (m + n) \u2194 (Odd m \u2194 Even n)", "start": [183, 1], "end": [184, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_add'", "code": "theorem odd_add' : Odd (m + n) \u2194 (Odd n \u2194 Even m)", "start": [187, 1], "end": [187, 79], "kind": "commanddeclaration"}, {"full_name": "Nat.ne_of_odd_add", "code": "theorem ne_of_odd_add (h : Odd (m + n)) : m \u2260 n", "start": [190, 1], "end": [190, 83], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_sub", "code": "@[parity_simps] theorem odd_sub (h : n \u2264 m) : Odd (m - n) \u2194 (Odd m \u2194 Even n)", "start": [193, 1], "end": [194, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.Odd.sub_even", "code": "theorem Odd.sub_even (h : n \u2264 m) (hm : Odd m) (hn : Even n) : Odd (m - n)", "start": [197, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "Nat.odd_sub'", "code": "theorem odd_sub' (h : n \u2264 m) : Odd (m - n) \u2194 (Odd n \u2194 Even m)", "start": [201, 1], "end": [202, 77], "kind": "commanddeclaration"}, {"full_name": "Nat.Even.sub_odd", "code": "theorem Even.sub_odd (h : n \u2264 m) (hm : Even m) (hn : Odd n) : Odd (m - n)", "start": [205, 1], "end": [206, 40], "kind": "commanddeclaration"}, {"full_name": "Nat.even_mul_succ_self", "code": "theorem even_mul_succ_self (n : \u2115) : Even (n * (n + 1))", "start": [209, 1], "end": [211, 13], "kind": "commanddeclaration"}, {"full_name": "Nat.even_mul_self_pred", "code": "theorem even_mul_self_pred : \u2200 n : \u2115, Even (n * (n - 1))", "start": [214, 1], "end": [216, 67], "kind": "commanddeclaration"}, {"full_name": "Nat.two_mul_div_two_of_even", "code": "theorem two_mul_div_two_of_even : Even n \u2192 2 * (n / 2) = n", "start": [219, 1], "end": [220, 51], "kind": "commanddeclaration"}, {"full_name": "Nat.div_two_mul_two_of_even", "code": "theorem div_two_mul_two_of_even : Even n \u2192 n / 2 * 2 = n", "start": [223, 1], "end": [224, 54], "kind": "commanddeclaration"}, {"full_name": "Nat.two_mul_div_two_add_one_of_odd", "code": "theorem two_mul_div_two_add_one_of_odd (h : Odd n) : 2 * (n / 2) + 1 = n", "start": [227, 1], "end": [228, 35], "kind": "commanddeclaration"}, {"full_name": "Nat.div_two_mul_two_add_one_of_odd", "code": "theorem div_two_mul_two_add_one_of_odd (h : Odd n) : n / 2 * 2 + 1 = n", "start": [231, 1], "end": [232, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.one_add_div_two_mul_two_of_odd", "code": "theorem one_add_div_two_mul_two_of_odd (h : Odd n) : 1 + n / 2 * 2 = n", "start": [235, 1], "end": [236, 36], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_div_two", "code": "theorem bit0_div_two : bit0 n / 2 = n", "start": [242, 1], "end": [243, 82], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_div_two", "code": "theorem bit1_div_two : bit1 n / 2 = n", "start": [246, 1], "end": [247, 98], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_div_bit0", "code": "@[simp]\ntheorem bit0_div_bit0 : bit0 n / bit0 m = n / m", "start": [250, 1], "end": [252, 65], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_div_bit0", "code": "@[simp]\ntheorem bit1_div_bit0 : bit1 n / bit0 m = n / m", "start": [255, 1], "end": [257, 63], "kind": "commanddeclaration"}, {"full_name": "Nat.bit0_mod_bit0", "code": "@[simp]\ntheorem bit0_mod_bit0 : bit0 n % bit0 m = bit0 (n % m)", "start": [260, 1], "end": [262, 91], "kind": "commanddeclaration"}, {"full_name": "Nat.bit1_mod_bit0", "code": "@[simp]\ntheorem bit1_mod_bit0 : bit1 n % bit0 m = bit1 (n % m)", "start": [265, 1], "end": [272, 43], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_bit0", "code": "theorem iterate_bit0 (hf : Involutive f) (n : \u2115) : f^[bit0 n] = id", "start": [298, 1], "end": [299, 82], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_bit1", "code": "theorem iterate_bit1 (hf : Involutive f) (n : \u2115) : f^[bit1 n] = f", "start": [302, 1], "end": [303, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_two_mul", "code": "theorem iterate_two_mul (hf : Involutive f) (n : \u2115) : f^[2 * n] = id", "start": [308, 1], "end": [309, 65], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_even", "code": "theorem iterate_even (hf : Involutive f) (hn : Even n) : f^[n] = id", "start": [311, 1], "end": [313, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_odd", "code": "theorem iterate_odd (hf : Involutive f) (hn : Odd n) : f^[n] = f", "start": [316, 1], "end": [318, 66], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_eq_self", "code": "theorem iterate_eq_self (hf : Involutive f) (hne : f \u2260 id) : f^[n] = f \u2194 Odd n", "start": [321, 1], "end": [323, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Involutive.iterate_eq_id", "code": "theorem iterate_eq_id (hf : Involutive f) (hne : f \u2260 id) : f^[n] = id \u2194 Even n", "start": [326, 1], "end": [327, 98], "kind": "commanddeclaration"}, {"full_name": "neg_one_pow_eq_one_iff_even", "code": "theorem neg_one_pow_eq_one_iff_even (h : (-1 : R) \u2260 1) : (-1 : R) ^ n = 1 \u2194 Even n", "start": [336, 1], "end": [338, 22], "kind": "commanddeclaration"}, {"full_name": "Odd.mod_even_iff", "code": "theorem Odd.mod_even_iff {n a : \u2115} (ha : Even a) : Odd (n % a) \u2194 Odd n", "start": [341, 1], "end": [344, 84], "kind": "commanddeclaration"}, {"full_name": "Even.mod_even_iff", "code": "theorem Even.mod_even_iff {n a : \u2115} (ha : Even a) : Even (n % a) \u2194 Even n", "start": [347, 1], "end": [350, 84], "kind": "commanddeclaration"}, {"full_name": "Odd.mod_even", "code": "theorem Odd.mod_even {n a : \u2115} (hn : Odd n) (ha : Even a) : Odd (n % a)", "start": [353, 1], "end": [355, 31], "kind": "commanddeclaration"}, {"full_name": "Even.mod_even", "code": "theorem Even.mod_even {n a : \u2115} (hn : Even n) (ha : Even a) : Even (n % a)", "start": [358, 1], "end": [360, 32], "kind": "commanddeclaration"}, {"full_name": "Odd.of_dvd_nat", "code": "theorem Odd.of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : Odd m", "start": [363, 1], "end": [364, 59], "kind": "commanddeclaration"}, {"full_name": "Odd.ne_two_of_dvd_nat", "code": "theorem Odd.ne_two_of_dvd_nat {m n : \u2115} (hn : Odd n) (hm : m \u2223 n) : m \u2260 2", "start": [367, 1], "end": [370, 46], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/Basic.lean", "imports": ["Mathlib/Data/Sum/Order.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/SetTheory/Cardinal/Basic.lean", "Mathlib/Order/InitialSeg.lean", "Mathlib/Tactic/PPWithUniv.lean"], "premises": [{"full_name": "nonempty_embedding_to_cardinal", "code": "theorem nonempty_embedding_to_cardinal : Nonempty (\u03c3 \u21aa Cardinal.{u})", "start": [81, 1], "end": [86, 51], "kind": "commanddeclaration"}, {"full_name": "embeddingToCardinal", "code": "def embeddingToCardinal : \u03c3 \u21aa Cardinal.{u} :=\n  Classical.choice nonempty_embedding_to_cardinal", "start": [89, 1], "end": [91, 50], "kind": "commanddeclaration"}, {"full_name": "WellOrderingRel", "code": "def WellOrderingRel : \u03c3 \u2192 \u03c3 \u2192 Prop :=\n  embeddingToCardinal \u207b\u00b9'o (\u00b7 < \u00b7)", "start": [94, 1], "end": [97, 35], "kind": "commanddeclaration"}, {"full_name": "WellOrderingRel.isWellOrder", "code": "instance WellOrderingRel.isWellOrder : IsWellOrder \u03c3 WellOrderingRel :=\n  (RelEmbedding.preimage _ _).isWellOrder", "start": [100, 1], "end": [101, 42], "kind": "commanddeclaration"}, {"full_name": "IsWellOrder.subtype_nonempty", "code": "instance IsWellOrder.subtype_nonempty : Nonempty { r // IsWellOrder \u03c3 r } :=\n  \u27e8\u27e8WellOrderingRel, inferInstance\u27e9\u27e9", "start": [104, 1], "end": [105, 37], "kind": "commanddeclaration"}, {"full_name": "WellOrder", "code": "structure WellOrder : Type (u + 1) where\n  \n  \u03b1 : Type u\n  \n  r : \u03b1 \u2192 \u03b1 \u2192 Prop\n  \n  wo : IsWellOrder \u03b1 r", "start": [113, 1], "end": [121, 23], "kind": "commanddeclaration"}, {"full_name": "WellOrder.inhabited", "code": "instance inhabited : Inhabited WellOrder :=\n  \u27e8\u27e8PEmpty, _, inferInstanceAs (IsWellOrder PEmpty EmptyRelation)\u27e9\u27e9", "start": [129, 1], "end": [130, 68], "kind": "commanddeclaration"}, {"full_name": "WellOrder.eta", "code": "@[simp]\ntheorem eta (o : WellOrder) : mk o.\u03b1 o.r o.wo = o", "start": [132, 1], "end": [135, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isEquivalent", "code": "instance Ordinal.isEquivalent : Setoid WellOrder\n    where\n  r := fun \u27e8_, r, _\u27e9 \u27e8_, s, _\u27e9 => Nonempty (r \u2243r s)\n  iseqv :=\n    \u27e8fun _ => \u27e8RelIso.refl _\u27e9, fun \u27e8e\u27e9 => \u27e8e.symm\u27e9, fun \u27e8e\u2081\u27e9 \u27e8e\u2082\u27e9 => \u27e8e\u2081.trans e\u2082\u27e9\u27e9", "start": [141, 1], "end": [147, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal", "code": "@[pp_with_univ]\ndef Ordinal : Type (u + 1) :=\n  Quotient Ordinal.isEquivalent", "start": [150, 1], "end": [153, 32], "kind": "commanddeclaration"}, {"full_name": "hasWellFoundedOut", "code": "instance hasWellFoundedOut (o : Ordinal) : WellFoundedRelation o.out.\u03b1 :=\n  \u27e8o.out.r, o.out.wo.wf\u27e9", "start": [156, 1], "end": [157, 25], "kind": "commanddeclaration"}, {"full_name": "linearOrderOut", "code": "instance linearOrderOut (o : Ordinal) : LinearOrder o.out.\u03b1 :=\n  IsWellOrder.linearOrder o.out.r", "start": [160, 1], "end": [161, 34], "kind": "commanddeclaration"}, {"full_name": "isWellOrder_out_lt", "code": "instance isWellOrder_out_lt (o : Ordinal) : IsWellOrder o.out.\u03b1 (\u00b7 < \u00b7) :=\n  o.out.wo", "start": [164, 1], "end": [165, 11], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type", "code": "def type (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [wo : IsWellOrder \u03b1 r] : Ordinal :=\n  \u27e6\u27e8\u03b1, r, wo\u27e9\u27e7", "start": [171, 1], "end": [173, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero", "code": "instance zero : Zero Ordinal :=\n  \u27e8type <| @EmptyRelation PEmpty\u27e9", "start": [176, 1], "end": [177, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.inhabited", "code": "instance inhabited : Inhabited Ordinal :=\n  \u27e80\u27e9", "start": [179, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one", "code": "instance one : One Ordinal :=\n  \u27e8type <| @EmptyRelation PUnit\u27e9", "start": [182, 1], "end": [183, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein", "code": "def typein (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (a : \u03b1) : Ordinal :=\n  type (Subrel r { b | r b a })", "start": [185, 1], "end": [188, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_def'", "code": "@[simp]\ntheorem type_def' (w : WellOrder) : \u27e6w\u27e7 = type w.r", "start": [191, 1], "end": [194, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_def", "code": "@[simp, nolint simpNF] theorem type_def (r) [wo : IsWellOrder \u03b1 r] : (\u27e6\u27e8\u03b1, r, wo\u27e9\u27e7 : Ordinal) = type r", "start": [197, 1], "end": [199, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_out", "code": "@[simp]\ntheorem type_out (o : Ordinal) : Ordinal.type o.out.r = o", "start": [202, 1], "end": [204, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_eq", "code": "theorem type_eq {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] :\n    type r = type s \u2194 Nonempty (r \u2243r s)", "start": [207, 1], "end": [209, 15], "kind": "commanddeclaration"}, {"full_name": "RelIso.ordinal_type_eq", "code": "theorem _root_.RelIso.ordinal_type_eq {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] (h : r \u2243r s) : type r = type s", "start": [212, 1], "end": [214, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_lt", "code": "@[simp]\ntheorem type_lt (o : Ordinal) : type ((\u00b7 < \u00b7) : o.out.\u03b1 \u2192 o.out.\u03b1 \u2192 Prop) = o", "start": [217, 1], "end": [219, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_eq_zero_of_empty", "code": "theorem type_eq_zero_of_empty (r) [IsWellOrder \u03b1 r] [IsEmpty \u03b1] : type r = 0", "start": [222, 1], "end": [223, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_eq_zero_iff_isEmpty", "code": "@[simp]\ntheorem type_eq_zero_iff_isEmpty [IsWellOrder \u03b1 r] : type r = 0 \u2194 IsEmpty \u03b1", "start": [226, 1], "end": [231, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_ne_zero_iff_nonempty", "code": "theorem type_ne_zero_iff_nonempty [IsWellOrder \u03b1 r] : type r \u2260 0 \u2194 Nonempty \u03b1", "start": [234, 1], "end": [234, 89], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_ne_zero_of_nonempty", "code": "theorem type_ne_zero_of_nonempty (r) [IsWellOrder \u03b1 r] [h : Nonempty \u03b1] : type r \u2260 0", "start": [237, 1], "end": [238, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_pEmpty", "code": "theorem type_pEmpty : type (@EmptyRelation PEmpty) = 0", "start": [241, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_empty", "code": "theorem type_empty : type (@EmptyRelation Empty) = 0", "start": [245, 1], "end": [246, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_eq_one_of_unique", "code": "theorem type_eq_one_of_unique (r) [IsWellOrder \u03b1 r] [Unique \u03b1] : type r = 1", "start": [249, 1], "end": [250, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_eq_one_iff_unique", "code": "@[simp]\ntheorem type_eq_one_iff_unique [IsWellOrder \u03b1 r] : type r = 1 \u2194 Nonempty (Unique \u03b1)", "start": [253, 1], "end": [258, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_pUnit", "code": "theorem type_pUnit : type (@EmptyRelation PUnit) = 1", "start": [261, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_unit", "code": "theorem type_unit : type (@EmptyRelation Unit) = 1", "start": [265, 1], "end": [266, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.out_empty_iff_eq_zero", "code": "@[simp]\ntheorem out_empty_iff_eq_zero {o : Ordinal} : IsEmpty o.out.\u03b1 \u2194 o = 0", "start": [269, 1], "end": [271, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.eq_zero_of_out_empty", "code": "theorem eq_zero_of_out_empty (o : Ordinal) [h : IsEmpty o.out.\u03b1] : o = 0", "start": [274, 1], "end": [275, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isEmpty_out_zero", "code": "instance isEmpty_out_zero : IsEmpty (0 : Ordinal).out.\u03b1 :=\n  out_empty_iff_eq_zero.2 rfl", "start": [278, 1], "end": [279, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.out_nonempty_iff_ne_zero", "code": "@[simp]\ntheorem out_nonempty_iff_ne_zero {o : Ordinal} : Nonempty o.out.\u03b1 \u2194 o \u2260 0", "start": [282, 1], "end": [284, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ne_zero_of_out_nonempty", "code": "theorem ne_zero_of_out_nonempty (o : Ordinal) [h : Nonempty o.out.\u03b1] : o \u2260 0", "start": [287, 1], "end": [288, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_ne_zero", "code": "protected theorem one_ne_zero : (1 : Ordinal) \u2260 0", "start": [291, 1], "end": [292, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nontrivial", "code": "instance nontrivial : Nontrivial Ordinal.{u} :=\n  \u27e8\u27e81, 0, Ordinal.one_ne_zero\u27e9\u27e9", "start": [295, 1], "end": [296, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_preimage", "code": "theorem type_preimage {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (f : \u03b2 \u2243 \u03b1) :\n    type (f \u207b\u00b9'o r) = type r", "start": [299, 1], "end": [301, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_preimage_aux", "code": "@[simp]\ntheorem type_preimage_aux {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (f : \u03b2 \u2243 \u03b1) :\n    @type _ (fun x y => r (f x) (f y)) (inferInstanceAs (IsWellOrder \u03b2 (\u2191f \u207b\u00b9'o r))) = type r", "start": [304, 1], "end": [307, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.inductionOn", "code": "@[elab_as_elim]\ntheorem inductionOn {C : Ordinal \u2192 Prop} (o : Ordinal)\n    (H : \u2200 (\u03b1 r) [IsWellOrder \u03b1 r], C (type r)) : C o", "start": [309, 1], "end": [312, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.partialOrder", "code": "instance partialOrder : PartialOrder Ordinal\n    where\n  le a b :=\n    Quotient.liftOn\u2082 a b (fun \u27e8_, r, _\u27e9 \u27e8_, s, _\u27e9 => Nonempty (r \u227ci s))\n      fun _ _ _ _ \u27e8f\u27e9 \u27e8g\u27e9 =>\n      propext\n        \u27e8fun \u27e8h\u27e9 => \u27e8(InitialSeg.ofIso f.symm).trans <| h.trans (InitialSeg.ofIso g)\u27e9, fun \u27e8h\u27e9 =>\n          \u27e8(InitialSeg.ofIso f).trans <| h.trans (InitialSeg.ofIso g.symm)\u27e9\u27e9\n  lt a b :=\n    Quotient.liftOn\u2082 a b (fun \u27e8_, r, _\u27e9 \u27e8_, s, _\u27e9 => Nonempty (r \u227ai s))\n      fun _ _ _ _ \u27e8f\u27e9 \u27e8g\u27e9 =>\n      propext\n        \u27e8fun \u27e8h\u27e9 => \u27e8PrincipalSeg.equivLT f.symm <| h.ltLe (InitialSeg.ofIso g)\u27e9, fun \u27e8h\u27e9 =>\n          \u27e8PrincipalSeg.equivLT f <| h.ltLe (InitialSeg.ofIso g.symm)\u27e9\u27e9\n  le_refl := Quot.ind fun \u27e8_, _, _\u27e9 => \u27e8InitialSeg.refl _\u27e9\n  le_trans a b c :=\n    Quotient.inductionOn\u2083 a b c fun _ _ _ \u27e8f\u27e9 \u27e8g\u27e9 => \u27e8f.trans g\u27e9\n  lt_iff_le_not_le a b :=\n    Quotient.inductionOn\u2082 a b fun _ _ =>\n      \u27e8fun \u27e8f\u27e9 => \u27e8\u27e8f\u27e9, fun \u27e8g\u27e9 => (f.ltLe g).irrefl\u27e9, fun \u27e8\u27e8f\u27e9, h\u27e9 =>\n        Sum.recOn f.ltOrEq (fun g => \u27e8g\u27e9) fun g => (h \u27e8InitialSeg.ofIso g.symm\u27e9).elim\u27e9\n  le_antisymm a b :=\n    Quotient.inductionOn\u2082 a b fun _ _ \u27e8h\u2081\u27e9 \u27e8h\u2082\u27e9 =>\n      Quot.sound \u27e8InitialSeg.antisymm h\u2081 h\u2082\u27e9", "start": [318, 1], "end": [341, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_le_iff", "code": "theorem type_le_iff {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] : type r \u2264 type s \u2194 Nonempty (r \u227ci s)", "start": [354, 1], "end": [356, 10], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_le_iff'", "code": "theorem type_le_iff' {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] : type r \u2264 type s \u2194 Nonempty (r \u21aar s)", "start": [359, 1], "end": [361, 44], "kind": "commanddeclaration"}, {"full_name": "InitialSeg.ordinal_type_le", "code": "theorem _root_.InitialSeg.ordinal_type_le {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] (h : r \u227ci s) : type r \u2264 type s", "start": [364, 1], "end": [366, 6], "kind": "commanddeclaration"}, {"full_name": "RelEmbedding.ordinal_type_le", "code": "theorem _root_.RelEmbedding.ordinal_type_le {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] (h : r \u21aar s) : type r \u2264 type s", "start": [369, 1], "end": [371, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_lt_iff", "code": "@[simp]\ntheorem type_lt_iff {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] : type r < type s \u2194 Nonempty (r \u227ai s)", "start": [374, 1], "end": [377, 10], "kind": "commanddeclaration"}, {"full_name": "PrincipalSeg.ordinal_type_lt", "code": "theorem _root_.PrincipalSeg.ordinal_type_lt {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop}\n    [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] (h : r \u227ai s) : type r < type s", "start": [380, 1], "end": [382, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_le", "code": "protected theorem zero_le (o : Ordinal) : 0 \u2264 o", "start": [385, 1], "end": [386, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.orderBot", "code": "instance orderBot : OrderBot Ordinal where\n  bot := 0\n  bot_le := Ordinal.zero_le", "start": [389, 1], "end": [391, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bot_eq_zero", "code": "@[simp]\ntheorem bot_eq_zero : (\u22a5 : Ordinal) = 0", "start": [393, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_zero", "code": "@[simp]\nprotected theorem le_zero {o : Ordinal} : o \u2264 0 \u2194 o = 0", "start": [398, 1], "end": [400, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pos_iff_ne_zero", "code": "protected theorem pos_iff_ne_zero {o : Ordinal} : 0 < o \u2194 o \u2260 0", "start": [403, 1], "end": [404, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.not_lt_zero", "code": "protected theorem not_lt_zero (o : Ordinal) : \u00aco < 0", "start": [407, 1], "end": [408, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.eq_zero_or_pos", "code": "theorem eq_zero_or_pos : \u2200 a : Ordinal, a = 0 \u2228 0 < a", "start": [411, 1], "end": [412, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zeroLEOneClass", "code": "instance zeroLEOneClass : ZeroLEOneClass Ordinal :=\n  \u27e8Ordinal.zero_le _\u27e9", "start": [415, 1], "end": [416, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.NeZero.one", "code": "instance NeZero.one : NeZero (1 : Ordinal) :=\n  \u27e8Ordinal.one_ne_zero\u27e9", "start": [418, 1], "end": [419, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.initialSegOut", "code": "def initialSegOut {\u03b1 \u03b2 : Ordinal} (h : \u03b1 \u2264 \u03b2) :\n    InitialSeg ((\u00b7 < \u00b7) : \u03b1.out.\u03b1 \u2192 \u03b1.out.\u03b1 \u2192 Prop) ((\u00b7 < \u00b7) : \u03b2.out.\u03b1 \u2192 \u03b2.out.\u03b1 \u2192 Prop) := by\n  change \u03b1.out.r \u227ci \u03b2.out.r\n  rw [\u2190 Quotient.out_eq \u03b1, \u2190 Quotient.out_eq \u03b2] at h; revert h\n  cases Quotient.out \u03b1; cases Quotient.out \u03b2; exact Classical.choice", "start": [422, 1], "end": [428, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principalSegOut", "code": "def principalSegOut {\u03b1 \u03b2 : Ordinal} (h : \u03b1 < \u03b2) :\n    PrincipalSeg ((\u00b7 < \u00b7) : \u03b1.out.\u03b1 \u2192 \u03b1.out.\u03b1 \u2192 Prop) ((\u00b7 < \u00b7) : \u03b2.out.\u03b1 \u2192 \u03b2.out.\u03b1 \u2192 Prop) := by\n  change \u03b1.out.r \u227ai \u03b2.out.r\n  rw [\u2190 Quotient.out_eq \u03b1, \u2190 Quotient.out_eq \u03b2] at h; revert h\n  cases Quotient.out \u03b1; cases Quotient.out \u03b2; exact Classical.choice", "start": [431, 1], "end": [437, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_lt_type", "code": "theorem typein_lt_type (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (a : \u03b1) : typein r a < type r", "start": [440, 1], "end": [441, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_lt_self", "code": "theorem typein_lt_self {o : Ordinal} (i : o.out.\u03b1) :\n    @typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) i < o", "start": [444, 1], "end": [447, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_top", "code": "@[simp]\ntheorem typein_top {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s]\n    (f : r \u227ai s) : typein s f.top = type r", "start": [450, 1], "end": [456, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_apply", "code": "@[simp]\ntheorem typein_apply {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s]\n    (f : r \u227ci s) (a : \u03b1) : Ordinal.typein s (f a) = Ordinal.typein r a", "start": [459, 1], "end": [470, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_lt_typein", "code": "@[simp]\ntheorem typein_lt_typein (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {a b : \u03b1} :\n    typein r a < typein r b \u2194 r a b", "start": [473, 1], "end": [484, 101], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_surj", "code": "theorem typein_surj (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {o} (h : o < type r) :\n    \u2203 a, typein r a = o", "start": [487, 1], "end": [489, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_injective", "code": "theorem typein_injective (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : Injective (typein r)", "start": [492, 1], "end": [493, 70], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_inj", "code": "@[simp]\ntheorem typein_inj (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {a b} : typein r a = typein r b \u2194 a = b", "start": [496, 1], "end": [498, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein.principalSeg", "code": "def typein.principalSeg {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    @PrincipalSeg \u03b1 Ordinal.{u} r (\u00b7 < \u00b7) :=\n  \u27e8\u27e8\u27e8typein r, typein_injective r\u27e9, typein_lt_typein r\u27e9, type r,\n    fun _ \u21a6 \u27e8typein_surj r, fun \u27e8a, h\u27e9 \u21a6 h \u25b8 typein_lt_type r a\u27e9\u27e9", "start": [501, 1], "end": [506, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein.principalSeg_coe", "code": "@[simp]\ntheorem typein.principalSeg_coe (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    (typein.principalSeg r : \u03b1 \u2192 Ordinal) = typein r", "start": [509, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum", "code": "def enum (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (o) (h : o < type r) : \u03b1 :=\n  (typein.principalSeg r).subrelIso \u27e8o, h\u27e9", "start": [518, 1], "end": [522, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_enum", "code": "@[simp]\ntheorem typein_enum (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {o} (h : o < type r) :\n    typein r (enum r o h) = o", "start": [524, 1], "end": [527, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_type", "code": "theorem enum_type {\u03b1 \u03b2} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s]\n    (f : s \u227ai r) {h : type s < type r} : enum r (type s) h = f.top", "start": [530, 1], "end": [532, 83], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_typein", "code": "@[simp]\ntheorem enum_typein (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (a : \u03b1) :\n    enum r (typein r a) (typein_lt_type r a) = a", "start": [535, 1], "end": [538, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_lt_enum", "code": "theorem enum_lt_enum {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] {o\u2081 o\u2082 : Ordinal} (h\u2081 : o\u2081 < type r)\n    (h\u2082 : o\u2082 < type r) : r (enum r o\u2081 h\u2081) (enum r o\u2082 h\u2082) \u2194 o\u2081 < o\u2082", "start": [541, 1], "end": [543, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.relIso_enum'", "code": "theorem relIso_enum' {\u03b1 \u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] (f : r \u2243r s) (o : Ordinal) :\n    \u2200 (hr : o < type r) (hs : o < type s), f (enum r o hr) = enum s o hs", "start": [546, 1], "end": [550, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.relIso_enum", "code": "theorem relIso_enum {\u03b1 \u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] (f : r \u2243r s) (o : Ordinal) (hr : o < type r) :\n    f (enum r o hr) =\n      enum s o\n        (by\n          convert hr using 1\n          apply Quotient.sound\n          exact \u27e8f.symm\u27e9)", "start": [553, 1], "end": [561, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_wf", "code": "theorem lt_wf : @WellFounded Ordinal (\u00b7 < \u00b7)", "start": [564, 1], "end": [579, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.wellFoundedRelation", "code": "instance wellFoundedRelation : WellFoundedRelation Ordinal :=\n  \u27e8(\u00b7 < \u00b7), lt_wf\u27e9", "start": [582, 1], "end": [583, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.induction", "code": "theorem induction {p : Ordinal.{u} \u2192 Prop} (i : Ordinal.{u}) (h : \u2200 j, (\u2200 k, k < j \u2192 p k) \u2192 p j) :\n    p i", "start": [585, 1], "end": [589, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card", "code": "def card : Ordinal \u2192 Cardinal :=\n  Quotient.map WellOrder.\u03b1 fun _ _ \u27e8e\u27e9 => \u27e8e.toEquiv\u27e9", "start": [595, 1], "end": [598, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_type", "code": "@[simp]\ntheorem card_type (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : card (type r) = #\u03b1", "start": [601, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_typein", "code": "@[simp, nolint simpNF]\ntheorem card_typein {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] (x : \u03b1) :\n    #{ y // r y x } = (typein r x).card", "start": [607, 1], "end": [610, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_le_card", "code": "theorem card_le_card {o\u2081 o\u2082 : Ordinal} : o\u2081 \u2264 o\u2082 \u2192 card o\u2081 \u2264 card o\u2082", "start": [613, 1], "end": [614, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_zero", "code": "@[simp]\ntheorem card_zero : card 0 = 0", "start": [617, 1], "end": [618, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_eq_zero", "code": "@[simp]\ntheorem card_eq_zero {o} : card o = 0 \u2194 o = 0", "start": [621, 1], "end": [626, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_one", "code": "@[simp]\ntheorem card_one : card 1 = 1", "start": [629, 1], "end": [630, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift", "code": "@[pp_with_univ]\ndef lift (o : Ordinal.{v}) : Ordinal.{max v u} :=\n  Quotient.liftOn o (fun w => type <| ULift.down.{u} \u207b\u00b9'o w.r) fun \u27e8_, r, _\u27e9 \u27e8_, s, _\u27e9 \u27e8f\u27e9 =>\n    Quot.sound\n      \u27e8(RelIso.preimage Equiv.ulift r).trans <| f.trans (RelIso.preimage Equiv.ulift s).symm\u27e9", "start": [636, 1], "end": [643, 94], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_uLift", "code": "theorem type_uLift (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    type (ULift.down.{v,u} \u207b\u00b9'o r) = lift.{v} (type r)", "start": [648, 1], "end": [651, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_uLift_aux", "code": "@[simp, nolint simpNF]\ntheorem type_uLift_aux (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    @type.{max v u} _ (fun x y => r (ULift.down.{v,u} x) (ULift.down.{v,u} y))\n      (inferInstanceAs (IsWellOrder (ULift \u03b1) (ULift.down \u207b\u00b9'o r))) = lift.{v} (type r)", "start": [655, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "RelIso.ordinal_lift_type_eq", "code": "theorem _root_.RelIso.ordinal_lift_type_eq {\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    {s : \u03b2 \u2192 \u03b2 \u2192 Prop} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] (f : r \u2243r s) :\n    lift.{v} (type r) = lift.{u} (type s)", "start": [661, 1], "end": [665, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_lift_preimage", "code": "theorem type_lift_preimage {\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r]\n    (f : \u03b2 \u2243 \u03b1) : lift.{u} (type (f \u207b\u00b9'o r)) = lift.{v} (type r)", "start": [669, 1], "end": [671, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_lift_preimage_aux", "code": "@[simp, nolint simpNF]\ntheorem type_lift_preimage_aux {\u03b1 : Type u} {\u03b2 : Type v} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r]\n    (f : \u03b2 \u2243 \u03b1) : lift.{u} (@type _ (fun x y => r (f x) (f y))\n      (inferInstanceAs (IsWellOrder \u03b2 (f \u207b\u00b9'o r)))) = lift.{v} (type r)", "start": [674, 1], "end": [678, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_umax", "code": "theorem lift_umax : lift.{max u v, u} = lift.{v, u}", "start": [680, 1], "end": [685, 98], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_umax'", "code": "theorem lift_umax' : lift.{max v u, u} = lift.{v, u}", "start": [688, 1], "end": [691, 12], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_id'", "code": "theorem lift_id' (a : Ordinal) : lift a = a", "start": [694, 1], "end": [697, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_id", "code": "@[simp]\ntheorem lift_id : \u2200 a, lift.{u, u} a = a", "start": [700, 1], "end": [703, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_uzero", "code": "@[simp]\ntheorem lift_uzero (a : Ordinal.{u}) : lift.{0} a = a", "start": [706, 1], "end": [709, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_lift", "code": "@[simp]\ntheorem lift_lift (a : Ordinal) : lift.{w} (lift.{v} a) = lift.{max v w} a", "start": [712, 1], "end": [717, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_type_le", "code": "theorem lift_type_le {\u03b1 : Type u} {\u03b2 : Type v} {r s} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] :\n    lift.{max v w} (type r) \u2264 lift.{max u w} (type s) \u2194 Nonempty (r \u227ci s)", "start": [720, 1], "end": [727, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_type_eq", "code": "theorem lift_type_eq {\u03b1 : Type u} {\u03b2 : Type v} {r s} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] :\n    lift.{max v w} (type r) = lift.{max u w} (type s) \u2194 Nonempty (r \u2243r s)", "start": [730, 1], "end": [736, 95], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_type_lt", "code": "theorem lift_type_lt {\u03b1 : Type u} {\u03b2 : Type v} {r s} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] :\n    lift.{max v w} (type r) < lift.{max u w} (type s) \u2194 Nonempty (r \u227ai s)", "start": [739, 1], "end": [750, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_le", "code": "@[simp]\ntheorem lift_le {a b : Ordinal} : lift.{u,v} a \u2264 lift.{u,v} b \u2194 a \u2264 b", "start": [753, 1], "end": [758, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_inj", "code": "@[simp]\ntheorem lift_inj {a b : Ordinal} : lift.{u,v} a = lift.{u,v} b \u2194 a = b", "start": [761, 1], "end": [763, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_lt", "code": "@[simp]\ntheorem lift_lt {a b : Ordinal} : lift.{u,v} a < lift.{u,v} b \u2194 a < b", "start": [766, 1], "end": [768, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_zero", "code": "@[simp]\ntheorem lift_zero : lift 0 = 0", "start": [771, 1], "end": [773, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_one", "code": "@[simp]\ntheorem lift_one : lift 1 = 1", "start": [776, 1], "end": [778, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_card", "code": "@[simp]\ntheorem lift_card (a) : Cardinal.lift.{u,v} (card a)= card (lift.{u,v} a)", "start": [781, 1], "end": [783, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_down'", "code": "theorem lift_down' {a : Cardinal.{u}} {b : Ordinal.{max u v}}\n    (h : card.{max u v} b \u2264 Cardinal.lift.{v,u} a) : \u2203 a', lift.{v,u} a' = b", "start": [786, 1], "end": [800, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_down", "code": "theorem lift_down {a : Ordinal.{u}} {b : Ordinal.{max u v}} (h : b \u2264 lift.{v,u} a) :\n    \u2203 a', lift.{v,u} a' = b", "start": [803, 1], "end": [805, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_lift_iff", "code": "theorem le_lift_iff {a : Ordinal.{u}} {b : Ordinal.{max u v}} :\n    b \u2264 lift.{v,u} a \u2194 \u2203 a', lift.{v,u} a' = b \u2227 a' \u2264 a", "start": [808, 1], "end": [813, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_lift_iff", "code": "theorem lt_lift_iff {a : Ordinal.{u}} {b : Ordinal.{max u v}} :\n    b < lift.{v,u} a \u2194 \u2203 a', lift.{v,u} a' = b \u2227 a' < a", "start": [816, 1], "end": [821, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.initialSeg", "code": "def lift.initialSeg : @InitialSeg Ordinal.{u} Ordinal.{max u v} (\u00b7 < \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8\u27e8\u27e8lift.{v}, fun _ _ => lift_inj.1\u27e9, lift_lt\u27e9, fun _ _ h => lift_down (le_of_lt h)\u27e9", "start": [824, 1], "end": [827, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.initialSeg_coe", "code": "@[simp]\ntheorem lift.initialSeg_coe : (lift.initialSeg.{u,v} : Ordinal \u2192 Ordinal) = lift.{v,u}", "start": [830, 1], "end": [832, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega", "code": "def omega : Ordinal.{u} :=\n  lift <| @type \u2115 (\u00b7 < \u00b7) _", "start": [838, 1], "end": [840, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_nat_lt", "code": "@[simp]\ntheorem type_nat_lt : @type \u2115 (\u00b7 < \u00b7) _ = \u03c9", "start": [847, 1], "end": [850, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_omega", "code": "@[simp]\ntheorem card_omega : card \u03c9 = \u2135\u2080", "start": [853, 1], "end": [855, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_omega", "code": "@[simp]\ntheorem lift_omega : lift \u03c9 = \u03c9", "start": [858, 1], "end": [860, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add", "code": "instance add : Add Ordinal.{u} :=\n  \u27e8fun o\u2081 o\u2082 =>\n    Quotient.liftOn\u2082 o\u2081 o\u2082 (fun \u27e8_, r, _\u27e9 \u27e8_, s, _\u27e9 => type (Sum.Lex r s))\n      fun _ _ _ _ \u27e8f\u27e9 \u27e8g\u27e9 => Quot.sound \u27e8RelIso.sumLexCongr f g\u27e9\u27e9", "start": [873, 1], "end": [878, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.addMonoidWithOne", "code": "instance addMonoidWithOne : AddMonoidWithOne Ordinal.{u} where\n  add := (\u00b7 + \u00b7)\n  zero := 0\n  one := 1\n  zero_add o :=\n    inductionOn o fun \u03b1 r _ =>\n      Eq.symm <| Quotient.sound \u27e8\u27e8(emptySum PEmpty \u03b1).symm, Sum.lex_inr_inr\u27e9\u27e9\n  add_zero o :=\n    inductionOn o fun \u03b1 r _ =>\n      Eq.symm <| Quotient.sound \u27e8\u27e8(sumEmpty \u03b1 PEmpty).symm, Sum.lex_inl_inl\u27e9\u27e9\n  add_assoc o\u2081 o\u2082 o\u2083 :=\n    Quotient.inductionOn\u2083 o\u2081 o\u2082 o\u2083 fun \u27e8\u03b1, r, _\u27e9 \u27e8\u03b2, s, _\u27e9 \u27e8\u03b3, t, _\u27e9 =>\n      Quot.sound\n        \u27e8\u27e8sumAssoc _ _ _, by\n          intros a b\n          rcases a with (\u27e8a | a\u27e9 | a) <;> rcases b with (\u27e8b | b\u27e9 | b) <;>\n            simp only [sumAssoc_apply_inl_inl, sumAssoc_apply_inl_inr, sumAssoc_apply_inr,\n              Sum.lex_inl_inl, Sum.lex_inr_inr, Sum.Lex.sep, Sum.lex_inr_inl]\u27e9\u27e9", "start": [880, 1], "end": [897, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_add", "code": "@[simp]\ntheorem card_add (o\u2081 o\u2082 : Ordinal) : card (o\u2081 + o\u2082) = card o\u2081 + card o\u2082", "start": [899, 1], "end": [901, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_sum_lex", "code": "@[simp]\ntheorem type_sum_lex {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] : type (Sum.Lex r s) = type r + type s", "start": [904, 1], "end": [907, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_nat", "code": "@[simp]\ntheorem card_nat (n : \u2115) : card.{u} n = n", "start": [910, 1], "end": [912, 75], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_covariantClass_le", "code": "instance add_covariantClass_le : CovariantClass Ordinal.{u} Ordinal.{u} (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) where\n  elim := fun c a b h => by\n    revert h c\n    refine inductionOn a (fun \u03b1\u2081 r\u2081 _ \u21a6 ?_)\n    refine inductionOn b (fun \u03b1\u2082 r\u2082 _ \u21a6 ?_)\n    rintro c \u27e8\u27e8\u27e8f, fo\u27e9, fi\u27e9\u27e9\n    refine inductionOn c (fun \u03b2 s _ \u21a6 ?_)\n    have := (Embedding.refl \u03b2).sumMap f\n    refine \u27e8\u27e8\u27e8(Embedding.refl.{u+1} _).sumMap f, ?_\u27e9, ?_\u27e9\u27e9\n    \u00b7 intros a b\n      match a, b with\n      | Sum.inl a, Sum.inl b => exact Sum.lex_inl_inl.trans Sum.lex_inl_inl.symm\n      | Sum.inl a, Sum.inr b => apply iff_of_true <;> apply Sum.Lex.sep\n      | Sum.inr a, Sum.inl b => apply iff_of_false <;> exact Sum.lex_inr_inl\n      | Sum.inr a, Sum.inr b => exact Sum.lex_inr_inr.trans <| fo.trans Sum.lex_inr_inr.symm\n    \u00b7 intros a b H\n      match a, b, H with\n      | _, Sum.inl b, _ => exact \u27e8Sum.inl b, rfl\u27e9\n      | Sum.inl a, Sum.inr b, H => exact (Sum.lex_inr_inl H).elim\n      | Sum.inr a, Sum.inr b, H =>\n        let \u27e8w, h\u27e9 := fi _ _ (Sum.lex_inr_inr.1 H)\n        exact \u27e8Sum.inr w, congr_arg Sum.inr h\u27e9", "start": [916, 1], "end": [937, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_swap_covariantClass_le", "code": "instance add_swap_covariantClass_le :\n    CovariantClass Ordinal.{u} Ordinal.{u} (swap (\u00b7 + \u00b7)) (\u00b7 \u2264 \u00b7) where\n  elim := fun c a b h => by\n    revert h c\n    refine inductionOn a (fun \u03b1\u2081 r\u2081 _ \u21a6 ?_)\n    refine inductionOn b (fun \u03b1\u2082 r\u2082 _ \u21a6 ?_)\n    rintro c \u27e8\u27e8\u27e8f, fo\u27e9, fi\u27e9\u27e9\n    refine inductionOn c (fun \u03b2 s _ \u21a6 ?_)\n    exact @RelEmbedding.ordinal_type_le _ _ (Sum.Lex r\u2081 s) (Sum.Lex r\u2082 s) _ _\n              \u27e8f.sumMap (Embedding.refl _), by\n                intro a b\n                constructor <;> intro H\n                \u00b7 cases' a with a a <;> cases' b with b b <;> cases H <;> constructor <;>\n                    [rwa [\u2190 fo]; assumption]\n                \u00b7 cases H <;> constructor <;> [rwa [fo]; assumption]\u27e9", "start": [941, 1], "end": [955, 70], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_add_right", "code": "theorem le_add_right (a b : Ordinal) : a \u2264 a + b", "start": [958, 1], "end": [959, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_add_left", "code": "theorem le_add_left (a b : Ordinal) : a \u2264 b + a", "start": [962, 1], "end": [963, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.linearOrder", "code": "instance linearOrder : LinearOrder Ordinal :=\n  {inferInstanceAs (PartialOrder Ordinal) with\n    le_total := fun a b =>\n      match lt_or_eq_of_le (le_add_left b a), lt_or_eq_of_le (le_add_right a b) with\n      | Or.inr h, _ => by rw [h]; exact Or.inl (le_add_right _ _)\n      | _, Or.inr h => by rw [h]; exact Or.inr (le_add_left _ _)\n      | Or.inl h\u2081, Or.inl h\u2082 => by\n        revert h\u2081 h\u2082\n        refine inductionOn a ?_\n        intro \u03b1\u2081 r\u2081 _\n        refine inductionOn b ?_\n        intro \u03b1\u2082 r\u2082 _ \u27e8f\u27e9 \u27e8g\u27e9\n        rw [\u2190 typein_top f, \u2190 typein_top g, le_iff_lt_or_eq, le_iff_lt_or_eq,\n                 typein_lt_typein, typein_lt_typein]\n        rcases trichotomous_of (Sum.Lex r\u2081 r\u2082) g.top f.top with (h | h | h) <;>\n          [exact Or.inl (Or.inl h); (left; right; rw [h]); exact Or.inr (Or.inl h)]\n    decidableLE := Classical.decRel _ }", "start": [966, 1], "end": [982, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.wellFoundedLT", "code": "instance wellFoundedLT : WellFoundedLT Ordinal :=\n  \u27e8lt_wf\u27e9", "start": [984, 1], "end": [985, 10], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isWellOrder", "code": "instance isWellOrder : IsWellOrder Ordinal (\u00b7 < \u00b7) where", "start": [987, 1], "end": [987, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.max_zero_left", "code": "@[simp]\ntheorem max_zero_left : \u2200 a : Ordinal, max 0 a = a", "start": [992, 1], "end": [994, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.max_zero_right", "code": "@[simp]\ntheorem max_zero_right : \u2200 a : Ordinal, max a 0 = a", "start": [997, 1], "end": [999, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.max_eq_zero", "code": "@[simp]\ntheorem max_eq_zero {a b : Ordinal} : max a b = 0 \u2194 a = 0 \u2227 b = 0", "start": [1002, 1], "end": [1004, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf (\u2205 : Set Ordinal) = 0", "start": [1007, 1], "end": [1009, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_le_iff'", "code": "private theorem succ_le_iff' {a b : Ordinal} : a + 1 \u2264 b \u2194 a < b", "start": [1013, 1], "end": [1038, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.noMaxOrder", "code": "instance noMaxOrder : NoMaxOrder Ordinal :=\n  \u27e8fun _ => \u27e8_, succ_le_iff'.1 le_rfl\u27e9\u27e9", "start": [1040, 1], "end": [1041, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succOrder", "code": "instance succOrder : SuccOrder Ordinal.{u} :=\n  SuccOrder.ofSuccLeIff (fun o => o + 1) succ_le_iff'", "start": [1043, 1], "end": [1044, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_one_eq_succ", "code": "@[simp]\ntheorem add_one_eq_succ (o : Ordinal) : o + 1 = succ o", "start": [1046, 1], "end": [1048, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_zero", "code": "@[simp]\ntheorem succ_zero : succ (0 : Ordinal) = 1", "start": [1051, 1], "end": [1053, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_one", "code": "@[simp]\ntheorem succ_one : succ (1 : Ordinal) = 2", "start": [1057, 1], "end": [1060, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_succ", "code": "theorem add_succ (o\u2081 o\u2082 : Ordinal) : o\u2081 + succ o\u2082 = succ (o\u2081 + o\u2082)", "start": [1063, 1], "end": [1064, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_le_iff_pos", "code": "theorem one_le_iff_pos {o : Ordinal} : 1 \u2264 o \u2194 0 < o", "start": [1067, 1], "end": [1067, 89], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_le_iff_ne_zero", "code": "theorem one_le_iff_ne_zero {o : Ordinal} : 1 \u2264 o \u2194 o \u2260 0", "start": [1070, 1], "end": [1071, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_pos", "code": "theorem succ_pos (o : Ordinal) : 0 < succ o", "start": [1074, 1], "end": [1075, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_ne_zero", "code": "theorem succ_ne_zero (o : Ordinal) : succ o \u2260 0", "start": [1078, 1], "end": [1079, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_one_iff_zero", "code": "theorem lt_one_iff_zero {a : Ordinal} : a < 1 \u2194 a = 0", "start": [1082, 1], "end": [1083, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_one_iff", "code": "theorem le_one_iff {a : Ordinal} : a \u2264 1 \u2194 a = 0 \u2228 a = 1", "start": [1086, 1], "end": [1087, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_succ", "code": "@[simp]\ntheorem card_succ (o : Ordinal) : card (succ o) = card o + 1", "start": [1090, 1], "end": [1092, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_succ", "code": "theorem nat_cast_succ (n : \u2115) : \u2191n.succ = succ (n : Ordinal)", "start": [1095, 1], "end": [1096, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.uniqueIioOne", "code": "instance uniqueIioOne : Unique (Iio (1 : Ordinal))\n    where\n  default := \u27e80, by simp\u27e9\n  uniq a := Subtype.ext <| lt_one_iff_zero.1 a.2", "start": [1099, 1], "end": [1102, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.uniqueOutOne", "code": "instance uniqueOutOne : Unique (1 : Ordinal).out.\u03b1\n    where\n  default := enum (\u00b7 < \u00b7) 0 (by simp)\n  uniq a := by\n    unfold default\n    rw [\u2190 @enum_typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) a]\n    congr\n    rw [\u2190 lt_one_iff_zero]\n    apply typein_lt_self", "start": [1105, 1], "end": [1113, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_out_eq", "code": "theorem one_out_eq (x : (1 : Ordinal).out.\u03b1) : x = enum (\u00b7 < \u00b7) 0 (by simp)", "start": [1116, 1], "end": [1117, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_one_out", "code": "@[simp]\ntheorem typein_one_out (x : (1 : Ordinal).out.\u03b1) :\n    @typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) x = 0", "start": [1123, 1], "end": [1126, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_le_typein", "code": "@[simp]\ntheorem typein_le_typein (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {x x' : \u03b1} :\n    typein r x \u2264 typein r x' \u2194 \u00acr x' x", "start": [1129, 1], "end": [1131, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.typein_le_typein'", "code": "theorem typein_le_typein' (o : Ordinal) {x x' : o.out.\u03b1} :\n    @typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) x \u2264 @typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) x'\n      \u2194 x \u2264 x'", "start": [1135, 1], "end": [1139, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_le_enum", "code": "@[simp, nolint simpNF]\ntheorem enum_le_enum (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] {o o' : Ordinal} (ho : o < type r)\n    (ho' : o' < type r) : \u00acr (enum r o' ho') (enum r o ho) \u2194 o \u2264 o'", "start": [1143, 1], "end": [1146, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_le_enum'", "code": "@[simp]\ntheorem enum_le_enum' (a : Ordinal) {o o' : Ordinal} (ho : o < type (\u00b7 < \u00b7))\n    (ho' : o' < type (\u00b7 < \u00b7)) : enum (\u00b7 < \u00b7) o ho \u2264 @enum a.out.\u03b1 (\u00b7 < \u00b7) _ o' ho' \u2194 o \u2264 o'", "start": [1149, 1], "end": [1152, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_zero_le", "code": "theorem enum_zero_le {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] (h0 : 0 < type r) (a : \u03b1) :\n    \u00acr a (enum r 0 h0)", "start": [1155, 1], "end": [1158, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_zero_le'", "code": "theorem enum_zero_le' {o : Ordinal} (h0 : 0 < o) (a : o.out.\u03b1) :\n    @enum o.out.\u03b1 (\u00b7 < \u00b7) _ 0 (by rwa [type_lt]) \u2264 a", "start": [1161, 1], "end": [1164, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_enum_succ", "code": "theorem le_enum_succ {o : Ordinal} (a : (succ o).out.\u03b1) :\n    a \u2264\n      @enum (succ o).out.\u03b1 (\u00b7 < \u00b7) _ o\n        (by\n          rw [type_lt]\n          exact lt_succ o)", "start": [1167, 1], "end": [1174, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_inj", "code": "@[simp]\ntheorem enum_inj {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] {o\u2081 o\u2082 : Ordinal} (h\u2081 : o\u2081 < type r)\n    (h\u2082 : o\u2082 < type r) : enum r o\u2081 h\u2081 = enum r o\u2082 h\u2082 \u2194 o\u2081 = o\u2082", "start": [1177, 1], "end": [1180, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumIso", "code": "@[simps]\ndef enumIso (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : Subrel (\u00b7 < \u00b7) (\u00b7 < type r) \u2243r r :=\n  { (typein.principalSeg r).subrelIso with\n    toFun := fun x \u21a6 enum r x.1 x.2\n    invFun := fun x \u21a6 \u27e8typein r x, typein_lt_type r x\u27e9 }", "start": [1184, 1], "end": [1189, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumIsoOut", "code": "@[simps!]\nnoncomputable def enumIsoOut (o : Ordinal) : Set.Iio o \u2243o o.out.\u03b1\n    where\n  toFun x :=\n    enum (\u00b7 < \u00b7) x.1 <| by\n      rw [type_lt]\n      exact x.2\n  invFun x := \u27e8@typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) x, typein_lt_self x\u27e9\n  left_inv := fun \u27e8o', h\u27e9 => Subtype.ext_val (typein_enum _ _)\n  right_inv h := enum_typein _ _\n  map_rel_iff' := by\n    rintro \u27e8a, _\u27e9 \u27e8b, _\u27e9\n    apply enum_le_enum'", "start": [1192, 1], "end": [1205, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.outOrderBotOfPos", "code": "def outOrderBotOfPos {o : Ordinal} (ho : 0 < o) : OrderBot o.out.\u03b1 where\n  bot_le := enum_zero_le' ho", "start": [1208, 1], "end": [1210, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_zero_eq_bot", "code": "theorem enum_zero_eq_bot {o : Ordinal} (ho : 0 < o) :\n    enum (\u00b7 < \u00b7) 0 (by rwa [type_lt]) =\n      haveI H := outOrderBotOfPos ho\n      \u22a5", "start": [1213, 1], "end": [1217, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.univ", "code": "@[nolint checkUnivs]\ndef univ : Ordinal.{max (u + 1) v} :=\n  lift.{v, u + 1} (@type Ordinal (\u00b7 < \u00b7) _)", "start": [1224, 1], "end": [1228, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.univ_id", "code": "theorem univ_id : univ.{u, u + 1} = @type Ordinal (\u00b7 < \u00b7) _", "start": [1231, 1], "end": [1232, 12], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_univ", "code": "@[simp]\ntheorem lift_univ : lift.{w} univ.{u, v} = univ.{u, max v w}", "start": [1235, 1], "end": [1237, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.univ_umax", "code": "theorem univ_umax : univ.{u, max (u + 1) v} = univ.{u, v}", "start": [1240, 1], "end": [1241, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.principalSeg", "code": "def lift.principalSeg : @PrincipalSeg Ordinal.{u} Ordinal.{max (u + 1) v} (\u00b7 < \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8\u2191lift.initialSeg.{u, max (u + 1) v}, univ.{u, v}, by\n    refine' fun b => inductionOn b _; intro \u03b2 s _\n    rw [univ, \u2190 lift_umax]; constructor <;> intro h\n    \u00b7 rw [\u2190 lift_id (type s)] at h \u22a2\n      cases' lift_type_lt.{_,_,v}.1 h with f\n      cases' f with f a hf\n      exists a\n      revert hf\n      refine inductionOn a ?_\n      intro \u03b1 r _ hf\n      refine'\n        lift_type_eq.{u, max (u + 1) v, max (u + 1) v}.2\n          \u27e8(RelIso.ofSurjective (RelEmbedding.ofMonotone _ _) _).symm\u27e9\n      \u00b7 exact fun b => enum r (f b) ((hf _).2 \u27e8_, rfl\u27e9)\n      \u00b7 refine' fun a b h => (typein_lt_typein r).1 _\n        rw [typein_enum, typein_enum]\n        exact f.map_rel_iff.2 h\n      \u00b7 intro a'\n        cases' (hf _).1 (typein_lt_type _ a') with b e\n        exists b\n        simp only [RelEmbedding.ofMonotone_coe]\n        simp [e]\n    \u00b7 cases' h with a e\n      rw [\u2190 e]\n      refine inductionOn a ?_\n      intro \u03b1 r _\n      exact lift_type_lt.{u, u + 1, max (u + 1) v}.2 \u27e8typein.principalSeg r\u27e9\u27e9", "start": [1244, 1], "end": [1274, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.principalSeg_coe", "code": "@[simp]\ntheorem lift.principalSeg_coe :\n    (lift.principalSeg.{u, v} : Ordinal \u2192 Ordinal) = lift.{max (u + 1) v}", "start": [1277, 1], "end": [1280, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.principalSeg_top", "code": "@[simp]\ntheorem lift.principalSeg_top : (lift.principalSeg.{u,v}).top = univ.{u,v}", "start": [1284, 1], "end": [1286, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift.principalSeg_top'", "code": "theorem lift.principalSeg_top' : lift.principalSeg.{u, u + 1}.top = @type Ordinal (\u00b7 < \u00b7) _", "start": [1289, 1], "end": [1290, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_ordinal_out", "code": "@[simp]\ntheorem mk_ordinal_out (o : Ordinal) : #o.out.\u03b1 = o.card", "start": [1302, 1], "end": [1304, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord", "code": "def ord (c : Cardinal) : Ordinal :=\n  let F := fun \u03b1 : Type u => \u2a05 r : { r // IsWellOrder \u03b1 r }, @type \u03b1 r.1 r.2\n  Quot.liftOn c F\n    (by\n      suffices : \u2200 {\u03b1 \u03b2}, \u03b1 \u2248 \u03b2 \u2192 F \u03b1 \u2264 F \u03b2\n      exact fun \u03b1 \u03b2 h => (this h).antisymm (this (Setoid.symm h))\n      rintro \u03b1 \u03b2 \u27e8f\u27e9\n      refine' le_ciInf_iff'.2 fun i => _\n      haveI := @RelEmbedding.isWellOrder _ _ (f \u207b\u00b9'o i.1) _ (\u2191(RelIso.preimage f i.1)) i.2\n      exact\n        (ciInf_le' _\n              (Subtype.mk (f \u207b\u00b9'o i.val)\n                (@RelEmbedding.isWellOrder _ _ _ _ (\u2191(RelIso.preimage f i.1)) i.2))).trans_eq\n          (Quot.sound \u27e8RelIso.preimage f i.1\u27e9))", "start": [1307, 1], "end": [1322, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_eq_Inf", "code": "theorem ord_eq_Inf (\u03b1 : Type u) : ord #\u03b1 = \u2a05 r : { r // IsWellOrder \u03b1 r }, @type \u03b1 r.1 r.2", "start": [1325, 1], "end": [1326, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_eq", "code": "theorem ord_eq (\u03b1) : \u2203 (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (wo : IsWellOrder \u03b1 r), ord #\u03b1 = @type \u03b1 r wo", "start": [1329, 1], "end": [1331, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_le_type", "code": "theorem ord_le_type (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [h : IsWellOrder \u03b1 r] : ord #\u03b1 \u2264 type r", "start": [1334, 1], "end": [1335, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_le", "code": "theorem ord_le {c o} : ord c \u2264 o \u2194 c \u2264 o.card", "start": [1338, 1], "end": [1350, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.gc_ord_card", "code": "theorem gc_ord_card : GaloisConnection ord card", "start": [1353, 1], "end": [1353, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_ord", "code": "theorem lt_ord {c o} : o < ord c \u2194 o.card < c", "start": [1356, 1], "end": [1357, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_ord", "code": "@[simp]\ntheorem card_ord (c) : (ord c).card = c", "start": [1360, 1], "end": [1365, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.gciOrdCard", "code": "def gciOrdCard : GaloisCoinsertion ord card :=\n  gc_ord_card.toGaloisCoinsertion fun c => c.card_ord.le", "start": [1368, 1], "end": [1370, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_card_le", "code": "theorem ord_card_le (o : Ordinal) : o.card.ord \u2264 o", "start": [1373, 1], "end": [1374, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_ord_succ_card", "code": "theorem lt_ord_succ_card (o : Ordinal) : o < (succ o.card).ord", "start": [1377, 1], "end": [1378, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_le_iff", "code": "theorem card_le_iff {o : Ordinal} {c : Cardinal} : o.card \u2264 c \u2194 o < (succ c).ord", "start": [1381, 1], "end": [1382, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_le_of_le_ord", "code": "lemma card_le_of_le_ord {o : Ordinal} {c : Cardinal} (ho : o \u2264 c.ord) :\n    o.card \u2264 c := by\n  rw [\u2190 card_ord c]; exact Ordinal.card_le_card ho", "start": [1384, 1], "end": [1392, 51], "kind": "mathlibtacticlemma"}, {"full_name": "Cardinal.ord_strictMono", "code": "@[mono]\ntheorem ord_strictMono : StrictMono ord", "start": [1394, 1], "end": [1396, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_mono", "code": "@[mono]\ntheorem ord_mono : Monotone ord", "start": [1399, 1], "end": [1401, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_le_ord", "code": "@[simp]\ntheorem ord_le_ord {c\u2081 c\u2082} : ord c\u2081 \u2264 ord c\u2082 \u2194 c\u2081 \u2264 c\u2082", "start": [1404, 1], "end": [1406, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_lt_ord", "code": "@[simp]\ntheorem ord_lt_ord {c\u2081 c\u2082} : ord c\u2081 < ord c\u2082 \u2194 c\u2081 < c\u2082", "start": [1409, 1], "end": [1411, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_zero", "code": "@[simp]\ntheorem ord_zero : ord 0 = 0", "start": [1414, 1], "end": [1416, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_nat", "code": "@[simp]\ntheorem ord_nat (n : \u2115) : ord n = n", "start": [1419, 1], "end": [1425, 96], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_one", "code": "@[simp]\ntheorem ord_one : ord 1 = 1", "start": [1428, 1], "end": [1429, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_ord", "code": "@[simp]\ntheorem lift_ord (c) : Ordinal.lift.{u,v} (ord c) = ord (lift.{u,v} c)", "start": [1432, 1], "end": [1437, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_ord_out", "code": "theorem mk_ord_out (c : Cardinal) : #c.ord.out.\u03b1 = c", "start": [1440, 1], "end": [1440, 64], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_typein_lt", "code": "theorem card_typein_lt (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (x : \u03b1) (h : ord #\u03b1 = type r) :\n    card (typein r x) < #\u03b1", "start": [1443, 1], "end": [1446, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.card_typein_out_lt", "code": "theorem card_typein_out_lt (c : Cardinal) (x : c.ord.out.\u03b1) :\n    card (@typein _ (\u00b7 < \u00b7) (isWellOrder_out_lt _) x) < c", "start": [1449, 1], "end": [1452, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_injective", "code": "theorem ord_injective : Injective ord", "start": [1455, 1], "end": [1457, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord.orderEmbedding", "code": "def ord.orderEmbedding : Cardinal \u21aao Ordinal :=\n  RelEmbedding.orderEmbeddingOfLTEmbedding\n    (RelEmbedding.ofMonotone Cardinal.ord fun _ _ => Cardinal.ord_lt_ord.2)", "start": [1460, 1], "end": [1465, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord.orderEmbedding_coe", "code": "@[simp]\ntheorem ord.orderEmbedding_coe : (ord.orderEmbedding : Cardinal \u2192 Ordinal) = ord", "start": [1468, 1], "end": [1470, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.univ", "code": "@[nolint checkUnivs]\ndef univ :=\n  lift.{v, u + 1} #Ordinal", "start": [1474, 1], "end": [1479, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.univ_id", "code": "theorem univ_id : univ.{u, u + 1} = #Ordinal", "start": [1482, 1], "end": [1483, 12], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_univ", "code": "@[simp]\ntheorem lift_univ : lift.{w} univ.{u, v} = univ.{u, max v w}", "start": [1486, 1], "end": [1488, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.univ_umax", "code": "theorem univ_umax : univ.{u, max (u + 1) v} = univ.{u, v}", "start": [1491, 1], "end": [1492, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt_univ", "code": "theorem lift_lt_univ (c : Cardinal) : lift.{u + 1, u} c < univ.{u, u + 1}", "start": [1495, 1], "end": [1497, 64], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lift_lt_univ'", "code": "theorem lift_lt_univ' (c : Cardinal) : lift.{max (u + 1) v, u} c < univ.{u, v}", "start": [1500, 1], "end": [1503, 13], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_univ", "code": "@[simp]\ntheorem ord_univ : ord univ.{u, v} = Ordinal.univ.{u, v}", "start": [1506, 1], "end": [1512, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_univ", "code": "theorem lt_univ {c} : c < univ.{u, u + 1} \u2194 \u2203 c', c = lift.{u + 1, u} c'", "start": [1515, 1], "end": [1522, 66], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_univ'", "code": "theorem lt_univ' {c} : c < univ.{u, v} \u2194 \u2203 c', c = lift.{max (u + 1) v, u} c'", "start": [1525, 1], "end": [1530, 91], "kind": "commanddeclaration"}, {"full_name": "Cardinal.small_iff_lift_mk_lt_univ", "code": "theorem small_iff_lift_mk_lt_univ {\u03b1 : Type u} :\n    Small.{v} \u03b1 \u2194 Cardinal.lift.{v+1,_} #\u03b1 < univ.{v, max u (v + 1)}", "start": [1533, 1], "end": [1540, 85], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_univ", "code": "@[simp]\ntheorem card_univ : card univ.{u,v} = Cardinal.univ.{u,v}", "start": [1547, 1], "end": [1549, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_le_card", "code": "@[simp]\ntheorem nat_le_card {o} {n : \u2115} : (n : Cardinal) \u2264 card o \u2194 (n : Ordinal) \u2264 o", "start": [1552, 1], "end": [1554, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_lt_card", "code": "@[simp]\ntheorem nat_lt_card {o} {n : \u2115} : (n : Cardinal) < card o \u2194 (n : Ordinal) < o", "start": [1557, 1], "end": [1560, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_lt_nat", "code": "@[simp]\ntheorem card_lt_nat {o} {n : \u2115} : card o < n \u2194 o < n", "start": [1563, 1], "end": [1565, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_le_nat", "code": "@[simp]\ntheorem card_le_nat {o} {n : \u2115} : card o \u2264 n \u2194 o \u2264 n", "start": [1568, 1], "end": [1570, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_eq_nat", "code": "@[simp]\ntheorem card_eq_nat {o} {n : \u2115} : card o = n \u2194 o = n", "start": [1573, 1], "end": [1575, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_fintype", "code": "@[simp]\ntheorem type_fintype (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] [Fintype \u03b1] : type r = Fintype.card \u03b1", "start": [1578, 1], "end": [1580, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_fin", "code": "theorem type_fin (n : \u2115) : @type (Fin n) (\u00b7 < \u00b7) _ = n", "start": [1583, 1], "end": [1583, 66], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Equiv.lean", "imports": ["Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Topology/Homeomorph.lean", "Mathlib/Topology/UniformSpace/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformEquiv", "code": "structure UniformEquiv (\u03b1 : Type*) (\u03b2 : Type*) [UniformSpace \u03b1] [UniformSpace \u03b2] extends\n  \u03b1 \u2243 \u03b2 where\n  \n  uniformContinuous_toFun : UniformContinuous toFun\n  \n  uniformContinuous_invFun : UniformContinuous invFun", "start": [34, 1], "end": [41, 54], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.toEquiv_injective", "code": "theorem toEquiv_injective : Function.Injective (toEquiv : \u03b1 \u2243\u1d64 \u03b2 \u2192 \u03b1 \u2243 \u03b2)", "start": [51, 1], "end": [52, 63], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformEquiv_mk_coe", "code": "@[simp]\ntheorem uniformEquiv_mk_coe (a : Equiv \u03b1 \u03b2) (b c) : (UniformEquiv.mk a b c : \u03b1 \u2192 \u03b2) = a", "start": [62, 1], "end": [64, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.symm", "code": "protected def symm (h : \u03b1 \u2243\u1d64 \u03b2) : \u03b2 \u2243\u1d64 \u03b1\n    where\n  uniformContinuous_toFun := h.uniformContinuous_invFun\n  uniformContinuous_invFun := h.uniformContinuous_toFun\n  toEquiv := h.toEquiv.symm", "start": [67, 1], "end": [72, 28], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.Simps.apply", "code": "def Simps.apply (h : \u03b1 \u2243\u1d64 \u03b2) : \u03b1 \u2192 \u03b2 :=\n  h", "start": [75, 1], "end": [78, 4], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.Simps.symm_apply", "code": "def Simps.symm_apply (h : \u03b1 \u2243\u1d64 \u03b2) : \u03b2 \u2192 \u03b1 :=\n  h.symm", "start": [81, 1], "end": [83, 9], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.coe_toEquiv", "code": "@[simp]\ntheorem coe_toEquiv (h : \u03b1 \u2243\u1d64 \u03b2) : \u21d1h.toEquiv = h", "start": [88, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.coe_symm_toEquiv", "code": "@[simp]\ntheorem coe_symm_toEquiv (h : \u03b1 \u2243\u1d64 \u03b2) : \u21d1h.toEquiv.symm = h.symm", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.ext", "code": "@[ext]\ntheorem ext {h h' : \u03b1 \u2243\u1d64 \u03b2} (H : \u2200 x, h x = h' x) : h = h'", "start": [98, 1], "end": [100, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.refl", "code": "@[simps! (config := { fullyApplied := false }) apply]\nprotected def refl (\u03b1 : Type*) [UniformSpace \u03b1] : \u03b1 \u2243\u1d64 \u03b1\n    where\n  uniformContinuous_toFun := uniformContinuous_id\n  uniformContinuous_invFun := uniformContinuous_id\n  toEquiv := Equiv.refl \u03b1", "start": [103, 1], "end": [109, 26], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.trans", "code": "protected def trans (h\u2081 : \u03b1 \u2243\u1d64 \u03b2) (h\u2082 : \u03b2 \u2243\u1d64 \u03b3) : \u03b1 \u2243\u1d64 \u03b3\n    where\n  uniformContinuous_toFun := h\u2082.uniformContinuous_toFun.comp h\u2081.uniformContinuous_toFun\n  uniformContinuous_invFun := h\u2081.uniformContinuous_invFun.comp h\u2082.uniformContinuous_invFun\n  toEquiv := Equiv.trans h\u2081.toEquiv h\u2082.toEquiv", "start": [112, 1], "end": [117, 47], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.trans_apply", "code": "@[simp]\ntheorem trans_apply (h\u2081 : \u03b1 \u2243\u1d64 \u03b2) (h\u2082 : \u03b2 \u2243\u1d64 \u03b3) (a : \u03b1) : h\u2081.trans h\u2082 a = h\u2082 (h\u2081 a)", "start": [120, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformEquiv_mk_coe_symm", "code": "@[simp]\ntheorem uniformEquiv_mk_coe_symm (a : Equiv \u03b1 \u03b2) (b c) :\n    ((UniformEquiv.mk a b c).symm : \u03b2 \u2192 \u03b1) = a.symm", "start": [125, 1], "end": [128, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.refl_symm", "code": "@[simp]\ntheorem refl_symm : (UniformEquiv.refl \u03b1).symm = UniformEquiv.refl \u03b1", "start": [131, 1], "end": [133, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformContinuous", "code": "protected theorem uniformContinuous (h : \u03b1 \u2243\u1d64 \u03b2) : UniformContinuous h", "start": [136, 1], "end": [137, 28], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.continuous", "code": "@[continuity]\nprotected theorem continuous (h : \u03b1 \u2243\u1d64 \u03b2) : Continuous h", "start": [140, 1], "end": [142, 33], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformContinuous_symm", "code": "protected theorem uniformContinuous_symm (h : \u03b1 \u2243\u1d64 \u03b2) : UniformContinuous h.symm", "start": [145, 1], "end": [146, 29], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.continuous_symm", "code": "@[continuity]\nprotected theorem continuous_symm (h : \u03b1 \u2243\u1d64 \u03b2) : Continuous h.symm", "start": [150, 1], "end": [152, 38], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.toHomeomorph", "code": "protected def toHomeomorph (e : \u03b1 \u2243\u1d64 \u03b2) : \u03b1 \u2243\u209c \u03b2 :=\n  { e.toEquiv with\n    continuous_toFun := e.continuous\n    continuous_invFun := e.continuous_symm }", "start": [155, 1], "end": [160, 45], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.toHomeomorph_apply", "code": "lemma toHomeomorph_apply (e : \u03b1 \u2243\u1d64 \u03b2) : (e.toHomeomorph : \u03b1 \u2192 \u03b2) = e := rfl", "start": [163, 1], "end": [163, 76], "kind": "mathlibtacticlemma"}, {"full_name": "UniformEquiv.toHomeomorph_symm_apply", "code": "lemma toHomeomorph_symm_apply (e : \u03b1 \u2243\u1d64 \u03b2) : (e.toHomeomorph.symm : \u03b2 \u2192 \u03b1) = e.symm := rfl", "start": [166, 1], "end": [166, 91], "kind": "mathlibtacticlemma"}, {"full_name": "UniformEquiv.apply_symm_apply", "code": "@[simp]\ntheorem apply_symm_apply (h : \u03b1 \u2243\u1d64 \u03b2) (x : \u03b2) : h (h.symm x) = x", "start": [169, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.symm_apply_apply", "code": "@[simp]\ntheorem symm_apply_apply (h : \u03b1 \u2243\u1d64 \u03b2) (x : \u03b1) : h.symm (h x) = x", "start": [174, 1], "end": [176, 31], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.bijective", "code": "protected theorem bijective (h : \u03b1 \u2243\u1d64 \u03b2) : Function.Bijective h", "start": [179, 1], "end": [180, 22], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.injective", "code": "protected theorem injective (h : \u03b1 \u2243\u1d64 \u03b2) : Function.Injective h", "start": [183, 1], "end": [184, 22], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.surjective", "code": "protected theorem surjective (h : \u03b1 \u2243\u1d64 \u03b2) : Function.Surjective h", "start": [187, 1], "end": [188, 23], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.changeInv", "code": "def changeInv (f : \u03b1 \u2243\u1d64 \u03b2) (g : \u03b2 \u2192 \u03b1) (hg : Function.RightInverse g f) : \u03b1 \u2243\u1d64 \u03b2 :=\n  have : g = f.symm :=\n    funext fun x => calc\n      g x = f.symm (f (g x)) := (f.left_inv (g x)).symm\n      _ = f.symm x := by rw [hg x]\n  { toFun := f\n    invFun := g\n    left_inv := by convert f.left_inv\n    right_inv := by convert f.right_inv using 1\n    uniformContinuous_toFun := f.uniformContinuous\n    uniformContinuous_invFun := by convert f.symm.uniformContinuous }", "start": [191, 1], "end": [202, 70], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.symm_comp_self", "code": "@[simp]\ntheorem symm_comp_self (h : \u03b1 \u2243\u1d64 \u03b2) : (h.symm : \u03b2 \u2192 \u03b1) \u2218 h = id", "start": [205, 1], "end": [207, 28], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.self_comp_symm", "code": "@[simp]\ntheorem self_comp_symm (h : \u03b1 \u2243\u1d64 \u03b2) : (h : \u03b1 \u2192 \u03b2) \u2218 h.symm = id", "start": [210, 1], "end": [212, 28], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.range_coe", "code": "theorem range_coe (h : \u03b1 \u2243\u1d64 \u03b2) : range h = univ", "start": [216, 1], "end": [217, 24], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.image_symm", "code": "theorem image_symm (h : \u03b1 \u2243\u1d64 \u03b2) : image h.symm = preimage h", "start": [220, 1], "end": [221, 42], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.preimage_symm", "code": "theorem preimage_symm (h : \u03b1 \u2243\u1d64 \u03b2) : preimage h.symm = image h", "start": [224, 1], "end": [225, 44], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.image_preimage", "code": "theorem image_preimage (h : \u03b1 \u2243\u1d64 \u03b2) (s : Set \u03b2) : h '' (h \u207b\u00b9' s) = s", "start": [229, 1], "end": [230, 29], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.preimage_image", "code": "theorem preimage_image (h : \u03b1 \u2243\u1d64 \u03b2) (s : Set \u03b1) : h \u207b\u00b9' (h '' s) = s", "start": [234, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformInducing", "code": "protected theorem uniformInducing (h : \u03b1 \u2243\u1d64 \u03b2) : UniformInducing h", "start": [238, 1], "end": [240, 51], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.comap_eq", "code": "theorem comap_eq (h : \u03b1 \u2243\u1d64 \u03b2) : UniformSpace.comap h \u2039_\u203a = \u2039_\u203a", "start": [243, 1], "end": [244, 52], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.uniformEmbedding", "code": "protected theorem uniformEmbedding (h : \u03b1 \u2243\u1d64 \u03b2) : UniformEmbedding h", "start": [247, 1], "end": [248, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.ofUniformEmbedding", "code": "noncomputable def ofUniformEmbedding (f : \u03b1 \u2192 \u03b2) (hf : UniformEmbedding f) : \u03b1 \u2243\u1d64 Set.range f\n    where\n  uniformContinuous_toFun := hf.toUniformInducing.uniformContinuous.subtype_mk _\n  uniformContinuous_invFun := by\n    rw [hf.toUniformInducing.uniformContinuous_iff, Equiv.invFun_as_coe,\n      Equiv.self_comp_ofInjective_symm]\n    exact uniformContinuous_subtype_val\n  toEquiv := Equiv.ofInjective f hf.inj", "start": [251, 1], "end": [259, 40], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.setCongr", "code": "def setCongr {s t : Set \u03b1} (h : s = t) : s \u2243\u1d64 t\n    where\n  uniformContinuous_toFun := uniformContinuous_subtype_val.subtype_mk _\n  uniformContinuous_invFun := uniformContinuous_subtype_val.subtype_mk _\n  toEquiv := Equiv.setCongr h", "start": [262, 1], "end": [267, 30], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodCongr", "code": "def prodCongr (h\u2081 : \u03b1 \u2243\u1d64 \u03b2) (h\u2082 : \u03b3 \u2243\u1d64 \u03b4) : \u03b1 \u00d7 \u03b3 \u2243\u1d64 \u03b2 \u00d7 \u03b4\n    where\n  uniformContinuous_toFun :=\n    (h\u2081.uniformContinuous.comp uniformContinuous_fst).prod_mk\n      (h\u2082.uniformContinuous.comp uniformContinuous_snd)\n  uniformContinuous_invFun :=\n    (h\u2081.symm.uniformContinuous.comp uniformContinuous_fst).prod_mk\n      (h\u2082.symm.uniformContinuous.comp uniformContinuous_snd)\n  toEquiv := h\u2081.toEquiv.prodCongr h\u2082.toEquiv", "start": [270, 1], "end": [279, 45], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodCongr_symm", "code": "@[simp]\ntheorem prodCongr_symm (h\u2081 : \u03b1 \u2243\u1d64 \u03b2) (h\u2082 : \u03b3 \u2243\u1d64 \u03b4) :\n    (h\u2081.prodCongr h\u2082).symm = h\u2081.symm.prodCongr h\u2082.symm", "start": [282, 1], "end": [285, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.coe_prodCongr", "code": "@[simp]\ntheorem coe_prodCongr (h\u2081 : \u03b1 \u2243\u1d64 \u03b2) (h\u2082 : \u03b3 \u2243\u1d64 \u03b4) : \u21d1(h\u2081.prodCongr h\u2082) = Prod.map h\u2081 h\u2082", "start": [288, 1], "end": [290, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodComm", "code": "def prodComm : \u03b1 \u00d7 \u03b2 \u2243\u1d64 \u03b2 \u00d7 \u03b1\n    where\n  uniformContinuous_toFun := uniformContinuous_snd.prod_mk uniformContinuous_fst\n  uniformContinuous_invFun := uniformContinuous_snd.prod_mk uniformContinuous_fst\n  toEquiv := Equiv.prodComm \u03b1 \u03b2", "start": [297, 1], "end": [302, 32], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodComm_symm", "code": "@[simp]\ntheorem prodComm_symm : (prodComm \u03b1 \u03b2).symm = prodComm \u03b2 \u03b1", "start": [305, 1], "end": [307, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.coe_prodComm", "code": "@[simp]\ntheorem coe_prodComm : \u21d1(prodComm \u03b1 \u03b2) = Prod.swap", "start": [310, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodAssoc", "code": "def prodAssoc : (\u03b1 \u00d7 \u03b2) \u00d7 \u03b3 \u2243\u1d64 \u03b1 \u00d7 \u03b2 \u00d7 \u03b3\n    where\n  uniformContinuous_toFun :=\n    (uniformContinuous_fst.comp uniformContinuous_fst).prod_mk\n      ((uniformContinuous_snd.comp uniformContinuous_fst).prod_mk uniformContinuous_snd)\n  uniformContinuous_invFun := by rw [Equiv.invFun, Equiv.prodAssoc]\n    exact (uniformContinuous_fst.prod_mk (uniformContinuous_fst.comp\n    uniformContinuous_snd)).prod_mk (uniformContinuous_snd.comp uniformContinuous_snd)\n  toEquiv := Equiv.prodAssoc \u03b1 \u03b2 \u03b3", "start": [315, 1], "end": [325, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.prodPunit", "code": "@[simps! (config := { fullyApplied := false }) apply]\ndef prodPunit : \u03b1 \u00d7 PUnit \u2243\u1d64 \u03b1 where\n  toEquiv := Equiv.prodPUnit \u03b1\n  uniformContinuous_toFun := uniformContinuous_fst\n  uniformContinuous_invFun := uniformContinuous_id.prod_mk uniformContinuous_const", "start": [328, 1], "end": [333, 83], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.punitProd", "code": "def punitProd : PUnit \u00d7 \u03b1 \u2243\u1d64 \u03b1 :=\n  (prodComm _ _).trans (prodPunit _)", "start": [336, 1], "end": [338, 37], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.coe_punitProd", "code": "@[simp]\ntheorem coe_punitProd : \u21d1(punitProd \u03b1) = Prod.snd", "start": [341, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.piCongrLeft", "code": "@[simps! apply toEquiv]\ndef piCongrLeft {\u03b9 \u03b9' : Type*} {\u03b2 : \u03b9' \u2192 Type*} [\u2200 j, UniformSpace (\u03b2 j)]\n    (e : \u03b9 \u2243 \u03b9') : (\u2200 i, \u03b2 (e i)) \u2243\u1d64 \u2200 j, \u03b2 j where\n  uniformContinuous_toFun := uniformContinuous_pi.mpr <| e.forall_congr_left.mp <| fun i \u21a6 by\n    simpa only [Equiv.toFun_as_coe_apply, Equiv.piCongrLeft_apply_apply] using\n      Pi.uniformContinuous_proj _ i\n  uniformContinuous_invFun := Pi.uniformContinuous_precomp' _ e\n  toEquiv := Equiv.piCongrLeft _ e", "start": [346, 1], "end": [355, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.piCongrRight", "code": "@[simps! apply toEquiv]\ndef piCongrRight {\u03b9 : Type*} {\u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*} [\u2200 i, UniformSpace (\u03b2\u2081 i)]\n    [\u2200 i, UniformSpace (\u03b2\u2082 i)] (F : \u2200 i, \u03b2\u2081 i \u2243\u1d64 \u03b2\u2082 i) : (\u2200 i, \u03b2\u2081 i) \u2243\u1d64 \u2200 i, \u03b2\u2082 i where\n  uniformContinuous_toFun := Pi.uniformContinuous_postcomp' _ fun i \u21a6 (F i).uniformContinuous\n  uniformContinuous_invFun := Pi.uniformContinuous_postcomp' _ fun i \u21a6 (F i).symm.uniformContinuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv", "start": [357, 1], "end": [364, 55], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.piCongrRight_symm", "code": "@[simp]\ntheorem piCongrRight_symm {\u03b9 : Type*} {\u03b2\u2081 \u03b2\u2082 : \u03b9 \u2192 Type*} [\u2200 i, UniformSpace (\u03b2\u2081 i)]\n    [\u2200 i, UniformSpace (\u03b2\u2082 i)] (F : \u2200 i, \u03b2\u2081 i \u2243\u1d64 \u03b2\u2082 i) :\n    (piCongrRight F).symm = piCongrRight fun i => (F i).symm", "start": [366, 1], "end": [370, 6], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.piCongr", "code": "@[simps! apply toEquiv]\ndef piCongr {\u03b9\u2081 \u03b9\u2082 : Type*} {\u03b2\u2081 : \u03b9\u2081 \u2192 Type*} {\u03b2\u2082 : \u03b9\u2082 \u2192 Type*}\n    [\u2200 i\u2081, UniformSpace (\u03b2\u2081 i\u2081)] [\u2200 i\u2082, UniformSpace (\u03b2\u2082 i\u2082)]\n    (e : \u03b9\u2081 \u2243 \u03b9\u2082) (F : \u2200 i\u2081, \u03b2\u2081 i\u2081 \u2243\u1d64 \u03b2\u2082 (e i\u2081)) : (\u2200 i\u2081, \u03b2\u2081 i\u2081) \u2243\u1d64 \u2200 i\u2082, \u03b2\u2082 i\u2082 :=\n  (UniformEquiv.piCongrRight F).trans (UniformEquiv.piCongrLeft e)", "start": [372, 1], "end": [379, 67], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.ulift", "code": "def ulift : ULift.{v, u} \u03b1 \u2243\u1d64 \u03b1 :=\n  { Equiv.ulift with\n    uniformContinuous_toFun := uniformContinuous_comap\n    uniformContinuous_invFun := by\n      have hf : UniformInducing (@Equiv.ulift.{v, u} \u03b1).toFun := \u27e8rfl\u27e9\n      simp_rw [hf.uniformContinuous_iff]\n      exact uniformContinuous_id }", "start": [381, 1], "end": [388, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.funUnique", "code": "@[simps! (config := { fullyApplied := false })]\ndef funUnique (\u03b9 \u03b1 : Type*) [Unique \u03b9] [UniformSpace \u03b1] : (\u03b9 \u2192 \u03b1) \u2243\u1d64 \u03b1\n    where\n  toEquiv := Equiv.funUnique \u03b9 \u03b1\n  uniformContinuous_toFun := Pi.uniformContinuous_proj _ _\n  uniformContinuous_invFun := uniformContinuous_pi.mpr fun _ => uniformContinuous_id", "start": [393, 1], "end": [399, 85], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.piFinTwo", "code": "@[simps! (config := { fullyApplied := false })]\ndef piFinTwo (\u03b1 : Fin 2 \u2192 Type u) [\u2200 i, UniformSpace (\u03b1 i)] : (\u2200 i, \u03b1 i) \u2243\u1d64 \u03b1 0 \u00d7 \u03b1 1\n    where\n  toEquiv := piFinTwoEquiv \u03b1\n  uniformContinuous_toFun := (Pi.uniformContinuous_proj _ 0).prod_mk (Pi.uniformContinuous_proj _ 1)\n  uniformContinuous_invFun :=\n    uniformContinuous_pi.mpr <| Fin.forall_fin_two.2 \u27e8uniformContinuous_fst, uniformContinuous_snd\u27e9", "start": [402, 1], "end": [409, 100], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.finTwoArrow", "code": "@[simps! (config := { fullyApplied := false })]\ndef finTwoArrow (\u03b1 : Type*) [UniformSpace \u03b1] : (Fin 2 \u2192 \u03b1) \u2243\u1d64 \u03b1 \u00d7 \u03b1 :=\n  { piFinTwo fun _ => \u03b1 with toEquiv := finTwoArrowEquiv \u03b1 }", "start": [412, 1], "end": [416, 61], "kind": "commanddeclaration"}, {"full_name": "UniformEquiv.image", "code": "def image (e : \u03b1 \u2243\u1d64 \u03b2) (s : Set \u03b1) : s \u2243\u1d64 e '' s\n    where\n  uniformContinuous_toFun := (e.uniformContinuous.comp uniformContinuous_subtype_val).subtype_mk _\n  uniformContinuous_invFun :=\n    (e.symm.uniformContinuous.comp uniformContinuous_subtype_val).subtype_mk _\n  toEquiv := e.toEquiv.image s", "start": [419, 1], "end": [426, 31], "kind": "commanddeclaration"}, {"full_name": "Equiv.toUniformEquivOfUniformInducing", "code": "def Equiv.toUniformEquivOfUniformInducing [UniformSpace \u03b1] [UniformSpace \u03b2] (f : \u03b1 \u2243 \u03b2)\n    (hf : UniformInducing f) : \u03b1 \u2243\u1d64 \u03b2 :=\n  { f with\n    uniformContinuous_toFun := hf.uniformContinuous\n    uniformContinuous_invFun := hf.uniformContinuous_iff.2 <| by simpa using uniformContinuous_id }", "start": [431, 1], "end": [437, 100], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "imports": ["Mathlib/Topology/UniformSpace/Cauchy.lean", "Mathlib/Topology/Separation.lean", "Mathlib/Topology/UniformSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TendstoUniformlyOnFilter", "code": "def TendstoUniformlyOnFilter (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (p : Filter \u03b9) (p' : Filter \u03b1) :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 n : \u03b9 \u00d7 \u03b1 in p \u00d7\u02e2 p', (f n.snd, F n.fst n.snd) \u2208 u", "start": [82, 1], "end": [86, 67], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOnFilter_iff_tendsto", "code": "theorem tendstoUniformlyOnFilter_iff_tendsto :\n    TendstoUniformlyOnFilter F f p p' \u2194\n      Tendsto (fun q : \u03b9 \u00d7 \u03b1 => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 p') (\ud835\udce4 \u03b2)", "start": [89, 1], "end": [97, 10], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn", "code": "def TendstoUniformlyOn (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (p : Filter \u03b9) (s : Set \u03b1) :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 n in p, \u2200 x : \u03b1, x \u2208 s \u2192 (f x, F n x) \u2208 u", "start": [100, 1], "end": [104, 58], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_iff_tendstoUniformlyOnFilter", "code": "theorem tendstoUniformlyOn_iff_tendstoUniformlyOnFilter :\n    TendstoUniformlyOn F f p s \u2194 TendstoUniformlyOnFilter F f p (\ud835\udcdf s)", "start": [107, 1], "end": [112, 7], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.tendstoUniformlyOnFilter", "code": "alias \u27e8TendstoUniformlyOn.tendstoUniformlyOnFilter, TendstoUniformlyOnFilter.tendstoUniformlyOn\u27e9 :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter", "start": [116, 1], "end": [117, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "TendstoUniformlyOnFilter.tendstoUniformlyOn", "code": "alias \u27e8TendstoUniformlyOn.tendstoUniformlyOnFilter, TendstoUniformlyOnFilter.tendstoUniformlyOn\u27e9 :=\n  tendstoUniformlyOn_iff_tendstoUniformlyOnFilter", "start": [116, 1], "end": [117, 50], "kind": "stdtacticaliasaliaslr"}, {"full_name": "tendstoUniformlyOn_iff_tendsto", "code": "theorem tendstoUniformlyOn_iff_tendsto {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9} {s : Set \u03b1} :\n    TendstoUniformlyOn F f p s \u2194 Tendsto (fun q : \u03b9 \u00d7 \u03b1 => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udce4 \u03b2)", "start": [121, 1], "end": [127, 98], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly", "code": "def TendstoUniformly (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (p : Filter \u03b9) :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 n in p, \u2200 x : \u03b1, (f x, F n x) \u2208 u", "start": [130, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_univ", "code": "theorem tendstoUniformlyOn_univ : TendstoUniformlyOn F f p univ \u2194 TendstoUniformly F f p", "start": [138, 1], "end": [139, 46], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformly_iff_tendstoUniformlyOnFilter", "code": "theorem tendstoUniformly_iff_tendstoUniformlyOnFilter :\n    TendstoUniformly F f p \u2194 TendstoUniformlyOnFilter F f p \u22a4", "start": [142, 1], "end": [144, 98], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.tendstoUniformlyOnFilter", "code": "theorem TendstoUniformly.tendstoUniformlyOnFilter (h : TendstoUniformly F f p) :\n    TendstoUniformlyOnFilter F f p \u22a4", "start": [147, 1], "end": [148, 97], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_iff_tendstoUniformly_comp_coe", "code": "theorem tendstoUniformlyOn_iff_tendstoUniformly_comp_coe :\n    TendstoUniformlyOn F f p s \u2194 TendstoUniformly (fun i (x : s) => F i x) (f \u2218 (\u2191)) p", "start": [151, 1], "end": [153, 38], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformly_iff_tendsto", "code": "theorem tendstoUniformly_iff_tendsto {F : \u03b9 \u2192 \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b2} {p : Filter \u03b9} :\n    TendstoUniformly F f p \u2194 Tendsto (fun q : \u03b9 \u00d7 \u03b1 => (f q.2, F q.1 q.2)) (p \u00d7\u02e2 \u22a4) (\ud835\udce4 \u03b2)", "start": [156, 1], "end": [162, 93], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.tendsto_at", "code": "theorem TendstoUniformlyOnFilter.tendsto_at (h : TendstoUniformlyOnFilter F f p p')\n    (hx : \ud835\udcdf {x} \u2264 p') : Tendsto (fun n => F n x) p <| \ud835\udcdd (f x)", "start": [165, 1], "end": [171, 31], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.tendsto_at", "code": "theorem TendstoUniformlyOn.tendsto_at (h : TendstoUniformlyOn F f p s) {x : \u03b1} (hx : x \u2208 s) :\n    Tendsto (fun n => F n x) p <| \ud835\udcdd (f x)", "start": [174, 1], "end": [178, 82], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.tendsto_at", "code": "theorem TendstoUniformly.tendsto_at (h : TendstoUniformly F f p) (x : \u03b1) :\n    Tendsto (fun n => F n x) p <| \ud835\udcdd (f x)", "start": [181, 1], "end": [184, 47], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.mono_left", "code": "theorem TendstoUniformlyOnFilter.mono_left {p'' : Filter \u03b9} (h : TendstoUniformlyOnFilter F f p p')\n    (hp : p'' \u2264 p) : TendstoUniformlyOnFilter F f p'' p'", "start": [189, 1], "end": [191, 46], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.mono_right", "code": "theorem TendstoUniformlyOnFilter.mono_right {p'' : Filter \u03b1} (h : TendstoUniformlyOnFilter F f p p')\n    (hp : p'' \u2264 p') : TendstoUniformlyOnFilter F f p p''", "start": [194, 1], "end": [196, 46], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.mono", "code": "theorem TendstoUniformlyOn.mono {s' : Set \u03b1} (h : TendstoUniformlyOn F f p s) (h' : s' \u2286 s) :\n    TendstoUniformlyOn F f p s'", "start": [199, 1], "end": [202, 91], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.congr", "code": "theorem TendstoUniformlyOnFilter.congr {F' : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : TendstoUniformlyOnFilter F f p p')\n    (hff' : \u2200\u1da0 n : \u03b9 \u00d7 \u03b1 in p \u00d7\u02e2 p', F n.fst n.snd = F' n.fst n.snd) :\n    TendstoUniformlyOnFilter F' f p p'", "start": [205, 1], "end": [210, 15], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.congr", "code": "theorem TendstoUniformlyOn.congr {F' : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : TendstoUniformlyOn F f p s)\n    (hff' : \u2200\u1da0 n in p, Set.EqOn (F n) (F' n) s) : TendstoUniformlyOn F' f p s", "start": [213, 1], "end": [219, 53], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.congr_right", "code": "theorem TendstoUniformlyOn.congr_right {g : \u03b1 \u2192 \u03b2} (hf : TendstoUniformlyOn F f p s)\n    (hfg : EqOn f g s) : TendstoUniformlyOn F g p s", "start": [222, 1], "end": [224, 65], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.tendstoUniformlyOn", "code": "protected theorem TendstoUniformly.tendstoUniformlyOn (h : TendstoUniformly F f p) :\n    TendstoUniformlyOn F f p s", "start": [227, 1], "end": [229, 53], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.comp", "code": "theorem TendstoUniformlyOnFilter.comp (h : TendstoUniformlyOnFilter F f p p') (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformlyOnFilter (fun n => F n \u2218 g) (f \u2218 g) p (p'.comap g)", "start": [232, 1], "end": [236, 51], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.comp", "code": "theorem TendstoUniformlyOn.comp (h : TendstoUniformlyOn F f p s) (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p (g \u207b\u00b9' s)", "start": [239, 1], "end": [243, 86], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.comp", "code": "theorem TendstoUniformly.comp (h : TendstoUniformly F f p) (g : \u03b3 \u2192 \u03b1) :\n    TendstoUniformly (fun n => F n \u2218 g) (f \u2218 g) p", "start": [246, 1], "end": [250, 57], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp_tendstoUniformlyOnFilter", "code": "theorem UniformContinuous.comp_tendstoUniformlyOnFilter [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3}\n    (hg : UniformContinuous g) (h : TendstoUniformlyOnFilter F f p p') :\n    TendstoUniformlyOnFilter (fun i => g \u2218 F i) (g \u2218 f) p p'", "start": [253, 1], "end": [257, 89], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp_tendstoUniformlyOn", "code": "theorem UniformContinuous.comp_tendstoUniformlyOn [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3}\n    (hg : UniformContinuous g) (h : TendstoUniformlyOn F f p s) :\n    TendstoUniformlyOn (fun i => g \u2218 F i) (g \u2218 f) p s", "start": [260, 1], "end": [264, 82], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp_tendstoUniformly", "code": "theorem UniformContinuous.comp_tendstoUniformly [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3}\n    (hg : UniformContinuous g) (h : TendstoUniformly F f p) :\n    TendstoUniformly (fun i => g \u2218 F i) (g \u2218 f) p", "start": [267, 1], "end": [270, 78], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.prod_map", "code": "theorem TendstoUniformlyOnFilter.prod_map {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {q : Filter \u03b9'} {q' : Filter \u03b1'} (h : TendstoUniformlyOnFilter F f p p')\n    (h' : TendstoUniformlyOnFilter F' f' q q') :\n    TendstoUniformlyOnFilter (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f')\n      (p \u00d7\u02e2 q) (p' \u00d7\u02e2 q')", "start": [273, 1], "end": [280, 24], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.prod_map", "code": "theorem TendstoUniformlyOn.prod_map {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {p' : Filter \u03b9'} {s' : Set \u03b1'} (h : TendstoUniformlyOn F f p s)\n    (h' : TendstoUniformlyOn F' f' p' s') :\n    TendstoUniformlyOn (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p')\n      (s \u00d7\u02e2 s')", "start": [283, 1], "end": [289, 60], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.prod_map", "code": "theorem TendstoUniformly.prod_map {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {f' : \u03b1' \u2192 \u03b2'} {p' : Filter \u03b9'} (h : TendstoUniformly F f p) (h' : TendstoUniformly F' f' p') :\n    TendstoUniformly (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (Prod.map f f') (p \u00d7\u02e2 p')", "start": [292, 1], "end": [296, 22], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.prod", "code": "theorem TendstoUniformlyOnFilter.prod {\u03b9' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1 \u2192 \u03b2'}\n    {f' : \u03b1 \u2192 \u03b2'} {q : Filter \u03b9'} (h : TendstoUniformlyOnFilter F f p p')\n    (h' : TendstoUniformlyOnFilter F' f' q p') :\n    TendstoUniformlyOnFilter (fun (i : \u03b9 \u00d7 \u03b9') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p \u00d7\u02e2 q) p'", "start": [299, 1], "end": [304, 56], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.prod", "code": "theorem TendstoUniformlyOn.prod {\u03b9' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1 \u2192 \u03b2'} {f' : \u03b1 \u2192 \u03b2'}\n    {p' : Filter \u03b9'} (h : TendstoUniformlyOn F f p s) (h' : TendstoUniformlyOn F' f' p' s) :\n    TendstoUniformlyOn (fun (i : \u03b9 \u00d7 \u03b9') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p.prod p') s", "start": [307, 1], "end": [311, 71], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.prod", "code": "theorem TendstoUniformly.prod {\u03b9' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1 \u2192 \u03b2'} {f' : \u03b1 \u2192 \u03b2'}\n    {p' : Filter \u03b9'} (h : TendstoUniformly F f p) (h' : TendstoUniformly F' f' p') :\n    TendstoUniformly (fun (i : \u03b9 \u00d7 \u03b9') a => (F i.1 a, F' i.2 a)) (fun a => (f a, f' a))\n      (p \u00d7\u02e2 p')", "start": [314, 1], "end": [318, 39], "kind": "commanddeclaration"}, {"full_name": "tendsto_prod_filter_iff", "code": "theorem tendsto_prod_filter_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 p') (\ud835\udcdd c) \u2194 TendstoUniformlyOnFilter F (fun _ => c) p p'", "start": [321, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "tendsto_prod_principal_iff", "code": "theorem tendsto_prod_principal_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udcdd c) \u2194 TendstoUniformlyOn F (fun _ => c) p s", "start": [329, 1], "end": [334, 32], "kind": "commanddeclaration"}, {"full_name": "tendsto_prod_top_iff", "code": "theorem tendsto_prod_top_iff {c : \u03b2} :\n    Tendsto (\u21bfF) (p \u00d7\u02e2 \u22a4) (\ud835\udcdd c) \u2194 TendstoUniformly F (fun _ => c) p", "start": [337, 1], "end": [341, 32], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_empty", "code": "theorem tendstoUniformlyOn_empty : TendstoUniformlyOn F f p \u2205", "start": [344, 1], "end": [345, 84], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_singleton_iff_tendsto", "code": "theorem tendstoUniformlyOn_singleton_iff_tendsto :\n    TendstoUniformlyOn F f p {x} \u2194 Tendsto (fun n : \u03b9 => F n x) p (\ud835\udcdd (f x))", "start": [348, 1], "end": [352, 72], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.tendstoUniformlyOnFilter_const", "code": "theorem Filter.Tendsto.tendstoUniformlyOnFilter_const {g : \u03b9 \u2192 \u03b2} {b : \u03b2} (hg : Tendsto g p (\ud835\udcdd b))\n    (p' : Filter \u03b1) :\n    TendstoUniformlyOnFilter (fun n : \u03b9 => fun _ : \u03b1 => g n) (fun _ : \u03b1 => b) p p'", "start": [355, 1], "end": [360, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.tendstoUniformlyOn_const", "code": "theorem Filter.Tendsto.tendstoUniformlyOn_const {g : \u03b9 \u2192 \u03b2} {b : \u03b2} (hg : Tendsto g p (\ud835\udcdd b))\n    (s : Set \u03b1) : TendstoUniformlyOn (fun n : \u03b9 => fun _ : \u03b1 => g n) (fun _ : \u03b1 => b) p s", "start": [363, 1], "end": [367, 96], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousOn.tendstoUniformlyOn", "code": "theorem UniformContinuousOn.tendstoUniformlyOn [UniformSpace \u03b1] [UniformSpace \u03b3] {x : \u03b1} {U : Set \u03b1}\n    {V : Set \u03b2} {F : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hF : UniformContinuousOn (\u21bfF) (U \u00d7\u02e2 V)) (hU : x \u2208 U) :\n    TendstoUniformlyOn F (F x) (\ud835\udcdd[U] x) V", "start": [371, 1], "end": [382, 60], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousOn.tendstoUniformly", "code": "theorem UniformContinuousOn.tendstoUniformly [UniformSpace \u03b1] [UniformSpace \u03b3] {x : \u03b1} {U : Set \u03b1}\n    (hU : U \u2208 \ud835\udcdd x) {F : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (hF : UniformContinuousOn (\u21bfF) (U \u00d7\u02e2 (univ : Set \u03b2))) :\n    TendstoUniformly F (F x) (\ud835\udcdd x)", "start": [384, 1], "end": [388, 53], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous\u2082.tendstoUniformly", "code": "theorem UniformContinuous\u2082.tendstoUniformly [UniformSpace \u03b1] [UniformSpace \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3}\n    (h : UniformContinuous\u2082 f) {x : \u03b1} : TendstoUniformly f (f x) (\ud835\udcdd x)", "start": [391, 1], "end": [393, 101], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOnFilter", "code": "def UniformCauchySeqOnFilter (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (p : Filter \u03b9) (p' : Filter \u03b1) : Prop :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 m : (\u03b9 \u00d7 \u03b9) \u00d7 \u03b1 in (p \u00d7\u02e2 p) \u00d7\u02e2 p', (F m.fst.fst m.snd, F m.fst.snd m.snd) \u2208 u", "start": [396, 1], "end": [399, 94], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn", "code": "def UniformCauchySeqOn (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (p : Filter \u03b9) (s : Set \u03b1) : Prop :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200\u1da0 m : \u03b9 \u00d7 \u03b9 in p \u00d7\u02e2 p, \u2200 x : \u03b1, x \u2208 s \u2192 (F m.fst x, F m.snd x) \u2208 u", "start": [402, 1], "end": [405, 81], "kind": "commanddeclaration"}, {"full_name": "uniformCauchySeqOn_iff_uniformCauchySeqOnFilter", "code": "theorem uniformCauchySeqOn_iff_uniformCauchySeqOnFilter :\n    UniformCauchySeqOn F p s \u2194 UniformCauchySeqOnFilter F p (\ud835\udcdf s)", "start": [408, 1], "end": [412, 37], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.uniformCauchySeqOnFilter", "code": "theorem UniformCauchySeqOn.uniformCauchySeqOnFilter (hF : UniformCauchySeqOn F p s) :\n    UniformCauchySeqOnFilter F p (\ud835\udcdf s)", "start": [415, 1], "end": [416, 101], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.uniformCauchySeqOnFilter", "code": "theorem TendstoUniformlyOnFilter.uniformCauchySeqOnFilter (hF : TendstoUniformlyOnFilter F f p p') :\n    UniformCauchySeqOnFilter F p p'", "start": [419, 1], "end": [428, 76], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.uniformCauchySeqOn", "code": "theorem TendstoUniformlyOn.uniformCauchySeqOn (hF : TendstoUniformlyOn F f p s) :\n    UniformCauchySeqOn F p s", "start": [431, 1], "end": [435, 57], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto", "code": "theorem UniformCauchySeqOnFilter.tendstoUniformlyOnFilter_of_tendsto [NeBot p]\n    (hF : UniformCauchySeqOnFilter F p p')\n    (hF' : \u2200\u1da0 x : \u03b1 in p', Tendsto (fun n => F n x) p (\ud835\udcdd (f x))) :\n    TendstoUniformlyOnFilter F f p p'", "start": [438, 1], "end": [465, 37], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto", "code": "theorem UniformCauchySeqOn.tendstoUniformlyOn_of_tendsto [NeBot p] (hF : UniformCauchySeqOn F p s)\n    (hF' : \u2200 x : \u03b1, x \u2208 s \u2192 Tendsto (fun n => F n x) p (\ud835\udcdd (f x))) : TendstoUniformlyOn F f p s", "start": [468, 1], "end": [472, 74], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOnFilter.mono_left", "code": "theorem UniformCauchySeqOnFilter.mono_left {p'' : Filter \u03b9} (hf : UniformCauchySeqOnFilter F p p')\n    (hp : p'' \u2264 p) : UniformCauchySeqOnFilter F p'' p'", "start": [475, 1], "end": [479, 28], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOnFilter.mono_right", "code": "theorem UniformCauchySeqOnFilter.mono_right {p'' : Filter \u03b1} (hf : UniformCauchySeqOnFilter F p p')\n    (hp : p'' \u2264 p') : UniformCauchySeqOnFilter F p p''", "start": [482, 1], "end": [485, 22], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.mono", "code": "theorem UniformCauchySeqOn.mono {s' : Set \u03b1} (hf : UniformCauchySeqOn F p s) (hss' : s' \u2286 s) :\n    UniformCauchySeqOn F p s'", "start": [488, 1], "end": [491, 71], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOnFilter.comp", "code": "theorem UniformCauchySeqOnFilter.comp {\u03b3 : Type*} (hf : UniformCauchySeqOnFilter F p p')\n    (g : \u03b3 \u2192 \u03b1) : UniformCauchySeqOnFilter (fun n => F n \u2218 g) p (p'.comap g)", "start": [494, 1], "end": [500, 100], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.comp", "code": "theorem UniformCauchySeqOn.comp {\u03b3 : Type*} (hf : UniformCauchySeqOn F p s) (g : \u03b3 \u2192 \u03b1) :\n    UniformCauchySeqOn (fun n => F n \u2218 g) p (g \u207b\u00b9' s)", "start": [503, 1], "end": [507, 67], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.comp_uniformCauchySeqOn", "code": "theorem UniformContinuous.comp_uniformCauchySeqOn [UniformSpace \u03b3] {g : \u03b2 \u2192 \u03b3}\n    (hg : UniformContinuous g) (hf : UniformCauchySeqOn F p s) :\n    UniformCauchySeqOn (fun n => g \u2218 F n) p s", "start": [510, 1], "end": [514, 75], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.prod_map", "code": "theorem UniformCauchySeqOn.prod_map {\u03b9' \u03b1' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1' \u2192 \u03b2'}\n    {p' : Filter \u03b9'} {s' : Set \u03b1'} (h : UniformCauchySeqOn F p s)\n    (h' : UniformCauchySeqOn F' p' s') :\n    UniformCauchySeqOn (fun i : \u03b9 \u00d7 \u03b9' => Prod.map (F i.1) (F' i.2)) (p \u00d7\u02e2 p') (s \u00d7\u02e2 s')", "start": [517, 1], "end": [528, 60], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.prod", "code": "theorem UniformCauchySeqOn.prod {\u03b9' \u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9' \u2192 \u03b1 \u2192 \u03b2'}\n    {p' : Filter \u03b9'} (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p' s) :\n    UniformCauchySeqOn (fun (i : \u03b9 \u00d7 \u03b9') a => (F i.fst a, F' i.snd a)) (p \u00d7\u02e2 p') s", "start": [531, 1], "end": [534, 71], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.prod'", "code": "theorem UniformCauchySeqOn.prod' {\u03b2' : Type*} [UniformSpace \u03b2'] {F' : \u03b9 \u2192 \u03b1 \u2192 \u03b2'}\n    (h : UniformCauchySeqOn F p s) (h' : UniformCauchySeqOn F' p s) :\n    UniformCauchySeqOn (fun (i : \u03b9) a => (F i a, F' i a)) p s", "start": [537, 1], "end": [541, 49], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.cauchy_map", "code": "theorem UniformCauchySeqOn.cauchy_map [hp : NeBot p] (hf : UniformCauchySeqOn F p s) (hx : x \u2208 s) :\n    Cauchy (map (fun i => F i x) p)", "start": [544, 1], "end": [551, 51], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_of_seq_tendstoUniformlyOn", "code": "theorem tendstoUniformlyOn_of_seq_tendstoUniformlyOn {l : Filter \u03b9} [l.IsCountablyGenerated]\n    (h : \u2200 u : \u2115 \u2192 \u03b9, Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s) :\n    TendstoUniformlyOn F f l s", "start": [556, 1], "end": [564, 41], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.seq_tendstoUniformlyOn", "code": "theorem TendstoUniformlyOn.seq_tendstoUniformlyOn {l : Filter \u03b9} (h : TendstoUniformlyOn F f l s)\n    (u : \u2115 \u2192 \u03b9) (hu : Tendsto u atTop l) : TendstoUniformlyOn (fun n => F (u n)) f atTop s", "start": [567, 1], "end": [570, 59], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformlyOn_iff_seq_tendstoUniformlyOn", "code": "theorem tendstoUniformlyOn_iff_seq_tendstoUniformlyOn {l : Filter \u03b9} [l.IsCountablyGenerated] :\n    TendstoUniformlyOn F f l s \u2194\n      \u2200 u : \u2115 \u2192 \u03b9, Tendsto u atTop l \u2192 TendstoUniformlyOn (fun n => F (u n)) f atTop s", "start": [573, 1], "end": [576, 92], "kind": "commanddeclaration"}, {"full_name": "tendstoUniformly_iff_seq_tendstoUniformly", "code": "theorem tendstoUniformly_iff_seq_tendstoUniformly {l : Filter \u03b9} [l.IsCountablyGenerated] :\n    TendstoUniformly F f l \u2194\n      \u2200 u : \u2115 \u2192 \u03b9, Tendsto u atTop l \u2192 TendstoUniformly (fun n => F (u n)) f atTop", "start": [579, 1], "end": [583, 54], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn", "code": "def TendstoLocallyUniformlyOn (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (p : Filter \u03b9) (s : Set \u03b1) :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 n in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u", "start": [590, 1], "end": [594, 73], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformly", "code": "def TendstoLocallyUniformly (F : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (p : Filter \u03b9) :=\n  \u2200 u \u2208 \ud835\udce4 \u03b2, \u2200 x : \u03b1, \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 n in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u", "start": [597, 1], "end": [601, 70], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_univ", "code": "theorem tendstoLocallyUniformlyOn_univ :\n    TendstoLocallyUniformlyOn F f p univ \u2194 TendstoLocallyUniformly F f p", "start": [604, 1], "end": [606, 77], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iff_forall_tendsto", "code": "theorem tendstoLocallyUniformlyOn_iff_forall_tendsto :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      \u2200 x \u2208 s, Tendsto (fun y : \u03b9 \u00d7 \u03b1 => (f y.2, F y.1 y.2)) (p \u00d7\u02e2 \ud835\udcdd[s] x) (\ud835\udce4 \u03b2)", "start": [610, 1], "end": [614, 42], "kind": "commanddeclaration"}, {"full_name": "IsOpen.tendstoLocallyUniformlyOn_iff_forall_tendsto", "code": "nonrec theorem IsOpen.tendstoLocallyUniformlyOn_iff_forall_tendsto (hs : IsOpen s) :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      \u2200 x \u2208 s, Tendsto (fun y : \u03b9 \u00d7 \u03b1 => (f y.2, F y.1 y.2)) (p \u00d7\u02e2 \ud835\udcdd x) (\ud835\udce4 \u03b2)", "start": [616, 1], "end": [620, 29], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformly_iff_forall_tendsto", "code": "theorem tendstoLocallyUniformly_iff_forall_tendsto :\n    TendstoLocallyUniformly F f p \u2194\n      \u2200 x, Tendsto (fun y : \u03b9 \u00d7 \u03b1 => (f y.2, F y.1 y.2)) (p \u00d7\u02e2 \ud835\udcdd x) (\ud835\udce4 \u03b2)", "start": [622, 1], "end": [625, 100], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe", "code": "theorem tendstoLocallyUniformlyOn_iff_tendstoLocallyUniformly_comp_coe :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      TendstoLocallyUniformly (fun i (x : s) => F i x) (f \u2218 (\u2191)) p", "start": [628, 1], "end": [632, 95], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.tendstoLocallyUniformlyOn", "code": "protected theorem TendstoUniformlyOn.tendstoLocallyUniformlyOn (h : TendstoUniformlyOn F f p s) :\n    TendstoLocallyUniformlyOn F f p s", "start": [635, 1], "end": [637, 50], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.tendstoLocallyUniformly", "code": "protected theorem TendstoUniformly.tendstoLocallyUniformly (h : TendstoUniformly F f p) :\n    TendstoLocallyUniformly F f p", "start": [640, 1], "end": [641, 91], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.mono", "code": "theorem TendstoLocallyUniformlyOn.mono (h : TendstoLocallyUniformlyOn F f p s) (h' : s' \u2286 s) :\n    TendstoLocallyUniformlyOn F f p s'", "start": [644, 1], "end": [648, 57], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iUnion", "code": "theorem tendstoLocallyUniformlyOn_iUnion {\u03b9' : Sort*} {S : \u03b9' \u2192 Set \u03b1} (hS : \u2200 i, IsOpen (S i))\n    (h : \u2200 i, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p (\u22c3 i, S i)", "start": [652, 1], "end": [657, 69], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_biUnion", "code": "theorem tendstoLocallyUniformlyOn_biUnion {s : Set \u03b3} {S : \u03b3 \u2192 Set \u03b1} (hS : \u2200 i \u2208 s, IsOpen (S i))\n    (h : \u2200 i \u2208 s, TendstoLocallyUniformlyOn F f p (S i)) :\n    TendstoLocallyUniformlyOn F f p (\u22c3 i \u2208 s, S i)", "start": [660, 1], "end": [664, 49], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_sUnion", "code": "theorem tendstoLocallyUniformlyOn_sUnion (S : Set (Set \u03b1)) (hS : \u2200 s \u2208 S, IsOpen s)\n    (h : \u2200 s \u2208 S, TendstoLocallyUniformlyOn F f p s) : TendstoLocallyUniformlyOn F f p (\u22c3\u2080 S)", "start": [667, 1], "end": [670, 47], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.union", "code": "theorem TendstoLocallyUniformlyOn.union {s\u2081 s\u2082 : Set \u03b1} (hs\u2081 : IsOpen s\u2081) (hs\u2082 : IsOpen s\u2082)\n    (h\u2081 : TendstoLocallyUniformlyOn F f p s\u2081) (h\u2082 : TendstoLocallyUniformlyOn F f p s\u2082) :\n    TendstoLocallyUniformlyOn F f p (s\u2081 \u222a s\u2082)", "start": [673, 1], "end": [677, 62], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformly.tendstoLocallyUniformlyOn", "code": "protected theorem TendstoLocallyUniformly.tendstoLocallyUniformlyOn\n    (h : TendstoLocallyUniformly F f p) : TendstoLocallyUniformlyOn F f p s", "start": [682, 1], "end": [684, 62], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace", "code": "theorem tendstoLocallyUniformly_iff_tendstoUniformly_of_compactSpace [CompactSpace \u03b1] :\n    TendstoLocallyUniformly F f p \u2194 TendstoUniformly F f p", "start": [687, 1], "end": [699, 33], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact", "code": "theorem tendstoLocallyUniformlyOn_iff_tendstoUniformlyOn_of_compact (hs : IsCompact s) :\n    TendstoLocallyUniformlyOn F f p s \u2194 TendstoUniformlyOn F f p s", "start": [702, 1], "end": [709, 59], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.comp", "code": "theorem TendstoLocallyUniformlyOn.comp [TopologicalSpace \u03b3] {t : Set \u03b3}\n    (h : TendstoLocallyUniformlyOn F f p s) (g : \u03b3 \u2192 \u03b1) (hg : MapsTo g t s)\n    (cg : ContinuousOn g t) : TendstoLocallyUniformlyOn (fun n => F n \u2218 g) (f \u2218 g) p t", "start": [712, 1], "end": [719, 57], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformly.comp", "code": "theorem TendstoLocallyUniformly.comp [TopologicalSpace \u03b3] (h : TendstoLocallyUniformly F f p)\n    (g : \u03b3 \u2192 \u03b1) (cg : Continuous g) : TendstoLocallyUniformly (fun n => F n \u2218 g) (f \u2218 g) p", "start": [722, 1], "end": [726, 38], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_TFAE", "code": "theorem tendstoLocallyUniformlyOn_TFAE [LocallyCompactSpace \u03b1] (G : \u03b9 \u2192 \u03b1 \u2192 \u03b2) (g : \u03b1 \u2192 \u03b2)\n    (p : Filter \u03b9) (hs : IsOpen s) :\n    List.TFAE [\n      TendstoLocallyUniformlyOn G g p s,\n      \u2200 K, K \u2286 s \u2192 IsCompact K \u2192 TendstoUniformlyOn G g p K,\n      \u2200 x \u2208 s, \u2203 v \u2208 \ud835\udcdd[s] x, TendstoUniformlyOn G g p v]", "start": [729, 1], "end": [746, 14], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iff_forall_isCompact", "code": "theorem tendstoLocallyUniformlyOn_iff_forall_isCompact [LocallyCompactSpace \u03b1] (hs : IsOpen s) :\n    TendstoLocallyUniformlyOn F f p s \u2194 \u2200 K, K \u2286 s \u2192 IsCompact K \u2192 TendstoUniformlyOn F f p K", "start": [749, 1], "end": [751, 52], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformlyOn_iff_filter", "code": "theorem tendstoLocallyUniformlyOn_iff_filter :\n    TendstoLocallyUniformlyOn F f p s \u2194 \u2200 x \u2208 s, TendstoUniformlyOnFilter F f p (\ud835\udcdd[s] x)", "start": [754, 1], "end": [763, 70], "kind": "commanddeclaration"}, {"full_name": "tendstoLocallyUniformly_iff_filter", "code": "theorem tendstoLocallyUniformly_iff_filter :\n    TendstoLocallyUniformly F f p \u2194 \u2200 x, TendstoUniformlyOnFilter F f p (\ud835\udcdd x)", "start": [766, 1], "end": [769, 63], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.tendsto_at", "code": "theorem TendstoLocallyUniformlyOn.tendsto_at (hf : TendstoLocallyUniformlyOn F f p s) {a : \u03b1}\n    (ha : a \u2208 s) : Tendsto (fun i => F i a) p (\ud835\udcdd (f a))", "start": [772, 1], "end": [775, 70], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.unique", "code": "theorem TendstoLocallyUniformlyOn.unique [p.NeBot] [T2Space \u03b2] {g : \u03b1 \u2192 \u03b2}\n    (hf : TendstoLocallyUniformlyOn F f p s) (hg : TendstoLocallyUniformlyOn F g p s) :\n    s.EqOn f g", "start": [778, 1], "end": [780, 89], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.congr", "code": "theorem TendstoLocallyUniformlyOn.congr {G : \u03b9 \u2192 \u03b1 \u2192 \u03b2} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : \u2200 n, s.EqOn (F n) (G n)) : TendstoLocallyUniformlyOn G f p s", "start": [783, 1], "end": [788, 64], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.congr_right", "code": "theorem TendstoLocallyUniformlyOn.congr_right {g : \u03b1 \u2192 \u03b2} (hf : TendstoLocallyUniformlyOn F f p s)\n    (hg : s.EqOn f g) : TendstoLocallyUniformlyOn F g p s", "start": [791, 1], "end": [796, 62], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt", "code": "theorem continuousWithinAt_of_locally_uniform_approx_of_continuousWithinAt (hx : x \u2208 s)\n    (L : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd[s] x, \u2203 F : \u03b1 \u2192 \u03b2, ContinuousWithinAt F s x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u) :\n    ContinuousWithinAt f s x", "start": [809, 1], "end": [825, 61], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_locally_uniform_approx_of_continuousAt", "code": "theorem continuousAt_of_locally_uniform_approx_of_continuousAt\n    (L : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u) :\n    ContinuousAt f x", "start": [828, 1], "end": [835, 77], "kind": "commanddeclaration"}, {"full_name": "continuousOn_of_locally_uniform_approx_of_continuousWithinAt", "code": "theorem continuousOn_of_locally_uniform_approx_of_continuousWithinAt\n    (L : \u2200 x \u2208 s, \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd[s] x, \u2203 F,\n      ContinuousWithinAt F s x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u) :\n    ContinuousOn f s", "start": [838, 1], "end": [844, 81], "kind": "commanddeclaration"}, {"full_name": "continuousOn_of_uniform_approx_of_continuousOn", "code": "theorem continuousOn_of_uniform_approx_of_continuousOn\n    (L : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 F, ContinuousOn F s \u2227 \u2200 y \u2208 s, (f y, F y) \u2208 u) : ContinuousOn f s", "start": [847, 1], "end": [852, 91], "kind": "commanddeclaration"}, {"full_name": "continuous_of_locally_uniform_approx_of_continuousAt", "code": "theorem continuous_of_locally_uniform_approx_of_continuousAt\n    (L : \u2200 x : \u03b1, \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2203 F, ContinuousAt F x \u2227 \u2200 y \u2208 t, (f y, F y) \u2208 u) :\n    Continuous f", "start": [855, 1], "end": [860, 65], "kind": "commanddeclaration"}, {"full_name": "continuous_of_uniform_approx_of_continuous", "code": "theorem continuous_of_uniform_approx_of_continuous\n    (L : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 F, Continuous F \u2227 \u2200 y, (f y, F y) \u2208 u) : Continuous f", "start": [863, 1], "end": [868, 55], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.continuousOn", "code": "protected theorem TendstoLocallyUniformlyOn.continuousOn (h : TendstoLocallyUniformlyOn F f p s)\n    (hc : \u2200\u1da0 n in p, ContinuousOn (F n) s) [NeBot p] : ContinuousOn f s", "start": [879, 1], "end": [886, 54], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.continuousOn", "code": "protected theorem TendstoUniformlyOn.continuousOn (h : TendstoUniformlyOn F f p s)\n    (hc : \u2200\u1da0 n in p, ContinuousOn (F n) s) [NeBot p] : ContinuousOn f s", "start": [889, 1], "end": [893, 46], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformly.continuous", "code": "protected theorem TendstoLocallyUniformly.continuous (h : TendstoLocallyUniformly F f p)\n    (hc : \u2200\u1da0 n in p, Continuous (F n)) [NeBot p] : Continuous f", "start": [896, 1], "end": [900, 85], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.continuous", "code": "protected theorem TendstoUniformly.continuous (h : TendstoUniformly F f p)\n    (hc : \u2200\u1da0 n in p, Continuous (F n)) [NeBot p] : Continuous f", "start": [903, 1], "end": [906, 42], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_of_locally_uniform_limit_within", "code": "theorem tendsto_comp_of_locally_uniform_limit_within (h : ContinuousWithinAt f s x)\n    (hg : Tendsto g p (\ud835\udcdd[s] x))\n    (hunif : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 n in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u) :\n    Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [918, 1], "end": [930, 89], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_of_locally_uniform_limit", "code": "theorem tendsto_comp_of_locally_uniform_limit (h : ContinuousAt f x) (hg : Tendsto g p (\ud835\udcdd x))\n    (hunif : \u2200 u \u2208 \ud835\udce4 \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 n in p, \u2200 y \u2208 t, (f y, F n y) \u2208 u) :\n    Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [933, 1], "end": [940, 64], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformlyOn.tendsto_comp", "code": "theorem TendstoLocallyUniformlyOn.tendsto_comp (h : TendstoLocallyUniformlyOn F f p s)\n    (hf : ContinuousWithinAt f s x) (hx : x \u2208 s) (hg : Tendsto g p (\ud835\udcdd[s] x)) :\n    Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [943, 1], "end": [948, 77], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.tendsto_comp", "code": "theorem TendstoUniformlyOn.tendsto_comp (h : TendstoUniformlyOn F f p s)\n    (hf : ContinuousWithinAt f s x) (hg : Tendsto g p (\ud835\udcdd[s] x)) :\n    Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [951, 1], "end": [956, 98], "kind": "commanddeclaration"}, {"full_name": "TendstoLocallyUniformly.tendsto_comp", "code": "theorem TendstoLocallyUniformly.tendsto_comp (h : TendstoLocallyUniformly F f p)\n    (hf : ContinuousAt f x) (hg : Tendsto g p (\ud835\udcdd x)) : Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [959, 1], "end": [962, 67], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.tendsto_comp", "code": "theorem TendstoUniformly.tendsto_comp (h : TendstoUniformly F f p) (hf : ContinuousAt f x)\n    (hg : Tendsto g p (\ud835\udcdd x)) : Tendsto (fun n => F n (g n)) p (\ud835\udcdd (f x))", "start": [965, 1], "end": [968, 47], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Extr.lean", "imports": ["Mathlib/Order/ConditionallyCompleteLattice/Basic.lean", "Mathlib/Order/Filter/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsMinFilter", "code": "def IsMinFilter : Prop :=\n  \u2200\u1da0 x in l, f a \u2264 f x", "start": [95, 1], "end": [97, 23], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter", "code": "def IsMaxFilter : Prop :=\n  \u2200\u1da0 x in l, f x \u2264 f a", "start": [100, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter", "code": "def IsExtrFilter : Prop :=\n  IsMinFilter f l a \u2228 IsMaxFilter f l a", "start": [105, 1], "end": [107, 40], "kind": "commanddeclaration"}, {"full_name": "IsMinOn", "code": "def IsMinOn :=\n  IsMinFilter f (\ud835\udcdf s) a", "start": [110, 1], "end": [112, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn", "code": "def IsMaxOn :=\n  IsMaxFilter f (\ud835\udcdf s) a", "start": [115, 1], "end": [117, 24], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn", "code": "def IsExtrOn : Prop :=\n  IsExtrFilter f (\ud835\udcdf s) a", "start": [120, 1], "end": [122, 25], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.elim", "code": "theorem IsExtrOn.elim {p : Prop} : IsExtrOn f s a \u2192 (IsMinOn f s a \u2192 p) \u2192 (IsMaxOn f s a \u2192 p) \u2192 p", "start": [127, 1], "end": [128, 10], "kind": "commanddeclaration"}, {"full_name": "isMinOn_iff", "code": "theorem isMinOn_iff : IsMinOn f s a \u2194 \u2200 x \u2208 s, f a \u2264 f x", "start": [131, 1], "end": [132, 10], "kind": "commanddeclaration"}, {"full_name": "isMaxOn_iff", "code": "theorem isMaxOn_iff : IsMaxOn f s a \u2194 \u2200 x \u2208 s, f x \u2264 f a", "start": [135, 1], "end": [136, 10], "kind": "commanddeclaration"}, {"full_name": "isMinOn_univ_iff", "code": "theorem isMinOn_univ_iff : IsMinOn f univ a \u2194 \u2200 x, f a \u2264 f x", "start": [139, 1], "end": [140, 43], "kind": "commanddeclaration"}, {"full_name": "isMaxOn_univ_iff", "code": "theorem isMaxOn_univ_iff : IsMaxOn f univ a \u2194 \u2200 x, f x \u2264 f a", "start": [143, 1], "end": [144, 43], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.tendsto_principal_Ici", "code": "theorem IsMinFilter.tendsto_principal_Ici (h : IsMinFilter f l a) : Tendsto f l (\ud835\udcdf <| Ici (f a))", "start": [147, 1], "end": [148, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.tendsto_principal_Iic", "code": "theorem IsMaxFilter.tendsto_principal_Iic (h : IsMaxFilter f l a) : Tendsto f l (\ud835\udcdf <| Iic (f a))", "start": [151, 1], "end": [152, 24], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.isExtr", "code": "theorem IsMinFilter.isExtr : IsMinFilter f l a \u2192 IsExtrFilter f l a", "start": [158, 1], "end": [159, 9], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.isExtr", "code": "theorem IsMaxFilter.isExtr : IsMaxFilter f l a \u2192 IsExtrFilter f l a", "start": [162, 1], "end": [163, 9], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.isExtr", "code": "theorem IsMinOn.isExtr (h : IsMinOn f s a) : IsExtrOn f s a", "start": [166, 1], "end": [167, 23], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.isExtr", "code": "theorem IsMaxOn.isExtr (h : IsMaxOn f s a) : IsExtrOn f s a", "start": [170, 1], "end": [171, 23], "kind": "commanddeclaration"}, {"full_name": "isMinFilter_const", "code": "theorem isMinFilter_const {b : \u03b2} : IsMinFilter (fun _ => b) l a", "start": [177, 1], "end": [178, 28], "kind": "commanddeclaration"}, {"full_name": "isMaxFilter_const", "code": "theorem isMaxFilter_const {b : \u03b2} : IsMaxFilter (fun _ => b) l a", "start": [181, 1], "end": [182, 28], "kind": "commanddeclaration"}, {"full_name": "isExtrFilter_const", "code": "theorem isExtrFilter_const {b : \u03b2} : IsExtrFilter (fun _ => b) l a", "start": [185, 1], "end": [186, 27], "kind": "commanddeclaration"}, {"full_name": "isMinOn_const", "code": "theorem isMinOn_const {b : \u03b2} : IsMinOn (fun _ => b) s a", "start": [189, 1], "end": [190, 20], "kind": "commanddeclaration"}, {"full_name": "isMaxOn_const", "code": "theorem isMaxOn_const {b : \u03b2} : IsMaxOn (fun _ => b) s a", "start": [193, 1], "end": [194, 20], "kind": "commanddeclaration"}, {"full_name": "isExtrOn_const", "code": "theorem isExtrOn_const {b : \u03b2} : IsExtrOn (fun _ => b) s a", "start": [197, 1], "end": [198, 21], "kind": "commanddeclaration"}, {"full_name": "isMinFilter_dual_iff", "code": "theorem isMinFilter_dual_iff : IsMinFilter (toDual \u2218 f) l a \u2194 IsMaxFilter f l a", "start": [206, 1], "end": [207, 10], "kind": "commanddeclaration"}, {"full_name": "isMaxFilter_dual_iff", "code": "theorem isMaxFilter_dual_iff : IsMaxFilter (toDual \u2218 f) l a \u2194 IsMinFilter f l a", "start": [210, 1], "end": [211, 10], "kind": "commanddeclaration"}, {"full_name": "isExtrFilter_dual_iff", "code": "theorem isExtrFilter_dual_iff : IsExtrFilter (toDual \u2218 f) l a \u2194 IsExtrFilter f l a", "start": [214, 1], "end": [215, 10], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.undual", "code": "alias \u27e8IsMinFilter.undual, IsMaxFilter.dual\u27e9 := isMinFilter_dual_iff", "start": [218, 1], "end": [218, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMaxFilter.dual", "code": "alias \u27e8IsMinFilter.undual, IsMaxFilter.dual\u27e9 := isMinFilter_dual_iff", "start": [218, 1], "end": [218, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMaxFilter.undual", "code": "alias \u27e8IsMaxFilter.undual, IsMinFilter.dual\u27e9 := isMaxFilter_dual_iff", "start": [222, 1], "end": [222, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMinFilter.dual", "code": "alias \u27e8IsMaxFilter.undual, IsMinFilter.dual\u27e9 := isMaxFilter_dual_iff", "start": [222, 1], "end": [222, 69], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsExtrFilter.undual", "code": "alias \u27e8IsExtrFilter.undual, IsExtrFilter.dual\u27e9 := isExtrFilter_dual_iff", "start": [226, 1], "end": [226, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsExtrFilter.dual", "code": "alias \u27e8IsExtrFilter.undual, IsExtrFilter.dual\u27e9 := isExtrFilter_dual_iff", "start": [226, 1], "end": [226, 72], "kind": "stdtacticaliasaliaslr"}, {"full_name": "isMinOn_dual_iff", "code": "theorem isMinOn_dual_iff : IsMinOn (toDual \u2218 f) s a \u2194 IsMaxOn f s a", "start": [230, 1], "end": [231, 10], "kind": "commanddeclaration"}, {"full_name": "isMaxOn_dual_iff", "code": "theorem isMaxOn_dual_iff : IsMaxOn (toDual \u2218 f) s a \u2194 IsMinOn f s a", "start": [234, 1], "end": [235, 10], "kind": "commanddeclaration"}, {"full_name": "isExtrOn_dual_iff", "code": "theorem isExtrOn_dual_iff : IsExtrOn (toDual \u2218 f) s a \u2194 IsExtrOn f s a", "start": [238, 1], "end": [239, 10], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.undual", "code": "alias \u27e8IsMinOn.undual, IsMaxOn.dual\u27e9 := isMinOn_dual_iff", "start": [242, 1], "end": [242, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMaxOn.dual", "code": "alias \u27e8IsMinOn.undual, IsMaxOn.dual\u27e9 := isMinOn_dual_iff", "start": [242, 1], "end": [242, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMaxOn.undual", "code": "alias \u27e8IsMaxOn.undual, IsMinOn.dual\u27e9 := isMaxOn_dual_iff", "start": [246, 1], "end": [246, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMinOn.dual", "code": "alias \u27e8IsMaxOn.undual, IsMinOn.dual\u27e9 := isMaxOn_dual_iff", "start": [246, 1], "end": [246, 57], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsExtrOn.undual", "code": "alias \u27e8IsExtrOn.undual, IsExtrOn.dual\u27e9 := isExtrOn_dual_iff", "start": [250, 1], "end": [250, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsExtrOn.dual", "code": "alias \u27e8IsExtrOn.undual, IsExtrOn.dual\u27e9 := isExtrOn_dual_iff", "start": [250, 1], "end": [250, 60], "kind": "stdtacticaliasaliaslr"}, {"full_name": "IsMinFilter.filter_mono", "code": "theorem IsMinFilter.filter_mono (h : IsMinFilter f l a) (hl : l' \u2264 l) : IsMinFilter f l' a", "start": [257, 1], "end": [258, 7], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.filter_mono", "code": "theorem IsMaxFilter.filter_mono (h : IsMaxFilter f l a) (hl : l' \u2264 l) : IsMaxFilter f l' a", "start": [261, 1], "end": [262, 7], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.filter_mono", "code": "theorem IsExtrFilter.filter_mono (h : IsExtrFilter f l a) (hl : l' \u2264 l) : IsExtrFilter f l' a", "start": [265, 1], "end": [266, 81], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.filter_inf", "code": "theorem IsMinFilter.filter_inf (h : IsMinFilter f l a) (l') : IsMinFilter f (l \u2293 l') a", "start": [269, 1], "end": [270, 28], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.filter_inf", "code": "theorem IsMaxFilter.filter_inf (h : IsMaxFilter f l a) (l') : IsMaxFilter f (l \u2293 l') a", "start": [273, 1], "end": [274, 28], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.filter_inf", "code": "theorem IsExtrFilter.filter_inf (h : IsExtrFilter f l a) (l') : IsExtrFilter f (l \u2293 l') a", "start": [277, 1], "end": [278, 28], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.on_subset", "code": "theorem IsMinOn.on_subset (hf : IsMinOn f t a) (h : s \u2286 t) : IsMinOn f s a", "start": [281, 1], "end": [282, 39], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.on_subset", "code": "theorem IsMaxOn.on_subset (hf : IsMaxOn f t a) (h : s \u2286 t) : IsMaxOn f s a", "start": [285, 1], "end": [286, 39], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.on_subset", "code": "theorem IsExtrOn.on_subset (hf : IsExtrOn f t a) (h : s \u2286 t) : IsExtrOn f s a", "start": [289, 1], "end": [290, 39], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.inter", "code": "theorem IsMinOn.inter (hf : IsMinOn f s a) (t) : IsMinOn f (s \u2229 t) a", "start": [293, 1], "end": [294, 39], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.inter", "code": "theorem IsMaxOn.inter (hf : IsMaxOn f s a) (t) : IsMaxOn f (s \u2229 t) a", "start": [297, 1], "end": [298, 39], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.inter", "code": "theorem IsExtrOn.inter (hf : IsExtrOn f s a) (t) : IsExtrOn f (s \u2229 t) a", "start": [301, 1], "end": [302, 39], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.comp_mono", "code": "theorem IsMinFilter.comp_mono (hf : IsMinFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsMinFilter (g \u2218 f) l a", "start": [308, 1], "end": [310, 40], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.comp_mono", "code": "theorem IsMaxFilter.comp_mono (hf : IsMaxFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsMaxFilter (g \u2218 f) l a", "start": [313, 1], "end": [315, 40], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.comp_mono", "code": "theorem IsExtrFilter.comp_mono (hf : IsExtrFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsExtrFilter (g \u2218 f) l a", "start": [318, 1], "end": [320, 82], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.comp_antitone", "code": "theorem IsMinFilter.comp_antitone (hf : IsMinFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsMaxFilter (g \u2218 f) l a", "start": [323, 1], "end": [325, 38], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.comp_antitone", "code": "theorem IsMaxFilter.comp_antitone (hf : IsMaxFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsMinFilter (g \u2218 f) l a", "start": [328, 1], "end": [330, 38], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.comp_antitone", "code": "theorem IsExtrFilter.comp_antitone (hf : IsExtrFilter f l a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsExtrFilter (g \u2218 f) l a", "start": [333, 1], "end": [335, 38], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.comp_mono", "code": "theorem IsMinOn.comp_mono (hf : IsMinOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsMinOn (g \u2218 f) s a", "start": [338, 1], "end": [340, 30], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.comp_mono", "code": "theorem IsMaxOn.comp_mono (hf : IsMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsMaxOn (g \u2218 f) s a", "start": [343, 1], "end": [345, 30], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.comp_mono", "code": "theorem IsExtrOn.comp_mono (hf : IsExtrOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsExtrOn (g \u2218 f) s a", "start": [348, 1], "end": [350, 31], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.comp_antitone", "code": "theorem IsMinOn.comp_antitone (hf : IsMinOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsMaxOn (g \u2218 f) s a", "start": [353, 1], "end": [355, 34], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.comp_antitone", "code": "theorem IsMaxOn.comp_antitone (hf : IsMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsMinOn (g \u2218 f) s a", "start": [358, 1], "end": [360, 34], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.comp_antitone", "code": "theorem IsExtrOn.comp_antitone (hf : IsExtrOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsExtrOn (g \u2218 f) s a", "start": [363, 1], "end": [365, 35], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.bicomp_mono", "code": "theorem IsMinFilter.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsMinFilter f l a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsMinFilter g l a) : IsMinFilter (fun x => op (f x) (g x)) l a", "start": [368, 1], "end": [371, 69], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.bicomp_mono", "code": "theorem IsMaxFilter.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsMaxFilter f l a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsMaxFilter g l a) : IsMaxFilter (fun x => op (f x) (g x)) l a", "start": [374, 1], "end": [377, 69], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.bicomp_mono", "code": "theorem IsMinOn.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsMinOn f s a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsMinOn g s a) : IsMinOn (fun x => op (f x) (g x)) s a", "start": [381, 1], "end": [384, 36], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.bicomp_mono", "code": "theorem IsMaxOn.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsMaxOn f s a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsMaxOn g s a) : IsMaxOn (fun x => op (f x) (g x)) s a", "start": [387, 1], "end": [390, 36], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.comp_tendsto", "code": "theorem IsMinFilter.comp_tendsto {g : \u03b4 \u2192 \u03b1} {l' : Filter \u03b4} {b : \u03b4} (hf : IsMinFilter f l (g b))\n    (hg : Tendsto g l' l) : IsMinFilter (f \u2218 g) l' b", "start": [396, 1], "end": [398, 8], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.comp_tendsto", "code": "theorem IsMaxFilter.comp_tendsto {g : \u03b4 \u2192 \u03b1} {l' : Filter \u03b4} {b : \u03b4} (hf : IsMaxFilter f l (g b))\n    (hg : Tendsto g l' l) : IsMaxFilter (f \u2218 g) l' b", "start": [401, 1], "end": [403, 8], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.comp_tendsto", "code": "theorem IsExtrFilter.comp_tendsto {g : \u03b4 \u2192 \u03b1} {l' : Filter \u03b4} {b : \u03b4} (hf : IsExtrFilter f l (g b))\n    (hg : Tendsto g l' l) : IsExtrFilter (f \u2218 g) l' b", "start": [406, 1], "end": [408, 88], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.on_preimage", "code": "theorem IsMinOn.on_preimage (g : \u03b4 \u2192 \u03b1) {b : \u03b4} (hf : IsMinOn f s (g b)) :\n    IsMinOn (f \u2218 g) (g \u207b\u00b9' s) b", "start": [411, 1], "end": [413, 69], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.on_preimage", "code": "theorem IsMaxOn.on_preimage (g : \u03b4 \u2192 \u03b1) {b : \u03b4} (hf : IsMaxOn f s (g b)) :\n    IsMaxOn (f \u2218 g) (g \u207b\u00b9' s) b", "start": [416, 1], "end": [418, 69], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.on_preimage", "code": "theorem IsExtrOn.on_preimage (g : \u03b4 \u2192 \u03b1) {b : \u03b4} (hf : IsExtrOn f s (g b)) :\n    IsExtrOn (f \u2218 g) (g \u207b\u00b9' s) b", "start": [421, 1], "end": [423, 84], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.comp_mapsTo", "code": "theorem IsMinOn.comp_mapsTo {t : Set \u03b4} {g : \u03b4 \u2192 \u03b1} {b : \u03b4} (hf : IsMinOn f s a) (hg : MapsTo g t s)\n    (ha : g b = a) : IsMinOn (f \u2218 g) t b", "start": [426, 1], "end": [428, 44], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.comp_mapsTo", "code": "theorem IsMaxOn.comp_mapsTo {t : Set \u03b4} {g : \u03b4 \u2192 \u03b1} {b : \u03b4} (hf : IsMaxOn f s a) (hg : MapsTo g t s)\n    (ha : g b = a) : IsMaxOn (f \u2218 g) t b", "start": [431, 1], "end": [433, 28], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.comp_mapsTo", "code": "theorem IsExtrOn.comp_mapsTo {t : Set \u03b4} {g : \u03b4 \u2192 \u03b1} {b : \u03b4} (hf : IsExtrOn f s a)\n    (hg : MapsTo g t s) (ha : g b = a) : IsExtrOn (f \u2218 g) t b", "start": [436, 1], "end": [438, 90], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.add", "code": "theorem IsMinFilter.add (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x + g x) l a", "start": [450, 1], "end": [453, 68], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.add", "code": "theorem IsMaxFilter.add (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x + g x) l a", "start": [456, 1], "end": [459, 68], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.add", "code": "theorem IsMinOn.add (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x + g x) s a", "start": [462, 1], "end": [463, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.add", "code": "theorem IsMaxOn.add (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x + g x) s a", "start": [466, 1], "end": [467, 24], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.neg", "code": "theorem IsMinFilter.neg (hf : IsMinFilter f l a) : IsMaxFilter (fun x => -f x) l a", "start": [479, 1], "end": [480, 49], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.neg", "code": "theorem IsMaxFilter.neg (hf : IsMaxFilter f l a) : IsMinFilter (fun x => -f x) l a", "start": [483, 1], "end": [484, 49], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.neg", "code": "theorem IsExtrFilter.neg (hf : IsExtrFilter f l a) : IsExtrFilter (fun x => -f x) l a", "start": [487, 1], "end": [488, 60], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.neg", "code": "theorem IsMinOn.neg (hf : IsMinOn f s a) : IsMaxOn (fun x => -f x) s a", "start": [491, 1], "end": [492, 49], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.neg", "code": "theorem IsMaxOn.neg (hf : IsMaxOn f s a) : IsMinOn (fun x => -f x) s a", "start": [495, 1], "end": [496, 49], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.neg", "code": "theorem IsExtrOn.neg (hf : IsExtrOn f s a) : IsExtrOn (fun x => -f x) s a", "start": [499, 1], "end": [500, 60], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.sub", "code": "theorem IsMinFilter.sub (hf : IsMinFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMinFilter (fun x => f x - g x) l a", "start": [503, 1], "end": [504, 95], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.sub", "code": "theorem IsMaxFilter.sub (hf : IsMaxFilter f l a) (hg : IsMinFilter g l a) :\n    IsMaxFilter (fun x => f x - g x) l a", "start": [507, 1], "end": [508, 95], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.sub", "code": "theorem IsMinOn.sub (hf : IsMinOn f s a) (hg : IsMaxOn g s a) : IsMinOn (fun x => f x - g x) s a", "start": [511, 1], "end": [512, 53], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.sub", "code": "theorem IsMaxOn.sub (hf : IsMaxOn f s a) (hg : IsMinOn g s a) : IsMaxOn (fun x => f x - g x) s a", "start": [515, 1], "end": [516, 53], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.sup", "code": "theorem IsMinFilter.sup (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x \u2294 g x) l a", "start": [528, 1], "end": [531, 68], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.sup", "code": "theorem IsMaxFilter.sup (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x \u2294 g x) l a", "start": [534, 1], "end": [537, 68], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.sup", "code": "theorem IsMinOn.sup (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x \u2294 g x) s a", "start": [540, 1], "end": [541, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.sup", "code": "theorem IsMaxOn.sup (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x \u2294 g x) s a", "start": [544, 1], "end": [545, 24], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.inf", "code": "theorem IsMinFilter.inf (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => f x \u2293 g x) l a", "start": [554, 1], "end": [557, 68], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.inf", "code": "theorem IsMaxFilter.inf (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => f x \u2293 g x) l a", "start": [560, 1], "end": [563, 68], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.inf", "code": "theorem IsMinOn.inf (hf : IsMinOn f s a) (hg : IsMinOn g s a) : IsMinOn (fun x => f x \u2293 g x) s a", "start": [566, 1], "end": [567, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.inf", "code": "theorem IsMaxOn.inf (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x \u2293 g x) s a", "start": [570, 1], "end": [571, 24], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.min", "code": "theorem IsMinFilter.min (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => min (f x) (g x)) l a", "start": [583, 1], "end": [586, 68], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.min", "code": "theorem IsMaxFilter.min (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => min (f x) (g x)) l a", "start": [589, 1], "end": [592, 68], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.min", "code": "theorem IsMinOn.min (hf : IsMinOn f s a) (hg : IsMinOn g s a) :\n    IsMinOn (fun x => min (f x) (g x)) s a", "start": [595, 1], "end": [597, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.min", "code": "theorem IsMaxOn.min (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) :\n    IsMaxOn (fun x => min (f x) (g x)) s a", "start": [600, 1], "end": [602, 24], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.max", "code": "theorem IsMinFilter.max (hf : IsMinFilter f l a) (hg : IsMinFilter g l a) :\n    IsMinFilter (fun x => max (f x) (g x)) l a", "start": [605, 1], "end": [608, 68], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.max", "code": "theorem IsMaxFilter.max (hf : IsMaxFilter f l a) (hg : IsMaxFilter g l a) :\n    IsMaxFilter (fun x => max (f x) (g x)) l a", "start": [611, 1], "end": [614, 68], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.max", "code": "theorem IsMinOn.max (hf : IsMinOn f s a) (hg : IsMinOn g s a) :\n    IsMinOn (fun x => max (f x) (g x)) s a", "start": [617, 1], "end": [619, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.max", "code": "theorem IsMaxOn.max (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) :\n    IsMaxOn (fun x => max (f x) (g x)) s a", "start": [622, 1], "end": [624, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isMaxFilter", "code": "theorem Filter.EventuallyLE.isMaxFilter {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (hle : g \u2264\u1da0[l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\n    IsMaxFilter g l a", "start": [634, 1], "end": [639, 24], "kind": "commanddeclaration"}, {"full_name": "IsMaxFilter.congr", "code": "theorem IsMaxFilter.congr {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}\n    (h : IsMaxFilter f l a) (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsMaxFilter g l a", "start": [642, 1], "end": [644, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isMaxFilter_iff", "code": "theorem Filter.EventuallyEq.isMaxFilter_iff {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsMaxFilter f l a \u2194 IsMaxFilter g l a", "start": [647, 1], "end": [649, 67], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isMinFilter", "code": "theorem Filter.EventuallyLE.isMinFilter {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (hle : f \u2264\u1da0[l] g) (hfga : f a = g a) (h : IsMinFilter f l a) :\n    IsMinFilter g l a", "start": [652, 1], "end": [655, 62], "kind": "commanddeclaration"}, {"full_name": "IsMinFilter.congr", "code": "theorem IsMinFilter.congr {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}\n    (h : IsMinFilter f l a) (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsMinFilter g l a", "start": [658, 1], "end": [660, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isMinFilter_iff", "code": "theorem Filter.EventuallyEq.isMinFilter_iff {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsMinFilter f l a \u2194 IsMinFilter g l a", "start": [663, 1], "end": [665, 67], "kind": "commanddeclaration"}, {"full_name": "IsExtrFilter.congr", "code": "theorem IsExtrFilter.congr {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} {l : Filter \u03b1}\n    (h : IsExtrFilter f l a) (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsExtrFilter g l a", "start": [668, 1], "end": [671, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isExtrFilter_iff", "code": "theorem Filter.EventuallyEq.isExtrFilter_iff {\u03b1 \u03b2 : Type*} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n    {l : Filter \u03b1} (heq : f =\u1da0[l] g) (hfga : f a = g a) : IsExtrFilter f l a \u2194 IsExtrFilter g l a", "start": [674, 1], "end": [676, 67], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.iSup_eq", "code": "theorem IsMaxOn.iSup_eq (hx\u2080 : x\u2080 \u2208 s) (h : IsMaxOn f s x\u2080) : \u2a06 x : s, f x = f x\u2080", "start": [688, 1], "end": [690, 93], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.iInf_eq", "code": "theorem IsMinOn.iInf_eq (hx\u2080 : x\u2080 \u2208 s) (h : IsMinOn f s x\u2080) : \u2a05 x : s, f x = f x\u2080", "start": [693, 1], "end": [694, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Order/Basic.lean", "imports": ["Mathlib/Topology/Support.lean", "Mathlib/Order/Filter/Interval.lean", "Mathlib/Data/Set/Intervals/Pi.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/TFAE.lean", "Mathlib/Data/Set/Pointwise/Interval.lean", "Mathlib/Topology/Algebra/Order/LeftRight.lean"], "premises": [{"full_name": "ClosedIicTopology", "code": "class ClosedIicTopology (\u03b1 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  isClosed_le' (a : \u03b1) : IsClosed { b : \u03b1 | b \u2264 a }", "start": [89, 1], "end": [93, 52], "kind": "commanddeclaration"}, {"full_name": "ClosedIciTopology", "code": "class ClosedIciTopology (\u03b1 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  isClosed_ge' (a : \u03b1) : IsClosed { b : \u03b1 | a \u2264 b }", "start": [98, 1], "end": [102, 52], "kind": "commanddeclaration"}, {"full_name": "OrderClosedTopology", "code": "class OrderClosedTopology (\u03b1 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  isClosed_le' : IsClosed { p : \u03b1 \u00d7 \u03b1 | p.1 \u2264 p.2 }", "start": [107, 1], "end": [113, 52], "kind": "commanddeclaration"}, {"full_name": "Dense.orderDual", "code": "theorem Dense.orderDual [TopologicalSpace \u03b1] {s : Set \u03b1} (hs : Dense s) :\n    Dense (OrderDual.ofDual \u207b\u00b9' s)", "start": [119, 1], "end": [121, 5], "kind": "commanddeclaration"}, {"full_name": "isClosed_Iic", "code": "theorem isClosed_Iic {a : \u03b1} : IsClosed (Iic a)", "start": [131, 1], "end": [132, 17], "kind": "commanddeclaration"}, {"full_name": "closure_Iic", "code": "@[simp]\ntheorem closure_Iic (a : \u03b1) : closure (Iic a) = Iic a", "start": [135, 1], "end": [137, 26], "kind": "commanddeclaration"}, {"full_name": "le_of_tendsto", "code": "theorem le_of_tendsto {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {x : Filter \u03b2} [NeBot x] (lim : Tendsto f x (\ud835\udcdd a))\n    (h : \u2200\u1da0 c in x, f c \u2264 b) : a \u2264 b", "start": [140, 1], "end": [142, 40], "kind": "commanddeclaration"}, {"full_name": "le_of_tendsto'", "code": "theorem le_of_tendsto' {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {x : Filter \u03b2} [NeBot x] (lim : Tendsto f x (\ud835\udcdd a))\n    (h : \u2200 c, f c \u2264 b) : a \u2264 b", "start": [145, 1], "end": [147, 45], "kind": "commanddeclaration"}, {"full_name": "isClosed_Ici", "code": "theorem isClosed_Ici {a : \u03b1} : IsClosed (Ici a)", "start": [159, 1], "end": [160, 17], "kind": "commanddeclaration"}, {"full_name": "closure_Ici", "code": "@[simp]\ntheorem closure_Ici (a : \u03b1) : closure (Ici a) = Ici a", "start": [163, 1], "end": [165, 26], "kind": "commanddeclaration"}, {"full_name": "ge_of_tendsto", "code": "theorem ge_of_tendsto {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {x : Filter \u03b2} [NeBot x] (lim : Tendsto f x (\ud835\udcdd a))\n    (h : \u2200\u1da0 c in x, b \u2264 f c) : b \u2264 a", "start": [168, 1], "end": [170, 40], "kind": "commanddeclaration"}, {"full_name": "ge_of_tendsto'", "code": "theorem ge_of_tendsto' {f : \u03b2 \u2192 \u03b1} {a b : \u03b1} {x : Filter \u03b2} [NeBot x] (lim : Tendsto f x (\ud835\udcdd a))\n    (h : \u2200 c, b \u2264 f c) : b \u2264 a", "start": [173, 1], "end": [175, 45], "kind": "commanddeclaration"}, {"full_name": "isClosed_le_prod", "code": "theorem isClosed_le_prod : IsClosed { p : \u03b1 \u00d7 \u03b1 | p.1 \u2264 p.2 }", "start": [196, 1], "end": [197, 17], "kind": "commanddeclaration"}, {"full_name": "isClosed_le", "code": "theorem isClosed_le [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) :\n    IsClosed { b | f b \u2264 g b }", "start": [200, 1], "end": [202, 64], "kind": "commanddeclaration"}, {"full_name": "isClosed_Icc", "code": "theorem isClosed_Icc {a b : \u03b1} : IsClosed (Icc a b)", "start": [214, 1], "end": [215, 43], "kind": "commanddeclaration"}, {"full_name": "closure_Icc", "code": "@[simp]\ntheorem closure_Icc (a b : \u03b1) : closure (Icc a b) = Icc a b", "start": [218, 1], "end": [220, 26], "kind": "commanddeclaration"}, {"full_name": "le_of_tendsto_of_tendsto", "code": "theorem le_of_tendsto_of_tendsto {f g : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a\u2081 a\u2082 : \u03b1} [NeBot b]\n    (hf : Tendsto f b (\ud835\udcdd a\u2081)) (hg : Tendsto g b (\ud835\udcdd a\u2082)) (h : f \u2264\u1da0[b] g) : a\u2081 \u2264 a\u2082", "start": [223, 1], "end": [226, 86], "kind": "commanddeclaration"}, {"full_name": "tendsto_le_of_eventuallyLE", "code": "alias tendsto_le_of_eventuallyLE := le_of_tendsto_of_tendsto", "start": [229, 1], "end": [229, 61], "kind": "stdtacticaliasalias"}, {"full_name": "le_of_tendsto_of_tendsto'", "code": "theorem le_of_tendsto_of_tendsto' {f g : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a\u2081 a\u2082 : \u03b1} [NeBot b]\n    (hf : Tendsto f b (\ud835\udcdd a\u2081)) (hg : Tendsto g b (\ud835\udcdd a\u2082)) (h : \u2200 x, f x \u2264 g x) : a\u2081 \u2264 a\u2082", "start": [232, 1], "end": [234, 58], "kind": "commanddeclaration"}, {"full_name": "closure_le_eq", "code": "@[simp]\ntheorem closure_le_eq [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) :\n    closure { b | f b \u2264 g b } = { b | f b \u2264 g b }", "start": [237, 1], "end": [240, 33], "kind": "commanddeclaration"}, {"full_name": "closure_lt_subset_le", "code": "theorem closure_lt_subset_le [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) : closure { b | f b < g b } \u2286 { b | f b \u2264 g b }", "start": [243, 1], "end": [245, 59], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.closure_le", "code": "theorem ContinuousWithinAt.closure_le [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} {s : Set \u03b2} {x : \u03b2}\n    (hx : x \u2208 closure s) (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x)\n    (h : \u2200 y \u2208 s, f y \u2264 g y) : f x \u2264 g x", "start": [248, 1], "end": [252, 84], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isClosed_le", "code": "theorem IsClosed.isClosed_le [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (hs : IsClosed s)\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) : IsClosed ({ x \u2208 s | f x \u2264 g x })", "start": [255, 1], "end": [259, 77], "kind": "commanddeclaration"}, {"full_name": "le_on_closure", "code": "theorem le_on_closure [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (h : \u2200 x \u2208 s, f x \u2264 g x)\n    (hf : ContinuousOn f (closure s)) (hg : ContinuousOn g (closure s)) \u2983x\u2984 (hx : x \u2208 closure s) :\n    f x \u2264 g x", "start": [262, 1], "end": [266, 67], "kind": "commanddeclaration"}, {"full_name": "IsClosed.epigraph", "code": "theorem IsClosed.epigraph [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (hs : IsClosed s)\n    (hf : ContinuousOn f s) : IsClosed { p : \u03b2 \u00d7 \u03b1 | p.1 \u2208 s \u2227 f p.1 \u2264 p.2 }", "start": [269, 1], "end": [271, 98], "kind": "commanddeclaration"}, {"full_name": "IsClosed.hypograph", "code": "theorem IsClosed.hypograph [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (hs : IsClosed s)\n    (hf : ContinuousOn f s) : IsClosed { p : \u03b2 \u00d7 \u03b1 | p.1 \u2208 s \u2227 p.2 \u2264 f p.1 }", "start": [274, 1], "end": [276, 98], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_neBot", "code": "theorem nhdsWithin_Ici_neBot {a b : \u03b1} (H\u2082 : a \u2264 b) : NeBot (\ud835\udcdd[Ici a] b)", "start": [280, 1], "end": [281, 29], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_self_neBot", "code": "@[instance]\ntheorem nhdsWithin_Ici_self_neBot (a : \u03b1) : NeBot (\ud835\udcdd[\u2265] a)", "start": [284, 1], "end": [286, 35], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_neBot", "code": "theorem nhdsWithin_Iic_neBot {a b : \u03b1} (H : a \u2264 b) : NeBot (\ud835\udcdd[Iic b] a)", "start": [289, 1], "end": [290, 28], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_self_neBot", "code": "@[instance]\ntheorem nhdsWithin_Iic_self_neBot (a : \u03b1) : NeBot (\ud835\udcdd[\u2264] a)", "start": [293, 1], "end": [295, 35], "kind": "commanddeclaration"}, {"full_name": "OrderClosedTopology.to_t2Space", "code": "instance (priority := 90) OrderClosedTopology.to_t2Space : T2Space \u03b1 :=\n  t2_iff_isClosed_diagonal.2 <| by\n    simpa only [diagonal, le_antisymm_iff] using\n      t.isClosed_le'.inter (isClosed_le continuous_snd continuous_fst)", "start": [305, 1], "end": [308, 71], "kind": "commanddeclaration"}, {"full_name": "isOpen_lt", "code": "theorem isOpen_lt [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) :\n    IsOpen { b | f b < g b }", "start": [317, 1], "end": [319, 68], "kind": "commanddeclaration"}, {"full_name": "isOpen_lt_prod", "code": "theorem isOpen_lt_prod : IsOpen { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 }", "start": [322, 1], "end": [323, 42], "kind": "commanddeclaration"}, {"full_name": "isOpen_Iio", "code": "theorem isOpen_Iio : IsOpen (Iio a)", "start": [328, 1], "end": [329, 43], "kind": "commanddeclaration"}, {"full_name": "isOpen_Ioi", "code": "theorem isOpen_Ioi : IsOpen (Ioi a)", "start": [332, 1], "end": [333, 43], "kind": "commanddeclaration"}, {"full_name": "isOpen_Ioo", "code": "theorem isOpen_Ioo : IsOpen (Ioo a b)", "start": [336, 1], "end": [337, 37], "kind": "commanddeclaration"}, {"full_name": "interior_Ioi", "code": "@[simp]\ntheorem interior_Ioi : interior (Ioi a) = Ioi a", "start": [340, 1], "end": [342, 25], "kind": "commanddeclaration"}, {"full_name": "interior_Iio", "code": "@[simp]\ntheorem interior_Iio : interior (Iio a) = Iio a", "start": [345, 1], "end": [347, 25], "kind": "commanddeclaration"}, {"full_name": "interior_Ioo", "code": "@[simp]\ntheorem interior_Ioo : interior (Ioo a b) = Ioo a b", "start": [350, 1], "end": [352, 25], "kind": "commanddeclaration"}, {"full_name": "Ioo_subset_closure_interior", "code": "theorem Ioo_subset_closure_interior : Ioo a b \u2286 closure (interior (Ioo a b))", "start": [355, 1], "end": [356, 43], "kind": "commanddeclaration"}, {"full_name": "Iio_mem_nhds", "code": "theorem Iio_mem_nhds {a b : \u03b1} (h : a < b) : Iio b \u2208 \ud835\udcdd a", "start": [359, 1], "end": [360, 31], "kind": "commanddeclaration"}, {"full_name": "Ioi_mem_nhds", "code": "theorem Ioi_mem_nhds {a b : \u03b1} (h : a < b) : Ioi a \u2208 \ud835\udcdd b", "start": [363, 1], "end": [364, 31], "kind": "commanddeclaration"}, {"full_name": "Iic_mem_nhds", "code": "theorem Iic_mem_nhds {a b : \u03b1} (h : a < b) : Iic b \u2208 \ud835\udcdd a", "start": [367, 1], "end": [368, 55], "kind": "commanddeclaration"}, {"full_name": "Ici_mem_nhds", "code": "theorem Ici_mem_nhds {a b : \u03b1} (h : a < b) : Ici a \u2208 \ud835\udcdd b", "start": [371, 1], "end": [372, 55], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhds", "code": "theorem Ioo_mem_nhds {a b x : \u03b1} (ha : a < x) (hb : x < b) : Ioo a b \u2208 \ud835\udcdd x", "start": [375, 1], "end": [376, 38], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhds", "code": "theorem Ioc_mem_nhds {a b x : \u03b1} (ha : a < x) (hb : x < b) : Ioc a b \u2208 \ud835\udcdd x", "start": [379, 1], "end": [380, 59], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhds", "code": "theorem Ico_mem_nhds {a b x : \u03b1} (ha : a < x) (hb : x < b) : Ico a b \u2208 \ud835\udcdd x", "start": [383, 1], "end": [384, 59], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhds", "code": "theorem Icc_mem_nhds {a b x : \u03b1} (ha : a < x) (hb : x < b) : Icc a b \u2208 \ud835\udcdd x", "start": [387, 1], "end": [388, 59], "kind": "commanddeclaration"}, {"full_name": "eventually_lt_of_tendsto_lt", "code": "theorem eventually_lt_of_tendsto_lt {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} {u v : \u03b1} (hv : v < u)\n    (h : Filter.Tendsto f l (\ud835\udcdd v)) : \u2200\u1da0 a in l, f a < u", "start": [391, 1], "end": [393, 41], "kind": "commanddeclaration"}, {"full_name": "eventually_gt_of_tendsto_gt", "code": "theorem eventually_gt_of_tendsto_gt {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} {u v : \u03b1} (hv : u < v)\n    (h : Filter.Tendsto f l (\ud835\udcdd v)) : \u2200\u1da0 a in l, u < f a", "start": [396, 1], "end": [398, 41], "kind": "commanddeclaration"}, {"full_name": "eventually_le_of_tendsto_lt", "code": "theorem eventually_le_of_tendsto_lt {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} {u v : \u03b1} (hv : v < u)\n    (h : Tendsto f l (\ud835\udcdd v)) : \u2200\u1da0 a in l, f a \u2264 u", "start": [401, 1], "end": [403, 60], "kind": "commanddeclaration"}, {"full_name": "eventually_ge_of_tendsto_gt", "code": "theorem eventually_ge_of_tendsto_gt {l : Filter \u03b3} {f : \u03b3 \u2192 \u03b1} {u v : \u03b1} (hv : u < v)\n    (h : Tendsto f l (\ud835\udcdd v)) : \u2200\u1da0 a in l, u \u2264 f a", "start": [406, 1], "end": [408, 60], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Ioi", "code": "theorem Ioo_mem_nhdsWithin_Ioi {a b c : \u03b1} (H : b \u2208 Ico a c) : Ioo a c \u2208 \ud835\udcdd[>] b", "start": [427, 1], "end": [429, 95], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Ioi'", "code": "theorem Ioo_mem_nhdsWithin_Ioi' {a b : \u03b1} (H : a < b) : Ioo a b \u2208 \ud835\udcdd[>] a", "start": [433, 1], "end": [434, 37], "kind": "commanddeclaration"}, {"full_name": "Covby.nhdsWithin_Ioi", "code": "theorem Covby.nhdsWithin_Ioi {a b : \u03b1} (h : a \u22d6 b) : \ud835\udcdd[>] a = \u22a5", "start": [436, 1], "end": [437, 65], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Ioi", "code": "theorem Ioc_mem_nhdsWithin_Ioi {a b c : \u03b1} (H : b \u2208 Ico a c) : Ioc a c \u2208 \ud835\udcdd[>] b", "start": [439, 1], "end": [440, 65], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Ioi'", "code": "theorem Ioc_mem_nhdsWithin_Ioi' {a b : \u03b1} (H : a < b) : Ioc a b \u2208 \ud835\udcdd[>] a", "start": [444, 1], "end": [445, 37], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Ioi", "code": "theorem Ico_mem_nhdsWithin_Ioi {a b c : \u03b1} (H : b \u2208 Ico a c) : Ico a c \u2208 \ud835\udcdd[>] b", "start": [447, 1], "end": [448, 65], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Ioi'", "code": "theorem Ico_mem_nhdsWithin_Ioi' {a b : \u03b1} (H : a < b) : Ico a b \u2208 \ud835\udcdd[>] a", "start": [452, 1], "end": [453, 37], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Ioi", "code": "theorem Icc_mem_nhdsWithin_Ioi {a b c : \u03b1} (H : b \u2208 Ico a c) : Icc a c \u2208 \ud835\udcdd[>] b", "start": [455, 1], "end": [456, 65], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Ioi'", "code": "theorem Icc_mem_nhdsWithin_Ioi' {a b : \u03b1} (H : a < b) : Icc a b \u2208 \ud835\udcdd[>] a", "start": [460, 1], "end": [461, 37], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioc_eq_nhdsWithin_Ioi", "code": "@[simp]\ntheorem nhdsWithin_Ioc_eq_nhdsWithin_Ioi {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ioc a b] a = \ud835\udcdd[>] a", "start": [463, 1], "end": [465, 67], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioo_eq_nhdsWithin_Ioi", "code": "@[simp]\ntheorem nhdsWithin_Ioo_eq_nhdsWithin_Ioi {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ioo a b] a = \ud835\udcdd[>] a", "start": [468, 1], "end": [470, 67], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ioc_iff_Ioi", "code": "@[simp]\ntheorem continuousWithinAt_Ioc_iff_Ioi [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Ioc a b) a \u2194 ContinuousWithinAt f (Ioi a) a", "start": [473, 1], "end": [476, 69], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ioo_iff_Ioi", "code": "@[simp]\ntheorem continuousWithinAt_Ioo_iff_Ioi [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Ioo a b) a \u2194 ContinuousWithinAt f (Ioi a) a", "start": [479, 1], "end": [482, 69], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Iio", "code": "theorem Ioo_mem_nhdsWithin_Iio {a b c : \u03b1} (H : b \u2208 Ioc a c) : Ioo a c \u2208 \ud835\udcdd[<] b", "start": [489, 1], "end": [491, 83], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Iio'", "code": "theorem Ioo_mem_nhdsWithin_Iio' {a b : \u03b1} (H : a < b) : Ioo a b \u2208 \ud835\udcdd[<] b", "start": [495, 1], "end": [496, 37], "kind": "commanddeclaration"}, {"full_name": "Covby.nhdsWithin_Iio", "code": "theorem Covby.nhdsWithin_Iio {a b : \u03b1} (h : a \u22d6 b) : \ud835\udcdd[<] b = \u22a5", "start": [498, 1], "end": [499, 65], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Iio", "code": "theorem Ico_mem_nhdsWithin_Iio {a b c : \u03b1} (H : b \u2208 Ioc a c) : Ico a c \u2208 \ud835\udcdd[<] b", "start": [501, 1], "end": [502, 65], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Iio'", "code": "theorem Ico_mem_nhdsWithin_Iio' {a b : \u03b1} (H : a < b) : Ico a b \u2208 \ud835\udcdd[<] b", "start": [506, 1], "end": [507, 37], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Iio", "code": "theorem Ioc_mem_nhdsWithin_Iio {a b c : \u03b1} (H : b \u2208 Ioc a c) : Ioc a c \u2208 \ud835\udcdd[<] b", "start": [509, 1], "end": [510, 65], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Iio'", "code": "theorem Ioc_mem_nhdsWithin_Iio' {a b : \u03b1} (H : a < b) : Ioc a b \u2208 \ud835\udcdd[<] b", "start": [514, 1], "end": [515, 37], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Iio", "code": "theorem Icc_mem_nhdsWithin_Iio {a b c : \u03b1} (H : b \u2208 Ioc a c) : Icc a c \u2208 \ud835\udcdd[<] b", "start": [517, 1], "end": [518, 65], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Iio'", "code": "theorem Icc_mem_nhdsWithin_Iio' {a b : \u03b1} (H : a < b) : Icc a b \u2208 \ud835\udcdd[<] b", "start": [521, 1], "end": [522, 37], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ico_eq_nhdsWithin_Iio", "code": "@[simp]\ntheorem nhdsWithin_Ico_eq_nhdsWithin_Iio {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ico a b] b = \ud835\udcdd[<] b", "start": [524, 1], "end": [526, 70], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioo_eq_nhdsWithin_Iio", "code": "@[simp]\ntheorem nhdsWithin_Ioo_eq_nhdsWithin_Iio {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ioo a b] b = \ud835\udcdd[<] b", "start": [529, 1], "end": [531, 70], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ico_iff_Iio", "code": "@[simp]\ntheorem continuousWithinAt_Ico_iff_Iio {a b : \u03b1} {f : \u03b1 \u2192 \u03b3} (h : a < b) :\n    ContinuousWithinAt f (Ico a b) b \u2194 ContinuousWithinAt f (Iio b) b", "start": [534, 1], "end": [537, 69], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ioo_iff_Iio", "code": "@[simp]\ntheorem continuousWithinAt_Ioo_iff_Iio {a b : \u03b1} {f : \u03b1 \u2192 \u03b3} (h : a < b) :\n    ContinuousWithinAt f (Ioo a b) b \u2194 ContinuousWithinAt f (Iio b) b", "start": [540, 1], "end": [543, 69], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Ici", "code": "theorem Ioo_mem_nhdsWithin_Ici {a b c : \u03b1} (H : b \u2208 Ioo a c) : Ioo a c \u2208 \ud835\udcdd[\u2265] b", "start": [550, 1], "end": [551, 61], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Ici", "code": "theorem Ioc_mem_nhdsWithin_Ici {a b c : \u03b1} (H : b \u2208 Ioo a c) : Ioc a c \u2208 \ud835\udcdd[\u2265] b", "start": [554, 1], "end": [555, 65], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Ici", "code": "theorem Ico_mem_nhdsWithin_Ici {a b c : \u03b1} (H : b \u2208 Ico a c) : Ico a c \u2208 \ud835\udcdd[\u2265] b", "start": [558, 1], "end": [560, 96], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Ici'", "code": "theorem Ico_mem_nhdsWithin_Ici' {a b : \u03b1} (H : a < b) : Ico a b \u2208 \ud835\udcdd[\u2265] a", "start": [563, 1], "end": [564, 37], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Ici", "code": "theorem Icc_mem_nhdsWithin_Ici {a b c : \u03b1} (H : b \u2208 Ico a c) : Icc a c \u2208 \ud835\udcdd[\u2265] b", "start": [566, 1], "end": [567, 65], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Ici'", "code": "theorem Icc_mem_nhdsWithin_Ici' {a b : \u03b1} (H : a < b) : Icc a b \u2208 \ud835\udcdd[\u2265] a", "start": [570, 1], "end": [571, 37], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Icc_eq_nhdsWithin_Ici", "code": "@[simp]\ntheorem nhdsWithin_Icc_eq_nhdsWithin_Ici {a b : \u03b1} (h : a < b) : \ud835\udcdd[Icc a b] a = \ud835\udcdd[\u2265] a", "start": [573, 1], "end": [575, 67], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ico_eq_nhdsWithin_Ici", "code": "@[simp]\ntheorem nhdsWithin_Ico_eq_nhdsWithin_Ici {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ico a b] a = \ud835\udcdd[\u2265] a", "start": [578, 1], "end": [580, 67], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Icc_iff_Ici", "code": "@[simp]\ntheorem continuousWithinAt_Icc_iff_Ici [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Icc a b) a \u2194 ContinuousWithinAt f (Ici a) a", "start": [583, 1], "end": [586, 69], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ico_iff_Ici", "code": "@[simp]\ntheorem continuousWithinAt_Ico_iff_Ici [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Ico a b) a \u2194 ContinuousWithinAt f (Ici a) a", "start": [589, 1], "end": [592, 69], "kind": "commanddeclaration"}, {"full_name": "Ioo_mem_nhdsWithin_Iic", "code": "theorem Ioo_mem_nhdsWithin_Iic {a b c : \u03b1} (H : b \u2208 Ioo a c) : Ioo a c \u2208 \ud835\udcdd[\u2264] b", "start": [600, 1], "end": [601, 61], "kind": "commanddeclaration"}, {"full_name": "Ico_mem_nhdsWithin_Iic", "code": "theorem Ico_mem_nhdsWithin_Iic {a b c : \u03b1} (H : b \u2208 Ioo a c) : Ico a c \u2208 \ud835\udcdd[\u2264] b", "start": [604, 1], "end": [605, 65], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Iic", "code": "theorem Ioc_mem_nhdsWithin_Iic {a b c : \u03b1} (H : b \u2208 Ioc a c) : Ioc a c \u2208 \ud835\udcdd[\u2264] b", "start": [608, 1], "end": [610, 83], "kind": "commanddeclaration"}, {"full_name": "Ioc_mem_nhdsWithin_Iic'", "code": "theorem Ioc_mem_nhdsWithin_Iic' {a b : \u03b1} (H : a < b) : Ioc a b \u2208 \ud835\udcdd[\u2264] b", "start": [613, 1], "end": [614, 37], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Iic", "code": "theorem Icc_mem_nhdsWithin_Iic {a b c : \u03b1} (H : b \u2208 Ioc a c) : Icc a c \u2208 \ud835\udcdd[\u2264] b", "start": [616, 1], "end": [617, 65], "kind": "commanddeclaration"}, {"full_name": "Icc_mem_nhdsWithin_Iic'", "code": "theorem Icc_mem_nhdsWithin_Iic' {a b : \u03b1} (H : a < b) : Icc a b \u2208 \ud835\udcdd[\u2264] b", "start": [620, 1], "end": [621, 37], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Icc_eq_nhdsWithin_Iic", "code": "@[simp]\ntheorem nhdsWithin_Icc_eq_nhdsWithin_Iic {a b : \u03b1} (h : a < b) : \ud835\udcdd[Icc a b] b = \ud835\udcdd[\u2264] b", "start": [623, 1], "end": [625, 70], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioc_eq_nhdsWithin_Iic", "code": "@[simp]\ntheorem nhdsWithin_Ioc_eq_nhdsWithin_Iic {a b : \u03b1} (h : a < b) : \ud835\udcdd[Ioc a b] b = \ud835\udcdd[\u2264] b", "start": [628, 1], "end": [630, 70], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Icc_iff_Iic", "code": "@[simp]\ntheorem continuousWithinAt_Icc_iff_Iic [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Icc a b) b \u2194 ContinuousWithinAt f (Iic b) b", "start": [633, 1], "end": [636, 69], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_Ioc_iff_Iic", "code": "@[simp]\ntheorem continuousWithinAt_Ioc_iff_Iic [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\n    ContinuousWithinAt f (Ioc a b) b \u2194 ContinuousWithinAt f (Iic b) b", "start": [639, 1], "end": [642, 69], "kind": "commanddeclaration"}, {"full_name": "lt_subset_interior_le", "code": "theorem lt_subset_interior_le (hf : Continuous f) (hg : Continuous g) :\n    { b | f b < g b } \u2286 interior { b | f b \u2264 g b }", "start": [655, 1], "end": [657, 58], "kind": "commanddeclaration"}, {"full_name": "frontier_le_subset_eq", "code": "theorem frontier_le_subset_eq (hf : Continuous f) (hg : Continuous g) :\n    frontier { b | f b \u2264 g b } \u2286 { b | f b = g b }", "start": [660, 1], "end": [665, 52], "kind": "commanddeclaration"}, {"full_name": "frontier_Iic_subset", "code": "theorem frontier_Iic_subset (a : \u03b1) : frontier (Iic a) \u2286 {a}", "start": [668, 1], "end": [669, 62], "kind": "commanddeclaration"}, {"full_name": "frontier_Ici_subset", "code": "theorem frontier_Ici_subset (a : \u03b1) : frontier (Ici a) \u2286 {a}", "start": [672, 1], "end": [673, 35], "kind": "commanddeclaration"}, {"full_name": "frontier_lt_subset_eq", "code": "theorem frontier_lt_subset_eq (hf : Continuous f) (hg : Continuous g) :\n    frontier { b | f b < g b } \u2286 { b | f b = g b }", "start": [676, 1], "end": [678, 98], "kind": "commanddeclaration"}, {"full_name": "continuous_if_le", "code": "theorem continuous_if_le [TopologicalSpace \u03b3] [\u2200 x, Decidable (f x \u2264 g x)] {f' g' : \u03b2 \u2192 \u03b3}\n    (hf : Continuous f) (hg : Continuous g) (hf' : ContinuousOn f' { x | f x \u2264 g x })\n    (hg' : ContinuousOn g' { x | g x \u2264 f x }) (hfg : \u2200 x, f x = g x \u2192 f' x = g' x) :\n    Continuous fun x => if f x \u2264 g x then f' x else g' x", "start": [681, 1], "end": [688, 37], "kind": "commanddeclaration"}, {"full_name": "Continuous.if_le", "code": "theorem Continuous.if_le [TopologicalSpace \u03b3] [\u2200 x, Decidable (f x \u2264 g x)] {f' g' : \u03b2 \u2192 \u03b3}\n    (hf' : Continuous f') (hg' : Continuous g') (hf : Continuous f) (hg : Continuous g)\n    (hfg : \u2200 x, f x = g x \u2192 f' x = g' x) : Continuous fun x => if f x \u2264 g x then f' x else g' x", "start": [691, 1], "end": [694, 63], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.eventually_lt", "code": "theorem Filter.Tendsto.eventually_lt {l : Filter \u03b3} {f g : \u03b3 \u2192 \u03b1} {y z : \u03b1} (hf : Tendsto f l (\ud835\udcdd y))\n    (hg : Tendsto g l (\ud835\udcdd z)) (hyz : y < z) : \u2200\u1da0 x in l, f x < g x", "start": [697, 1], "end": [701, 16], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.eventually_lt", "code": "nonrec theorem ContinuousAt.eventually_lt {x\u2080 : \u03b2} (hf : ContinuousAt f x\u2080) (hg : ContinuousAt g x\u2080)\n    (hfg : f x\u2080 < g x\u2080) : \u2200\u1da0 x in \ud835\udcdd x\u2080, f x < g x", "start": [704, 1], "end": [706, 26], "kind": "commanddeclaration"}, {"full_name": "Continuous.min", "code": "@[continuity]\nprotected theorem Continuous.min (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun b => min (f b) (g b)", "start": [709, 1], "end": [713, 38], "kind": "commanddeclaration"}, {"full_name": "Continuous.max", "code": "@[continuity]\nprotected theorem Continuous.max (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun b => max (f b) (g b)", "start": [716, 1], "end": [719, 34], "kind": "commanddeclaration"}, {"full_name": "continuous_min", "code": "theorem continuous_min : Continuous fun p : \u03b1 \u00d7 \u03b1 => min p.1 p.2", "start": [724, 1], "end": [725, 36], "kind": "commanddeclaration"}, {"full_name": "continuous_max", "code": "theorem continuous_max : Continuous fun p : \u03b1 \u00d7 \u03b1 => max p.1 p.2", "start": [728, 1], "end": [729, 36], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.max", "code": "protected theorem Filter.Tendsto.max {b : Filter \u03b2} {a\u2081 a\u2082 : \u03b1} (hf : Tendsto f b (\ud835\udcdd a\u2081))\n    (hg : Tendsto g b (\ud835\udcdd a\u2082)) : Tendsto (fun b => max (f b) (g b)) b (\ud835\udcdd (max a\u2081 a\u2082))", "start": [732, 1], "end": [734, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.min", "code": "protected theorem Filter.Tendsto.min {b : Filter \u03b2} {a\u2081 a\u2082 : \u03b1} (hf : Tendsto f b (\ud835\udcdd a\u2081))\n    (hg : Tendsto g b (\ud835\udcdd a\u2082)) : Tendsto (fun b => min (f b) (g b)) b (\ud835\udcdd (min a\u2081 a\u2082))", "start": [737, 1], "end": [739, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.max_right", "code": "protected theorem Filter.Tendsto.max_right {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => max a (f i)) l (\ud835\udcdd a)", "start": [742, 1], "end": [745, 7], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.max_left", "code": "protected theorem Filter.Tendsto.max_left {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => max (f i) a) l (\ud835\udcdd a)", "start": [748, 1], "end": [751, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_max_right", "code": "theorem Filter.tendsto_nhds_max_right {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd[>] a)) :\n    Tendsto (fun i => max a (f i)) l (\ud835\udcdd[>] a)", "start": [754, 1], "end": [757, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_max_left", "code": "theorem Filter.tendsto_nhds_max_left {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd[>] a)) :\n    Tendsto (fun i => max (f i) a) l (\ud835\udcdd[>] a)", "start": [760, 1], "end": [763, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.min_right", "code": "theorem Filter.Tendsto.min_right {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => min a (f i)) l (\ud835\udcdd a)", "start": [766, 1], "end": [768, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.min_left", "code": "theorem Filter.Tendsto.min_left {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun i => min (f i) a) l (\ud835\udcdd a)", "start": [771, 1], "end": [773, 39], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_min_right", "code": "theorem Filter.tendsto_nhds_min_right {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd[<] a)) :\n    Tendsto (fun i => min a (f i)) l (\ud835\udcdd[<] a)", "start": [776, 1], "end": [778, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_nhds_min_left", "code": "theorem Filter.tendsto_nhds_min_left {l : Filter \u03b2} {a : \u03b1} (h : Tendsto f l (\ud835\udcdd[<] a)) :\n    Tendsto (fun i => min (f i) a) l (\ud835\udcdd[<] a)", "start": [781, 1], "end": [783, 44], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_lt", "code": "protected theorem Dense.exists_lt [NoMinOrder \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    \u2203 y \u2208 s, y < x", "start": [786, 1], "end": [788, 46], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_gt", "code": "protected theorem Dense.exists_gt [NoMaxOrder \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    \u2203 y \u2208 s, x < y", "start": [791, 1], "end": [793, 27], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_le", "code": "protected theorem Dense.exists_le [NoMinOrder \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    \u2203 y \u2208 s, y \u2264 x", "start": [796, 1], "end": [798, 48], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_ge", "code": "protected theorem Dense.exists_ge [NoMaxOrder \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    \u2203 y \u2208 s, x \u2264 y", "start": [801, 1], "end": [803, 27], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_le'", "code": "theorem Dense.exists_le' {s : Set \u03b1} (hs : Dense s) (hbot : \u2200 x, IsBot x \u2192 x \u2208 s) (x : \u03b1) :\n    \u2203 y \u2208 s, y \u2264 x", "start": [806, 1], "end": [812, 26], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_ge'", "code": "theorem Dense.exists_ge' {s : Set \u03b1} (hs : Dense s) (htop : \u2200 x, IsTop x \u2192 x \u2208 s) (x : \u03b1) :\n    \u2203 y \u2208 s, x \u2264 y", "start": [815, 1], "end": [817, 33], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_between", "code": "theorem Dense.exists_between [DenselyOrdered \u03b1] {s : Set \u03b1} (hs : Dense s) {x y : \u03b1} (h : x < y) :\n    \u2203 z \u2208 s, z \u2208 Ioo x y", "start": [820, 1], "end": [822, 51], "kind": "commanddeclaration"}, {"full_name": "Dense.Ioi_eq_biUnion", "code": "theorem Dense.Ioi_eq_biUnion [DenselyOrdered \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    Ioi x = \u22c3 y \u2208 s \u2229 Ioi x, Ioi y", "start": [825, 1], "end": [829, 43], "kind": "commanddeclaration"}, {"full_name": "Dense.Iio_eq_biUnion", "code": "theorem Dense.Iio_eq_biUnion [DenselyOrdered \u03b1] {s : Set \u03b1} (hs : Dense s) (x : \u03b1) :\n    Iio x = \u22c3 y \u2208 s \u2229 Iio x, Iio y", "start": [831, 1], "end": [833, 39], "kind": "commanddeclaration"}, {"full_name": "Pi.orderClosedTopology'", "code": "instance Pi.orderClosedTopology' [Preorder \u03b2] [TopologicalSpace \u03b2] [OrderClosedTopology \u03b2] :\n    OrderClosedTopology (\u03b1 \u2192 \u03b2) :=\n  inferInstance", "start": [850, 1], "end": [852, 16], "kind": "commanddeclaration"}, {"full_name": "OrderTopology", "code": "class OrderTopology (\u03b1 : Type*) [t : TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  topology_eq_generate_intervals : t = generateFrom { s | \u2203 a, s = Ioi a \u2228 s = Iio a }", "start": [856, 1], "end": [862, 87], "kind": "commanddeclaration"}, {"full_name": "Preorder.topology", "code": "def Preorder.topology (\u03b1 : Type*) [Preorder \u03b1] : TopologicalSpace \u03b1 :=\n  generateFrom { s : Set \u03b1 | \u2203 a : \u03b1, s = { b : \u03b1 | a < b } \u2228 s = { b : \u03b1 | b < a } }", "start": [865, 1], "end": [870, 86], "kind": "commanddeclaration"}, {"full_name": "isOpen_iff_generate_intervals", "code": "theorem isOpen_iff_generate_intervals {s : Set \u03b1} :\n    IsOpen s \u2194 GenerateOpen { s | \u2203 a, s = Ioi a \u2228 s = Iio a } s", "start": [884, 1], "end": [886, 45], "kind": "commanddeclaration"}, {"full_name": "isOpen_lt'", "code": "theorem isOpen_lt' (a : \u03b1) : IsOpen { b : \u03b1 | a < b }", "start": [889, 1], "end": [890, 60], "kind": "commanddeclaration"}, {"full_name": "isOpen_gt'", "code": "theorem isOpen_gt' (a : \u03b1) : IsOpen { b : \u03b1 | b < a }", "start": [893, 1], "end": [894, 60], "kind": "commanddeclaration"}, {"full_name": "lt_mem_nhds", "code": "theorem lt_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd b, a < x", "start": [897, 1], "end": [898, 28], "kind": "commanddeclaration"}, {"full_name": "le_mem_nhds", "code": "theorem le_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd b, a \u2264 x", "start": [901, 1], "end": [902, 41], "kind": "commanddeclaration"}, {"full_name": "gt_mem_nhds", "code": "theorem gt_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x < b", "start": [905, 1], "end": [906, 28], "kind": "commanddeclaration"}, {"full_name": "ge_mem_nhds", "code": "theorem ge_mem_nhds {a b : \u03b1} (h : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x \u2264 b", "start": [909, 1], "end": [910, 41], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_order", "code": "theorem nhds_eq_order (a : \u03b1) : \ud835\udcdd a = (\u2a05 b \u2208 Iio a, \ud835\udcdf (Ioi b)) \u2293 \u2a05 b \u2208 Ioi a, \ud835\udcdf (Iio b)", "start": [913, 1], "end": [916, 78], "kind": "commanddeclaration"}, {"full_name": "tendsto_order", "code": "theorem tendsto_order {f : \u03b2 \u2192 \u03b1} {a : \u03b1} {x : Filter \u03b2} :\n    Tendsto f x (\ud835\udcdd a) \u2194 (\u2200 a' < a, \u2200\u1da0 b in x, a' < f b) \u2227 \u2200 a' > a, \u2200\u1da0 b in x, f b < a'", "start": [919, 1], "end": [921, 81], "kind": "commanddeclaration"}, {"full_name": "tendstoIccClassNhds", "code": "instance tendstoIccClassNhds (a : \u03b1) : TendstoIxxClass Icc (\ud835\udcdd a) (\ud835\udcdd a) := by\n  simp only [nhds_eq_order, iInf_subtype']\n  refine\n    ((hasBasis_iInf_principal_finite _).inf (hasBasis_iInf_principal_finite _)).tendstoIxxClass\n      fun s _ => ?_\n  refine' ((ordConnected_biInter _).inter (ordConnected_biInter _)).out <;> intro _ _\n  exacts [ordConnected_Ioi, ordConnected_Iio]", "start": [924, 1], "end": [930, 46], "kind": "commanddeclaration"}, {"full_name": "tendstoIcoClassNhds", "code": "instance tendstoIcoClassNhds (a : \u03b1) : TendstoIxxClass Ico (\ud835\udcdd a) (\ud835\udcdd a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ico_subset_Icc_self", "start": [933, 1], "end": [934, 59], "kind": "commanddeclaration"}, {"full_name": "tendstoIocClassNhds", "code": "instance tendstoIocClassNhds (a : \u03b1) : TendstoIxxClass Ioc (\ud835\udcdd a) (\ud835\udcdd a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioc_subset_Icc_self", "start": [937, 1], "end": [938, 59], "kind": "commanddeclaration"}, {"full_name": "tendstoIooClassNhds", "code": "instance tendstoIooClassNhds (a : \u03b1) : TendstoIxxClass Ioo (\ud835\udcdd a) (\ud835\udcdd a) :=\n  tendstoIxxClass_of_subset fun _ _ => Ioo_subset_Icc_self", "start": [941, 1], "end": [942, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_tendsto_of_tendsto_of_le_of_le'", "code": "theorem tendsto_of_tendsto_of_tendsto_of_le_of_le' {f g h : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1}\n    (hg : Tendsto g b (\ud835\udcdd a)) (hh : Tendsto h b (\ud835\udcdd a)) (hgf : \u2200\u1da0 b in b, g b \u2264 f b)\n    (hfh : \u2200\u1da0 b in b, f b \u2264 h b) : Tendsto f b (\ud835\udcdd a)", "start": [945, 1], "end": [950, 42], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_tendsto_of_tendsto_of_le_of_le", "code": "theorem tendsto_of_tendsto_of_tendsto_of_le_of_le {f g h : \u03b2 \u2192 \u03b1} {b : Filter \u03b2} {a : \u03b1}\n    (hg : Tendsto g b (\ud835\udcdd a)) (hh : Tendsto h b (\ud835\udcdd a)) (hgf : g \u2264 f) (hfh : f \u2264 h) :\n    Tendsto f b (\ud835\udcdd a)", "start": [953, 1], "end": [959, 31], "kind": "commanddeclaration"}, {"full_name": "nhds_order_unbounded", "code": "theorem nhds_order_unbounded {a : \u03b1} (hu : \u2203 u, a < u) (hl : \u2203 l, l < a) :\n    \ud835\udcdd a = \u2a05 (l) (_ : l < a) (u) (_ : a < u), \ud835\udcdf (Ioo l u)", "start": [962, 1], "end": [964, 96], "kind": "commanddeclaration"}, {"full_name": "tendsto_order_unbounded", "code": "theorem tendsto_order_unbounded {f : \u03b2 \u2192 \u03b1} {a : \u03b1} {x : Filter \u03b2} (hu : \u2203 u, a < u)\n    (hl : \u2203 l, l < a) (h : \u2200 l u, l < a \u2192 a < u \u2192 \u2200\u1da0 b in x, l < f b \u2227 f b < u) :\n    Tendsto f x (\ud835\udcdd a)", "start": [967, 1], "end": [971, 31], "kind": "commanddeclaration"}, {"full_name": "tendstoIxxNhdsWithin", "code": "instance tendstoIxxNhdsWithin {\u03b1 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1] (a : \u03b1) {s t : Set \u03b1}\n    {Ixx} [TendstoIxxClass Ixx (\ud835\udcdd a) (\ud835\udcdd a)] [TendstoIxxClass Ixx (\ud835\udcdf s) (\ud835\udcdf t)] :\n    TendstoIxxClass Ixx (\ud835\udcdd[s] a) (\ud835\udcdd[t] a) :=\n  Filter.tendstoIxxClass_inf", "start": [976, 1], "end": [979, 29], "kind": "commanddeclaration"}, {"full_name": "tendstoIccClassNhdsPi", "code": "instance tendstoIccClassNhdsPi {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)]\n    [\u2200 i, TopologicalSpace (\u03b1 i)] [\u2200 i, OrderTopology (\u03b1 i)] (f : \u2200 i, \u03b1 i) :\n    TendstoIxxClass Icc (\ud835\udcdd f) (\ud835\udcdd f) := by\n  constructor\n  conv in (\ud835\udcdd f).smallSets => rw [nhds_pi, Filter.pi]\n  simp only [smallSets_iInf, smallSets_comap, tendsto_iInf, tendsto_lift', (\u00b7 \u2218 \u00b7),\n    mem_powerset_iff]\n  intro i s hs\n  have : Tendsto (fun g : \u2200 i, \u03b1 i => g i) (\ud835\udcdd f) (\ud835\udcdd (f i)) := (continuous_apply i).tendsto f\n  refine' (tendsto_lift'.1 ((this.comp tendsto_fst).Icc (this.comp tendsto_snd)) s hs).mono _\n  exact fun p hp g hg => hp \u27e8hg.1 _, hg.2 _\u27e9", "start": [982, 1], "end": [992, 45], "kind": "commanddeclaration"}, {"full_name": "induced_topology_le_preorder", "code": "theorem induced_topology_le_preorder [Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b2]\n    [OrderTopology \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : \u2200 {x y}, f x < f y \u2194 x < y) :\n    induced f \u2039TopologicalSpace \u03b2\u203a \u2264 Preorder.topology \u03b1", "start": [996, 1], "end": [1003, 48], "kind": "commanddeclaration"}, {"full_name": "induced_topology_eq_preorder", "code": "theorem induced_topology_eq_preorder [Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b2]\n    [OrderTopology \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : \u2200 {x y}, f x < f y \u2194 x < y)\n    (H\u2081 : \u2200 {a b x}, b < f a \u2192 \u00ac(b < f x) \u2192 \u2203 y, y < a \u2227 b \u2264 f y)\n    (H\u2082 : \u2200 {a b x}, f a < b \u2192 \u00ac(f x < b) \u2192 \u2203 y, a < y \u2227 f y \u2264 b) :\n    induced f \u2039TopologicalSpace \u03b2\u203a = Preorder.topology \u03b1", "start": [1006, 1], "end": [1025, 46], "kind": "commanddeclaration"}, {"full_name": "induced_orderTopology'", "code": "theorem induced_orderTopology' {\u03b1 : Type u} {\u03b2 : Type v} [Preorder \u03b1] [ta : TopologicalSpace \u03b2]\n    [Preorder \u03b2] [OrderTopology \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 {x y}, f x < f y \u2194 x < y)\n    (H\u2081 : \u2200 {a x}, x < f a \u2192 \u2203 b < a, x \u2264 f b) (H\u2082 : \u2200 {a x}, f a < x \u2192 \u2203 b > a, f b \u2264 x) :\n    @OrderTopology _ (induced f ta) _", "start": [1027, 1], "end": [1032, 72], "kind": "commanddeclaration"}, {"full_name": "induced_orderTopology", "code": "theorem induced_orderTopology {\u03b1 : Type u} {\u03b2 : Type v} [Preorder \u03b1] [ta : TopologicalSpace \u03b2]\n    [Preorder \u03b2] [OrderTopology \u03b2] (f : \u03b1 \u2192 \u03b2) (hf : \u2200 {x y}, f x < f y \u2194 x < y)\n    (H : \u2200 {x y}, x < y \u2192 \u2203 a, x < f a \u2227 f a < y) : @OrderTopology _ (induced f ta) _", "start": [1035, 1], "end": [1040, 65], "kind": "commanddeclaration"}, {"full_name": "StrictMono.induced_topology_eq_preorder", "code": "nonrec theorem StrictMono.induced_topology_eq_preorder {\u03b1 \u03b2 : Type*} [LinearOrder \u03b1]\n    [LinearOrder \u03b2] [t : TopologicalSpace \u03b2] [OrderTopology \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : StrictMono f) (hc : OrdConnected (range f)) : t.induced f = Preorder.topology \u03b1", "start": [1043, 1], "end": [1052, 41], "kind": "commanddeclaration"}, {"full_name": "StrictMono.embedding_of_ordConnected", "code": "theorem StrictMono.embedding_of_ordConnected {\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [LinearOrder \u03b2]\n    [TopologicalSpace \u03b1] [h : OrderTopology \u03b1] [TopologicalSpace \u03b2] [OrderTopology \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : StrictMono f) (hc : OrdConnected (range f)) : Embedding f", "start": [1054, 1], "end": [1059, 79], "kind": "commanddeclaration"}, {"full_name": "orderTopology_of_ordConnected", "code": "instance orderTopology_of_ordConnected {\u03b1 : Type u} [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] {t : Set \u03b1} [ht : OrdConnected t] : OrderTopology t :=\n  \u27e8(Subtype.strictMono_coe t).induced_topology_eq_preorder $ by\n    rwa [\u2190 @Subtype.range_val _ t] at ht\u27e9", "start": [1061, 1], "end": [1066, 42], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_eq''", "code": "theorem nhdsWithin_Ici_eq'' [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTopology \u03b1] (a : \u03b1) :\n    \ud835\udcdd[\u2265] a = (\u2a05 (u) (_ : a < u), \ud835\udcdf (Iio u)) \u2293 \ud835\udcdf (Ici a)", "start": [1069, 1], "end": [1073, 90], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_eq''", "code": "theorem nhdsWithin_Iic_eq'' [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTopology \u03b1] (a : \u03b1) :\n    \ud835\udcdd[\u2264] a = (\u2a05 l < a, \ud835\udcdf (Ioi l)) \u2293 \ud835\udcdf (Iic a)", "start": [1076, 1], "end": [1078, 33], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_eq'", "code": "theorem nhdsWithin_Ici_eq' [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTopology \u03b1] {a : \u03b1}\n    (ha : \u2203 u, a < u) : \ud835\udcdd[\u2265] a = \u2a05 (u) (_ : a < u), \ud835\udcdf (Ico a u)", "start": [1081, 1], "end": [1083, 78], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_eq'", "code": "theorem nhdsWithin_Iic_eq' [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTopology \u03b1] {a : \u03b1}\n    (ha : \u2203 l, l < a) : \ud835\udcdd[\u2264] a = \u2a05 l < a, \ud835\udcdf (Ioc l a)", "start": [1086, 1], "end": [1088, 78], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_basis'", "code": "theorem nhdsWithin_Ici_basis' [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] {a : \u03b1}\n    (ha : \u2203 u, a < u) : (\ud835\udcdd[\u2265] a).HasBasis (fun u => a < u) fun u => Ico a u", "start": [1091, 1], "end": [1097, 9], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_basis'", "code": "theorem nhdsWithin_Iic_basis' [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] {a : \u03b1}\n    (ha : \u2203 l, l < a) : (\ud835\udcdd[\u2264] a).HasBasis (fun l => l < a) fun l => Ioc l a", "start": [1100, 1], "end": [1103, 22], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_basis", "code": "theorem nhdsWithin_Ici_basis [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [NoMaxOrder \u03b1]\n    (a : \u03b1) : (\ud835\udcdd[\u2265] a).HasBasis (fun u => a < u) fun u => Ico a u", "start": [1106, 1], "end": [1108, 38], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iic_basis", "code": "theorem nhdsWithin_Iic_basis [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTopology \u03b1] [NoMinOrder \u03b1]\n    (a : \u03b1) : (\ud835\udcdd[\u2264] a).HasBasis (fun l => l < a) fun l => Ioc l a", "start": [1111, 1], "end": [1113, 38], "kind": "commanddeclaration"}, {"full_name": "nhds_top_order", "code": "theorem nhds_top_order [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderTop \u03b1] [OrderTopology \u03b1] :\n    \ud835\udcdd (\u22a4 : \u03b1) = \u2a05 (l) (h\u2082 : l < \u22a4), \ud835\udcdf (Ioi l)", "start": [1116, 1], "end": [1117, 81], "kind": "commanddeclaration"}, {"full_name": "nhds_bot_order", "code": "theorem nhds_bot_order [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderBot \u03b1] [OrderTopology \u03b1] :\n    \ud835\udcdd (\u22a5 : \u03b1) = \u2a05 (l) (h\u2082 : \u22a5 < l), \ud835\udcdf (Iio l)", "start": [1120, 1], "end": [1121, 81], "kind": "commanddeclaration"}, {"full_name": "nhds_top_basis", "code": "theorem nhds_top_basis [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTop \u03b1] [OrderTopology \u03b1]\n    [Nontrivial \u03b1] : (\ud835\udcdd \u22a4).HasBasis (fun a : \u03b1 => a < \u22a4) fun a : \u03b1 => Ioi a", "start": [1124, 1], "end": [1127, 82], "kind": "commanddeclaration"}, {"full_name": "nhds_bot_basis", "code": "theorem nhds_bot_basis [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderBot \u03b1] [OrderTopology \u03b1]\n    [Nontrivial \u03b1] : (\ud835\udcdd \u22a5).HasBasis (fun a : \u03b1 => \u22a5 < a) fun a : \u03b1 => Iio a", "start": [1130, 1], "end": [1132, 28], "kind": "commanddeclaration"}, {"full_name": "nhds_top_basis_Ici", "code": "theorem nhds_top_basis_Ici [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderTop \u03b1] [OrderTopology \u03b1]\n    [Nontrivial \u03b1] [DenselyOrdered \u03b1] : (\ud835\udcdd \u22a4).HasBasis (fun a : \u03b1 => a < \u22a4) Ici", "start": [1135, 1], "end": [1139, 45], "kind": "commanddeclaration"}, {"full_name": "nhds_bot_basis_Iic", "code": "theorem nhds_bot_basis_Iic [TopologicalSpace \u03b1] [LinearOrder \u03b1] [OrderBot \u03b1] [OrderTopology \u03b1]\n    [Nontrivial \u03b1] [DenselyOrdered \u03b1] : (\ud835\udcdd \u22a5).HasBasis (fun a : \u03b1 => \u22a5 < a) Iic", "start": [1142, 1], "end": [1144, 32], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_top_mono", "code": "theorem tendsto_nhds_top_mono [TopologicalSpace \u03b2] [Preorder \u03b2] [OrderTop \u03b2] [OrderTopology \u03b2]\n    {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : Tendsto f l (\ud835\udcdd \u22a4)) (hg : f \u2264\u1da0[l] g) : Tendsto g l (\ud835\udcdd \u22a4)", "start": [1147, 1], "end": [1151, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_bot_mono", "code": "theorem tendsto_nhds_bot_mono [TopologicalSpace \u03b2] [Preorder \u03b2] [OrderBot \u03b2] [OrderTopology \u03b2]\n    {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : Tendsto f l (\ud835\udcdd \u22a5)) (hg : g \u2264\u1da0[l] f) : Tendsto g l (\ud835\udcdd \u22a5)", "start": [1154, 1], "end": [1156, 41], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_top_mono'", "code": "theorem tendsto_nhds_top_mono' [TopologicalSpace \u03b2] [Preorder \u03b2] [OrderTop \u03b2] [OrderTopology \u03b2]\n    {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : Tendsto f l (\ud835\udcdd \u22a4)) (hg : f \u2264 g) : Tendsto g l (\ud835\udcdd \u22a4)", "start": [1159, 1], "end": [1161, 53], "kind": "commanddeclaration"}, {"full_name": "tendsto_nhds_bot_mono'", "code": "theorem tendsto_nhds_bot_mono' [TopologicalSpace \u03b2] [Preorder \u03b2] [OrderBot \u03b2] [OrderTopology \u03b2]\n    {l : Filter \u03b1} {f g : \u03b1 \u2192 \u03b2} (hf : Tendsto f l (\ud835\udcdd \u22a5)) (hg : g \u2264 f) : Tendsto g l (\ud835\udcdd \u22a5)", "start": [1164, 1], "end": [1166, 53], "kind": "commanddeclaration"}, {"full_name": "eventually_le_nhds", "code": "theorem eventually_le_nhds (hab : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x \u2264 b", "start": [1177, 1], "end": [1177, 82], "kind": "commanddeclaration"}, {"full_name": "eventually_lt_nhds", "code": "theorem eventually_lt_nhds (hab : a < b) : \u2200\u1da0 x in \ud835\udcdd a, x < b", "start": [1180, 1], "end": [1180, 82], "kind": "commanddeclaration"}, {"full_name": "eventually_ge_nhds", "code": "theorem eventually_ge_nhds (hab : b < a) : \u2200\u1da0 x in \ud835\udcdd a, b \u2264 x", "start": [1183, 1], "end": [1183, 82], "kind": "commanddeclaration"}, {"full_name": "eventually_gt_nhds", "code": "theorem eventually_gt_nhds (hab : b < a) : \u2200\u1da0 x in \ud835\udcdd a, b < x", "start": [1186, 1], "end": [1186, 82], "kind": "commanddeclaration"}, {"full_name": "order_separated", "code": "theorem order_separated {a\u2081 a\u2082 : \u03b1} (h : a\u2081 < a\u2082) :\n    \u2203 u v : Set \u03b1, IsOpen u \u2227 IsOpen v \u2227 a\u2081 \u2208 u \u2227 a\u2082 \u2208 v \u2227 \u2200 b\u2081 \u2208 u, \u2200 b\u2082 \u2208 v, b\u2081 < b\u2082", "start": [1195, 1], "end": [1198, 56], "kind": "commanddeclaration"}, {"full_name": "OrderTopology.to_orderClosedTopology", "code": "instance (priority := 100) OrderTopology.to_orderClosedTopology : OrderClosedTopology \u03b1 where\n  isClosed_le' := isOpen_compl_iff.1 <| isOpen_prod_iff.mpr fun a\u2081 a\u2082 (h : \u00aca\u2081 \u2264 a\u2082) =>\n    have h : a\u2082 < a\u2081 := lt_of_not_ge h\n    let \u27e8u, v, hu, hv, ha\u2081, ha\u2082, h\u27e9 := order_separated h\n    \u27e8v, u, hv, hu, ha\u2082, ha\u2081, fun \u27e8b\u2081, b\u2082\u27e9 \u27e8h\u2081, h\u2082\u27e9 => not_le_of_gt <| h b\u2082 h\u2082 b\u2081 h\u2081\u27e9", "start": [1202, 1], "end": [1206, 85], "kind": "commanddeclaration"}, {"full_name": "exists_Ioc_subset_of_mem_nhds", "code": "theorem exists_Ioc_subset_of_mem_nhds {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) (h : \u2203 l, l < a) :\n    \u2203 l < a, Ioc l a \u2286 s", "start": [1209, 1], "end": [1211, 63], "kind": "commanddeclaration"}, {"full_name": "exists_Ioc_subset_of_mem_nhds'", "code": "theorem exists_Ioc_subset_of_mem_nhds' {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) {l : \u03b1} (hl : l < a) :\n    \u2203 l' \u2208 Ico l a, Ioc l' a \u2286 s", "start": [1214, 1], "end": [1218, 58], "kind": "commanddeclaration"}, {"full_name": "exists_Ico_subset_of_mem_nhds'", "code": "theorem exists_Ico_subset_of_mem_nhds' {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) {u : \u03b1} (hu : a < u) :\n    \u2203 u' \u2208 Ioc a u, Ico a u' \u2286 s", "start": [1221, 1], "end": [1224, 86], "kind": "commanddeclaration"}, {"full_name": "exists_Ico_subset_of_mem_nhds", "code": "theorem exists_Ico_subset_of_mem_nhds {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) (h : \u2203 u, a < u) :\n    \u2203 u, a < u \u2227 Ico a u \u2286 s", "start": [1227, 1], "end": [1231, 20], "kind": "commanddeclaration"}, {"full_name": "exists_Icc_mem_subset_of_mem_nhdsWithin_Ici", "code": "theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Ici {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd[\u2265] a) :\n    \u2203 b, a \u2264 b \u2227 Icc a b \u2208 \ud835\udcdd[\u2265] a \u2227 Icc a b \u2286 s", "start": [1234, 1], "end": [1244, 49], "kind": "commanddeclaration"}, {"full_name": "exists_Icc_mem_subset_of_mem_nhdsWithin_Iic", "code": "theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd[\u2264] a) :\n    \u2203 b \u2264 a, Icc b a \u2208 \ud835\udcdd[\u2264] a \u2227 Icc b a \u2286 s", "start": [1247, 1], "end": [1250, 78], "kind": "commanddeclaration"}, {"full_name": "exists_Icc_mem_subset_of_mem_nhds", "code": "theorem exists_Icc_mem_subset_of_mem_nhds {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd a) :\n    \u2203 b c, a \u2208 Icc b c \u2227 Icc b c \u2208 \ud835\udcdd a \u2227 Icc b c \u2286 s", "start": [1253, 1], "end": [1261, 62], "kind": "commanddeclaration"}, {"full_name": "IsOpen.exists_Ioo_subset", "code": "theorem IsOpen.exists_Ioo_subset [Nontrivial \u03b1] {s : Set \u03b1} (hs : IsOpen s) (h : s.Nonempty) :\n    \u2203 a b, a < b \u2227 Ioo a b \u2286 s", "start": [1264, 1], "end": [1275, 51], "kind": "commanddeclaration"}, {"full_name": "dense_of_exists_between", "code": "theorem dense_of_exists_between [Nontrivial \u03b1] {s : Set \u03b1}\n    (h : \u2200 \u2983a b\u2984, a < b \u2192 \u2203 c \u2208 s, a < c \u2227 c < b) : Dense s", "start": [1278, 1], "end": [1283, 24], "kind": "commanddeclaration"}, {"full_name": "dense_iff_exists_between", "code": "theorem dense_iff_exists_between [DenselyOrdered \u03b1] [Nontrivial \u03b1] {s : Set \u03b1} :\n    Dense s \u2194 \u2200 a b, a < b \u2192 \u2203 c \u2208 s, a < c \u2227 c < b", "start": [1286, 1], "end": [1291, 67], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_iff_exists_Ioo_subset'", "code": "theorem mem_nhds_iff_exists_Ioo_subset' {a : \u03b1} {s : Set \u03b1} (hl : \u2203 l, l < a) (hu : \u2203 u, a < u) :\n    s \u2208 \ud835\udcdd a \u2194 \u2203 l u, a \u2208 Ioo l u \u2227 Ioo l u \u2286 s", "start": [1294, 1], "end": [1304, 53], "kind": "commanddeclaration"}, {"full_name": "mem_nhds_iff_exists_Ioo_subset", "code": "theorem mem_nhds_iff_exists_Ioo_subset [NoMaxOrder \u03b1] [NoMinOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd a \u2194 \u2203 l u, a \u2208 Ioo l u \u2227 Ioo l u \u2286 s", "start": [1307, 1], "end": [1311, 62], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_Ioo'", "code": "theorem nhds_basis_Ioo' {a : \u03b1} (hl : \u2203 l, l < a) (hu : \u2203 u, a < u) :\n    (\ud835\udcdd a).HasBasis (fun b : \u03b1 \u00d7 \u03b1 => b.1 < a \u2227 a < b.2) fun b => Ioo b.1 b.2", "start": [1314, 1], "end": [1316, 70], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_Ioo", "code": "theorem nhds_basis_Ioo [NoMaxOrder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun b : \u03b1 \u00d7 \u03b1 => b.1 < a \u2227 a < b.2) fun b => Ioo b.1 b.2", "start": [1319, 1], "end": [1321, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_Ioo_subset", "code": "theorem Filter.Eventually.exists_Ioo_subset [NoMaxOrder \u03b1] [NoMinOrder \u03b1] {a : \u03b1} {p : \u03b1 \u2192 Prop}\n    (hp : \u2200\u1da0 x in \ud835\udcdd a, p x) : \u2203 l u, a \u2208 Ioo l u \u2227 Ioo l u \u2286 { x | p x }", "start": [1324, 1], "end": [1326, 38], "kind": "commanddeclaration"}, {"full_name": "Dense.topology_eq_generateFrom", "code": "theorem Dense.topology_eq_generateFrom [DenselyOrdered \u03b1] {s : Set \u03b1} (hs : Dense s) :\n    \u2039TopologicalSpace \u03b1\u203a = .generateFrom (Ioi '' s \u222a Iio '' s)", "start": [1329, 1], "end": [1341, 99], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.SecondCountableTopology.of_separableSpace_orderTopology", "code": "theorem TopologicalSpace.SecondCountableTopology.of_separableSpace_orderTopology [DenselyOrdered \u03b1]\n    [SeparableSpace \u03b1] : SecondCountableTopology \u03b1", "start": [1345, 1], "end": [1352, 40], "kind": "commanddeclaration"}, {"full_name": "countable_setOf_covby_right", "code": "theorem countable_setOf_covby_right [SecondCountableTopology \u03b1] :\n    Set.Countable { x : \u03b1 | \u2203 y, x \u22d6 y }", "start": [1357, 1], "end": [1397, 99], "kind": "commanddeclaration"}, {"full_name": "countable_of_isolated_right'", "code": "@[deprecated countable_setOf_covby_right]\ntheorem countable_of_isolated_right' [SecondCountableTopology \u03b1] :\n    Set.Countable { x : \u03b1 | \u2203 y, x < y \u2227 Ioo x y = \u2205 }", "start": [1399, 1], "end": [1404, 68], "kind": "commanddeclaration"}, {"full_name": "countable_setOf_covby_left", "code": "theorem countable_setOf_covby_left [SecondCountableTopology \u03b1] :\n    Set.Countable { x : \u03b1 | \u2203 y, y \u22d6 x }", "start": [1407, 1], "end": [1412, 37], "kind": "commanddeclaration"}, {"full_name": "countable_of_isolated_left'", "code": "theorem countable_of_isolated_left' [SecondCountableTopology \u03b1] :\n    Set.Countable { x : \u03b1 | \u2203 y, y < x \u2227 Ioo y x = \u2205 }", "start": [1414, 1], "end": [1418, 67], "kind": "commanddeclaration"}, {"full_name": "Set.PairwiseDisjoint.countable_of_Ioo", "code": "theorem Set.PairwiseDisjoint.countable_of_Ioo [SecondCountableTopology \u03b1] {y : \u03b1 \u2192 \u03b1} {s : Set \u03b1}\n    (h : PairwiseDisjoint s fun x => Ioo x (y x)) (h' : \u2200 x \u2208 s, x < y x) : s.Countable", "start": [1421, 1], "end": [1430, 43], "kind": "commanddeclaration"}, {"full_name": "countable_image_lt_image_Ioi", "code": "theorem countable_image_lt_image_Ioi [LinearOrder \u03b2] (f : \u03b2 \u2192 \u03b1) [SecondCountableTopology \u03b1] :\n    Set.Countable {x | \u2203 z, f x < z \u2227 \u2200 y, x < y \u2192 z \u2264 f y}", "start": [1433, 1], "end": [1467, 64], "kind": "commanddeclaration"}, {"full_name": "countable_image_gt_image_Ioi", "code": "theorem countable_image_gt_image_Ioi [LinearOrder \u03b2] (f : \u03b2 \u2192 \u03b1) [SecondCountableTopology \u03b1] :\n    Set.Countable {x | \u2203 z, z < f x \u2227 \u2200 y, x < y \u2192 f y \u2264 z}", "start": [1469, 1], "end": [1473, 44], "kind": "commanddeclaration"}, {"full_name": "countable_image_lt_image_Iio", "code": "theorem countable_image_lt_image_Iio [LinearOrder \u03b2] (f : \u03b2 \u2192 \u03b1) [SecondCountableTopology \u03b1] :\n    Set.Countable {x | \u2203 z, f x < z \u2227 \u2200 y, y < x \u2192 z \u2264 f y}", "start": [1475, 1], "end": [1479, 44], "kind": "commanddeclaration"}, {"full_name": "countable_image_gt_image_Iio", "code": "theorem countable_image_gt_image_Iio [LinearOrder \u03b2] (f : \u03b2 \u2192 \u03b1) [SecondCountableTopology \u03b1] :\n    Set.Countable {x | \u2203 z, z < f x \u2227 \u2200 y, y < x \u2192 f y \u2264 z}", "start": [1481, 1], "end": [1485, 55], "kind": "commanddeclaration"}, {"full_name": "instIsCountablyGenerated_atTop", "code": "instance instIsCountablyGenerated_atTop [SecondCountableTopology \u03b1] :\n    IsCountablyGenerated (atTop : Filter \u03b1) := by\n  by_cases h : \u2203 (x : \u03b1), IsTop x\n  \u00b7 rcases h with \u27e8x, hx\u27e9\n    rw [atTop_eq_pure_of_isTop hx]\n    exact isCountablyGenerated_pure x\n  \u00b7 rcases exists_countable_basis \u03b1 with \u27e8b, b_count, b_ne, hb\u27e9\n    have : Countable b := by exact Iff.mpr countable_coe_iff b_count\n    have A : \u2200 (s : b), \u2203 (x : \u03b1), x \u2208 (s : Set \u03b1) := by\n      intro s\n      have : (s : Set \u03b1) \u2260 \u2205 := by\n        intro H\n        apply b_ne\n        convert s.2\n        exact H.symm\n      exact Iff.mp nmem_singleton_empty this\n    choose a ha using A\n    have : (atTop : Filter \u03b1) = (generate (Ici '' (range a))) := by\n      apply atTop_eq_generate_of_not_bddAbove\n      intro \u27e8x, hx\u27e9\n      simp only [IsTop, not_exists, not_forall, not_le] at h\n      rcases h x with \u27e8y, hy\u27e9\n      obtain \u27e8s, sb, -, hs\u27e9 : \u2203 s, s \u2208 b \u2227 y \u2208 s \u2227 s \u2286 Ioi x :=\n        hb.exists_subset_of_mem_open hy isOpen_Ioi\n      have I : a \u27e8s, sb\u27e9 \u2264 x := hx (mem_range_self _)\n      have J : x < a \u27e8s, sb\u27e9 := hs (ha \u27e8s, sb\u27e9)\n      exact lt_irrefl _ (I.trans_lt J)\n    rw [this]\n    exact \u27e8_, (countable_range _).image _, rfl\u27e9", "start": [1487, 1], "end": [1515, 48], "kind": "commanddeclaration"}, {"full_name": "instIsCountablyGenerated_atBot", "code": "instance instIsCountablyGenerated_atBot [SecondCountableTopology \u03b1] :\n    IsCountablyGenerated (atBot : Filter \u03b1) :=\n  @instIsCountablyGenerated_atTop \u03b1\u1d52\u1d48 _ _ _ _", "start": [1517, 1], "end": [1519, 46], "kind": "commanddeclaration"}, {"full_name": "pi_Iic_mem_nhds", "code": "theorem pi_Iic_mem_nhds (ha : \u2200 i, x i < a i) : Iic a \u2208 \ud835\udcdd x", "start": [1534, 1], "end": [1535, 82], "kind": "commanddeclaration"}, {"full_name": "pi_Iic_mem_nhds'", "code": "theorem pi_Iic_mem_nhds' (ha : \u2200 i, x' i < a' i) : Iic a' \u2208 \ud835\udcdd x'", "start": [1538, 1], "end": [1539, 21], "kind": "commanddeclaration"}, {"full_name": "pi_Ici_mem_nhds", "code": "theorem pi_Ici_mem_nhds (ha : \u2200 i, a i < x i) : Ici a \u2208 \ud835\udcdd x", "start": [1542, 1], "end": [1543, 82], "kind": "commanddeclaration"}, {"full_name": "pi_Ici_mem_nhds'", "code": "theorem pi_Ici_mem_nhds' (ha : \u2200 i, a' i < x' i) : Ici a' \u2208 \ud835\udcdd x'", "start": [1546, 1], "end": [1547, 21], "kind": "commanddeclaration"}, {"full_name": "pi_Icc_mem_nhds", "code": "theorem pi_Icc_mem_nhds (ha : \u2200 i, a i < x i) (hb : \u2200 i, x i < b i) : Icc a b \u2208 \ud835\udcdd x", "start": [1550, 1], "end": [1551, 86], "kind": "commanddeclaration"}, {"full_name": "pi_Icc_mem_nhds'", "code": "theorem pi_Icc_mem_nhds' (ha : \u2200 i, a' i < x' i) (hb : \u2200 i, x' i < b' i) : Icc a' b' \u2208 \ud835\udcdd x'", "start": [1554, 1], "end": [1555, 24], "kind": "commanddeclaration"}, {"full_name": "pi_Iio_mem_nhds", "code": "theorem pi_Iio_mem_nhds (ha : \u2200 i, x i < a i) : Iio a \u2208 \ud835\udcdd x", "start": [1560, 1], "end": [1562, 28], "kind": "commanddeclaration"}, {"full_name": "pi_Iio_mem_nhds'", "code": "theorem pi_Iio_mem_nhds' (ha : \u2200 i, x' i < a' i) : Iio a' \u2208 \ud835\udcdd x'", "start": [1565, 1], "end": [1566, 21], "kind": "commanddeclaration"}, {"full_name": "pi_Ioi_mem_nhds", "code": "theorem pi_Ioi_mem_nhds (ha : \u2200 i, a i < x i) : Ioi a \u2208 \ud835\udcdd x", "start": [1569, 1], "end": [1570, 57], "kind": "commanddeclaration"}, {"full_name": "pi_Ioi_mem_nhds'", "code": "theorem pi_Ioi_mem_nhds' (ha : \u2200 i, a' i < x' i) : Ioi a' \u2208 \ud835\udcdd x'", "start": [1573, 1], "end": [1574, 21], "kind": "commanddeclaration"}, {"full_name": "pi_Ioc_mem_nhds", "code": "theorem pi_Ioc_mem_nhds (ha : \u2200 i, a i < x i) (hb : \u2200 i, x i < b i) : Ioc a b \u2208 \ud835\udcdd x", "start": [1577, 1], "end": [1579, 35], "kind": "commanddeclaration"}, {"full_name": "pi_Ioc_mem_nhds'", "code": "theorem pi_Ioc_mem_nhds' (ha : \u2200 i, a' i < x' i) (hb : \u2200 i, x' i < b' i) : Ioc a' b' \u2208 \ud835\udcdd x'", "start": [1582, 1], "end": [1583, 24], "kind": "commanddeclaration"}, {"full_name": "pi_Ico_mem_nhds", "code": "theorem pi_Ico_mem_nhds (ha : \u2200 i, a i < x i) (hb : \u2200 i, x i < b i) : Ico a b \u2208 \ud835\udcdd x", "start": [1586, 1], "end": [1588, 35], "kind": "commanddeclaration"}, {"full_name": "pi_Ico_mem_nhds'", "code": "theorem pi_Ico_mem_nhds' (ha : \u2200 i, a' i < x' i) (hb : \u2200 i, x' i < b' i) : Ico a' b' \u2208 \ud835\udcdd x'", "start": [1591, 1], "end": [1592, 24], "kind": "commanddeclaration"}, {"full_name": "pi_Ioo_mem_nhds", "code": "theorem pi_Ioo_mem_nhds (ha : \u2200 i, a i < x i) (hb : \u2200 i, x i < b i) : Ioo a b \u2208 \ud835\udcdd x", "start": [1595, 1], "end": [1597, 35], "kind": "commanddeclaration"}, {"full_name": "pi_Ioo_mem_nhds'", "code": "theorem pi_Ioo_mem_nhds' (ha : \u2200 i, a' i < x' i) (hb : \u2200 i, x' i < b' i) : Ioo a' b' \u2208 \ud835\udcdd x'", "start": [1600, 1], "end": [1601, 24], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_atTop", "code": "theorem disjoint_nhds_atTop [NoMaxOrder \u03b1] (x : \u03b1) : Disjoint (\ud835\udcdd x) atTop", "start": [1606, 1], "end": [1609, 44], "kind": "commanddeclaration"}, {"full_name": "inf_nhds_atTop", "code": "@[simp]\ntheorem inf_nhds_atTop [NoMaxOrder \u03b1] (x : \u03b1) : \ud835\udcdd x \u2293 atTop = \u22a5", "start": [1612, 1], "end": [1614, 41], "kind": "commanddeclaration"}, {"full_name": "disjoint_nhds_atBot", "code": "theorem disjoint_nhds_atBot [NoMinOrder \u03b1] (x : \u03b1) : Disjoint (\ud835\udcdd x) atBot", "start": [1617, 1], "end": [1618, 35], "kind": "commanddeclaration"}, {"full_name": "inf_nhds_atBot", "code": "@[simp]\ntheorem inf_nhds_atBot [NoMinOrder \u03b1] (x : \u03b1) : \ud835\udcdd x \u2293 atBot = \u22a5", "start": [1621, 1], "end": [1623, 30], "kind": "commanddeclaration"}, {"full_name": "not_tendsto_nhds_of_tendsto_atTop", "code": "theorem not_tendsto_nhds_of_tendsto_atTop [NoMaxOrder \u03b1] {F : Filter \u03b2} [NeBot F] {f : \u03b2 \u2192 \u03b1}\n    (hf : Tendsto f F atTop) (x : \u03b1) : \u00acTendsto f F (\ud835\udcdd x)", "start": [1626, 1], "end": [1628, 46], "kind": "commanddeclaration"}, {"full_name": "not_tendsto_atTop_of_tendsto_nhds", "code": "theorem not_tendsto_atTop_of_tendsto_nhds [NoMaxOrder \u03b1] {F : Filter \u03b2} [NeBot F] {f : \u03b2 \u2192 \u03b1}\n    {x : \u03b1} (hf : Tendsto f F (\ud835\udcdd x)) : \u00acTendsto f F atTop", "start": [1631, 1], "end": [1633, 41], "kind": "commanddeclaration"}, {"full_name": "not_tendsto_nhds_of_tendsto_atBot", "code": "theorem not_tendsto_nhds_of_tendsto_atBot [NoMinOrder \u03b1] {F : Filter \u03b2} [NeBot F] {f : \u03b2 \u2192 \u03b1}\n    (hf : Tendsto f F atBot) (x : \u03b1) : \u00acTendsto f F (\ud835\udcdd x)", "start": [1636, 1], "end": [1638, 46], "kind": "commanddeclaration"}, {"full_name": "not_tendsto_atBot_of_tendsto_nhds", "code": "theorem not_tendsto_atBot_of_tendsto_nhds [NoMinOrder \u03b1] {F : Filter \u03b2} [NeBot F] {f : \u03b2 \u2192 \u03b1}\n    {x : \u03b1} (hf : Tendsto f F (\ud835\udcdd x)) : \u00acTendsto f F atBot", "start": [1641, 1], "end": [1643, 41], "kind": "commanddeclaration"}, {"full_name": "TFAE_mem_nhdsWithin_Ioi", "code": "theorem TFAE_mem_nhdsWithin_Ioi {a b : \u03b1} (hab : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[>] a,\n      s \u2208 \ud835\udcdd[Ioc a b] a,\n      s \u2208 \ud835\udcdd[Ioo a b] a,\n      \u2203 u \u2208 Ioc a b, Ioo a u \u2286 s,\n      \u2203 u \u2208 Ioi a, Ioo a u \u2286 s]", "start": [1654, 1], "end": [1684, 14], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset", "code": "theorem mem_nhdsWithin_Ioi_iff_exists_mem_Ioc_Ioo_subset {a u' : \u03b1} {s : Set \u03b1} (hu' : a < u') :\n    s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioc a u', Ioo a u \u2286 s", "start": [1687, 1], "end": [1689, 42], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ioi_iff_exists_Ioo_subset'", "code": "theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset' {a u' : \u03b1} {s : Set \u03b1} (hu' : a < u') :\n    s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioi a, Ioo a u \u2286 s", "start": [1692, 1], "end": [1696, 42], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_basis'", "code": "theorem nhdsWithin_Ioi_basis' {a : \u03b1} (h : \u2203 b, a < b) : (\ud835\udcdd[>] a).HasBasis (a < \u00b7) (Ioo a)", "start": [1699, 1], "end": [1701, 57], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_eq_bot_iff", "code": "theorem nhdsWithin_Ioi_eq_bot_iff {a : \u03b1} : \ud835\udcdd[>] a = \u22a5 \u2194 IsTop a \u2228 \u2203 b, a \u22d6 b", "start": [1703, 1], "end": [1708, 72], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ioi_iff_exists_Ioo_subset", "code": "theorem mem_nhdsWithin_Ioi_iff_exists_Ioo_subset [NoMaxOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioi a, Ioo a u \u2286 s", "start": [1710, 1], "end": [1715, 48], "kind": "commanddeclaration"}, {"full_name": "countable_setOf_isolated_right", "code": "theorem countable_setOf_isolated_right [SecondCountableTopology \u03b1] :\n    { x : \u03b1 | \ud835\udcdd[>] x = \u22a5 }.Countable", "start": [1718, 1], "end": [1723, 75], "kind": "commanddeclaration"}, {"full_name": "countable_setOf_isolated_left", "code": "theorem countable_setOf_isolated_left [SecondCountableTopology \u03b1] :\n    { x : \u03b1 | \ud835\udcdd[<] x = \u22a5 }.Countable", "start": [1725, 1], "end": [1729, 44], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ioi_iff_exists_Ioc_subset", "code": "theorem mem_nhdsWithin_Ioi_iff_exists_Ioc_subset [NoMaxOrder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1}\n    {s : Set \u03b1} : s \u2208 \ud835\udcdd[>] a \u2194 \u2203 u \u2208 Ioi a, Ioc a u \u2286 s", "start": [1731, 1], "end": [1741, 55], "kind": "commanddeclaration"}, {"full_name": "TFAE_mem_nhdsWithin_Iio", "code": "theorem TFAE_mem_nhdsWithin_Iio {a b : \u03b1} (h : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[<] b,s \u2208 \ud835\udcdd[Ico a b] b,s \u2208 \ud835\udcdd[Ioo a b] b,\u2203 l \u2208 Ico a b, Ioo l b \u2286 s,\u2203 l \u2208 Iio b, Ioo l b \u2286 s]", "start": [1745, 1], "end": [1759, 50], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset", "code": "theorem mem_nhdsWithin_Iio_iff_exists_mem_Ico_Ioo_subset {a l' : \u03b1} {s : Set \u03b1} (hl' : l' < a) :\n    s \u2208 \ud835\udcdd[<] a \u2194 \u2203 l \u2208 Ico l' a, Ioo l a \u2286 s", "start": [1762, 1], "end": [1764, 42], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iio_iff_exists_Ioo_subset'", "code": "theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset' {a l' : \u03b1} {s : Set \u03b1} (hl' : l' < a) :\n    s \u2208 \ud835\udcdd[<] a \u2194 \u2203 l \u2208 Iio a, Ioo l a \u2286 s", "start": [1767, 1], "end": [1771, 42], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iio_iff_exists_Ioo_subset", "code": "theorem mem_nhdsWithin_Iio_iff_exists_Ioo_subset [NoMinOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd[<] a \u2194 \u2203 l \u2208 Iio a, Ioo l a \u2286 s", "start": [1774, 1], "end": [1779, 46], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iio_iff_exists_Ico_subset", "code": "theorem mem_nhdsWithin_Iio_iff_exists_Ico_subset [NoMinOrder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1}\n    {s : Set \u03b1} : s \u2208 \ud835\udcdd[<] a \u2194 \u2203 l \u2208 Iio a, Ico l a \u2286 s", "start": [1782, 1], "end": [1787, 66], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_basis'", "code": "theorem nhdsWithin_Iio_basis' {a : \u03b1} (h : \u2203 b, b < a) : (\ud835\udcdd[<] a).HasBasis (\u00b7 < a) (Ioo \u00b7 a)", "start": [1790, 1], "end": [1792, 57], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_eq_bot_iff", "code": "theorem nhdsWithin_Iio_eq_bot_iff {a : \u03b1} : \ud835\udcdd[<] a = \u22a5 \u2194 IsBot a \u2228 \u2203 b, b \u22d6 a", "start": [1794, 1], "end": [1797, 34], "kind": "commanddeclaration"}, {"full_name": "TFAE_mem_nhdsWithin_Ici", "code": "theorem TFAE_mem_nhdsWithin_Ici {a b : \u03b1} (hab : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[\u2265] a,\n      s \u2208 \ud835\udcdd[Icc a b] a,\n      s \u2208 \ud835\udcdd[Ico a b] a,\n      \u2203 u \u2208 Ioc a b, Ico a u \u2286 s,\n      \u2203 u \u2208 Ioi a , Ico a u \u2286 s]", "start": [1800, 1], "end": [1827, 14], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset", "code": "theorem mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset {a u' : \u03b1} {s : Set \u03b1} (hu' : a < u') :\n    s \u2208 \ud835\udcdd[\u2265] a \u2194 \u2203 u \u2208 Ioc a u', Ico a u \u2286 s", "start": [1830, 1], "end": [1832, 70], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ici_iff_exists_Ico_subset'", "code": "theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset' {a u' : \u03b1} {s : Set \u03b1} (hu' : a < u') :\n    s \u2208 \ud835\udcdd[\u2265] a \u2194 \u2203 u \u2208 Ioi a, Ico a u \u2286 s", "start": [1835, 1], "end": [1839, 70], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ici_iff_exists_Ico_subset", "code": "theorem mem_nhdsWithin_Ici_iff_exists_Ico_subset [NoMaxOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd[\u2265] a \u2194 \u2203 u \u2208 Ioi a, Ico a u \u2286 s", "start": [1842, 1], "end": [1847, 48], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ici_basis_Ico", "code": "theorem nhdsWithin_Ici_basis_Ico [NoMaxOrder \u03b1] (a : \u03b1) :\n    (\ud835\udcdd[\u2265] a).HasBasis (fun u => a < u) (Ico a)", "start": [1850, 1], "end": [1852, 54], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Ici_iff_exists_Icc_subset", "code": "theorem mem_nhdsWithin_Ici_iff_exists_Icc_subset [NoMaxOrder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1}\n    {s : Set \u03b1} : s \u2208 \ud835\udcdd[\u2265] a \u2194 \u2203 u, a < u \u2227 Icc a u \u2286 s", "start": [1855, 1], "end": [1865, 55], "kind": "commanddeclaration"}, {"full_name": "TFAE_mem_nhdsWithin_Iic", "code": "theorem TFAE_mem_nhdsWithin_Iic {a b : \u03b1} (h : a < b) (s : Set \u03b1) :\n    TFAE [s \u2208 \ud835\udcdd[\u2264] b,s \u2208 \ud835\udcdd[Icc a b] b,s \u2208 \ud835\udcdd[Ioc a b] b,\u2203 l \u2208 Ico a b, Ioc l b \u2286 s,\u2203 l \u2208 Iio b, Ioc l b \u2286 s]", "start": [1869, 1], "end": [1883, 50], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset", "code": "theorem mem_nhdsWithin_Iic_iff_exists_mem_Ico_Ioc_subset {a l' : \u03b1} {s : Set \u03b1} (hl' : l' < a) :\n    s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l \u2208 Ico l' a, Ioc l a \u2286 s", "start": [1886, 1], "end": [1888, 70], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iic_iff_exists_Ioc_subset'", "code": "theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset' {a l' : \u03b1} {s : Set \u03b1} (hl' : l' < a) :\n    s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l \u2208 Iio a, Ioc l a \u2286 s", "start": [1891, 1], "end": [1895, 70], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iic_iff_exists_Ioc_subset", "code": "theorem mem_nhdsWithin_Iic_iff_exists_Ioc_subset [NoMinOrder \u03b1] {a : \u03b1} {s : Set \u03b1} :\n    s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l \u2208 Iio a, Ioc l a \u2286 s", "start": [1898, 1], "end": [1903, 48], "kind": "commanddeclaration"}, {"full_name": "mem_nhdsWithin_Iic_iff_exists_Icc_subset", "code": "theorem mem_nhdsWithin_Iic_iff_exists_Icc_subset [NoMinOrder \u03b1] [DenselyOrdered \u03b1] {a : \u03b1}\n    {s : Set \u03b1} : s \u2208 \ud835\udcdd[\u2264] a \u2194 \u2203 l, l < a \u2227 Icc l a \u2286 s", "start": [1906, 1], "end": [1913, 63], "kind": "commanddeclaration"}, {"full_name": "nhds_eq_iInf_abs_sub", "code": "theorem nhds_eq_iInf_abs_sub (a : \u03b1) : \ud835\udcdd a = \u2a05 r > 0, \ud835\udcdf { b | |a - b| < r }", "start": [1926, 1], "end": [1930, 65], "kind": "commanddeclaration"}, {"full_name": "orderTopology_of_nhds_abs", "code": "theorem orderTopology_of_nhds_abs {\u03b1 : Type*} [TopologicalSpace \u03b1] [LinearOrderedAddCommGroup \u03b1]\n    (h_nhds : \u2200 a : \u03b1, \ud835\udcdd a = \u2a05 r > 0, \ud835\udcdf { b | |a - b| < r }) : OrderTopology \u03b1", "start": [1933, 1], "end": [1938, 38], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedAddCommGroup.tendsto_nhds", "code": "theorem LinearOrderedAddCommGroup.tendsto_nhds {x : Filter \u03b2} {a : \u03b1} :\n    Tendsto f x (\ud835\udcdd a) \u2194 \u2200 \u03b5 > (0 : \u03b1), \u2200\u1da0 b in x, |f b - a| < \u03b5", "start": [1941, 1], "end": [1943, 46], "kind": "commanddeclaration"}, {"full_name": "eventually_abs_sub_lt", "code": "theorem eventually_abs_sub_lt (a : \u03b1) {\u03b5 : \u03b1} (h\u03b5 : 0 < \u03b5) : \u2200\u1da0 x in \ud835\udcdd a, |x - a| < \u03b5", "start": [1946, 1], "end": [1948, 94], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.add_atTop", "code": "theorem Filter.Tendsto.add_atTop {C : \u03b1} (hf : Tendsto f l (\ud835\udcdd C)) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [1951, 1], "end": [1958, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.add_atBot", "code": "theorem Filter.Tendsto.add_atBot {C : \u03b1} (hf : Tendsto f l (\ud835\udcdd C)) (hg : Tendsto g l atBot) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [1961, 1], "end": [1965, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_add", "code": "theorem Filter.Tendsto.atTop_add {C : \u03b1} (hf : Tendsto f l atTop) (hg : Tendsto g l (\ud835\udcdd C)) :\n    Tendsto (fun x => f x + g x) l atTop", "start": [1968, 1], "end": [1973, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_add", "code": "theorem Filter.Tendsto.atBot_add {C : \u03b1} (hf : Tendsto f l atBot) (hg : Tendsto g l (\ud835\udcdd C)) :\n    Tendsto (fun x => f x + g x) l atBot", "start": [1976, 1], "end": [1981, 24], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_abs_sub_lt", "code": "theorem nhds_basis_abs_sub_lt [NoMaxOrder \u03b1] (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun \u03b5 : \u03b1 => (0 : \u03b1) < \u03b5) fun \u03b5 => { b | |b - a| < \u03b5 }", "start": [1984, 1], "end": [1989, 48], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_Ioo_pos", "code": "theorem nhds_basis_Ioo_pos [NoMaxOrder \u03b1] (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis (fun \u03b5 : \u03b1 => (0 : \u03b1) < \u03b5) fun \u03b5 => Ioo (a - \u03b5) (a + \u03b5)", "start": [1992, 1], "end": [1995, 83], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_Icc_pos", "code": "theorem nhds_basis_Icc_pos [NoMaxOrder \u03b1] [DenselyOrdered \u03b1] (a : \u03b1) :\n    (\ud835\udcdd a).HasBasis ((0 : \u03b1) < \u00b7) fun \u03b5 \u21a6 Icc (a - \u03b5) (a + \u03b5)", "start": [1998, 1], "end": [2003, 46], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_zero_abs_sub_lt", "code": "theorem nhds_basis_zero_abs_sub_lt [NoMaxOrder \u03b1] :\n    (\ud835\udcdd (0 : \u03b1)).HasBasis (fun \u03b5 : \u03b1 => (0 : \u03b1) < \u03b5) fun \u03b5 => { b | |b| < \u03b5 }", "start": [2007, 1], "end": [2009, 44], "kind": "commanddeclaration"}, {"full_name": "nhds_basis_Ioo_pos_of_pos", "code": "theorem nhds_basis_Ioo_pos_of_pos [NoMaxOrder \u03b1] {a : \u03b1} (ha : 0 < a) :\n    (\ud835\udcdd a).HasBasis (fun \u03b5 : \u03b1 => (0 : \u03b1) < \u03b5 \u2227 \u03b5 \u2264 a) fun \u03b5 => Ioo (a - \u03b5) (a + \u03b5)", "start": [2014, 1], "end": [2018, 98], "kind": "commanddeclaration"}, {"full_name": "preimage_neg", "code": "@[deprecated image_neg]\ntheorem preimage_neg [AddGroup \u03b1] : preimage (Neg.neg : \u03b1 \u2192 \u03b1) = image (Neg.neg : \u03b1 \u2192 \u03b1)", "start": [2023, 1], "end": [2025, 33], "kind": "commanddeclaration"}, {"full_name": "Filter.map_neg_eq_comap_neg", "code": "@[deprecated] theorem Filter.map_neg_eq_comap_neg [AddGroup \u03b1] :\n    map (Neg.neg : \u03b1 \u2192 \u03b1) = comap (Neg.neg : \u03b1 \u2192 \u03b1)", "start": [2028, 1], "end": [2031, 76], "kind": "commanddeclaration"}, {"full_name": "IsLUB.frequently_mem", "code": "theorem IsLUB.frequently_mem {a : \u03b1} {s : Set \u03b1} (ha : IsLUB s a) (hs : s.Nonempty) :\n    \u2203\u1da0 x in \ud835\udcdd[\u2264] a, x \u2208 s", "start": [2039, 1], "end": [2047, 22], "kind": "commanddeclaration"}, {"full_name": "IsLUB.frequently_nhds_mem", "code": "theorem IsLUB.frequently_nhds_mem {a : \u03b1} {s : Set \u03b1} (ha : IsLUB s a) (hs : s.Nonempty) :\n    \u2203\u1da0 x in \ud835\udcdd a, x \u2208 s", "start": [2050, 1], "end": [2052, 49], "kind": "commanddeclaration"}, {"full_name": "IsGLB.frequently_mem", "code": "theorem IsGLB.frequently_mem {a : \u03b1} {s : Set \u03b1} (ha : IsGLB s a) (hs : s.Nonempty) :\n    \u2203\u1da0 x in \ud835\udcdd[\u2265] a, x \u2208 s", "start": [2055, 1], "end": [2057, 40], "kind": "commanddeclaration"}, {"full_name": "IsGLB.frequently_nhds_mem", "code": "theorem IsGLB.frequently_nhds_mem {a : \u03b1} {s : Set \u03b1} (ha : IsGLB s a) (hs : s.Nonempty) :\n    \u2203\u1da0 x in \ud835\udcdd a, x \u2208 s", "start": [2060, 1], "end": [2062, 49], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mem_closure", "code": "theorem IsLUB.mem_closure {a : \u03b1} {s : Set \u03b1} (ha : IsLUB s a) (hs : s.Nonempty) : a \u2208 closure s", "start": [2065, 1], "end": [2066, 42], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mem_closure", "code": "theorem IsGLB.mem_closure {a : \u03b1} {s : Set \u03b1} (ha : IsGLB s a) (hs : s.Nonempty) : a \u2208 closure s", "start": [2069, 1], "end": [2070, 42], "kind": "commanddeclaration"}, {"full_name": "IsLUB.nhdsWithin_neBot", "code": "theorem IsLUB.nhdsWithin_neBot {a : \u03b1} {s : Set \u03b1} (ha : IsLUB s a) (hs : s.Nonempty) :\n    NeBot (\ud835\udcdd[s] a)", "start": [2073, 1], "end": [2075, 57], "kind": "commanddeclaration"}, {"full_name": "IsGLB.nhdsWithin_neBot", "code": "theorem IsGLB.nhdsWithin_neBot : \u2200 {a : \u03b1} {s : Set \u03b1}, IsGLB s a \u2192 s.Nonempty \u2192 NeBot (\ud835\udcdd[s] a)", "start": [2078, 1], "end": [2079, 36], "kind": "commanddeclaration"}, {"full_name": "isLUB_of_mem_nhds", "code": "theorem isLUB_of_mem_nhds {s : Set \u03b1} {a : \u03b1} {f : Filter \u03b1} (hsa : a \u2208 upperBounds s) (hsf : s \u2208 f)\n    [NeBot (f \u2293 \ud835\udcdd a)] : IsLUB s a", "start": [2082, 1], "end": [2089, 24], "kind": "commanddeclaration"}, {"full_name": "isLUB_of_mem_closure", "code": "theorem isLUB_of_mem_closure {s : Set \u03b1} {a : \u03b1} (hsa : a \u2208 upperBounds s) (hsf : a \u2208 closure s) :\n    IsLUB s a", "start": [2092, 1], "end": [2095, 53], "kind": "commanddeclaration"}, {"full_name": "isGLB_of_mem_nhds", "code": "theorem isGLB_of_mem_nhds :\n    \u2200 {s : Set \u03b1} {a : \u03b1} {f : Filter \u03b1}, a \u2208 lowerBounds s \u2192 s \u2208 f \u2192 NeBot (f \u2293 \ud835\udcdd a) \u2192 IsGLB s a", "start": [2098, 1], "end": [2100, 31], "kind": "commanddeclaration"}, {"full_name": "isGLB_of_mem_closure", "code": "theorem isGLB_of_mem_closure {s : Set \u03b1} {a : \u03b1} (hsa : a \u2208 lowerBounds s) (hsf : a \u2208 closure s) :\n    IsGLB s a", "start": [2103, 1], "end": [2105, 42], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mem_upperBounds_of_tendsto", "code": "theorem IsLUB.mem_upperBounds_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3]\n    {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : MonotoneOn f s) (ha : IsLUB s a)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : b \u2208 upperBounds (f '' s)", "start": [2108, 1], "end": [2115, 72], "kind": "commanddeclaration"}, {"full_name": "IsLUB.isLUB_of_tendsto", "code": "theorem IsLUB.isLUB_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3] {f : \u03b1 \u2192 \u03b3}\n    {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : MonotoneOn f s) (ha : IsLUB s a) (hs : s.Nonempty)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : IsLUB (f '' s) b", "start": [2120, 1], "end": [2125, 101], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mem_lowerBounds_of_tendsto", "code": "theorem IsGLB.mem_lowerBounds_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3]\n    {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : MonotoneOn f s) (ha : IsGLB s a)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : b \u2208 lowerBounds (f '' s)", "start": [2128, 1], "end": [2131, 71], "kind": "commanddeclaration"}, {"full_name": "IsGLB.isGLB_of_tendsto", "code": "theorem IsGLB.isGLB_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3] {f : \u03b1 \u2192 \u03b3}\n    {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : MonotoneOn f s) :\n    IsGLB s a \u2192 s.Nonempty \u2192 Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b) \u2192 IsGLB (f '' s) b", "start": [2137, 1], "end": [2140, 55], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mem_lowerBounds_of_tendsto", "code": "theorem IsLUB.mem_lowerBounds_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3]\n    {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : AntitoneOn f s) (ha : IsLUB s a)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : b \u2208 lowerBounds (f '' s)", "start": [2143, 1], "end": [2146, 55], "kind": "commanddeclaration"}, {"full_name": "IsLUB.isGLB_of_tendsto", "code": "theorem IsLUB.isGLB_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3] :\n    \u2200 {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3},\n      AntitoneOn f s \u2192 IsLUB s a \u2192 s.Nonempty \u2192 Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b) \u2192 IsGLB (f '' s) b", "start": [2149, 1], "end": [2152, 36], "kind": "commanddeclaration"}, {"full_name": "IsGLB.mem_upperBounds_of_tendsto", "code": "theorem IsGLB.mem_upperBounds_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3]\n    {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3} (hf : AntitoneOn f s) (ha : IsGLB s a)\n    (hb : Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b)) : b \u2208 upperBounds (f '' s)", "start": [2155, 1], "end": [2158, 55], "kind": "commanddeclaration"}, {"full_name": "IsGLB.isLUB_of_tendsto", "code": "theorem IsGLB.isLUB_of_tendsto [Preorder \u03b3] [TopologicalSpace \u03b3] [OrderClosedTopology \u03b3] :\n    \u2200 {f : \u03b1 \u2192 \u03b3} {s : Set \u03b1} {a : \u03b1} {b : \u03b3},\n      AntitoneOn f s \u2192 IsGLB s a \u2192 s.Nonempty \u2192 Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b) \u2192 IsLUB (f '' s) b", "start": [2161, 1], "end": [2164, 36], "kind": "commanddeclaration"}, {"full_name": "IsLUB.mem_of_isClosed", "code": "theorem IsLUB.mem_of_isClosed {a : \u03b1} {s : Set \u03b1} (ha : IsLUB s a) (hs : s.Nonempty)\n    (sc : IsClosed s) : a \u2208 s", "start": [2167, 1], "end": [2169, 41], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isLUB_mem", "code": "alias IsClosed.isLUB_mem := IsLUB.mem_of_isClosed", "start": [2172, 1], "end": [2172, 50], "kind": "stdtacticaliasalias"}, {"full_name": "IsGLB.mem_of_isClosed", "code": "theorem IsGLB.mem_of_isClosed {a : \u03b1} {s : Set \u03b1} (ha : IsGLB s a) (hs : s.Nonempty)\n    (sc : IsClosed s) : a \u2208 s", "start": [2175, 1], "end": [2177, 41], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isGLB_mem", "code": "alias IsClosed.isGLB_mem := IsGLB.mem_of_isClosed", "start": [2180, 1], "end": [2180, 50], "kind": "stdtacticaliasalias"}, {"full_name": "IsLUB.exists_seq_strictMono_tendsto_of_not_mem", "code": "theorem IsLUB.exists_seq_strictMono_tendsto_of_not_mem {t : Set \u03b1} {x : \u03b1}\n    [IsCountablyGenerated (\ud835\udcdd x)] (htx : IsLUB t x) (not_mem : x \u2209 t) (ht : t.Nonempty) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictMono u \u2227 (\u2200 n, u n < x) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t", "start": [2187, 1], "end": [2198, 41], "kind": "commanddeclaration"}, {"full_name": "IsLUB.exists_seq_monotone_tendsto", "code": "theorem IsLUB.exists_seq_monotone_tendsto {t : Set \u03b1} {x : \u03b1} [IsCountablyGenerated (\ud835\udcdd x)]\n    (htx : IsLUB t x) (ht : t.Nonempty) :\n    \u2203 u : \u2115 \u2192 \u03b1, Monotone u \u2227 (\u2200 n, u n \u2264 x) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t", "start": [2201, 1], "end": [2207, 61], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictMono_tendsto'", "code": "theorem exists_seq_strictMono_tendsto' {\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]\n    [DenselyOrdered \u03b1] [OrderTopology \u03b1] [FirstCountableTopology \u03b1] {x y : \u03b1} (hy : y < x) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictMono u \u2227 (\u2200 n, u n \u2208 Ioo y x) \u2227 Tendsto u atTop (\ud835\udcdd x)", "start": [2210, 1], "end": [2216, 31], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictMono_tendsto", "code": "theorem exists_seq_strictMono_tendsto [DenselyOrdered \u03b1] [NoMinOrder \u03b1] [FirstCountableTopology \u03b1]\n    (x : \u03b1) : \u2203 u : \u2115 \u2192 \u03b1, StrictMono u \u2227 (\u2200 n, u n < x) \u2227 Tendsto u atTop (\ud835\udcdd x)", "start": [2219, 1], "end": [2223, 49], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictMono_tendsto_nhdsWithin", "code": "theorem exists_seq_strictMono_tendsto_nhdsWithin [DenselyOrdered \u03b1] [NoMinOrder \u03b1]\n    [FirstCountableTopology \u03b1] (x : \u03b1) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictMono u \u2227 (\u2200 n, u n < x) \u2227 Tendsto u atTop (\ud835\udcdd[<] x)", "start": [2226, 1], "end": [2230, 101], "kind": "commanddeclaration"}, {"full_name": "exists_seq_tendsto_sSup", "code": "theorem exists_seq_tendsto_sSup {\u03b1 : Type*} [ConditionallyCompleteLinearOrder \u03b1]\n    [TopologicalSpace \u03b1] [OrderTopology \u03b1] [FirstCountableTopology \u03b1] {S : Set \u03b1} (hS : S.Nonempty)\n    (hS' : BddAbove S) : \u2203 u : \u2115 \u2192 \u03b1, Monotone u \u2227 Tendsto u atTop (\ud835\udcdd (sSup S)) \u2227 \u2200 n, u n \u2208 S", "start": [2233, 1], "end": [2237, 26], "kind": "commanddeclaration"}, {"full_name": "IsGLB.exists_seq_strictAnti_tendsto_of_not_mem", "code": "theorem IsGLB.exists_seq_strictAnti_tendsto_of_not_mem {t : Set \u03b1} {x : \u03b1}\n    [IsCountablyGenerated (\ud835\udcdd x)] (htx : IsGLB t x) (not_mem : x \u2209 t) (ht : t.Nonempty) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, x < u n) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t", "start": [2240, 1], "end": [2243, 75], "kind": "commanddeclaration"}, {"full_name": "IsGLB.exists_seq_antitone_tendsto", "code": "theorem IsGLB.exists_seq_antitone_tendsto {t : Set \u03b1} {x : \u03b1} [IsCountablyGenerated (\ud835\udcdd x)]\n    (htx : IsGLB t x) (ht : t.Nonempty) :\n    \u2203 u : \u2115 \u2192 \u03b1, Antitone u \u2227 (\u2200 n, x \u2264 u n) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t", "start": [2246, 1], "end": [2249, 54], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictAnti_tendsto'", "code": "theorem exists_seq_strictAnti_tendsto' [DenselyOrdered \u03b1] [FirstCountableTopology \u03b1] {x y : \u03b1}\n    (hy : x < y) : \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, u n \u2208 Ioo x y) \u2227 Tendsto u atTop (\ud835\udcdd x)", "start": [2252, 1], "end": [2255, 86], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictAnti_tendsto", "code": "theorem exists_seq_strictAnti_tendsto [DenselyOrdered \u03b1] [NoMaxOrder \u03b1] [FirstCountableTopology \u03b1]\n    (x : \u03b1) : \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, x < u n) \u2227 Tendsto u atTop (\ud835\udcdd x)", "start": [2258, 1], "end": [2260, 45], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictAnti_tendsto_nhdsWithin", "code": "theorem exists_seq_strictAnti_tendsto_nhdsWithin [DenselyOrdered \u03b1] [NoMaxOrder \u03b1]\n    [FirstCountableTopology \u03b1] (x : \u03b1) :\n    \u2203 u : \u2115 \u2192 \u03b1, StrictAnti u \u2227 (\u2200 n, x < u n) \u2227 Tendsto u atTop (\ud835\udcdd[>] x)", "start": [2263, 1], "end": [2266, 56], "kind": "commanddeclaration"}, {"full_name": "exists_seq_strictAnti_strictMono_tendsto", "code": "theorem exists_seq_strictAnti_strictMono_tendsto [DenselyOrdered \u03b1] [FirstCountableTopology \u03b1]\n    {x y : \u03b1} (h : x < y) :\n    \u2203 u v : \u2115 \u2192 \u03b1, StrictAnti u \u2227 StrictMono v \u2227 (\u2200 k, u k \u2208 Ioo x y) \u2227 (\u2200 l, v l \u2208 Ioo x y) \u2227\n      (\u2200 k l, u k < v l) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 Tendsto v atTop (\ud835\udcdd y)", "start": [2269, 1], "end": [2277, 81], "kind": "commanddeclaration"}, {"full_name": "exists_seq_tendsto_sInf", "code": "theorem exists_seq_tendsto_sInf {\u03b1 : Type*} [ConditionallyCompleteLinearOrder \u03b1]\n    [TopologicalSpace \u03b1] [OrderTopology \u03b1] [FirstCountableTopology \u03b1] {S : Set \u03b1} (hS : S.Nonempty)\n    (hS' : BddBelow S) : \u2203 u : \u2115 \u2192 \u03b1, Antitone u \u2227 Tendsto u atTop (\ud835\udcdd (sInf S)) \u2227 \u2200 n, u n \u2208 S", "start": [2280, 1], "end": [2283, 44], "kind": "commanddeclaration"}, {"full_name": "closure_Ioi'", "code": "theorem closure_Ioi' {a : \u03b1} (h : (Ioi a).Nonempty) : closure (Ioi a) = Ici a", "start": [2293, 1], "end": [2299, 34], "kind": "commanddeclaration"}, {"full_name": "closure_Ioi", "code": "@[simp]\ntheorem closure_Ioi (a : \u03b1) [NoMaxOrder \u03b1] : closure (Ioi a) = Ici a", "start": [2302, 1], "end": [2305, 28], "kind": "commanddeclaration"}, {"full_name": "closure_Iio'", "code": "theorem closure_Iio' (h : (Iio a).Nonempty) : closure (Iio a) = Iic a", "start": [2308, 1], "end": [2311, 28], "kind": "commanddeclaration"}, {"full_name": "closure_Iio", "code": "@[simp]\ntheorem closure_Iio (a : \u03b1) [NoMinOrder \u03b1] : closure (Iio a) = Iic a", "start": [2314, 1], "end": [2317, 28], "kind": "commanddeclaration"}, {"full_name": "closure_Ioo", "code": "@[simp]\ntheorem closure_Ioo {a b : \u03b1} (hab : a \u2260 b) : closure (Ioo a b) = Icc a b", "start": [2320, 1], "end": [2331, 27], "kind": "commanddeclaration"}, {"full_name": "closure_Ioc", "code": "@[simp]\ntheorem closure_Ioc {a b : \u03b1} (hab : a \u2260 b) : closure (Ioc a b) = Icc a b", "start": [2334, 1], "end": [2340, 25], "kind": "commanddeclaration"}, {"full_name": "closure_Ico", "code": "@[simp]\ntheorem closure_Ico {a b : \u03b1} (hab : a \u2260 b) : closure (Ico a b) = Icc a b", "start": [2343, 1], "end": [2349, 25], "kind": "commanddeclaration"}, {"full_name": "interior_Ici'", "code": "@[simp]\ntheorem interior_Ici' {a : \u03b1} (ha : (Iio a).Nonempty) : interior (Ici a) = Ioi a", "start": [2352, 1], "end": [2354, 63], "kind": "commanddeclaration"}, {"full_name": "interior_Ici", "code": "theorem interior_Ici [NoMinOrder \u03b1] {a : \u03b1} : interior (Ici a) = Ioi a", "start": [2357, 1], "end": [2358, 29], "kind": "commanddeclaration"}, {"full_name": "interior_Iic'", "code": "@[simp]\ntheorem interior_Iic' {a : \u03b1} (ha : (Ioi a).Nonempty) : interior (Iic a) = Iio a", "start": [2361, 1], "end": [2363, 30], "kind": "commanddeclaration"}, {"full_name": "interior_Iic", "code": "theorem interior_Iic [NoMaxOrder \u03b1] {a : \u03b1} : interior (Iic a) = Iio a", "start": [2366, 1], "end": [2367, 29], "kind": "commanddeclaration"}, {"full_name": "interior_Icc", "code": "@[simp]\ntheorem interior_Icc [NoMinOrder \u03b1] [NoMaxOrder \u03b1] {a b : \u03b1} : interior (Icc a b) = Ioo a b", "start": [2370, 1], "end": [2372, 82], "kind": "commanddeclaration"}, {"full_name": "interior_Ico", "code": "@[simp]\ntheorem interior_Ico [NoMinOrder \u03b1] {a b : \u03b1} : interior (Ico a b) = Ioo a b", "start": [2375, 1], "end": [2377, 82], "kind": "commanddeclaration"}, {"full_name": "interior_Ioc", "code": "@[simp]\ntheorem interior_Ioc [NoMaxOrder \u03b1] {a b : \u03b1} : interior (Ioc a b) = Ioo a b", "start": [2380, 1], "end": [2382, 82], "kind": "commanddeclaration"}, {"full_name": "closure_interior_Icc", "code": "theorem closure_interior_Icc {a b : \u03b1} (h : a \u2260 b) : closure (interior (Icc a b)) = Icc a b", "start": [2385, 1], "end": [2390, 71], "kind": "commanddeclaration"}, {"full_name": "Ioc_subset_closure_interior", "code": "theorem Ioc_subset_closure_interior (a b : \u03b1) : Ioc a b \u2286 closure (interior (Ioc a b))", "start": [2393, 1], "end": [2400, 71], "kind": "commanddeclaration"}, {"full_name": "Ico_subset_closure_interior", "code": "theorem Ico_subset_closure_interior (a b : \u03b1) : Ico a b \u2286 closure (interior (Ico a b))", "start": [2403, 1], "end": [2404, 100], "kind": "commanddeclaration"}, {"full_name": "frontier_Ici'", "code": "@[simp]\ntheorem frontier_Ici' {a : \u03b1} (ha : (Iio a).Nonempty) : frontier (Ici a) = {a}", "start": [2407, 1], "end": [2409, 22], "kind": "commanddeclaration"}, {"full_name": "frontier_Ici", "code": "theorem frontier_Ici [NoMinOrder \u03b1] {a : \u03b1} : frontier (Ici a) = {a}", "start": [2412, 1], "end": [2413, 29], "kind": "commanddeclaration"}, {"full_name": "frontier_Iic'", "code": "@[simp]\ntheorem frontier_Iic' {a : \u03b1} (ha : (Ioi a).Nonempty) : frontier (Iic a) = {a}", "start": [2416, 1], "end": [2418, 22], "kind": "commanddeclaration"}, {"full_name": "frontier_Iic", "code": "theorem frontier_Iic [NoMaxOrder \u03b1] {a : \u03b1} : frontier (Iic a) = {a}", "start": [2421, 1], "end": [2422, 29], "kind": "commanddeclaration"}, {"full_name": "frontier_Ioi'", "code": "@[simp]\ntheorem frontier_Ioi' {a : \u03b1} (ha : (Ioi a).Nonempty) : frontier (Ioi a) = {a}", "start": [2425, 1], "end": [2427, 59], "kind": "commanddeclaration"}, {"full_name": "frontier_Ioi", "code": "theorem frontier_Ioi [NoMaxOrder \u03b1] {a : \u03b1} : frontier (Ioi a) = {a}", "start": [2430, 1], "end": [2431, 29], "kind": "commanddeclaration"}, {"full_name": "frontier_Iio'", "code": "@[simp]\ntheorem frontier_Iio' {a : \u03b1} (ha : (Iio a).Nonempty) : frontier (Iio a) = {a}", "start": [2434, 1], "end": [2436, 59], "kind": "commanddeclaration"}, {"full_name": "frontier_Iio", "code": "theorem frontier_Iio [NoMinOrder \u03b1] {a : \u03b1} : frontier (Iio a) = {a}", "start": [2439, 1], "end": [2440, 29], "kind": "commanddeclaration"}, {"full_name": "frontier_Icc", "code": "@[simp]\ntheorem frontier_Icc [NoMinOrder \u03b1] [NoMaxOrder \u03b1] {a b : \u03b1} (h : a \u2264 b) :\n    frontier (Icc a b) = {a, b}", "start": [2443, 1], "end": [2445, 76], "kind": "commanddeclaration"}, {"full_name": "frontier_Ioo", "code": "@[simp]\ntheorem frontier_Ioo {a b : \u03b1} (h : a < b) : frontier (Ioo a b) = {a, b}", "start": [2448, 1], "end": [2450, 72], "kind": "commanddeclaration"}, {"full_name": "frontier_Ico", "code": "@[simp]\ntheorem frontier_Ico [NoMinOrder \u03b1] {a b : \u03b1} (h : a < b) : frontier (Ico a b) = {a, b}", "start": [2453, 1], "end": [2455, 72], "kind": "commanddeclaration"}, {"full_name": "frontier_Ioc", "code": "@[simp]\ntheorem frontier_Ioc [NoMaxOrder \u03b1] {a b : \u03b1} (h : a < b) : frontier (Ioc a b) = {a, b}", "start": [2458, 1], "end": [2460, 72], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_neBot'", "code": "theorem nhdsWithin_Ioi_neBot' {a b : \u03b1} (H\u2081 : (Ioi a).Nonempty) (H\u2082 : a \u2264 b) :\n    NeBot (\ud835\udcdd[Ioi a] b)", "start": [2463, 1], "end": [2465, 65], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_neBot", "code": "theorem nhdsWithin_Ioi_neBot [NoMaxOrder \u03b1] {a b : \u03b1} (H : a \u2264 b) : NeBot (\ud835\udcdd[Ioi a] b)", "start": [2468, 1], "end": [2469, 39], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_self_neBot'", "code": "theorem nhdsWithin_Ioi_self_neBot' {a : \u03b1} (H : (Ioi a).Nonempty) : NeBot (\ud835\udcdd[>] a)", "start": [2472, 1], "end": [2473, 38], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Ioi_self_neBot", "code": "instance nhdsWithin_Ioi_self_neBot [NoMaxOrder \u03b1] (a : \u03b1) : NeBot (\ud835\udcdd[>] a) :=\n  nhdsWithin_Ioi_neBot (le_refl a)", "start": [2476, 1], "end": [2477, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_gt", "code": "theorem Filter.Eventually.exists_gt [NoMaxOrder \u03b1] {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in \ud835\udcdd a, p x) :\n    \u2203 b > a, p b", "start": [2480, 1], "end": [2483, 89], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_neBot'", "code": "theorem nhdsWithin_Iio_neBot' {b c : \u03b1} (H\u2081 : (Iio c).Nonempty) (H\u2082 : b \u2264 c) :\n    NeBot (\ud835\udcdd[Iio c] b)", "start": [2486, 1], "end": [2488, 65], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_neBot", "code": "theorem nhdsWithin_Iio_neBot [NoMinOrder \u03b1] {a b : \u03b1} (H : a \u2264 b) : NeBot (\ud835\udcdd[Iio b] a)", "start": [2491, 1], "end": [2492, 39], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_self_neBot'", "code": "theorem nhdsWithin_Iio_self_neBot' {b : \u03b1} (H : (Iio b).Nonempty) : NeBot (\ud835\udcdd[<] b)", "start": [2495, 1], "end": [2496, 38], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_Iio_self_neBot", "code": "instance nhdsWithin_Iio_self_neBot [NoMinOrder \u03b1] (a : \u03b1) : NeBot (\ud835\udcdd[<] a) :=\n  nhdsWithin_Iio_neBot (le_refl a)", "start": [2499, 1], "end": [2500, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.exists_lt", "code": "theorem Filter.Eventually.exists_lt [NoMinOrder \u03b1] {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200\u1da0 x in \ud835\udcdd a, p x) :\n    \u2203 b < a, p b", "start": [2503, 1], "end": [2505, 43], "kind": "commanddeclaration"}, {"full_name": "right_nhdsWithin_Ico_neBot", "code": "theorem right_nhdsWithin_Ico_neBot {a b : \u03b1} (H : a < b) : NeBot (\ud835\udcdd[Ico a b] b)", "start": [2508, 1], "end": [2509, 52], "kind": "commanddeclaration"}, {"full_name": "left_nhdsWithin_Ioc_neBot", "code": "theorem left_nhdsWithin_Ioc_neBot {a b : \u03b1} (H : a < b) : NeBot (\ud835\udcdd[Ioc a b] a)", "start": [2512, 1], "end": [2513, 52], "kind": "commanddeclaration"}, {"full_name": "left_nhdsWithin_Ioo_neBot", "code": "theorem left_nhdsWithin_Ioo_neBot {a b : \u03b1} (H : a < b) : NeBot (\ud835\udcdd[Ioo a b] a)", "start": [2516, 1], "end": [2517, 52], "kind": "commanddeclaration"}, {"full_name": "right_nhdsWithin_Ioo_neBot", "code": "theorem right_nhdsWithin_Ioo_neBot {a b : \u03b1} (H : a < b) : NeBot (\ud835\udcdd[Ioo a b] b)", "start": [2520, 1], "end": [2521, 52], "kind": "commanddeclaration"}, {"full_name": "comap_coe_nhdsWithin_Iio_of_Ioo_subset", "code": "theorem comap_coe_nhdsWithin_Iio_of_Ioo_subset (hb : s \u2286 Iio b)\n    (hs : s.Nonempty \u2192 \u2203 a < b, Ioo a b \u2286 s) : comap ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd[<] b) = atTop", "start": [2524, 1], "end": [2539, 80], "kind": "commanddeclaration"}, {"full_name": "comap_coe_nhdsWithin_Ioi_of_Ioo_subset", "code": "theorem comap_coe_nhdsWithin_Ioi_of_Ioo_subset (ha : s \u2286 Ioi a)\n    (hs : s.Nonempty \u2192 \u2203 b > a, Ioo a b \u2286 s) : comap ((\u2191) : s \u2192 \u03b1) (\ud835\udcdd[>] a) = atBot", "start": [2542, 1], "end": [2545, 55], "kind": "commanddeclaration"}, {"full_name": "map_coe_atTop_of_Ioo_subset", "code": "theorem map_coe_atTop_of_Ioo_subset (hb : s \u2286 Iio b) (hs : \u2200 a' < b, \u2203 a < b, Ioo a b \u2286 s) :\n    map ((\u2191) : s \u2192 \u03b1) atTop = \ud835\udcdd[<] b", "start": [2548, 1], "end": [2555, 69], "kind": "commanddeclaration"}, {"full_name": "map_coe_atBot_of_Ioo_subset", "code": "theorem map_coe_atBot_of_Ioo_subset (ha : s \u2286 Ioi a) (hs : \u2200 b' > a, \u2203 b > a, Ioo a b \u2286 s) :\n    map ((\u2191) : s \u2192 \u03b1) atBot = \ud835\udcdd[>] a", "start": [2558, 1], "end": [2563, 58], "kind": "commanddeclaration"}, {"full_name": "comap_coe_Ioo_nhdsWithin_Iio", "code": "theorem comap_coe_Ioo_nhdsWithin_Iio (a b : \u03b1) : comap ((\u2191) : Ioo a b \u2192 \u03b1) (\ud835\udcdd[<] b) = atTop", "start": [2566, 1], "end": [2570, 41], "kind": "commanddeclaration"}, {"full_name": "comap_coe_Ioo_nhdsWithin_Ioi", "code": "theorem comap_coe_Ioo_nhdsWithin_Ioi (a b : \u03b1) : comap ((\u2191) : Ioo a b \u2192 \u03b1) (\ud835\udcdd[>] a) = atBot", "start": [2573, 1], "end": [2577, 41], "kind": "commanddeclaration"}, {"full_name": "comap_coe_Ioi_nhdsWithin_Ioi", "code": "theorem comap_coe_Ioi_nhdsWithin_Ioi (a : \u03b1) : comap ((\u2191) : Ioi a \u2192 \u03b1) (\ud835\udcdd[>] a) = atBot", "start": [2580, 1], "end": [2581, 101], "kind": "commanddeclaration"}, {"full_name": "comap_coe_Iio_nhdsWithin_Iio", "code": "theorem comap_coe_Iio_nhdsWithin_Iio (a : \u03b1) : comap ((\u2191) : Iio a \u2192 \u03b1) (\ud835\udcdd[<] a) = atTop", "start": [2584, 1], "end": [2585, 44], "kind": "commanddeclaration"}, {"full_name": "map_coe_Ioo_atTop", "code": "@[simp]\ntheorem map_coe_Ioo_atTop {a b : \u03b1} (h : a < b) : map ((\u2191) : Ioo a b \u2192 \u03b1) atTop = \ud835\udcdd[<] b", "start": [2588, 1], "end": [2590, 83], "kind": "commanddeclaration"}, {"full_name": "map_coe_Ioo_atBot", "code": "@[simp]\ntheorem map_coe_Ioo_atBot {a b : \u03b1} (h : a < b) : map ((\u2191) : Ioo a b \u2192 \u03b1) atBot = \ud835\udcdd[>] a", "start": [2593, 1], "end": [2595, 83], "kind": "commanddeclaration"}, {"full_name": "map_coe_Ioi_atBot", "code": "@[simp]\ntheorem map_coe_Ioi_atBot (a : \u03b1) : map ((\u2191) : Ioi a \u2192 \u03b1) atBot = \ud835\udcdd[>] a", "start": [2598, 1], "end": [2600, 87], "kind": "commanddeclaration"}, {"full_name": "map_coe_Iio_atTop", "code": "@[simp]\ntheorem map_coe_Iio_atTop (a : \u03b1) : map ((\u2191) : Iio a \u2192 \u03b1) atTop = \ud835\udcdd[<] a", "start": [2603, 1], "end": [2605, 33], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_coe_Ioo_atTop", "code": "@[simp]\ntheorem tendsto_comp_coe_Ioo_atTop (h : a < b) :\n    Tendsto (fun x : Ioo a b => f x) atTop l \u2194 Tendsto f (\ud835\udcdd[<] b) l", "start": [2610, 1], "end": [2613, 52], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_coe_Ioo_atBot", "code": "@[simp]\ntheorem tendsto_comp_coe_Ioo_atBot (h : a < b) :\n    Tendsto (fun x : Ioo a b => f x) atBot l \u2194 Tendsto f (\ud835\udcdd[>] a) l", "start": [2616, 1], "end": [2619, 52], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_coe_Ioi_atBot", "code": "@[simp, nolint simpNF]\ntheorem tendsto_comp_coe_Ioi_atBot :\n    Tendsto (fun x : Ioi a => f x) atBot l \u2194 Tendsto f (\ud835\udcdd[>] a) l", "start": [2623, 1], "end": [2626, 50], "kind": "commanddeclaration"}, {"full_name": "tendsto_comp_coe_Iio_atTop", "code": "@[simp, nolint simpNF]\ntheorem tendsto_comp_coe_Iio_atTop :\n    Tendsto (fun x : Iio a => f x) atTop l \u2194 Tendsto f (\ud835\udcdd[<] a) l", "start": [2630, 1], "end": [2633, 50], "kind": "commanddeclaration"}, {"full_name": "tendsto_Ioo_atTop", "code": "@[simp]\ntheorem tendsto_Ioo_atTop {f : \u03b2 \u2192 Ioo a b} :\n    Tendsto f l atTop \u2194 Tendsto (fun x => (f x : \u03b1)) l (\ud835\udcdd[<] b)", "start": [2636, 1], "end": [2639, 62], "kind": "commanddeclaration"}, {"full_name": "tendsto_Ioo_atBot", "code": "@[simp]\ntheorem tendsto_Ioo_atBot {f : \u03b2 \u2192 Ioo a b} :\n    Tendsto f l atBot \u2194 Tendsto (fun x => (f x : \u03b1)) l (\ud835\udcdd[>] a)", "start": [2642, 1], "end": [2645, 62], "kind": "commanddeclaration"}, {"full_name": "tendsto_Ioi_atBot", "code": "@[simp]\ntheorem tendsto_Ioi_atBot {f : \u03b2 \u2192 Ioi a} :\n    Tendsto f l atBot \u2194 Tendsto (fun x => (f x : \u03b1)) l (\ud835\udcdd[>] a)", "start": [2648, 1], "end": [2651, 62], "kind": "commanddeclaration"}, {"full_name": "tendsto_Iio_atTop", "code": "@[simp]\ntheorem tendsto_Iio_atTop {f : \u03b2 \u2192 Iio a} :\n    Tendsto f l atTop \u2194 Tendsto (fun x => (f x : \u03b1)) l (\ud835\udcdd[<] a)", "start": [2654, 1], "end": [2657, 62], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_countable_dense_subset_no_bot_top", "code": "theorem Dense.exists_countable_dense_subset_no_bot_top [Nontrivial \u03b1] {s : Set \u03b1} [SeparableSpace s]\n    (hs : Dense s) :\n    \u2203 t, t \u2286 s \u2227 t.Countable \u2227 Dense t \u2227 (\u2200 x, IsBot x \u2192 x \u2209 t) \u2227 \u2200 x, IsTop x \u2192 x \u2209 t", "start": [2670, 1], "end": [2682, 14], "kind": "commanddeclaration"}, {"full_name": "exists_countable_dense_no_bot_top", "code": "theorem exists_countable_dense_no_bot_top [SeparableSpace \u03b1] [Nontrivial \u03b1] :\n    \u2203 s : Set \u03b1, s.Countable \u2227 Dense s \u2227 (\u2200 x, IsBot x \u2192 x \u2209 s) \u2227 \u2200 x, IsTop x \u2192 x \u2209 s", "start": [2687, 1], "end": [2693, 66], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sSup_of_continuousAt'", "code": "theorem Monotone.map_sSup_of_continuousAt' {f : \u03b1 \u2192 \u03b2} {A : Set \u03b1} (Cf : ContinuousAt f (sSup A))\n    (Mf : Monotone f) (A_nonemp : A.Nonempty) (A_bdd : BddAbove A := by bddDefault) :\n    f (sSup A) = sSup (f '' A)", "start": [2703, 1], "end": [2710, 58], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iSup_of_continuousAt'", "code": "theorem Monotone.map_iSup_of_continuousAt' {\u03b9 : Sort*} [Nonempty \u03b9] {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f)\n    (bdd : BddAbove (range g) := by bddDefault) : f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [2713, 1], "end": [2719, 6], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sInf_of_continuousAt'", "code": "theorem Monotone.map_sInf_of_continuousAt' {f : \u03b1 \u2192 \u03b2} {A : Set \u03b1} (Cf : ContinuousAt f (sInf A))\n    (Mf : Monotone f) (A_nonemp : A.Nonempty) (A_bdd : BddBelow A := by bddDefault) :\n    f (sInf A) = sInf (f '' A)", "start": [2722, 1], "end": [2727, 85], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iInf_of_continuousAt'", "code": "theorem Monotone.map_iInf_of_continuousAt' {\u03b9 : Sort*} [Nonempty \u03b9] {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f)\n    (bdd : BddBelow (range g) := by bddDefault) : f (\u2a05 i, g i) = \u2a05 i, f (g i)", "start": [2730, 1], "end": [2736, 6], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sInf_of_continuousAt'", "code": "theorem Antitone.map_sInf_of_continuousAt' {f : \u03b1 \u2192 \u03b2} {A : Set \u03b1} (Cf : ContinuousAt f (sInf A))\n    (Af : Antitone f) (A_nonemp : A.Nonempty) (A_bdd : BddBelow A := by bddDefault) :\n    f (sInf A) = sSup (f '' A)", "start": [2739, 1], "end": [2744, 80], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iInf_of_continuousAt'", "code": "theorem Antitone.map_iInf_of_continuousAt' {\u03b9 : Sort*} [Nonempty \u03b9] {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f)\n    (bdd : BddBelow (range g) := by bddDefault) : f (\u2a05 i, g i) = \u2a06 i, f (g i)", "start": [2747, 1], "end": [2753, 6], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sSup_of_continuousAt'", "code": "theorem Antitone.map_sSup_of_continuousAt' {f : \u03b1 \u2192 \u03b2} {A : Set \u03b1} (Cf : ContinuousAt f (sSup A))\n    (Af : Antitone f) (A_nonemp : A.Nonempty) (A_bdd : BddAbove A := by bddDefault) :\n    f (sSup A) = sInf (f '' A)", "start": [2756, 1], "end": [2761, 80], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iSup_of_continuousAt'", "code": "theorem Antitone.map_iSup_of_continuousAt' {\u03b9 : Sort*} [Nonempty \u03b9] {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f)\n    (bdd : BddAbove (range g) := by bddDefault) : f (\u2a06 i, g i) = \u2a05 i, f (g i)", "start": [2764, 1], "end": [2770, 6], "kind": "commanddeclaration"}, {"full_name": "sSup_mem_closure", "code": "theorem sSup_mem_closure {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    {s : Set \u03b1} (hs : s.Nonempty) : sSup s \u2208 closure s", "start": [2780, 1], "end": [2782, 32], "kind": "commanddeclaration"}, {"full_name": "sInf_mem_closure", "code": "theorem sInf_mem_closure {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    {s : Set \u03b1} (hs : s.Nonempty) : sInf s \u2208 closure s", "start": [2785, 1], "end": [2787, 32], "kind": "commanddeclaration"}, {"full_name": "IsClosed.sSup_mem", "code": "theorem IsClosed.sSup_mem {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1]\n    [OrderTopology \u03b1] {s : Set \u03b1} (hs : s.Nonempty) (hc : IsClosed s) : sSup s \u2208 s", "start": [2790, 1], "end": [2792, 39], "kind": "commanddeclaration"}, {"full_name": "IsClosed.sInf_mem", "code": "theorem IsClosed.sInf_mem {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1]\n    [OrderTopology \u03b1] {s : Set \u03b1} (hs : s.Nonempty) (hc : IsClosed s) : sInf s \u2208 s", "start": [2795, 1], "end": [2797, 39], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sSup_of_continuousAt", "code": "theorem Monotone.map_sSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sSup s))\n    (Mf : Monotone f) (fbot : f \u22a5 = \u22a5) : f (sSup s) = sSup (f '' s)", "start": [2800, 1], "end": [2806, 44], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iSup_of_continuousAt", "code": "theorem Monotone.map_iSup_of_continuousAt {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iSup g)) (Mf : Monotone f) (fbot : f \u22a5 = \u22a5) :\n    f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [2809, 1], "end": [2814, 74], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_sInf_of_continuousAt", "code": "theorem Monotone.map_sInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sInf s))\n    (Mf : Monotone f) (ftop : f \u22a4 = \u22a4) : f (sInf s) = sInf (f '' s)", "start": [2817, 1], "end": [2821, 74], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_iInf_of_continuousAt", "code": "theorem Monotone.map_iInf_of_continuousAt {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iInf g)) (Mf : Monotone f) (ftop : f \u22a4 = \u22a4) : f (iInf g) = iInf (f \u2218 g)", "start": [2824, 1], "end": [2828, 74], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sSup_of_continuousAt", "code": "theorem Antitone.map_sSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sSup s))\n    (Af : Antitone f) (fbot : f \u22a5 = \u22a4) : f (sSup s) = sInf (f '' s)", "start": [2831, 1], "end": [2836, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iSup_of_continuousAt", "code": "theorem Antitone.map_iSup_of_continuousAt {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iSup g)) (Af : Antitone f) (fbot : f \u22a5 = \u22a4) :\n    f (\u2a06 i, g i) = \u2a05 i, f (g i)", "start": [2839, 1], "end": [2845, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_sInf_of_continuousAt", "code": "theorem Antitone.map_sInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sInf s))\n    (Af : Antitone f) (ftop : f \u22a4 = \u22a5) : f (sInf s) = sSup (f '' s)", "start": [2848, 1], "end": [2853, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_iInf_of_continuousAt", "code": "theorem Antitone.map_iInf_of_continuousAt {\u03b9 : Sort*} {f : \u03b1 \u2192 \u03b2} {g : \u03b9 \u2192 \u03b1}\n    (Cf : ContinuousAt f (iInf g)) (Af : Antitone f) (ftop : f \u22a4 = \u22a5) : f (iInf g) = iSup (f \u2218 g)", "start": [2856, 1], "end": [2861, 9], "kind": "commanddeclaration"}, {"full_name": "csSup_mem_closure", "code": "theorem csSup_mem_closure {s : Set \u03b1} (hs : s.Nonempty) (B : BddAbove s) : sSup s \u2208 closure s", "start": [2871, 1], "end": [2872, 36], "kind": "commanddeclaration"}, {"full_name": "csInf_mem_closure", "code": "theorem csInf_mem_closure {s : Set \u03b1} (hs : s.Nonempty) (B : BddBelow s) : sInf s \u2208 closure s", "start": [2875, 1], "end": [2876, 36], "kind": "commanddeclaration"}, {"full_name": "IsClosed.csSup_mem", "code": "theorem IsClosed.csSup_mem {s : Set \u03b1} (hc : IsClosed s) (hs : s.Nonempty) (B : BddAbove s) :\n    sSup s \u2208 s", "start": [2879, 1], "end": [2881, 43], "kind": "commanddeclaration"}, {"full_name": "IsClosed.csInf_mem", "code": "theorem IsClosed.csInf_mem {s : Set \u03b1} (hc : IsClosed s) (hs : s.Nonempty) (B : BddBelow s) :\n    sInf s \u2208 s", "start": [2884, 1], "end": [2886, 43], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isLeast_csInf", "code": "theorem IsClosed.isLeast_csInf {s : Set \u03b1} (hc : IsClosed s) (hs : s.Nonempty) (B : BddBelow s) :\n    IsLeast s (sInf s)", "start": [2889, 1], "end": [2891, 44], "kind": "commanddeclaration"}, {"full_name": "IsClosed.isGreatest_csSup", "code": "theorem IsClosed.isGreatest_csSup {s : Set \u03b1} (hc : IsClosed s) (hs : s.Nonempty) (B : BddAbove s) :\n    IsGreatest s (sSup s)", "start": [2893, 1], "end": [2895, 44], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_csSup_of_continuousAt", "code": "theorem Monotone.map_csSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sSup s))\n    (Mf : Monotone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sSup (f '' s)", "start": [2897, 1], "end": [2903, 33], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_ciSup_of_continuousAt", "code": "theorem Monotone.map_ciSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a06 i, g i))\n    (Mf : Monotone f) (H : BddAbove (range g)) : f (\u2a06 i, g i) = \u2a06 i, f (g i)", "start": [2906, 1], "end": [2910, 91], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_csInf_of_continuousAt", "code": "theorem Monotone.map_csInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sInf s))\n    (Mf : Monotone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sInf (f '' s)", "start": [2913, 1], "end": [2917, 75], "kind": "commanddeclaration"}, {"full_name": "Monotone.map_ciInf_of_continuousAt", "code": "theorem Monotone.map_ciInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a05 i, g i))\n    (Mf : Monotone f) (H : BddBelow (range g)) : f (\u2a05 i, g i) = \u2a05 i, f (g i)", "start": [2920, 1], "end": [2924, 72], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_csSup_of_continuousAt", "code": "theorem Antitone.map_csSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sSup s))\n    (Af : Antitone f) (ne : s.Nonempty) (H : BddAbove s) : f (sSup s) = sInf (f '' s)", "start": [2927, 1], "end": [2932, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_ciSup_of_continuousAt", "code": "theorem Antitone.map_ciSup_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a06 i, g i))\n    (Af : Antitone f) (H : BddAbove (range g)) : f (\u2a06 i, g i) = \u2a05 i, f (g i)", "start": [2935, 1], "end": [2940, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_csInf_of_continuousAt", "code": "theorem Antitone.map_csInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (Cf : ContinuousAt f (sInf s))\n    (Af : Antitone f) (ne : s.Nonempty) (H : BddBelow s) : f (sInf s) = sSup (f '' s)", "start": [2943, 1], "end": [2948, 9], "kind": "commanddeclaration"}, {"full_name": "Antitone.map_ciInf_of_continuousAt", "code": "theorem Antitone.map_ciInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a05 i, g i))\n    (Af : Antitone f) (H : BddBelow (range g)) : f (\u2a05 i, g i) = \u2a06 i, f (g i)", "start": [2951, 1], "end": [2956, 9], "kind": "commanddeclaration"}, {"full_name": "Monotone.tendsto_nhdsWithin_Iio", "code": "theorem Monotone.tendsto_nhdsWithin_Iio {\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b2] [TopologicalSpace \u03b2] [OrderTopology \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (Mf : Monotone f) (x : \u03b1) : Tendsto f (\ud835\udcdd[<] x) (\ud835\udcdd (sSup (f '' Iio x)))", "start": [2959, 1], "end": [2970, 74], "kind": "commanddeclaration"}, {"full_name": "Monotone.tendsto_nhdsWithin_Ioi", "code": "theorem Monotone.tendsto_nhdsWithin_Ioi {\u03b1 \u03b2 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1]\n    [OrderTopology \u03b1] [ConditionallyCompleteLinearOrder \u03b2] [TopologicalSpace \u03b2] [OrderTopology \u03b2]\n    {f : \u03b1 \u2192 \u03b2} (Mf : Monotone f) (x : \u03b1) : Tendsto f (\ud835\udcdd[>] x) (\ud835\udcdd (sInf (f '' Ioi x)))", "start": [2973, 1], "end": [2977, 66], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_pos_mem_Ioo", "code": "@[deprecated Ioo_mem_nhdsWithin_Ioi']\ntheorem eventually_nhdsWithin_pos_mem_Ioo {\u03b5 : \u03b1} (h : 0 < \u03b5) : \u2200\u1da0 x in \ud835\udcdd[>] 0, x \u2208 Ioo 0 \u03b5", "start": [2988, 1], "end": [2990, 28], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_pos_mem_Ioc", "code": "@[deprecated Ioc_mem_nhdsWithin_Ioi']\ntheorem eventually_nhdsWithin_pos_mem_Ioc {\u03b5 : \u03b1} (h : 0 < \u03b5) : \u2200\u1da0 x in \ud835\udcdd[>] 0, x \u2208 Ioc 0 \u03b5", "start": [2993, 1], "end": [2995, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/NNReal.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Algebra/Order/Field/Canonical/Basic.lean", "Mathlib/Tactic/GCongr/Core.lean", "Mathlib/Algebra/Order/Nonneg/Field.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Basic.lean", "Mathlib/Algebra/Order/Nonneg/Floor.lean", "Mathlib/Order/ConditionallyCompleteLattice/Group.lean", "Mathlib/Data/Real/Pointwise.lean"], "premises": [{"full_name": "NNReal", "code": "def NNReal := { r : \u211d // 0 \u2264 r } deriving\n  Zero, One, Semiring, StrictOrderedSemiring, CommMonoidWithZero, CommSemiring,\n  SemilatticeInf, SemilatticeSup, DistribLattice, OrderedCommSemiring,\n  CanonicallyOrderedCommSemiring, Inhabited", "start": [58, 1], "end": [62, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.toReal", "code": "@[coe] def toReal : \u211d\u22650 \u2192 \u211d := Subtype.val", "start": [80, 1], "end": [81, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.val_eq_coe", "code": "@[simp]\ntheorem val_eq_coe (n : \u211d\u22650) : n.val = n", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.canLift", "code": "instance canLift : CanLift \u211d \u211d\u22650 toReal fun r => 0 \u2264 r :=\n  Subtype.canLift _", "start": [91, 1], "end": [92, 20], "kind": "commanddeclaration"}, {"full_name": "NNReal.eq", "code": "@[ext] protected theorem eq {n m : \u211d\u22650} : (n : \u211d) = (m : \u211d) \u2192 n = m", "start": [95, 1], "end": [96, 13], "kind": "commanddeclaration"}, {"full_name": "NNReal.eq_iff", "code": "protected theorem eq_iff {n m : \u211d\u22650} : (n : \u211d) = (m : \u211d) \u2194 n = m", "start": [99, 1], "end": [100, 23], "kind": "commanddeclaration"}, {"full_name": "NNReal.ne_iff", "code": "theorem ne_iff {x y : \u211d\u22650} : (x : \u211d) \u2260 (y : \u211d) \u2194 x \u2260 y", "start": [103, 1], "end": [104, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.forall", "code": "protected theorem \u00abforall\u00bb {p : \u211d\u22650 \u2192 Prop} :\n    (\u2200 x : \u211d\u22650, p x) \u2194 \u2200 (x : \u211d) (hx : 0 \u2264 x), p \u27e8x, hx\u27e9", "start": [107, 1], "end": [109, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists", "code": "protected theorem \u00abexists\u00bb {p : \u211d\u22650 \u2192 Prop} :\n    (\u2203 x : \u211d\u22650, p x) \u2194 \u2203 (x : \u211d) (hx : 0 \u2264 x), p \u27e8x, hx\u27e9", "start": [112, 1], "end": [114, 17], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal", "code": "noncomputable def _root_.Real.toNNReal (r : \u211d) : \u211d\u22650 :=\n  \u27e8max r 0, le_max_right _ _\u27e9", "start": [117, 1], "end": [119, 30], "kind": "commanddeclaration"}, {"full_name": "Real.coe_toNNReal", "code": "theorem _root_.Real.coe_toNNReal (r : \u211d) (hr : 0 \u2264 r) : (Real.toNNReal r : \u211d) = r", "start": [122, 1], "end": [123, 17], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_of_nonneg", "code": "theorem _root_.Real.toNNReal_of_nonneg {r : \u211d} (hr : 0 \u2264 r) : r.toNNReal = \u27e8r, hr\u27e9", "start": [126, 1], "end": [127, 42], "kind": "commanddeclaration"}, {"full_name": "Real.le_coe_toNNReal", "code": "theorem _root_.Real.le_coe_toNNReal (r : \u211d) : r \u2264 Real.toNNReal r", "start": [130, 1], "end": [131, 18], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_nonneg", "code": "theorem coe_nonneg (r : \u211d\u22650) : (0 : \u211d) \u2264 r", "start": [134, 1], "end": [134, 50], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_mk", "code": "@[simp, norm_cast] theorem coe_mk (a : \u211d) (ha) : toReal \u27e8a, ha\u27e9 = a", "start": [137, 1], "end": [137, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_injective", "code": "protected theorem coe_injective : Injective ((\u2191) : \u211d\u22650 \u2192 \u211d)", "start": [162, 1], "end": [162, 85], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_eq", "code": "@[simp, norm_cast]\nprotected theorem coe_eq {r\u2081 r\u2082 : \u211d\u22650} : (r\u2081 : \u211d) = r\u2082 \u2194 r\u2081 = r\u2082", "start": [165, 1], "end": [167, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_zero", "code": "@[simp, norm_cast]\nprotected theorem coe_zero : ((0 : \u211d\u22650) : \u211d) = 0", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_one", "code": "@[simp, norm_cast]\nprotected theorem coe_one : ((1 : \u211d\u22650) : \u211d) = 1", "start": [175, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_add", "code": "@[simp, norm_cast]\nprotected theorem coe_add (r\u2081 r\u2082 : \u211d\u22650) : ((r\u2081 + r\u2082 : \u211d\u22650) : \u211d) = r\u2081 + r\u2082", "start": [180, 1], "end": [182, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_mul", "code": "@[simp, norm_cast]\nprotected theorem coe_mul (r\u2081 r\u2082 : \u211d\u22650) : ((r\u2081 * r\u2082 : \u211d\u22650) : \u211d) = r\u2081 * r\u2082", "start": [185, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_inv", "code": "@[simp, norm_cast]\nprotected theorem coe_inv (r : \u211d\u22650) : ((r\u207b\u00b9 : \u211d\u22650) : \u211d) = (r : \u211d)\u207b\u00b9", "start": [190, 1], "end": [192, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_div", "code": "@[simp, norm_cast]\nprotected theorem coe_div (r\u2081 r\u2082 : \u211d\u22650) : ((r\u2081 / r\u2082 : \u211d\u22650) : \u211d) = (r\u2081 : \u211d) / r\u2082", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_two", "code": "protected theorem coe_two : ((2 : \u211d\u22650) : \u211d) = 2", "start": [203, 1], "end": [203, 55], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_sub", "code": "@[simp, norm_cast]\nprotected theorem coe_sub {r\u2081 r\u2082 : \u211d\u22650} (h : r\u2082 \u2264 r\u2081) : ((r\u2081 - r\u2082 : \u211d\u22650) : \u211d) = \u2191r\u2081 - \u2191r\u2082", "start": [206, 1], "end": [208, 70], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_eq_zero", "code": "@[simp, norm_cast]\nprotected theorem coe_eq_zero (r : \u211d\u22650) : \u2191r = (0 : \u211d) \u2194 r = 0", "start": [211, 1], "end": [213, 40], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_eq_one", "code": "@[simp, norm_cast]\nprotected theorem coe_eq_one (r : \u211d\u22650) : \u2191r = (1 : \u211d) \u2194 r = 1", "start": [216, 1], "end": [218, 39], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_ne_zero", "code": "theorem coe_ne_zero {r : \u211d\u22650} : (r : \u211d) \u2260 0 \u2194 r \u2260 0", "start": [222, 1], "end": [222, 73], "kind": "commanddeclaration"}, {"full_name": "NNReal.toRealHom", "code": "def toRealHom : \u211d\u22650 \u2192+* \u211d where\n  toFun := (\u2191)\n  map_one' := NNReal.coe_one\n  map_mul' := NNReal.coe_mul\n  map_zero' := NNReal.coe_zero\n  map_add' := NNReal.coe_add", "start": [227, 1], "end": [235, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_toRealHom", "code": "@[simp] theorem coe_toRealHom : \u21d1toRealHom = toReal", "start": [238, 1], "end": [238, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.smul_def", "code": "theorem smul_def {M : Type*} [MulAction \u211d M] (c : \u211d\u22650) (x : M) : c \u2022 x = (c : \u211d) \u2022 x", "start": [247, 1], "end": [248, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.smulCommClass_left", "code": "instance smulCommClass_left {M N : Type*} [MulAction \u211d N] [SMul M N] [SMulCommClass \u211d M N] :\n    SMulCommClass \u211d\u22650 M N where smul_comm r := (smul_comm (r : \u211d) : _)", "start": [254, 1], "end": [255, 71], "kind": "commanddeclaration"}, {"full_name": "NNReal.smulCommClass_right", "code": "instance smulCommClass_right {M N : Type*} [MulAction \u211d N] [SMul M N] [SMulCommClass M \u211d N] :\n    SMulCommClass M \u211d\u22650 N where smul_comm m r := (smul_comm m (r : \u211d) : _)", "start": [258, 1], "end": [259, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_indicator", "code": "@[simp, norm_cast]\ntheorem coe_indicator {\u03b1} (s : Set \u03b1) (f : \u03b1 \u2192 \u211d\u22650) (a : \u03b1) :\n    ((s.indicator f a : \u211d\u22650) : \u211d) = s.indicator (fun x => \u2191(f x)) a", "start": [291, 1], "end": [294, 45], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (r : \u211d\u22650) (n : \u2115) : ((r ^ n : \u211d\u22650) : \u211d) = (r : \u211d) ^ n", "start": [297, 1], "end": [298, 77], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_zpow", "code": "@[simp, norm_cast]\ntheorem coe_zpow (r : \u211d\u22650) (n : \u2124) : ((r ^ n : \u211d\u22650) : \u211d) = (r : \u211d) ^ n", "start": [301, 1], "end": [302, 78], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_list_sum", "code": "@[norm_cast]\ntheorem coe_list_sum (l : List \u211d\u22650) : ((l.sum : \u211d\u22650) : \u211d) = (l.map (\u2191)).sum", "start": [305, 1], "end": [307, 27], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_list_prod", "code": "@[norm_cast]\ntheorem coe_list_prod (l : List \u211d\u22650) : ((l.prod : \u211d\u22650) : \u211d) = (l.map (\u2191)).prod", "start": [310, 1], "end": [312, 28], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_multiset_sum", "code": "@[norm_cast]\ntheorem coe_multiset_sum (s : Multiset \u211d\u22650) : ((s.sum : \u211d\u22650) : \u211d) = (s.map (\u2191)).sum", "start": [315, 1], "end": [317, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_multiset_prod", "code": "@[norm_cast]\ntheorem coe_multiset_prod (s : Multiset \u211d\u22650) : ((s.prod : \u211d\u22650) : \u211d) = (s.map (\u2191)).prod", "start": [320, 1], "end": [322, 32], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_sum", "code": "@[norm_cast]\ntheorem coe_sum {\u03b1} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650} : \u2191(\u2211 a in s, f a) = \u2211 a in s, (f a : \u211d)", "start": [325, 1], "end": [327, 24], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_sum_of_nonneg", "code": "theorem _root_.Real.toNNReal_sum_of_nonneg {\u03b1} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d}\n    (hf : \u2200 a, a \u2208 s \u2192 0 \u2264 f a) :\n    Real.toNNReal (\u2211 a in s, f a) = \u2211 a in s, Real.toNNReal (f a)", "start": [330, 1], "end": [334, 81], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_prod", "code": "@[norm_cast]\ntheorem coe_prod {\u03b1} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650} : \u2191(\u220f a in s, f a) = \u220f a in s, (f a : \u211d)", "start": [337, 1], "end": [339, 25], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_prod_of_nonneg", "code": "theorem _root_.Real.toNNReal_prod_of_nonneg {\u03b1} {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d}\n    (hf : \u2200 a, a \u2208 s \u2192 0 \u2264 f a) :\n    Real.toNNReal (\u220f a in s, f a) = \u220f a in s, Real.toNNReal (f a)", "start": [342, 1], "end": [346, 82], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_nsmul", "code": "theorem coe_nsmul (r : \u211d\u22650) (n : \u2115) : \u2191(n \u2022 r) = n \u2022 (r : \u211d)", "start": [350, 1], "end": [350, 68], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_nat_cast", "code": "@[simp, norm_cast]\nprotected theorem coe_nat_cast (n : \u2115) : (\u2191(\u2191n : \u211d\u22650) : \u211d) = n", "start": [353, 1], "end": [355, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_ofNat", "code": "@[simp, norm_cast]\nprotected theorem coe_ofNat (n : \u2115) [n.AtLeastTwo] :\n    (no_index (OfNat.ofNat n : \u211d\u22650) : \u211d) = OfNat.ofNat n", "start": [358, 1], "end": [361, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_le_coe", "code": "@[simp, norm_cast]\nprotected theorem coe_le_coe {r\u2081 r\u2082 : \u211d\u22650} : (r\u2081 : \u211d) \u2264 r\u2082 \u2194 r\u2081 \u2264 r\u2082", "start": [365, 1], "end": [367, 10], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_lt_coe", "code": "@[simp, norm_cast]\nprotected theorem coe_lt_coe {r\u2081 r\u2082 : \u211d\u22650} : (r\u2081 : \u211d) < r\u2082 \u2194 r\u2081 < r\u2082", "start": [370, 1], "end": [372, 10], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_pos", "code": "@[simp, norm_cast]\nprotected theorem coe_pos {r : \u211d\u22650} : (0 : \u211d) < r \u2194 0 < r", "start": [375, 1], "end": [377, 10], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_mono", "code": "protected theorem coe_mono : Monotone ((\u2191) : \u211d\u22650 \u2192 \u211d)", "start": [380, 1], "end": [380, 88], "kind": "commanddeclaration"}, {"full_name": "NNReal.toReal_le_toReal", "code": "@[gcongr]\ntheorem _root_.NNReal.toReal_le_toReal {x y : NNReal} (h : x \u2264 y) : (x : \u211d) \u2264 y", "start": [383, 1], "end": [384, 101], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_mono", "code": "protected theorem _root_.Real.toNNReal_mono : Monotone Real.toNNReal", "start": [386, 1], "end": [387, 27], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_coe", "code": "@[simp]\ntheorem _root_.Real.toNNReal_coe {r : \u211d\u22650} : Real.toNNReal r = r", "start": [390, 1], "end": [392, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.mk_coe_nat", "code": "@[simp]\ntheorem mk_coe_nat (n : \u2115) : @Eq \u211d\u22650 (\u27e8(n : \u211d), n.cast_nonneg\u27e9 : \u211d\u22650) n", "start": [395, 1], "end": [397, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.toNNReal_coe_nat", "code": "@[simp]\ntheorem toNNReal_coe_nat (n : \u2115) : Real.toNNReal n = n", "start": [401, 1], "end": [403, 43], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_ofNat", "code": "@[simp]\ntheorem _root_.Real.toNNReal_ofNat (n : \u2115) [n.AtLeastTwo] :\n    Real.toNNReal (no_index (OfNat.ofNat n)) = OfNat.ofNat n", "start": [406, 1], "end": [409, 21], "kind": "commanddeclaration"}, {"full_name": "NNReal.gi", "code": "noncomputable def gi : GaloisInsertion Real.toNNReal (\u2191) :=\n  GaloisInsertion.monotoneIntro NNReal.coe_mono Real.toNNReal_mono Real.le_coe_toNNReal fun _ =>\n    Real.toNNReal_coe", "start": [411, 1], "end": [414, 22], "kind": "commanddeclaration"}, {"full_name": "NNReal.orderIsoIccZeroCoe", "code": "def orderIsoIccZeroCoe (a : \u211d\u22650) : Set.Icc (0 : \u211d) a \u2243o Set.Iic a where\n  toEquiv := Equiv.Set.sep (Set.Ici 0) fun x : \u211d => x \u2264 a\n  map_rel_iff' := Iff.rfl", "start": [449, 1], "end": [454, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.orderIsoIccZeroCoe_apply_coe_coe", "code": "@[simp]\ntheorem orderIsoIccZeroCoe_apply_coe_coe (a : \u211d\u22650) (b : Set.Icc (0 : \u211d) a) :\n    (orderIsoIccZeroCoe a b : \u211d) = b", "start": [457, 1], "end": [460, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.orderIsoIccZeroCoe_symm_apply_coe", "code": "@[simp]\ntheorem orderIsoIccZeroCoe_symm_apply_coe (a : \u211d\u22650) (b : Set.Iic a) :\n    ((orderIsoIccZeroCoe a).symm b : \u211d) = b", "start": [462, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_image", "code": "theorem coe_image {s : Set \u211d\u22650} :\n    (\u2191) '' s = { x : \u211d | \u2203 h : 0 \u2264 x, @Membership.mem \u211d\u22650 _ _ \u27e8x, h\u27e9 s }", "start": [469, 1], "end": [471, 20], "kind": "commanddeclaration"}, {"full_name": "NNReal.bddAbove_coe", "code": "theorem bddAbove_coe {s : Set \u211d\u22650} : BddAbove (((\u2191) : \u211d\u22650 \u2192 \u211d) '' s) \u2194 BddAbove s", "start": [474, 1], "end": [479, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.bddBelow_coe", "code": "theorem bddBelow_coe (s : Set \u211d\u22650) : BddBelow (((\u2191) : \u211d\u22650 \u2192 \u211d) '' s)", "start": [482, 1], "end": [483, 36], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_sSup", "code": "@[norm_cast]\ntheorem coe_sSup (s : Set \u211d\u22650) : (\u2191(sSup s) : \u211d) = sSup (((\u2191) : \u211d\u22650 \u2192 \u211d) '' s)", "start": [489, 1], "end": [502, 27], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_iSup", "code": "@[simp, norm_cast] theorem coe_iSup {\u03b9 : Sort*} (s : \u03b9 \u2192 \u211d\u22650) : (\u2191(\u2a06 i, s i) : \u211d) = \u2a06 i, \u2191(s i)", "start": [505, 1], "end": [507, 51], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_sInf", "code": "@[norm_cast]\ntheorem coe_sInf (s : Set \u211d\u22650) : (\u2191(sInf s) : \u211d) = sInf (((\u2191) : \u211d\u22650 \u2192 \u211d) '' s)", "start": [510, 1], "end": [519, 95], "kind": "commanddeclaration"}, {"full_name": "NNReal.sInf_empty", "code": "@[simp]\ntheorem sInf_empty : sInf (\u2205 : Set \u211d\u22650) = 0", "start": [522, 1], "end": [524, 72], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_iInf", "code": "@[norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} (s : \u03b9 \u2192 \u211d\u22650) : (\u2191(\u2a05 i, s i) : \u211d) = \u2a05 i, \u2191(s i)", "start": [527, 1], "end": [529, 51], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_iInf_add_iInf", "code": "theorem le_iInf_add_iInf {\u03b9 \u03b9' : Sort*} [Nonempty \u03b9] [Nonempty \u03b9'] {f : \u03b9 \u2192 \u211d\u22650} {g : \u03b9' \u2192 \u211d\u22650}\n    {a : \u211d\u22650} (h : \u2200 i j, a \u2264 f i + g j) : a \u2264 (\u2a05 i, f i) + \u2a05 j, g j", "start": [532, 1], "end": [535, 29], "kind": "commanddeclaration"}, {"full_name": "NNReal.covariant_add", "code": "instance covariant_add : CovariantClass \u211d\u22650 \u211d\u22650 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) := inferInstance", "start": [541, 1], "end": [541, 81], "kind": "commanddeclaration"}, {"full_name": "NNReal.contravariant_add", "code": "instance contravariant_add : ContravariantClass \u211d\u22650 \u211d\u22650 (\u00b7 + \u00b7) (\u00b7 < \u00b7) := inferInstance", "start": [544, 1], "end": [544, 89], "kind": "commanddeclaration"}, {"full_name": "NNReal.covariant_mul", "code": "instance covariant_mul : CovariantClass \u211d\u22650 \u211d\u22650 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) := inferInstance", "start": [547, 1], "end": [547, 81], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_of_forall_pos_le_add", "code": "nonrec theorem le_of_forall_pos_le_add {a b : \u211d\u22650} (h : \u2200 \u03b5, 0 < \u03b5 \u2192 a \u2264 b + \u03b5) : a \u2264 b", "start": [551, 1], "end": [552, 28], "kind": "commanddeclaration"}, {"full_name": "NNReal.lt_iff_exists_rat_btwn", "code": "theorem lt_iff_exists_rat_btwn (a b : \u211d\u22650) :\n    a < b \u2194 \u2203 q : \u211a, 0 \u2264 q \u2227 a < Real.toNNReal q \u2227 Real.toNNReal q < b", "start": [555, 1], "end": [563, 45], "kind": "commanddeclaration"}, {"full_name": "NNReal.bot_eq_zero", "code": "theorem bot_eq_zero : (\u22a5 : \u211d\u22650) = 0", "start": [566, 1], "end": [566, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_sup", "code": "theorem mul_sup (a b c : \u211d\u22650) : a * (b \u2294 c) = a * b \u2294 a * c", "start": [569, 1], "end": [570, 37], "kind": "commanddeclaration"}, {"full_name": "NNReal.sup_mul", "code": "theorem sup_mul (a b c : \u211d\u22650) : (a \u2294 b) * c = a * c \u2294 b * c", "start": [573, 1], "end": [574, 37], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_finset_sup", "code": "theorem mul_finset_sup {\u03b1} (r : \u211d\u22650) (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d\u22650) :\n    r * s.sup f = s.sup fun a => r * f a", "start": [577, 1], "end": [579, 64], "kind": "commanddeclaration"}, {"full_name": "NNReal.finset_sup_mul", "code": "theorem finset_sup_mul {\u03b1} (s : Finset \u03b1) (f : \u03b1 \u2192 \u211d\u22650) (r : \u211d\u22650) :\n    s.sup f * r = s.sup fun a => f a * r", "start": [582, 1], "end": [584, 85], "kind": "commanddeclaration"}, {"full_name": "NNReal.finset_sup_div", "code": "theorem finset_sup_div {\u03b1} {f : \u03b1 \u2192 \u211d\u22650} {s : Finset \u03b1} (r : \u211d\u22650) :\n    s.sup f / r = s.sup fun a => f a / r", "start": [587, 1], "end": [588, 90], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max (x y : \u211d\u22650) : ((max x y : \u211d\u22650) : \u211d) = max (x : \u211d) (y : \u211d)", "start": [591, 1], "end": [593, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min (x y : \u211d\u22650) : ((min x y : \u211d\u22650) : \u211d) = min (x : \u211d) (y : \u211d)", "start": [596, 1], "end": [598, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.zero_le_coe", "code": "@[simp]\ntheorem zero_le_coe {q : \u211d\u22650} : 0 \u2264 (q : \u211d)", "start": [601, 1], "end": [603, 6], "kind": "commanddeclaration"}, {"full_name": "Real.coe_toNNReal'", "code": "@[simp]\ntheorem coe_toNNReal' (r : \u211d) : (Real.toNNReal r : \u211d) = max r 0", "start": [614, 1], "end": [616, 6], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_zero", "code": "@[simp]\ntheorem toNNReal_zero : Real.toNNReal 0 = 0", "start": [619, 1], "end": [620, 82], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_one", "code": "@[simp]\ntheorem toNNReal_one : Real.toNNReal 1 = 1", "start": [623, 1], "end": [624, 86], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_pos", "code": "@[simp]\ntheorem toNNReal_pos {r : \u211d} : 0 < Real.toNNReal r \u2194 0 < r", "start": [627, 1], "end": [629, 40], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_eq_zero", "code": "@[simp]\ntheorem toNNReal_eq_zero {r : \u211d} : Real.toNNReal r = 0 \u2194 r \u2264 0", "start": [632, 1], "end": [634, 62], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_of_nonpos", "code": "theorem toNNReal_of_nonpos {r : \u211d} : r \u2264 0 \u2192 Real.toNNReal r = 0", "start": [637, 1], "end": [638, 21], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_le_toNNReal_iff", "code": "@[simp]\ntheorem toNNReal_le_toNNReal_iff {r p : \u211d} (hp : 0 \u2264 p) :\n    toNNReal r \u2264 toNNReal p \u2194 r \u2264 p", "start": [641, 1], "end": [643, 73], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_eq_toNNReal_iff", "code": "@[simp]\ntheorem toNNReal_eq_toNNReal_iff {r p : \u211d} (hr : 0 \u2264 r) (hp : 0 \u2264 p) :\n    toNNReal r = toNNReal p \u2194 r = p", "start": [646, 1], "end": [648, 87], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_lt_toNNReal_iff'", "code": "@[simp]\ntheorem toNNReal_lt_toNNReal_iff' {r p : \u211d} : Real.toNNReal r < Real.toNNReal p \u2194 r < p \u2227 0 < p", "start": [651, 1], "end": [653, 51], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_lt_toNNReal_iff", "code": "theorem toNNReal_lt_toNNReal_iff {r p : \u211d} (h : 0 < p) :\n    Real.toNNReal r < Real.toNNReal p \u2194 r < p", "start": [656, 1], "end": [658, 51], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_lt_toNNReal_iff_of_nonneg", "code": "theorem toNNReal_lt_toNNReal_iff_of_nonneg {r p : \u211d} (hr : 0 \u2264 r) :\n    Real.toNNReal r < Real.toNNReal p \u2194 r < p", "start": [661, 1], "end": [663, 80], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_add", "code": "@[simp]\ntheorem toNNReal_add {r p : \u211d} (hr : 0 \u2264 r) (hp : 0 \u2264 p) :\n    Real.toNNReal (r + p) = Real.toNNReal r + Real.toNNReal p", "start": [666, 1], "end": [669, 44], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_add_toNNReal", "code": "theorem toNNReal_add_toNNReal {r p : \u211d} (hr : 0 \u2264 r) (hp : 0 \u2264 p) :\n    Real.toNNReal r + Real.toNNReal p = Real.toNNReal (r + p)", "start": [672, 1], "end": [674, 33], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_le_toNNReal", "code": "theorem toNNReal_le_toNNReal {r p : \u211d} (h : r \u2264 p) : Real.toNNReal r \u2264 Real.toNNReal p", "start": [677, 1], "end": [678, 23], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_add_le", "code": "theorem toNNReal_add_le {r p : \u211d} : Real.toNNReal (r + p) \u2264 Real.toNNReal r + Real.toNNReal p", "start": [681, 1], "end": [682, 100], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_le_iff_le_coe", "code": "theorem toNNReal_le_iff_le_coe {r : \u211d} {p : \u211d\u22650} : toNNReal r \u2264 p \u2194 r \u2264 \u2191p", "start": [685, 1], "end": [686, 19], "kind": "commanddeclaration"}, {"full_name": "Real.le_toNNReal_iff_coe_le", "code": "theorem le_toNNReal_iff_coe_le {r : \u211d\u22650} {p : \u211d} (hp : 0 \u2264 p) : r \u2264 Real.toNNReal p \u2194 \u2191r \u2264 p", "start": [689, 1], "end": [690, 51], "kind": "commanddeclaration"}, {"full_name": "Real.le_toNNReal_iff_coe_le'", "code": "theorem le_toNNReal_iff_coe_le' {r : \u211d\u22650} {p : \u211d} (hr : 0 < r) : r \u2264 Real.toNNReal p \u2194 \u2191r \u2264 p", "start": [693, 1], "end": [695, 87], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_lt_iff_lt_coe", "code": "theorem toNNReal_lt_iff_lt_coe {r : \u211d} {p : \u211d\u22650} (ha : 0 \u2264 r) : Real.toNNReal r < p \u2194 r < \u2191p", "start": [698, 1], "end": [699, 51], "kind": "commanddeclaration"}, {"full_name": "Real.lt_toNNReal_iff_coe_lt", "code": "theorem lt_toNNReal_iff_coe_lt {r : \u211d\u22650} {p : \u211d} : r < Real.toNNReal p \u2194 \u2191r < p", "start": [702, 1], "end": [703, 48], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_pow", "code": "theorem toNNReal_pow {x : \u211d} (hx : 0 \u2264 x) (n : \u2115) : (x ^ n).toNNReal = x.toNNReal ^ n", "start": [709, 1], "end": [711, 28], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_mul", "code": "theorem toNNReal_mul {p q : \u211d} (hp : 0 \u2264 p) :\n    Real.toNNReal (p * q) = Real.toNNReal p * Real.toNNReal q", "start": [714, 1], "end": [716, 47], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_eq_mul_left", "code": "theorem mul_eq_mul_left {a b c : \u211d\u22650} (h : a \u2260 0) : a * b = a * c \u2194 b = c", "start": [729, 1], "end": [730, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.pow_antitone_exp", "code": "theorem pow_antitone_exp {a : \u211d\u22650} (m n : \u2115) (mn : m \u2264 n) (a1 : a \u2264 1) : a ^ n \u2264 a ^ m", "start": [737, 1], "end": [738, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists_pow_lt_of_lt_one", "code": "nonrec theorem exists_pow_lt_of_lt_one {a b : \u211d\u22650} (ha : 0 < a) (hb : b < 1) :\n    \u2203 n : \u2115, b ^ n < a", "start": [741, 1], "end": [744, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists_mem_Ico_zpow", "code": "nonrec theorem exists_mem_Ico_zpow {x : \u211d\u22650} {y : \u211d\u22650} (hx : x \u2260 0) (hy : 1 < y) :\n    \u2203 n : \u2124, x \u2208 Set.Ico (y ^ n) (y ^ (n + 1))", "start": [747, 1], "end": [749, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.exists_mem_Ioc_zpow", "code": "nonrec theorem exists_mem_Ioc_zpow {x : \u211d\u22650} {y : \u211d\u22650} (hx : x \u2260 0) (hy : 1 < y) :\n    \u2203 n : \u2124, x \u2208 Set.Ioc (y ^ n) (y ^ (n + 1))", "start": [752, 1], "end": [754, 44], "kind": "commanddeclaration"}, {"full_name": "NNReal.sub_def", "code": "theorem sub_def {r p : \u211d\u22650} : r - p = Real.toNNReal (r - p)", "start": [769, 1], "end": [770, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.coe_sub_def", "code": "theorem coe_sub_def {r p : \u211d\u22650} : \u2191(r - p) = max (r - p : \u211d) 0", "start": [773, 1], "end": [774, 6], "kind": "commanddeclaration"}, {"full_name": "NNReal.sub_div", "code": "theorem sub_div (a b c : \u211d\u22650) : (a - b) / c = a / c - b / c", "start": [779, 1], "end": [780, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.sum_div", "code": "theorem sum_div {\u03b9} (s : Finset \u03b9) (f : \u03b9 \u2192 \u211d\u22650) (b : \u211d\u22650) :\n    (\u2211 i in s, f i) / b = \u2211 i in s, f i / b", "start": [787, 1], "end": [789, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.inv_le", "code": "@[simp]\ntheorem inv_le {r p : \u211d\u22650} (h : r \u2260 0) : r\u207b\u00b9 \u2264 p \u2194 1 \u2264 r * p", "start": [792, 1], "end": [794, 65], "kind": "commanddeclaration"}, {"full_name": "NNReal.inv_le_of_le_mul", "code": "theorem inv_le_of_le_mul {r p : \u211d\u22650} (h : 1 \u2264 r * p) : r\u207b\u00b9 \u2264 p", "start": [797, 1], "end": [798, 38], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_inv_iff_mul_le", "code": "@[simp]\ntheorem le_inv_iff_mul_le {r p : \u211d\u22650} (h : p \u2260 0) : r \u2264 p\u207b\u00b9 \u2194 r * p \u2264 1", "start": [801, 1], "end": [803, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.lt_inv_iff_mul_lt", "code": "@[simp]\ntheorem lt_inv_iff_mul_lt {r p : \u211d\u22650} (h : p \u2260 0) : r < p\u207b\u00b9 \u2194 r * p < 1", "start": [806, 1], "end": [808, 75], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_le_iff_le_inv", "code": "theorem mul_le_iff_le_inv {a b r : \u211d\u22650} (hr : r \u2260 0) : r * a \u2264 b \u2194 a \u2264 r\u207b\u00b9 * b", "start": [811, 1], "end": [813, 85], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_div_iff_mul_le", "code": "theorem le_div_iff_mul_le {a b r : \u211d\u22650} (hr : r \u2260 0) : a \u2264 b / r \u2194 a * r \u2264 b", "start": [816, 1], "end": [817, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_iff", "code": "theorem div_le_iff {a b r : \u211d\u22650} (hr : r \u2260 0) : a / r \u2264 b \u2194 a \u2264 b * r", "start": [820, 1], "end": [821, 17], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_iff'", "code": "nonrec theorem div_le_iff' {a b r : \u211d\u22650} (hr : r \u2260 0) : a / r \u2264 b \u2194 a \u2264 r * b", "start": [824, 1], "end": [825, 49], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_of_le_mul", "code": "theorem div_le_of_le_mul {a b c : \u211d\u22650} (h : a \u2264 b * c) : a / c \u2264 b", "start": [828, 1], "end": [829, 59], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_of_le_mul'", "code": "theorem div_le_of_le_mul' {a b c : \u211d\u22650} (h : a \u2264 b * c) : a / b \u2264 c", "start": [832, 1], "end": [833, 39], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_div_iff", "code": "nonrec theorem le_div_iff {a b r : \u211d\u22650} (hr : r \u2260 0) : a \u2264 b / r \u2194 a * r \u2264 b", "start": [836, 1], "end": [837, 48], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_div_iff'", "code": "nonrec theorem le_div_iff' {a b r : \u211d\u22650} (hr : r \u2260 0) : a \u2264 b / r \u2194 r * a \u2264 b", "start": [840, 1], "end": [841, 49], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_lt_iff", "code": "theorem div_lt_iff {a b r : \u211d\u22650} (hr : r \u2260 0) : a / r < b \u2194 a < b * r", "start": [844, 1], "end": [845, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_lt_iff'", "code": "theorem div_lt_iff' {a b r : \u211d\u22650} (hr : r \u2260 0) : a / r < b \u2194 a < r * b", "start": [848, 1], "end": [849, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.lt_div_iff", "code": "theorem lt_div_iff {a b r : \u211d\u22650} (hr : r \u2260 0) : a < b / r \u2194 a * r < b", "start": [852, 1], "end": [853, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.lt_div_iff'", "code": "theorem lt_div_iff' {a b r : \u211d\u22650} (hr : r \u2260 0) : a < b / r \u2194 r * a < b", "start": [856, 1], "end": [857, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_lt_of_lt_div", "code": "theorem mul_lt_of_lt_div {a b r : \u211d\u22650} (h : a < b / r) : a * r < b", "start": [860, 1], "end": [861, 61], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_div_left_of_le", "code": "theorem div_le_div_left_of_le {a b c : \u211d\u22650} (c0 : c \u2260 0) (cb : c \u2264 b) :\n    a / b \u2264 a / c", "start": [865, 1], "end": [867, 49], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_le_div_left", "code": "nonrec theorem div_le_div_left {a b c : \u211d\u22650} (a0 : 0 < a) (b0 : 0 < b) (c0 : 0 < c) :\n    a / b \u2264 a / c \u2194 c \u2264 b", "start": [870, 1], "end": [872, 27], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_of_forall_lt_one_mul_le", "code": "theorem le_of_forall_lt_one_mul_le {x y : \u211d\u22650} (h : \u2200 a < 1, a * x \u2264 y) : x \u2264 y", "start": [875, 1], "end": [881, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.half_le_self", "code": "nonrec theorem half_le_self (a : \u211d\u22650) : a / 2 \u2264 a", "start": [884, 1], "end": [885, 22], "kind": "commanddeclaration"}, {"full_name": "NNReal.half_lt_self", "code": "nonrec theorem half_lt_self {a : \u211d\u22650} (h : a \u2260 0) : a / 2 < a", "start": [888, 1], "end": [889, 24], "kind": "commanddeclaration"}, {"full_name": "NNReal.div_lt_one_of_lt", "code": "theorem div_lt_one_of_lt {a b : \u211d\u22650} (h : a < b) : a / b < 1", "start": [892, 1], "end": [894, 48], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_inv", "code": "theorem _root_.Real.toNNReal_inv {x : \u211d} : Real.toNNReal x\u207b\u00b9 = (Real.toNNReal x)\u207b\u00b9", "start": [897, 1], "end": [901, 85], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_div", "code": "theorem _root_.Real.toNNReal_div {x y : \u211d} (hx : 0 \u2264 x) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y", "start": [904, 1], "end": [906, 83], "kind": "commanddeclaration"}, {"full_name": "Real.toNNReal_div'", "code": "theorem _root_.Real.toNNReal_div' {x y : \u211d} (hy : 0 \u2264 y) :\n    Real.toNNReal (x / y) = Real.toNNReal x / Real.toNNReal y", "start": [909, 1], "end": [911, 94], "kind": "commanddeclaration"}, {"full_name": "NNReal.inv_lt_one_iff", "code": "theorem inv_lt_one_iff {x : \u211d\u22650} (hx : x \u2260 0) : x\u207b\u00b9 < 1 \u2194 1 < x", "start": [914, 1], "end": [915, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.zpow_pos", "code": "theorem zpow_pos {x : \u211d\u22650} (hx : x \u2260 0) (n : \u2124) : 0 < x ^ n", "start": [918, 1], "end": [919, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.inv_lt_inv", "code": "theorem inv_lt_inv {x y : \u211d\u22650} (hx : x \u2260 0) (h : x < y) : y\u207b\u00b9 < x\u207b\u00b9", "start": [922, 1], "end": [923, 31], "kind": "commanddeclaration"}, {"full_name": "NNReal.abs_eq", "code": "@[simp]\ntheorem abs_eq (x : \u211d\u22650) : |(x : \u211d)| = x", "start": [928, 1], "end": [930, 27], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_toNNReal_of_coe_le", "code": "theorem le_toNNReal_of_coe_le {x : \u211d\u22650} {y : \u211d} (h : \u2191x \u2264 y) : x \u2264 y.toNNReal", "start": [939, 1], "end": [940, 46], "kind": "commanddeclaration"}, {"full_name": "NNReal.sSup_of_not_bddAbove", "code": "nonrec theorem sSup_of_not_bddAbove {s : Set \u211d\u22650} (hs : \u00acBddAbove s) : SupSet.sSup s = 0", "start": [943, 1], "end": [946, 32], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_of_not_bddAbove", "code": "theorem iSup_of_not_bddAbove (hf : \u00acBddAbove (range f)) : \u2a06 i, f i = 0", "start": [949, 1], "end": [950, 26], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_empty", "code": "theorem iSup_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u211d\u22650) : \u2a06 i, f i = 0", "start": [953, 1], "end": [953, 80], "kind": "commanddeclaration"}, {"full_name": "NNReal.iInf_empty", "code": "theorem iInf_empty [IsEmpty \u03b9] (f : \u03b9 \u2192 \u211d\u22650) : \u2a05 i, f i = 0", "start": [955, 1], "end": [956, 34], "kind": "commanddeclaration"}, {"full_name": "NNReal.iInf_const_zero", "code": "@[simp]\ntheorem iInf_const_zero {\u03b1 : Sort*} : \u2a05 _ : \u03b1, (0 : \u211d\u22650) = 0", "start": [959, 1], "end": [962, 30], "kind": "commanddeclaration"}, {"full_name": "NNReal.iInf_mul", "code": "theorem iInf_mul (f : \u03b9 \u2192 \u211d\u22650) (a : \u211d\u22650) : iInf f * a = \u2a05 i, f i * a", "start": [965, 1], "end": [967, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_iInf", "code": "theorem mul_iInf (f : \u03b9 \u2192 \u211d\u22650) (a : \u211d\u22650) : a * iInf f = \u2a05 i, a * f i", "start": [970, 1], "end": [971, 43], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_iSup", "code": "theorem mul_iSup (f : \u03b9 \u2192 \u211d\u22650) (a : \u211d\u22650) : (a * \u2a06 i, f i) = \u2a06 i, a * f i", "start": [974, 1], "end": [976, 56], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_mul", "code": "theorem iSup_mul (f : \u03b9 \u2192 \u211d\u22650) (a : \u211d\u22650) : (\u2a06 i, f i) * a = \u2a06 i, f i * a", "start": [979, 1], "end": [981, 21], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_div", "code": "theorem iSup_div (f : \u03b9 \u2192 \u211d\u22650) (a : \u211d\u22650) : (\u2a06 i, f i) / a = \u2a06 i, f i / a", "start": [984, 1], "end": [985, 39], "kind": "commanddeclaration"}, {"full_name": "NNReal.mul_iSup_le", "code": "theorem mul_iSup_le {a : \u211d\u22650} {g : \u211d\u22650} {h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 j, g * h j \u2264 a) : g * iSup h \u2264 a", "start": [989, 1], "end": [991, 20], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_mul_le", "code": "theorem iSup_mul_le {a : \u211d\u22650} {g : \u03b9 \u2192 \u211d\u22650} {h : \u211d\u22650} (H : \u2200 i, g i * h \u2264 a) : iSup g * h \u2264 a", "start": [995, 1], "end": [997, 20], "kind": "commanddeclaration"}, {"full_name": "NNReal.iSup_mul_iSup_le", "code": "theorem iSup_mul_iSup_le {a : \u211d\u22650} {g h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 i j, g i * h j \u2264 a) :\n    iSup g * iSup h \u2264 a", "start": [1001, 1], "end": [1003, 42], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_mul_iInf", "code": "theorem le_mul_iInf {a : \u211d\u22650} {g : \u211d\u22650} {h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 j, a \u2264 g * h j) : a \u2264 g * iInf h", "start": [1008, 1], "end": [1010, 19], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_iInf_mul", "code": "theorem le_iInf_mul {a : \u211d\u22650} {g : \u03b9 \u2192 \u211d\u22650} {h : \u211d\u22650} (H : \u2200 i, a \u2264 g i * h) : a \u2264 iInf g * h", "start": [1013, 1], "end": [1015, 19], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_iInf_mul_iInf", "code": "theorem le_iInf_mul_iInf {a : \u211d\u22650} {g h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 i j, a \u2264 g i * h j) :\n    a \u2264 iInf g * iInf h", "start": [1018, 1], "end": [1020, 42], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_coe_nnreal_real", "code": "theorem preimage_coe_nnreal_real (h : s.OrdConnected) : ((\u2191) \u207b\u00b9' s : Set \u211d\u22650).OrdConnected", "start": [1033, 1], "end": [1034, 34], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_coe_nnreal_real", "code": "theorem image_coe_nnreal_real (h : t.OrdConnected) : ((\u2191) '' t : Set \u211d).OrdConnected", "start": [1037, 1], "end": [1039, 85], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_real_toNNReal", "code": "theorem image_real_toNNReal (h : s.OrdConnected) : (Real.toNNReal '' s).OrdConnected", "start": [1043, 1], "end": [1050, 79], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_real_toNNReal", "code": "theorem preimage_real_toNNReal (h : t.OrdConnected) : (Real.toNNReal \u207b\u00b9' t).OrdConnected", "start": [1053, 1], "end": [1054, 37], "kind": "commanddeclaration"}, {"full_name": "Real.nnabs", "code": "def nnabs : \u211d \u2192*\u2080 \u211d\u22650 where\n  toFun x := \u27e8|x|, abs_nonneg x\u27e9\n  map_zero' := by ext; simp\n  map_one' := by ext; simp\n  map_mul' x y := by ext; simp [abs_mul]", "start": [1063, 1], "end": [1069, 41], "kind": "commanddeclaration"}, {"full_name": "Real.coe_nnabs", "code": "@[norm_cast, simp]\ntheorem coe_nnabs (x : \u211d) : (nnabs x : \u211d) = |x|", "start": [1072, 1], "end": [1074, 6], "kind": "commanddeclaration"}, {"full_name": "Real.nnabs_of_nonneg", "code": "@[simp]\ntheorem nnabs_of_nonneg {x : \u211d} (h : 0 \u2264 x) : nnabs x = toNNReal x", "start": [1077, 1], "end": [1080, 52], "kind": "commanddeclaration"}, {"full_name": "Real.nnabs_coe", "code": "theorem nnabs_coe (x : \u211d\u22650) : nnabs x = x", "start": [1083, 1], "end": [1083, 53], "kind": "commanddeclaration"}, {"full_name": "Real.coe_toNNReal_le", "code": "theorem coe_toNNReal_le (x : \u211d) : (toNNReal x : \u211d) \u2264 |x|", "start": [1086, 1], "end": [1087, 40], "kind": "commanddeclaration"}, {"full_name": "Real.cast_natAbs_eq_nnabs_cast", "code": "theorem cast_natAbs_eq_nnabs_cast (n : \u2124) : (n.natAbs : \u211d\u22650) = nnabs n", "start": [1090, 1], "end": [1092, 74], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.nnreal_coe_pos", "code": "private theorem nnreal_coe_pos {r : \u211d\u22650} : 0 < r \u2192 0 < (r : \u211d)", "start": [1101, 1], "end": [1102, 19], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalNNRealtoReal", "code": "@[positivity NNReal.toReal _]\ndef evalNNRealtoReal : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app _ (a : Q(NNReal))) \u2190 whnfR e | throwError \"not NNReal.toReal\"\n  let z\u03b1' \u2190 synthInstanceQ (q(Zero NNReal) : Q(Type))\n  let p\u03b1' \u2190 synthInstanceQ (q(PartialOrder NNReal) : Q(Type))\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  assertInstancesCommute\n  match ra with\n  | .positive pa => pure (.positive (q(nnreal_coe_pos $pa) : Expr))\n  | _ => pure (.nonnegative (q(NNReal.coe_nonneg $a) : Expr))", "start": [1104, 1], "end": [1114, 62], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/WithBotTop.lean", "imports": ["Mathlib/Data/Set/Intervals/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "WithTop.preimage_coe_top", "code": "@[simp]\ntheorem preimage_coe_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' {\u22a4} = (\u2205 : Set \u03b1)", "start": [25, 1], "end": [27, 47], "kind": "commanddeclaration"}, {"full_name": "WithTop.range_coe", "code": "theorem range_coe : range (some : \u03b1 \u2192 WithTop \u03b1) = Iio \u22a4", "start": [32, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ioi", "code": "@[simp]\ntheorem preimage_coe_Ioi : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioi a = Ioi a", "start": [38, 1], "end": [40, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ici", "code": "@[simp]\ntheorem preimage_coe_Ici : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ici a = Ici a", "start": [43, 1], "end": [45, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Iio", "code": "@[simp]\ntheorem preimage_coe_Iio : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Iio a = Iio a", "start": [48, 1], "end": [50, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Iic", "code": "@[simp]\ntheorem preimage_coe_Iic : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Iic a = Iic a", "start": [53, 1], "end": [55, 26], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Icc", "code": "@[simp]\ntheorem preimage_coe_Icc : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Icc a b = Icc a b", "start": [58, 1], "end": [59, 101], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ico", "code": "@[simp]\ntheorem preimage_coe_Ico : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ico a b = Ico a b", "start": [62, 1], "end": [63, 101], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ioc", "code": "@[simp]\ntheorem preimage_coe_Ioc : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioc a b = Ioc a b", "start": [66, 1], "end": [67, 101], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ioo", "code": "@[simp]\ntheorem preimage_coe_Ioo : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioo a b = Ioo a b", "start": [70, 1], "end": [71, 101], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Iio_top", "code": "@[simp]\ntheorem preimage_coe_Iio_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Iio \u22a4 = univ", "start": [74, 1], "end": [76, 35], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ico_top", "code": "@[simp]\ntheorem preimage_coe_Ico_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ico a \u22a4 = Ici a", "start": [79, 1], "end": [81, 25], "kind": "commanddeclaration"}, {"full_name": "WithTop.preimage_coe_Ioo_top", "code": "@[simp]\ntheorem preimage_coe_Ioo_top : (some : \u03b1 \u2192 WithTop \u03b1) \u207b\u00b9' Ioo a \u22a4 = Ioi a", "start": [84, 1], "end": [86, 25], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Ioi", "code": "theorem image_coe_Ioi : (some : \u03b1 \u2192 WithTop \u03b1) '' Ioi a = Ioo (a : WithTop \u03b1) \u22a4", "start": [89, 1], "end": [90, 83], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Ici", "code": "theorem image_coe_Ici : (some : \u03b1 \u2192 WithTop \u03b1) '' Ici a = Ico (a : WithTop \u03b1) \u22a4", "start": [93, 1], "end": [94, 83], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Iio", "code": "theorem image_coe_Iio : (some : \u03b1 \u2192 WithTop \u03b1) '' Iio a = Iio (a : WithTop \u03b1)", "start": [97, 1], "end": [99, 58], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Iic", "code": "theorem image_coe_Iic : (some : \u03b1 \u2192 WithTop \u03b1) '' Iic a = Iic (a : WithTop \u03b1)", "start": [102, 1], "end": [104, 69], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Icc", "code": "theorem image_coe_Icc : (some : \u03b1 \u2192 WithTop \u03b1) '' Icc a b = Icc (a : WithTop \u03b1) b", "start": [107, 1], "end": [110, 78], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Ico", "code": "theorem image_coe_Ico : (some : \u03b1 \u2192 WithTop \u03b1) '' Ico a b = Ico (a : WithTop \u03b1) b", "start": [113, 1], "end": [115, 94], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Ioc", "code": "theorem image_coe_Ioc : (some : \u03b1 \u2192 WithTop \u03b1) '' Ioc a b = Ioc (a : WithTop \u03b1) b", "start": [118, 1], "end": [121, 78], "kind": "commanddeclaration"}, {"full_name": "WithTop.image_coe_Ioo", "code": "theorem image_coe_Ioo : (some : \u03b1 \u2192 WithTop \u03b1) '' Ioo a b = Ioo (a : WithTop \u03b1) b", "start": [124, 1], "end": [126, 94], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_bot", "code": "@[simp]\ntheorem preimage_coe_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' {\u22a5} = (\u2205 : Set \u03b1)", "start": [135, 1], "end": [137, 32], "kind": "commanddeclaration"}, {"full_name": "WithBot.range_coe", "code": "theorem range_coe : range (some : \u03b1 \u2192 WithBot \u03b1) = Ioi \u22a5", "start": [142, 1], "end": [143, 27], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioi", "code": "@[simp]\ntheorem preimage_coe_Ioi : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioi a = Ioi a", "start": [146, 1], "end": [148, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ici", "code": "@[simp]\ntheorem preimage_coe_Ici : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ici a = Ici a", "start": [151, 1], "end": [153, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Iio", "code": "@[simp]\ntheorem preimage_coe_Iio : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Iio a = Iio a", "start": [156, 1], "end": [158, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Iic", "code": "@[simp]\ntheorem preimage_coe_Iic : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Iic a = Iic a", "start": [161, 1], "end": [163, 26], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Icc", "code": "@[simp]\ntheorem preimage_coe_Icc : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Icc a b = Icc a b", "start": [166, 1], "end": [167, 101], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ico", "code": "@[simp]\ntheorem preimage_coe_Ico : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ico a b = Ico a b", "start": [170, 1], "end": [171, 101], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioc", "code": "@[simp]\ntheorem preimage_coe_Ioc : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioc a b = Ioc a b", "start": [174, 1], "end": [175, 101], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioo", "code": "@[simp]\ntheorem preimage_coe_Ioo : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioo a b = Ioo a b", "start": [178, 1], "end": [179, 101], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioi_bot", "code": "@[simp]\ntheorem preimage_coe_Ioi_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioi \u22a5 = univ", "start": [182, 1], "end": [184, 35], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioc_bot", "code": "@[simp]\ntheorem preimage_coe_Ioc_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioc \u22a5 a = Iic a", "start": [187, 1], "end": [189, 25], "kind": "commanddeclaration"}, {"full_name": "WithBot.preimage_coe_Ioo_bot", "code": "@[simp]\ntheorem preimage_coe_Ioo_bot : (some : \u03b1 \u2192 WithBot \u03b1) \u207b\u00b9' Ioo \u22a5 a = Iio a", "start": [192, 1], "end": [194, 25], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Iio", "code": "theorem image_coe_Iio : (some : \u03b1 \u2192 WithBot \u03b1) '' Iio a = Ioo (\u22a5 : WithBot \u03b1) a", "start": [197, 1], "end": [198, 95], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Iic", "code": "theorem image_coe_Iic : (some : \u03b1 \u2192 WithBot \u03b1) '' Iic a = Ioc (\u22a5 : WithBot \u03b1) a", "start": [201, 1], "end": [202, 95], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Ioi", "code": "theorem image_coe_Ioi : (some : \u03b1 \u2192 WithBot \u03b1) '' Ioi a = Ioi (a : WithBot \u03b1)", "start": [205, 1], "end": [207, 58], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Ici", "code": "theorem image_coe_Ici : (some : \u03b1 \u2192 WithBot \u03b1) '' Ici a = Ici (a : WithBot \u03b1)", "start": [210, 1], "end": [212, 69], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Icc", "code": "theorem image_coe_Icc : (some : \u03b1 \u2192 WithBot \u03b1) '' Icc a b = Icc (a : WithBot \u03b1) b", "start": [215, 1], "end": [218, 78], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Ioc", "code": "theorem image_coe_Ioc : (some : \u03b1 \u2192 WithBot \u03b1) '' Ioc a b = Ioc (a : WithBot \u03b1) b", "start": [221, 1], "end": [223, 94], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Ico", "code": "theorem image_coe_Ico : (some : \u03b1 \u2192 WithBot \u03b1) '' Ico a b = Ico (a : WithBot \u03b1) b", "start": [226, 1], "end": [229, 78], "kind": "commanddeclaration"}, {"full_name": "WithBot.image_coe_Ioo", "code": "theorem image_coe_Ioo : (some : \u03b1 \u2192 WithBot \u03b1) '' Ioo a b = Ioo (a : WithBot \u03b1) b", "start": [232, 1], "end": [234, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Group/Basic.lean", "imports": ["Mathlib/Topology/Algebra/Monoid.lean", "Mathlib/Topology/Algebra/Constructions.lean", "Mathlib/GroupTheory/GroupAction/ConjAct.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/GroupAction/Quotient.lean", "Mathlib/GroupTheory/QuotientGroup.lean"], "premises": [{"full_name": "Homeomorph.mulLeft", "code": "@[to_additive \"Addition from the left in a topological additive group as a homeomorphism.\"]\nprotected def Homeomorph.mulLeft (a : G) : G \u2243\u209c G :=\n  { Equiv.mulLeft a with\n    continuous_toFun := continuous_const.mul continuous_id\n    continuous_invFun := continuous_const.mul continuous_id }", "start": [54, 1], "end": [59, 62], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_mulLeft", "code": "@[to_additive (attr := simp)]\ntheorem Homeomorph.coe_mulLeft (a : G) : \u21d1(Homeomorph.mulLeft a) = (\u00b7 * \u00b7) a", "start": [63, 1], "end": [65, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulLeft_symm", "code": "@[to_additive]\ntheorem Homeomorph.mulLeft_symm (a : G) : (Homeomorph.mulLeft a).symm = Homeomorph.mulLeft a\u207b\u00b9", "start": [69, 1], "end": [72, 6], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_mul_left", "code": "@[to_additive]\ntheorem isOpenMap_mul_left (a : G) : IsOpenMap fun x => a * x", "start": [76, 1], "end": [78, 35], "kind": "commanddeclaration"}, {"full_name": "IsOpen.leftCoset", "code": "@[to_additive IsOpen.left_addCoset]\ntheorem IsOpen.leftCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (leftCoset x U)", "start": [82, 1], "end": [84, 27], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_mul_left", "code": "@[to_additive]\ntheorem isClosedMap_mul_left (a : G) : IsClosedMap fun x => a * x", "start": [88, 1], "end": [90, 37], "kind": "commanddeclaration"}, {"full_name": "IsClosed.leftCoset", "code": "@[to_additive IsClosed.left_addCoset]\ntheorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (leftCoset x U)", "start": [94, 1], "end": [96, 29], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulRight", "code": "@[to_additive \"Addition from the right in a topological additive group as a homeomorphism.\"]\nprotected def Homeomorph.mulRight (a : G) : G \u2243\u209c G :=\n  { Equiv.mulRight a with\n    continuous_toFun := continuous_id.mul continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }", "start": [100, 1], "end": [105, 62], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_mulRight", "code": "@[to_additive (attr := simp)]\ntheorem Homeomorph.coe_mulRight (a : G) : \u21d1(Homeomorph.mulRight a) = fun g => g * a", "start": [109, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulRight_symm", "code": "@[to_additive]\ntheorem Homeomorph.mulRight_symm (a : G) :\n    (Homeomorph.mulRight a).symm = Homeomorph.mulRight a\u207b\u00b9", "start": [115, 1], "end": [119, 6], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_mul_right", "code": "@[to_additive]\ntheorem isOpenMap_mul_right (a : G) : IsOpenMap fun x => x * a", "start": [123, 1], "end": [125, 36], "kind": "commanddeclaration"}, {"full_name": "IsOpen.rightCoset", "code": "@[to_additive IsOpen.right_addCoset]\ntheorem IsOpen.rightCoset {U : Set G} (h : IsOpen U) (x : G) : IsOpen (rightCoset U x)", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_mul_right", "code": "@[to_additive]\ntheorem isClosedMap_mul_right (a : G) : IsClosedMap fun x => x * a", "start": [135, 1], "end": [137, 38], "kind": "commanddeclaration"}, {"full_name": "IsClosed.rightCoset", "code": "@[to_additive IsClosed.right_addCoset]\ntheorem IsClosed.rightCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (rightCoset U x)", "start": [141, 1], "end": [143, 30], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_of_open_singleton_one", "code": "@[to_additive]\ntheorem discreteTopology_of_open_singleton_one (h : IsOpen ({1} : Set G)) : DiscreteTopology G", "start": [147, 1], "end": [155, 36], "kind": "commanddeclaration"}, {"full_name": "discreteTopology_iff_open_singleton_one", "code": "@[to_additive]\ntheorem discreteTopology_iff_open_singleton_one : DiscreteTopology G \u2194 IsOpen ({1} : Set G)", "start": [159, 1], "end": [161, 88], "kind": "commanddeclaration"}, {"full_name": "ContinuousNeg", "code": "class ContinuousNeg (G : Type u) [TopologicalSpace G] [Neg G] : Prop where\n  continuous_neg : Continuous fun a : G => -a", "start": [172, 1], "end": [176, 46], "kind": "commanddeclaration"}, {"full_name": "ContinuousInv", "code": "@[to_additive (attr := continuity)]\nclass ContinuousInv (G : Type u) [TopologicalSpace G] [Inv G] : Prop where\n  continuous_inv : Continuous fun a : G => a\u207b\u00b9", "start": [181, 1], "end": [186, 47], "kind": "commanddeclaration"}, {"full_name": "continuousOn_inv", "code": "@[to_additive]\ntheorem continuousOn_inv {s : Set G} : ContinuousOn Inv.inv s", "start": [200, 1], "end": [202, 30], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_inv", "code": "@[to_additive]\ntheorem continuousWithinAt_inv {s : Set G} {x : G} : ContinuousWithinAt Inv.inv s x", "start": [206, 1], "end": [208, 36], "kind": "commanddeclaration"}, {"full_name": "continuousAt_inv", "code": "@[to_additive]\ntheorem continuousAt_inv {x : G} : ContinuousAt Inv.inv x", "start": [212, 1], "end": [214, 30], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv", "code": "@[to_additive]\ntheorem tendsto_inv (a : G) : Tendsto Inv.inv (\ud835\udcdd a) (\ud835\udcdd a\u207b\u00b9)", "start": [218, 1], "end": [220, 19], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inv", "code": "@[to_additive\n  \"If a function converges to a value in an additive topological group, then its\n  negation converges to the negation of this value.\"]\ntheorem Filter.Tendsto.inv {f : \u03b1 \u2192 G} {l : Filter \u03b1} {y : G} (h : Tendsto f l (\ud835\udcdd y)) :\n    Tendsto (fun x => (f x)\u207b\u00b9) l (\ud835\udcdd y\u207b\u00b9)", "start": [224, 1], "end": [232, 36], "kind": "commanddeclaration"}, {"full_name": "Continuous.inv", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.inv (hf : Continuous f) : Continuous fun x => (f x)\u207b\u00b9", "start": [238, 1], "end": [240, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.inv", "code": "@[to_additive]\ntheorem ContinuousAt.inv (hf : ContinuousAt f x) : ContinuousAt (fun x => (f x)\u207b\u00b9) x", "start": [244, 1], "end": [246, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.inv", "code": "@[to_additive]\ntheorem ContinuousOn.inv (hf : ContinuousOn f s) : ContinuousOn (fun x => (f x)\u207b\u00b9) s", "start": [250, 1], "end": [252, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.inv", "code": "@[to_additive]\ntheorem ContinuousWithinAt.inv (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => (f x)\u207b\u00b9) s x", "start": [256, 1], "end": [259, 24], "kind": "commanddeclaration"}, {"full_name": "Prod.continuousInv", "code": "@[to_additive]\ninstance Prod.continuousInv [TopologicalSpace H] [Inv H] [ContinuousInv H] :\n    ContinuousInv (G \u00d7 H) :=\n  \u27e8continuous_inv.fst'.prod_mk continuous_inv.snd'\u27e9", "start": [263, 1], "end": [266, 52], "kind": "commanddeclaration"}, {"full_name": "Pi.continuousInv", "code": "@[to_additive]\ninstance Pi.continuousInv {C : \u03b9 \u2192 Type*} [\u2200 i, TopologicalSpace (C i)] [\u2200 i, Inv (C i)]\n    [\u2200 i, ContinuousInv (C i)] : ContinuousInv (\u2200 i, C i) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv", "start": [270, 1], "end": [273, 68], "kind": "commanddeclaration"}, {"full_name": "Pi.has_continuous_inv'", "code": "@[to_additive\n  \"A version of `Pi.continuousNeg` for non-dependent functions. It is needed\n  because sometimes Lean fails to use `Pi.continuousNeg` for non-dependent functions.\"]\ninstance Pi.has_continuous_inv' : ContinuousInv (\u03b9 \u2192 G) :=\n  Pi.continuousInv", "start": [277, 1], "end": [283, 19], "kind": "commanddeclaration"}, {"full_name": "continuousInv_of_discreteTopology", "code": "@[to_additive]\ninstance (priority := 100) continuousInv_of_discreteTopology [TopologicalSpace H] [Inv H]\n    [DiscreteTopology H] : ContinuousInv H :=\n  \u27e8continuous_of_discreteTopology\u27e9", "start": [287, 1], "end": [290, 35], "kind": "commanddeclaration"}, {"full_name": "isClosed_setOf_map_inv", "code": "@[to_additive]\ntheorem isClosed_setOf_map_inv [Inv G\u2081] [Inv G\u2082] [ContinuousInv G\u2082] :\n    IsClosed { f : G\u2081 \u2192 G\u2082 | \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9 }", "start": [298, 1], "end": [302, 93], "kind": "commanddeclaration"}, {"full_name": "IsCompact.inv", "code": "@[to_additive]\ntheorem IsCompact.inv (hs : IsCompact s) : IsCompact s\u207b\u00b9", "start": [320, 1], "end": [323, 32], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.inv", "code": "@[to_additive \"Negation in a topological group as a homeomorphism.\"]\nprotected def Homeomorph.inv (G : Type*) [TopologicalSpace G] [InvolutiveInv G]\n    [ContinuousInv G] : G \u2243\u209c G :=\n  { Equiv.inv G with\n    continuous_toFun := continuous_inv\n    continuous_invFun := continuous_inv }", "start": [329, 1], "end": [335, 42], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_inv", "code": "@[to_additive]\ntheorem isOpenMap_inv : IsOpenMap (Inv.inv : G \u2192 G)", "start": [339, 1], "end": [341, 31], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_inv", "code": "@[to_additive]\ntheorem isClosedMap_inv : IsClosedMap (Inv.inv : G \u2192 G)", "start": [345, 1], "end": [347, 33], "kind": "commanddeclaration"}, {"full_name": "IsOpen.inv", "code": "@[to_additive]\ntheorem IsOpen.inv (hs : IsOpen s) : IsOpen s\u207b\u00b9", "start": [353, 1], "end": [355, 29], "kind": "commanddeclaration"}, {"full_name": "IsClosed.inv", "code": "@[to_additive]\ntheorem IsClosed.inv (hs : IsClosed s) : IsClosed s\u207b\u00b9", "start": [359, 1], "end": [361, 29], "kind": "commanddeclaration"}, {"full_name": "inv_closure", "code": "@[to_additive]\ntheorem inv_closure : \u2200 s : Set G, (closure s)\u207b\u00b9 = closure s\u207b\u00b9", "start": [365, 1], "end": [367, 38], "kind": "commanddeclaration"}, {"full_name": "continuousInv_sInf", "code": "@[to_additive]\ntheorem continuousInv_sInf {ts : Set (TopologicalSpace G)}\n    (h : \u2200 t \u2208 ts, @ContinuousInv G t _) : @ContinuousInv G (sInf ts) _", "start": [377, 1], "end": [383, 80], "kind": "commanddeclaration"}, {"full_name": "continuousInv_iInf", "code": "@[to_additive]\ntheorem continuousInv_iInf {ts' : \u03b9' \u2192 TopologicalSpace G}\n    (h' : \u2200 i, @ContinuousInv G (ts' i) _) : @ContinuousInv G (\u2a05 i, ts' i) _", "start": [387, 1], "end": [391, 57], "kind": "commanddeclaration"}, {"full_name": "continuousInv_inf", "code": "@[to_additive]\ntheorem continuousInv_inf {t\u2081 t\u2082 : TopologicalSpace G} (h\u2081 : @ContinuousInv G t\u2081 _)\n    (h\u2082 : @ContinuousInv G t\u2082 _) : @ContinuousInv G (t\u2081 \u2293 t\u2082) _", "start": [395, 1], "end": [400, 25], "kind": "commanddeclaration"}, {"full_name": "Inducing.continuousInv", "code": "@[to_additive]\ntheorem Inducing.continuousInv {G H : Type*} [Inv G] [Inv H] [TopologicalSpace G]\n    [TopologicalSpace H] [ContinuousInv H] {f : G \u2192 H} (hf : Inducing f)\n    (hf_inv : \u2200 x, f x\u207b\u00b9 = (f x)\u207b\u00b9) : ContinuousInv G", "start": [406, 1], "end": [410, 83], "kind": "commanddeclaration"}, {"full_name": "TopologicalAddGroup", "code": "class TopologicalAddGroup (G : Type u) [TopologicalSpace G] [AddGroup G] extends\n  ContinuousAdd G, ContinuousNeg G : Prop", "start": [425, 1], "end": [428, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup", "code": "@[to_additive]\nclass TopologicalGroup (G : Type*) [TopologicalSpace G] [Group G] extends ContinuousMul G,\n  ContinuousInv G : Prop", "start": [431, 1], "end": [440, 25], "kind": "commanddeclaration"}, {"full_name": "ConjAct.units_continuousConstSMul", "code": "instance ConjAct.units_continuousConstSMul {M} [Monoid M] [TopologicalSpace M]\n    [ContinuousMul M] : ContinuousConstSMul (ConjAct M\u02e3) M :=\n  \u27e8fun _ => (continuous_const.mul continuous_id).mul continuous_const\u27e9", "start": [446, 1], "end": [448, 71], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.continuous_conj_prod", "code": "@[to_additive\n  \"Conjugation is jointly continuous on `G \u00d7 G` when both `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj_prod [ContinuousInv G] :\n    Continuous fun g : G \u00d7 G => g.fst * g.snd * g.fst\u207b\u00b9", "start": [453, 1], "end": [458, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.continuous_conj", "code": "@[to_additive (attr := continuity)\n  \"Conjugation by a fixed element is continuous when `add` is continuous.\"]\ntheorem TopologicalGroup.continuous_conj (g : G) : Continuous fun h : G => g * h * g\u207b\u00b9", "start": [462, 1], "end": [466, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.continuous_conj'", "code": "@[to_additive (attr := continuity)\n  \"Conjugation acting on fixed element of the additive group is continuous when both\n    `add` and `neg` are continuous.\"]\ntheorem TopologicalGroup.continuous_conj' [ContinuousInv G] (h : G) :\n    Continuous fun g : G => g * h * g\u207b\u00b9", "start": [470, 1], "end": [477, 46], "kind": "commanddeclaration"}, {"full_name": "continuous_zpow", "code": "@[to_additive (attr := continuity)]\ntheorem continuous_zpow : \u2200 z : \u2124, Continuous fun a : G => a ^ z", "start": [488, 1], "end": [491, 65], "kind": "commanddeclaration"}, {"full_name": "AddGroup.continuousConstSMul_int", "code": "instance AddGroup.continuousConstSMul_int {A} [AddGroup A] [TopologicalSpace A]\n    [TopologicalAddGroup A] : ContinuousConstSMul \u2124 A :=\n  \u27e8continuous_zsmul\u27e9", "start": [495, 1], "end": [497, 21], "kind": "commanddeclaration"}, {"full_name": "AddGroup.continuousSMul_int", "code": "instance AddGroup.continuousSMul_int {A} [AddGroup A] [TopologicalSpace A]\n    [TopologicalAddGroup A] : ContinuousSMul \u2124 A :=\n  \u27e8continuous_prod_of_discrete_left.mpr continuous_zsmul\u27e9", "start": [500, 1], "end": [502, 58], "kind": "commanddeclaration"}, {"full_name": "Continuous.zpow", "code": "@[to_additive (attr := continuity)]\ntheorem Continuous.zpow {f : \u03b1 \u2192 G} (h : Continuous f) (z : \u2124) : Continuous fun b => f b ^ z", "start": [505, 1], "end": [507, 29], "kind": "commanddeclaration"}, {"full_name": "continuousOn_zpow", "code": "@[to_additive]\ntheorem continuousOn_zpow {s : Set G} (z : \u2124) : ContinuousOn (fun x => x ^ z) s", "start": [511, 1], "end": [513, 35], "kind": "commanddeclaration"}, {"full_name": "continuousAt_zpow", "code": "@[to_additive]\ntheorem continuousAt_zpow (x : G) (z : \u2124) : ContinuousAt (fun x => x ^ z) x", "start": [517, 1], "end": [519, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.zpow", "code": "@[to_additive]\ntheorem Filter.Tendsto.zpow {\u03b1} {l : Filter \u03b1} {f : \u03b1 \u2192 G} {x : G} (hf : Tendsto f l (\ud835\udcdd x))\n    (z : \u2124) : Tendsto (fun x => f x ^ z) l (\ud835\udcdd (x ^ z))", "start": [523, 1], "end": [526, 42], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.zpow", "code": "@[to_additive]\ntheorem ContinuousWithinAt.zpow {f : \u03b1 \u2192 G} {x : \u03b1} {s : Set \u03b1} (hf : ContinuousWithinAt f s x)\n    (z : \u2124) : ContinuousWithinAt (fun x => f x ^ z) s x", "start": [530, 1], "end": [533, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.zpow", "code": "@[to_additive]\ntheorem ContinuousAt.zpow {f : \u03b1 \u2192 G} {x : \u03b1} (hf : ContinuousAt f x) (z : \u2124) :\n    ContinuousAt (fun x => f x ^ z) x", "start": [537, 1], "end": [540, 27], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.zpow", "code": "@[to_additive]\ntheorem ContinuousOn.zpow {f : \u03b1 \u2192 G} {s : Set \u03b1} (hf : ContinuousOn f s) (z : \u2124) :\n    ContinuousOn (fun x => f x ^ z) s", "start": [544, 1], "end": [546, 70], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Ioi", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ioi {a : H} : Tendsto Inv.inv (\ud835\udcdd[>] a) (\ud835\udcdd[<] a\u207b\u00b9)", "start": [556, 1], "end": [558, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Iio", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iio {a : H} : Tendsto Inv.inv (\ud835\udcdd[<] a) (\ud835\udcdd[>] a\u207b\u00b9)", "start": [562, 1], "end": [564, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Ioi_inv", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ioi_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[>] a\u207b\u00b9) (\ud835\udcdd[<] a)", "start": [568, 1], "end": [570, 69], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Iio_inv", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iio_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[<] a\u207b\u00b9) (\ud835\udcdd[>] a)", "start": [574, 1], "end": [576, 69], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Ici", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ici {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2265] a) (\ud835\udcdd[\u2264] a\u207b\u00b9)", "start": [580, 1], "end": [582, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Iic", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iic {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2264] a) (\ud835\udcdd[\u2265] a\u207b\u00b9)", "start": [586, 1], "end": [588, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Ici_inv", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Ici_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2265] a\u207b\u00b9) (\ud835\udcdd[\u2264] a)", "start": [592, 1], "end": [594, 69], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_nhdsWithin_Iic_inv", "code": "@[to_additive]\ntheorem tendsto_inv_nhdsWithin_Iic_inv {a : H} : Tendsto Inv.inv (\ud835\udcdd[\u2264] a\u207b\u00b9) (\ud835\udcdd[\u2265] a)", "start": [598, 1], "end": [600, 69], "kind": "commanddeclaration"}, {"full_name": "Pi.topologicalGroup", "code": "@[to_additive]\ninstance Pi.topologicalGroup {C : \u03b2 \u2192 Type*} [\u2200 b, TopologicalSpace (C b)] [\u2200 b, Group (C b)]\n    [\u2200 b, TopologicalGroup (C b)] : TopologicalGroup (\u2200 b, C b) where\n  continuous_inv := continuous_pi fun i => (continuous_apply i).inv", "start": [610, 1], "end": [613, 68], "kind": "commanddeclaration"}, {"full_name": "nhds_one_symm", "code": "@[to_additive]\ntheorem nhds_one_symm : comap Inv.inv (\ud835\udcdd (1 : G)) = \ud835\udcdd (1 : G)", "start": [629, 1], "end": [631, 70], "kind": "commanddeclaration"}, {"full_name": "nhds_one_symm'", "code": "@[to_additive]\ntheorem nhds_one_symm' : map Inv.inv (\ud835\udcdd (1 : G)) = \ud835\udcdd (1 : G)", "start": [635, 1], "end": [637, 68], "kind": "commanddeclaration"}, {"full_name": "inv_mem_nhds_one", "code": "@[to_additive]\ntheorem inv_mem_nhds_one {S : Set G} (hS : S \u2208 (\ud835\udcdd 1 : Filter G)) : S\u207b\u00b9 \u2208 \ud835\udcdd (1 : G)", "start": [641, 1], "end": [643, 31], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.shearMulRight", "code": "@[to_additive \"The map `(x, y) \u21a6 (x, x + y)` as a homeomorphism. This is a shear mapping.\"]\nprotected def Homeomorph.shearMulRight : G \u00d7 G \u2243\u209c G \u00d7 G :=\n  { Equiv.prodShear (Equiv.refl _) Equiv.mulLeft with\n    continuous_toFun := continuous_fst.prod_mk continuous_mul\n    continuous_invFun := continuous_fst.prod_mk <| continuous_fst.inv.mul continuous_snd }", "start": [647, 1], "end": [652, 91], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.shearMulRight_coe", "code": "@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_coe :\n    \u21d1(Homeomorph.shearMulRight G) = fun z : G \u00d7 G => (z.1, z.1 * z.2)", "start": [656, 1], "end": [659, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.shearMulRight_symm_coe", "code": "@[to_additive (attr := simp)]\ntheorem Homeomorph.shearMulRight_symm_coe :\n    \u21d1(Homeomorph.shearMulRight G).symm = fun z : G \u00d7 G => (z.1, z.1\u207b\u00b9 * z.2)", "start": [663, 1], "end": [666, 6], "kind": "commanddeclaration"}, {"full_name": "Inducing.topologicalGroup", "code": "@[to_additive]\nprotected theorem Inducing.topologicalGroup {F : Type*} [Group H] [TopologicalSpace H]\n    [MonoidHomClass F H G] (f : F) (hf : Inducing f) : TopologicalGroup H", "start": [672, 1], "end": [676, 54], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_induced", "code": "@[to_additive]\ntheorem topologicalGroup_induced {F : Type*} [Group H] [MonoidHomClass F H G] (f : F) :\n    @TopologicalGroup H (induced f \u2039_\u203a) _", "start": [680, 1], "end": [685, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.topologicalClosure", "code": "@[to_additive\n  \"The (topological-space) closure of an additive subgroup of a space `M` with\n  `ContinuousAdd` is itself an additive subgroup.\"]\ndef Subgroup.topologicalClosure (s : Subgroup G) : Subgroup G :=\n  { s.toSubmonoid.topologicalClosure with\n    carrier := _root_.closure (s : Set G)\n    inv_mem' := fun {g} hg => by simpa only [\u2190 Set.mem_inv, inv_closure, inv_coe_set] using hg }", "start": [697, 1], "end": [705, 97], "kind": "commanddeclaration"}, {"full_name": "Subgroup.topologicalClosure_coe", "code": "@[to_additive (attr := simp)]\ntheorem Subgroup.topologicalClosure_coe {s : Subgroup G} :\n    (s.topologicalClosure : Set G) = _root_.closure s", "start": [709, 1], "end": [712, 6], "kind": "commanddeclaration"}, {"full_name": "Subgroup.le_topologicalClosure", "code": "@[to_additive]\ntheorem Subgroup.le_topologicalClosure (s : Subgroup G) : s \u2264 s.topologicalClosure", "start": [716, 1], "end": [718, 24], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isClosed_topologicalClosure", "code": "@[to_additive]\ntheorem Subgroup.isClosed_topologicalClosure (s : Subgroup G) :\n    IsClosed (s.topologicalClosure : Set G)", "start": [722, 1], "end": [724, 64], "kind": "commanddeclaration"}, {"full_name": "Subgroup.topologicalClosure_minimal", "code": "@[to_additive]\ntheorem Subgroup.topologicalClosure_minimal (s : Subgroup G) {t : Subgroup G} (h : s \u2264 t)\n    (ht : IsClosed (t : Set G)) : s.topologicalClosure \u2264 t", "start": [728, 1], "end": [731, 23], "kind": "commanddeclaration"}, {"full_name": "DenseRange.topologicalClosure_map_subgroup", "code": "@[to_additive]\ntheorem DenseRange.topologicalClosure_map_subgroup [Group H] [TopologicalSpace H]\n    [TopologicalGroup H] {f : G \u2192* H} (hf : Continuous f) (hf' : DenseRange f) {s : Subgroup G}\n    (hs : s.topologicalClosure = \u22a4) : (s.map f).topologicalClosure = \u22a4", "start": [735, 1], "end": [741, 30], "kind": "commanddeclaration"}, {"full_name": "Subgroup.is_normal_topologicalClosure", "code": "@[to_additive \"The topological closure of a normal additive subgroup is normal.\"]\ntheorem Subgroup.is_normal_topologicalClosure {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] (N : Subgroup G) [N.Normal] : (Subgroup.topologicalClosure N).Normal where", "start": [745, 1], "end": [751, 68], "kind": "commanddeclaration"}, {"full_name": "mul_mem_connectedComponent_one", "code": "@[to_additive]\ntheorem mul_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [MulOneClass G]\n    [ContinuousMul G] {g h : G} (hg : g \u2208 connectedComponent (1 : G))\n    (hh : h \u2208 connectedComponent (1 : G)) : g * h \u2208 connectedComponent (1 : G)", "start": [755, 1], "end": [764, 68], "kind": "commanddeclaration"}, {"full_name": "inv_mem_connectedComponent_one", "code": "@[to_additive]\ntheorem inv_mem_connectedComponent_one {G : Type*} [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] {g : G} (hg : g \u2208 connectedComponent (1 : G)) :\n    g\u207b\u00b9 \u2208 connectedComponent (1 : G)", "start": [768, 1], "end": [775, 46], "kind": "commanddeclaration"}, {"full_name": "Subgroup.connectedComponentOfOne", "code": "@[to_additive \"The connected component of 0 is a subgroup of `G`.\"]\ndef Subgroup.connectedComponentOfOne (G : Type*) [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] : Subgroup G where\n  carrier := connectedComponent (1 : G)\n  one_mem' := mem_connectedComponent\n  mul_mem' hg hh := mul_mem_connectedComponent_one hg hh\n  inv_mem' hg := inv_mem_connectedComponent_one hg", "start": [779, 1], "end": [786, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.commGroupTopologicalClosure", "code": "@[to_additive\n  \"If a subgroup of an additive topological group is commutative, then so is its\n  topological closure.\"]\ndef Subgroup.commGroupTopologicalClosure [T2Space G] (s : Subgroup G)\n    (hs : \u2200 x y : s, x * y = y * x) : CommGroup s.topologicalClosure :=\n  { s.topologicalClosure.toGroup, s.toSubmonoid.commMonoidTopologicalClosure hs with }", "start": [790, 1], "end": [796, 87], "kind": "commanddeclaration"}, {"full_name": "exists_nhds_split_inv", "code": "@[to_additive exists_nhds_half_neg]\ntheorem exists_nhds_split_inv {s : Set G} (hs : s \u2208 \ud835\udcdd (1 : G)) :\n    \u2203 V \u2208 \ud835\udcdd (1 : G), \u2200 v \u2208 V, \u2200 w \u2208 V, v / w \u2208 s", "start": [800, 1], "end": [806, 9], "kind": "commanddeclaration"}, {"full_name": "nhds_translation_mul_inv", "code": "@[to_additive]\ntheorem nhds_translation_mul_inv (x : G) : comap (fun y : G => y * x\u207b\u00b9) (\ud835\udcdd 1) = \ud835\udcdd x", "start": [810, 1], "end": [812, 88], "kind": "commanddeclaration"}, {"full_name": "map_mul_left_nhds", "code": "@[to_additive (attr := simp)]\ntheorem map_mul_left_nhds (x y : G) : map ((\u00b7 * \u00b7) x) (\ud835\udcdd y) = \ud835\udcdd (x * y)", "start": [816, 1], "end": [818, 39], "kind": "commanddeclaration"}, {"full_name": "map_mul_left_nhds_one", "code": "@[to_additive]\ntheorem map_mul_left_nhds_one (x : G) : map ((\u00b7 * \u00b7) x) (\ud835\udcdd 1) = \ud835\udcdd x", "start": [822, 1], "end": [823, 79], "kind": "commanddeclaration"}, {"full_name": "map_mul_right_nhds", "code": "@[to_additive (attr := simp)]\ntheorem map_mul_right_nhds (x y : G) : map (fun z => z * x) (\ud835\udcdd y) = \ud835\udcdd (y * x)", "start": [827, 1], "end": [829, 40], "kind": "commanddeclaration"}, {"full_name": "map_mul_right_nhds_one", "code": "@[to_additive]\ntheorem map_mul_right_nhds_one (x : G) : map (fun y => y * x) (\ud835\udcdd 1) = \ud835\udcdd x", "start": [833, 1], "end": [834, 85], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.nhds_of_one", "code": "@[to_additive]\ntheorem Filter.HasBasis.nhds_of_one {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set G}\n    (hb : HasBasis (\ud835\udcdd 1 : Filter G) p s) (x : G) :\n    HasBasis (\ud835\udcdd x) p fun i => { y | y / x \u2208 s i }", "start": [838, 1], "end": [844, 19], "kind": "commanddeclaration"}, {"full_name": "mem_closure_iff_nhds_one", "code": "@[to_additive]\ntheorem mem_closure_iff_nhds_one {x : G} {s : Set G} :\n    x \u2208 closure s \u2194 \u2200 U \u2208 (\ud835\udcdd 1 : Filter G), \u2203 y \u2208 s, y / x \u2208 U", "start": [848, 1], "end": [852, 30], "kind": "commanddeclaration"}, {"full_name": "continuous_of_continuousAt_one", "code": "@[to_additive\n  \"An additive monoid homomorphism (a bundled morphism of a type that implements\n  `AddMonoidHomClass`) from an additive topological group to an additive topological monoid is\n  continuous provided that it is continuous at zero. See also\n  `uniformContinuous_of_continuousAt_zero`.\"]\ntheorem continuous_of_continuousAt_one {M hom : Type*} [MulOneClass M] [TopologicalSpace M]\n    [ContinuousMul M] [MonoidHomClass hom G M] (f : hom) (hf : ContinuousAt f 1) :\n    Continuous f", "start": [856, 1], "end": [869, 57], "kind": "commanddeclaration"}, {"full_name": "continuous_of_continuousAt_one\u2082", "code": "@[to_additive continuous_of_continuousAt_zero\u2082]\ntheorem continuous_of_continuousAt_one\u2082 {H M : Type*} [CommMonoid M] [TopologicalSpace M]\n    [ContinuousMul M] [Group H] [TopologicalSpace H] [TopologicalGroup H] (f : G \u2192* H \u2192* M)\n    (hf : ContinuousAt (fun x : G \u00d7 H \u21a6 f x.1 x.2) (1, 1))\n    (hl : \u2200 x, ContinuousAt (f x) 1) (hr : \u2200 y, ContinuousAt (fun x => f x y) 1) :\n    Continuous (fun x : G \u00d7 H \u21a6 f x.1 x.2)", "start": [874, 1], "end": [884, 52], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.ext", "code": "@[to_additive]\ntheorem TopologicalGroup.ext {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _)\n    (h : @nhds G t 1 = @nhds G t' 1) : t = t'", "start": [886, 1], "end": [891, 92], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.ext_iff", "code": "@[to_additive]\ntheorem TopologicalGroup.ext_iff {G : Type*} [Group G] {t t' : TopologicalSpace G}\n    (tg : @TopologicalGroup G t _) (tg' : @TopologicalGroup G t' _) :\n    t = t' \u2194 @nhds G t 1 = @nhds G t' 1", "start": [895, 1], "end": [899, 33], "kind": "commanddeclaration"}, {"full_name": "ContinuousInv.of_nhds_one", "code": "@[to_additive]\ntheorem ContinuousInv.of_nhds_one {G : Type*} [Group G] [TopologicalSpace G]\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x : G => x\u2080 * x) (\ud835\udcdd 1))\n    (hconj : \u2200 x\u2080 : G, Tendsto (fun x : G => x\u2080 * x * x\u2080\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1)) : ContinuousInv G", "start": [903, 1], "end": [912, 36], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.of_nhds_one'", "code": "@[to_additive]\ntheorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n    (hright : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)) : TopologicalGroup G", "start": [916, 1], "end": [929, 30], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.of_nhds_one", "code": "@[to_additive]\ntheorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n    (hconj : \u2200 x\u2080 : G, Tendsto (fun x => x\u2080 * x * x\u2080\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1)) : TopologicalGroup G", "start": [933, 1], "end": [944, 32], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.of_comm_of_nhds_one", "code": "@[to_additive]\ntheorem TopologicalGroup.of_comm_of_nhds_one {G : Type u} [CommGroup G] [TopologicalSpace G]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n    (hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n    (hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1)) : TopologicalGroup G", "start": [948, 1], "end": [953, 75], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.Quotient.topologicalSpace", "code": "@[to_additive]\ninstance QuotientGroup.Quotient.topologicalSpace {G : Type*} [Group G] [TopologicalSpace G]\n    (N : Subgroup G) : TopologicalSpace (G \u29f8 N) :=\n  instTopologicalSpaceQuotient", "start": [963, 1], "end": [966, 31], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.isOpenMap_coe", "code": "@[to_additive]\ntheorem QuotientGroup.isOpenMap_coe : IsOpenMap ((\u2191) : G \u2192 G \u29f8 N)", "start": [972, 1], "end": [977, 79], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_quotient", "code": "@[to_additive]\ninstance topologicalGroup_quotient [N.Normal] : TopologicalGroup (G \u29f8 N) where\n  continuous_mul := by\n    have cont : Continuous (((\u2191) : G \u2192 G \u29f8 N) \u2218 fun p : G \u00d7 G \u21a6 p.fst * p.snd) :=\n      continuous_quot_mk.comp continuous_mul\n    have quot : QuotientMap fun p : G \u00d7 G \u21a6 ((p.1 : G \u29f8 N), (p.2 : G \u29f8 N)) := by\n      apply IsOpenMap.to_quotientMap\n      \u00b7 exact (QuotientGroup.isOpenMap_coe N).prod (QuotientGroup.isOpenMap_coe N)\n      \u00b7 exact continuous_quot_mk.prod_map continuous_quot_mk\n      \u00b7 exact (surjective_quot_mk _).Prod_map (surjective_quot_mk _)\n    exact quot.continuous_iff.2 cont\n  continuous_inv := by\n    have quot := IsOpenMap.to_quotientMap\n      (QuotientGroup.isOpenMap_coe N) continuous_quot_mk (surjective_quot_mk _)\n    rw [quot.continuous_iff]\n    exact continuous_quot_mk.comp continuous_inv", "start": [981, 1], "end": [996, 49], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.nhds_eq", "code": "@[to_additive\n  \"Neighborhoods in the quotient are precisely the map of neighborhoods in the prequotient.\"]\ntheorem QuotientGroup.nhds_eq (x : G) : \ud835\udcdd (x : G \u29f8 N) = Filter.map (\u2191) (\ud835\udcdd x)", "start": [1000, 1], "end": [1004, 90], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.exists_antitone_basis_nhds_one", "code": "@[to_additive\n  \"Any first countable topological additive group has an antitone neighborhood basis\n  `u : \u2115 \u2192 set G` for which `u (n + 1) + u (n + 1) \u2286 u n`.\n  The existence of such a neighborhood basis is a key tool for `QuotientAddGroup.completeSpace`\"]\ntheorem TopologicalGroup.exists_antitone_basis_nhds_one :\n    \u2203 u : \u2115 \u2192 Set G, (\ud835\udcdd 1).HasAntitoneBasis u \u2227 \u2200 n, u (n + 1) * u (n + 1) \u2286 u n", "start": [1011, 1], "end": [1033, 58], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.nhds_one_isCountablyGenerated", "code": "@[to_additive\n  \"In a first countable topological additive group `G` with normal additive subgroup\n  `N`, `0 : G \u29f8 N` has a countable neighborhood basis.\"]\ninstance QuotientGroup.nhds_one_isCountablyGenerated : (\ud835\udcdd (1 : G \u29f8 N)).IsCountablyGenerated :=\n  (QuotientGroup.nhds_eq N 1).symm \u25b8 map.isCountablyGenerated _ _", "start": [1037, 1], "end": [1043, 66], "kind": "commanddeclaration"}, {"full_name": "ContinuousSub", "code": "class ContinuousSub (G : Type*) [TopologicalSpace G] [Sub G] : Prop where\n  continuous_sub : Continuous fun p : G \u00d7 G => p.1 - p.2", "start": [1049, 1], "end": [1052, 57], "kind": "commanddeclaration"}, {"full_name": "ContinuousDiv", "code": "@[to_additive existing]\nclass ContinuousDiv (G : Type*) [TopologicalSpace G] [Div G] : Prop where\n  continuous_div' : Continuous fun p : G \u00d7 G => p.1 / p.2", "start": [1055, 1], "end": [1060, 58], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.to_continuousDiv", "code": "@[to_additive]\ninstance (priority := 100) TopologicalGroup.to_continuousDiv [TopologicalSpace G] [Group G]\n    [TopologicalGroup G] : ContinuousDiv G :=\n  \u27e8by\n    simp only [div_eq_mul_inv]\n    exact continuous_fst.mul continuous_snd.inv\u27e9", "start": [1064, 1], "end": [1069, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.div'", "code": "@[to_additive sub]\ntheorem Filter.Tendsto.div' {f g : \u03b1 \u2192 G} {l : Filter \u03b1} {a b : G} (hf : Tendsto f l (\ud835\udcdd a))\n    (hg : Tendsto g l (\ud835\udcdd b)) : Tendsto (fun x => f x / g x) l (\ud835\udcdd (a / b))", "start": [1081, 1], "end": [1084, 61], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_div'", "code": "@[to_additive const_sub]\ntheorem Filter.Tendsto.const_div' (b : G) {c : G} {f : \u03b1 \u2192 G} {l : Filter \u03b1}\n    (h : Tendsto f l (\ud835\udcdd c)) : Tendsto (fun k : \u03b1 => b / f k) l (\ud835\udcdd (b / c))", "start": [1088, 1], "end": [1091, 28], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.div_const'", "code": "@[to_additive sub_const]\ntheorem Filter.Tendsto.div_const' {c : G} {f : \u03b1 \u2192 G} {l : Filter \u03b1} (h : Tendsto f l (\ud835\udcdd c))\n    (b : G) : Tendsto (fun k : \u03b1 => f k / b) l (\ud835\udcdd (c / b))", "start": [1095, 1], "end": [1098, 28], "kind": "commanddeclaration"}, {"full_name": "Continuous.div'", "code": "@[to_additive (attr := continuity) sub]\ntheorem Continuous.div' (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x / g x", "start": [1104, 1], "end": [1106, 43], "kind": "commanddeclaration"}, {"full_name": "continuous_div_left'", "code": "@[to_additive (attr := continuity) continuous_sub_left]\ntheorem continuous_div_left' (a : G) : Continuous fun b : G => a / b", "start": [1110, 1], "end": [1112, 38], "kind": "commanddeclaration"}, {"full_name": "continuous_div_right'", "code": "@[to_additive (attr := continuity) continuous_sub_right]\ntheorem continuous_div_right' (a : G) : Continuous fun b : G => b / a", "start": [1116, 1], "end": [1118, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.div'", "code": "@[to_additive sub]\ntheorem ContinuousAt.div' {f g : \u03b1 \u2192 G} {x : \u03b1} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :\n    ContinuousAt (fun x => f x / g x) x", "start": [1122, 1], "end": [1125, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.div'", "code": "@[to_additive sub]\ntheorem ContinuousWithinAt.div' (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) :\n    ContinuousWithinAt (fun x => f x / g x) s x", "start": [1129, 1], "end": [1132, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.div'", "code": "@[to_additive sub]\ntheorem ContinuousOn.div' (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x / g x) s", "start": [1136, 1], "end": [1138, 80], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.divLeft", "code": "@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \" A version of `Homeomorph.addLeft a (-b)` that is defeq to `a - b`. \"]\ndef Homeomorph.divLeft (x : G) : G \u2243\u209c G :=\n  { Equiv.divLeft x with\n    continuous_toFun := continuous_const.div' continuous_id\n    continuous_invFun := continuous_inv.mul continuous_const }", "start": [1148, 1], "end": [1154, 63], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_div_left", "code": "@[to_additive]\ntheorem isOpenMap_div_left (a : G) : IsOpenMap ((\u00b7 / \u00b7) a)", "start": [1158, 1], "end": [1160, 35], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_div_left", "code": "@[to_additive]\ntheorem isClosedMap_div_left (a : G) : IsClosedMap ((\u00b7 / \u00b7) a)", "start": [1164, 1], "end": [1166, 37], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.divRight", "code": "@[to_additive (attr := simps! (config := { simpRhs := true }))\n  \"A version of `Homeomorph.addRight (-a) b` that is defeq to `b - a`. \"]\ndef Homeomorph.divRight (x : G) : G \u2243\u209c G :=\n  { Equiv.divRight x with\n    continuous_toFun := continuous_id.div' continuous_const\n    continuous_invFun := continuous_id.mul continuous_const }", "start": [1170, 1], "end": [1176, 62], "kind": "commanddeclaration"}, {"full_name": "isOpenMap_div_right", "code": "@[to_additive]\ntheorem isOpenMap_div_right (a : G) : IsOpenMap fun x => x / a", "start": [1180, 1], "end": [1182, 36], "kind": "commanddeclaration"}, {"full_name": "isClosedMap_div_right", "code": "@[to_additive]\ntheorem isClosedMap_div_right (a : G) : IsClosedMap fun x => x / a", "start": [1186, 1], "end": [1188, 38], "kind": "commanddeclaration"}, {"full_name": "tendsto_div_nhds_one_iff", "code": "@[to_additive]\ntheorem tendsto_div_nhds_one_iff {\u03b1 : Type*} {l : Filter \u03b1} {x : G} {u : \u03b1 \u2192 G} :\n    Tendsto (fun n => u n / x) l (\ud835\udcdd 1) \u2194 Tendsto u l (\ud835\udcdd x)", "start": [1192, 1], "end": [1196, 70], "kind": "commanddeclaration"}, {"full_name": "nhds_translation_div", "code": "@[to_additive]\ntheorem nhds_translation_div (x : G) : comap (\u00b7 / x) (\ud835\udcdd 1) = \ud835\udcdd x", "start": [1200, 1], "end": [1202, 63], "kind": "commanddeclaration"}, {"full_name": "IsOpen.smul_left", "code": "@[to_additive]\ntheorem IsOpen.smul_left (ht : IsOpen t) : IsOpen (s \u2022 t)", "start": [1222, 1], "end": [1225, 44], "kind": "commanddeclaration"}, {"full_name": "subset_interior_smul_right", "code": "@[to_additive]\ntheorem subset_interior_smul_right : s \u2022 interior t \u2286 interior (s \u2022 t)", "start": [1229, 1], "end": [1231, 89], "kind": "commanddeclaration"}, {"full_name": "smul_mem_nhds", "code": "@[to_additive]\ntheorem smul_mem_nhds (a : \u03b1) {x : \u03b2} (ht : t \u2208 \ud835\udcdd x) : a \u2022 t \u2208 \ud835\udcdd (a \u2022 x)", "start": [1235, 1], "end": [1238, 86], "kind": "commanddeclaration"}, {"full_name": "subset_interior_smul", "code": "@[to_additive]\ntheorem subset_interior_smul : interior s \u2022 interior t \u2286 interior (s \u2022 t)", "start": [1244, 1], "end": [1246, 80], "kind": "commanddeclaration"}, {"full_name": "IsClosed.smul_left_of_isCompact", "code": "@[to_additive]\ntheorem IsClosed.smul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (s \u2022 t)", "start": [1257, 1], "end": [1276, 52], "kind": "commanddeclaration"}, {"full_name": "MulAction.isClosedMap_quotient", "code": "@[to_additive]\ntheorem MulAction.isClosedMap_quotient [CompactSpace \u03b1] :\n    letI := orbitRel \u03b1 \u03b2\n    IsClosedMap (Quotient.mk' : \u03b2 \u2192 Quotient (orbitRel \u03b1 \u03b2))", "start": [1292, 1], "end": [1300, 6], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mul_left", "code": "@[to_additive]\ntheorem IsOpen.mul_left : IsOpen t \u2192 IsOpen (s * t)", "start": [1308, 1], "end": [1310, 19], "kind": "commanddeclaration"}, {"full_name": "subset_interior_mul_right", "code": "@[to_additive]\ntheorem subset_interior_mul_right : s * interior t \u2286 interior (s * t)", "start": [1314, 1], "end": [1316, 29], "kind": "commanddeclaration"}, {"full_name": "subset_interior_mul", "code": "@[to_additive]\ntheorem subset_interior_mul : interior s * interior t \u2286 interior (s * t)", "start": [1320, 1], "end": [1322, 23], "kind": "commanddeclaration"}, {"full_name": "singleton_mul_mem_nhds", "code": "@[to_additive]\ntheorem singleton_mul_mem_nhds (a : \u03b1) {b : \u03b1} (h : s \u2208 \ud835\udcdd b) : {a} * s \u2208 \ud835\udcdd (a * b)", "start": [1326, 1], "end": [1329, 33], "kind": "commanddeclaration"}, {"full_name": "singleton_mul_mem_nhds_of_nhds_one", "code": "@[to_additive]\ntheorem singleton_mul_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : {a} * s \u2208 \ud835\udcdd a", "start": [1333, 1], "end": [1335, 56], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mul_right", "code": "@[to_additive]\ntheorem IsOpen.mul_right (hs : IsOpen s) : IsOpen (s * t)", "start": [1345, 1], "end": [1348, 44], "kind": "commanddeclaration"}, {"full_name": "subset_interior_mul_left", "code": "@[to_additive]\ntheorem subset_interior_mul_left : interior s * t \u2286 interior (s * t)", "start": [1352, 1], "end": [1354, 88], "kind": "commanddeclaration"}, {"full_name": "subset_interior_mul'", "code": "@[to_additive]\ntheorem subset_interior_mul' : interior s * interior t \u2286 interior (s * t)", "start": [1358, 1], "end": [1360, 75], "kind": "commanddeclaration"}, {"full_name": "mul_singleton_mem_nhds", "code": "@[to_additive]\ntheorem mul_singleton_mem_nhds (a : \u03b1) {b : \u03b1} (h : s \u2208 \ud835\udcdd b) : s * {a} \u2208 \ud835\udcdd (b * a)", "start": [1364, 1], "end": [1367, 26], "kind": "commanddeclaration"}, {"full_name": "mul_singleton_mem_nhds_of_nhds_one", "code": "@[to_additive]\ntheorem mul_singleton_mem_nhds_of_nhds_one (a : \u03b1) (h : s \u2208 \ud835\udcdd (1 : \u03b1)) : s * {a} \u2208 \ud835\udcdd a", "start": [1371, 1], "end": [1373, 56], "kind": "commanddeclaration"}, {"full_name": "IsOpen.div_left", "code": "@[to_additive]\ntheorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t)", "start": [1383, 1], "end": [1386, 60], "kind": "commanddeclaration"}, {"full_name": "IsOpen.div_right", "code": "@[to_additive]\ntheorem IsOpen.div_right (hs : IsOpen s) : IsOpen (s / t)", "start": [1390, 1], "end": [1393, 61], "kind": "commanddeclaration"}, {"full_name": "subset_interior_div_left", "code": "@[to_additive]\ntheorem subset_interior_div_left : interior s / t \u2286 interior (s / t)", "start": [1397, 1], "end": [1399, 84], "kind": "commanddeclaration"}, {"full_name": "subset_interior_div_right", "code": "@[to_additive]\ntheorem subset_interior_div_right : s / interior t \u2286 interior (s / t)", "start": [1403, 1], "end": [1405, 82], "kind": "commanddeclaration"}, {"full_name": "subset_interior_div", "code": "@[to_additive]\ntheorem subset_interior_div : interior s / interior t \u2286 interior (s / t)", "start": [1409, 1], "end": [1411, 71], "kind": "commanddeclaration"}, {"full_name": "IsOpen.mul_closure", "code": "@[to_additive]\ntheorem IsOpen.mul_closure (hs : IsOpen s) (t : Set \u03b1) : s * closure t = s * t", "start": [1415, 1], "end": [1421, 51], "kind": "commanddeclaration"}, {"full_name": "IsOpen.closure_mul", "code": "@[to_additive]\ntheorem IsOpen.closure_mul (ht : IsOpen t) (s : Set \u03b1) : closure s * t = s * t", "start": [1425, 1], "end": [1428, 13], "kind": "commanddeclaration"}, {"full_name": "IsOpen.div_closure", "code": "@[to_additive]\ntheorem IsOpen.div_closure (hs : IsOpen s) (t : Set \u03b1) : s / closure t = s / t", "start": [1432, 1], "end": [1434, 56], "kind": "commanddeclaration"}, {"full_name": "IsOpen.closure_div", "code": "@[to_additive]\ntheorem IsOpen.closure_div (ht : IsOpen t) (s : Set \u03b1) : closure s / t = s / t", "start": [1438, 1], "end": [1440, 47], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mul_left_of_isCompact", "code": "@[to_additive]\ntheorem IsClosed.mul_left_of_isCompact (ht : IsClosed t) (hs : IsCompact s) : IsClosed (s * t)", "start": [1444, 1], "end": [1446, 31], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mul_right_of_isCompact", "code": "@[to_additive]\ntheorem IsClosed.mul_right_of_isCompact (ht : IsClosed t) (hs : IsCompact s) :\n    IsClosed (t * s)", "start": [1448, 1], "end": [1452, 68], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.isClosedMap_coe", "code": "@[to_additive]\ntheorem QuotientGroup.isClosedMap_coe {H : Subgroup \u03b1} (hH : IsCompact (H : Set \u03b1)) :\n    IsClosedMap ((\u2191) : \u03b1 \u2192 \u03b1 \u29f8 H)", "start": [1454, 1], "end": [1462, 6], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.t1Space", "code": "@[to_additive]\ntheorem TopologicalGroup.t1Space (h : @IsClosed G _ {1}) : T1Space G", "start": [1472, 1], "end": [1474, 56], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.regularSpace", "code": "@[to_additive]\ninstance (priority := 100) TopologicalGroup.regularSpace : RegularSpace G := by\n  refine' RegularSpace.ofExistsMemNhdsIsClosedSubset fun a s hs => _\n  have : Tendsto (fun p : G \u00d7 G => p.1 * p.2) (\ud835\udcdd (a, 1)) (\ud835\udcdd a) :=\n    continuous_mul.tendsto' _ _ (mul_one a)\n  rcases mem_nhds_prod_iff.mp (this hs) with \u27e8U, hU, V, hV, hUV\u27e9\n  rw [\u2190 image_subset_iff, image_prod] at hUV\n  refine' \u27e8closure U, mem_of_superset hU subset_closure, isClosed_closure, _\u27e9\n  calc\n    closure U \u2286 closure U * interior V := subset_mul_left _ (mem_interior_iff_mem_nhds.2 hV)\n    _ = U * interior V := isOpen_interior.closure_mul U\n    _ \u2286 U * V := mul_subset_mul_left interior_subset\n    _ \u2286 s := hUV", "start": [1484, 1], "end": [1496, 17], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.t2Space_iff_one_closed", "code": "@[to_additive]\ntheorem TopologicalGroup.t2Space_iff_one_closed : T2Space G \u2194 IsClosed ({1} : Set G)", "start": [1508, 1], "end": [1511, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.t2Space_of_one_sep", "code": "@[to_additive]\ntheorem TopologicalGroup.t2Space_of_one_sep (H : \u2200 x : G, x \u2260 1 \u2192 \u2203 U \u2208 \ud835\udcdd (1 : G), x \u2209 U) :\n    T2Space G", "start": [1515, 1], "end": [1521, 94], "kind": "commanddeclaration"}, {"full_name": "exists_closed_nhds_one_inv_eq_mul_subset", "code": "@[to_additive \"Given a neighborhood `U` of the identity, one may find a neighborhood `V` of the\nidentity which is closed, symmetric, and satisfies `V + V \u2286 U`.\"]\ntheorem exists_closed_nhds_one_inv_eq_mul_subset {U : Set G} (hU : U \u2208 \ud835\udcdd 1) :\n    \u2203 V \u2208 \ud835\udcdd 1, IsClosed V \u2227 V\u207b\u00b9 = V \u2227 V * V \u2286 U", "start": [1525, 1], "end": [1539, 14], "kind": "commanddeclaration"}, {"full_name": "Subgroup.t3_quotient_of_isClosed", "code": "@[to_additive]\ninstance Subgroup.t3_quotient_of_isClosed (S : Subgroup G) [Subgroup.Normal S]\n    [hS : IsClosed (S : Set G)] : T3Space (G \u29f8 S) := by\n  rw [\u2190 QuotientGroup.ker_mk' S] at hS\n  haveI := TopologicalGroup.t1Space (G \u29f8 S) (quotientMap_quotient_mk'.isClosed_preimage.mp hS)\n  infer_instance", "start": [1543, 1], "end": [1548, 17], "kind": "commanddeclaration"}, {"full_name": "Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite", "code": "@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly\n  discontinuously on the left, if it is discrete in the sense that `S \u2229 K` is finite for all compact\n  `K`. (See also `DiscreteTopology`.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S G", "start": [1552, 1], "end": [1568, 43], "kind": "commanddeclaration"}, {"full_name": "Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite", "code": "@[to_additive\n  \"A subgroup `S` of an additive topological group `G` acts on `G` properly discontinuously\n  on the right, if it is discrete in the sense that `S \u2229 K` is finite for all compact `K`.\n  (See also `DiscreteTopology`.)\n\n  If `G` is Hausdorff, this can be combined with `t2Space_of_properlyDiscontinuousVAdd_of_t2Space`\n  to show that the quotient group `G \u29f8 S` is Hausdorff.\"]\ntheorem Subgroup.properlyDiscontinuousSMul_opposite_of_tendsto_cofinite (S : Subgroup G)\n    (hS : Tendsto S.subtype cofinite (cocompact G)) : ProperlyDiscontinuousSMul S.op G", "start": [1574, 1], "end": [1599, 45], "kind": "commanddeclaration"}, {"full_name": "compact_open_separated_mul_right", "code": "@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `K + V \u2286 U`.\"]\ntheorem compact_open_separated_mul_right {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K \u2286 U) : \u2203 V \u2208 \ud835\udcdd (1 : G), K * V \u2286 U", "start": [1612, 1], "end": [1634, 55], "kind": "commanddeclaration"}, {"full_name": "compact_open_separated_mul_left", "code": "@[to_additive\n  \"Given a compact set `K` inside an open set `U`, there is an open neighborhood `V` of\n  `0` such that `V + K \u2286 U`.\"]\ntheorem compact_open_separated_mul_left {K U : Set G} (hK : IsCompact K) (hU : IsOpen U)\n    (hKU : K \u2286 U) : \u2203 V \u2208 \ud835\udcdd (1 : G), V * K \u2286 U", "start": [1640, 1], "end": [1652, 45], "kind": "commanddeclaration"}, {"full_name": "compact_covered_by_mul_left_translates", "code": "@[to_additive\n  \"A compact set is covered by finitely many left additive translates of a set\n    with non-empty interior.\"]\ntheorem compact_covered_by_mul_left_translates {K V : Set G} (hK : IsCompact K)\n    (hV : (interior V).Nonempty) : \u2203 t : Finset G, K \u2286 \u22c3 g \u2208 t, (fun h => g * h) \u207b\u00b9' V", "start": [1662, 1], "end": [1676, 72], "kind": "commanddeclaration"}, {"full_name": "SeparableWeaklyLocallyCompactGroup.sigmaCompactSpace", "code": "@[to_additive SeparableWeaklyLocallyCompactAddGroup.sigmaCompactSpace\n  \"Every weakly locally compact separable topological additive group is \u03c3-compact.\n  Note: this is not true if we drop the topological group hypothesis.\"]\ninstance (priority := 100) SeparableWeaklyLocallyCompactGroup.sigmaCompactSpace [SeparableSpace G]\n    [WeaklyLocallyCompactSpace G] : SigmaCompactSpace G := by\n  obtain \u27e8L, hLc, hL1\u27e9 := exists_compact_mem_nhds (1 : G)\n  refine' \u27e8\u27e8fun n => (fun x => x * denseSeq G n) \u207b\u00b9' L, _, _\u27e9\u27e9\n  \u00b7 intro n\n    exact (Homeomorph.mulRight _).isCompact_preimage.mpr hLc\n  \u00b7 refine' iUnion_eq_univ_iff.2 fun x => _\n    obtain \u27e8_, \u27e8n, rfl\u27e9, hn\u27e9 : (range (denseSeq G) \u2229 (fun y => x * y) \u207b\u00b9' L).Nonempty := by\n      rw [\u2190 (Homeomorph.mulLeft x).apply_symm_apply 1] at hL1\n      exact (denseRange_denseSeq G).inter_nhds_nonempty\n          ((Homeomorph.mulLeft x).continuous.continuousAt <| hL1)\n    exact \u27e8n, hn\u27e9", "start": [1680, 1], "end": [1696, 18], "kind": "commanddeclaration"}, {"full_name": "exists_disjoint_smul_of_isCompact", "code": "@[to_additive\n  \"Given two compact sets in a noncompact additive topological group, there is a\n  translate of the second one that is disjoint from the first one.\"]\ntheorem exists_disjoint_smul_of_isCompact [NoncompactSpace G] {K L : Set G} (hK : IsCompact K)\n    (hL : IsCompact L) : \u2203 g : G, Disjoint K (g \u2022 L)", "start": [1700, 1], "end": [1715, 48], "kind": "commanddeclaration"}, {"full_name": "exists_isCompact_isClosed_subset_isCompact_nhds_one", "code": "@[to_additive \"A compact neighborhood of `0` in a topological additive group\nadmits a closed compact subset that is a neighborhood of `0`.\"]\ntheorem exists_isCompact_isClosed_subset_isCompact_nhds_one\n    {L : Set G} (Lcomp : IsCompact L) (L1 : L \u2208 \ud835\udcdd (1 : G)) :\n    \u2203 K : Set G, IsCompact K \u2227 IsClosed K \u2227 K \u2286 L \u2227 K \u2208 \ud835\udcdd (1 : G)", "start": [1719, 1], "end": [1727, 68], "kind": "commanddeclaration"}, {"full_name": "local_isCompact_isClosed_nhds_of_group", "code": "@[to_additive\n  \"In a locally compact additive group, any neighborhood of the identity contains a\n  compact closed neighborhood of the identity, even without separation assumptions on the space.\"]\ntheorem local_isCompact_isClosed_nhds_of_group [LocallyCompactSpace G] {U : Set G}\n    (hU : U \u2208 \ud835\udcdd (1 : G)) :\n    \u2203 K : Set G, IsCompact K \u2227 IsClosed K \u2227 K \u2286 U \u2227 (1 : G) \u2208 interior K", "start": [1729, 1], "end": [1740, 69], "kind": "commanddeclaration"}, {"full_name": "exists_isCompact_isClosed_nhds_one", "code": "@[to_additive]\ntheorem exists_isCompact_isClosed_nhds_one [WeaklyLocallyCompactSpace G] :\n    \u2203 K : Set G, IsCompact K \u2227 IsClosed K \u2227 K \u2208 \ud835\udcdd 1", "start": [1746, 1], "end": [1751, 22], "kind": "commanddeclaration"}, {"full_name": "nhds_mul", "code": "@[to_additive]\ntheorem nhds_mul (x y : G) : \ud835\udcdd (x * y) = \ud835\udcdd x * \ud835\udcdd y", "start": [1759, 1], "end": [1767, 24], "kind": "commanddeclaration"}, {"full_name": "nhdsMulHom", "code": "@[to_additive (attr := simps)\n  \"On an additive topological group, `\ud835\udcdd : G \u2192 Filter G` can be promoted to an `AddHom`.\"]\ndef nhdsMulHom : G \u2192\u2099* Filter G where\n  toFun := \ud835\udcdd\n  map_mul' _ _ := nhds_mul _ _", "start": [1771, 1], "end": [1776, 31], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.continuousConstSMul", "code": "@[to_additive]\ninstance QuotientGroup.continuousConstSMul : ContinuousConstSMul G (G \u29f8 \u0393) where\n  continuous_const_smul g := by\n     convert ((@continuous_const _ _ _ _ g).mul continuous_id).quotient_map' _", "start": [1796, 1], "end": [1799, 79], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.continuous_smul\u2081", "code": "@[to_additive]\ntheorem QuotientGroup.continuous_smul\u2081 (x : G \u29f8 \u0393) : Continuous fun g : G => g \u2022 x", "start": [1803, 1], "end": [1806, 62], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.secondCountableTopology", "code": "@[to_additive\n  \"The quotient of a second countable additive topological group by a subgroup is second\n  countable.\"]\ninstance QuotientGroup.secondCountableTopology [SecondCountableTopology G] :\n    SecondCountableTopology (G \u29f8 \u0393) :=\n  ContinuousConstSMul.secondCountableTopology", "start": [1810, 1], "end": [1816, 46], "kind": "commanddeclaration"}, {"full_name": "toUnits_homeomorph", "code": "@[to_additive \" If `G` is an additive group with topological negation, then it is homeomorphic to\nits additive units.\"]\ndef toUnits_homeomorph [Group G] [TopologicalSpace G] [ContinuousInv G] : G \u2243\u209c G\u02e3 where\n  toEquiv := toUnits.toEquiv\n  continuous_toFun := Units.continuous_iff.2 \u27e8continuous_id, continuous_inv\u27e9\n  continuous_invFun := Units.continuous_val", "start": [1822, 1], "end": [1828, 44], "kind": "commanddeclaration"}, {"full_name": "Units.embedding_val", "code": "@[to_additive] theorem Units.embedding_val [Group G] [TopologicalSpace G] [ContinuousInv G] :\n    Embedding (val : G\u02e3 \u2192 G)", "start": [1832, 1], "end": [1834, 36], "kind": "commanddeclaration"}, {"full_name": "Units.Homeomorph.prodUnits", "code": "@[to_additive\n  \"The topological group isomorphism between the additive units of a product of two\n  additive monoids, and the product of the additive units of each additive monoid.\"]\ndef Homeomorph.prodUnits : (\u03b1 \u00d7 \u03b2)\u02e3 \u2243\u209c \u03b1\u02e3 \u00d7 \u03b2\u02e3 where\n  continuous_toFun :=\n    (continuous_fst.units_map (MonoidHom.fst \u03b1 \u03b2)).prod_mk\n      (continuous_snd.units_map (MonoidHom.snd \u03b1 \u03b2))\n  continuous_invFun :=\n    Units.continuous_iff.2\n      \u27e8continuous_val.fst'.prod_mk continuous_val.snd',\n        continuous_coe_inv.fst'.prod_mk continuous_coe_inv.snd'\u27e9\n  toEquiv := MulEquiv.prodUnits.toEquiv", "start": [1846, 1], "end": [1859, 40], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_sInf", "code": "@[to_additive]\ntheorem topologicalGroup_sInf {ts : Set (TopologicalSpace G)}\n    (h : \u2200 t \u2208 ts, @TopologicalGroup G t _) : @TopologicalGroup G (sInf ts) _", "start": [1869, 1], "end": [1877, 60], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_iInf", "code": "@[to_additive]\ntheorem topologicalGroup_iInf {ts' : \u03b9 \u2192 TopologicalSpace G}\n    (h' : \u2200 i, @TopologicalGroup G (ts' i) _) : @TopologicalGroup G (\u2a05 i, ts' i) _", "start": [1881, 1], "end": [1885, 60], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_inf", "code": "@[to_additive]\ntheorem topologicalGroup_inf {t\u2081 t\u2082 : TopologicalSpace G} (h\u2081 : @TopologicalGroup G t\u2081 _)\n    (h\u2082 : @TopologicalGroup G t\u2082 _) : @TopologicalGroup G (t\u2081 \u2293 t\u2082) _", "start": [1889, 1], "end": [1894, 25], "kind": "commanddeclaration"}, {"full_name": "GroupTopology", "code": "structure GroupTopology (\u03b1 : Type u) [Group \u03b1] extends TopologicalSpace \u03b1, TopologicalGroup \u03b1 :\n  Type u", "start": [1915, 1], "end": [1918, 9], "kind": "commanddeclaration"}, {"full_name": "AddGroupTopology", "code": "structure AddGroupTopology (\u03b1 : Type u) [AddGroup \u03b1] extends TopologicalSpace \u03b1,\n  TopologicalAddGroup \u03b1 : Type u", "start": [1921, 1], "end": [1924, 33], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.continuous_mul'", "code": "@[to_additive \"A version of the global `continuous_add` suitable for dot notation.\"]\ntheorem continuous_mul' (g : GroupTopology \u03b1) :\n    haveI := g.toTopologicalSpace\n    Continuous fun p : \u03b1 \u00d7 \u03b1 => p.1 * p.2", "start": [1933, 1], "end": [1940, 23], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.continuous_inv'", "code": "@[to_additive \"A version of the global `continuous_neg` suitable for dot notation.\"]\ntheorem continuous_inv' (g : GroupTopology \u03b1) :\n    haveI := g.toTopologicalSpace\n    Continuous (Inv.inv : \u03b1 \u2192 \u03b1)", "start": [1944, 1], "end": [1951, 23], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_injective", "code": "@[to_additive]\ntheorem toTopologicalSpace_injective :\n    Function.Injective (toTopologicalSpace : GroupTopology \u03b1 \u2192 TopologicalSpace \u03b1)", "start": [1955, 1], "end": [1961, 10], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.ext'", "code": "@[to_additive (attr := ext)]\ntheorem ext' {f g : GroupTopology \u03b1} (h : f.IsOpen = g.IsOpen) : f = g", "start": [1965, 1], "end": [1967, 57], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_le", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_le {x y : GroupTopology \u03b1} :\n    x.toTopologicalSpace \u2264 y.toTopologicalSpace \u2194 x \u2264 y", "start": [1979, 1], "end": [1982, 10], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_top", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_top : (\u22a4 : GroupTopology \u03b1).toTopologicalSpace = \u22a4", "start": [1992, 1], "end": [1994, 6], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_bot", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_bot : (\u22a5 : GroupTopology \u03b1).toTopologicalSpace = \u22a5", "start": [2006, 1], "end": [2008, 6], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_inf", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_inf (x y : GroupTopology \u03b1) :\n    (x \u2293 y).toTopologicalSpace = x.toTopologicalSpace \u2293 y.toTopologicalSpace", "start": [2022, 1], "end": [2025, 6], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_sInf", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_sInf (s : Set (GroupTopology \u03b1)) :\n    (sInf s).toTopologicalSpace = sInf (toTopologicalSpace '' s)", "start": [2045, 1], "end": [2047, 72], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.toTopologicalSpace_iInf", "code": "@[to_additive (attr := simp)]\ntheorem toTopologicalSpace_iInf {\u03b9} (s : \u03b9 \u2192 GroupTopology \u03b1) :\n    (\u2a05 i, s i).toTopologicalSpace = \u2a05 i, (s i).toTopologicalSpace", "start": [2051, 1], "end": [2054, 39], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.coinduced", "code": "@[to_additive\n  \"Given `f : \u03b1 \u2192 \u03b2` and a topology on `\u03b1`, the coinduced additive group topology on `\u03b2`\n  is the finest topology such that `f` is continuous and `\u03b2` is a topological additive group.\"]\ndef coinduced {\u03b1 \u03b2 : Type*} [t : TopologicalSpace \u03b1] [Group \u03b2] (f : \u03b1 \u2192 \u03b2) : GroupTopology \u03b2 :=\n  sInf { b : GroupTopology \u03b2 | TopologicalSpace.coinduced f t \u2264 b.toTopologicalSpace }", "start": [2094, 1], "end": [2100, 87], "kind": "commanddeclaration"}, {"full_name": "GroupTopology.coinduced_continuous", "code": "@[to_additive]\ntheorem coinduced_continuous {\u03b1 \u03b2 : Type*} [t : TopologicalSpace \u03b1] [Group \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    Continuous[t, (coinduced f).toTopologicalSpace] f", "start": [2104, 1], "end": [2109, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "imports": ["Mathlib/CategoryTheory/NatIso.lean", "Mathlib/Logic/Equiv/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Full", "code": "class Full (F : C \u2964 D) where\n  \n  preimage : \u2200 {X Y : C} (_ : F.obj X \u27f6 F.obj Y), X \u27f6 Y\n  \n  witness : \u2200 {X Y : C} (f : F.obj X \u27f6 F.obj Y), F.map (preimage f) = f := by aesop_cat", "start": [39, 1], "end": [49, 88], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful", "code": "class Faithful (F : C \u2964 D) : Prop where\n  \n  map_injective : \u2200 {X Y : C}, Function.Injective (F.map : (X \u27f6 Y) \u2192 (F.obj X \u27f6 F.obj Y)) := by\n    aesop_cat", "start": [58, 1], "end": [65, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_injective", "code": "theorem map_injective (F : C \u2964 D) [Faithful F] :\n    Function.Injective <| (F.map : (X \u27f6 Y) \u2192 (F.obj X \u27f6 F.obj Y))", "start": [73, 1], "end": [75, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.mapIso_injective", "code": "theorem mapIso_injective (F : C \u2964 D) [Faithful F] :\n    Function.Injective <| (F.mapIso : (X \u2245 Y) \u2192 (F.obj X \u2245 F.obj Y))", "start": [78, 1], "end": [80, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preimage", "code": "@[pp_dot]\ndef preimage (F : C \u2964 D) [Full F] (f : F.obj X \u27f6 F.obj Y) : X \u27f6 Y :=\n  Full.preimage.{v\u2081, v\u2082} f", "start": [83, 1], "end": [86, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.image_preimage", "code": "@[simp]\ntheorem image_preimage (F : C \u2964 D) [Full F] {X Y : C} (f : F.obj X \u27f6 F.obj Y) :\n    F.map (preimage F f) = f", "start": [89, 1], "end": [91, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_surjective", "code": "theorem map_surjective (F : C \u2964 D) [Full F] :\n    Function.Surjective (F.map : (X \u27f6 Y) \u2192 (F.obj X \u27f6 F.obj Y))", "start": [94, 1], "end": [96, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.fullOfExists", "code": "noncomputable def fullOfExists (F : C \u2964 D)\n    (h : \u2200 (X Y : C) (f : F.obj X \u27f6 F.obj Y), \u2203 p, F.map p = f) : Full F := by\n  choose p hp using h\n  exact \u27e8@p, @hp\u27e9", "start": [99, 1], "end": [103, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.fullOfSurjective", "code": "noncomputable def fullOfSurjective (F : C \u2964 D)\n    (h : \u2200 X Y : C, Function.Surjective (F.map : (X \u27f6 Y) \u2192 (F.obj X \u27f6 F.obj Y))) : Full F :=\n  fullOfExists _ h", "start": [106, 1], "end": [109, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preimage_id", "code": "@[simp]\ntheorem preimage_id : F.preimage (\ud835\udfd9 (F.obj X)) = \ud835\udfd9 X", "start": [118, 1], "end": [120, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preimage_comp", "code": "@[simp]\ntheorem preimage_comp (f : F.obj X \u27f6 F.obj Y) (g : F.obj Y \u27f6 F.obj Z) :\n    F.preimage (f \u226b g) = F.preimage f \u226b F.preimage g", "start": [123, 1], "end": [126, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.preimage_map", "code": "@[simp]\ntheorem preimage_map (f : X \u27f6 Y) : F.preimage (F.map f) = f", "start": [129, 1], "end": [131, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preimageIso", "code": "@[simps]\ndef preimageIso (f : F.obj X \u2245 F.obj Y) :\n    X \u2245 Y where\n  hom := F.preimage f.hom\n  inv := F.preimage f.inv\n  hom_inv_id := F.map_injective (by simp)\n  inv_hom_id := F.map_injective (by simp)", "start": [138, 1], "end": [145, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.preimageIso_mapIso", "code": "@[simp]\ntheorem preimageIso_mapIso (f : X \u2245 Y) : F.preimageIso (F.mapIso f) = f", "start": [150, 1], "end": [153, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_fully_faithful", "code": "theorem isIso_of_fully_faithful (f : X \u27f6 Y) [IsIso (F.map f)] : IsIso f", "start": [158, 1], "end": [162, 89], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.equivOfFullyFaithful", "code": "@[simps]\ndef equivOfFullyFaithful {X Y} :\n    (X \u27f6 Y) \u2243 (F.obj X \u27f6 F.obj Y) where\n  toFun f := F.map f\n  invFun f := F.preimage f\n  left_inv f := by simp\n  right_inv f := by simp", "start": [165, 1], "end": [172, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoEquivOfFullyFaithful", "code": "@[simps]\ndef isoEquivOfFullyFaithful {X Y} :\n    (X \u2245 Y) \u2243 (F.obj X \u2245 F.obj Y) where\n  toFun f := F.mapIso f\n  invFun f := F.preimageIso f\n  left_inv f := by simp\n  right_inv f := by\n    ext\n    simp", "start": [177, 1], "end": [186, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.natTransOfCompFullyFaithful", "code": "@[simps]\ndef natTransOfCompFullyFaithful (\u03b1 : F \u22d9 H \u27f6 G \u22d9 H) :\n    F \u27f6 G where\n  app X := (equivOfFullyFaithful H).symm (\u03b1.app X)\n  naturality X Y f := by\n    dsimp\n    apply H.map_injective\n    simpa using \u03b1.naturality f", "start": [197, 1], "end": [206, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.natIsoOfCompFullyFaithful", "code": "@[simps!]\ndef natIsoOfCompFullyFaithful (i : F \u22d9 H \u2245 G \u22d9 H) : F \u2245 G :=\n  NatIso.ofComponents (fun X => (isoEquivOfFullyFaithful H).symm (i.app X)) fun f => by\n    dsimp\n    apply H.map_injective\n    simpa using i.hom.naturality f", "start": [210, 1], "end": [217, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.natIsoOfCompFullyFaithful_hom", "code": "theorem natIsoOfCompFullyFaithful_hom (i : F \u22d9 H \u2245 G \u22d9 H) :\n    (natIsoOfCompFullyFaithful H i).hom = natTransOfCompFullyFaithful H i.hom", "start": [222, 1], "end": [225, 35], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.natIsoOfCompFullyFaithful_inv", "code": "theorem natIsoOfCompFullyFaithful_inv (i : F \u22d9 H \u2245 G \u22d9 H) :\n    (natIsoOfCompFullyFaithful H i).inv = natTransOfCompFullyFaithful H i.inv", "start": [228, 1], "end": [231, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.equivOfCompFullyFaithful", "code": "@[simps]\ndef NatTrans.equivOfCompFullyFaithful :\n    (F \u27f6 G) \u2243 (F \u22d9 H \u27f6 G \u22d9 H) where\n  toFun \u03b1 := \u03b1 \u25eb \ud835\udfd9 H\n  invFun := natTransOfCompFullyFaithful H\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [234, 1], "end": [242, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.equivOfCompFullyFaithful", "code": "@[simps]\ndef NatIso.equivOfCompFullyFaithful :\n    (F \u2245 G) \u2243 (F \u22d9 H \u2245 G \u22d9 H) where\n  toFun e := NatIso.hcomp e (Iso.refl H)\n  invFun := natIsoOfCompFullyFaithful H\n  left_inv := by aesop_cat\n  right_inv := by aesop_cat", "start": [247, 1], "end": [255, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.id", "code": "instance Full.id : Full (\ud835\udfed C) where preimage f := f", "start": [268, 1], "end": [268, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.id", "code": "instance Faithful.id : Faithful (\ud835\udfed C) := { }", "start": [271, 1], "end": [271, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.comp", "code": "instance Faithful.comp [Faithful F] [Faithful G] :\n    Faithful (F \u22d9 G) where map_injective p := F.map_injective (G.map_injective p)", "start": [278, 1], "end": [279, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.of_comp", "code": "theorem Faithful.of_comp [Faithful <| F \u22d9 G] : Faithful F", "start": [282, 1], "end": [284, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.ofIso", "code": "def Full.ofIso [Full F] (\u03b1 : F \u2245 F') :\n    Full F' where\n  preimage {X Y} f := F.preimage ((\u03b1.app X).hom \u226b f \u226b (\u03b1.app Y).inv)\n  witness f := by simp [\u2190NatIso.naturality_1 \u03b1]", "start": [291, 1], "end": [295, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.of_iso", "code": "theorem Faithful.of_iso [Faithful F] (\u03b1 : F \u2245 F') : Faithful F'", "start": [298, 1], "end": [300, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.of_comp_iso", "code": "theorem Faithful.of_comp_iso {H : C \u2964 E} [Faithful H] (h : F \u22d9 G \u2245 H) : Faithful F", "start": [307, 1], "end": [308, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.faithful_of_comp", "code": "alias _root_.CategoryTheory.Iso.faithful_of_comp := Faithful.of_comp_iso", "start": [311, 1], "end": [311, 73], "kind": "stdtacticaliasalias"}, {"full_name": "CategoryTheory.Faithful.of_comp_eq", "code": "theorem Faithful.of_comp_eq {H : C \u2964 E} [\u210b : Faithful H] (h : F \u22d9 G = H) : Faithful F", "start": [316, 1], "end": [317, 49], "kind": "commanddeclaration"}, {"full_name": "Eq.faithful_of_comp", "code": "alias _root_.Eq.faithful_of_comp := Faithful.of_comp_eq", "start": [320, 1], "end": [320, 56], "kind": "stdtacticaliasalias"}, {"full_name": "CategoryTheory.Faithful.div", "code": "protected def Faithful.div (F : C \u2964 E) (G : D \u2964 E) [Faithful G] (obj : C \u2192 D)\n    (h_obj : \u2200 X, G.obj (obj X) = F.obj X) (map : \u2200 {X Y}, (X \u27f6 Y) \u2192 (obj X \u27f6 obj Y))\n    (h_map : \u2200 {X Y} {f : X \u27f6 Y}, HEq (G.map (map f)) (F.map f)) : C \u2964 D :=\n  { obj, map := @map,\n    map_id := by\n      intros X\n      apply G.map_injective\n      apply eq_of_heq\n      trans F.map (\ud835\udfd9 X)\n      \u00b7 exact h_map\n      \u00b7 rw [F.map_id, G.map_id, h_obj X]\n    map_comp := by\n      intros X Y Z f g\n      refine G.map_injective <| eq_of_heq <| h_map.trans ?_\n      simp only [Functor.map_comp]\n      convert HEq.refl (F.map f \u226b F.map g)\n      all_goals { first | apply h_obj | apply h_map } }", "start": [324, 1], "end": [341, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.div_comp", "code": "theorem Faithful.div_comp (F : C \u2964 E) [Faithful F] (G : D \u2964 E) [Faithful G] (obj : C \u2192 D)\n    (h_obj : \u2200 X, G.obj (obj X) = F.obj X) (map : \u2200 {X Y}, (X \u27f6 Y) \u2192 (obj X \u27f6 obj Y))\n    (h_map : \u2200 {X Y} {f : X \u27f6 Y}, HEq (G.map (map f)) (F.map f)) :\n    Faithful.div F G obj @h_obj @map @h_map \u22d9 G = F", "start": [348, 1], "end": [363, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.div_faithful", "code": "theorem Faithful.div_faithful (F : C \u2964 E) [Faithful F] (G : D \u2964 E) [Faithful G] (obj : C \u2192 D)\n    (h_obj : \u2200 X, G.obj (obj X) = F.obj X) (map : \u2200 {X Y}, (X \u27f6 Y) \u2192 (obj X \u27f6 obj Y))\n    (h_map : \u2200 {X Y} {f : X \u27f6 Y}, HEq (G.map (map f)) (F.map f)) :\n    Faithful (Faithful.div F G obj @h_obj @map @h_map)", "start": [366, 1], "end": [370, 60], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.comp", "code": "instance Full.comp [Full F] [Full G] :\n    Full (F \u22d9 G) where preimage f := F.preimage (G.preimage f)", "start": [373, 1], "end": [374, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.ofCompFaithful", "code": "def Full.ofCompFaithful [Full <| F \u22d9 G] [Faithful G] :\n    Full F where\n  preimage f := (F \u22d9 G).preimage (G.map f)\n  witness _ := G.map_injective ((F \u22d9 G).image_preimage _)", "start": [377, 1], "end": [381, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.ofCompFaithfulIso", "code": "def Full.ofCompFaithfulIso {F : C \u2964 D} {G : D \u2964 E} {H : C \u2964 E} [Full H] [Faithful G]\n    (h : F \u22d9 G \u2245 H) : Full F :=\n  @Full.ofCompFaithful _ _ _ _ _ _ F G (Full.ofIso h.symm) _", "start": [384, 1], "end": [387, 61], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullyFaithfulCancelRight", "code": "def fullyFaithfulCancelRight {F G : C \u2964 D} (H : D \u2964 E) [Full H] [Faithful H]\n    (comp_iso : F \u22d9 H \u2245 G \u22d9 H) : F \u2245 G :=\n  NatIso.ofComponents (fun X => H.preimageIso (comp_iso.app X)) fun f =>\n    H.map_injective (by simpa using comp_iso.hom.naturality f)", "start": [390, 1], "end": [396, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullyFaithfulCancelRight_hom_app", "code": "@[simp]\ntheorem fullyFaithfulCancelRight_hom_app {F G : C \u2964 D} {H : D \u2964 E} [Full H] [Faithful H]\n    (comp_iso : F \u22d9 H \u2245 G \u22d9 H) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).hom.app X = H.preimage (comp_iso.hom.app X)", "start": [399, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullyFaithfulCancelRight_inv_app", "code": "@[simp]\ntheorem fullyFaithfulCancelRight_inv_app {F G : C \u2964 D} {H : D \u2964 E} [Full H] [Faithful H]\n    (comp_iso : F \u22d9 H \u2245 G \u22d9 H) (X : C) :\n    (fullyFaithfulCancelRight H comp_iso).inv.app X = H.preimage (comp_iso.inv.app X)", "start": [406, 1], "end": [410, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/DirectSum/Module.lean", "imports": ["Mathlib/LinearAlgebra/Basis.lean", "Mathlib/Algebra/DirectSum/Basic.lean", "Mathlib/LinearAlgebra/DFinsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "DirectSum.smul_apply", "code": "theorem smul_apply (b : R) (v : \u2a01 i, M i) (i : \u03b9) : (b \u2022 v) i = b \u2022 v i", "start": [57, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lmk", "code": "def lmk : \u2200 s : Finset \u03b9, (\u2200 i : (\u2191s : Set \u03b9), M i.val) \u2192\u2097[R] \u2a01 i, M i :=\n  DFinsupp.lmk", "start": [63, 1], "end": [65, 15], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lof", "code": "def lof : \u2200 i : \u03b9, M i \u2192\u2097[R] \u2a01 i, M i :=\n  DFinsupp.lsingle", "start": [68, 1], "end": [70, 19], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lof_eq_of", "code": "theorem lof_eq_of (i : \u03b9) (b : M i) : lof R \u03b9 M i b = of M i b", "start": [73, 1], "end": [73, 70], "kind": "commanddeclaration"}, {"full_name": "DirectSum.single_eq_lof", "code": "theorem single_eq_lof (i : \u03b9) (b : M i) : DFinsupp.single i b = lof R \u03b9 M i b", "start": [78, 1], "end": [78, 85], "kind": "commanddeclaration"}, {"full_name": "DirectSum.mk_smul", "code": "theorem mk_smul (s : Finset \u03b9) (c : R) (x) : mk M s (c \u2022 x) = c \u2022 mk M s x", "start": [81, 1], "end": [83, 29], "kind": "commanddeclaration"}, {"full_name": "DirectSum.of_smul", "code": "theorem of_smul (i : \u03b9) (c : R) (x) : of M i (c \u2022 x) = c \u2022 of M i x", "start": [86, 1], "end": [88, 29], "kind": "commanddeclaration"}, {"full_name": "DirectSum.support_smul", "code": "theorem support_smul [\u2200 (i : \u03b9) (x : M i), Decidable (x \u2260 0)] (c : R) (v : \u2a01 i, M i) :\n    (c \u2022 v).support \u2286 v.support", "start": [93, 1], "end": [95, 28], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toModule", "code": "def toModule : (\u2a01 i, M i) \u2192\u2097[R] N :=\n  FunLike.coe (DFinsupp.lsum \u2115) \u03c6", "start": [104, 1], "end": [106, 34], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coe_toModule_eq_coe_toAddMonoid", "code": "theorem coe_toModule_eq_coe_toAddMonoid :\n    (toModule R \u03b9 N \u03c6 : (\u2a01 i, M i) \u2192 N) = toAddMonoid fun i \u21a6 (\u03c6 i).toAddMonoidHom", "start": [109, 1], "end": [112, 90], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toModule_lof", "code": "@[simp]\ntheorem toModule_lof (i) (x : M i) : toModule R \u03b9 N \u03c6 (lof R \u03b9 M i x) = \u03c6 i x", "start": [117, 1], "end": [121, 52], "kind": "commanddeclaration"}, {"full_name": "DirectSum.toModule.unique", "code": "theorem toModule.unique (f : \u2a01 i, M i) : \u03c8 f = toModule R \u03b9 N (fun i \u21a6 \u03c8.comp <| lof R \u03b9 M i) f", "start": [126, 1], "end": [129, 40], "kind": "commanddeclaration"}, {"full_name": "DirectSum.linearMap_ext", "code": "@[ext]\ntheorem linearMap_ext \u2983\u03c8 \u03c8' : (\u2a01 i, M i) \u2192\u2097[R] N\u2984\n    (H : \u2200 i, \u03c8.comp (lof R \u03b9 M i) = \u03c8'.comp (lof R \u03b9 M i)) : \u03c8 = \u03c8'", "start": [134, 1], "end": [140, 23], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lsetToSet", "code": "def lsetToSet (S T : Set \u03b9) (H : S \u2286 T) : (\u2a01 i : S, M i) \u2192\u2097[R] \u2a01 i : T, M i :=\n  toModule R _ _ fun i \u21a6 lof R T (fun i : Subtype T \u21a6 M i) \u27e8i, H i.prop\u27e9", "start": [143, 1], "end": [146, 73], "kind": "commanddeclaration"}, {"full_name": "DirectSum.linearEquivFunOnFintype", "code": "@[simps apply]\ndef linearEquivFunOnFintype [Fintype \u03b9] : (\u2a01 i, M i) \u2243\u2097[R] \u2200 i, M i :=\n  { DFinsupp.equivFunOnFintype with\n    toFun := (\u2191)\n    map_add' := fun f g \u21a6 by\n      ext\n      rw [add_apply, Pi.add_apply]\n    map_smul' := fun c f \u21a6 by\n      simp_rw [RingHom.id_apply]\n      rw [DFinsupp.coe_smul] }", "start": [151, 1], "end": [162, 31], "kind": "commanddeclaration"}, {"full_name": "DirectSum.linearEquivFunOnFintype_lof", "code": "@[simp]\ntheorem linearEquivFunOnFintype_lof [Fintype \u03b9] [DecidableEq \u03b9] (i : \u03b9) (m : M i) :\n    (linearEquivFunOnFintype R \u03b9 M) (lof R \u03b9 M i m) = Pi.single i m", "start": [167, 1], "end": [172, 69], "kind": "commanddeclaration"}, {"full_name": "DirectSum.linearEquivFunOnFintype_symm_single", "code": "@[simp]\ntheorem linearEquivFunOnFintype_symm_single [Fintype \u03b9] [DecidableEq \u03b9] (i : \u03b9) (m : M i) :\n    (linearEquivFunOnFintype R \u03b9 M).symm (Pi.single i m) = lof R \u03b9 M i m", "start": [175, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "DirectSum.linearEquivFunOnFintype_symm_coe", "code": "@[simp]\ntheorem linearEquivFunOnFintype_symm_coe [Fintype \u03b9] (f : \u2a01 i, M i) :\n    (linearEquivFunOnFintype R \u03b9 M).symm f = f", "start": [183, 1], "end": [186, 33], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lid", "code": "protected def lid (M : Type v) (\u03b9 : Type* := PUnit) [AddCommMonoid M] [Module R M] [Unique \u03b9] :\n    (\u2a01 _ : \u03b9, M) \u2243\u2097[R] M :=\n  { DirectSum.id M \u03b9, toModule R \u03b9 M fun _ \u21a6 LinearMap.id with }", "start": [189, 1], "end": [192, 65], "kind": "commanddeclaration"}, {"full_name": "DirectSum.component", "code": "def component (i : \u03b9) : (\u2a01 i, M i) \u2192\u2097[R] M i :=\n  DFinsupp.lapply i", "start": [197, 1], "end": [199, 20], "kind": "commanddeclaration"}, {"full_name": "DirectSum.apply_eq_component", "code": "theorem apply_eq_component (f : \u2a01 i, M i) (i : \u03b9) : f i = component R \u03b9 M i f", "start": [204, 1], "end": [204, 85], "kind": "commanddeclaration"}, {"full_name": "DirectSum.ext", "code": "@[ext]\ntheorem ext {f g : \u2a01 i, M i} (h : \u2200 i, component R \u03b9 M i f = component R \u03b9 M i g) : f = g", "start": [207, 1], "end": [209, 17], "kind": "commanddeclaration"}, {"full_name": "DirectSum.ext_iff", "code": "theorem ext_iff {f g : \u2a01 i, M i} : f = g \u2194 \u2200 i, component R \u03b9 M i f = component R \u03b9 M i g", "start": [212, 1], "end": [213, 31], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lof_apply", "code": "@[simp]\ntheorem lof_apply (i : \u03b9) (b : M i) : ((lof R \u03b9 M i) b) i = b", "start": [216, 1], "end": [218, 26], "kind": "commanddeclaration"}, {"full_name": "DirectSum.component.lof_self", "code": "@[simp]\ntheorem component.lof_self (i : \u03b9) (b : M i) : component R \u03b9 M i ((lof R \u03b9 M i) b) = b", "start": [221, 1], "end": [223, 18], "kind": "commanddeclaration"}, {"full_name": "DirectSum.component.of", "code": "theorem component.of (i j : \u03b9) (b : M j) :\n    component R \u03b9 M i ((lof R \u03b9 M j) b) = if h : j = i then Eq.recOn h b else 0", "start": [226, 1], "end": [228, 24], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lequivCongrLeft", "code": "def lequivCongrLeft (h : \u03b9 \u2243 \u03ba) : (\u2a01 i, M i) \u2243\u2097[R] \u2a01 k, M (h.symm k) :=\n  { equivCongrLeft h with map_smul' := DFinsupp.comapDomain'_smul h.invFun h.right_inv }", "start": [235, 1], "end": [237, 89], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lequivCongrLeft_apply", "code": "@[simp]\ntheorem lequivCongrLeft_apply (h : \u03b9 \u2243 \u03ba) (f : \u2a01 i, M i) (k : \u03ba) :\n    lequivCongrLeft R h f k = f (h.symm k)", "start": [240, 1], "end": [243, 29], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaLcurry", "code": "def sigmaLcurry : (\u2a01 i : \u03a3i, _, \u03b4 i.1 i.2) \u2192\u2097[R] \u2a01 (i) (j), \u03b4 i j :=\n  { sigmaCurry with map_smul' := fun r \u21a6 by convert DFinsupp.sigmaCurry_smul (\u03b4 := \u03b4) r }", "start": [254, 1], "end": [256, 90], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaLcurry_apply", "code": "@[simp]\ntheorem sigmaLcurry_apply (f : \u2a01 i : \u03a3_, _, \u03b4 i.1 i.2) (i : \u03b9) (j : \u03b1 i) :\n    sigmaLcurry R f i j = f \u27e8i, j\u27e9", "start": [259, 1], "end": [262, 25], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaLuncurry", "code": "noncomputable def sigmaLuncurry [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)] :\n    (\u2a01 (i) (j), \u03b4 i j) \u2192\u2097[R] \u2a01 i : \u03a3_, _, \u03b4 i.1 i.2 :=\n  { sigmaUncurry with map_smul' := DFinsupp.sigmaUncurry_smul }", "start": [266, 1], "end": [269, 64], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaLuncurry_apply", "code": "@[simp]\ntheorem sigmaLuncurry_apply [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)]\n    (f : \u2a01 (i) (j), \u03b4 i j) (i : \u03b9) (j : \u03b1 i) : sigmaLuncurry R f \u27e8i, j\u27e9 = f i j", "start": [272, 1], "end": [275, 27], "kind": "commanddeclaration"}, {"full_name": "DirectSum.sigmaLcurryEquiv", "code": "def sigmaLcurryEquiv [\u2200 i, DecidableEq (\u03b1 i)] [\u2200 i j, DecidableEq (\u03b4 i j)] :\n    (\u2a01 i : \u03a3_, _, \u03b4 i.1 i.2) \u2243\u2097[R] \u2a01 (i) (j), \u03b4 i j :=\n  { sigmaCurryEquiv, sigmaLcurry R with }", "start": [278, 1], "end": [281, 42], "kind": "commanddeclaration"}, {"full_name": "DirectSum.lequivProdDirectSum", "code": "@[simps]\nnoncomputable def lequivProdDirectSum : (\u2a01 i, \u03b1 i) \u2243\u2097[R] \u03b1 none \u00d7 \u2a01 i, \u03b1 (some i) :=\n  { addEquivProdDirectSum with map_smul' := DFinsupp.equivProdDFinsupp_smul }", "start": [290, 1], "end": [294, 78], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coeLinearMap", "code": "def coeLinearMap : (\u2a01 i, A i) \u2192\u2097[R] M :=\n  toModule R \u03b9 M fun i \u21a6 (A i).subtype", "start": [313, 1], "end": [316, 39], "kind": "commanddeclaration"}, {"full_name": "DirectSum.coeLinearMap_of", "code": "@[simp]\ntheorem coeLinearMap_of (i : \u03b9) (x : A i) : DirectSum.coeLinearMap A (of (fun i \u21a6 A i) i x) = x", "start": [319, 1], "end": [322, 78], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.submodule_iSup_eq_top", "code": "theorem IsInternal.submodule_iSup_eq_top (h : IsInternal A) : iSup A = \u22a4", "start": [327, 1], "end": [330, 40], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.submodule_independent", "code": "theorem IsInternal.submodule_independent (h : IsInternal A) : CompleteLattice.Independent A", "start": [333, 1], "end": [335, 71], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.collectedBasis", "code": "noncomputable def IsInternal.collectedBasis (h : IsInternal A) {\u03b1 : \u03b9 \u2192 Type*}\n    (v : \u2200 i, Basis (\u03b1 i) R (A i)) : Basis (\u03a3i, \u03b1 i) R M where\n  repr :=\n    ((LinearEquiv.ofBijective (DirectSum.coeLinearMap A) h).symm \u226a\u226b\u2097\n        DFinsupp.mapRange.linearEquiv fun i \u21a6 (v i).repr) \u226a\u226b\u2097\n      (sigmaFinsuppLequivDFinsupp R).symm", "start": [338, 1], "end": [345, 42], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.collectedBasis_coe", "code": "@[simp]\ntheorem IsInternal.collectedBasis_coe (h : IsInternal A) {\u03b1 : \u03b9 \u2192 Type*}\n    (v : \u2200 i, Basis (\u03b1 i) R (A i)) : \u21d1(h.collectedBasis v) = fun a : \u03a3i, \u03b1 i \u21a6 \u2191(v a.1 a.2)", "start": [348, 1], "end": [369, 35], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.collectedBasis_mem", "code": "theorem IsInternal.collectedBasis_mem (h : IsInternal A) {\u03b1 : \u03b9 \u2192 Type*}\n    (v : \u2200 i, Basis (\u03b1 i) R (A i)) (a : \u03a3i, \u03b1 i) : h.collectedBasis v a \u2208 A a.1", "start": [372, 1], "end": [373, 91], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.isCompl", "code": "theorem IsInternal.isCompl {A : \u03b9 \u2192 Submodule R M} {i j : \u03b9} (hij : i \u2260 j)\n    (h : (Set.univ : Set \u03b9) = {i, j}) (hi : IsInternal A) : IsCompl (A i) (A j)", "start": [376, 1], "end": [383, 93], "kind": "commanddeclaration"}, {"full_name": "DirectSum.isInternal_submodule_of_independent_of_iSup_eq_top", "code": "theorem isInternal_submodule_of_independent_of_iSup_eq_top {A : \u03b9 \u2192 Submodule R M}\n    (hi : CompleteLattice.Independent A) (hs : iSup A = \u22a4) : IsInternal A", "start": [396, 1], "end": [401, 89], "kind": "commanddeclaration"}, {"full_name": "DirectSum.isInternal_submodule_iff_independent_and_iSup_eq_top", "code": "theorem isInternal_submodule_iff_independent_and_iSup_eq_top (A : \u03b9 \u2192 Submodule R M) :\n    IsInternal A \u2194 CompleteLattice.Independent A \u2227 iSup A = \u22a4", "start": [404, 1], "end": [409, 64], "kind": "commanddeclaration"}, {"full_name": "DirectSum.isInternal_submodule_iff_isCompl", "code": "theorem isInternal_submodule_iff_isCompl (A : \u03b9 \u2192 Submodule R M) {i j : \u03b9} (hij : i \u2260 j)\n    (h : (Set.univ : Set \u03b9) = {i, j}) : IsInternal A \u2194 IsCompl (A i) (A j)", "start": [412, 1], "end": [419, 85], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.addSubmonoid_independent", "code": "theorem IsInternal.addSubmonoid_independent {M : Type*} [AddCommMonoid M] {A : \u03b9 \u2192 AddSubmonoid M}\n    (h : IsInternal A) : CompleteLattice.Independent A", "start": [425, 1], "end": [427, 76], "kind": "commanddeclaration"}, {"full_name": "DirectSum.IsInternal.addSubgroup_independent", "code": "theorem IsInternal.addSubgroup_independent {M : Type*} [AddCommGroup M] {A : \u03b9 \u2192 AddSubgroup M}\n    (h : IsInternal A) : CompleteLattice.Independent A", "start": [430, 1], "end": [432, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Submonoid/ZeroDivisors.lean", "imports": ["Mathlib/Algebra/GroupWithZero/NeZero.lean", "Mathlib/GroupTheory/Submonoid/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nonZeroDivisorsLeft", "code": "def nonZeroDivisorsLeft : Submonoid M\u2080 where\n  carrier := {x | \u2200 y, y * x = 0 \u2192 y = 0}\n  one_mem' := by simp\n  mul_mem' {x} {y} hx hy := fun z hz \u21a6 hx _ <| hy _ (mul_assoc z x y \u25b8 hz)", "start": [23, 1], "end": [28, 75], "kind": "commanddeclaration"}, {"full_name": "mem_nonZeroDivisorsLeft_iff", "code": "@[simp] lemma mem_nonZeroDivisorsLeft_iff {x : M\u2080} :\n    x \u2208 nonZeroDivisorsLeft M\u2080 \u2194 \u2200 y, y * x = 0 \u2192 y = 0 :=\n  Iff.rfl", "start": [30, 1], "end": [32, 10], "kind": "mathlibtacticlemma"}, {"full_name": "nonZeroDivisorsRight", "code": "def nonZeroDivisorsRight : Submonoid M\u2080 where\n  carrier := {x | \u2200 y, x * y = 0 \u2192 y = 0}\n  one_mem' := by simp\n  mul_mem' := fun {x} {y} hx hy z hz \u21a6 hy _ (hx _ ((mul_assoc x y z).symm \u25b8 hz))", "start": [34, 1], "end": [39, 81], "kind": "commanddeclaration"}, {"full_name": "mem_nonZeroDivisorsRight_iff", "code": "@[simp] lemma mem_nonZeroDivisorsRight_iff {x : M\u2080} :\n    x \u2208 nonZeroDivisorsRight M\u2080 \u2194 \u2200 y, x * y = 0 \u2192 y = 0 :=\n  Iff.rfl", "start": [41, 1], "end": [43, 10], "kind": "mathlibtacticlemma"}, {"full_name": "nonZeroDivisorsLeft_eq_right", "code": "lemma nonZeroDivisorsLeft_eq_right (M\u2080 : Type*) [CommMonoidWithZero M\u2080] :\n    nonZeroDivisorsLeft M\u2080 = nonZeroDivisorsRight M\u2080 := by\n  ext x; simp [mul_comm x]", "start": [45, 1], "end": [47, 27], "kind": "mathlibtacticlemma"}, {"full_name": "coe_nonZeroDivisorsLeft_eq", "code": "@[simp] lemma coe_nonZeroDivisorsLeft_eq [NoZeroDivisors M\u2080] [Nontrivial M\u2080] :\n    nonZeroDivisorsLeft M\u2080 = {x : M\u2080 | x \u2260 0} := by\n  ext x\n  simp only [SetLike.mem_coe, mem_nonZeroDivisorsLeft_iff, mul_eq_zero, forall_eq_or_imp, true_and,\n    Set.mem_setOf_eq]\n  refine' \u27e8fun h \u21a6 _, fun hx y hx' \u21a6 by contradiction\u27e9\n  contrapose! h\n  exact \u27e81, h, one_ne_zero\u27e9", "start": [49, 1], "end": [56, 28], "kind": "mathlibtacticlemma"}, {"full_name": "coe_nonZeroDivisorsRight_eq", "code": "@[simp] lemma coe_nonZeroDivisorsRight_eq [NoZeroDivisors M\u2080] [Nontrivial M\u2080] :\n    nonZeroDivisorsRight M\u2080 = {x : M\u2080 | x \u2260 0} := by\n  ext x\n  simp only [SetLike.mem_coe, mem_nonZeroDivisorsRight_iff, mul_eq_zero, Set.mem_setOf_eq]\n  refine' \u27e8fun h \u21a6 _, fun hx y hx' \u21a6 by aesop\u27e9\n  contrapose! h\n  exact \u27e81, Or.inl h, one_ne_zero\u27e9", "start": [58, 1], "end": [64, 35], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "imports": ["Mathlib/Algebra/Module/Algebra.lean", "Mathlib/Data/Matrix/Block.lean", "Mathlib/Algebra/Algebra/Subalgebra/Tower.lean", "Mathlib/LinearAlgebra/StdBasis.lean", "Mathlib/RingTheory/AlgebraTower.lean", "Mathlib/Data/Matrix/Notation.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Matrix.vecMulLinear", "code": "@[simps]\ndef Matrix.vecMulLinear [Fintype m] (M : Matrix m n R) : (m \u2192 R) \u2192\u2097[R] n \u2192 R where\n  toFun x := M.vecMul x\n  map_add' _ _ := funext fun _ => add_dotProduct _ _ _\n  map_smul' _ _ := funext fun _ => smul_dotProduct _ _ _", "start": [86, 1], "end": [91, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.vecMul_stdBasis", "code": "@[simp]\ntheorem Matrix.vecMul_stdBasis (M : Matrix m n R) (i j) :\n    M.vecMul (LinearMap.stdBasis R (fun _ => R) i 1) j = M i j", "start": [96, 1], "end": [105, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixRight'", "code": "def LinearMap.toMatrixRight' : ((m \u2192 R) \u2192\u2097[R] n \u2192 R) \u2243\u2097[R\u1d50\u1d52\u1d56] Matrix m n R where\n  toFun f i j := f (stdBasis R (fun _ => R) i 1) j\n  invFun := Matrix.vecMulLinear\n  right_inv M := by\n    ext i j\n    simp only [Matrix.vecMul_stdBasis, Matrix.vecMulLinear_apply]\n  left_inv f := by\n    apply (Pi.basisFun R m).ext\n    intro j; ext i\n    simp only [Pi.basisFun_apply, Matrix.vecMul_stdBasis, Matrix.vecMulLinear_apply]\n  map_add' f g := by\n    ext i j\n    simp only [Pi.add_apply, LinearMap.add_apply, Matrix.add_apply]\n  map_smul' c f := by\n    ext i j\n    simp only [Pi.smul_apply, LinearMap.smul_apply, RingHom.id_apply, Matrix.smul_apply]", "start": [108, 1], "end": [126, 89], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearMapRight'", "code": "abbrev Matrix.toLinearMapRight' : Matrix m n R \u2243\u2097[R\u1d50\u1d52\u1d56] (m \u2192 R) \u2192\u2097[R] n \u2192 R :=\n  LinearEquiv.symm LinearMap.toMatrixRight'", "start": [129, 1], "end": [132, 44], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearMapRight'_apply", "code": "@[simp]\ntheorem Matrix.toLinearMapRight'_apply (M : Matrix m n R) (v : m \u2192 R) :\n    (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) M v = M.vecMul v", "start": [135, 1], "end": [139, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearMapRight'_mul", "code": "@[simp]\ntheorem Matrix.toLinearMapRight'_mul [Fintype l] [DecidableEq l] (M : Matrix l m R)\n    (N : Matrix m n R) :\n    (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) (M * N) =\n      ((Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) N).comp\n        ((Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) M)", "start": [142, 1], "end": [149, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearMapRight'_mul_apply", "code": "theorem Matrix.toLinearMapRight'_mul_apply [Fintype l] [DecidableEq l] (M : Matrix l m R)\n    (N : Matrix m n R) (x) :\n    (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) (M * N) x =\n      (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) N\n        ((Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) M x)", "start": [152, 1], "end": [158, 29], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearMapRight'_one", "code": "@[simp]\ntheorem Matrix.toLinearMapRight'_one :\n    (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) (1 : Matrix m m R) = LinearMap.id", "start": [161, 1], "end": [166, 45], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinearEquivRight'OfInv", "code": "@[simps]\ndef Matrix.toLinearEquivRight'OfInv [Fintype n] [DecidableEq n] {M : Matrix m n R}\n    {M' : Matrix n m R} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (n \u2192 R) \u2243\u2097[R] m \u2192 R :=\n  { (LinearMap.toMatrixRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _).symm\n      M' with\n    toFun := (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) M'\n    invFun := (Matrix.toLinearMapRight' : _ \u2243\u2097[R\u1d50\u1d52\u1d56] _) M\n    left_inv := fun x => by\n      dsimp only rw [\u2190 Matrix.toLinearMapRight'_mul_apply, hM'M, Matrix.toLinearMapRight'_one, id_apply]\n    right_inv := fun x => by\n      dsimp only rw [\u2190 Matrix.toLinearMapRight'_mul_apply, hMM', Matrix.toLinearMapRight'_one, id_apply] }", "start": [169, 1], "end": [186, 96], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin", "code": "def Matrix.mulVecLin [Fintype n] (M : Matrix m n R) : (n \u2192 R) \u2192\u2097[R] m \u2192 R where\n  toFun := M.mulVec\n  map_add' _ _ := funext fun _ => dotProduct_add _ _ _\n  map_smul' _ _ := funext fun _ => dotProduct_smul _ _ _", "start": [204, 1], "end": [208, 57], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_apply", "code": "@[simp]\ntheorem Matrix.mulVecLin_apply [Fintype n] (M : Matrix m n R) (v : n \u2192 R) :\n    M.mulVecLin v = M.mulVec v", "start": [211, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_zero", "code": "@[simp]\ntheorem Matrix.mulVecLin_zero [Fintype n] : Matrix.mulVecLin (0 : Matrix m n R) = 0", "start": [217, 1], "end": [219, 28], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_add", "code": "@[simp]\ntheorem Matrix.mulVecLin_add [Fintype n] (M N : Matrix m n R) :\n    (M + N).mulVecLin = M.mulVecLin + N.mulVecLin", "start": [222, 1], "end": [225, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_submatrix", "code": "theorem Matrix.mulVecLin_submatrix [Fintype n] [Fintype l] (f\u2081 : m \u2192 k) (e\u2082 : n \u2243 l)\n    (M : Matrix k l R) :\n    (M.submatrix f\u2081 e\u2082).mulVecLin = funLeft R R f\u2081 \u2218\u2097 M.mulVecLin \u2218\u2097 funLeft _ _ e\u2082.symm", "start": [228, 1], "end": [231, 56], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_reindex", "code": "theorem Matrix.mulVecLin_reindex [Fintype n] [Fintype l] (e\u2081 : k \u2243 m) (e\u2082 : l \u2243 n)\n    (M : Matrix k l R) :\n    (reindex e\u2081 e\u2082 M).mulVecLin =\n      \u2191(LinearEquiv.funCongrLeft R R e\u2081.symm) \u2218\u2097\n        M.mulVecLin \u2218\u2097 \u2191(LinearEquiv.funCongrLeft R R e\u2082)", "start": [234, 1], "end": [240, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_one", "code": "@[simp]\ntheorem Matrix.mulVecLin_one [DecidableEq n] :\n    Matrix.mulVecLin (1 : Matrix n n R) = LinearMap.id", "start": [245, 1], "end": [248, 48], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVecLin_mul", "code": "@[simp]\ntheorem Matrix.mulVecLin_mul [Fintype m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.mulVecLin (M * N) = (Matrix.mulVecLin M).comp (Matrix.mulVecLin N)", "start": [251, 1], "end": [254, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.ker_mulVecLin_eq_bot_iff", "code": "theorem Matrix.ker_mulVecLin_eq_bot_iff {M : Matrix n n R} :\n    (LinearMap.ker M.mulVecLin) = \u22a5 \u2194 \u2200 v, M.mulVec v = 0 \u2192 v = 0", "start": [257, 1], "end": [259, 78], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_stdBasis", "code": "theorem Matrix.mulVec_stdBasis [DecidableEq n] (M : Matrix m n R) (i j) :\n    M.mulVec (LinearMap.stdBasis R (fun _ => R) j 1) i = M i j", "start": [262, 1], "end": [264, 70], "kind": "commanddeclaration"}, {"full_name": "Matrix.mulVec_stdBasis_apply", "code": "@[simp]\ntheorem Matrix.mulVec_stdBasis_apply [DecidableEq n] (M : Matrix m n R) (j) :\n    M.mulVec (LinearMap.stdBasis R (fun _ => R) j 1) = M\u1d40 j", "start": [267, 1], "end": [270, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_mulVecLin", "code": "theorem Matrix.range_mulVecLin (M : Matrix m n R) :\n    LinearMap.range M.mulVecLin = span R (range M\u1d40)", "start": [273, 1], "end": [278, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'", "code": "def LinearMap.toMatrix' : ((n \u2192 R) \u2192\u2097[R] m \u2192 R) \u2243\u2097[R] Matrix m n R where\n  toFun f := of fun i j => f (stdBasis R (fun _ => R) j 1) i\n  invFun := Matrix.mulVecLin\n  right_inv M := by\n    ext i j\n    simp only [Matrix.mulVec_stdBasis, Matrix.mulVecLin_apply, of_apply]\n  left_inv f := by\n    apply (Pi.basisFun R n).ext\n    intro j; ext i\n    simp only [Pi.basisFun_apply, Matrix.mulVec_stdBasis, Matrix.mulVecLin_apply, of_apply]\n  map_add' f g := by\n    ext i j\n    simp only [Pi.add_apply, LinearMap.add_apply, of_apply, Matrix.add_apply]\n  map_smul' c f := by\n    ext i j\n    simp only [Pi.smul_apply, LinearMap.smul_apply, RingHom.id_apply, of_apply, Matrix.smul_apply]", "start": [283, 1], "end": [299, 99], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'", "code": "def Matrix.toLin' : Matrix m n R \u2243\u2097[R] (n \u2192 R) \u2192\u2097[R] m \u2192 R :=\n  LinearMap.toMatrix'.symm", "start": [302, 1], "end": [306, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_apply'", "code": "theorem Matrix.toLin'_apply' (M : Matrix m n R) : Matrix.toLin' M = M.mulVecLin", "start": [309, 1], "end": [310, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_symm", "code": "@[simp]\ntheorem LinearMap.toMatrix'_symm :\n    (LinearMap.toMatrix'.symm : Matrix m n R \u2243\u2097[R] _) = Matrix.toLin'", "start": [313, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_symm", "code": "@[simp]\ntheorem Matrix.toLin'_symm :\n    (Matrix.toLin'.symm : ((n \u2192 R) \u2192\u2097[R] m \u2192 R) \u2243\u2097[R] _) = LinearMap.toMatrix'", "start": [319, 1], "end": [322, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_toLin'", "code": "@[simp]\ntheorem LinearMap.toMatrix'_toLin' (M : Matrix m n R) : LinearMap.toMatrix' (Matrix.toLin' M) = M", "start": [325, 1], "end": [327, 41], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_toMatrix'", "code": "@[simp]\ntheorem Matrix.toLin'_toMatrix' (f : (n \u2192 R) \u2192\u2097[R] m \u2192 R) :\n    Matrix.toLin' (LinearMap.toMatrix' f) = f", "start": [330, 1], "end": [333, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_apply", "code": "@[simp]\ntheorem LinearMap.toMatrix'_apply (f : (n \u2192 R) \u2192\u2097[R] m \u2192 R) (i j) :\n    LinearMap.toMatrix' f i j = f (fun j' => if j' = j then 1 else 0) i", "start": [336, 1], "end": [345, 30], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_apply", "code": "@[simp]\ntheorem Matrix.toLin'_apply (M : Matrix m n R) (v : n \u2192 R) : Matrix.toLin' M v = M.mulVec v", "start": [348, 1], "end": [350, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_one", "code": "@[simp]\ntheorem Matrix.toLin'_one : Matrix.toLin' (1 : Matrix n n R) = LinearMap.id", "start": [353, 1], "end": [355, 23], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_id", "code": "@[simp]\ntheorem LinearMap.toMatrix'_id : LinearMap.toMatrix' (LinearMap.id : (n \u2192 R) \u2192\u2097[R] n \u2192 R) = 1", "start": [358, 1], "end": [361, 61], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_one", "code": "@[simp]\ntheorem LinearMap.toMatrix'_one : LinearMap.toMatrix' (1 : (n \u2192 R) \u2192\u2097[R] n \u2192 R) = 1", "start": [364, 1], "end": [366, 25], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_mul", "code": "@[simp]\ntheorem Matrix.toLin'_mul [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.toLin' (M * N) = (Matrix.toLin' M).comp (Matrix.toLin' N)", "start": [368, 1], "end": [371, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_submatrix", "code": "@[simp]\ntheorem Matrix.toLin'_submatrix [Fintype l] [DecidableEq l] (f\u2081 : m \u2192 k) (e\u2082 : n \u2243 l)\n    (M : Matrix k l R) :\n    Matrix.toLin' (M.submatrix f\u2081 e\u2082) =\n      funLeft R R f\u2081 \u2218\u2097 (Matrix.toLin' M) \u2218\u2097 funLeft _ _ e\u2082.symm", "start": [374, 1], "end": [379, 35], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_reindex", "code": "theorem Matrix.toLin'_reindex [Fintype l] [DecidableEq l] (e\u2081 : k \u2243 m) (e\u2082 : l \u2243 n)\n    (M : Matrix k l R) :\n    Matrix.toLin' (reindex e\u2081 e\u2082 M) =\n      \u2191(LinearEquiv.funCongrLeft R R e\u2081.symm) \u2218\u2097 (Matrix.toLin' M) \u2218\u2097\n        \u2191(LinearEquiv.funCongrLeft R R e\u2082)", "start": [382, 1], "end": [388, 33], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'_mul_apply", "code": "theorem Matrix.toLin'_mul_apply [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R)\n    (x) : Matrix.toLin' (M * N) x = Matrix.toLin' M (Matrix.toLin' N x)", "start": [391, 1], "end": [394, 47], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_comp", "code": "theorem LinearMap.toMatrix'_comp [Fintype l] [DecidableEq l] (f : (n \u2192 R) \u2192\u2097[R] m \u2192 R)\n    (g : (l \u2192 R) \u2192\u2097[R] n \u2192 R) :\n    LinearMap.toMatrix' (f.comp g) = LinearMap.toMatrix' f * LinearMap.toMatrix' g", "start": [397, 1], "end": [402, 75], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_mul", "code": "theorem LinearMap.toMatrix'_mul [Fintype m] [DecidableEq m] (f g : (m \u2192 R) \u2192\u2097[R] m \u2192 R) :\n    LinearMap.toMatrix' (f * g) = LinearMap.toMatrix' f * LinearMap.toMatrix' g", "start": [405, 1], "end": [407, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix'_algebraMap", "code": "@[simp]\ntheorem LinearMap.toMatrix'_algebraMap (x : R) :\n    LinearMap.toMatrix' (algebraMap R (Module.End R (n \u2192 R)) x) = scalar n x", "start": [410, 1], "end": [413, 42], "kind": "commanddeclaration"}, {"full_name": "Matrix.ker_toLin'_eq_bot_iff", "code": "theorem Matrix.ker_toLin'_eq_bot_iff {M : Matrix n n R} :\n    LinearMap.ker (Matrix.toLin' M) = \u22a5 \u2194 \u2200 v, M.mulVec v = 0 \u2192 v = 0", "start": [416, 1], "end": [418, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.range_toLin'", "code": "theorem Matrix.range_toLin' (M : Matrix m n R) :\n    LinearMap.range (Matrix.toLin' M) = span R (range M\u1d40)", "start": [421, 1], "end": [423, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin'OfInv", "code": "@[simps]\ndef Matrix.toLin'OfInv [Fintype m] [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R}\n    (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (m \u2192 R) \u2243\u2097[R] n \u2192 R :=\n  { Matrix.toLin' M' with\n    toFun := Matrix.toLin' M'\n    invFun := Matrix.toLin' M\n    left_inv := fun x => by rw [\u2190 Matrix.toLin'_mul_apply, hMM', Matrix.toLin'_one, id_apply]\n    right_inv := fun x => by\n      simp only\n      rw [\u2190 Matrix.toLin'_mul_apply, hM'M, Matrix.toLin'_one, id_apply] }", "start": [426, 1], "end": [437, 74], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'", "code": "def LinearMap.toMatrixAlgEquiv' : ((n \u2192 R) \u2192\u2097[R] n \u2192 R) \u2243\u2090[R] Matrix n n R :=\n  AlgEquiv.ofLinearEquiv LinearMap.toMatrix' LinearMap.toMatrix'_one LinearMap.toMatrix'_mul", "start": [440, 1], "end": [442, 93], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv'", "code": "def Matrix.toLinAlgEquiv' : Matrix n n R \u2243\u2090[R] (n \u2192 R) \u2192\u2097[R] n \u2192 R :=\n  LinearMap.toMatrixAlgEquiv'.symm", "start": [445, 1], "end": [447, 35], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_symm", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_symm :\n    (LinearMap.toMatrixAlgEquiv'.symm : Matrix n n R \u2243\u2090[R] _) = Matrix.toLinAlgEquiv'", "start": [450, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv'_symm", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv'_symm :\n    (Matrix.toLinAlgEquiv'.symm : ((n \u2192 R) \u2192\u2097[R] n \u2192 R) \u2243\u2090[R] _) = LinearMap.toMatrixAlgEquiv'", "start": [456, 1], "end": [459, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv'", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv' (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv' (Matrix.toLinAlgEquiv' M) = M", "start": [462, 1], "end": [465, 49], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv'_toMatrixAlgEquiv'", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv'_toMatrixAlgEquiv' (f : (n \u2192 R) \u2192\u2097[R] n \u2192 R) :\n    Matrix.toLinAlgEquiv' (LinearMap.toMatrixAlgEquiv' f) = f", "start": [468, 1], "end": [471, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_apply", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_apply (f : (n \u2192 R) \u2192\u2097[R] n \u2192 R) (i j) :\n    LinearMap.toMatrixAlgEquiv' f i j = f (fun j' => if j' = j then 1 else 0) i", "start": [474, 1], "end": [477, 37], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv'_apply", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv'_apply (M : Matrix n n R) (v : n \u2192 R) :\n    Matrix.toLinAlgEquiv' M v = M.mulVec v", "start": [480, 1], "end": [483, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv'_one", "code": "theorem Matrix.toLinAlgEquiv'_one : Matrix.toLinAlgEquiv' (1 : Matrix n n R) = LinearMap.id", "start": [489, 1], "end": [490, 20], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_id", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_id :\n    LinearMap.toMatrixAlgEquiv' (LinearMap.id : (n \u2192 R) \u2192\u2097[R] n \u2192 R) = 1", "start": [493, 1], "end": [496, 25], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_comp", "code": "theorem LinearMap.toMatrixAlgEquiv'_comp (f g : (n \u2192 R) \u2192\u2097[R] n \u2192 R) :\n    LinearMap.toMatrixAlgEquiv' (f.comp g) =\n      LinearMap.toMatrixAlgEquiv' f * LinearMap.toMatrixAlgEquiv' g", "start": [501, 1], "end": [504, 31], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv'_mul", "code": "theorem LinearMap.toMatrixAlgEquiv'_mul (f g : (n \u2192 R) \u2192\u2097[R] n \u2192 R) :\n    LinearMap.toMatrixAlgEquiv' (f * g) =\n      LinearMap.toMatrixAlgEquiv' f * LinearMap.toMatrixAlgEquiv' g", "start": [507, 1], "end": [510, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix", "code": "def LinearMap.toMatrix : (M\u2081 \u2192\u2097[R] M\u2082) \u2243\u2097[R] Matrix m n R :=\n  LinearEquiv.trans (LinearEquiv.arrowCongr v\u2081.equivFun v\u2082.equivFun) LinearMap.toMatrix'", "start": [525, 1], "end": [528, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_eq_toMatrix'", "code": "theorem LinearMap.toMatrix_eq_toMatrix' :\n    LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n) = LinearMap.toMatrix'", "start": [531, 1], "end": [535, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin", "code": "def Matrix.toLin : Matrix m n R \u2243\u2097[R] M\u2081 \u2192\u2097[R] M\u2082 :=\n  (LinearMap.toMatrix v\u2081 v\u2082).symm", "start": [538, 1], "end": [541, 34], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_eq_toLin'", "code": "theorem Matrix.toLin_eq_toLin' : Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m) = Matrix.toLin'", "start": [544, 1], "end": [547, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_symm", "code": "@[simp]\ntheorem LinearMap.toMatrix_symm : (LinearMap.toMatrix v\u2081 v\u2082).symm = Matrix.toLin v\u2081 v\u2082", "start": [550, 1], "end": [552, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_symm", "code": "@[simp]\ntheorem Matrix.toLin_symm : (Matrix.toLin v\u2081 v\u2082).symm = LinearMap.toMatrix v\u2081 v\u2082", "start": [555, 1], "end": [557, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_toMatrix", "code": "@[simp]\ntheorem Matrix.toLin_toMatrix (f : M\u2081 \u2192\u2097[R] M\u2082) :\n    Matrix.toLin v\u2081 v\u2082 (LinearMap.toMatrix v\u2081 v\u2082 f) = f", "start": [560, 1], "end": [563, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_toLin", "code": "@[simp]\ntheorem LinearMap.toMatrix_toLin (M : Matrix m n R) :\n    LinearMap.toMatrix v\u2081 v\u2082 (Matrix.toLin v\u2081 v\u2082 M) = M", "start": [566, 1], "end": [569, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_apply", "code": "theorem LinearMap.toMatrix_apply (f : M\u2081 \u2192\u2097[R] M\u2082) (i : m) (j : n) :\n    LinearMap.toMatrix v\u2081 v\u2082 f i j = v\u2082.repr (f (v\u2081 j)) i", "start": [572, 1], "end": [581, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_transpose_apply", "code": "theorem LinearMap.toMatrix_transpose_apply (f : M\u2081 \u2192\u2097[R] M\u2082) (j : n) :\n    (LinearMap.toMatrix v\u2081 v\u2082 f)\u1d40 j = v\u2082.repr (f (v\u2081 j))", "start": [584, 1], "end": [586, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_apply'", "code": "theorem LinearMap.toMatrix_apply' (f : M\u2081 \u2192\u2097[R] M\u2082) (i : m) (j : n) :\n    LinearMap.toMatrix v\u2081 v\u2082 f i j = v\u2082.repr (f (v\u2081 j)) i", "start": [589, 1], "end": [591, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_transpose_apply'", "code": "theorem LinearMap.toMatrix_transpose_apply' (f : M\u2081 \u2192\u2097[R] M\u2082) (j : n) :\n    (LinearMap.toMatrix v\u2081 v\u2082 f)\u1d40 j = v\u2082.repr (f (v\u2081 j))", "start": [594, 1], "end": [596, 47], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_apply", "code": "theorem Matrix.toLin_apply (M : Matrix m n R) (v : M\u2081) :\n    Matrix.toLin v\u2081 v\u2082 M v = \u2211 j, M.mulVec (v\u2081.repr v) j \u2022 v\u2082 j", "start": [599, 1], "end": [602, 53], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_self", "code": "@[simp]\ntheorem Matrix.toLin_self (M : Matrix m n R) (i : n) :\n    Matrix.toLin v\u2081 v\u2082 M (v\u2081 i) = \u2211 j, M j i \u2022 v\u2082 j", "start": [605, 1], "end": [615, 18], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_id", "code": "theorem LinearMap.toMatrix_id : LinearMap.toMatrix v\u2081 v\u2081 id = 1", "start": [618, 1], "end": [621, 83], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_one", "code": "@[simp]\ntheorem LinearMap.toMatrix_one : LinearMap.toMatrix v\u2081 v\u2081 1 = 1", "start": [624, 1], "end": [626, 27], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_one", "code": "@[simp]\ntheorem Matrix.toLin_one : Matrix.toLin v\u2081 v\u2081 1 = LinearMap.id", "start": [629, 1], "end": [631, 57], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_reindexRange", "code": "theorem LinearMap.toMatrix_reindexRange [DecidableEq M\u2081] [DecidableEq M\u2082] (f : M\u2081 \u2192\u2097[R] M\u2082) (k : m)\n    (i : n) :\n    LinearMap.toMatrix v\u2081.reindexRange v\u2082.reindexRange f \u27e8v\u2082 k, Set.mem_range_self k\u27e9\n        \u27e8v\u2081 i, Set.mem_range_self i\u27e9 =\n      LinearMap.toMatrix v\u2081 v\u2082 f k i", "start": [634, 1], "end": [639, 90], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_comp", "code": "theorem LinearMap.toMatrix_comp [Fintype l] [DecidableEq m] (f : M\u2082 \u2192\u2097[R] M\u2083) (g : M\u2081 \u2192\u2097[R] M\u2082) :\n    LinearMap.toMatrix v\u2081 v\u2083 (f.comp g) =\n    LinearMap.toMatrix v\u2082 v\u2083 f * LinearMap.toMatrix v\u2081 v\u2082 g", "start": [644, 1], "end": [648, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_mul", "code": "theorem LinearMap.toMatrix_mul (f g : M\u2081 \u2192\u2097[R] M\u2081) :\n    LinearMap.toMatrix v\u2081 v\u2081 (f * g) = LinearMap.toMatrix v\u2081 v\u2081 f * LinearMap.toMatrix v\u2081 v\u2081 g", "start": [651, 1], "end": [653, 67], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_pow", "code": "lemma LinearMap.toMatrix_pow (f : M\u2081 \u2192\u2097[R] M\u2081) (k : \u2115) :\n    (toMatrix v\u2081 v\u2081 f) ^ k = toMatrix v\u2081 v\u2081 (f ^ k) := by\n  induction' k with k ih; simp\n  rw [pow_succ, pow_succ, ih, \u2190 toMatrix_mul]", "start": [656, 1], "end": [659, 46], "kind": "mathlibtacticlemma"}, {"full_name": "LinearMap.toMatrix_algebraMap", "code": "@[simp]\ntheorem LinearMap.toMatrix_algebraMap (x : R) :\n    LinearMap.toMatrix v\u2081 v\u2081 (algebraMap R (Module.End R M\u2081) x) = scalar n x", "start": [661, 1], "end": [664, 65], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_mulVec_repr", "code": "theorem LinearMap.toMatrix_mulVec_repr (f : M\u2081 \u2192\u2097[R] M\u2082) (x : M\u2081) :\n    (LinearMap.toMatrix v\u2081 v\u2082 f).mulVec (v\u2081.repr x) = v\u2082.repr (f x)", "start": [667, 1], "end": [673, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrix_basis_equiv", "code": "@[simp]\ntheorem LinearMap.toMatrix_basis_equiv [Fintype l] [DecidableEq l] (b : Basis l R M\u2081)\n    (b' : Basis l R M\u2082) :\n    LinearMap.toMatrix b' b (b'.equiv b (Equiv.refl l) : M\u2082 \u2192\u2097[R] M\u2081) = 1", "start": [676, 1], "end": [681, 83], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_mul", "code": "theorem Matrix.toLin_mul [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) :\n    Matrix.toLin v\u2081 v\u2083 (A * B) = (Matrix.toLin v\u2082 v\u2083 A).comp (Matrix.toLin v\u2081 v\u2082 B)", "start": [684, 1], "end": [689, 40], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_mul_apply", "code": "theorem Matrix.toLin_mul_apply [Fintype l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R)\n    (x) : Matrix.toLin v\u2081 v\u2083 (A * B) x = (Matrix.toLin v\u2082 v\u2083 A) (Matrix.toLin v\u2081 v\u2082 B x)", "start": [692, 1], "end": [695, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinOfInv", "code": "@[simps]\ndef Matrix.toLinOfInv [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R} (hMM' : M * M' = 1)\n    (hM'M : M' * M = 1) : M\u2081 \u2243\u2097[R] M\u2082 :=\n  { Matrix.toLin v\u2081 v\u2082 M with\n    toFun := Matrix.toLin v\u2081 v\u2082 M\n    invFun := Matrix.toLin v\u2082 v\u2081 M'\n    left_inv := fun x => by rw [\u2190 Matrix.toLin_mul_apply, hM'M, Matrix.toLin_one, id_apply]\n    right_inv := fun x => by\n      simp only\n      rw [\u2190 Matrix.toLin_mul_apply, hMM', Matrix.toLin_one, id_apply] }", "start": [698, 1], "end": [709, 72], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv", "code": "def LinearMap.toMatrixAlgEquiv : (M\u2081 \u2192\u2097[R] M\u2081) \u2243\u2090[R] Matrix n n R :=\n  AlgEquiv.ofLinearEquiv\n    (LinearMap.toMatrix v\u2081 v\u2081) (LinearMap.toMatrix_one v\u2081) (LinearMap.toMatrix_mul v\u2081)", "start": [712, 1], "end": [716, 87], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv", "code": "def Matrix.toLinAlgEquiv : Matrix n n R \u2243\u2090[R] M\u2081 \u2192\u2097[R] M\u2081 :=\n  (LinearMap.toMatrixAlgEquiv v\u2081).symm", "start": [719, 1], "end": [722, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_symm", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_symm :\n    (LinearMap.toMatrixAlgEquiv v\u2081).symm = Matrix.toLinAlgEquiv v\u2081", "start": [725, 1], "end": [728, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_symm", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv_symm :\n    (Matrix.toLinAlgEquiv v\u2081).symm = LinearMap.toMatrixAlgEquiv v\u2081", "start": [731, 1], "end": [734, 6], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_toMatrixAlgEquiv", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv_toMatrixAlgEquiv (f : M\u2081 \u2192\u2097[R] M\u2081) :\n    Matrix.toLinAlgEquiv v\u2081 (LinearMap.toMatrixAlgEquiv v\u2081 f) = f", "start": [737, 1], "end": [740, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_toLinAlgEquiv", "code": "@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_toLinAlgEquiv (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv v\u2081 (Matrix.toLinAlgEquiv v\u2081 M) = M", "start": [743, 1], "end": [746, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_apply", "code": "theorem LinearMap.toMatrixAlgEquiv_apply (f : M\u2081 \u2192\u2097[R] M\u2081) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v\u2081 f i j = v\u2081.repr (f (v\u2081 j)) i", "start": [749, 1], "end": [751, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_transpose_apply", "code": "theorem LinearMap.toMatrixAlgEquiv_transpose_apply (f : M\u2081 \u2192\u2097[R] M\u2081) (j : n) :\n    (LinearMap.toMatrixAlgEquiv v\u2081 f)\u1d40 j = v\u2081.repr (f (v\u2081 j))", "start": [754, 1], "end": [756, 43], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_apply'", "code": "theorem LinearMap.toMatrixAlgEquiv_apply' (f : M\u2081 \u2192\u2097[R] M\u2081) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v\u2081 f i j = v\u2081.repr (f (v\u2081 j)) i", "start": [759, 1], "end": [761, 44], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_transpose_apply'", "code": "theorem LinearMap.toMatrixAlgEquiv_transpose_apply' (f : M\u2081 \u2192\u2097[R] M\u2081) (j : n) :\n    (LinearMap.toMatrixAlgEquiv v\u2081 f)\u1d40 j = v\u2081.repr (f (v\u2081 j))", "start": [764, 1], "end": [766, 52], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_apply", "code": "theorem Matrix.toLinAlgEquiv_apply (M : Matrix n n R) (v : M\u2081) :\n    Matrix.toLinAlgEquiv v\u2081 M v = \u2211 j, M.mulVec (v\u2081.repr v) j \u2022 v\u2081 j", "start": [769, 1], "end": [772, 61], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_self", "code": "@[simp]\ntheorem Matrix.toLinAlgEquiv_self (M : Matrix n n R) (i : n) :\n    Matrix.toLinAlgEquiv v\u2081 M (v\u2081 i) = \u2211 j, M j i \u2022 v\u2081 j", "start": [775, 1], "end": [778, 28], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_id", "code": "theorem LinearMap.toMatrixAlgEquiv_id : LinearMap.toMatrixAlgEquiv v\u2081 id = 1", "start": [781, 1], "end": [782, 92], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_one", "code": "theorem Matrix.toLinAlgEquiv_one : Matrix.toLinAlgEquiv v\u2081 1 = LinearMap.id", "start": [788, 1], "end": [789, 81], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_reindexRange", "code": "theorem LinearMap.toMatrixAlgEquiv_reindexRange [DecidableEq M\u2081] (f : M\u2081 \u2192\u2097[R] M\u2081) (k i : n) :\n    LinearMap.toMatrixAlgEquiv v\u2081.reindexRange f\n        \u27e8v\u2081 k, Set.mem_range_self k\u27e9 \u27e8v\u2081 i, Set.mem_range_self i\u27e9 =\n      LinearMap.toMatrixAlgEquiv v\u2081 f k i", "start": [792, 1], "end": [796, 98], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_comp", "code": "theorem LinearMap.toMatrixAlgEquiv_comp (f g : M\u2081 \u2192\u2097[R] M\u2081) :\n    LinearMap.toMatrixAlgEquiv v\u2081 (f.comp g) =\n      LinearMap.toMatrixAlgEquiv v\u2081 f * LinearMap.toMatrixAlgEquiv v\u2081 g", "start": [799, 1], "end": [802, 77], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toMatrixAlgEquiv_mul", "code": "theorem LinearMap.toMatrixAlgEquiv_mul (f g : M\u2081 \u2192\u2097[R] M\u2081) :\n    LinearMap.toMatrixAlgEquiv v\u2081 (f * g) =\n      LinearMap.toMatrixAlgEquiv v\u2081 f * LinearMap.toMatrixAlgEquiv v\u2081 g", "start": [805, 1], "end": [808, 69], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLinAlgEquiv_mul", "code": "theorem Matrix.toLinAlgEquiv_mul (A B : Matrix n n R) :\n    Matrix.toLinAlgEquiv v\u2081 (A * B) =\n      (Matrix.toLinAlgEquiv v\u2081 A).comp (Matrix.toLinAlgEquiv v\u2081 B)", "start": [811, 1], "end": [814, 43], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_finTwoProd_apply", "code": "@[simp]\ntheorem Matrix.toLin_finTwoProd_apply (a b c d : R) (x : R \u00d7 R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] x =\n      (a * x.fst + b * x.snd, c * x.fst + d * x.snd)", "start": [817, 1], "end": [822, 81], "kind": "commanddeclaration"}, {"full_name": "Matrix.toLin_finTwoProd", "code": "theorem Matrix.toLin_finTwoProd (a b c d : R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] =\n      (a \u2022 LinearMap.fst R R R + b \u2022 LinearMap.snd R R R).prod\n        (c \u2022 LinearMap.fst R R R + d \u2022 LinearMap.snd R R R)", "start": [825, 1], "end": [829, 57], "kind": "commanddeclaration"}, {"full_name": "toMatrix_distrib_mul_action_toLinearMap", "code": "@[simp]\ntheorem toMatrix_distrib_mul_action_toLinearMap (x : R) :\n    LinearMap.toMatrix v\u2081 v\u2081 (DistribMulAction.toLinearMap R M\u2081 x) =\n    Matrix.diagonal fun _ => x", "start": [832, 1], "end": [839, 21], "kind": "commanddeclaration"}, {"full_name": "Algebra.toMatrix_lmul'", "code": "theorem toMatrix_lmul' (x : S) (i j) :\n    LinearMap.toMatrix b b (lmul R S x) i j = b.repr (x * b j) i", "start": [852, 1], "end": [854, 79], "kind": "commanddeclaration"}, {"full_name": "Algebra.toMatrix_lsmul", "code": "@[simp]\ntheorem toMatrix_lsmul (x : R) :\n    LinearMap.toMatrix b b (Algebra.lsmul R R S x) = Matrix.diagonal fun _ => x", "start": [857, 1], "end": [860, 46], "kind": "commanddeclaration"}, {"full_name": "Algebra.leftMulMatrix", "code": "noncomputable def leftMulMatrix : S \u2192\u2090[R] Matrix m m R where\n  toFun x := LinearMap.toMatrix b b (Algebra.lmul R S x)\n  map_zero' := by\n    dsimp only  rw [AlgHom.map_zero, LinearEquiv.map_zero]\n  map_one' := by\n    dsimp only  rw [AlgHom.map_one, LinearMap.toMatrix_one]\n  map_add' x y := by\n    dsimp only  rw [AlgHom.map_add, LinearEquiv.map_add]\n  map_mul' x y := by\n    dsimp only  rw [AlgHom.map_mul, LinearMap.toMatrix_mul]\n  commutes' r := by\n    dsimp only  ext\n    rw [lmul_algebraMap, toMatrix_lsmul, algebraMap_eq_diagonal, Pi.algebraMap_def,\n      Algebra.id.map_eq_self]", "start": [863, 1], "end": [888, 30], "kind": "commanddeclaration"}, {"full_name": "Algebra.leftMulMatrix_apply", "code": "theorem leftMulMatrix_apply (x : S) : leftMulMatrix b x = LinearMap.toMatrix b b (lmul R S x)", "start": [891, 1], "end": [892, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.leftMulMatrix_eq_repr_mul", "code": "theorem leftMulMatrix_eq_repr_mul (x : S) (i j) : leftMulMatrix b x i j = b.repr (x * b j) i", "start": [895, 1], "end": [898, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.leftMulMatrix_mulVec_repr", "code": "theorem leftMulMatrix_mulVec_repr (x y : S) :\n    (leftMulMatrix b x).mulVec (b.repr y) = b.repr (x * y)", "start": [901, 1], "end": [903, 53], "kind": "commanddeclaration"}, {"full_name": "Algebra.toMatrix_lmul_eq", "code": "@[simp]\ntheorem toMatrix_lmul_eq (x : S) :\n    LinearMap.toMatrix b b (LinearMap.mulLeft R x) = leftMulMatrix b x", "start": [906, 1], "end": [909, 6], "kind": "commanddeclaration"}, {"full_name": "Algebra.leftMulMatrix_injective", "code": "theorem leftMulMatrix_injective : Function.Injective (leftMulMatrix b)", "start": [912, 1], "end": [916, 25], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_leftMulMatrix", "code": "theorem smul_leftMulMatrix (x) (ik jk) :\n    leftMulMatrix (b.smul c) x ik jk = leftMulMatrix b (leftMulMatrix c x ik.2 jk.2) ik.1 jk.1", "start": [931, 1], "end": [935, 43], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_leftMulMatrix_algebraMap", "code": "theorem smul_leftMulMatrix_algebraMap (x : S) :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) = blockDiagonal fun _ => leftMulMatrix b x", "start": [938, 1], "end": [942, 51], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_leftMulMatrix_algebraMap_eq", "code": "theorem smul_leftMulMatrix_algebraMap_eq (x : S) (i j k) :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) (i, k) (j, k) = leftMulMatrix b x i j", "start": [945, 1], "end": [947, 61], "kind": "commanddeclaration"}, {"full_name": "Algebra.smul_leftMulMatrix_algebraMap_ne", "code": "theorem smul_leftMulMatrix_algebraMap_ne (x : S) (i j) {k k'} (h : k \u2260 k') :\n    leftMulMatrix (b.smul c) (algebraMap _ _ x) (i, k) (j, k') = 0", "start": [950, 1], "end": [952, 69], "kind": "commanddeclaration"}, {"full_name": "algEquivMatrix'", "code": "def algEquivMatrix' [Fintype n] : Module.End R (n \u2192 R) \u2243\u2090[R] Matrix n n R :=\n  { LinearMap.toMatrix' with\n    map_mul' := LinearMap.toMatrix'_comp\n    commutes' := LinearMap.toMatrix'_algebraMap }", "start": [967, 1], "end": [973, 50], "kind": "commanddeclaration"}, {"full_name": "LinearEquiv.algConj", "code": "def LinearEquiv.algConj (e : M\u2081 \u2243\u2097[R] M\u2082) : Module.End R M\u2081 \u2243\u2090[R] Module.End R M\u2082 :=\n  { e.conj with\n    map_mul' := fun f g => by apply e.arrowCongr_comp\n    commutes' := fun r => by\n      change e.conj (r \u2022 LinearMap.id) = r \u2022 LinearMap.id\n      rw [LinearEquiv.map_smul, LinearEquiv.conj_id] }", "start": [976, 1], "end": [983, 55], "kind": "commanddeclaration"}, {"full_name": "algEquivMatrix", "code": "def algEquivMatrix [Fintype n] (h : Basis n R M) : Module.End R M \u2243\u2090[R] Matrix n n R :=\n  h.equivFun.algConj.trans algEquivMatrix'", "start": [986, 1], "end": [989, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/GeomSum.lean", "imports": ["Mathlib/Tactic/Abel.lean", "Mathlib/Algebra/BigOperators/Order.lean", "Mathlib/Algebra/BigOperators/Intervals.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Ring.lean", "Mathlib/Data/Nat/Parity.lean"], "premises": [{"full_name": "geom_sum_succ", "code": "theorem geom_sum_succ {x : \u03b1} {n : \u2115} :\n    \u2211 i in range (n + 1), x ^ i = (x * \u2211 i in range n, x ^ i) + 1", "start": [46, 1], "end": [48, 61], "kind": "commanddeclaration"}, {"full_name": "geom_sum_succ'", "code": "theorem geom_sum_succ' {x : \u03b1} {n : \u2115} :\n    \u2211 i in range (n + 1), x ^ i = x ^ n + \u2211 i in range n, x ^ i", "start": [51, 1], "end": [53, 44], "kind": "commanddeclaration"}, {"full_name": "geom_sum_zero", "code": "theorem geom_sum_zero (x : \u03b1) : \u2211 i in range 0, x ^ i = 0", "start": [56, 1], "end": [57, 6], "kind": "commanddeclaration"}, {"full_name": "geom_sum_one", "code": "theorem geom_sum_one (x : \u03b1) : \u2211 i in range 1, x ^ i = 1", "start": [60, 1], "end": [60, 85], "kind": "commanddeclaration"}, {"full_name": "geom_sum_two", "code": "@[simp]\ntheorem geom_sum_two {x : \u03b1} : \u2211 i in range 2, x ^ i = x + 1", "start": [63, 1], "end": [64, 89], "kind": "commanddeclaration"}, {"full_name": "zero_geom_sum", "code": "@[simp]\ntheorem zero_geom_sum : \u2200 {n}, \u2211 i in range n, (0 : \u03b1) ^ i = if n = 0 then 0 else 1", "start": [67, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "one_geom_sum", "code": "theorem one_geom_sum (n : \u2115) : \u2211 i in range n, (1 : \u03b1) ^ i = n", "start": [76, 1], "end": [76, 74], "kind": "commanddeclaration"}, {"full_name": "op_geom_sum", "code": "theorem op_geom_sum (x : \u03b1) (n : \u2115) : op (\u2211 i in range n, x ^ i) = \u2211 i in range n, op x ^ i", "start": [81, 1], "end": [82, 7], "kind": "commanddeclaration"}, {"full_name": "op_geom_sum\u2082", "code": "@[simp]\ntheorem op_geom_sum\u2082 (x y : \u03b1) (n : \u2115) : \u2211 i in range n, op y ^ (n - 1 - i) * op x ^ i =\n    \u2211 i in range n, op y ^ i * op x ^ (n - 1 - i)", "start": [86, 1], "end": [94, 37], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_with_one", "code": "theorem geom_sum\u2082_with_one (x : \u03b1) (n : \u2115) :\n    \u2211 i in range n, x ^ i * 1 ^ (n - 1 - i) = \u2211 i in range n, x ^ i", "start": [97, 1], "end": [99, 52], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_mul_add", "code": "protected theorem Commute.geom_sum\u2082_mul_add {x y : \u03b1} (h : Commute x y) (n : \u2115) :\n    (\u2211 i in range n, (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n", "start": [102, 1], "end": [126, 81], "kind": "commanddeclaration"}, {"full_name": "neg_one_geom_sum", "code": "@[simp]\ntheorem neg_one_geom_sum [Ring \u03b1] {n : \u2115} :\n    \u2211 i in range n, (-1 : \u03b1) ^ i = if Even n then 0 else 1", "start": [131, 1], "end": [139, 64], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_self", "code": "theorem geom_sum\u2082_self {\u03b1 : Type*} [CommRing \u03b1] (x : \u03b1) (n : \u2115) :\n    \u2211 i in range n, x ^ i * x ^ (n - 1 - i) = n * x ^ (n - 1)", "start": [142, 1], "end": [152, 67], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_mul_add", "code": "theorem geom_sum\u2082_mul_add [CommSemiring \u03b1] (x y : \u03b1) (n : \u2115) :\n    (\u2211 i in range n, (x + y) ^ i * y ^ (n - 1 - i)) * x + y ^ n = (x + y) ^ n", "start": [155, 1], "end": [158, 40], "kind": "commanddeclaration"}, {"full_name": "geom_sum_mul_add", "code": "theorem geom_sum_mul_add [Semiring \u03b1] (x : \u03b1) (n : \u2115) :\n    (\u2211 i in range n, (x + 1) ^ i) * x + 1 = (x + 1) ^ n", "start": [161, 1], "end": [165, 13], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_mul", "code": "protected theorem Commute.geom_sum\u2082_mul [Ring \u03b1] {x y : \u03b1} (h : Commute x y) (n : \u2115) :\n    (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n", "start": [168, 1], "end": [172, 30], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_neg_geom_sum\u2082", "code": "theorem Commute.mul_neg_geom_sum\u2082 [Ring \u03b1] {x y : \u03b1} (h : Commute x y) (n : \u2115) :\n    ((y - x) * \u2211 i in range n, x ^ i * y ^ (n - 1 - i)) = y ^ n - x ^ n", "start": [175, 1], "end": [179, 45], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_geom_sum\u2082", "code": "theorem Commute.mul_geom_sum\u2082 [Ring \u03b1] {x y : \u03b1} (h : Commute x y) (n : \u2115) :\n    ((x - y) * \u2211 i in range n, x ^ i * y ^ (n - 1 - i)) = x ^ n - y ^ n", "start": [182, 1], "end": [184, 68], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_mul", "code": "theorem geom_sum\u2082_mul [CommRing \u03b1] (x y : \u03b1) (n : \u2115) :\n    (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ n", "start": [187, 1], "end": [189, 36], "kind": "commanddeclaration"}, {"full_name": "Commute.sub_dvd_pow_sub_pow", "code": "theorem Commute.sub_dvd_pow_sub_pow [Ring \u03b1] {x y : \u03b1} (h : Commute x y) (n : \u2115) :\n    x - y \u2223 x ^ n - y ^ n", "start": [192, 1], "end": [194, 34], "kind": "commanddeclaration"}, {"full_name": "sub_dvd_pow_sub_pow", "code": "theorem sub_dvd_pow_sub_pow [CommRing \u03b1] (x y : \u03b1) (n : \u2115) : x - y \u2223 x ^ n - y ^ n", "start": [196, 1], "end": [197, 42], "kind": "commanddeclaration"}, {"full_name": "one_sub_dvd_one_sub_pow", "code": "theorem one_sub_dvd_one_sub_pow [Ring \u03b1] (x : \u03b1) (n : \u2115) :\n    1 - x \u2223 1 - x ^ n", "start": [200, 1], "end": [203, 51], "kind": "commanddeclaration"}, {"full_name": "sub_one_dvd_pow_sub_one", "code": "theorem sub_one_dvd_pow_sub_one [Ring \u03b1] (x : \u03b1) (n : \u2115) :\n    x - 1 \u2223 x ^ n - 1", "start": [205, 1], "end": [208, 52], "kind": "commanddeclaration"}, {"full_name": "nat_sub_dvd_pow_sub_pow", "code": "theorem nat_sub_dvd_pow_sub_pow (x y n : \u2115) : x - y \u2223 x ^ n - y ^ n", "start": [210, 1], "end": [215, 63], "kind": "commanddeclaration"}, {"full_name": "Odd.add_dvd_pow_add_pow", "code": "theorem Odd.add_dvd_pow_add_pow [CommRing \u03b1] (x y : \u03b1) {n : \u2115} (h : Odd n) :\n    x + y \u2223 x ^ n + y ^ n", "start": [218, 1], "end": [222, 28], "kind": "commanddeclaration"}, {"full_name": "Odd.nat_add_dvd_pow_add_pow", "code": "theorem Odd.nat_add_dvd_pow_add_pow (x y : \u2115) {n : \u2115} (h : Odd n) : x + y \u2223 x ^ n + y ^ n", "start": [225, 1], "end": [226, 56], "kind": "commanddeclaration"}, {"full_name": "geom_sum_mul", "code": "theorem geom_sum_mul [Ring \u03b1] (x : \u03b1) (n : \u2115) : (\u2211 i in range n, x ^ i) * (x - 1) = x ^ n - 1", "start": [229, 1], "end": [232, 13], "kind": "commanddeclaration"}, {"full_name": "mul_geom_sum", "code": "theorem mul_geom_sum [Ring \u03b1] (x : \u03b1) (n : \u2115) : ((x - 1) * \u2211 i in range n, x ^ i) = x ^ n - 1", "start": [235, 1], "end": [236, 55], "kind": "commanddeclaration"}, {"full_name": "geom_sum_mul_neg", "code": "theorem geom_sum_mul_neg [Ring \u03b1] (x : \u03b1) (n : \u2115) :\n    (\u2211 i in range n, x ^ i) * (1 - x) = 1 - x ^ n", "start": [239, 1], "end": [243, 13], "kind": "commanddeclaration"}, {"full_name": "mul_neg_geom_sum", "code": "theorem mul_neg_geom_sum [Ring \u03b1] (x : \u03b1) (n : \u2115) : ((1 - x) * \u2211 i in range n, x ^ i) = 1 - x ^ n", "start": [246, 1], "end": [247, 59], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_comm", "code": "protected theorem Commute.geom_sum\u2082_comm {\u03b1 : Type u} [Semiring \u03b1] {x y : \u03b1} (n : \u2115)\n    (h : Commute x y) :\n    \u2211 i in range n, x ^ i * y ^ (n - 1 - i) = \u2211 i in range n, y ^ i * x ^ (n - 1 - i)", "start": [250, 1], "end": [257, 98], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_comm", "code": "theorem geom_sum\u2082_comm {\u03b1 : Type u} [CommSemiring \u03b1] (x y : \u03b1) (n : \u2115) :\n    \u2211 i in range n, x ^ i * y ^ (n - 1 - i) = \u2211 i in range n, y ^ i * x ^ (n - 1 - i)", "start": [260, 1], "end": [262, 37], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082", "code": "protected theorem Commute.geom_sum\u2082 [DivisionRing \u03b1] {x y : \u03b1} (h' : Commute x y) (h : x \u2260 y)\n    (n : \u2115) : \u2211 i in range n, x ^ i * y ^ (n - 1 - i) = (x ^ n - y ^ n) / (x - y)", "start": [265, 1], "end": [268, 49], "kind": "commanddeclaration"}, {"full_name": "geom\u2082_sum", "code": "theorem geom\u2082_sum [Field \u03b1] {x y : \u03b1} (h : x \u2260 y) (n : \u2115) :\n    \u2211 i in range n, x ^ i * y ^ (n - 1 - i) = (x ^ n - y ^ n) / (x - y)", "start": [271, 1], "end": [273, 34], "kind": "commanddeclaration"}, {"full_name": "geom_sum_eq", "code": "theorem geom_sum_eq [DivisionRing \u03b1] {x : \u03b1} (h : x \u2260 1) (n : \u2115) :\n    \u2211 i in range n, x ^ i = (x ^ n - 1) / (x - 1)", "start": [276, 1], "end": [279, 45], "kind": "commanddeclaration"}, {"full_name": "Commute.mul_geom_sum\u2082_Ico", "code": "protected theorem Commute.mul_geom_sum\u2082_Ico [Ring \u03b1] {x y : \u03b1} (h : Commute x y) {m n : \u2115}\n    (hmn : m \u2264 n) :\n    ((x - y) * \u2211 i in Finset.Ico m n, x ^ i * y ^ (n - 1 - i)) = x ^ n - x ^ m * y ^ (n - m)", "start": [282, 1], "end": [299, 95], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_succ_eq", "code": "protected theorem Commute.geom_sum\u2082_succ_eq {\u03b1 : Type u} [Ring \u03b1] {x y : \u03b1} (h : Commute x y)\n    {n : \u2115} :\n    \u2211 i in range (n + 1), x ^ i * y ^ (n - i) =\n      x ^ n + y * \u2211 i in range n, x ^ i * y ^ (n - 1 - i)", "start": [302, 1], "end": [313, 62], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_succ_eq", "code": "theorem geom_sum\u2082_succ_eq {\u03b1 : Type u} [CommRing \u03b1] (x y : \u03b1) {n : \u2115} :\n    \u2211 i in range (n + 1), x ^ i * y ^ (n - i) =\n      x ^ n + y * \u2211 i in range n, x ^ i * y ^ (n - 1 - i)", "start": [316, 1], "end": [319, 38], "kind": "commanddeclaration"}, {"full_name": "mul_geom_sum\u2082_Ico", "code": "theorem mul_geom_sum\u2082_Ico [CommRing \u03b1] (x y : \u03b1) {m n : \u2115} (hmn : m \u2264 n) :\n    ((x - y) * \u2211 i in Finset.Ico m n, x ^ i * y ^ (n - 1 - i)) = x ^ n - x ^ m * y ^ (n - m)", "start": [322, 1], "end": [324, 42], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_Ico_mul", "code": "protected theorem Commute.geom_sum\u2082_Ico_mul [Ring \u03b1] {x y : \u03b1} (h : Commute x y) {m n : \u2115}\n    (hmn : m \u2264 n) :\n    (\u2211 i in Finset.Ico m n, x ^ i * y ^ (n - 1 - i)) * (x - y) = x ^ n - y ^ (n - m) * x ^ m", "start": [327, 1], "end": [339, 47], "kind": "commanddeclaration"}, {"full_name": "geom_sum_Ico_mul", "code": "theorem geom_sum_Ico_mul [Ring \u03b1] (x : \u03b1) {m n : \u2115} (hmn : m \u2264 n) :\n    (\u2211 i in Finset.Ico m n, x ^ i) * (x - 1) = x ^ n - x ^ m", "start": [342, 1], "end": [344, 91], "kind": "commanddeclaration"}, {"full_name": "geom_sum_Ico_mul_neg", "code": "theorem geom_sum_Ico_mul_neg [Ring \u03b1] (x : \u03b1) {m n : \u2115} (hmn : m \u2264 n) :\n    (\u2211 i in Finset.Ico m n, x ^ i) * (1 - x) = x ^ m - x ^ n", "start": [347, 1], "end": [349, 98], "kind": "commanddeclaration"}, {"full_name": "Commute.geom_sum\u2082_Ico", "code": "protected theorem Commute.geom_sum\u2082_Ico [DivisionRing \u03b1] {x y : \u03b1} (h : Commute x y) (hxy : x \u2260 y)\n    {m n : \u2115} (hmn : m \u2264 n) :\n    (\u2211 i in Finset.Ico m n, x ^ i * y ^ (n - 1 - i)) = (x ^ n - y ^ (n - m) * x ^ m) / (x - y)", "start": [352, 1], "end": [356, 56], "kind": "commanddeclaration"}, {"full_name": "geom_sum\u2082_Ico", "code": "theorem geom_sum\u2082_Ico [Field \u03b1] {x y : \u03b1} (hxy : x \u2260 y) {m n : \u2115} (hmn : m \u2264 n) :\n    (\u2211 i in Finset.Ico m n, x ^ i * y ^ (n - 1 - i)) = (x ^ n - y ^ (n - m) * x ^ m) / (x - y)", "start": [359, 1], "end": [361, 42], "kind": "commanddeclaration"}, {"full_name": "geom_sum_Ico", "code": "theorem geom_sum_Ico [DivisionRing \u03b1] {x : \u03b1} (hx : x \u2260 1) {m n : \u2115} (hmn : m \u2264 n) :\n    \u2211 i in Finset.Ico m n, x ^ i = (x ^ n - x ^ m) / (x - 1)", "start": [364, 1], "end": [366, 95], "kind": "commanddeclaration"}, {"full_name": "geom_sum_Ico'", "code": "theorem geom_sum_Ico' [DivisionRing \u03b1] {x : \u03b1} (hx : x \u2260 1) {m n : \u2115} (hmn : m \u2264 n) :\n    \u2211 i in Finset.Ico m n, x ^ i = (x ^ m - x ^ n) / (1 - x)", "start": [369, 1], "end": [372, 66], "kind": "commanddeclaration"}, {"full_name": "geom_sum_Ico_le_of_lt_one", "code": "theorem geom_sum_Ico_le_of_lt_one [LinearOrderedField \u03b1] {x : \u03b1} (hx : 0 \u2264 x) (h'x : x < 1)\n    {m n : \u2115} : \u2211 i in Ico m n, x ^ i \u2264 x ^ m / (1 - x)", "start": [375, 1], "end": [384, 25], "kind": "commanddeclaration"}, {"full_name": "geom_sum_inv", "code": "theorem geom_sum_inv [DivisionRing \u03b1] {x : \u03b1} (hx1 : x \u2260 1) (hx0 : x \u2260 0) (n : \u2115) :\n    \u2211 i in range n, x\u207b\u00b9 ^ i = (x - 1)\u207b\u00b9 * (x - x\u207b\u00b9 ^ n * x)", "start": [387, 1], "end": [400, 51], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_geom_sum", "code": "theorem RingHom.map_geom_sum [Semiring \u03b1] [Semiring \u03b2] (x : \u03b1) (n : \u2115) (f : \u03b1 \u2192+* \u03b2) :\n    f (\u2211 i in range n, x ^ i) = \u2211 i in range n, f x ^ i", "start": [405, 1], "end": [406, 79], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_geom_sum\u2082", "code": "theorem RingHom.map_geom_sum\u2082 [Semiring \u03b1] [Semiring \u03b2] (x y : \u03b1) (n : \u2115) (f : \u03b1 \u2192+* \u03b2) :\n    f (\u2211 i in range n, x ^ i * y ^ (n - 1 - i)) = \u2211 i in range n, f x ^ i * f y ^ (n - 1 - i)", "start": [409, 1], "end": [411, 19], "kind": "commanddeclaration"}, {"full_name": "Nat.pred_mul_geom_sum_le", "code": "theorem Nat.pred_mul_geom_sum_le (a b n : \u2115) :\n    ((b - 1) * \u2211 i in range n.succ, a / b ^ i) \u2264 a * b - a / b ^ n", "start": [417, 1], "end": [429, 61], "kind": "commanddeclaration"}, {"full_name": "Nat.geom_sum_le", "code": "theorem Nat.geom_sum_le {b : \u2115} (hb : 2 \u2264 b) (a n : \u2115) :\n    \u2211 i in range n, a / b ^ i \u2264 a * b / (b - 1)", "start": [432, 1], "end": [439, 60], "kind": "commanddeclaration"}, {"full_name": "Nat.geom_sum_Ico_le", "code": "theorem Nat.geom_sum_Ico_le {b : \u2115} (hb : 2 \u2264 b) (a n : \u2115) :\n    \u2211 i in Ico 1 n, a / b ^ i \u2264 a / (b - 1)", "start": [442, 1], "end": [457, 100], "kind": "commanddeclaration"}, {"full_name": "geom_sum_pos", "code": "theorem geom_sum_pos [StrictOrderedSemiring \u03b1] (hx : 0 \u2264 x) (hn : n \u2260 0) :\n    0 < \u2211 i in range n, x ^ i", "start": [464, 1], "end": [466, 76], "kind": "commanddeclaration"}, {"full_name": "geom_sum_pos_and_lt_one", "code": "theorem geom_sum_pos_and_lt_one [StrictOrderedRing \u03b1] (hx : x < 0) (hx' : 0 < x + 1) (hn : 1 < n) :\n    (0 < \u2211 i in range n, x ^ i) \u2227 \u2211 i in range n, x ^ i < 1", "start": [469, 1], "end": [479, 38], "kind": "commanddeclaration"}, {"full_name": "geom_sum_alternating_of_le_neg_one", "code": "theorem geom_sum_alternating_of_le_neg_one [StrictOrderedRing \u03b1] (hx : x + 1 \u2264 0) (n : \u2115) :\n    if Even n then (\u2211 i in range n, x ^ i) \u2264 0 else 1 \u2264 \u2211 i in range n, x ^ i", "start": [482, 1], "end": [493, 64], "kind": "commanddeclaration"}, {"full_name": "geom_sum_alternating_of_lt_neg_one", "code": "theorem geom_sum_alternating_of_lt_neg_one [StrictOrderedRing \u03b1] (hx : x + 1 < 0) (hn : 1 < n) :\n    if Even n then (\u2211 i in range n, x ^ i) < 0 else 1 < \u2211 i in range n, x ^ i", "start": [496, 1], "end": [515, 24], "kind": "commanddeclaration"}, {"full_name": "geom_sum_pos'", "code": "theorem geom_sum_pos' [LinearOrderedRing \u03b1] (hx : 0 < x + 1) (hn : n \u2260 0) :\n    0 < \u2211 i in range n, x ^ i", "start": [518, 1], "end": [525, 84], "kind": "commanddeclaration"}, {"full_name": "Odd.geom_sum_pos", "code": "theorem Odd.geom_sum_pos [LinearOrderedRing \u03b1] (h : Odd n) : 0 < \u2211 i in range n, x ^ i", "start": [528, 1], "end": [538, 47], "kind": "commanddeclaration"}, {"full_name": "geom_sum_pos_iff", "code": "theorem geom_sum_pos_iff [LinearOrderedRing \u03b1] (hn : n \u2260 0) :\n    (0 < \u2211 i in range n, x ^ i) \u2194 Odd n \u2228 0 < x + 1", "start": [541, 1], "end": [549, 33], "kind": "commanddeclaration"}, {"full_name": "geom_sum_ne_zero", "code": "theorem geom_sum_ne_zero [LinearOrderedRing \u03b1] (hx : x \u2260 -1) (hn : n \u2260 0) :\n    \u2211 i in range n, x ^ i \u2260 0", "start": [552, 1], "end": [564, 52], "kind": "commanddeclaration"}, {"full_name": "geom_sum_eq_zero_iff_neg_one", "code": "theorem geom_sum_eq_zero_iff_neg_one [LinearOrderedRing \u03b1] (hn : n \u2260 0) :\n    \u2211 i in range n, x ^ i = 0 \u2194 x = -1 \u2227 Even n", "start": [567, 1], "end": [575, 33], "kind": "commanddeclaration"}, {"full_name": "geom_sum_neg_iff", "code": "theorem geom_sum_neg_iff [LinearOrderedRing \u03b1] (hn : n \u2260 0) :\n    \u2211 i in range n, x ^ i < 0 \u2194 Even n \u2227 x + 1 < 0", "start": [578, 1], "end": [583, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Subsingleton.lean", "imports": ["Mathlib/Order/Filter/Bases.lean", "Mathlib/Order/Filter/Ultrafilter.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.Subsingleton", "code": "protected def Subsingleton (l : Filter \u03b1) : Prop := \u2203 s \u2208 l, Set.Subsingleton s", "start": [20, 1], "end": [22, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.subsingleton_iff", "code": "theorem HasBasis.subsingleton_iff {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1} (h : l.HasBasis p s) :\n    l.Subsingleton \u2194 \u2203 i, p i \u2227 (s i).Subsingleton", "start": [24, 1], "end": [26, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.anti", "code": "theorem Subsingleton.anti {l'} (hl : l.Subsingleton) (hl' : l' \u2264 l) : l'.Subsingleton", "start": [28, 1], "end": [29, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.of_subsingleton", "code": "@[nontriviality]\ntheorem Subsingleton.of_subsingleton [Subsingleton \u03b1] : l.Subsingleton", "start": [31, 1], "end": [33, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.map", "code": "theorem Subsingleton.map (hl : l.Subsingleton) (f : \u03b1 \u2192 \u03b2) : (map f l).Subsingleton", "start": [35, 1], "end": [36, 66], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.prod", "code": "theorem Subsingleton.prod (hl : l.Subsingleton) {l' : Filter \u03b2} (hl' : l'.Subsingleton) :\n    (l \u00d7\u02e2 l').Subsingleton", "start": [38, 1], "end": [40, 97], "kind": "commanddeclaration"}, {"full_name": "Filter.subsingleton_pure", "code": "@[simp]\ntheorem subsingleton_pure {a : \u03b1} : Filter.Subsingleton (pure a)", "start": [42, 1], "end": [44, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.subsingleton_bot", "code": "@[simp]\ntheorem subsingleton_bot : Filter.Subsingleton (\u22a5 : Filter \u03b1)", "start": [46, 1], "end": [48, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.exists_eq_pure", "code": "theorem Subsingleton.exists_eq_pure [l.NeBot] (hl : l.Subsingleton) : \u2203 a, l = pure a", "start": [50, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.subsingleton_iff_bot_or_pure", "code": "theorem subsingleton_iff_bot_or_pure : l.Subsingleton \u2194 l = \u22a5 \u2228 \u2203 a, l = pure a", "start": [57, 1], "end": [61, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.subsingleton_iff_exists_le_pure", "code": "theorem subsingleton_iff_exists_le_pure [Nonempty \u03b1] : l.Subsingleton \u2194 \u2203 a, l \u2264 pure a", "start": [63, 1], "end": [68, 69], "kind": "commanddeclaration"}, {"full_name": "Filter.subsingleton_iff_exists_singleton_mem", "code": "theorem subsingleton_iff_exists_singleton_mem [Nonempty \u03b1] : l.Subsingleton \u2194 \u2203 a, {a} \u2208 l", "start": [70, 1], "end": [71, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.Subsingleton.exists_le_pure", "code": "alias \u27e8Subsingleton.exists_le_pure, _\u27e9 := subsingleton_iff_exists_le_pure", "start": [73, 1], "end": [74, 74], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.Subsingleton.isCountablyGenerated", "code": "lemma Subsingleton.isCountablyGenerated (hl : l.Subsingleton) : IsCountablyGenerated l := by\n  rcases subsingleton_iff_bot_or_pure.1 hl with rfl|\u27e8x, rfl\u27e9\n  \u00b7 exact isCountablyGenerated_bot\n  \u00b7 exact isCountablyGenerated_pure x", "start": [76, 1], "end": [79, 38], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/Algebra/RestrictScalars.lean", "imports": ["Mathlib/Algebra/Algebra/Tower.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RestrictScalars", "code": "@[nolint unusedArguments]\ndef RestrictScalars (_R _S M : Type*) : Type _ := M", "start": [46, 1], "end": [78, 52], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.moduleOrig", "code": "def RestrictScalars.moduleOrig [I : Module S M] : Module S (RestrictScalars R S M) := I", "start": [93, 1], "end": [94, 88], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.module", "code": "instance RestrictScalars.module [Module S M] : Module R (RestrictScalars R S M) :=\n  Module.compHom M (algebraMap R S)", "start": [103, 1], "end": [109, 36], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.isScalarTower", "code": "instance RestrictScalars.isScalarTower [Module S M] : IsScalarTower R S (RestrictScalars R S M) :=\n  \u27e8fun r S M \u21a6 by\n    rw [Algebra.smul_def, mul_smul]\n    rfl\u27e9", "start": [111, 1], "end": [116, 9], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.opModule", "code": "instance RestrictScalars.opModule [Module S\u1d50\u1d52\u1d56 M] : Module R\u1d50\u1d52\u1d56 (RestrictScalars R S M) :=\n  letI : Module S\u1d50\u1d52\u1d56 (RestrictScalars R S M) := \u2039Module S\u1d50\u1d52\u1d56 M\u203a\n  Module.compHom M (RingHom.op $ algebraMap R S)", "start": [121, 1], "end": [128, 49], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.isCentralScalar", "code": "instance RestrictScalars.isCentralScalar [Module S M] [Module S\u1d50\u1d52\u1d56 M] [IsCentralScalar S M] :\n    IsCentralScalar R (RestrictScalars R S M) where\n  op_smul_eq_smul r _x := (op_smul_eq_smul (algebraMap R S r) (_ : M) : _)", "start": [131, 1], "end": [133, 75], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.lsmul", "code": "def RestrictScalars.lsmul [Module S M] : S \u2192\u2090[R] Module.End R (RestrictScalars R S M) :=\n  letI : Module S (RestrictScalars R S M) := RestrictScalars.moduleOrig R S M\n  Algebra.lsmul R R (RestrictScalars R S M)", "start": [136, 1], "end": [143, 44], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.addEquiv", "code": "def RestrictScalars.addEquiv : RestrictScalars R S M \u2243+ M :=\n  AddEquiv.refl M", "start": [150, 1], "end": [152, 18], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.smul_def", "code": "theorem RestrictScalars.smul_def (c : R) (x : RestrictScalars R S M) :\n    c \u2022 x = (RestrictScalars.addEquiv R S M).symm\n      (algebraMap R S c \u2022 RestrictScalars.addEquiv R S M x)", "start": [157, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.addEquiv_map_smul", "code": "@[simp]\ntheorem RestrictScalars.addEquiv_map_smul (c : R) (x : RestrictScalars R S M) :\n    RestrictScalars.addEquiv R S M (c \u2022 x) = algebraMap R S c \u2022 RestrictScalars.addEquiv R S M x", "start": [163, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.addEquiv_symm_map_algebraMap_smul", "code": "theorem RestrictScalars.addEquiv_symm_map_algebraMap_smul (r : R) (x : M) :\n    (RestrictScalars.addEquiv R S M).symm (algebraMap R S r \u2022 x) =\n      r \u2022 (RestrictScalars.addEquiv R S M).symm x", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.addEquiv_symm_map_smul_smul", "code": "theorem RestrictScalars.addEquiv_symm_map_smul_smul (r : R) (s : S) (x : M) :\n    (RestrictScalars.addEquiv R S M).symm ((r \u2022 s) \u2022 x) =\n      r \u2022 (RestrictScalars.addEquiv R S M).symm (s \u2022 x)", "start": [175, 1], "end": [179, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.lsmul_apply_apply", "code": "theorem RestrictScalars.lsmul_apply_apply (s : S) (x : RestrictScalars R S M) :\n    RestrictScalars.lsmul R S M s x =\n      (RestrictScalars.addEquiv R S M).symm (s \u2022 RestrictScalars.addEquiv R S M x)", "start": [182, 1], "end": [185, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.ringEquiv", "code": "def RestrictScalars.ringEquiv : RestrictScalars R S A \u2243+* A :=\n  RingEquiv.refl _", "start": [202, 1], "end": [204, 19], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.ringEquiv_map_smul", "code": "@[simp]\ntheorem RestrictScalars.ringEquiv_map_smul (r : R) (x : RestrictScalars R S A) :\n    RestrictScalars.ringEquiv R S A (r \u2022 x) =\n      algebraMap R S r \u2022 RestrictScalars.ringEquiv R S A x", "start": [209, 1], "end": [213, 6], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.algebra", "code": "instance RestrictScalars.algebra : Algebra R (RestrictScalars R S A) :=\n  { (algebraMap S A).comp (algebraMap R S) with\n    smul := (\u00b7 \u2022 \u00b7)\n    commutes' := fun _ _ \u21a6 Algebra.commutes' _ _\n    smul_def' := fun _ _ \u21a6 Algebra.smul_def' _ _ }", "start": [216, 1], "end": [221, 51], "kind": "commanddeclaration"}, {"full_name": "RestrictScalars.ringEquiv_algebraMap", "code": "@[simp]\ntheorem RestrictScalars.ringEquiv_algebraMap (r : R) :\n    RestrictScalars.ringEquiv R S A (algebraMap R (RestrictScalars R S A) r) =\n      algebraMap S A (algebraMap R S r)", "start": [223, 1], "end": [227, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Finiteness.lean", "imports": ["Mathlib/Data/Set/Pointwise/Finite.lean", "Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Data/Finset/Preimage.lean", "Mathlib/GroupTheory/Submonoid/Operations.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/QuotientGroup.lean", "Mathlib/SetTheory/Cardinal/Finite.lean"], "premises": [{"full_name": "Submonoid.FG", "code": "@[to_additive]\ndef Submonoid.FG (P : Submonoid M) : Prop :=\n  \u2203 S : Finset M, Submonoid.closure \u2191S = P", "start": [42, 1], "end": [45, 43], "kind": "commanddeclaration"}, {"full_name": "Submonoid.fg_iff", "code": "@[to_additive \"An equivalent expression of `AddSubmonoid.FG` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Submonoid.fg_iff (P : Submonoid M) :\n    Submonoid.FG P \u2194 \u2203 S : Set M, Submonoid.closure S = P \u2227 S.Finite", "start": [53, 1], "end": [59, 44], "kind": "commanddeclaration"}, {"full_name": "Submonoid.fg_iff_add_fg", "code": "theorem Submonoid.fg_iff_add_fg (P : Submonoid M) : P.FG \u2194 P.toAddSubmonoid.FG", "start": [63, 1], "end": [71, 91], "kind": "commanddeclaration"}, {"full_name": "AddSubmonoid.fg_iff_mul_fg", "code": "theorem AddSubmonoid.fg_iff_mul_fg (P : AddSubmonoid N) : P.FG \u2194 P.toSubmonoid.FG", "start": [74, 1], "end": [75, 57], "kind": "commanddeclaration"}, {"full_name": "Monoid.FG", "code": "class Monoid.FG : Prop where\n  out : (\u22a4 : Submonoid M).FG", "start": [84, 1], "end": [86, 29], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.FG", "code": "class AddMonoid.FG : Prop where\n  out : (\u22a4 : AddSubmonoid N).FG", "start": [89, 1], "end": [92, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_def", "code": "theorem Monoid.fg_def : Monoid.FG M \u2194 (\u22a4 : Submonoid M).FG", "start": [99, 1], "end": [100, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.fg_def", "code": "theorem AddMonoid.fg_def : AddMonoid.FG N \u2194 (\u22a4 : AddSubmonoid N).FG", "start": [103, 1], "end": [104, 31], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_iff", "code": "@[to_additive\n      \"An equivalent expression of `AddMonoid.FG` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Monoid.fg_iff :\n    Monoid.FG M \u2194 \u2203 S : Set M, Submonoid.closure S = (\u22a4 : Submonoid M) \u2227 S.Finite", "start": [107, 1], "end": [112, 79], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_iff_add_fg", "code": "theorem Monoid.fg_iff_add_fg : Monoid.FG M \u2194 AddMonoid.FG (Additive M)", "start": [116, 1], "end": [117, 99], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.fg_iff_mul_fg", "code": "theorem AddMonoid.fg_iff_mul_fg : AddMonoid.FG N \u2194 Monoid.FG (Multiplicative N)", "start": [120, 1], "end": [122, 46], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.fg_of_monoid_fg", "code": "instance AddMonoid.fg_of_monoid_fg [Monoid.FG M] : AddMonoid.FG (Additive M) :=\n  Monoid.fg_iff_add_fg.1 \u2039_\u203a", "start": [125, 1], "end": [126, 29], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_of_addMonoid_fg", "code": "instance Monoid.fg_of_addMonoid_fg [AddMonoid.FG N] : Monoid.FG (Multiplicative N) :=\n  AddMonoid.fg_iff_mul_fg.1 \u2039_\u203a", "start": [129, 1], "end": [130, 32], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_of_finite", "code": "@[to_additive]\ninstance (priority := 100) Monoid.fg_of_finite [Finite M] : Monoid.FG M := by\n  cases nonempty_fintype M\n  exact \u27e8\u27e8Finset.univ, by rw [Finset.coe_univ]; exact Submonoid.closure_univ\u27e9\u27e9", "start": [133, 1], "end": [136, 79], "kind": "commanddeclaration"}, {"full_name": "Submonoid.FG.map", "code": "@[to_additive]\ntheorem Submonoid.FG.map {M' : Type*} [Monoid M'] {P : Submonoid M} (h : P.FG) (e : M \u2192* M') :\n    (P.map e).FG", "start": [142, 1], "end": [147, 72], "kind": "commanddeclaration"}, {"full_name": "Submonoid.FG.map_injective", "code": "@[to_additive]\ntheorem Submonoid.FG.map_injective {M' : Type*} [Monoid M'] {P : Submonoid M} (e : M \u2192* M')\n    (he : Function.Injective e) (h : (P.map e).FG) : P.FG", "start": [151, 1], "end": [161, 38], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_iff_submonoid_fg", "code": "@[to_additive (attr := simp)]\ntheorem Monoid.fg_iff_submonoid_fg (N : Submonoid M) : Monoid.FG N \u2194 N.FG", "start": [165, 1], "end": [168, 99], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_of_surjective", "code": "@[to_additive]\ntheorem Monoid.fg_of_surjective {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M \u2192* M')\n    (hf : Function.Surjective f) : Monoid.FG M'", "start": [172, 1], "end": [179, 43], "kind": "commanddeclaration"}, {"full_name": "Monoid.fg_range", "code": "@[to_additive]\ninstance Monoid.fg_range {M' : Type*} [Monoid M'] [Monoid.FG M] (f : M \u2192* M') :\n    Monoid.FG (MonoidHom.mrange f) :=\n  Monoid.fg_of_surjective f.mrangeRestrict f.mrangeRestrict_surjective", "start": [183, 1], "end": [186, 71], "kind": "commanddeclaration"}, {"full_name": "Submonoid.powers_fg", "code": "@[to_additive AddSubmonoid.multiples_fg]\ntheorem Submonoid.powers_fg (r : M) : (Submonoid.powers r).FG", "start": [190, 1], "end": [192, 78], "kind": "commanddeclaration"}, {"full_name": "Monoid.powers_fg", "code": "@[to_additive AddMonoid.multiples_fg]\ninstance Monoid.powers_fg (r : M) : Monoid.FG (Submonoid.powers r) :=\n  (Monoid.fg_iff_submonoid_fg _).mpr (Submonoid.powers_fg r)", "start": [196, 1], "end": [198, 61], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure_finset_fg", "code": "@[to_additive]\ninstance Monoid.closure_finset_fg (s : Finset M) : Monoid.FG (Submonoid.closure (s : Set M)) := by\n  refine' \u27e8\u27e8s.preimage Subtype.val (Subtype.coe_injective.injOn _), _\u27e9\u27e9\n  rw [Finset.coe_preimage, Submonoid.closure_closure_coe_preimage]", "start": [202, 1], "end": [205, 67], "kind": "commanddeclaration"}, {"full_name": "Monoid.closure_finite_fg", "code": "@[to_additive]\ninstance Monoid.closure_finite_fg (s : Set M) [Finite s] : Monoid.FG (Submonoid.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset \u25b8 Monoid.closure_finset_fg s.toFinset", "start": [209, 1], "end": [212, 55], "kind": "commanddeclaration"}, {"full_name": "Subgroup.FG", "code": "@[to_additive]\ndef Subgroup.FG (P : Subgroup G) : Prop :=\n  \u2203 S : Finset G, Subgroup.closure \u2191S = P", "start": [223, 1], "end": [226, 42], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fg_iff", "code": "@[to_additive \"An equivalent expression of `AddSubgroup.fg` in terms of `Set.Finite` instead of\n`Finset`.\"]\ntheorem Subgroup.fg_iff (P : Subgroup G) :\n    Subgroup.FG P \u2194 \u2203 S : Set G, Subgroup.closure S = P \u2227 S.Finite", "start": [234, 1], "end": [240, 44], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fg_iff_submonoid_fg", "code": "@[to_additive \"An additive subgroup is finitely generated if\nand only if it is finitely generated as an additive submonoid.\"]\ntheorem Subgroup.fg_iff_submonoid_fg (P : Subgroup G) : P.FG \u2194 P.toSubmonoid.FG", "start": [244, 1], "end": [258, 36], "kind": "commanddeclaration"}, {"full_name": "Subgroup.fg_iff_add_fg", "code": "theorem Subgroup.fg_iff_add_fg (P : Subgroup G) : P.FG \u2194 P.toAddSubgroup.FG", "start": [262, 1], "end": [264, 47], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.fg_iff_mul_fg", "code": "theorem AddSubgroup.fg_iff_mul_fg (P : AddSubgroup H) : P.FG \u2194 P.toSubgroup.FG", "start": [267, 1], "end": [269, 66], "kind": "commanddeclaration"}, {"full_name": "Group.FG", "code": "class Group.FG : Prop where\n  out : (\u22a4 : Subgroup G).FG", "start": [278, 1], "end": [280, 28], "kind": "commanddeclaration"}, {"full_name": "AddGroup.FG", "code": "class AddGroup.FG : Prop where\n  out : (\u22a4 : AddSubgroup H).FG", "start": [283, 1], "end": [286, 31], "kind": "commanddeclaration"}, {"full_name": "Group.fg_def", "code": "theorem Group.fg_def : Group.FG G \u2194 (\u22a4 : Subgroup G).FG", "start": [293, 1], "end": [294, 31], "kind": "commanddeclaration"}, {"full_name": "AddGroup.fg_def", "code": "theorem AddGroup.fg_def : AddGroup.FG H \u2194 (\u22a4 : AddSubgroup H).FG", "start": [297, 1], "end": [298, 31], "kind": "commanddeclaration"}, {"full_name": "Group.fg_iff", "code": "@[to_additive\n      \"An equivalent expression of `AddGroup.fg` in terms of `Set.Finite` instead of `Finset`.\"]\ntheorem Group.fg_iff : Group.FG G \u2194 \u2203 S : Set G, Subgroup.closure S = (\u22a4 : Subgroup G) \u2227 S.Finite", "start": [301, 1], "end": [305, 77], "kind": "commanddeclaration"}, {"full_name": "Group.fg_iff'", "code": "@[to_additive]\ntheorem Group.fg_iff' :\n    Group.FG G \u2194 \u2203 (n : _) (S : Finset G), S.card = n \u2227 Subgroup.closure (S : Set G) = \u22a4", "start": [309, 1], "end": [312, 92], "kind": "commanddeclaration"}, {"full_name": "Group.fg_iff_monoid_fg", "code": "@[to_additive \"An additive group is finitely generated if and only\nif it is finitely generated as an additive monoid.\"]\ntheorem Group.fg_iff_monoid_fg : Group.FG G \u2194 Monoid.FG G", "start": [316, 1], "end": [321, 78], "kind": "commanddeclaration"}, {"full_name": "Group.fg_iff_subgroup_fg", "code": "@[to_additive (attr := simp)]\ntheorem Group.fg_iff_subgroup_fg (H : Subgroup G) : Group.FG H \u2194 H.FG", "start": [325, 1], "end": [328, 42], "kind": "commanddeclaration"}, {"full_name": "GroupFG.iff_add_fg", "code": "theorem GroupFG.iff_add_fg : Group.FG G \u2194 AddGroup.FG (Additive G)", "start": [330, 1], "end": [331, 97], "kind": "commanddeclaration"}, {"full_name": "AddGroup.fg_iff_mul_fg", "code": "theorem AddGroup.fg_iff_mul_fg : AddGroup.FG H \u2194 Group.FG (Multiplicative H)", "start": [334, 1], "end": [336, 45], "kind": "commanddeclaration"}, {"full_name": "AddGroup.fg_of_group_fg", "code": "instance AddGroup.fg_of_group_fg [Group.FG G] : AddGroup.FG (Additive G) :=\n  GroupFG.iff_add_fg.1 \u2039_\u203a", "start": [339, 1], "end": [340, 27], "kind": "commanddeclaration"}, {"full_name": "Group.fg_of_mul_group_fg", "code": "instance Group.fg_of_mul_group_fg [AddGroup.FG H] : Group.FG (Multiplicative H) :=\n  AddGroup.fg_iff_mul_fg.1 \u2039_\u203a", "start": [343, 1], "end": [344, 31], "kind": "commanddeclaration"}, {"full_name": "Group.fg_of_finite", "code": "@[to_additive]\ninstance (priority := 100) Group.fg_of_finite [Finite G] : Group.FG G := by\n  cases nonempty_fintype G\n  exact \u27e8\u27e8Finset.univ, by rw [Finset.coe_univ]; exact Subgroup.closure_univ\u27e9\u27e9", "start": [347, 1], "end": [350, 78], "kind": "commanddeclaration"}, {"full_name": "Group.fg_of_surjective", "code": "@[to_additive]\ntheorem Group.fg_of_surjective {G' : Type*} [Group G'] [hG : Group.FG G] {f : G \u2192* G'}\n    (hf : Function.Surjective f) : Group.FG G'", "start": [354, 1], "end": [358, 74], "kind": "commanddeclaration"}, {"full_name": "Group.fg_range", "code": "@[to_additive]\ninstance Group.fg_range {G' : Type*} [Group G'] [Group.FG G] (f : G \u2192* G') : Group.FG f.range :=\n  Group.fg_of_surjective f.rangeRestrict_surjective", "start": [362, 1], "end": [364, 52], "kind": "commanddeclaration"}, {"full_name": "Group.closure_finset_fg", "code": "@[to_additive]\ninstance Group.closure_finset_fg (s : Finset G) : Group.FG (Subgroup.closure (s : Set G)) := by\n  refine' \u27e8\u27e8s.preimage Subtype.val (Subtype.coe_injective.injOn _), _\u27e9\u27e9\n  rw [Finset.coe_preimage, \u2190 Subgroup.coeSubtype, Subgroup.closure_preimage_eq_top]", "start": [368, 1], "end": [371, 84], "kind": "commanddeclaration"}, {"full_name": "Group.closure_finite_fg", "code": "@[to_additive]\ninstance Group.closure_finite_fg (s : Set G) [Finite s] : Group.FG (Subgroup.closure s) :=\n  haveI := Fintype.ofFinite s\n  s.coe_toFinset \u25b8 Group.closure_finset_fg s.toFinset", "start": [375, 1], "end": [378, 54], "kind": "commanddeclaration"}, {"full_name": "Group.rank", "code": "@[to_additive \"The minimum number of generators of an additive group\"]\nnoncomputable def Group.rank [h : Group.FG G] :=\n  @Nat.find _ (Classical.decPred _) (Group.fg_iff'.mp h)", "start": [384, 1], "end": [387, 57], "kind": "commanddeclaration"}, {"full_name": "Group.rank_spec", "code": "@[to_additive]\ntheorem Group.rank_spec [h : Group.FG G] :\n    \u2203 S : Finset G, S.card = Group.rank G \u2227 Subgroup.closure (S : Set G) = \u22a4", "start": [391, 1], "end": [394, 62], "kind": "commanddeclaration"}, {"full_name": "Group.rank_le", "code": "@[to_additive]\ntheorem Group.rank_le [h : Group.FG G] {S : Finset G} (hS : Subgroup.closure (S : Set G) = \u22a4) :\n    Group.rank G \u2264 S.card", "start": [398, 1], "end": [401, 75], "kind": "commanddeclaration"}, {"full_name": "Group.rank_le_of_surjective", "code": "@[to_additive]\ntheorem Group.rank_le_of_surjective [Group.FG G] [Group.FG G'] (f : G \u2192* G')\n    (hf : Function.Surjective f) : Group.rank G' \u2264 Group.rank G", "start": [407, 1], "end": [415, 46], "kind": "commanddeclaration"}, {"full_name": "Group.rank_range_le", "code": "@[to_additive]\ntheorem Group.rank_range_le [Group.FG G] {f : G \u2192* G'} : Group.rank f.range \u2264 Group.rank G", "start": [419, 1], "end": [421, 73], "kind": "commanddeclaration"}, {"full_name": "Group.rank_congr", "code": "@[to_additive]\ntheorem Group.rank_congr [Group.FG G] [Group.FG G'] (f : G \u2243* G') : Group.rank G = Group.rank G'", "start": [425, 1], "end": [428, 49], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rank_congr", "code": "@[to_additive]\ntheorem rank_congr {H K : Subgroup G} [Group.FG H] [Group.FG K] (h : H = K) :\n    Group.rank H = Group.rank K", "start": [436, 1], "end": [438, 51], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rank_closure_finset_le_card", "code": "@[to_additive]\ntheorem rank_closure_finset_le_card (s : Finset G) : Group.rank (closure (s : Set G)) \u2264 s.card", "start": [442, 1], "end": [453, 40], "kind": "commanddeclaration"}, {"full_name": "Subgroup.rank_closure_finite_le_nat_card", "code": "@[to_additive]\ntheorem rank_closure_finite_le_nat_card (s : Set G) [Finite s] :\n    Group.rank (closure s) \u2264 Nat.card s", "start": [457, 1], "end": [462, 47], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.fg", "code": "@[to_additive]\ninstance QuotientGroup.fg [Group.FG G] (N : Subgroup G) [Subgroup.Normal N] : Group.FG <| G \u29f8 N :=\n  Group.fg_of_surjective <| QuotientGroup.mk'_surjective N", "start": [470, 1], "end": [472, 59], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/Arithmetic.lean", "imports": ["Mathlib/SetTheory/Ordinal/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.lift_add", "code": "@[simp]\ntheorem lift_add (a b : Ordinal.{v}) : lift.{u} (a + b) = lift.{u} a + lift.{u} b", "start": [68, 1], "end": [73, 101], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_succ", "code": "@[simp]\ntheorem lift_succ (a : Ordinal.{v}) : lift.{u} (succ a) = succ (lift.{u} a)", "start": [76, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_contravariantClass_le", "code": "instance add_contravariantClass_le : ContravariantClass Ordinal.{u} Ordinal.{u} (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun a b c =>\n    inductionOn a fun \u03b1 r hr =>\n      inductionOn b fun \u03b2\u2081 s\u2081 hs\u2081 =>\n        inductionOn c fun \u03b2\u2082 s\u2082 hs\u2082 \u27e8f\u27e9 =>\n          \u27e8have fl : \u2200 a, f (Sum.inl a) = Sum.inl a := fun a => by\n              simpa only [InitialSeg.trans_apply, InitialSeg.leAdd_apply] using\n                @InitialSeg.eq _ _ _ _ _\n                  ((InitialSeg.leAdd r s\u2081).trans f) (InitialSeg.leAdd r s\u2082) a\n            have : \u2200 b, { b' // f (Sum.inr b) = Sum.inr b' } := by\n              intro b; cases e : f (Sum.inr b)\n              \u00b7 rw [\u2190 fl] at e\n                have := f.inj' e\n                contradiction\n              \u00b7 exact \u27e8_, rfl\u27e9\n            let g (b) := (this b).1\n            have fr : \u2200 b, f (Sum.inr b) = Sum.inr (g b) := fun b => (this b).2\n            \u27e8\u27e8\u27e8g, fun x y h => by\n                  injection f.inj' (by rw [fr, fr, h] : f (Sum.inr x) = f (Sum.inr y))\u27e9,\n                @fun a b => by\n                  simpa only [Sum.lex_inr_inr, fr, InitialSeg.coe_coe_fn, Embedding.coeFn_mk] using\n                    @RelEmbedding.map_rel_iff _ _ _ _ f.toRelEmbedding (Sum.inr a) (Sum.inr b)\u27e9,\n              fun a b H => by\n                rcases f.init (by rw [fr] <;> exact Sum.lex_inr_inr.2 H) with \u27e8a' | a', h\u27e9\n                \u00b7 rw [fl] at h\n                  cases h\n                \u00b7 rw [fr] at h\n                  exact \u27e8a', Sum.inr.inj h\u27e9\u27e9\u27e9\u27e9", "start": [82, 1], "end": [112, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_left_cancel", "code": "theorem add_left_cancel (a) {b c : Ordinal} : a + b = a + c \u2194 b = c", "start": [115, 1], "end": [116, 51], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_lt_add_iff_left'", "code": "private theorem add_lt_add_iff_left' (a) {b c : Ordinal} : a + b < a + c \u2194 b < c", "start": [119, 1], "end": [120, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_covariantClass_lt", "code": "instance add_covariantClass_lt : CovariantClass Ordinal.{u} Ordinal.{u} (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun a _b _c => (add_lt_add_iff_left' a).2\u27e9", "start": [122, 1], "end": [123, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_contravariantClass_lt", "code": "instance add_contravariantClass_lt : ContravariantClass Ordinal.{u} Ordinal.{u} (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  \u27e8fun a _b _c => (add_lt_add_iff_left' a).1\u27e9", "start": [126, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_swap_contravariantClass_lt", "code": "instance add_swap_contravariantClass_lt :\n    ContravariantClass Ordinal.{u} Ordinal.{u} (swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7) :=\n  \u27e8fun _a _b _c => lt_imp_lt_of_le_imp_le fun h => add_le_add_right h _\u27e9", "start": [130, 1], "end": [132, 73], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_le_add_iff_right", "code": "theorem add_le_add_iff_right {a b : Ordinal} : \u2200 n : \u2115, a + n \u2264 b + n \u2194 a \u2264 b", "start": [135, 1], "end": [138, 90], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_right_cancel", "code": "theorem add_right_cancel {a b : Ordinal} (n : \u2115) : a + n = b + n \u2194 a = b", "start": [141, 1], "end": [142, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_eq_zero_iff", "code": "theorem add_eq_zero_iff {a b : Ordinal} : a + b = 0 \u2194 a = 0 \u2227 b = 0", "start": [145, 1], "end": [149, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.left_eq_zero_of_add_eq_zero", "code": "theorem left_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : a = 0", "start": [152, 1], "end": [153, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.right_eq_zero_of_add_eq_zero", "code": "theorem right_eq_zero_of_add_eq_zero {a b : Ordinal} (h : a + b = 0) : b = 0", "start": [156, 1], "end": [157, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred", "code": "def pred (o : Ordinal) : Ordinal :=\n  if h : \u2203 a, o = succ a then Classical.choose h else o", "start": [163, 1], "end": [166, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_succ", "code": "@[simp]\ntheorem pred_succ (o) : pred (succ o) = o", "start": [169, 1], "end": [172, 88], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_le_self", "code": "theorem pred_le_self (o) : pred o \u2264 o", "start": [175, 1], "end": [179, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_eq_iff_not_succ", "code": "theorem pred_eq_iff_not_succ {o} : pred o = o \u2194 \u00ac\u2203 a, o = succ a", "start": [182, 1], "end": [183, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_eq_iff_not_succ'", "code": "theorem pred_eq_iff_not_succ' {o} : pred o = o \u2194 \u2200 a, o \u2260 succ a", "start": [186, 1], "end": [187, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_lt_iff_is_succ", "code": "theorem pred_lt_iff_is_succ {o} : pred o < o \u2194 \u2203 a, o = succ a", "start": [190, 1], "end": [192, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_zero", "code": "@[simp]\ntheorem pred_zero : pred 0 = 0", "start": [195, 1], "end": [197, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_pred_iff_is_succ", "code": "theorem succ_pred_iff_is_succ {o} : succ (pred o) = o \u2194 \u2203 a, o = succ a", "start": [200, 1], "end": [201, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_lt_of_not_succ", "code": "theorem succ_lt_of_not_succ {o b : Ordinal} (h : \u00ac\u2203 a, o = succ a) : succ b < o \u2194 b < o", "start": [204, 1], "end": [205, 88], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_pred", "code": "theorem lt_pred {a b} : a < pred b \u2194 succ a < b", "start": [208, 1], "end": [212, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.pred_le", "code": "theorem pred_le {a b} : pred a \u2264 b \u2194 a \u2264 succ b", "start": [215, 1], "end": [216, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_is_succ", "code": "@[simp]\ntheorem lift_is_succ {o : Ordinal.{v}} : (\u2203 a, lift.{u} o = succ a) \u2194 \u2203 a, o = succ a", "start": [219, 1], "end": [224, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_pred", "code": "@[simp]\ntheorem lift_pred (o : Ordinal.{v}) : lift.{u} (pred o) = pred (lift.{u} o)", "start": [227, 1], "end": [230, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit", "code": "def IsLimit (o : Ordinal) : Prop :=\n  o \u2260 0 \u2227 \u2200 a < o, succ a < o", "start": [236, 1], "end": [238, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit.succ_lt", "code": "theorem IsLimit.succ_lt {o a : Ordinal} (h : IsLimit o) : a < o \u2192 succ a < o", "start": [241, 1], "end": [242, 8], "kind": "commanddeclaration"}, {"full_name": "Ordinal.not_zero_isLimit", "code": "theorem not_zero_isLimit : \u00acIsLimit 0", "start": [245, 1], "end": [246, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.not_succ_isLimit", "code": "theorem not_succ_isLimit (o) : \u00acIsLimit (succ o)", "start": [249, 1], "end": [250, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.not_succ_of_isLimit", "code": "theorem not_succ_of_isLimit {o} (h : IsLimit o) : \u00ac\u2203 a, o = succ a", "start": [253, 1], "end": [254, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_lt_of_isLimit", "code": "theorem succ_lt_of_isLimit {o a : Ordinal} (h : IsLimit o) : succ a < o \u2194 a < o", "start": [257, 1], "end": [258, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_succ_of_isLimit", "code": "theorem le_succ_of_isLimit {o} (h : IsLimit o) {a} : o \u2264 succ a \u2194 o \u2264 a", "start": [261, 1], "end": [262, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.limit_le", "code": "theorem limit_le {o} (h : IsLimit o) {a} : o \u2264 a \u2194 \u2200 x < o, x \u2264 a", "start": [265, 1], "end": [267, 90], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_limit", "code": "theorem lt_limit {o} (h : IsLimit o) {a} : a < o \u2194 \u2203 x < o, a < x", "start": [270, 1], "end": [272, 75], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_isLimit", "code": "@[simp]\ntheorem lift_isLimit (o) : IsLimit (lift o) \u2194 IsLimit o", "start": [275, 1], "end": [281, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit.pos", "code": "theorem IsLimit.pos {o : Ordinal} (h : IsLimit o) : 0 < o", "start": [284, 1], "end": [285, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit.one_lt", "code": "theorem IsLimit.one_lt {o : Ordinal} (h : IsLimit o) : 1 < o", "start": [288, 1], "end": [289, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit.nat_lt", "code": "theorem IsLimit.nat_lt {o : Ordinal} (h : IsLimit o) : \u2200 n : \u2115, (n : Ordinal) < o", "start": [292, 1], "end": [294, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_or_succ_or_limit", "code": "theorem zero_or_succ_or_limit (o : Ordinal) : o = 0 \u2228 (\u2203 a, o = succ a) \u2228 IsLimit o", "start": [297, 1], "end": [301, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.limitRecOn", "code": "@[elab_as_elim]\ndef limitRecOn {C : Ordinal \u2192 Sort*} (o : Ordinal) (H\u2081 : C 0) (H\u2082 : \u2200 o, C o \u2192 C (succ o))\n    (H\u2083 : \u2200 o, IsLimit o \u2192 (\u2200 o' < o, C o') \u2192 C o) : C o :=\n  lt_wf.fix\n    (fun o IH =>\n      if o0 : o = 0 then by rw [o0]; exact H\u2081\n      else\n        if h : \u2203 a, o = succ a then by\n          rw [\u2190 succ_pred_iff_is_succ.2 h]; exact H\u2082 _ (IH _ <| pred_lt_iff_is_succ.2 h)\n        else H\u2083 _ \u27e8o0, fun a => (succ_lt_of_not_succ h).2\u27e9 IH)\n    o", "start": [304, 1], "end": [316, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.limitRecOn_zero", "code": "@[simp]\ntheorem limitRecOn_zero {C} (H\u2081 H\u2082 H\u2083) : @limitRecOn C 0 H\u2081 H\u2082 H\u2083 = H\u2081", "start": [319, 1], "end": [321, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.limitRecOn_succ", "code": "@[simp]\ntheorem limitRecOn_succ {C} (o H\u2081 H\u2082 H\u2083) :\n    @limitRecOn C (succ o) H\u2081 H\u2082 H\u2083 = H\u2082 o (@limitRecOn C o H\u2081 H\u2082 H\u2083)", "start": [324, 1], "end": [332, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.limitRecOn_limit", "code": "@[simp]\ntheorem limitRecOn_limit {C} (o H\u2081 H\u2082 H\u2083 h) :\n    @limitRecOn C o H\u2081 H\u2082 H\u2083 = H\u2083 o h fun x _h => @limitRecOn C x H\u2081 H\u2082 H\u2083", "start": [335, 1], "end": [338, 83], "kind": "commanddeclaration"}, {"full_name": "Ordinal.orderTopOutSucc", "code": "instance orderTopOutSucc (o : Ordinal) : OrderTop (succ o).out.\u03b1 :=\n  @OrderTop.mk _ _ (Top.mk _) le_enum_succ", "start": [341, 1], "end": [342, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enum_succ_eq_top", "code": "theorem enum_succ_eq_top {o : Ordinal} :\n    enum (\u00b7 < \u00b7) o\n        (by\n          rw [type_lt]\n          exact lt_succ o) =\n      (\u22a4 : (succ o).out.\u03b1)", "start": [345, 1], "end": [351, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.has_succ_of_type_succ_lt", "code": "theorem has_succ_of_type_succ_lt {\u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [wo : IsWellOrder \u03b1 r]\n    (h : \u2200 a < type r, succ a < type r) (x : \u03b1) : \u2203 y, r x y", "start": [354, 1], "end": [358, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.out_no_max_of_succ_lt", "code": "theorem out_no_max_of_succ_lt {o : Ordinal} (ho : \u2200 a < o, succ a < o) : NoMaxOrder o.out.\u03b1", "start": [361, 1], "end": [362, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bounded_singleton", "code": "theorem bounded_singleton {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsWellOrder \u03b1 r] (hr : (type r).IsLimit) (x) :\n    Bounded r {x}", "start": [365, 1], "end": [372, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_subrel_lt", "code": "theorem type_subrel_lt (o : Ordinal.{u}) :\n    type (Subrel ((\u00b7 < \u00b7) : Ordinal \u2192 Ordinal \u2192 Prop) { o' : Ordinal | o' < o })\n      = Ordinal.lift.{u + 1} o", "start": [376, 1], "end": [382, 85], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mk_initialSeg", "code": "theorem mk_initialSeg (o : Ordinal.{u}) :\n    #{ o' : Ordinal | o' < o } = Cardinal.lift.{u + 1} o.card", "start": [385, 1], "end": [387, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal", "code": "def IsNormal (f : Ordinal \u2192 Ordinal) : Prop :=\n  (\u2200 o, f o < f (succ o)) \u2227 \u2200 o, IsLimit o \u2192 \u2200 a, f o \u2264 a \u2194 \u2200 b < o, f b \u2264 a", "start": [393, 1], "end": [397, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.limit_le", "code": "theorem IsNormal.limit_le {f} (H : IsNormal f) :\n    \u2200 {o}, IsLimit o \u2192 \u2200 {a}, f o \u2264 a \u2194 \u2200 b < o, f b \u2264 a", "start": [400, 1], "end": [402, 7], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.limit_lt", "code": "theorem IsNormal.limit_lt {f} (H : IsNormal f) {o} (h : IsLimit o) {a} :\n    a < f o \u2194 \u2203 b < o, a < f b", "start": [405, 1], "end": [407, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.strictMono", "code": "theorem IsNormal.strictMono {f} (H : IsNormal f) : StrictMono f", "start": [410, 1], "end": [414, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.monotone", "code": "theorem IsNormal.monotone {f} (H : IsNormal f) : Monotone f", "start": [417, 1], "end": [418, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isNormal_iff_strictMono_limit", "code": "theorem isNormal_iff_strictMono_limit (f : Ordinal \u2192 Ordinal) :\n    IsNormal f \u2194 StrictMono f \u2227 \u2200 o, IsLimit o \u2192 \u2200 a, (\u2200 b < o, f b \u2264 a) \u2192 f o \u2264 a", "start": [421, 1], "end": [425, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.lt_iff", "code": "theorem IsNormal.lt_iff {f} (H : IsNormal f) {a b} : f a < f b \u2194 a < b", "start": [428, 1], "end": [429, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.le_iff", "code": "theorem IsNormal.le_iff {f} (H : IsNormal f) {a b} : f a \u2264 f b \u2194 a \u2264 b", "start": [432, 1], "end": [433, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.inj", "code": "theorem IsNormal.inj {f} (H : IsNormal f) {a b} : f a = f b \u2194 a = b", "start": [436, 1], "end": [437, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.self_le", "code": "theorem IsNormal.self_le {f} (H : IsNormal f) (a) : a \u2264 f a", "start": [440, 1], "end": [441, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.le_set", "code": "theorem IsNormal.le_set {f o} (H : IsNormal f) (p : Set Ordinal) (p0 : p.Nonempty) (b)\n    (H\u2082 : \u2200 o, b \u2264 o \u2194 \u2200 a \u2208 p, a \u2264 o) : f b \u2264 o \u2194 \u2200 a \u2208 p, f a \u2264 o", "start": [444, 1], "end": [460, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.le_set'", "code": "theorem IsNormal.le_set' {f o} (H : IsNormal f) (p : Set \u03b1) (p0 : p.Nonempty) (g : \u03b1 \u2192 Ordinal) (b)\n    (H\u2082 : \u2200 o, b \u2264 o \u2194 \u2200 a \u2208 p, g a \u2264 o) : f b \u2264 o \u2194 \u2200 a \u2208 p, f (g a) \u2264 o", "start": [463, 1], "end": [465, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.refl", "code": "theorem IsNormal.refl : IsNormal id", "start": [468, 1], "end": [469, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.trans", "code": "theorem IsNormal.trans {f g} (H\u2081 : IsNormal f) (H\u2082 : IsNormal g) : IsNormal (f \u2218 g)", "start": [472, 1], "end": [474, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.isLimit", "code": "theorem IsNormal.isLimit {f} (H : IsNormal f) {o} (l : IsLimit o) : IsLimit (f o)", "start": [477, 1], "end": [480, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.le_iff_eq", "code": "theorem IsNormal.le_iff_eq {f} (H : IsNormal f) {a} : f a \u2264 a \u2194 f a = a", "start": [483, 1], "end": [484, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_le_of_limit", "code": "theorem add_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a + b \u2264 c \u2194 \u2200 b' < b, a + b' \u2264 c", "start": [487, 1], "end": [512, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_isNormal", "code": "theorem add_isNormal (a : Ordinal) : IsNormal ((\u00b7 + \u00b7) a)", "start": [515, 1], "end": [516, 85], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_isLimit", "code": "theorem add_isLimit (a) {b} : IsLimit b \u2192 IsLimit (a + b)", "start": [519, 1], "end": [520, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsLimit.add", "code": "alias IsLimit.add := add_isLimit", "start": [523, 1], "end": [523, 33], "kind": "stdtacticaliasalias"}, {"full_name": "Ordinal.sub_nonempty", "code": "theorem sub_nonempty {a b : Ordinal} : { o | a \u2264 b + o }.Nonempty", "start": [529, 1], "end": [531, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub", "code": "instance sub : Sub Ordinal :=\n  \u27e8fun a b => sInf { o | a \u2264 b + o }\u27e9", "start": [534, 1], "end": [536, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_add_sub", "code": "theorem le_add_sub (a b : Ordinal) : a \u2264 b + (a - b)", "start": [538, 1], "end": [539, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_le", "code": "theorem sub_le {a b c : Ordinal} : a - b \u2264 c \u2194 a \u2264 b + c", "start": [542, 1], "end": [543, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_sub", "code": "theorem lt_sub {a b c : Ordinal} : a < b - c \u2194 c + a < b", "start": [546, 1], "end": [547, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_sub_cancel", "code": "theorem add_sub_cancel (a b : Ordinal) : a + b - a = b", "start": [550, 1], "end": [551, 81], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_eq_of_add_eq", "code": "theorem sub_eq_of_add_eq {a b c : Ordinal} (h : a + b = c) : c - a = b", "start": [554, 1], "end": [555, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_le_self", "code": "theorem sub_le_self (a b : Ordinal) : a - b \u2264 a", "start": [558, 1], "end": [559, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_sub_cancel_of_le", "code": "protected theorem add_sub_cancel_of_le {a b : Ordinal} (h : b \u2264 a) : b + (a - b) = a", "start": [562, 1], "end": [569, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_sub_of_le", "code": "theorem le_sub_of_le {a b c : Ordinal} (h : b \u2264 a) : c \u2264 a - b \u2194 b + c \u2264 a", "start": [572, 1], "end": [573, 63], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_lt_of_le", "code": "theorem sub_lt_of_le {a b c : Ordinal} (h : b \u2264 a) : a - b < c \u2194 a < b + c", "start": [576, 1], "end": [577, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.existsAddOfLE", "code": "instance existsAddOfLE : ExistsAddOfLE Ordinal :=\n  \u27e8fun h => \u27e8_, (Ordinal.add_sub_cancel_of_le h).symm\u27e9\u27e9", "start": [580, 1], "end": [581, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_zero", "code": "@[simp]\ntheorem sub_zero (a : Ordinal) : a - 0 = a", "start": [583, 1], "end": [584, 96], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_sub", "code": "@[simp]\ntheorem zero_sub (a : Ordinal) : 0 - a = 0", "start": [587, 1], "end": [588, 91], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_self", "code": "@[simp]\ntheorem sub_self (a : Ordinal) : a - a = 0", "start": [591, 1], "end": [592, 96], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_eq_zero_iff_le", "code": "protected theorem sub_eq_zero_iff_le {a b : Ordinal} : a - b = 0 \u2194 a \u2264 b", "start": [595, 1], "end": [597, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_sub", "code": "theorem sub_sub (a b c : Ordinal) : a - b - c = a - (b + c)", "start": [600, 1], "end": [601, 73], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_sub_add_cancel", "code": "@[simp]\ntheorem add_sub_add_cancel (a b c : Ordinal) : a + b - (a + c) = b - c", "start": [604, 1], "end": [606, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sub_isLimit", "code": "theorem sub_isLimit {a b} (l : IsLimit a) (h : b < a) : IsLimit (a - b)", "start": [609, 1], "end": [611, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_add_omega", "code": "theorem one_add_omega : 1 + \u03c9 = \u03c9", "start": [615, 1], "end": [624, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_add_of_omega_le", "code": "@[simp]\ntheorem one_add_of_omega_le {o} (h : \u03c9 \u2264 o) : 1 + o = o", "start": [627, 1], "end": [629, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.monoid", "code": "instance monoid : Monoid Ordinal.{u}\n    where\n  mul a b :=\n    Quotient.liftOn\u2082 a b\n      (fun \u27e8\u03b1, r, wo\u27e9 \u27e8\u03b2, s, wo'\u27e9 => \u27e6\u27e8\u03b2 \u00d7 \u03b1, Prod.Lex s r, inferInstance\u27e9\u27e7 :\n        WellOrder \u2192 WellOrder \u2192 Ordinal)\n      fun \u27e8\u03b1\u2081, r\u2081, o\u2081\u27e9 \u27e8\u03b1\u2082, r\u2082, o\u2082\u27e9 \u27e8\u03b2\u2081, s\u2081, p\u2081\u27e9 \u27e8\u03b2\u2082, s\u2082, p\u2082\u27e9 \u27e8f\u27e9 \u27e8g\u27e9 =>\n      Quot.sound \u27e8RelIso.prodLexCongr g f\u27e9\n  one := 1\n  mul_assoc a b c :=\n    Quotient.inductionOn\u2083 a b c fun \u27e8\u03b1, r, _\u27e9 \u27e8\u03b2, s, _\u27e9 \u27e8\u03b3, t, _\u27e9 =>\n      Eq.symm <|\n        Quotient.sound\n          \u27e8\u27e8prodAssoc _ _ _, @fun a b => by\n              rcases a with \u27e8\u27e8a\u2081, a\u2082\u27e9, a\u2083\u27e9\n              rcases b with \u27e8\u27e8b\u2081, b\u2082\u27e9, b\u2083\u27e9\n              simp [Prod.lex_def, and_or_left, or_assoc, and_assoc]\u27e9\u27e9\n  mul_one a :=\n    inductionOn a fun \u03b1 r _ =>\n      Quotient.sound\n        \u27e8\u27e8punitProd _, @fun a b => by\n            rcases a with \u27e8\u27e8\u27e8\u27e9\u27e9, a\u27e9; rcases b with \u27e8\u27e8\u27e8\u27e9\u27e9, b\u27e9\n            simp only [Prod.lex_def, EmptyRelation, false_or_iff]\n            simp only [eq_self_iff_true, true_and_iff]\n            rfl\u27e9\u27e9\n  one_mul a :=\n    inductionOn a fun \u03b1 r _ =>\n      Quotient.sound\n        \u27e8\u27e8prodPUnit _, @fun a b => by\n            rcases a with \u27e8a, \u27e8\u27e8\u27e9\u27e9\u27e9; rcases b with \u27e8b, \u27e8\u27e8\u27e9\u27e9\u27e9\n            simp only [Prod.lex_def, EmptyRelation, and_false_iff, or_false_iff]\n            rfl\u27e9\u27e9", "start": [635, 1], "end": [668, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.type_prod_lex", "code": "@[simp]\ntheorem type_prod_lex {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (s : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsWellOrder \u03b1 r]\n    [IsWellOrder \u03b2 s] : type (Prod.Lex s r) = type r * type s", "start": [670, 1], "end": [673, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_eq_zero'", "code": "private theorem mul_eq_zero' {a b : Ordinal} : a * b = 0 \u2194 a = 0 \u2228 b = 0", "start": [676, 1], "end": [681, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.monoidWithZero", "code": "instance monoidWithZero : MonoidWithZero Ordinal :=\n  { Ordinal.monoid with\n    zero := 0\n    mul_zero := fun _a => mul_eq_zero'.2 <| Or.inr rfl\n    zero_mul := fun _a => mul_eq_zero'.2 <| Or.inl rfl }", "start": [683, 1], "end": [687, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.noZeroDivisors", "code": "instance noZeroDivisors : NoZeroDivisors Ordinal :=\n  \u27e8fun {_ _} => mul_eq_zero'.1\u27e9", "start": [689, 1], "end": [690, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_mul", "code": "@[simp]\ntheorem lift_mul (a b : Ordinal.{v}) : lift.{u} (a * b) = lift.{u} a * lift.{u} b", "start": [692, 1], "end": [698, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_mul", "code": "@[simp]\ntheorem card_mul (a b) : card (a * b) = card a * card b", "start": [701, 1], "end": [703, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.leftDistribClass", "code": "instance leftDistribClass : LeftDistribClass Ordinal.{u} :=\n  \u27e8fun a b c =>\n    Quotient.inductionOn\u2083 a b c fun \u27e8\u03b1, r, _\u27e9 \u27e8\u03b2, s, _\u27e9 \u27e8\u03b3, t, _\u27e9 =>\n      Quotient.sound\n        \u27e8\u27e8sumProdDistrib _ _ _, by\n          rintro \u27e8a\u2081 | a\u2081, a\u2082\u27e9 \u27e8b\u2081 | b\u2081, b\u2082\u27e9 <;>\n            simp only [Prod.lex_def, Sum.lex_inl_inl, Sum.Lex.sep, Sum.lex_inr_inl,\n              Sum.lex_inr_inr, sumProdDistrib_apply_left, sumProdDistrib_apply_right] <;>\n            simp only [Sum.inl.inj_iff, Sum.inr.inj_iff,\n              true_or_iff, false_and_iff, false_or_iff]\u27e9\u27e9\u27e9", "start": [706, 1], "end": [716, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_succ", "code": "theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a", "start": [718, 1], "end": [719, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_covariantClass_le", "code": "instance mul_covariantClass_le : CovariantClass Ordinal.{u} Ordinal.{u} (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun c a b =>\n    Quotient.inductionOn\u2083 a b c fun \u27e8\u03b1, r, _\u27e9 \u27e8\u03b2, s, _\u27e9 \u27e8\u03b3, t, _\u27e9 \u27e8f\u27e9 => by\n      refine'\n        (RelEmbedding.ofMonotone (fun a : \u03b1 \u00d7 \u03b3 => (f a.1, a.2)) fun a b h => _).ordinal_type_le\n      cases' h with a\u2081 b\u2081 a\u2082 b\u2082 h' a b\u2081 b\u2082 h'\n      \u00b7 exact Prod.Lex.left _ _ (f.toRelEmbedding.map_rel_iff.2 h')\n      \u00b7 exact Prod.Lex.right _ h'\u27e9", "start": [722, 1], "end": [729, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_swap_covariantClass_le", "code": "instance mul_swap_covariantClass_le :\n    CovariantClass Ordinal.{u} Ordinal.{u} (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun c a b =>\n    Quotient.inductionOn\u2083 a b c fun \u27e8\u03b1, r, _\u27e9 \u27e8\u03b2, s, _\u27e9 \u27e8\u03b3, t, _\u27e9 \u27e8f\u27e9 => by\n      refine'\n        (RelEmbedding.ofMonotone (fun a : \u03b3 \u00d7 \u03b1 => (a.1, f a.2)) fun a b h => _).ordinal_type_le\n      cases' h with a\u2081 b\u2081 a\u2082 b\u2082 h' a b\u2081 b\u2082 h'\n      \u00b7 exact Prod.Lex.left _ _ h'\n      \u00b7 exact Prod.Lex.right _ (f.toRelEmbedding.map_rel_iff.2 h')\u27e9", "start": [732, 1], "end": [740, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_mul_left", "code": "theorem le_mul_left (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 a * b", "start": [743, 1], "end": [745, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_mul_right", "code": "theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 b * a", "start": [748, 1], "end": [750, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_le_of_limit_aux", "code": "private theorem mul_le_of_limit_aux {\u03b1 \u03b2 r s} [IsWellOrder \u03b1 r] [IsWellOrder \u03b2 s] {c}\n    (h : IsLimit (type s)) (H : \u2200 b' < type s, type r * b' \u2264 c) (l : c < type r * type s) :\n    False", "start": [753, 1], "end": [790, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_le_of_limit", "code": "theorem mul_le_of_limit {a b c : Ordinal} (h : IsLimit b) : a * b \u2264 c \u2194 \u2200 b' < b, a * b' \u2264 c", "start": [792, 1], "end": [800, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_isNormal", "code": "theorem mul_isNormal {a : Ordinal} (h : 0 < a) : IsNormal ((\u00b7 * \u00b7) a)", "start": [803, 1], "end": [809, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_mul_of_limit", "code": "theorem lt_mul_of_limit {a b c : Ordinal} (h : IsLimit c) : a < b * c \u2194 \u2203 c' < c, a < b * c'", "start": [812, 1], "end": [814, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_lt_mul_iff_left", "code": "theorem mul_lt_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b < a * c \u2194 b < c", "start": [817, 1], "end": [818, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_le_mul_iff_left", "code": "theorem mul_le_mul_iff_left {a b c : Ordinal} (a0 : 0 < a) : a * b \u2264 a * c \u2194 b \u2264 c", "start": [821, 1], "end": [822, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_lt_mul_of_pos_left", "code": "theorem mul_lt_mul_of_pos_left {a b c : Ordinal} (h : a < b) (c0 : 0 < c) : c * a < c * b", "start": [825, 1], "end": [826, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_pos", "code": "theorem mul_pos {a b : Ordinal} (h\u2081 : 0 < a) (h\u2082 : 0 < b) : 0 < a * b", "start": [829, 1], "end": [830, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_ne_zero", "code": "theorem mul_ne_zero {a b : Ordinal} : a \u2260 0 \u2192 b \u2260 0 \u2192 a * b \u2260 0", "start": [833, 1], "end": [834, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_of_mul_le_mul_left", "code": "theorem le_of_mul_le_mul_left {a b c : Ordinal} (h : c * a \u2264 c * b) (h0 : 0 < c) : a \u2264 b", "start": [837, 1], "end": [838, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_right_inj", "code": "theorem mul_right_inj {a b c : Ordinal} (a0 : 0 < a) : a * b = a * c \u2194 b = c", "start": [841, 1], "end": [842, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_isLimit", "code": "theorem mul_isLimit {a b : Ordinal} (a0 : 0 < a) : IsLimit b \u2192 IsLimit (a * b)", "start": [845, 1], "end": [846, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_isLimit_left", "code": "theorem mul_isLimit_left {a b : Ordinal} (l : IsLimit a) (b0 : 0 < b) : IsLimit (a * b)", "start": [849, 1], "end": [854, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.smul_eq_mul", "code": "theorem smul_eq_mul : \u2200 (n : \u2115) (a : Ordinal), n \u2022 a = a * n", "start": [857, 1], "end": [859, 97], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_nonempty", "code": "theorem div_nonempty {a b : Ordinal} (h : b \u2260 0) : { o | a < b * succ o }.Nonempty", "start": [865, 1], "end": [869, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div", "code": "instance div : Div Ordinal :=\n  \u27e8fun a b => if _h : b = 0 then 0 else sInf { o | a < b * succ o }\u27e9", "start": [872, 1], "end": [874, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_zero", "code": "@[simp]\ntheorem div_zero (a : Ordinal) : a / 0 = 0", "start": [876, 1], "end": [878, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_def", "code": "theorem div_def (a) {b : Ordinal} (h : b \u2260 0) : a / b = sInf { o | a < b * succ o }", "start": [881, 1], "end": [882, 12], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_mul_succ_div", "code": "theorem lt_mul_succ_div (a) {b : Ordinal} (h : b \u2260 0) : a < b * succ (a / b)", "start": [885, 1], "end": [886, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_mul_div_add", "code": "theorem lt_mul_div_add (a) {b : Ordinal} (h : b \u2260 0) : a < b * (a / b) + b", "start": [889, 1], "end": [890, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_le", "code": "theorem div_le {a b c : Ordinal} (b0 : b \u2260 0) : a / b \u2264 c \u2194 a < b * succ c", "start": [893, 1], "end": [895, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_div", "code": "theorem lt_div {a b c : Ordinal} (h : c \u2260 0) : a < b / c \u2194 c * succ a \u2264 b", "start": [898, 1], "end": [899, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_pos", "code": "theorem div_pos {b c : Ordinal} (h : c \u2260 0) : 0 < b / c \u2194 c \u2264 b", "start": [902, 1], "end": [902, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_div", "code": "theorem le_div {a b c : Ordinal} (c0 : c \u2260 0) : a \u2264 b / c \u2194 c * a \u2264 b", "start": [905, 1], "end": [912, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_lt", "code": "theorem div_lt {a b c : Ordinal} (b0 : b \u2260 0) : a / b < c \u2194 a < b * c", "start": [915, 1], "end": [916, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_le_of_le_mul", "code": "theorem div_le_of_le_mul {a b c : Ordinal} (h : a \u2264 b * c) : a / b \u2264 c", "start": [919, 1], "end": [922, 101], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_lt_of_lt_div", "code": "theorem mul_lt_of_lt_div {a b c : Ordinal} : a < b / c \u2192 c * a < b", "start": [925, 1], "end": [926, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_div", "code": "@[simp]\ntheorem zero_div (a : Ordinal) : 0 / a = 0", "start": [929, 1], "end": [931, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_div_le", "code": "theorem mul_div_le (a b : Ordinal) : b * (a / b) \u2264 a", "start": [934, 1], "end": [935, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_add_div", "code": "theorem mul_add_div (a) {b : Ordinal} (b0 : b \u2260 0) (c) : (b * a + c) / b = a + c / b", "start": [938, 1], "end": [944, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_eq_zero_of_lt", "code": "theorem div_eq_zero_of_lt {a b : Ordinal} (h : a < b) : a / b = 0", "start": [947, 1], "end": [949, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_div_cancel", "code": "@[simp]\ntheorem mul_div_cancel (a) {b : Ordinal} (b0 : b \u2260 0) : b * a / b = a", "start": [952, 1], "end": [954, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_one", "code": "@[simp]\ntheorem div_one (a : Ordinal) : a / 1 = a", "start": [957, 1], "end": [959, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_self", "code": "@[simp]\ntheorem div_self {a : Ordinal} (h : a \u2260 0) : a / a = 1", "start": [962, 1], "end": [964, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_sub", "code": "theorem mul_sub (a b c : Ordinal) : a * (b - c) = a * b - a * c", "start": [967, 1], "end": [970, 100], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isLimit_add_iff", "code": "theorem isLimit_add_iff {a b} : IsLimit (a + b) \u2194 IsLimit b \u2228 b = 0 \u2227 IsLimit a", "start": [973, 1], "end": [985, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.dvd_add_iff", "code": "theorem dvd_add_iff : \u2200 {a b c : Ordinal}, a \u2223 b \u2192 (a \u2223 b + c \u2194 a \u2223 c)", "start": [988, 1], "end": [992, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_mul_cancel", "code": "theorem div_mul_cancel : \u2200 {a b : Ordinal}, a \u2260 0 \u2192 a \u2223 b \u2192 a * (b / a) = b", "start": [995, 1], "end": [996, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_of_dvd", "code": "theorem le_of_dvd : \u2200 {a b : Ordinal}, b \u2260 0 \u2192 a \u2223 b \u2192 a \u2264 b", "start": [999, 1], "end": [1006, 87], "kind": "commanddeclaration"}, {"full_name": "Ordinal.dvd_antisymm", "code": "theorem dvd_antisymm {a b : Ordinal} (h\u2081 : a \u2223 b) (h\u2082 : b \u2223 a) : a = b", "start": [1009, 1], "end": [1013, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isAntisymm", "code": "instance isAntisymm : IsAntisymm Ordinal (\u00b7 \u2223 \u00b7) :=\n  \u27e8@dvd_antisymm\u27e9", "start": [1016, 1], "end": [1017, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod", "code": "instance mod : Mod Ordinal :=\n  \u27e8fun a b => a - b * (a / b)\u27e9", "start": [1019, 1], "end": [1022, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_def", "code": "theorem mod_def (a b : Ordinal) : a % b = a - b * (a / b)", "start": [1024, 1], "end": [1025, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_le", "code": "theorem mod_le (a b : Ordinal) : a % b \u2264 a", "start": [1028, 1], "end": [1029, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_zero", "code": "@[simp]\ntheorem mod_zero (a : Ordinal) : a % 0 = a", "start": [1032, 1], "end": [1033, 99], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_eq_of_lt", "code": "theorem mod_eq_of_lt {a b : Ordinal} (h : a < b) : a % b = a", "start": [1036, 1], "end": [1037, 63], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_mod", "code": "@[simp]\ntheorem zero_mod (b : Ordinal) : 0 % b = 0", "start": [1040, 1], "end": [1041, 99], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_add_mod", "code": "theorem div_add_mod (a b : Ordinal) : b * (a / b) + a % b = a", "start": [1044, 1], "end": [1045, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_lt", "code": "theorem mod_lt (a) {b : Ordinal} (h : b \u2260 0) : a % b < b", "start": [1048, 1], "end": [1049, 89], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_self", "code": "@[simp]\ntheorem mod_self (a : Ordinal) : a % a = 0", "start": [1052, 1], "end": [1055, 62], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_one", "code": "@[simp]\ntheorem mod_one (a : Ordinal) : a % 1 = 0", "start": [1058, 1], "end": [1059, 96], "kind": "commanddeclaration"}, {"full_name": "Ordinal.dvd_of_mod_eq_zero", "code": "theorem dvd_of_mod_eq_zero {a b : Ordinal} (H : a % b = 0) : b \u2223 a", "start": [1062, 1], "end": [1063, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_eq_zero_of_dvd", "code": "theorem mod_eq_zero_of_dvd {a b : Ordinal} (H : b \u2223 a) : a % b = 0", "start": [1066, 1], "end": [1070, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.dvd_iff_mod_eq_zero", "code": "theorem dvd_iff_mod_eq_zero {a b : Ordinal} : b \u2223 a \u2194 a % b = 0", "start": [1073, 1], "end": [1074, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_add_mod_self", "code": "@[simp]\ntheorem mul_add_mod_self (x y z : Ordinal) : (x * y + z) % x = z % x", "start": [1077, 1], "end": [1081, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_mod", "code": "@[simp]\ntheorem mul_mod (x y : Ordinal) : x * y % x = 0", "start": [1084, 1], "end": [1086, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_mod_of_dvd", "code": "theorem mod_mod_of_dvd (a : Ordinal) {b c : Ordinal} (h : c \u2223 b) : a % b % c = a % c", "start": [1089, 1], "end": [1092, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_mod", "code": "@[simp]\ntheorem mod_mod (a b : Ordinal) : a % b % b = a % b", "start": [1095, 1], "end": [1097, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bfamilyOfFamily'", "code": "def bfamilyOfFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (f : \u03b9 \u2192 \u03b1) :\n    \u2200 a < type r, \u03b1 := fun a ha => f (enum r a ha)", "start": [1110, 1], "end": [1113, 51], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bfamilyOfFamily", "code": "def bfamilyOfFamily {\u03b9 : Type u} : (\u03b9 \u2192 \u03b1) \u2192 \u2200 a < type (@WellOrderingRel \u03b9), \u03b1 :=\n  bfamilyOfFamily' WellOrderingRel", "start": [1116, 1], "end": [1119, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.familyOfBFamily'", "code": "def familyOfBFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o} (ho : type r = o)\n    (f : \u2200 a < o, \u03b1) : \u03b9 \u2192 \u03b1 := fun i =>\n  f (typein r i)\n    (by\n      rw [\u2190 ho]\n      exact typein_lt_type r i)", "start": [1122, 1], "end": [1129, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.familyOfBFamily", "code": "def familyOfBFamily (o : Ordinal) (f : \u2200 a < o, \u03b1) : o.out.\u03b1 \u2192 \u03b1 :=\n  familyOfBFamily' (\u00b7 < \u00b7) (type_lt o) f", "start": [1132, 1], "end": [1135, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bfamilyOfFamily'_typein", "code": "@[simp]\ntheorem bfamilyOfFamily'_typein {\u03b9} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (f : \u03b9 \u2192 \u03b1) (i) :\n    bfamilyOfFamily' r f (typein r i) (typein_lt_type r i) = f i", "start": [1138, 1], "end": [1141, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bfamilyOfFamily_typein", "code": "@[simp]\ntheorem bfamilyOfFamily_typein {\u03b9} (f : \u03b9 \u2192 \u03b1) (i) :\n    bfamilyOfFamily f (typein _ i) (typein_lt_type _ i) = f i", "start": [1144, 1], "end": [1147, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.familyOfBFamily'_enum", "code": "@[simp, nolint simpNF] theorem familyOfBFamily'_enum {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o}\n    (ho : type r = o) (f : \u2200 a < o, \u03b1) (i hi) :\n    familyOfBFamily' r ho f (enum r i (by rwa [ho])) = f i hi", "start": [1150, 1], "end": [1154, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.familyOfBFamily_enum", "code": "@[simp, nolint simpNF] theorem familyOfBFamily_enum (o : Ordinal) (f : \u2200 a < o, \u03b1) (i hi) :\n    familyOfBFamily o f\n        (enum (\u00b7 < \u00b7) i\n          (by\n            convert hi\n            exact type_lt _)) =\n      f i hi", "start": [1157, 1], "end": [1165, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.brange", "code": "def brange (o : Ordinal) (f : \u2200 a < o, \u03b1) : Set \u03b1 :=\n  { a | \u2203 i hi, f i hi = a }", "start": [1168, 1], "end": [1170, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_brange", "code": "theorem mem_brange {o : Ordinal} {f : \u2200 a < o, \u03b1} {a} : a \u2208 brange o f \u2194 \u2203 i hi, f i hi = a", "start": [1173, 1], "end": [1174, 10], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mem_brange_self", "code": "theorem mem_brange_self {o} (f : \u2200 a < o, \u03b1) (i hi) : f i hi \u2208 brange o f", "start": [1177, 1], "end": [1178, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.range_familyOfBFamily'", "code": "@[simp]\ntheorem range_familyOfBFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o}\n    (ho : type r = o) (f : \u2200 a < o, \u03b1) : range (familyOfBFamily' r ho f) = brange o f", "start": [1181, 1], "end": [1188, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.range_familyOfBFamily", "code": "@[simp]\ntheorem range_familyOfBFamily {o} (f : \u2200 a < o, \u03b1) : range (familyOfBFamily o f) = brange o f", "start": [1191, 1], "end": [1193, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.brange_bfamilyOfFamily'", "code": "@[simp]\ntheorem brange_bfamilyOfFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (f : \u03b9 \u2192 \u03b1) :\n    brange _ (bfamilyOfFamily' r f) = range f", "start": [1196, 1], "end": [1203, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.brange_bfamilyOfFamily", "code": "@[simp]\ntheorem brange_bfamilyOfFamily {\u03b9 : Type u} (f : \u03b9 \u2192 \u03b1) : brange _ (bfamilyOfFamily f) = range f", "start": [1206, 1], "end": [1208, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.brange_const", "code": "@[simp]\ntheorem brange_const {o : Ordinal} (ho : o \u2260 0) {c : \u03b1} : (brange o fun _ _ => c) = {c}", "start": [1211, 1], "end": [1214, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.comp_bfamilyOfFamily'", "code": "theorem comp_bfamilyOfFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (f : \u03b9 \u2192 \u03b1)\n    (g : \u03b1 \u2192 \u03b2) : (fun i hi => g (bfamilyOfFamily' r f i hi)) = bfamilyOfFamily' r (g \u2218 f)", "start": [1217, 1], "end": [1219, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.comp_bfamilyOfFamily", "code": "theorem comp_bfamilyOfFamily {\u03b9 : Type u} (f : \u03b9 \u2192 \u03b1) (g : \u03b1 \u2192 \u03b2) :\n    (fun i hi => g (bfamilyOfFamily f i hi)) = bfamilyOfFamily (g \u2218 f)", "start": [1222, 1], "end": [1224, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.comp_familyOfBFamily'", "code": "theorem comp_familyOfBFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o}\n    (ho : type r = o) (f : \u2200 a < o, \u03b1) (g : \u03b1 \u2192 \u03b2) :\n    g \u2218 familyOfBFamily' r ho f = familyOfBFamily' r ho fun i hi => g (f i hi)", "start": [1227, 1], "end": [1230, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.comp_familyOfBFamily", "code": "theorem comp_familyOfBFamily {o} (f : \u2200 a < o, \u03b1) (g : \u03b1 \u2192 \u03b2) :\n    g \u2218 familyOfBFamily o f = familyOfBFamily o fun i hi => g (f i hi)", "start": [1233, 1], "end": [1235, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup", "code": "def sup {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : Ordinal.{max u v} :=\n  iSup f", "start": [1242, 1], "end": [1244, 9], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sSup_eq_sup", "code": "@[simp]\ntheorem sSup_eq_sup {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : sSup (Set.range f) = sup.{_, v} f", "start": [1247, 1], "end": [1249, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bddAbove_range", "code": "theorem bddAbove_range {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : BddAbove (Set.range f)", "start": [1252, 1], "end": [1258, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_sup", "code": "theorem le_sup {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : \u2200 i, f i \u2264 sup.{_, v} f", "start": [1261, 1], "end": [1262, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_le_iff", "code": "theorem sup_le_iff {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a} : sup.{_, v} f \u2264 a \u2194 \u2200 i, f i \u2264 a", "start": [1265, 1], "end": [1266, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_le", "code": "theorem sup_le {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a} : (\u2200 i, f i \u2264 a) \u2192 sup.{_, v} f \u2264 a", "start": [1269, 1], "end": [1270, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_sup", "code": "theorem lt_sup {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a} : a < sup.{_, v} f \u2194 \u2203 i, a < f i", "start": [1273, 1], "end": [1274, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ne_sup_iff_lt_sup", "code": "theorem ne_sup_iff_lt_sup {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} :\n    (\u2200 i, f i \u2260 sup.{_, v} f) \u2194 \u2200 i, f i < sup.{_, v} f", "start": [1277, 1], "end": [1279, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_not_succ_of_ne_sup", "code": "theorem sup_not_succ_of_ne_sup {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}}\n    (hf : \u2200 i, f i \u2260 sup.{_, v} f) {a} (hao : a < sup.{_, v} f) : succ a < sup.{_, v} f", "start": [1282, 1], "end": [1286, 100], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_zero_iff", "code": "@[simp]\ntheorem sup_eq_zero_iff {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} :\n    sup.{_, v} f = 0 \u2194 \u2200 i, f i = 0", "start": [1289, 1], "end": [1296, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.sup", "code": "theorem IsNormal.sup {f : Ordinal.{max u v} \u2192 Ordinal.{max u w}} (H : IsNormal f) {\u03b9 : Type u}\n    (g : \u03b9 \u2192 Ordinal.{max u v}) [Nonempty \u03b9] : f (sup.{_, v} g) = sup.{_, w} (f \u2218 g)", "start": [1299, 1], "end": [1303, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_empty", "code": "@[simp]\ntheorem sup_empty {\u03b9} [IsEmpty \u03b9] (f : \u03b9 \u2192 Ordinal) : sup f = 0", "start": [1306, 1], "end": [1308, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_const", "code": "@[simp]\ntheorem sup_const {\u03b9} [_h\u03b9 : Nonempty \u03b9] (o : Ordinal) : (sup fun _ : \u03b9 => o) = o", "start": [1311, 1], "end": [1313, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_unique", "code": "@[simp]\ntheorem sup_unique {\u03b9} [Unique \u03b9] (f : \u03b9 \u2192 Ordinal) : sup f = f default", "start": [1316, 1], "end": [1318, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_le_of_range_subset", "code": "theorem sup_le_of_range_subset {\u03b9 \u03b9'} {f : \u03b9 \u2192 Ordinal} {g : \u03b9' \u2192 Ordinal}\n    (h : Set.range f \u2286 Set.range g) : sup.{u, max v w} f \u2264 sup.{v, max u w} g", "start": [1321, 1], "end": [1325, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_of_range_eq", "code": "theorem sup_eq_of_range_eq {\u03b9 \u03b9'} {f : \u03b9 \u2192 Ordinal} {g : \u03b9' \u2192 Ordinal}\n    (h : Set.range f = Set.range g) : sup.{u, max v w} f = sup.{v, max u w} g", "start": [1328, 1], "end": [1330, 91], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_sum", "code": "@[simp]\ntheorem sup_sum {\u03b1 : Type u} {\u03b2 : Type v} (f : Sum \u03b1 \u03b2 \u2192 Ordinal) :\n    sup.{max u v, w} f =\n      max (sup.{u, max v w} fun a => f (Sum.inl a)) (sup.{v, max u w} fun b => f (Sum.inr b))", "start": [1333, 1], "end": [1344, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.unbounded_range_of_sup_ge", "code": "theorem unbounded_range_of_sup_ge {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (f : \u03b2 \u2192 \u03b1)\n    (h : type r \u2264 sup.{u, u} (typein r \u2218 f)) : Unbounded r (range f)", "start": [1347, 1], "end": [1353, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_sup_shrink_equiv", "code": "theorem le_sup_shrink_equiv {s : Set Ordinal.{u}} (hs : Small.{u} s) (a) (ha : a \u2208 s) :\n    a \u2264 sup.{u, u} fun x => ((@equivShrink s hs).symm x).val", "start": [1356, 1], "end": [1359, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.small_Iio", "code": "instance small_Iio (o : Ordinal.{u}) : Small.{u} (Set.Iio o) :=\n  let f : o.out.\u03b1 \u2192 Set.Iio o :=\n    fun x => \u27e8typein ((\u00b7 < \u00b7) : o.out.\u03b1 \u2192 o.out.\u03b1 \u2192 Prop) x, typein_lt_self x\u27e9\n  let hf : Surjective f := fun b =>\n    \u27e8enum (\u00b7 < \u00b7) b.val\n        (by\n          rw [type_lt]\n          exact b.prop),\n      Subtype.ext (typein_enum _ _)\u27e9\n  small_of_surjective hf", "start": [1362, 1], "end": [1371, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.small_Iic", "code": "instance small_Iic (o : Ordinal.{u}) : Small.{u} (Set.Iic o) := by\n  rw [\u2190 Iio_succ]\n  infer_instance", "start": [1374, 1], "end": [1376, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bddAbove_iff_small", "code": "theorem bddAbove_iff_small {s : Set Ordinal.{u}} : BddAbove s \u2194 Small.{u} s", "start": [1379, 1], "end": [1381, 82], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bddAbove_of_small", "code": "theorem bddAbove_of_small (s : Set Ordinal.{u}) [h : Small.{u} s] : BddAbove s", "start": [1384, 1], "end": [1385, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_sSup", "code": "theorem sup_eq_sSup {s : Set Ordinal.{u}} (hs : Small.{u} s) :\n    (sup.{u, u} fun x => (@equivShrink s hs).symm x) = sSup s", "start": [1388, 1], "end": [1392, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sSup_ord", "code": "theorem sSup_ord {s : Set Cardinal.{u}} (hs : BddAbove s) : (sSup s).ord = sSup (ord '' s)", "start": [1395, 1], "end": [1400, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.iSup_ord", "code": "theorem iSup_ord {\u03b9} {f : \u03b9 \u2192 Cardinal} (hf : BddAbove (range f)) :\n    (iSup f).ord = \u2a06 i, (f i).ord", "start": [1403, 1], "end": [1409, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_le_sup", "code": "private theorem sup_le_sup {\u03b9 \u03b9' : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (r' : \u03b9' \u2192 \u03b9' \u2192 Prop)\n    [IsWellOrder \u03b9 r] [IsWellOrder \u03b9' r'] {o} (ho : type r = o) (ho' : type r' = o)\n    (f : \u2200 a < o, Ordinal.{max u v}) :\n    sup.{_, v} (familyOfBFamily' r ho f) \u2264 sup.{_, v} (familyOfBFamily' r' ho' f)", "start": [1412, 1], "end": [1424, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_sup", "code": "theorem sup_eq_sup {\u03b9 \u03b9' : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (r' : \u03b9' \u2192 \u03b9' \u2192 Prop) [IsWellOrder \u03b9 r]\n    [IsWellOrder \u03b9' r'] {o : Ordinal.{u}} (ho : type r = o) (ho' : type r' = o)\n    (f : \u2200 a < o, Ordinal.{max u v}) :\n    sup.{_, v} (familyOfBFamily' r ho f) = sup.{_, v} (familyOfBFamily' r' ho' f)", "start": [1426, 1], "end": [1430, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup", "code": "def bsup (o : Ordinal.{u}) (f : \u2200 a < o, Ordinal.{max u v}) : Ordinal.{max u v} :=\n  sup.{_, v} (familyOfBFamily o f)", "start": [1433, 1], "end": [1437, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_bsup", "code": "@[simp]\ntheorem sup_eq_bsup {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    sup.{_, v} (familyOfBFamily o f) = bsup.{_, v} o f", "start": [1440, 1], "end": [1443, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_bsup'", "code": "@[simp]\ntheorem sup_eq_bsup' {o : Ordinal.{u}} {\u03b9} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (ho : type r = o)\n    (f : \u2200 a < o, Ordinal.{max u v}) : sup.{_, v} (familyOfBFamily' r ho f) = bsup.{_, v} o f", "start": [1446, 1], "end": [1449, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sSup_eq_bsup", "code": "@[simp, nolint simpNF] theorem sSup_eq_bsup {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    sSup (brange o f) = bsup.{_, v} o f", "start": [1452, 1], "end": [1456, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_sup'", "code": "@[simp]\ntheorem bsup_eq_sup' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily' r f) = sup.{_, v} f", "start": [1459, 1], "end": [1462, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_bsup", "code": "theorem bsup_eq_bsup {\u03b9 : Type u} (r r' : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] [IsWellOrder \u03b9 r']\n    (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily' r f) = bsup.{_, v} _ (bfamilyOfFamily' r' f)", "start": [1465, 1], "end": [1468, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_sup", "code": "@[simp]\ntheorem bsup_eq_sup {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    bsup.{_, v} _ (bfamilyOfFamily f) = sup.{_, v} f", "start": [1471, 1], "end": [1474, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_congr", "code": "@[congr]\ntheorem bsup_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    bsup.{_, v} o\u2081 f = bsup.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm)", "start": [1477, 1], "end": [1482, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_le_iff", "code": "theorem bsup_le_iff {o f a} : bsup.{u, v} o f \u2264 a \u2194 \u2200 i h, f i h \u2264 a", "start": [1485, 1], "end": [1489, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_le", "code": "theorem bsup_le {o : Ordinal} {f : \u2200 b < o, Ordinal} {a} :\n    (\u2200 i h, f i h \u2264 a) \u2192 bsup.{u, v} o f \u2264 a", "start": [1492, 1], "end": [1494, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_bsup", "code": "theorem le_bsup {o} (f : \u2200 a < o, Ordinal) (i h) : f i h \u2264 bsup o f", "start": [1497, 1], "end": [1498, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_bsup", "code": "theorem lt_bsup {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) {a} :\n    a < bsup.{_, v} o f \u2194 \u2203 i hi, a < f i hi", "start": [1501, 1], "end": [1503, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.bsup", "code": "theorem IsNormal.bsup {f : Ordinal.{max u v} \u2192 Ordinal.{max u w}} (H : IsNormal f)\n    {o : Ordinal.{u}} :\n    \u2200 (g : \u2200 a < o, Ordinal), o \u2260 0 \u2192 f (bsup.{_, v} o g) = bsup.{_, w} o fun a h => f (g a h)", "start": [1506, 1], "end": [1511, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_bsup_of_ne_bsup", "code": "theorem lt_bsup_of_ne_bsup {o : Ordinal.{u}} {f : \u2200 a < o, Ordinal.{max u v}} :\n    (\u2200 i h, f i h \u2260 bsup.{_, v} o f) \u2194 \u2200 i h, f i h < bsup.{_, v} o f", "start": [1514, 1], "end": [1516, 91], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_not_succ_of_ne_bsup", "code": "theorem bsup_not_succ_of_ne_bsup {o : Ordinal.{u}} {f : \u2200 a < o, Ordinal.{max u v}}\n    (hf : \u2200 {i : Ordinal} (h : i < o), f i h \u2260 bsup.{_, v} o f) (a) :\n    a < bsup.{_, v} o f \u2192 succ a < bsup.{_, v} o f", "start": [1519, 1], "end": [1523, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_zero_iff", "code": "@[simp]\ntheorem bsup_eq_zero_iff {o} {f : \u2200 a < o, Ordinal} : bsup o f = 0 \u2194 \u2200 i hi, f i hi = 0", "start": [1526, 1], "end": [1532, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_bsup_of_limit", "code": "theorem lt_bsup_of_limit {o : Ordinal} {f : \u2200 a < o, Ordinal}\n    (hf : \u2200 {a a'} (ha : a < o) (ha' : a' < o), a < a' \u2192 f a ha < f a' ha')\n    (ho : \u2200 a < o, succ a < o) (i h) : f i h < bsup o f", "start": [1535, 1], "end": [1538, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_succ_of_mono", "code": "theorem bsup_succ_of_mono {o : Ordinal} {f : \u2200 a < succ o, Ordinal}\n    (hf : \u2200 {i j} (hi hj), i \u2264 j \u2192 f i hi \u2264 f j hj) : bsup _ f = f o (lt_succ o)", "start": [1541, 1], "end": [1543, 80], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_zero", "code": "@[simp]\ntheorem bsup_zero (f : \u2200 a < (0 : Ordinal), Ordinal) : bsup 0 f = 0", "start": [1546, 1], "end": [1548, 65], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_const", "code": "theorem bsup_const {o : Ordinal.{u}} (ho : o \u2260 0) (a : Ordinal.{max u v}) :\n    (bsup.{_, v} o fun _ _ => a) = a", "start": [1551, 1], "end": [1553, 87], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_one", "code": "@[simp]\ntheorem bsup_one (f : \u2200 a < (1 : Ordinal), Ordinal) : bsup 1 f = f 0 zero_lt_one", "start": [1556, 1], "end": [1558, 89], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_le_of_brange_subset", "code": "theorem bsup_le_of_brange_subset {o o'} {f : \u2200 a < o, Ordinal} {g : \u2200 a < o', Ordinal}\n    (h : brange o f \u2286 brange o' g) : bsup.{u, max v w} o f \u2264 bsup.{v, max u w} o' g", "start": [1561, 1], "end": [1566, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_of_brange_eq", "code": "theorem bsup_eq_of_brange_eq {o o'} {f : \u2200 a < o, Ordinal} {g : \u2200 a < o', Ordinal}\n    (h : brange o f = brange o' g) : bsup.{u, max v w} o f = bsup.{v, max u w} o' g", "start": [1569, 1], "end": [1571, 95], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub", "code": "def lsub {\u03b9} (f : \u03b9 \u2192 Ordinal) : Ordinal :=\n  sup (succ \u2218 f)", "start": [1574, 1], "end": [1576, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_lsub", "code": "@[simp]\ntheorem sup_eq_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    sup.{_, v} (succ \u2218 f) = lsub.{_, v} f", "start": [1579, 1], "end": [1582, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_le_iff", "code": "theorem lsub_le_iff {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a} :\n    lsub.{_, v} f \u2264 a \u2194 \u2200 i, f i < a", "start": [1585, 1], "end": [1589, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_le", "code": "theorem lsub_le {\u03b9} {f : \u03b9 \u2192 Ordinal} {a} : (\u2200 i, f i < a) \u2192 lsub f \u2264 a", "start": [1592, 1], "end": [1593, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_lsub", "code": "theorem lt_lsub {\u03b9} (f : \u03b9 \u2192 Ordinal) (i) : f i < lsub f", "start": [1596, 1], "end": [1597, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_lsub_iff", "code": "theorem lt_lsub_iff {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a} :\n    a < lsub.{_, v} f \u2194 \u2203 i, a \u2264 f i", "start": [1600, 1], "end": [1602, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_le_lsub", "code": "theorem sup_le_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : sup.{_, v} f \u2264 lsub.{_, v} f", "start": [1605, 1], "end": [1606, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_le_sup_succ", "code": "theorem lsub_le_sup_succ {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    lsub.{_, v} f \u2264 succ (sup.{_, v} f)", "start": [1609, 1], "end": [1611, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_lsub_or_sup_succ_eq_lsub", "code": "theorem sup_eq_lsub_or_sup_succ_eq_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f \u2228 succ (sup.{_, v} f) = lsub.{_, v} f", "start": [1614, 1], "end": [1618, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_succ_le_lsub", "code": "theorem sup_succ_le_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    succ (sup.{_, v} f) \u2264 lsub.{_, v} f \u2194 \u2203 i, f i = sup.{_, v} f", "start": [1621, 1], "end": [1628, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_succ_eq_lsub", "code": "theorem sup_succ_eq_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    succ (sup.{_, v} f) = lsub.{_, v} f \u2194 \u2203 i, f i = sup.{_, v} f", "start": [1631, 1], "end": [1633, 65], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_lsub_iff_succ", "code": "theorem sup_eq_lsub_iff_succ {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f \u2194 \u2200 a < lsub.{_, v} f, succ a < lsub.{_, v} f", "start": [1636, 1], "end": [1649, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_eq_lsub_iff_lt_sup", "code": "theorem sup_eq_lsub_iff_lt_sup {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    sup.{_, v} f = lsub.{_, v} f \u2194 \u2200 i, f i < sup.{_, v} f", "start": [1652, 1], "end": [1656, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_empty", "code": "@[simp]\ntheorem lsub_empty {\u03b9} [h : IsEmpty \u03b9] (f : \u03b9 \u2192 Ordinal) : lsub f = 0", "start": [1659, 1], "end": [1662, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_pos", "code": "theorem lsub_pos {\u03b9 : Type u} [h : Nonempty \u03b9] (f : \u03b9 \u2192 Ordinal.{max u v}) : 0 < lsub.{_, v} f", "start": [1665, 1], "end": [1666, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_eq_zero_iff", "code": "@[simp]\ntheorem lsub_eq_zero_iff {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    lsub.{_, v} f = 0 \u2194 IsEmpty \u03b9", "start": [1669, 1], "end": [1675, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_const", "code": "@[simp]\ntheorem lsub_const {\u03b9} [Nonempty \u03b9] (o : Ordinal) : (lsub fun _ : \u03b9 => o) = succ o", "start": [1678, 1], "end": [1680, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_unique", "code": "@[simp]\ntheorem lsub_unique {\u03b9} [Unique \u03b9] (f : \u03b9 \u2192 Ordinal) : lsub f = succ (f default)", "start": [1683, 1], "end": [1685, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_le_of_range_subset", "code": "theorem lsub_le_of_range_subset {\u03b9 \u03b9'} {f : \u03b9 \u2192 Ordinal} {g : \u03b9' \u2192 Ordinal}\n    (h : Set.range f \u2286 Set.range g) : lsub.{u, max v w} f \u2264 lsub.{v, max u w} g", "start": [1688, 1], "end": [1690, 97], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_eq_of_range_eq", "code": "theorem lsub_eq_of_range_eq {\u03b9 \u03b9'} {f : \u03b9 \u2192 Ordinal} {g : \u03b9' \u2192 Ordinal}\n    (h : Set.range f = Set.range g) : lsub.{u, max v w} f = lsub.{v, max u w} g", "start": [1693, 1], "end": [1695, 93], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_sum", "code": "@[simp]\ntheorem lsub_sum {\u03b1 : Type u} {\u03b2 : Type v} (f : Sum \u03b1 \u03b2 \u2192 Ordinal) :\n    lsub.{max u v, w} f =\n      max (lsub.{u, max v w} fun a => f (Sum.inl a)) (lsub.{v, max u w} fun b => f (Sum.inr b))", "start": [1698, 1], "end": [1702, 12], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_not_mem_range", "code": "theorem lsub_not_mem_range {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    lsub.{_, v} f \u2209 Set.range f", "start": [1705, 1], "end": [1707, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nonempty_compl_range", "code": "theorem nonempty_compl_range {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : (Set.range f)\u1d9c.Nonempty", "start": [1710, 1], "end": [1711, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_typein", "code": "@[simp]\ntheorem lsub_typein (o : Ordinal) : lsub.{u, u} (typein ((\u00b7 < \u00b7) : o.out.\u03b1 \u2192 o.out.\u03b1 \u2192 Prop)) = o", "start": [1714, 1], "end": [1721, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_typein_limit", "code": "theorem sup_typein_limit {o : Ordinal} (ho : \u2200 a, a < o \u2192 succ a < o) :\n    sup.{u, u} (typein ((\u00b7 < \u00b7) : o.out.\u03b1 \u2192 o.out.\u03b1 \u2192 Prop)) = o", "start": [1724, 1], "end": [1727, 91], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_typein_succ", "code": "@[simp]\ntheorem sup_typein_succ {o : Ordinal} :\n    sup.{u, u} (typein ((\u00b7 < \u00b7) : (succ o).out.\u03b1 \u2192 (succ o).out.\u03b1 \u2192 Prop)) = o", "start": [1730, 1], "end": [1741, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub", "code": "def blsub (o : Ordinal.{u}) (f : \u2200 a < o, Ordinal.{max u v}) : Ordinal.{max u v} :=\n  bsup.{_, v} o fun a ha => succ (f a ha)", "start": [1744, 1], "end": [1749, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_blsub", "code": "@[simp]\ntheorem bsup_eq_blsub (o : Ordinal.{u}) (f : \u2200 a < o, Ordinal.{max u v}) :\n    (bsup.{_, v} o fun a ha => succ (f a ha)) = blsub.{_, v} o f", "start": [1752, 1], "end": [1755, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_eq_blsub'", "code": "theorem lsub_eq_blsub' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o} (ho : type r = o)\n    (f : \u2200 a < o, Ordinal.{max u v}) : lsub.{_, v} (familyOfBFamily' r ho f) = blsub.{_, v} o f", "start": [1758, 1], "end": [1760, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_eq_lsub", "code": "theorem lsub_eq_lsub {\u03b9 \u03b9' : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) (r' : \u03b9' \u2192 \u03b9' \u2192 Prop) [IsWellOrder \u03b9 r]\n    [IsWellOrder \u03b9' r'] {o} (ho : type r = o) (ho' : type r' = o)\n    (f : \u2200 a < o, Ordinal.{max u v}) :\n    lsub.{_, v} (familyOfBFamily' r ho f) = lsub.{_, v} (familyOfBFamily' r' ho' f)", "start": [1763, 1], "end": [1767, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_eq_blsub", "code": "@[simp]\ntheorem lsub_eq_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    lsub.{_, v} (familyOfBFamily o f) = blsub.{_, v} o f", "start": [1770, 1], "end": [1773, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_eq_lsub'", "code": "@[simp]\ntheorem blsub_eq_lsub' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r]\n    (f : \u03b9 \u2192 Ordinal.{max u v}) : blsub.{_, v} _ (bfamilyOfFamily' r f) = lsub.{_, v} f", "start": [1776, 1], "end": [1779, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_eq_blsub", "code": "theorem blsub_eq_blsub {\u03b9 : Type u} (r r' : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] [IsWellOrder \u03b9 r']\n    (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    blsub.{_, v} _ (bfamilyOfFamily' r f) = blsub.{_, v} _ (bfamilyOfFamily' r' f)", "start": [1782, 1], "end": [1785, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_eq_lsub", "code": "@[simp]\ntheorem blsub_eq_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) :\n    blsub.{_, v} _ (bfamilyOfFamily f) = lsub.{_, v} f", "start": [1788, 1], "end": [1791, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_congr", "code": "@[congr]\ntheorem blsub_congr {o\u2081 o\u2082 : Ordinal.{u}} (f : \u2200 a < o\u2081, Ordinal.{max u v}) (ho : o\u2081 = o\u2082) :\n    blsub.{_, v} o\u2081 f = blsub.{_, v} o\u2082 fun a h => f a (h.trans_eq ho.symm)", "start": [1794, 1], "end": [1799, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_le_iff", "code": "theorem blsub_le_iff {o : Ordinal.{u}} {f : \u2200 a < o, Ordinal.{max u v}} {a} :\n    blsub.{_, v} o f \u2264 a \u2194 \u2200 i h, f i h < a", "start": [1802, 1], "end": [1805, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_le", "code": "theorem blsub_le {o : Ordinal} {f : \u2200 b < o, Ordinal} {a} : (\u2200 i h, f i h < a) \u2192 blsub o f \u2264 a", "start": [1808, 1], "end": [1809, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_blsub", "code": "theorem lt_blsub {o} (f : \u2200 a < o, Ordinal) (i h) : f i h < blsub o f", "start": [1812, 1], "end": [1813, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_blsub_iff", "code": "theorem lt_blsub_iff {o : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{max u v}} {a} :\n    a < blsub.{_, v} o f \u2194 \u2203 i hi, a \u2264 f i hi", "start": [1816, 1], "end": [1818, 87], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_le_blsub", "code": "theorem bsup_le_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f \u2264 blsub.{_, v} o f", "start": [1821, 1], "end": [1823, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_le_bsup_succ", "code": "theorem blsub_le_bsup_succ {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    blsub.{_, v} o f \u2264 succ (bsup.{_, v} o f)", "start": [1826, 1], "end": [1828, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_blsub_or_succ_bsup_eq_blsub", "code": "theorem bsup_eq_blsub_or_succ_bsup_eq_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f \u2228 succ (bsup.{_, v} o f) = blsub.{_, v} o f", "start": [1831, 1], "end": [1834, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_succ_le_blsub", "code": "theorem bsup_succ_le_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    succ (bsup.{_, v} o f) \u2264 blsub.{_, v} o f \u2194 \u2203 i hi, f i hi = bsup.{_, v} o f", "start": [1837, 1], "end": [1846, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_succ_eq_blsub", "code": "theorem bsup_succ_eq_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    succ (bsup.{_, v} o f) = blsub.{_, v} o f \u2194 \u2203 i hi, f i hi = bsup.{_, v} o f", "start": [1849, 1], "end": [1851, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_blsub_iff_succ", "code": "theorem bsup_eq_blsub_iff_succ {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f \u2194 \u2200 a < blsub.{_, v} o f, succ a < blsub.{_, v} o f", "start": [1854, 1], "end": [1857, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_blsub_iff_lt_bsup", "code": "theorem bsup_eq_blsub_iff_lt_bsup {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    bsup.{_, v} o f = blsub.{_, v} o f \u2194 \u2200 i hi, f i hi < bsup.{_, v} o f", "start": [1860, 1], "end": [1864, 73], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_eq_blsub_of_lt_succ_limit", "code": "theorem bsup_eq_blsub_of_lt_succ_limit {o : Ordinal.{u}} (ho : IsLimit o)\n    {f : \u2200 a < o, Ordinal.{max u v}} (hf : \u2200 a ha, f a ha < f (succ a) (ho.2 a ha)) :\n    bsup.{_, v} o f = blsub.{_, v} o f", "start": [1867, 1], "end": [1871, 55], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_succ_of_mono", "code": "theorem blsub_succ_of_mono {o : Ordinal.{u}} {f : \u2200 a < succ o, Ordinal.{max u v}}\n    (hf : \u2200 {i j} (hi hj), i \u2264 j \u2192 f i hi \u2264 f j hj) : blsub.{_, v} _ f = succ (f o (lt_succ o))", "start": [1874, 1], "end": [1876, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_eq_zero_iff", "code": "@[simp]\ntheorem blsub_eq_zero_iff {o} {f : \u2200 a < o, Ordinal} : blsub o f = 0 \u2194 o = 0", "start": [1879, 1], "end": [1882, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_zero", "code": "@[simp]\ntheorem blsub_zero (f : \u2200 a < (0 : Ordinal), Ordinal) : blsub 0 f = 0", "start": [1886, 1], "end": [1887, 99], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_pos", "code": "theorem blsub_pos {o : Ordinal} (ho : 0 < o) (f : \u2200 a < o, Ordinal) : 0 < blsub o f", "start": [1890, 1], "end": [1891, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_type", "code": "theorem blsub_type {\u03b1 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r]\n    (f : \u2200 a < type r, Ordinal.{max u v}) :\n    blsub.{_, v} (type r) f = lsub.{_, v} fun a => f (typein r a) (typein_lt_type _ _)", "start": [1894, 1], "end": [1899, 94], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_const", "code": "theorem blsub_const {o : Ordinal} (ho : o \u2260 0) (a : Ordinal) :\n    (blsub.{u, v} o fun _ _ => a) = succ a", "start": [1902, 1], "end": [1904, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_one", "code": "@[simp]\ntheorem blsub_one (f : \u2200 a < (1 : Ordinal), Ordinal) : blsub 1 f = succ (f 0 zero_lt_one)", "start": [1907, 1], "end": [1909, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_id", "code": "@[simp]\ntheorem blsub_id : \u2200 o, (blsub.{u, u} o fun x _ => x) = o", "start": [1912, 1], "end": [1914, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_id_limit", "code": "theorem bsup_id_limit {o : Ordinal} : (\u2200 a < o, succ a < o) \u2192 (bsup.{u, u} o fun x _ => x) = o", "start": [1917, 1], "end": [1918, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_id_succ", "code": "@[simp]\ntheorem bsup_id_succ (o) : (bsup.{u, u} (succ o) fun x _ => x) = o", "start": [1921, 1], "end": [1923, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_le_of_brange_subset", "code": "theorem blsub_le_of_brange_subset {o o'} {f : \u2200 a < o, Ordinal} {g : \u2200 a < o', Ordinal}\n    (h : brange o f \u2286 brange o' g) : blsub.{u, max v w} o f \u2264 blsub.{v, max u w} o' g", "start": [1926, 1], "end": [1931, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_eq_of_brange_eq", "code": "theorem blsub_eq_of_brange_eq {o o'} {f : \u2200 a < o, Ordinal} {g : \u2200 a < o', Ordinal}\n    (h : { o | \u2203 i hi, f i hi = o } = { o | \u2203 i hi, g i hi = o }) :\n    blsub.{u, max v w} o f = blsub.{v, max u w} o' g", "start": [1934, 1], "end": [1937, 97], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_comp", "code": "theorem bsup_comp {o o' : Ordinal.{max u v}} {f : \u2200 a < o, Ordinal.{max u v w}}\n    (hf : \u2200 {i j} (hi) (hj), i \u2264 j \u2192 f i hi \u2264 f j hj) {g : \u2200 a < o', Ordinal.{max u v}}\n    (hg : blsub.{_, u} o' g = o) :\n    (bsup.{_, w} o' fun a ha => f (g a ha) (by rw [\u2190 hg]; apply lt_blsub)) = bsup.{_, w} o f", "start": [1940, 1], "end": [1948, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_comp", "code": "theorem blsub_comp {o o' : Ordinal.{max u v}} {f : \u2200 a < o, Ordinal.{max u v w}}\n    (hf : \u2200 {i j} (hi) (hj), i \u2264 j \u2192 f i hi \u2264 f j hj) {g : \u2200 a < o', Ordinal.{max u v}}\n    (hg : blsub.{_, u} o' g = o) :\n    (blsub.{_, w} o' fun a ha => f (g a ha) (by rw [\u2190 hg]; apply lt_blsub)) = blsub.{_, w} o f", "start": [1951, 1], "end": [1956, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.bsup_eq", "code": "theorem IsNormal.bsup_eq {f : Ordinal.{u} \u2192 Ordinal.{max u v}} (H : IsNormal f) {o : Ordinal.{u}}\n    (h : IsLimit o) : (Ordinal.bsup.{_, v} o fun x _ => f x) = f o", "start": [1959, 1], "end": [1961, 73], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.blsub_eq", "code": "theorem IsNormal.blsub_eq {f : Ordinal.{u} \u2192 Ordinal.{max u v}} (H : IsNormal f) {o : Ordinal.{u}}\n    (h : IsLimit o) : (blsub.{_, v} o fun x _ => f x) = f o", "start": [1964, 1], "end": [1967, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isNormal_iff_lt_succ_and_bsup_eq", "code": "theorem isNormal_iff_lt_succ_and_bsup_eq {f : Ordinal.{u} \u2192 Ordinal.{max u v}} :\n    IsNormal f \u2194 (\u2200 a, f a < f (succ a)) \u2227 \u2200 o, IsLimit o \u2192 (bsup.{_, v} o fun x _ => f x) = f o", "start": [1970, 1], "end": [1975, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isNormal_iff_lt_succ_and_blsub_eq", "code": "theorem isNormal_iff_lt_succ_and_blsub_eq {f : Ordinal.{u} \u2192 Ordinal.{max u v}} :\n    IsNormal f \u2194 (\u2200 a, f a < f (succ a)) \u2227\n      \u2200 o, IsLimit o \u2192 (blsub.{_, v} o fun x _ => f x) = f o", "start": [1978, 1], "end": [1984, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.eq_iff_zero_and_succ", "code": "theorem IsNormal.eq_iff_zero_and_succ {f g : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f)\n    (hg : IsNormal g) : f = g \u2194 f 0 = g 0 \u2227 \u2200 a, f a = g a \u2192 f (succ a) = g (succ a)", "start": [1987, 1], "end": [1996, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub\u2082", "code": "def blsub\u2082 (o\u2081 o\u2082 : Ordinal) (op : {a : Ordinal} \u2192 (a < o\u2081) \u2192 {b : Ordinal} \u2192 (b < o\u2082) \u2192 Ordinal) :\n    Ordinal :=\n  lsub (fun x : o\u2081.out.\u03b1 \u00d7 o\u2082.out.\u03b1 => op (typein_lt_self x.1) (typein_lt_self x.2))", "start": [1999, 1], "end": [2003, 85], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_blsub\u2082", "code": "theorem lt_blsub\u2082 {o\u2081 o\u2082 : Ordinal}\n    (op : {a : Ordinal} \u2192 (a < o\u2081) \u2192 {b : Ordinal} \u2192 (b < o\u2082) \u2192 Ordinal) {a b : Ordinal}\n    (ha : a < o\u2081) (hb : b < o\u2082) : op ha hb < blsub\u2082 o\u2081 o\u2082 op", "start": [2006, 1], "end": [2011, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex", "code": "def mex {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : Ordinal :=\n  sInf (Set.range f)\u1d9c", "start": [2017, 1], "end": [2019, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex_not_mem_range", "code": "theorem mex_not_mem_range {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : mex.{_, v} f \u2209 Set.range f", "start": [2022, 1], "end": [2023, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_mex_of_forall", "code": "theorem le_mex_of_forall {\u03b9 : Type u} {f : \u03b9 \u2192 Ordinal.{max u v}} {a : Ordinal}\n    (H : \u2200 b < a, \u2203 i, f i = b) : a \u2264 mex.{_, v} f", "start": [2026, 1], "end": [2029, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ne_mex", "code": "theorem ne_mex {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : \u2200 i, f i \u2260 mex.{_, v} f", "start": [2032, 1], "end": [2033, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex_le_of_ne", "code": "theorem mex_le_of_ne {\u03b9} {f : \u03b9 \u2192 Ordinal} {a} (ha : \u2200 i, f i \u2260 a) : mex f \u2264 a", "start": [2036, 1], "end": [2037, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_of_lt_mex", "code": "theorem exists_of_lt_mex {\u03b9} {f : \u03b9 \u2192 Ordinal} {a} (ha : a < mex f) : \u2203 i, f i = a", "start": [2040, 1], "end": [2042, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex_le_lsub", "code": "theorem mex_le_lsub {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{max u v}) : mex.{_, v} f \u2264 lsub.{_, v} f", "start": [2045, 1], "end": [2046, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex_monotone", "code": "theorem mex_monotone {\u03b1 \u03b2 : Type u} {f : \u03b1 \u2192 Ordinal.{max u v}} {g : \u03b2 \u2192 Ordinal.{max u v}}\n    (h : Set.range f \u2286 Set.range g) : mex.{_, v} f \u2264 mex.{_, v} g", "start": [2049, 1], "end": [2054, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mex_lt_ord_succ_mk", "code": "theorem mex_lt_ord_succ_mk {\u03b9 : Type u} (f : \u03b9 \u2192 Ordinal.{u}) :\n    mex.{_, u} f < (succ #\u03b9).ord", "start": [2057, 1], "end": [2070, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex", "code": "def bmex (o : Ordinal) (f : \u2200 a < o, Ordinal) : Ordinal :=\n  mex (familyOfBFamily o f)", "start": [2073, 1], "end": [2079, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex_not_mem_brange", "code": "theorem bmex_not_mem_brange {o : Ordinal} (f : \u2200 a < o, Ordinal) : bmex o f \u2209 brange o f", "start": [2082, 1], "end": [2084, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_bmex_of_forall", "code": "theorem le_bmex_of_forall {o : Ordinal} (f : \u2200 a < o, Ordinal) {a : Ordinal}\n    (H : \u2200 b < a, \u2203 i hi, f i hi = b) : a \u2264 bmex o f", "start": [2087, 1], "end": [2090, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ne_bmex", "code": "theorem ne_bmex {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) {i} (hi) :\n    f i hi \u2260 bmex.{_, v} o f", "start": [2093, 1], "end": [2098, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex_le_of_ne", "code": "theorem bmex_le_of_ne {o : Ordinal} {f : \u2200 a < o, Ordinal} {a} (ha : \u2200 i hi, f i hi \u2260 a) :\n    bmex o f \u2264 a", "start": [2101, 1], "end": [2103, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_of_lt_bmex", "code": "theorem exists_of_lt_bmex {o : Ordinal} {f : \u2200 a < o, Ordinal} {a} (ha : a < bmex o f) :\n    \u2203 i hi, f i hi = a", "start": [2106, 1], "end": [2109, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex_le_blsub", "code": "theorem bmex_le_blsub {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{max u v}) :\n    bmex.{_, v} o f \u2264 blsub.{_, v} o f", "start": [2112, 1], "end": [2114, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex_monotone", "code": "theorem bmex_monotone {o o' : Ordinal.{u}}\n    {f : \u2200 a < o, Ordinal.{max u v}} {g : \u2200 a < o', Ordinal.{max u v}}\n    (h : brange o f \u2286 brange o' g) : bmex.{_, v} o f \u2264 bmex.{_, v} o' g", "start": [2117, 1], "end": [2120, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bmex_lt_ord_succ_card", "code": "theorem bmex_lt_ord_succ_card {o : Ordinal.{u}} (f : \u2200 a < o, Ordinal.{u}) :\n    bmex.{_, u} o f < (succ o.card).ord", "start": [2123, 1], "end": [2126, 49], "kind": "commanddeclaration"}, {"full_name": "not_surjective_of_ordinal", "code": "theorem not_surjective_of_ordinal {\u03b1 : Type u} (f : \u03b1 \u2192 Ordinal.{u}) : \u00acSurjective f", "start": [2134, 1], "end": [2135, 44], "kind": "commanddeclaration"}, {"full_name": "not_injective_of_ordinal", "code": "theorem not_injective_of_ordinal {\u03b1 : Type u} (f : Ordinal.{u} \u2192 \u03b1) : \u00acInjective f", "start": [2138, 1], "end": [2139, 52], "kind": "commanddeclaration"}, {"full_name": "not_surjective_of_ordinal_of_small", "code": "theorem not_surjective_of_ordinal_of_small {\u03b1 : Type v} [Small.{u} \u03b1] (f : \u03b1 \u2192 Ordinal.{u}) :\n    \u00acSurjective f", "start": [2142, 1], "end": [2143, 99], "kind": "commanddeclaration"}, {"full_name": "not_injective_of_ordinal_of_small", "code": "theorem not_injective_of_ordinal_of_small {\u03b1 : Type v} [Small.{u} \u03b1] (f : Ordinal.{u} \u2192 \u03b1) :\n    \u00acInjective f", "start": [2146, 1], "end": [2147, 91], "kind": "commanddeclaration"}, {"full_name": "not_small_ordinal", "code": "theorem not_small_ordinal : \u00acSmall.{u} Ordinal.{max u v}", "start": [2150, 1], "end": [2153, 82], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd", "code": "def enumOrd (S : Set Ordinal.{u}) : Ordinal \u2192 Ordinal :=\n  lt_wf.fix fun o f => sInf (S \u2229 Set.Ici (blsub.{u, u} o f))", "start": [2163, 1], "end": [2165, 61], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_def'", "code": "theorem enumOrd_def' (o) :\n    enumOrd S o = sInf (S \u2229 Set.Ici (blsub.{u, u} o fun a _ => enumOrd S a))", "start": [2170, 1], "end": [2174, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_def'_nonempty", "code": "theorem enumOrd_def'_nonempty (hS : Unbounded (\u00b7 < \u00b7) S) (a) : (S \u2229 Set.Ici a).Nonempty", "start": [2177, 1], "end": [2180, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_mem_aux", "code": "private theorem enumOrd_mem_aux (hS : Unbounded (\u00b7 < \u00b7) S) (o) :\n    enumOrd S o \u2208 S \u2229 Set.Ici (blsub.{u, u} o fun c _ => enumOrd S c)", "start": [2183, 1], "end": [2186, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_mem", "code": "theorem enumOrd_mem (hS : Unbounded (\u00b7 < \u00b7) S) (o) : enumOrd S o \u2208 S", "start": [2188, 1], "end": [2189, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_le_enumOrd", "code": "theorem blsub_le_enumOrd (hS : Unbounded (\u00b7 < \u00b7) S) (o) :\n    (blsub.{u, u} o fun c _ => enumOrd S c) \u2264 enumOrd S o", "start": [2192, 1], "end": [2194, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_strictMono", "code": "theorem enumOrd_strictMono (hS : Unbounded (\u00b7 < \u00b7) S) : StrictMono (enumOrd S)", "start": [2197, 1], "end": [2198, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_def", "code": "theorem enumOrd_def (o) : enumOrd S o = sInf (S \u2229 { b | \u2200 c, c < o \u2192 enumOrd S c < b })", "start": [2201, 1], "end": [2205, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_def_nonempty", "code": "theorem enumOrd_def_nonempty (hS : Unbounded (\u00b7 < \u00b7) S) {o} :\n    { x | x \u2208 S \u2227 \u2200 c, c < o \u2192 enumOrd S c < x }.Nonempty", "start": [2208, 1], "end": [2211, 60], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_range", "code": "@[simp]\ntheorem enumOrd_range {f : Ordinal \u2192 Ordinal} (hf : StrictMono f) : enumOrd (range f) = f", "start": [2214, 1], "end": [2228, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_univ", "code": "@[simp]\ntheorem enumOrd_univ : enumOrd Set.univ = id", "start": [2231, 1], "end": [2234, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_zero", "code": "@[simp]\ntheorem enumOrd_zero : enumOrd S 0 = sInf S", "start": [2237, 1], "end": [2240, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_succ_le", "code": "theorem enumOrd_succ_le {a b} (hS : Unbounded (\u00b7 < \u00b7) S) (ha : a \u2208 S) (hb : enumOrd S b < a) :\n    enumOrd S (succ b) \u2264 a", "start": [2243, 1], "end": [2247, 98], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_le_of_subset", "code": "theorem enumOrd_le_of_subset {S T : Set Ordinal} (hS : Unbounded (\u00b7 < \u00b7) S) (hST : S \u2286 T) (a) :\n    enumOrd T a \u2264 enumOrd S a", "start": [2250, 1], "end": [2255, 98], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrd_surjective", "code": "theorem enumOrd_surjective (hS : Unbounded (\u00b7 < \u00b7) S) : \u2200 s \u2208 S, \u2203 a, enumOrd S a = s", "start": [2258, 1], "end": [2273, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.enumOrdOrderIso", "code": "def enumOrdOrderIso (hS : Unbounded (\u00b7 < \u00b7) S) : Ordinal \u2243o S :=\n  StrictMono.orderIsoOfSurjective (fun o => \u27e8_, enumOrd_mem hS o\u27e9) (enumOrd_strictMono hS) fun s =>\n    let \u27e8a, ha\u27e9 := enumOrd_surjective hS s s.prop\n    \u27e8a, Subtype.eq ha\u27e9", "start": [2276, 1], "end": [2280, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.range_enumOrd", "code": "theorem range_enumOrd (hS : Unbounded (\u00b7 < \u00b7) S) : range (enumOrd S) = S", "start": [2283, 1], "end": [2285, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.eq_enumOrd", "code": "theorem eq_enumOrd (f : Ordinal \u2192 Ordinal) (hS : Unbounded (\u00b7 < \u00b7) S) :\n    StrictMono f \u2227 range f = S \u2194 f = enumOrd S", "start": [2288, 1], "end": [2295, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_add_nat_cast", "code": "@[simp]\ntheorem one_add_nat_cast (m : \u2115) : 1 + (m : Ordinal) = succ m", "start": [2303, 1], "end": [2306, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_mul", "code": "@[simp, norm_cast]\ntheorem nat_cast_mul (m : \u2115) : \u2200 n : \u2115, ((m * n : \u2115) : Ordinal) = m * n", "start": [2309, 1], "end": [2312, 94], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_le", "code": "@[simp, norm_cast]\ntheorem nat_cast_le {m n : \u2115} : (m : Ordinal) \u2264 n \u2194 m \u2264 n", "start": [2315, 1], "end": [2317, 88], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_lt", "code": "@[simp, norm_cast]\ntheorem nat_cast_lt {m n : \u2115} : (m : Ordinal) < n \u2194 m < n", "start": [2320, 1], "end": [2322, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_inj", "code": "@[simp, norm_cast]\ntheorem nat_cast_inj {m n : \u2115} : (m : Ordinal) = n \u2194 m = n", "start": [2325, 1], "end": [2327, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_eq_zero", "code": "@[simp, norm_cast]\ntheorem nat_cast_eq_zero {n : \u2115} : (n : Ordinal) = 0 \u2194 n = 0", "start": [2330, 1], "end": [2332, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_ne_zero", "code": "theorem nat_cast_ne_zero {n : \u2115} : (n : Ordinal) \u2260 0 \u2194 n \u2260 0", "start": [2335, 1], "end": [2336, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_pos", "code": "@[simp, norm_cast]\ntheorem nat_cast_pos {n : \u2115} : (0 : Ordinal) < n \u2194 0 < n", "start": [2339, 1], "end": [2341, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_sub", "code": "@[simp, norm_cast]\ntheorem nat_cast_sub (m n : \u2115) : ((m - n : \u2115) : Ordinal) = m - n", "start": [2344, 1], "end": [2350, 97], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_div", "code": "@[simp, norm_cast]\ntheorem nat_cast_div (m n : \u2115) : ((m / n : \u2115) : Ordinal) = m / n", "start": [2353, 1], "end": [2363, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_mod", "code": "@[simp, norm_cast]\ntheorem nat_cast_mod (m n : \u2115) : ((m % n : \u2115) : Ordinal) = m % n", "start": [2366, 1], "end": [2369, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_nat_cast", "code": "@[simp]\ntheorem lift_nat_cast : \u2200 n : \u2115, lift.{u, v} n = n", "start": [2372, 1], "end": [2375, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_aleph0", "code": "@[simp]\ntheorem ord_aleph0 : ord.{u} \u2135\u2080 = \u03c9", "start": [2387, 1], "end": [2393, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_one_of_aleph0_le", "code": "@[simp]\ntheorem add_one_of_aleph0_le {c} (h : \u2135\u2080 \u2264 c) : c + 1 = c", "start": [2396, 1], "end": [2399, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_add_of_limit", "code": "theorem lt_add_of_limit {a b c : Ordinal.{u}} (h : IsLimit c) :\n    a < b + c \u2194 \u2203 c' < c, a < b + c'", "start": [2406, 1], "end": [2412, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_omega", "code": "theorem lt_omega {o : Ordinal} : o < \u03c9 \u2194 \u2203 n : \u2115, o = n", "start": [2415, 1], "end": [2416, 75], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_lt_omega", "code": "theorem nat_lt_omega (n : \u2115) : \u2191n < \u03c9", "start": [2419, 1], "end": [2420, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_pos", "code": "theorem omega_pos : 0 < \u03c9", "start": [2423, 1], "end": [2424, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_ne_zero", "code": "theorem omega_ne_zero : \u03c9 \u2260 0", "start": [2427, 1], "end": [2428, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_lt_omega", "code": "theorem one_lt_omega : 1 < \u03c9", "start": [2431, 1], "end": [2431, 82], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_isLimit", "code": "theorem omega_isLimit : IsLimit \u03c9", "start": [2434, 1], "end": [2437, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_le", "code": "theorem omega_le {o : Ordinal} : \u03c9 \u2264 o \u2194 \u2200 n : \u2115, \u2191n \u2264 o", "start": [2440, 1], "end": [2444, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_nat_cast", "code": "@[simp]\ntheorem sup_nat_cast : sup Nat.cast = \u03c9", "start": [2447, 1], "end": [2449, 75], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_lt_limit", "code": "theorem nat_lt_limit {o} (h : IsLimit o) : \u2200 n : \u2115, \u2191n < o", "start": [2452, 1], "end": [2454, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_le_of_isLimit", "code": "theorem omega_le_of_isLimit {o} (h : IsLimit o) : \u03c9 \u2264 o", "start": [2457, 1], "end": [2458, 51], "kind": "commanddeclaration"}, {"full_name": "Ordinal.isLimit_iff_omega_dvd", "code": "theorem isLimit_iff_omega_dvd {a : Ordinal} : IsLimit a \u2194 a \u2260 0 \u2227 \u03c9 \u2223 a", "start": [2461, 1], "end": [2474, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_mul_limit_aux", "code": "theorem add_mul_limit_aux {a b c : Ordinal} (ba : b + a = a) (l : IsLimit c)\n    (IH : \u2200 c' < c, (a + b) * succ c' = a * succ c' + b) : (a + b) * c = a * c", "start": [2477, 1], "end": [2488, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_mul_succ", "code": "theorem add_mul_succ {a b : Ordinal} (c) (ba : b + a = a) : (a + b) * succ c = a * succ c + b", "start": [2491, 1], "end": [2499, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_mul_limit", "code": "theorem add_mul_limit {a b c : Ordinal} (ba : b + a = a) (l : IsLimit c) : (a + b) * c = a * c", "start": [2502, 1], "end": [2503, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_le_of_forall_add_lt", "code": "theorem add_le_of_forall_add_lt {a b c : Ordinal} (hb : 0 < b) (h : \u2200 d < b, a + d < c) :\n    a + b \u2264 c", "start": [2506, 1], "end": [2516, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.apply_omega", "code": "theorem IsNormal.apply_omega {f : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f) :\n    Ordinal.sup.{0, u} (f \u2218 Nat.cast) = f \u03c9", "start": [2519, 1], "end": [2520, 97], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_add_nat", "code": "@[simp]\ntheorem sup_add_nat (o : Ordinal) : (sup fun n : \u2115 => o + n) = o + \u03c9", "start": [2523, 1], "end": [2525, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_mul_nat", "code": "@[simp]\ntheorem sup_mul_nat (o : Ordinal) : (sup fun n : \u2115 => o * n) = o * \u03c9", "start": [2528, 1], "end": [2533, 40], "kind": "commanddeclaration"}, {"full_name": "Acc.rank", "code": "noncomputable def rank (h : Acc r a) : Ordinal.{u} :=\n  Acc.recOn h fun a _h ih => Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ <| ih b b.2", "start": [2542, 1], "end": [2546, 97], "kind": "commanddeclaration"}, {"full_name": "Acc.rank_eq", "code": "theorem rank_eq (h : Acc r a) :\n    h.rank = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ (h.inv b.2).rank", "start": [2549, 1], "end": [2552, 6], "kind": "commanddeclaration"}, {"full_name": "Acc.rank_lt_of_rel", "code": "theorem rank_lt_of_rel (hb : Acc r b) (h : r a b) : (hb.inv h).rank < hb.rank", "start": [2555, 1], "end": [2560, 8], "kind": "commanddeclaration"}, {"full_name": "WellFounded.rank", "code": "noncomputable def rank (a : \u03b1) : Ordinal.{u} :=\n  (hwf.apply a).rank", "start": [2569, 1], "end": [2573, 21], "kind": "commanddeclaration"}, {"full_name": "WellFounded.rank_eq", "code": "theorem rank_eq :\n    hwf.rank a = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ <| hwf.rank b", "start": [2576, 1], "end": [2579, 6], "kind": "commanddeclaration"}, {"full_name": "WellFounded.rank_lt_of_rel", "code": "theorem rank_lt_of_rel (h : r a b) : hwf.rank a < hwf.rank b", "start": [2582, 1], "end": [2583, 25], "kind": "commanddeclaration"}, {"full_name": "WellFounded.rank_strictMono", "code": "theorem rank_strictMono [Preorder \u03b1] [WellFoundedLT \u03b1] :\n    StrictMono (rank <| @IsWellFounded.wf \u03b1 (\u00b7 < \u00b7) _)", "start": [2586, 1], "end": [2587, 86], "kind": "commanddeclaration"}, {"full_name": "WellFounded.rank_strictAnti", "code": "theorem rank_strictAnti [Preorder \u03b1] [WellFoundedGT \u03b1] :\n    StrictAnti (rank <| @IsWellFounded.wf \u03b1 (\u00b7 > \u00b7) _)", "start": [2590, 1], "end": [2592, 50], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "imports": ["Mathlib/Topology/UniformSpace/Pi.lean", "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "Mathlib/Topology/UniformSpace/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformFun", "code": "def UniformFun (\u03b1 \u03b2 : Type*) :=\n  \u03b1 \u2192 \u03b2", "start": [144, 1], "end": [147, 8], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun", "code": "@[nolint unusedArguments]\ndef UniformOnFun (\u03b1 \u03b2 : Type*) (_ : Set (Set \u03b1)) :=\n  \u03b1 \u2192 \u03b2", "start": [150, 1], "end": [154, 8], "kind": "commanddeclaration"}, {"full_name": "UniformFun.ofFun", "code": "def UniformFun.ofFun {\u03b1 \u03b2} : (\u03b1 \u2192 \u03b2) \u2243 (\u03b1 \u2192\u1d64 \u03b2) :=\n  \u27e8fun x => x, fun x => x, fun _ => rfl, fun _ => rfl\u27e9", "start": [174, 1], "end": [176, 55], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.ofFun", "code": "def UniformOnFun.ofFun {\u03b1 \u03b2} (\ud835\udd16) : (\u03b1 \u2192 \u03b2) \u2243 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) :=\n  \u27e8fun x => x, fun x => x, fun _ => rfl, fun _ => rfl\u27e9", "start": [179, 1], "end": [181, 55], "kind": "commanddeclaration"}, {"full_name": "UniformFun.toFun", "code": "def UniformFun.toFun {\u03b1 \u03b2} : (\u03b1 \u2192\u1d64 \u03b2) \u2243 (\u03b1 \u2192 \u03b2) :=\n  UniformFun.ofFun.symm", "start": [184, 1], "end": [186, 24], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.toFun", "code": "def UniformOnFun.toFun {\u03b1 \u03b2} (\ud835\udd16) : (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) \u2243 (\u03b1 \u2192 \u03b2) :=\n  (UniformOnFun.ofFun \ud835\udd16).symm", "start": [189, 1], "end": [191, 30], "kind": "commanddeclaration"}, {"full_name": "UniformFun.gen", "code": "protected def gen (V : Set (\u03b2 \u00d7 \u03b2)) : Set ((\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b2)) :=\n  { uv : (\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b2) | \u2200 x, (uv.1 x, uv.2 x) \u2208 V }", "start": [206, 1], "end": [209, 59], "kind": "commanddeclaration"}, {"full_name": "UniformFun.isBasis_gen", "code": "protected theorem isBasis_gen (\ud835\udcd1 : Filter <| \u03b2 \u00d7 \u03b2) :\n    IsBasis (fun V : Set (\u03b2 \u00d7 \u03b2) => V \u2208 \ud835\udcd1) (UniformFun.gen \u03b1 \u03b2)", "start": [212, 1], "end": [219, 92], "kind": "commanddeclaration"}, {"full_name": "UniformFun.basis", "code": "protected def basis (\ud835\udcd5 : Filter <| \u03b2 \u00d7 \u03b2) : FilterBasis ((\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b2)) :=\n  (UniformFun.isBasis_gen \u03b1 \u03b2 \ud835\udcd5).filterBasis", "start": [222, 1], "end": [228, 45], "kind": "commanddeclaration"}, {"full_name": "UniformFun.filter", "code": "protected def filter (\ud835\udcd5 : Filter <| \u03b2 \u00d7 \u03b2) : Filter ((\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b2)) :=\n  (UniformFun.basis \u03b1 \u03b2 \ud835\udcd5).filter", "start": [231, 1], "end": [235, 34], "kind": "commanddeclaration"}, {"full_name": "UniformFun.phi", "code": "protected def phi (\u03b1 \u03b2 : Type*) (uvx : ((\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b2)) \u00d7 \u03b1) : \u03b2 \u00d7 \u03b2 :=\n  (uvx.fst.fst uvx.2, uvx.1.2 uvx.2)", "start": [242, 1], "end": [243, 37], "kind": "commanddeclaration"}, {"full_name": "UniformFun.gc", "code": "protected theorem gc : GaloisConnection lower_adjoint fun \ud835\udcd5 => UniformFun.filter \u03b1 \u03b2 \ud835\udcd5", "start": [253, 1], "end": [274, 39], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformCore", "code": "protected def uniformCore : UniformSpace.Core (\u03b1 \u2192\u1d64 \u03b2) :=\n  UniformSpace.Core.mkOfBasis (UniformFun.basis \u03b1 \u03b2 (\ud835\udce4 \u03b2))\n    (fun _ \u27e8_, hV, hVU\u27e9 _ => hVU \u25b8 fun _ => refl_mem_uniformity hV)\n    (fun _ \u27e8V, hV, hVU\u27e9 =>\n      hVU \u25b8\n        \u27e8UniformFun.gen \u03b1 \u03b2 (Prod.swap \u207b\u00b9' V), \u27e8Prod.swap \u207b\u00b9' V, tendsto_swap_uniformity hV, rfl\u27e9,\n          fun _ huv x => huv x\u27e9)\n    fun _ \u27e8_, hV, hVU\u27e9 =>\n    hVU \u25b8\n      let \u27e8W, hW, hWV\u27e9 := comp_mem_uniformity_sets hV\n      \u27e8UniformFun.gen \u03b1 \u03b2 W, \u27e8W, hW, rfl\u27e9, fun _ \u27e8w, huw, hwv\u27e9 x => hWV \u27e8w x, \u27e8huw x, hwv x\u27e9\u27e9\u27e9", "start": [279, 1], "end": [290, 95], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformSpace", "code": "instance uniformSpace : UniformSpace (\u03b1 \u2192\u1d64 \u03b2) :=\n  UniformSpace.ofCore (UniformFun.uniformCore \u03b1 \u03b2)", "start": [293, 1], "end": [296, 51], "kind": "commanddeclaration"}, {"full_name": "UniformFun.topologicalSpace", "code": "instance topologicalSpace : TopologicalSpace (\u03b1 \u2192\u1d64 \u03b2) :=\n  inferInstance", "start": [298, 1], "end": [300, 16], "kind": "commanddeclaration"}, {"full_name": "UniformFun.hasBasis_uniformity", "code": "protected theorem hasBasis_uniformity :\n    (\ud835\udce4 (\u03b1 \u2192\u1d64 \u03b2)).HasBasis (fun V => V \u2208 \ud835\udce4 \u03b2) (UniformFun.gen \u03b1 \u03b2)", "start": [305, 1], "end": [309, 46], "kind": "commanddeclaration"}, {"full_name": "UniformFun.hasBasis_uniformity_of_basis", "code": "protected theorem hasBasis_uniformity_of_basis {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)}\n    (h : (\ud835\udce4 \u03b2).HasBasis p s) : (\ud835\udce4 (\u03b1 \u2192\u1d64 \u03b2)).HasBasis p (UniformFun.gen \u03b1 \u03b2 \u2218 s)", "start": [312, 1], "end": [321, 54], "kind": "commanddeclaration"}, {"full_name": "UniformFun.hasBasis_nhds_of_basis", "code": "protected theorem hasBasis_nhds_of_basis (f) {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)}\n    (h : HasBasis (\ud835\udce4 \u03b2) p s) :\n    (\ud835\udcdd f).HasBasis p fun i => { g | (f, g) \u2208 UniformFun.gen \u03b1 \u03b2 (s i) }", "start": [324, 1], "end": [329, 73], "kind": "commanddeclaration"}, {"full_name": "UniformFun.hasBasis_nhds", "code": "protected theorem hasBasis_nhds (f) :\n    (\ud835\udcdd f).HasBasis (fun V => V \u2208 \ud835\udce4 \u03b2) fun V => { g | (f, g) \u2208 UniformFun.gen \u03b1 \u03b2 V }", "start": [332, 1], "end": [336, 64], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformContinuous_eval", "code": "theorem uniformContinuous_eval (x : \u03b1) :\n    UniformContinuous (Function.eval x \u2218 toFun : (\u03b1 \u2192\u1d64 \u03b2) \u2192 \u03b2)", "start": [341, 1], "end": [347, 49], "kind": "commanddeclaration"}, {"full_name": "UniformFun.mono", "code": "protected theorem mono : Monotone (@UniformFun.uniformSpace \u03b1 \u03b3)", "start": [352, 1], "end": [355, 36], "kind": "commanddeclaration"}, {"full_name": "UniformFun.iInf_eq", "code": "protected theorem iInf_eq {u : \u03b9 \u2192 UniformSpace \u03b3} : \ud835\udcb0(\u03b1, \u03b3, (\u2a05 i, u i)) = \u2a05 i, \ud835\udcb0(\u03b1, \u03b3, u i)", "start": [358, 1], "end": [366, 35], "kind": "commanddeclaration"}, {"full_name": "UniformFun.inf_eq", "code": "protected theorem inf_eq {u\u2081 u\u2082 : UniformSpace \u03b3} :\n    \ud835\udcb0(\u03b1, \u03b3, u\u2081 \u2293 u\u2082) = \ud835\udcb0(\u03b1, \u03b3, u\u2081) \u2293 \ud835\udcb0(\u03b1, \u03b3, u\u2082)", "start": [369, 1], "end": [377, 18], "kind": "commanddeclaration"}, {"full_name": "UniformFun.comap_eq", "code": "protected theorem comap_eq {f : \u03b3 \u2192 \u03b2} :\n    \ud835\udcb0(\u03b1, \u03b3, \u2039UniformSpace \u03b2\u203a.comap f) = \ud835\udcb0(\u03b1, \u03b2, _).comap ((f \u2218 \u00b7))", "start": [381, 1], "end": [402, 6], "kind": "commanddeclaration"}, {"full_name": "UniformFun.postcomp_uniformContinuous", "code": "protected theorem postcomp_uniformContinuous [UniformSpace \u03b3] {f : \u03b3 \u2192 \u03b2}\n    (hf : UniformContinuous f) :\n    UniformContinuous (ofFun \u2218 (f \u2218 \u00b7) \u2218 toFun : (\u03b1 \u2192\u1d64 \u03b3) \u2192 \u03b1 \u2192\u1d64 \u03b2)", "start": [405, 1], "end": [414, 87], "kind": "commanddeclaration"}, {"full_name": "UniformFun.postcomp_uniformInducing", "code": "protected theorem postcomp_uniformInducing [UniformSpace \u03b3] {f : \u03b3 \u2192 \u03b2} (hf : UniformInducing f) :\n    UniformInducing (ofFun \u2218 (f \u2218 \u00b7) \u2218 toFun : (\u03b1 \u2192\u1d64 \u03b3) \u2192 \u03b1 \u2192\u1d64 \u03b2)", "start": [422, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "UniformFun.congrRight", "code": "protected def congrRight [UniformSpace \u03b3] (e : \u03b3 \u2243\u1d64 \u03b2) : (\u03b1 \u2192\u1d64 \u03b3) \u2243\u1d64 (\u03b1 \u2192\u1d64 \u03b2) :=\n  { Equiv.piCongrRight fun _a =>\n      e.toEquiv with\n    uniformContinuous_toFun := UniformFun.postcomp_uniformContinuous e.uniformContinuous\n    uniformContinuous_invFun := UniformFun.postcomp_uniformContinuous e.symm.uniformContinuous }", "start": [439, 1], "end": [445, 97], "kind": "commanddeclaration"}, {"full_name": "UniformFun.precomp_uniformContinuous", "code": "protected theorem precomp_uniformContinuous {f : \u03b3 \u2192 \u03b1} :\n    UniformContinuous fun g : \u03b1 \u2192\u1d64 \u03b2 => ofFun (g \u2218 f)", "start": [448, 1], "end": [461, 55], "kind": "commanddeclaration"}, {"full_name": "UniformFun.congrLeft", "code": "protected def congrLeft (e : \u03b3 \u2243 \u03b1) : (\u03b3 \u2192\u1d64 \u03b2) \u2243\u1d64 (\u03b1 \u2192\u1d64 \u03b2) :=\n  { Equiv.arrowCongr e\n      (Equiv.refl\n        _) with\n    uniformContinuous_toFun := UniformFun.precomp_uniformContinuous\n    uniformContinuous_invFun := UniformFun.precomp_uniformContinuous }", "start": [464, 1], "end": [471, 71], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformContinuous_toFun", "code": "protected theorem uniformContinuous_toFun : UniformContinuous (toFun : (\u03b1 \u2192\u1d64 \u03b2) \u2192 \u03b1 \u2192 \u03b2)", "start": [481, 1], "end": [489, 35], "kind": "commanddeclaration"}, {"full_name": "UniformFun.tendsto_iff_tendstoUniformly", "code": "protected theorem tendsto_iff_tendstoUniformly {F : \u03b9 \u2192 \u03b1 \u2192\u1d64 \u03b2} {f : \u03b1 \u2192\u1d64 \u03b2} :\n    Tendsto F p (\ud835\udcdd f) \u2194 TendstoUniformly F f p", "start": [492, 1], "end": [497, 16], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformEquivProdArrow", "code": "protected def uniformEquivProdArrow [UniformSpace \u03b3] : (\u03b1 \u2192\u1d64 \u03b2 \u00d7 \u03b3) \u2243\u1d64 (\u03b1 \u2192\u1d64 \u03b2) \u00d7 (\u03b1 \u2192\u1d64 \u03b3) :=\n  Equiv.toUniformEquivOfUniformInducing (Equiv.arrowProdEquivProdArrow _ _ _) $ by\n    constructor\n    change\n      comap (Prod.map (Equiv.arrowProdEquivProdArrow _ _ _) (Equiv.arrowProdEquivProdArrow _ _ _))\n          _ = _\n    simp_rw [UniformFun]\n    rw [\u2190 uniformity_comap]\n    congr\n    unfold instUniformSpaceProd\n    rw [UniformSpace.comap_inf, \u2190 UniformSpace.comap_comap, \u2190 UniformSpace.comap_comap]\n    have := (@UniformFun.inf_eq \u03b1 (\u03b2 \u00d7 \u03b3)\n      (UniformSpace.comap Prod.fst \u2039_\u203a) (UniformSpace.comap Prod.snd \u2039_\u203a)).symm\n    rwa [UniformFun.comap_eq, UniformFun.comap_eq] at this", "start": [500, 1], "end": [520, 59], "kind": "commanddeclaration"}, {"full_name": "UniformFun.uniformEquivPiComm", "code": "protected def uniformEquivPiComm : UniformEquiv (\u03b1 \u2192\u1d64 \u2200 i, \u03b4 i) (\u2200 i, \u03b1 \u2192\u1d64 \u03b4 i) :=\n  @Equiv.toUniformEquivOfUniformInducing\n    _ _ \ud835\udcb0(\u03b1, \u2200 i, \u03b4 i, Pi.uniformSpace \u03b4)\n    (@Pi.uniformSpace \u03b9 (fun i => \u03b1 \u2192 \u03b4 i) fun i => \ud835\udcb0(\u03b1, \u03b4 i, _)) (Equiv.piComm _) $ by\n      refine @UniformInducing.mk ?_ ?_ ?_ ?_ ?_ ?_\n      change comap (Prod.map Function.swap Function.swap) _ = _\n      rw [\u2190 uniformity_comap]\n      congr\n      unfold Pi.uniformSpace\n      rw [UniformSpace.ofCoreEq_toCore, UniformSpace.ofCoreEq_toCore,\n        UniformSpace.comap_iInf, UniformFun.iInf_eq]\n      refine' iInf_congr fun i => _\n      rw [\u2190 UniformSpace.comap_comap, UniformFun.comap_eq]\n      rfl", "start": [526, 1], "end": [546, 10], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.gen", "code": "protected def gen (\ud835\udd16) (S : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) : Set ((\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) \u00d7 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2)) :=\n  { uv : (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) \u00d7 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) | \u2200 x \u2208 S, (uv.1 x, uv.2 x) \u2208 V }", "start": [561, 1], "end": [566, 69], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.gen_eq_preimage_restrict", "code": "protected theorem gen_eq_preimage_restrict {\ud835\udd16} (S : Set \u03b1) (V : Set (\u03b2 \u00d7 \u03b2)) :\n    UniformOnFun.gen \ud835\udd16 S V =\n      Prod.map (S.restrict \u2218 UniformFun.toFun) (S.restrict \u2218 UniformFun.toFun) \u207b\u00b9'\n        UniformFun.gen S \u03b2 V", "start": [569, 1], "end": [579, 59], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.gen_mono", "code": "protected theorem gen_mono {\ud835\udd16} {S S' : Set \u03b1} {V V' : Set (\u03b2 \u00d7 \u03b2)} (hS : S' \u2286 S) (hV : V \u2286 V') :\n    UniformOnFun.gen \ud835\udd16 S V \u2286 UniformOnFun.gen \ud835\udd16 S' V'", "start": [582, 1], "end": [584, 93], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.isBasis_gen", "code": "protected theorem isBasis_gen (\ud835\udd16 : Set (Set \u03b1)) (h : \ud835\udd16.Nonempty) (h' : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16)\n    (\ud835\udcd1 : FilterBasis <| \u03b2 \u00d7 \u03b2) :\n    IsBasis (fun SV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => SV.1 \u2208 \ud835\udd16 \u2227 SV.2 \u2208 \ud835\udcd1) fun SV =>\n      UniformOnFun.gen \ud835\udd16 SV.1 SV.2", "start": [587, 1], "end": [601, 94], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformSpace", "code": "instance uniformSpace : UniformSpace (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) :=\n  \u2a05 (s : Set \u03b1) (_ : s \u2208 \ud835\udd16), UniformSpace.comap s.restrict \ud835\udcb0(s, \u03b2, _)", "start": [606, 1], "end": [611, 70], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.topologicalSpace", "code": "instance topologicalSpace : TopologicalSpace (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) :=\n  \ud835\udcb1(\u03b1, \u03b2, \ud835\udd16, _).toTopologicalSpace", "start": [615, 1], "end": [618, 35], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.topologicalSpace_eq", "code": "protected theorem topologicalSpace_eq :\n    UniformOnFun.topologicalSpace \u03b1 \u03b2 \ud835\udd16 =\n      \u2a05 (s : Set \u03b1) (_ : s \u2208 \ud835\udd16), TopologicalSpace.induced (s.restrict \u2218 UniformFun.toFun)\n        (UniformFun.topologicalSpace s \u03b2)", "start": [620, 1], "end": [629, 6], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_uniformity_of_basis_aux\u2081", "code": "protected theorem hasBasis_uniformity_of_basis_aux\u2081 {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)}\n    (hb : HasBasis (\ud835\udce4 \u03b2) p s) (S : Set \u03b1) :\n    (@uniformity (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) ((UniformFun.uniformSpace S \u03b2).comap S.restrict)).HasBasis p fun i =>\n      UniformOnFun.gen \ud835\udd16 S (s i)", "start": [632, 1], "end": [637, 65], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_uniformity_of_basis_aux\u2082", "code": "protected theorem hasBasis_uniformity_of_basis_aux\u2082 (h : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) {p : \u03b9 \u2192 Prop}\n    {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)} (hb : HasBasis (\ud835\udce4 \u03b2) p s) :\n    DirectedOn\n      ((fun s : Set \u03b1 => (UniformFun.uniformSpace s \u03b2).comap (s.restrict : (\u03b1 \u2192\u1d64 \u03b2) \u2192 s \u2192\u1d64 \u03b2)) \u207b\u00b9'o\n        GE.ge)\n      \ud835\udd16", "start": [640, 1], "end": [649, 64], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_uniformity_of_basis", "code": "protected theorem hasBasis_uniformity_of_basis (h : \ud835\udd16.Nonempty) (h' : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16)\n    {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)} (hb : HasBasis (\ud835\udce4 \u03b2) p s) :\n    (\ud835\udce4 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2)).HasBasis (fun Si : Set \u03b1 \u00d7 \u03b9 => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2) fun Si =>\n      UniformOnFun.gen \ud835\udd16 Si.1 (s Si.2)", "start": [652, 1], "end": [663, 67], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_uniformity", "code": "protected theorem hasBasis_uniformity (h : \ud835\udd16.Nonempty) (h' : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) :\n    (\ud835\udce4 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2)).HasBasis (fun SV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => SV.1 \u2208 \ud835\udd16 \u2227 SV.2 \u2208 \ud835\udce4 \u03b2) fun SV =>\n      UniformOnFun.gen \ud835\udd16 SV.1 SV.2", "start": [666, 1], "end": [671, 72], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_nhds_of_basis", "code": "protected theorem hasBasis_nhds_of_basis (f : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) (h : \ud835\udd16.Nonempty)\n    (h' : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set (\u03b2 \u00d7 \u03b2)} (hb : HasBasis (\ud835\udce4 \u03b2) p s) :\n    (\ud835\udcdd f).HasBasis (fun Si : Set \u03b1 \u00d7 \u03b9 => Si.1 \u2208 \ud835\udd16 \u2227 p Si.2) fun Si =>\n      { g | (g, f) \u2208 UniformOnFun.gen \ud835\udd16 Si.1 (s Si.2) }", "start": [674, 1], "end": [682, 82], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.hasBasis_nhds", "code": "protected theorem hasBasis_nhds (f : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) (h : \ud835\udd16.Nonempty) (h' : DirectedOn (\u00b7 \u2286 \u00b7) \ud835\udd16) :\n    (\ud835\udcdd f).HasBasis (fun SV : Set \u03b1 \u00d7 Set (\u03b2 \u00d7 \u03b2) => SV.1 \u2208 \ud835\udd16 \u2227 SV.2 \u2208 \ud835\udce4 \u03b2) fun SV =>\n      { g | (g, f) \u2208 UniformOnFun.gen \ud835\udd16 SV.1 SV.2 }", "start": [685, 1], "end": [690, 73], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformContinuous_restrict", "code": "protected theorem uniformContinuous_restrict (h : s \u2208 \ud835\udd16) :\n    UniformContinuous (UniformFun.ofFun \u2218 (s.restrict : (\u03b1 \u2192 \u03b2) \u2192 s \u2192 \u03b2) \u2218 toFun \ud835\udd16)", "start": [693, 1], "end": [699, 21], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.mono", "code": "protected theorem mono \u2983u\u2081 u\u2082 : UniformSpace \u03b3\u2984 (hu : u\u2081 \u2264 u\u2082) \u2983\ud835\udd16\u2081 \ud835\udd16\u2082 : Set (Set \u03b1)\u2984\n    (h\ud835\udd16 : \ud835\udd16\u2082 \u2286 \ud835\udd16\u2081) : \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16\u2081, u\u2081) \u2264 \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16\u2082, u\u2082)", "start": [704, 1], "end": [710, 98], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformContinuous_eval_of_mem", "code": "theorem uniformContinuous_eval_of_mem {x : \u03b1} (hxs : x \u2208 s) (hs : s \u2208 \ud835\udd16) :\n    UniformContinuous ((Function.eval x : (\u03b1 \u2192 \u03b2) \u2192 \u03b2) \u2218 toFun \ud835\udd16)", "start": [713, 1], "end": [718, 55], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.iInf_eq", "code": "protected theorem iInf_eq {u : \u03b9 \u2192 UniformSpace \u03b3} :\n    \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, \u2a05 i, u i) = \u2a05 i, \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, u i)", "start": [723, 1], "end": [729, 38], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.inf_eq", "code": "protected theorem inf_eq {u\u2081 u\u2082 : UniformSpace \u03b3} :\n    \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, u\u2081 \u2293 u\u2082) = \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, u\u2081) \u2293 \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, u\u2082)", "start": [732, 1], "end": [738, 18], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.comap_eq", "code": "protected theorem comap_eq {f : \u03b3 \u2192 \u03b2} :\n    \ud835\udcb1(\u03b1, \u03b3, \ud835\udd16, \u2039UniformSpace \u03b2\u203a.comap f) = \ud835\udcb1(\u03b1, \u03b2, \ud835\udd16, _).comap ((\u00b7 \u2218 \u00b7) f)", "start": [741, 1], "end": [749, 6], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.postcomp_uniformContinuous", "code": "protected theorem postcomp_uniformContinuous [UniformSpace \u03b3] {f : \u03b3 \u2192 \u03b2}\n    (hf : UniformContinuous f) : UniformContinuous (ofFun \ud835\udd16 \u2218 (\u00b7 \u2218 \u00b7) f \u2218 toFun \ud835\udd16)", "start": [753, 1], "end": [762, 100], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.postcomp_uniformInducing", "code": "protected theorem postcomp_uniformInducing [UniformSpace \u03b3] {f : \u03b3 \u2192 \u03b2} (hf : UniformInducing f) :\n    UniformInducing (ofFun \ud835\udd16 \u2218 (\u00b7 \u2218 \u00b7) f \u2218 toFun \ud835\udd16)", "start": [765, 1], "end": [779, 6], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.congrRight", "code": "protected def congrRight [UniformSpace \u03b3] (e : \u03b3 \u2243\u1d64 \u03b2) : (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b3) \u2243\u1d64 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) :=\n  {\n    Equiv.piCongrRight fun _a =>\n      e.toEquiv with\n    uniformContinuous_toFun := UniformOnFun.postcomp_uniformContinuous e.uniformContinuous\n    uniformContinuous_invFun := UniformOnFun.postcomp_uniformContinuous e.symm.uniformContinuous }", "start": [782, 1], "end": [789, 99], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.precomp_uniformContinuous", "code": "protected theorem precomp_uniformContinuous {\ud835\udd17 : Set (Set \u03b3)} {f : \u03b3 \u2192 \u03b1}\n    (hf : \ud835\udd17 \u2286 image f \u207b\u00b9' \ud835\udd16) :\n    UniformContinuous fun g : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2 => ofFun \ud835\udd17 (g \u2218 f)", "start": [792, 1], "end": [822, 45], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.congrLeft", "code": "protected def congrLeft {\ud835\udd17 : Set (Set \u03b3)} (e : \u03b3 \u2243 \u03b1) (he : \ud835\udd17 \u2286 image e \u207b\u00b9' \ud835\udd16)\n    (he' : \ud835\udd16 \u2286 preimage e \u207b\u00b9' \ud835\udd17) : (\u03b3 \u2192\u1d64[\ud835\udd17] \u03b2) \u2243\u1d64 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) :=\n  { Equiv.arrowCongr e\n      (Equiv.refl\n        _) with\n    uniformContinuous_toFun :=\n      UniformOnFun.precomp_uniformContinuous\n        (by\n          intro s hs\n          change e.symm '' s \u2208 \ud835\udd17\n          rw [\u2190 preimage_equiv_eq_image_symm]\n          exact he' hs)\n    uniformContinuous_invFun := UniformOnFun.precomp_uniformContinuous he }", "start": [825, 1], "end": [839, 76], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.t2Space_of_covering", "code": "theorem t2Space_of_covering [T2Space \u03b2] (h : \u22c3\u2080 \ud835\udd16 = univ) : T2Space (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2)", "start": [842, 1], "end": [849, 95], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformContinuous_toFun", "code": "protected theorem uniformContinuous_toFun (h : \u22c3\u2080 \ud835\udd16 = univ) :\n    UniformContinuous (toFun \ud835\udd16 : (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) \u2192 \u03b1 \u2192 \u03b2)", "start": [852, 1], "end": [862, 49], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.tendsto_iff_tendstoUniformlyOn", "code": "protected theorem tendsto_iff_tendstoUniformlyOn {F : \u03b9 \u2192 \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2} {f : \u03b1 \u2192\u1d64[\ud835\udd16] \u03b2} :\n    Tendsto F p (\ud835\udcdd f) \u2194 \u2200 s \u2208 \ud835\udd16, TendstoUniformlyOn F f p s", "start": [865, 1], "end": [875, 6], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformEquivProdArrow", "code": "protected def uniformEquivProdArrow [UniformSpace \u03b3] :\n    (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2 \u00d7 \u03b3) \u2243\u1d64 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2) \u00d7 (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b3) :=\n  ((UniformOnFun.ofFun \ud835\udd16).symm.trans <|\n    (Equiv.arrowProdEquivProdArrow _ _ _).trans <|\n      (UniformOnFun.ofFun \ud835\udd16).prodCongr (UniformOnFun.ofFun \ud835\udd16)).toUniformEquivOfUniformInducing $ by\n      constructor\n      rw [uniformity_prod, comap_inf, comap_comap, comap_comap]\n      have H := @UniformOnFun.inf_eq \u03b1 (\u03b2 \u00d7 \u03b3) \ud835\udd16\n        (UniformSpace.comap Prod.fst \u2039_\u203a) (UniformSpace.comap Prod.snd \u2039_\u203a)\n      apply_fun (fun u \u21a6 @uniformity (\u03b1 \u2192\u1d64[\ud835\udd16] \u03b2 \u00d7 \u03b3) u) at H\n      convert H.symm using 1\n      rw [UniformOnFun.comap_eq, UniformOnFun.comap_eq]\n      erw [inf_uniformity]\n      rw [uniformity_comap, uniformity_comap]\n      rfl", "start": [878, 1], "end": [901, 10], "kind": "commanddeclaration"}, {"full_name": "UniformOnFun.uniformEquivPiComm", "code": "protected def uniformEquivPiComm : (\u03b1 \u2192\u1d64[\ud835\udd16] ((i:\u03b9) \u2192 \u03b4 i)) \u2243\u1d64 ((i:\u03b9) \u2192 \u03b1 \u2192\u1d64[\ud835\udd16] \u03b4 i) :=\n  @Equiv.toUniformEquivOfUniformInducing (\u03b1 \u2192\u1d64[\ud835\udd16] ((i:\u03b9) \u2192 \u03b4 i)) ((i:\u03b9) \u2192 \u03b1 \u2192\u1d64[\ud835\udd16] \u03b4 i)\n      _ _ (Equiv.piComm _) $ by\n    constructor\n    change comap (Prod.map Function.swap Function.swap) _ = _\n    erw [\u2190 uniformity_comap]\n    congr\n    rw [Pi.uniformSpace, UniformSpace.ofCoreEq_toCore, Pi.uniformSpace,\n      UniformSpace.ofCoreEq_toCore, UniformSpace.comap_iInf, UniformOnFun.iInf_eq]\n    refine' iInf_congr fun i => _\n    rw [\u2190 UniformSpace.comap_comap, UniformOnFun.comap_eq]\n    rfl", "start": [907, 1], "end": [927, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/LocalExtr.lean", "imports": ["Mathlib/Order/Filter/Extr.lean", "Mathlib/Topology/ContinuousOn.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLocalMinOn", "code": "def IsLocalMinOn :=\n  IsMinFilter f (\ud835\udcdd[s] a) a", "start": [46, 1], "end": [48, 27], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn", "code": "def IsLocalMaxOn :=\n  IsMaxFilter f (\ud835\udcdd[s] a) a", "start": [51, 1], "end": [53, 27], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn", "code": "def IsLocalExtrOn :=\n  IsExtrFilter f (\ud835\udcdd[s] a) a", "start": [56, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin", "code": "def IsLocalMin :=\n  IsMinFilter f (\ud835\udcdd a) a", "start": [61, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax", "code": "def IsLocalMax :=\n  IsMaxFilter f (\ud835\udcdd a) a", "start": [66, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr", "code": "def IsLocalExtr :=\n  IsExtrFilter f (\ud835\udcdd a) a", "start": [71, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.elim", "code": "theorem IsLocalExtrOn.elim {p : Prop} :\n    IsLocalExtrOn f s a \u2192 (IsLocalMinOn f s a \u2192 p) \u2192 (IsLocalMaxOn f s a \u2192 p) \u2192 p", "start": [78, 1], "end": [80, 10], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.elim", "code": "theorem IsLocalExtr.elim {p : Prop} :\n    IsLocalExtr f a \u2192 (IsLocalMin f a \u2192 p) \u2192 (IsLocalMax f a \u2192 p) \u2192 p", "start": [83, 1], "end": [85, 10], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.on", "code": "theorem IsLocalMin.on (h : IsLocalMin f a) (s) : IsLocalMinOn f s a", "start": [90, 1], "end": [91, 17], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.on", "code": "theorem IsLocalMax.on (h : IsLocalMax f a) (s) : IsLocalMaxOn f s a", "start": [94, 1], "end": [95, 17], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.on", "code": "theorem IsLocalExtr.on (h : IsLocalExtr f a) (s) : IsLocalExtrOn f s a", "start": [98, 1], "end": [99, 17], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.on_subset", "code": "theorem IsLocalMinOn.on_subset {t : Set \u03b1} (hf : IsLocalMinOn f t a) (h : s \u2286 t) :\n    IsLocalMinOn f s a", "start": [102, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.on_subset", "code": "theorem IsLocalMaxOn.on_subset {t : Set \u03b1} (hf : IsLocalMaxOn f t a) (h : s \u2286 t) :\n    IsLocalMaxOn f s a", "start": [107, 1], "end": [109, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.on_subset", "code": "theorem IsLocalExtrOn.on_subset {t : Set \u03b1} (hf : IsLocalExtrOn f t a) (h : s \u2286 t) :\n    IsLocalExtrOn f s a", "start": [112, 1], "end": [114, 40], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.inter", "code": "theorem IsLocalMinOn.inter (hf : IsLocalMinOn f s a) (t) : IsLocalMinOn f (s \u2229 t) a", "start": [117, 1], "end": [118, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.inter", "code": "theorem IsLocalMaxOn.inter (hf : IsLocalMaxOn f s a) (t) : IsLocalMaxOn f (s \u2229 t) a", "start": [121, 1], "end": [122, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.inter", "code": "theorem IsLocalExtrOn.inter (hf : IsLocalExtrOn f s a) (t) : IsLocalExtrOn f (s \u2229 t) a", "start": [125, 1], "end": [126, 39], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.localize", "code": "theorem IsMinOn.localize (hf : IsMinOn f s a) : IsLocalMinOn f s a", "start": [129, 1], "end": [130, 33], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.localize", "code": "theorem IsMaxOn.localize (hf : IsMaxOn f s a) : IsLocalMaxOn f s a", "start": [133, 1], "end": [134, 33], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.localize", "code": "theorem IsExtrOn.localize (hf : IsExtrOn f s a) : IsLocalExtrOn f s a", "start": [137, 1], "end": [138, 33], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.isLocalMin", "code": "theorem IsLocalMinOn.isLocalMin (hf : IsLocalMinOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalMin f a", "start": [141, 1], "end": [143, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.isLocalMax", "code": "theorem IsLocalMaxOn.isLocalMax (hf : IsLocalMaxOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalMax f a", "start": [146, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.isLocalExtr", "code": "theorem IsLocalExtrOn.isLocalExtr (hf : IsLocalExtrOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalExtr f a", "start": [151, 1], "end": [152, 84], "kind": "commanddeclaration"}, {"full_name": "IsMinOn.isLocalMin", "code": "theorem IsMinOn.isLocalMin (hf : IsMinOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalMin f a", "start": [155, 1], "end": [156, 28], "kind": "commanddeclaration"}, {"full_name": "IsMaxOn.isLocalMax", "code": "theorem IsMaxOn.isLocalMax (hf : IsMaxOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalMax f a", "start": [159, 1], "end": [160, 28], "kind": "commanddeclaration"}, {"full_name": "IsExtrOn.isLocalExtr", "code": "theorem IsExtrOn.isLocalExtr (hf : IsExtrOn f s a) (hs : s \u2208 \ud835\udcdd a) : IsLocalExtr f a", "start": [163, 1], "end": [164, 29], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.not_nhds_le_map", "code": "theorem IsLocalMinOn.not_nhds_le_map [TopologicalSpace \u03b2] (hf : IsLocalMinOn f s a)\n    [NeBot (\ud835\udcdd[<] f a)] : \u00ac\ud835\udcdd (f a) \u2264 map f (\ud835\udcdd[s] a)", "start": [167, 1], "end": [171, 19], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.not_nhds_le_map", "code": "theorem IsLocalMaxOn.not_nhds_le_map [TopologicalSpace \u03b2] (hf : IsLocalMaxOn f s a)\n    [NeBot (\ud835\udcdd[>] f a)] : \u00ac\ud835\udcdd (f a) \u2264 map f (\ud835\udcdd[s] a)", "start": [174, 1], "end": [176, 59], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.not_nhds_le_map", "code": "theorem IsLocalExtrOn.not_nhds_le_map [TopologicalSpace \u03b2] (hf : IsLocalExtrOn f s a)\n    [NeBot (\ud835\udcdd[<] f a)] [NeBot (\ud835\udcdd[>] f a)] : \u00ac\ud835\udcdd (f a) \u2264 map f (\ud835\udcdd[s] a)", "start": [179, 1], "end": [181, 66], "kind": "commanddeclaration"}, {"full_name": "isLocalMinOn_const", "code": "theorem isLocalMinOn_const {b : \u03b2} : IsLocalMinOn (fun _ => b) s a", "start": [187, 1], "end": [188, 20], "kind": "commanddeclaration"}, {"full_name": "isLocalMaxOn_const", "code": "theorem isLocalMaxOn_const {b : \u03b2} : IsLocalMaxOn (fun _ => b) s a", "start": [191, 1], "end": [192, 20], "kind": "commanddeclaration"}, {"full_name": "isLocalExtrOn_const", "code": "theorem isLocalExtrOn_const {b : \u03b2} : IsLocalExtrOn (fun _ => b) s a", "start": [195, 1], "end": [196, 21], "kind": "commanddeclaration"}, {"full_name": "isLocalMin_const", "code": "theorem isLocalMin_const {b : \u03b2} : IsLocalMin (fun _ => b) a", "start": [199, 1], "end": [200, 20], "kind": "commanddeclaration"}, {"full_name": "isLocalMax_const", "code": "theorem isLocalMax_const {b : \u03b2} : IsLocalMax (fun _ => b) a", "start": [203, 1], "end": [204, 20], "kind": "commanddeclaration"}, {"full_name": "isLocalExtr_const", "code": "theorem isLocalExtr_const {b : \u03b2} : IsLocalExtr (fun _ => b) a", "start": [207, 1], "end": [208, 21], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.comp_mono", "code": "nonrec theorem IsLocalMin.comp_mono (hf : IsLocalMin f a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalMin (g \u2218 f) a", "start": [213, 1], "end": [215, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.comp_mono", "code": "nonrec theorem IsLocalMax.comp_mono (hf : IsLocalMax f a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalMax (g \u2218 f) a", "start": [218, 1], "end": [220, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.comp_mono", "code": "nonrec theorem IsLocalExtr.comp_mono (hf : IsLocalExtr f a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalExtr (g \u2218 f) a", "start": [223, 1], "end": [225, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.comp_antitone", "code": "nonrec theorem IsLocalMin.comp_antitone (hf : IsLocalMin f a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalMax (g \u2218 f) a", "start": [228, 1], "end": [230, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.comp_antitone", "code": "nonrec theorem IsLocalMax.comp_antitone (hf : IsLocalMax f a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalMin (g \u2218 f) a", "start": [233, 1], "end": [235, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.comp_antitone", "code": "nonrec theorem IsLocalExtr.comp_antitone (hf : IsLocalExtr f a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalExtr (g \u2218 f) a", "start": [238, 1], "end": [240, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.comp_mono", "code": "nonrec theorem IsLocalMinOn.comp_mono (hf : IsLocalMinOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalMinOn (g \u2218 f) s a", "start": [243, 1], "end": [245, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.comp_mono", "code": "nonrec theorem IsLocalMaxOn.comp_mono (hf : IsLocalMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalMaxOn (g \u2218 f) s a", "start": [248, 1], "end": [250, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.comp_mono", "code": "nonrec theorem IsLocalExtrOn.comp_mono (hf : IsLocalExtrOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\n    IsLocalExtrOn (g \u2218 f) s a", "start": [253, 1], "end": [255, 18], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.comp_antitone", "code": "nonrec theorem IsLocalMinOn.comp_antitone (hf : IsLocalMinOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalMaxOn (g \u2218 f) s a", "start": [258, 1], "end": [260, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.comp_antitone", "code": "nonrec theorem IsLocalMaxOn.comp_antitone (hf : IsLocalMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Antitone g) :\n    IsLocalMinOn (g \u2218 f) s a", "start": [263, 1], "end": [265, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.comp_antitone", "code": "nonrec theorem IsLocalExtrOn.comp_antitone (hf : IsLocalExtrOn f s a) {g : \u03b2 \u2192 \u03b3}\n    (hg : Antitone g) : IsLocalExtrOn (g \u2218 f) s a", "start": [268, 1], "end": [270, 22], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.bicomp_mono", "code": "nonrec theorem IsLocalMin.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsLocalMin f a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsLocalMin g a) : IsLocalMin (fun x => op (f x) (g x)) a", "start": [273, 1], "end": [276, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.bicomp_mono", "code": "nonrec theorem IsLocalMax.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsLocalMax f a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsLocalMax g a) : IsLocalMax (fun x => op (f x) (g x)) a", "start": [279, 1], "end": [282, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.bicomp_mono", "code": "nonrec theorem IsLocalMinOn.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsLocalMinOn f s a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsLocalMinOn g s a) : IsLocalMinOn (fun x => op (f x) (g x)) s a", "start": [286, 1], "end": [289, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.bicomp_mono", "code": "nonrec theorem IsLocalMaxOn.bicomp_mono [Preorder \u03b4] {op : \u03b2 \u2192 \u03b3 \u2192 \u03b4}\n    (hop : ((\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7) \u21d2 (\u00b7 \u2264 \u00b7)) op op) (hf : IsLocalMaxOn f s a) {g : \u03b1 \u2192 \u03b3}\n    (hg : IsLocalMaxOn g s a) : IsLocalMaxOn (fun x => op (f x) (g x)) s a", "start": [292, 1], "end": [295, 24], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.comp_continuous", "code": "theorem IsLocalMin.comp_continuous [TopologicalSpace \u03b4] {g : \u03b4 \u2192 \u03b1} {b : \u03b4}\n    (hf : IsLocalMin f (g b)) (hg : ContinuousAt g b) : IsLocalMin (f \u2218 g) b", "start": [301, 1], "end": [303, 8], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.comp_continuous", "code": "theorem IsLocalMax.comp_continuous [TopologicalSpace \u03b4] {g : \u03b4 \u2192 \u03b1} {b : \u03b4}\n    (hf : IsLocalMax f (g b)) (hg : ContinuousAt g b) : IsLocalMax (f \u2218 g) b", "start": [306, 1], "end": [308, 8], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.comp_continuous", "code": "theorem IsLocalExtr.comp_continuous [TopologicalSpace \u03b4] {g : \u03b4 \u2192 \u03b1} {b : \u03b4}\n    (hf : IsLocalExtr f (g b)) (hg : ContinuousAt g b) : IsLocalExtr (f \u2218 g) b", "start": [311, 1], "end": [313, 21], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.comp_continuousOn", "code": "theorem IsLocalMin.comp_continuousOn [TopologicalSpace \u03b4] {s : Set \u03b4} {g : \u03b4 \u2192 \u03b1} {b : \u03b4}\n    (hf : IsLocalMin f (g b)) (hg : ContinuousOn g s) (hb : b \u2208 s) : IsLocalMinOn (f \u2218 g) s b", "start": [316, 1], "end": [318, 28], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.comp_continuousOn", "code": "theorem IsLocalMax.comp_continuousOn [TopologicalSpace \u03b4] {s : Set \u03b4} {g : \u03b4 \u2192 \u03b1} {b : \u03b4}\n    (hf : IsLocalMax f (g b)) (hg : ContinuousOn g s) (hb : b \u2208 s) : IsLocalMaxOn (f \u2218 g) s b", "start": [321, 1], "end": [323, 28], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.comp_continuousOn", "code": "theorem IsLocalExtr.comp_continuousOn [TopologicalSpace \u03b4] {s : Set \u03b4} (g : \u03b4 \u2192 \u03b1) {b : \u03b4}\n    (hf : IsLocalExtr f (g b)) (hg : ContinuousOn g s) (hb : b \u2208 s) : IsLocalExtrOn (f \u2218 g) s b", "start": [326, 1], "end": [329, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.comp_continuousOn", "code": "theorem IsLocalMinOn.comp_continuousOn [TopologicalSpace \u03b4] {t : Set \u03b1} {s : Set \u03b4} {g : \u03b4 \u2192 \u03b1}\n    {b : \u03b4} (hf : IsLocalMinOn f t (g b)) (hst : s \u2286 g \u207b\u00b9' t) (hg : ContinuousOn g s) (hb : b \u2208 s) :\n    IsLocalMinOn (f \u2218 g) s b", "start": [332, 1], "end": [337, 63], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.comp_continuousOn", "code": "theorem IsLocalMaxOn.comp_continuousOn [TopologicalSpace \u03b4] {t : Set \u03b1} {s : Set \u03b4} {g : \u03b4 \u2192 \u03b1}\n    {b : \u03b4} (hf : IsLocalMaxOn f t (g b)) (hst : s \u2286 g \u207b\u00b9' t) (hg : ContinuousOn g s) (hb : b \u2208 s) :\n    IsLocalMaxOn (f \u2218 g) s b", "start": [340, 1], "end": [345, 63], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.comp_continuousOn", "code": "theorem IsLocalExtrOn.comp_continuousOn [TopologicalSpace \u03b4] {t : Set \u03b1} {s : Set \u03b4} (g : \u03b4 \u2192 \u03b1)\n    {b : \u03b4} (hf : IsLocalExtrOn f t (g b)) (hst : s \u2286 g \u207b\u00b9' t) (hg : ContinuousOn g s)\n    (hb : b \u2208 s) : IsLocalExtrOn (f \u2218 g) s b", "start": [348, 1], "end": [352, 57], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.add", "code": "nonrec theorem IsLocalMin.add (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => f x + g x) a", "start": [364, 1], "end": [366, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.add", "code": "nonrec theorem IsLocalMax.add (hf : IsLocalMax f a) (hg : IsLocalMax g a) :\n    IsLocalMax (fun x => f x + g x) a", "start": [369, 1], "end": [371, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.add", "code": "nonrec theorem IsLocalMinOn.add (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => f x + g x) s a", "start": [374, 1], "end": [376, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.add", "code": "nonrec theorem IsLocalMaxOn.add (hf : IsLocalMaxOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMaxOn (fun x => f x + g x) s a", "start": [379, 1], "end": [381, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.neg", "code": "nonrec theorem IsLocalMin.neg (hf : IsLocalMin f a) : IsLocalMax (fun x => -f x) a", "start": [393, 1], "end": [394, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.neg", "code": "nonrec theorem IsLocalMax.neg (hf : IsLocalMax f a) : IsLocalMin (fun x => -f x) a", "start": [397, 1], "end": [398, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.neg", "code": "nonrec theorem IsLocalExtr.neg (hf : IsLocalExtr f a) : IsLocalExtr (fun x => -f x) a", "start": [401, 1], "end": [402, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.neg", "code": "nonrec theorem IsLocalMinOn.neg (hf : IsLocalMinOn f s a) : IsLocalMaxOn (fun x => -f x) s a", "start": [405, 1], "end": [406, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.neg", "code": "nonrec theorem IsLocalMaxOn.neg (hf : IsLocalMaxOn f s a) : IsLocalMinOn (fun x => -f x) s a", "start": [409, 1], "end": [410, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.neg", "code": "nonrec theorem IsLocalExtrOn.neg (hf : IsLocalExtrOn f s a) : IsLocalExtrOn (fun x => -f x) s a", "start": [413, 1], "end": [414, 9], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.sub", "code": "nonrec theorem IsLocalMin.sub (hf : IsLocalMin f a) (hg : IsLocalMax g a) :\n    IsLocalMin (fun x => f x - g x) a", "start": [417, 1], "end": [419, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.sub", "code": "nonrec theorem IsLocalMax.sub (hf : IsLocalMax f a) (hg : IsLocalMin g a) :\n    IsLocalMax (fun x => f x - g x) a", "start": [422, 1], "end": [424, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.sub", "code": "nonrec theorem IsLocalMinOn.sub (hf : IsLocalMinOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMinOn (fun x => f x - g x) s a", "start": [427, 1], "end": [429, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.sub", "code": "nonrec theorem IsLocalMaxOn.sub (hf : IsLocalMaxOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMaxOn (fun x => f x - g x) s a", "start": [432, 1], "end": [434, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.sup", "code": "nonrec theorem IsLocalMin.sup (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => f x \u2294 g x) a", "start": [446, 1], "end": [448, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.sup", "code": "nonrec theorem IsLocalMax.sup (hf : IsLocalMax f a) (hg : IsLocalMax g a) :\n    IsLocalMax (fun x => f x \u2294 g x) a", "start": [451, 1], "end": [453, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.sup", "code": "nonrec theorem IsLocalMinOn.sup (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => f x \u2294 g x) s a", "start": [456, 1], "end": [458, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.sup", "code": "nonrec theorem IsLocalMaxOn.sup (hf : IsLocalMaxOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMaxOn (fun x => f x \u2294 g x) s a", "start": [461, 1], "end": [463, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.inf", "code": "nonrec theorem IsLocalMin.inf (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => f x \u2293 g x) a", "start": [472, 1], "end": [474, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.inf", "code": "nonrec theorem IsLocalMax.inf (hf : IsLocalMax f a) (hg : IsLocalMax g a) :\n    IsLocalMax (fun x => f x \u2293 g x) a", "start": [477, 1], "end": [479, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.inf", "code": "nonrec theorem IsLocalMinOn.inf (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => f x \u2293 g x) s a", "start": [482, 1], "end": [484, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.inf", "code": "nonrec theorem IsLocalMaxOn.inf (hf : IsLocalMaxOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMaxOn (fun x => f x \u2293 g x) s a", "start": [487, 1], "end": [489, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.min", "code": "nonrec theorem IsLocalMin.min (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => min (f x) (g x)) a", "start": [501, 1], "end": [503, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.min", "code": "nonrec theorem IsLocalMax.min (hf : IsLocalMax f a) (hg : IsLocalMax g a) :\n    IsLocalMax (fun x => min (f x) (g x)) a", "start": [506, 1], "end": [508, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.min", "code": "nonrec theorem IsLocalMinOn.min (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => min (f x) (g x)) s a", "start": [511, 1], "end": [513, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.min", "code": "nonrec theorem IsLocalMaxOn.min (hf : IsLocalMaxOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMaxOn (fun x => min (f x) (g x)) s a", "start": [516, 1], "end": [518, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.max", "code": "nonrec theorem IsLocalMin.max (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\n    IsLocalMin (fun x => max (f x) (g x)) a", "start": [521, 1], "end": [523, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.max", "code": "nonrec theorem IsLocalMax.max (hf : IsLocalMax f a) (hg : IsLocalMax g a) :\n    IsLocalMax (fun x => max (f x) (g x)) a", "start": [526, 1], "end": [528, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.max", "code": "nonrec theorem IsLocalMinOn.max (hf : IsLocalMinOn f s a) (hg : IsLocalMinOn g s a) :\n    IsLocalMinOn (fun x => max (f x) (g x)) s a", "start": [531, 1], "end": [533, 12], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.max", "code": "nonrec theorem IsLocalMaxOn.max (hf : IsLocalMaxOn f s a) (hg : IsLocalMaxOn g s a) :\n    IsLocalMaxOn (fun x => max (f x) (g x)) s a", "start": [536, 1], "end": [538, 12], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isLocalMaxOn", "code": "theorem Filter.EventuallyLE.isLocalMaxOn {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hle : g \u2264\u1da0[\ud835\udcdd[s] a] f)\n    (hfga : f a = g a) (h : IsLocalMaxOn f s a) : IsLocalMaxOn g s a", "start": [550, 1], "end": [552, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalMaxOn.congr", "code": "nonrec theorem IsLocalMaxOn.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMaxOn f s a)\n    (heq : f =\u1da0[\ud835\udcdd[s] a] g) (hmem : a \u2208 s) : IsLocalMaxOn g s a", "start": [555, 1], "end": [557, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalMaxOn_iff", "code": "theorem Filter.EventuallyEq.isLocalMaxOn_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd[s] a] g)\n    (hmem : a \u2208 s) : IsLocalMaxOn f s a \u2194 IsLocalMaxOn g s a", "start": [560, 1], "end": [562, 51], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isLocalMinOn", "code": "theorem Filter.EventuallyLE.isLocalMinOn {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hle : f \u2264\u1da0[\ud835\udcdd[s] a] g)\n    (hfga : f a = g a) (h : IsLocalMinOn f s a) : IsLocalMinOn g s a", "start": [565, 1], "end": [567, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalMinOn.congr", "code": "nonrec theorem IsLocalMinOn.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMinOn f s a)\n    (heq : f =\u1da0[\ud835\udcdd[s] a] g) (hmem : a \u2208 s) : IsLocalMinOn g s a", "start": [570, 1], "end": [572, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalMinOn_iff", "code": "nonrec theorem Filter.EventuallyEq.isLocalMinOn_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd[s] a] g)\n    (hmem : a \u2208 s) : IsLocalMinOn f s a \u2194 IsLocalMinOn g s a", "start": [575, 1], "end": [577, 51], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtrOn.congr", "code": "nonrec theorem IsLocalExtrOn.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalExtrOn f s a)\n    (heq : f =\u1da0[\ud835\udcdd[s] a] g) (hmem : a \u2208 s) : IsLocalExtrOn g s a", "start": [580, 1], "end": [582, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalExtrOn_iff", "code": "theorem Filter.EventuallyEq.isLocalExtrOn_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd[s] a] g)\n    (hmem : a \u2208 s) : IsLocalExtrOn f s a \u2194 IsLocalExtrOn g s a", "start": [585, 1], "end": [587, 52], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isLocalMax", "code": "theorem Filter.EventuallyLE.isLocalMax {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hle : g \u2264\u1da0[\ud835\udcdd a] f) (hfga : f a = g a)\n    (h : IsLocalMax f a) : IsLocalMax g a", "start": [590, 1], "end": [592, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalMax.congr", "code": "nonrec theorem IsLocalMax.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMax f a) (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalMax g a", "start": [595, 1], "end": [597, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalMax_iff", "code": "theorem Filter.EventuallyEq.isLocalMax_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalMax f a \u2194 IsLocalMax g a", "start": [600, 1], "end": [602, 37], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyLE.isLocalMin", "code": "theorem Filter.EventuallyLE.isLocalMin {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (hle : f \u2264\u1da0[\ud835\udcdd a] g) (hfga : f a = g a)\n    (h : IsLocalMin f a) : IsLocalMin g a", "start": [605, 1], "end": [607, 25], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.congr", "code": "nonrec theorem IsLocalMin.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMin f a) (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalMin g a", "start": [610, 1], "end": [612, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalMin_iff", "code": "theorem Filter.EventuallyEq.isLocalMin_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalMin f a \u2194 IsLocalMin g a", "start": [615, 1], "end": [617, 37], "kind": "commanddeclaration"}, {"full_name": "IsLocalExtr.congr", "code": "nonrec theorem IsLocalExtr.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalExtr f a) (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalExtr g a", "start": [620, 1], "end": [622, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.isLocalExtr_iff", "code": "theorem Filter.EventuallyEq.isLocalExtr_iff {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (heq : f =\u1da0[\ud835\udcdd a] g) :\n    IsLocalExtr f a \u2194 IsLocalExtr g a", "start": [625, 1], "end": [627, 38], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/Order/CompleteLatticeIntervals.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "intermediate_value_univ\u2082", "code": "theorem intermediate_value_univ\u2082 [PreconnectedSpace X] {a b : X} {f g : X \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) (ha : f a \u2264 g a) (hb : g b \u2264 f b) : \u2203 x, f x = g x", "start": [63, 1], "end": [71, 33], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_univ\u2082_eventually\u2081", "code": "theorem intermediate_value_univ\u2082_eventually\u2081 [PreconnectedSpace X] {a : X} {l : Filter X} [NeBot l]\n    {f g : X \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) (ha : f a \u2264 g a) (he : g \u2264\u1da0[l] f) :\n    \u2203 x, f x = g x", "start": [74, 1], "end": [77, 63], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_univ\u2082_eventually\u2082", "code": "theorem intermediate_value_univ\u2082_eventually\u2082 [PreconnectedSpace X] {l\u2081 l\u2082 : Filter X} [NeBot l\u2081]\n    [NeBot l\u2082] {f g : X \u2192 \u03b1} (hf : Continuous f) (hg : Continuous g) (he\u2081 : f \u2264\u1da0[l\u2081] g)\n    (he\u2082 : g \u2264\u1da0[l\u2082] f) : \u2203 x, f x = g x", "start": [80, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value\u2082", "code": "theorem IsPreconnected.intermediate_value\u2082 {s : Set X} (hs : IsPreconnected s) {a b : X}\n    (ha : a \u2208 s) (hb : b \u2208 s) {f g : X \u2192 \u03b1} (hf : ContinuousOn f s) (hg : ContinuousOn g s)\n    (ha' : f a \u2264 g a) (hb' : g b \u2264 f b) : \u2203 x \u2208 s, f x = g x", "start": [88, 1], "end": [98, 15], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value\u2082_eventually\u2081", "code": "theorem IsPreconnected.intermediate_value\u2082_eventually\u2081 {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a \u2208 s) [NeBot l] (hl : l \u2264 \ud835\udcdf s) {f g : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    (hg : ContinuousOn g s) (ha' : f a \u2264 g a) (he : g \u2264\u1da0[l] f) : \u2203 x \u2208 s, f x = g x", "start": [101, 1], "end": [108, 23], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value\u2082_eventually\u2082", "code": "theorem IsPreconnected.intermediate_value\u2082_eventually\u2082 {s : Set X} (hs : IsPreconnected s)\n    {l\u2081 l\u2082 : Filter X} [NeBot l\u2081] [NeBot l\u2082] (hl\u2081 : l\u2081 \u2264 \ud835\udcdf s) (hl\u2082 : l\u2082 \u2264 \ud835\udcdf s) {f g : X \u2192 \u03b1}\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (he\u2081 : f \u2264\u1da0[l\u2081] g) (he\u2082 : g \u2264\u1da0[l\u2082] f) :\n    \u2203 x \u2208 s, f x = g x", "start": [111, 1], "end": [120, 23], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value", "code": "theorem IsPreconnected.intermediate_value {s : Set X} (hs : IsPreconnected s) {a b : X} (ha : a \u2208 s)\n    (hb : b \u2208 s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s) : Icc (f a) (f b) \u2286 f '' s", "start": [123, 1], "end": [126, 63], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Ico", "code": "theorem IsPreconnected.intermediate_value_Ico {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a \u2208 s) [NeBot l] (hl : l \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s) {v : \u03b1}\n    (ht : Tendsto f l (\ud835\udcdd v)) : Ico (f a) v \u2286 f '' s", "start": [129, 1], "end": [133, 41], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Ioc", "code": "theorem IsPreconnected.intermediate_value_Ioc {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a \u2208 s) [NeBot l] (hl : l \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s) {v : \u03b1}\n    (ht : Tendsto f l (\ud835\udcdd v)) : Ioc v (f a) \u2286 f '' s", "start": [136, 1], "end": [140, 77], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Ioo", "code": "theorem IsPreconnected.intermediate_value_Ioo {s : Set X} (hs : IsPreconnected s) {l\u2081 l\u2082 : Filter X}\n    [NeBot l\u2081] [NeBot l\u2082] (hl\u2081 : l\u2081 \u2264 \ud835\udcdf s) (hl\u2082 : l\u2082 \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    {v\u2081 v\u2082 : \u03b1} (ht\u2081 : Tendsto f l\u2081 (\ud835\udcdd v\u2081)) (ht\u2082 : Tendsto f l\u2082 (\ud835\udcdd v\u2082)) :\n    Ioo v\u2081 v\u2082 \u2286 f '' s", "start": [143, 1], "end": [148, 80], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Ici", "code": "theorem IsPreconnected.intermediate_value_Ici {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a \u2208 s) [NeBot l] (hl : l \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atTop) : Ici (f a) \u2286 f '' s", "start": [151, 1], "end": [154, 90], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Iic", "code": "theorem IsPreconnected.intermediate_value_Iic {s : Set X} (hs : IsPreconnected s) {a : X}\n    {l : Filter X} (ha : a \u2208 s) [NeBot l] (hl : l \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    (ht : Tendsto f l atBot) : Iic (f a) \u2286 f '' s", "start": [157, 1], "end": [161, 35], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Ioi", "code": "theorem IsPreconnected.intermediate_value_Ioi {s : Set X} (hs : IsPreconnected s) {l\u2081 l\u2082 : Filter X}\n    [NeBot l\u2081] [NeBot l\u2082] (hl\u2081 : l\u2081 \u2264 \ud835\udcdf s) (hl\u2082 : l\u2082 \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    {v : \u03b1} (ht\u2081 : Tendsto f l\u2081 (\ud835\udcdd v)) (ht\u2082 : Tendsto f l\u2082 atTop) : Ioi v \u2286 f '' s", "start": [164, 1], "end": [168, 64], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Iio", "code": "theorem IsPreconnected.intermediate_value_Iio {s : Set X} (hs : IsPreconnected s) {l\u2081 l\u2082 : Filter X}\n    [NeBot l\u2081] [NeBot l\u2082] (hl\u2081 : l\u2081 \u2264 \ud835\udcdf s) (hl\u2082 : l\u2082 \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    {v : \u03b1} (ht\u2081 : Tendsto f l\u2081 atBot) (ht\u2082 : Tendsto f l\u2082 (\ud835\udcdd v)) : Iio v \u2286 f '' s", "start": [171, 1], "end": [175, 40], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.intermediate_value_Iii", "code": "theorem IsPreconnected.intermediate_value_Iii {s : Set X} (hs : IsPreconnected s) {l\u2081 l\u2082 : Filter X}\n    [NeBot l\u2081] [NeBot l\u2082] (hl\u2081 : l\u2081 \u2264 \ud835\udcdf s) (hl\u2082 : l\u2082 \u2264 \ud835\udcdf s) {f : X \u2192 \u03b1} (hf : ContinuousOn f s)\n    (ht\u2081 : Tendsto f l\u2081 atBot) (ht\u2082 : Tendsto f l\u2082 atTop) : univ \u2286 f '' s", "start": [178, 1], "end": [182, 28], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_univ", "code": "theorem intermediate_value_univ [PreconnectedSpace X] (a b : X) {f : X \u2192 \u03b1} (hf : Continuous f) :\n    Icc (f a) (f b) \u2286 range f", "start": [186, 1], "end": [188, 100], "kind": "commanddeclaration"}, {"full_name": "mem_range_of_exists_le_of_exists_ge", "code": "theorem mem_range_of_exists_le_of_exists_ge [PreconnectedSpace X] {c : \u03b1} {f : X \u2192 \u03b1}\n    (hf : Continuous f) (h\u2081 : \u2203 a, f a \u2264 c) (h\u2082 : \u2203 b, c \u2264 f b) : c \u2208 range f", "start": [191, 1], "end": [194, 80], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.Icc_subset", "code": "theorem IsPreconnected.Icc_subset {s : Set \u03b1} (hs : IsPreconnected s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) : Icc a b \u2286 s", "start": [213, 1], "end": [216, 74], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.ordConnected", "code": "theorem IsPreconnected.ordConnected {s : Set \u03b1} (h : IsPreconnected s) : OrdConnected s", "start": [219, 1], "end": [220, 40], "kind": "commanddeclaration"}, {"full_name": "IsConnected.Icc_subset", "code": "theorem IsConnected.Icc_subset {s : Set \u03b1} (hs : IsConnected s) {a b : \u03b1} (ha : a \u2208 s)\n    (hb : b \u2208 s) : Icc a b \u2286 s", "start": [223, 1], "end": [226, 24], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.eq_univ_of_unbounded", "code": "theorem IsPreconnected.eq_univ_of_unbounded {s : Set \u03b1} (hs : IsPreconnected s) (hb : \u00acBddBelow s)\n    (ha : \u00acBddAbove s) : s = univ", "start": [229, 1], "end": [236, 55], "kind": "commanddeclaration"}, {"full_name": "IsConnected.Ioo_csInf_csSup_subset", "code": "theorem IsConnected.Ioo_csInf_csSup_subset {s : Set \u03b1} (hs : IsConnected s) (hb : BddBelow s)\n    (ha : BddAbove s) : Ioo (sInf s) (sSup s) \u2286 s", "start": [245, 1], "end": [251, 37], "kind": "commanddeclaration"}, {"full_name": "eq_Icc_csInf_csSup_of_connected_bdd_closed", "code": "theorem eq_Icc_csInf_csSup_of_connected_bdd_closed {s : Set \u03b1} (hc : IsConnected s)\n    (hb : BddBelow s) (ha : BddAbove s) (hcl : IsClosed s) : s = Icc (sInf s) (sSup s)", "start": [254, 1], "end": [257, 80], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.Ioi_csInf_subset", "code": "theorem IsPreconnected.Ioi_csInf_subset {s : Set \u03b1} (hs : IsPreconnected s) (hb : BddBelow s)\n    (ha : \u00acBddAbove s) : Ioi (sInf s) \u2286 s", "start": [260, 1], "end": [265, 37], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.Iio_csSup_subset", "code": "theorem IsPreconnected.Iio_csSup_subset {s : Set \u03b1} (hs : IsPreconnected s) (hb : \u00acBddBelow s)\n    (ha : BddAbove s) : Iio (sSup s) \u2286 s", "start": [268, 1], "end": [270, 56], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.mem_intervals", "code": "theorem IsPreconnected.mem_intervals {s : Set \u03b1} (hs : IsPreconnected s) :\n    s \u2208\n      ({Icc (sInf s) (sSup s), Ico (sInf s) (sSup s), Ioc (sInf s) (sSup s), Ioo (sInf s) (sSup s),\n          Ici (sInf s), Ioi (sInf s), Iic (sSup s), Iio (sSup s), univ, \u2205} :\n        Set (Set \u03b1))", "start": [273, 1], "end": [304, 49], "kind": "commanddeclaration"}, {"full_name": "setOf_isPreconnected_subset_of_ordered", "code": "theorem setOf_isPreconnected_subset_of_ordered :\n    { s : Set \u03b1 | IsPreconnected s } \u2286\n      (range (uncurry Icc) \u222a range (uncurry Ico) \u222a range (uncurry Ioc) \u222a range (uncurry Ioo)) \u222a\n      (range Ici \u222a range Ioi \u222a range Iic \u222a range Iio \u222a {univ, \u2205})", "start": [307, 1], "end": [328, 40], "kind": "commanddeclaration"}, {"full_name": "IsClosed.mem_of_ge_of_forall_exists_gt", "code": "theorem IsClosed.mem_of_ge_of_forall_exists_gt {a b : \u03b1} {s : Set \u03b1} (hs : IsClosed (s \u2229 Icc a b))\n    (ha : a \u2208 s) (hab : a \u2264 b) (hgt : \u2200 x \u2208 s \u2229 Ico a b, (s \u2229 Ioc x b).Nonempty) : b \u2208 s", "start": [339, 1], "end": [354, 90], "kind": "commanddeclaration"}, {"full_name": "IsClosed.Icc_subset_of_forall_exists_gt", "code": "theorem IsClosed.Icc_subset_of_forall_exists_gt {a b : \u03b1} {s : Set \u03b1} (hs : IsClosed (s \u2229 Icc a b))\n    (ha : a \u2208 s) (hgt : \u2200 x \u2208 s \u2229 Ico a b, \u2200 y \u2208 Ioi x, (s \u2229 Ioc x y).Nonempty) : Icc a b \u2286 s", "start": [357, 1], "end": [372, 60], "kind": "commanddeclaration"}, {"full_name": "IsClosed.Icc_subset_of_forall_mem_nhdsWithin", "code": "theorem IsClosed.Icc_subset_of_forall_mem_nhdsWithin {a b : \u03b1} {s : Set \u03b1}\n    (hs : IsClosed (s \u2229 Icc a b)) (ha : a \u2208 s) (hgt : \u2200 x \u2208 s \u2229 Ico a b, s \u2208 \ud835\udcdd[>] x) :\n    Icc a b \u2286 s", "start": [377, 1], "end": [387, 70], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Icc_aux", "code": "theorem isPreconnected_Icc_aux (x y : \u03b1) (s t : Set \u03b1) (hxy : x \u2264 y) (hs : IsClosed s)\n    (ht : IsClosed t) (hab : Icc a b \u2286 s \u222a t) (hx : x \u2208 Icc a b \u2229 s) (hy : y \u2208 Icc a b \u2229 t) :\n    (Icc a b \u2229 (s \u2229 t)).Nonempty", "start": [390, 1], "end": [405, 67], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Icc", "code": "theorem isPreconnected_Icc : IsPreconnected (Icc a b)", "start": [408, 1], "end": [418, 64], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_uIcc", "code": "theorem isPreconnected_uIcc : IsPreconnected (uIcc a b)", "start": [421, 1], "end": [422, 21], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.isPreconnected", "code": "theorem Set.OrdConnected.isPreconnected {s : Set \u03b1} (h : s.OrdConnected) : IsPreconnected s", "start": [425, 1], "end": [427, 88], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_iff_ordConnected", "code": "theorem isPreconnected_iff_ordConnected {s : Set \u03b1} : IsPreconnected s \u2194 OrdConnected s", "start": [430, 1], "end": [431, 65], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Ici", "code": "theorem isPreconnected_Ici : IsPreconnected (Ici a)", "start": [434, 1], "end": [435, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Iic", "code": "theorem isPreconnected_Iic : IsPreconnected (Iic a)", "start": [438, 1], "end": [439, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Iio", "code": "theorem isPreconnected_Iio : IsPreconnected (Iio a)", "start": [442, 1], "end": [443, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Ioi", "code": "theorem isPreconnected_Ioi : IsPreconnected (Ioi a)", "start": [446, 1], "end": [447, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Ioo", "code": "theorem isPreconnected_Ioo : IsPreconnected (Ioo a b)", "start": [450, 1], "end": [451, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Ioc", "code": "theorem isPreconnected_Ioc : IsPreconnected (Ioc a b)", "start": [454, 1], "end": [455, 34], "kind": "commanddeclaration"}, {"full_name": "isPreconnected_Ico", "code": "theorem isPreconnected_Ico : IsPreconnected (Ico a b)", "start": [458, 1], "end": [459, 34], "kind": "commanddeclaration"}, {"full_name": "isConnected_Ici", "code": "theorem isConnected_Ici : IsConnected (Ici a)", "start": [462, 1], "end": [463, 37], "kind": "commanddeclaration"}, {"full_name": "isConnected_Iic", "code": "theorem isConnected_Iic : IsConnected (Iic a)", "start": [466, 1], "end": [467, 37], "kind": "commanddeclaration"}, {"full_name": "isConnected_Ioi", "code": "theorem isConnected_Ioi [NoMaxOrder \u03b1] : IsConnected (Ioi a)", "start": [470, 1], "end": [471, 37], "kind": "commanddeclaration"}, {"full_name": "isConnected_Iio", "code": "theorem isConnected_Iio [NoMinOrder \u03b1] : IsConnected (Iio a)", "start": [474, 1], "end": [475, 37], "kind": "commanddeclaration"}, {"full_name": "isConnected_Icc", "code": "theorem isConnected_Icc (h : a \u2264 b) : IsConnected (Icc a b)", "start": [478, 1], "end": [479, 41], "kind": "commanddeclaration"}, {"full_name": "isConnected_Ioo", "code": "theorem isConnected_Ioo (h : a < b) : IsConnected (Ioo a b)", "start": [482, 1], "end": [483, 41], "kind": "commanddeclaration"}, {"full_name": "isConnected_Ioc", "code": "theorem isConnected_Ioc (h : a < b) : IsConnected (Ioc a b)", "start": [486, 1], "end": [487, 41], "kind": "commanddeclaration"}, {"full_name": "isConnected_Ico", "code": "theorem isConnected_Ico (h : a < b) : IsConnected (Ico a b)", "start": [490, 1], "end": [491, 41], "kind": "commanddeclaration"}, {"full_name": "ordered_connected_space", "code": "instance (priority := 100) ordered_connected_space : PreconnectedSpace \u03b1 :=\n  \u27e8ordConnected_univ.isPreconnected\u27e9", "start": [494, 1], "end": [495, 37], "kind": "commanddeclaration"}, {"full_name": "setOf_isPreconnected_eq_of_ordered", "code": "theorem setOf_isPreconnected_eq_of_ordered :\n    { s : Set \u03b1 | IsPreconnected s } =\n      range (uncurry Icc) \u222a range (uncurry Ico) \u222a range (uncurry Ioc) \u222a range (uncurry Ioo) \u222a\n      (range Ici \u222a range Ioi \u222a range Iic \u222a range Iio \u222a {univ, \u2205})", "start": [498, 1], "end": [513, 47], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Icc", "code": "theorem intermediate_value_Icc {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4} (hf : ContinuousOn f (Icc a b)) :\n    Icc (f a) (f b) \u2286 f '' Icc a b", "start": [526, 1], "end": [530, 86], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Icc'", "code": "theorem intermediate_value_Icc' {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f (Icc a b)) : Icc (f b) (f a) \u2286 f '' Icc a b", "start": [533, 1], "end": [537, 86], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_uIcc", "code": "theorem intermediate_value_uIcc {a b : \u03b1} {f : \u03b1 \u2192 \u03b4} (hf : ContinuousOn f (uIcc a b)) :\n    uIcc (f a) (f b) \u2286 f '' uIcc a b", "start": [540, 1], "end": [543, 82], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ico", "code": "theorem intermediate_value_Ico {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4} (hf : ContinuousOn f (Icc a b)) :\n    Ico (f a) (f b) \u2286 f '' Ico a b", "start": [546, 1], "end": [551, 71], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ico'", "code": "theorem intermediate_value_Ico' {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f (Icc a b)) : Ioc (f b) (f a) \u2286 f '' Ico a b", "start": [554, 1], "end": [559, 71], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ioc", "code": "theorem intermediate_value_Ioc {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4} (hf : ContinuousOn f (Icc a b)) :\n    Ioc (f a) (f b) \u2286 f '' Ioc a b", "start": [562, 1], "end": [567, 71], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ioc'", "code": "theorem intermediate_value_Ioc' {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f (Icc a b)) : Ico (f b) (f a) \u2286 f '' Ioc a b", "start": [570, 1], "end": [575, 71], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ioo", "code": "theorem intermediate_value_Ioo {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4} (hf : ContinuousOn f (Icc a b)) :\n    Ioo (f a) (f b) \u2286 f '' Ioo a b", "start": [578, 1], "end": [585, 71], "kind": "commanddeclaration"}, {"full_name": "intermediate_value_Ioo'", "code": "theorem intermediate_value_Ioo' {a b : \u03b1} (hab : a \u2264 b) {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f (Icc a b)) : Ioo (f b) (f a) \u2286 f '' Ioo a b", "start": [588, 1], "end": [595, 71], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.surjOn_Icc", "code": "theorem ContinuousOn.surjOn_Icc {s : Set \u03b1} [hs : OrdConnected s] {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) : SurjOn f s (Icc (f a) (f b))", "start": [598, 1], "end": [602, 48], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.surjOn_uIcc", "code": "theorem ContinuousOn.surjOn_uIcc {s : Set \u03b1} [hs : OrdConnected s] {f : \u03b1 \u2192 \u03b4}\n    (hf : ContinuousOn f s) {a b : \u03b1} (ha : a \u2208 s) (hb : b \u2208 s) : SurjOn f s (uIcc (f a) (f b))", "start": [605, 1], "end": [609, 74], "kind": "commanddeclaration"}, {"full_name": "Continuous.surjective", "code": "theorem Continuous.surjective {f : \u03b1 \u2192 \u03b4} (hf : Continuous f) (h_top : Tendsto f atTop atTop)\n    (h_bot : Tendsto f atBot atBot) : Function.Surjective f", "start": [612, 1], "end": [617, 54], "kind": "commanddeclaration"}, {"full_name": "Continuous.surjective'", "code": "theorem Continuous.surjective' {f : \u03b1 \u2192 \u03b4} (hf : Continuous f) (h_top : Tendsto f atBot atTop)\n    (h_bot : Tendsto f atTop atBot) : Function.Surjective f", "start": [620, 1], "end": [624, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.surjOn_of_tendsto", "code": "theorem ContinuousOn.surjOn_of_tendsto {f : \u03b1 \u2192 \u03b4} {s : Set \u03b1} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atBot)\n    (htop : Tendsto (fun x : s => f x) atTop atTop) : SurjOn f s univ", "start": [627, 1], "end": [635, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.surjOn_of_tendsto'", "code": "theorem ContinuousOn.surjOn_of_tendsto' {f : \u03b1 \u2192 \u03b4} {s : Set \u03b1} [OrdConnected s] (hs : s.Nonempty)\n    (hf : ContinuousOn f s) (hbot : Tendsto (fun x : s => f x) atBot atTop)\n    (htop : Tendsto (fun x : s => f x) atTop atBot) : SurjOn f s univ", "start": [638, 1], "end": [645, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Real/ENNReal.lean", "imports": ["Mathlib/Tactic/GCongr/Core.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/WithBotTop.lean", "Mathlib/Algebra/Order/Sub/WithTop.lean", "Mathlib/Data/Real/NNReal.lean"], "premises": [{"full_name": "ENNReal", "code": "def ENNReal := WithTop \u211d\u22650\n  deriving Zero, AddCommMonoidWithOne, SemilatticeSup, DistribLattice, Nontrivial", "start": [81, 1], "end": [84, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.instSub", "code": "noncomputable instance instSub : Sub \u211d\u22650\u221e := inferInstanceAs (Sub (WithTop \u211d\u22650))", "start": [110, 1], "end": [110, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.covariantClass_mul_le", "code": "instance covariantClass_mul_le : CovariantClass \u211d\u22650\u221e \u211d\u22650\u221e (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7) := inferInstance", "start": [119, 1], "end": [119, 91], "kind": "commanddeclaration"}, {"full_name": "ENNReal.covariantClass_add_le", "code": "instance covariantClass_add_le : CovariantClass \u211d\u22650\u221e \u211d\u22650\u221e (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) := inferInstance", "start": [122, 1], "end": [122, 91], "kind": "commanddeclaration"}, {"full_name": "ENNReal.some", "code": "@[coe, match_pattern] def some : \u211d\u22650 \u2192 \u211d\u22650\u221e := WithTop.some", "start": [138, 1], "end": [139, 60], "kind": "commanddeclaration"}, {"full_name": "ENNReal.recTopCoe", "code": "def recTopCoe {C : \u211d\u22650\u221e \u2192 Sort*} (top : C \u221e) (coe : \u2200 x : \u211d\u22650, C x) (x : \u211d\u22650\u221e) : C x :=\n  WithTop.recTopCoe top coe x", "start": [143, 1], "end": [145, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.canLift", "code": "instance canLift : CanLift \u211d\u22650\u221e \u211d\u22650 some (\u00b7 \u2260 \u221e) := WithTop.canLift", "start": [147, 1], "end": [147, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.none_eq_top", "code": "@[simp] theorem none_eq_top : (none : \u211d\u22650\u221e) = \u221e", "start": [150, 1], "end": [150, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.some_eq_coe", "code": "@[simp] theorem some_eq_coe (a : \u211d\u22650) : (Option.some a : \u211d\u22650\u221e) = (\u2191a : \u211d\u22650\u221e)", "start": [153, 1], "end": [153, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.some_eq_coe'", "code": "@[simp] theorem some_eq_coe' (a : \u211d\u22650) : (WithTop.some a : \u211d\u22650\u221e) = (\u2191a : \u211d\u22650\u221e)", "start": [156, 1], "end": [156, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_injective", "code": "protected theorem coe_injective : Function.Injective ((\u2191) : \u211d\u22650 \u2192 \u211d\u22650\u221e)", "start": [158, 1], "end": [158, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.range_coe'", "code": "theorem range_coe' : range some = Iio \u221e", "start": [160, 1], "end": [160, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.range_coe", "code": "theorem range_coe : range some = {\u221e}\u1d9c", "start": [161, 1], "end": [161, 90], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal", "code": "protected def toNNReal : \u211d\u22650\u221e \u2192 \u211d\u22650 := WithTop.untop' 0", "start": [163, 1], "end": [164, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal", "code": "protected def toReal (a : \u211d\u22650\u221e) : Real := a.toNNReal", "start": [167, 1], "end": [168, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal", "code": "protected noncomputable def ofReal (r : Real) : \u211d\u22650\u221e := r.toNNReal", "start": [171, 1], "end": [172, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_coe", "code": "@[simp, norm_cast]\ntheorem toNNReal_coe : (r : \u211d\u22650\u221e).toNNReal = r", "start": [175, 1], "end": [176, 54], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_toNNReal", "code": "@[simp]\ntheorem coe_toNNReal : \u2200 {a : \u211d\u22650\u221e}, a \u2260 \u221e \u2192 \u2191a.toNNReal = a", "start": [179, 1], "end": [182, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_toReal", "code": "@[simp]\ntheorem ofReal_toReal {a : \u211d\u22650\u221e} (h : a \u2260 \u221e) : ENNReal.ofReal a.toReal = a", "start": [185, 1], "end": [187, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ofReal", "code": "@[simp]\ntheorem toReal_ofReal {r : \u211d} (h : 0 \u2264 r) : (ENNReal.ofReal r).toReal = r", "start": [190, 1], "end": [192, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ofReal'", "code": "theorem toReal_ofReal' {r : \u211d} : (ENNReal.ofReal r).toReal = max r 0", "start": [195, 1], "end": [195, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_toNNReal_le_self", "code": "theorem coe_toNNReal_le_self : \u2200 {a : \u211d\u22650\u221e}, \u2191a.toNNReal \u2264 a", "start": [198, 1], "end": [200, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_nnreal_eq", "code": "theorem coe_nnreal_eq (r : \u211d\u22650) : (r : \u211d\u22650\u221e) = ENNReal.ofReal r", "start": [203, 1], "end": [204, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_eq_coe_nnreal", "code": "theorem ofReal_eq_coe_nnreal {x : \u211d} (h : 0 \u2264 x) :\n    ENNReal.ofReal x = some \u27e8x, h\u27e9", "start": [207, 1], "end": [209, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_coe_nnreal", "code": "@[simp] theorem ofReal_coe_nnreal : ENNReal.ofReal p = p", "start": [212, 1], "end": [212, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_zero", "code": "@[simp, norm_cast] theorem coe_zero : \u2191(0 : \u211d\u22650) = (0 : \u211d\u22650\u221e)", "start": [215, 1], "end": [215, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_one", "code": "@[simp, norm_cast] theorem coe_one : \u2191(1 : \u211d\u22650) = (1 : \u211d\u22650\u221e)", "start": [218, 1], "end": [218, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_nonneg", "code": "@[simp] theorem toReal_nonneg {a : \u211d\u22650\u221e} : 0 \u2264 a.toReal", "start": [221, 1], "end": [221, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_toNNReal", "code": "@[simp] theorem top_toNNReal : \u221e.toNNReal = 0", "start": [224, 1], "end": [224, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_toReal", "code": "@[simp] theorem top_toReal : \u221e.toReal = 0", "start": [227, 1], "end": [227, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_toReal", "code": "@[simp] theorem one_toReal : (1 : \u211d\u22650\u221e).toReal = 1", "start": [230, 1], "end": [230, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_toNNReal", "code": "@[simp] theorem one_toNNReal : (1 : \u211d\u22650\u221e).toNNReal = 1", "start": [233, 1], "end": [233, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_toReal", "code": "@[simp] theorem coe_toReal (r : \u211d\u22650) : (r : \u211d\u22650\u221e).toReal = r", "start": [236, 1], "end": [236, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_toNNReal", "code": "@[simp] theorem zero_toNNReal : (0 : \u211d\u22650\u221e).toNNReal = 0", "start": [239, 1], "end": [239, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_toReal", "code": "@[simp] theorem zero_toReal : (0 : \u211d\u22650\u221e).toReal = 0", "start": [242, 1], "end": [242, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_zero", "code": "@[simp] theorem ofReal_zero : ENNReal.ofReal (0 : \u211d) = 0", "start": [245, 1], "end": [245, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_one", "code": "@[simp] theorem ofReal_one : ENNReal.ofReal (1 : \u211d) = (1 : \u211d\u22650\u221e)", "start": [248, 1], "end": [248, 93], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_toReal_le", "code": "theorem ofReal_toReal_le {a : \u211d\u22650\u221e} : ENNReal.ofReal a.toReal \u2264 a", "start": [251, 1], "end": [252, 71], "kind": "commanddeclaration"}, {"full_name": "ENNReal.forall_ennreal", "code": "theorem forall_ennreal {p : \u211d\u22650\u221e \u2192 Prop} : (\u2200 a, p a) \u2194 (\u2200 r : \u211d\u22650, p r) \u2227 p \u221e", "start": [255, 1], "end": [256, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.forall_ne_top", "code": "theorem forall_ne_top {p : \u211d\u22650\u221e \u2192 Prop} : (\u2200 a, a \u2260 \u221e \u2192 p a) \u2194 \u2200 r : \u211d\u22650, p r", "start": [259, 1], "end": [260, 22], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_ne_top'", "code": "theorem exists_ne_top' {p : \u211d\u22650\u221e \u2192 Prop} : (\u2203 (a : \u211d\u22650\u221e) (_ : a \u2260 \u221e), p a) \u2194 \u2203 r : \u211d\u22650, p r", "start": [263, 1], "end": [264, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_ne_top", "code": "theorem exists_ne_top {p : \u211d\u22650\u221e \u2192 Prop} : (\u2203 a : \u211d\u22650\u221e, a \u2260 \u221e \u2227 p a) \u2194 \u2203 r : \u211d\u22650, p r", "start": [267, 1], "end": [268, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_eq_zero_iff", "code": "theorem toNNReal_eq_zero_iff (x : \u211d\u22650\u221e) : x.toNNReal = 0 \u2194 x = 0 \u2228 x = \u221e", "start": [270, 1], "end": [271, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_eq_zero_iff", "code": "theorem toReal_eq_zero_iff (x : \u211d\u22650\u221e) : x.toReal = 0 \u2194 x = 0 \u2228 x = \u221e", "start": [274, 1], "end": [275, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_ne_zero", "code": "theorem toNNReal_ne_zero : a.toNNReal \u2260 0 \u2194 a \u2260 0 \u2227 a \u2260 \u221e", "start": [278, 1], "end": [279, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ne_zero", "code": "theorem toReal_ne_zero : a.toReal \u2260 0 \u2194 a \u2260 0 \u2227 a \u2260 \u221e", "start": [282, 1], "end": [283, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_eq_one_iff", "code": "theorem toNNReal_eq_one_iff (x : \u211d\u22650\u221e) : x.toNNReal = 1 \u2194 x = 1", "start": [286, 1], "end": [287, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_eq_one_iff", "code": "theorem toReal_eq_one_iff (x : \u211d\u22650\u221e) : x.toReal = 1 \u2194 x = 1", "start": [290, 1], "end": [291, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_ne_one", "code": "theorem toNNReal_ne_one : a.toNNReal \u2260 1 \u2194 a \u2260 1", "start": [294, 1], "end": [295, 28], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ne_one", "code": "theorem toReal_ne_one : a.toReal \u2260 1 \u2194 a \u2260 1", "start": [298, 1], "end": [299, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_ne_top", "code": "@[simp] theorem coe_ne_top : (r : \u211d\u22650\u221e) \u2260 \u221e", "start": [302, 1], "end": [302, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_ne_coe", "code": "@[simp] theorem top_ne_coe : \u221e \u2260 (r : \u211d\u22650\u221e)", "start": [305, 1], "end": [305, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_lt_top", "code": "@[simp] theorem coe_lt_top : (r : \u211d\u22650\u221e) < \u221e", "start": [308, 1], "end": [308, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_ne_top", "code": "@[simp] theorem ofReal_ne_top {r : \u211d} : ENNReal.ofReal r \u2260 \u221e", "start": [311, 1], "end": [311, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_lt_top", "code": "@[simp] theorem ofReal_lt_top {r : \u211d} : ENNReal.ofReal r < \u221e", "start": [314, 1], "end": [314, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_ne_ofReal", "code": "@[simp] theorem top_ne_ofReal {r : \u211d} : \u221e \u2260 ENNReal.ofReal r", "start": [317, 1], "end": [317, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_toReal_eq_iff", "code": "@[simp]\ntheorem ofReal_toReal_eq_iff : ENNReal.ofReal a.toReal = a \u2194 a \u2260 \u22a4", "start": [320, 1], "end": [324, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ofReal_eq_iff", "code": "@[simp]\ntheorem toReal_ofReal_eq_iff {a : \u211d} : (ENNReal.ofReal a).toReal = a \u2194 0 \u2264 a", "start": [327, 1], "end": [331, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_ne_top", "code": "@[simp] theorem zero_ne_top : 0 \u2260 \u221e", "start": [334, 1], "end": [334, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_ne_zero", "code": "@[simp] theorem top_ne_zero : \u221e \u2260 0", "start": [337, 1], "end": [337, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_ne_top", "code": "@[simp] theorem one_ne_top : 1 \u2260 \u221e", "start": [340, 1], "end": [340, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_ne_one", "code": "@[simp] theorem top_ne_one : \u221e \u2260 1", "start": [343, 1], "end": [343, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_eq_coe", "code": "@[simp, norm_cast] theorem coe_eq_coe : (\u2191r : \u211d\u22650\u221e) = \u2191q \u2194 r = q", "start": [346, 1], "end": [346, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_le_coe", "code": "@[simp, norm_cast] theorem coe_le_coe : (\u2191r : \u211d\u22650\u221e) \u2264 \u2191q \u2194 r \u2264 q", "start": [349, 1], "end": [349, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_lt_coe", "code": "@[simp, norm_cast] theorem coe_lt_coe : (\u2191r : \u211d\u22650\u221e) < \u2191q \u2194 r < q", "start": [352, 1], "end": [352, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_le_coe_of_le", "code": "alias \u27e8_, coe_le_coe_of_le\u27e9 := coe_le_coe", "start": [356, 1], "end": [356, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ENNReal.coe_lt_coe_of_le", "code": "alias \u27e8_, coe_lt_coe_of_le\u27e9 := coe_lt_coe", "start": [360, 1], "end": [360, 42], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ENNReal.coe_mono", "code": "theorem coe_mono : Monotone some", "start": [363, 1], "end": [363, 60], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_strictMono", "code": "theorem coe_strictMono : StrictMono some", "start": [366, 1], "end": [366, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_eq_zero", "code": "@[simp, norm_cast] theorem coe_eq_zero : (\u2191r : \u211d\u22650\u221e) = 0 \u2194 r = 0", "start": [368, 1], "end": [368, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_eq_coe", "code": "@[simp, norm_cast] theorem zero_eq_coe : 0 = (\u2191r : \u211d\u22650\u221e) \u2194 0 = r", "start": [371, 1], "end": [371, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_eq_one", "code": "@[simp, norm_cast] theorem coe_eq_one : (\u2191r : \u211d\u22650\u221e) = 1 \u2194 r = 1", "start": [374, 1], "end": [374, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_eq_coe", "code": "@[simp, norm_cast] theorem one_eq_coe : 1 = (\u2191r : \u211d\u22650\u221e) \u2194 1 = r", "start": [377, 1], "end": [377, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_pos", "code": "@[simp, norm_cast] theorem coe_pos : 0 < (r : \u211d\u22650\u221e) \u2194 0 < r", "start": [380, 1], "end": [380, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_ne_zero", "code": "theorem coe_ne_zero : (r : \u211d\u22650\u221e) \u2260 0 \u2194 r \u2260 0", "start": [383, 1], "end": [383, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_add", "code": "@[simp, norm_cast] theorem coe_add : \u2191(r + p) = (r : \u211d\u22650\u221e) + p", "start": [386, 1], "end": [386, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul : \u2191(r * p) = (r : \u211d\u22650\u221e) * p", "start": [389, 1], "end": [391, 18], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_ofNat", "code": "@[simp, norm_cast] theorem coe_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ((no_index (OfNat.ofNat n) : \u211d\u22650) : \u211d\u22650\u221e) = OfNat.ofNat n", "start": [397, 1], "end": [399, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_two", "code": "theorem coe_two : ((2 : \u211d\u22650) : \u211d\u22650\u221e) = 2", "start": [403, 1], "end": [403, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_eq_toNNReal_iff", "code": "theorem toNNReal_eq_toNNReal_iff (x y : \u211d\u22650\u221e) :\n    x.toNNReal = y.toNNReal \u2194 x = y \u2228 x = 0 \u2227 y = \u22a4 \u2228 x = \u22a4 \u2227 y = 0", "start": [406, 1], "end": [408, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_eq_toReal_iff", "code": "theorem toReal_eq_toReal_iff (x y : \u211d\u22650\u221e) :\n    x.toReal = y.toReal \u2194 x = y \u2228 x = 0 \u2227 y = \u22a4 \u2228 x = \u22a4 \u2227 y = 0", "start": [411, 1], "end": [413, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_eq_toNNReal_iff'", "code": "theorem toNNReal_eq_toNNReal_iff' {x y : \u211d\u22650\u221e} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) :\n    x.toNNReal = y.toNNReal \u2194 x = y", "start": [416, 1], "end": [418, 91], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_eq_toReal_iff'", "code": "theorem toReal_eq_toReal_iff' {x y : \u211d\u22650\u221e} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) :\n    x.toReal = y.toReal \u2194 x = y", "start": [421, 1], "end": [423, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_two", "code": "@[simp]\nnonrec theorem one_lt_two : (1 : \u211d\u22650\u221e) < 2", "start": [426, 1], "end": [428, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.two_ne_top", "code": "theorem two_ne_top : (2 : \u211d\u22650\u221e) \u2260 \u221e", "start": [431, 1], "end": [431, 50], "kind": "commanddeclaration"}, {"full_name": "fact_one_le_one_ennreal", "code": "instance _root_.fact_one_le_one_ennreal : Fact ((1 : \u211d\u22650\u221e) \u2264 1) :=\n  \u27e8le_rfl\u27e9", "start": [434, 1], "end": [436, 11], "kind": "commanddeclaration"}, {"full_name": "fact_one_le_two_ennreal", "code": "instance _root_.fact_one_le_two_ennreal : Fact ((1 : \u211d\u22650\u221e) \u2264 2) :=\n  \u27e8one_le_two\u27e9", "start": [439, 1], "end": [441, 15], "kind": "commanddeclaration"}, {"full_name": "fact_one_le_top_ennreal", "code": "instance _root_.fact_one_le_top_ennreal : Fact ((1 : \u211d\u22650\u221e) \u2264 \u221e) :=\n  \u27e8le_top\u27e9", "start": [444, 1], "end": [446, 11], "kind": "commanddeclaration"}, {"full_name": "ENNReal.neTopEquivNNReal", "code": "def neTopEquivNNReal : { a | a \u2260 \u221e } \u2243 \u211d\u22650 where\n  toFun x := ENNReal.toNNReal x\n  invFun x := \u27e8x, coe_ne_top\u27e9\n  left_inv := fun x => Subtype.eq <| coe_toNNReal x.2\n  right_inv _ := toNNReal_coe", "start": [449, 1], "end": [454, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.cinfi_ne_top", "code": "theorem cinfi_ne_top [InfSet \u03b1] (f : \u211d\u22650\u221e \u2192 \u03b1) : \u2a05 x : { x // x \u2260 \u221e }, f x = \u2a05 x : \u211d\u22650, f x", "start": [457, 1], "end": [458, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_ne_top", "code": "theorem iInf_ne_top [CompleteLattice \u03b1] (f : \u211d\u22650\u221e \u2192 \u03b1) :\n    \u2a05 (x) (_ : x \u2260 \u221e), f x = \u2a05 x : \u211d\u22650, f x", "start": [461, 1], "end": [462, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.csupr_ne_top", "code": "theorem csupr_ne_top [SupSet \u03b1] (f : \u211d\u22650\u221e \u2192 \u03b1) : \u2a06 x : { x // x \u2260 \u221e }, f x = \u2a06 x : \u211d\u22650, f x", "start": [465, 1], "end": [466, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_ne_top", "code": "theorem iSup_ne_top [CompleteLattice \u03b1] (f : \u211d\u22650\u221e \u2192 \u03b1) :\n    \u2a06 (x) (_ : x \u2260 \u221e), f x = \u2a06 x : \u211d\u22650, f x", "start": [469, 1], "end": [471, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_ennreal", "code": "theorem iInf_ennreal {\u03b1 : Type*} [CompleteLattice \u03b1] {f : \u211d\u22650\u221e \u2192 \u03b1} :\n    \u2a05 n, f n = (\u2a05 n : \u211d\u22650, f n) \u2293 f \u221e", "start": [474, 1], "end": [476, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_ennreal", "code": "theorem iSup_ennreal {\u03b1 : Type*} [CompleteLattice \u03b1] {f : \u211d\u22650\u221e \u2192 \u03b1} :\n    \u2a06 n, f n = (\u2a06 n : \u211d\u22650, f n) \u2294 f \u221e", "start": [479, 1], "end": [481, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofNNRealHom", "code": "def ofNNRealHom : \u211d\u22650 \u2192+* \u211d\u22650\u221e where\n  toFun := some\n  map_one' := coe_one\n  map_mul' _ _ := coe_mul\n  map_zero' := coe_zero\n  map_add' _ _ := coe_add", "start": [484, 1], "end": [490, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_ofNNRealHom", "code": "@[simp] theorem coe_ofNNRealHom : \u21d1ofNNRealHom = some", "start": [493, 1], "end": [493, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smul_def", "code": "theorem smul_def {M : Type*} [MulAction \u211d\u22650\u221e M] (c : \u211d\u22650) (x : M) : c \u2022 x = (c : \u211d\u22650\u221e) \u2022 x", "start": [503, 1], "end": [504, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smulCommClass_left", "code": "instance smulCommClass_left {M N : Type*} [MulAction \u211d\u22650\u221e N] [SMul M N] [SMulCommClass \u211d\u22650\u221e M N] :\n    SMulCommClass \u211d\u22650 M N where smul_comm r := (smul_comm (r : \u211d\u22650\u221e) : _)", "start": [510, 1], "end": [511, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smulCommClass_right", "code": "instance smulCommClass_right {M N : Type*} [MulAction \u211d\u22650\u221e N] [SMul M N] [SMulCommClass M \u211d\u22650\u221e N] :\n    SMulCommClass M \u211d\u22650 N where smul_comm m r := (smul_comm m (r : \u211d\u22650\u221e) : _)", "start": [514, 1], "end": [515, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_smul", "code": "theorem coe_smul {R} (r : R) (s : \u211d\u22650) [SMul R \u211d\u22650] [SMul R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650 \u211d\u22650]\n    [IsScalarTower R \u211d\u22650 \u211d\u22650\u221e] : (\u2191(r \u2022 s) : \u211d\u22650\u221e) = (r : R) \u2022 (s : \u211d\u22650\u221e)", "start": [539, 1], "end": [542, 13], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_indicator", "code": "@[simp, norm_cast]\ntheorem coe_indicator {\u03b1} (s : Set \u03b1) (f : \u03b1 \u2192 \u211d\u22650) (a : \u03b1) :\n    ((s.indicator f a : \u211d\u22650) : \u211d\u22650\u221e) = s.indicator (fun x => \u2191(f x)) a", "start": [547, 1], "end": [550, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (n : \u2115) : (\u2191(r ^ n) : \u211d\u22650\u221e) = (r : \u211d\u22650\u221e) ^ n", "start": [553, 1], "end": [555, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_eq_top", "code": "@[simp] theorem add_eq_top : a + b = \u221e \u2194 a = \u221e \u2228 b = \u221e", "start": [558, 1], "end": [558, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_top", "code": "@[simp] theorem add_lt_top : a + b < \u221e \u2194 a < \u221e \u2227 b < \u221e", "start": [561, 1], "end": [561, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_add", "code": "theorem toNNReal_add {r\u2081 r\u2082 : \u211d\u22650\u221e} (h\u2081 : r\u2081 \u2260 \u221e) (h\u2082 : r\u2082 \u2260 \u221e) :\n    (r\u2081 + r\u2082).toNNReal = r\u2081.toNNReal + r\u2082.toNNReal", "start": [564, 1], "end": [568, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.not_lt_top", "code": "theorem not_lt_top {x : \u211d\u22650\u221e} : \u00acx < \u221e \u2194 x = \u221e", "start": [571, 1], "end": [571, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_ne_top", "code": "theorem add_ne_top : a + b \u2260 \u221e \u2194 a \u2260 \u221e \u2227 b \u2260 \u221e", "start": [574, 1], "end": [574, 101], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_top'", "code": "theorem mul_top' : a * \u221e = if a = 0 then 0 else \u221e", "start": [577, 1], "end": [577, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_top", "code": "@[simp] theorem mul_top (h : a \u2260 0) : a * \u221e = \u221e", "start": [581, 1], "end": [581, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_mul'", "code": "theorem top_mul' : \u221e * a = if a = 0 then 0 else \u221e", "start": [583, 1], "end": [583, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_mul", "code": "@[simp] theorem top_mul (h : a \u2260 0) : \u221e * a = \u221e", "start": [587, 1], "end": [587, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_mul_top", "code": "theorem top_mul_top : \u221e * \u221e = \u221e", "start": [589, 1], "end": [589, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smul_top", "code": "theorem smul_top {R} [Zero R] [SMulWithZero R \u211d\u22650\u221e] [IsScalarTower R \u211d\u22650\u221e \u211d\u22650\u221e]\n    [NoZeroSMulDivisors R \u211d\u22650\u221e] [DecidableEq R] (c : R) :\n    c \u2022 \u221e = if c = 0 then 0 else \u221e", "start": [593, 1], "end": [598, 58], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_pow", "code": "theorem top_pow {n : \u2115} (h : 0 < n) : \u221e ^ n = \u221e", "start": [603, 1], "end": [605, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_eq_top", "code": "theorem mul_eq_top : a * b = \u221e \u2194 a \u2260 0 \u2227 b = \u221e \u2228 a = \u221e \u2227 b \u2260 0", "start": [608, 1], "end": [609, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_top", "code": "theorem mul_lt_top : a \u2260 \u221e \u2192 b \u2260 \u221e \u2192 a * b < \u221e", "start": [612, 1], "end": [612, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_ne_top", "code": "theorem mul_ne_top : a \u2260 \u221e \u2192 b \u2260 \u221e \u2192 a * b \u2260 \u221e", "start": [615, 1], "end": [615, 101], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_top_of_mul_ne_top_left", "code": "theorem lt_top_of_mul_ne_top_left (h : a * b \u2260 \u221e) (hb : b \u2260 0) : a < \u221e", "start": [618, 1], "end": [619, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_top_of_mul_ne_top_right", "code": "theorem lt_top_of_mul_ne_top_right (h : a * b \u2260 \u221e) (ha : a \u2260 0) : b < \u221e", "start": [622, 1], "end": [623, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_top_iff", "code": "theorem mul_lt_top_iff {a b : \u211d\u22650\u221e} : a * b < \u221e \u2194 a < \u221e \u2227 b < \u221e \u2228 a = 0 \u2228 b = 0", "start": [626, 1], "end": [632, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_self_lt_top_iff", "code": "theorem mul_self_lt_top_iff {a : \u211d\u22650\u221e} : a * a < \u22a4 \u2194 a < \u22a4", "start": [635, 1], "end": [638, 11], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_pos_iff", "code": "theorem mul_pos_iff : 0 < a * b \u2194 0 < a \u2227 0 < b", "start": [641, 1], "end": [642, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_pos", "code": "theorem mul_pos (ha : a \u2260 0) (hb : b \u2260 0) : 0 < a * b", "start": [645, 1], "end": [646, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_eq_top_iff", "code": "@[simp] theorem pow_eq_top_iff {n : \u2115} : a ^ n = \u221e \u2194 a = \u221e \u2227 n \u2260 0", "start": [650, 1], "end": [655, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_eq_top", "code": "theorem pow_eq_top (n : \u2115) (h : a ^ n = \u221e) : a = \u221e", "start": [658, 1], "end": [659, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_ne_top", "code": "theorem pow_ne_top (h : a \u2260 \u221e) {n : \u2115} : a ^ n \u2260 \u221e", "start": [662, 1], "end": [663, 22], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_lt_top", "code": "theorem pow_lt_top : a < \u221e \u2192 \u2200 n : \u2115, a ^ n < \u221e", "start": [666, 1], "end": [667, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_finset_sum", "code": "@[simp, norm_cast]\ntheorem coe_finset_sum {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650} : \u2191(\u2211 a in s, f a) = \u2211 a in s, (f a : \u211d\u22650\u221e)", "start": [670, 1], "end": [672, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_finset_prod", "code": "@[simp, norm_cast]\ntheorem coe_finset_prod {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650} : \u2191(\u220f a in s, f a) = \u220f a in s, (f a : \u211d\u22650\u221e)", "start": [675, 1], "end": [677, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.bot_eq_zero", "code": "theorem bot_eq_zero : (\u22a5 : \u211d\u22650\u221e) = 0", "start": [682, 1], "end": [682, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.not_top_le_coe", "code": "theorem not_top_le_coe : \u00ac\u221e \u2264 \u2191r", "start": [687, 1], "end": [687, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_le_coe_iff", "code": "@[simp, norm_cast]\ntheorem one_le_coe_iff : (1 : \u211d\u22650\u221e) \u2264 \u2191r \u2194 1 \u2264 r", "start": [690, 1], "end": [691, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_le_one_iff", "code": "@[simp, norm_cast]\ntheorem coe_le_one_iff : \u2191r \u2264 (1 : \u211d\u22650\u221e) \u2194 r \u2264 1", "start": [694, 1], "end": [695, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_lt_one_iff", "code": "@[simp, norm_cast]\ntheorem coe_lt_one_iff : (\u2191p : \u211d\u22650\u221e) < 1 \u2194 p < 1", "start": [698, 1], "end": [699, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_coe_iff", "code": "@[simp, norm_cast]\ntheorem one_lt_coe_iff : 1 < (\u2191p : \u211d\u22650\u221e) \u2194 1 < p", "start": [702, 1], "end": [703, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_nat", "code": "@[simp, norm_cast]\ntheorem coe_nat (n : \u2115) : ((n : \u211d\u22650) : \u211d\u22650\u221e) = n", "start": [706, 1], "end": [707, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_coe_nat", "code": "@[simp] theorem ofReal_coe_nat (n : \u2115) : ENNReal.ofReal n = n", "start": [710, 1], "end": [710, 90], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_ofNat", "code": "@[simp] theorem ofReal_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ENNReal.ofReal (no_index (OfNat.ofNat n)) = OfNat.ofNat n", "start": [713, 1], "end": [715, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nat_ne_top", "code": "@[simp] theorem nat_ne_top (n : \u2115) : (n : \u211d\u22650\u221e) \u2260 \u221e", "start": [717, 1], "end": [717, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_ne_nat", "code": "@[simp] theorem top_ne_nat (n : \u2115) : \u221e \u2260 n", "start": [720, 1], "end": [720, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_top", "code": "@[simp] theorem one_lt_top : 1 < \u221e", "start": [723, 1], "end": [723, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_nat", "code": "@[simp, norm_cast]\ntheorem toNNReal_nat (n : \u2115) : (n : \u211d\u22650\u221e).toNNReal = n", "start": [726, 1], "end": [728, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_nat", "code": "@[simp, norm_cast]\ntheorem toReal_nat (n : \u2115) : (n : \u211d\u22650\u221e).toReal = n", "start": [731, 1], "end": [733, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ofNat", "code": "@[simp] theorem toReal_ofNat (n : \u2115) [n.AtLeastTwo] :\n    ENNReal.toReal (no_index (OfNat.ofNat n)) = OfNat.ofNat n", "start": [736, 1], "end": [738, 15], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_coe_iff", "code": "theorem le_coe_iff : a \u2264 \u2191r \u2194 \u2203 p : \u211d\u22650, a = p \u2227 p \u2264 r", "start": [740, 1], "end": [740, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_le_iff", "code": "theorem coe_le_iff : \u2191r \u2264 a \u2194 \u2200 p : \u211d\u22650, a = p \u2192 r \u2264 p", "start": [743, 1], "end": [743, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_iff_exists_coe", "code": "theorem lt_iff_exists_coe : a < b \u2194 \u2203 p : \u211d\u22650, a = p \u2227 \u2191p < b", "start": [746, 1], "end": [747, 28], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_le_coe_of_le_coe", "code": "theorem toReal_le_coe_of_le_coe {a : \u211d\u22650\u221e} {b : \u211d\u22650} (h : a \u2264 b) : a.toReal \u2264 b", "start": [750, 1], "end": [752, 16], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_finset_sup", "code": "@[simp, norm_cast]\ntheorem coe_finset_sup {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650} : \u2191(s.sup f) = s.sup fun x => (f x : \u211d\u22650\u221e)", "start": [755, 1], "end": [757, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.max_eq_zero_iff", "code": "@[simp] theorem max_eq_zero_iff : max a b = 0 \u2194 a = 0 \u2227 b = 0", "start": [760, 1], "end": [760, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.max_zero_left", "code": "theorem max_zero_left : max 0 a = a", "start": [763, 1], "end": [764, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.max_zero_right", "code": "theorem max_zero_right : max a 0 = a", "start": [767, 1], "end": [768, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sup_eq_max", "code": "@[simp] theorem sup_eq_max : a \u2294 b = max a b", "start": [771, 1], "end": [771, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_pos", "code": "protected theorem pow_pos : 0 < a \u2192 \u2200 n : \u2115, 0 < a ^ n", "start": [774, 1], "end": [775, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_ne_zero", "code": "protected theorem pow_ne_zero : a \u2260 0 \u2192 \u2200 n : \u2115, a ^ n \u2260 0", "start": [778, 1], "end": [779, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.not_lt_zero", "code": "theorem not_lt_zero : \u00aca < 0", "start": [782, 1], "end": [782, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_add_le_add_left", "code": "protected theorem le_of_add_le_add_left : a \u2260 \u221e \u2192 a + b \u2264 a + c \u2192 b \u2264 c", "start": [785, 1], "end": [786, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_add_le_add_right", "code": "protected theorem le_of_add_le_add_right : a \u2260 \u221e \u2192 b + a \u2264 c + a \u2192 b \u2264 c", "start": [789, 1], "end": [790, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_left", "code": "@[gcongr] protected theorem add_lt_add_left : a \u2260 \u221e \u2192 b < c \u2192 a + b < a + c", "start": [793, 1], "end": [794, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_right", "code": "@[gcongr] protected theorem add_lt_add_right : a \u2260 \u221e \u2192 b < c \u2192 b + a < c + a", "start": [797, 1], "end": [798, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_le_add_iff_left", "code": "protected theorem add_le_add_iff_left : a \u2260 \u221e \u2192 (a + b \u2264 a + c \u2194 b \u2264 c)", "start": [801, 1], "end": [802, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_le_add_iff_right", "code": "protected theorem add_le_add_iff_right : a \u2260 \u221e \u2192 (b + a \u2264 c + a \u2194 b \u2264 c)", "start": [805, 1], "end": [806, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_iff_left", "code": "protected theorem add_lt_add_iff_left : a \u2260 \u221e \u2192 (a + b < a + c \u2194 b < c)", "start": [809, 1], "end": [810, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_iff_right", "code": "protected theorem add_lt_add_iff_right : a \u2260 \u221e \u2192 (b + a < c + a \u2194 b < c)", "start": [813, 1], "end": [814, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_of_le_of_lt", "code": "protected theorem add_lt_add_of_le_of_lt : a \u2260 \u221e \u2192 a \u2264 b \u2192 c < d \u2192 a + c < b + d", "start": [817, 1], "end": [818, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add_of_lt_of_le", "code": "protected theorem add_lt_add_of_lt_of_le : c \u2260 \u221e \u2192 a < b \u2192 c \u2264 d \u2192 a + c < b + d", "start": [821, 1], "end": [822, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.contravariantClass_add_lt", "code": "instance contravariantClass_add_lt : ContravariantClass \u211d\u22650\u221e \u211d\u22650\u221e (\u00b7 + \u00b7) (\u00b7 < \u00b7) :=\n  WithTop.contravariantClass_add_lt", "start": [825, 1], "end": [826, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_add_right", "code": "theorem lt_add_right (ha : a \u2260 \u221e) (hb : b \u2260 0) : a < a + b", "start": [829, 1], "end": [830, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_iff_exists_rat_btwn", "code": "theorem lt_iff_exists_rat_btwn :\n    a < b \u2194 \u2203 q : \u211a, 0 \u2264 q \u2227 a < Real.toNNReal q \u2227 (Real.toNNReal q : \u211d\u22650\u221e) < b", "start": [835, 1], "end": [843, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_iff_exists_real_btwn", "code": "theorem lt_iff_exists_real_btwn :\n    a < b \u2194 \u2203 r : \u211d, 0 \u2264 r \u2227 a < ENNReal.ofReal r \u2227 (ENNReal.ofReal r : \u211d\u22650\u221e) < b", "start": [846, 1], "end": [851, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_iff_exists_nnreal_btwn", "code": "theorem lt_iff_exists_nnreal_btwn : a < b \u2194 \u2203 r : \u211d\u22650, a < r \u2227 (r : \u211d\u22650\u221e) < b", "start": [854, 1], "end": [855, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_iff_exists_add_pos_lt", "code": "theorem lt_iff_exists_add_pos_lt : a < b \u2194 \u2203 r : \u211d\u22650, 0 < r \u2227 a + r < b", "start": [858, 1], "end": [864, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_forall_pos_le_add", "code": "theorem le_of_forall_pos_le_add (h : \u2200 \u03b5 : \u211d\u22650, 0 < \u03b5 \u2192 b < \u221e \u2192 a \u2264 b + \u03b5) : a \u2264 b", "start": [867, 1], "end": [870, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_nat_lt_coe", "code": "theorem coe_nat_lt_coe {n : \u2115} : (n : \u211d\u22650\u221e) < r \u2194 \u2191n < r", "start": [873, 1], "end": [874, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_lt_coe_nat", "code": "theorem coe_lt_coe_nat {n : \u2115} : (r : \u211d\u22650\u221e) < n \u2194 r < n", "start": [877, 1], "end": [878, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_nat_gt", "code": "protected theorem exists_nat_gt {r : \u211d\u22650\u221e} (h : r \u2260 \u221e) : \u2203 n : \u2115, r < n", "start": [881, 1], "end": [884, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Iio_coe_nat", "code": "@[simp]\ntheorem iUnion_Iio_coe_nat : \u22c3 n : \u2115, Iio (n : \u211d\u22650\u221e) = {\u221e}\u1d9c", "start": [887, 1], "end": [891, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Iic_coe_nat", "code": "@[simp]\ntheorem iUnion_Iic_coe_nat : \u22c3 n : \u2115, Iic (n : \u211d\u22650\u221e) = {\u221e}\u1d9c", "start": [894, 1], "end": [897, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Ioc_coe_nat", "code": "@[simp]\ntheorem iUnion_Ioc_coe_nat : \u22c3 n : \u2115, Ioc a n = Ioi a \\ {\u221e}", "start": [900, 1], "end": [902, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Ioo_coe_nat", "code": "@[simp]\ntheorem iUnion_Ioo_coe_nat : \u22c3 n : \u2115, Ioo a n = Ioi a \\ {\u221e}", "start": [905, 1], "end": [907, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Icc_coe_nat", "code": "@[simp]\ntheorem iUnion_Icc_coe_nat : \u22c3 n : \u2115, Icc a n = Ici a \\ {\u221e}", "start": [910, 1], "end": [912, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iUnion_Ico_coe_nat", "code": "@[simp]\ntheorem iUnion_Ico_coe_nat : \u22c3 n : \u2115, Ico a n = Ici a \\ {\u221e}", "start": [915, 1], "end": [917, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInter_Ici_coe_nat", "code": "@[simp]\ntheorem iInter_Ici_coe_nat : \u22c2 n : \u2115, Ici (n : \u211d\u22650\u221e) = {\u221e}", "start": [920, 1], "end": [922, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInter_Ioi_coe_nat", "code": "@[simp]\ntheorem iInter_Ioi_coe_nat : \u22c2 n : \u2115, Ioi (n : \u211d\u22650\u221e) = {\u221e}", "start": [925, 1], "end": [927, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_lt_add", "code": "@[gcongr] theorem add_lt_add (ac : a < c) (bd : b < d) : a + b < c + d", "start": [931, 1], "end": [937, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_min", "code": "@[simp, norm_cast]\ntheorem coe_min : ((min r p : \u211d\u22650) : \u211d\u22650\u221e) = min (r : \u211d\u22650\u221e) p", "start": [940, 1], "end": [941, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_max", "code": "@[simp, norm_cast]\ntheorem coe_max : ((max r p : \u211d\u22650) : \u211d\u22650\u221e) = max (r : \u211d\u22650\u221e) p", "start": [944, 1], "end": [945, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_top_imp_top_of_toNNReal_le", "code": "theorem le_of_top_imp_top_of_toNNReal_le {a b : \u211d\u22650\u221e} (h : a = \u22a4 \u2192 b = \u22a4)\n    (h_nnreal : a \u2260 \u22a4 \u2192 b \u2260 \u22a4 \u2192 a.toNNReal \u2264 b.toNNReal) : a \u2264 b", "start": [948, 1], "end": [954, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.abs_toReal", "code": "@[simp]\ntheorem abs_toReal {x : \u211d\u22650\u221e} : |x.toReal| = x.toReal", "start": [957, 1], "end": [958, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_sSup", "code": "theorem coe_sSup {s : Set \u211d\u22650} : BddAbove s \u2192 (\u2191(sSup s) : \u211d\u22650\u221e) = \u2a06 a \u2208 s, \u2191a", "start": [965, 1], "end": [966, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_sInf", "code": "theorem coe_sInf {s : Set \u211d\u22650} : s.Nonempty \u2192 (\u2191(sInf s) : \u211d\u22650\u221e) = \u2a05 a \u2208 s, \u2191a", "start": [969, 1], "end": [970, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_iSup", "code": "theorem coe_iSup {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650} (hf : BddAbove (range f)) :\n    (\u2191(iSup f) : \u211d\u22650\u221e) = \u2a06 a, \u2191(f a)", "start": [973, 1], "end": [975, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_iInf", "code": "@[norm_cast]\ntheorem coe_iInf {\u03b9 : Sort*} [Nonempty \u03b9] (f : \u03b9 \u2192 \u211d\u22650) : (\u2191(iInf f) : \u211d\u22650\u221e) = \u2a05 a, \u2191(f a)", "start": [978, 1], "end": [980, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_mem_upperBounds", "code": "theorem coe_mem_upperBounds {s : Set \u211d\u22650} :\n    \u2191r \u2208 upperBounds (some '' s) \u2194 r \u2208 upperBounds s", "start": [983, 1], "end": [985, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_coe_eq_top", "code": "lemma iSup_coe_eq_top : \u2a06 i, (f i : \u211d\u22650\u221e) = \u22a4 \u2194 \u00ac BddAbove (range f) := WithTop.iSup_coe_eq_top", "start": [988, 1], "end": [988, 96], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.iSup_coe_lt_top", "code": "lemma iSup_coe_lt_top : \u2a06 i, (f i : \u211d\u22650\u221e) < \u22a4 \u2194 BddAbove (range f) := WithTop.iSup_coe_lt_top", "start": [989, 1], "end": [989, 94], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.iInf_coe_eq_top", "code": "lemma iInf_coe_eq_top : \u2a05 i, (f i : \u211d\u22650\u221e) = \u22a4 \u2194 IsEmpty \u03b9 := WithTop.iInf_coe_eq_top", "start": [990, 1], "end": [990, 85], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.iInf_coe_lt_top", "code": "lemma iInf_coe_lt_top : \u2a05 i, (f i : \u211d\u22650\u221e) < \u22a4 \u2194 Nonempty \u03b9 := WithTop.iInf_coe_lt_top", "start": [991, 1], "end": [991, 86], "kind": "mathlibtacticlemma"}, {"full_name": "ENNReal.mul_lt_mul", "code": "@[mono, gcongr]\ntheorem mul_lt_mul (ac : a < c) (bd : b < d) : a * b < c * d", "start": [998, 1], "end": [1008, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_left_mono", "code": "theorem mul_left_mono : Monotone (a * \u00b7)", "start": [1012, 1], "end": [1012, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_right_mono", "code": "theorem mul_right_mono : Monotone (\u00b7 * a)", "start": [1016, 1], "end": [1016, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_strictMono", "code": "theorem pow_strictMono : \u2200 {n : \u2115}, n \u2260 0 \u2192 StrictMono fun x : \u211d\u22650\u221e => x ^ n", "start": [1020, 1], "end": [1023, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.pow_lt_pow_of_lt_left", "code": "@[gcongr] protected theorem pow_lt_pow_of_lt_left (h : a < b) {n : \u2115} (hn : n \u2260 0) :\n    a ^ n < b ^ n", "start": [1026, 1], "end": [1028, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.max_mul", "code": "theorem max_mul : max a b * c = max (a * c) (b * c)", "start": [1030, 1], "end": [1030, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_max", "code": "theorem mul_max : a * max b c = max (a * b) (a * c)", "start": [1033, 1], "end": [1033, 77], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_left_strictMono", "code": "theorem mul_left_strictMono (h0 : a \u2260 0) (hinf : a \u2260 \u221e) : StrictMono (a * \u00b7)", "start": [1037, 1], "end": [1043, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_mul_left'", "code": "@[gcongr] protected theorem mul_lt_mul_left' (h0 : a \u2260 0) (hinf : a \u2260 \u22a4) (bc : b < c) :\n    a * b < a * c", "start": [1046, 1], "end": [1048, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_mul_right'", "code": "@[gcongr] protected theorem mul_lt_mul_right' (h0 : a \u2260 0) (hinf : a \u2260 \u22a4) (bc : b < c) :\n    b * a < c * a", "start": [1050, 1], "end": [1052, 71], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_eq_mul_left", "code": "theorem mul_eq_mul_left (h0 : a \u2260 0) (hinf : a \u2260 \u221e) : a * b = a * c \u2194 b = c", "start": [1055, 1], "end": [1056, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_eq_mul_right", "code": "theorem mul_eq_mul_right : c \u2260 0 \u2192 c \u2260 \u221e \u2192 (a * c = b * c \u2194 a = b)", "start": [1060, 1], "end": [1061, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_le_mul_left", "code": "theorem mul_le_mul_left (h0 : a \u2260 0) (hinf : a \u2260 \u221e) : (a * b \u2264 a * c \u2194 b \u2264 c)", "start": [1065, 1], "end": [1066, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_le_mul_right", "code": "theorem mul_le_mul_right : c \u2260 0 \u2192 c \u2260 \u221e \u2192 (a * c \u2264 b * c \u2194 a \u2264 b)", "start": [1070, 1], "end": [1071, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_mul_left", "code": "theorem mul_lt_mul_left (h0 : a \u2260 0) (hinf : a \u2260 \u221e) : (a * b < a * c \u2194 b < c)", "start": [1075, 1], "end": [1076, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_mul_right", "code": "theorem mul_lt_mul_right : c \u2260 0 \u2192 c \u2260 \u221e \u2192 (a * c < b * c \u2194 a < b)", "start": [1080, 1], "end": [1081, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.addLECancellable_iff_ne", "code": "theorem addLECancellable_iff_ne {a : \u211d\u22650\u221e} : AddLECancellable a \u2194 a \u2260 \u221e", "start": [1089, 1], "end": [1097, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.cancel_of_ne", "code": "theorem cancel_of_ne {a : \u211d\u22650\u221e} (h : a \u2260 \u221e) : AddLECancellable a", "start": [1100, 1], "end": [1102, 32], "kind": "commanddeclaration"}, {"full_name": "ENNReal.cancel_of_lt", "code": "theorem cancel_of_lt {a : \u211d\u22650\u221e} (h : a < \u221e) : AddLECancellable a", "start": [1105, 1], "end": [1107, 20], "kind": "commanddeclaration"}, {"full_name": "ENNReal.cancel_of_lt'", "code": "theorem cancel_of_lt' {a b : \u211d\u22650\u221e} (h : a < b) : AddLECancellable a", "start": [1110, 1], "end": [1112, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.cancel_coe", "code": "theorem cancel_coe {a : \u211d\u22650} : AddLECancellable (a : \u211d\u22650\u221e)", "start": [1115, 1], "end": [1117, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_right_inj", "code": "theorem add_right_inj (h : a \u2260 \u221e) : a + b = a + c \u2194 b = c", "start": [1120, 1], "end": [1121, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_left_inj", "code": "theorem add_left_inj (h : a \u2260 \u221e) : b + a = c + a \u2194 b = c", "start": [1124, 1], "end": [1125, 28], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_eq_sInf", "code": "theorem sub_eq_sInf {a b : \u211d\u22650\u221e} : a - b = sInf { d | a \u2264 d + b }", "start": [1132, 1], "end": [1133, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_sub", "code": "@[simp] theorem coe_sub : (\u2191(r - p) : \u211d\u22650\u221e) = \u2191r - \u2191p", "start": [1136, 1], "end": [1137, 73], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_sub_coe", "code": "@[simp] theorem top_sub_coe : \u221e - \u2191r = \u221e", "start": [1140, 1], "end": [1141, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_top", "code": "theorem sub_top : a - \u221e = 0", "start": [1144, 1], "end": [1145, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_eq_top_iff", "code": "@[simp] theorem sub_eq_top_iff : a - b = \u221e \u2194 a = \u221e \u2227 b \u2260 \u221e", "start": [1149, 1], "end": [1149, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_ne_top", "code": "theorem sub_ne_top (ha : a \u2260 \u221e) : a - b \u2260 \u221e", "start": [1152, 1], "end": [1152, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.nat_cast_sub", "code": "@[simp, norm_cast]\ntheorem nat_cast_sub (m n : \u2115) : \u2191(m - n) = (m - n : \u211d\u22650\u221e)", "start": [1155, 1], "end": [1157, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_eq_of_eq_add", "code": "protected theorem sub_eq_of_eq_add (hb : b \u2260 \u221e) : a = c + b \u2192 a - b = c", "start": [1160, 1], "end": [1161, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eq_sub_of_add_eq", "code": "protected theorem eq_sub_of_add_eq (hc : c \u2260 \u221e) : a + c = b \u2192 a = b - c", "start": [1164, 1], "end": [1165, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_eq_of_eq_add_rev", "code": "protected theorem sub_eq_of_eq_add_rev (hb : b \u2260 \u221e) : a = b + c \u2192 a - b = c", "start": [1168, 1], "end": [1169, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_eq_of_add_eq", "code": "theorem sub_eq_of_add_eq (hb : b \u2260 \u221e) (hc : a + b = c) : c - b = a", "start": [1172, 1], "end": [1173, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_sub_cancel_left", "code": "@[simp]\nprotected theorem add_sub_cancel_left (ha : a \u2260 \u221e) : a + b - a = b", "start": [1176, 1], "end": [1178, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_sub_cancel_right", "code": "@[simp]\nprotected theorem add_sub_cancel_right (hb : b \u2260 \u221e) : a + b - b = a", "start": [1181, 1], "end": [1183, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_add_of_sub_lt_left", "code": "protected theorem lt_add_of_sub_lt_left (h : a \u2260 \u221e \u2228 b \u2260 \u221e) : a - b < c \u2192 a < b + c", "start": [1186, 1], "end": [1190, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_add_of_sub_lt_right", "code": "protected theorem lt_add_of_sub_lt_right (h : a \u2260 \u221e \u2228 c \u2260 \u221e) : a - c < b \u2192 a < b + c", "start": [1193, 1], "end": [1194, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_sub_of_add_le_left", "code": "theorem le_sub_of_add_le_left (ha : a \u2260 \u221e) : a + b \u2264 c \u2192 b \u2264 c - a", "start": [1197, 1], "end": [1198, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_sub_of_add_le_right", "code": "theorem le_sub_of_add_le_right (hb : b \u2260 \u221e) : a + b \u2264 c \u2192 a \u2264 c - b", "start": [1201, 1], "end": [1202, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_lt_of_lt_add", "code": "protected theorem sub_lt_of_lt_add (hac : c \u2264 a) (h : a < b + c) : a - c < b", "start": [1205, 1], "end": [1206, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_lt_iff_lt_right", "code": "protected theorem sub_lt_iff_lt_right (hb : b \u2260 \u221e) (hab : b \u2264 a) : a - b < c \u2194 a < c + b", "start": [1209, 1], "end": [1210, 42], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_lt_self", "code": "protected theorem sub_lt_self (ha : a \u2260 \u221e) (ha\u2080 : a \u2260 0) (hb : b \u2260 0) : a - b < a", "start": [1213, 1], "end": [1214, 80], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_lt_self_iff", "code": "protected theorem sub_lt_self_iff (ha : a \u2260 \u221e) : a - b < a \u2194 0 < a \u2227 0 < b", "start": [1217, 1], "end": [1218, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_lt_of_sub_lt", "code": "theorem sub_lt_of_sub_lt (h\u2082 : c \u2264 a) (h\u2083 : a \u2260 \u221e \u2228 b \u2260 \u221e) (h\u2081 : a - b < c) : a - c < b", "start": [1221, 1], "end": [1222, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_sub_cancel", "code": "theorem sub_sub_cancel (h : a \u2260 \u221e) (h2 : b \u2264 a) : a - (a - b) = b", "start": [1225, 1], "end": [1226, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_right_inj", "code": "theorem sub_right_inj {a b c : \u211d\u22650\u221e} (ha : a \u2260 \u221e) (hb : b \u2264 a) (hc : c \u2264 a) :\n    a - b = a - c \u2194 b = c", "start": [1229, 1], "end": [1232, 54], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_mul", "code": "theorem sub_mul (h : 0 < b \u2192 b < a \u2192 c \u2260 \u221e) : (a - b) * c = a * c - b * c", "start": [1235, 1], "end": [1238, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_sub", "code": "theorem mul_sub (h : 0 < c \u2192 c < b \u2192 a \u2260 \u221e) : a * (b - c) = a * b - a * c", "start": [1241, 1], "end": [1243, 18], "kind": "commanddeclaration"}, {"full_name": "ENNReal.prod_lt_top", "code": "theorem prod_lt_top {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 a \u2208 s, f a \u2260 \u221e) : \u220f a in s, f a < \u221e", "start": [1252, 1], "end": [1254, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sum_lt_top", "code": "theorem sum_lt_top {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2200 a \u2208 s, f a \u2260 \u221e) : \u2211 a in s, f a < \u221e", "start": [1257, 1], "end": [1259, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sum_lt_top_iff", "code": "theorem sum_lt_top_iff {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} : \u2211 a in s, f a < \u221e \u2194 \u2200 a \u2208 s, f a < \u221e", "start": [1262, 1], "end": [1264, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sum_eq_top_iff", "code": "theorem sum_eq_top_iff {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} : \u2211 x in s, f x = \u221e \u2194 \u2203 a \u2208 s, f a = \u221e", "start": [1267, 1], "end": [1269, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_top_of_sum_ne_top", "code": "theorem lt_top_of_sum_ne_top {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (h : \u2211 x in s, f x \u2260 \u221e) {a : \u03b1}\n    (ha : a \u2208 s) : f a < \u221e", "start": [1272, 1], "end": [1274, 33], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_sum", "code": "theorem toNNReal_sum {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 a \u2208 s, f a \u2260 \u221e) :\n    ENNReal.toNNReal (\u2211 a in s, f a) = \u2211 a in s, ENNReal.toNNReal (f a)", "start": [1277, 1], "end": [1284, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_sum", "code": "theorem toReal_sum {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : \u2200 a \u2208 s, f a \u2260 \u221e) :\n    ENNReal.toReal (\u2211 a in s, f a) = \u2211 a in s, ENNReal.toReal (f a)", "start": [1287, 1], "end": [1291, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_sum_of_nonneg", "code": "theorem ofReal_sum_of_nonneg {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d} (hf : \u2200 i, i \u2208 s \u2192 0 \u2264 f i) :\n    ENNReal.ofReal (\u2211 i in s, f i) = \u2211 i in s, ENNReal.ofReal (f i)", "start": [1294, 1], "end": [1297, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sum_lt_sum_of_nonempty", "code": "theorem sum_lt_sum_of_nonempty {s : Finset \u03b1} (hs : s.Nonempty) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (Hlt : \u2200 i \u2208 s, f i < g i) : \u2211 i in s, f i < \u2211 i in s, g i", "start": [1300, 1], "end": [1307, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_le_of_sum_le", "code": "theorem exists_le_of_sum_le {s : Finset \u03b1} (hs : s.Nonempty) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n    (Hle : \u2211 i in s, f i \u2264 \u2211 i in s, g i) : \u2203 i \u2208 s, f i \u2264 g i", "start": [1310, 1], "end": [1313, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Ico_eq_Iio", "code": "protected theorem Ico_eq_Iio : Ico 0 y = Iio y", "start": [1322, 1], "end": [1323, 10], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mem_Iio_self_add", "code": "theorem mem_Iio_self_add : x \u2260 \u221e \u2192 \u03b5 \u2260 0 \u2192 x \u2208 Iio (x + \u03b5)", "start": [1326, 1], "end": [1326, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mem_Ioo_self_sub_add", "code": "theorem mem_Ioo_self_sub_add : x \u2260 \u221e \u2192 x \u2260 0 \u2192 \u03b5\u2081 \u2260 0 \u2192 \u03b5\u2082 \u2260 0 \u2192 x \u2208 Ioo (x - \u03b5\u2081) (x + \u03b5\u2082)", "start": [1329, 1], "end": [1330, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_eq_inv_mul", "code": "protected theorem div_eq_inv_mul : a / b = b\u207b\u00b9 * a", "start": [1367, 1], "end": [1367, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_zero", "code": "@[simp] theorem inv_zero : (0 : \u211d\u22650\u221e)\u207b\u00b9 = \u221e", "start": [1370, 1], "end": [1371, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_top", "code": "@[simp] theorem inv_top : \u221e\u207b\u00b9 = 0", "start": [1374, 1], "end": [1375, 101], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_inv_le", "code": "theorem coe_inv_le : (\u2191r\u207b\u00b9 : \u211d\u22650\u221e) \u2264 (\u2191r)\u207b\u00b9", "start": [1378, 1], "end": [1383, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv (hr : r \u2260 0) : (\u2191r\u207b\u00b9 : \u211d\u22650\u221e) = (\u2191r)\u207b\u00b9", "start": [1386, 1], "end": [1388, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_inv_two", "code": "@[norm_cast]\ntheorem coe_inv_two : ((2\u207b\u00b9 : \u211d\u22650) : \u211d\u22650\u221e) = 2\u207b\u00b9", "start": [1391, 1], "end": [1392, 96], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_div", "code": "@[simp, norm_cast]\ntheorem coe_div (hr : r \u2260 0) : (\u2191(p / r) : \u211d\u22650\u221e) = p / r", "start": [1395, 1], "end": [1397, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_zero", "code": "theorem div_zero (h : a \u2260 0) : a / 0 = \u221e", "start": [1400, 1], "end": [1400, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_pow", "code": "protected theorem inv_pow : \u2200 {a : \u211d\u22650\u221e} {n : \u2115}, (a ^ n)\u207b\u00b9 = a\u207b\u00b9 ^ n", "start": [1407, 1], "end": [1415, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_inv_cancel", "code": "protected theorem mul_inv_cancel (h0 : a \u2260 0) (ht : a \u2260 \u221e) : a * a\u207b\u00b9 = 1", "start": [1418, 1], "end": [1421, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_mul_cancel", "code": "protected theorem inv_mul_cancel (h0 : a \u2260 0) (ht : a \u2260 \u221e) : a\u207b\u00b9 * a = 1", "start": [1424, 1], "end": [1425, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_mul_cancel", "code": "protected theorem div_mul_cancel (h0 : a \u2260 0) (hI : a \u2260 \u221e) : b / a * a = b", "start": [1428, 1], "end": [1429, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_div_cancel'", "code": "protected theorem mul_div_cancel' (h0 : a \u2260 0) (hI : a \u2260 \u221e) : a * (b / a) = b", "start": [1432, 1], "end": [1433, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_comm_div", "code": "protected theorem mul_comm_div : a / b * c = a * (c / b)", "start": [1437, 1], "end": [1438, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_div_right_comm", "code": "protected theorem mul_div_right_comm : a * b / c = a / c * b", "start": [1441, 1], "end": [1442, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_eq_top", "code": "@[simp] theorem inv_eq_top : a\u207b\u00b9 = \u221e \u2194 a = 0", "start": [1449, 1], "end": [1449, 67], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_ne_top", "code": "theorem inv_ne_top : a\u207b\u00b9 \u2260 \u221e \u2194 a \u2260 0", "start": [1452, 1], "end": [1452, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_lt_top", "code": "@[simp]\ntheorem inv_lt_top {x : \u211d\u22650\u221e} : x\u207b\u00b9 < \u221e \u2194 0 < x", "start": [1455, 1], "end": [1457, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_lt_top", "code": "theorem div_lt_top {x y : \u211d\u22650\u221e} (h1 : x \u2260 \u221e) (h2 : y \u2260 0) : x / y < \u221e", "start": [1460, 1], "end": [1461, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_eq_zero", "code": "@[simp]\nprotected theorem inv_eq_zero : a\u207b\u00b9 = 0 \u2194 a = \u221e", "start": [1464, 1], "end": [1466, 20], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_ne_zero", "code": "protected theorem inv_ne_zero : a\u207b\u00b9 \u2260 0 \u2194 a \u2260 \u221e", "start": [1469, 1], "end": [1469, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_pos", "code": "protected theorem div_pos (ha : a \u2260 0) (hb : b \u2260 \u221e) : 0 < a / b", "start": [1472, 1], "end": [1473, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_inv", "code": "protected theorem mul_inv {a b : \u211d\u22650\u221e} (ha : a \u2260 0 \u2228 b \u2260 \u221e) (hb : a \u2260 \u221e \u2228 b \u2260 0) :\n    (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9", "start": [1476, 1], "end": [1492, 18], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_div_mul_left", "code": "protected theorem mul_div_mul_left (a b : \u211d\u22650\u221e) (hc : c \u2260 0) (hc' : c \u2260 \u22a4) :\n    c * a / (c * b) = a / b", "start": [1495, 1], "end": [1498, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_div_mul_right", "code": "protected theorem mul_div_mul_right (a b : \u211d\u22650\u221e) (hc : c \u2260 0) (hc' : c \u2260 \u22a4) :\n    a * c / (b * c) = a / b", "start": [1501, 1], "end": [1504, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_div", "code": "protected theorem sub_div (h : 0 < b \u2192 b < a \u2192 c \u2260 0) : (a - b) / c = a / c - b / c", "start": [1507, 1], "end": [1509, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_pos", "code": "@[simp]\nprotected theorem inv_pos : 0 < a\u207b\u00b9 \u2194 a \u2260 \u221e", "start": [1512, 1], "end": [1514, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_strictAnti", "code": "theorem inv_strictAnti : StrictAnti (Inv.inv : \u211d\u22650\u221e \u2192 \u211d\u22650\u221e)", "start": [1517, 1], "end": [1524, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_lt_inv", "code": "@[simp]\nprotected theorem inv_lt_inv : a\u207b\u00b9 < b\u207b\u00b9 \u2194 b < a", "start": [1527, 1], "end": [1529, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_lt_iff_inv_lt", "code": "theorem inv_lt_iff_inv_lt : a\u207b\u00b9 < b \u2194 b\u207b\u00b9 < a", "start": [1532, 1], "end": [1533, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_inv_iff_lt_inv", "code": "theorem lt_inv_iff_lt_inv : a < b\u207b\u00b9 \u2194 b < a\u207b\u00b9", "start": [1536, 1], "end": [1537, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_le_inv", "code": "@[simp]\nprotected theorem inv_le_inv : a\u207b\u00b9 \u2264 b\u207b\u00b9 \u2194 b \u2264 a", "start": [1540, 1], "end": [1542, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_le_iff_inv_le", "code": "theorem inv_le_iff_inv_le : a\u207b\u00b9 \u2264 b \u2194 b\u207b\u00b9 \u2264 a", "start": [1545, 1], "end": [1546, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_inv_iff_le_inv", "code": "theorem le_inv_iff_le_inv : a \u2264 b\u207b\u00b9 \u2194 b \u2264 a\u207b\u00b9", "start": [1549, 1], "end": [1550, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_le_inv'", "code": "@[gcongr] protected theorem inv_le_inv' (h : a \u2264 b) : b\u207b\u00b9 \u2264 a\u207b\u00b9", "start": [1553, 1], "end": [1554, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_lt_inv'", "code": "@[gcongr] protected theorem inv_lt_inv' (h : a < b) : b\u207b\u00b9 < a\u207b\u00b9", "start": [1556, 1], "end": [1556, 92], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_le_one", "code": "@[simp]\nprotected theorem inv_le_one : a\u207b\u00b9 \u2264 1 \u2194 1 \u2264 a", "start": [1558, 1], "end": [1559, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_le_inv", "code": "protected theorem one_le_inv : 1 \u2264 a\u207b\u00b9 \u2194 a \u2264 1", "start": [1562, 1], "end": [1562, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_lt_one", "code": "@[simp]\nprotected theorem inv_lt_one : a\u207b\u00b9 < 1 \u2194 1 < a", "start": [1565, 1], "end": [1566, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_lt_inv", "code": "@[simp]\nprotected theorem one_lt_inv : 1 < a\u207b\u00b9 \u2194 a < 1", "start": [1569, 1], "end": [1570, 85], "kind": "commanddeclaration"}, {"full_name": "OrderIso.invENNReal", "code": "@[simps! apply]\ndef _root_.OrderIso.invENNReal : \u211d\u22650\u221e \u2243o \u211d\u22650\u221e\u1d52\u1d48 where\n  map_rel_iff' := ENNReal.inv_le_inv\n  toEquiv := (Equiv.inv \u211d\u22650\u221e).trans OrderDual.toDual", "start": [1573, 1], "end": [1577, 53], "kind": "commanddeclaration"}, {"full_name": "OrderIso.invENNReal_symm_apply", "code": "@[simp]\ntheorem _root_.OrderIso.invENNReal_symm_apply (a : \u211d\u22650\u221e\u1d52\u1d48) :\n    OrderIso.invENNReal.symm a = (OrderDual.ofDual a)\u207b\u00b9", "start": [1581, 1], "end": [1584, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_top", "code": "@[simp] theorem div_top : a / \u221e = 0", "start": [1587, 1], "end": [1587, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_div", "code": "theorem top_div : \u221e / a = if a = \u221e then 0 else \u221e", "start": [1592, 1], "end": [1592, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_div_of_ne_top", "code": "theorem top_div_of_ne_top (h : a \u2260 \u221e) : \u221e / a = \u221e", "start": [1595, 1], "end": [1595, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_div_coe", "code": "@[simp] theorem top_div_coe : \u221e / p = \u221e", "start": [1598, 1], "end": [1598, 72], "kind": "commanddeclaration"}, {"full_name": "ENNReal.top_div_of_lt_top", "code": "theorem top_div_of_lt_top (h : a < \u221e) : \u221e / a = \u221e", "start": [1601, 1], "end": [1601, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_div", "code": "@[simp] protected theorem zero_div : 0 / a = 0", "start": [1604, 1], "end": [1604, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_eq_top", "code": "theorem div_eq_top : a / b = \u221e \u2194 a \u2260 0 \u2227 b = 0 \u2228 a = \u221e \u2227 b \u2260 \u221e", "start": [1607, 1], "end": [1608, 44], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_div_iff_mul_le", "code": "protected theorem le_div_iff_mul_le (h0 : b \u2260 0 \u2228 c \u2260 0) (ht : b \u2260 \u221e \u2228 c \u2260 \u221e) :\n    a \u2264 c / b \u2194 a * b \u2264 c", "start": [1611, 1], "end": [1621, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_iff_le_mul", "code": "protected theorem div_le_iff_le_mul (hb0 : b \u2260 0 \u2228 c \u2260 \u221e) (hbt : b \u2260 \u221e \u2228 c \u2260 0) :\n    a / b \u2264 c \u2194 a \u2264 c * b", "start": [1624, 1], "end": [1627, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_div_iff_mul_lt", "code": "protected theorem lt_div_iff_mul_lt (hb0 : b \u2260 0 \u2228 c \u2260 \u221e) (hbt : b \u2260 \u221e \u2228 c \u2260 0) :\n    c < a / b \u2194 c * b < a", "start": [1630, 1], "end": [1632, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_of_le_mul", "code": "theorem div_le_of_le_mul (h : a \u2264 b * c) : a / c \u2264 b", "start": [1635, 1], "end": [1640, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_of_le_mul'", "code": "theorem div_le_of_le_mul' (h : a \u2264 b * c) : a / b \u2264 c", "start": [1643, 1], "end": [1644, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_self_le_one", "code": "protected theorem div_self_le_one : a / a \u2264 1", "start": [1647, 1], "end": [1647, 85], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_le_of_le_div", "code": "theorem mul_le_of_le_div (h : a \u2264 b / c) : a * c \u2264 b", "start": [1649, 1], "end": [1651, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_le_of_le_div'", "code": "theorem mul_le_of_le_div' (h : a \u2264 b / c) : c * a \u2264 b", "start": [1654, 1], "end": [1655, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_lt_iff", "code": "protected theorem div_lt_iff (h0 : b \u2260 0 \u2228 c \u2260 0) (ht : b \u2260 \u221e \u2228 c \u2260 \u221e) : c / b < a \u2194 c < a * b", "start": [1658, 1], "end": [1659, 60], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_of_lt_div", "code": "theorem mul_lt_of_lt_div (h : a < b / c) : a * c < b", "start": [1662, 1], "end": [1664, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_lt_of_lt_div'", "code": "theorem mul_lt_of_lt_div' (h : a < b / c) : c * a < b", "start": [1667, 1], "end": [1668, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_lt_of_lt_mul", "code": "theorem div_lt_of_lt_mul (h : a < b * c) : a / c < b", "start": [1671, 1], "end": [1672, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_lt_of_lt_mul'", "code": "theorem div_lt_of_lt_mul' (h : a < b * c) : a / b < c", "start": [1674, 1], "end": [1675, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_le_iff_le_mul", "code": "theorem inv_le_iff_le_mul (h\u2081 : b = \u221e \u2192 a \u2260 0) (h\u2082 : a = \u221e \u2192 b \u2260 0) : a\u207b\u00b9 \u2264 b \u2194 1 \u2264 a * b", "start": [1677, 1], "end": [1679, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_inv_iff_mul_le", "code": "@[simp 900]\ntheorem le_inv_iff_mul_le : a \u2264 b\u207b\u00b9 \u2194 a * b \u2264 1", "start": [1682, 1], "end": [1686, 11], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_div", "code": "@[gcongr] protected theorem div_le_div (hab : a \u2264 b) (hdc : d \u2264 c) : a / c \u2264 b / d", "start": [1689, 1], "end": [1690, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_div_left", "code": "@[gcongr] protected theorem div_le_div_left (h : a \u2264 b) (c : \u211d\u22650\u221e) : c / b \u2264 c / a", "start": [1693, 1], "end": [1694, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_le_div_right", "code": "@[gcongr] protected theorem div_le_div_right (h : a \u2264 b) (c : \u211d\u22650\u221e) : a / c \u2264 b / c", "start": [1697, 1], "end": [1698, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eq_inv_of_mul_eq_one_left", "code": "protected theorem eq_inv_of_mul_eq_one_left (h : a * b = 1) : a = b\u207b\u00b9", "start": [1701, 1], "end": [1705, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_le_iff_le_inv", "code": "theorem mul_le_iff_le_inv {a b r : \u211d\u22650\u221e} (hr\u2080 : r \u2260 0) (hr\u2081 : r \u2260 \u221e) : r * a \u2264 b \u2194 a \u2264 r\u207b\u00b9 * b", "start": [1708, 1], "end": [1710, 13], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_inv_smul_iff", "code": "protected theorem le_inv_smul_iff {a b : \u211d\u22650\u221e} {r : \u211d\u22650} (hr\u2080 : r \u2260 0) : a \u2264 r\u207b\u00b9 \u2022 b \u2194 r \u2022 a \u2264 b", "start": [1713, 1], "end": [1715, 99], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_smul_le_iff", "code": "protected theorem inv_smul_le_iff {a b : \u211d\u22650\u221e} {r : \u211d\u22650} (hr\u2080 : r \u2260 0) : r\u207b\u00b9 \u2022 a \u2264 b \u2194 a \u2264 r \u2022 b", "start": [1718, 1], "end": [1720, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_forall_nnreal_lt", "code": "theorem le_of_forall_nnreal_lt {x y : \u211d\u22650\u221e} (h : \u2200 r : \u211d\u22650, \u2191r < x \u2192 \u2191r \u2264 y) : x \u2264 y", "start": [1723, 1], "end": [1726, 15], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_of_forall_pos_nnreal_lt", "code": "theorem le_of_forall_pos_nnreal_lt {x y : \u211d\u22650\u221e} (h : \u2200 r : \u211d\u22650, 0 < r \u2192 \u2191r < x \u2192 \u2191r \u2264 y) : x \u2264 y", "start": [1729, 1], "end": [1731, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eq_top_of_forall_nnreal_le", "code": "theorem eq_top_of_forall_nnreal_le {x : \u211d\u22650\u221e} (h : \u2200 r : \u211d\u22650, \u2191r \u2264 x) : x = \u221e", "start": [1734, 1], "end": [1735, 54], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_div", "code": "protected theorem add_div : (a + b) / c = a / c + b / c", "start": [1738, 1], "end": [1739, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_add_div_same", "code": "protected theorem div_add_div_same {a b c : \u211d\u22650\u221e} : a / c + b / c = (a + b) / c", "start": [1742, 1], "end": [1743, 23], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_self", "code": "protected theorem div_self (h0 : a \u2260 0) (hI : a \u2260 \u221e) : a / a = 1", "start": [1746, 1], "end": [1747, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_div_le", "code": "theorem mul_div_le : a * (b / a) \u2264 b", "start": [1750, 1], "end": [1751, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.eq_div_iff", "code": "theorem eq_div_iff (ha : a \u2260 0) (ha' : a \u2260 \u221e) : b = c / a \u2194 a * b = c", "start": [1754, 1], "end": [1756, 61], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_eq_div_iff", "code": "protected theorem div_eq_div_iff (ha : a \u2260 0) (ha' : a \u2260 \u221e) (hb : b \u2260 0) (hb' : b \u2260 \u221e) :\n    c / b = d / a \u2194 a * c = b * d", "start": [1759, 1], "end": [1763, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_eq_one_iff", "code": "theorem div_eq_one_iff {a b : \u211d\u22650\u221e} (hb\u2080 : b \u2260 0) (hb\u2081 : b \u2260 \u221e) : a / b = 1 \u2194 a = b", "start": [1766, 1], "end": [1768, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_two_add_inv_two", "code": "theorem inv_two_add_inv_two : (2 : \u211d\u22650\u221e)\u207b\u00b9 + 2\u207b\u00b9 = 1", "start": [1771, 1], "end": [1772, 76], "kind": "commanddeclaration"}, {"full_name": "ENNReal.inv_three_add_inv_three", "code": "theorem inv_three_add_inv_three : (3 : \u211d\u22650\u221e)\u207b\u00b9 + 3\u207b\u00b9 + 3\u207b\u00b9 = 1", "start": [1775, 1], "end": [1777, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_halves", "code": "@[simp]\nprotected theorem add_halves (a : \u211d\u22650\u221e) : a / 2 + a / 2 = a", "start": [1780, 1], "end": [1782, 63], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_thirds", "code": "@[simp]\ntheorem add_thirds (a : \u211d\u22650\u221e) : a / 3 + a / 3 + a / 3 = a", "start": [1785, 1], "end": [1787, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_eq_zero_iff", "code": "@[simp] theorem div_eq_zero_iff : a / b = 0 \u2194 a = 0 \u2228 b = \u221e", "start": [1790, 1], "end": [1790, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.div_pos_iff", "code": "@[simp] theorem div_pos_iff : 0 < a / b \u2194 a \u2260 0 \u2227 b \u2260 \u221e", "start": [1793, 1], "end": [1793, 93], "kind": "commanddeclaration"}, {"full_name": "ENNReal.half_pos", "code": "protected theorem half_pos (h : a \u2260 0) : 0 < a / 2", "start": [1796, 1], "end": [1796, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_half_lt_one", "code": "protected theorem one_half_lt_one : (2\u207b\u00b9 : \u211d\u22650\u221e) < 1", "start": [1799, 1], "end": [1800, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.half_lt_self", "code": "protected theorem half_lt_self (hz : a \u2260 0) (ht : a \u2260 \u221e) : a / 2 < a", "start": [1803, 1], "end": [1807, 50], "kind": "commanddeclaration"}, {"full_name": "ENNReal.half_le_self", "code": "protected theorem half_le_self : a / 2 \u2264 a", "start": [1810, 1], "end": [1811, 47], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_half", "code": "theorem sub_half (h : a \u2260 \u221e) : a - a / 2 = a / 2", "start": [1814, 1], "end": [1816, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.one_sub_inv_two", "code": "@[simp]\ntheorem one_sub_inv_two : (1 : \u211d\u22650\u221e) - 2\u207b\u00b9 = 2\u207b\u00b9", "start": [1819, 1], "end": [1821, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoIicOneBirational", "code": "@[simps! apply_coe]\ndef orderIsoIicOneBirational : \u211d\u22650\u221e \u2243o Iic (1 : \u211d\u22650\u221e) := by\n  refine StrictMono.orderIsoOfRightInverse\n    (fun x => \u27e8(x\u207b\u00b9 + 1)\u207b\u00b9, ENNReal.inv_le_one.2 <| le_add_self\u27e9)\n    (fun x y hxy => ?_) (fun x => (x.1\u207b\u00b9 - 1)\u207b\u00b9) fun x => Subtype.ext ?_\n  \u00b7 simpa only [Subtype.mk_lt_mk, ENNReal.inv_lt_inv, ENNReal.add_lt_add_iff_right one_ne_top]\n  \u00b7 have : (1 : \u211d\u22650\u221e) \u2264 x.1\u207b\u00b9 := ENNReal.one_le_inv.2 x.2\n    simp only [inv_inv, Subtype.coe_mk, tsub_add_cancel_of_le this]", "start": [1824, 1], "end": [1832, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoIicOneBirational_symm_apply", "code": "@[simp]\ntheorem orderIsoIicOneBirational_symm_apply (x : Iic (1 : \u211d\u22650\u221e)) :\n    orderIsoIicOneBirational.symm x = (x.1\u207b\u00b9 - 1)\u207b\u00b9", "start": [1835, 1], "end": [1838, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoIicCoe", "code": "@[simps! apply_coe]\ndef orderIsoIicCoe (a : \u211d\u22650) : Iic (a : \u211d\u22650\u221e) \u2243o Iic a :=\n  OrderIso.symm\n    { toFun := fun x => \u27e8x, coe_le_coe.2 x.2\u27e9\n      invFun := fun x => \u27e8ENNReal.toNNReal x, coe_le_coe.1 <| coe_toNNReal_le_self.trans x.2\u27e9\n      left_inv := fun x => Subtype.ext <| toNNReal_coe\n      right_inv := fun x => Subtype.ext <| coe_toNNReal (ne_top_of_le_ne_top coe_ne_top x.2)\n      map_rel_iff' := fun {_ _} => by\n        simp only [Equiv.coe_fn_mk, Subtype.mk_le_mk, coe_le_coe, Subtype.coe_le_coe] }", "start": [1841, 1], "end": [1850, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoIicCoe_symm_apply_coe", "code": "@[simp]\ntheorem orderIsoIicCoe_symm_apply_coe (a : \u211d\u22650) (b : Iic a) :\n    ((orderIsoIicCoe a).symm b : \u211d\u22650\u221e) = b", "start": [1853, 1], "end": [1856, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoUnitIntervalBirational", "code": "def orderIsoUnitIntervalBirational : \u211d\u22650\u221e \u2243o Icc (0 : \u211d) 1 :=\n  orderIsoIicOneBirational.trans <| (orderIsoIicCoe 1).trans <| (NNReal.orderIsoIccZeroCoe 1).symm", "start": [1859, 1], "end": [1861, 99], "kind": "commanddeclaration"}, {"full_name": "ENNReal.orderIsoUnitIntervalBirational_apply_coe", "code": "@[simp]\ntheorem orderIsoUnitIntervalBirational_apply_coe (x : \u211d\u22650\u221e) :\n    (orderIsoUnitIntervalBirational x : \u211d) = (x\u207b\u00b9 + 1)\u207b\u00b9.toReal", "start": [1864, 1], "end": [1867, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_inv_nat_lt", "code": "theorem exists_inv_nat_lt {a : \u211d\u22650\u221e} (h : a \u2260 0) : \u2203 n : \u2115, (n : \u211d\u22650\u221e)\u207b\u00b9 < a", "start": [1870, 1], "end": [1871, 88], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_nat_pos_mul_gt", "code": "theorem exists_nat_pos_mul_gt (ha : a \u2260 0) (hb : b \u2260 \u221e) : \u2203 n > 0, b < (n : \u2115) * a", "start": [1874, 1], "end": [1877, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_nat_mul_gt", "code": "theorem exists_nat_mul_gt (ha : a \u2260 0) (hb : b \u2260 \u221e) : \u2203 n : \u2115, b < n * a", "start": [1880, 1], "end": [1881, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_nat_pos_inv_mul_lt", "code": "theorem exists_nat_pos_inv_mul_lt (ha : a \u2260 \u221e) (hb : b \u2260 0) :\n    \u2203 n > 0, ((n : \u2115) : \u211d\u22650\u221e)\u207b\u00b9 * a < b", "start": [1884, 1], "end": [1889, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_nnreal_pos_mul_lt", "code": "theorem exists_nnreal_pos_mul_lt (ha : a \u2260 \u221e) (hb : b \u2260 0) : \u2203 n > 0, \u2191(n : \u211d\u22650) * a < b", "start": [1892, 1], "end": [1895, 34], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_inv_two_pow_lt", "code": "theorem exists_inv_two_pow_lt (ha : a \u2260 0) : \u2203 n : \u2115, 2\u207b\u00b9 ^ n < a", "start": [1898, 1], "end": [1903, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.coe_zpow", "code": "@[simp, norm_cast]\ntheorem coe_zpow (hr : r \u2260 0) (n : \u2124) : (\u2191(r ^ n) : \u211d\u22650\u221e) = (r : \u211d\u22650\u221e) ^ n", "start": [1906, 1], "end": [1911, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zpow_pos", "code": "theorem zpow_pos (ha : a \u2260 0) (h'a : a \u2260 \u221e) (n : \u2124) : 0 < a ^ n", "start": [1914, 1], "end": [1917, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zpow_lt_top", "code": "theorem zpow_lt_top (ha : a \u2260 0) (h'a : a \u2260 \u221e) (n : \u2124) : a ^ n < \u221e", "start": [1920, 1], "end": [1923, 68], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_mem_Ico_zpow", "code": "theorem exists_mem_Ico_zpow {x y : \u211d\u22650\u221e} (hx : x \u2260 0) (h'x : x \u2260 \u221e) (hy : 1 < y) (h'y : y \u2260 \u22a4) :\n    \u2203 n : \u2124, x \u2208 Ico (y ^ n) (y ^ (n + 1))", "start": [1926, 1], "end": [1936, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.exists_mem_Ioc_zpow", "code": "theorem exists_mem_Ioc_zpow {x y : \u211d\u22650\u221e} (hx : x \u2260 0) (h'x : x \u2260 \u221e) (hy : 1 < y) (h'y : y \u2260 \u22a4) :\n    \u2203 n : \u2124, x \u2208 Ioc (y ^ n) (y ^ (n + 1))", "start": [1939, 1], "end": [1949, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.Ioo_zero_top_eq_iUnion_Ico_zpow", "code": "theorem Ioo_zero_top_eq_iUnion_Ico_zpow {y : \u211d\u22650\u221e} (hy : 1 < y) (h'y : y \u2260 \u22a4) :\n    Ioo (0 : \u211d\u22650\u221e) (\u221e : \u211d\u22650\u221e) = \u22c3 n : \u2124, Ico (y ^ n) (y ^ (n + 1))", "start": [1952, 1], "end": [1964, 65], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zpow_le_of_le", "code": "@[gcongr]\ntheorem zpow_le_of_le {x : \u211d\u22650\u221e} (hx : 1 \u2264 x) {a b : \u2124} (h : a \u2264 b) : x ^ a \u2264 x ^ b", "start": [1967, 1], "end": [1979, 8], "kind": "commanddeclaration"}, {"full_name": "ENNReal.monotone_zpow", "code": "theorem monotone_zpow {x : \u211d\u22650\u221e} (hx : 1 \u2264 x) : Monotone ((x ^ \u00b7) : \u2124 \u2192 \u211d\u22650\u221e)", "start": [1982, 1], "end": [1983, 21], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zpow_add", "code": "protected theorem zpow_add {x : \u211d\u22650\u221e} (hx : x \u2260 0) (h'x : x \u2260 \u221e) (m n : \u2124) :\n    x ^ (m + n) = x ^ m * x ^ n", "start": [1986, 1], "end": [1990, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_add", "code": "theorem toReal_add (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : (a + b).toReal = a.toReal + b.toReal", "start": [1997, 1], "end": [2000, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_sub_of_le", "code": "theorem toReal_sub_of_le {a b : \u211d\u22650\u221e} (h : b \u2264 a) (ha : a \u2260 \u221e) :\n    (a - b).toReal = a.toReal - b.toReal", "start": [2003, 1], "end": [2007, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_toReal_sub", "code": "theorem le_toReal_sub {a b : \u211d\u22650\u221e} (hb : b \u2260 \u221e) : a.toReal - b.toReal \u2264 (a - b).toReal", "start": [2010, 1], "end": [2015, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_add_le", "code": "theorem toReal_add_le : (a + b).toReal \u2264 a.toReal + b.toReal", "start": [2018, 1], "end": [2022, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_add", "code": "theorem ofReal_add {p q : \u211d} (hp : 0 \u2264 p) (hq : 0 \u2264 q) :\n    ENNReal.ofReal (p + q) = ENNReal.ofReal p + ENNReal.ofReal q", "start": [2025, 1], "end": [2028, 29], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_add_le", "code": "theorem ofReal_add_le {p q : \u211d} : ENNReal.ofReal (p + q) \u2264 ENNReal.ofReal p + ENNReal.ofReal q", "start": [2031, 1], "end": [2032, 36], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_le_toReal", "code": "@[simp]\ntheorem toReal_le_toReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toReal \u2264 b.toReal \u2194 a \u2264 b", "start": [2035, 1], "end": [2039, 12], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_mono", "code": "theorem toReal_mono (hb : b \u2260 \u221e) (h : a \u2264 b) : a.toReal \u2264 b.toReal", "start": [2042, 1], "end": [2043, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_mono'", "code": "theorem toReal_mono' (h : a \u2264 b) (ht : b = \u221e \u2192 a = \u221e) : a.toReal \u2264 b.toReal", "start": [2047, 1], "end": [2050, 35], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_lt_toReal", "code": "@[simp]\ntheorem toReal_lt_toReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toReal < b.toReal \u2194 a < b", "start": [2052, 1], "end": [2056, 12], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_strict_mono", "code": "theorem toReal_strict_mono (hb : b \u2260 \u221e) (h : a < b) : a.toReal < b.toReal", "start": [2059, 1], "end": [2060, 37], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_mono", "code": "theorem toNNReal_mono (hb : b \u2260 \u221e) (h : a \u2264 b) : a.toNNReal \u2264 b.toNNReal", "start": [2063, 1], "end": [2064, 19], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_le_add'", "code": "theorem toReal_le_add' (hle : a \u2264 b + c) (hb : b = \u221e \u2192 a = \u221e) (hc : c = \u221e \u2192 a = \u221e) :\n    a.toReal \u2264 b.toReal + c.toReal", "start": [2068, 1], "end": [2074, 56], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_le_add", "code": "theorem toReal_le_add (hle : a \u2264 b + c) (hb : b \u2260 \u221e) (hc : c \u2260 \u221e) :\n    a.toReal \u2264 b.toReal + c.toReal", "start": [2077, 1], "end": [2082, 55], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_le_toNNReal", "code": "@[simp]\ntheorem toNNReal_le_toNNReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toNNReal \u2264 b.toNNReal \u2194 a \u2264 b", "start": [2084, 1], "end": [2086, 89], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_strict_mono", "code": "theorem toNNReal_strict_mono (hb : b \u2260 \u221e) (h : a < b) : a.toNNReal < b.toNNReal", "start": [2089, 1], "end": [2090, 45], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_lt_toNNReal", "code": "@[simp]\ntheorem toNNReal_lt_toNNReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toNNReal < b.toNNReal \u2194 a < b", "start": [2093, 1], "end": [2095, 96], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_max", "code": "theorem toReal_max (hr : a \u2260 \u221e) (hp : b \u2260 \u221e) :\n    ENNReal.toReal (max a b) = max (ENNReal.toReal a) (ENNReal.toReal b)", "start": [2098, 1], "end": [2102, 69], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_min", "code": "theorem toReal_min {a b : \u211d\u22650\u221e} (hr : a \u2260 \u221e) (hp : b \u2260 \u221e) :\n    ENNReal.toReal (min a b) = min (ENNReal.toReal a) (ENNReal.toReal b)", "start": [2105, 1], "end": [2108, 82], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_sup", "code": "theorem toReal_sup {a b : \u211d\u22650\u221e} : a \u2260 \u221e \u2192 b \u2260 \u221e \u2192 (a \u2294 b).toReal = a.toReal \u2294 b.toReal", "start": [2111, 1], "end": [2112, 13], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_inf", "code": "theorem toReal_inf {a b : \u211d\u22650\u221e} : a \u2260 \u221e \u2192 b \u2260 \u221e \u2192 (a \u2293 b).toReal = a.toReal \u2293 b.toReal", "start": [2115, 1], "end": [2116, 13], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_pos_iff", "code": "theorem toNNReal_pos_iff : 0 < a.toNNReal \u2194 0 < a \u2227 a < \u221e", "start": [2119, 1], "end": [2120, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_pos", "code": "theorem toNNReal_pos {a : \u211d\u22650\u221e} (ha\u2080 : a \u2260 0) (ha_top : a \u2260 \u221e) : 0 < a.toNNReal", "start": [2123, 1], "end": [2124, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_pos_iff", "code": "theorem toReal_pos_iff : 0 < a.toReal \u2194 0 < a \u2227 a < \u221e", "start": [2127, 1], "end": [2128, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_pos", "code": "theorem toReal_pos {a : \u211d\u22650\u221e} (ha\u2080 : a \u2260 0) (ha_top : a \u2260 \u221e) : 0 < a.toReal", "start": [2131, 1], "end": [2132, 79], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_le_ofReal", "code": "theorem ofReal_le_ofReal {p q : \u211d} (h : p \u2264 q) : ENNReal.ofReal p \u2264 ENNReal.ofReal q", "start": [2135, 1], "end": [2136, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_le_of_le_toReal", "code": "theorem ofReal_le_of_le_toReal {a : \u211d} {b : \u211d\u22650\u221e} (h : a \u2264 ENNReal.toReal b) :\n    ENNReal.ofReal a \u2264 b", "start": [2139, 1], "end": [2141, 46], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_le_ofReal_iff", "code": "@[simp]\ntheorem ofReal_le_ofReal_iff {p q : \u211d} (h : 0 \u2264 q) : ENNReal.ofReal p \u2264 ENNReal.ofReal q \u2194 p \u2264 q", "start": [2144, 1], "end": [2146, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_eq_ofReal_iff", "code": "@[simp]\ntheorem ofReal_eq_ofReal_iff {p q : \u211d} (hp : 0 \u2264 p) (hq : 0 \u2264 q) :\n    ENNReal.ofReal p = ENNReal.ofReal q \u2194 p = q", "start": [2149, 1], "end": [2152, 87], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_lt_ofReal_iff", "code": "@[simp]\ntheorem ofReal_lt_ofReal_iff {p q : \u211d} (h : 0 < q) : ENNReal.ofReal p < ENNReal.ofReal q \u2194 p < q", "start": [2155, 1], "end": [2157, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_lt_ofReal_iff_of_nonneg", "code": "theorem ofReal_lt_ofReal_iff_of_nonneg {p q : \u211d} (hp : 0 \u2264 p) :\n    ENNReal.ofReal p < ENNReal.ofReal q \u2194 p < q", "start": [2160, 1], "end": [2162, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_pos", "code": "@[simp]\ntheorem ofReal_pos {p : \u211d} : 0 < ENNReal.ofReal p \u2194 0 < p", "start": [2165, 1], "end": [2166, 86], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_eq_zero", "code": "@[simp]\ntheorem ofReal_eq_zero {p : \u211d} : ENNReal.ofReal p = 0 \u2194 p \u2264 0", "start": [2169, 1], "end": [2170, 90], "kind": "commanddeclaration"}, {"full_name": "ENNReal.zero_eq_ofReal", "code": "@[simp]\ntheorem zero_eq_ofReal {p : \u211d} : 0 = ENNReal.ofReal p \u2194 p \u2264 0", "start": [2173, 1], "end": [2175, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_of_nonpos", "code": "alias \u27e8_, ofReal_of_nonpos\u27e9 := ofReal_eq_zero", "start": [2178, 1], "end": [2178, 46], "kind": "stdtacticaliasaliaslr"}, {"full_name": "ENNReal.ofReal_sub", "code": "theorem ofReal_sub (p : \u211d) {q : \u211d} (hq : 0 \u2264 q) :\n    ENNReal.ofReal (p - q) = ENNReal.ofReal p - ENNReal.ofReal q", "start": [2181, 1], "end": [2186, 60], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_le_iff_le_toReal", "code": "theorem ofReal_le_iff_le_toReal {a : \u211d} {b : \u211d\u22650\u221e} (hb : b \u2260 \u221e) :\n    ENNReal.ofReal a \u2264 b \u2194 a \u2264 ENNReal.toReal b", "start": [2189, 1], "end": [2192, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_lt_iff_lt_toReal", "code": "theorem ofReal_lt_iff_lt_toReal {a : \u211d} {b : \u211d\u22650\u221e} (ha : 0 \u2264 a) (hb : b \u2260 \u221e) :\n    ENNReal.ofReal a < b \u2194 a < ENNReal.toReal b", "start": [2195, 1], "end": [2198, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_lt_coe_iff", "code": "theorem ofReal_lt_coe_iff {a : \u211d} {b : \u211d\u22650} (ha : 0 \u2264 a) : ENNReal.ofReal a < b \u2194 a < b", "start": [2201, 1], "end": [2202, 70], "kind": "commanddeclaration"}, {"full_name": "ENNReal.le_ofReal_iff_toReal_le", "code": "theorem le_ofReal_iff_toReal_le {a : \u211d\u22650\u221e} {b : \u211d} (ha : a \u2260 \u221e) (hb : 0 \u2264 b) :\n    a \u2264 ENNReal.ofReal b \u2194 ENNReal.toReal a \u2264 b", "start": [2204, 1], "end": [2207, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_le_of_le_ofReal", "code": "theorem toReal_le_of_le_ofReal {a : \u211d\u22650\u221e} {b : \u211d} (hb : 0 \u2264 b) (h : a \u2264 ENNReal.ofReal b) :\n    ENNReal.toReal a \u2264 b", "start": [2210, 1], "end": [2213, 38], "kind": "commanddeclaration"}, {"full_name": "ENNReal.lt_ofReal_iff_toReal_lt", "code": "theorem lt_ofReal_iff_toReal_lt {a : \u211d\u22650\u221e} {b : \u211d} (ha : a \u2260 \u221e) :\n    a < ENNReal.ofReal b \u2194 ENNReal.toReal a < b", "start": [2216, 1], "end": [2219, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_lt_of_lt_ofReal", "code": "theorem toReal_lt_of_lt_ofReal {b : \u211d} (h : a < ENNReal.ofReal b) : ENNReal.toReal a < b", "start": [2222, 1], "end": [2223, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_mul", "code": "theorem ofReal_mul {p q : \u211d} (hp : 0 \u2264 p) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q", "start": [2225, 1], "end": [2227, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_mul'", "code": "theorem ofReal_mul' {p q : \u211d} (hq : 0 \u2264 q) :\n    ENNReal.ofReal (p * q) = ENNReal.ofReal p * ENNReal.ofReal q", "start": [2230, 1], "end": [2232, 41], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_pow", "code": "theorem ofReal_pow {p : \u211d} (hp : 0 \u2264 p) (n : \u2115) : ENNReal.ofReal (p ^ n) = ENNReal.ofReal p ^ n", "start": [2235, 1], "end": [2236, 97], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_nsmul", "code": "theorem ofReal_nsmul {x : \u211d} {n : \u2115} : ENNReal.ofReal (n \u2022 x) = n \u2022 ENNReal.ofReal x", "start": [2239, 1], "end": [2240, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_inv_of_pos", "code": "theorem ofReal_inv_of_pos {x : \u211d} (hx : 0 < x) : (ENNReal.ofReal x)\u207b\u00b9 = ENNReal.ofReal x\u207b\u00b9", "start": [2243, 1], "end": [2245, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_div_of_pos", "code": "theorem ofReal_div_of_pos {x y : \u211d} (hy : 0 < y) :\n    ENNReal.ofReal (x / y) = ENNReal.ofReal x / ENNReal.ofReal y", "start": [2248, 1], "end": [2250, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_mul", "code": "@[simp]\ntheorem toNNReal_mul {a b : \u211d\u22650\u221e} : (a * b).toNNReal = a.toNNReal * b.toNNReal", "start": [2253, 1], "end": [2255, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_mul_top", "code": "theorem toNNReal_mul_top (a : \u211d\u22650\u221e) : ENNReal.toNNReal (a * \u221e) = 0", "start": [2258, 1], "end": [2258, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_top_mul", "code": "theorem toNNReal_top_mul (a : \u211d\u22650\u221e) : ENNReal.toNNReal (\u221e * a) = 0", "start": [2261, 1], "end": [2261, 78], "kind": "commanddeclaration"}, {"full_name": "ENNReal.smul_toNNReal", "code": "@[simp]\ntheorem smul_toNNReal (a : \u211d\u22650) (b : \u211d\u22650\u221e) : (a \u2022 b).toNNReal = a * b.toNNReal", "start": [2264, 1], "end": [2267, 57], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNRealHom", "code": "def toNNRealHom : \u211d\u22650\u221e \u2192* \u211d\u22650 where\n  toFun := ENNReal.toNNReal\n  map_one' := toNNReal_coe\n  map_mul' _ _ := toNNReal_mul", "start": [2271, 1], "end": [2275, 31], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_pow", "code": "@[simp]\ntheorem toNNReal_pow (a : \u211d\u22650\u221e) (n : \u2115) : (a ^ n).toNNReal = a.toNNReal ^ n", "start": [2278, 1], "end": [2280, 26], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_prod", "code": "@[simp]\ntheorem toNNReal_prod {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (\u220f i in s, f i).toNNReal = \u220f i in s, (f i).toNNReal", "start": [2283, 1], "end": [2286, 27], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toRealHom", "code": "def toRealHom : \u211d\u22650\u221e \u2192* \u211d :=\n  (NNReal.toRealHom : \u211d\u22650 \u2192* \u211d).comp toNNRealHom", "start": [2290, 1], "end": [2292, 49], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_mul", "code": "@[simp]\ntheorem toReal_mul : (a * b).toReal = a.toReal * b.toReal", "start": [2295, 1], "end": [2297, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_nsmul", "code": "theorem toReal_nsmul (a : \u211d\u22650\u221e) (n : \u2115) : (n \u2022 a).toReal = n \u2022 a.toReal", "start": [2300, 1], "end": [2300, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_pow", "code": "@[simp]\ntheorem toReal_pow (a : \u211d\u22650\u221e) (n : \u2115) : (a ^ n).toReal = a.toReal ^ n", "start": [2302, 1], "end": [2304, 24], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_prod", "code": "@[simp]\ntheorem toReal_prod {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} :\n    (\u220f i in s, f i).toReal = \u220f i in s, (f i).toReal", "start": [2307, 1], "end": [2310, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_ofReal_mul", "code": "theorem toReal_ofReal_mul (c : \u211d) (a : \u211d\u22650\u221e) (h : 0 \u2264 c) :\n    ENNReal.toReal (ENNReal.ofReal c * a) = c * ENNReal.toReal a", "start": [2313, 1], "end": [2315, 51], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_mul_top", "code": "theorem toReal_mul_top (a : \u211d\u22650\u221e) : ENNReal.toReal (a * \u221e) = 0", "start": [2318, 1], "end": [2319, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_top_mul", "code": "theorem toReal_top_mul (a : \u211d\u22650\u221e) : ENNReal.toReal (\u221e * a) = 0", "start": [2322, 1], "end": [2324, 25], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_eq_toReal", "code": "theorem toReal_eq_toReal (ha : a \u2260 \u221e) (hb : b \u2260 \u221e) : a.toReal = b.toReal \u2194 a = b", "start": [2327, 1], "end": [2330, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_smul", "code": "theorem toReal_smul (r : \u211d\u22650) (s : \u211d\u22650\u221e) : (r \u2022 s).toReal = r \u2022 s.toReal", "start": [2333, 1], "end": [2335, 6], "kind": "commanddeclaration"}, {"full_name": "ENNReal.trichotomy", "code": "protected theorem trichotomy (p : \u211d\u22650\u221e) : p = 0 \u2228 p = \u221e \u2228 0 < p.toReal", "start": [2338, 1], "end": [2339, 52], "kind": "commanddeclaration"}, {"full_name": "ENNReal.trichotomy\u2082", "code": "protected theorem trichotomy\u2082 {p q : \u211d\u22650\u221e} (hpq : p \u2264 q) :\n    p = 0 \u2227 q = 0 \u2228\n      p = 0 \u2227 q = \u221e \u2228\n        p = 0 \u2227 0 < q.toReal \u2228\n          p = \u221e \u2227 q = \u221e \u2228\n            0 < p.toReal \u2227 q = \u221e \u2228 0 < p.toReal \u2227 0 < q.toReal \u2227 p.toReal \u2264 q.toReal", "start": [2342, 1], "end": [2355, 94], "kind": "commanddeclaration"}, {"full_name": "ENNReal.dichotomy", "code": "protected theorem dichotomy (p : \u211d\u22650\u221e) [Fact (1 \u2264 p)] : p = \u221e \u2228 1 \u2264 p.toReal", "start": [2358, 1], "end": [2361, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_pos_iff_ne_top", "code": "theorem toReal_pos_iff_ne_top (p : \u211d\u22650\u221e) [Fact (1 \u2264 p)] : 0 < p.toReal \u2194 p \u2260 \u221e", "start": [2364, 1], "end": [2368, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_inv", "code": "theorem toNNReal_inv (a : \u211d\u22650\u221e) : a\u207b\u00b9.toNNReal = a.toNNReal\u207b\u00b9", "start": [2371, 1], "end": [2374, 48], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_div", "code": "theorem toNNReal_div (a b : \u211d\u22650\u221e) : (a / b).toNNReal = a.toNNReal / b.toNNReal", "start": [2377, 1], "end": [2378, 66], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_inv", "code": "theorem toReal_inv (a : \u211d\u22650\u221e) : a\u207b\u00b9.toReal = a.toReal\u207b\u00b9", "start": [2381, 1], "end": [2382, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_div", "code": "theorem toReal_div (a b : \u211d\u22650\u221e) : (a / b).toReal = a.toReal / b.toReal", "start": [2385, 1], "end": [2386, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.ofReal_prod_of_nonneg", "code": "theorem ofReal_prod_of_nonneg {s : Finset \u03b1} {f : \u03b1 \u2192 \u211d} (hf : \u2200 i, i \u2208 s \u2192 0 \u2264 f i) :\n    ENNReal.ofReal (\u220f i in s, f i) = \u220f i in s, ENNReal.ofReal (f i)", "start": [2389, 1], "end": [2392, 40], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_iInf", "code": "theorem toNNReal_iInf (hf : \u2200 i, f i \u2260 \u221e) : (iInf f).toNNReal = \u2a05 i, (f i).toNNReal", "start": [2408, 1], "end": [2412, 39], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_sInf", "code": "theorem toNNReal_sInf (s : Set \u211d\u22650\u221e) (hs : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sInf s).toNNReal = sInf (ENNReal.toNNReal '' s)", "start": [2415, 1], "end": [2420, 98], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_iSup", "code": "theorem toNNReal_iSup (hf : \u2200 i, f i \u2260 \u221e) : (iSup f).toNNReal = \u2a06 i, (f i).toNNReal", "start": [2423, 1], "end": [2428, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toNNReal_sSup", "code": "theorem toNNReal_sSup (s : Set \u211d\u22650\u221e) (hs : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sSup s).toNNReal = sSup (ENNReal.toNNReal '' s)", "start": [2431, 1], "end": [2436, 98], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_iInf", "code": "theorem toReal_iInf (hf : \u2200 i, f i \u2260 \u221e) : (iInf f).toReal = \u2a05 i, (f i).toReal", "start": [2439, 1], "end": [2440, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_sInf", "code": "theorem toReal_sInf (s : Set \u211d\u22650\u221e) (hf : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sInf s).toReal = sInf (ENNReal.toReal '' s)", "start": [2443, 1], "end": [2445, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_iSup", "code": "theorem toReal_iSup (hf : \u2200 i, f i \u2260 \u221e) : (iSup f).toReal = \u2a06 i, (f i).toReal", "start": [2448, 1], "end": [2449, 64], "kind": "commanddeclaration"}, {"full_name": "ENNReal.toReal_sSup", "code": "theorem toReal_sSup (s : Set \u211d\u22650\u221e) (hf : \u2200 r \u2208 s, r \u2260 \u221e) :\n    (sSup s).toReal = sSup (ENNReal.toReal '' s)", "start": [2452, 1], "end": [2454, 83], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_add", "code": "theorem iInf_add : iInf f + a = \u2a05 i, f i + a", "start": [2457, 1], "end": [2459, 81], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_sub", "code": "theorem iSup_sub : (\u2a06 i, f i) - a = \u2a06 i, f i - a", "start": [2462, 1], "end": [2464, 62], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sub_iInf", "code": "theorem sub_iInf : (a - \u2a05 i, f i) = \u2a06 i, a - f i", "start": [2467, 1], "end": [2470, 53], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sInf_add", "code": "theorem sInf_add {s : Set \u211d\u22650\u221e} : sInf s + a = \u2a05 b \u2208 s, b + a", "start": [2473, 1], "end": [2473, 98], "kind": "commanddeclaration"}, {"full_name": "ENNReal.add_iInf", "code": "theorem add_iInf {a : \u211d\u22650\u221e} : a + iInf f = \u2a05 b, a + f b", "start": [2476, 1], "end": [2477, 43], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_add_iInf", "code": "theorem iInf_add_iInf (h : \u2200 i j, \u2203 k, f k + g k \u2264 f i + g j) : iInf f + iInf g = \u2a05 a, f a + g a", "start": [2480, 1], "end": [2486, 59], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_sum", "code": "theorem iInf_sum {f : \u03b9 \u2192 \u03b1 \u2192 \u211d\u22650\u221e} {s : Finset \u03b1} [Nonempty \u03b9]\n    (h : \u2200 (t : Finset \u03b1) (i j : \u03b9), \u2203 k, \u2200 a \u2208 t, f k a \u2264 f i a \u2227 f k a \u2264 f j a) :\n    \u2a05 i, \u2211 a in s, f i a = \u2211 a in s, \u2a05 i, f i a", "start": [2489, 1], "end": [2498, 74], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul_of_ne", "code": "theorem iInf_mul_of_ne {\u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} {x : \u211d\u22650\u221e} (h0 : x \u2260 0) (h : x \u2260 \u221e) :\n    iInf f * x = \u2a05 i, f i * x", "start": [2501, 1], "end": [2507, 95], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iInf_mul", "code": "theorem iInf_mul {\u03b9} [Nonempty \u03b9] {f : \u03b9 \u2192 \u211d\u22650\u221e} {x : \u211d\u22650\u221e} (h : x \u2260 \u221e) :\n    iInf f * x = \u2a05 i, f i * x", "start": [2510, 1], "end": [2516, 30], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_iInf", "code": "theorem mul_iInf {\u03b9} [Nonempty \u03b9] {f : \u03b9 \u2192 \u211d\u22650\u221e} {x : \u211d\u22650\u221e} (h : x \u2260 \u221e) :\n    x * iInf f = \u2a05 i, x * f i", "start": [2519, 1], "end": [2522, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.mul_iInf_of_ne", "code": "theorem mul_iInf_of_ne {\u03b9} {f : \u03b9 \u2192 \u211d\u22650\u221e} {x : \u211d\u22650\u221e} (h0 : x \u2260 0) (h : x \u2260 \u221e) :\n    x * iInf f = \u2a05 i, x * f i", "start": [2525, 1], "end": [2528, 84], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_eq_zero", "code": "@[simp]\ntheorem iSup_eq_zero {\u03b9 : Sort*} {f : \u03b9 \u2192 \u211d\u22650\u221e} : \u2a06 i, f i = 0 \u2194 \u2200 i, f i = 0", "start": [2537, 1], "end": [2539, 14], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_zero_eq_zero", "code": "@[simp]\ntheorem iSup_zero_eq_zero {\u03b9 : Sort*} : \u2a06 _ : \u03b9, (0 : \u211d\u22650\u221e) = 0", "start": [2542, 1], "end": [2543, 75], "kind": "commanddeclaration"}, {"full_name": "ENNReal.sup_eq_zero", "code": "theorem sup_eq_zero {a b : \u211d\u22650\u221e} : a \u2294 b = 0 \u2194 a = 0 \u2227 b = 0", "start": [2546, 1], "end": [2547, 17], "kind": "commanddeclaration"}, {"full_name": "ENNReal.iSup_coe_nat", "code": "theorem iSup_coe_nat : \u2a06 n : \u2115, (n : \u211d\u22650\u221e) = \u221e", "start": [2550, 1], "end": [2551, 80], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_coe_nnreal_ennreal", "code": "theorem preimage_coe_nnreal_ennreal (h : u.OrdConnected) : ((\u2191) \u207b\u00b9' u : Set \u211d\u22650).OrdConnected", "start": [2566, 1], "end": [2567, 35], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_coe_nnreal_ennreal", "code": "theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((\u2191) '' t : Set \u211d\u22650\u221e).OrdConnected", "start": [2571, 1], "end": [2574, 96], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.preimage_ennreal_ofReal", "code": "theorem preimage_ennreal_ofReal (h : u.OrdConnected) : (ENNReal.ofReal \u207b\u00b9' u).OrdConnected", "start": [2577, 1], "end": [2578, 55], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.image_ennreal_ofReal", "code": "theorem image_ennreal_ofReal (h : s.OrdConnected) : (ENNReal.ofReal '' s).OrdConnected", "start": [2581, 1], "end": [2582, 80], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalENNRealtoReal", "code": "@[positivity ENNReal.toReal _]\ndef evalENNRealtoReal : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app (f : Q(ENNReal \u2192 Real)) (a : Q(ENNReal))) \u2190 whnfR e | throwError \"not ENNReal.toReal\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(ENNReal.toReal)\n  pure (.nonnegative (q(@ENNReal.toReal_nonneg $a) : Expr))", "start": [2593, 1], "end": [2598, 60], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalENNRealOfReal", "code": "@[positivity ENNReal.ofReal _]\ndef evalENNRealOfReal : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app (f : Q(Real \u2192 ENNReal)) (a : Q(Real))) \u2190 whnfR e | throwError \"not ENNReal.ofReal\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(ENNReal.ofReal)\n  let z\u03b1' \u2190 synthInstanceQ (q(Zero Real) : Q(Type))\n  let p\u03b1' \u2190 synthInstanceQ (q(PartialOrder Real) : Q(Type))\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  assertInstancesCommute\n  match ra with\n  | .positive pa => pure (.positive (q(Iff.mpr (@ENNReal.ofReal_pos $a) $pa) : Expr))\n  | _ => pure .none", "start": [2600, 1], "end": [2611, 20], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalENNRealSome", "code": "@[positivity ENNReal.some _]\ndef evalENNRealSome : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let (.app (f : Q(NNReal \u2192 ENNReal)) (a : Q(NNReal))) \u2190 whnfR e | throwError \"not ENNReal.some\"\n  guard <|\u2190 withDefault <| withNewMCtxDepth <| isDefEq f q(ENNReal.some)\n  let z\u03b1' \u2190 synthInstanceQ (q(Zero NNReal) : Q(Type))\n  let p\u03b1' \u2190 synthInstanceQ (q(PartialOrder NNReal) : Q(Type))\n  let ra \u2190 core z\u03b1' p\u03b1' a\n  assertInstancesCommute\n  match ra with\n  | .positive pa => pure (.positive (q(Iff.mpr (@ENNReal.coe_pos $a) $pa) : Expr))\n  | _ => pure .none", "start": [2613, 1], "end": [2624, 20], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Ring/Basic.lean", "imports": ["Mathlib/RingTheory/Subring/Basic.lean", "Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Algebra/Ring/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalSemiring", "code": "class TopologicalSemiring [TopologicalSpace \u03b1] [NonUnitalNonAssocSemiring \u03b1] extends\n  ContinuousAdd \u03b1, ContinuousMul \u03b1 : Prop", "start": [36, 1], "end": [45, 42], "kind": "commanddeclaration"}, {"full_name": "TopologicalRing", "code": "class TopologicalRing [TopologicalSpace \u03b1] [NonUnitalNonAssocRing \u03b1] extends TopologicalSemiring \u03b1,\n  ContinuousNeg \u03b1 : Prop", "start": [48, 1], "end": [55, 25], "kind": "commanddeclaration"}, {"full_name": "TopologicalSemiring.continuousNeg_of_mul", "code": "theorem TopologicalSemiring.continuousNeg_of_mul [TopologicalSpace \u03b1] [NonAssocRing \u03b1]\n    [ContinuousMul \u03b1] : ContinuousNeg \u03b1 where", "start": [60, 1], "end": [65, 86], "kind": "commanddeclaration"}, {"full_name": "TopologicalSemiring.toTopologicalRing", "code": "theorem TopologicalSemiring.toTopologicalRing [TopologicalSpace \u03b1] [NonAssocRing \u03b1]\n    (_ : TopologicalSemiring \u03b1) : TopologicalRing \u03b1 where", "start": [68, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "TopologicalRing.to_topologicalAddGroup", "code": "instance (priority := 100) TopologicalRing.to_topologicalAddGroup [NonUnitalNonAssocRing \u03b1]\n    [TopologicalSpace \u03b1] [TopologicalRing \u03b1] : TopologicalAddGroup \u03b1 := \u27e8\u27e9", "start": [77, 1], "end": [78, 75], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.topologicalSemiring", "code": "instance (priority := 50) DiscreteTopology.topologicalSemiring [TopologicalSpace \u03b1]\n    [NonUnitalNonAssocSemiring \u03b1] [DiscreteTopology \u03b1] : TopologicalSemiring \u03b1 := \u27e8\u27e9", "start": [81, 1], "end": [82, 85], "kind": "commanddeclaration"}, {"full_name": "DiscreteTopology.topologicalRing", "code": "instance (priority := 50) DiscreteTopology.topologicalRing [TopologicalSpace \u03b1]\n    [NonUnitalNonAssocRing \u03b1] [DiscreteTopology \u03b1] : TopologicalRing \u03b1 := \u27e8\u27e9", "start": [85, 1], "end": [86, 77], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.topologicalSemiring", "code": "instance topologicalSemiring (S : Subsemiring \u03b1) : TopologicalSemiring S :=\n  { S.toSubmonoid.continuousMul, S.toAddSubmonoid.continuousAdd with }", "start": [96, 1], "end": [97, 71], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.topologicalClosure", "code": "def Subsemiring.topologicalClosure (s : Subsemiring \u03b1) : Subsemiring \u03b1 :=\n  { s.toSubmonoid.topologicalClosure, s.toAddSubmonoid.topologicalClosure with\n    carrier := _root_.closure (s : Set \u03b1) }", "start": [101, 1], "end": [105, 44], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.topologicalClosure_coe", "code": "@[simp]\ntheorem Subsemiring.topologicalClosure_coe (s : Subsemiring \u03b1) :\n    (s.topologicalClosure : Set \u03b1) = _root_.closure (s : Set \u03b1)", "start": [108, 1], "end": [111, 6], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.le_topologicalClosure", "code": "theorem Subsemiring.le_topologicalClosure (s : Subsemiring \u03b1) : s \u2264 s.topologicalClosure", "start": [114, 1], "end": [115, 24], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.isClosed_topologicalClosure", "code": "theorem Subsemiring.isClosed_topologicalClosure (s : Subsemiring \u03b1) :\n    IsClosed (s.topologicalClosure : Set \u03b1)", "start": [118, 1], "end": [119, 64], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.topologicalClosure_minimal", "code": "theorem Subsemiring.topologicalClosure_minimal (s : Subsemiring \u03b1) {t : Subsemiring \u03b1} (h : s \u2264 t)\n    (ht : IsClosed (t : Set \u03b1)) : s.topologicalClosure \u2264 t", "start": [122, 1], "end": [124, 23], "kind": "commanddeclaration"}, {"full_name": "Subsemiring.commSemiringTopologicalClosure", "code": "def Subsemiring.commSemiringTopologicalClosure [T2Space \u03b1] (s : Subsemiring \u03b1)\n    (hs : \u2200 x y : s, x * y = y * x) : CommSemiring s.topologicalClosure :=\n  { s.topologicalClosure.toSemiring, s.toSubmonoid.commMonoidTopologicalClosure hs with }", "start": [127, 1], "end": [131, 90], "kind": "commanddeclaration"}, {"full_name": "Pi.instTopologicalSemiring", "code": "instance Pi.instTopologicalSemiring {\u03b2 : Type*} {C : \u03b2 \u2192 Type*} [\u2200 b, TopologicalSpace (C b)]\n    [\u2200 b, NonUnitalNonAssocSemiring (C b)] [\u2200 b, TopologicalSemiring (C b)] :\n    TopologicalSemiring (\u2200 b, C b) where", "start": [152, 1], "end": [154, 41], "kind": "commanddeclaration"}, {"full_name": "Pi.instTopologicalRing", "code": "instance Pi.instTopologicalRing {\u03b2 : Type*} {C : \u03b2 \u2192 Type*} [\u2200 b, TopologicalSpace (C b)]\n    [\u2200 b, NonUnitalNonAssocRing (C b)] [\u2200 b, TopologicalRing (C b)] :\n    TopologicalRing (\u2200 b, C b) := \u27e8\u27e9", "start": [157, 1], "end": [159, 37], "kind": "commanddeclaration"}, {"full_name": "TopologicalRing.of_addGroup_of_nhds_zero", "code": "theorem TopologicalRing.of_addGroup_of_nhds_zero [TopologicalAddGroup R]\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : R \u2192 R \u2192 R)) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hmul_left : \u2200 x\u2080 : R, Tendsto (fun x : R => x\u2080 * x) (\ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hmul_right : \u2200 x\u2080 : R, Tendsto (fun x : R => x * x\u2080) (\ud835\udcdd 0) <| \ud835\udcdd 0) : TopologicalRing R where", "start": [201, 1], "end": [207, 90], "kind": "commanddeclaration"}, {"full_name": "TopologicalRing.of_nhds_zero", "code": "theorem TopologicalRing.of_nhds_zero\n    (hadd : Tendsto (uncurry ((\u00b7 + \u00b7) : R \u2192 R \u2192 R)) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hneg : Tendsto (fun x => -x : R \u2192 R) (\ud835\udcdd 0) (\ud835\udcdd 0))\n    (hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : R \u2192 R \u2192 R)) (\ud835\udcdd 0 \u00d7\u02e2 \ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hmul_left : \u2200 x\u2080 : R, Tendsto (fun x : R => x\u2080 * x) (\ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hmul_right : \u2200 x\u2080 : R, Tendsto (fun x : R => x * x\u2080) (\ud835\udcdd 0) <| \ud835\udcdd 0)\n    (hleft : \u2200 x\u2080 : R, \ud835\udcdd x\u2080 = map (fun x => x\u2080 + x) (\ud835\udcdd 0)) : TopologicalRing R", "start": [210, 1], "end": [218, 69], "kind": "commanddeclaration"}, {"full_name": "mulLeft_continuous", "code": "theorem mulLeft_continuous (x : \u03b1) : Continuous (AddMonoidHom.mulLeft x)", "start": [229, 1], "end": [231, 37], "kind": "commanddeclaration"}, {"full_name": "mulRight_continuous", "code": "theorem mulRight_continuous (x : \u03b1) : Continuous (AddMonoidHom.mulRight x)", "start": [234, 1], "end": [236, 37], "kind": "commanddeclaration"}, {"full_name": "Subring.instTopologicalRing", "code": "instance Subring.instTopologicalRing (S : Subring \u03b1) : TopologicalRing S :=\n  { S.toSubmonoid.continuousMul, inferInstanceAs (TopologicalAddGroup S.toAddSubgroup) with }", "start": [243, 1], "end": [244, 94], "kind": "commanddeclaration"}, {"full_name": "Subring.topologicalClosure", "code": "def Subring.topologicalClosure (S : Subring \u03b1) : Subring \u03b1 :=\n  { S.toSubmonoid.topologicalClosure, S.toAddSubgroup.topologicalClosure with\n    carrier := _root_.closure (S : Set \u03b1) }", "start": [246, 1], "end": [250, 44], "kind": "commanddeclaration"}, {"full_name": "Subring.le_topologicalClosure", "code": "theorem Subring.le_topologicalClosure (s : Subring \u03b1) : s \u2264 s.topologicalClosure", "start": [253, 1], "end": [254, 24], "kind": "commanddeclaration"}, {"full_name": "Subring.isClosed_topologicalClosure", "code": "theorem Subring.isClosed_topologicalClosure (s : Subring \u03b1) :\n    IsClosed (s.topologicalClosure : Set \u03b1)", "start": [257, 1], "end": [258, 64], "kind": "commanddeclaration"}, {"full_name": "Subring.topologicalClosure_minimal", "code": "theorem Subring.topologicalClosure_minimal (s : Subring \u03b1) {t : Subring \u03b1} (h : s \u2264 t)\n    (ht : IsClosed (t : Set \u03b1)) : s.topologicalClosure \u2264 t", "start": [261, 1], "end": [263, 23], "kind": "commanddeclaration"}, {"full_name": "Subring.commRingTopologicalClosure", "code": "def Subring.commRingTopologicalClosure [T2Space \u03b1] (s : Subring \u03b1) (hs : \u2200 x y : s, x * y = y * x) :\n    CommRing s.topologicalClosure :=\n  { s.topologicalClosure.toRing, s.toSubmonoid.commMonoidTopologicalClosure hs with }", "start": [266, 1], "end": [269, 86], "kind": "commanddeclaration"}, {"full_name": "RingTopology", "code": "structure RingTopology (\u03b1 : Type u) [Ring \u03b1] extends TopologicalSpace \u03b1, TopologicalRing \u03b1 : Type u", "start": [287, 1], "end": [289, 100], "kind": "commanddeclaration"}, {"full_name": "RingTopology.inhabited", "code": "instance inhabited {\u03b1 : Type u} [Ring \u03b1] : Inhabited (RingTopology \u03b1) :=\n  \u27e8let _ : TopologicalSpace \u03b1 := \u22a4;\n    { continuous_add := continuous_top\n      continuous_mul := continuous_top\n      continuous_neg := continuous_top }\u27e9", "start": [296, 1], "end": [300, 42], "kind": "commanddeclaration"}, {"full_name": "RingTopology.toTopologicalSpace_injective", "code": "theorem toTopologicalSpace_injective :\n    Injective (toTopologicalSpace : RingTopology \u03b1 \u2192 TopologicalSpace \u03b1)", "start": [303, 1], "end": [305, 39], "kind": "commanddeclaration"}, {"full_name": "RingTopology.ext", "code": "@[ext]\ntheorem ext {f g : RingTopology \u03b1} (h : f.IsOpen = g.IsOpen) : f = g", "start": [307, 1], "end": [309, 57], "kind": "commanddeclaration"}, {"full_name": "RingTopology.def_sInf", "code": "private def def_sInf (S : Set (RingTopology \u03b1)) : RingTopology \u03b1 :=\n  let _ := sInf (toTopologicalSpace '' S)\n  { toContinuousAdd := continuousAdd_sInf <| ball_image_iff.2 fun t _ =>\n      let _ := t.1; t.toContinuousAdd\n    toContinuousMul := continuousMul_sInf <| ball_image_iff.2 fun t _ =>\n      let _ := t.1; t.toContinuousMul\n    toContinuousNeg := continuousNeg_sInf <| ball_image_iff.2 fun t _ =>\n      let _ := t.1; t.toContinuousNeg }", "start": [317, 1], "end": [324, 40], "kind": "commanddeclaration"}, {"full_name": "RingTopology.coinduced", "code": "def coinduced {\u03b1 \u03b2 : Type*} [t : TopologicalSpace \u03b1] [Ring \u03b2] (f : \u03b1 \u2192 \u03b2) : RingTopology \u03b2 :=\n  sInf { b : RingTopology \u03b2 | t.coinduced f \u2264 b.toTopologicalSpace }", "start": [342, 1], "end": [345, 69], "kind": "commanddeclaration"}, {"full_name": "RingTopology.coinduced_continuous", "code": "theorem coinduced_continuous {\u03b1 \u03b2 : Type*} [t : TopologicalSpace \u03b1] [Ring \u03b2] (f : \u03b1 \u2192 \u03b2) :\n    Continuous[t, (coinduced f).toTopologicalSpace] f", "start": [348, 1], "end": [350, 83], "kind": "commanddeclaration"}, {"full_name": "RingTopology.toAddGroupTopology", "code": "def toAddGroupTopology (t : RingTopology \u03b1) : AddGroupTopology \u03b1 where\n  toTopologicalSpace := t.toTopologicalSpace\n  toTopologicalAddGroup :=\n    @TopologicalRing.to_topologicalAddGroup _ _ t.toTopologicalSpace t.toTopologicalRing", "start": [353, 1], "end": [357, 89], "kind": "commanddeclaration"}, {"full_name": "RingTopology.toAddGroupTopology.orderEmbedding", "code": "def toAddGroupTopology.orderEmbedding : OrderEmbedding (RingTopology \u03b1) (AddGroupTopology \u03b1) :=\n  OrderEmbedding.ofMapLEIff toAddGroupTopology fun _ _ => Iff.rfl", "start": [360, 1], "end": [362, 66], "kind": "commanddeclaration"}, {"full_name": "AbsoluteValue.comp", "code": "def AbsoluteValue.comp {R S T : Type*} [Semiring T] [Semiring R] [OrderedSemiring S]\n    (v : AbsoluteValue R S) {f : T \u2192+* R} (hf : Function.Injective f) : AbsoluteValue T S where\n  toMulHom := v.1.comp f\n  nonneg' _ := v.nonneg _\n  eq_zero' _ := v.eq_zero.trans (map_eq_zero_iff f hf)\n  add_le' _ _ := (congr_arg v (map_add f _ _)).trans_le (v.add_le _ _)", "start": [369, 1], "end": [376, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/FieldTheory/Subfield.lean", "imports": ["Mathlib/Algebra/Order/Field/InjSurj.lean", "Mathlib/Algebra/Algebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SubfieldClass", "code": "class SubfieldClass (S K : Type*) [Field K] [SetLike S K] extends SubringClass S K,\n  InvMemClass S K : Prop", "start": [70, 1], "end": [72, 25], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.toSubgroupClass", "code": "instance (priority := 100) toSubgroupClass : SubgroupClass S K :=\n  { h with }", "start": [80, 1], "end": [86, 13], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.coe_rat_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem coe_rat_mem (s : S) (x : \u211a) : (x : K) \u2208 s", "start": [91, 1], "end": [93, 86], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.coe_rat_cast", "code": "@[simp]\ntheorem coe_rat_cast (s : S) (x : \u211a) : ((x : s) : K) = x", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.rat_smul_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\ntheorem rat_smul_mem (s : S) (a : \u211a) (x : s) : a \u2022 (x : K) \u2208 s", "start": [105, 1], "end": [107, 67], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.ofScientific_mem", "code": "@[aesop safe apply (rule_sets [SetLike])]\nlemma ofScientific_mem (s : S) {b : Bool} {n m : \u2115} :\n    (OfScientific.ofScientific n b m : K) \u2208 s :=\n  SubfieldClass.coe_rat_mem ..", "start": [110, 1], "end": [113, 31], "kind": "mathlibtacticlemma"}, {"full_name": "SubfieldClass.coe_rat_smul", "code": "@[simp]\ntheorem coe_rat_smul (s : S) (a : \u211a) (x : s) : (a \u2022 x : K) = a \u2022 (x : K)", "start": [118, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.toField", "code": "instance (priority := 75) toField (s : S) : Field s :=\n  Subtype.coe_injective.field ((\u2191) : s \u2192 K)\n    (by rfl) (by rfl) (by intros _ _; rfl) (by intros _ _; rfl) (by intros _; rfl)\n    (by intros _ _; rfl) (by intros _; rfl) (by intros _ _; rfl) (by intros _ _; rfl)\n    (by intros _ _; rfl) (by intros _ _; rfl) (by intros _ _; rfl) (by intros _ _; rfl)\n    (by intros _; rfl) (by intros _; rfl) (by intros _; rfl)", "start": [126, 1], "end": [132, 61], "kind": "commanddeclaration"}, {"full_name": "SubfieldClass.toLinearOrderedField", "code": "instance (priority := 75) toLinearOrderedField {K} [LinearOrderedField K] [SetLike S K]\n    [SubfieldClass S K] (s : S) : LinearOrderedField s :=\n  Subtype.coe_injective.linearOrderedField (\u2191) rfl rfl (fun _ _ => rfl)\n    (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [136, 1], "end": [143, 66], "kind": "commanddeclaration"}, {"full_name": "Subfield", "code": "structure Subfield (K : Type u) [Field K] extends Subring K where\n  \n  inv_mem' : \u2200 x \u2208 carrier, x\u207b\u00b9 \u2208 carrier", "start": [148, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "Subfield.toAddSubgroup", "code": "def toAddSubgroup (s : Subfield K) : AddSubgroup K :=\n  { s.toSubring.toAddSubgroup with }", "start": [161, 1], "end": [163, 37], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_carrier", "code": "theorem mem_carrier {s : Subfield K} {x : K} : x \u2208 s.carrier \u2194 x \u2208 s", "start": [185, 1], "end": [186, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_mk", "code": "@[simp]\ntheorem mem_mk {S : Subring K} {x : K} (h) : x \u2208 (\u27e8S, h\u27e9 : Subfield K) \u2194 x \u2208 S", "start": [190, 1], "end": [192, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_set_mk", "code": "@[simp]\ntheorem coe_set_mk (S : Subring K) (h) : ((\u27e8S, h\u27e9 : Subfield K) : Set K) = S", "start": [195, 1], "end": [197, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mk_le_mk", "code": "@[simp]\ntheorem mk_le_mk {S S' : Subring K} (h h') : (\u27e8S, h\u27e9 : Subfield K) \u2264 (\u27e8S', h'\u27e9 : Subfield K) \u2194\n    S \u2264 S'", "start": [200, 1], "end": [203, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.ext", "code": "@[ext]\ntheorem ext {S T : Subfield K} (h : \u2200 x, x \u2208 S \u2194 x \u2208 T) : S = T", "start": [206, 1], "end": [209, 16], "kind": "commanddeclaration"}, {"full_name": "Subfield.copy", "code": "protected def copy (S : Subfield K) (s : Set K) (hs : s = \u2191S) : Subfield K :=\n  { S.toSubring.copy s hs with\n    carrier := s\n    inv_mem' := hs.symm \u25b8 S.inv_mem' }", "start": [212, 1], "end": [217, 39], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_copy", "code": "@[simp]\ntheorem coe_copy (S : Subfield K) (s : Set K) (hs : s = \u2191S) : (S.copy s hs : Set K) = s", "start": [220, 1], "end": [222, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.copy_eq", "code": "theorem copy_eq (S : Subfield K) (s : Set K) (hs : s = \u2191S) : S.copy s hs = S", "start": [225, 1], "end": [226, 27], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_toSubring", "code": "@[simp]\ntheorem coe_toSubring (s : Subfield K) : (s.toSubring : Set K) = s", "start": [229, 1], "end": [231, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_toSubring", "code": "@[simp]\ntheorem mem_toSubring (s : Subfield K) (x : K) : x \u2208 s.toSubring \u2194 x \u2208 s", "start": [234, 1], "end": [236, 10], "kind": "commanddeclaration"}, {"full_name": "Subring.toSubfield", "code": "def Subring.toSubfield (s : Subring K) (hinv : \u2200 x \u2208 s, x\u207b\u00b9 \u2208 s) : Subfield K :=\n  { s with inv_mem' := hinv }", "start": [241, 1], "end": [243, 30], "kind": "commanddeclaration"}, {"full_name": "Subfield.one_mem", "code": "protected theorem one_mem : (1 : K) \u2208 s", "start": [252, 1], "end": [254, 12], "kind": "commanddeclaration"}, {"full_name": "Subfield.zero_mem", "code": "protected theorem zero_mem : (0 : K) \u2208 s", "start": [257, 1], "end": [259, 13], "kind": "commanddeclaration"}, {"full_name": "Subfield.mul_mem", "code": "protected theorem mul_mem {x y : K} : x \u2208 s \u2192 y \u2208 s \u2192 x * y \u2208 s", "start": [262, 1], "end": [264, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.add_mem", "code": "protected theorem add_mem {x y : K} : x \u2208 s \u2192 y \u2208 s \u2192 x + y \u2208 s", "start": [267, 1], "end": [269, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.neg_mem", "code": "protected theorem neg_mem {x : K} : x \u2208 s \u2192 -x \u2208 s", "start": [272, 1], "end": [274, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.sub_mem", "code": "protected theorem sub_mem {x y : K} : x \u2208 s \u2192 y \u2208 s \u2192 x - y \u2208 s", "start": [277, 1], "end": [279, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.inv_mem", "code": "protected theorem inv_mem {x : K} : x \u2208 s \u2192 x\u207b\u00b9 \u2208 s", "start": [282, 1], "end": [284, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.div_mem", "code": "protected theorem div_mem {x y : K} : x \u2208 s \u2192 y \u2208 s \u2192 x / y \u2208 s", "start": [287, 1], "end": [289, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.list_prod_mem", "code": "protected theorem list_prod_mem {l : List K} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.prod \u2208 s", "start": [292, 1], "end": [294, 16], "kind": "commanddeclaration"}, {"full_name": "Subfield.list_sum_mem", "code": "protected theorem list_sum_mem {l : List K} : (\u2200 x \u2208 l, x \u2208 s) \u2192 l.sum \u2208 s", "start": [297, 1], "end": [299, 15], "kind": "commanddeclaration"}, {"full_name": "Subfield.multiset_prod_mem", "code": "protected theorem multiset_prod_mem (m : Multiset K) : (\u2200 a \u2208 m, a \u2208 s) \u2192 m.prod \u2208 s", "start": [302, 1], "end": [304, 22], "kind": "commanddeclaration"}, {"full_name": "Subfield.multiset_sum_mem", "code": "protected theorem multiset_sum_mem (m : Multiset K) : (\u2200 a \u2208 m, a \u2208 s) \u2192 m.sum \u2208 s", "start": [307, 1], "end": [309, 21], "kind": "commanddeclaration"}, {"full_name": "Subfield.prod_mem", "code": "protected theorem prod_mem {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 K} (h : \u2200 c \u2208 t, f c \u2208 s) :\n    (\u220f i in t, f i) \u2208 s", "start": [312, 1], "end": [315, 13], "kind": "commanddeclaration"}, {"full_name": "Subfield.sum_mem", "code": "protected theorem sum_mem {\u03b9 : Type*} {t : Finset \u03b9} {f : \u03b9 \u2192 K} (h : \u2200 c \u2208 t, f c \u2208 s) :\n    (\u2211 i in t, f i) \u2208 s", "start": [318, 1], "end": [321, 12], "kind": "commanddeclaration"}, {"full_name": "Subfield.pow_mem", "code": "protected theorem pow_mem {x : K} (hx : x \u2208 s) (n : \u2115) : x ^ n \u2208 s", "start": [324, 1], "end": [325, 15], "kind": "commanddeclaration"}, {"full_name": "Subfield.zsmul_mem", "code": "protected theorem zsmul_mem {x : K} (hx : x \u2208 s) (n : \u2124) : n \u2022 x \u2208 s", "start": [328, 1], "end": [329, 17], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_int_mem", "code": "protected theorem coe_int_mem (n : \u2124) : (n : K) \u2208 s", "start": [332, 1], "end": [333, 18], "kind": "commanddeclaration"}, {"full_name": "Subfield.zpow_mem", "code": "theorem zpow_mem {x : K} (hx : x \u2208 s) (n : \u2124) : x ^ n \u2208 s", "start": [336, 1], "end": [339, 69], "kind": "commanddeclaration"}, {"full_name": "Subfield.toField", "code": "instance toField : Field s :=\n  Subtype.coe_injective.field ((\u2191) : s \u2192 K) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ => rfl) fun _ => rfl", "start": [354, 1], "end": [358, 98], "kind": "commanddeclaration"}, {"full_name": "Subfield.toLinearOrderedField", "code": "instance toLinearOrderedField {K} [LinearOrderedField K] (s : Subfield K) : LinearOrderedField s :=\n  Subtype.coe_injective.linearOrderedField (\u2191) rfl rfl (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ => rfl) (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)\n    (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) (fun _ => rfl)\n    (fun _ => rfl) (fun _ => rfl) (fun _ _ => rfl) fun _ _ => rfl", "start": [361, 1], "end": [366, 66], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : s) : (\u2191(x + y) : K) = \u2191x + \u2191y", "start": [369, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (x y : s) : (\u2191(x - y) : K) = \u2191x - \u2191y", "start": [374, 1], "end": [376, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (x : s) : (\u2191(-x) : K) = -\u2191x", "start": [379, 1], "end": [381, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : s) : (\u2191(x * y) : K) = \u2191x * \u2191y", "start": [384, 1], "end": [386, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_div", "code": "@[simp, norm_cast]\ntheorem coe_div (x y : s) : (\u2191(x / y) : K) = \u2191x / \u2191y", "start": [389, 1], "end": [391, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_inv", "code": "@[simp, norm_cast]\ntheorem coe_inv (x : s) : (\u2191x\u207b\u00b9 : K) = (\u2191x)\u207b\u00b9", "start": [394, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : ((0 : s) : K) = 0", "start": [399, 1], "end": [401, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : ((1 : s) : K) = 1", "start": [404, 1], "end": [406, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.subtype", "code": "def subtype (s : Subfield K) : s \u2192+* K :=\n  { s.toSubmonoid.subtype, s.toAddSubgroup.subtype with toFun := (\u2191) }", "start": [411, 1], "end": [413, 71], "kind": "commanddeclaration"}, {"full_name": "Subfield.toAlgebra", "code": "instance toAlgebra : Algebra s K :=\n  RingHom.toAlgebra s.subtype", "start": [416, 1], "end": [417, 30], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_subtype", "code": "@[simp]\ntheorem coe_subtype : \u21d1(s.subtype) = ((\u2191) : s \u2192 K)", "start": [420, 1], "end": [422, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.toSubring_subtype_eq_subtype", "code": "theorem toSubring_subtype_eq_subtype (F : Type*) [Field F] (S : Subfield F) :\n    S.toSubring.subtype = S.subtype", "start": [425, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_toSubmonoid", "code": "theorem mem_toSubmonoid {s : Subfield K} {x : K} : x \u2208 s.toSubmonoid \u2194 x \u2208 s", "start": [434, 1], "end": [435, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_toSubmonoid", "code": "@[simp]\ntheorem coe_toSubmonoid : (s.toSubmonoid : Set K) = s", "start": [438, 1], "end": [440, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_toAddSubgroup", "code": "@[simp]\ntheorem mem_toAddSubgroup {s : Subfield K} {x : K} : x \u2208 s.toAddSubgroup \u2194 x \u2208 s", "start": [443, 1], "end": [445, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_toAddSubgroup", "code": "@[simp]\ntheorem coe_toAddSubgroup : (s.toAddSubgroup : Set K) = s", "start": [448, 1], "end": [450, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_top", "code": "@[simp]\ntheorem mem_top (x : K) : x \u2208 (\u22a4 : Subfield K)", "start": [463, 1], "end": [465, 17], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_top", "code": "@[simp]\ntheorem coe_top : ((\u22a4 : Subfield K) : Set K) = Set.univ", "start": [468, 1], "end": [470, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.topEquiv", "code": "@[simps!]\ndef topEquiv : (\u22a4 : Subfield K) \u2243+* K :=\n  Subsemiring.topEquiv", "start": [473, 1], "end": [476, 23], "kind": "commanddeclaration"}, {"full_name": "Subfield.comap", "code": "def comap (s : Subfield L) : Subfield K :=\n  { s.toSubring.comap f with\n    inv_mem' := fun x hx =>\n      show f x\u207b\u00b9 \u2208 s by\n        rw [map_inv\u2080 f]\n        exact s.inv_mem hx }", "start": [484, 1], "end": [490, 29], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_comap", "code": "@[simp]\ntheorem coe_comap (s : Subfield L) : (s.comap f : Set K) = f \u207b\u00b9' s", "start": [493, 1], "end": [495, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_comap", "code": "@[simp]\ntheorem mem_comap {s : Subfield L} {f : K \u2192+* L} {x : K} : x \u2208 s.comap f \u2194 f x \u2208 s", "start": [498, 1], "end": [500, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.comap_comap", "code": "theorem comap_comap (s : Subfield M) (g : L \u2192+* M) (f : K \u2192+* L) :\n    (s.comap g).comap f = s.comap (g.comp f)", "start": [503, 1], "end": [505, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.map", "code": "def map (s : Subfield K) : Subfield L :=\n  { s.toSubring.map f with\n    inv_mem' := by\n      rintro _ \u27e8x, hx, rfl\u27e9\n      exact \u27e8x\u207b\u00b9, s.inv_mem hx, map_inv\u2080 f x\u27e9 }", "start": [511, 1], "end": [516, 48], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_map", "code": "@[simp]\ntheorem coe_map : (s.map f : Set L) = f '' s", "start": [519, 1], "end": [521, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_map", "code": "@[simp]\ntheorem mem_map {f : K \u2192+* L} {s : Subfield K} {y : L} : y \u2208 s.map f \u2194 \u2203 x \u2208 s, f x = y", "start": [524, 1], "end": [527, 96], "kind": "commanddeclaration"}, {"full_name": "Subfield.map_map", "code": "theorem map_map (g : L \u2192+* M) (f : K \u2192+* L) : (s.map f).map g = s.map (g.comp f)", "start": [530, 1], "end": [531, 40], "kind": "commanddeclaration"}, {"full_name": "Subfield.map_le_iff_le_comap", "code": "theorem map_le_iff_le_comap {f : K \u2192+* L} {s : Subfield K} {t : Subfield L} :\n    s.map f \u2264 t \u2194 s \u2264 t.comap f", "start": [534, 1], "end": [536, 23], "kind": "commanddeclaration"}, {"full_name": "Subfield.gc_map_comap", "code": "theorem gc_map_comap (f : K \u2192+* L) : GaloisConnection (map f) (comap f)", "start": [539, 1], "end": [540, 22], "kind": "commanddeclaration"}, {"full_name": "RingHom.fieldRange", "code": "def fieldRange : Subfield L :=\n  ((\u22a4 : Subfield K).map f).copy (Set.range f) Set.image_univ.symm", "start": [552, 1], "end": [554, 66], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_fieldRange", "code": "@[simp]\ntheorem coe_fieldRange : (f.fieldRange : Set L) = Set.range f", "start": [557, 1], "end": [559, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.mem_fieldRange", "code": "@[simp]\ntheorem mem_fieldRange {f : K \u2192+* L} {y : L} : y \u2208 f.fieldRange \u2194 \u2203 x, f x = y", "start": [562, 1], "end": [564, 10], "kind": "commanddeclaration"}, {"full_name": "RingHom.fieldRange_eq_map", "code": "theorem fieldRange_eq_map : f.fieldRange = Subfield.map f \u22a4", "start": [567, 1], "end": [569, 7], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_fieldRange", "code": "theorem map_fieldRange : f.fieldRange.map g = (g.comp f).fieldRange", "start": [572, 1], "end": [573, 68], "kind": "commanddeclaration"}, {"full_name": "RingHom.fintypeFieldRange", "code": "instance fintypeFieldRange [Fintype K] [DecidableEq L] (f : K \u2192+* L) : Fintype f.fieldRange :=\n  Set.fintypeRange f", "start": [576, 1], "end": [580, 21], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_inf", "code": "@[simp]\ntheorem coe_inf (p p' : Subfield K) : ((p \u2293 p' : Subfield K) : Set K) = p.carrier \u2229 p'.carrier", "start": [598, 1], "end": [600, 6], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_inf", "code": "@[simp]\ntheorem mem_inf {p p' : Subfield K} {x : K} : x \u2208 p \u2293 p' \u2194 x \u2208 p \u2227 x \u2208 p'", "start": [603, 1], "end": [605, 10], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_sInf", "code": "@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subfield K)) : ((sInf S : Subfield K) : Set K) = \u22c2 s \u2208 S, \u2191s", "start": [617, 1], "end": [625, 54], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_sInf", "code": "theorem mem_sInf {S : Set (Subfield K)} {x : K} : x \u2208 sInf S \u2194 \u2200 p \u2208 S, x \u2208 p", "start": [628, 1], "end": [630, 91], "kind": "commanddeclaration"}, {"full_name": "Subfield.sInf_toSubring", "code": "@[simp]\ntheorem sInf_toSubring (s : Set (Subfield K)) :\n    (sInf s).toSubring = \u2a05 t \u2208 s, Subfield.toSubring t", "start": [633, 1], "end": [645, 70], "kind": "commanddeclaration"}, {"full_name": "Subfield.isGLB_sInf", "code": "theorem isGLB_sInf (S : Set (Subfield K)) : IsGLB S (sInf S)", "start": [648, 1], "end": [652, 19], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure", "code": "def closure (s : Set K) : Subfield K where\n  carrier := {z : K | \u2203 (x : K) (_ : x \u2208 Subring.closure s) (y : K)\n    (_ : y \u2208 Subring.closure s), x / y = z}\n  zero_mem' := \u27e80, Subring.zero_mem _, 1, Subring.one_mem _, div_one _\u27e9\n  one_mem' := \u27e81, Subring.one_mem _, 1, Subring.one_mem _, div_one _\u27e9\n  neg_mem' {x} := by\n    rintro \u27e8y, hy, z, hz, x_eq\u27e9\n    exact \u27e8-y, Subring.neg_mem _ hy, z, hz, x_eq \u25b8 neg_div _ _\u27e9\n  inv_mem' x := by rintro \u27e8y, hy, z, hz, x_eq\u27e9; exact \u27e8z, hz, y, hy, x_eq \u25b8 (inv_div _ _).symm \u27e9\n  add_mem' x_mem y_mem := by\n    obtain \u27e8nx, hnx, dx, hdx, rfl\u27e9 := id x_mem\n    obtain \u27e8ny, hny, dy, hdy, rfl\u27e9 := id y_mem\n    by_cases hx0 : dx = 0; \u00b7 rwa [hx0, div_zero, zero_add]\n    by_cases hy0 : dy = 0; \u00b7 rwa [hy0, div_zero, add_zero]\n    exact\n      \u27e8nx * dy + dx * ny, Subring.add_mem _ (Subring.mul_mem _ hnx hdy) (Subring.mul_mem _ hdx hny),\n        dx * dy, Subring.mul_mem _ hdx hdy, (div_add_div nx ny hx0 hy0).symm\u27e9\n  mul_mem' x_mem y_mem := by\n    obtain \u27e8nx, hnx, dx, hdx, rfl\u27e9 := id x_mem\n    obtain \u27e8ny, hny, dy, hdy, rfl\u27e9 := id y_mem\n    exact\n      \u27e8nx * ny, Subring.mul_mem _ hnx hny, dx * dy, Subring.mul_mem _ hdx hdy,\n        (div_mul_div_comm _ _ _ _).symm\u27e9", "start": [667, 1], "end": [690, 41], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_closure_iff", "code": "theorem mem_closure_iff {s : Set K} {x} :\n    x \u2208 closure s \u2194 \u2203 y \u2208 Subring.closure s, \u2203 z \u2208 Subring.closure s, y / z = x", "start": [693, 1], "end": [696, 53], "kind": "commanddeclaration"}, {"full_name": "Subfield.subring_closure_le", "code": "theorem subring_closure_le (s : Set K) : Subring.closure s \u2264 (closure s).toSubring", "start": [699, 1], "end": [700, 43], "kind": "commanddeclaration"}, {"full_name": "Subfield.subset_closure", "code": "@[simp, aesop safe 20 apply (rule_sets [SetLike])]\ntheorem subset_closure {s : Set K} : s \u2286 closure s", "start": [703, 1], "end": [706, 65], "kind": "commanddeclaration"}, {"full_name": "Subfield.not_mem_of_not_mem_closure", "code": "theorem not_mem_of_not_mem_closure {s : Set K} {P : K} (hP : P \u2209 closure s) : P \u2209 s", "start": [709, 1], "end": [710, 24], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_closure", "code": "theorem mem_closure {x : K} {s : Set K} : x \u2208 closure s \u2194 \u2200 S : Subfield K, s \u2286 S \u2192 x \u2208 S", "start": [713, 1], "end": [718, 43], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_le", "code": "@[simp]\ntheorem closure_le {s : Set K} {t : Subfield K} : closure s \u2264 t \u2194 s \u2286 t", "start": [721, 1], "end": [724, 73], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_mono", "code": "theorem closure_mono \u2983s t : Set K\u2984 (h : s \u2286 t) : closure s \u2264 closure t", "start": [727, 1], "end": [730, 52], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_eq_of_le", "code": "theorem closure_eq_of_le {s : Set K} {t : Subfield K} (h\u2081 : s \u2286 t) (h\u2082 : t \u2264 closure s) :\n    closure s = t", "start": [733, 1], "end": [735, 35], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_induction", "code": "@[elab_as_elim]\ntheorem closure_induction {s : Set K} {p : K \u2192 Prop} {x} (h : x \u2208 closure s) (Hs : \u2200 x \u2208 s, p x)\n    (H1 : p 1) (Hadd : \u2200 x y, p x \u2192 p y \u2192 p (x + y)) (Hneg : \u2200 x, p x \u2192 p (-x))\n    (Hinv : \u2200 x, p x \u2192 p x\u207b\u00b9) (Hmul : \u2200 x y, p x \u2192 p y \u2192 p (x * y)) : p x", "start": [738, 1], "end": [749, 42], "kind": "commanddeclaration"}, {"full_name": "Subfield.gi", "code": "protected def gi : GaloisInsertion (@closure K _) (\u2191) where\n  choice s _ := closure s\n  gc _ _ := closure_le\n  le_l_u _ := subset_closure\n  choice_eq _ _ := rfl", "start": [754, 1], "end": [759, 23], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_eq", "code": "theorem closure_eq (s : Subfield K) : closure (s : Set K) = s", "start": [764, 1], "end": [766, 27], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_empty", "code": "@[simp]\ntheorem closure_empty : closure (\u2205 : Set K) = \u22a5", "start": [769, 1], "end": [771, 27], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_univ", "code": "@[simp]\ntheorem closure_univ : closure (Set.univ : Set K) = \u22a4", "start": [774, 1], "end": [776, 30], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_union", "code": "theorem closure_union (s t : Set K) : closure (s \u222a t) = closure s \u2294 closure t", "start": [779, 1], "end": [780, 27], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_iUnion", "code": "theorem closure_iUnion {\u03b9} (s : \u03b9 \u2192 Set K) : closure (\u22c3 i, s i) = \u2a06 i, closure (s i)", "start": [783, 1], "end": [784, 28], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_sUnion", "code": "theorem closure_sUnion (s : Set (Set K)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t", "start": [787, 1], "end": [788, 28], "kind": "commanddeclaration"}, {"full_name": "Subfield.map_sup", "code": "theorem map_sup (s t : Subfield K) (f : K \u2192+* L) : (s \u2294 t).map f = s.map f \u2294 t.map f", "start": [791, 1], "end": [792, 25], "kind": "commanddeclaration"}, {"full_name": "Subfield.map_iSup", "code": "theorem map_iSup {\u03b9 : Sort*} (f : K \u2192+* L) (s : \u03b9 \u2192 Subfield K) :\n    (iSup s).map f = \u2a06 i, (s i).map f", "start": [795, 1], "end": [797, 26], "kind": "commanddeclaration"}, {"full_name": "Subfield.comap_inf", "code": "theorem comap_inf (s t : Subfield L) (f : K \u2192+* L) : (s \u2293 t).comap f = s.comap f \u2293 t.comap f", "start": [800, 1], "end": [801, 25], "kind": "commanddeclaration"}, {"full_name": "Subfield.comap_iInf", "code": "theorem comap_iInf {\u03b9 : Sort*} (f : K \u2192+* L) (s : \u03b9 \u2192 Subfield L) :\n    (iInf s).comap f = \u2a05 i, (s i).comap f", "start": [804, 1], "end": [806, 26], "kind": "commanddeclaration"}, {"full_name": "Subfield.map_bot", "code": "@[simp]\ntheorem map_bot (f : K \u2192+* L) : (\u22a5 : Subfield K).map f = \u22a5", "start": [809, 1], "end": [811, 25], "kind": "commanddeclaration"}, {"full_name": "Subfield.comap_top", "code": "@[simp]\ntheorem comap_top (f : K \u2192+* L) : (\u22a4 : Subfield L).comap f = \u22a4", "start": [814, 1], "end": [816, 25], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_iSup_of_directed", "code": "theorem mem_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subfield K} (hS : Directed (\u00b7 \u2264 \u00b7) S)\n    {x : K} : (x \u2208 \u2a06 i, S i) \u2194 \u2203 i, x \u2208 S i", "start": [819, 1], "end": [838, 47], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_iSup_of_directed", "code": "theorem coe_iSup_of_directed {\u03b9} [h\u03b9 : Nonempty \u03b9] {S : \u03b9 \u2192 Subfield K} (hS : Directed (\u00b7 \u2264 \u00b7) S) :\n    ((\u2a06 i, S i : Subfield K) : Set K) = \u22c3 i, \u2191(S i)", "start": [841, 1], "end": [843, 53], "kind": "commanddeclaration"}, {"full_name": "Subfield.mem_sSup_of_directedOn", "code": "theorem mem_sSup_of_directedOn {S : Set (Subfield K)} (Sne : S.Nonempty) (hS : DirectedOn (\u00b7 \u2264 \u00b7) S)\n    {x : K} : x \u2208 sSup S \u2194 \u2203 s \u2208 S, x \u2208 s", "start": [846, 1], "end": [849, 95], "kind": "commanddeclaration"}, {"full_name": "Subfield.coe_sSup_of_directedOn", "code": "theorem coe_sSup_of_directedOn {S : Set (Subfield K)} (Sne : S.Nonempty)\n    (hS : DirectedOn (\u00b7 \u2264 \u00b7) S) : (\u2191(sSup S) : Set K) = \u22c3 s \u2208 S, \u2191s", "start": [852, 1], "end": [854, 59], "kind": "commanddeclaration"}, {"full_name": "RingHom.rangeRestrictField", "code": "def rangeRestrictField (f : K \u2192+* L) : K \u2192+* f.fieldRange :=\n  f.rangeSRestrict", "start": [865, 1], "end": [867, 19], "kind": "commanddeclaration"}, {"full_name": "RingHom.coe_rangeRestrictField", "code": "@[simp]\ntheorem coe_rangeRestrictField (f : K \u2192+* L) (x : K) : (f.rangeRestrictField x : L) = f x", "start": [870, 1], "end": [872, 6], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqLocusField", "code": "def eqLocusField (f g : K \u2192+* L) : Subfield K :=\n  { (f : K \u2192+* L).eqLocus g with\n    inv_mem' := fun x (hx : f x = g x) => show f x\u207b\u00b9 = g x\u207b\u00b9 by rw [map_inv\u2080 f, map_inv\u2080 g, hx]\n    carrier := { x | f x = g x } }", "start": [875, 1], "end": [880, 35], "kind": "commanddeclaration"}, {"full_name": "RingHom.eqOn_field_closure", "code": "theorem eqOn_field_closure {f g : K \u2192+* L} {s : Set K} (h : Set.EqOn f g s) :\n    Set.EqOn f g (closure s)", "start": [883, 1], "end": [886, 56], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_subfield_top", "code": "theorem eq_of_eqOn_subfield_top {f g : K \u2192+* L} (h : Set.EqOn f g (\u22a4 : Subfield K)) : f = g", "start": [889, 1], "end": [890, 25], "kind": "commanddeclaration"}, {"full_name": "RingHom.eq_of_eqOn_of_field_closure_eq_top", "code": "theorem eq_of_eqOn_of_field_closure_eq_top {s : Set K} (hs : closure s = \u22a4) {f g : K \u2192+* L}\n    (h : s.EqOn f g) : f = g", "start": [893, 1], "end": [895, 55], "kind": "commanddeclaration"}, {"full_name": "RingHom.field_closure_preimage_le", "code": "theorem field_closure_preimage_le (f : K \u2192+* L) (s : Set L) :\n    closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [898, 1], "end": [900, 81], "kind": "commanddeclaration"}, {"full_name": "RingHom.map_field_closure", "code": "theorem map_field_closure (f : K \u2192+* L) (s : Set K) : (closure s).map f = closure (f '' s)", "start": [903, 1], "end": [909, 56], "kind": "commanddeclaration"}, {"full_name": "Subfield.inclusion", "code": "def inclusion {S T : Subfield K} (h : S \u2264 T) : S \u2192+* T :=\n  S.subtype.codRestrict _ fun x => h x.2", "start": [918, 1], "end": [920, 41], "kind": "commanddeclaration"}, {"full_name": "Subfield.fieldRange_subtype", "code": "@[simp]\ntheorem fieldRange_subtype (s : Subfield K) : s.subtype.fieldRange = s", "start": [923, 1], "end": [925, 57], "kind": "commanddeclaration"}, {"full_name": "RingEquiv.subfieldCongr", "code": "def subfieldCongr (h : s = t) : s \u2243+* t :=\n  { Equiv.setCongr <| SetLike.ext'_iff.1 h with\n    map_mul' := fun _ _ => rfl\n    map_add' := fun _ _ => rfl }", "start": [934, 1], "end": [939, 33], "kind": "commanddeclaration"}, {"full_name": "Subfield.closure_preimage_le", "code": "theorem closure_preimage_le (f : K \u2192+* L) (s : Set L) : closure (f \u207b\u00b9' s) \u2264 (closure s).comap f", "start": [948, 1], "end": [949, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/GroupWithZero.lean", "imports": ["Mathlib/Topology/Algebra/Monoid.lean", "Mathlib/Topology/Homeomorph.lean", "Mathlib/Algebra/Group/Pi.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.Tendsto.div_const", "code": "theorem Filter.Tendsto.div_const {x : G\u2080} (hf : Tendsto f l (\ud835\udcdd x)) (y : G\u2080) :\n    Tendsto (fun a => f a / y) l (\ud835\udcdd (x / y))", "start": [52, 1], "end": [54, 62], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.div_const", "code": "nonrec theorem ContinuousAt.div_const {a : \u03b1} (hf : ContinuousAt f a) (y : G\u2080) :\n    ContinuousAt (fun x => f x / y) a", "start": [59, 1], "end": [61, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.div_const", "code": "nonrec theorem ContinuousWithinAt.div_const {a} (hf : ContinuousWithinAt f s a) (y : G\u2080) :\n    ContinuousWithinAt (fun x => f x / y) s a", "start": [64, 1], "end": [66, 17], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.div_const", "code": "theorem ContinuousOn.div_const (hf : ContinuousOn f s) (y : G\u2080) :\n    ContinuousOn (fun x => f x / y) s", "start": [69, 1], "end": [71, 62], "kind": "commanddeclaration"}, {"full_name": "Continuous.div_const", "code": "@[continuity]\ntheorem Continuous.div_const (hf : Continuous f) (y : G\u2080) : Continuous fun x => f x / y", "start": [74, 1], "end": [76, 60], "kind": "commanddeclaration"}, {"full_name": "HasContinuousInv\u2080", "code": "class HasContinuousInv\u2080 (G\u2080 : Type*) [Zero G\u2080] [Inv G\u2080] [TopologicalSpace G\u2080] : Prop where\n  \n  continuousAt_inv\u2080 : \u2200 \u2983x : G\u2080\u2984, x \u2260 0 \u2192 ContinuousAt Inv.inv x", "start": [81, 1], "end": [85, 65], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv\u2080", "code": "theorem tendsto_inv\u2080 {x : G\u2080} (hx : x \u2260 0) : Tendsto Inv.inv (\ud835\udcdd x) (\ud835\udcdd x\u207b\u00b9)", "start": [103, 1], "end": [104, 23], "kind": "commanddeclaration"}, {"full_name": "continuousOn_inv\u2080", "code": "theorem continuousOn_inv\u2080 : ContinuousOn (Inv.inv : G\u2080 \u2192 G\u2080) {0}\u1d9c", "start": [107, 1], "end": [108, 44], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inv\u2080", "code": "theorem Filter.Tendsto.inv\u2080 {a : G\u2080} (hf : Tendsto f l (\ud835\udcdd a)) (ha : a \u2260 0) :\n    Tendsto (fun x => (f x)\u207b\u00b9) l (\ud835\udcdd a\u207b\u00b9)", "start": [111, 1], "end": [116, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.inv\u2080", "code": "nonrec theorem ContinuousWithinAt.inv\u2080 (hf : ContinuousWithinAt f s a) (ha : f a \u2260 0) :\n    ContinuousWithinAt (fun x => (f x)\u207b\u00b9) s a", "start": [121, 1], "end": [123, 13], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.inv\u2080", "code": "nonrec theorem ContinuousAt.inv\u2080 (hf : ContinuousAt f a) (ha : f a \u2260 0) :\n    ContinuousAt (fun x => (f x)\u207b\u00b9) a", "start": [126, 1], "end": [128, 13], "kind": "commanddeclaration"}, {"full_name": "Continuous.inv\u2080", "code": "@[continuity]\ntheorem Continuous.inv\u2080 (hf : Continuous f) (h0 : \u2200 x, f x \u2260 0) : Continuous fun x => (f x)\u207b\u00b9", "start": [131, 1], "end": [133, 68], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.inv\u2080", "code": "theorem ContinuousOn.inv\u2080 (hf : ContinuousOn f s) (h0 : \u2200 x \u2208 s, f x \u2260 0) :\n    ContinuousOn (fun x => (f x)\u207b\u00b9) s", "start": [136, 1], "end": [137, 78], "kind": "commanddeclaration"}, {"full_name": "Units.embedding_val\u2080", "code": "theorem Units.embedding_val\u2080 [GroupWithZero G\u2080] [TopologicalSpace G\u2080] [HasContinuousInv\u2080 G\u2080] :\n    Embedding (val : G\u2080\u02e3 \u2192 G\u2080)", "start": [142, 1], "end": [146, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.div", "code": "theorem Filter.Tendsto.div {l : Filter \u03b1} {a b : G\u2080} (hf : Tendsto f l (\ud835\udcdd a))\n    (hg : Tendsto g l (\ud835\udcdd b)) (hy : b \u2260 0) : Tendsto (f / g) l (\ud835\udcdd (a / b))", "start": [161, 1], "end": [163, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_mul_iff_of_ne_zero", "code": "theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space G\u2080] {f g : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {x y : G\u2080}\n    (hg : Tendsto g l (\ud835\udcdd y)) (hy : y \u2260 0) :\n    Tendsto (fun n => f n * g n) l (\ud835\udcdd <| x * y) \u2194 Tendsto f l (\ud835\udcdd x)", "start": [166, 1], "end": [172, 69], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.div", "code": "nonrec theorem ContinuousWithinAt.div (hf : ContinuousWithinAt f s a)\n    (hg : ContinuousWithinAt g s a) (h\u2080 : g a \u2260 0) : ContinuousWithinAt (f / g) s a", "start": [177, 1], "end": [179, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.div", "code": "theorem ContinuousOn.div (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h\u2080 : \u2200 x \u2208 s, g x \u2260 0) :\n    ContinuousOn (f / g) s", "start": [182, 1], "end": [183, 76], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.div", "code": "nonrec theorem ContinuousAt.div (hf : ContinuousAt f a) (hg : ContinuousAt g a) (h\u2080 : g a \u2260 0) :\n    ContinuousAt (f / g) a", "start": [186, 1], "end": [190, 15], "kind": "commanddeclaration"}, {"full_name": "Continuous.div", "code": "@[continuity]\ntheorem Continuous.div (hf : Continuous f) (hg : Continuous g) (h\u2080 : \u2200 x, g x \u2260 0) :\n    Continuous (f / g)", "start": [193, 1], "end": [195, 83], "kind": "commanddeclaration"}, {"full_name": "continuousOn_div", "code": "theorem continuousOn_div : ContinuousOn (fun p : G\u2080 \u00d7 G\u2080 => p.1 / p.2) { p | p.2 \u2260 0 }", "start": [198, 1], "end": [199, 52], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.comp_div_cases", "code": "theorem ContinuousAt.comp_div_cases {f g : \u03b1 \u2192 G\u2080} (h : \u03b1 \u2192 G\u2080 \u2192 \u03b2) (hf : ContinuousAt f a)\n    (hg : ContinuousAt g a) (hh : g a \u2260 0 \u2192 ContinuousAt (\u21bfh) (a, f a / g a))\n    (h2h : g a = 0 \u2192 Tendsto (\u21bfh) (\ud835\udcdd a \u00d7\u02e2 \u22a4) (\ud835\udcdd (h a 0))) :\n    ContinuousAt (fun x => h x (f x / g x)) a", "start": [202, 1], "end": [216, 76], "kind": "commanddeclaration"}, {"full_name": "Continuous.comp_div_cases", "code": "theorem Continuous.comp_div_cases {f g : \u03b1 \u2192 G\u2080} (h : \u03b1 \u2192 G\u2080 \u2192 \u03b2) (hf : Continuous f)\n    (hg : Continuous g) (hh : \u2200 a, g a \u2260 0 \u2192 ContinuousAt (\u21bfh) (a, f a / g a))\n    (h2h : \u2200 a, g a = 0 \u2192 Tendsto (\u21bfh) (\ud835\udcdd a \u00d7\u02e2 \u22a4) (\ud835\udcdd (h a 0))) :\n    Continuous fun x => h x (f x / g x)", "start": [219, 1], "end": [226, 68], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulLeft\u2080", "code": "protected def mulLeft\u2080 (c : \u03b1) (hc : c \u2260 0) : \u03b1 \u2243\u209c \u03b1 :=\n  { Equiv.mulLeft\u2080 c hc with\n    continuous_toFun := continuous_mul_left _\n    continuous_invFun := continuous_mul_left _ }", "start": [238, 1], "end": [243, 49], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulRight\u2080", "code": "protected def mulRight\u2080 (c : \u03b1) (hc : c \u2260 0) : \u03b1 \u2243\u209c \u03b1 :=\n  { Equiv.mulRight\u2080 c hc with\n    continuous_toFun := continuous_mul_right _\n    continuous_invFun := continuous_mul_right _ }", "start": [246, 1], "end": [251, 50], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_mulLeft\u2080", "code": "@[simp]\ntheorem coe_mulLeft\u2080 (c : \u03b1) (hc : c \u2260 0) : \u21d1(Homeomorph.mulLeft\u2080 c hc) = (c * \u00b7)", "start": [254, 1], "end": [256, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulLeft\u2080_symm_apply", "code": "@[simp]\ntheorem mulLeft\u2080_symm_apply (c : \u03b1) (hc : c \u2260 0) :\n    ((Homeomorph.mulLeft\u2080 c hc).symm : \u03b1 \u2192 \u03b1) = (c\u207b\u00b9 * \u00b7)", "start": [259, 1], "end": [262, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.coe_mulRight\u2080", "code": "@[simp]\ntheorem coe_mulRight\u2080 (c : \u03b1) (hc : c \u2260 0) : \u21d1(Homeomorph.mulRight\u2080 c hc) = (\u00b7 * c)", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "Homeomorph.mulRight\u2080_symm_apply", "code": "@[simp]\ntheorem mulRight\u2080_symm_apply (c : \u03b1) (hc : c \u2260 0) :\n    ((Homeomorph.mulRight\u2080 c hc).symm : \u03b1 \u2192 \u03b1) = (\u00b7 * c\u207b\u00b9)", "start": [270, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "map_mul_left_nhds\u2080", "code": "theorem map_mul_left_nhds\u2080 (ha : a \u2260 0) (b : G\u2080) : map (a * \u00b7) (\ud835\udcdd b) = \ud835\udcdd (a * b)", "start": [282, 1], "end": [283, 43], "kind": "commanddeclaration"}, {"full_name": "map_mul_left_nhds_one\u2080", "code": "theorem map_mul_left_nhds_one\u2080 (ha : a \u2260 0) : map (a * \u00b7) (\ud835\udcdd 1) = \ud835\udcdd (a)", "start": [285, 1], "end": [286, 38], "kind": "commanddeclaration"}, {"full_name": "map_mul_right_nhds\u2080", "code": "theorem map_mul_right_nhds\u2080 (ha : a \u2260 0) (b : G\u2080) : map (\u00b7 * a) (\ud835\udcdd b) = \ud835\udcdd (b * a)", "start": [288, 1], "end": [289, 44], "kind": "commanddeclaration"}, {"full_name": "map_mul_right_nhds_one\u2080", "code": "theorem map_mul_right_nhds_one\u2080 (ha : a \u2260 0) : map (\u00b7 * a) (\ud835\udcdd 1) = \ud835\udcdd (a)", "start": [291, 1], "end": [292, 39], "kind": "commanddeclaration"}, {"full_name": "nhds_translation_mul_inv\u2080", "code": "theorem nhds_translation_mul_inv\u2080 (ha : a \u2260 0) : comap (\u00b7 * a\u207b\u00b9) (\ud835\udcdd 1) = \ud835\udcdd a", "start": [294, 1], "end": [295, 70], "kind": "commanddeclaration"}, {"full_name": "HasContinuousInv\u2080.of_nhds_one", "code": "theorem HasContinuousInv\u2080.of_nhds_one (h : Tendsto Inv.inv (\ud835\udcdd (1 : G\u2080)) (\ud835\udcdd 1)) :\n    HasContinuousInv\u2080 G\u2080 where", "start": [297, 1], "end": [305, 65], "kind": "commanddeclaration"}, {"full_name": "continuousAt_zpow\u2080", "code": "theorem continuousAt_zpow\u2080 (x : G\u2080) (m : \u2124) (h : x \u2260 0 \u2228 0 \u2264 m) :\n    ContinuousAt (fun x => x ^ m) x", "start": [313, 1], "end": [319, 63], "kind": "commanddeclaration"}, {"full_name": "continuousOn_zpow\u2080", "code": "theorem continuousOn_zpow\u2080 (m : \u2124) : ContinuousOn (fun x : G\u2080 => x ^ m) {0}\u1d9c", "start": [322, 1], "end": [323, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.zpow\u2080", "code": "theorem Filter.Tendsto.zpow\u2080 {f : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {a : G\u2080} (hf : Tendsto f l (\ud835\udcdd a)) (m : \u2124)\n    (h : a \u2260 0 \u2228 0 \u2264 m) : Tendsto (fun x => f x ^ m) l (\ud835\udcdd (a ^ m))", "start": [326, 1], "end": [328, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.zpow\u2080", "code": "nonrec theorem ContinuousAt.zpow\u2080 (hf : ContinuousAt f a) (m : \u2124) (h : f a \u2260 0 \u2228 0 \u2264 m) :\n    ContinuousAt (fun x => f x ^ m) a", "start": [333, 1], "end": [335, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.zpow\u2080", "code": "nonrec theorem ContinuousWithinAt.zpow\u2080 (hf : ContinuousWithinAt f s a) (m : \u2124)\n    (h : f a \u2260 0 \u2228 0 \u2264 m) : ContinuousWithinAt (fun x => f x ^ m) s a", "start": [338, 1], "end": [340, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.zpow\u2080", "code": "theorem ContinuousOn.zpow\u2080 (hf : ContinuousOn f s) (m : \u2124) (h : \u2200 a \u2208 s, f a \u2260 0 \u2228 0 \u2264 m) :\n    ContinuousOn (fun x => f x ^ m) s", "start": [343, 1], "end": [344, 80], "kind": "commanddeclaration"}, {"full_name": "Continuous.zpow\u2080", "code": "@[continuity]\ntheorem Continuous.zpow\u2080 (hf : Continuous f) (m : \u2124) (h0 : \u2200 a, f a \u2260 0 \u2228 0 \u2264 m) :\n    Continuous fun x => f x ^ m", "start": [347, 1], "end": [350, 71], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/FullSubcategory.lean", "imports": ["Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.InducedCategory", "code": "@[nolint unusedArguments]\ndef InducedCategory (_F : C \u2192 D) : Type u\u2081 :=\n  C", "start": [48, 1], "end": [55, 4], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.hasCoeToSort", "code": "instance InducedCategory.hasCoeToSort {\u03b1 : Sort*} [CoeSort D \u03b1] :\n    CoeSort (InducedCategory D F) \u03b1 :=\n  \u27e8fun c => F c\u27e9", "start": [60, 1], "end": [62, 17], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.category", "code": "instance InducedCategory.category : Category.{v} (InducedCategory D F) where\n  Hom X Y := F X \u27f6 F Y\n  id X := \ud835\udfd9 (F X)\n  comp f g := f \u226b g", "start": [65, 1], "end": [68, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inducedFunctor", "code": "@[simps]\ndef inducedFunctor : InducedCategory D F \u2964 D where\n  obj := F\n  map f := f", "start": [71, 1], "end": [77, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.full", "code": "instance InducedCategory.full : Full (inducedFunctor F) where preimage f := f", "start": [82, 1], "end": [82, 78], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.InducedCategory.faithful", "code": "instance InducedCategory.faithful : Faithful (inducedFunctor F) where", "start": [85, 1], "end": [85, 70], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory", "code": "@[ext]\nstructure FullSubcategory where\n  \n  obj : C\n  \n  property : Z obj", "start": [95, 1], "end": [107, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.category", "code": "instance FullSubcategory.category : Category.{v} (FullSubcategory Z) :=\n  InducedCategory.category FullSubcategory.obj", "start": [112, 1], "end": [113, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.id_def", "code": "lemma FullSubcategory.id_def (X : FullSubcategory Z) : \ud835\udfd9 X = \ud835\udfd9 X.obj := rfl", "start": [118, 1], "end": [118, 76], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.FullSubcategory.comp_def", "code": "lemma FullSubcategory.comp_def {X Y Z : FullSubcategory Z} (f : X \u27f6 Y) (g : Y \u27f6 Z) :\n    f \u226b g = (f \u226b g : X.obj \u27f6 Z.obj) := rfl", "start": [120, 1], "end": [121, 43], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.fullSubcategoryInclusion", "code": "def fullSubcategoryInclusion : FullSubcategory Z \u2964 C :=\n  inducedFunctor FullSubcategory.obj", "start": [123, 1], "end": [127, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullSubcategoryInclusion.obj", "code": "@[simp]\ntheorem fullSubcategoryInclusion.obj {X} : (fullSubcategoryInclusion Z).obj X = X.obj", "start": [130, 1], "end": [132, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullSubcategoryInclusion.map", "code": "@[simp]\ntheorem fullSubcategoryInclusion.map {X Y} {f : X \u27f6 Y} : (fullSubcategoryInclusion Z).map f = f", "start": [135, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.full", "code": "instance FullSubcategory.full : Full (fullSubcategoryInclusion Z) :=\n  InducedCategory.full _", "start": [140, 1], "end": [141, 25], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.faithful", "code": "instance FullSubcategory.faithful : Faithful (fullSubcategoryInclusion Z) :=\n  InducedCategory.faithful _", "start": [144, 1], "end": [145, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.map", "code": "@[simps]\ndef FullSubcategory.map (h : \u2200 \u2983X\u2984, Z X \u2192 Z' X) : FullSubcategory Z \u2964 FullSubcategory Z' where\n  obj X := \u27e8X.1, h X.2\u27e9\n  map f := f", "start": [150, 1], "end": [154, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.full_map", "code": "instance FullSubcategory.full_map (h : \u2200 \u2983X\u2984, Z X \u2192 Z' X) :\n  Full (FullSubcategory.map h) where preimage f := f", "start": [159, 1], "end": [160, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.faithful_map", "code": "instance FullSubcategory.faithful_map (h : \u2200 \u2983X\u2984, Z X \u2192 Z' X) :\n  Faithful (FullSubcategory.map h) where", "start": [162, 1], "end": [163, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.map_inclusion", "code": "@[simp]\ntheorem FullSubcategory.map_inclusion (h : \u2200 \u2983X\u2984, Z X \u2192 Z' X) :\n    FullSubcategory.map h \u22d9 fullSubcategoryInclusion Z' = fullSubcategoryInclusion Z", "start": [165, 1], "end": [168, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.lift", "code": "@[simps]\ndef FullSubcategory.lift (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) : C \u2964 FullSubcategory P where\n  obj X := \u27e8F.obj X, hF X\u27e9\n  map f := F.map f", "start": [175, 1], "end": [180, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.lift_comp_inclusion_eq", "code": "@[simp]\ntheorem FullSubcategory.lift_comp_inclusion_eq (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) :\n    FullSubcategory.lift P F hF \u22d9 fullSubcategoryInclusion P = F", "start": [185, 1], "end": [188, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.lift_comp_inclusion", "code": "def FullSubcategory.lift_comp_inclusion (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) :\n    FullSubcategory.lift P F hF \u22d9 fullSubcategoryInclusion P \u2245 F :=\n  Iso.refl _", "start": [190, 1], "end": [194, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullSubcategoryInclusion_obj_lift_obj", "code": "@[simp]\ntheorem fullSubcategoryInclusion_obj_lift_obj (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) {X : C} :\n    (fullSubcategoryInclusion P).obj ((FullSubcategory.lift P F hF).obj X) = F.obj X", "start": [197, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.fullSubcategoryInclusion_map_lift_map", "code": "@[simp]\ntheorem fullSubcategoryInclusion_map_lift_map (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) {X Y : C}\n    (f : X \u27f6 Y) :\n    (fullSubcategoryInclusion P).map ((FullSubcategory.lift P F hF).map f) = F.map f", "start": [203, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.FullSubcategory.lift_comp_map", "code": "@[simp]\ntheorem FullSubcategory.lift_comp_map (F : C \u2964 D) (hF : \u2200 X, P (F.obj X)) (h : \u2200 \u2983X\u2984, P X \u2192 Q X) :\n    FullSubcategory.lift P F hF \u22d9 FullSubcategory.map h =\n      FullSubcategory.lift Q F fun X => h (hF X)", "start": [217, 1], "end": [221, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/DirectSum/Finsupp.lean", "imports": ["Mathlib/Algebra/DirectSum/Module.lean", "Mathlib/Data/Finsupp/ToDFinsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "finsuppLEquivDirectSum", "code": "def finsuppLEquivDirectSum : (\u03b9 \u2192\u2080 M) \u2243\u2097[R] \u2a01 _ : \u03b9, M :=\n  haveI : \u2200 m : M, Decidable (m \u2260 0) := Classical.decPred _\n  finsuppLequivDFinsupp R", "start": [33, 1], "end": [37, 26], "kind": "commanddeclaration"}, {"full_name": "finsuppLEquivDirectSum_single", "code": "@[simp]\ntheorem finsuppLEquivDirectSum_single (i : \u03b9) (m : M) :\n    finsuppLEquivDirectSum R M \u03b9 (Finsupp.single i m) = DirectSum.lof R \u03b9 _ i m", "start": [40, 1], "end": [43, 32], "kind": "commanddeclaration"}, {"full_name": "finsuppLEquivDirectSum_symm_lof", "code": "@[simp]\ntheorem finsuppLEquivDirectSum_symm_lof (i : \u03b9) (m : M) :\n    (finsuppLEquivDirectSum R M \u03b9).symm (DirectSum.lof R \u03b9 _ i m) = Finsupp.single i m", "start": [46, 1], "end": [50, 32], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "imports": ["Mathlib/Algebra/DirectSum/Module.lean", "Mathlib/LinearAlgebra/TensorProduct.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TensorProduct.directSum", "code": "protected def directSum :\n    ((\u2a01 i\u2081, M\u2081 i\u2081) \u2297[R] \u2a01 i\u2082, M\u2082 i\u2082) \u2243\u2097[R] \u2a01 i : \u03b9\u2081 \u00d7 \u03b9\u2082, M\u2081 i.1 \u2297[R] M\u2082 i.2 := by\n  refine LinearEquiv.ofLinear (R := R) (R\u2082 := R) ?toFun ?invFun ?left ?right\n  \u00b7 refine lift ?_\n    refine DirectSum.toModule R _ _ fun i\u2081 => ?_\n    refine @LinearMap.flip R _ R _ R _ R _ _ _ _ _ _ _ _ _ _ _ _ _ _ ?_\n    refine DirectSum.toModule R _ _ fun i\u2082 => LinearMap.flip <| ?_\n    refine curry ?_\n    exact DirectSum.lof R (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => M\u2081 i.1 \u2297[R] M\u2082 i.2) (i\u2081, i\u2082)\n  \u00b7 refine DirectSum.toModule R _ _ fun i => ?_\n    exact map (DirectSum.lof R _ M\u2081 i.1) (DirectSum.lof R _ M\u2082 i.2)\n  \u00b7 refine DirectSum.linearMap_ext R fun \u27e8i\u2081, i\u2082\u27e9 => ?_\n    refine TensorProduct.ext ?_\n    refine LinearMap.ext\u2082 fun m\u2081 m\u2082 => ?_\n    simp only [compr\u2082_apply, comp_apply, id_apply, mk_apply, DirectSum.toModule_lof, map_tmul,\n        lift.tmul, flip_apply, curry_apply]\n  \u00b7 refine TensorProduct.ext ?_\n    refine @DirectSum.linearMap_ext R _ _ _ _ _ _ _ _ (_) _ _ fun i\u2081 => ?_\n    refine @LinearMap.ext _ _ _ _ _ _ _ _ (_) (_) _ _ _ fun x\u2081 => ?_\n    refine @DirectSum.linearMap_ext R _ _ _ _ _ _ _ _ (_) _ _ fun i\u2082 => ?_\n    refine LinearMap.ext fun x\u2082 => ?_\n    simp only [compr\u2082_apply, comp_apply, id_apply, mk_apply, DirectSum.toModule_lof, map_tmul,\n        lift.tmul, flip_apply, curry_apply]", "start": [53, 1], "end": [82, 44], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumLeft", "code": "def directSumLeft : (\u2a01 i\u2081, M\u2081 i\u2081) \u2297[R] M\u2082' \u2243\u2097[R] \u2a01 i, M\u2081 i \u2297[R] M\u2082' :=\n  LinearEquiv.ofLinear\n    (lift <|\n      DirectSum.toModule R _ _ fun i =>\n        (mk R _ _).compr\u2082 <| DirectSum.lof R \u03b9\u2081 (fun i => M\u2081 i \u2297[R] M\u2082') _)\n    (DirectSum.toModule R _ _ fun i => rTensor _ (DirectSum.lof R \u03b9\u2081 _ _))\n    (DirectSum.linearMap_ext R fun i =>\n      TensorProduct.ext <|\n        LinearMap.ext\u2082 fun m\u2081 m\u2082 => by\n          dsimp only [comp_apply, compr\u2082_apply, id_apply, mk_apply]\n          simp_rw [DirectSum.toModule_lof, rTensor_tmul, lift.tmul, DirectSum.toModule_lof,\n            compr\u2082_apply, mk_apply])\n    (TensorProduct.ext <|\n      DirectSum.linearMap_ext R fun i =>\n        LinearMap.ext\u2082 fun m\u2081 m\u2082 => by\n          dsimp only [comp_apply, compr\u2082_apply, id_apply, mk_apply]\n          simp_rw [lift.tmul, DirectSum.toModule_lof, compr\u2082_apply,\n            mk_apply, DirectSum.toModule_lof, rTensor_tmul])", "start": [124, 1], "end": [142, 61], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumRight", "code": "def directSumRight : (M\u2081' \u2297[R] \u2a01 i, M\u2082 i) \u2243\u2097[R] \u2a01 i, M\u2081' \u2297[R] M\u2082 i :=\n  TensorProduct.comm R _ _ \u226a\u226b\u2097 directSumLeft R M\u2082 M\u2081' \u226a\u226b\u2097\n    DFinsupp.mapRange.linearEquiv fun _ => TensorProduct.comm R _ _", "start": [145, 1], "end": [148, 68], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSum_lof_tmul_lof", "code": "@[simp]\ntheorem directSum_lof_tmul_lof (i\u2081 : \u03b9\u2081) (m\u2081 : M\u2081 i\u2081) (i\u2082 : \u03b9\u2082) (m\u2082 : M\u2082 i\u2082) :\n    TensorProduct.directSum R M\u2081 M\u2082 (DirectSum.lof R \u03b9\u2081 M\u2081 i\u2081 m\u2081 \u2297\u209c DirectSum.lof R \u03b9\u2082 M\u2082 i\u2082 m\u2082) =\n      DirectSum.lof R (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => M\u2081 i.1 \u2297[R] M\u2082 i.2) (i\u2081, i\u2082) (m\u2081 \u2297\u209c m\u2082)", "start": [153, 1], "end": [157, 33], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSum_symm_lof_tmul", "code": "@[simp]\ntheorem directSum_symm_lof_tmul (i\u2081 : \u03b9\u2081) (m\u2081 : M\u2081 i\u2081) (i\u2082 : \u03b9\u2082) (m\u2082 : M\u2082 i\u2082) :\n    (TensorProduct.directSum R M\u2081 M\u2082).symm\n      (DirectSum.lof R (\u03b9\u2081 \u00d7 \u03b9\u2082) (fun i => M\u2081 i.1 \u2297[R] M\u2082 i.2) (i\u2081, i\u2082) (m\u2081 \u2297\u209c m\u2082)) =\n      (DirectSum.lof R \u03b9\u2081 M\u2081 i\u2081 m\u2081 \u2297\u209c DirectSum.lof R \u03b9\u2082 M\u2082 i\u2082 m\u2082)", "start": [160, 1], "end": [165, 57], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumLeft_tmul_lof", "code": "@[simp]\ntheorem directSumLeft_tmul_lof (i : \u03b9\u2081) (x : M\u2081 i) (y : M\u2082') :\n    directSumLeft R M\u2081 M\u2082' (DirectSum.lof R _ _ i x \u2297\u209c[R] y) =\n    DirectSum.lof R _ _ i (x \u2297\u209c[R] y)", "start": [167, 1], "end": [173, 6], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumLeft_symm_lof_tmul", "code": "@[simp]\ntheorem directSumLeft_symm_lof_tmul (i : \u03b9\u2081) (x : M\u2081 i) (y : M\u2082') :\n    (directSumLeft R M\u2081 M\u2082').symm (DirectSum.lof R _ _ i (x \u2297\u209c[R] y)) =\n      DirectSum.lof R _ _ i x \u2297\u209c[R] y", "start": [176, 1], "end": [180, 57], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumRight_tmul_lof", "code": "@[simp]\ntheorem directSumRight_tmul_lof (x : M\u2081') (i : \u03b9\u2082) (y : M\u2082 i) :\n    directSumRight R M\u2081' M\u2082 (x \u2297\u209c[R] DirectSum.lof R _ _ i y) =\n    DirectSum.lof R _ _ i (x \u2297\u209c[R] y)", "start": [183, 1], "end": [189, 54], "kind": "commanddeclaration"}, {"full_name": "TensorProduct.directSumRight_symm_lof_tmul", "code": "@[simp]\ntheorem directSumRight_symm_lof_tmul (x : M\u2081') (i : \u03b9\u2082) (y : M\u2082 i) :\n    (directSumRight R M\u2081' M\u2082).symm (DirectSum.lof R _ _ i (x \u2297\u209c[R] y)) =\n      x \u2297\u209c[R] DirectSum.lof R _ _ i y", "start": [192, 1], "end": [196, 58], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Order.lean", "imports": ["Mathlib/Data/Finsupp/Defs.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.instLEFinsupp", "code": "instance instLEFinsupp : LE (\u03b9 \u2192\u2080 \u03b1) :=\n  \u27e8fun f g => \u2200 i, f i \u2264 g i\u27e9", "start": [48, 1], "end": [49, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.le_def", "code": "theorem le_def {f g : \u03b9 \u2192\u2080 \u03b1} : f \u2264 g \u2194 \u2200 i, f i \u2264 g i", "start": [51, 1], "end": [52, 10], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderEmbeddingToFun", "code": "def orderEmbeddingToFun : (\u03b9 \u2192\u2080 \u03b1) \u21aao (\u03b9 \u2192 \u03b1) where\n  toFun f := f\n  inj' f g h :=\n    Finsupp.ext fun i => by\n      dsimp at h\n      rw [h]\n  map_rel_iff' {a b} := (@le_def _ _ _ _ a b).symm", "start": [55, 1], "end": [62, 51], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderEmbeddingToFun_apply", "code": "@[simp]\ntheorem orderEmbeddingToFun_apply {f : \u03b9 \u2192\u2080 \u03b1} {i : \u03b9} : orderEmbeddingToFun f i = f i", "start": [65, 1], "end": [67, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.preorder", "code": "instance preorder : Preorder (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.instLEFinsupp with\n    le_refl := fun f i => le_rfl\n    le_trans := fun f g h hfg hgh i => (hfg i).trans (hgh i) }", "start": [76, 1], "end": [79, 63], "kind": "commanddeclaration"}, {"full_name": "Finsupp.monotone_toFun", "code": "theorem monotone_toFun : Monotone (Finsupp.toFun : (\u03b9 \u2192\u2080 \u03b1) \u2192 \u03b9 \u2192 \u03b1)", "start": [81, 1], "end": [82, 34], "kind": "commanddeclaration"}, {"full_name": "Finsupp.partialorder", "code": "instance partialorder [PartialOrder \u03b1] : PartialOrder (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.preorder with le_antisymm :=\n      fun _f _g hfg hgf => ext fun i => (hfg i).antisymm (hgf i) }", "start": [87, 1], "end": [89, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.semilatticeInf", "code": "instance semilatticeInf [SemilatticeInf \u03b1] : SemilatticeInf (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.partialorder with\n    inf := zipWith (\u00b7 \u2293 \u00b7) inf_idem\n    inf_le_left := fun _f _g _i => inf_le_left\n    inf_le_right := fun _f _g _i => inf_le_right\n    le_inf := fun _f _g _i h1 h2 s => le_inf (h1 s) (h2 s) }", "start": [91, 1], "end": [96, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.inf_apply", "code": "@[simp]\ntheorem inf_apply [SemilatticeInf \u03b1] {i : \u03b9} {f g : \u03b9 \u2192\u2080 \u03b1} : (f \u2293 g) i = f i \u2293 g i", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.semilatticeSup", "code": "instance semilatticeSup [SemilatticeSup \u03b1] : SemilatticeSup (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.partialorder with\n    sup := zipWith (\u00b7 \u2294 \u00b7) sup_idem\n    le_sup_left := fun _f _g _i => le_sup_left\n    le_sup_right := fun _f _g _i => le_sup_right\n    sup_le := fun _f _g _h hf hg i => sup_le (hf i) (hg i) }", "start": [103, 1], "end": [108, 61], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sup_apply", "code": "@[simp]\ntheorem sup_apply [SemilatticeSup \u03b1] {i : \u03b9} {f g : \u03b9 \u2192\u2080 \u03b1} : (f \u2294 g) i = f i \u2294 g i", "start": [110, 1], "end": [112, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lattice", "code": "instance lattice [Lattice \u03b1] : Lattice (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.semilatticeInf, Finsupp.semilatticeSup with }", "start": [115, 1], "end": [116, 58], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_inf_union_support_sup", "code": "theorem support_inf_union_support_sup : (f \u2293 g).support \u222a (f \u2294 g).support = f.support \u222a g.support", "start": [122, 1], "end": [123, 75], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_sup_union_support_inf", "code": "theorem support_sup_union_support_inf : (f \u2294 g).support \u222a (f \u2293 g).support = f.support \u222a g.support", "start": [126, 1], "end": [127, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderedAddCommMonoid", "code": "instance orderedAddCommMonoid [OrderedAddCommMonoid \u03b1] : OrderedAddCommMonoid (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.addCommMonoid, Finsupp.partialorder with\n    add_le_add_left := fun _a _b h c s => add_le_add_left (h s) (c s) }", "start": [136, 1], "end": [138, 72], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderedCancelAddCommMonoid", "code": "instance orderedCancelAddCommMonoid [OrderedCancelAddCommMonoid \u03b1] :\n    OrderedCancelAddCommMonoid (\u03b9 \u2192\u2080 \u03b1) :=\n  { Finsupp.orderedAddCommMonoid with\n    le_of_add_le_add_left := fun _f _g _i h s => le_of_add_le_add_left (h s) }", "start": [140, 1], "end": [143, 79], "kind": "commanddeclaration"}, {"full_name": "Finsupp.contravariantClass", "code": "instance contravariantClass [OrderedAddCommMonoid \u03b1] [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] :\n    ContravariantClass (\u03b9 \u2192\u2080 \u03b1) (\u03b9 \u2192\u2080 \u03b1) (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7) :=\n  \u27e8fun _f _g _h H x => le_of_add_le_add_left <| H x\u27e9", "start": [145, 1], "end": [147, 53], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderBot", "code": "instance orderBot : OrderBot (\u03b9 \u2192\u2080 \u03b1) where\n  bot := 0\n  bot_le := by simp only [le_def, coe_zero, Pi.zero_apply, imp_true_iff, zero_le]", "start": [153, 1], "end": [155, 82], "kind": "commanddeclaration"}, {"full_name": "Finsupp.bot_eq_zero", "code": "protected theorem bot_eq_zero : (\u22a5 : \u03b9 \u2192\u2080 \u03b1) = 0", "start": [157, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.add_eq_zero_iff", "code": "@[simp]\ntheorem add_eq_zero_iff (f g : \u03b9 \u2192\u2080 \u03b1) : f + g = 0 \u2194 f = 0 \u2227 g = 0", "start": [161, 1], "end": [163, 37], "kind": "commanddeclaration"}, {"full_name": "Finsupp.le_iff'", "code": "theorem le_iff' (f g : \u03b9 \u2192\u2080 \u03b1) {s : Finset \u03b9} (hf : f.support \u2286 s) : f \u2264 g \u2194 \u2200 i \u2208 s, f i \u2264 g i", "start": [166, 1], "end": [169, 98], "kind": "commanddeclaration"}, {"full_name": "Finsupp.le_iff", "code": "theorem le_iff (f g : \u03b9 \u2192\u2080 \u03b1) : f \u2264 g \u2194 \u2200 i \u2208 f.support, f i \u2264 g i", "start": [172, 1], "end": [173, 31], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_monotone", "code": "lemma support_monotone : Monotone (support (\u03b1 := \u03b9) (M := \u03b1)) :=\n  fun f g h a ha \u21a6 by rw [mem_support_iff, \u2190pos_iff_ne_zero] at ha \u22a2; exact ha.trans_le (h _)", "start": [176, 1], "end": [177, 94], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.support_mono", "code": "lemma support_mono (hfg : f \u2264 g) : f.support \u2286 g.support := support_monotone hfg", "start": [179, 1], "end": [179, 81], "kind": "mathlibtacticlemma"}, {"full_name": "Finsupp.decidableLE", "code": "instance decidableLE [DecidableRel (@LE.le \u03b1 _)] : DecidableRel (@LE.le (\u03b9 \u2192\u2080 \u03b1) _) := fun f g =>\n  decidable_of_iff _ (le_iff f g).symm", "start": [181, 1], "end": [182, 39], "kind": "commanddeclaration"}, {"full_name": "Finsupp.decidableLT", "code": "instance decidableLT [DecidableRel (@LE.le \u03b1 _)] : DecidableRel (@LT.lt (\u03b9 \u2192\u2080 \u03b1) _) :=\n  decidableLTOfDecidableLE", "start": [185, 1], "end": [186, 27], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_le_iff", "code": "@[simp]\ntheorem single_le_iff {i : \u03b9} {x : \u03b1} {f : \u03b9 \u2192\u2080 \u03b1} : single i x \u2264 f \u2194 x \u2264 f i", "start": [188, 1], "end": [190, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.tsub", "code": "instance tsub : Sub (\u03b9 \u2192\u2080 \u03b1) :=\n  \u27e8zipWith (fun m n => m - n) (tsub_self 0)\u27e9", "start": [195, 1], "end": [198, 45], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderedSub", "code": "instance orderedSub : OrderedSub (\u03b9 \u2192\u2080 \u03b1) :=\n  \u27e8fun _n _m _k => forall_congr' fun _x => tsub_le_iff_right\u27e9", "start": [201, 1], "end": [202, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_tsub", "code": "@[simp]\ntheorem coe_tsub (f g : \u03b9 \u2192\u2080 \u03b1) : \u21d1(f - g) = f - g", "start": [210, 1], "end": [212, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.tsub_apply", "code": "theorem tsub_apply (f g : \u03b9 \u2192\u2080 \u03b1) (a : \u03b9) : (f - g) a = f a - g a", "start": [215, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.single_tsub", "code": "@[simp]\ntheorem single_tsub : single i (a - b) = single i a - single i b", "start": [219, 1], "end": [224, 88], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_tsub", "code": "theorem support_tsub {f1 f2 : \u03b9 \u2192\u2080 \u03b1} : (f1 - f2).support \u2286 f1.support", "start": [227, 1], "end": [229, 72], "kind": "commanddeclaration"}, {"full_name": "Finsupp.subset_support_tsub", "code": "theorem subset_support_tsub [DecidableEq \u03b9] {f1 f2 : \u03b9 \u2192\u2080 \u03b1} :\n    f1.support \\ f2.support \u2286 (f1 - f2).support", "start": [232, 1], "end": [234, 55], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_inf", "code": "@[simp]\ntheorem support_inf [DecidableEq \u03b9] (f g : \u03b9 \u2192\u2080 \u03b1) : (f \u2293 g).support = f.support \u2229 g.support", "start": [243, 1], "end": [248, 67], "kind": "commanddeclaration"}, {"full_name": "Finsupp.support_sup", "code": "@[simp]\ntheorem support_sup [DecidableEq \u03b9] (f g : \u03b9 \u2192\u2080 \u03b1) : (f \u2294 g).support = f.support \u222a g.support", "start": [251, 1], "end": [255, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.disjoint_iff", "code": "nonrec theorem disjoint_iff {f g : \u03b9 \u2192\u2080 \u03b1} : Disjoint f g \u2194 Disjoint f.support g.support", "start": [258, 1], "end": [262, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sub_single_one_add", "code": "theorem sub_single_one_add {a : \u03b9} {u u' : \u03b9 \u2192\u2080 \u2115} (h : u a \u2260 0) :\n    u - single a 1 + u' = u + u' - single a 1", "start": [272, 1], "end": [274, 76], "kind": "commanddeclaration"}, {"full_name": "Finsupp.add_sub_single_one", "code": "theorem add_sub_single_one {a : \u03b9} {u u' : \u03b9 \u2192\u2080 \u2115} (h : u' a \u2260 0) :\n    u + (u' - single a 1) = u + u' - single a 1", "start": [277, 1], "end": [279, 84], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Valuation/Basic.lean", "imports": ["Mathlib/Tactic/TFAE.lean", "Mathlib/RingTheory/Ideal/Operations.lean", "Mathlib/Algebra/Order/WithZero.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Valuation", "code": "structure Valuation extends R \u2192*\u2080 \u0393\u2080 where\n  \n  map_add_le_max' : \u2200 x y, toFun (x + y) \u2264 max (toFun x) (toFun y)", "start": [74, 1], "end": [79, 67], "kind": "commanddeclaration"}, {"full_name": "ValuationClass", "code": "class ValuationClass (F) (R \u0393\u2080 : outParam (Type*)) [LinearOrderedCommMonoidWithZero \u0393\u2080] [Ring R]\n  extends MonoidWithZeroHomClass F R \u0393\u2080 where\n  \n  map_add_le_max (f : F) (x y : R) : f (x + y) \u2264 max (f x) (f y)", "start": [82, 1], "end": [88, 65], "kind": "commanddeclaration"}, {"full_name": "Valuation.toFun_eq_coe", "code": "theorem toFun_eq_coe (v : Valuation R \u0393\u2080) : v.toFun = v", "start": [135, 1], "end": [135, 63], "kind": "commanddeclaration"}, {"full_name": "Valuation.toMonoidWithZeroHom_coe_eq_coe", "code": "@[simp] theorem toMonoidWithZeroHom_coe_eq_coe (v : Valuation R \u0393\u2080) :\n    (v.toMonoidWithZeroHom : R \u2192 \u0393\u2080) = v", "start": [138, 1], "end": [140, 48], "kind": "commanddeclaration"}, {"full_name": "Valuation.ext", "code": "@[ext]\ntheorem ext {v\u2081 v\u2082 : Valuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082", "start": [142, 1], "end": [144, 20], "kind": "commanddeclaration"}, {"full_name": "Valuation.coe_coe", "code": "@[simp, norm_cast]\ntheorem coe_coe : \u21d1(v : R \u2192*\u2080 \u0393\u2080) = v", "start": [149, 1], "end": [150, 45], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_zero", "code": "theorem map_zero : v 0 = 0", "start": [154, 1], "end": [155, 14], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_one", "code": "theorem map_one : v 1 = 1", "start": [159, 1], "end": [160, 13], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_mul", "code": "theorem map_mul : \u2200 x y, v (x * y) = v x * v y", "start": [164, 1], "end": [165, 13], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add", "code": "theorem map_add : \u2200 x y, v (x + y) \u2264 max (v x) (v y)", "start": [169, 1], "end": [170, 20], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add'", "code": "@[simp]\ntheorem map_add' : \u2200 x y, v (x + y) \u2264 v x \u2228 v (x + y) \u2264 v y", "start": [173, 1], "end": [177, 16], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_le", "code": "theorem map_add_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x + y) \u2264 g", "start": [179, 1], "end": [180, 43], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_lt", "code": "theorem map_add_lt {x y g} (hx : v x < g) (hy : v y < g) : v (x + y) < g", "start": [183, 1], "end": [184, 49], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sum_le", "code": "theorem map_sum_le {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, v (f i) \u2264 g) :\n    v (\u2211 i in s, f i) \u2264 g", "start": [187, 1], "end": [193, 36], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sum_lt", "code": "theorem map_sum_lt {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 0)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i in s, f i) < g", "start": [196, 1], "end": [202, 36], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sum_lt'", "code": "theorem map_sum_lt' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : 0 < g)\n    (hf : \u2200 i \u2208 s, v (f i) < g) : v (\u2211 i in s, f i) < g", "start": [205, 1], "end": [207, 32], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_pow", "code": "theorem map_pow : \u2200 (x) (n : \u2115), v (x ^ n) = v x ^ n", "start": [211, 1], "end": [212, 44], "kind": "commanddeclaration"}, {"full_name": "Valuation.ext_iff", "code": "theorem ext_iff {v\u2081 v\u2082 : Valuation R \u0393\u2080} : v\u2081 = v\u2082 \u2194 \u2200 r, v\u2081 r = v\u2082 r", "start": [215, 1], "end": [218, 18], "kind": "commanddeclaration"}, {"full_name": "Valuation.toPreorder", "code": "def toPreorder : Preorder R :=\n  Preorder.lift v", "start": [223, 1], "end": [225, 18], "kind": "commanddeclaration"}, {"full_name": "Valuation.zero_iff", "code": "theorem zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x = 0 \u2194 x = 0", "start": [228, 1], "end": [231, 16], "kind": "commanddeclaration"}, {"full_name": "Valuation.ne_zero_iff", "code": "theorem ne_zero_iff [Nontrivial \u0393\u2080] (v : Valuation K \u0393\u2080) {x : K} : v x \u2260 0 \u2194 x \u2260 0", "start": [234, 1], "end": [235, 16], "kind": "commanddeclaration"}, {"full_name": "Valuation.unit_map_eq", "code": "theorem unit_map_eq (u : R\u02e3) : (Units.map (v : R \u2192* \u0393\u2080) u : \u0393\u2080) = v u", "start": [238, 1], "end": [239, 6], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap", "code": "def comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) : Valuation S \u0393\u2080 :=\n  { v.toMonoidWithZeroHom.comp f.toMonoidWithZeroHom with\n    toFun := v \u2218 f\n    map_add_le_max' := fun x y => by simp only [comp_apply, map_add, f.map_add] }", "start": [242, 1], "end": [246, 82], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap_apply", "code": "@[simp]\ntheorem comap_apply {S : Type*} [Ring S] (f : S \u2192+* R) (v : Valuation R \u0393\u2080) (s : S) :\n    v.comap f s = v (f s)", "start": [249, 1], "end": [251, 33], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap_id", "code": "@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v", "start": [254, 1], "end": [256, 20], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap_comp", "code": "theorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f", "start": [259, 1], "end": [261, 20], "kind": "commanddeclaration"}, {"full_name": "Valuation.map", "code": "def map (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (v : Valuation R \u0393\u2080) : Valuation R \u0393'\u2080 :=\n  { MonoidWithZeroHom.comp f v.toMonoidWithZeroHom with\n    toFun := f \u2218 v\n    map_add_le_max' := fun r s =>\n      calc\n        f (v (r + s)) \u2264 f (max (v r) (v s)) := hf (v.map_add r s)\n        _ = max (f (v r)) (f (v s)) := hf.map_max\n         }", "start": [264, 1], "end": [273, 11], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv", "code": "def IsEquiv (v\u2081 : Valuation R \u0393\u2080) (v\u2082 : Valuation R \u0393'\u2080) : Prop :=\n  \u2200 r s, v\u2081 r \u2264 v\u2081 s \u2194 v\u2082 r \u2264 v\u2082 s", "start": [276, 1], "end": [278, 35], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_neg", "code": "@[simp]\ntheorem map_neg (x : R) : v (-x) = v x", "start": [287, 1], "end": [289, 46], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sub_swap", "code": "theorem map_sub_swap (x y : R) : v (x - y) = v (y - x)", "start": [292, 1], "end": [293, 53], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sub", "code": "theorem map_sub (x y : R) : v (x - y) \u2264 max (v x) (v y)", "start": [296, 1], "end": [300, 43], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_sub_le", "code": "theorem map_sub_le {x y g} (hx : v x \u2264 g) (hy : v y \u2264 g) : v (x - y) \u2264 g", "start": [303, 1], "end": [305, 63], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_of_distinct_val", "code": "theorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = max (v x) (v y)", "start": [308, 1], "end": [320, 29], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_eq_of_lt_right", "code": "theorem map_add_eq_of_lt_right (h : v x < v y) : v (x + y) = v y", "start": [323, 1], "end": [324, 69], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_eq_of_lt_left", "code": "theorem map_add_eq_of_lt_left (h : v y < v x) : v (x + y) = v x", "start": [327, 1], "end": [328, 50], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_eq_of_sub_lt", "code": "theorem map_eq_of_sub_lt (h : v (y - x) < v x) : v y = v x", "start": [331, 1], "end": [334, 19], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_one_add_of_lt", "code": "theorem map_one_add_of_lt (h : v x < 1) : v (1 + x) = 1", "start": [337, 1], "end": [339, 57], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_one_sub_of_lt", "code": "theorem map_one_sub_of_lt (h : v x < 1) : v (1 - x) = 1", "start": [342, 1], "end": [345, 68], "kind": "commanddeclaration"}, {"full_name": "Valuation.one_lt_val_iff", "code": "theorem one_lt_val_iff (v : Valuation K \u0393\u2080) {x : K} (h : x \u2260 0) : 1 < v x \u2194 v x\u207b\u00b9 < 1", "start": [348, 1], "end": [349, 65], "kind": "commanddeclaration"}, {"full_name": "Valuation.ltAddSubgroup", "code": "def ltAddSubgroup (v : Valuation R \u0393\u2080) (\u03b3 : \u0393\u2080\u02e3) : AddSubgroup R where\n  carrier := { x | v x < \u03b3 }\n  zero_mem' := by simp\n  add_mem' {x y} x_in y_in := lt_of_le_of_lt (v.map_add x y) (max_lt x_in y_in)\n  neg_mem' x_in := by rwa [Set.mem_setOf, map_neg]", "start": [352, 1], "end": [357, 51], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.refl", "code": "@[refl]\ntheorem refl : v.IsEquiv v", "start": [370, 1], "end": [371, 52], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.symm", "code": "@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081", "start": [374, 1], "end": [375, 80], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.trans", "code": "@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083", "start": [378, 1], "end": [380, 32], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.of_eq", "code": "theorem of_eq {v' : Valuation R \u0393\u2080} (h : v = v') : v.IsEquiv v'", "start": [383, 1], "end": [383, 83], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.map", "code": "theorem map {v' : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080) (hf : Monotone f) (inf : Injective f)\n    (h : v.IsEquiv v') : (v.map f hf).IsEquiv (v'.map f hf)", "start": [386, 1], "end": [393, 51], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.comap", "code": "theorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f)", "start": [396, 1], "end": [398, 66], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.val_eq", "code": "theorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s", "start": [401, 1], "end": [402, 63], "kind": "commanddeclaration"}, {"full_name": "Valuation.IsEquiv.ne_zero", "code": "theorem ne_zero (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 0 \u2194 v\u2082 r \u2260 0", "start": [405, 1], "end": [407, 41], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_of_map_strictMono", "code": "theorem isEquiv_of_map_strictMono [LinearOrderedCommMonoidWithZero \u0393\u2080]\n    [LinearOrderedCommMonoidWithZero \u0393'\u2080] [Ring R] {v : Valuation R \u0393\u2080} (f : \u0393\u2080 \u2192*\u2080 \u0393'\u2080)\n    (H : StrictMono f) : IsEquiv (v.map f H.monotone) v", "start": [415, 1], "end": [418, 42], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_of_val_le_one", "code": "theorem isEquiv_of_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080)\n    (h : \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1) : v.IsEquiv v'", "start": [421, 1], "end": [438, 12], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_iff_val_le_one", "code": "theorem isEquiv_iff_val_le_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x \u2264 1 \u2194 v' x \u2264 1", "start": [441, 1], "end": [444, 63], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_iff_val_eq_one", "code": "theorem isEquiv_iff_val_eq_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x = 1 \u2194 v' x = 1", "start": [447, 1], "end": [480, 27], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_iff_val_lt_one", "code": "theorem isEquiv_iff_val_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v x < 1 \u2194 v' x < 1", "start": [483, 1], "end": [510, 60], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_iff_val_sub_one_lt_one", "code": "theorem isEquiv_iff_val_sub_one_lt_one [LinearOrderedCommGroupWithZero \u0393\u2080]\n    [LinearOrderedCommGroupWithZero \u0393'\u2080] (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    v.IsEquiv v' \u2194 \u2200 {x : K}, v (x - 1) < 1 \u2194 v' (x - 1) < 1", "start": [513, 1], "end": [517, 45], "kind": "commanddeclaration"}, {"full_name": "Valuation.isEquiv_tfae", "code": "theorem isEquiv_tfae [LinearOrderedCommGroupWithZero \u0393\u2080] [LinearOrderedCommGroupWithZero \u0393'\u2080]\n    (v : Valuation K \u0393\u2080) (v' : Valuation K \u0393'\u2080) :\n    [v.IsEquiv v', \u2200 {x}, v x \u2264 1 \u2194 v' x \u2264 1, \u2200 {x}, v x = 1 \u2194 v' x = 1, \u2200 {x}, v x < 1 \u2194 v' x < 1,\n        \u2200 {x}, v (x - 1) < 1 \u2194 v' (x - 1) < 1].TFAE", "start": [520, 1], "end": [528, 14], "kind": "commanddeclaration"}, {"full_name": "Valuation.supp", "code": "def supp : Ideal R where\n  carrier := { x | v x = 0 }\n  zero_mem' := map_zero v\n  add_mem' {x y} hx hy := le_zero_iff.mp <|\n    calc\n      v (x + y) \u2264 max (v x) (v y) := v.map_add x y\n      _ \u2264 0 := max_le (le_zero_iff.mpr hx) (le_zero_iff.mpr hy)\n  smul_mem' c x hx :=\n    calc\n      v (c * x) = v c * v x := map_mul v c x\n      _ = v c * 0 := (congr_arg _ hx)\n      _ = 0 := mul_zero _", "start": [541, 1], "end": [553, 26], "kind": "commanddeclaration"}, {"full_name": "Valuation.mem_supp_iff", "code": "@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = 0", "start": [556, 1], "end": [558, 10], "kind": "commanddeclaration"}, {"full_name": "Valuation.map_add_supp", "code": "theorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a", "start": [573, 1], "end": [581, 74], "kind": "commanddeclaration"}, {"full_name": "Valuation.comap_supp", "code": "theorem comap_supp {S : Type*} [CommRing S] (f : S \u2192+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp", "start": [584, 1], "end": [586, 86], "kind": "commanddeclaration"}, {"full_name": "AddValuation", "code": "def AddValuation :=\n  Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48)", "start": [598, 1], "end": [601, 36], "kind": "commanddeclaration"}, {"full_name": "AddValuation.of", "code": "def of : AddValuation R \u0393\u2080 where\n  toFun := f\n  map_one' := h1\n  map_zero' := h0\n  map_add_le_max' := hadd\n  map_mul' := hmul", "start": [629, 1], "end": [635, 19], "kind": "commanddeclaration"}, {"full_name": "AddValuation.of_apply", "code": "@[simp]\ntheorem of_apply : (of f h0 h1 hadd hmul) r = f r", "start": [640, 1], "end": [641, 57], "kind": "commanddeclaration"}, {"full_name": "AddValuation.valuation", "code": "def valuation : Valuation R (Multiplicative \u0393\u2080\u1d52\u1d48) :=\n  v", "start": [644, 1], "end": [647, 4], "kind": "commanddeclaration"}, {"full_name": "AddValuation.valuation_apply", "code": "@[simp]\ntheorem valuation_apply (r : R) : v.valuation r = Multiplicative.ofAdd (OrderDual.toDual (v r))", "start": [650, 1], "end": [652, 6], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_zero", "code": "@[simp]\ntheorem map_zero : v 0 = (\u22a4 : \u0393\u2080)", "start": [658, 1], "end": [660, 23], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_one", "code": "@[simp]\ntheorem map_one : v 1 = (0 : \u0393\u2080)", "start": [663, 1], "end": [665, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.asFun", "code": "def asFun : R \u2192 \u0393\u2080 := v", "start": [669, 1], "end": [670, 24], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_mul", "code": "@[simp]\ntheorem map_mul : \u2200 (x y : R), v (x * y) = v x + v y", "start": [672, 1], "end": [674, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_add", "code": "theorem map_add : \u2200 (x y : R), min (v x) (v y) \u2264 v (x + y)", "start": [678, 1], "end": [679, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_add'", "code": "@[simp]\ntheorem map_add' : \u2200 (x y : R), v x \u2264 v (x + y) \u2228 v y \u2264 v (x + y)", "start": [682, 1], "end": [686, 16], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_le_add", "code": "theorem map_le_add {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x + y)", "start": [688, 1], "end": [689, 31], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_lt_add", "code": "theorem map_lt_add {x y : R} {g : \u0393\u2080} (hx : g < v x) (hy : g < v y) : g < v (x + y)", "start": [692, 1], "end": [693, 31], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_le_sum", "code": "theorem map_le_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hf : \u2200 i \u2208 s, g \u2264 v (f i)) :\n    g \u2264 v (\u2211 i in s, f i)", "start": [696, 1], "end": [698, 18], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_lt_sum", "code": "theorem map_lt_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g \u2260 \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i in s, f i)", "start": [701, 1], "end": [703, 21], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_lt_sum'", "code": "theorem map_lt_sum' {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R} {g : \u0393\u2080} (hg : g < \u22a4)\n    (hf : \u2200 i \u2208 s, g < v (f i)) : g < v (\u2211 i in s, f i)", "start": [706, 1], "end": [708, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_pow", "code": "@[simp]\ntheorem map_pow : \u2200 (x : R) (n : \u2115), v (x ^ n) = n \u2022 (v x)", "start": [711, 1], "end": [713, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.ext", "code": "@[ext]\ntheorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082", "start": [716, 1], "end": [718, 18], "kind": "commanddeclaration"}, {"full_name": "AddValuation.ext_iff", "code": "theorem ext_iff {v\u2081 v\u2082 : AddValuation R \u0393\u2080} : v\u2081 = v\u2082 \u2194 \u2200 (r : R), v\u2081 r = v\u2082 r", "start": [721, 1], "end": [722, 20], "kind": "commanddeclaration"}, {"full_name": "AddValuation.toPreorder", "code": "def toPreorder : Preorder R :=\n  Preorder.lift v", "start": [727, 1], "end": [729, 18], "kind": "commanddeclaration"}, {"full_name": "AddValuation.top_iff", "code": "@[simp]\ntheorem top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x = (\u22a4 : \u0393\u2080) \u2194 x = 0", "start": [732, 1], "end": [735, 13], "kind": "commanddeclaration"}, {"full_name": "AddValuation.ne_top_iff", "code": "theorem ne_top_iff [Nontrivial \u0393\u2080] (v : AddValuation K \u0393\u2080) {x : K} : v x \u2260 (\u22a4 : \u0393\u2080) \u2194 x \u2260 0", "start": [738, 1], "end": [739, 16], "kind": "commanddeclaration"}, {"full_name": "AddValuation.comap", "code": "def comap {S : Type*} [Ring S] (f : S \u2192+* R) (v : AddValuation R \u0393\u2080) : AddValuation S \u0393\u2080 :=\n  Valuation.comap f v", "start": [742, 1], "end": [744, 22], "kind": "commanddeclaration"}, {"full_name": "AddValuation.comap_id", "code": "@[simp]\ntheorem comap_id : v.comap (RingHom.id R) = v", "start": [747, 1], "end": [749, 23], "kind": "commanddeclaration"}, {"full_name": "AddValuation.comap_comp", "code": "theorem comap_comp {S\u2081 : Type*} {S\u2082 : Type*} [Ring S\u2081] [Ring S\u2082] (f : S\u2081 \u2192+* S\u2082) (g : S\u2082 \u2192+* R) :\n    v.comap (g.comp f) = (v.comap g).comap f", "start": [752, 1], "end": [754, 29], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map", "code": "def map (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f) (v : AddValuation R \u0393\u2080) :\n    AddValuation R \u0393'\u2080 :=\n  @Valuation.map R (Multiplicative \u0393\u2080\u1d52\u1d48) (Multiplicative \u0393'\u2080\u1d52\u1d48) _ _ _\n    { toFun := f\n      map_mul' := f.map_add\n      map_one' := f.map_zero\n      map_zero' := ht } (fun _ _ h => hf h) v", "start": [757, 1], "end": [766, 46], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv", "code": "def IsEquiv (v\u2081 : AddValuation R \u0393\u2080) (v\u2082 : AddValuation R \u0393'\u2080) : Prop :=\n  Valuation.IsEquiv v\u2081 v\u2082", "start": [769, 1], "end": [772, 26], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_inv", "code": "@[simp]\ntheorem map_inv (v : AddValuation K \u0393\u2080) {x : K} : v x\u207b\u00b9 = - (v x)", "start": [781, 1], "end": [783, 25], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_neg", "code": "@[simp]\ntheorem map_neg (x : R) : v (-x) = v x", "start": [786, 1], "end": [788, 24], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_sub_swap", "code": "theorem map_sub_swap (x y : R) : v (x - y) = v (y - x)", "start": [791, 1], "end": [792, 31], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_sub", "code": "theorem map_sub (x y : R) : min (v x) (v y) \u2264 v (x - y)", "start": [795, 1], "end": [796, 26], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_le_sub", "code": "theorem map_le_sub {x y : R} {g : \u0393\u2080} (hx : g \u2264 v x) (hy : g \u2264 v y) : g \u2264 v (x - y)", "start": [799, 1], "end": [800, 31], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_add_of_distinct_val", "code": "theorem map_add_of_distinct_val (h : v x \u2260 v y) : v (x + y) = @Min.min \u0393\u2080 _ (v x) (v y)", "start": [803, 1], "end": [804, 40], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_eq_of_lt_sub", "code": "theorem map_eq_of_lt_sub (h : v x < v (y - x)) : v y = v x", "start": [807, 1], "end": [808, 33], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.refl", "code": "@[refl]\ntheorem refl : v.IsEquiv v", "start": [823, 1], "end": [825, 25], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.symm", "code": "@[symm]\ntheorem symm (h : v\u2081.IsEquiv v\u2082) : v\u2082.IsEquiv v\u2081", "start": [828, 1], "end": [830, 27], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.trans", "code": "@[trans]\ntheorem trans (h\u2081\u2082 : v\u2081.IsEquiv v\u2082) (h\u2082\u2083 : v\u2082.IsEquiv v\u2083) : v\u2081.IsEquiv v\u2083", "start": [833, 1], "end": [835, 34], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.of_eq", "code": "theorem of_eq {v' : AddValuation R \u0393\u2080} (h : v = v') : v.IsEquiv v'", "start": [838, 1], "end": [839, 28], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.map", "code": "theorem map {v' : AddValuation R \u0393\u2080} (f : \u0393\u2080 \u2192+ \u0393'\u2080) (ht : f \u22a4 = \u22a4) (hf : Monotone f)\n    (inf : Injective f) (h : v.IsEquiv v') : (v.map f ht hf).IsEquiv (v'.map f ht hf)", "start": [842, 1], "end": [848, 52], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.comap", "code": "theorem comap {S : Type*} [Ring S] (f : S \u2192+* R) (h : v\u2081.IsEquiv v\u2082) :\n    (v\u2081.comap f).IsEquiv (v\u2082.comap f)", "start": [851, 1], "end": [854, 30], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.val_eq", "code": "theorem val_eq (h : v\u2081.IsEquiv v\u2082) {r s : R} : v\u2081 r = v\u2081 s \u2194 v\u2082 r = v\u2082 s", "start": [857, 1], "end": [858, 29], "kind": "commanddeclaration"}, {"full_name": "AddValuation.IsEquiv.ne_top", "code": "theorem ne_top (h : v\u2081.IsEquiv v\u2082) {r : R} : v\u2081 r \u2260 (\u22a4 : \u0393\u2080) \u2194 v\u2082 r \u2260 (\u22a4 : \u0393'\u2080)", "start": [861, 1], "end": [862, 30], "kind": "commanddeclaration"}, {"full_name": "AddValuation.supp", "code": "def supp : Ideal R :=\n  Valuation.supp v", "start": [875, 1], "end": [877, 19], "kind": "commanddeclaration"}, {"full_name": "AddValuation.mem_supp_iff", "code": "@[simp]\ntheorem mem_supp_iff (x : R) : x \u2208 supp v \u2194 v x = (\u22a4 : \u0393\u2080)", "start": [880, 1], "end": [882, 29], "kind": "commanddeclaration"}, {"full_name": "AddValuation.map_add_supp", "code": "theorem map_add_supp (a : R) {s : R} (h : s \u2208 supp v) : v (a + s) = v a", "start": [885, 1], "end": [886, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Nilpotent.lean", "imports": ["Mathlib/Algebra/GeomSum.lean", "Mathlib/LinearAlgebra/Matrix/ToLin.lean", "Mathlib/GroupTheory/Submonoid/ZeroDivisors.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Choose/Sum.lean", "Mathlib/Algebra/Algebra/Bilinear.lean", "Mathlib/RingTheory/Ideal/Operations.lean"], "premises": [{"full_name": "IsNilpotent", "code": "def IsNilpotent [Zero R] [Pow R \u2115] (x : R) : Prop :=\n  \u2203 n : \u2115, x ^ n = 0", "start": [35, 1], "end": [41, 21], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.mk", "code": "theorem IsNilpotent.mk [Zero R] [Pow R \u2115] (x : R) (n : \u2115) (e : x ^ n = 0) : IsNilpotent x", "start": [44, 1], "end": [45, 9], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.zero", "code": "@[simp] theorem IsNilpotent.zero [MonoidWithZero R] : IsNilpotent (0 : R)", "start": [48, 1], "end": [49, 17], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.neg", "code": "theorem IsNilpotent.neg [Ring R] (h : IsNilpotent x) : IsNilpotent (-x)", "start": [52, 1], "end": [55, 29], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.pow", "code": "lemma IsNilpotent.pow {n : \u2115} {S : Type*} [MonoidWithZero S] {x : S}\n    (hx : IsNilpotent x) : IsNilpotent (x ^ n.succ) := by\n  obtain \u27e8N,hN\u27e9 := hx\n  use N\n  rw [\u2190pow_mul, Nat.succ_mul, pow_add, hN, mul_zero]", "start": [58, 1], "end": [62, 53], "kind": "mathlibtacticlemma"}, {"full_name": "IsNilpotent.pow_of_pos", "code": "lemma IsNilpotent.pow_of_pos {n} {S : Type*} [MonoidWithZero S] {x : S}\n    (hx : IsNilpotent x) (hn : n \u2260 0) : IsNilpotent (x ^ n) := by\n  cases n with\n  | zero => contradiction\n  | succ => exact IsNilpotent.pow hx", "start": [64, 1], "end": [68, 37], "kind": "mathlibtacticlemma"}, {"full_name": "isNilpotent_neg_iff", "code": "@[simp]\ntheorem isNilpotent_neg_iff [Ring R] : IsNilpotent (-x) \u2194 IsNilpotent x", "start": [70, 1], "end": [72, 47], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.map", "code": "theorem IsNilpotent.map [MonoidWithZero R] [MonoidWithZero S] {r : R} {F : Type*}\n    [MonoidWithZeroHomClass F R S] (hr : IsNilpotent r) (f : F) : IsNilpotent (f r)", "start": [75, 1], "end": [78, 43], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.sub_one_isUnit", "code": "theorem IsNilpotent.sub_one_isUnit [Ring R] {r : R} (hnil : IsNilpotent r) : IsUnit (r - 1)", "start": [81, 1], "end": [87, 9], "kind": "commanddeclaration"}, {"full_name": "Commute.IsNilpotent.add_isUnit", "code": "theorem Commute.IsNilpotent.add_isUnit [Ring R] {r : R} {u : R\u02e3} (hnil : IsNilpotent r)\n    (hru : Commute r (\u2191u\u207b\u00b9 : R)) : IsUnit (u + r)", "start": [89, 1], "end": [96, 7], "kind": "commanddeclaration"}, {"full_name": "IsReduced", "code": "@[mk_iff isReduced_iff]\nclass IsReduced (R : Type*) [Zero R] [Pow R \u2115] : Prop where\n  \n  eq_zero : \u2200 x : R, IsNilpotent x \u2192 x = 0", "start": [98, 1], "end": [102, 43], "kind": "commanddeclaration"}, {"full_name": "isReduced_of_noZeroDivisors", "code": "instance (priority := 900) isReduced_of_noZeroDivisors [MonoidWithZero R] [NoZeroDivisors R] :\n    IsReduced R :=\n  \u27e8fun _ \u27e8_, hn\u27e9 => pow_eq_zero hn\u27e9", "start": [105, 1], "end": [107, 36], "kind": "commanddeclaration"}, {"full_name": "isReduced_of_subsingleton", "code": "instance (priority := 900) isReduced_of_subsingleton [Zero R] [Pow R \u2115] [Subsingleton R] :\n    IsReduced R :=\n  \u27e8fun _ _ => Subsingleton.elim _ _\u27e9", "start": [110, 1], "end": [112, 37], "kind": "commanddeclaration"}, {"full_name": "IsNilpotent.eq_zero", "code": "theorem IsNilpotent.eq_zero [Zero R] [Pow R \u2115] [IsReduced R] (h : IsNilpotent x) : x = 0", "start": [115, 1], "end": [116, 24], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_iff_eq_zero", "code": "@[simp]\ntheorem isNilpotent_iff_eq_zero [MonoidWithZero R] [IsReduced R] : IsNilpotent x \u2194 x = 0", "start": [119, 1], "end": [121, 59], "kind": "commanddeclaration"}, {"full_name": "isReduced_of_injective", "code": "theorem isReduced_of_injective [MonoidWithZero R] [MonoidWithZero S] {F : Type*}\n    [MonoidWithZeroHomClass F R S] (f : F) (hf : Function.Injective f) [IsReduced S] :\n    IsReduced R", "start": [124, 1], "end": [131, 27], "kind": "commanddeclaration"}, {"full_name": "RingHom.ker_isRadical_iff_reduced_of_surjective", "code": "theorem RingHom.ker_isRadical_iff_reduced_of_surjective {S F} [CommSemiring R] [CommRing S]\n    [RingHomClass F R S] {f : F} (hf : Function.Surjective f) :\n    (RingHom.ker f).IsRadical \u2194 IsReduced S", "start": [134, 1], "end": [138, 6], "kind": "commanddeclaration"}, {"full_name": "IsRadical", "code": "def IsRadical [Dvd R] [Pow R \u2115] (y : R) : Prop :=\n  \u2200 (n : \u2115) (x), y \u2223 x ^ n \u2192 y \u2223 x", "start": [141, 1], "end": [144, 35], "kind": "commanddeclaration"}, {"full_name": "zero_isRadical_iff", "code": "theorem zero_isRadical_iff [MonoidWithZero R] : IsRadical (0 : R) \u2194 IsReduced R", "start": [147, 1], "end": [149, 20], "kind": "commanddeclaration"}, {"full_name": "isRadical_iff_span_singleton", "code": "theorem isRadical_iff_span_singleton [CommSemiring R] :\n    IsRadical y \u2194 (Ideal.span ({y} : Set R)).IsRadical", "start": [152, 1], "end": [155, 67], "kind": "commanddeclaration"}, {"full_name": "isRadical_iff_pow_one_lt", "code": "theorem isRadical_iff_pow_one_lt [MonoidWithZero R] (k : \u2115) (hk : 1 < k) :\n    IsRadical y \u2194 \u2200 x, y \u2223 x ^ k \u2192 y \u2223 x", "start": [158, 1], "end": [162, 95], "kind": "commanddeclaration"}, {"full_name": "isReduced_iff_pow_one_lt", "code": "theorem isReduced_iff_pow_one_lt [MonoidWithZero R] (k : \u2115) (hk : 1 < k) :\n    IsReduced R \u2194 \u2200 x : R, x ^ k = 0 \u2192 x = 0", "start": [165, 1], "end": [167, 78], "kind": "commanddeclaration"}, {"full_name": "Commute.isNilpotent_add", "code": "theorem isNilpotent_add (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x + y)", "start": [176, 1], "end": [186, 43], "kind": "commanddeclaration"}, {"full_name": "Commute.isNilpotent_sum", "code": "protected lemma isNilpotent_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R}\n    (hnp : \u2200 i \u2208 s, IsNilpotent (f i)) (h_comm : \u2200 i j, i \u2208 s \u2192 j \u2208 s \u2192 Commute (f i) (f j)) :\n    IsNilpotent (\u2211 i in s, f i) := by\n  classical\n  induction' s using Finset.induction with j s hj ih; simp\n  rw [Finset.sum_insert hj]\n  apply Commute.isNilpotent_add\n  \u00b7 exact Commute.sum_right _ _ _ (fun i hi \u21a6 h_comm _ _ (by simp) (by simp [hi]))\n  \u00b7 apply hnp; simp\n  \u00b7 exact ih (fun i hi \u21a6 hnp i (by simp [hi]))\n      (fun i j hi hj \u21a6 h_comm i j (by simp [hi]) (by simp [hj]))", "start": [189, 1], "end": [199, 65], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.isNilpotent_mul_left", "code": "theorem isNilpotent_mul_left (h : IsNilpotent x) : IsNilpotent (x * y)", "start": [201, 1], "end": [204, 36], "kind": "commanddeclaration"}, {"full_name": "Commute.isNilpotent_mul_left_iff", "code": "protected lemma isNilpotent_mul_left_iff (hy : y \u2208 nonZeroDivisorsLeft R) :\n    IsNilpotent (x * y) \u2194 IsNilpotent x := by\n  refine' \u27e8_, h_comm.isNilpotent_mul_left\u27e9\n  rintro \u27e8k, hk\u27e9\n  rw [mul_pow h_comm] at hk\n  exact \u27e8k, (nonZeroDivisorsLeft R).pow_mem hy k _ hk\u27e9", "start": [207, 1], "end": [212, 55], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.isNilpotent_mul_right", "code": "theorem isNilpotent_mul_right (h : IsNilpotent y) : IsNilpotent (x * y)", "start": [214, 1], "end": [216, 43], "kind": "commanddeclaration"}, {"full_name": "Commute.isNilpotent_mul_right_iff", "code": "protected lemma isNilpotent_mul_right_iff (hx : x \u2208 nonZeroDivisorsRight R) :\n    IsNilpotent (x * y) \u2194 IsNilpotent y := by\n  refine' \u27e8_, h_comm.isNilpotent_mul_right\u27e9\n  rintro \u27e8k, hk\u27e9\n  rw [mul_pow h_comm] at hk\n  exact \u27e8k, (nonZeroDivisorsRight R).pow_mem hx k _ hk\u27e9", "start": [219, 1], "end": [224, 56], "kind": "mathlibtacticlemma"}, {"full_name": "Commute.isNilpotent_sub", "code": "theorem isNilpotent_sub (hx : IsNilpotent x) (hy : IsNilpotent y) : IsNilpotent (x - y)", "start": [232, 1], "end": [236, 37], "kind": "commanddeclaration"}, {"full_name": "isNilpotent_sum", "code": "lemma isNilpotent_sum {\u03b9 : Type*} {s : Finset \u03b9} {f : \u03b9 \u2192 R}\n    (hnp : \u2200 i \u2208 s, IsNilpotent (f i)) :\n    IsNilpotent (\u2211 i in s, f i) :=\n  Commute.isNilpotent_sum hnp fun _ _ _ _ \u21a6 Commute.all _ _", "start": [247, 1], "end": [250, 60], "kind": "mathlibtacticlemma"}, {"full_name": "nilradical", "code": "def nilradical (R : Type*) [CommSemiring R] : Ideal R :=\n  (0 : Ideal R).radical", "start": [252, 1], "end": [254, 24], "kind": "commanddeclaration"}, {"full_name": "mem_nilradical", "code": "theorem mem_nilradical : x \u2208 nilradical R \u2194 IsNilpotent x", "start": [257, 1], "end": [258, 10], "kind": "commanddeclaration"}, {"full_name": "nilradical_eq_sInf", "code": "theorem nilradical_eq_sInf (R : Type*) [CommSemiring R] :\n    nilradical R = sInf { J : Ideal R | J.IsPrime }", "start": [261, 1], "end": [263, 71], "kind": "commanddeclaration"}, {"full_name": "nilpotent_iff_mem_prime", "code": "theorem nilpotent_iff_mem_prime : IsNilpotent x \u2194 \u2200 J : Ideal R, J.IsPrime \u2192 x \u2208 J", "start": [266, 1], "end": [268, 6], "kind": "commanddeclaration"}, {"full_name": "nilradical_le_prime", "code": "theorem nilradical_le_prime (J : Ideal R) [H : J.IsPrime] : nilradical R \u2264 J", "start": [271, 1], "end": [272, 42], "kind": "commanddeclaration"}, {"full_name": "nilradical_eq_zero", "code": "@[simp]\ntheorem nilradical_eq_zero (R : Type*) [CommSemiring R] [IsReduced R] : nilradical R = 0", "start": [275, 1], "end": [277, 45], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isNilpotent_mulLeft_iff", "code": "@[simp]\ntheorem isNilpotent_mulLeft_iff (a : A) : IsNilpotent (mulLeft R a) \u2194 IsNilpotent a", "start": [286, 1], "end": [290, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isNilpotent_mulRight_iff", "code": "@[simp]\ntheorem isNilpotent_mulRight_iff (a : A) : IsNilpotent (mulRight R a) \u2194 IsNilpotent a", "start": [293, 1], "end": [297, 13], "kind": "commanddeclaration"}, {"full_name": "LinearMap.isNilpotent_toMatrix_iff", "code": "@[simp]\nlemma isNilpotent_toMatrix_iff (b : Basis \u03b9 R M) (f : M \u2192\u2097[R] M) :\n    IsNilpotent (toMatrix b b f) \u2194 IsNilpotent f := by\n  refine' exists_congr fun k \u21a6 _\n  rw [toMatrix_pow]\n  exact (toMatrix b b).map_eq_zero_iff", "start": [303, 1], "end": [308, 39], "kind": "mathlibtacticlemma"}, {"full_name": "Module.End.IsNilpotent.mapQ", "code": "theorem IsNilpotent.mapQ (hnp : IsNilpotent f) : IsNilpotent (p.mapQ p f hp)", "start": [318, 1], "end": [321, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Idempotents.lean", "imports": ["Mathlib/Algebra/Ring/Defs.lean", "Mathlib/Algebra/GroupPower/Basic.lean", "Mathlib/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsIdempotentElem", "code": "def IsIdempotentElem (p : M) : Prop :=\n  p * p = p", "start": [36, 1], "end": [39, 12], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.of_isIdempotent", "code": "theorem of_isIdempotent [IsIdempotent M (\u00b7 * \u00b7)] (a : M) : IsIdempotentElem a", "start": [44, 1], "end": [45, 28], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.eq", "code": "theorem eq {p : M} (h : IsIdempotentElem p) : p * p = p", "start": [48, 1], "end": [49, 4], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.mul_of_commute", "code": "theorem mul_of_commute {p q : S} (h : Commute p q) (h\u2081 : IsIdempotentElem p)\n    (h\u2082 : IsIdempotentElem q) : IsIdempotentElem (p * q)", "start": [52, 1], "end": [54, 98], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.zero", "code": "theorem zero : IsIdempotentElem (0 : M\u2080)", "start": [57, 1], "end": [58, 13], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.one", "code": "theorem one : IsIdempotentElem (1 : M\u2081)", "start": [61, 1], "end": [62, 12], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.one_sub", "code": "theorem one_sub {p : R} (h : IsIdempotentElem p) : IsIdempotentElem (1 - p)", "start": [65, 1], "end": [66, 86], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.one_sub_iff", "code": "@[simp]\ntheorem one_sub_iff {p : R} : IsIdempotentElem (1 - p) \u2194 IsIdempotentElem p", "start": [69, 1], "end": [71, 70], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.pow", "code": "theorem pow {p : N} (n : \u2115) (h : IsIdempotentElem p) : IsIdempotentElem (p ^ n)", "start": [74, 1], "end": [78, 45], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.pow_succ_eq", "code": "theorem pow_succ_eq {p : N} (n : \u2115) (h : IsIdempotentElem p) : p ^ (n + 1) = p", "start": [81, 1], "end": [82, 89], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.iff_eq_one", "code": "@[simp]\ntheorem iff_eq_one {p : G} : IsIdempotentElem p \u2194 p = 1", "start": [85, 1], "end": [88, 17], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.iff_eq_zero_or_one", "code": "@[simp]\ntheorem iff_eq_zero_or_one {p : G\u2080} : IsIdempotentElem p \u2194 p = 0 \u2228 p = 1", "start": [91, 1], "end": [96, 55], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.coe_zero", "code": "@[simp]\ntheorem coe_zero : \u2191(0 : { p : M\u2080 // IsIdempotentElem p }) = (0 : M\u2080)", "start": [106, 1], "end": [108, 6], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.coe_one", "code": "@[simp]\ntheorem coe_one : \u2191(1 : { p : M\u2081 // IsIdempotentElem p }) = (1 : M\u2081)", "start": [113, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.coe_compl", "code": "@[simp]\ntheorem coe_compl (p : { p : R // IsIdempotentElem p }) : \u2191p\u1d9c = (1 : R) - \u2191p", "start": [121, 1], "end": [123, 6], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.compl_compl", "code": "@[simp]\ntheorem compl_compl (p : { p : R // IsIdempotentElem p }) : p\u1d9c\u1d9c = p", "start": [126, 1], "end": [128, 36], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.zero_compl", "code": "@[simp]\ntheorem zero_compl : (0 : { p : R // IsIdempotentElem p })\u1d9c = 1", "start": [131, 1], "end": [133, 28], "kind": "commanddeclaration"}, {"full_name": "IsIdempotentElem.one_compl", "code": "@[simp]\ntheorem one_compl : (1 : { p : R // IsIdempotentElem p })\u1d9c = 0", "start": [136, 1], "end": [138, 28], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/EventuallyConst.lean", "imports": ["Mathlib/Algebra/IndicatorFunction.lean", "Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Order/Filter/Subsingleton.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Filter.EventuallyConst", "code": "def EventuallyConst (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b1) : Prop := (map f l).Subsingleton", "start": [30, 1], "end": [31, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eventuallyConst_iff", "code": "theorem HasBasis.eventuallyConst_iff {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    (h : l.HasBasis p s) : EventuallyConst f l \u2194 \u2203 i, p i \u2227 \u2200 x \u2208 s i, \u2200 y \u2208 s i, f x = f y", "start": [33, 1], "end": [35, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.eventuallyConst_iff'", "code": "theorem HasBasis.eventuallyConst_iff' {\u03b9 : Sort*} {p : \u03b9 \u2192 Prop} {s : \u03b9 \u2192 Set \u03b1}\n    {x : \u03b9 \u2192 \u03b1} (h : l.HasBasis p s) (hx : \u2200 i, p i \u2192 x i \u2208 s i) :\n    EventuallyConst f l \u2194 \u2203 i, p i \u2227 \u2200 y \u2208 s i, f y = f (x i)", "start": [37, 1], "end": [41, 80], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_iff_tendsto", "code": "lemma eventuallyConst_iff_tendsto [Nonempty \u03b2] :\n    EventuallyConst f l \u2194 \u2203 x, Tendsto f l (pure x) :=\n  subsingleton_iff_exists_le_pure", "start": [43, 1], "end": [45, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.exists_tendsto", "code": "alias \u27e8EventuallyConst.exists_tendsto, _\u27e9 := eventuallyConst_iff_tendsto", "start": [47, 1], "end": [47, 73], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.EventuallyConst.of_tendsto", "code": "theorem EventuallyConst.of_tendsto {x : \u03b2} (h : Tendsto f l (pure x)) : EventuallyConst f l", "start": [49, 1], "end": [50, 65], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_iff_exists_eventuallyEq", "code": "theorem eventuallyConst_iff_exists_eventuallyEq [Nonempty \u03b2] :\n    EventuallyConst f l \u2194 \u2203 c, f =\u1da0[l] fun _ \u21a6 c", "start": [52, 1], "end": [54, 40], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyConst.eventuallyEq_const", "code": "alias \u27e8EventuallyConst.eventuallyEq_const, _\u27e9 := eventuallyConst_iff_exists_eventuallyEq", "start": [56, 1], "end": [56, 89], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Filter.eventuallyConst_pred'", "code": "theorem eventuallyConst_pred' {p : \u03b1 \u2192 Prop} :\n    EventuallyConst p l \u2194 (p =\u1da0[l] fun _ \u21a6 False) \u2228 (p =\u1da0[l] fun _ \u21a6 True)", "start": [58, 1], "end": [60, 71], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_pred", "code": "theorem eventuallyConst_pred {p : \u03b1 \u2192 Prop} :\n    EventuallyConst p l \u2194 (\u2200\u1da0 x in l, p x) \u2228 (\u2200\u1da0 x in l, \u00acp x)", "start": [62, 1], "end": [64, 54], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_set'", "code": "theorem eventuallyConst_set' {s : Set \u03b1} :\n    EventuallyConst s l \u2194 (s =\u1da0[l] (\u2205 : Set \u03b1)) \u2228 s =\u1da0[l] univ", "start": [66, 1], "end": [68, 24], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_set", "code": "theorem eventuallyConst_set {s : Set \u03b1} :\n    EventuallyConst s l \u2194 (\u2200\u1da0 x in l, x \u2208 s) \u2228 (\u2200\u1da0 x in l, x \u2209 s)", "start": [70, 1], "end": [72, 23], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyEq.eventuallyConst_iff", "code": "theorem EventuallyEq.eventuallyConst_iff {g : \u03b1 \u2192 \u03b2} (h : f =\u1da0[l] g) :\n    EventuallyConst f l \u2194 EventuallyConst g l", "start": [74, 1], "end": [76, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_id", "code": "@[simp] theorem eventuallyConst_id : EventuallyConst id l \u2194 l.Subsingleton", "start": [78, 1], "end": [78, 86], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyConst.bot", "code": "@[simp] protected lemma bot : EventuallyConst f \u22a5 := subsingleton_bot", "start": [82, 1], "end": [82, 70], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.const", "code": "@[simp]\nprotected lemma const (c : \u03b2) : EventuallyConst (fun _ \u21a6 c) l :=\n  .of_tendsto tendsto_const_pure", "start": [84, 1], "end": [86, 33], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.congr", "code": "protected lemma congr {g} (h : EventuallyConst f l) (hg : f =\u1da0[l] g) : EventuallyConst g l :=\n  hg.eventuallyConst_iff.1 h", "start": [88, 1], "end": [89, 29], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.of_subsingleton_right", "code": "@[nontriviality]\nlemma of_subsingleton_right [Subsingleton \u03b2] : EventuallyConst f l := .of_subsingleton", "start": [91, 1], "end": [92, 87], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.anti", "code": "nonrec lemma anti {l'} (h : EventuallyConst f l) (hl' : l' \u2264 l) : EventuallyConst f l' :=\n  h.anti (map_mono hl')", "start": [94, 1], "end": [95, 24], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.of_subsingleton_left", "code": "@[nontriviality]\nlemma of_subsingleton_left [Subsingleton \u03b1] : EventuallyConst f l :=\n  .map .of_subsingleton f", "start": [97, 1], "end": [99, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.comp", "code": "lemma comp (h : EventuallyConst f l) (g : \u03b2 \u2192 \u03b3) : EventuallyConst (g \u2218 f) l := h.map g", "start": [101, 1], "end": [101, 88], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.inv", "code": "@[to_additive]\nprotected lemma inv [Inv \u03b2] (h : EventuallyConst f l) : EventuallyConst (f\u207b\u00b9) l := h.comp Inv.inv", "start": [103, 1], "end": [104, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.comp_tendsto", "code": "lemma comp_tendsto {lb : Filter \u03b2} {g : \u03b2 \u2192 \u03b3} (hg : EventuallyConst g lb)\n    (hf : Tendsto f l lb) : EventuallyConst (g \u2218 f) l :=\n  hg.anti hf", "start": [106, 1], "end": [108, 13], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.apply", "code": "lemma apply {\u03b9 : Type*} {p : \u03b9 \u2192 Type*} {g : \u03b1 \u2192 \u2200 x, p x}\n    (h : EventuallyConst g l) (i : \u03b9) : EventuallyConst (g \u00b7 i) l :=\n  h.comp <| Function.eval i", "start": [110, 1], "end": [112, 28], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.comp\u2082", "code": "lemma comp\u2082 {g : \u03b1 \u2192 \u03b3} (hf : EventuallyConst f l) (op : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : EventuallyConst g l) :\n    EventuallyConst (fun x \u21a6 op (f x) (g x)) l :=\n  ((hf.prod hg).map op.uncurry).anti <|\n    (tendsto_map (f := op.uncurry)).comp (tendsto_map.prod_mk tendsto_map)", "start": [114, 1], "end": [117, 75], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.prod_mk", "code": "lemma prod_mk {g : \u03b1 \u2192 \u03b3} (hf : EventuallyConst f l) (hg : EventuallyConst g l) :\n    EventuallyConst (fun x \u21a6 (f x, g x)) l :=\n  hf.comp\u2082 Prod.mk hg", "start": [119, 1], "end": [121, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.mul", "code": "@[to_additive]\nlemma mul [Mul \u03b2] {g : \u03b1 \u2192 \u03b2} (hf : EventuallyConst f l) (hg : EventuallyConst g l) :\n    EventuallyConst (f * g) l :=\n  hf.comp\u2082 (\u00b7 * \u00b7) hg", "start": [123, 1], "end": [126, 22], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.of_mulIndicator_const", "code": "@[to_additive]\nlemma of_mulIndicator_const (h : EventuallyConst (s.mulIndicator fun _ \u21a6 c) l) (hc : c \u2260 1) :\n    EventuallyConst s l := by\n  simpa [(\u00b7 \u2218 \u00b7), hc, imp_false] using h.comp (\u00b7 = c)", "start": [130, 1], "end": [133, 54], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.EventuallyConst.mulIndicator_const", "code": "@[to_additive]\ntheorem mulIndicator_const (h : EventuallyConst s l) (c : \u03b2) :\n    EventuallyConst (s.mulIndicator fun _ \u21a6 c) l", "start": [135, 1], "end": [138, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyConst.mulIndicator_const_iff_of_ne", "code": "@[to_additive]\ntheorem mulIndicator_const_iff_of_ne (hc : c \u2260 1) :\n    EventuallyConst (s.mulIndicator fun _ \u21a6 c) l \u2194 EventuallyConst s l", "start": [140, 1], "end": [143, 59], "kind": "commanddeclaration"}, {"full_name": "Filter.EventuallyConst.mulIndicator_const_iff", "code": "@[to_additive (attr := simp)]\ntheorem mulIndicator_const_iff :\n    EventuallyConst (s.mulIndicator fun _ \u21a6 c) l \u2194 c = 1 \u2228 EventuallyConst s l", "start": [145, 1], "end": [148, 79], "kind": "commanddeclaration"}, {"full_name": "Filter.eventuallyConst_atTop", "code": "lemma eventuallyConst_atTop [SemilatticeSup \u03b1] [Nonempty \u03b1] :\n    EventuallyConst f atTop \u2194 (\u2203 i, \u2200 j, i \u2264 j \u2192 f j = f i) :=\n  (atTop_basis.eventuallyConst_iff' fun i _ \u21a6 left_mem_Ici).trans <| by\n    simp only [true_and, mem_Ici]", "start": [152, 1], "end": [155, 34], "kind": "mathlibtacticlemma"}, {"full_name": "Filter.eventuallyConst_atTop_nat", "code": "lemma eventuallyConst_atTop_nat {f : \u2115 \u2192 \u03b1} :\n    EventuallyConst f atTop \u2194 \u2203 n, \u2200 m, n \u2264 m \u2192 f (m + 1) = f m := by\n  rw [eventuallyConst_atTop]\n  refine exists_congr fun n \u21a6 \u27e8fun h m hm \u21a6 ?_, fun h m hm \u21a6 ?_\u27e9\n  \u00b7 exact (h (m + 1) (hm.trans m.le_succ)).trans (h m hm).symm\n  \u00b7 induction m, hm using Nat.le_induction with\n    | base => rfl\n    | succ m hm ihm => exact (h m hm).trans ihm", "start": [157, 1], "end": [164, 48], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/RingTheory/Finiteness.lean", "imports": ["Mathlib/GroupTheory/Finiteness.lean", "Mathlib/LinearAlgebra/StdBasis.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/RestrictScalars.lean", "Mathlib/RingTheory/Ideal/Operations.lean"], "premises": [{"full_name": "Submodule.FG", "code": "def FG (N : Submodule R M) : Prop :=\n  \u2203 S : Finset M, Submodule.span R \u2191S = N", "start": [46, 1], "end": [48, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_def", "code": "theorem fg_def {N : Submodule R M} : N.FG \u2194 \u2203 S : Set M, S.Finite \u2227 span R S = N", "start": [51, 1], "end": [55, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iff_addSubmonoid_fg", "code": "theorem fg_iff_addSubmonoid_fg (P : Submodule \u2115 M) : P.FG \u2194 P.toAddSubmonoid.FG", "start": [58, 1], "end": [60, 65], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iff_add_subgroup_fg", "code": "theorem fg_iff_add_subgroup_fg {G : Type*} [AddCommGroup G] (P : Submodule \u2124 G) :\n    P.FG \u2194 P.toAddSubgroup.FG", "start": [63, 1], "end": [66, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iff_exists_fin_generating_family", "code": "theorem fg_iff_exists_fin_generating_family {N : Submodule R M} :\n    N.FG \u2194 \u2203 (n : \u2115) (s : Fin n \u2192 M), span R (range s) = N", "start": [69, 1], "end": [77, 42], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul", "code": "theorem exists_sub_one_mem_and_smul_eq_zero_of_fg_of_le_smul {R : Type*} [CommRing R] {M : Type*}\n    [AddCommGroup M] [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.FG) (hin : N \u2264 I \u2022 N) :\n    \u2203 r : R, r - 1 \u2208 I \u2227 \u2200 n \u2208 N, r \u2022 n = (0 : M)", "start": [80, 1], "end": [134, 55], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_mem_and_smul_eq_self_of_fg_of_le_smul", "code": "theorem exists_mem_and_smul_eq_self_of_fg_of_le_smul {R : Type*} [CommRing R] {M : Type*}\n    [AddCommGroup M] [Module R M] (I : Ideal R) (N : Submodule R M) (hn : N.FG) (hin : N \u2264 I \u2022 N) :\n    \u2203 r \u2208 I, \u2200 n \u2208 N, r \u2022 n = n", "start": [137, 1], "end": [141, 81], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_bot", "code": "theorem fg_bot : (\u22a5 : Submodule R M).FG", "start": [144, 1], "end": [145, 44], "kind": "commanddeclaration"}, {"full_name": "Subalgebra.fg_bot_toSubmodule", "code": "theorem _root_.Subalgebra.fg_bot_toSubmodule {R A : Type*} [CommSemiring R] [Semiring A]\n    [Algebra R A] : (\u22a5 : Subalgebra R A).toSubmodule.FG", "start": [148, 1], "end": [150, 43], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_unit", "code": "theorem fg_unit {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] (I : (Submodule R A)\u02e3) :\n    (I : Submodule R A).FG", "start": [153, 1], "end": [164, 15], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_of_isUnit", "code": "theorem fg_of_isUnit {R A : Type*} [CommSemiring R] [Semiring A] [Algebra R A] {I : Submodule R A}\n    (hI : IsUnit I) : I.FG", "start": [167, 1], "end": [169, 18], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_span", "code": "theorem fg_span {s : Set M} (hs : s.Finite) : FG (span R s)", "start": [172, 1], "end": [173, 41], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_span_singleton", "code": "theorem fg_span_singleton (x : M) : FG (R \u2219 x)", "start": [176, 1], "end": [177, 31], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.sup", "code": "theorem FG.sup {N\u2081 N\u2082 : Submodule R M} (hN\u2081 : N\u2081.FG) (hN\u2082 : N\u2082.FG) : (N\u2081 \u2294 N\u2082).FG", "start": [180, 1], "end": [183, 74], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_finset_sup", "code": "theorem fg_finset_sup {\u03b9 : Type*} (s : Finset \u03b9) (N : \u03b9 \u2192 Submodule R M) (h : \u2200 i \u2208 s, (N i).FG) :\n    (s.sup N).FG", "start": [186, 1], "end": [188, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_biSup", "code": "theorem fg_biSup {\u03b9 : Type*} (s : Finset \u03b9) (N : \u03b9 \u2192 Submodule R M) (h : \u2200 i \u2208 s, (N i).FG) :\n    (\u2a06 i \u2208 s, N i).FG", "start": [191, 1], "end": [192, 86], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iSup", "code": "theorem fg_iSup {\u03b9 : Type*} [Finite \u03b9] (N : \u03b9 \u2192 Submodule R M) (h : \u2200 i, (N i).FG) :\n    (iSup N).FG", "start": [195, 1], "end": [198, 52], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.map", "code": "theorem FG.map {N : Submodule R M} (hs : N.FG) : (N.map f).FG", "start": [205, 1], "end": [207, 60], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_of_fg_map_injective", "code": "theorem fg_of_fg_map_injective (f : M \u2192\u2097[R] P) (hf : Function.Injective f) {N : Submodule R M}\n    (hfn : (N.map f).FG) : N.FG", "start": [212, 1], "end": [220, 29], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_of_fg_map", "code": "theorem fg_of_fg_map {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P]\n    [Module R P] (f : M \u2192\u2097[R] P)\n    (hf : LinearMap.ker f = \u22a5) {N : Submodule R M}\n    (hfn : (N.map f).FG) : N.FG", "start": [223, 1], "end": [227, 59], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_top", "code": "theorem fg_top (N : Submodule R M) : (\u22a4 : Submodule R N).FG \u2194 N.FG", "start": [230, 1], "end": [232, 95], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_of_linearEquiv", "code": "theorem fg_of_linearEquiv (e : M \u2243\u2097[R] P) (h : (\u22a4 : Submodule R P).FG) : (\u22a4 : Submodule R M).FG", "start": [235, 1], "end": [236, 56], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.prod", "code": "theorem FG.prod {sb : Submodule R M} {sc : Submodule R P} (hsb : sb.FG) (hsc : sc.FG) :\n    (sb.prod sc).FG", "start": [239, 1], "end": [245, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_pi", "code": "theorem fg_pi {\u03b9 : Type*} {M : \u03b9 \u2192 Type*} [Finite \u03b9] [\u2200 i, AddCommMonoid (M i)]\n    [\u2200 i, Module R (M i)] {p : \u2200 i, Submodule R (M i)} (hsb : \u2200 i, (p i).FG) :\n    (Submodule.pi Set.univ p).FG", "start": [248, 1], "end": [257, 70], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_of_fg_map_of_fg_inf_ker", "code": "theorem fg_of_fg_map_of_fg_inf_ker {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    [AddCommGroup P] [Module R P] (f : M \u2192\u2097[R] P) {s : Submodule R M}\n    (hs1 : (s.map f).FG)\n    (hs2 : (s \u2293 LinearMap.ker f).FG) : s.FG", "start": [260, 1], "end": [333, 40], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_induction", "code": "theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    (P : Submodule R M \u2192 Prop) (h\u2081 : \u2200 x, P (Submodule.span R {x}))\n    (h\u2082 : \u2200 M\u2081 M\u2082, P M\u2081 \u2192 P M\u2082 \u2192 P (M\u2081 \u2294 M\u2082)) (N : Submodule R M) (hN : N.FG) : P N", "start": [336, 1], "end": [345, 36], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_ker_comp", "code": "theorem fg_ker_comp {R M N P : Type*} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N]\n    [Module R N] [AddCommGroup P] [Module R P] (f : M \u2192\u2097[R] N) (g : N \u2192\u2097[R] P)\n    (hf1 : (LinearMap.ker f).FG) (hf2 : (LinearMap.ker g).FG)\n    (hsur : Function.Surjective f) : (g.comp f).ker.FG", "start": [348, 1], "end": [358, 57], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_restrictScalars", "code": "theorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommGroup M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG", "start": [361, 1], "end": [367, 64], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.stablizes_of_iSup_eq", "code": "theorem FG.stablizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : \u2115 \u2192o Submodule R M)\n    (H : iSup N = M') : \u2203 n, M' = N n", "start": [370, 1], "end": [386, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.fg_iff_compact", "code": "theorem fg_iff_compact (s : Submodule R M) : s.FG \u2194 CompleteLattice.IsCompactElement s", "start": [389, 1], "end": [417, 22], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.map\u2082", "code": "theorem FG.map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) {p : Submodule R M} {q : Submodule R N} (hp : p.FG)\n    (hq : q.FG) : (map\u2082 f p q).FG", "start": [432, 1], "end": [438, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.mul", "code": "theorem FG.mul (hm : M.FG) (hn : N.FG) : (M * N).FG", "start": [449, 1], "end": [450, 15], "kind": "commanddeclaration"}, {"full_name": "Submodule.FG.pow", "code": "theorem FG.pow (h : M.FG) (n : \u2115) : (M ^ n).FG", "start": [453, 1], "end": [454, 90], "kind": "commanddeclaration"}, {"full_name": "Ideal.FG", "code": "def FG (I : Ideal R) : Prop :=\n  \u2203 S : Finset R, Ideal.span \u2191S = I", "start": [465, 1], "end": [469, 36], "kind": "commanddeclaration"}, {"full_name": "Ideal.FG.map", "code": "theorem FG.map {R S : Type*} [Semiring R] [Semiring S] {I : Ideal R} (h : I.FG) (f : R \u2192+* S) :\n    (I.map f).FG", "start": [472, 1], "end": [480, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.fg_ker_comp", "code": "theorem fg_ker_comp {R S A : Type*} [CommRing R] [CommRing S] [CommRing A] (f : R \u2192+* S)\n    (g : S \u2192+* A) (hf : f.ker.FG) (hg : g.ker.FG) (hsur : Function.Surjective f) :\n    (g.comp f).ker.FG", "start": [483, 1], "end": [492, 99], "kind": "commanddeclaration"}, {"full_name": "Ideal.exists_radical_pow_le_of_fg", "code": "theorem exists_radical_pow_le_of_fg {R : Type*} [CommSemiring R] (I : Ideal R) (h : I.radical.FG) :\n    \u2203 n : \u2115, I.radical ^ n \u2264 I", "start": [495, 1], "end": [513, 29], "kind": "commanddeclaration"}, {"full_name": "Module.Finite", "code": "class Module.Finite [Semiring R] [AddCommMonoid M] [Module R M] : Prop where\n  out : (\u22a4 : Submodule R M).FG", "start": [522, 1], "end": [524, 31], "kind": "commanddeclaration"}, {"full_name": "Module.finite_def", "code": "theorem finite_def {R M} [Semiring R] [AddCommMonoid M] [Module R M] :\n    Finite R M \u2194 (\u22a4 : Submodule R M).FG", "start": [533, 1], "end": [535, 31], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.iff_addMonoid_fg", "code": "theorem iff_addMonoid_fg {M : Type*} [AddCommMonoid M] : Module.Finite \u2115 M \u2194 AddMonoid.FG M", "start": [542, 1], "end": [544, 83], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.iff_addGroup_fg", "code": "theorem iff_addGroup_fg {G : Type*} [AddCommGroup G] : Module.Finite \u2124 G \u2194 AddGroup.FG G", "start": [547, 1], "end": [549, 82], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.exists_fin", "code": "theorem exists_fin [Finite R M] : \u2203 (n : \u2115) (s : Fin n \u2192 M), Submodule.span R (range s) = \u22a4", "start": [554, 1], "end": [556, 55], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.exists_fin'", "code": "lemma exists_fin' (R M : Type*) [CommSemiring R] [AddCommMonoid M] [Module R M] [Finite R M] :\n    \u2203 (n : \u2115) (f : (Fin n \u2192 R) \u2192\u2097[R] M), Surjective f := by\n  have \u27e8n, s, hs\u27e9 := exists_fin (R := R) (M := M)\n  exact \u27e8n, piEquiv (Fin n) R M s, by simpa\u27e9", "start": [559, 1], "end": [562, 45], "kind": "mathlibtacticlemma"}, {"full_name": "Module.Finite.of_surjective", "code": "theorem of_surjective [hM : Finite R M] (f : M \u2192\u2097[R] N) (hf : Surjective f) : Finite R N", "start": [564, 1], "end": [567, 22], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.range", "code": "instance range [Finite R M] (f : M \u2192\u2097[R] N) : Finite R (LinearMap.range f) :=\n  of_surjective f.rangeRestrict fun \u27e8_, y, hy\u27e9 => \u27e8y, Subtype.ext hy\u27e9", "start": [570, 1], "end": [572, 70], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.map", "code": "instance map (p : Submodule R M) [Finite R p] (f : M \u2192\u2097[R] N) : Finite R (p.map f) :=\n  of_surjective (f.restrict fun _ => Submodule.mem_map_of_mem) fun \u27e8_, _, hy, hy'\u27e9 =>\n    \u27e8\u27e8_, hy\u27e9, Subtype.ext hy'\u27e9", "start": [575, 1], "end": [578, 31], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.self", "code": "instance self : Finite R R :=\n  \u27e8\u27e8{1}, by simpa only [Finset.coe_singleton] using Ideal.span_singleton_one\u27e9\u27e9", "start": [583, 1], "end": [584, 79], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.of_restrictScalars_finite", "code": "theorem of_restrictScalars_finite (R A M : Type*) [CommSemiring R] [Semiring A] [AddCommMonoid M]\n    [Module R M] [Module A M] [Algebra R A] [IsScalarTower R A M] [hM : Finite R M] :\n    Finite A M", "start": [589, 1], "end": [597, 13], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.prod", "code": "instance prod [hM : Finite R M] [hN : Finite R N] : Finite R (M \u00d7 N) :=\n  \u27e8by\n    rw [\u2190 Submodule.prod_top]\n    exact hM.1.prod hN.1\u27e9", "start": [602, 1], "end": [605, 26], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.pi", "code": "instance pi {\u03b9 : Type*} {M : \u03b9 \u2192 Type*} [_root_.Finite \u03b9] [\u2200 i, AddCommMonoid (M i)]\n    [\u2200 i, Module R (M i)] [h : \u2200 i, Finite R (M i)] : Finite R (\u2200 i, M i) :=\n  \u27e8by\n    rw [\u2190 Submodule.pi_top]\n    exact Submodule.fg_pi fun i => (h i).1\u27e9", "start": [608, 1], "end": [612, 44], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.equiv", "code": "theorem equiv [Finite R M] (e : M \u2243\u2097[R] N) : Finite R N", "start": [615, 1], "end": [616, 45], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.ulift", "code": "instance ulift [Finite R M] : Finite R (ULift M) := equiv ULift.moduleEquiv.symm", "start": [619, 1], "end": [619, 81], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.trans", "code": "theorem trans {R : Type*} (A M : Type*) [CommSemiring R] [Semiring A] [Algebra R A]\n    [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M] :\n    \u2200 [Finite R A] [Finite A M], Finite R M", "start": [623, 1], "end": [631, 45], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.base_change", "code": "instance Module.Finite.base_change [CommSemiring R] [Semiring A] [Algebra R A] [AddCommMonoid M]\n    [Module R M] [h : Module.Finite R M] : Module.Finite A (TensorProduct R A M) := by\n  classical\n    obtain \u27e8s, hs\u27e9 := h.out\n    refine' \u27e8\u27e8s.image (TensorProduct.mk R A M 1), eq_top_iff.mpr fun x _ => _\u27e9\u27e9\n    apply @TensorProduct.induction_on _ _ _ _ _ _ _ _ _ x\n    \u00b7 exact zero_mem _\n    \u00b7 intro x y\n      haveI : IsScalarTower R A (TensorProduct R A M) := TensorProduct.isScalarTower_left\n      rw [Finset.coe_image, \u2190 Submodule.span_span_of_tower R, Submodule.span_image, hs,\n        Submodule.map_top, LinearMap.range_coe]\n      change _ \u2208 Submodule.span A (Set.range <| TensorProduct.mk R A M 1)\n      rw [\u2190 mul_one x, \u2190 smul_eq_mul, \u2190 TensorProduct.smul_tmul']\n      exact Submodule.smul_mem _ x (Submodule.subset_span <| Set.mem_range_self y)\n    \u00b7 exact fun _ _ => Submodule.add_mem _", "start": [647, 1], "end": [662, 43], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.tensorProduct", "code": "instance Module.Finite.tensorProduct [CommSemiring R] [AddCommMonoid M] [Module R M]\n    [AddCommMonoid N] [Module R N] [hM : Module.Finite R M] [hN : Module.Finite R N] :\n    Module.Finite R (TensorProduct R M N) where\n  out := (TensorProduct.map\u2082_mk_top_top_eq_top R M N).subst (hM.out.map\u2082 _ hN.out)", "start": [665, 1], "end": [668, 83], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite", "code": "def Finite (f : A \u2192+* B) : Prop :=\n  letI : Algebra A B := f.toAlgebra\n  Module.Finite A B", "start": [677, 1], "end": [680, 20], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.id", "code": "theorem id : Finite (RingHom.id A)", "start": [687, 1], "end": [688, 23], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.of_surjective", "code": "theorem of_surjective (f : A \u2192+* B) (hf : Surjective f) : f.Finite", "start": [693, 1], "end": [695, 57], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.comp", "code": "theorem comp {g : B \u2192+* C} {f : A \u2192+* B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite", "start": [698, 1], "end": [705, 32], "kind": "commanddeclaration"}, {"full_name": "RingHom.Finite.of_comp_finite", "code": "theorem of_comp_finite {f : A \u2192+* B} {g : B \u2192+* C} (h : (g.comp f).Finite) : g.Finite", "start": [708, 1], "end": [714, 54], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite", "code": "def Finite (f : A \u2192\u2090[R] B) : Prop :=\n  f.toRingHom.Finite", "start": [729, 1], "end": [732, 21], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite.id", "code": "theorem id : Finite (AlgHom.id R A)", "start": [739, 1], "end": [740, 22], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite.comp", "code": "theorem comp {g : B \u2192\u2090[R] C} {f : A \u2192\u2090[R] B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite", "start": [745, 1], "end": [746, 28], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite.of_surjective", "code": "theorem of_surjective (f : A \u2192\u2090[R] B) (hf : Surjective f) : f.Finite", "start": [749, 1], "end": [750, 46], "kind": "commanddeclaration"}, {"full_name": "AlgHom.Finite.of_comp_finite", "code": "theorem of_comp_finite {f : A \u2192\u2090[R] B} {g : B \u2192\u2090[R] C} (h : (g.comp f).Finite) : g.Finite", "start": [753, 1], "end": [754, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/Exponential.lean", "imports": ["Mathlib/SetTheory/Ordinal/Arithmetic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.pow", "code": "instance pow : Pow Ordinal Ordinal :=\n  \u27e8fun a b => if a = 0 then 1 - b else limitRecOn b 1 (fun _ IH => IH * a) fun b _ => bsup.{u, u} b\u27e9", "start": [28, 1], "end": [30, 101], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_def", "code": "theorem opow_def (a b : Ordinal) :\n    (a^b) = if a = 0 then 1 - b else limitRecOn b 1 (fun _ IH => IH * a) fun b _ => bsup.{u, u} b", "start": [35, 1], "end": [37, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_opow'", "code": "theorem zero_opow' (a : Ordinal) : (0^a) = 1 - a", "start": [41, 1], "end": [41, 85], "kind": "commanddeclaration"}, {"full_name": "Ordinal.zero_opow", "code": "@[simp]\ntheorem zero_opow {a : Ordinal} (a0 : a \u2260 0) : (0^a) = 0", "start": [44, 1], "end": [46, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_zero", "code": "@[simp]\ntheorem opow_zero (a : Ordinal) : (a^0) = 1", "start": [49, 1], "end": [53, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_succ", "code": "@[simp]\ntheorem opow_succ (a b : Ordinal) : (a^succ b) = (a^b) * a", "start": [56, 1], "end": [59, 58], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_limit", "code": "theorem opow_limit {a b : Ordinal} (a0 : a \u2260 0) (h : IsLimit b) :\n    (a^b) = bsup.{u, u} b fun c _ => a^c", "start": [62, 1], "end": [64, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_le_of_limit", "code": "theorem opow_le_of_limit {a b c : Ordinal} (a0 : a \u2260 0) (h : IsLimit b) :\n    (a^b) \u2264 c \u2194 \u2200 b' < b, (a^b') \u2264 c", "start": [67, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_opow_of_limit", "code": "theorem lt_opow_of_limit {a b c : Ordinal} (b0 : b \u2260 0) (h : IsLimit c) :\n    a < (b^c) \u2194 \u2203 c' < c, a < (b^c')", "start": [71, 1], "end": [73, 98], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_one", "code": "@[simp]\ntheorem opow_one (a : Ordinal) : (a^1) = a", "start": [76, 1], "end": [78, 62], "kind": "commanddeclaration"}, {"full_name": "Ordinal.one_opow", "code": "@[simp]\ntheorem one_opow (a : Ordinal) : (1^a) = 1", "start": [81, 1], "end": [90, 94], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_pos", "code": "theorem opow_pos {a : Ordinal} (b) (a0 : 0 < a) : 0 < (a^b)", "start": [93, 1], "end": [101, 79], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_ne_zero", "code": "theorem opow_ne_zero {a : Ordinal} (b) (a0 : a \u2260 0) : (a^b) \u2260 0", "start": [104, 1], "end": [105, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_isNormal", "code": "theorem opow_isNormal {a : Ordinal} (h : 1 < a) : IsNormal ((\u00b7^\u00b7) a)", "start": [108, 1], "end": [111, 51], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_lt_opow_iff_right", "code": "theorem opow_lt_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : (a^b) < (a^c) \u2194 b < c", "start": [114, 1], "end": [115, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_le_opow_iff_right", "code": "theorem opow_le_opow_iff_right {a b c : Ordinal} (a1 : 1 < a) : (a^b) \u2264 (a^c) \u2194 b \u2264 c", "start": [118, 1], "end": [119, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_right_inj", "code": "theorem opow_right_inj {a b c : Ordinal} (a1 : 1 < a) : (a^b) = (a^c) \u2194 b = c", "start": [122, 1], "end": [123, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_isLimit", "code": "theorem opow_isLimit {a b : Ordinal} (a1 : 1 < a) : IsLimit b \u2192 IsLimit (a^b)", "start": [126, 1], "end": [127, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_isLimit_left", "code": "theorem opow_isLimit_left {a b : Ordinal} (l : IsLimit a) (hb : b \u2260 0) : IsLimit (a^b)", "start": [130, 1], "end": [135, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_le_opow_right", "code": "theorem opow_le_opow_right {a b c : Ordinal} (h\u2081 : 0 < a) (h\u2082 : b \u2264 c) : (a^b) \u2264 (a^c)", "start": [138, 1], "end": [143, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_le_opow_left", "code": "theorem opow_le_opow_left {a b : Ordinal} (c) (ab : a \u2264 b) : (a^c) \u2264 (b^c)", "start": [146, 1], "end": [161, 96], "kind": "commanddeclaration"}, {"full_name": "Ordinal.left_le_opow", "code": "theorem left_le_opow (a : Ordinal) {b : Ordinal} (b1 : 0 < b) : a \u2264 (a^b)", "start": [164, 1], "end": [172, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.right_le_opow", "code": "theorem right_le_opow {a : Ordinal} (b) (a1 : 1 < a) : b \u2264 (a^b)", "start": [175, 1], "end": [176, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_lt_opow_left_of_succ", "code": "theorem opow_lt_opow_left_of_succ {a b c : Ordinal} (ab : a < b) : (a^succ c) < (b^succ c)", "start": [179, 1], "end": [183, 81], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_add", "code": "theorem opow_add (a b c : Ordinal) : a^(b + c) = (a^b) * (a^c)", "start": [186, 1], "end": [207, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_one_add", "code": "theorem opow_one_add (a b : Ordinal) : a^(1 + b) = a * (a^b)", "start": [210, 1], "end": [210, 91], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_dvd_opow", "code": "theorem opow_dvd_opow (a) {b c : Ordinal} (h : b \u2264 c) : (a^b) \u2223 (a^c)", "start": [213, 1], "end": [214, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_dvd_opow_iff", "code": "theorem opow_dvd_opow_iff {a b c : Ordinal} (a1 : 1 < a) : (a^b) \u2223 (a^c) \u2194 b \u2264 c", "start": [217, 1], "end": [222, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_mul", "code": "theorem opow_mul (a b c : Ordinal) : a^(b * c) = ((a^b)^c)", "start": [225, 1], "end": [247, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log", "code": "def log (b : Ordinal) (x : Ordinal) : Ordinal :=\n  if _h : 1 < b then pred (sInf { o | x < (b^o) }) else 0", "start": [253, 1], "end": [257, 58], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_nonempty", "code": "theorem log_nonempty {b x : Ordinal} (h : 1 < b) : { o | x < (b^o) }.Nonempty", "start": [260, 1], "end": [262, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_def", "code": "theorem log_def {b : Ordinal} (h : 1 < b) (x : Ordinal) : log b x = pred (sInf { o | x < (b^o) })", "start": [265, 1], "end": [266, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_of_not_one_lt_left", "code": "theorem log_of_not_one_lt_left {b : Ordinal} (h : \u00ac1 < b) (x : Ordinal) : log b x = 0", "start": [269, 1], "end": [270, 29], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_of_left_le_one", "code": "theorem log_of_left_le_one {b : Ordinal} (h : b \u2264 1) : \u2200 x, log b x = 0", "start": [273, 1], "end": [274, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_zero_left", "code": "@[simp]\ntheorem log_zero_left : \u2200 b, log 0 b = 0", "start": [277, 1], "end": [279, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_zero_right", "code": "@[simp]\ntheorem log_zero_right (b : Ordinal) : log b 0 = 0", "start": [282, 1], "end": [290, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_one_left", "code": "@[simp]\ntheorem log_one_left : \u2200 b, log 1 b = 0", "start": [293, 1], "end": [295, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.succ_log_def", "code": "theorem succ_log_def {b x : Ordinal} (hb : 1 < b) (hx : x \u2260 0) :\n    succ (log b x) = sInf { o | x < (b^o) }", "start": [298, 1], "end": [307, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_opow_succ_log_self", "code": "theorem lt_opow_succ_log_self {b : Ordinal} (hb : 1 < b) (x : Ordinal) :\n    x < (b^succ (log b x))", "start": [310, 1], "end": [315, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_log_le_self", "code": "theorem opow_log_le_self (b) {x : Ordinal} (hx : x \u2260 0) : (b^log b x) \u2264 x", "start": [318, 1], "end": [326, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_le_iff_le_log", "code": "theorem opow_le_iff_le_log {b x c : Ordinal} (hb : 1 < b) (hx : x \u2260 0) : (b^c) \u2264 x \u2194 c \u2264 log b x", "start": [329, 1], "end": [335, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_opow_iff_log_lt", "code": "theorem lt_opow_iff_log_lt {b x c : Ordinal} (hb : 1 < b) (hx : x \u2260 0) : x < (b^c) \u2194 log b x < c", "start": [338, 1], "end": [339, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_pos", "code": "theorem log_pos {b o : Ordinal} (hb : 1 < b) (ho : o \u2260 0) (hbo : b \u2264 o) : 0 < log b o", "start": [342, 1], "end": [343, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_eq_zero", "code": "theorem log_eq_zero {b o : Ordinal} (hbo : o < b) : log b o = 0", "start": [346, 1], "end": [353, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_mono_right", "code": "@[mono]\ntheorem log_mono_right (b) {x y : Ordinal} (xy : x \u2264 y) : log b x \u2264 log b y", "start": [356, 1], "end": [363, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_le_self", "code": "theorem log_le_self (b x : Ordinal) : log b x \u2264 x", "start": [366, 1], "end": [370, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_one_right", "code": "@[simp]\ntheorem log_one_right (b : Ordinal) : log b 1 = 0", "start": [373, 1], "end": [375, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mod_opow_log_lt_self", "code": "theorem mod_opow_log_lt_self (b : Ordinal) {o : Ordinal} (ho : o \u2260 0) : o % (b^log b o) < o", "start": [378, 1], "end": [381, 75], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_mod_opow_log_lt_log_self", "code": "theorem log_mod_opow_log_lt_log_self {b o : Ordinal} (hb : 1 < b) (ho : o \u2260 0) (hbo : b \u2264 o) :\n    log b (o % (b^log b o)) < log b o", "start": [384, 1], "end": [393, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_mul_add_pos", "code": "theorem opow_mul_add_pos {b v : Ordinal} (hb : b \u2260 0) (u) (hv : v \u2260 0) (w) : 0 < (b^u) * v + w", "start": [396, 1], "end": [398, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_mul_add_lt_opow_mul_succ", "code": "theorem opow_mul_add_lt_opow_mul_succ {b u w : Ordinal} (v : Ordinal) (hw : w < (b^u)) :\n    (b^u) * v + w < (b^u) * succ v", "start": [401, 1], "end": [402, 77], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_mul_add_lt_opow_succ", "code": "theorem opow_mul_add_lt_opow_succ {b u v w : Ordinal} (hvb : v < b) (hw : w < (b^u)) :\n    (b^u) * v + w < (b^succ u)", "start": [405, 1], "end": [409, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_opow_mul_add", "code": "theorem log_opow_mul_add {b u v w : Ordinal} (hb : 1 < b) (hv : v \u2260 0) (hvb : v < b)\n    (hw : w < (b^u)) : log b ((b^u) * v + w) = u", "start": [412, 1], "end": [421, 62], "kind": "commanddeclaration"}, {"full_name": "Ordinal.log_opow", "code": "theorem log_opow {b : Ordinal} (hb : 1 < b) (x : Ordinal) : log b (b^x) = x", "start": [424, 1], "end": [427, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_opow_log_pos", "code": "theorem div_opow_log_pos (b : Ordinal) {o : Ordinal} (ho : o \u2260 0) : 0 < o / (b^log b o)", "start": [430, 1], "end": [434, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.div_opow_log_lt", "code": "theorem div_opow_log_lt {b : Ordinal} (o : Ordinal) (hb : 1 < b) : o / (b^log b o) < b", "start": [437, 1], "end": [439, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_log_le_log_mul", "code": "theorem add_log_le_log_mul {x y : Ordinal} (b : Ordinal) (hx : x \u2260 0) (hy : y \u2260 0) :\n    log b x + log b y \u2264 log b (x * y)", "start": [442, 1], "end": [448, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nat_cast_opow", "code": "@[simp, norm_cast]\ntheorem nat_cast_opow (m : \u2115) : \u2200 n : \u2115, ((m ^ n : \u2115) : Ordinal) = (m^n)", "start": [453, 1], "end": [457, 95], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_opow_nat", "code": "theorem sup_opow_nat {o : Ordinal} (ho : 0 < o) : (sup fun n : \u2115 => o^n) = (o^\u03c9)", "start": [460, 1], "end": [466, 34], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "imports": ["Mathlib/Topology/UniformSpace/UniformConvergenceTopology.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "EquicontinuousAt", "code": "def EquicontinuousAt (F : \u03b9 \u2192 X \u2192 \u03b1) (x\u2080 : X) : Prop :=\n  \u2200 U \u2208 \ud835\udce4 \u03b1, \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 i, (F i x\u2080, F i x) \u2208 U", "start": [91, 1], "end": [95, 52], "kind": "commanddeclaration"}, {"full_name": "Set.EquicontinuousAt", "code": "protected abbrev Set.EquicontinuousAt (H : Set <| X \u2192 \u03b1) (x\u2080 : X) : Prop :=\n  EquicontinuousAt ((\u2191) : H \u2192 X \u2192 \u03b1) x\u2080", "start": [98, 1], "end": [101, 40], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous", "code": "def Equicontinuous (F : \u03b9 \u2192 X \u2192 \u03b1) : Prop :=\n  \u2200 x\u2080, EquicontinuousAt F x\u2080", "start": [104, 1], "end": [107, 30], "kind": "commanddeclaration"}, {"full_name": "Set.Equicontinuous", "code": "protected abbrev Set.Equicontinuous (H : Set <| X \u2192 \u03b1) : Prop :=\n  Equicontinuous ((\u2191) : H \u2192 X \u2192 \u03b1)", "start": [110, 1], "end": [113, 35], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous", "code": "def UniformEquicontinuous (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1) : Prop :=\n  \u2200 U \u2208 \ud835\udce4 \u03b1, \u2200\u1da0 xy : \u03b2 \u00d7 \u03b2 in \ud835\udce4 \u03b2, \u2200 i, (F i xy.1, F i xy.2) \u2208 U", "start": [116, 1], "end": [120, 65], "kind": "commanddeclaration"}, {"full_name": "Set.UniformEquicontinuous", "code": "protected abbrev Set.UniformEquicontinuous (H : Set <| \u03b2 \u2192 \u03b1) : Prop :=\n  UniformEquicontinuous ((\u2191) : H \u2192 \u03b2 \u2192 \u03b1)", "start": [123, 1], "end": [126, 42], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_empty", "code": "@[simp]\nlemma equicontinuousAt_empty [h : IsEmpty \u03b9] (F : \u03b9 \u2192 X \u2192 \u03b1) (x\u2080 : X) :\n    EquicontinuousAt F x\u2080 :=\n  fun _ _ \u21a6 eventually_of_forall (fun _ \u21a6 h.elim)", "start": [133, 1], "end": [136, 50], "kind": "mathlibtacticlemma"}, {"full_name": "equicontinuous_empty", "code": "@[simp]\nlemma equicontinuous_empty [IsEmpty \u03b9] (F : \u03b9 \u2192 X \u2192 \u03b1) :\n    Equicontinuous F :=\n  equicontinuousAt_empty F", "start": [138, 1], "end": [141, 27], "kind": "mathlibtacticlemma"}, {"full_name": "uniformEquicontinuous_empty", "code": "@[simp]\nlemma uniformEquicontinuous_empty [h : IsEmpty \u03b9] (F : \u03b9 \u2192 \u03b2 \u2192 \u03b1) :\n    UniformEquicontinuous F :=\n  fun _ _ \u21a6 eventually_of_forall (fun _ \u21a6 h.elim)", "start": [143, 1], "end": [146, 50], "kind": "mathlibtacticlemma"}, {"full_name": "equicontinuousAt_finite", "code": "theorem equicontinuousAt_finite [Finite \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 i, ContinuousAt (F i) x\u2080", "start": [152, 1], "end": [155, 41], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_finite", "code": "theorem equicontinuous_finite [Finite \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} :\n    Equicontinuous F \u2194 \u2200 i, Continuous (F i)", "start": [157, 1], "end": [159, 99], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_finite", "code": "theorem uniformEquicontinuous_finite [Finite \u03b9] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194 \u2200 i, UniformContinuous (F i)", "start": [161, 1], "end": [163, 75], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_unique", "code": "theorem equicontinuousAt_unique [Unique \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} {x : X} :\n    EquicontinuousAt F x \u2194 ContinuousAt (F default) x", "start": [169, 1], "end": [171, 50], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_unique", "code": "theorem equicontinuous_unique [Unique \u03b9] {F : \u03b9 \u2192 X \u2192 \u03b1} :\n    Equicontinuous F \u2194 Continuous (F default)", "start": [173, 1], "end": [175, 48], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_unique", "code": "theorem uniformEquicontinuous_unique [Unique \u03b9] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194 UniformContinuous (F default)", "start": [177, 1], "end": [179, 55], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_iff_pair", "code": "theorem equicontinuousAt_iff_pair {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} :\n    EquicontinuousAt F x\u2080 \u2194\n      \u2200 U \u2208 \ud835\udce4 \u03b1, \u2203 V \u2208 \ud835\udcdd x\u2080, \u2200 x \u2208 V, \u2200 y \u2208 V, \u2200 i, (F i x, F i y) \u2208 U", "start": [181, 1], "end": [191, 79], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous.equicontinuous", "code": "theorem UniformEquicontinuous.equicontinuous {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h : UniformEquicontinuous F) :\n    Equicontinuous F", "start": [194, 1], "end": [197, 65], "kind": "commanddeclaration"}, {"full_name": "EquicontinuousAt.continuousAt", "code": "theorem EquicontinuousAt.continuousAt {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} (h : EquicontinuousAt F x\u2080) (i : \u03b9) :\n    ContinuousAt (F i) x\u2080", "start": [200, 1], "end": [203, 100], "kind": "commanddeclaration"}, {"full_name": "Set.EquicontinuousAt.continuousAt_of_mem", "code": "protected theorem Set.EquicontinuousAt.continuousAt_of_mem {H : Set <| X \u2192 \u03b1} {x\u2080 : X}\n    (h : H.EquicontinuousAt x\u2080) {f : X \u2192 \u03b1} (hf : f \u2208 H) : ContinuousAt f x\u2080", "start": [206, 1], "end": [208, 25], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous.continuous", "code": "theorem Equicontinuous.continuous {F : \u03b9 \u2192 X \u2192 \u03b1} (h : Equicontinuous F) (i : \u03b9) :\n    Continuous (F i)", "start": [211, 1], "end": [214, 64], "kind": "commanddeclaration"}, {"full_name": "Set.Equicontinuous.continuous_of_mem", "code": "protected theorem Set.Equicontinuous.continuous_of_mem {H : Set <| X \u2192 \u03b1} (h : H.Equicontinuous)\n    {f : X \u2192 \u03b1} (hf : f \u2208 H) : Continuous f", "start": [217, 1], "end": [219, 23], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous.uniformContinuous", "code": "theorem UniformEquicontinuous.uniformContinuous {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h : UniformEquicontinuous F)\n    (i : \u03b9) : UniformContinuous (F i)", "start": [222, 1], "end": [225, 60], "kind": "commanddeclaration"}, {"full_name": "Set.UniformEquicontinuous.uniformContinuous_of_mem", "code": "protected theorem Set.UniformEquicontinuous.uniformContinuous_of_mem {H : Set <| \u03b2 \u2192 \u03b1}\n    (h : H.UniformEquicontinuous) {f : \u03b2 \u2192 \u03b1} (hf : f \u2208 H) : UniformContinuous f", "start": [228, 1], "end": [230, 30], "kind": "commanddeclaration"}, {"full_name": "EquicontinuousAt.comp", "code": "theorem EquicontinuousAt.comp {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} (h : EquicontinuousAt F x\u2080) (u : \u03ba \u2192 \u03b9) :\n    EquicontinuousAt (F \u2218 u) x\u2080", "start": [233, 1], "end": [235, 82], "kind": "commanddeclaration"}, {"full_name": "Set.EquicontinuousAt.mono", "code": "protected theorem Set.EquicontinuousAt.mono {H H' : Set <| X \u2192 \u03b1} {x\u2080 : X}\n    (h : H.EquicontinuousAt x\u2080) (hH : H' \u2286 H) : H'.EquicontinuousAt x\u2080", "start": [238, 1], "end": [240, 24], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous.comp", "code": "theorem Equicontinuous.comp {F : \u03b9 \u2192 X \u2192 \u03b1} (h : Equicontinuous F) (u : \u03ba \u2192 \u03b9) :\n    Equicontinuous (F \u2218 u)", "start": [243, 1], "end": [245, 52], "kind": "commanddeclaration"}, {"full_name": "Set.Equicontinuous.mono", "code": "protected theorem Set.Equicontinuous.mono {H H' : Set <| X \u2192 \u03b1} (h : H.Equicontinuous)\n    (hH : H' \u2286 H) : H'.Equicontinuous", "start": [248, 1], "end": [250, 24], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous.comp", "code": "theorem UniformEquicontinuous.comp {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h : UniformEquicontinuous F) (u : \u03ba \u2192 \u03b9) :\n    UniformEquicontinuous (F \u2218 u)", "start": [253, 1], "end": [255, 84], "kind": "commanddeclaration"}, {"full_name": "Set.UniformEquicontinuous.mono", "code": "protected theorem Set.UniformEquicontinuous.mono {H H' : Set <| \u03b2 \u2192 \u03b1} (h : H.UniformEquicontinuous)\n    (hH : H' \u2286 H) : H'.UniformEquicontinuous", "start": [258, 1], "end": [260, 24], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_iff_range", "code": "theorem equicontinuousAt_iff_range {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} :\n    EquicontinuousAt F x\u2080 \u2194 EquicontinuousAt ((\u2191) : range F \u2192 X \u2192 \u03b1) x\u2080", "start": [263, 1], "end": [267, 57], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_iff_range", "code": "theorem equicontinuous_iff_range {F : \u03b9 \u2192 X \u2192 \u03b1} :\n    Equicontinuous F \u2194 Equicontinuous ((\u2191) : range F \u2192 X \u2192 \u03b1)", "start": [270, 1], "end": [274, 52], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_at_iff_range", "code": "theorem uniformEquicontinuous_at_iff_range {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194 UniformEquicontinuous ((\u2191) : range F \u2192 \u03b2 \u2192 \u03b1)", "start": [277, 1], "end": [282, 35], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_iff_continuousAt", "code": "theorem equicontinuousAt_iff_continuousAt {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} :\n    EquicontinuousAt F x\u2080 \u2194 ContinuousAt (ofFun \u2218 Function.swap F : X \u2192 \u03b9 \u2192\u1d64 \u03b1) x\u2080", "start": [289, 1], "end": [296, 6], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_iff_continuous", "code": "theorem equicontinuous_iff_continuous {F : \u03b9 \u2192 X \u2192 \u03b1} :\n    Equicontinuous F \u2194 Continuous (ofFun \u2218 Function.swap F : X \u2192 \u03b9 \u2192\u1d64 \u03b1)", "start": [299, 1], "end": [305, 91], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_iff_uniformContinuous", "code": "theorem uniformEquicontinuous_iff_uniformContinuous {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} :\n    UniformEquicontinuous F \u2194 UniformContinuous (ofFun \u2218 Function.swap F : \u03b2 \u2192 \u03b9 \u2192\u1d64 \u03b1)", "start": [308, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_iInf_rng", "code": "theorem equicontinuousAt_iInf_rng {\u03b1' : Type*} {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'}\n    {x\u2080 : X} :\n    @EquicontinuousAt _ _ _ _ (\u2a05 k, u k) F x\u2080 \u2194 \u2200 k, @EquicontinuousAt _ _ _ _ (u k) F x\u2080", "start": [318, 1], "end": [323, 76], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_iInf_rng", "code": "theorem equicontinuous_iInf_rng {\u03b1' : Type*} {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 X \u2192 \u03b1'} :\n    @Equicontinuous _ _ _ _ (\u2a05 k, u k) F \u2194 \u2200 k, @Equicontinuous _ _ _ _ (u k) F", "start": [325, 1], "end": [328, 72], "kind": "commanddeclaration"}, {"full_name": "uniformEquicontinuous_iInf_rng", "code": "theorem uniformEquicontinuous_iInf_rng {\u03b1' : Type*} {u : \u03ba \u2192 UniformSpace \u03b1'} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1'} :\n    @UniformEquicontinuous _ _ _ (\u2a05 k, u k) _ F \u2194 \u2200 k, @UniformEquicontinuous _ _ _ (u k) _ F", "start": [330, 1], "end": [333, 54], "kind": "commanddeclaration"}, {"full_name": "equicontinuousAt_iInf_dom", "code": "theorem equicontinuousAt_iInf_dom {X' : Type*} {t : \u03ba \u2192 TopologicalSpace X'} {F : \u03b9 \u2192 X' \u2192 \u03b1}\n    {x\u2080 : X'} {k : \u03ba} (hk : @EquicontinuousAt _ _ _ (t k) _ F x\u2080) :\n    @EquicontinuousAt _ _ _ (\u2a05 k, t k) _ F x\u2080", "start": [335, 1], "end": [341, 27], "kind": "commanddeclaration"}, {"full_name": "equicontinuous_iInf_dom", "code": "theorem equicontinuous_iInf_dom {X' : Type*} {t : \u03ba \u2192 TopologicalSpace X'} {F : \u03b9 \u2192 X' \u2192 \u03b1}\n    {k : \u03ba} (hk : @Equicontinuous _ _ _ (t k) _ F) :\n    @Equicontinuous _ _ _ (\u2a05 k, t k) _ F", "start": [343, 1], "end": [347, 31], "kind": "commanddeclaration"}, {"full_name": "uniform_equicontinuous_infi_dom", "code": "theorem uniform_equicontinuous_infi_dom {\u03b2' : Type*} {u : \u03ba \u2192 UniformSpace \u03b2'} {F : \u03b9 \u2192 \u03b2' \u2192 \u03b1}\n    {k : \u03ba} (hk : @UniformEquicontinuous _ _ _ _ (u k) F) :\n    @UniformEquicontinuous _ _ _ _ (\u2a05 k, u k) F", "start": [349, 1], "end": [353, 38], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.equicontinuousAt_iff_left", "code": "theorem Filter.HasBasis.equicontinuousAt_iff_left {\u03ba : Type*} {p : \u03ba \u2192 Prop} {s : \u03ba \u2192 Set X}\n    {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} (hX : (\ud835\udcdd x\u2080).HasBasis p s) :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 U \u2208 \ud835\udce4 \u03b1, \u2203 k, p k \u2227 \u2200 x \u2208 s k, \u2200 i, (F i x\u2080, F i x) \u2208 U", "start": [357, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.equicontinuousAt_iff_right", "code": "theorem Filter.HasBasis.equicontinuousAt_iff_right {\u03ba : Type*} {p : \u03ba \u2192 Prop} {s : \u03ba \u2192 Set (\u03b1 \u00d7 \u03b1)}\n    {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} (h\u03b1 : (\ud835\udce4 \u03b1).HasBasis p s) :\n    EquicontinuousAt F x\u2080 \u2194 \u2200 k, p k \u2192 \u2200\u1da0 x in \ud835\udcdd x\u2080, \u2200 i, (F i x\u2080, F i x) \u2208 s k", "start": [366, 1], "end": [371, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.equicontinuousAt_iff", "code": "theorem Filter.HasBasis.equicontinuousAt_iff {\u03ba\u2081 \u03ba\u2082 : Type*} {p\u2081 : \u03ba\u2081 \u2192 Prop} {s\u2081 : \u03ba\u2081 \u2192 Set X}\n    {p\u2082 : \u03ba\u2082 \u2192 Prop} {s\u2082 : \u03ba\u2082 \u2192 Set (\u03b1 \u00d7 \u03b1)} {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} (hX : (\ud835\udcdd x\u2080).HasBasis p\u2081 s\u2081)\n    (h\u03b1 : (\ud835\udce4 \u03b1).HasBasis p\u2082 s\u2082) :\n    EquicontinuousAt F x\u2080 \u2194\n      \u2200 k\u2082, p\u2082 k\u2082 \u2192 \u2203 k\u2081, p\u2081 k\u2081 \u2227 \u2200 x \u2208 s\u2081 k\u2081, \u2200 i, (F i x\u2080, F i x) \u2208 s\u2082 k\u2082", "start": [376, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformEquicontinuous_iff_left", "code": "theorem Filter.HasBasis.uniformEquicontinuous_iff_left {\u03ba : Type*} {p : \u03ba \u2192 Prop}\n    {s : \u03ba \u2192 Set (\u03b2 \u00d7 \u03b2)} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h\u03b2 : (\ud835\udce4 \u03b2).HasBasis p s) :\n    UniformEquicontinuous F \u2194\n      \u2200 U \u2208 \ud835\udce4 \u03b1, \u2203 k, p k \u2227 \u2200 x y, (x, y) \u2208 s k \u2192 \u2200 i, (F i x, F i y) \u2208 U", "start": [389, 1], "end": [396, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformEquicontinuous_iff_right", "code": "theorem Filter.HasBasis.uniformEquicontinuous_iff_right {\u03ba : Type*} {p : \u03ba \u2192 Prop}\n    {s : \u03ba \u2192 Set (\u03b1 \u00d7 \u03b1)} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} (h\u03b1 : (\ud835\udce4 \u03b1).HasBasis p s) :\n    UniformEquicontinuous F \u2194 \u2200 k, p k \u2192 \u2200\u1da0 xy : \u03b2 \u00d7 \u03b2 in \ud835\udce4 \u03b2, \u2200 i, (F i xy.1, F i xy.2) \u2208 s k", "start": [399, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformEquicontinuous_iff", "code": "theorem Filter.HasBasis.uniformEquicontinuous_iff {\u03ba\u2081 \u03ba\u2082 : Type*} {p\u2081 : \u03ba\u2081 \u2192 Prop}\n    {s\u2081 : \u03ba\u2081 \u2192 Set (\u03b2 \u00d7 \u03b2)} {p\u2082 : \u03ba\u2082 \u2192 Prop} {s\u2082 : \u03ba\u2082 \u2192 Set (\u03b1 \u00d7 \u03b1)} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1}\n    (h\u03b2 : (\ud835\udce4 \u03b2).HasBasis p\u2081 s\u2081) (h\u03b1 : (\ud835\udce4 \u03b1).HasBasis p\u2082 s\u2082) :\n    UniformEquicontinuous F \u2194\n      \u2200 k\u2082, p\u2082 k\u2082 \u2192 \u2203 k\u2081, p\u2081 k\u2081 \u2227 \u2200 x y, (x, y) \u2208 s\u2081 k\u2081 \u2192 \u2200 i, (F i x, F i y) \u2208 s\u2082 k\u2082", "start": [409, 1], "end": [417, 6], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.equicontinuousAt_iff", "code": "theorem UniformInducing.equicontinuousAt_iff {F : \u03b9 \u2192 X \u2192 \u03b1} {x\u2080 : X} {u : \u03b1 \u2192 \u03b2}\n    (hu : UniformInducing u) : EquicontinuousAt F x\u2080 \u2194 EquicontinuousAt ((\u00b7 \u2218 \u00b7) u \u2218 F) x\u2080", "start": [420, 1], "end": [427, 6], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.equicontinuous_iff", "code": "theorem UniformInducing.equicontinuous_iff {F : \u03b9 \u2192 X \u2192 \u03b1} {u : \u03b1 \u2192 \u03b2} (hu : UniformInducing u) :\n    Equicontinuous F \u2194 Equicontinuous ((\u00b7 \u2218 \u00b7) u \u2218 F)", "start": [430, 1], "end": [435, 31], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.uniformEquicontinuous_iff", "code": "theorem UniformInducing.uniformEquicontinuous_iff {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {u : \u03b1 \u2192 \u03b3}\n    (hu : UniformInducing u) : UniformEquicontinuous F \u2194 UniformEquicontinuous ((\u00b7 \u2218 \u00b7) u \u2218 F)", "start": [438, 1], "end": [446, 6], "kind": "commanddeclaration"}, {"full_name": "EquicontinuousAt.closure'", "code": "theorem EquicontinuousAt.closure' {A : Set Y} {u : Y \u2192 X \u2192 \u03b1} {x\u2080 : X}\n    (hA : EquicontinuousAt (u \u2218 (\u2191) : A \u2192 X \u2192 \u03b1) x\u2080) (hu : Continuous u) :\n    EquicontinuousAt (u \u2218 (\u2191) : closure A \u2192 X \u2192 \u03b1) x\u2080", "start": [449, 1], "end": [462, 90], "kind": "commanddeclaration"}, {"full_name": "EquicontinuousAt.closure", "code": "protected theorem EquicontinuousAt.closure {A : Set (X \u2192 \u03b1)} {x\u2080 : X} (hA : A.EquicontinuousAt x\u2080) :\n    (closure A).EquicontinuousAt x\u2080", "start": [465, 1], "end": [469, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.continuousAt_of_equicontinuousAt", "code": "theorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter \u03b9} [l.NeBot] {F : \u03b9 \u2192 X \u2192 \u03b1}\n    {f : X \u2192 \u03b1} {x\u2080 : X} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : EquicontinuousAt F x\u2080) :\n    ContinuousAt f x\u2080", "start": [472, 1], "end": [478, 74], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous.closure'", "code": "theorem Equicontinuous.closure' {A : Set Y} {u : Y \u2192 X \u2192 \u03b1}\n    (hA : Equicontinuous (u \u2218 (\u2191) : A \u2192 X \u2192 \u03b1)) (hu : Continuous u) :\n    Equicontinuous (u \u2218 (\u2191) : closure A \u2192 X \u2192 \u03b1)", "start": [481, 1], "end": [487, 80], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous.closure", "code": "theorem Equicontinuous.closure {A : Set <| X \u2192 \u03b1} (hA : A.Equicontinuous) :\n    (closure A).Equicontinuous", "start": [490, 1], "end": [493, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.continuous_of_equicontinuousAt", "code": "theorem Filter.Tendsto.continuous_of_equicontinuousAt {l : Filter \u03b9} [l.NeBot] {F : \u03b9 \u2192 X \u2192 \u03b1}\n    {f : X \u2192 \u03b1} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : Equicontinuous F) : Continuous f", "start": [496, 1], "end": [500, 86], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous.closure'", "code": "theorem UniformEquicontinuous.closure' {A : Set Y} {u : Y \u2192 \u03b2 \u2192 \u03b1}\n    (hA : UniformEquicontinuous (u \u2218 (\u2191) : A \u2192 \u03b2 \u2192 \u03b1)) (hu : Continuous u) :\n    UniformEquicontinuous (u \u2218 (\u2191) : closure A \u2192 \u03b2 \u2192 \u03b1)", "start": [503, 1], "end": [517, 89], "kind": "commanddeclaration"}, {"full_name": "UniformEquicontinuous.closure", "code": "theorem UniformEquicontinuous.closure {A : Set <| \u03b2 \u2192 \u03b1} (hA : A.UniformEquicontinuous) :\n    (closure A).UniformEquicontinuous", "start": [520, 1], "end": [524, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous", "code": "theorem Filter.Tendsto.uniformContinuous_of_uniformEquicontinuous {l : Filter \u03b9} [l.NeBot]\n    {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : UniformEquicontinuous F) :\n    UniformContinuous f", "start": [527, 1], "end": [533, 74], "kind": "commanddeclaration"}, {"full_name": "EquicontinuousAt.tendsto_of_mem_closure", "code": "theorem EquicontinuousAt.tendsto_of_mem_closure {l : Filter \u03b9} {F : \u03b9 \u2192 X \u2192 \u03b1} {f : X \u2192 \u03b1}\n    {s : Set X} {x : X} {z : \u03b1} (hF : EquicontinuousAt F x) (hf : Tendsto f (\ud835\udcdd[s] x) (\ud835\udcdd z))\n    (hs : \u2200 y \u2208 s, Tendsto (F \u00b7 y) l (\ud835\udcdd (f y))) (hx : x \u2208 closure s) :\n    Tendsto (F \u00b7 x) l (\ud835\udcdd z)", "start": [536, 1], "end": [554, 63], "kind": "commanddeclaration"}, {"full_name": "Equicontinuous.isClosed_setOf_tendsto", "code": "theorem Equicontinuous.isClosed_setOf_tendsto {l : Filter \u03b9} {F : \u03b9 \u2192 X \u2192 \u03b1} {f : X \u2192 \u03b1}\n    (hF : Equicontinuous F) (hf : Continuous f) :\n    IsClosed {x | Tendsto (F \u00b7 x) l (\ud835\udcdd (f x))}", "start": [556, 1], "end": [563, 90], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/Compact.lean", "imports": ["Mathlib/Topology/Algebra/Order/IntermediateValue.lean", "Mathlib/Topology/LocalExtr.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CompactIccSpace", "code": "class CompactIccSpace (\u03b1 : Type*) [TopologicalSpace \u03b1] [Preorder \u03b1] : Prop where\n  \n  isCompact_Icc : \u2200 {a b : \u03b1}, IsCompact (Icc a b)", "start": [48, 1], "end": [53, 51], "kind": "commanddeclaration"}, {"full_name": "CompactIccSpace.mk'", "code": "lemma CompactIccSpace.mk' [TopologicalSpace \u03b1] [Preorder \u03b1]\n    (h : \u2200 {a b : \u03b1}, a \u2264 b \u2192 IsCompact (Icc a b)) : CompactIccSpace \u03b1 where\n  isCompact_Icc {a b} := by_cases h $ fun hab => by rw [Icc_eq_empty hab]; exact isCompact_empty", "start": [59, 1], "end": [61, 97], "kind": "mathlibtacticlemma"}, {"full_name": "CompactIccSpace.mk''", "code": "lemma CompactIccSpace.mk'' [TopologicalSpace \u03b1] [PartialOrder \u03b1]\n    (h : \u2200 {a b : \u03b1}, a < b \u2192 IsCompact (Icc a b)) : CompactIccSpace \u03b1 :=\n  .mk' fun hab => hab.eq_or_lt.elim (by rintro rfl; simp) h", "start": [64, 1], "end": [66, 60], "kind": "mathlibtacticlemma"}, {"full_name": "ConditionallyCompleteLinearOrder.toCompactIccSpace", "code": "instance (priority := 100) ConditionallyCompleteLinearOrder.toCompactIccSpace (\u03b1 : Type*)\n    [ConditionallyCompleteLinearOrder \u03b1] [TopologicalSpace \u03b1] [OrderTopology \u03b1] :\n    CompactIccSpace \u03b1 := by\n  refine' .mk'' fun {a b} hlt => ?_\n  cases' le_or_lt a b with hab hab\n  swap\n  \u00b7 simp [hab]\n  refine' isCompact_iff_ultrafilter_le_nhds.2 fun f hf => _\n  contrapose! hf\n  rw [le_principal_iff]\n  have hpt : \u2200 x \u2208 Icc a b, {x} \u2209 f := fun x hx hxf =>\n    hf x hx ((le_pure_iff.2 hxf).trans (pure_le_nhds x))\n  set s := { x \u2208 Icc a b | Icc a x \u2209 f }\n  have hsb : b \u2208 upperBounds s := fun x hx => hx.1.2\n  have sbd : BddAbove s := \u27e8b, hsb\u27e9\n  have ha : a \u2208 s := by simp [hpt, hab]\n  rcases hab.eq_or_lt with (rfl | _hlt)\n  \u00b7 exact ha.2\n  obtain \u27e8c, hsc\u27e9 : \u2203 c, IsLUB s c := \u27e8sSup s, isLUB_csSup \u27e8a, ha\u27e9 \u27e8b, hsb\u27e9\u27e9\n  have hc : c \u2208 Icc a b := \u27e8hsc.1 ha, hsc.2 hsb\u27e9\n  specialize hf c hc\n  have hcs : c \u2208 s := by\n    rcases hc.1.eq_or_lt with (rfl | hlt); \u00b7 assumption\n    refine' \u27e8hc, fun hcf => hf fun U hU => _\u27e9\n    rcases (mem_nhdsWithin_Iic_iff_exists_Ioc_subset' hlt).1 (mem_nhdsWithin_of_mem_nhds hU)\n      with \u27e8x, hxc, hxU\u27e9\n    rcases ((hsc.frequently_mem \u27e8a, ha\u27e9).and_eventually\n      (Ioc_mem_nhdsWithin_Iic \u27e8hxc, le_rfl\u27e9)).exists with \u27e8y, \u27e8_hyab, hyf\u27e9, hy\u27e9\n    refine' mem_of_superset (f.diff_mem_iff.2 \u27e8hcf, hyf\u27e9) (Subset.trans _ hxU)\n    rw [diff_subset_iff]\n    exact Subset.trans Icc_subset_Icc_union_Ioc <| union_subset_union Subset.rfl <|\n      Ioc_subset_Ioc_left hy.1.le\n  rcases hc.2.eq_or_lt with (rfl | hlt); \u00b7 exact hcs.2\n  contrapose! hf\n  intro U hU\n  rcases (mem_nhdsWithin_Ici_iff_exists_mem_Ioc_Ico_subset hlt).1\n      (mem_nhdsWithin_of_mem_nhds hU) with\n    \u27e8y, hxy, hyU\u27e9\n  refine' mem_of_superset _ hyU; clear! U\n  have hy : y \u2208 Icc a b := \u27e8hc.1.trans hxy.1.le, hxy.2\u27e9\n  by_cases hay : Icc a y \u2208 f\n  \u00b7 refine' mem_of_superset (f.diff_mem_iff.2 \u27e8f.diff_mem_iff.2 \u27e8hay, hcs.2\u27e9, hpt y hy\u27e9) _\n    rw [diff_subset_iff, union_comm, Ico_union_right hxy.1.le, diff_subset_iff]\n    exact Icc_subset_Icc_union_Icc\n  \u00b7 exact ((hsc.1 \u27e8hy, hay\u27e9).not_lt hxy.1).elim", "start": [68, 1], "end": [116, 48], "kind": "commanddeclaration"}, {"full_name": "Pi.compact_Icc_space'", "code": "instance Pi.compact_Icc_space' {\u03b1 \u03b2 : Type*} [Preorder \u03b2] [TopologicalSpace \u03b2]\n    [CompactIccSpace \u03b2] : CompactIccSpace (\u03b1 \u2192 \u03b2) :=\n  inferInstance", "start": [123, 1], "end": [125, 16], "kind": "commanddeclaration"}, {"full_name": "isCompact_uIcc", "code": "theorem isCompact_uIcc {\u03b1 : Type*} [LinearOrder \u03b1] [TopologicalSpace \u03b1] [CompactIccSpace \u03b1]\n    {a b : \u03b1} : IsCompact (uIcc a b)", "start": [132, 1], "end": [135, 16], "kind": "commanddeclaration"}, {"full_name": "compactSpace_of_completeLinearOrder", "code": "instance (priority := 100) compactSpace_of_completeLinearOrder {\u03b1 : Type*} [CompleteLinearOrder \u03b1]\n    [TopologicalSpace \u03b1] [OrderTopology \u03b1] : CompactSpace \u03b1 :=\n  \u27e8by simp only [\u2190 Icc_bot_top, isCompact_Icc]\u27e9", "start": [139, 1], "end": [146, 48], "kind": "commanddeclaration"}, {"full_name": "compactSpace_Icc", "code": "instance compactSpace_Icc (a b : \u03b1) : CompactSpace (Icc a b) :=\n  isCompact_iff_compactSpace.mp isCompact_Icc", "start": [153, 1], "end": [154, 46], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isLeast", "code": "theorem IsCompact.exists_isLeast [ClosedIicTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : \u2203 x, IsLeast s x", "start": [168, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isGreatest", "code": "theorem IsCompact.exists_isGreatest [ClosedIciTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : \u2203 x, IsGreatest s x", "start": [181, 1], "end": [183, 46], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isGLB", "code": "theorem IsCompact.exists_isGLB [ClosedIicTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : \u2203 x \u2208 s, IsGLB s x", "start": [186, 1], "end": [188, 78], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isLUB", "code": "theorem IsCompact.exists_isLUB [ClosedIciTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : \u2203 x \u2208 s, IsLUB s x", "start": [191, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isMinOn", "code": "theorem IsCompact.exists_isMinOn [ClosedIicTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) : \u2203 x \u2208 s, IsMinOn f s x", "start": [197, 1], "end": [201, 38], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_forall_le", "code": "@[deprecated IsCompact.exists_isMinOn]\ntheorem IsCompact.exists_forall_le [ClosedIicTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) : \u2203 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y", "start": [203, 1], "end": [207, 28], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isMaxOn", "code": "theorem IsCompact.exists_isMaxOn [ClosedIciTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) : \u2203 x \u2208 s, IsMaxOn f s x", "start": [211, 1], "end": [214, 49], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_forall_ge", "code": "@[deprecated IsCompact.exists_isMaxOn]\ntheorem IsCompact.exists_forall_ge [ClosedIciTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) : \u2203 x \u2208 s, \u2200 y \u2208 s, f y \u2264 f x", "start": [216, 1], "end": [220, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.exists_isMinOn'", "code": "theorem ContinuousOn.exists_isMinOn' [ClosedIicTopology \u03b1] {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x\u2080 : \u03b2} (h\u2080 : x\u2080 \u2208 s)\n    (hc : \u2200\u1da0 x in cocompact \u03b2 \u2293 \ud835\udcdf s, f x\u2080 \u2264 f x) : \u2203 x \u2208 s, IsMinOn f s x", "start": [223, 1], "end": [234, 80], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.exists_forall_le'", "code": "@[deprecated ContinuousOn.exists_isMinOn']\ntheorem ContinuousOn.exists_forall_le' [ClosedIicTopology \u03b1] {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x\u2080 : \u03b2} (h\u2080 : x\u2080 \u2208 s)\n    (hc : \u2200\u1da0 x in cocompact \u03b2 \u2293 \ud835\udcdf s, f x\u2080 \u2264 f x) : \u2203 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y", "start": [236, 1], "end": [242, 31], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.exists_isMaxOn'", "code": "theorem ContinuousOn.exists_isMaxOn' [ClosedIciTopology \u03b1] {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x\u2080 : \u03b2} (h\u2080 : x\u2080 \u2208 s)\n    (hc : \u2200\u1da0 x in cocompact \u03b2 \u2293 \ud835\udcdf s, f x \u2264 f x\u2080) : \u2203 x \u2208 s, IsMaxOn f s x", "start": [245, 1], "end": [250, 55], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.exists_forall_ge'", "code": "@[deprecated ContinuousOn.exists_isMaxOn']\ntheorem ContinuousOn.exists_forall_ge' [ClosedIciTopology \u03b1] {s : Set \u03b2} {f : \u03b2 \u2192 \u03b1}\n    (hf : ContinuousOn f s) (hsc : IsClosed s) {x\u2080 : \u03b2} (h\u2080 : x\u2080 \u2208 s)\n    (hc : \u2200\u1da0 x in cocompact \u03b2 \u2293 \ud835\udcdf s, f x \u2264 f x\u2080) : \u2203 x \u2208 s, \u2200 y \u2208 s, f y \u2264 f x", "start": [252, 1], "end": [258, 31], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_le'", "code": "theorem Continuous.exists_forall_le' [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (x\u2080 : \u03b2) (h : \u2200\u1da0 x in cocompact \u03b2, f x\u2080 \u2264 f x) : \u2203 x : \u03b2, \u2200 y : \u03b2, f x \u2264 f y", "start": [261, 1], "end": [267, 34], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_ge'", "code": "theorem Continuous.exists_forall_ge' [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (x\u2080 : \u03b2) (h : \u2200\u1da0 x in cocompact \u03b2, f x \u2264 f x\u2080) : \u2203 x : \u03b2, \u2200 y : \u03b2, f y \u2264 f x", "start": [270, 1], "end": [274, 50], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_le", "code": "theorem Continuous.exists_forall_le [ClosedIicTopology \u03b1] [Nonempty \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Continuous f) (hlim : Tendsto f (cocompact \u03b2) atTop) : \u2203 x, \u2200 y, f x \u2264 f y", "start": [277, 1], "end": [282, 80], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_ge", "code": "theorem Continuous.exists_forall_ge [ClosedIciTopology \u03b1] [Nonempty \u03b2] {f : \u03b2 \u2192 \u03b1}\n    (hf : Continuous f) (hlim : Tendsto f (cocompact \u03b2) atBot) : \u2203 x, \u2200 y, f y \u2264 f x", "start": [285, 1], "end": [289, 49], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_le_of_hasCompactMulSupport", "code": "@[to_additive \"A continuous function with compact support has a global minimum.\"]\ntheorem Continuous.exists_forall_le_of_hasCompactMulSupport [ClosedIicTopology \u03b1] [Nonempty \u03b2]\n    [One \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    \u2203 x : \u03b2, \u2200 y : \u03b2, f x \u2264 f y", "start": [292, 1], "end": [299, 16], "kind": "commanddeclaration"}, {"full_name": "Continuous.exists_forall_ge_of_hasCompactMulSupport", "code": "@[to_additive \"A continuous function with compact support has a global maximum.\"]\ntheorem Continuous.exists_forall_ge_of_hasCompactMulSupport [ClosedIciTopology \u03b1] [Nonempty \u03b2]\n    [One \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Continuous f) (h : HasCompactMulSupport f) :\n    \u2203 x : \u03b2, \u2200 y : \u03b2, f y \u2264 f x", "start": [303, 1], "end": [308, 70], "kind": "commanddeclaration"}, {"full_name": "IsCompact.bddBelow", "code": "theorem IsCompact.bddBelow [ClosedIicTopology \u03b1] [Nonempty \u03b1] {s : Set \u03b1} (hs : IsCompact s) :\n    BddBelow s", "start": [312, 1], "end": [318, 19], "kind": "commanddeclaration"}, {"full_name": "IsCompact.bddAbove", "code": "theorem IsCompact.bddAbove [ClosedIciTopology \u03b1] [Nonempty \u03b1] {s : Set \u03b1} (hs : IsCompact s) :\n    BddAbove s", "start": [321, 1], "end": [324, 35], "kind": "commanddeclaration"}, {"full_name": "IsCompact.bddBelow_image", "code": "theorem IsCompact.bddBelow_image [ClosedIicTopology \u03b1] [Nonempty \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2}\n    (hK : IsCompact K) (hf : ContinuousOn f K) : BddBelow (f '' K)", "start": [327, 1], "end": [330, 41], "kind": "commanddeclaration"}, {"full_name": "IsCompact.bddAbove_image", "code": "theorem IsCompact.bddAbove_image [ClosedIciTopology \u03b1] [Nonempty \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2}\n    (hK : IsCompact K) (hf : ContinuousOn f K) : BddAbove (f '' K)", "start": [333, 1], "end": [336, 44], "kind": "commanddeclaration"}, {"full_name": "Continuous.bddBelow_range_of_hasCompactMulSupport", "code": "@[to_additive \" A continuous function with compact support is bounded below. \"]\ntheorem Continuous.bddBelow_range_of_hasCompactMulSupport [ClosedIicTopology \u03b1] [One \u03b1]\n    {f : \u03b2 \u2192 \u03b1} (hf : Continuous f) (h : HasCompactMulSupport f) : BddBelow (range f)", "start": [339, 1], "end": [343, 34], "kind": "commanddeclaration"}, {"full_name": "Continuous.bddAbove_range_of_hasCompactMulSupport", "code": "@[to_additive \" A continuous function with compact support is bounded above. \"]\ntheorem Continuous.bddAbove_range_of_hasCompactMulSupport [ClosedIciTopology \u03b1] [One \u03b1]\n    {f : \u03b2 \u2192 \u03b1} (hf : Continuous f) (h : HasCompactMulSupport f) : BddAbove (range f)", "start": [347, 1], "end": [351, 68], "kind": "commanddeclaration"}, {"full_name": "IsCompact.sSup_lt_iff_of_continuous", "code": "theorem IsCompact.sSup_lt_iff_of_continuous [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2}\n    (hK : IsCompact K) (h0K : K.Nonempty) (hf : ContinuousOn f K) (y : \u03b1) :\n    sSup (f '' K) < y \u2194 \u2200 x \u2208 K, f x < y", "start": [362, 1], "end": [369, 44], "kind": "commanddeclaration"}, {"full_name": "IsCompact.lt_sInf_iff_of_continuous", "code": "theorem IsCompact.lt_sInf_iff_of_continuous [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {K : Set \u03b2}\n    (hK : IsCompact K) (h0K : K.Nonempty) (hf : ContinuousOn f K) (y : \u03b1) :\n    y < sInf (f '' K) \u2194 \u2200 x \u2208 K, y < f x", "start": [372, 1], "end": [375, 61], "kind": "commanddeclaration"}, {"full_name": "IsCompact.sInf_mem", "code": "theorem IsCompact.sInf_mem [ClosedIicTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : sInf s \u2208 s", "start": [389, 1], "end": [392, 15], "kind": "commanddeclaration"}, {"full_name": "IsCompact.sSup_mem", "code": "theorem IsCompact.sSup_mem [ClosedIciTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : sSup s \u2208 s", "start": [395, 1], "end": [397, 40], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isGLB_sInf", "code": "theorem IsCompact.isGLB_sInf [ClosedIicTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsGLB s (sInf s)", "start": [400, 1], "end": [402, 31], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isLUB_sSup", "code": "theorem IsCompact.isLUB_sSup [ClosedIciTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsLUB s (sSup s)", "start": [405, 1], "end": [407, 42], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isLeast_sInf", "code": "theorem IsCompact.isLeast_sInf [ClosedIicTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsLeast s (sInf s)", "start": [410, 1], "end": [412, 45], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isGreatest_sSup", "code": "theorem IsCompact.isGreatest_sSup [ClosedIciTopology \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : IsGreatest s (sSup s)", "start": [415, 1], "end": [417, 44], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_sInf_image_eq_and_le", "code": "theorem IsCompact.exists_sInf_image_eq_and_le [ClosedIicTopology \u03b1] {s : Set \u03b2}\n    (hs : IsCompact s) (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) :\n    \u2203 x \u2208 s, sInf (f '' s) = f x \u2227 \u2200 y \u2208 s, f x \u2264 f y", "start": [420, 1], "end": [425, 93], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_sSup_image_eq_and_ge", "code": "theorem IsCompact.exists_sSup_image_eq_and_ge [ClosedIciTopology \u03b1] {s : Set \u03b2}\n    (hs : IsCompact s) (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) :\n    \u2203 x \u2208 s, sSup (f '' s) = f x \u2227 \u2200 y \u2208 s, f y \u2264 f x", "start": [428, 1], "end": [431, 62], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_sInf_image_eq", "code": "theorem IsCompact.exists_sInf_image_eq [ClosedIicTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) {f : \u03b2 \u2192 \u03b1} (hf : ContinuousOn f s) : \u2203 x \u2208 s, sInf (f '' s) = f x", "start": [434, 1], "end": [437, 15], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_sSup_image_eq", "code": "theorem IsCompact.exists_sSup_image_eq [ClosedIciTopology \u03b1] {s : Set \u03b2} (hs : IsCompact s)\n    (ne_s : s.Nonempty) : \u2200 {f : \u03b2 \u2192 \u03b1}, ContinuousOn f s \u2192 \u2203 x \u2208 s, sSup (f '' s) = f x", "start": [440, 1], "end": [442, 52], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isMinOn_mem_subset", "code": "theorem IsCompact.exists_isMinOn_mem_subset [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2}\n    {z : \u03b2} (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z \u2208 t)\n    (hfz : \u2200 z' \u2208 t \\ s, f z < f z') : \u2203 x \u2208 s, IsMinOn f t x", "start": [451, 1], "end": [455, 71], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isMaxOn_mem_subset", "code": "theorem IsCompact.exists_isMaxOn_mem_subset [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2}\n    {z : \u03b2} (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z \u2208 t)\n    (hfz : \u2200 z' \u2208 t \\ s, f z' < f z) : \u2203 x \u2208 s, IsMaxOn f t x", "start": [457, 1], "end": [461, 71], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isLocalMinOn_mem_subset", "code": "@[deprecated IsCompact.exists_isMinOn_mem_subset]\ntheorem IsCompact.exists_isLocalMinOn_mem_subset [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2}\n    {z : \u03b2} (ht : IsCompact t) (hf : ContinuousOn f t) (hz : z \u2208 t)\n    (hfz : \u2200 z' \u2208 t \\ s, f z < f z') : \u2203 x \u2208 s, IsLocalMinOn f t x", "start": [463, 1], "end": [468, 23], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isLocalMin_mem_open", "code": "theorem IsCompact.exists_isLocalMin_mem_open [ClosedIicTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2}\n    {z : \u03b2} (ht : IsCompact t) (hst : s \u2286 t) (hf : ContinuousOn f t) (hz : z \u2208 t)\n    (hfz : \u2200 z' \u2208 t \\ s, f z < f z') (hs : IsOpen s) : \u2203 x \u2208 s, IsLocalMin f x", "start": [473, 1], "end": [477, 61], "kind": "commanddeclaration"}, {"full_name": "IsCompact.exists_isLocalMax_mem_open", "code": "theorem IsCompact.exists_isLocalMax_mem_open [ClosedIciTopology \u03b1] {f : \u03b2 \u2192 \u03b1} {s t : Set \u03b2}\n    {z : \u03b2} (ht : IsCompact t) (hst : s \u2286 t) (hf : ContinuousOn f t) (hz : z \u2208 t)\n    (hfz : \u2200 z' \u2208 t \\ s, f z' < f z) (hs : IsOpen s) : \u2203 x \u2208 s, IsLocalMax f x", "start": [480, 1], "end": [484, 61], "kind": "commanddeclaration"}, {"full_name": "eq_Icc_of_connected_compact", "code": "theorem eq_Icc_of_connected_compact {s : Set \u03b1} (h\u2081 : IsConnected s) (h\u2082 : IsCompact s) :\n    s = Icc (sInf s) (sSup s)", "start": [491, 1], "end": [493, 84], "kind": "commanddeclaration"}, {"full_name": "IsCompact.continuous_sSup", "code": "theorem IsCompact.continuous_sSup {f : \u03b3 \u2192 \u03b2 \u2192 \u03b1} {K : Set \u03b2} (hK : IsCompact K)\n    (hf : Continuous \u21bff) : Continuous fun x => sSup (f x '' K)", "start": [509, 1], "end": [534, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.continuous_sInf", "code": "theorem IsCompact.continuous_sInf {f : \u03b3 \u2192 \u03b2 \u2192 \u03b1} {K : Set \u03b2} (hK : IsCompact K)\n    (hf : Continuous \u21bff) : Continuous fun x => sInf (f x '' K)", "start": [537, 1], "end": [539, 45], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.image_Icc", "code": "theorem image_Icc (hab : a \u2264 b) (h : ContinuousOn f <| Icc a b) :\n    f '' Icc a b = Icc (sInf <| f '' Icc a b) (sSup <| f '' Icc a b)", "start": [553, 1], "end": [556, 44], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.image_uIcc_eq_Icc", "code": "theorem image_uIcc_eq_Icc (h : ContinuousOn f [[a, b]]) :\n    f '' [[a, b]] = Icc (sInf (f '' [[a, b]])) (sSup (f '' [[a, b]]))", "start": [559, 1], "end": [561, 25], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.image_uIcc", "code": "theorem image_uIcc (h : ContinuousOn f <| [[a, b]]) :\n    f '' [[a, b]] = [[sInf (f '' [[a, b]]), sSup (f '' [[a, b]])]]", "start": [564, 1], "end": [568, 38], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.sInf_image_Icc_le", "code": "theorem sInf_image_Icc_le (h : ContinuousOn f <| Icc a b) (hc : c \u2208 Icc a b) :\n    sInf (f '' Icc a b) \u2264 f c", "start": [571, 1], "end": [575, 15], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.le_sSup_image_Icc", "code": "theorem le_sSup_image_Icc (h : ContinuousOn f <| Icc a b) (hc : c \u2208 Icc a b) :\n    f c \u2264 sSup (f '' Icc a b)", "start": [578, 1], "end": [582, 15], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/EMetricSpace/Basic.lean", "imports": ["Mathlib/Topology/UniformSpace/UniformConvergence.lean", "Mathlib/Data/Real/ENNReal.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Topology/UniformSpace/Pi.lean"], "premises": [{"full_name": "uniformity_dist_of_mem_uniformity", "code": "theorem uniformity_dist_of_mem_uniformity [LinearOrder \u03b2] {U : Filter (\u03b1 \u00d7 \u03b1)} (z : \u03b2)\n    (D : \u03b1 \u2192 \u03b1 \u2192 \u03b2) (H : \u2200 s, s \u2208 U \u2194 \u2203 \u03b5 > z, \u2200 {a b : \u03b1}, D a b < \u03b5 \u2192 (a, b) \u2208 s) :\n    U = \u2a05 \u03b5 > z, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | D p.1 p.2 < \u03b5 }", "start": [38, 1], "end": [43, 84], "kind": "commanddeclaration"}, {"full_name": "EDist", "code": "class EDist (\u03b1 : Type*) where\n  edist : \u03b1 \u2192 \u03b1 \u2192 \u211d\u22650\u221e", "start": [46, 1], "end": [48, 23], "kind": "commanddeclaration"}, {"full_name": "uniformSpaceOfEDist", "code": "def uniformSpaceOfEDist (edist : \u03b1 \u2192 \u03b1 \u2192 \u211d\u22650\u221e) (edist_self : \u2200 x : \u03b1, edist x x = 0)\n    (edist_comm : \u2200 x y : \u03b1, edist x y = edist y x)\n    (edist_triangle : \u2200 x y z : \u03b1, edist x z \u2264 edist x y + edist y z) : UniformSpace \u03b1 :=\n  .ofFun edist edist_self edist_comm edist_triangle fun \u03b5 \u03b50 =>\n    \u27e8\u03b5 / 2, ENNReal.half_pos \u03b50.ne', fun _ h\u2081 _ h\u2082 =>\n      (ENNReal.add_lt_add h\u2081 h\u2082).trans_eq (ENNReal.add_halves _)\u27e9", "start": [53, 1], "end": [59, 66], "kind": "commanddeclaration"}, {"full_name": "PseudoEMetricSpace", "code": "class PseudoEMetricSpace (\u03b1 : Type u) extends EDist \u03b1 : Type u where\n  edist_self : \u2200 x : \u03b1, edist x x = 0\n  edist_comm : \u2200 x y : \u03b1, edist x y = edist y x\n  edist_triangle : \u2200 x y z : \u03b1, edist x z \u2264 edist x y + edist y z\n  toUniformSpace : UniformSpace \u03b1 := uniformSpaceOfEDist edist edist_self edist_comm edist_triangle\n  uniformity_edist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 } := by rfl", "start": [64, 1], "end": [82, 82], "kind": "commanddeclaration"}, {"full_name": "edist_triangle_left", "code": "theorem edist_triangle_left (x y z : \u03b1) : edist x y \u2264 edist z x + edist z y", "start": [95, 1], "end": [97, 42], "kind": "commanddeclaration"}, {"full_name": "edist_triangle_right", "code": "theorem edist_triangle_right (x y z : \u03b1) : edist x y \u2264 edist x z + edist y z", "start": [100, 1], "end": [101, 42], "kind": "commanddeclaration"}, {"full_name": "edist_congr_right", "code": "theorem edist_congr_right {x y z : \u03b1} (h : edist x y = 0) : edist x z = edist y z", "start": [104, 1], "end": [110, 25], "kind": "commanddeclaration"}, {"full_name": "edist_congr_left", "code": "theorem edist_congr_left {x y z : \u03b1} (h : edist x y = 0) : edist z x = edist z y", "start": [113, 1], "end": [115, 28], "kind": "commanddeclaration"}, {"full_name": "edist_congr", "code": "theorem edist_congr {w x y z : \u03b1} (hl : edist w x = 0) (hr : edist y z = 0) :\n    edist w y = edist x z", "start": [119, 1], "end": [121, 53], "kind": "commanddeclaration"}, {"full_name": "edist_triangle4", "code": "theorem edist_triangle4 (x y z t : \u03b1) : edist x t \u2264 edist x y + edist y z + edist z t", "start": [123, 1], "end": [126, 87], "kind": "commanddeclaration"}, {"full_name": "edist_le_Ico_sum_edist", "code": "theorem edist_le_Ico_sum_edist (f : \u2115 \u2192 \u03b1) {m n} (h : m \u2264 n) :\n    edist (f m) (f n) \u2264 \u2211 i in Finset.Ico m n, edist (f i) (f (i + 1))", "start": [129, 1], "end": [139, 87], "kind": "commanddeclaration"}, {"full_name": "edist_le_range_sum_edist", "code": "theorem edist_le_range_sum_edist (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    edist (f 0) (f n) \u2264 \u2211 i in Finset.range n, edist (f i) (f (i + 1))", "start": [142, 1], "end": [145, 67], "kind": "commanddeclaration"}, {"full_name": "edist_le_Ico_sum_of_edist_le", "code": "theorem edist_le_Ico_sum_of_edist_le {f : \u2115 \u2192 \u03b1} {m n} (hmn : m \u2264 n) {d : \u2115 \u2192 \u211d\u22650\u221e}\n    (hd : \u2200 {k}, m \u2264 k \u2192 k < n \u2192 edist (f k) (f (k + 1)) \u2264 d k) :\n    edist (f m) (f n) \u2264 \u2211 i in Finset.Ico m n, d i", "start": [148, 1], "end": [154, 86], "kind": "commanddeclaration"}, {"full_name": "edist_le_range_sum_of_edist_le", "code": "theorem edist_le_range_sum_of_edist_le {f : \u2115 \u2192 \u03b1} (n : \u2115) {d : \u2115 \u2192 \u211d\u22650\u221e}\n    (hd : \u2200 {k}, k < n \u2192 edist (f k) (f (k + 1)) \u2264 d k) :\n    edist (f 0) (f n) \u2264 \u2211 i in Finset.range n, d i", "start": [157, 1], "end": [162, 79], "kind": "commanddeclaration"}, {"full_name": "uniformity_pseudoedist", "code": "theorem uniformity_pseudoedist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 }", "start": [165, 1], "end": [167, 38], "kind": "commanddeclaration"}, {"full_name": "uniformSpace_edist", "code": "theorem uniformSpace_edist :\n    \u2039PseudoEMetricSpace \u03b1\u203a.toUniformSpace =\n      uniformSpaceOfEDist edist edist_self edist_comm edist_triangle", "start": [170, 1], "end": [173, 42], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist", "code": "theorem uniformity_basis_edist :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 }", "start": [176, 1], "end": [178, 86], "kind": "commanddeclaration"}, {"full_name": "mem_uniformity_edist", "code": "theorem mem_uniformity_edist {s : Set (\u03b1 \u00d7 \u03b1)} :\n    s \u2208 \ud835\udce4 \u03b1 \u2194 \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, edist a b < \u03b5 \u2192 (a, b) \u2208 s", "start": [181, 1], "end": [184, 44], "kind": "commanddeclaration"}, {"full_name": "EMetric.mk_uniformity_basis", "code": "protected theorem EMetric.mk_uniformity_basis {\u03b2 : Type*} {p : \u03b2 \u2192 Prop} {f : \u03b2 \u2192 \u211d\u22650\u221e}\n    (hf\u2080 : \u2200 x, p x \u2192 0 < f x) (hf : \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 x, p x \u2227 f x \u2264 \u03b5) :\n    (\ud835\udce4 \u03b1).HasBasis p fun x => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < f x }", "start": [187, 1], "end": [200, 47], "kind": "commanddeclaration"}, {"full_name": "EMetric.mk_uniformity_basis_le", "code": "protected theorem EMetric.mk_uniformity_basis_le {\u03b2 : Type*} {p : \u03b2 \u2192 Prop} {f : \u03b2 \u2192 \u211d\u22650\u221e}\n    (hf\u2080 : \u2200 x, p x \u2192 0 < f x) (hf : \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 x, p x \u2227 f x \u2264 \u03b5) :\n    (\ud835\udce4 \u03b1).HasBasis p fun x => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 \u2264 f x }", "start": [203, 1], "end": [216, 77], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_le", "code": "theorem uniformity_basis_edist_le :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 \u2264 \u03b5 }", "start": [219, 1], "end": [221, 78], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist'", "code": "theorem uniformity_basis_edist' (\u03b5' : \u211d\u22650\u221e) (h\u03b5' : 0 < \u03b5') :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => \u03b5 \u2208 Ioo 0 \u03b5') fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 }", "start": [224, 1], "end": [228, 89], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_le'", "code": "theorem uniformity_basis_edist_le' (\u03b5' : \u211d\u22650\u221e) (h\u03b5' : 0 < \u03b5') :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => \u03b5 \u2208 Ioo 0 \u03b5') fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 \u2264 \u03b5 }", "start": [231, 1], "end": [235, 89], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_nnreal", "code": "theorem uniformity_basis_edist_nnreal :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650 => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 }", "start": [238, 1], "end": [242, 47], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_nnreal_le", "code": "theorem uniformity_basis_edist_nnreal_le :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650 => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 \u2264 \u03b5 }", "start": [245, 1], "end": [249, 47], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_inv_nat", "code": "theorem uniformity_basis_edist_inv_nat :\n    (\ud835\udce4 \u03b1).HasBasis (fun _ => True) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < (\u2191n)\u207b\u00b9 }", "start": [252, 1], "end": [256, 30], "kind": "commanddeclaration"}, {"full_name": "uniformity_basis_edist_inv_two_pow", "code": "theorem uniformity_basis_edist_inv_two_pow :\n    (\ud835\udce4 \u03b1).HasBasis (fun _ => True) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < 2\u207b\u00b9 ^ n }", "start": [259, 1], "end": [264, 30], "kind": "commanddeclaration"}, {"full_name": "edist_mem_uniformity", "code": "theorem edist_mem_uniformity {\u03b5 : \u211d\u22650\u221e} (\u03b50 : 0 < \u03b5) : { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 } \u2208 \ud835\udce4 \u03b1", "start": [267, 1], "end": [269, 37], "kind": "commanddeclaration"}, {"full_name": "EMetric.instIsCountablyGeneratedUniformity", "code": "instance (priority := 900) instIsCountablyGeneratedUniformity : IsCountablyGenerated (\ud835\udce4 \u03b1) :=\n  isCountablyGenerated_of_seq \u27e8_, uniformity_basis_edist_inv_nat.eq_iInf\u27e9", "start": [274, 1], "end": [275, 74], "kind": "commanddeclaration"}, {"full_name": "EMetric.uniformContinuousOn_iff", "code": "theorem uniformContinuousOn_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    UniformContinuousOn f s \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a}, a \u2208 s \u2192 \u2200 {b}, b \u2208 s \u2192 edist a b < \u03b4 \u2192 edist (f a) (f b) < \u03b5", "start": [278, 1], "end": [282, 72], "kind": "commanddeclaration"}, {"full_name": "EMetric.uniformContinuous_iff", "code": "theorem uniformContinuous_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b1}, edist a b < \u03b4 \u2192 edist (f a) (f b) < \u03b5", "start": [285, 1], "end": [288, 70], "kind": "commanddeclaration"}, {"full_name": "EMetric.uniformInducing_iff", "code": "theorem uniformInducing_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformInducing f \u2194 UniformContinuous f \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, edist (f a) (f b) < \u03b5 \u2192 edist a b < \u03b4", "start": [292, 1], "end": [297, 47], "kind": "commanddeclaration"}, {"full_name": "EMetric.uniformEmbedding_iff", "code": "nonrec theorem uniformEmbedding_iff [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 Function.Injective f \u2227 UniformContinuous f \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, edist (f a) (f b) < \u03b5 \u2192 edist a b < \u03b4", "start": [299, 1], "end": [303, 86], "kind": "commanddeclaration"}, {"full_name": "EMetric.controlled_of_uniformEmbedding", "code": "theorem controlled_of_uniformEmbedding [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (h : UniformEmbedding f) :\n    (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b1}, edist a b < \u03b4 \u2192 edist (f a) (f b) < \u03b5) \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, edist (f a) (f b) < \u03b5 \u2192 edist a b < \u03b4", "start": [306, 1], "end": [314, 80], "kind": "commanddeclaration"}, {"full_name": "EMetric.cauchy_iff", "code": "protected theorem cauchy_iff {f : Filter \u03b1} :\n    Cauchy f \u2194 f \u2260 \u22a5 \u2227 \u2200 \u03b5 > 0, \u2203 t \u2208 f, \u2200 x, x \u2208 t \u2192 \u2200 y, y \u2208 t \u2192 edist x y < \u03b5", "start": [317, 1], "end": [320, 60], "kind": "commanddeclaration"}, {"full_name": "EMetric.complete_of_convergent_controlled_sequences", "code": "theorem complete_of_convergent_controlled_sequences (B : \u2115 \u2192 \u211d\u22650\u221e) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 edist (u n) (u m) < B N) \u2192\n      \u2203 x, Tendsto u atTop (\ud835\udcdd x)) :\n    CompleteSpace \u03b1", "start": [323, 1], "end": [333, 93], "kind": "commanddeclaration"}, {"full_name": "EMetric.complete_of_cauchySeq_tendsto", "code": "theorem complete_of_cauchySeq_tendsto :\n    (\u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) \u2192 CompleteSpace \u03b1", "start": [336, 1], "end": [339, 45], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendstoLocallyUniformlyOn_iff", "code": "theorem tendstoLocallyUniformlyOn_iff {\u03b9 : Type*} [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1}\n    {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 n in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5", "start": [342, 1], "end": [350, 55], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendstoUniformlyOn_iff", "code": "theorem tendstoUniformlyOn_iff {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoUniformlyOn F f p s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 n in p, \u2200 x \u2208 s, edist (f x) (F n x) < \u03b5", "start": [353, 1], "end": [358, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendstoLocallyUniformly_iff", "code": "theorem tendstoLocallyUniformly_iff {\u03b9 : Type*} [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1}\n    {p : Filter \u03b9} :\n    TendstoLocallyUniformly F f p \u2194\n      \u2200 \u03b5 > 0, \u2200 x : \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 n in p, \u2200 y \u2208 t, edist (f y) (F n y) < \u03b5", "start": [361, 1], "end": [367, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendstoUniformly_iff", "code": "theorem tendstoUniformly_iff {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} :\n    TendstoUniformly F f p \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 n in p, \u2200 x, edist (f x) (F n x) < \u03b5", "start": [370, 1], "end": [373, 88], "kind": "commanddeclaration"}, {"full_name": "PseudoEMetricSpace.replaceUniformity", "code": "def PseudoEMetricSpace.replaceUniformity {\u03b1} [U : UniformSpace \u03b1] (m : PseudoEMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : PseudoEMetricSpace \u03b1 where\n  edist := @edist _ m.toEDist\n  edist_self := edist_self\n  edist_comm := edist_comm\n  edist_triangle := edist_triangle\n  toUniformSpace := U\n  uniformity_edist := H.trans (@PseudoEMetricSpace.uniformity_edist \u03b1 _)", "start": [380, 1], "end": [393, 73], "kind": "commanddeclaration"}, {"full_name": "PseudoEMetricSpace.induced", "code": "def PseudoEMetricSpace.induced {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (m : PseudoEMetricSpace \u03b2) :\n    PseudoEMetricSpace \u03b1 where\n  edist x y := edist (f x) (f y)\n  edist_self _ := edist_self _\n  edist_comm _ _ := edist_comm _ _\n  edist_triangle _ _ _ := edist_triangle _ _ _\n  toUniformSpace := UniformSpace.comap f m.toUniformSpace\n  uniformity_edist := (uniformity_basis_edist.comap (Prod.map f f)).eq_biInf", "start": [396, 1], "end": [404, 77], "kind": "commanddeclaration"}, {"full_name": "Subtype.edist_eq", "code": "theorem Subtype.edist_eq {p : \u03b1 \u2192 Prop} (x y : Subtype p) : edist x y = edist (x : \u03b1) y", "start": [411, 1], "end": [413, 95], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.edist_unop", "code": "@[to_additive]\ntheorem edist_unop (x y : \u03b1\u1d50\u1d52\u1d56) : edist (unop x) (unop y) = edist x y", "start": [423, 1], "end": [424, 77], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.edist_op", "code": "@[to_additive]\ntheorem edist_op (x y : \u03b1) : edist (op x) (op y) = edist x y", "start": [428, 1], "end": [429, 68], "kind": "commanddeclaration"}, {"full_name": "ULift.edist_eq", "code": "theorem ULift.edist_eq (x y : ULift \u03b1) : edist x y = edist x.down y.down", "start": [439, 1], "end": [439, 80], "kind": "commanddeclaration"}, {"full_name": "ULift.edist_up_up", "code": "@[simp]\ntheorem ULift.edist_up_up (x y : \u03b1) : edist (ULift.up x) (ULift.up y) = edist x y", "start": [442, 1], "end": [443, 89], "kind": "commanddeclaration"}, {"full_name": "Prod.pseudoEMetricSpaceMax", "code": "instance Prod.pseudoEMetricSpaceMax [PseudoEMetricSpace \u03b2] : PseudoEMetricSpace (\u03b1 \u00d7 \u03b2) where\n  edist x y := edist x.1 y.1 \u2294 edist x.2 y.2\n  edist_self x := by simp\n  edist_comm x y := by simp [edist_comm]\n  edist_triangle x y z :=\n    max_le (le_trans (edist_triangle _ _ _) (add_le_add (le_max_left _ _) (le_max_left _ _)))\n      (le_trans (edist_triangle _ _ _) (add_le_add (le_max_right _ _) (le_max_right _ _)))\n  uniformity_edist := uniformity_prod.trans <| by\n    simp [PseudoEMetricSpace.uniformity_edist, \u2190 iInf_inf_eq, setOf_and]\n  toUniformSpace := inferInstance", "start": [448, 1], "end": [460, 34], "kind": "commanddeclaration"}, {"full_name": "Prod.edist_eq", "code": "theorem Prod.edist_eq [PseudoEMetricSpace \u03b2] (x y : \u03b1 \u00d7 \u03b2) :\n    edist x y = max (edist x.1 y.1) (edist x.2 y.2)", "start": [463, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "edist_pi_def", "code": "theorem edist_pi_def [\u2200 b, EDist (\u03c0 b)] (f g : \u2200 b, \u03c0 b) :\n    edist f g = Finset.sup univ fun b => edist (f b) (g b)", "start": [478, 1], "end": [480, 6], "kind": "commanddeclaration"}, {"full_name": "edist_le_pi_edist", "code": "theorem edist_le_pi_edist [\u2200 b, EDist (\u03c0 b)] (f g : \u2200 b, \u03c0 b) (b : \u03b2) :\n    edist (f b) (g b) \u2264 edist f g", "start": [483, 1], "end": [485, 63], "kind": "commanddeclaration"}, {"full_name": "edist_pi_le_iff", "code": "theorem edist_pi_le_iff [\u2200 b, EDist (\u03c0 b)] {f g : \u2200 b, \u03c0 b} {d : \u211d\u22650\u221e} :\n    edist f g \u2264 d \u2194 \u2200 b, edist (f b) (g b) \u2264 d", "start": [488, 1], "end": [490, 74], "kind": "commanddeclaration"}, {"full_name": "edist_pi_const_le", "code": "theorem edist_pi_const_le (a b : \u03b1) : (edist (fun _ : \u03b2 => a) fun _ => b) \u2264 edist a b", "start": [493, 1], "end": [494, 36], "kind": "commanddeclaration"}, {"full_name": "edist_pi_const", "code": "@[simp]\ntheorem edist_pi_const [Nonempty \u03b2] (a b : \u03b1) : (edist (fun _ : \u03b2 => a) fun _ => b) = edist a b", "start": [497, 1], "end": [499, 45], "kind": "commanddeclaration"}, {"full_name": "pseudoEMetricSpacePi", "code": "instance pseudoEMetricSpacePi [\u2200 b, PseudoEMetricSpace (\u03c0 b)] : PseudoEMetricSpace (\u2200 b, \u03c0 b) where\n  edist_self f := bot_unique <| Finset.sup_le <| by simp\n  edist_comm f g := by simp [edist_pi_def, edist_comm]\n  edist_triangle f g h := edist_pi_le_iff.2 <| fun b => le_trans (edist_triangle _ (g b) _)\n    (add_le_add (edist_le_pi_edist _ _ _) (edist_le_pi_edist _ _ _))\n  toUniformSpace := Pi.uniformSpace _\n  uniformity_edist := by\n    simp only [Pi.uniformity, PseudoEMetricSpace.uniformity_edist, comap_iInf, gt_iff_lt,\n      preimage_setOf_eq, comap_principal, edist_pi_def]\n    rw [iInf_comm]; congr; funext \u03b5\n    rw [iInf_comm]; congr; funext \u03b5pos\n    simp [setOf_forall, \u03b5pos]", "start": [502, 1], "end": [518, 30], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball", "code": "def ball (x : \u03b1) (\u03b5 : \u211d\u22650\u221e) : Set \u03b1 :=\n  { y | edist y x < \u03b5 }", "start": [527, 1], "end": [529, 24], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_ball", "code": "@[simp] theorem mem_ball : y \u2208 ball x \u03b5 \u2194 edist y x < \u03b5", "start": [532, 1], "end": [532, 67], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_ball'", "code": "theorem mem_ball' : y \u2208 ball x \u03b5 \u2194 edist x y < \u03b5", "start": [535, 1], "end": [535, 81], "kind": "commanddeclaration"}, {"full_name": "EMetric.closedBall", "code": "def closedBall (x : \u03b1) (\u03b5 : \u211d\u22650\u221e) :=\n  { y | edist y x \u2264 \u03b5 }", "start": [538, 1], "end": [540, 24], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closedBall", "code": "@[simp] theorem mem_closedBall : y \u2208 closedBall x \u03b5 \u2194 edist y x \u2264 \u03b5", "start": [543, 1], "end": [543, 79], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closedBall'", "code": "theorem mem_closedBall' : y \u2208 closedBall x \u03b5 \u2194 edist x y \u2264 \u03b5", "start": [546, 1], "end": [546, 99], "kind": "commanddeclaration"}, {"full_name": "EMetric.closedBall_top", "code": "@[simp]\ntheorem closedBall_top (x : \u03b1) : closedBall x \u221e = univ", "start": [549, 1], "end": [551, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_subset_closedBall", "code": "theorem ball_subset_closedBall : ball x \u03b5 \u2286 closedBall x \u03b5", "start": [554, 1], "end": [554, 88], "kind": "commanddeclaration"}, {"full_name": "EMetric.pos_of_mem_ball", "code": "theorem pos_of_mem_ball (hy : y \u2208 ball x \u03b5) : 0 < \u03b5", "start": [557, 1], "end": [558, 32], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_ball_self", "code": "theorem mem_ball_self (h : 0 < \u03b5) : x \u2208 ball x \u03b5", "start": [561, 1], "end": [562, 29], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closedBall_self", "code": "theorem mem_closedBall_self : x \u2208 closedBall x \u03b5", "start": [565, 1], "end": [566, 49], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_ball_comm", "code": "theorem mem_ball_comm : x \u2208 ball y \u03b5 \u2194 y \u2208 ball x \u03b5", "start": [569, 1], "end": [569, 83], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closedBall_comm", "code": "theorem mem_closedBall_comm : x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5", "start": [572, 1], "end": [573, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_subset_ball", "code": "theorem ball_subset_ball (h : \u03b5\u2081 \u2264 \u03b5\u2082) : ball x \u03b5\u2081 \u2286 ball x \u03b5\u2082", "start": [576, 1], "end": [577, 22], "kind": "commanddeclaration"}, {"full_name": "EMetric.closedBall_subset_closedBall", "code": "theorem closedBall_subset_closedBall (h : \u03b5\u2081 \u2264 \u03b5\u2082) : closedBall x \u03b5\u2081 \u2286 closedBall x \u03b5\u2082", "start": [580, 1], "end": [581, 40], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_disjoint", "code": "theorem ball_disjoint (h : \u03b5\u2081 + \u03b5\u2082 \u2264 edist x y) : Disjoint (ball x \u03b5\u2081) (ball y \u03b5\u2082)", "start": [584, 1], "end": [586, 80], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_subset", "code": "theorem ball_subset (h : edist x y + \u03b5\u2081 \u2264 \u03b5\u2082) (h' : edist x y \u2260 \u221e) : ball x \u03b5\u2081 \u2286 ball y \u03b5\u2082", "start": [589, 1], "end": [595, 16], "kind": "commanddeclaration"}, {"full_name": "EMetric.exists_ball_subset_ball", "code": "theorem exists_ball_subset_ball (h : y \u2208 ball x \u03b5) : \u2203 \u03b5' > 0, ball y \u03b5' \u2286 ball x \u03b5", "start": [598, 1], "end": [601, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_eq_empty_iff", "code": "theorem ball_eq_empty_iff : ball x \u03b5 = \u2205 \u2194 \u03b5 = 0", "start": [604, 1], "end": [607, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.ordConnected_setOf_closedBall_subset", "code": "theorem ordConnected_setOf_closedBall_subset (x : \u03b1) (s : Set \u03b1) :\n    OrdConnected { r | closedBall x r \u2286 s }", "start": [610, 1], "end": [612, 70], "kind": "commanddeclaration"}, {"full_name": "EMetric.ordConnected_setOf_ball_subset", "code": "theorem ordConnected_setOf_ball_subset (x : \u03b1) (s : Set \u03b1) : OrdConnected { r | ball x r \u2286 s }", "start": [615, 1], "end": [616, 58], "kind": "commanddeclaration"}, {"full_name": "EMetric.edistLtTopSetoid", "code": "def edistLtTopSetoid : Setoid \u03b1 where\n  r x y := edist x y < \u22a4\n  iseqv :=\n    \u27e8fun x => by rw [edist_self]; exact ENNReal.coe_lt_top,\n      fun h => by rwa [edist_comm], fun hxy hyz =>\n        lt_of_le_of_lt (edist_triangle _ _ _) (ENNReal.add_lt_top.2 \u27e8hxy, hyz\u27e9)\u27e9", "start": [619, 1], "end": [625, 81], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_zero", "code": "@[simp]\ntheorem ball_zero : ball x 0 = \u2205", "start": [628, 1], "end": [629, 70], "kind": "commanddeclaration"}, {"full_name": "EMetric.nhds_basis_eball", "code": "theorem nhds_basis_eball : (\ud835\udcdd x).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) (ball x)", "start": [632, 1], "end": [633, 47], "kind": "commanddeclaration"}, {"full_name": "EMetric.nhdsWithin_basis_eball", "code": "theorem nhdsWithin_basis_eball : (\ud835\udcdd[s] x).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => ball x \u03b5 \u2229 s", "start": [636, 1], "end": [637, 41], "kind": "commanddeclaration"}, {"full_name": "EMetric.nhds_basis_closed_eball", "code": "theorem nhds_basis_closed_eball : (\ud835\udcdd x).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) (closedBall x)", "start": [640, 1], "end": [641, 50], "kind": "commanddeclaration"}, {"full_name": "EMetric.nhdsWithin_basis_closed_eball", "code": "theorem nhdsWithin_basis_closed_eball :\n    (\ud835\udcdd[s] x).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => closedBall x \u03b5 \u2229 s", "start": [644, 1], "end": [646, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.nhds_eq", "code": "theorem nhds_eq : \ud835\udcdd x = \u2a05 \u03b5 > 0, \ud835\udcdf (ball x \u03b5)", "start": [649, 1], "end": [650, 28], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_nhds_iff", "code": "theorem mem_nhds_iff : s \u2208 \ud835\udcdd x \u2194 \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s", "start": [653, 1], "end": [654, 27], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_nhdsWithin_iff", "code": "theorem mem_nhdsWithin_iff : s \u2208 \ud835\udcdd[t] x \u2194 \u2203 \u03b5 > 0, ball x \u03b5 \u2229 t \u2286 s", "start": [657, 1], "end": [658, 33], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendsto_nhdsWithin_nhdsWithin", "code": "theorem tendsto_nhdsWithin_nhdsWithin {t : Set \u03b2} {a b} :\n    Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd[t] b) \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 \u2983x\u2984, x \u2208 s \u2192 edist x a < \u03b4 \u2192 f x \u2208 t \u2227 edist (f x) b < \u03b5", "start": [665, 1], "end": [670, 44], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendsto_nhdsWithin_nhds", "code": "theorem tendsto_nhdsWithin_nhds {a b} :\n    Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b) \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, x \u2208 s \u2192 edist x a < \u03b4 \u2192 edist (f x) b < \u03b5", "start": [673, 1], "end": [677, 37], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendsto_nhds_nhds", "code": "theorem tendsto_nhds_nhds {a b} :\n    Tendsto f (\ud835\udcdd a) (\ud835\udcdd b) \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 \u2983x\u2984, edist x a < \u03b4 \u2192 edist (f x) b < \u03b5", "start": [680, 1], "end": [682, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.isOpen_iff", "code": "theorem isOpen_iff : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s", "start": [687, 1], "end": [688, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.isOpen_ball", "code": "theorem isOpen_ball : IsOpen (ball x \u03b5)", "start": [691, 1], "end": [692, 48], "kind": "commanddeclaration"}, {"full_name": "EMetric.isClosed_ball_top", "code": "theorem isClosed_ball_top : IsClosed (ball x \u22a4)", "start": [695, 1], "end": [698, 67], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_mem_nhds", "code": "theorem ball_mem_nhds (x : \u03b1) {\u03b5 : \u211d\u22650\u221e} (\u03b50 : 0 < \u03b5) : ball x \u03b5 \u2208 \ud835\udcdd x", "start": [701, 1], "end": [702, 42], "kind": "commanddeclaration"}, {"full_name": "EMetric.closedBall_mem_nhds", "code": "theorem closedBall_mem_nhds (x : \u03b1) {\u03b5 : \u211d\u22650\u221e} (\u03b50 : 0 < \u03b5) : closedBall x \u03b5 \u2208 \ud835\udcdd x", "start": [705, 1], "end": [706, 62], "kind": "commanddeclaration"}, {"full_name": "EMetric.ball_prod_same", "code": "theorem ball_prod_same [PseudoEMetricSpace \u03b2] (x : \u03b1) (y : \u03b2) (r : \u211d\u22650\u221e) :\n    ball x r \u00d7\u02e2 ball y r = ball (x, y) r", "start": [709, 1], "end": [711, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.closedBall_prod_same", "code": "theorem closedBall_prod_same [PseudoEMetricSpace \u03b2] (x : \u03b1) (y : \u03b2) (r : \u211d\u22650\u221e) :\n    closedBall x r \u00d7\u02e2 closedBall y r = closedBall (x, y) r", "start": [714, 1], "end": [716, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.mem_closure_iff", "code": "theorem mem_closure_iff : x \u2208 closure s \u2194 \u2200 \u03b5 > 0, \u2203 y \u2208 s, edist x y < \u03b5", "start": [719, 1], "end": [721, 95], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendsto_nhds", "code": "theorem tendsto_nhds {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u f (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in f, edist (u x) a < \u03b5", "start": [724, 1], "end": [726, 37], "kind": "commanddeclaration"}, {"full_name": "EMetric.tendsto_atTop", "code": "theorem tendsto_atTop [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u atTop (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, edist (u n) a < \u03b5", "start": [729, 1], "end": [732, 61], "kind": "commanddeclaration"}, {"full_name": "EMetric.inseparable_iff", "code": "theorem inseparable_iff : Inseparable x y \u2194 edist x y = 0", "start": [735, 1], "end": [736, 85], "kind": "commanddeclaration"}, {"full_name": "EMetric.cauchySeq_iff", "code": "theorem cauchySeq_iff [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m, N \u2264 m \u2192 \u2200 n, N \u2264 n \u2192 edist (u m) (u n) < \u03b5", "start": [740, 1], "end": [744, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.cauchySeq_iff'", "code": "theorem cauchySeq_iff' [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > (0 : \u211d\u22650\u221e), \u2203 N, \u2200 n \u2265 N, edist (u n) (u N) < \u03b5", "start": [747, 1], "end": [750, 40], "kind": "commanddeclaration"}, {"full_name": "EMetric.cauchySeq_iff_NNReal", "code": "theorem cauchySeq_iff_NNReal [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 : \u211d\u22650, 0 < \u03b5 \u2192 \u2203 N, \u2200 n, N \u2264 n \u2192 edist (u n) (u N) < \u03b5", "start": [753, 1], "end": [757, 47], "kind": "commanddeclaration"}, {"full_name": "EMetric.totallyBounded_iff", "code": "theorem totallyBounded_iff {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Finite \u2227 s \u2286 \u22c3 y \u2208 t, ball y \u03b5", "start": [760, 1], "end": [765, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.totallyBounded_iff'", "code": "theorem totallyBounded_iff' {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 \u03b5 > 0, \u2203 t, t \u2286 s \u2227 Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, ball y \u03b5", "start": [768, 1], "end": [773, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.subset_countable_closure_of_almost_dense_set", "code": "theorem subset_countable_closure_of_almost_dense_set (s : Set \u03b1)\n    (hs : \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Countable \u2227 s \u2286 \u22c3 x \u2208 t, closedBall x \u03b5) :\n    \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s \u2286 closure t", "start": [779, 1], "end": [807, 41], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.exists_countable_dense_subset", "code": "theorem _root_.TopologicalSpace.IsSeparable.exists_countable_dense_subset\n    {s : Set \u03b1} (hs : IsSeparable s) : \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s \u2286 closure t", "start": [811, 1], "end": [821, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalSpace.IsSeparable.separableSpace", "code": "theorem _root_.TopologicalSpace.IsSeparable.separableSpace {s : Set \u03b1} (hs : IsSeparable s) :\n    SeparableSpace s", "start": [824, 1], "end": [832, 55], "kind": "commanddeclaration"}, {"full_name": "EMetric.subset_countable_closure_of_compact", "code": "theorem subset_countable_closure_of_compact {s : Set \u03b1} (hs : IsCompact s) :\n    \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s \u2286 closure t", "start": [836, 1], "end": [842, 88], "kind": "commanddeclaration"}, {"full_name": "EMetric.secondCountable_of_sigmaCompact", "code": "theorem secondCountable_of_sigmaCompact [SigmaCompactSpace \u03b1] : SecondCountableTopology \u03b1", "start": [853, 1], "end": [861, 54], "kind": "commanddeclaration"}, {"full_name": "EMetric.secondCountable_of_almost_dense_set", "code": "theorem secondCountable_of_almost_dense_set\n    (hs : \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Countable \u2227 \u22c3 x \u2208 t, closedBall x \u03b5 = univ) :\n    SecondCountableTopology \u03b1", "start": [866, 1], "end": [873, 45], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam", "code": "noncomputable def diam (s : Set \u03b1) :=\n  \u2a06 (x \u2208 s) (y \u2208 s), edist x y", "start": [880, 1], "end": [882, 31], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_eq_sSup", "code": "theorem diam_eq_sSup (s : Set \u03b1) : diam s = sSup (image2 edist s s)", "start": [885, 1], "end": [885, 88], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_le_iff", "code": "theorem diam_le_iff {d : \u211d\u22650\u221e} : diam s \u2264 d \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, edist x y \u2264 d", "start": [887, 1], "end": [888, 32], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_image_le_iff", "code": "theorem diam_image_le_iff {d : \u211d\u22650\u221e} {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    diam (f '' s) \u2264 d \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, edist (f x) (f y) \u2264 d", "start": [891, 1], "end": [893, 42], "kind": "commanddeclaration"}, {"full_name": "EMetric.edist_le_of_diam_le", "code": "theorem edist_le_of_diam_le {d} (hx : x \u2208 s) (hy : y \u2208 s) (hd : diam s \u2264 d) : edist x y \u2264 d", "start": [896, 1], "end": [897, 29], "kind": "commanddeclaration"}, {"full_name": "EMetric.edist_le_diam_of_mem", "code": "theorem edist_le_diam_of_mem (hx : x \u2208 s) (hy : y \u2208 s) : edist x y \u2264 diam s", "start": [900, 1], "end": [902, 35], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_le", "code": "theorem diam_le {d : \u211d\u22650\u221e} (h : \u2200 x \u2208 s, \u2200 y \u2208 s, edist x y \u2264 d) : diam s \u2264 d", "start": [905, 1], "end": [908, 18], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_subsingleton", "code": "theorem diam_subsingleton (hs : s.Subsingleton) : diam s = 0", "start": [911, 1], "end": [913, 92], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_empty", "code": "@[simp]\ntheorem diam_empty : diam (\u2205 : Set \u03b1) = 0", "start": [916, 1], "end": [919, 39], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_singleton", "code": "@[simp]\ntheorem diam_singleton : diam ({x} : Set \u03b1) = 0", "start": [922, 1], "end": [925, 43], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_iUnion_mem_option", "code": "theorem diam_iUnion_mem_option {\u03b9 : Type*} (o : Option \u03b9) (s : \u03b9 \u2192 Set \u03b1) :\n    diam (\u22c3 i \u2208 o, s i) = \u2a06 i \u2208 o, diam (s i)", "start": [928, 1], "end": [929, 69], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_insert", "code": "theorem diam_insert : diam (insert x s) = max (\u2a06 y \u2208 s, edist x y) (diam s)", "start": [932, 1], "end": [935, 68], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_pair", "code": "theorem diam_pair : diam ({x, y} : Set \u03b1) = edist x y", "start": [938, 1], "end": [939, 82], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_triple", "code": "theorem diam_triple : diam ({x, y, z} : Set \u03b1) = max (max (edist x y) (edist x z)) (edist y z)", "start": [942, 1], "end": [944, 24], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_mono", "code": "theorem diam_mono {s t : Set \u03b1} (h : s \u2286 t) : diam s \u2264 diam t", "start": [947, 1], "end": [949, 64], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_union", "code": "theorem diam_union {t : Set \u03b1} (xs : x \u2208 s) (yt : y \u2208 t) :\n    diam (s \u222a t) \u2264 diam s + edist x y + diam t", "start": [952, 1], "end": [972, 53], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_union'", "code": "theorem diam_union' {t : Set \u03b1} (h : (s \u2229 t).Nonempty) : diam (s \u222a t) \u2264 diam s + diam t", "start": [975, 1], "end": [977, 31], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_closedBall", "code": "theorem diam_closedBall {r : \u211d\u22650\u221e} : diam (closedBall x r) \u2264 2 * r", "start": [980, 1], "end": [985, 36], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_ball", "code": "theorem diam_ball {r : \u211d\u22650\u221e} : diam (ball x r) \u2264 2 * r", "start": [988, 1], "end": [989, 62], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_pi_le_of_le", "code": "theorem diam_pi_le_of_le {\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoEMetricSpace (\u03c0 b)]\n    {s : \u2200 b : \u03b2, Set (\u03c0 b)} {c : \u211d\u22650\u221e} (h : \u2200 b, diam (s b) \u2264 c) : diam (Set.pi univ s) \u2264 c", "start": [992, 1], "end": [996, 63], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace", "code": "class EMetricSpace (\u03b1 : Type u) extends PseudoEMetricSpace \u03b1 : Type u where\n  eq_of_edist_eq_zero : \u2200 {x y : \u03b1}, edist x y = 0 \u2192 x = y", "start": [1004, 1], "end": [1006, 59], "kind": "commanddeclaration"}, {"full_name": "edist_eq_zero", "code": "@[simp]\ntheorem edist_eq_zero {x y : \u03b3} : edist x y = 0 \u2194 x = y", "start": [1013, 1], "end": [1016, 51], "kind": "commanddeclaration"}, {"full_name": "zero_eq_edist", "code": "@[simp]\ntheorem zero_eq_edist {x y : \u03b3} : 0 = edist x y \u2194 x = y", "start": [1019, 1], "end": [1020, 87], "kind": "commanddeclaration"}, {"full_name": "edist_le_zero", "code": "theorem edist_le_zero {x y : \u03b3} : edist x y \u2264 0 \u2194 x = y", "start": [1023, 1], "end": [1024, 41], "kind": "commanddeclaration"}, {"full_name": "edist_pos", "code": "@[simp]\ntheorem edist_pos {x y : \u03b3} : 0 < edist x y \u2194 x \u2260 y", "start": [1027, 1], "end": [1028, 74], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_edist_le", "code": "theorem eq_of_forall_edist_le {x y : \u03b3} (h : \u2200 \u03b5 > 0, edist x y \u2264 \u03b5) : x = y", "start": [1031, 1], "end": [1033, 64], "kind": "commanddeclaration"}, {"full_name": "to_separated", "code": "instance (priority := 100) to_separated : SeparatedSpace \u03b3 :=\n  separated_def.2 fun _ _ h =>\n    eq_of_forall_edist_le fun _ \u03b50 => le_of_lt (h _ (edist_mem_uniformity \u03b50))", "start": [1037, 1], "end": [1040, 79], "kind": "commanddeclaration"}, {"full_name": "EMetric.uniformEmbedding_iff'", "code": "theorem EMetric.uniformEmbedding_iff' [EMetricSpace \u03b2] {f : \u03b3 \u2192 \u03b2} :\n    UniformEmbedding f \u2194\n      (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b3}, edist a b < \u03b4 \u2192 edist (f a) (f b) < \u03b5) \u2227\n        \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b3}, edist (f a) (f b) < \u03b5 \u2192 edist a b < \u03b4", "start": [1043, 1], "end": [1049, 88], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace.ofT0PseudoEMetricSpace", "code": "@[reducible] def EMetricSpace.ofT0PseudoEMetricSpace (\u03b1 : Type*) [PseudoEMetricSpace \u03b1] [T0Space \u03b1] :\n    EMetricSpace \u03b1 :=\n  { \u2039PseudoEMetricSpace \u03b1\u203a with\n    eq_of_edist_eq_zero := fun h => (EMetric.inseparable_iff.2 h).eq }", "start": [1052, 1], "end": [1057, 71], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace.replaceUniformity", "code": "def EMetricSpace.replaceUniformity {\u03b3} [U : UniformSpace \u03b3] (m : EMetricSpace \u03b3)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : EMetricSpace \u03b3 where\n  edist := @edist _ m.toEDist\n  edist_self := edist_self\n  eq_of_edist_eq_zero := @eq_of_edist_eq_zero _ _\n  edist_comm := edist_comm\n  edist_triangle := edist_triangle\n  toUniformSpace := U\n  uniformity_edist := H.trans (@PseudoEMetricSpace.uniformity_edist \u03b3 _)", "start": [1060, 1], "end": [1074, 73], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace.induced", "code": "def EMetricSpace.induced {\u03b3 \u03b2} (f : \u03b3 \u2192 \u03b2) (hf : Function.Injective f) (m : EMetricSpace \u03b2) :\n    EMetricSpace \u03b3 :=\n  { PseudoEMetricSpace.induced f m.toPseudoEMetricSpace with\n    eq_of_edist_eq_zero := fun h => hf (edist_eq_zero.1 h) }", "start": [1077, 1], "end": [1081, 61], "kind": "commanddeclaration"}, {"full_name": "Prod.emetricSpaceMax", "code": "instance Prod.emetricSpaceMax [EMetricSpace \u03b2] : EMetricSpace (\u03b3 \u00d7 \u03b2) :=\n  .ofT0PseudoEMetricSpace _", "start": [1096, 1], "end": [1100, 28], "kind": "commanddeclaration"}, {"full_name": "uniformity_edist", "code": "theorem uniformity_edist : \ud835\udce4 \u03b3 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b3 \u00d7 \u03b3 | edist p.1 p.2 < \u03b5 }", "start": [1103, 1], "end": [1105, 38], "kind": "commanddeclaration"}, {"full_name": "emetricSpacePi", "code": "instance emetricSpacePi [\u2200 b, EMetricSpace (\u03c0 b)] : EMetricSpace (\u2200 b, \u03c0 b) :=\n  .ofT0PseudoEMetricSpace _", "start": [1114, 1], "end": [1120, 28], "kind": "commanddeclaration"}, {"full_name": "EMetric.countable_closure_of_compact", "code": "theorem countable_closure_of_compact {s : Set \u03b3} (hs : IsCompact s) :\n    \u2203 t, t \u2286 s \u2227 t.Countable \u2227 s = closure t", "start": [1127, 1], "end": [1131, 71], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_eq_zero_iff", "code": "theorem diam_eq_zero_iff : diam s = 0 \u2194 s.Subsingleton", "start": [1138, 1], "end": [1139, 94], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_pos_iff", "code": "theorem diam_pos_iff : 0 < diam s \u2194 s.Nontrivial", "start": [1142, 1], "end": [1143, 82], "kind": "commanddeclaration"}, {"full_name": "EMetric.diam_pos_iff'", "code": "theorem diam_pos_iff' : 0 < diam s \u2194 \u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y", "start": [1145, 1], "end": [1146, 56], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.edist_mk", "code": "@[simp] theorem UniformSpace.SeparationQuotient.edist_mk [PseudoEMetricSpace X] (x y : X) :\n    @edist (UniformSpace.SeparationQuotient X) _ (Quot.mk _ x) (Quot.mk _ y) = edist x y", "start": [1163, 1], "end": [1165, 6], "kind": "commanddeclaration"}, {"full_name": "edist_ofMul", "code": "@[simp]\ntheorem edist_ofMul (a b : X) : edist (ofMul a) (ofMul b) = edist a b", "start": [1198, 1], "end": [1200, 6], "kind": "commanddeclaration"}, {"full_name": "edist_ofAdd", "code": "@[simp]\ntheorem edist_ofAdd (a b : X) : edist (ofAdd a) (ofAdd b) = edist a b", "start": [1203, 1], "end": [1205, 6], "kind": "commanddeclaration"}, {"full_name": "edist_toMul", "code": "@[simp]\ntheorem edist_toMul (a b : Additive X) : edist (toMul a) (toMul b) = edist a b", "start": [1208, 1], "end": [1210, 6], "kind": "commanddeclaration"}, {"full_name": "edist_toAdd", "code": "@[simp]\ntheorem edist_toAdd (a b : Multiplicative X) : edist (toAdd a) (toAdd b) = edist a b", "start": [1213, 1], "end": [1215, 6], "kind": "commanddeclaration"}, {"full_name": "edist_toDual", "code": "@[simp]\ntheorem edist_toDual (a b : X) : edist (toDual a) (toDual b) = edist a b", "start": [1240, 1], "end": [1242, 6], "kind": "commanddeclaration"}, {"full_name": "edist_ofDual", "code": "@[simp]\ntheorem edist_ofDual (a b : X\u1d52\u1d48) : edist (ofDual a) (ofDual b) = edist a b", "start": [1245, 1], "end": [1247, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Bornology/Constructions.lean", "imports": ["Mathlib/Topology/Bornology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.instBornology", "code": "instance Prod.instBornology : Bornology (\u03b1 \u00d7 \u03b2) where\n  cobounded' := (cobounded \u03b1).coprod (cobounded \u03b2)\n  le_cofinite' :=\n    @coprod_cofinite \u03b1 \u03b2 \u25b8 coprod_mono \u2039Bornology \u03b1\u203a.le_cofinite \u2039Bornology \u03b2\u203a.le_cofinite", "start": [26, 1], "end": [29, 91], "kind": "commanddeclaration"}, {"full_name": "Pi.instBornology", "code": "instance Pi.instBornology : Bornology (\u2200 i, \u03c0 i) where\n  cobounded' := Filter.coprod\u1d62 fun i => cobounded (\u03c0 i)\n  le_cofinite' := @coprod\u1d62_cofinite \u03b9 \u03c0 _ \u25b8 Filter.coprod\u1d62_mono fun _ => Bornology.le_cofinite _", "start": [32, 1], "end": [34, 97], "kind": "commanddeclaration"}, {"full_name": "Bornology.induced", "code": "@[reducible]\ndef Bornology.induced {\u03b1 \u03b2 : Type*} [Bornology \u03b2] (f : \u03b1 \u2192 \u03b2) : Bornology \u03b1\n    where\n  cobounded' := comap f (cobounded \u03b2)\n  le_cofinite' := (comap_mono (Bornology.le_cofinite \u03b2)).trans (comap_cofinite_le _)", "start": [37, 1], "end": [42, 85], "kind": "commanddeclaration"}, {"full_name": "Bornology.cobounded_prod", "code": "theorem cobounded_prod : cobounded (\u03b1 \u00d7 \u03b2) = (cobounded \u03b1).coprod (cobounded \u03b2)", "start": [55, 1], "end": [56, 6], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_image_fst_and_snd", "code": "theorem isBounded_image_fst_and_snd {s : Set (\u03b1 \u00d7 \u03b2)} :\n    IsBounded (Prod.fst '' s) \u2227 IsBounded (Prod.snd '' s) \u2194 IsBounded s", "start": [59, 1], "end": [61, 24], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.fst_of_prod", "code": "theorem IsBounded.fst_of_prod (h : IsBounded (s \u00d7\u02e2 t)) (ht : t.Nonempty) : IsBounded s", "start": [66, 1], "end": [67, 60], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.snd_of_prod", "code": "theorem IsBounded.snd_of_prod (h : IsBounded (s \u00d7\u02e2 t)) (hs : s.Nonempty) : IsBounded t", "start": [70, 1], "end": [71, 60], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.prod", "code": "theorem IsBounded.prod (hs : IsBounded s) (ht : IsBounded t) : IsBounded (s \u00d7\u02e2 t)", "start": [74, 1], "end": [76, 85], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_prod_of_nonempty", "code": "theorem isBounded_prod_of_nonempty (hne : Set.Nonempty (s \u00d7\u02e2 t)) :\n    IsBounded (s \u00d7\u02e2 t) \u2194 IsBounded s \u2227 IsBounded t", "start": [79, 1], "end": [81, 83], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_prod", "code": "theorem isBounded_prod : IsBounded (s \u00d7\u02e2 t) \u2194 s = \u2205 \u2228 t = \u2205 \u2228 IsBounded s \u2227 IsBounded t", "start": [84, 1], "end": [87, 94], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_prod_self", "code": "theorem isBounded_prod_self : IsBounded (s \u00d7\u02e2 s) \u2194 IsBounded s", "start": [90, 1], "end": [92, 73], "kind": "commanddeclaration"}, {"full_name": "Bornology.cobounded_pi", "code": "theorem cobounded_pi : cobounded (\u2200 i, \u03c0 i) = Filter.coprod\u1d62 fun i => cobounded (\u03c0 i)", "start": [100, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Bornology.forall_isBounded_image_eval_iff", "code": "theorem forall_isBounded_image_eval_iff {s : Set (\u2200 i, \u03c0 i)} :\n    (\u2200 i, IsBounded (eval i '' s)) \u2194 IsBounded s", "start": [104, 1], "end": [106, 25], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.pi", "code": "theorem IsBounded.pi (h : \u2200 i, IsBounded (S i)) : IsBounded (pi univ S)", "start": [109, 1], "end": [110, 84], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_pi_of_nonempty", "code": "theorem isBounded_pi_of_nonempty (hne : (pi univ S).Nonempty) :\n    IsBounded (pi univ S) \u2194 \u2200 i, IsBounded (S i)", "start": [113, 1], "end": [115, 101], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_pi", "code": "theorem isBounded_pi : IsBounded (pi univ S) \u2194 (\u2203 i, S i = \u2205) \u2228 \u2200 i, IsBounded (S i)", "start": [118, 1], "end": [123, 39], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_induced", "code": "theorem isBounded_induced {\u03b1 \u03b2 : Type*} [Bornology \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    @IsBounded \u03b1 (Bornology.induced f) s \u2194 IsBounded (f '' s)", "start": [131, 1], "end": [133, 18], "kind": "commanddeclaration"}, {"full_name": "Bornology.isBounded_image_subtype_val", "code": "theorem isBounded_image_subtype_val {p : \u03b1 \u2192 Prop} {s : Set { x // p x }} :\n    IsBounded (Subtype.val '' s) \u2194 IsBounded s", "start": [136, 1], "end": [138, 25], "kind": "commanddeclaration"}, {"full_name": "boundedSpace_induced_iff", "code": "theorem boundedSpace_induced_iff {\u03b1 \u03b2 : Type*} [Bornology \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    @BoundedSpace \u03b1 (Bornology.induced f) \u2194 IsBounded (range f)", "start": [156, 1], "end": [158, 80], "kind": "commanddeclaration"}, {"full_name": "boundedSpace_subtype_iff", "code": "theorem boundedSpace_subtype_iff {p : \u03b1 \u2192 Prop} :\n    BoundedSpace (Subtype p) \u2194 IsBounded { x | p x }", "start": [162, 1], "end": [164, 59], "kind": "commanddeclaration"}, {"full_name": "boundedSpace_val_set_iff", "code": "theorem boundedSpace_val_set_iff {s : Set \u03b1} : BoundedSpace s \u2194 IsBounded s", "start": [167, 1], "end": [168, 27], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.boundedSpace_subtype", "code": "alias \u27e8_, Bornology.IsBounded.boundedSpace_subtype\u27e9 := boundedSpace_subtype_iff", "start": [171, 1], "end": [171, 80], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Bornology.IsBounded.boundedSpace_val", "code": "alias \u27e8_, Bornology.IsBounded.boundedSpace_val\u27e9 := boundedSpace_val_set_iff", "start": [174, 1], "end": [174, 76], "kind": "stdtacticaliasaliaslr"}]}
{"path": "Mathlib/Topology/Algebra/Field.lean", "imports": ["Mathlib/Topology/Algebra/GroupWithZero.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/LocalExtr.lean", "Mathlib/FieldTheory/Subfield.lean", "Mathlib/Topology/Algebra/Ring/Basic.lean"], "premises": [{"full_name": "Filter.tendsto_cocompact_mul_left\u2080", "code": "theorem Filter.tendsto_cocompact_mul_left\u2080 [ContinuousMul K] {a : K} (ha : a \u2260 0) :\n    Filter.Tendsto (fun x : K => a * x) (Filter.cocompact K) (Filter.cocompact K)", "start": [23, 1], "end": [27, 56], "kind": "commanddeclaration"}, {"full_name": "Filter.tendsto_cocompact_mul_right\u2080", "code": "theorem Filter.tendsto_cocompact_mul_right\u2080 [ContinuousMul K] {a : K} (ha : a \u2260 0) :\n    Filter.Tendsto (fun x : K => x * a) (Filter.cocompact K) (Filter.cocompact K)", "start": [30, 1], "end": [34, 57], "kind": "commanddeclaration"}, {"full_name": "TopologicalDivisionRing", "code": "class TopologicalDivisionRing extends TopologicalRing K, HasContinuousInv\u2080 K : Prop", "start": [39, 1], "end": [41, 84], "kind": "commanddeclaration"}, {"full_name": "Subfield.topologicalClosure", "code": "def Subfield.topologicalClosure (K : Subfield \u03b1) : Subfield \u03b1 :=\n  { K.toSubring.topologicalClosure with\n    carrier := _root_.closure (K : Set \u03b1)\n    inv_mem' := fun x hx => by\n      dsimp only at hx \u22a2\n      rcases eq_or_ne x 0 with (rfl | h)\n      \u00b7 rwa [inv_zero]\n      \u00b7 rw [\u2190 @inv_coe_set \u03b1 (Subfield \u03b1) _ _ SubfieldClass.toInvMemClass K, \u2190 Set.image_inv]\n        exact mem_closure_image (continuousAt_inv\u2080 h) hx }", "start": [48, 1], "end": [59, 59], "kind": "commanddeclaration"}, {"full_name": "Subfield.le_topologicalClosure", "code": "theorem Subfield.le_topologicalClosure (s : Subfield \u03b1) : s \u2264 s.topologicalClosure", "start": [62, 1], "end": [63, 24], "kind": "commanddeclaration"}, {"full_name": "Subfield.isClosed_topologicalClosure", "code": "theorem Subfield.isClosed_topologicalClosure (s : Subfield \u03b1) :\n    IsClosed (s.topologicalClosure : Set \u03b1)", "start": [66, 1], "end": [68, 19], "kind": "commanddeclaration"}, {"full_name": "Subfield.topologicalClosure_minimal", "code": "theorem Subfield.topologicalClosure_minimal (s : Subfield \u03b1) {t : Subfield \u03b1} (h : s \u2264 t)\n    (ht : IsClosed (t : Set \u03b1)) : s.topologicalClosure \u2264 t", "start": [71, 1], "end": [73, 23], "kind": "commanddeclaration"}, {"full_name": "affineHomeomorph", "code": "@[simps]\ndef affineHomeomorph (a b : \ud835\udd5c) (h : a \u2260 0) : \ud835\udd5c \u2243\u209c \ud835\udd5c where\n  toFun x := a * x + b\n  invFun y := (y - b) / a\n  left_inv x := by\n    simp only [add_sub_cancel]\n    exact mul_div_cancel_left x h\n  right_inv y := by simp [mul_div_cancel' _ h]", "start": [89, 1], "end": [100, 47], "kind": "commanddeclaration"}, {"full_name": "IsLocalMin.inv", "code": "theorem IsLocalMin.inv {f : \u03b1 \u2192 \u03b2} {a : \u03b1} (h1 : IsLocalMin f a) (h2 : \u2200\u1da0 z in \ud835\udcdd a, 0 < f z) :\n    IsLocalMax f\u207b\u00b9 a", "start": [111, 1], "end": [113, 83], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq", "code": "theorem IsPreconnected.eq_one_or_eq_neg_one_of_sq_eq [Ring \ud835\udd5c] [NoZeroDivisors \ud835\udd5c]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hsq : EqOn (f ^ 2) 1 S) :\n    EqOn f 1 S \u2228 EqOn f (-1) S", "start": [127, 1], "end": [135, 47], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.eq_or_eq_neg_of_sq_eq", "code": "theorem IsPreconnected.eq_or_eq_neg_of_sq_eq [Field \ud835\udd5c] [HasContinuousInv\u2080 \ud835\udd5c] [ContinuousMul \ud835\udd5c]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : \u2200 {x : \u03b1}, x \u2208 S \u2192 g x \u2260 0) :\n    EqOn f g S \u2228 EqOn f (-g) S", "start": [138, 1], "end": [148, 74], "kind": "commanddeclaration"}, {"full_name": "IsPreconnected.eq_of_sq_eq", "code": "theorem IsPreconnected.eq_of_sq_eq [Field \ud835\udd5c] [HasContinuousInv\u2080 \ud835\udd5c] [ContinuousMul \ud835\udd5c]\n    (hS : IsPreconnected S) (hf : ContinuousOn f S) (hg : ContinuousOn g S)\n    (hsq : EqOn (f ^ 2) (g ^ 2) S) (hg_ne : \u2200 {x : \u03b1}, x \u2208 S \u2192 g x \u2260 0) {y : \u03b1} (hy : y \u2208 S)\n    (hy' : f y = g y) : EqOn f g S", "start": [151, 1], "end": [161, 57], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/Group.lean", "imports": ["Mathlib/Topology/Algebra/Group/Basic.lean", "Mathlib/Topology/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearOrderedAddCommGroup.topologicalAddGroup", "code": "instance (priority := 100) LinearOrderedAddCommGroup.topologicalAddGroup : TopologicalAddGroup G\n    where\n  continuous_add := by\n    refine' continuous_iff_continuousAt.2 _\n    rintro \u27e8a, b\u27e9\n    refine' LinearOrderedAddCommGroup.tendsto_nhds.2 fun \u03b5 \u03b50 => _\n    rcases dense_or_discrete 0 \u03b5 with (\u27e8\u03b4, \u03b40, \u03b4\u03b5\u27e9 | \u27e8_h\u2081, h\u2082\u27e9)\n    \u00b7 filter_upwards [(eventually_abs_sub_lt a \u03b40).prod_nhds\n          (eventually_abs_sub_lt b (sub_pos.2 \u03b4\u03b5))]\n      rintro \u27e8x, y\u27e9 \u27e8hx : |x - a| < \u03b4, hy : |y - b| < \u03b5 - \u03b4\u27e9\n      rw [add_sub_add_comm]\n      calc\n        |x - a + (y - b)| \u2264 |x - a| + |y - b| := abs_add _ _\n        _ < \u03b4 + (\u03b5 - \u03b4) := add_lt_add hx hy\n        _ = \u03b5 := add_sub_cancel'_right _ _\n    \u00b7 have h\u03b5 : \u2200 {x y}, |x - y| < \u03b5 \u2192 x = y := by\n        intro x y h\n        simpa [sub_eq_zero] using h\u2082 _ h\n      filter_upwards [(eventually_abs_sub_lt a \u03b50).prod_nhds (eventually_abs_sub_lt b \u03b50)]\n      rintro \u27e8x, y\u27e9 \u27e8hx : |x - a| < \u03b5, hy : |y - b| < \u03b5\u27e9\n      simpa [h\u03b5 hx, h\u03b5 hy]\n  continuous_neg :=\n    continuous_iff_continuousAt.2 fun a =>\n      LinearOrderedAddCommGroup.tendsto_nhds.2 fun \u03b5 \u03b50 =>\n        (eventually_abs_sub_lt a \u03b50).mono fun x hx => by rwa [neg_sub_neg, abs_sub_comm]", "start": [29, 1], "end": [55, 89], "kind": "commanddeclaration"}, {"full_name": "continuous_abs", "code": "@[continuity]\ntheorem continuous_abs : Continuous (abs : G \u2192 G)", "start": [58, 1], "end": [60, 35], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.abs", "code": "protected theorem Filter.Tendsto.abs {a : G} (h : Tendsto f l (\ud835\udcdd a)) :\n    Tendsto (fun x => |f x|) l (\ud835\udcdd |a|)", "start": [63, 1], "end": [65, 36], "kind": "commanddeclaration"}, {"full_name": "tendsto_zero_iff_abs_tendsto_zero", "code": "theorem tendsto_zero_iff_abs_tendsto_zero (f : \u03b1 \u2192 G) :\n    Tendsto f l (\ud835\udcdd 0) \u2194 Tendsto (abs \u2218 f) l (\ud835\udcdd 0)", "start": [68, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "Continuous.abs", "code": "protected theorem Continuous.abs (h : Continuous f) : Continuous fun x => |f x|", "start": [79, 1], "end": [80, 24], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.abs", "code": "protected theorem ContinuousAt.abs (h : ContinuousAt f a) : ContinuousAt (fun x => |f x|) a", "start": [83, 1], "end": [84, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.abs", "code": "protected theorem ContinuousWithinAt.abs (h : ContinuousWithinAt f s a) :\n    ContinuousWithinAt (fun x => |f x|) s a", "start": [87, 1], "end": [89, 23], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.abs", "code": "protected theorem ContinuousOn.abs (h : ContinuousOn f s) : ContinuousOn (fun x => |f x|) s", "start": [92, 1], "end": [93, 27], "kind": "commanddeclaration"}, {"full_name": "tendsto_abs_nhdsWithin_zero", "code": "theorem tendsto_abs_nhdsWithin_zero : Tendsto (abs : G \u2192 G) (\ud835\udcdd[\u2260] 0) (\ud835\udcdd[>] 0)", "start": [96, 1], "end": [98, 54], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Whiskering.lean", "imports": ["Mathlib/CategoryTheory/Functor/Category.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "Mathlib/CategoryTheory/Iso.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.whiskerLeft", "code": "@[simps]\ndef whiskerLeft (F : C \u2964 D) {G H : D \u2964 E} (\u03b1 : G \u27f6 H) :\n    F \u22d9 G \u27f6 F \u22d9 H where\n  app X := \u03b1.app (F.obj X)\n  naturality X Y f := by rw [Functor.comp_map, Functor.comp_map, \u03b1.naturality]", "start": [43, 1], "end": [50, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight", "code": "@[simps]\ndef whiskerRight {G H : C \u2964 D} (\u03b1 : G \u27f6 H) (F : D \u2964 E) :\n    G \u22d9 F \u27f6 H \u22d9 F where\n  app X := F.map (\u03b1.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, \u2190 F.map_comp, \u2190 F.map_comp, \u03b1.naturality]", "start": [54, 1], "end": [62, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskeringLeft", "code": "@[simps]\ndef whiskeringLeft : (C \u2964 D) \u2964 (D \u2964 E) \u2964 C \u2964 E where\n  obj F :=\n    { obj := fun G => F \u22d9 G\n      map := fun \u03b1 => whiskerLeft F \u03b1 }\n  map \u03c4 :=\n    { app := fun H =>\n        { app := fun c => H.map (\u03c4.app c)\n          naturality := fun X Y f => by dsimp; rw [\u2190 H.map_comp, \u2190 H.map_comp, \u2190 \u03c4.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }", "start": [68, 1], "end": [82, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskeringRight", "code": "@[simps]\ndef whiskeringRight : (D \u2964 E) \u2964 (C \u2964 D) \u2964 C \u2964 E where\n  obj H :=\n    { obj := fun F => F \u22d9 H\n      map := fun \u03b1 => whiskerRight \u03b1 H }\n  map \u03c4 :=\n    { app := fun F =>\n        { app := fun c => \u03c4.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [\u03c4.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [\u2190 NatTrans.naturality] }", "start": [88, 1], "end": [102, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.faithful_whiskeringRight_obj", "code": "instance faithful_whiskeringRight_obj {F : D \u2964 E} [Faithful F] :\n    Faithful ((whiskeringRight C D E).obj F) where\n  map_injective h\u03b1\u03b2 := by\n    ext X\n    exact (F.map_injective <| congr_fun (congr_arg NatTrans.app h\u03b1\u03b2) X)", "start": [110, 1], "end": [114, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_id", "code": "@[simp]\ntheorem whiskerLeft_id (F : C \u2964 D) {G : D \u2964 E} :\n    whiskerLeft F (NatTrans.id G) = NatTrans.id (F.comp G)", "start": [117, 1], "end": [120, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_id'", "code": "@[simp]\ntheorem whiskerLeft_id' (F : C \u2964 D) {G : D \u2964 E} : whiskerLeft F (\ud835\udfd9 G) = \ud835\udfd9 (F.comp G)", "start": [123, 1], "end": [125, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_id", "code": "@[simp]\ntheorem whiskerRight_id {G : C \u2964 D} (F : D \u2964 E) :\n    whiskerRight (NatTrans.id G) F = NatTrans.id (G.comp F)", "start": [128, 1], "end": [131, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_id'", "code": "@[simp]\ntheorem whiskerRight_id' {G : C \u2964 D} (F : D \u2964 E) : whiskerRight (\ud835\udfd9 G) F = \ud835\udfd9 (G.comp F)", "start": [134, 1], "end": [136, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_comp", "code": "@[simp]\ntheorem whiskerLeft_comp (F : C \u2964 D) {G H K : D \u2964 E} (\u03b1 : G \u27f6 H) (\u03b2 : H \u27f6 K) :\n    whiskerLeft F (\u03b1 \u226b \u03b2) = whiskerLeft F \u03b1 \u226b whiskerLeft F \u03b2", "start": [139, 1], "end": [142, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_comp", "code": "@[simp]\ntheorem whiskerRight_comp {G H K : C \u2964 D} (\u03b1 : G \u27f6 H) (\u03b2 : H \u27f6 K) (F : D \u2964 E) :\n    whiskerRight (\u03b1 \u226b \u03b2) F = whiskerRight \u03b1 F \u226b whiskerRight \u03b2 F", "start": [145, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerLeft", "code": "def isoWhiskerLeft (F : C \u2964 D) {G H : D \u2964 E} (\u03b1 : G \u2245 H) : F \u22d9 G \u2245 F \u22d9 H :=\n  ((whiskeringLeft C D E).obj F).mapIso \u03b1", "start": [151, 1], "end": [155, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerLeft_hom", "code": "@[simp]\ntheorem isoWhiskerLeft_hom (F : C \u2964 D) {G H : D \u2964 E} (\u03b1 : G \u2245 H) :\n    (isoWhiskerLeft F \u03b1).hom = whiskerLeft F \u03b1.hom", "start": [158, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerLeft_inv", "code": "@[simp]\ntheorem isoWhiskerLeft_inv (F : C \u2964 D) {G H : D \u2964 E} (\u03b1 : G \u2245 H) :\n    (isoWhiskerLeft F \u03b1).inv = whiskerLeft F \u03b1.inv", "start": [164, 1], "end": [167, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerRight", "code": "def isoWhiskerRight {G H : C \u2964 D} (\u03b1 : G \u2245 H) (F : D \u2964 E) : G \u22d9 F \u2245 H \u22d9 F :=\n  ((whiskeringRight C D E).obj F).mapIso \u03b1", "start": [170, 1], "end": [174, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerRight_hom", "code": "@[simp]\ntheorem isoWhiskerRight_hom {G H : C \u2964 D} (\u03b1 : G \u2245 H) (F : D \u2964 E) :\n    (isoWhiskerRight \u03b1 F).hom = whiskerRight \u03b1.hom F", "start": [177, 1], "end": [180, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoWhiskerRight_inv", "code": "@[simp]\ntheorem isoWhiskerRight_inv {G H : C \u2964 D} (\u03b1 : G \u2245 H) (F : D \u2964 E) :\n    (isoWhiskerRight \u03b1 F).inv = whiskerRight \u03b1.inv F", "start": [183, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_whiskerLeft", "code": "instance isIso_whiskerLeft (F : C \u2964 D) {G H : D \u2964 E} (\u03b1 : G \u27f6 H) [IsIso \u03b1] :\n    IsIso (whiskerLeft F \u03b1) :=\n  IsIso.of_iso (isoWhiskerLeft F (asIso \u03b1))", "start": [189, 1], "end": [191, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_whiskerRight", "code": "instance isIso_whiskerRight {G H : C \u2964 D} (\u03b1 : G \u27f6 H) (F : D \u2964 E) [IsIso \u03b1] :\n    IsIso (whiskerRight \u03b1 F) :=\n  IsIso.of_iso (isoWhiskerRight (asIso \u03b1) F)", "start": [194, 1], "end": [196, 45], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerLeft_twice", "code": "@[simp]\ntheorem whiskerLeft_twice (F : B \u2964 C) (G : C \u2964 D) {H K : D \u2964 E} (\u03b1 : H \u27f6 K) :\n    whiskerLeft F (whiskerLeft G \u03b1) = whiskerLeft (F \u22d9 G) \u03b1", "start": [205, 1], "end": [208, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_twice", "code": "@[simp]\ntheorem whiskerRight_twice {H K : B \u2964 C} (F : C \u2964 D) (G : D \u2964 E) (\u03b1 : H \u27f6 K) :\n    whiskerRight (whiskerRight \u03b1 F) G = whiskerRight \u03b1 (F \u22d9 G)", "start": [211, 1], "end": [214, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.whiskerRight_left", "code": "theorem whiskerRight_left (F : B \u2964 C) {G H : C \u2964 D} (\u03b1 : G \u27f6 H) (K : D \u2964 E) :\n    whiskerRight (whiskerLeft F \u03b1) K = whiskerLeft F (whiskerRight \u03b1 K)", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftUnitor", "code": "@[simps]\ndef leftUnitor (F : A \u2964 B) :\n    \ud835\udfed A \u22d9 F \u2245 F where\n  hom := { app := fun X => \ud835\udfd9 (F.obj X) }\n  inv := { app := fun X => \ud835\udfd9 (F.obj X) }", "start": [232, 1], "end": [238, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightUnitor", "code": "@[simps]\ndef rightUnitor (F : A \u2964 B) :\n    F \u22d9 \ud835\udfed B \u2245 F where\n  hom := { app := fun X => \ud835\udfd9 (F.obj X) }\n  inv := { app := fun X => \ud835\udfd9 (F.obj X) }", "start": [243, 1], "end": [249, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.associator", "code": "@[simps]\ndef associator (F : A \u2964 B) (G : B \u2964 C) (H : C \u2964 D) :\n    (F \u22d9 G) \u22d9 H \u2245 F \u22d9 G \u22d9 H where\n  hom := { app := fun _ => \ud835\udfd9 _ }\n  inv := { app := fun _ => \ud835\udfd9 _ }", "start": [258, 1], "end": [267, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.assoc", "code": "protected theorem assoc (F : A \u2964 B) (G : B \u2964 C) (H : C \u2964 D) : (F \u22d9 G) \u22d9 H = F \u22d9 G \u22d9 H", "start": [272, 1], "end": [273, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.triangle", "code": "theorem triangle (F : A \u2964 B) (G : B \u2964 C) :\n    (associator F (\ud835\udfed B) G).hom \u226b whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G", "start": [276, 1], "end": [278, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.pentagon", "code": "theorem pentagon :\n    whiskerRight (associator F G H).hom K \u226b\n        (associator F (G \u22d9 H) K).hom \u226b whiskerLeft F (associator G H K).hom =\n      (associator (F \u22d9 G) H K).hom \u226b (associator F G (H \u22d9 K)).hom", "start": [286, 1], "end": [289, 82], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Tactic/CategoryTheory/Slice.lean", "imports": ["Mathlib/CategoryTheory/Category/Basic.lean", "Mathlib/Tactic/Conv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "evalSlice", "code": "def evalSlice (a b : Nat) : TacticM Unit := do\n  let _ \u2190 iterateUntilFailureWithResults do\n    evalTactic (\u2190 `(conv| rw [Category.assoc]))\n  iterateRange (a - 1) (a - 1) do\n      evalTactic (\u2190 `(conv| congr))\n      evalTactic (\u2190 `(tactic| rotate_left))\n  let k \u2190 iterateUntilFailureCount\n    <| evalTactic (\u2190 `(conv| rw [\u2190Category.assoc]))\n  let c := k+1+a-b\n  iterateRange c c <| evalTactic (\u2190 `(conv| congr))\n  let _ \u2190 iterateUntilFailureWithResults do\n    evalTactic (\u2190 `(conv| rw [Category.assoc]))", "start": [35, 1], "end": [56, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/EssentialImage.lean", "imports": ["Mathlib/CategoryTheory/NatIso.lean", "Mathlib/CategoryTheory/FullSubcategory.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.essImage", "code": "def essImage (F : C \u2964 D) : Set D := fun Y => \u2203 X : C, Nonempty (F.obj X \u2245 Y)", "start": [36, 1], "end": [41, 77], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage.witness", "code": "def essImage.witness {Y : D} (h : Y \u2208 F.essImage) : C :=\n  h.choose", "start": [44, 1], "end": [46, 11], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage.getIso", "code": "def essImage.getIso {Y : D} (h : Y \u2208 F.essImage) : F.obj (essImage.witness h) \u2245 Y :=\n  Classical.choice h.choose_spec", "start": [49, 1], "end": [52, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage.ofIso", "code": "theorem essImage.ofIso {Y Y' : D} (h : Y \u2245 Y') (hY : Y \u2208 essImage F) : Y' \u2208 essImage F", "start": [55, 1], "end": [57, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage.ofNatIso", "code": "theorem essImage.ofNatIso {F' : C \u2964 D} (h : F \u2245 F') {Y : D} (hY : Y \u2208 essImage F) :\n    Y \u2208 essImage F'", "start": [60, 1], "end": [65, 58], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImage_eq_of_natIso", "code": "theorem essImage_eq_of_natIso {F' : C \u2964 D} (h : F \u2245 F') : essImage F = essImage F'", "start": [68, 1], "end": [70, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.obj_mem_essImage", "code": "theorem obj_mem_essImage (F : D \u2964 C) (Y : D) : F.obj Y \u2208 essImage F", "start": [73, 1], "end": [75, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.EssImageSubcategory", "code": "def EssImageSubcategory (F : C \u2964 D) :=\n  FullSubcategory F.essImage", "start": [78, 1], "end": [81, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.essImageInclusion", "code": "@[simps!]\ndef essImageInclusion (F : C \u2964 D) : F.EssImageSubcategory \u2964 D :=\n  fullSubcategoryInclusion _", "start": [88, 1], "end": [91, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEssImage", "code": "@[simps!]\ndef toEssImage (F : C \u2964 D) : C \u2964 F.EssImageSubcategory :=\n  FullSubcategory.lift _ F (obj_mem_essImage _)", "start": [104, 1], "end": [110, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.toEssImageCompEssentialImageInclusion", "code": "@[simps!]\ndef toEssImageCompEssentialImageInclusion (F : C \u2964 D) : F.toEssImage \u22d9 F.essImageInclusion \u2245 F :=\n  FullSubcategory.lift_comp_inclusion _ _ _", "start": [115, 1], "end": [120, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EssSurj", "code": "class EssSurj (F : C \u2964 D) : Prop where\n  \n  mem_essImage (Y : D) : Y \u2208 F.essImage", "start": [127, 1], "end": [134, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.EssSurj.toEssImage", "code": "instance EssSurj.toEssImage : EssSurj F.toEssImage where\n  mem_essImage := fun \u27e8_, hY\u27e9 =>\n    \u27e8_, \u27e8\u27e8_, _, hY.getIso.hom_inv_id, hY.getIso.inv_hom_id\u27e9\u27e9\u27e9", "start": [137, 1], "end": [139, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.objPreimage", "code": "def Functor.objPreimage (Y : D) : C :=\n  essImage.witness (@EssSurj.mem_essImage _ _ _ _ F _ Y)", "start": [143, 1], "end": [147, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.objObjPreimageIso", "code": "def Functor.objObjPreimageIso (Y : D) : F.obj (F.objPreimage Y) \u2245 Y :=\n  Functor.essImage.getIso _", "start": [150, 1], "end": [153, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Faithful.toEssImage", "code": "instance Faithful.toEssImage (F : C \u2964 D) [Faithful F] : Faithful F.toEssImage :=\n  Faithful.of_comp_iso F.toEssImageCompEssentialImageInclusion", "start": [156, 1], "end": [158, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Full.toEssImage", "code": "instance Full.toEssImage (F : C \u2964 D) [Full F] : Full F.toEssImage :=\n  haveI := Full.ofIso F.toEssImageCompEssentialImageInclusion.symm\n  Full.ofCompFaithful F.toEssImage F.essImageInclusion", "start": [161, 1], "end": [164, 55], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.instEssSurjId", "code": "instance instEssSurjId : EssSurj (\ud835\udfed C) where\n  mem_essImage Y := \u27e8Y, \u27e8Iso.refl _\u27e9\u27e9", "start": [167, 1], "end": [168, 38], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.map_essSurj", "code": "theorem Iso.map_essSurj {F G : C \u2964 D} [EssSurj F] (\u03b1 : F \u2245 G) : EssSurj G where", "start": [170, 1], "end": [171, 73], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "imports": ["Mathlib/LinearAlgebra/StdBasis.lean", "Mathlib/LinearAlgebra/DFinsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.linearIndependent_single", "code": "theorem linearIndependent_single {\u03c6 : \u03b9 \u2192 Type*} {f : \u2200 \u03b9, \u03c6 \u03b9 \u2192 M}\n    (hf : \u2200 i, LinearIndependent R (f i)) :\n    LinearIndependent R fun ix : \u03a3i, \u03c6 i => single ix.1 (f ix.1 ix.2)", "start": [36, 1], "end": [53, 50], "kind": "commanddeclaration"}, {"full_name": "Finsupp.basis", "code": "protected def basis {\u03c6 : \u03b9 \u2192 Type*} (b : \u2200 i, Basis (\u03c6 i) R M) : Basis (\u03a3i, \u03c6 i) R (\u03b9 \u2192\u2080 M) :=\n  Basis.ofRepr\n    { toFun := fun g =>\n        { toFun := fun ix => (b ix.1).repr (g ix.1) ix.2\n          support := g.support.sigma fun i => ((b i).repr (g i)).support\n          mem_support_toFun := fun ix => by\n            simp only [Finset.mem_sigma, mem_support_iff, and_iff_right_iff_imp, Ne.def]\n            intro b hg\n            simp [hg] at b }\n      invFun := fun g =>\n        { toFun := fun i =>\n            (b i).repr.symm (g.comapDomain _ (Set.injOn_of_injective sigma_mk_injective _))\n          support := g.support.image Sigma.fst\n          mem_support_toFun := fun i => by\n            rw [Ne.def, \u2190 (b i).repr.injective.eq_iff, (b i).repr.apply_symm_apply, FunLike.ext_iff]\n            simp only [exists_prop, LinearEquiv.map_zero, comapDomain_apply, zero_apply,\n              exists_and_right, mem_support_iff, exists_eq_right, Sigma.exists, Finset.mem_image,\n              not_forall] }\n      left_inv := fun g => by\n        ext i\n        rw [\u2190 (b i).repr.injective.eq_iff]\n        ext x\n        simp only [coe_mk, LinearEquiv.apply_symm_apply, comapDomain_apply]\n      right_inv := fun g => by\n        ext \u27e8i, x\u27e9\n        simp only [coe_mk, LinearEquiv.apply_symm_apply, comapDomain_apply]\n      map_add' := fun g h => by\n        ext \u27e8i, x\u27e9\n        simp only [coe_mk, add_apply, LinearEquiv.map_add]\n      map_smul' := fun c h => by\n        ext \u27e8i, x\u27e9\n        simp only [coe_mk, smul_apply, LinearEquiv.map_smul, RingHom.id_apply] }", "start": [67, 1], "end": [99, 81], "kind": "commanddeclaration"}, {"full_name": "Finsupp.basis_repr", "code": "@[simp]\ntheorem basis_repr {\u03c6 : \u03b9 \u2192 Type*} (b : \u2200 i, Basis (\u03c6 i) R M) (g : \u03b9 \u2192\u2080 M) (ix) :\n    (Finsupp.basis b).repr g ix = (b ix.1).repr (g ix.1) ix.2", "start": [102, 1], "end": [105, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_basis", "code": "@[simp]\ntheorem coe_basis {\u03c6 : \u03b9 \u2192 Type*} (b : \u2200 i, Basis (\u03c6 i) R M) :\n    \u21d1(Finsupp.basis b) = fun ix : \u03a3i, \u03c6 i => single ix.1 (b ix.1 ix.2)", "start": [108, 1], "end": [122, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.basisSingleOne", "code": "@[simps]\nprotected def basisSingleOne : Basis \u03b9 R (\u03b9 \u2192\u2080 R) :=\n  Basis.ofRepr (LinearEquiv.refl _ _)", "start": [125, 1], "end": [128, 38], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_basisSingleOne", "code": "@[simp]\ntheorem coe_basisSingleOne : (Finsupp.basisSingleOne : \u03b9 \u2192 \u03b9 \u2192\u2080 R) = fun i => Finsupp.single i 1", "start": [131, 1], "end": [133, 45], "kind": "commanddeclaration"}, {"full_name": "DFinsupp.basis", "code": "noncomputable def basis {\u03b7 : \u03b9 \u2192 Type*} (b : \u2200 i, Basis (\u03b7 i) R (M i)) :\n    Basis (\u03a3i, \u03b7 i) R (\u03a0\u2080 i, M i) :=\n  .ofRepr\n    ((mapRange.linearEquiv fun i => (b i).repr).trans (sigmaFinsuppLequivDFinsupp R).symm)", "start": [144, 1], "end": [150, 91], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_single_ite", "code": "theorem _root_.Finset.sum_single_ite (a : R) (i : n) :\n    (Finset.univ.sum fun x : n => Finsupp.single x (ite (i = x) a 0)) = Finsupp.single i a", "start": [168, 1], "end": [180, 13], "kind": "commanddeclaration"}, {"full_name": "Finset.sum_univ_ite", "code": "@[simp]\ntheorem _root_.Finset.sum_univ_ite (b : n \u2192 M) (i : n) :\n    (Finset.sum Finset.univ fun (x : n) => (if i = x then (1:R) else 0) \u2022 b x) = b i", "start": [184, 1], "end": [187, 90], "kind": "commanddeclaration"}, {"full_name": "Basis.equivFun_symm_stdBasis", "code": "theorem equivFun_symm_stdBasis (b : Basis n R M) (i : n) :\n    b.equivFun.symm (LinearMap.stdBasis R (fun _ => R) i 1) = b i", "start": [189, 1], "end": [191, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "imports": ["Mathlib/LinearAlgebra/DirectSum/TensorProduct.lean", "Mathlib/Algebra/DirectSum/Finsupp.lean", "Mathlib/LinearAlgebra/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "finsuppTensorFinsupp", "code": "noncomputable def finsuppTensorFinsupp (R M N \u03b9 \u03ba : Sort _) [CommRing R] [AddCommGroup M]\n    [Module R M] [AddCommGroup N] [Module R N] : (\u03b9 \u2192\u2080 M) \u2297[R] (\u03ba \u2192\u2080 N) \u2243\u2097[R] \u03b9 \u00d7 \u03ba \u2192\u2080 M \u2297[R] N :=\n  TensorProduct.congr (finsuppLEquivDirectSum R M \u03b9) (finsuppLEquivDirectSum R N \u03ba) \u226a\u226b\u2097\n    ((TensorProduct.directSum R (fun _ : \u03b9 => M) fun _ : \u03ba => N) \u226a\u226b\u2097\n      (finsuppLEquivDirectSum R (M \u2297[R] N) (\u03b9 \u00d7 \u03ba)).symm)", "start": [38, 1], "end": [43, 58], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp_single", "code": "@[simp]\ntheorem finsuppTensorFinsupp_single (R M N \u03b9 \u03ba : Sort _) [CommRing R] [AddCommGroup M] [Module R M]\n    [AddCommGroup N] [Module R N] (i : \u03b9) (m : M) (k : \u03ba) (n : N) :\n    finsuppTensorFinsupp R M N \u03b9 \u03ba (Finsupp.single i m \u2297\u209c Finsupp.single k n) =\n      Finsupp.single (i, k) (m \u2297\u209c n)", "start": [46, 1], "end": [51, 43], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp_apply", "code": "@[simp]\ntheorem finsuppTensorFinsupp_apply (R M N \u03b9 \u03ba : Sort _) [CommRing R] [AddCommGroup M] [Module R M]\n    [AddCommGroup N] [Module R N] (f : \u03b9 \u2192\u2080 M) (g : \u03ba \u2192\u2080 N) (i : \u03b9) (k : \u03ba) :\n    finsuppTensorFinsupp R M N \u03b9 \u03ba (f \u2297\u209c g) (i, k) = f i \u2297\u209c g k", "start": [54, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp_symm_single", "code": "@[simp]\ntheorem finsuppTensorFinsupp_symm_single (R M N \u03b9 \u03ba : Sort _) [CommRing R] [AddCommGroup M]\n    [Module R M] [AddCommGroup N] [Module R N] (i : \u03b9 \u00d7 \u03ba) (m : M) (n : N) :\n    (finsuppTensorFinsupp R M N \u03b9 \u03ba).symm (Finsupp.single i (m \u2297\u209c n)) =\n      Finsupp.single i.1 m \u2297\u209c Finsupp.single i.2 n", "start": [77, 1], "end": [83, 89], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp'", "code": "def finsuppTensorFinsupp' : (\u03b1 \u2192\u2080 S) \u2297[S] (\u03b2 \u2192\u2080 S) \u2243\u2097[S] \u03b1 \u00d7 \u03b2 \u2192\u2080 S :=\n  (finsuppTensorFinsupp S S S \u03b1 \u03b2).trans (Finsupp.lcongr (Equiv.refl _) (TensorProduct.lid S S))", "start": [88, 1], "end": [90, 97], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp'_apply_apply", "code": "@[simp]\ntheorem finsuppTensorFinsupp'_apply_apply (f : \u03b1 \u2192\u2080 S) (g : \u03b2 \u2192\u2080 S) (a : \u03b1) (b : \u03b2) :\n    finsuppTensorFinsupp' S \u03b1 \u03b2 (f \u2297\u209c[S] g) (a, b) = f a * g b", "start": [93, 1], "end": [95, 98], "kind": "commanddeclaration"}, {"full_name": "finsuppTensorFinsupp'_single_tmul_single", "code": "@[simp]\ntheorem finsuppTensorFinsupp'_single_tmul_single (a : \u03b1) (b : \u03b2) (r\u2081 r\u2082 : S) :\n    finsuppTensorFinsupp' S \u03b1 \u03b2 (Finsupp.single a r\u2081 \u2297\u209c[S] Finsupp.single b r\u2082) =\n      Finsupp.single (a, b) (r\u2081 * r\u2082)", "start": [98, 1], "end": [104, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Finsupp/Multiset.lean", "imports": ["Mathlib/Data/Finsupp/Basic.lean", "Mathlib/Data/Finsupp/Order.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Finsupp.toMultiset", "code": "def toMultiset : (\u03b1 \u2192\u2080 \u2115) \u2192+ Multiset \u03b1 where\n  toFun f := Finsupp.sum f fun a n => n \u2022 {a}\n  map_add' _f _g := sum_add_index' (h := fun a n => n \u2022 ({a} : Multiset \u03b1))\n    (fun _ \u21a6 zero_nsmul _) (fun _ \u21a6 add_nsmul _)\n  map_zero' := sum_zero_index", "start": [28, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_zero", "code": "theorem toMultiset_zero : toMultiset (0 : \u03b1 \u2192\u2080 \u2115) = 0", "start": [41, 1], "end": [42, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_add", "code": "theorem toMultiset_add (m n : \u03b1 \u2192\u2080 \u2115) : toMultiset (m + n) = toMultiset m + toMultiset n", "start": [45, 1], "end": [46, 25], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_apply", "code": "theorem toMultiset_apply (f : \u03b1 \u2192\u2080 \u2115) : toMultiset f = f.sum fun a n => n \u2022 {a}", "start": [49, 1], "end": [50, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_single", "code": "@[simp]\ntheorem toMultiset_single (a : \u03b1) (n : \u2115) : toMultiset (single a n) = n \u2022 {a}", "start": [53, 1], "end": [55, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_sum", "code": "theorem toMultiset_sum {f : \u03b9 \u2192 \u03b1 \u2192\u2080 \u2115} (s : Finset \u03b9) :\n    Finsupp.toMultiset (\u2211 i in s, f i) = \u2211 i in s, Finsupp.toMultiset (f i)", "start": [58, 1], "end": [60, 33], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_sum_single", "code": "theorem toMultiset_sum_single (s : Finset \u03b9) (n : \u2115) :\n    Finsupp.toMultiset (\u2211 i in s, single i n) = n \u2022 s.val", "start": [63, 1], "end": [65, 89], "kind": "commanddeclaration"}, {"full_name": "Finsupp.card_toMultiset", "code": "theorem card_toMultiset (f : \u03b1 \u2192\u2080 \u2115) : Multiset.card (toMultiset f) = f.sum fun _ => id", "start": [68, 1], "end": [69, 60], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_map", "code": "theorem toMultiset_map (f : \u03b1 \u2192\u2080 \u2115) (g : \u03b1 \u2192 \u03b2) :\n    f.toMultiset.map g = toMultiset (f.mapDomain g)", "start": [72, 1], "end": [80, 8], "kind": "commanddeclaration"}, {"full_name": "Finsupp.prod_toMultiset", "code": "@[to_additive (attr := simp)]\ntheorem prod_toMultiset [CommMonoid \u03b1] (f : \u03b1 \u2192\u2080 \u2115) :\n    f.toMultiset.prod = f.prod fun a n => a ^ n", "start": [83, 1], "end": [91, 23], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toFinset_toMultiset", "code": "@[simp]\ntheorem toFinset_toMultiset [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 \u2115) : f.toMultiset.toFinset = f.support", "start": [94, 1], "end": [102, 41], "kind": "commanddeclaration"}, {"full_name": "Finsupp.count_toMultiset", "code": "@[simp]\ntheorem count_toMultiset [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 \u2115) (a : \u03b1) : (toMultiset f).count a = f a", "start": [105, 1], "end": [115, 62], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_sup", "code": "theorem toMultiset_sup [DecidableEq \u03b1] (f g : \u03b1 \u2192\u2080 \u2115) :\n    toMultiset (f \u2294 g) = toMultiset f \u222a toMultiset g", "start": [118, 1], "end": [121, 90], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_inf", "code": "theorem toMultiset_inf [DecidableEq \u03b1] (f g : \u03b1 \u2192\u2080 \u2115) :\n    toMultiset (f \u2293 g) = toMultiset f \u2229 toMultiset g", "start": [123, 1], "end": [126, 90], "kind": "commanddeclaration"}, {"full_name": "Finsupp.mem_toMultiset", "code": "@[simp]\ntheorem mem_toMultiset (f : \u03b1 \u2192\u2080 \u2115) (i : \u03b1) : i \u2208 toMultiset f \u2194 i \u2208 f.support", "start": [128, 1], "end": [131, 83], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp", "code": "@[simps symm_apply]\ndef toFinsupp : Multiset \u03b1 \u2243+ (\u03b1 \u2192\u2080 \u2115) where\n  toFun s := \u27e8s.toFinset, fun a => s.count a, fun a => by simp\u27e9\n  invFun f := Finsupp.toMultiset f\n  map_add' s t := Finsupp.ext <| fun _ => count_add _ _ _\n  right_inv f :=\n    Finsupp.ext fun a => by\n      simp only [Finsupp.toMultiset_apply, Finsupp.sum, Multiset.count_sum',\n        Multiset.count_singleton, mul_boole, Finsupp.coe_mk, Finsupp.mem_support_iff,\n        Multiset.count_nsmul, Finset.sum_ite_eq, ite_not, ite_eq_right_iff]\n      exact Eq.symm\n  left_inv s := by simp only [Finsupp.toMultiset_apply, Finsupp.sum, Finsupp.coe_mk,\n    Multiset.toFinset_sum_count_nsmul_eq]", "start": [140, 1], "end": [154, 42], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_support", "code": "@[simp]\ntheorem toFinsupp_support (s : Multiset \u03b1) : s.toFinsupp.support = s.toFinset", "start": [157, 1], "end": [158, 85], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_apply", "code": "@[simp]\ntheorem toFinsupp_apply (s : Multiset \u03b1) (a : \u03b1) : toFinsupp s a = s.count a", "start": [161, 1], "end": [162, 84], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_zero", "code": "theorem toFinsupp_zero : toFinsupp (0 : Multiset \u03b1) = 0", "start": [165, 1], "end": [165, 77], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_add", "code": "theorem toFinsupp_add (s t : Multiset \u03b1) : toFinsupp (s + t) = toFinsupp s + toFinsupp t", "start": [168, 1], "end": [169, 24], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_singleton", "code": "@[simp]\ntheorem toFinsupp_singleton (a : \u03b1) : toFinsupp ({a} : Multiset \u03b1) = Finsupp.single a 1", "start": [172, 1], "end": [174, 94], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_toMultiset", "code": "@[simp]\ntheorem toFinsupp_toMultiset (s : Multiset \u03b1) : Finsupp.toMultiset (toFinsupp s) = s", "start": [177, 1], "end": [179, 40], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_eq_iff", "code": "theorem toFinsupp_eq_iff {s : Multiset \u03b1} {f : \u03b1 \u2192\u2080 \u2115} :\n    toFinsupp s = f \u2194 s = Finsupp.toMultiset f", "start": [182, 1], "end": [184, 45], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_union", "code": "theorem toFinsupp_union (s t : Multiset \u03b1) : toFinsupp (s \u222a t) = toFinsupp s \u2294 toFinsupp t", "start": [187, 1], "end": [189, 20], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_inter", "code": "theorem toFinsupp_inter (s t : Multiset \u03b1) : toFinsupp (s \u2229 t) = toFinsupp s \u2293 toFinsupp t", "start": [191, 1], "end": [193, 20], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_toFinsupp", "code": "@[simp]\ntheorem Finsupp.toMultiset_toFinsupp [DecidableEq \u03b1] (f : \u03b1 \u2192\u2080 \u2115) :\n    Multiset.toFinsupp (Finsupp.toMultiset f) = f", "start": [197, 1], "end": [200, 40], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_eq_iff", "code": "theorem Finsupp.toMultiset_eq_iff [DecidableEq \u03b1] {f : \u03b1 \u2192\u2080 \u2115} {s : Multiset \u03b1}:\n    Finsupp.toMultiset f = s \u2194 f = Multiset.toFinsupp s", "start": [203, 1], "end": [205, 35], "kind": "commanddeclaration"}, {"full_name": "Finsupp.orderIsoMultiset", "code": "def orderIsoMultiset [DecidableEq \u03b9] : (\u03b9 \u2192\u2080 \u2115) \u2243o Multiset \u03b9 where\n  toEquiv := Multiset.toFinsupp.symm.toEquiv\n  map_rel_iff' {f g} := by simp [le_def, Multiset.le_iff_count]", "start": [210, 1], "end": [213, 64], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_orderIsoMultiset", "code": "@[simp]\ntheorem coe_orderIsoMultiset [DecidableEq \u03b9] : \u21d1(@orderIsoMultiset \u03b9 _) = toMultiset", "start": [216, 1], "end": [218, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.coe_orderIsoMultiset_symm", "code": "@[simp]\ntheorem coe_orderIsoMultiset_symm [DecidableEq \u03b9] :\n    \u21d1(@orderIsoMultiset \u03b9).symm = Multiset.toFinsupp", "start": [221, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "Finsupp.toMultiset_strictMono", "code": "theorem toMultiset_strictMono : StrictMono (@toMultiset \u03b9)", "start": [227, 1], "end": [228, 56], "kind": "commanddeclaration"}, {"full_name": "Finsupp.sum_id_lt_of_lt", "code": "theorem sum_id_lt_of_lt (m n : \u03b9 \u2192\u2080 \u2115) (h : m < n) : (m.sum fun _ => id) < n.sum fun _ => id", "start": [231, 1], "end": [234, 32], "kind": "commanddeclaration"}, {"full_name": "Finsupp.lt_wf", "code": "theorem lt_wf : WellFounded (@LT.lt (\u03b9 \u2192\u2080 \u2115) _)", "start": [239, 1], "end": [241, 71], "kind": "commanddeclaration"}, {"full_name": "Multiset.toFinsupp_strictMono", "code": "theorem Multiset.toFinsupp_strictMono [DecidableEq \u03b9] : StrictMono (@Multiset.toFinsupp \u03b9 _)", "start": [251, 1], "end": [252, 48], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/BigOperators/Associated.lean", "imports": ["Mathlib/Algebra/Associated.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prime.exists_mem_multiset_dvd", "code": "theorem exists_mem_multiset_dvd {s : Multiset \u03b1} : p \u2223 s.prod \u2192 \u2203 a \u2208 s, p \u2223 a", "start": [31, 1], "end": [38, 43], "kind": "commanddeclaration"}, {"full_name": "Prime.exists_mem_multiset_map_dvd", "code": "theorem exists_mem_multiset_map_dvd {s : Multiset \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    p \u2223 (s.map f).prod \u2192 \u2203 a \u2208 s, p \u2223 f a", "start": [41, 1], "end": [44, 33], "kind": "commanddeclaration"}, {"full_name": "Prime.exists_mem_finset_dvd", "code": "theorem exists_mem_finset_dvd {s : Finset \u03b2} {f : \u03b2 \u2192 \u03b1} : p \u2223 s.prod f \u2192 \u2203 i \u2208 s, p \u2223 f i", "start": [47, 1], "end": [48, 33], "kind": "commanddeclaration"}, {"full_name": "Prod.associated_iff", "code": "theorem Prod.associated_iff {M N : Type*} [Monoid M] [Monoid N] {x z : M \u00d7 N} :\n    x ~\u1d64 z \u2194 x.1 ~\u1d64 z.1 \u2227 x.2 ~\u1d64 z.2", "start": [53, 1], "end": [58, 80], "kind": "commanddeclaration"}, {"full_name": "Associated.prod", "code": "theorem Associated.prod {M : Type*} [CommMonoid M] {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 M)\n    (g : \u03b9 \u2192 M) (h : \u2200 i, i \u2208 s \u2192 (f i) ~\u1d64 (g i)) : (\u220f i in s, f i) ~\u1d64 (\u220f i in s, g i)", "start": [60, 1], "end": [71, 58], "kind": "commanddeclaration"}, {"full_name": "exists_associated_mem_of_dvd_prod", "code": "theorem exists_associated_mem_of_dvd_prod [CancelCommMonoidWithZero \u03b1] {p : \u03b1} (hp : Prime p)\n    {s : Multiset \u03b1} : (\u2200 r \u2208 s, Prime r) \u2192 p \u2223 s.prod \u2192 \u2203 q \u2208 s, p ~\u1d64 q", "start": [73, 1], "end": [81, 55], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_primes_dvd", "code": "theorem Multiset.prod_primes_dvd [CancelCommMonoidWithZero \u03b1]\n    [\u2200 a : \u03b1, DecidablePred (Associated a)] {s : Multiset \u03b1} (n : \u03b1) (h : \u2200 a \u2208 s, Prime a)\n    (div : \u2200 a \u2208 s, a \u2223 n) (uniq : \u2200 a, s.countP (Associated a) \u2264 1) : s.prod \u2223 n", "start": [84, 1], "end": [102, 41], "kind": "commanddeclaration"}, {"full_name": "Finset.prod_primes_dvd", "code": "theorem Finset.prod_primes_dvd [CancelCommMonoidWithZero \u03b1] [Unique \u03b1\u02e3] {s : Finset \u03b1} (n : \u03b1)\n    (h : \u2200 a \u2208 s, Prime a) (div : \u2200 a \u2208 s, a \u2223 n) : (\u220f p in s, p) \u2223 n", "start": [105, 1], "end": [120, 25], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_mk", "code": "theorem prod_mk {p : Multiset \u03b1} : (p.map Associates.mk).prod = Associates.mk p.prod", "start": [129, 1], "end": [130, 85], "kind": "commanddeclaration"}, {"full_name": "Associates.finset_prod_mk", "code": "theorem finset_prod_mk {p : Finset \u03b2} {f : \u03b2 \u2192 \u03b1} :\n    (\u220f i in p, Associates.mk (f i)) = Associates.mk (\u220f i in p, f i)", "start": [133, 1], "end": [138, 101], "kind": "commanddeclaration"}, {"full_name": "Associates.rel_associated_iff_map_eq_map", "code": "theorem rel_associated_iff_map_eq_map {p q : Multiset \u03b1} :\n    Multiset.Rel Associated p q \u2194 p.map Associates.mk = q.map Associates.mk", "start": [141, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_eq_one_iff", "code": "theorem prod_eq_one_iff {p : Multiset (Associates \u03b1)} :\n    p.prod = 1 \u2194 \u2200 a \u2208 p, (a : Associates \u03b1) = 1", "start": [147, 1], "end": [150, 86], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_le_prod", "code": "theorem prod_le_prod {p q : Multiset (Associates \u03b1)} (h : p \u2264 q) : p.prod \u2264 q.prod", "start": [153, 1], "end": [158, 41], "kind": "commanddeclaration"}, {"full_name": "Associates.exists_mem_multiset_le_of_prime", "code": "theorem exists_mem_multiset_le_of_prime {s : Multiset (Associates \u03b1)} {p : Associates \u03b1}\n    (hp : Prime p) : p \u2264 s.prod \u2192 \u2203 a \u2208 s, p \u2264 a", "start": [167, 1], "end": [176, 43], "kind": "commanddeclaration"}, {"full_name": "Multiset.prod_ne_zero_of_prime", "code": "theorem prod_ne_zero_of_prime [CancelCommMonoidWithZero \u03b1] [Nontrivial \u03b1] (s : Multiset \u03b1)\n    (h : \u2200 x \u2208 s, Prime x) : s.prod \u2260 0", "start": [185, 1], "end": [187, 61], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_finset_prod_iff", "code": "theorem Prime.dvd_finset_prod_iff {S : Finset \u03b1} {p : M} (pp : Prime p) (g : \u03b1 \u2192 M) :\n    p \u2223 S.prod g \u2194 \u2203 a \u2208 S, p \u2223 g a", "start": [198, 1], "end": [200, 89], "kind": "commanddeclaration"}, {"full_name": "Prime.dvd_finsupp_prod_iff", "code": "theorem Prime.dvd_finsupp_prod_iff {f : \u03b1 \u2192\u2080 M} {g : \u03b1 \u2192 M \u2192 \u2115} {p : \u2115} (pp : Prime p) :\n    p \u2223 f.prod g \u2194 \u2203 a \u2208 f.support, p \u2223 g a (f a)", "start": [203, 1], "end": [205, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Multiplicity.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/RingTheory/Valuation/Basic.lean", "Mathlib/Algebra/Associated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "multiplicity", "code": "def multiplicity [Monoid \u03b1] [DecidableRel ((\u00b7 \u2223 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] (a b : \u03b1) : PartENat :=\n  PartENat.find fun n => \u00aca ^ (n + 1) \u2223 b", "start": [33, 1], "end": [37, 42], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Finite", "code": "@[reducible]\ndef Finite (a b : \u03b1) : Prop :=\n  \u2203 n : \u2115, \u00aca ^ (n + 1) \u2223 b", "start": [46, 1], "end": [49, 28], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_iff_dom", "code": "theorem finite_iff_dom [DecidableRel ((\u00b7 \u2223 \u00b7) : \u03b1 \u2192 \u03b1 \u2192 Prop)] {a b : \u03b1} :\n    Finite a b \u2194 (multiplicity a b).Dom", "start": [52, 1], "end": [54, 10], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_def", "code": "theorem finite_def {a b : \u03b1} : Finite a b \u2194 \u2203 n : \u2115, \u00aca ^ (n + 1) \u2223 b", "start": [57, 1], "end": [58, 10], "kind": "commanddeclaration"}, {"full_name": "multiplicity.not_dvd_one_of_finite_one_right", "code": "theorem not_dvd_one_of_finite_one_right {a : \u03b1} : Finite a 1 \u2192 \u00aca \u2223 1", "start": [61, 1], "end": [62, 62], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Int.coe_nat_multiplicity", "code": "@[norm_cast]\ntheorem Int.coe_nat_multiplicity (a b : \u2115) : multiplicity (a : \u2124) (b : \u2124) = multiplicity a b", "start": [65, 1], "end": [74, 13], "kind": "commanddeclaration"}, {"full_name": "multiplicity.not_finite_iff_forall", "code": "theorem not_finite_iff_forall {a b : \u03b1} : \u00acFinite a b \u2194 \u2200 n : \u2115, a ^ n \u2223 b", "start": [77, 1], "end": [84, 62], "kind": "commanddeclaration"}, {"full_name": "multiplicity.not_unit_of_finite", "code": "theorem not_unit_of_finite {a b : \u03b1} (h : Finite a b) : \u00acIsUnit a", "start": [87, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_of_finite_mul_right", "code": "theorem finite_of_finite_mul_right {a b c : \u03b1} : Finite a (b * c) \u2192 Finite a b", "start": [92, 1], "end": [93, 49], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_dvd_of_le_multiplicity", "code": "theorem pow_dvd_of_le_multiplicity {a b : \u03b1} {k : \u2115} :\n    (k : PartENat) \u2264 multiplicity a b \u2192 a ^ k \u2223 b", "start": [98, 1], "end": [106, 97], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_multiplicity_dvd", "code": "theorem pow_multiplicity_dvd {a b : \u03b1} (h : Finite a b) : a ^ get (multiplicity a b) h \u2223 b", "start": [109, 1], "end": [110, 60], "kind": "commanddeclaration"}, {"full_name": "multiplicity.is_greatest", "code": "theorem is_greatest {a b : \u03b1} {m : \u2115} (hm : multiplicity a b < m) : \u00aca ^ m \u2223 b", "start": [113, 1], "end": [114, 94], "kind": "commanddeclaration"}, {"full_name": "multiplicity.is_greatest'", "code": "theorem is_greatest' {a b : \u03b1} {m : \u2115} (h : Finite a b) (hm : get (multiplicity a b) h < m) :\n    \u00aca ^ m \u2223 b", "start": [117, 1], "end": [119, 75], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pos_of_dvd", "code": "theorem pos_of_dvd {a b : \u03b1} (hfin : Finite a b) (hdiv : a \u2223 b) :\n    0 < (multiplicity a b).get hfin", "start": [122, 1], "end": [125, 58], "kind": "commanddeclaration"}, {"full_name": "multiplicity.unique", "code": "theorem unique {a b : \u03b1} {k : \u2115} (hk : a ^ k \u2223 b) (hsucc : \u00aca ^ (k + 1) \u2223 b) :\n    (k : PartENat) = multiplicity a b", "start": [128, 1], "end": [133, 40], "kind": "commanddeclaration"}, {"full_name": "multiplicity.unique'", "code": "theorem unique' {a b : \u03b1} {k : \u2115} (hk : a ^ k \u2223 b) (hsucc : \u00aca ^ (k + 1) \u2223 b) :\n    k = get (multiplicity a b) \u27e8k, hsucc\u27e9", "start": [136, 1], "end": [138, 69], "kind": "commanddeclaration"}, {"full_name": "multiplicity.le_multiplicity_of_pow_dvd", "code": "theorem le_multiplicity_of_pow_dvd {a b : \u03b1} {k : \u2115} (hk : a ^ k \u2223 b) :\n    (k : PartENat) \u2264 multiplicity a b", "start": [141, 1], "end": [143, 45], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow_dvd_iff_le_multiplicity", "code": "theorem pow_dvd_iff_le_multiplicity {a b : \u03b1} {k : \u2115} :\n    a ^ k \u2223 b \u2194 (k : PartENat) \u2264 multiplicity a b", "start": [146, 1], "end": [148, 59], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_lt_iff_neg_dvd", "code": "theorem multiplicity_lt_iff_neg_dvd {a b : \u03b1} {k : \u2115} :\n    multiplicity a b < (k : PartENat) \u2194 \u00aca ^ k \u2223 b", "start": [151, 1], "end": [152, 98], "kind": "commanddeclaration"}, {"full_name": "multiplicity.eq_coe_iff", "code": "theorem eq_coe_iff {a b : \u03b1} {n : \u2115} :\n    multiplicity a b = (n : PartENat) \u2194 a ^ n \u2223 b \u2227 \u00aca ^ (n + 1) \u2223 b", "start": [155, 1], "end": [164, 69], "kind": "commanddeclaration"}, {"full_name": "multiplicity.eq_top_iff", "code": "theorem eq_top_iff {a b : \u03b1} : multiplicity a b = \u22a4 \u2194 \u2200 n : \u2115, a ^ n \u2223 b", "start": [167, 1], "end": [177, 24], "kind": "commanddeclaration"}, {"full_name": "multiplicity.isUnit_left", "code": "@[simp]\ntheorem isUnit_left {a : \u03b1} (b : \u03b1) (ha : IsUnit a) : multiplicity a b = \u22a4", "start": [180, 1], "end": [182, 46], "kind": "commanddeclaration"}, {"full_name": "multiplicity.one_left", "code": "theorem one_left (b : \u03b1) : multiplicity 1 b = \u22a4", "start": [186, 1], "end": [187, 27], "kind": "commanddeclaration"}, {"full_name": "multiplicity.get_one_right", "code": "@[simp]\ntheorem get_one_right {a : \u03b1} (ha : Finite a 1) : get (multiplicity a 1) ha = 0", "start": [190, 1], "end": [193, 44], "kind": "commanddeclaration"}, {"full_name": "multiplicity.unit_left", "code": "theorem unit_left (a : \u03b1) (u : \u03b1\u02e3) : multiplicity (u : \u03b1) a = \u22a4", "start": [197, 1], "end": [198, 25], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_eq_zero", "code": "theorem multiplicity_eq_zero {a b : \u03b1} : multiplicity a b = 0 \u2194 \u00aca \u2223 b", "start": [201, 1], "end": [203, 83], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_ne_zero", "code": "theorem multiplicity_ne_zero {a b : \u03b1} : multiplicity a b \u2260 0 \u2194 a \u2223 b", "start": [206, 1], "end": [207, 32], "kind": "commanddeclaration"}, {"full_name": "multiplicity.eq_top_iff_not_finite", "code": "theorem eq_top_iff_not_finite {a b : \u03b1} : multiplicity a b = \u22a4 \u2194 \u00acFinite a b", "start": [210, 1], "end": [211, 20], "kind": "commanddeclaration"}, {"full_name": "multiplicity.ne_top_iff_finite", "code": "theorem ne_top_iff_finite {a b : \u03b1} : multiplicity a b \u2260 \u22a4 \u2194 Finite a b", "start": [214, 1], "end": [215, 56], "kind": "commanddeclaration"}, {"full_name": "multiplicity.lt_top_iff_finite", "code": "theorem lt_top_iff_finite {a b : \u03b1} : multiplicity a b < \u22a4 \u2194 Finite a b", "start": [218, 1], "end": [219, 44], "kind": "commanddeclaration"}, {"full_name": "multiplicity.exists_eq_pow_mul_and_not_dvd", "code": "theorem exists_eq_pow_mul_and_not_dvd {a b : \u03b1} (hfin : Finite a b) :\n    \u2203 c : \u03b1, b = a ^ (multiplicity a b).get hfin * c \u2227 \u00aca \u2223 c", "start": [222, 1], "end": [229, 51], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_le_multiplicity_iff", "code": "theorem multiplicity_le_multiplicity_iff {a b c d : \u03b1} :\n    multiplicity a b \u2264 multiplicity c d \u2194 \u2200 n : \u2115, a ^ n \u2223 b \u2192 c ^ n \u2223 d", "start": [234, 1], "end": [242, 96], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_eq_multiplicity_iff", "code": "theorem multiplicity_eq_multiplicity_iff {a b c d : \u03b1} :\n    multiplicity a b = multiplicity c d \u2194 \u2200 n : \u2115, a ^ n \u2223 b \u2194 c ^ n \u2223 d", "start": [245, 1], "end": [251, 65], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_le_multiplicity_of_dvd_right", "code": "theorem multiplicity_le_multiplicity_of_dvd_right {a b c : \u03b1} (h : b \u2223 c) :\n    multiplicity a b \u2264 multiplicity a c", "start": [254, 1], "end": [256, 60], "kind": "commanddeclaration"}, {"full_name": "multiplicity.eq_of_associated_right", "code": "theorem eq_of_associated_right {a b c : \u03b1} (h : Associated b c) :\n    multiplicity a b = multiplicity a c", "start": [259, 1], "end": [262, 59], "kind": "commanddeclaration"}, {"full_name": "multiplicity.dvd_of_multiplicity_pos", "code": "theorem dvd_of_multiplicity_pos {a b : \u03b1} (h : (0 : PartENat) < multiplicity a b) : a \u2223 b", "start": [265, 1], "end": [268, 61], "kind": "commanddeclaration"}, {"full_name": "multiplicity.dvd_iff_multiplicity_pos", "code": "theorem dvd_iff_multiplicity_pos {a b : \u03b1} : (0 : PartENat) < multiplicity a b \u2194 a \u2223 b", "start": [271, 1], "end": [277, 30], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_nat_iff", "code": "theorem finite_nat_iff {a b : \u2115} : Finite a b \u2194 a \u2260 1 \u2227 0 < b", "start": [280, 1], "end": [295, 40], "kind": "commanddeclaration"}, {"full_name": "has_dvd.dvd.multiplicity_pos", "code": "alias \u27e8_, _root_.has_dvd.dvd.multiplicity_pos\u27e9 := dvd_iff_multiplicity_pos", "start": [298, 1], "end": [298, 75], "kind": "stdtacticaliasaliaslr"}, {"full_name": "multiplicity.finite_of_finite_mul_left", "code": "theorem finite_of_finite_mul_left {a b c : \u03b1} : Finite a (b * c) \u2192 Finite a c", "start": [306, 1], "end": [307, 50], "kind": "commanddeclaration"}, {"full_name": "multiplicity.isUnit_right", "code": "theorem isUnit_right {a b : \u03b1} (ha : \u00acIsUnit a) (hb : IsUnit b) : multiplicity a b = 0", "start": [312, 1], "end": [316, 54], "kind": "commanddeclaration"}, {"full_name": "multiplicity.one_right", "code": "theorem one_right {a : \u03b1} (ha : \u00acIsUnit a) : multiplicity a 1 = 0", "start": [319, 1], "end": [320, 29], "kind": "commanddeclaration"}, {"full_name": "multiplicity.unit_right", "code": "theorem unit_right {a : \u03b1} (ha : \u00acIsUnit a) (u : \u03b1\u02e3) : multiplicity a u = 0", "start": [323, 1], "end": [324, 27], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_le_multiplicity_of_dvd_left", "code": "theorem multiplicity_le_multiplicity_of_dvd_left {a b c : \u03b1} (hdvd : a \u2223 b) :\n    multiplicity b c \u2264 multiplicity a c", "start": [329, 1], "end": [331, 84], "kind": "commanddeclaration"}, {"full_name": "multiplicity.eq_of_associated_left", "code": "theorem eq_of_associated_left {a b c : \u03b1} (h : Associated a b) :\n    multiplicity b c = multiplicity a c", "start": [334, 1], "end": [337, 58], "kind": "commanddeclaration"}, {"full_name": "multiplicity.ne_zero_of_finite", "code": "theorem ne_zero_of_finite {a b : \u03b1} (h : Finite a b) : b \u2260 0", "start": [349, 1], "end": [351, 31], "kind": "commanddeclaration"}, {"full_name": "multiplicity.zero", "code": "@[simp]\nprotected theorem zero (a : \u03b1) : multiplicity a 0 = \u22a4", "start": [356, 1], "end": [358, 59], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_zero_eq_zero_of_ne_zero", "code": "@[simp]\ntheorem multiplicity_zero_eq_zero_of_ne_zero (a : \u03b1) (ha : a \u2260 0) : multiplicity 0 a = 0", "start": [361, 1], "end": [363, 62], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_mk_eq_multiplicity", "code": "theorem multiplicity_mk_eq_multiplicity\n    [DecidableRel ((\u00b7 \u2223 \u00b7) : Associates \u03b1 \u2192 Associates \u03b1 \u2192 Prop)] {a b : \u03b1} :\n    multiplicity (Associates.mk a) (Associates.mk b) = multiplicity a b", "start": [374, 1], "end": [392, 43], "kind": "commanddeclaration"}, {"full_name": "multiplicity.min_le_multiplicity_add", "code": "theorem min_le_multiplicity_add {p a b : \u03b1} :\n    min (multiplicity p a) (multiplicity p b) \u2264 multiplicity p (a + b)", "start": [401, 1], "end": [409, 79], "kind": "commanddeclaration"}, {"full_name": "multiplicity.neg", "code": "@[simp]\nprotected theorem neg (a b : \u03b1) : multiplicity a (-b) = multiplicity a b", "start": [418, 1], "end": [425, 67], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Int.natAbs", "code": "theorem Int.natAbs (a : \u2115) (b : \u2124) : multiplicity a b.natAbs = multiplicity (a : \u2124) b", "start": [428, 1], "end": [431, 52], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_add_of_gt", "code": "theorem multiplicity_add_of_gt {p a b : \u03b1} (h : multiplicity p b < multiplicity p a) :\n    multiplicity p (a + b) = multiplicity p b", "start": [434, 1], "end": [449, 38], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_sub_of_gt", "code": "theorem multiplicity_sub_of_gt {p a b : \u03b1} (h : multiplicity p b < multiplicity p a) :\n    multiplicity p (a - b) = multiplicity p b", "start": [452, 1], "end": [454, 84], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_add_eq_min", "code": "theorem multiplicity_add_eq_min {p a b : \u03b1} (h : multiplicity p a \u2260 multiplicity p b) :\n    multiplicity p (a + b) = min (multiplicity p a) (multiplicity p b)", "start": [457, 1], "end": [464, 23], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_mul_aux", "code": "theorem finite_mul_aux {p : \u03b1} (hp : Prime p) {a b : \u03b1} :\n    \u2200 {n m : \u2115}, \u00acp ^ (n + 1) \u2223 a \u2192 \u00acp ^ (m + 1) \u2223 b \u2192 \u00acp ^ (n + m + 1) \u2223 a * b", "start": [475, 1], "end": [506, 45], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_mul", "code": "theorem finite_mul {p a b : \u03b1} (hp : Prime p) : Finite p a \u2192 Finite p b \u2192 Finite p (a * b)", "start": [509, 1], "end": [510, 58], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_mul_iff", "code": "theorem finite_mul_iff {p a b : \u03b1} (hp : Prime p) : Finite p (a * b) \u2194 Finite p a \u2227 Finite p b", "start": [513, 1], "end": [515, 27], "kind": "commanddeclaration"}, {"full_name": "multiplicity.finite_pow", "code": "theorem finite_pow {p a : \u03b1} (hp : Prime p) : \u2200 {k : \u2115} (_ : Finite p a), Finite p (a ^ k)", "start": [518, 1], "end": [520, 84], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_self", "code": "@[simp]\ntheorem multiplicity_self {a : \u03b1} (ha : \u00acIsUnit a) (ha0 : a \u2260 0) : multiplicity a a = 1", "start": [525, 1], "end": [529, 90], "kind": "commanddeclaration"}, {"full_name": "multiplicity.get_multiplicity_self", "code": "@[simp]\ntheorem get_multiplicity_self {a : \u03b1} (ha : Finite a a) : get (multiplicity a a) ha = 1", "start": [532, 1], "end": [540, 79], "kind": "commanddeclaration"}, {"full_name": "multiplicity.mul'", "code": "protected theorem mul' {p a b : \u03b1} (hp : Prime p) (h : (multiplicity p (a * b)).Dom) :\n    get (multiplicity p (a * b)) h =\n      get (multiplicity p a) ((finite_mul_iff hp).1 h).1 +\n        get (multiplicity p b) ((finite_mul_iff hp).1 h).2", "start": [543, 1], "end": [568, 85], "kind": "commanddeclaration"}, {"full_name": "multiplicity.mul", "code": "protected theorem mul {p a b : \u03b1} (hp : Prime p) :\n    multiplicity p (a * b) = multiplicity p a + multiplicity p b", "start": [573, 1], "end": [582, 72], "kind": "commanddeclaration"}, {"full_name": "multiplicity.Finset.prod", "code": "theorem Finset.prod {\u03b2 : Type*} {p : \u03b1} (hp : Prime p) (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    multiplicity p (\u220f x in s, f x) = \u2211 x in s, multiplicity p (f x)", "start": [585, 1], "end": [592, 34], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow'", "code": "protected theorem pow' {p a : \u03b1} (hp : Prime p) (ha : Finite p a) :\n    \u2200 {k : \u2115}, get (multiplicity p (a ^ k)) (finite_pow hp ha) = k * get (multiplicity p a) ha", "start": [596, 1], "end": [603, 60], "kind": "commanddeclaration"}, {"full_name": "multiplicity.pow", "code": "theorem pow {p a : \u03b1} (hp : Prime p) : \u2200 {k : \u2115}, multiplicity p (a ^ k) = k \u2022 multiplicity p a", "start": [606, 1], "end": [608, 81], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_pow_self", "code": "theorem multiplicity_pow_self {p : \u03b1} (h0 : p \u2260 0) (hu : \u00acIsUnit p) (n : \u2115) :\n    multiplicity p (p ^ n) = n", "start": [611, 1], "end": [616, 29], "kind": "commanddeclaration"}, {"full_name": "multiplicity.multiplicity_pow_self_of_prime", "code": "theorem multiplicity_pow_self_of_prime {p : \u03b1} (hp : Prime p) (n : \u2115) :\n    multiplicity p (p ^ n) = n", "start": [619, 1], "end": [621, 49], "kind": "commanddeclaration"}, {"full_name": "multiplicity.addValuation", "code": "noncomputable def addValuation (hp : Prime p) : AddValuation R PartENat :=\n  AddValuation.of (multiplicity p) (multiplicity.zero _) (one_right hp.not_unit)\n    (fun _ _ => min_le_multiplicity_add) fun _ _ => multiplicity.mul hp", "start": [630, 1], "end": [633, 72], "kind": "commanddeclaration"}, {"full_name": "multiplicity.addValuation_apply", "code": "@[simp]\ntheorem addValuation_apply {hp : Prime p} {r : R} : addValuation hp r = multiplicity p r", "start": [636, 1], "end": [638, 6], "kind": "commanddeclaration"}, {"full_name": "multiplicity_eq_zero_of_coprime", "code": "theorem multiplicity_eq_zero_of_coprime {p a b : \u2115} (hp : p \u2260 1)\n    (hle : multiplicity p a \u2264 multiplicity p b) (hab : Nat.Coprime a b) : multiplicity p a = 0", "start": [649, 1], "end": [657, 16], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Noetherian.lean", "imports": ["Mathlib/GroupTheory/Finiteness.lean", "Mathlib/RingTheory/Finiteness.lean", "Mathlib/Order/Filter/EventuallyConst.lean", "Mathlib/Algebra/Ring/Idempotents.lean", "Mathlib/Algebra/Algebra/Subalgebra/Basic.lean", "Mathlib/RingTheory/Nilpotent.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Tower.lean", "Mathlib/LinearAlgebra/LinearIndependent.lean", "Mathlib/Order/CompactlyGenerated.lean", "Mathlib/Order/OrderIsoNat.lean"], "premises": [{"full_name": "IsNoetherian", "code": "class IsNoetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M] : Prop where\n  noetherian : \u2200 s : Submodule R M, s.FG", "start": [63, 1], "end": [68, 41], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_def", "code": "theorem isNoetherian_def : IsNoetherian R M \u2194 \u2200 s : Submodule R M, s.FG", "start": [83, 1], "end": [85, 43], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_submodule", "code": "theorem isNoetherian_submodule {N : Submodule R M} :\n    IsNoetherian R N \u2194 \u2200 s : Submodule R M, s \u2264 N \u2192 s.FG", "start": [88, 1], "end": [98, 41], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_submodule_left", "code": "theorem isNoetherian_submodule_left {N : Submodule R M} :\n    IsNoetherian R N \u2194 \u2200 s : Submodule R M, (N \u2293 s).FG", "start": [101, 1], "end": [103, 100], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_submodule_right", "code": "theorem isNoetherian_submodule_right {N : Submodule R M} :\n    IsNoetherian R N \u2194 \u2200 s : Submodule R M, (s \u2293 N).FG", "start": [106, 1], "end": [108, 100], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_submodule'", "code": "instance isNoetherian_submodule' [IsNoetherian R M] (N : Submodule R M) : IsNoetherian R N :=\n  isNoetherian_submodule.2 fun _ _ => IsNoetherian.noetherian _", "start": [111, 1], "end": [112, 64], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_le", "code": "theorem isNoetherian_of_le {s t : Submodule R M} [ht : IsNoetherian R t] (h : s \u2264 t) :\n    IsNoetherian R s", "start": [115, 1], "end": [117, 90], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_surjective", "code": "theorem isNoetherian_of_surjective (f : M \u2192\u2097[R] P) (hf : LinearMap.range f = \u22a4) [IsNoetherian R M] :\n    IsNoetherian R P", "start": [122, 1], "end": [126, 33], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_linearEquiv", "code": "theorem isNoetherian_of_linearEquiv (f : M \u2243\u2097[R] P) [IsNoetherian R M] : IsNoetherian R P", "start": [131, 1], "end": [132, 53], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_top_iff", "code": "theorem isNoetherian_top_iff : IsNoetherian R (\u22a4 : Submodule R M) \u2194 IsNoetherian R M", "start": [135, 1], "end": [138, 87], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_injective", "code": "theorem isNoetherian_of_injective [IsNoetherian R P] (f : M \u2192\u2097[R] P) (hf : Function.Injective f) :\n    IsNoetherian R M", "start": [141, 1], "end": [143, 66], "kind": "commanddeclaration"}, {"full_name": "fg_of_injective", "code": "theorem fg_of_injective [IsNoetherian R P] {N : Submodule R M} (f : M \u2192\u2097[R] P)\n    (hf : Function.Injective f) : N.FG", "start": [146, 1], "end": [149, 28], "kind": "commanddeclaration"}, {"full_name": "Module.IsNoetherian.finite", "code": "instance (priority := 100) IsNoetherian.finite [IsNoetherian R M] : Finite R M :=\n  \u27e8IsNoetherian.noetherian \u22a4\u27e9", "start": [163, 1], "end": [164, 30], "kind": "commanddeclaration"}, {"full_name": "Module.Finite.of_injective", "code": "theorem Finite.of_injective [IsNoetherian R N] (f : M \u2192\u2097[R] N) (hf : Function.Injective f) :\n    Finite R M", "start": [169, 1], "end": [171, 25], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_ker_bot", "code": "theorem isNoetherian_of_ker_bot [IsNoetherian R P] (f : M \u2192\u2097[R] P) (hf : LinearMap.ker f = \u22a5) :\n    IsNoetherian R M", "start": [186, 1], "end": [188, 93], "kind": "commanddeclaration"}, {"full_name": "fg_of_ker_bot", "code": "theorem fg_of_ker_bot [IsNoetherian R P] {N : Submodule R M} (f : M \u2192\u2097[R] P)\n    (hf : LinearMap.ker f = \u22a5) : N.FG", "start": [191, 1], "end": [194, 28], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_prod", "code": "instance isNoetherian_prod [IsNoetherian R M] [IsNoetherian R P] : IsNoetherian R (M \u00d7 P) :=\n  \u27e8fun s =>\n    Submodule.fg_of_fg_map_of_fg_inf_ker (LinearMap.snd R M P) (noetherian _) <|\n      have : s \u2293 LinearMap.ker (LinearMap.snd R M P) \u2264 LinearMap.range (LinearMap.inl R M P) :=\n        fun x \u27e8_, hx2\u27e9 => \u27e8x.1, Prod.ext rfl <| Eq.symm <| LinearMap.mem_ker.1 hx2\u27e9\n      Submodule.map_comap_eq_self this \u25b8 (noetherian _).map _\u27e9", "start": [197, 1], "end": [202, 63], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_pi", "code": "instance isNoetherian_pi {R \u03b9 : Type*} {M : \u03b9 \u2192 Type*}\n    [Ring R] [\u2200 i, AddCommGroup (M i)] [\u2200 i, Module R (M i)] [Finite \u03b9]\n    [\u2200 i, IsNoetherian R (M i)] : IsNoetherian R (\u2200 i, M i) := by\n  cases nonempty_fintype \u03b9\n  haveI := Classical.decEq \u03b9\n  suffices on_finset : \u2200 s : Finset \u03b9, IsNoetherian R (\u2200 i : s, M i)\n  \u00b7 let coe_e := Equiv.subtypeUnivEquiv <| @Finset.mem_univ \u03b9 _\n    letI : IsNoetherian R (\u2200 i : Finset.univ, M (coe_e i)) := on_finset Finset.univ\n    exact isNoetherian_of_linearEquiv (LinearEquiv.piCongrLeft R M coe_e)\n  intro s\n  induction' s using Finset.induction with a s has ih\n  \u00b7 exact \u27e8fun s => by\n      have : s = \u22a5 := by simp only [eq_iff_true_of_subsingleton]\n      rw [this]\n      apply Submodule.fg_bot\u27e9\n  refine\n    @isNoetherian_of_linearEquiv R (M a \u00d7 ((i : s) \u2192 M i)) _ _ _ _ _ _ ?_ <|\n      @isNoetherian_prod R (M a) _ _ _ _ _ _ _ ih\n  refine\n  { toFun := fun f i =>\n      (Finset.mem_insert.1 i.2).by_cases\n        (fun h : i.1 = a => show M i.1 from Eq.recOn h.symm f.1)\n        (fun h : i.1 \u2208 s => show M i.1 from f.2 \u27e8i.1, h\u27e9),\n    invFun := fun f =>\n      (f \u27e8a, Finset.mem_insert_self _ _\u27e9, fun i => f \u27e8i.1, Finset.mem_insert_of_mem i.2\u27e9),\n    map_add' := ?_,\n    map_smul' := ?_\n    left_inv := ?_,\n    right_inv := ?_ }\n  \u00b7 intro f g\n    ext i\n    unfold Or.by_cases\n    cases' i with i hi\n    rcases Finset.mem_insert.1 hi with (rfl | h)\n    \u00b7 change _ = _ + _\n      simp only [dif_pos]\n      rfl\n    \u00b7 change _ = _ + _\n      have : \u00aci = a := by\n        rintro rfl\n        exact has h\n      simp only [dif_neg this, dif_pos h]\n      rfl\n  \u00b7 intro c f\n    ext i\n    unfold Or.by_cases\n    cases' i with i hi\n    rcases Finset.mem_insert.1 hi with (rfl | h)\n    \u00b7 dsimp\n      simp only [dif_pos]\n    \u00b7 dsimp\n      have : \u00aci = a := by\n        rintro rfl\n        exact has h\n      simp only [dif_neg this, dif_pos h]\n  \u00b7 intro f\n    apply Prod.ext\n    \u00b7 simp only [Or.by_cases, dif_pos]\n    \u00b7 ext \u27e8i, his\u27e9\n      have : \u00aci = a := by\n        rintro rfl\n        exact has his\n      simp only [Or.by_cases, this, not_false_iff, dif_neg]\n  \u00b7 intro f\n    ext \u27e8i, hi\u27e9\n    rcases Finset.mem_insert.1 hi with (rfl | h)\n    \u00b7 simp only [Or.by_cases, dif_pos]\n    \u00b7 have : \u00aci = a := by\n        rintro rfl\n        exact has h\n      simp only [Or.by_cases, dif_neg this, dif_pos h]", "start": [205, 1], "end": [275, 55], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_pi'", "code": "instance isNoetherian_pi' {R \u03b9 M : Type*} [Ring R] [AddCommGroup M] [Module R M] [Finite \u03b9]\n    [IsNoetherian R M] : IsNoetherian R (\u03b9 \u2192 M) :=\n  isNoetherian_pi", "start": [278, 1], "end": [283, 18], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_linearMap_pi", "code": "instance isNoetherian_linearMap_pi {\u03b9 : Type*} [Finite \u03b9] : IsNoetherian R ((\u03b9 \u2192 R) \u2192\u2097[R] M) :=\n  let _i : Fintype \u03b9 := Fintype.ofFinite \u03b9; isNoetherian_of_linearEquiv (Module.piEquiv \u03b9 R M)", "start": [293, 1], "end": [294, 95], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_linearMap", "code": "instance isNoetherian_linearMap : IsNoetherian R (N \u2192\u2097[R] M) := by\n  obtain \u27e8n, f, hf\u27e9 := Module.Finite.exists_fin' R N\n  let g : (N \u2192\u2097[R] M) \u2192\u2097[R] (Fin n \u2192 R) \u2192\u2097[R] M := (LinearMap.llcomp R (Fin n \u2192 R) N M).flip f\n  exact isNoetherian_of_injective g hf.injective_linearMapComp_right", "start": [296, 1], "end": [299, 69], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_iff_wellFounded", "code": "theorem isNoetherian_iff_wellFounded :\n    IsNoetherian R M \u2194 WellFounded ((\u00b7 > \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop)", "start": [312, 1], "end": [319, 47], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_iff_fg_wellFounded", "code": "theorem isNoetherian_iff_fg_wellFounded :\n    IsNoetherian R M \u2194\n      WellFounded\n        ((\u00b7 > \u00b7) : { N : Submodule R M // N.FG } \u2192 { N : Submodule R M // N.FG } \u2192 Prop)", "start": [322, 1], "end": [344, 76], "kind": "commanddeclaration"}, {"full_name": "wellFounded_submodule_gt", "code": "theorem wellFounded_submodule_gt (R M) [Semiring R] [AddCommMonoid M] [Module R M] :\n    \u2200 [IsNoetherian R M], WellFounded ((\u00b7 > \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop)", "start": [349, 1], "end": [351, 38], "kind": "commanddeclaration"}, {"full_name": "set_has_maximal_iff_noetherian", "code": "theorem set_has_maximal_iff_noetherian :\n    (\u2200 a : Set <| Submodule R M, a.Nonempty \u2192 \u2203 M' \u2208 a, \u2200 I \u2208 a, \u00acM' < I) \u2194 IsNoetherian R M", "start": [356, 1], "end": [360, 73], "kind": "commanddeclaration"}, {"full_name": "monotone_stabilizes_iff_noetherian", "code": "theorem monotone_stabilizes_iff_noetherian :\n    (\u2200 f : \u2115 \u2192o Submodule R M, \u2203 n, \u2200 m, n \u2264 m \u2192 f n = f m) \u2194 IsNoetherian R M", "start": [363, 1], "end": [366, 74], "kind": "commanddeclaration"}, {"full_name": "eventuallyConst_of_isNoetherian", "code": "theorem eventuallyConst_of_isNoetherian [IsNoetherian R M] (f : \u2115 \u2192o Submodule R M) :\n    atTop.EventuallyConst f", "start": [369, 1], "end": [372, 65], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.induction", "code": "theorem IsNoetherian.induction [IsNoetherian R M] {P : Submodule R M \u2192 Prop}\n    (hgt : \u2200 I, (\u2200 J > I, P J) \u2192 P I) (I : Submodule R M) : P I", "start": [374, 1], "end": [377, 61], "kind": "commanddeclaration"}, {"full_name": "finite_of_linearIndependent", "code": "theorem finite_of_linearIndependent [Nontrivial R] {s : Set M}\n    (hs : LinearIndependent R ((\u2191) : s \u2192 M)) : s.Finite", "start": [389, 1], "end": [409, 78], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_range_eq_ker", "code": "theorem isNoetherian_of_range_eq_ker [IsNoetherian R P] (f : M \u2192\u2097[R] N)\n    (g : N \u2192\u2097[R] P) (hf : Function.Injective f) (hg : Function.Surjective g)\n    (h : LinearMap.range f = LinearMap.ker g) :\n    IsNoetherian R N", "start": [412, 1], "end": [422, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eventually_disjoint_ker_pow_range_pow", "code": "theorem LinearMap.eventually_disjoint_ker_pow_range_pow (f : M \u2192\u2097[R] M) :\n    \u2200\u1da0 n in atTop, Disjoint (LinearMap.ker (f ^ n)) (LinearMap.range (f ^ n))", "start": [425, 1], "end": [437, 40], "kind": "commanddeclaration"}, {"full_name": "LinearMap.eventually_iSup_ker_pow_eq", "code": "lemma LinearMap.eventually_iSup_ker_pow_eq (f : M \u2192\u2097[R] M) :\n    \u2200\u1da0 n in atTop, \u2a06 m, LinearMap.ker (f ^ m) = LinearMap.ker (f ^ n) := by\n  obtain \u27e8n, hn : \u2200 m, n \u2264 m \u2192 ker (f ^ n) = ker (f ^ m)\u27e9 :=\n    monotone_stabilizes_iff_noetherian.mpr inferInstance f.iterateKer\n  refine eventually_atTop.mpr \u27e8n, fun m hm \u21a6 ?_\u27e9\n  refine le_antisymm (iSup_le fun l \u21a6 ?_) (le_iSup (fun i \u21a6 LinearMap.ker (f ^ i)) m)\n  cases' le_or_lt m l with h h\n  \u00b7 rw [\u2190 hn _ (hm.trans h), hn _ hm]\n  \u00b7 exact f.iterateKer.monotone h.le", "start": [440, 1], "end": [448, 37], "kind": "mathlibtacticlemma"}, {"full_name": "IsNoetherian.injective_of_surjective_endomorphism", "code": "theorem IsNoetherian.injective_of_surjective_endomorphism (f : M \u2192\u2097[R] M)\n    (s : Surjective f) : Injective f", "start": [450, 1], "end": [457, 67], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.bijective_of_surjective_endomorphism", "code": "theorem IsNoetherian.bijective_of_surjective_endomorphism (f : M \u2192\u2097[R] M)\n    (s : Surjective f) : Bijective f", "start": [460, 1], "end": [463, 61], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.disjoint_partialSups_eventually_bot", "code": "theorem IsNoetherian.disjoint_partialSups_eventually_bot\n    (f : \u2115 \u2192 Submodule R M) (h : \u2200 n, Disjoint (partialSups f n) (f (n + 1))) :\n    \u2203 n : \u2115, \u2200 m, n \u2264 m \u2192 f m = \u22a5", "start": [466, 1], "end": [484, 96], "kind": "commanddeclaration"}, {"full_name": "IsNoetherian.equivPUnitOfProdInjective", "code": "noncomputable def IsNoetherian.equivPUnitOfProdInjective (f : M \u00d7 N \u2192\u2097[R] M)\n    (i : Injective f) : N \u2243\u2097[R] PUnit.{w + 1} := by\n  apply Nonempty.some\n  obtain \u27e8n, w\u27e9 :=\n    IsNoetherian.disjoint_partialSups_eventually_bot (f.tailing i) (f.tailings_disjoint_tailing i)\n  specialize w n (le_refl n)\n  apply Nonempty.intro\n  refine (LinearMap.tailingLinearEquiv f i n).symm \u226a\u226b\u2097 ?_\n  rw [w]\n  apply Submodule.botEquivPUnit", "start": [487, 1], "end": [499, 32], "kind": "commanddeclaration"}, {"full_name": "IsNoetherianRing", "code": "@[reducible]\ndef IsNoetherianRing (R) [Semiring R] :=\n  IsNoetherian R R", "start": [504, 1], "end": [509, 19], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_iff", "code": "theorem isNoetherianRing_iff {R} [Semiring R] : IsNoetherianRing R \u2194 IsNoetherian R R", "start": [512, 1], "end": [513, 10], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_iff_ideal_fg", "code": "theorem isNoetherianRing_iff_ideal_fg (R : Type*) [Semiring R] :\n    IsNoetherianRing R \u2194 \u2200 I : Ideal R, I.FG", "start": [516, 1], "end": [519, 46], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_finite", "code": "instance (priority := 80) isNoetherian_of_finite (R M) [Finite M] [Semiring R] [AddCommMonoid M]\n    [Module R M] : IsNoetherian R M :=\n  \u27e8fun s => \u27e8(s : Set M).toFinite.toFinset, by rw [Set.Finite.coe_toFinset, Submodule.span_eq]\u27e9\u27e9", "start": [523, 1], "end": [525, 97], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_subsingleton", "code": "instance (priority := 100) isNoetherian_of_subsingleton (R M) [Subsingleton R] [Semiring R]\n    [AddCommMonoid M] [Module R M] : IsNoetherian R M :=\n  haveI := Module.subsingleton R M\n  isNoetherian_of_finite R M", "start": [529, 1], "end": [533, 29], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_submodule_of_noetherian", "code": "theorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n    (N : Submodule R M) (h : IsNoetherian R M) : IsNoetherian R N", "start": [536, 1], "end": [539, 82], "kind": "commanddeclaration"}, {"full_name": "Submodule.Quotient.isNoetherian", "code": "instance Submodule.Quotient.isNoetherian {R} [Ring R] {M} [AddCommGroup M] [Module R M]\n    (N : Submodule R M) [h : IsNoetherian R M] : IsNoetherian R (M \u29f8 N) := by\n  rw [isNoetherian_iff_wellFounded] at h \u22a2\n  exact OrderEmbedding.wellFounded (Submodule.comapMkQOrderEmbedding N).dual h", "start": [542, 1], "end": [545, 79], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_tower", "code": "theorem isNoetherian_of_tower (R) {S M} [Semiring R] [Semiring S] [AddCommMonoid M] [SMul R S]\n    [Module S M] [Module R M] [IsScalarTower R S M] (h : IsNoetherian R M) : IsNoetherian S M", "start": [548, 1], "end": [553, 72], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_fg_of_noetherian", "code": "theorem isNoetherian_of_fg_of_noetherian {R M} [Ring R] [AddCommGroup M] [Module R M]\n    (N : Submodule R M) [I : IsNoetherianRing R] (hN : N.FG) : IsNoetherian R N", "start": [556, 1], "end": [588, 53], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_of_isNoetherianRing_of_finite", "code": "theorem isNoetherian_of_isNoetherianRing_of_finite (R M : Type*)\n    [Ring R] [AddCommGroup M] [Module R M] [IsNoetherianRing R] [Module.Finite R M] :\n    IsNoetherian R M", "start": [593, 1], "end": [598, 74], "kind": "commanddeclaration"}, {"full_name": "isNoetherian_span_of_finite", "code": "theorem isNoetherian_span_of_finite (R) {M} [Ring R] [AddCommGroup M] [Module R M]\n    [IsNoetherianRing R] {A : Set M} (hA : A.Finite) : IsNoetherian R (Submodule.span R A)", "start": [601, 1], "end": [605, 73], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_of_surjective", "code": "theorem isNoetherianRing_of_surjective (R) [Ring R] (S) [Ring S] (f : R \u2192+* S)\n    (hf : Function.Surjective f) [H : IsNoetherianRing R] : IsNoetherianRing S", "start": [608, 1], "end": [611, 82], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_range", "code": "instance isNoetherianRing_range {R} [Ring R] {S} [Ring S] (f : R \u2192+* S) [IsNoetherianRing R] :\n    IsNoetherianRing f.range :=\n  isNoetherianRing_of_surjective R f.range f.rangeRestrict f.rangeRestrict_surjective", "start": [614, 1], "end": [616, 86], "kind": "commanddeclaration"}, {"full_name": "isNoetherianRing_of_ringEquiv", "code": "theorem isNoetherianRing_of_ringEquiv (R) [Ring R] {S} [Ring S] (f : R \u2243+* S) [IsNoetherianRing R] :\n    IsNoetherianRing S", "start": [619, 1], "end": [621, 70], "kind": "commanddeclaration"}, {"full_name": "IsNoetherianRing.isNilpotent_nilradical", "code": "theorem IsNoetherianRing.isNilpotent_nilradical (R : Type*) [CommRing R] [IsNoetherianRing R] :\n    IsNilpotent (nilradical R)", "start": [624, 1], "end": [627, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "imports": ["Mathlib/SetTheory/Ordinal/Arithmetic.lean", "Mathlib/SetTheory/Ordinal/Exponential.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.nfpFamily", "code": "def nfpFamily (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) (a : Ordinal) : Ordinal :=\n  sup (List.foldr f a)", "start": [46, 1], "end": [54, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_eq_sup", "code": "theorem nfpFamily_eq_sup (f : \u03b9 \u2192 Ordinal.{max u v} \u2192 Ordinal.{max u v}) (a : Ordinal.{max u v}) :\n    nfpFamily.{u, v} f a = sup.{u, v} (List.foldr f a)", "start": [57, 1], "end": [59, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.foldr_le_nfpFamily", "code": "theorem foldr_le_nfpFamily (f : \u03b9 \u2192 Ordinal \u2192 Ordinal)\n    (a l) : List.foldr f a l \u2264 nfpFamily.{u, v} f a", "start": [62, 1], "end": [64, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_nfpFamily", "code": "theorem le_nfpFamily (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) (a) : a \u2264 nfpFamily f a", "start": [67, 1], "end": [68, 14], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_nfpFamily", "code": "theorem lt_nfpFamily {a b} : a < nfpFamily.{u, v} f b \u2194 \u2203 l, a < List.foldr f b l", "start": [71, 1], "end": [72, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_le_iff", "code": "theorem nfpFamily_le_iff {a b} : nfpFamily.{u, v} f a \u2264 b \u2194 \u2200 l, List.foldr f a l \u2264 b", "start": [75, 1], "end": [76, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_le", "code": "theorem nfpFamily_le {a b} : (\u2200 l, List.foldr f a l \u2264 b) \u2192 nfpFamily.{u, v} f a \u2264 b", "start": [79, 1], "end": [80, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_monotone", "code": "theorem nfpFamily_monotone (hf : \u2200 i, Monotone (f i)) : Monotone (nfpFamily.{u, v} f)", "start": [83, 1], "end": [84, 93], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_lt_nfpFamily", "code": "theorem apply_lt_nfpFamily (H : \u2200 i, IsNormal (f i)) {a b} (hb : b < nfpFamily.{u, v} f a) (i) :\n    f i b < nfpFamily.{u, v} f a", "start": [87, 1], "end": [90, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_lt_nfpFamily_iff", "code": "theorem apply_lt_nfpFamily_iff [Nonempty \u03b9] (H : \u2200 i, IsNormal (f i)) {a b} :\n    (\u2200 i, f i b < nfpFamily.{u, v} f a) \u2194 b < nfpFamily.{u, v} f a", "start": [93, 1], "end": [99, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_le_apply", "code": "theorem nfpFamily_le_apply [Nonempty \u03b9] (H : \u2200 i, IsNormal (f i)) {a b} :\n    (\u2203 i, nfpFamily.{u, v} f a \u2264 f i b) \u2194 nfpFamily.{u, v} f a \u2264 b", "start": [102, 1], "end": [106, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_le_fp", "code": "theorem nfpFamily_le_fp (H : \u2200 i, Monotone (f i)) {a b} (ab : a \u2264 b) (h : \u2200 i, f i b \u2264 b) :\n    nfpFamily.{u, v} f a \u2264 b", "start": [109, 1], "end": [116, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_fp", "code": "theorem nfpFamily_fp {i} (H : IsNormal (f i)) (a) :\n    f i (nfpFamily.{u, v} f a) = nfpFamily.{u, v} f a", "start": [119, 1], "end": [125, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_le_nfpFamily", "code": "theorem apply_le_nfpFamily [h\u03b9 : Nonempty \u03b9] {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} (H : \u2200 i, IsNormal (f i))\n    {a b} : (\u2200 i, f i b \u2264 nfpFamily.{u, v} f a) \u2194 b \u2264 nfpFamily.{u, v} f a", "start": [128, 1], "end": [134, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_eq_self", "code": "theorem nfpFamily_eq_self {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {a} (h : \u2200 i, f i a = a) :\n    nfpFamily f a = a", "start": [137, 1], "end": [139, 82], "kind": "commanddeclaration"}, {"full_name": "Ordinal.fp_family_unbounded", "code": "theorem fp_family_unbounded (H : \u2200 i, IsNormal (f i)) :\n    (\u22c2 i, Function.fixedPoints (f i)).Unbounded (\u00b7 < \u00b7)", "start": [143, 1], "end": [149, 66], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily", "code": "def derivFamily (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) (o : Ordinal) : Ordinal :=\n  limitRecOn o (nfpFamily.{u, v} f 0) (fun _ IH => nfpFamily.{u, v} f (succ IH))\n    fun a _ => bsup.{max u v, u} a", "start": [152, 1], "end": [158, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_zero", "code": "@[simp]\ntheorem derivFamily_zero (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) :\n    derivFamily.{u, v} f 0 = nfpFamily.{u, v} f 0", "start": [161, 1], "end": [164, 24], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_succ", "code": "@[simp]\ntheorem derivFamily_succ (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) (o) :\n    derivFamily.{u, v} f (succ o) = nfpFamily.{u, v} f (succ (derivFamily.{u, v} f o))", "start": [167, 1], "end": [170, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_limit", "code": "theorem derivFamily_limit (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) {o} :\n    IsLimit o \u2192 derivFamily.{u, v} f o = bsup.{max u v, u} o fun a _ => derivFamily.{u, v} f a", "start": [173, 1], "end": [175, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_isNormal", "code": "theorem derivFamily_isNormal (f : \u03b9 \u2192 Ordinal \u2192 Ordinal) : IsNormal (derivFamily f)", "start": [178, 1], "end": [180, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_fp", "code": "theorem derivFamily_fp {i} (H : IsNormal (f i)) (o : Ordinal.{max u v}) :\n    f i (derivFamily.{u, v} f o) = derivFamily.{u, v} f o", "start": [183, 1], "end": [193, 67], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_iff_derivFamily", "code": "theorem le_iff_derivFamily (H : \u2200 i, IsNormal (f i)) {a} :\n    (\u2200 i, f i a \u2264 a) \u2194 \u2203 o, derivFamily.{u, v} f o = a", "start": [196, 1], "end": [220, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.fp_iff_derivFamily", "code": "theorem fp_iff_derivFamily (H : \u2200 i, IsNormal (f i)) {a} :\n    (\u2200 i, f i a = a) \u2194 \u2203 o, derivFamily.{u, v} f o = a", "start": [223, 1], "end": [225, 99], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivFamily_eq_enumOrd", "code": "theorem derivFamily_eq_enumOrd (H : \u2200 i, IsNormal (f i)) :\n    derivFamily.{u, v} f = enumOrd (\u22c2 i, Function.fixedPoints (f i))", "start": [228, 1], "end": [239, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily", "code": "def nfpBFamily (o : Ordinal) (f : \u2200 b < o, Ordinal \u2192 Ordinal) : Ordinal \u2192 Ordinal :=\n  nfpFamily (familyOfBFamily o f)", "start": [251, 1], "end": [255, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_eq_nfpFamily", "code": "theorem nfpBFamily_eq_nfpFamily {o : Ordinal} (f : \u2200 b < o, Ordinal \u2192 Ordinal) :\n    nfpBFamily.{u, v} o f = nfpFamily.{u, v} (familyOfBFamily o f)", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.foldr_le_nfpBFamily", "code": "theorem foldr_le_nfpBFamily {o : Ordinal}\n    (f : \u2200 b < o, Ordinal \u2192 Ordinal) (a l) :\n    List.foldr (familyOfBFamily o f) a l \u2264 nfpBFamily.{u, v} o f a", "start": [263, 1], "end": [266, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_nfpBFamily", "code": "theorem le_nfpBFamily {o : Ordinal} (f : \u2200 b < o, Ordinal \u2192 Ordinal) (a) :\n    a \u2264 nfpBFamily.{u, v} o f a", "start": [269, 1], "end": [271, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_nfpBFamily", "code": "theorem lt_nfpBFamily {a b} :\n    a < nfpBFamily.{u, v} o f b \u2194 \u2203 l, a < List.foldr (familyOfBFamily o f) b l", "start": [274, 1], "end": [276, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_le_iff", "code": "theorem nfpBFamily_le_iff {o : Ordinal} {f : \u2200 b < o, Ordinal \u2192 Ordinal} {a b} :\n    nfpBFamily.{u, v} o f a \u2264 b \u2194 \u2200 l, List.foldr (familyOfBFamily o f) a l \u2264 b", "start": [279, 1], "end": [281, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_le", "code": "theorem nfpBFamily_le {o : Ordinal} {f : \u2200 b < o, Ordinal \u2192 Ordinal} {a b} :\n    (\u2200 l, List.foldr (familyOfBFamily o f) a l \u2264 b) \u2192 nfpBFamily.{u, v} o f a \u2264 b", "start": [284, 1], "end": [286, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_monotone", "code": "theorem nfpBFamily_monotone (hf : \u2200 i hi, Monotone (f i hi)) : Monotone (nfpBFamily.{u, v} o f)", "start": [289, 1], "end": [290, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_lt_nfpBFamily", "code": "theorem apply_lt_nfpBFamily (H : \u2200 i hi, IsNormal (f i hi)) {a b} (hb : b < nfpBFamily.{u, v} o f a)\n    (i hi) : f i hi b < nfpBFamily.{u, v} o f a", "start": [293, 1], "end": [296, 47], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_lt_nfpBFamily_iff", "code": "theorem apply_lt_nfpBFamily_iff (ho : o \u2260 0) (H : \u2200 i hi, IsNormal (f i hi)) {a b} :\n    (\u2200 i hi, f i hi b < nfpBFamily.{u, v} o f a) \u2194 b < nfpBFamily.{u, v} o f a", "start": [299, 1], "end": [304, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_le_apply", "code": "theorem nfpBFamily_le_apply (ho : o \u2260 0) (H : \u2200 i hi, IsNormal (f i hi)) {a b} :\n    (\u2203 i hi, nfpBFamily.{u, v} o f a \u2264 f i hi b) \u2194 nfpBFamily.{u, v} o f a \u2264 b", "start": [307, 1], "end": [311, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_le_fp", "code": "theorem nfpBFamily_le_fp (H : \u2200 i hi, Monotone (f i hi)) {a b} (ab : a \u2264 b)\n    (h : \u2200 i hi, f i hi b \u2264 b) : nfpBFamily.{u, v} o f a \u2264 b", "start": [314, 1], "end": [316, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_fp", "code": "theorem nfpBFamily_fp {i hi} (H : IsNormal (f i hi)) (a) :\n    f i hi (nfpBFamily.{u, v} o f a) = nfpBFamily.{u, v} o f a", "start": [319, 1], "end": [324, 10], "kind": "commanddeclaration"}, {"full_name": "Ordinal.apply_le_nfpBFamily", "code": "theorem apply_le_nfpBFamily (ho : o \u2260 0) (H : \u2200 i hi, IsNormal (f i hi)) {a b} :\n    (\u2200 i hi, f i hi b \u2264 nfpBFamily.{u, v} o f a) \u2194 b \u2264 nfpBFamily.{u, v} o f a", "start": [327, 1], "end": [333, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_eq_self", "code": "theorem nfpBFamily_eq_self {a} (h : \u2200 i hi, f i hi a = a) : nfpBFamily.{u, v} o f a = a", "start": [336, 1], "end": [337, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.fp_bfamily_unbounded", "code": "theorem fp_bfamily_unbounded (H : \u2200 i hi, IsNormal (f i hi)) :\n    (\u22c2 (i) (hi), Function.fixedPoints (f i hi)).Unbounded (\u00b7 < \u00b7)", "start": [340, 1], "end": [346, 76], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivBFamily", "code": "def derivBFamily (o : Ordinal) (f : \u2200 b < o, Ordinal \u2192 Ordinal) : Ordinal \u2192 Ordinal :=\n  derivFamily (familyOfBFamily o f)", "start": [349, 1], "end": [353, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivBFamily_eq_derivFamily", "code": "theorem derivBFamily_eq_derivFamily {o : Ordinal} (f : \u2200 b < o, Ordinal \u2192 Ordinal) :\n    derivBFamily.{u, v} o f = derivFamily.{u, v} (familyOfBFamily o f)", "start": [356, 1], "end": [358, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivBFamily_isNormal", "code": "theorem derivBFamily_isNormal {o : Ordinal} (f : \u2200 b < o, Ordinal \u2192 Ordinal) :\n    IsNormal (derivBFamily o f)", "start": [361, 1], "end": [363, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivBFamily_fp", "code": "theorem derivBFamily_fp {i hi} (H : IsNormal (f i hi)) (a : Ordinal) :\n    f i hi (derivBFamily.{u, v} o f a) = derivBFamily.{u, v} o f a", "start": [366, 1], "end": [371, 10], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_iff_derivBFamily", "code": "theorem le_iff_derivBFamily (H : \u2200 i hi, IsNormal (f i hi)) {a} :\n    (\u2200 i hi, f i hi a \u2264 a) \u2194 \u2203 b, derivBFamily.{u, v} o f b = a", "start": [374, 1], "end": [381, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.fp_iff_derivBFamily", "code": "theorem fp_iff_derivBFamily (H : \u2200 i hi, IsNormal (f i hi)) {a} :\n    (\u2200 i hi, f i hi a = a) \u2194 \u2203 b, derivBFamily.{u, v} o f b = a", "start": [384, 1], "end": [389, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.derivBFamily_eq_enumOrd", "code": "theorem derivBFamily_eq_enumOrd (H : \u2200 i hi, IsNormal (f i hi)) :\n    derivBFamily.{u, v} o f = enumOrd (\u22c2 (i) (hi), Function.fixedPoints (f i hi))", "start": [392, 1], "end": [400, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp", "code": "def nfp (f : Ordinal \u2192 Ordinal) : Ordinal \u2192 Ordinal :=\n  nfpFamily fun _ : Unit => f", "start": [412, 1], "end": [416, 30], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_eq_nfpFamily", "code": "theorem nfp_eq_nfpFamily (f : Ordinal \u2192 Ordinal) : nfp f = nfpFamily fun _ : Unit => f", "start": [419, 1], "end": [420, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_iterate_eq_nfp", "code": "@[simp]\ntheorem sup_iterate_eq_nfp (f : Ordinal.{u} \u2192 Ordinal.{u}) :\n    (fun a => sup fun n : \u2115 => f^[n] a) = nfp f", "start": [423, 1], "end": [432, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.iterate_le_nfp", "code": "theorem iterate_le_nfp (f a n) : f^[n] a \u2264 nfp f a", "start": [435, 1], "end": [437, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_nfp", "code": "theorem le_nfp (f a) : a \u2264 nfp f a", "start": [440, 1], "end": [441, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_nfp", "code": "theorem lt_nfp {a b} : a < nfp f b \u2194 \u2203 n, a < f^[n] b", "start": [444, 1], "end": [446, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_le_iff", "code": "theorem nfp_le_iff {a b} : nfp f a \u2264 b \u2194 \u2200 n, f^[n] a \u2264 b", "start": [449, 1], "end": [451, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_le", "code": "theorem nfp_le {a b} : (\u2200 n, f^[n] a \u2264 b) \u2192 nfp f a \u2264 b", "start": [454, 1], "end": [455, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_id", "code": "@[simp]\ntheorem nfp_id : nfp id = id", "start": [458, 1], "end": [462, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_monotone", "code": "theorem nfp_monotone (hf : Monotone f) : Monotone (nfp f)", "start": [465, 1], "end": [466, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.apply_lt_nfp", "code": "theorem IsNormal.apply_lt_nfp {f} (H : IsNormal f) {a b} : f b < nfp f a \u2194 b < nfp f a", "start": [469, 1], "end": [472, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.nfp_le_apply", "code": "theorem IsNormal.nfp_le_apply {f} (H : IsNormal f) {a b} : nfp f a \u2264 f b \u2194 nfp f a \u2264 b", "start": [475, 1], "end": [476, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_le_fp", "code": "theorem nfp_le_fp {f} (H : Monotone f) {a b} (ab : a \u2264 b) (h : f b \u2264 b) : nfp f a \u2264 b", "start": [479, 1], "end": [480, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.nfp_fp", "code": "theorem IsNormal.nfp_fp {f} (H : IsNormal f) : \u2200 a, f (nfp f a) = nfp f a", "start": [483, 1], "end": [484, 46], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.apply_le_nfp", "code": "theorem IsNormal.apply_le_nfp {f} (H : IsNormal f) {a b} : f b \u2264 nfp f a \u2194 b \u2264 nfp f a", "start": [487, 1], "end": [488, 81], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_eq_self", "code": "theorem nfp_eq_self {f : Ordinal \u2192 Ordinal} {a} (h : f a = a) : nfp f a = a", "start": [491, 1], "end": [492, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.fp_unbounded", "code": "theorem fp_unbounded (H : IsNormal f) : (Function.fixedPoints f).Unbounded (\u00b7 < \u00b7)", "start": [495, 1], "end": [499, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv", "code": "def deriv (f : Ordinal \u2192 Ordinal) : Ordinal \u2192 Ordinal :=\n  derivFamily fun _ : Unit => f", "start": [502, 1], "end": [506, 32], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_eq_derivFamily", "code": "theorem deriv_eq_derivFamily (f : Ordinal \u2192 Ordinal) : deriv f = derivFamily fun _ : Unit => f", "start": [509, 1], "end": [510, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_zero", "code": "@[simp]\ntheorem deriv_zero (f) : deriv f 0 = nfp f 0", "start": [513, 1], "end": [515, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_succ", "code": "@[simp]\ntheorem deriv_succ (f o) : deriv f (succ o) = nfp f (succ (deriv f o))", "start": [518, 1], "end": [520, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_limit", "code": "theorem deriv_limit (f) {o} : IsLimit o \u2192 deriv f o = bsup.{u, 0} o fun a _ => deriv f a", "start": [523, 1], "end": [524, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_isNormal", "code": "theorem deriv_isNormal (f) : IsNormal (deriv f)", "start": [527, 1], "end": [528, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_id_of_nfp_id", "code": "theorem deriv_id_of_nfp_id {f : Ordinal \u2192 Ordinal} (h : nfp f = id) : deriv f = id", "start": [531, 1], "end": [532, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.deriv_fp", "code": "theorem IsNormal.deriv_fp {f} (H : IsNormal f) : \u2200 o, f (deriv f o) = deriv f o", "start": [535, 1], "end": [536, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.le_iff_deriv", "code": "theorem IsNormal.le_iff_deriv {f} (H : IsNormal f) {a} : f a \u2264 a \u2194 \u2203 o, deriv f o = a", "start": [539, 1], "end": [542, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.fp_iff_deriv", "code": "theorem IsNormal.fp_iff_deriv {f} (H : IsNormal f) {a} : f a = a \u2194 \u2203 o, deriv f o = a", "start": [545, 1], "end": [546, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_eq_enumOrd", "code": "theorem deriv_eq_enumOrd (H : IsNormal f) : deriv f = enumOrd (Function.fixedPoints f)", "start": [549, 1], "end": [552, 34], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_eq_id_of_nfp_eq_id", "code": "theorem deriv_eq_id_of_nfp_eq_id {f : Ordinal \u2192 Ordinal} (h : nfp f = id) : deriv f = id", "start": [555, 1], "end": [556, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_add_zero", "code": "@[simp]\ntheorem nfp_add_zero (a) : nfp (a + \u00b7) 0 = a * omega", "start": [564, 1], "end": [571, 74], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_add_eq_mul_omega", "code": "theorem nfp_add_eq_mul_omega {a b} (hba : b \u2264 a * omega) : nfp (a + \u00b7) b = a * omega", "start": [574, 1], "end": [578, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_eq_right_iff_mul_omega_le", "code": "theorem add_eq_right_iff_mul_omega_le {a b : Ordinal} : a + b = b \u2194 a * omega \u2264 b", "start": [581, 1], "end": [589, 52], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_le_right_iff_mul_omega_le", "code": "theorem add_le_right_iff_mul_omega_le {a b : Ordinal} : a + b \u2264 b \u2194 a * omega \u2264 b", "start": [592, 1], "end": [594, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_add_eq_mul_omega_add", "code": "theorem deriv_add_eq_mul_omega_add (a b : Ordinal.{u}) : deriv (a + \u00b7) b = a * omega + b", "start": [597, 1], "end": [604, 95], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_mul_one", "code": "@[simp]\ntheorem nfp_mul_one {a : Ordinal} (ha : 0 < a) : nfp (a * \u00b7) 1 = (a^omega)", "start": [612, 1], "end": [622, 13], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_mul_zero", "code": "@[simp]\ntheorem nfp_mul_zero (a : Ordinal) : nfp (a * \u00b7) 0 = 0", "start": [625, 1], "end": [630, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_zero_mul", "code": "@[simp]\ntheorem nfp_zero_mul : nfp (HMul.hMul 0) = id", "start": [633, 1], "end": [642, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_mul_zero", "code": "@[simp]\ntheorem deriv_mul_zero : deriv (HMul.hMul 0) = id", "start": [645, 1], "end": [647, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_mul_eq_opow_omega", "code": "theorem nfp_mul_eq_opow_omega {a b : Ordinal} (hb : 0 < b) (hba : b \u2264 (a^omega)) :\n    nfp (a * \u00b7) b = (a^omega.{u})", "start": [650, 1], "end": [660, 70], "kind": "commanddeclaration"}, {"full_name": "Ordinal.eq_zero_or_opow_omega_le_of_mul_eq_right", "code": "theorem eq_zero_or_opow_omega_le_of_mul_eq_right {a b : Ordinal} (hab : a * b = b) :\n    b = 0 \u2228 (a^omega.{u}) \u2264 b", "start": [663, 1], "end": [672, 63], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_eq_right_iff_opow_omega_dvd", "code": "theorem mul_eq_right_iff_opow_omega_dvd {a b : Ordinal} : a * b = b \u2194 (a^omega) \u2223 b", "start": [675, 1], "end": [688, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_le_right_iff_opow_omega_dvd", "code": "theorem mul_le_right_iff_opow_omega_dvd {a b : Ordinal} (ha : 0 < a) :\n    a * b \u2264 b \u2194 (a^omega) \u2223 b", "start": [691, 1], "end": [694, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_mul_opow_omega_add", "code": "theorem nfp_mul_opow_omega_add {a c : Ordinal} (b) (ha : 0 < a) (hc : 0 < c) (hca : c \u2264 (a^omega)) :\n    nfp (a * \u00b7) ((a^omega) * b + c) = (a^omega.{u}) * succ b", "start": [697, 1], "end": [712, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.deriv_mul_eq_opow_omega_mul", "code": "theorem deriv_mul_eq_opow_omega_mul {a : Ordinal.{u}} (ha : 0 < a) (b) :\n    deriv (a * \u00b7) b = (a^omega) * b", "start": [715, 1], "end": [723, 85], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Compact.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "Mathlib/Topology/UniformSpace/Equicontinuity.lean", "Mathlib/Topology/Support.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "nhdsSet_diagonal_eq_uniformity", "code": "theorem nhdsSet_diagonal_eq_uniformity [CompactSpace \u03b1] : \ud835\udcdd\u02e2 (diagonal \u03b1) = \ud835\udce4 \u03b1", "start": [48, 1], "end": [59, 47], "kind": "commanddeclaration"}, {"full_name": "compactSpace_uniformity", "code": "theorem compactSpace_uniformity [CompactSpace \u03b1] : \ud835\udce4 \u03b1 = \u2a06 x, \ud835\udcdd (x, x)", "start": [62, 1], "end": [65, 65], "kind": "commanddeclaration"}, {"full_name": "unique_uniformity_of_compact", "code": "theorem unique_uniformity_of_compact [t : TopologicalSpace \u03b3] [CompactSpace \u03b3]\n    {u u' : UniformSpace \u03b3} (h : u.toTopologicalSpace = t) (h' : u'.toTopologicalSpace = t) :\n    u = u'", "start": [68, 1], "end": [74, 68], "kind": "commanddeclaration"}, {"full_name": "uniformSpaceOfCompactT2", "code": "def uniformSpaceOfCompactT2 [TopologicalSpace \u03b3] [CompactSpace \u03b3] [T2Space \u03b3] : UniformSpace \u03b3\n    where\n  uniformity := \ud835\udcdd\u02e2 (diagonal \u03b3)\n  refl := principal_le_nhdsSet\n  symm := continuous_swap.tendsto_nhdsSet fun x => Eq.symm\n  comp := by\n    \n    set \ud835\udcdd\u0394 := \ud835\udcdd\u02e2 (diagonal \u03b3)\n    set F := \ud835\udcdd\u0394.lift' fun s : Set (\u03b3 \u00d7 \u03b3) => s \u25cb s\n    rw [le_iff_forall_inf_principal_compl]\n    intro V V_in\n    by_contra H\n    haveI : NeBot (F \u2293 \ud835\udcdf V\u1d9c) := \u27e8H\u27e9\n    obtain \u27e8\u27e8x, y\u27e9, hxy\u27e9 : \u2203 p : \u03b3 \u00d7 \u03b3, ClusterPt p (F \u2293 \ud835\udcdf V\u1d9c) := cluster_point_of_compact _\n    have clV : ClusterPt (x, y) (\ud835\udcdf <| V\u1d9c) := hxy.of_inf_right\n    have : (x, y) \u2209 interior V := by\n      have : (x, y) \u2208 closure V\u1d9c := by rwa [mem_closure_iff_clusterPt]\n      rwa [closure_compl] at this\n    have diag_subset : diagonal \u03b3 \u2286 interior V := subset_interior_iff_mem_nhdsSet.2 V_in\n    have x_ne_y : x \u2260 y := mt (@diag_subset (x, y)) this\n    obtain\n      \u27e8U\u2081, _, V\u2081, V\u2081_in, U\u2082, _, V\u2082, V\u2082_in, V\u2081_cl, V\u2082_cl, U\u2081_op, U\u2082_op, VU\u2081, VU\u2082, hU\u2081\u2082\u27e9 :=\n      disjoint_nested_nhds x_ne_y\n    let U\u2083 := (V\u2081 \u222a V\u2082)\u1d9c\n    have U\u2083_op : IsOpen U\u2083 := (V\u2081_cl.union V\u2082_cl).isOpen_compl\n    let W := U\u2081 \u00d7\u02e2 U\u2081 \u222a U\u2082 \u00d7\u02e2 U\u2082 \u222a U\u2083 \u00d7\u02e2 U\u2083\n    have W_in : W \u2208 \ud835\udcdd\u0394 := by\n      rw [mem_nhdsSet_iff_forall]\n      rintro \u27e8z, z'\u27e9 (rfl : z = z')\n      refine' IsOpen.mem_nhds _ _\n      \u00b7 apply_rules [IsOpen.union, IsOpen.prod]\n      \u00b7 simp only [mem_union, mem_prod, and_self_iff]\n        exact (_root_.em _).imp_left fun h => union_subset_union VU\u2081 VU\u2082 h\n    have : W \u25cb W \u2208 F := @mem_lift' _ _ _ (fun s => s \u25cb s) _ W_in\n      have hV\u2081\u2082 : V\u2081 \u00d7\u02e2 V\u2082 \u2208 \ud835\udcdd (x, y) := prod_mem_nhds V\u2081_in V\u2082_in\n    obtain \u27e8\u27e8u, v\u27e9, \u27e8u_in, v_in\u27e9, w, huw, hwv\u27e9 := clusterPt_iff.mp hxy.of_inf_left hV\u2081\u2082 this\n    have uw_in : (u, w) \u2208 U\u2081 \u00d7\u02e2 U\u2081 :=\n      (huw.resolve_right fun h => h.1 <| Or.inl u_in).resolve_right fun h =>\n        hU\u2081\u2082.le_bot \u27e8VU\u2081 u_in, h.1\u27e9\n    have wv_in : (w, v) \u2208 U\u2082 \u00d7\u02e2 U\u2082 :=\n      (hwv.resolve_right fun h => h.2 <| Or.inr v_in).resolve_left fun h =>\n        hU\u2081\u2082.le_bot \u27e8h.2, VU\u2082 v_in\u27e9\n    exact hU\u2081\u2082.le_bot \u27e8uw_in.2, wv_in.1\u27e9\n  isOpen_uniformity := by\n    suffices \u2200 x : \u03b3, Filter.comap (Prod.mk x) (\ud835\udcdd\u02e2 (diagonal \u03b3)) = \ud835\udcdd x by\n      intro s\n      simp_rw [isOpen_iff_mem_nhds, \u2190 mem_comap_prod_mk, this]\n    intro x\n    simp_rw [nhdsSet_diagonal, comap_iSup, nhds_prod_eq, comap_prod, (\u00b7 \u2218 \u00b7), comap_id']\n    rw [iSup_split_single _ x, comap_const_of_mem fun V => mem_of_mem_nhds]\n    suffices \u2200 (y) (_ : y \u2260 x), comap (fun _ : \u03b3 => x) (\ud835\udcdd y) \u2293 \ud835\udcdd y \u2264 \ud835\udcdd x by simpa\n    intro y hxy\n    simp [comap_const_of_not_mem (compl_singleton_mem_nhds hxy) (Classical.not_not.2 rfl)]", "start": [77, 1], "end": [156, 91], "kind": "commanddeclaration"}, {"full_name": "CompactSpace.uniformContinuous_of_continuous", "code": "theorem CompactSpace.uniformContinuous_of_continuous [CompactSpace \u03b1] {f : \u03b1 \u2192 \u03b2}\n    (h : Continuous f) : UniformContinuous f", "start": [164, 1], "end": [171, 76], "kind": "commanddeclaration"}, {"full_name": "IsCompact.uniformContinuousOn_of_continuous", "code": "theorem IsCompact.uniformContinuousOn_of_continuous {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} (hs : IsCompact s)\n    (hf : ContinuousOn f s) : UniformContinuousOn f s", "start": [174, 1], "end": [181, 56], "kind": "commanddeclaration"}, {"full_name": "IsCompact.uniformContinuousAt_of_continuousAt", "code": "theorem IsCompact.uniformContinuousAt_of_continuousAt {r : Set (\u03b2 \u00d7 \u03b2)} {s : Set \u03b1}\n    (hs : IsCompact s) (f : \u03b1 \u2192 \u03b2) (hf : \u2200 a \u2208 s, ContinuousAt f a) (hr : r \u2208 \ud835\udce4 \u03b2) :\n    { x : \u03b1 \u00d7 \u03b1 | x.1 \u2208 s \u2192 (f x.1, f x.2) \u2208 r } \u2208 \ud835\udce4 \u03b1", "start": [184, 1], "end": [200, 60], "kind": "commanddeclaration"}, {"full_name": "Continuous.uniformContinuous_of_tendsto_cocompact", "code": "theorem Continuous.uniformContinuous_of_tendsto_cocompact {f : \u03b1 \u2192 \u03b2} {x : \u03b2}\n    (h_cont : Continuous f) (hx : Tendsto f (cocompact \u03b1) (\ud835\udcdd x)) : UniformContinuous f", "start": [203, 1], "end": [217, 53], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.is_one_at_infty", "code": "@[to_additive \"If `f` has compact support, then `f` tends to zero at infinity.\"]\ntheorem HasCompactMulSupport.is_one_at_infty {f : \u03b1 \u2192 \u03b3} [TopologicalSpace \u03b3] [One \u03b3]\n    (h : HasCompactMulSupport f) : Tendsto f (cocompact \u03b1) (\ud835\udcdd 1)", "start": [220, 1], "end": [231, 27], "kind": "commanddeclaration"}, {"full_name": "HasCompactMulSupport.uniformContinuous_of_continuous", "code": "@[to_additive]\ntheorem HasCompactMulSupport.uniformContinuous_of_continuous {f : \u03b1 \u2192 \u03b2} [One \u03b2]\n    (h1 : HasCompactMulSupport f) (h2 : Continuous f) : UniformContinuous f", "start": [235, 1], "end": [238, 63], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.tendstoUniformly", "code": "theorem ContinuousOn.tendstoUniformly [LocallyCompactSpace \u03b1] [CompactSpace \u03b2] [UniformSpace \u03b3]\n    {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {x : \u03b1} {U : Set \u03b1} (hxU : U \u2208 \ud835\udcdd x) (h : ContinuousOn (\u21bff) (U \u00d7\u02e2 univ)) :\n    TendstoUniformly f (f x) (\ud835\udcdd x)", "start": [242, 1], "end": [251, 34], "kind": "commanddeclaration"}, {"full_name": "Continuous.tendstoUniformly", "code": "theorem Continuous.tendstoUniformly [WeaklyLocallyCompactSpace \u03b1] [CompactSpace \u03b2] [UniformSpace \u03b3]\n    (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (h : Continuous \u21bff) (x : \u03b1) : TendstoUniformly f (f x) (\ud835\udcdd x)", "start": [254, 1], "end": [261, 28], "kind": "commanddeclaration"}, {"full_name": "CompactSpace.uniformEquicontinuous_of_equicontinuous", "code": "theorem CompactSpace.uniformEquicontinuous_of_equicontinuous {\u03b9 : Type*} {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1}\n    [CompactSpace \u03b2] (h : Equicontinuous F) : UniformEquicontinuous F", "start": [266, 1], "end": [272, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/DiscreteSubset.lean", "imports": ["Mathlib/Topology/Separation.lean", "Mathlib/Topology/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "tendsto_cofinite_cocompact_iff", "code": "lemma tendsto_cofinite_cocompact_iff :\n    Tendsto f cofinite (cocompact _) \u2194 \u2200 K, IsCompact K \u2192 Set.Finite (f \u207b\u00b9' K) := by\n  rw [hasBasis_cocompact.tendsto_right_iff]\n  refine' forall\u2082_congr (fun K _ \u21a6 _)\n  simp only [mem_compl_iff, eventually_cofinite, not_not, preimage]", "start": [44, 1], "end": [48, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Continuous.discrete_of_tendsto_cofinite_cocompact", "code": "lemma Continuous.discrete_of_tendsto_cofinite_cocompact [T1Space X] [WeaklyLocallyCompactSpace Y]\n    (hf' : Continuous f) (hf : Tendsto f cofinite (cocompact _)) :\n    DiscreteTopology X := by\n  refine' singletons_open_iff_discrete.mp (fun x \u21a6 _)\n  obtain \u27e8K : Set Y, hK : IsCompact K, hK' : K \u2208 \ud835\udcdd (f x)\u27e9 := exists_compact_mem_nhds (f x)\n  obtain \u27e8U : Set Y, hU\u2081 : U \u2286 K, hU\u2082 : IsOpen U, hU\u2083 : f x \u2208 U\u27e9 := mem_nhds_iff.mp hK'\n  have hU\u2084 : Set.Finite (f\u207b\u00b9' U) :=\n    Finite.subset (tendsto_cofinite_cocompact_iff.mp hf K hK) (preimage_mono hU\u2081)\n  exact isOpen_singleton_of_finite_mem_nhds _ ((hU\u2082.preimage hf').mem_nhds hU\u2083) hU\u2084", "start": [50, 1], "end": [58, 84], "kind": "mathlibtacticlemma"}, {"full_name": "tendsto_cofinite_cocompact_of_discrete", "code": "lemma tendsto_cofinite_cocompact_of_discrete [DiscreteTopology X]\n    (hf : Tendsto f (cocompact _) (cocompact _)) :\n    Tendsto f cofinite (cocompact _) := by\n  convert hf\n  rw [cocompact_eq_cofinite X]", "start": [60, 1], "end": [64, 31], "kind": "mathlibtacticlemma"}, {"full_name": "IsClosed.tendsto_coe_cofinite_of_discreteTopology", "code": "lemma IsClosed.tendsto_coe_cofinite_of_discreteTopology\n    {s : Set X} (hs : IsClosed s) (_hs' : DiscreteTopology s) :\n    Tendsto ((\u2191) : s \u2192 X) cofinite (cocompact _) :=\n  tendsto_cofinite_cocompact_of_discrete hs.closedEmbedding_subtype_val.tendsto_cocompact", "start": [66, 1], "end": [69, 90], "kind": "mathlibtacticlemma"}, {"full_name": "IsClosed.tendsto_coe_cofinite_iff", "code": "lemma IsClosed.tendsto_coe_cofinite_iff [T1Space X] [WeaklyLocallyCompactSpace X]\n    {s : Set X} (hs : IsClosed s) :\n    Tendsto ((\u2191) : s \u2192 X) cofinite (cocompact _) \u2194 DiscreteTopology s :=\n  \u27e8continuous_subtype_val.discrete_of_tendsto_cofinite_cocompact,\n   fun _ \u21a6 hs.tendsto_coe_cofinite_of_discreteTopology inferInstance\u27e9", "start": [71, 1], "end": [75, 70], "kind": "mathlibtacticlemma"}, {"full_name": "isClosed_and_discrete_iff", "code": "theorem isClosed_and_discrete_iff {S : Set X} :\n    IsClosed S \u2227 DiscreteTopology S \u2194 \u2200 x, Disjoint (\ud835\udcdd[\u2260] x) (\ud835\udcdf S)", "start": [81, 1], "end": [92, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.codiscrete", "code": "def Filter.codiscrete (X : Type*) [TopologicalSpace X] : Filter X where\n  sets := {U | IsOpen U \u2227 DiscreteTopology \u2191U\u1d9c}\n  univ_sets := \u27e8isOpen_univ, compl_univ.symm \u25b8 Subsingleton.discreteTopology\u27e9\n  sets_of_superset := by\n    intro U V hU hV\n    simp_rw [\u2190isClosed_compl_iff, isClosed_and_discrete_iff] at hU \u22a2\n    exact fun x \u21a6 (hU x).mono_right (principal_mono.mpr <| compl_subset_compl.mpr hV)\n  inter_sets := by\n    intro U V hU hV\n    simp_rw [\u2190isClosed_compl_iff, isClosed_and_discrete_iff] at hU hV \u22a2\n    exact fun x \u21a6 compl_inter U V \u25b8 sup_principal \u25b8 disjoint_sup_right.mpr \u27e8hU x, hV x\u27e9", "start": [94, 1], "end": [105, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/CompleteSeparated.lean", "imports": ["Mathlib/Topology/UniformSpace/Cauchy.lean", "Mathlib/Topology/UniformSpace/Separation.lean", "Mathlib/Topology/DenseEmbedding.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsComplete.isClosed", "code": "theorem IsComplete.isClosed [UniformSpace \u03b1] [SeparatedSpace \u03b1] {s : Set \u03b1} (h : IsComplete s) :\n    IsClosed s", "start": [25, 1], "end": [32, 59], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.continuous_extend_of_cauchy", "code": "theorem continuous_extend_of_cauchy {e : \u03b1 \u2192 \u03b2} {f : \u03b1 \u2192 \u03b3} (de : DenseInducing e)\n    (h : \u2200 b : \u03b2, Cauchy (map f (comap e <| \ud835\udcdd b))) : Continuous (de.extend f)", "start": [43, 1], "end": [45, 61], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Star/Prod.lean", "imports": ["Mathlib/Algebra/Module/Prod.lean", "Mathlib/Algebra/Ring/Prod.lean", "Mathlib/Algebra/Star/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Prod.fst_star", "code": "@[simp]\ntheorem fst_star [Star R] [Star S] (x : R \u00d7 S) : (star x).1 = star x.1", "start": [27, 1], "end": [29, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.snd_star", "code": "@[simp]\ntheorem snd_star [Star R] [Star S] (x : R \u00d7 S) : (star x).2 = star x.2", "start": [32, 1], "end": [34, 6], "kind": "commanddeclaration"}, {"full_name": "Prod.star_def", "code": "theorem star_def [Star R] [Star S] (x : R \u00d7 S) : star x = (star x.1, star x.2)", "start": [37, 1], "end": [38, 6], "kind": "commanddeclaration"}, {"full_name": "Units.embed_product_star", "code": "theorem Units.embed_product_star [Monoid R] [StarMul R] (u : R\u02e3) :\n    Units.embedProduct R (star u) = star (Units.embedProduct R u)", "start": [66, 1], "end": [68, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/AbstractCompletion.lean", "imports": ["Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Topology/UniformSpace/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AbstractCompletion", "code": "structure AbstractCompletion (\u03b1 : Type u) [UniformSpace \u03b1] where\n  \n  space : Type u\n  \n  coe : \u03b1 \u2192 space\n  \n  uniformStruct : UniformSpace space\n  \n  complete : CompleteSpace space\n  \n  separation : SeparatedSpace space\n  \n  uniformInducing : UniformInducing coe\n  \n  dense : DenseRange coe", "start": [57, 1], "end": [73, 25], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.ofComplete", "code": "def ofComplete [SeparatedSpace \u03b1] [CompleteSpace \u03b1] : AbstractCompletion \u03b1 :=\n  mk \u03b1 id inferInstance inferInstance inferInstance uniformInducing_id denseRange_id", "start": [87, 1], "end": [89, 85], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.closure_range", "code": "theorem closure_range : closure (range \u03b9) = univ", "start": [92, 1], "end": [93, 26], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.denseInducing", "code": "theorem denseInducing : DenseInducing \u03b9", "start": [96, 1], "end": [97, 44], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_coe", "code": "theorem uniformContinuous_coe : UniformContinuous \u03b9", "start": [100, 1], "end": [101, 56], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.continuous_coe", "code": "theorem continuous_coe : Continuous \u03b9", "start": [104, 1], "end": [105, 39], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {p : hat\u03b1 \u2192 Prop} (a : hat\u03b1) (hp : IsClosed { a | p a }) (ih : \u2200 a, p (\u03b9 a)) :\n    p a", "start": [108, 1], "end": [111, 38], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.funext", "code": "protected theorem funext [TopologicalSpace \u03b2] [T2Space \u03b2] {f g : hat\u03b1 \u2192 \u03b2} (hf : Continuous f)\n    (hg : Continuous g) (h : \u2200 a, f (\u03b9 a) = g (\u03b9 a)) : f = g", "start": [116, 1], "end": [118, 59], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend", "code": "protected def extend (f : \u03b1 \u2192 \u03b2) : hat\u03b1 \u2192 \u03b2 :=\n  if UniformContinuous f then pkg.denseInducing.extend f else fun x => f (pkg.dense.some x)", "start": [125, 1], "end": [127, 92], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend_def", "code": "theorem extend_def (hf : UniformContinuous f) : pkg.extend f = pkg.denseInducing.extend f", "start": [132, 1], "end": [133, 12], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend_coe", "code": "theorem extend_coe [T2Space \u03b2] (hf : UniformContinuous f) (a : \u03b1) : (pkg.extend f) (\u03b9 a) = f a", "start": [136, 1], "end": [138, 52], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_extend", "code": "theorem uniformContinuous_extend : UniformContinuous (pkg.extend f)", "start": [143, 1], "end": [149, 59], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.continuous_extend", "code": "theorem continuous_extend : Continuous (pkg.extend f)", "start": [152, 1], "end": [153, 42], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend_unique", "code": "theorem extend_unique (hf : UniformContinuous f) {g : hat\u03b1 \u2192 \u03b2} (hg : UniformContinuous g)\n    (h : \u2200 a : \u03b1, f a = g (\u03b9 a)) : pkg.extend f = g", "start": [158, 1], "end": [161, 41], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend_comp_coe", "code": "@[simp]\ntheorem extend_comp_coe {f : hat\u03b1 \u2192 \u03b2} (hf : UniformContinuous f) : pkg.extend (f \u2218 \u03b9) = f", "start": [164, 1], "end": [168, 62], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) : hat\u03b1 \u2192 hat\u03b2 :=\n  pkg.extend (\u03b9' \u2218 f)", "start": [181, 1], "end": [183, 22], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_map", "code": "theorem uniformContinuous_map : UniformContinuous (map f)", "start": [190, 1], "end": [191, 31], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.continuous_map", "code": "@[continuity]\ntheorem continuous_map : Continuous (map f)", "start": [194, 1], "end": [196, 24], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map_coe", "code": "@[simp]\ntheorem map_coe (hf : UniformContinuous f) (a : \u03b1) : map f (\u03b9 a) = \u03b9' (f a)", "start": [201, 1], "end": [203, 56], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map_unique", "code": "theorem map_unique {f : \u03b1 \u2192 \u03b2} {g : hat\u03b1 \u2192 hat\u03b2} (hg : UniformContinuous g)\n    (h : \u2200 a, \u03b9' (f a) = g (\u03b9 a)) : map f = g", "start": [206, 1], "end": [212, 60], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map_id", "code": "@[simp]\ntheorem map_id : pkg.map pkg id = id", "start": [215, 1], "end": [217, 55], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend_map", "code": "theorem extend_map [CompleteSpace \u03b3] [SeparatedSpace \u03b3] {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2}\n    (hf : UniformContinuous f) (hg : UniformContinuous g) :\n    pkg'.extend f \u2218 map g = pkg.extend (f \u2218 g)", "start": [222, 1], "end": [228, 8], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map_comp", "code": "theorem map_comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : UniformContinuous g) (hf : UniformContinuous f) :\n    pkg'.map pkg'' g \u2218 pkg.map pkg' f = pkg.map pkg'' (g \u2218 f)", "start": [233, 1], "end": [235, 63], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.compare", "code": "def compare : pkg.space \u2192 pkg'.space :=\n  pkg.extend pkg'.coe", "start": [245, 1], "end": [247, 22], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_compare", "code": "theorem uniformContinuous_compare : UniformContinuous (pkg.compare pkg')", "start": [250, 1], "end": [251, 31], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.compare_coe", "code": "theorem compare_coe (a : \u03b1) : pkg.compare pkg' (pkg.coe a) = pkg'.coe a", "start": [254, 1], "end": [255, 46], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.inverse_compare", "code": "theorem inverse_compare : pkg.compare pkg' \u2218 pkg'.compare pkg = id", "start": [258, 1], "end": [264, 6], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.compareEquiv", "code": "def compareEquiv : pkg.space \u2243\u1d64 pkg'.space\n    where\n  toFun := pkg.compare pkg'\n  invFun := pkg'.compare pkg\n  left_inv := congr_fun (pkg'.inverse_compare pkg)\n  right_inv := congr_fun (pkg.inverse_compare pkg')\n  uniformContinuous_toFun := uniformContinuous_compare _ _\n  uniformContinuous_invFun := uniformContinuous_compare _ _", "start": [267, 1], "end": [275, 60], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_compareEquiv", "code": "theorem uniformContinuous_compareEquiv : UniformContinuous (pkg.compareEquiv pkg')", "start": [278, 1], "end": [279, 37], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_compareEquiv_symm", "code": "theorem uniformContinuous_compareEquiv_symm : UniformContinuous (pkg.compareEquiv pkg').symm", "start": [282, 1], "end": [283, 37], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.prod", "code": "protected def prod : AbstractCompletion (\u03b1 \u00d7 \u03b2)\n    where\n  space := hat\u03b1 \u00d7 hat\u03b2\n  coe p := \u27e8\u03b9 p.1, \u03b9' p.2\u27e9\n  uniformStruct := inferInstance\n  complete := inferInstance\n  separation := inferInstance\n  uniformInducing := UniformInducing.prod pkg.uniformInducing pkg'.uniformInducing\n  dense := DenseRange.prod_map pkg.dense pkg'.dense", "start": [296, 1], "end": [305, 52], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extend\u2082", "code": "protected def extend\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : hat\u03b1 \u2192 hat\u03b2 \u2192 \u03b3 :=\n  curry <| (pkg.prod pkg').extend (uncurry f)", "start": [322, 1], "end": [324, 46], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.extension\u2082_coe_coe", "code": "theorem extension\u2082_coe_coe (hf : UniformContinuous <| uncurry f) (a : \u03b1) (b : \u03b2) :\n    pkg.extend\u2082 pkg' f (\u03b9 a) (\u03b9' b) = f a b", "start": [331, 1], "end": [334, 36], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_extension\u2082", "code": "theorem uniformContinuous_extension\u2082 : UniformContinuous\u2082 (pkg.extend\u2082 pkg' f)", "start": [343, 1], "end": [345, 33], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map\u2082", "code": "protected def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : hat\u03b1 \u2192 hat\u03b2 \u2192 hat\u03b3 :=\n  pkg.extend\u2082 pkg' (pkg''.coe \u2218\u2082 f)", "start": [366, 1], "end": [368, 36], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.uniformContinuous_map\u2082", "code": "theorem uniformContinuous_map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : UniformContinuous\u2082 (pkg.map\u2082 pkg' pkg'' f)", "start": [371, 1], "end": [372, 61], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.continuous_map\u2082", "code": "theorem continuous_map\u2082 {\u03b4} [TopologicalSpace \u03b4] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : \u03b4 \u2192 hat\u03b1} {b : \u03b4 \u2192 hat\u03b2}\n    (ha : Continuous a) (hb : Continuous b) :\n    Continuous fun d : \u03b4 => pkg.map\u2082 pkg' pkg'' f (a d) (b d)", "start": [375, 1], "end": [378, 93], "kind": "commanddeclaration"}, {"full_name": "AbstractCompletion.map\u2082_coe_coe", "code": "theorem map\u2082_coe_coe (a : \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : UniformContinuous\u2082 f) :\n    pkg.map\u2082 pkg' pkg'' f (\u03b9 a) (\u03b9' b) = \u03b9'' (f a b)", "start": [381, 1], "end": [383, 94], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Set/Intervals/ProjIcc.lean", "imports": ["Mathlib/Data/Set/Intervals/OrdConnected.lean", "Mathlib/Data/Set/Function.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.projIci", "code": "def projIci (a x : \u03b1) : Ici a := \u27e8max a x, le_max_left _ _\u27e9", "start": [39, 1], "end": [40, 60], "kind": "commanddeclaration"}, {"full_name": "Set.projIic", "code": "def projIic (b x : \u03b1) : Iic b := \u27e8min b x, min_le_left _ _\u27e9", "start": [43, 1], "end": [44, 60], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc", "code": "def projIcc (a b : \u03b1) (h : a \u2264 b) (x : \u03b1) : Icc a b :=\n  \u27e8max a (min b x), le_max_left _ _, max_le h (min_le_left _ _)\u27e9", "start": [47, 1], "end": [49, 65], "kind": "commanddeclaration"}, {"full_name": "Set.coe_projIci", "code": "@[norm_cast]\ntheorem coe_projIci (a x : \u03b1) : (projIci a x : \u03b1) = max a x", "start": [54, 1], "end": [55, 67], "kind": "commanddeclaration"}, {"full_name": "Set.coe_projIic", "code": "@[norm_cast]\ntheorem coe_projIic (b x : \u03b1) : (projIic b x : \u03b1) = min b x", "start": [58, 1], "end": [59, 67], "kind": "commanddeclaration"}, {"full_name": "Set.coe_projIcc", "code": "@[norm_cast]\ntheorem coe_projIcc (a b : \u03b1) (h : a \u2264 b) (x : \u03b1) : (projIcc a b h x : \u03b1) = max a (min b x)", "start": [62, 1], "end": [63, 99], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_of_le", "code": "theorem projIci_of_le (hx : x \u2264 a) : projIci a x = \u27e8a, le_rfl\u27e9", "start": [66, 1], "end": [66, 95], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_of_le", "code": "theorem projIic_of_le (hx : b \u2264 x) : projIic b x = \u27e8b, le_rfl\u27e9", "start": [69, 1], "end": [69, 95], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_of_le_left", "code": "theorem projIcc_of_le_left (hx : x \u2264 a) : projIcc a b h x = \u27e8a, left_mem_Icc.2 h\u27e9", "start": [72, 1], "end": [73, 33], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_of_right_le", "code": "theorem projIcc_of_right_le (hx : b \u2264 x) : projIcc a b h x = \u27e8b, right_mem_Icc.2 h\u27e9", "start": [77, 1], "end": [78, 24], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_self", "code": "@[simp]\ntheorem projIci_self (a : \u03b1) : projIci a a = \u27e8a, le_rfl\u27e9", "start": [81, 1], "end": [82, 81], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_self", "code": "@[simp]\ntheorem projIic_self (b : \u03b1) : projIic b b = \u27e8b, le_rfl\u27e9", "start": [85, 1], "end": [86, 81], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_left", "code": "@[simp]\ntheorem projIcc_left : projIcc a b h a = \u27e8a, left_mem_Icc.2 h\u27e9", "start": [89, 1], "end": [91, 30], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_right", "code": "@[simp]\ntheorem projIcc_right : projIcc a b h b = \u27e8b, right_mem_Icc.2 h\u27e9", "start": [94, 1], "end": [96, 31], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_eq_self", "code": "theorem projIci_eq_self : projIci a x = \u27e8a, le_rfl\u27e9 \u2194 x \u2264 a", "start": [99, 1], "end": [99, 98], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_eq_self", "code": "theorem projIic_eq_self : projIic b x = \u27e8b, le_rfl\u27e9 \u2194 b \u2264 x", "start": [102, 1], "end": [102, 98], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_eq_left", "code": "theorem projIcc_eq_left (h : a < b) : projIcc a b h.le x = \u27e8a, left_mem_Icc.mpr h.le\u27e9 \u2194 x \u2264 a", "start": [105, 1], "end": [106, 44], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_eq_right", "code": "theorem projIcc_eq_right (h : a < b) : projIcc a b h.le x = \u27e8b, right_mem_Icc.2 h.le\u27e9 \u2194 b \u2264 x", "start": [109, 1], "end": [110, 72], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_of_mem", "code": "theorem projIci_of_mem (hx : x \u2208 Ici a) : projIci a x = \u27e8x, hx\u27e9", "start": [113, 1], "end": [113, 86], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_of_mem", "code": "theorem projIic_of_mem (hx : x \u2208 Iic b) : projIic b x = \u27e8x, hx\u27e9", "start": [116, 1], "end": [116, 86], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_of_mem", "code": "theorem projIcc_of_mem (hx : x \u2208 Icc a b) : projIcc a b h x = \u27e8x, hx\u27e9", "start": [119, 1], "end": [120, 29], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_coe", "code": "@[simp]\ntheorem projIci_coe (x : Ici a) : projIci a x = x", "start": [123, 1], "end": [124, 86], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_coe", "code": "@[simp]\ntheorem projIic_coe (x : Iic b) : projIic b x = x", "start": [127, 1], "end": [128, 86], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_val", "code": "@[simp]\ntheorem projIcc_val (x : Icc a b) : projIcc a b h x = x", "start": [131, 1], "end": [134, 23], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_surjOn", "code": "theorem projIci_surjOn : SurjOn (projIci a) (Ici a) univ", "start": [137, 1], "end": [137, 95], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_surjOn", "code": "theorem projIic_surjOn : SurjOn (projIic b) (Iic b) univ", "start": [140, 1], "end": [140, 95], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_surjOn", "code": "theorem projIcc_surjOn : SurjOn (projIcc a b h) (Icc a b) univ", "start": [143, 1], "end": [144, 28], "kind": "commanddeclaration"}, {"full_name": "Set.projIci_surjective", "code": "theorem projIci_surjective : Surjective (projIci a)", "start": [147, 1], "end": [147, 83], "kind": "commanddeclaration"}, {"full_name": "Set.projIic_surjective", "code": "theorem projIic_surjective : Surjective (projIic b)", "start": [150, 1], "end": [150, 83], "kind": "commanddeclaration"}, {"full_name": "Set.projIcc_surjective", "code": "theorem projIcc_surjective : Surjective (projIcc a b h)", "start": [153, 1], "end": [153, 89], "kind": "commanddeclaration"}, {"full_name": "Set.range_projIci", "code": "@[simp]\ntheorem range_projIci : range (projIci a) = univ", "start": [156, 1], "end": [157, 80], "kind": "commanddeclaration"}, {"full_name": "Set.range_projIic", "code": "@[simp]\ntheorem range_projIic : range (projIic a) = univ", "start": [160, 1], "end": [161, 80], "kind": "commanddeclaration"}, {"full_name": "Set.range_projIcc", "code": "@[simp]\ntheorem range_projIcc : range (projIcc a b h) = univ", "start": [164, 1], "end": [166, 34], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_projIci", "code": "theorem monotone_projIci : Monotone (projIci a)", "start": [169, 1], "end": [169, 80], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_projIic", "code": "theorem monotone_projIic : Monotone (projIic a)", "start": [172, 1], "end": [172, 80], "kind": "commanddeclaration"}, {"full_name": "Set.monotone_projIcc", "code": "theorem monotone_projIcc : Monotone (projIcc a b h)", "start": [175, 1], "end": [176, 45], "kind": "commanddeclaration"}, {"full_name": "Set.strictMonoOn_projIci", "code": "theorem strictMonoOn_projIci : StrictMonoOn (projIci a) (Ici a)", "start": [179, 1], "end": [180, 38], "kind": "commanddeclaration"}, {"full_name": "Set.strictMonoOn_projIic", "code": "theorem strictMonoOn_projIic : StrictMonoOn (projIic b) (Iic b)", "start": [183, 1], "end": [184, 38], "kind": "commanddeclaration"}, {"full_name": "Set.strictMonoOn_projIcc", "code": "theorem strictMonoOn_projIcc : StrictMonoOn (projIcc a b h) (Icc a b)", "start": [187, 1], "end": [188, 38], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend", "code": "def IciExtend (f : Ici a \u2192 \u03b2) : \u03b1 \u2192 \u03b2 :=\n  f \u2218 projIci a", "start": [191, 1], "end": [193, 16], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend", "code": "def IicExtend (f : Iic b \u2192 \u03b2) : \u03b1 \u2192 \u03b2 :=\n  f \u2218 projIic b", "start": [196, 1], "end": [198, 16], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend", "code": "def IccExtend {a b : \u03b1} (h : a \u2264 b) (f : Icc a b \u2192 \u03b2) : \u03b1 \u2192 \u03b2 :=\n  f \u2218 projIcc a b h", "start": [201, 1], "end": [203, 20], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend_apply", "code": "theorem IciExtend_apply (f : Ici a \u2192 \u03b2) (x : \u03b1) : IciExtend f x = f \u27e8max a x, le_max_left _ _\u27e9", "start": [206, 1], "end": [207, 6], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend_apply", "code": "theorem IicExtend_apply (f : Iic b \u2192 \u03b2) (x : \u03b1) : IicExtend f x = f \u27e8min b x, min_le_left _ _\u27e9", "start": [210, 1], "end": [211, 6], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_apply", "code": "theorem IccExtend_apply (h : a \u2264 b) (f : Icc a b \u2192 \u03b2) (x : \u03b1) :\n    IccExtend h f x = f \u27e8max a (min b x), le_max_left _ _, max_le h (min_le_left _ _)\u27e9", "start": [214, 1], "end": [215, 94], "kind": "commanddeclaration"}, {"full_name": "Set.range_IciExtend", "code": "@[simp]\ntheorem range_IciExtend (f : Ici a \u2192 \u03b2) : range (IciExtend f) = range f", "start": [218, 1], "end": [220, 76], "kind": "commanddeclaration"}, {"full_name": "Set.range_IicExtend", "code": "@[simp]\ntheorem range_IicExtend (f : Iic b \u2192 \u03b2) : range (IicExtend f) = range f", "start": [223, 1], "end": [225, 76], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_range", "code": "@[simp]\ntheorem IccExtend_range (f : Icc a b \u2192 \u03b2) : range (IccExtend h f) = range f", "start": [228, 1], "end": [230, 65], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend_of_le", "code": "theorem IciExtend_of_le (f : Ici a \u2192 \u03b2) (hx : x \u2264 a) : IciExtend f x = f \u27e8a, le_rfl\u27e9", "start": [233, 1], "end": [234, 33], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend_of_le", "code": "theorem IicExtend_of_le (f : Iic b \u2192 \u03b2) (hx : b \u2264 x) : IicExtend f x = f \u27e8b, le_rfl\u27e9", "start": [237, 1], "end": [238, 33], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_of_le_left", "code": "theorem IccExtend_of_le_left (f : Icc a b \u2192 \u03b2) (hx : x \u2264 a) :\n    IccExtend h f x = f \u27e8a, left_mem_Icc.2 h\u27e9", "start": [241, 1], "end": [243, 41], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_of_right_le", "code": "theorem IccExtend_of_right_le (f : Icc a b \u2192 \u03b2) (hx : b \u2264 x) :\n    IccExtend h f x = f \u27e8b, right_mem_Icc.2 h\u27e9", "start": [246, 1], "end": [248, 41], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend_self", "code": "@[simp]\ntheorem IciExtend_self (f : Ici a \u2192 \u03b2) : IciExtend f a = f \u27e8a, le_rfl\u27e9", "start": [251, 1], "end": [253, 27], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend_self", "code": "@[simp]\ntheorem IicExtend_self (f : Iic b \u2192 \u03b2) : IicExtend f b = f \u27e8b, le_rfl\u27e9", "start": [256, 1], "end": [258, 27], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_left", "code": "@[simp]\ntheorem IccExtend_left (f : Icc a b \u2192 \u03b2) : IccExtend h f a = f \u27e8a, left_mem_Icc.2 h\u27e9", "start": [261, 1], "end": [263, 34], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_right", "code": "@[simp]\ntheorem IccExtend_right (f : Icc a b \u2192 \u03b2) : IccExtend h f b = f \u27e8b, right_mem_Icc.2 h\u27e9", "start": [266, 1], "end": [268, 35], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend_of_mem", "code": "theorem IciExtend_of_mem (f : Ici a \u2192 \u03b2) (hx : x \u2208 Ici a) : IciExtend f x = f \u27e8x, hx\u27e9", "start": [271, 1], "end": [272, 34], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend_of_mem", "code": "theorem IicExtend_of_mem (f : Iic b \u2192 \u03b2) (hx : x \u2208 Iic b) : IicExtend f x = f \u27e8x, hx\u27e9", "start": [275, 1], "end": [276, 34], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_of_mem", "code": "theorem IccExtend_of_mem (f : Icc a b \u2192 \u03b2) (hx : x \u2208 Icc a b) : IccExtend h f x = f \u27e8x, hx\u27e9", "start": [279, 1], "end": [280, 37], "kind": "commanddeclaration"}, {"full_name": "Set.IciExtend_coe", "code": "@[simp]\ntheorem IciExtend_coe (f : Ici a \u2192 \u03b2) (x : Ici a) : IciExtend f x = f x", "start": [283, 1], "end": [285, 30], "kind": "commanddeclaration"}, {"full_name": "Set.IicExtend_coe", "code": "@[simp]\ntheorem IicExtend_coe (f : Iic b \u2192 \u03b2) (x : Iic b) : IicExtend f x = f x", "start": [288, 1], "end": [290, 30], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_val", "code": "@[simp]\ntheorem IccExtend_val (f : Icc a b \u2192 \u03b2) (x : Icc a b) : IccExtend h f x = f x", "start": [293, 1], "end": [295, 33], "kind": "commanddeclaration"}, {"full_name": "Set.IccExtend_eq_self", "code": "theorem IccExtend_eq_self (f : \u03b1 \u2192 \u03b2) (ha : \u2200 x < a, f x = f a) (hb : \u2200 x, b < x \u2192 f x = f b) :\n    IccExtend h (f \u2218 (\u2191)) = f", "start": [298, 1], "end": [308, 56], "kind": "commanddeclaration"}, {"full_name": "Monotone.IciExtend", "code": "protected theorem Monotone.IciExtend {f : Ici a \u2192 \u03b2} (hf : Monotone f) : Monotone (IciExtend f)", "start": [317, 1], "end": [318, 27], "kind": "commanddeclaration"}, {"full_name": "Monotone.IicExtend", "code": "protected theorem Monotone.IicExtend {f : Iic b \u2192 \u03b2} (hf : Monotone f) : Monotone (IicExtend f)", "start": [321, 1], "end": [322, 27], "kind": "commanddeclaration"}, {"full_name": "Monotone.IccExtend", "code": "protected theorem Monotone.IccExtend (hf : Monotone f) : Monotone (IccExtend h f)", "start": [325, 1], "end": [326, 32], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictMonoOn_IciExtend", "code": "theorem StrictMono.strictMonoOn_IciExtend {f : Ici a \u2192 \u03b2} (hf : StrictMono f) :\n    StrictMonoOn (IciExtend f) (Ici a)", "start": [329, 1], "end": [331, 44], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictMonoOn_IicExtend", "code": "theorem StrictMono.strictMonoOn_IicExtend {f : Iic b \u2192 \u03b2} (hf : StrictMono f) :\n    StrictMonoOn (IicExtend f) (Iic b)", "start": [334, 1], "end": [336, 44], "kind": "commanddeclaration"}, {"full_name": "StrictMono.strictMonoOn_IccExtend", "code": "theorem StrictMono.strictMonoOn_IccExtend (hf : StrictMono f) :\n    StrictMonoOn (IccExtend h f) (Icc a b)", "start": [339, 1], "end": [341, 48], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.IciExtend", "code": "protected theorem Set.OrdConnected.IciExtend {s : Set (Ici a)} (hs : s.OrdConnected) :\n    {x | IciExtend (\u00b7 \u2208 s) x}.OrdConnected", "start": [344, 1], "end": [346, 88], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.IicExtend", "code": "protected theorem Set.OrdConnected.IicExtend {s : Set (Iic b)} (hs : s.OrdConnected) :\n    {x | IicExtend (\u00b7 \u2208 s) x}.OrdConnected", "start": [349, 1], "end": [351, 88], "kind": "commanddeclaration"}, {"full_name": "Set.OrdConnected.restrict", "code": "protected theorem Set.OrdConnected.restrict (hs : s.OrdConnected) :\n    {x | restrict t (\u00b7 \u2208 s) x}.OrdConnected", "start": [354, 1], "end": [356, 42], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Basic.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Topology/Bornology/Constructions.lean", "Mathlib/Topology/EMetricSpace/Basic.lean", "Mathlib/Topology/Algebra/Order/Compact.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformSpace.ofDist", "code": "def UniformSpace.ofDist (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d) (dist_self : \u2200 x : \u03b1, dist x x = 0)\n    (dist_comm : \u2200 x y : \u03b1, dist x y = dist y x)\n    (dist_triangle : \u2200 x y z : \u03b1, dist x z \u2264 dist x y + dist y z) : UniformSpace \u03b1 :=\n  .ofFun dist dist_self dist_comm dist_triangle fun \u03b5 \u03b50 =>\n    \u27e8\u03b5 / 2, half_pos \u03b50, fun _x hx _y hy => add_halves \u03b5 \u25b8 add_lt_add hx hy\u27e9", "start": [59, 1], "end": [64, 77], "kind": "commanddeclaration"}, {"full_name": "Bornology.ofDist", "code": "@[reducible]\ndef Bornology.ofDist {\u03b1 : Type*} (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d) (dist_comm : \u2200 x y, dist x y = dist y x)\n    (dist_triangle : \u2200 x y z, dist x z \u2264 dist x y + dist y z) : Bornology \u03b1 :=\n  Bornology.ofBounded { s : Set \u03b1 | \u2203 C, \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C }\n    \u27e80, fun x hx y => hx.elim\u27e9 (fun s \u27e8c, hc\u27e9 t h => \u27e8c, fun x hx y hy => hc (h hx) (h hy)\u27e9)\n    (fun s hs t ht => by\n      rcases s.eq_empty_or_nonempty with rfl | \u27e8x, hx\u27e9\n      \u00b7 rwa [empty_union]\n      rcases t.eq_empty_or_nonempty with rfl | \u27e8y, hy\u27e9\n      \u00b7 rwa [union_empty]\n      rsuffices \u27e8C, hC\u27e9 : \u2203 C, \u2200 z \u2208 s \u222a t, dist x z \u2264 C\n      \u00b7 refine \u27e8C + C, fun a ha b hb => (dist_triangle a x b).trans ?_\u27e9\n        simpa only [dist_comm] using add_le_add (hC _ ha) (hC _ hb)\n      rcases hs with \u27e8Cs, hs\u27e9; rcases ht with \u27e8Ct, ht\u27e9\n      refine \u27e8max Cs (dist x y + Ct), fun z hz => hz.elim\n        (fun hz => (hs hx hz).trans (le_max_left _ _))\n        (fun hz => (dist_triangle x y z).trans <|\n          (add_le_add le_rfl (ht hy hz)).trans (le_max_right _ _))\u27e9)\n    fun z => \u27e8dist z z, forall_eq.2 <| forall_eq.2 le_rfl\u27e9", "start": [68, 1], "end": [87, 59], "kind": "commanddeclaration"}, {"full_name": "Dist", "code": "@[ext]\nclass Dist (\u03b1 : Type*) where\n  dist : \u03b1 \u2192 \u03b1 \u2192 \u211d", "start": [90, 1], "end": [94, 19], "kind": "commanddeclaration"}, {"full_name": "dist_nonneg'", "code": "private theorem dist_nonneg' {\u03b1} {x y : \u03b1} (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d)\n    (dist_self : \u2200 x : \u03b1, dist x x = 0) (dist_comm : \u2200 x y : \u03b1, dist x y = dist y x)\n    (dist_triangle : \u2200 x y z : \u03b1, dist x z \u2264 dist x y + dist y z) : 0 \u2264 dist x y", "start": [101, 1], "end": [109, 42], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace", "code": "class PseudoMetricSpace (\u03b1 : Type u) extends Dist \u03b1 : Type u where\n  dist_self : \u2200 x : \u03b1, dist x x = 0\n  dist_comm : \u2200 x y : \u03b1, dist x y = dist y x\n  dist_triangle : \u2200 x y z : \u03b1, dist x z \u2264 dist x y + dist y z\n  edist : \u03b1 \u2192 \u03b1 \u2192 \u211d\u22650\u221e := fun x y => ENNReal.some \u27e8dist x y, dist_nonneg' _ \u2039_\u203a \u2039_\u203a \u2039_\u203a\u27e9\n  edist_dist : \u2200 x y : \u03b1, edist x y = ENNReal.ofReal (dist x y) toUniformSpace : UniformSpace \u03b1 := .ofDist dist dist_self dist_comm dist_triangle\n  uniformity_dist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < \u03b5 } := by intros; rfl\n  toBornology : Bornology \u03b1 := Bornology.ofDist dist dist_comm dist_triangle\n  cobounded_sets : (Bornology.cobounded \u03b1).sets =\n    { s | \u2203 C : \u211d, \u2200 x \u2208 s\u1d9c, \u2200 y \u2208 s\u1d9c, dist x y \u2264 C } := by intros; rfl", "start": [113, 1], "end": [133, 72], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.ext", "code": "@[ext]\ntheorem PseudoMetricSpace.ext {\u03b1 : Type*} {m m' : PseudoMetricSpace \u03b1}\n    (h : m.toDist = m'.toDist) : m = m'", "start": [136, 1], "end": [148, 55], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.toEDist", "code": "instance (priority := 200) PseudoMetricSpace.toEDist : EDist \u03b1 :=\n  \u27e8PseudoMetricSpace.edist\u27e9", "start": [156, 1], "end": [157, 28], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.ofDistTopology", "code": "def PseudoMetricSpace.ofDistTopology {\u03b1 : Type u} [TopologicalSpace \u03b1] (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d)\n    (dist_self : \u2200 x : \u03b1, dist x x = 0) (dist_comm : \u2200 x y : \u03b1, dist x y = dist y x)\n    (dist_triangle : \u2200 x y z : \u03b1, dist x z \u2264 dist x y + dist y z)\n    (H : \u2200 s : Set \u03b1, IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, \u2200 y, dist x y < \u03b5 \u2192 y \u2208 s) :\n    PseudoMetricSpace \u03b1 :=\n  { dist := dist\n    dist_self := dist_self\n    dist_comm := dist_comm\n    dist_triangle := dist_triangle\n    edist_dist := fun x y => by exact ENNReal.coe_nnreal_eq _\n    toUniformSpace :=\n      { toCore := (UniformSpace.ofDist dist dist_self dist_comm dist_triangle).toCore\n        isOpen_uniformity := fun s => (H s).trans <| forall\u2082_congr fun x _ =>\n          ((UniformSpace.hasBasis_ofFun (exists_gt (0 : \u211d)) dist _ _ _ _).comap\n            (Prod.mk x)).mem_iff.symm.trans mem_comap_prod_mk }\n    uniformity_dist := rfl\n    toBornology := Bornology.ofDist dist dist_comm dist_triangle\n    cobounded_sets := rfl }", "start": [160, 1], "end": [180, 28], "kind": "commanddeclaration"}, {"full_name": "dist_self", "code": "@[simp]\ntheorem dist_self (x : \u03b1) : dist x x = 0", "start": [183, 1], "end": [185, 32], "kind": "commanddeclaration"}, {"full_name": "dist_comm", "code": "theorem dist_comm (x y : \u03b1) : dist x y = dist y x", "start": [188, 1], "end": [189, 34], "kind": "commanddeclaration"}, {"full_name": "edist_dist", "code": "theorem edist_dist (x y : \u03b1) : edist x y = ENNReal.ofReal (dist x y)", "start": [192, 1], "end": [193, 35], "kind": "commanddeclaration"}, {"full_name": "dist_triangle", "code": "theorem dist_triangle (x y z : \u03b1) : dist x z \u2264 dist x y + dist y z", "start": [196, 1], "end": [197, 40], "kind": "commanddeclaration"}, {"full_name": "dist_triangle_left", "code": "theorem dist_triangle_left (x y z : \u03b1) : dist x y \u2264 dist z x + dist z y", "start": [200, 1], "end": [201, 40], "kind": "commanddeclaration"}, {"full_name": "dist_triangle_right", "code": "theorem dist_triangle_right (x y z : \u03b1) : dist x y \u2264 dist x z + dist y z", "start": [204, 1], "end": [205, 40], "kind": "commanddeclaration"}, {"full_name": "dist_triangle4", "code": "theorem dist_triangle4 (x y z w : \u03b1) : dist x w \u2264 dist x y + dist y z + dist z w", "start": [208, 1], "end": [211, 83], "kind": "commanddeclaration"}, {"full_name": "dist_triangle4_left", "code": "theorem dist_triangle4_left (x\u2081 y\u2081 x\u2082 y\u2082 : \u03b1) :\n    dist x\u2082 y\u2082 \u2264 dist x\u2081 y\u2081 + (dist x\u2081 x\u2082 + dist y\u2081 y\u2082)", "start": [214, 1], "end": [217, 23], "kind": "commanddeclaration"}, {"full_name": "dist_triangle4_right", "code": "theorem dist_triangle4_right (x\u2081 y\u2081 x\u2082 y\u2082 : \u03b1) :\n    dist x\u2081 y\u2081 \u2264 dist x\u2081 x\u2082 + dist y\u2081 y\u2082 + dist x\u2082 y\u2082", "start": [220, 1], "end": [223, 23], "kind": "commanddeclaration"}, {"full_name": "dist_le_Ico_sum_dist", "code": "theorem dist_le_Ico_sum_dist (f : \u2115 \u2192 \u03b1) {m n} (h : m \u2264 n) :\n    dist (f m) (f n) \u2264 \u2211 i in Finset.Ico m n, dist (f i) (f (i + 1))", "start": [226, 1], "end": [236, 87], "kind": "commanddeclaration"}, {"full_name": "dist_le_range_sum_dist", "code": "theorem dist_le_range_sum_dist (f : \u2115 \u2192 \u03b1) (n : \u2115) :\n    dist (f 0) (f n) \u2264 \u2211 i in Finset.range n, dist (f i) (f (i + 1))", "start": [239, 1], "end": [242, 65], "kind": "commanddeclaration"}, {"full_name": "dist_le_Ico_sum_of_dist_le", "code": "theorem dist_le_Ico_sum_of_dist_le {f : \u2115 \u2192 \u03b1} {m n} (hmn : m \u2264 n) {d : \u2115 \u2192 \u211d}\n    (hd : \u2200 {k}, m \u2264 k \u2192 k < n \u2192 dist (f k) (f (k + 1)) \u2264 d k) :\n    dist (f m) (f n) \u2264 \u2211 i in Finset.Ico m n, d i", "start": [245, 1], "end": [251, 86], "kind": "commanddeclaration"}, {"full_name": "dist_le_range_sum_of_dist_le", "code": "theorem dist_le_range_sum_of_dist_le {f : \u2115 \u2192 \u03b1} (n : \u2115) {d : \u2115 \u2192 \u211d}\n    (hd : \u2200 {k}, k < n \u2192 dist (f k) (f (k + 1)) \u2264 d k) :\n    dist (f 0) (f n) \u2264 \u2211 i in Finset.range n, d i", "start": [254, 1], "end": [259, 77], "kind": "commanddeclaration"}, {"full_name": "swap_dist", "code": "theorem swap_dist : Function.swap (@dist \u03b1 _) = dist", "start": [262, 1], "end": [262, 91], "kind": "commanddeclaration"}, {"full_name": "abs_dist_sub_le", "code": "theorem abs_dist_sub_le (x y z : \u03b1) : |dist x z - dist y z| \u2264 dist x y", "start": [265, 1], "end": [267, 96], "kind": "commanddeclaration"}, {"full_name": "dist_nonneg", "code": "theorem dist_nonneg {x y : \u03b1} : 0 \u2264 dist x y", "start": [270, 1], "end": [271, 54], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalDist", "code": "@[positivity Dist.dist _ _]\ndef evalDist : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app (.app _ a) b \u2190 whnfR e | throwError \"not dist\"\n  let p \u2190 mkAppOptM ``dist_nonneg #[none, none, a, b]\n  pure (.nonnegative p)", "start": [278, 1], "end": [283, 24], "kind": "commanddeclaration"}, {"full_name": "abs_dist", "code": "@[simp] theorem abs_dist {a b : \u03b1} : |dist a b| = dist a b", "start": [289, 1], "end": [289, 88], "kind": "commanddeclaration"}, {"full_name": "NNDist", "code": "class NNDist (\u03b1 : Type*) where\n  nndist : \u03b1 \u2192 \u03b1 \u2192 \u211d\u22650", "start": [292, 1], "end": [294, 23], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.toNNDist", "code": "instance (priority := 100) PseudoMetricSpace.toNNDist : NNDist \u03b1 :=\n  \u27e8fun a b => \u27e8dist a b, dist_nonneg\u27e9\u27e9", "start": [300, 1], "end": [302, 39], "kind": "commanddeclaration"}, {"full_name": "dist_nndist", "code": "theorem dist_nndist (x y : \u03b1) : dist x y = nndist x y", "start": [305, 1], "end": [306, 61], "kind": "commanddeclaration"}, {"full_name": "coe_nndist", "code": "@[simp, norm_cast]\ntheorem coe_nndist (x y : \u03b1) : \u2191(nndist x y) = dist x y", "start": [309, 1], "end": [310, 63], "kind": "commanddeclaration"}, {"full_name": "edist_nndist", "code": "theorem edist_nndist (x y : \u03b1) : edist x y = nndist x y", "start": [313, 1], "end": [315, 58], "kind": "commanddeclaration"}, {"full_name": "nndist_edist", "code": "theorem nndist_edist (x y : \u03b1) : nndist x y = (edist x y).toNNReal", "start": [318, 1], "end": [320, 22], "kind": "commanddeclaration"}, {"full_name": "coe_nnreal_ennreal_nndist", "code": "@[simp, norm_cast]\ntheorem coe_nnreal_ennreal_nndist (x y : \u03b1) : \u2191(nndist x y) = edist x y", "start": [323, 1], "end": [325, 26], "kind": "commanddeclaration"}, {"full_name": "edist_lt_coe", "code": "@[simp, norm_cast]\ntheorem edist_lt_coe {x y : \u03b1} {c : \u211d\u22650} : edist x y < c \u2194 nndist x y < c", "start": [328, 1], "end": [330, 40], "kind": "commanddeclaration"}, {"full_name": "edist_le_coe", "code": "@[simp, norm_cast]\ntheorem edist_le_coe {x y : \u03b1} {c : \u211d\u22650} : edist x y \u2264 c \u2194 nndist x y \u2264 c", "start": [333, 1], "end": [335, 40], "kind": "commanddeclaration"}, {"full_name": "edist_lt_top", "code": "theorem edist_lt_top {\u03b1 : Type*} [PseudoMetricSpace \u03b1] (x y : \u03b1) : edist x y < \u22a4", "start": [338, 1], "end": [340, 48], "kind": "commanddeclaration"}, {"full_name": "edist_ne_top", "code": "theorem edist_ne_top (x y : \u03b1) : edist x y \u2260 \u22a4", "start": [343, 1], "end": [345, 24], "kind": "commanddeclaration"}, {"full_name": "nndist_self", "code": "@[simp]\ntheorem nndist_self (a : \u03b1) : nndist a a = 0", "start": [348, 1], "end": [351, 41], "kind": "commanddeclaration"}, {"full_name": "dist_lt_coe", "code": "@[simp, norm_cast]\ntheorem dist_lt_coe {x y : \u03b1} {c : \u211d\u22650} : dist x y < c \u2194 nndist x y < c", "start": [356, 1], "end": [358, 10], "kind": "commanddeclaration"}, {"full_name": "dist_le_coe", "code": "@[simp, norm_cast]\ntheorem dist_le_coe {x y : \u03b1} {c : \u211d\u22650} : dist x y \u2264 c \u2194 nndist x y \u2264 c", "start": [361, 1], "end": [363, 10], "kind": "commanddeclaration"}, {"full_name": "edist_lt_ofReal", "code": "@[simp]\ntheorem edist_lt_ofReal {x y : \u03b1} {r : \u211d} : edist x y < ENNReal.ofReal r \u2194 dist x y < r", "start": [366, 1], "end": [368, 70], "kind": "commanddeclaration"}, {"full_name": "edist_le_ofReal", "code": "@[simp]\ntheorem edist_le_ofReal {x y : \u03b1} {r : \u211d} (hr : 0 \u2264 r) :\n    edist x y \u2264 ENNReal.ofReal r \u2194 dist x y \u2264 r", "start": [371, 1], "end": [374, 51], "kind": "commanddeclaration"}, {"full_name": "nndist_dist", "code": "theorem nndist_dist (x y : \u03b1) : nndist x y = Real.toNNReal (dist x y)", "start": [377, 1], "end": [379, 38], "kind": "commanddeclaration"}, {"full_name": "nndist_comm", "code": "theorem nndist_comm (x y : \u03b1) : nndist x y = nndist y x", "start": [382, 1], "end": [382, 86], "kind": "commanddeclaration"}, {"full_name": "nndist_triangle", "code": "theorem nndist_triangle (x y z : \u03b1) : nndist x z \u2264 nndist x y + nndist y z", "start": [385, 1], "end": [387, 22], "kind": "commanddeclaration"}, {"full_name": "nndist_triangle_left", "code": "theorem nndist_triangle_left (x y z : \u03b1) : nndist x y \u2264 nndist z x + nndist z y", "start": [390, 1], "end": [391, 27], "kind": "commanddeclaration"}, {"full_name": "nndist_triangle_right", "code": "theorem nndist_triangle_right (x y z : \u03b1) : nndist x y \u2264 nndist x z + nndist y z", "start": [394, 1], "end": [395, 28], "kind": "commanddeclaration"}, {"full_name": "dist_edist", "code": "theorem dist_edist (x y : \u03b1) : dist x y = (edist x y).toReal", "start": [398, 1], "end": [400, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.ball", "code": "def ball (x : \u03b1) (\u03b5 : \u211d) : Set \u03b1 :=\n  { y | dist y x < \u03b5 }", "start": [408, 1], "end": [410, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_ball", "code": "@[simp]\ntheorem mem_ball : y \u2208 ball x \u03b5 \u2194 dist y x < \u03b5", "start": [413, 1], "end": [415, 10], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_ball'", "code": "theorem mem_ball' : y \u2208 ball x \u03b5 \u2194 dist x y < \u03b5", "start": [418, 1], "end": [418, 79], "kind": "commanddeclaration"}, {"full_name": "Metric.pos_of_mem_ball", "code": "theorem pos_of_mem_ball (hy : y \u2208 ball x \u03b5) : 0 < \u03b5", "start": [421, 1], "end": [422, 26], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_ball_self", "code": "theorem mem_ball_self (h : 0 < \u03b5) : x \u2208 ball x \u03b5", "start": [425, 1], "end": [426, 28], "kind": "commanddeclaration"}, {"full_name": "Metric.nonempty_ball", "code": "@[simp]\ntheorem nonempty_ball : (ball x \u03b5).Nonempty \u2194 0 < \u03b5", "start": [429, 1], "end": [431, 70], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_eq_empty", "code": "@[simp]\ntheorem ball_eq_empty : ball x \u03b5 = \u2205 \u2194 \u03b5 \u2264 0", "start": [434, 1], "end": [436, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_zero", "code": "@[simp]\ntheorem ball_zero : ball x 0 = \u2205", "start": [439, 1], "end": [440, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_lt_mem_ball_of_mem_ball", "code": "theorem exists_lt_mem_ball_of_mem_ball (h : x \u2208 ball y \u03b5) : \u2203 \u03b5' < \u03b5, x \u2208 ball y \u03b5'", "start": [443, 1], "end": [449, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_eq_ball", "code": "theorem ball_eq_ball (\u03b5 : \u211d) (x : \u03b1) :\n    UniformSpace.ball x { p | dist p.2 p.1 < \u03b5 } = Metric.ball x \u03b5", "start": [452, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_eq_ball'", "code": "theorem ball_eq_ball' (\u03b5 : \u211d) (x : \u03b1) :\n    UniformSpace.ball x { p | dist p.1 p.2 < \u03b5 } = Metric.ball x \u03b5", "start": [457, 1], "end": [460, 38], "kind": "commanddeclaration"}, {"full_name": "Metric.iUnion_ball_nat", "code": "@[simp]\ntheorem iUnion_ball_nat (x : \u03b1) : \u22c3 n : \u2115, ball x n = univ", "start": [463, 1], "end": [465, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.iUnion_ball_nat_succ", "code": "@[simp]\ntheorem iUnion_ball_nat_succ (x : \u03b1) : \u22c3 n : \u2115, ball x (n + 1) = univ", "start": [468, 1], "end": [470, 97], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall", "code": "def closedBall (x : \u03b1) (\u03b5 : \u211d) :=\n  { y | dist y x \u2264 \u03b5 }", "start": [473, 1], "end": [475, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closedBall", "code": "@[simp] theorem mem_closedBall : y \u2208 closedBall x \u03b5 \u2194 dist y x \u2264 \u03b5", "start": [478, 1], "end": [478, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closedBall'", "code": "theorem mem_closedBall' : y \u2208 closedBall x \u03b5 \u2194 dist x y \u2264 \u03b5", "start": [481, 1], "end": [481, 97], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere", "code": "def sphere (x : \u03b1) (\u03b5 : \u211d) := { y | dist y x = \u03b5 }", "start": [484, 1], "end": [485, 51], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_sphere", "code": "@[simp] theorem mem_sphere : y \u2208 sphere x \u03b5 \u2194 dist y x = \u03b5", "start": [488, 1], "end": [488, 70], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_sphere'", "code": "theorem mem_sphere' : y \u2208 sphere x \u03b5 \u2194 dist x y = \u03b5", "start": [491, 1], "end": [491, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.ne_of_mem_sphere", "code": "theorem ne_of_mem_sphere (h : y \u2208 sphere x \u03b5) (h\u03b5 : \u03b5 \u2260 0) : y \u2260 x", "start": [494, 1], "end": [495, 51], "kind": "commanddeclaration"}, {"full_name": "Metric.nonneg_of_mem_sphere", "code": "theorem nonneg_of_mem_sphere (hy : y \u2208 sphere x \u03b5) : 0 \u2264 \u03b5", "start": [498, 1], "end": [499, 26], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_eq_empty_of_neg", "code": "@[simp]\ntheorem sphere_eq_empty_of_neg (h\u03b5 : \u03b5 < 0) : sphere x \u03b5 = \u2205", "start": [502, 1], "end": [504, 87], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_eq_empty_of_subsingleton", "code": "theorem sphere_eq_empty_of_subsingleton [Subsingleton \u03b1] (h\u03b5 : \u03b5 \u2260 0) : sphere x \u03b5 = \u2205", "start": [507, 1], "end": [508, 95], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_isEmpty_of_subsingleton", "code": "theorem sphere_isEmpty_of_subsingleton [Subsingleton \u03b1] (h\u03b5 : \u03b5 \u2260 0) : IsEmpty (sphere x \u03b5)", "start": [511, 1], "end": [512, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closedBall_self", "code": "theorem mem_closedBall_self (h : 0 \u2264 \u03b5) : x \u2208 closedBall x \u03b5", "start": [515, 1], "end": [516, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.nonempty_closedBall", "code": "@[simp]\ntheorem nonempty_closedBall : (closedBall x \u03b5).Nonempty \u2194 0 \u2264 \u03b5", "start": [519, 1], "end": [521, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_eq_empty", "code": "@[simp]\ntheorem closedBall_eq_empty : closedBall x \u03b5 = \u2205 \u2194 \u03b5 < 0", "start": [524, 1], "end": [526, 64], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_eq_sphere_of_nonpos", "code": "theorem closedBall_eq_sphere_of_nonpos (h\u03b5 : \u03b5 \u2264 0) : closedBall x \u03b5 = sphere x \u03b5", "start": [529, 1], "end": [531, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset_closedBall", "code": "theorem ball_subset_closedBall : ball x \u03b5 \u2286 closedBall x \u03b5", "start": [534, 1], "end": [535, 33], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_subset_closedBall", "code": "theorem sphere_subset_closedBall : sphere x \u03b5 \u2286 closedBall x \u03b5", "start": [538, 1], "end": [538, 84], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_disjoint_ball", "code": "theorem closedBall_disjoint_ball (h : \u03b4 + \u03b5 \u2264 dist x y) : Disjoint (closedBall x \u03b4) (ball y \u03b5)", "start": [541, 1], "end": [543, 83], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_disjoint_closedBall", "code": "theorem ball_disjoint_closedBall (h : \u03b4 + \u03b5 \u2264 dist x y) : Disjoint (ball x \u03b4) (closedBall y \u03b5)", "start": [546, 1], "end": [547, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_disjoint_ball", "code": "theorem ball_disjoint_ball (h : \u03b4 + \u03b5 \u2264 dist x y) : Disjoint (ball x \u03b4) (ball y \u03b5)", "start": [550, 1], "end": [551, 64], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_disjoint_closedBall", "code": "theorem closedBall_disjoint_closedBall (h : \u03b4 + \u03b5 < dist x y) :\n    Disjoint (closedBall x \u03b4) (closedBall y \u03b5)", "start": [554, 1], "end": [557, 71], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_disjoint_ball", "code": "theorem sphere_disjoint_ball : Disjoint (sphere x \u03b5) (ball x \u03b5)", "start": [560, 1], "end": [561, 69], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_union_sphere", "code": "@[simp]\ntheorem ball_union_sphere : ball x \u03b5 \u222a sphere x \u03b5 = closedBall x \u03b5", "start": [564, 1], "end": [566, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_union_ball", "code": "@[simp]\ntheorem sphere_union_ball : sphere x \u03b5 \u222a ball x \u03b5 = closedBall x \u03b5", "start": [569, 1], "end": [571, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_diff_sphere", "code": "@[simp]\ntheorem closedBall_diff_sphere : closedBall x \u03b5 \\ sphere x \u03b5 = ball x \u03b5", "start": [574, 1], "end": [576, 89], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_diff_ball", "code": "@[simp]\ntheorem closedBall_diff_ball : closedBall x \u03b5 \\ ball x \u03b5 = sphere x \u03b5", "start": [579, 1], "end": [581, 88], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_ball_comm", "code": "theorem mem_ball_comm : x \u2208 ball y \u03b5 \u2194 y \u2208 ball x \u03b5", "start": [584, 1], "end": [584, 83], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closedBall_comm", "code": "theorem mem_closedBall_comm : x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5", "start": [587, 1], "end": [588, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_sphere_comm", "code": "theorem mem_sphere_comm : x \u2208 sphere y \u03b5 \u2194 y \u2208 sphere x \u03b5", "start": [591, 1], "end": [591, 93], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset_ball", "code": "theorem ball_subset_ball (h : \u03b5\u2081 \u2264 \u03b5\u2082) : ball x \u03b5\u2081 \u2286 ball x \u03b5\u2082", "start": [594, 1], "end": [595, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_eq_bInter_ball", "code": "theorem closedBall_eq_bInter_ball : closedBall x \u03b5 = \u22c2 \u03b4 > \u03b5, ball x \u03b4", "start": [598, 1], "end": [599, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset_ball'", "code": "theorem ball_subset_ball' (h : \u03b5\u2081 + dist x y \u2264 \u03b5\u2082) : ball x \u03b5\u2081 \u2286 ball y \u03b5\u2082", "start": [602, 1], "end": [606, 16], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_closedBall", "code": "theorem closedBall_subset_closedBall (h : \u03b5\u2081 \u2264 \u03b5\u2082) : closedBall x \u03b5\u2081 \u2286 closedBall x \u03b5\u2082", "start": [609, 1], "end": [610, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_closedBall'", "code": "theorem closedBall_subset_closedBall' (h : \u03b5\u2081 + dist x y \u2264 \u03b5\u2082) :\n    closedBall x \u03b5\u2081 \u2286 closedBall y \u03b5\u2082", "start": [613, 1], "end": [618, 16], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_ball", "code": "theorem closedBall_subset_ball (h : \u03b5\u2081 < \u03b5\u2082) : closedBall x \u03b5\u2081 \u2286 ball x \u03b5\u2082", "start": [621, 1], "end": [622, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_subset_ball'", "code": "theorem closedBall_subset_ball' (h : \u03b5\u2081 + dist x y < \u03b5\u2082) :\n    closedBall x \u03b5\u2081 \u2286 ball y \u03b5\u2082", "start": [625, 1], "end": [630, 16], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_le_add_of_nonempty_closedBall_inter_closedBall", "code": "theorem dist_le_add_of_nonempty_closedBall_inter_closedBall\n    (h : (closedBall x \u03b5\u2081 \u2229 closedBall y \u03b5\u2082).Nonempty) : dist x y \u2264 \u03b5\u2081 + \u03b5\u2082", "start": [633, 1], "end": [638, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_lt_add_of_nonempty_closedBall_inter_ball", "code": "theorem dist_lt_add_of_nonempty_closedBall_inter_ball (h : (closedBall x \u03b5\u2081 \u2229 ball y \u03b5\u2082).Nonempty) :\n    dist x y < \u03b5\u2081 + \u03b5\u2082", "start": [641, 1], "end": [646, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_lt_add_of_nonempty_ball_inter_closedBall", "code": "theorem dist_lt_add_of_nonempty_ball_inter_closedBall (h : (ball x \u03b5\u2081 \u2229 closedBall y \u03b5\u2082).Nonempty) :\n    dist x y < \u03b5\u2081 + \u03b5\u2082", "start": [649, 1], "end": [653, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_lt_add_of_nonempty_ball_inter_ball", "code": "theorem dist_lt_add_of_nonempty_ball_inter_ball (h : (ball x \u03b5\u2081 \u2229 ball y \u03b5\u2082).Nonempty) :\n    dist x y < \u03b5\u2081 + \u03b5\u2082", "start": [656, 1], "end": [659, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.iUnion_closedBall_nat", "code": "@[simp]\ntheorem iUnion_closedBall_nat (x : \u03b1) : \u22c3 n : \u2115, closedBall x n = univ", "start": [662, 1], "end": [664, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.iUnion_inter_closedBall_nat", "code": "theorem iUnion_inter_closedBall_nat (s : Set \u03b1) (x : \u03b1) : \u22c3 n : \u2115, s \u2229 closedBall x n = s", "start": [667, 1], "end": [668, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset", "code": "theorem ball_subset (h : dist x y \u2264 \u03b5\u2082 - \u03b5\u2081) : ball x \u03b5\u2081 \u2286 ball y \u03b5\u2082", "start": [671, 1], "end": [673, 75], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_half_subset", "code": "theorem ball_half_subset (y) (h : y \u2208 ball x (\u03b5 / 2)) : ball y (\u03b5 / 2) \u2286 ball x \u03b5", "start": [676, 1], "end": [677, 60], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_ball_subset_ball", "code": "theorem exists_ball_subset_ball (h : y \u2208 ball x \u03b5) : \u2203 \u03b5' > 0, ball y \u03b5' \u2286 ball x \u03b5", "start": [680, 1], "end": [681, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.forall_of_forall_mem_closedBall", "code": "theorem forall_of_forall_mem_closedBall (p : \u03b1 \u2192 Prop) (x : \u03b1)\n    (H : \u2203\u1da0 R : \u211d in atTop, \u2200 y \u2208 closedBall x R, p y) (y : \u03b1) : p y", "start": [684, 1], "end": [690, 15], "kind": "commanddeclaration"}, {"full_name": "Metric.forall_of_forall_mem_ball", "code": "theorem forall_of_forall_mem_ball (p : \u03b1 \u2192 Prop) (x : \u03b1)\n    (H : \u2203\u1da0 R : \u211d in atTop, \u2200 y \u2208 ball x R, p y) (y : \u03b1) : p y", "start": [693, 1], "end": [699, 15], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff", "code": "theorem isBounded_iff {s : Set \u03b1} :\n    IsBounded s \u2194 \u2203 C : \u211d, \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C", "start": [702, 1], "end": [705, 17], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_eventually", "code": "theorem isBounded_iff_eventually {s : Set \u03b1} :\n    IsBounded s \u2194 \u2200\u1da0 C in atTop, \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C", "start": [708, 1], "end": [712, 25], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_exists_ge", "code": "theorem isBounded_iff_exists_ge {s : Set \u03b1} (c : \u211d) :\n    IsBounded s \u2194 \u2203 C, c \u2264 C \u2227 \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 dist x y \u2264 C", "start": [715, 1], "end": [718, 49], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_nndist", "code": "theorem isBounded_iff_nndist {s : Set \u03b1} :\n    IsBounded s \u2194 \u2203 C : \u211d\u22650, \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 nndist x y \u2264 C", "start": [721, 1], "end": [724, 32], "kind": "commanddeclaration"}, {"full_name": "Metric.toUniformSpace_eq", "code": "theorem toUniformSpace_eq :\n    \u2039PseudoMetricSpace \u03b1\u203a.toUniformSpace = .ofDist dist dist_self dist_comm dist_triangle", "start": [727, 1], "end": [729, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist", "code": "theorem uniformity_basis_dist :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < \u03b5 }", "start": [732, 1], "end": [735, 60], "kind": "commanddeclaration"}, {"full_name": "Metric.mk_uniformity_basis", "code": "protected theorem mk_uniformity_basis {\u03b2 : Type*} {p : \u03b2 \u2192 Prop} {f : \u03b2 \u2192 \u211d}\n    (hf\u2080 : \u2200 i, p i \u2192 0 < f i) (hf : \u2200 \u2983\u03b5\u2984, 0 < \u03b5 \u2192 \u2203 i, p i \u2227 f i \u2264 \u03b5) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < f i }", "start": [738, 1], "end": [751, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_rat", "code": "theorem uniformity_basis_dist_rat :\n    (\ud835\udce4 \u03b1).HasBasis (fun r : \u211a => 0 < r) fun r => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < r }", "start": [754, 1], "end": [758, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_inv_nat_succ", "code": "theorem uniformity_basis_dist_inv_nat_succ :\n    (\ud835\udce4 \u03b1).HasBasis (fun _ => True) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < 1 / (\u2191n + 1) }", "start": [761, 1], "end": [764, 71], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_inv_nat_pos", "code": "theorem uniformity_basis_dist_inv_nat_pos :\n    (\ud835\udce4 \u03b1).HasBasis (fun n : \u2115 => 0 < n) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < 1 / \u2191n }", "start": [767, 1], "end": [771, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_pow", "code": "theorem uniformity_basis_dist_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n    (\ud835\udce4 \u03b1).HasBasis (fun _ : \u2115 => True) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < r ^ n }", "start": [774, 1], "end": [778, 24], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_lt", "code": "theorem uniformity_basis_dist_lt {R : \u211d} (hR : 0 < R) :\n    (\ud835\udce4 \u03b1).HasBasis (fun r : \u211d => 0 < r \u2227 r < R) fun r => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < r }", "start": [781, 1], "end": [785, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.mk_uniformity_basis_le", "code": "protected theorem mk_uniformity_basis_le {\u03b2 : Type*} {p : \u03b2 \u2192 Prop} {f : \u03b2 \u2192 \u211d}\n    (hf\u2080 : \u2200 x, p x \u2192 0 < f x) (hf : \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 x, p x \u2227 f x \u2264 \u03b5) :\n    (\ud835\udce4 \u03b1).HasBasis p fun x => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 \u2264 f x }", "start": [788, 1], "end": [803, 89], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_le", "code": "theorem uniformity_basis_dist_le :\n    (\ud835\udce4 \u03b1).HasBasis ((0 : \u211d) < \u00b7) fun \u03b5 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 \u2264 \u03b5 }", "start": [806, 1], "end": [810, 77], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_dist_le_pow", "code": "theorem uniformity_basis_dist_le_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n    (\ud835\udce4 \u03b1).HasBasis (fun _ : \u2115 => True) fun n : \u2115 => { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 \u2264 r ^ n }", "start": [813, 1], "end": [817, 24], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_uniformity_dist", "code": "theorem mem_uniformity_dist {s : Set (\u03b1 \u00d7 \u03b1)} :\n    s \u2208 \ud835\udce4 \u03b1 \u2194 \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, dist a b < \u03b5 \u2192 (a, b) \u2208 s", "start": [820, 1], "end": [822, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_mem_uniformity", "code": "theorem dist_mem_uniformity {\u03b5 : \u211d} (\u03b50 : 0 < \u03b5) : { p : \u03b1 \u00d7 \u03b1 | dist p.1 p.2 < \u03b5 } \u2208 \ud835\udce4 \u03b1", "start": [825, 1], "end": [827, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuous_iff", "code": "theorem uniformContinuous_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformContinuous f \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b1}, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5", "start": [830, 1], "end": [832, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuousOn_iff", "code": "theorem uniformContinuousOn_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    UniformContinuousOn f s \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2200 y \u2208 s, dist x y < \u03b4 \u2192 dist (f x) (f y) < \u03b5", "start": [835, 1], "end": [838, 84], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformContinuousOn_iff_le", "code": "theorem uniformContinuousOn_iff_le [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    UniformContinuousOn f s \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2200 y \u2208 s, dist x y \u2264 \u03b4 \u2192 dist (f x) (f y) \u2264 \u03b5", "start": [841, 1], "end": [844, 90], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformInducing_iff", "code": "nonrec theorem uniformInducing_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformInducing f \u2194 UniformContinuous f \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, dist (f a) (f b) < \u03b5 \u2192 dist a b < \u03b4", "start": [847, 1], "end": [852, 93], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEmbedding_iff", "code": "nonrec theorem uniformEmbedding_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    UniformEmbedding f \u2194 Function.Injective f \u2227 UniformContinuous f \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, dist (f a) (f b) < \u03b5 \u2192 dist a b < \u03b4", "start": [854, 1], "end": [857, 59], "kind": "commanddeclaration"}, {"full_name": "Metric.controlled_of_uniformEmbedding", "code": "theorem controlled_of_uniformEmbedding [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} (h : UniformEmbedding f) :\n    (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b1}, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5) \u2227\n      \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b1}, dist (f a) (f b) < \u03b5 \u2192 dist a b < \u03b4", "start": [860, 1], "end": [865, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.totallyBounded_iff", "code": "theorem totallyBounded_iff {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 \u03b5 > 0, \u2203 t : Set \u03b1, t.Finite \u2227 s \u2286 \u22c3 y \u2208 t, ball y \u03b5", "start": [868, 1], "end": [870, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.totallyBounded_of_finite_discretization", "code": "theorem totallyBounded_of_finite_discretization {s : Set \u03b1}\n    (H : \u2200 \u03b5 > (0 : \u211d),\n        \u2203 (\u03b2 : Type u) (_ : Fintype \u03b2) (F : s \u2192 \u03b2), \u2200 x y, F x = F y \u2192 dist (x : \u03b1) y < \u03b5) :\n    TotallyBounded s", "start": [873, 1], "end": [891, 48], "kind": "commanddeclaration"}, {"full_name": "Metric.finite_approx_of_totallyBounded", "code": "theorem finite_approx_of_totallyBounded {s : Set \u03b1} (hs : TotallyBounded s) :\n    \u2200 \u03b5 > 0, \u2203 t, t \u2286 s \u2227 Set.Finite t \u2227 s \u2286 \u22c3 y \u2208 t, ball y \u03b5", "start": [894, 1], "end": [898, 41], "kind": "commanddeclaration"}, {"full_name": "Metric.tendstoUniformlyOnFilter_iff", "code": "theorem tendstoUniformlyOnFilter_iff {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} {p' : Filter \u03b2} :\n    TendstoUniformlyOnFilter F f p p' \u2194\n      \u2200 \u03b5 > 0, \u2200\u1da0 n : \u03b9 \u00d7 \u03b2 in p \u00d7\u02e2 p', dist (f n.snd) (F n.fst n.snd) < \u03b5", "start": [901, 1], "end": [907, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.tendstoLocallyUniformlyOn_iff", "code": "theorem tendstoLocallyUniformlyOn_iff [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1}\n    {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoLocallyUniformlyOn F f p s \u2194\n      \u2200 \u03b5 > 0, \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 n in p, \u2200 y \u2208 t, dist (f y) (F n y) < \u03b5", "start": [910, 1], "end": [918, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.tendstoUniformlyOn_iff", "code": "theorem tendstoUniformlyOn_iff {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} {s : Set \u03b2} :\n    TendstoUniformlyOn F f p s \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 n in p, \u2200 x \u2208 s, dist (f x) (F n x) < \u03b5", "start": [921, 1], "end": [926, 54], "kind": "commanddeclaration"}, {"full_name": "Metric.tendstoLocallyUniformly_iff", "code": "theorem tendstoLocallyUniformly_iff [TopologicalSpace \u03b2] {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1}\n    {p : Filter \u03b9} :\n    TendstoLocallyUniformly F f p \u2194\n      \u2200 \u03b5 > 0, \u2200 x : \u03b2, \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 n in p, \u2200 y \u2208 t, dist (f y) (F n y) < \u03b5", "start": [929, 1], "end": [935, 41], "kind": "commanddeclaration"}, {"full_name": "Metric.tendstoUniformly_iff", "code": "theorem tendstoUniformly_iff {F : \u03b9 \u2192 \u03b2 \u2192 \u03b1} {f : \u03b2 \u2192 \u03b1} {p : Filter \u03b9} :\n    TendstoUniformly F f p \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 n in p, \u2200 x, dist (f x) (F n x) < \u03b5", "start": [938, 1], "end": [942, 7], "kind": "commanddeclaration"}, {"full_name": "Metric.cauchy_iff", "code": "protected theorem cauchy_iff {f : Filter \u03b1} :\n    Cauchy f \u2194 NeBot f \u2227 \u2200 \u03b5 > 0, \u2203 t \u2208 f, \u2200 x \u2208 t, \u2200 y \u2208 t, dist x y < \u03b5", "start": [945, 1], "end": [947, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_ball", "code": "theorem nhds_basis_ball : (\ud835\udcdd x).HasBasis (0 < \u00b7) (ball x)", "start": [950, 1], "end": [951, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_nhds_iff", "code": "theorem mem_nhds_iff : s \u2208 \ud835\udcdd x \u2194 \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s", "start": [954, 1], "end": [955, 26], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_nhds_iff", "code": "theorem eventually_nhds_iff {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 y in \ud835\udcdd x, p y) \u2194 \u2203 \u03b5 > 0, \u2200 \u2983y\u2984, dist y x < \u03b5 \u2192 p y", "start": [958, 1], "end": [960, 15], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_nhds_iff_ball", "code": "theorem eventually_nhds_iff_ball {p : \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 y in \ud835\udcdd x, p y) \u2194 \u2203 \u03b5 > 0, \u2200 y \u2208 ball x \u03b5, p y", "start": [963, 1], "end": [965, 15], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_nhds_prod_iff", "code": "theorem eventually_nhds_prod_iff {f : Filter \u03b9} {x\u2080 : \u03b1} {p : \u03b1 \u00d7 \u03b9 \u2192 Prop} :\n    (\u2200\u1da0 x in \ud835\udcdd x\u2080 \u00d7\u02e2 f, p x) \u2194 \u2203 \u03b5 > (0 : \u211d), \u2203 pa : \u03b9 \u2192 Prop, (\u2200\u1da0 i in f, pa i) \u2227\n      \u2200 {x}, dist x x\u2080 < \u03b5 \u2192 \u2200 {i}, pa i \u2192 p (x, i)", "start": [968, 1], "end": [975, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_prod_nhds_iff", "code": "theorem eventually_prod_nhds_iff {f : Filter \u03b9} {x\u2080 : \u03b1} {p : \u03b9 \u00d7 \u03b1 \u2192 Prop} :\n    (\u2200\u1da0 x in f \u00d7\u02e2 \ud835\udcdd x\u2080, p x) \u2194 \u2203 pa : \u03b9 \u2192 Prop, (\u2200\u1da0 i in f, pa i) \u2227\n      \u2203 \u03b5 > 0, \u2200 {i}, pa i \u2192 \u2200 {x}, dist x x\u2080 < \u03b5 \u2192 p (i, x)", "start": [978, 1], "end": [986, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_closedBall", "code": "theorem nhds_basis_closedBall : (\ud835\udcdd x).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) (closedBall x)", "start": [989, 1], "end": [990, 49], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_ball_inv_nat_succ", "code": "theorem nhds_basis_ball_inv_nat_succ :\n    (\ud835\udcdd x).HasBasis (fun _ => True) fun n : \u2115 => ball x (1 / (\u2191n + 1))", "start": [993, 1], "end": [995, 59], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_ball_inv_nat_pos", "code": "theorem nhds_basis_ball_inv_nat_pos :\n    (\ud835\udcdd x).HasBasis (fun n => 0 < n) fun n : \u2115 => ball x (1 / \u2191n)", "start": [998, 1], "end": [1000, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_ball_pow", "code": "theorem nhds_basis_ball_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n    (\ud835\udcdd x).HasBasis (fun _ => True) fun n : \u2115 => ball x (r ^ n)", "start": [1003, 1], "end": [1005, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.nhds_basis_closedBall_pow", "code": "theorem nhds_basis_closedBall_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n    (\ud835\udcdd x).HasBasis (fun _ => True) fun n : \u2115 => closedBall x (r ^ n)", "start": [1008, 1], "end": [1010, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.isOpen_iff", "code": "theorem isOpen_iff : IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, ball x \u03b5 \u2286 s", "start": [1013, 1], "end": [1014, 48], "kind": "commanddeclaration"}, {"full_name": "Metric.isOpen_ball", "code": "theorem isOpen_ball : IsOpen (ball x \u03b5)", "start": [1017, 1], "end": [1018, 48], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_mem_nhds", "code": "theorem ball_mem_nhds (x : \u03b1) {\u03b5 : \u211d} (\u03b50 : 0 < \u03b5) : ball x \u03b5 \u2208 \ud835\udcdd x", "start": [1021, 1], "end": [1022, 42], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_mem_nhds", "code": "theorem closedBall_mem_nhds (x : \u03b1) {\u03b5 : \u211d} (\u03b50 : 0 < \u03b5) : closedBall x \u03b5 \u2208 \ud835\udcdd x", "start": [1025, 1], "end": [1026, 62], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_mem_nhds_of_mem", "code": "theorem closedBall_mem_nhds_of_mem {x c : \u03b1} {\u03b5 : \u211d} (h : x \u2208 ball c \u03b5) : closedBall c \u03b5 \u2208 \ud835\udcdd x", "start": [1029, 1], "end": [1030, 66], "kind": "commanddeclaration"}, {"full_name": "Metric.nhdsWithin_basis_ball", "code": "theorem nhdsWithin_basis_ball {s : Set \u03b1} :\n    (\ud835\udcdd[s] x).HasBasis (fun \u03b5 : \u211d => 0 < \u03b5) fun \u03b5 => ball x \u03b5 \u2229 s", "start": [1033, 1], "end": [1035, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_nhdsWithin_iff", "code": "theorem mem_nhdsWithin_iff {t : Set \u03b1} : s \u2208 \ud835\udcdd[t] x \u2194 \u2203 \u03b5 > 0, ball x \u03b5 \u2229 t \u2286 s", "start": [1038, 1], "end": [1039, 32], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_nhdsWithin_nhdsWithin", "code": "theorem tendsto_nhdsWithin_nhdsWithin [PseudoMetricSpace \u03b2] {t : Set \u03b2} {f : \u03b1 \u2192 \u03b2} {a b} :\n    Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd[t] b) \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, x \u2208 s \u2192 dist x a < \u03b4 \u2192 f x \u2208 t \u2227 dist (f x) b < \u03b5", "start": [1042, 1], "end": [1046, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_nhdsWithin_nhds", "code": "theorem tendsto_nhdsWithin_nhds [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a b} :\n    Tendsto f (\ud835\udcdd[s] a) (\ud835\udcdd b) \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, x \u2208 s \u2192 dist x a < \u03b4 \u2192 dist (f x) b < \u03b5", "start": [1049, 1], "end": [1053, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_nhds_nhds", "code": "theorem tendsto_nhds_nhds [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a b} :\n    Tendsto f (\ud835\udcdd a) (\ud835\udcdd b) \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, dist x a < \u03b4 \u2192 dist (f x) b < \u03b5", "start": [1056, 1], "end": [1058, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousAt_iff", "code": "theorem continuousAt_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} :\n    ContinuousAt f a \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, dist x a < \u03b4 \u2192 dist (f x) (f a) < \u03b5", "start": [1061, 1], "end": [1063, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousWithinAt_iff", "code": "theorem continuousWithinAt_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {a : \u03b1} {s : Set \u03b1} :\n    ContinuousWithinAt f s a \u2194\n      \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {x : \u03b1}, x \u2208 s \u2192 dist x a < \u03b4 \u2192 dist (f x) (f a) < \u03b5", "start": [1066, 1], "end": [1069, 54], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousOn_iff", "code": "theorem continuousOn_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 a \u2208 s, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5", "start": [1072, 1], "end": [1074, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.continuous_iff", "code": "theorem continuous_iff [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2} :\n    Continuous f \u2194 \u2200 b, \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 a, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5", "start": [1077, 1], "end": [1079, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_nhds", "code": "theorem tendsto_nhds {f : Filter \u03b2} {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u f (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in f, dist (u x) a < \u03b5", "start": [1082, 1], "end": [1084, 36], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousAt_iff'", "code": "theorem continuousAt_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} :\n    ContinuousAt f b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd b, dist (f x) (f b) < \u03b5", "start": [1087, 1], "end": [1089, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousWithinAt_iff'", "code": "theorem continuousWithinAt_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {b : \u03b2} {s : Set \u03b2} :\n    ContinuousWithinAt f s b \u2194 \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd[s] b, dist (f x) (f b) < \u03b5", "start": [1092, 1], "end": [1094, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.continuousOn_iff'", "code": "theorem continuousOn_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    ContinuousOn f s \u2194 \u2200 b \u2208 s, \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd[s] b, dist (f x) (f b) < \u03b5", "start": [1097, 1], "end": [1099, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.continuous_iff'", "code": "theorem continuous_iff' [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} :\n    Continuous f \u2194 \u2200 (a), \u2200 \u03b5 > 0, \u2200\u1da0 x in \ud835\udcdd a, dist (f x) (f a) < \u03b5", "start": [1102, 1], "end": [1104, 75], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_atTop", "code": "theorem tendsto_atTop [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u atTop (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) a < \u03b5", "start": [1107, 1], "end": [1110, 30], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_atTop'", "code": "theorem tendsto_atTop' [Nonempty \u03b2] [SemilatticeSup \u03b2] [NoMaxOrder \u03b2] {u : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    Tendsto u atTop (\ud835\udcdd a) \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, dist (u n) a < \u03b5", "start": [1113, 1], "end": [1119, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.isOpen_singleton_iff", "code": "theorem isOpen_singleton_iff {\u03b1 : Type*} [PseudoMetricSpace \u03b1] {x : \u03b1} :\n    IsOpen ({x} : Set \u03b1) \u2194 \u2203 \u03b5 > 0, \u2200 y, dist y x < \u03b5 \u2192 y = x", "start": [1122, 1], "end": [1124, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_ball_inter_eq_singleton_of_mem_discrete", "code": "theorem exists_ball_inter_eq_singleton_of_mem_discrete [DiscreteTopology s] {x : \u03b1} (hx : x \u2208 s) :\n    \u2203 \u03b5 > 0, Metric.ball x \u03b5 \u2229 s = {x}", "start": [1127, 1], "end": [1131, 63], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_closedBall_inter_eq_singleton_of_discrete", "code": "theorem exists_closedBall_inter_eq_singleton_of_discrete [DiscreteTopology s] {x : \u03b1} (hx : x \u2208 s) :\n    \u2203 \u03b5 > 0, Metric.closedBall x \u03b5 \u2229 s = {x}", "start": [1134, 1], "end": [1138, 69], "kind": "commanddeclaration"}, {"full_name": "Dense.exists_dist_lt", "code": "theorem _root_.Dense.exists_dist_lt {s : Set \u03b1} (hs : Dense s) (x : \u03b1) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) :\n    \u2203 y \u2208 s, dist x y < \u03b5", "start": [1141, 1], "end": [1144, 67], "kind": "commanddeclaration"}, {"full_name": "DenseRange.exists_dist_lt", "code": "nonrec theorem _root_.DenseRange.exists_dist_lt {\u03b2 : Type*} {f : \u03b2 \u2192 \u03b1} (hf : DenseRange f) (x : \u03b1)\n    {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) : \u2203 y, dist x (f y) < \u03b5", "start": [1147, 1], "end": [1149, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_edist_aux", "code": "theorem Metric.uniformity_edist_aux {\u03b1} (d : \u03b1 \u2192 \u03b1 \u2192 \u211d\u22650) :\n    \u2a05 \u03b5 > (0 : \u211d), \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | \u2191(d p.1 p.2) < \u03b5 } =\n      \u2a05 \u03b5 > (0 : \u211d\u22650\u221e), \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | \u2191(d p.1 p.2) < \u03b5 }", "start": [1161, 1], "end": [1171, 40], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_edist", "code": "theorem Metric.uniformity_edist : \ud835\udce4 \u03b1 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b1 \u00d7 \u03b1 | edist p.1 p.2 < \u03b5 }", "start": [1173, 1], "end": [1175, 33], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.toPseudoEMetricSpace", "code": "instance (priority := 100) PseudoMetricSpace.toPseudoEMetricSpace : PseudoEMetricSpace \u03b1 :=\n  { \u2039PseudoMetricSpace \u03b1\u203a with\n    edist_self := by simp [edist_dist]\n    edist_comm := fun _ _ => by simp only [edist_dist, dist_comm]\n    edist_triangle := fun x y z => by\n      simp only [edist_dist, \u2190 ENNReal.ofReal_add, dist_nonneg]\n      rw [ENNReal.ofReal_le_ofReal_iff _]\n      \u00b7 exact dist_triangle _ _ _\n      \u00b7 simpa using add_le_add (dist_nonneg : 0 \u2264 dist x y) dist_nonneg\n    uniformity_edist := Metric.uniformity_edist }", "start": [1179, 1], "end": [1189, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_basis_edist", "code": "@[deprecated _root_.uniformity_basis_edist]\nprotected theorem Metric.uniformity_basis_edist :\n    (\ud835\udce4 \u03b1).HasBasis (fun \u03b5 : \u211d\u22650\u221e => 0 < \u03b5) fun \u03b5 => { p | edist p.1 p.2 < \u03b5 }", "start": [1192, 1], "end": [1196, 25], "kind": "commanddeclaration"}, {"full_name": "Metric.eball_top_eq_univ", "code": "theorem Metric.eball_top_eq_univ (x : \u03b1) : EMetric.ball x \u221e = Set.univ", "start": [1199, 1], "end": [1201, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.emetric_ball", "code": "@[simp]\ntheorem Metric.emetric_ball {x : \u03b1} {\u03b5 : \u211d} : EMetric.ball x (ENNReal.ofReal \u03b5) = ball x \u03b5", "start": [1204, 1], "end": [1209, 59], "kind": "commanddeclaration"}, {"full_name": "Metric.emetric_ball_nnreal", "code": "@[simp]\ntheorem Metric.emetric_ball_nnreal {x : \u03b1} {\u03b5 : \u211d\u22650} : EMetric.ball x \u03b5 = ball x \u03b5", "start": [1212, 1], "end": [1216, 7], "kind": "commanddeclaration"}, {"full_name": "Metric.emetric_closedBall", "code": "theorem Metric.emetric_closedBall {x : \u03b1} {\u03b5 : \u211d} (h : 0 \u2264 \u03b5) :\n    EMetric.closedBall x (ENNReal.ofReal \u03b5) = closedBall x \u03b5", "start": [1219, 1], "end": [1222, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.emetric_closedBall_nnreal", "code": "@[simp]\ntheorem Metric.emetric_closedBall_nnreal {x : \u03b1} {\u03b5 : \u211d\u22650} :\n    EMetric.closedBall x \u03b5 = closedBall x \u03b5", "start": [1225, 1], "end": [1229, 75], "kind": "commanddeclaration"}, {"full_name": "Metric.emetric_ball_top", "code": "@[simp]\ntheorem Metric.emetric_ball_top (x : \u03b1) : EMetric.ball x \u22a4 = univ", "start": [1232, 1], "end": [1234, 46], "kind": "commanddeclaration"}, {"full_name": "Metric.inseparable_iff", "code": "theorem Metric.inseparable_iff {x y : \u03b1} : Inseparable x y \u2194 dist x y = 0", "start": [1237, 1], "end": [1238, 99], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceUniformity", "code": "@[reducible]\ndef PseudoMetricSpace.replaceUniformity {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : PseudoMetricSpace \u03b1 :=\n  { m with\n    toUniformSpace := U\n    uniformity_dist := H.trans PseudoMetricSpace.uniformity_dist }", "start": [1241, 1], "end": [1250, 67], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceUniformity_eq", "code": "theorem PseudoMetricSpace.replaceUniformity_eq {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m", "start": [1253, 1], "end": [1256, 6], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceTopology", "code": "@[reducible]\ndef PseudoMetricSpace.replaceTopology {\u03b3} [U : TopologicalSpace \u03b3] (m : PseudoMetricSpace \u03b3)\n    (H : U = m.toUniformSpace.toTopologicalSpace) : PseudoMetricSpace \u03b3 :=\n  @PseudoMetricSpace.replaceUniformity \u03b3 (m.toUniformSpace.replaceTopology H) m rfl", "start": [1264, 1], "end": [1271, 84], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceTopology_eq", "code": "theorem PseudoMetricSpace.replaceTopology_eq {\u03b3} [U : TopologicalSpace \u03b3] (m : PseudoMetricSpace \u03b3)\n    (H : U = m.toUniformSpace.toTopologicalSpace) : m.replaceTopology H = m", "start": [1274, 1], "end": [1277, 6], "kind": "commanddeclaration"}, {"full_name": "PseudoEMetricSpace.toPseudoMetricSpaceOfDist", "code": "def PseudoEMetricSpace.toPseudoMetricSpaceOfDist {\u03b1 : Type u} [e : PseudoEMetricSpace \u03b1]\n    (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d) (edist_ne_top : \u2200 x y : \u03b1, edist x y \u2260 \u22a4)\n    (h : \u2200 x y, dist x y = ENNReal.toReal (edist x y)) : PseudoMetricSpace \u03b1 where\n  dist := dist\n  dist_self x := by simp [h]\n  dist_comm x y := by simp [h, edist_comm]\n  dist_triangle x y z := by\n    simp only [h]\n    exact ENNReal.toReal_le_add (edist_triangle _ _ _) (edist_ne_top _ _) (edist_ne_top _ _)\n  edist := edist\n  edist_dist _ _ := by simp only [h, ENNReal.ofReal_toReal (edist_ne_top _ _)]\n  toUniformSpace := e.toUniformSpace\n  uniformity_dist := e.uniformity_edist.trans <| by\n    simpa only [ENNReal.coe_toNNReal (edist_ne_top _ _), h]\n      using (Metric.uniformity_edist_aux fun x y : \u03b1 => (edist x y).toNNReal).symm", "start": [1280, 1], "end": [1299, 83], "kind": "commanddeclaration"}, {"full_name": "PseudoEMetricSpace.toPseudoMetricSpace", "code": "@[reducible]\ndef PseudoEMetricSpace.toPseudoMetricSpace {\u03b1 : Type u} [PseudoEMetricSpace \u03b1]\n    (h : \u2200 x y : \u03b1, edist x y \u2260 \u22a4) : PseudoMetricSpace \u03b1 :=\n  PseudoEMetricSpace.toPseudoMetricSpaceOfDist (fun x y => ENNReal.toReal (edist x y)) h fun _ _ =>\n    rfl", "start": [1302, 1], "end": [1309, 8], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceBornology", "code": "@[reducible]\ndef PseudoMetricSpace.replaceBornology {\u03b1} [B : Bornology \u03b1] (m : PseudoMetricSpace \u03b1)\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    PseudoMetricSpace \u03b1 :=\n  { m with\n    toBornology := B\n    cobounded_sets := Set.ext <| compl_surjective.forall.2 fun s =>\n        (H s).trans <| by rw [isBounded_iff, mem_setOf_eq, compl_compl] }", "start": [1312, 1], "end": [1323, 74], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.replaceBornology_eq", "code": "theorem PseudoMetricSpace.replaceBornology_eq {\u03b1} [m : PseudoMetricSpace \u03b1] [B : Bornology \u03b1]\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    PseudoMetricSpace.replaceBornology _ H = m", "start": [1326, 1], "end": [1330, 6], "kind": "commanddeclaration"}, {"full_name": "Metric.complete_of_convergent_controlled_sequences", "code": "theorem Metric.complete_of_convergent_controlled_sequences (B : \u2115 \u2192 Real) (hB : \u2200 n, 0 < B n)\n    (H : \u2200 u : \u2115 \u2192 \u03b1, (\u2200 N n m : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (u n) (u m) < B N) \u2192\n      \u2203 x, Tendsto u atTop (\ud835\udcdd x)) :\n    CompleteSpace \u03b1", "start": [1338, 1], "end": [1348, 91], "kind": "commanddeclaration"}, {"full_name": "Metric.complete_of_cauchySeq_tendsto", "code": "theorem Metric.complete_of_cauchySeq_tendsto :\n    (\u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) \u2192 CompleteSpace \u03b1", "start": [1351, 1], "end": [1353, 40], "kind": "commanddeclaration"}, {"full_name": "Real.pseudoMetricSpace", "code": "instance Real.pseudoMetricSpace : PseudoMetricSpace \u211d where\n  dist x y := |x - y|\n  dist_self := by simp [abs_zero]\n  dist_comm x y := abs_sub_comm _ _\n  dist_triangle x y z := abs_sub_le _ _ _\n  edist_dist := fun x y => by exact ENNReal.coe_nnreal_eq _", "start": [1358, 1], "end": [1364, 60], "kind": "commanddeclaration"}, {"full_name": "Real.dist_eq", "code": "theorem Real.dist_eq (x y : \u211d) : dist x y = |x - y|", "start": [1367, 1], "end": [1367, 59], "kind": "commanddeclaration"}, {"full_name": "Real.nndist_eq", "code": "theorem Real.nndist_eq (x y : \u211d) : nndist x y = Real.nnabs (x - y)", "start": [1370, 1], "end": [1370, 74], "kind": "commanddeclaration"}, {"full_name": "Real.nndist_eq'", "code": "theorem Real.nndist_eq' (x y : \u211d) : nndist x y = Real.nnabs (y - x)", "start": [1373, 1], "end": [1374, 18], "kind": "commanddeclaration"}, {"full_name": "Real.dist_0_eq_abs", "code": "theorem Real.dist_0_eq_abs (x : \u211d) : dist x 0 = |x|", "start": [1377, 1], "end": [1377, 78], "kind": "commanddeclaration"}, {"full_name": "Real.dist_left_le_of_mem_uIcc", "code": "theorem Real.dist_left_le_of_mem_uIcc {x y z : \u211d} (h : y \u2208 uIcc x z) : dist x y \u2264 dist x z", "start": [1380, 1], "end": [1381, 60], "kind": "commanddeclaration"}, {"full_name": "Real.dist_right_le_of_mem_uIcc", "code": "theorem Real.dist_right_le_of_mem_uIcc {x y z : \u211d} (h : y \u2208 uIcc x z) : dist y z \u2264 dist x z", "start": [1384, 1], "end": [1385, 63], "kind": "commanddeclaration"}, {"full_name": "Real.dist_le_of_mem_uIcc", "code": "theorem Real.dist_le_of_mem_uIcc {x y x' y' : \u211d} (hx : x \u2208 uIcc x' y') (hy : y \u2208 uIcc x' y') :\n    dist x y \u2264 dist x' y'", "start": [1388, 1], "end": [1390, 95], "kind": "commanddeclaration"}, {"full_name": "Real.dist_le_of_mem_Icc", "code": "theorem Real.dist_le_of_mem_Icc {x y x' y' : \u211d} (hx : x \u2208 Icc x' y') (hy : y \u2208 Icc x' y') :\n    dist x y \u2264 y' - x'", "start": [1393, 1], "end": [1396, 71], "kind": "commanddeclaration"}, {"full_name": "Real.dist_le_of_mem_Icc_01", "code": "theorem Real.dist_le_of_mem_Icc_01 {x y : \u211d} (hx : x \u2208 Icc (0 : \u211d) 1) (hy : y \u2208 Icc (0 : \u211d) 1) :\n    dist x y \u2264 1", "start": [1399, 1], "end": [1400, 81], "kind": "commanddeclaration"}, {"full_name": "Real.ball_eq_Ioo", "code": "theorem Real.ball_eq_Ioo (x r : \u211d) : ball x r = Ioo (x - r) (x + r)", "start": [1407, 1], "end": [1410, 19], "kind": "commanddeclaration"}, {"full_name": "Real.closedBall_eq_Icc", "code": "theorem Real.closedBall_eq_Icc {x r : \u211d} : closedBall x r = Icc (x - r) (x + r)", "start": [1413, 1], "end": [1416, 17], "kind": "commanddeclaration"}, {"full_name": "Real.Ioo_eq_ball", "code": "theorem Real.Ioo_eq_ball (x y : \u211d) : Ioo x y = ball ((x + y) / 2) ((y - x) / 2)", "start": [1419, 1], "end": [1421, 67], "kind": "commanddeclaration"}, {"full_name": "Real.Icc_eq_closedBall", "code": "theorem Real.Icc_eq_closedBall (x y : \u211d) : Icc x y = closedBall ((x + y) / 2) ((y - x) / 2)", "start": [1424, 1], "end": [1426, 65], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_Icc", "code": "theorem totallyBounded_Icc (a b : \u03b1) : TotallyBounded (Icc a b)", "start": [1433, 1], "end": [1434, 31], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_Ico", "code": "theorem totallyBounded_Ico (a b : \u03b1) : TotallyBounded (Ico a b)", "start": [1437, 1], "end": [1438, 69], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_Ioc", "code": "theorem totallyBounded_Ioc (a b : \u03b1) : TotallyBounded (Ioc a b)", "start": [1441, 1], "end": [1442, 69], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_Ioo", "code": "theorem totallyBounded_Ioo (a b : \u03b1) : TotallyBounded (Ioo a b)", "start": [1445, 1], "end": [1446, 69], "kind": "commanddeclaration"}, {"full_name": "squeeze_zero'", "code": "theorem squeeze_zero' {\u03b1} {f g : \u03b1 \u2192 \u211d} {t\u2080 : Filter \u03b1} (hf : \u2200\u1da0 t in t\u2080, 0 \u2264 f t)\n    (hft : \u2200\u1da0 t in t\u2080, f t \u2264 g t) (g0 : Tendsto g t\u2080 (nhds 0)) : Tendsto f t\u2080 (\ud835\udcdd 0)", "start": [1451, 1], "end": [1455, 74], "kind": "commanddeclaration"}, {"full_name": "squeeze_zero", "code": "theorem squeeze_zero {\u03b1} {f g : \u03b1 \u2192 \u211d} {t\u2080 : Filter \u03b1} (hf : \u2200 t, 0 \u2264 f t) (hft : \u2200 t, f t \u2264 g t)\n    (g0 : Tendsto g t\u2080 (\ud835\udcdd 0)) : Tendsto f t\u2080 (\ud835\udcdd 0)", "start": [1458, 1], "end": [1462, 72], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformity_eq_comap_nhds_zero", "code": "theorem Metric.uniformity_eq_comap_nhds_zero :\n    \ud835\udce4 \u03b1 = comap (fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2) (\ud835\udcdd (0 : \u211d))", "start": [1465, 1], "end": [1469, 40], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_iff_tendsto_dist_atTop_0", "code": "theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 Tendsto (fun n : \u03b2 \u00d7 \u03b2 => dist (u n.1) (u n.2)) atTop (\ud835\udcdd 0)", "start": [1472, 1], "end": [1474, 91], "kind": "commanddeclaration"}, {"full_name": "tendsto_uniformity_iff_dist_tendsto_zero", "code": "theorem tendsto_uniformity_iff_dist_tendsto_zero {f : \u03b9 \u2192 \u03b1 \u00d7 \u03b1} {p : Filter \u03b9} :\n    Tendsto f p (\ud835\udce4 \u03b1) \u2194 Tendsto (fun x => dist (f x).1 (f x).2) p (\ud835\udcdd 0)", "start": [1477, 1], "end": [1479, 68], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.congr_dist", "code": "theorem Filter.Tendsto.congr_dist {f\u2081 f\u2082 : \u03b9 \u2192 \u03b1} {p : Filter \u03b9} {a : \u03b1}\n    (h\u2081 : Tendsto f\u2081 p (\ud835\udcdd a)) (h : Tendsto (fun x => dist (f\u2081 x) (f\u2082 x)) p (\ud835\udcdd 0)) :\n    Tendsto f\u2082 p (\ud835\udcdd a)", "start": [1482, 1], "end": [1485, 70], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_tendsto_of_dist", "code": "alias tendsto_of_tendsto_of_dist := Filter.Tendsto.congr_dist", "start": [1488, 1], "end": [1488, 62], "kind": "stdtacticaliasalias"}, {"full_name": "tendsto_iff_of_dist", "code": "theorem tendsto_iff_of_dist {f\u2081 f\u2082 : \u03b9 \u2192 \u03b1} {p : Filter \u03b9} {a : \u03b1}\n    (h : Tendsto (fun x => dist (f\u2081 x) (f\u2082 x)) p (\ud835\udcdd 0)) : Tendsto f\u2081 p (\ud835\udcdd a) \u2194 Tendsto f\u2082 p (\ud835\udcdd a)", "start": [1491, 1], "end": [1493, 72], "kind": "commanddeclaration"}, {"full_name": "eventually_closedBall_subset", "code": "theorem eventually_closedBall_subset {x : \u03b1} {u : Set \u03b1} (hu : u \u2208 \ud835\udcdd x) :\n    \u2200\u1da0 r in \ud835\udcdd (0 : \u211d), closedBall x r \u2286 u", "start": [1496, 1], "end": [1502, 90], "kind": "commanddeclaration"}, {"full_name": "Metric.cauchySeq_iff", "code": "theorem Metric.cauchySeq_iff {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 m \u2265 N, \u2200 n \u2265 N, dist (u m) (u n) < \u03b5", "start": [1511, 1], "end": [1516, 38], "kind": "commanddeclaration"}, {"full_name": "Metric.cauchySeq_iff'", "code": "theorem Metric.cauchySeq_iff' {u : \u03b2 \u2192 \u03b1} :\n    CauchySeq u \u2194 \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, dist (u n) (u N) < \u03b5", "start": [1519, 1], "end": [1522, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformCauchySeqOn_iff", "code": "theorem Metric.uniformCauchySeqOn_iff {\u03b3 : Type*} {F : \u03b2 \u2192 \u03b3 \u2192 \u03b1} {s : Set \u03b3} :\n    UniformCauchySeqOn F atTop s \u2194 \u2200 \u03b5 > (0 : \u211d),\n      \u2203 N : \u03b2, \u2200 m \u2265 N, \u2200 n \u2265 N, \u2200 x \u2208 s, dist (F m x) (F n x) < \u03b5", "start": [1526, 1], "end": [1548, 50], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_le_tendsto_0'", "code": "theorem cauchySeq_of_le_tendsto_0' {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m : \u03b2, n \u2264 m \u2192 dist (s n) (s m) \u2264 b n) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) : CauchySeq s", "start": [1551, 1], "end": [1558, 16], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_of_le_tendsto_0", "code": "theorem cauchySeq_of_le_tendsto_0 {s : \u03b2 \u2192 \u03b1} (b : \u03b2 \u2192 \u211d)\n    (h : \u2200 n m N : \u03b2, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b N) (h\u2080 : Tendsto b atTop (\ud835\udcdd 0)) :\n    CauchySeq s", "start": [1561, 1], "end": [1566, 72], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_bdd", "code": "theorem cauchySeq_bdd {u : \u2115 \u2192 \u03b1} (hu : CauchySeq u) : \u2203 R > 0, \u2200 m n, dist (u m) (u n) < R", "start": [1569, 1], "end": [1581, 66], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_iff_le_tendsto_0", "code": "theorem cauchySeq_iff_le_tendsto_0 {s : \u2115 \u2192 \u03b1} :\n    CauchySeq s \u2194\n      \u2203 b : \u2115 \u2192 \u211d,\n        (\u2200 n, 0 \u2264 b n) \u2227\n          (\u2200 n m N : \u2115, N \u2264 n \u2192 N \u2264 m \u2192 dist (s n) (s m) \u2264 b N) \u2227 Tendsto b atTop (\ud835\udcdd 0)", "start": [1584, 1], "end": [1614, 76], "kind": "commanddeclaration"}, {"full_name": "PseudoMetricSpace.induced", "code": "@[reducible]\ndef PseudoMetricSpace.induced {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (m : PseudoMetricSpace \u03b2) :\n    PseudoMetricSpace \u03b1 where\n  dist x y := dist (f x) (f y)\n  dist_self x := dist_self _\n  dist_comm x y := dist_comm _ _\n  dist_triangle x y z := dist_triangle _ _ _\n  edist x y := edist (f x) (f y)\n  edist_dist x y := edist_dist _ _\n  toUniformSpace := UniformSpace.comap f m.toUniformSpace\n  uniformity_dist := (uniformity_basis_dist.comap _).eq_biInf\n  toBornology := Bornology.induced f\n  cobounded_sets := Set.ext fun s => mem_comap_iff_compl.trans <| by\n    simp only [\u2190 isBounded_def, isBounded_iff, ball_image_iff, mem_setOf]", "start": [1619, 1], "end": [1633, 74], "kind": "commanddeclaration"}, {"full_name": "Inducing.comapPseudoMetricSpace", "code": "def Inducing.comapPseudoMetricSpace {\u03b1 \u03b2} [TopologicalSpace \u03b1] [m : PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (hf : Inducing f) : PseudoMetricSpace \u03b1 :=\n  .replaceTopology (.induced f m) hf.induced", "start": [1636, 1], "end": [1641, 45], "kind": "commanddeclaration"}, {"full_name": "UniformInducing.comapPseudoMetricSpace", "code": "def UniformInducing.comapPseudoMetricSpace {\u03b1 \u03b2} [UniformSpace \u03b1] [m : PseudoMetricSpace \u03b2]\n    (f : \u03b1 \u2192 \u03b2) (h : UniformInducing f) : PseudoMetricSpace \u03b1 :=\n  .replaceUniformity (.induced f m) h.comap_uniformity.symm", "start": [1644, 1], "end": [1649, 60], "kind": "commanddeclaration"}, {"full_name": "Subtype.pseudoMetricSpace", "code": "instance Subtype.pseudoMetricSpace {p : \u03b1 \u2192 Prop} : PseudoMetricSpace (Subtype p) :=\n  PseudoMetricSpace.induced Subtype.val \u2039_\u203a", "start": [1652, 1], "end": [1653, 44], "kind": "commanddeclaration"}, {"full_name": "Subtype.dist_eq", "code": "theorem Subtype.dist_eq {p : \u03b1 \u2192 Prop} (x y : Subtype p) : dist x y = dist (x : \u03b1) y", "start": [1656, 1], "end": [1657, 6], "kind": "commanddeclaration"}, {"full_name": "Subtype.nndist_eq", "code": "theorem Subtype.nndist_eq {p : \u03b1 \u2192 Prop} (x y : Subtype p) : nndist x y = nndist (x : \u03b1) y", "start": [1660, 1], "end": [1661, 6], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.instPseudoMetricSpaceMulOpposite", "code": "@[to_additive]\ninstance instPseudoMetricSpaceMulOpposite : PseudoMetricSpace \u03b1\u1d50\u1d52\u1d56 :=\n  PseudoMetricSpace.induced MulOpposite.unop \u2039_\u203a", "start": [1666, 1], "end": [1668, 49], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.dist_unop", "code": "@[to_additive (attr := simp)]\ntheorem dist_unop (x y : \u03b1\u1d50\u1d52\u1d56) : dist (unop x) (unop y) = dist x y", "start": [1670, 1], "end": [1671, 74], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.dist_op", "code": "@[to_additive (attr := simp)]\ntheorem dist_op (x y : \u03b1) : dist (op x) (op y) = dist x y", "start": [1675, 1], "end": [1676, 65], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nndist_unop", "code": "@[to_additive (attr := simp)]\ntheorem nndist_unop (x y : \u03b1\u1d50\u1d52\u1d56) : nndist (unop x) (unop y) = nndist x y", "start": [1680, 1], "end": [1681, 80], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.nndist_op", "code": "@[to_additive (attr := simp)]\ntheorem nndist_op (x y : \u03b1) : nndist (op x) (op y) = nndist x y", "start": [1685, 1], "end": [1686, 71], "kind": "commanddeclaration"}, {"full_name": "NNReal.dist_eq", "code": "theorem NNReal.dist_eq (a b : \u211d\u22650) : dist a b = |(a : \u211d) - b|", "start": [1696, 1], "end": [1696, 69], "kind": "commanddeclaration"}, {"full_name": "NNReal.nndist_eq", "code": "theorem NNReal.nndist_eq (a b : \u211d\u22650) : nndist a b = max (a - b) (b - a)", "start": [1699, 1], "end": [1702, 41], "kind": "commanddeclaration"}, {"full_name": "NNReal.nndist_zero_eq_val", "code": "@[simp]\ntheorem NNReal.nndist_zero_eq_val (z : \u211d\u22650) : nndist 0 z = z", "start": [1705, 1], "end": [1707, 77], "kind": "commanddeclaration"}, {"full_name": "NNReal.nndist_zero_eq_val'", "code": "@[simp]\ntheorem NNReal.nndist_zero_eq_val' (z : \u211d\u22650) : nndist z 0 = z", "start": [1710, 1], "end": [1713, 36], "kind": "commanddeclaration"}, {"full_name": "NNReal.le_add_nndist", "code": "theorem NNReal.le_add_nndist (a b : \u211d\u22650) : a \u2264 b + nndist a b", "start": [1716, 1], "end": [1720, 38], "kind": "commanddeclaration"}, {"full_name": "ULift.dist_eq", "code": "theorem ULift.dist_eq (x y : ULift \u03b2) : dist x y = dist x.down y.down", "start": [1732, 1], "end": [1732, 77], "kind": "commanddeclaration"}, {"full_name": "ULift.nndist_eq", "code": "theorem ULift.nndist_eq (x y : ULift \u03b2) : nndist x y = nndist x.down y.down", "start": [1735, 1], "end": [1735, 83], "kind": "commanddeclaration"}, {"full_name": "ULift.dist_up_up", "code": "@[simp]\ntheorem ULift.dist_up_up (x y : \u03b2) : dist (ULift.up x) (ULift.up y) = dist x y", "start": [1738, 1], "end": [1739, 86], "kind": "commanddeclaration"}, {"full_name": "ULift.nndist_up_up", "code": "@[simp]\ntheorem ULift.nndist_up_up (x y : \u03b2) : nndist (ULift.up x) (ULift.up y) = nndist x y", "start": [1742, 1], "end": [1743, 92], "kind": "commanddeclaration"}, {"full_name": "Prod.pseudoMetricSpaceMax", "code": "instance Prod.pseudoMetricSpaceMax : PseudoMetricSpace (\u03b1 \u00d7 \u03b2) :=\n  let i := PseudoEMetricSpace.toPseudoMetricSpaceOfDist\n    (fun x y : \u03b1 \u00d7 \u03b2 => dist x.1 y.1 \u2294 dist x.2 y.2)\n    (fun x y => (max_lt (edist_lt_top _ _) (edist_lt_top _ _)).ne) fun x y => by\n      simp only [sup_eq_max, dist_edist, \u2190 ENNReal.toReal_max (edist_ne_top _ _) (edist_ne_top _ _),\n        Prod.edist_eq]\n  i.replaceBornology fun s => by\n    simp only [\u2190 isBounded_image_fst_and_snd, isBounded_iff_eventually, ball_image_iff, \u2190\n      eventually_and, \u2190 forall_and, \u2190 max_le_iff]\n    rfl", "start": [1753, 1], "end": [1762, 8], "kind": "commanddeclaration"}, {"full_name": "Prod.dist_eq", "code": "theorem Prod.dist_eq {x y : \u03b1 \u00d7 \u03b2} : dist x y = max (dist x.1 y.1) (dist x.2 y.2)", "start": [1765, 1], "end": [1765, 89], "kind": "commanddeclaration"}, {"full_name": "dist_prod_same_left", "code": "@[simp]\ntheorem dist_prod_same_left {x : \u03b1} {y\u2081 y\u2082 : \u03b2} : dist (x, y\u2081) (x, y\u2082) = dist y\u2081 y\u2082", "start": [1768, 1], "end": [1770, 35], "kind": "commanddeclaration"}, {"full_name": "dist_prod_same_right", "code": "@[simp]\ntheorem dist_prod_same_right {x\u2081 x\u2082 : \u03b1} {y : \u03b2} : dist (x\u2081, y) (x\u2082, y) = dist x\u2081 x\u2082", "start": [1773, 1], "end": [1775, 35], "kind": "commanddeclaration"}, {"full_name": "ball_prod_same", "code": "theorem ball_prod_same (x : \u03b1) (y : \u03b2) (r : \u211d) : ball x r \u00d7\u02e2 ball y r = ball (x, y) r", "start": [1778, 1], "end": [1779, 38], "kind": "commanddeclaration"}, {"full_name": "closedBall_prod_same", "code": "theorem closedBall_prod_same (x : \u03b1) (y : \u03b2) (r : \u211d) :\n    closedBall x r \u00d7\u02e2 closedBall y r = closedBall (x, y) r", "start": [1782, 1], "end": [1784, 38], "kind": "commanddeclaration"}, {"full_name": "sphere_prod", "code": "theorem sphere_prod (x : \u03b1 \u00d7 \u03b2) (r : \u211d) :\n    sphere x r = sphere x.1 r \u00d7\u02e2 closedBall x.2 r \u222a closedBall x.1 r \u00d7\u02e2 sphere x.2 r", "start": [1787, 1], "end": [1797, 30], "kind": "commanddeclaration"}, {"full_name": "dist_dist_dist_le_left", "code": "theorem dist_dist_dist_le_left (x y z : \u03b1) : dist (dist x z) (dist y z) \u2264 dist x y", "start": [1803, 1], "end": [1804, 21], "kind": "commanddeclaration"}, {"full_name": "dist_dist_dist_le_right", "code": "theorem dist_dist_dist_le_right (x y z : \u03b1) : dist (dist x y) (dist x z) \u2264 dist y z", "start": [1806, 1], "end": [1807, 62], "kind": "commanddeclaration"}, {"full_name": "dist_dist_dist_le", "code": "theorem dist_dist_dist_le (x y x' y' : \u03b1) : dist (dist x y) (dist x' y') \u2264 dist x x' + dist y y'", "start": [1809, 1], "end": [1811, 78], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_dist", "code": "theorem uniformContinuous_dist : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2", "start": [1813, 1], "end": [1820, 29], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.dist", "code": "protected theorem UniformContinuous.dist [UniformSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun b => dist (f b) (g b)", "start": [1823, 1], "end": [1825, 46], "kind": "commanddeclaration"}, {"full_name": "continuous_dist", "code": "@[continuity]\ntheorem continuous_dist : Continuous fun p : \u03b1 \u00d7 \u03b1 => dist p.1 p.2", "start": [1828, 1], "end": [1830, 36], "kind": "commanddeclaration"}, {"full_name": "Continuous.dist", "code": "@[continuity]\nprotected theorem Continuous.dist [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => dist (f b) (g b)", "start": [1833, 1], "end": [1836, 43], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.dist", "code": "protected theorem Filter.Tendsto.dist {f g : \u03b2 \u2192 \u03b1} {x : Filter \u03b2} {a b : \u03b1}\n    (hf : Tendsto f x (\ud835\udcdd a)) (hg : Tendsto g x (\ud835\udcdd b)) :\n    Tendsto (fun x => dist (f x) (g x)) x (\ud835\udcdd (dist a b))", "start": [1839, 1], "end": [1842, 61], "kind": "commanddeclaration"}, {"full_name": "nhds_comap_dist", "code": "theorem nhds_comap_dist (a : \u03b1) : ((\ud835\udcdd (0 : \u211d)).comap (dist \u00b7 a)) = \ud835\udcdd a", "start": [1845, 1], "end": [1847, 24], "kind": "commanddeclaration"}, {"full_name": "tendsto_iff_dist_tendsto_zero", "code": "theorem tendsto_iff_dist_tendsto_zero {f : \u03b2 \u2192 \u03b1} {x : Filter \u03b2} {a : \u03b1} :\n    Tendsto f x (\ud835\udcdd a) \u2194 Tendsto (fun b => dist (f b) a) x (\ud835\udcdd 0)", "start": [1850, 1], "end": [1852, 51], "kind": "commanddeclaration"}, {"full_name": "continuous_iff_continuous_dist", "code": "theorem continuous_iff_continuous_dist [TopologicalSpace \u03b2] {f : \u03b2 \u2192 \u03b1} :\n    Continuous f \u2194 Continuous fun x : \u03b2 \u00d7 \u03b2 => dist (f x.1) (f x.2)", "start": [1855, 1], "end": [1859, 85], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_nndist", "code": "theorem uniformContinuous_nndist : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2", "start": [1862, 1], "end": [1863, 38], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.nndist", "code": "protected theorem UniformContinuous.nndist [UniformSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun b => nndist (f b) (g b)", "start": [1866, 1], "end": [1868, 48], "kind": "commanddeclaration"}, {"full_name": "continuous_nndist", "code": "theorem continuous_nndist : Continuous fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2", "start": [1871, 1], "end": [1872, 38], "kind": "commanddeclaration"}, {"full_name": "Continuous.nndist", "code": "protected theorem Continuous.nndist [TopologicalSpace \u03b2] {f g : \u03b2 \u2192 \u03b1} (hf : Continuous f)\n    (hg : Continuous g) : Continuous fun b => nndist (f b) (g b)", "start": [1875, 1], "end": [1877, 45], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.nndist", "code": "protected theorem Filter.Tendsto.nndist {f g : \u03b2 \u2192 \u03b1} {x : Filter \u03b2} {a b : \u03b1}\n    (hf : Tendsto f x (\ud835\udcdd a)) (hg : Tendsto g x (\ud835\udcdd b)) :\n    Tendsto (fun x => nndist (f x) (g x)) x (\ud835\udcdd (nndist a b))", "start": [1880, 1], "end": [1883, 63], "kind": "commanddeclaration"}, {"full_name": "Metric.isClosed_ball", "code": "theorem isClosed_ball : IsClosed (closedBall x \u03b5)", "start": [1890, 1], "end": [1891, 69], "kind": "commanddeclaration"}, {"full_name": "Metric.isClosed_sphere", "code": "theorem isClosed_sphere : IsClosed (sphere x \u03b5)", "start": [1894, 1], "end": [1895, 69], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_closedBall", "code": "@[simp]\ntheorem closure_closedBall : closure (closedBall x \u03b5) = closedBall x \u03b5", "start": [1898, 1], "end": [1900, 27], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_sphere", "code": "@[simp]\ntheorem closure_sphere : closure (sphere x \u03b5) = sphere x \u03b5", "start": [1903, 1], "end": [1905, 29], "kind": "commanddeclaration"}, {"full_name": "Metric.closure_ball_subset_closedBall", "code": "theorem closure_ball_subset_closedBall : closure (ball x \u03b5) \u2286 closedBall x \u03b5", "start": [1908, 1], "end": [1909, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_ball_subset_sphere", "code": "theorem frontier_ball_subset_sphere : frontier (ball x \u03b5) \u2286 sphere x \u03b5", "start": [1912, 1], "end": [1913, 79], "kind": "commanddeclaration"}, {"full_name": "Metric.frontier_closedBall_subset_sphere", "code": "theorem frontier_closedBall_subset_sphere : frontier (closedBall x \u03b5) \u2286 sphere x \u03b5", "start": [1916, 1], "end": [1917, 79], "kind": "commanddeclaration"}, {"full_name": "Metric.ball_subset_interior_closedBall", "code": "theorem ball_subset_interior_closedBall : ball x \u03b5 \u2286 interior (closedBall x \u03b5)", "start": [1920, 1], "end": [1921, 54], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closure_iff", "code": "theorem mem_closure_iff {s : Set \u03b1} {a : \u03b1} : a \u2208 closure s \u2194 \u2200 \u03b5 > 0, \u2203 b \u2208 s, dist a b < \u03b5", "start": [1924, 1], "end": [1926, 91], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closure_range_iff", "code": "theorem mem_closure_range_iff {e : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    a \u2208 closure (range e) \u2194 \u2200 \u03b5 > 0, \u2203 k : \u03b2, dist a (e k) < \u03b5", "start": [1929, 1], "end": [1931, 48], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_closure_range_iff_nat", "code": "theorem mem_closure_range_iff_nat {e : \u03b2 \u2192 \u03b1} {a : \u03b1} :\n    a \u2208 closure (range e) \u2194 \u2200 n : \u2115, \u2203 k : \u03b2, dist a (e k) < 1 / ((n : \u211d) + 1)", "start": [1934, 1], "end": [1937, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.mem_of_closed'", "code": "theorem mem_of_closed' {s : Set \u03b1} (hs : IsClosed s) {a : \u03b1} :\n    a \u2208 s \u2194 \u2200 \u03b5 > 0, \u2203 b \u2208 s, dist a b < \u03b5", "start": [1940, 1], "end": [1942, 60], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_zero'", "code": "theorem closedBall_zero' (x : \u03b1) : closedBall x 0 = closure {x}", "start": [1945, 1], "end": [1949, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.eventually_isCompact_closedBall", "code": "lemma eventually_isCompact_closedBall [LocallyCompactSpace \u03b1] (x : \u03b1) :\n    \u2200\u1da0 r in \ud835\udcdd (0 : \u211d), IsCompact (closedBall x r) := by\n  rcases local_compact_nhds (x := x) (n := univ) univ_mem with \u27e8s, hs, -, s_compact\u27e9\n  filter_upwards [eventually_closedBall_subset hs] with r hr\n  exact IsCompact.of_isClosed_subset s_compact isClosed_ball hr", "start": [1952, 1], "end": [1956, 64], "kind": "mathlibtacticlemma"}, {"full_name": "Metric.exists_isCompact_closedBall", "code": "lemma exists_isCompact_closedBall [LocallyCompactSpace \u03b1] (x : \u03b1) :\n    \u2203 r, 0 < r \u2227 IsCompact (closedBall x r) := by\n  have : \u2200\u1da0 r in \ud835\udcdd[>] 0, IsCompact (closedBall x r) :=\n    eventually_nhdsWithin_of_eventually_nhds (eventually_isCompact_closedBall x)\n  simpa only [and_comm] using (this.and self_mem_nhdsWithin).exists", "start": [1958, 1], "end": [1962, 68], "kind": "mathlibtacticlemma"}, {"full_name": "Metric.dense_iff", "code": "theorem dense_iff {s : Set \u03b1} : Dense s \u2194 \u2200 x, \u2200 r > 0, (ball x r \u2229 s).Nonempty", "start": [1964, 1], "end": [1966, 95], "kind": "commanddeclaration"}, {"full_name": "Metric.denseRange_iff", "code": "theorem denseRange_iff {f : \u03b2 \u2192 \u03b1} : DenseRange f \u2194 \u2200 x, \u2200 r > 0, \u2203 y, dist x (f y) < r", "start": [1969, 1], "end": [1970, 74], "kind": "commanddeclaration"}, {"full_name": "Inducing.isSeparable_preimage", "code": "protected theorem _root_.Inducing.isSeparable_preimage {f : \u03b2 \u2192 \u03b1} [TopologicalSpace \u03b2]\n    (hf : Inducing f) {s : Set \u03b1} (hs : IsSeparable s) : IsSeparable (f \u207b\u00b9' s)", "start": [1975, 1], "end": [1983, 48], "kind": "commanddeclaration"}, {"full_name": "Embedding.isSeparable_preimage", "code": "protected theorem _root_.Embedding.isSeparable_preimage {f : \u03b2 \u2192 \u03b1} [TopologicalSpace \u03b2]\n    (hf : Embedding f) {s : Set \u03b1} (hs : IsSeparable s) : IsSeparable (f \u207b\u00b9' s)", "start": [1986, 1], "end": [1988, 40], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.isSeparable_image", "code": "theorem _root_.ContinuousOn.isSeparable_image [TopologicalSpace \u03b2] {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : ContinuousOn f s) (hs : IsSeparable s) : IsSeparable (f '' s)", "start": [1991, 1], "end": [1995, 69], "kind": "commanddeclaration"}, {"full_name": "pseudoMetricSpacePi", "code": "instance pseudoMetricSpacePi : PseudoMetricSpace (\u2200 b, \u03c0 b) := by\n  \n  let i := PseudoEMetricSpace.toPseudoMetricSpaceOfDist\n    (fun f g : \u2200 b, \u03c0 b => ((sup univ fun b => nndist (f b) (g b) : \u211d\u22650) : \u211d))\n    (fun f g => ((Finset.sup_lt_iff bot_lt_top).2 fun b _ => edist_lt_top _ _).ne)\n    (fun f g => by\n      simp only [edist_pi_def, edist_nndist, \u2190 ENNReal.coe_finset_sup, ENNReal.coe_toReal])\n  refine i.replaceBornology fun s => ?_\n  simp only [\u2190 isBounded_def, isBounded_iff_eventually, \u2190 forall_isBounded_image_eval_iff,\n    ball_image_iff, \u2190 Filter.eventually_all, Function.eval_apply, @dist_nndist (\u03c0 _)]\n  refine' eventually_congr ((eventually_ge_atTop 0).mono fun C hC => _)\n  lift C to \u211d\u22650 using hC\n  refine' \u27e8fun H x hx y hy => NNReal.coe_le_coe.2 <| Finset.sup_le fun b _ => H b x hx y hy,\n    fun H b x hx y hy => NNReal.coe_le_coe.2 _\u27e9\n  simpa only using Finset.sup_le_iff.1 (NNReal.coe_le_coe.1 <| H hx hy) b (Finset.mem_univ b)", "start": [2006, 1], "end": [2023, 94], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_def", "code": "theorem nndist_pi_def (f g : \u2200 b, \u03c0 b) : nndist f g = sup univ fun b => nndist (f b) (g b)", "start": [2026, 1], "end": [2027, 16], "kind": "commanddeclaration"}, {"full_name": "dist_pi_def", "code": "theorem dist_pi_def (f g : \u2200 b, \u03c0 b) : dist f g = (sup univ fun b => nndist (f b) (g b) : \u211d\u22650)", "start": [2030, 1], "end": [2031, 6], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_le_iff", "code": "theorem nndist_pi_le_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} :\n    nndist f g \u2264 r \u2194 \u2200 b, nndist (f b) (g b) \u2264 r", "start": [2034, 1], "end": [2035, 76], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_lt_iff", "code": "theorem nndist_pi_lt_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} (hr : 0 < r) :\n    nndist f g < r \u2194 \u2200 b, nndist (f b) (g b) < r", "start": [2038, 1], "end": [2040, 63], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_eq_iff", "code": "theorem nndist_pi_eq_iff {f g : \u2200 b, \u03c0 b} {r : \u211d\u22650} (hr : 0 < r) :\n    nndist f g = r \u2194 (\u2203 i, nndist (f i) (g i) = r) \u2227 \u2200 b, nndist (f b) (g b) \u2264 r", "start": [2043, 1], "end": [2049, 36], "kind": "commanddeclaration"}, {"full_name": "dist_pi_lt_iff", "code": "theorem dist_pi_lt_iff {f g : \u2200 b, \u03c0 b} {r : \u211d} (hr : 0 < r) :\n    dist f g < r \u2194 \u2200 b, dist (f b) (g b) < r", "start": [2052, 1], "end": [2055, 28], "kind": "commanddeclaration"}, {"full_name": "dist_pi_le_iff", "code": "theorem dist_pi_le_iff {f g : \u2200 b, \u03c0 b} {r : \u211d} (hr : 0 \u2264 r) :\n    dist f g \u2264 r \u2194 \u2200 b, dist (f b) (g b) \u2264 r", "start": [2058, 1], "end": [2061, 25], "kind": "commanddeclaration"}, {"full_name": "dist_pi_eq_iff", "code": "theorem dist_pi_eq_iff {f g : \u2200 b, \u03c0 b} {r : \u211d} (hr : 0 < r) :\n    dist f g = r \u2194 (\u2203 i, dist (f i) (g i) = r) \u2227 \u2200 b, dist (f b) (g b) \u2264 r", "start": [2064, 1], "end": [2067, 80], "kind": "commanddeclaration"}, {"full_name": "dist_pi_le_iff'", "code": "theorem dist_pi_le_iff' [Nonempty \u03b2] {f g : \u2200 b, \u03c0 b} {r : \u211d} :\n    dist f g \u2264 r \u2194 \u2200 b, dist (f b) (g b) \u2264 r", "start": [2070, 1], "end": [2075, 60], "kind": "commanddeclaration"}, {"full_name": "dist_pi_const_le", "code": "theorem dist_pi_const_le (a b : \u03b1) : (dist (fun _ : \u03b2 => a) fun _ => b) \u2264 dist a b", "start": [2078, 1], "end": [2079, 49], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_const_le", "code": "theorem nndist_pi_const_le (a b : \u03b1) : (nndist (fun _ : \u03b2 => a) fun _ => b) \u2264 nndist a b", "start": [2082, 1], "end": [2083, 37], "kind": "commanddeclaration"}, {"full_name": "dist_pi_const", "code": "@[simp]\ntheorem dist_pi_const [Nonempty \u03b2] (a b : \u03b1) : (dist (fun _ : \u03b2 => a) fun _ => b) = dist a b", "start": [2086, 1], "end": [2088, 78], "kind": "commanddeclaration"}, {"full_name": "nndist_pi_const", "code": "@[simp]\ntheorem nndist_pi_const [Nonempty \u03b2] (a b : \u03b1) :\n    (nndist (fun _ : \u03b2 => a) fun _ => b) = nndist a b", "start": [2091, 1], "end": [2094, 33], "kind": "commanddeclaration"}, {"full_name": "nndist_le_pi_nndist", "code": "theorem nndist_le_pi_nndist (f g : \u2200 b, \u03c0 b) (b : \u03b2) : nndist (f b) (g b) \u2264 nndist f g", "start": [2097, 1], "end": [2099, 32], "kind": "commanddeclaration"}, {"full_name": "dist_le_pi_dist", "code": "theorem dist_le_pi_dist (f g : \u2200 b, \u03c0 b) (b : \u03b2) : dist (f b) (g b) \u2264 dist f g", "start": [2102, 1], "end": [2103, 72], "kind": "commanddeclaration"}, {"full_name": "ball_pi", "code": "theorem ball_pi (x : \u2200 b, \u03c0 b) {r : \u211d} (hr : 0 < r) :\n    ball x r = Set.pi univ fun b => ball (x b) r", "start": [2106, 1], "end": [2111, 27], "kind": "commanddeclaration"}, {"full_name": "ball_pi'", "code": "theorem ball_pi' [Nonempty \u03b2] (x : \u2200 b, \u03c0 b) (r : \u211d) :\n    ball x r = Set.pi univ fun b => ball (x b) r", "start": [2114, 1], "end": [2118, 73], "kind": "commanddeclaration"}, {"full_name": "closedBall_pi", "code": "theorem closedBall_pi (x : \u2200 b, \u03c0 b) {r : \u211d} (hr : 0 \u2264 r) :\n    closedBall x r = Set.pi univ fun b => closedBall (x b) r", "start": [2121, 1], "end": [2126, 27], "kind": "commanddeclaration"}, {"full_name": "closedBall_pi'", "code": "theorem closedBall_pi' [Nonempty \u03b2] (x : \u2200 b, \u03c0 b) (r : \u211d) :\n    closedBall x r = Set.pi univ fun b => closedBall (x b) r", "start": [2129, 1], "end": [2133, 85], "kind": "commanddeclaration"}, {"full_name": "sphere_pi", "code": "theorem sphere_pi (x : \u2200 b, \u03c0 b) {r : \u211d} (h : 0 < r \u2228 Nonempty \u03b2) :\n    sphere x r = (\u22c3 i : \u03b2, Function.eval i \u207b\u00b9' sphere (x i) r) \u2229 closedBall x r", "start": [2136, 1], "end": [2151, 51], "kind": "commanddeclaration"}, {"full_name": "Fin.nndist_insertNth_insertNth", "code": "@[simp]\ntheorem Fin.nndist_insertNth_insertNth {n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*}\n    [\u2200 i, PseudoMetricSpace (\u03b1 i)] (i : Fin (n + 1)) (x y : \u03b1 i) (f g : \u2200 j, \u03b1 (i.succAbove j)) :\n    nndist (i.insertNth x f) (i.insertNth y g) = max (nndist x y) (nndist f g)", "start": [2154, 1], "end": [2158, 82], "kind": "commanddeclaration"}, {"full_name": "Fin.dist_insertNth_insertNth", "code": "@[simp]\ntheorem Fin.dist_insertNth_insertNth {n : \u2115} {\u03b1 : Fin (n + 1) \u2192 Type*}\n    [\u2200 i, PseudoMetricSpace (\u03b1 i)] (i : Fin (n + 1)) (x y : \u03b1 i) (f g : \u2200 j, \u03b1 (i.succAbove j)) :\n    dist (i.insertNth x f) (i.insertNth y g) = max (dist x y) (dist f g)", "start": [2161, 1], "end": [2165, 74], "kind": "commanddeclaration"}, {"full_name": "Real.dist_le_of_mem_pi_Icc", "code": "theorem Real.dist_le_of_mem_pi_Icc {x y x' y' : \u03b2 \u2192 \u211d} (hx : x \u2208 Icc x' y') (hy : y \u2208 Icc x' y') :\n    dist x y \u2264 dist x' y'", "start": [2168, 1], "end": [2172, 46], "kind": "commanddeclaration"}, {"full_name": "finite_cover_balls_of_compact", "code": "theorem finite_cover_balls_of_compact {\u03b1 : Type u} [PseudoMetricSpace \u03b1] {s : Set \u03b1}\n    (hs : IsCompact s) {e : \u211d} (he : 0 < e) :\n    \u2203 t, t \u2286 s \u2227 Set.Finite t \u2227 s \u2286 \u22c3 x \u2208 t, ball x e", "start": [2179, 1], "end": [2185, 31], "kind": "commanddeclaration"}, {"full_name": "IsCompact.finite_cover_balls", "code": "alias IsCompact.finite_cover_balls := finite_cover_balls_of_compact", "start": [2188, 1], "end": [2188, 68], "kind": "stdtacticaliasalias"}, {"full_name": "ProperSpace", "code": "class ProperSpace (\u03b1 : Type u) [PseudoMetricSpace \u03b1] : Prop where\n  isCompact_closedBall : \u2200 x : \u03b1, \u2200 r, IsCompact (closedBall x r)", "start": [2197, 1], "end": [2199, 66], "kind": "commanddeclaration"}, {"full_name": "isCompact_sphere", "code": "theorem isCompact_sphere {\u03b1 : Type*} [PseudoMetricSpace \u03b1] [ProperSpace \u03b1] (x : \u03b1) (r : \u211d) :\n    IsCompact (sphere x r)", "start": [2204, 1], "end": [2207, 89], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere.compactSpace", "code": "instance Metric.sphere.compactSpace {\u03b1 : Type*} [PseudoMetricSpace \u03b1] [ProperSpace \u03b1]\n    (x : \u03b1) (r : \u211d) : CompactSpace (sphere x r) :=\n  isCompact_iff_compactSpace.mp (isCompact_sphere _ _)", "start": [2210, 1], "end": [2213, 55], "kind": "commanddeclaration"}, {"full_name": "secondCountable_of_proper", "code": "instance (priority := 100) secondCountable_of_proper [ProperSpace \u03b1] :\n    SecondCountableTopology \u03b1 := by\n  suffices SigmaCompactSpace \u03b1 by exact EMetric.secondCountable_of_sigmaCompact \u03b1\n  rcases em (Nonempty \u03b1) with (\u27e8\u27e8x\u27e9\u27e9 | hn)\n  \u00b7 exact \u27e8\u27e8fun n => closedBall x n, fun n => isCompact_closedBall _ _, iUnion_closedBall_nat _\u27e9\u27e9\n  \u00b7 exact \u27e8\u27e8fun _ => \u2205, fun _ => isCompact_empty, iUnion_eq_univ_iff.2 fun x => (hn \u27e8x\u27e9).elim\u27e9\u27e9", "start": [2216, 1], "end": [2224, 96], "kind": "commanddeclaration"}, {"full_name": "properSpace_of_compact_closedBall_of_le", "code": "theorem properSpace_of_compact_closedBall_of_le (R : \u211d)\n    (h : \u2200 x : \u03b1, \u2200 r, R \u2264 r \u2192 IsCompact (closedBall x r)) : ProperSpace \u03b1", "start": [2227, 1], "end": [2232, 55], "kind": "commanddeclaration"}, {"full_name": "proper_of_compact", "code": "instance (priority := 100) proper_of_compact [CompactSpace \u03b1] : ProperSpace \u03b1 :=\n  \u27e8fun _ _ => isClosed_ball.isCompact\u27e9", "start": [2237, 1], "end": [2238, 39], "kind": "commanddeclaration"}, {"full_name": "locally_compact_of_proper", "code": "instance (priority := 100) locally_compact_of_proper [ProperSpace \u03b1] : LocallyCompactSpace \u03b1 :=\n  locallyCompactSpace_of_hasBasis (fun _ => nhds_basis_closedBall) fun _ _ _ =>\n    isCompact_closedBall _ _", "start": [2242, 1], "end": [2245, 29], "kind": "commanddeclaration"}, {"full_name": "complete_of_proper", "code": "instance (priority := 100) complete_of_proper [ProperSpace \u03b1] : CompleteSpace \u03b1 :=\n  \u27e8fun {f} hf => by\n    \n    obtain \u27e8t, t_fset, ht\u27e9 : \u2203 t \u2208 f, \u2200 x \u2208 t, \u2200 y \u2208 t, dist x y < 1 :=\n      (Metric.cauchy_iff.1 hf).2 1 zero_lt_one\n    rcases hf.1.nonempty_of_mem t_fset with \u27e8x, xt\u27e9\n    have : closedBall x 1 \u2208 f := mem_of_superset t_fset fun y yt => (ht y yt x xt).le\n    rcases (isCompact_iff_totallyBounded_isComplete.1 (isCompact_closedBall x 1)).2 f hf\n        (le_principal_iff.2 this) with\n      \u27e8y, -, hy\u27e9\n    exact \u27e8y, hy\u27e9\u27e9", "start": [2249, 1], "end": [2261, 19], "kind": "commanddeclaration"}, {"full_name": "prod_properSpace", "code": "instance prod_properSpace {\u03b1 : Type*} {\u03b2 : Type*} [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2]\n    [ProperSpace \u03b1] [ProperSpace \u03b2] : ProperSpace (\u03b1 \u00d7 \u03b2) where\n  isCompact_closedBall := by\n    rintro \u27e8x, y\u27e9 r\n    rw [\u2190 closedBall_prod_same x y]\n    exact (isCompact_closedBall x r).prod (isCompact_closedBall y r)", "start": [2264, 1], "end": [2270, 69], "kind": "commanddeclaration"}, {"full_name": "pi_properSpace", "code": "instance pi_properSpace {\u03c0 : \u03b2 \u2192 Type*} [Fintype \u03b2] [\u2200 b, PseudoMetricSpace (\u03c0 b)]\n    [h : \u2200 b, ProperSpace (\u03c0 b)] : ProperSpace (\u2200 b, \u03c0 b) := by\n  refine' properSpace_of_compact_closedBall_of_le 0 fun x r hr => _\n  rw [closedBall_pi _ hr]\n  exact isCompact_univ_pi fun _ => isCompact_closedBall _ _", "start": [2273, 1], "end": [2278, 60], "kind": "commanddeclaration"}, {"full_name": "exists_pos_lt_subset_ball", "code": "theorem exists_pos_lt_subset_ball (hr : 0 < r) (hs : IsClosed s) (h : s \u2286 ball x r) :\n    \u2203 r' \u2208 Ioo 0 r, s \u2286 ball x r'", "start": [2283, 1], "end": [2295, 89], "kind": "commanddeclaration"}, {"full_name": "exists_lt_subset_ball", "code": "theorem exists_lt_subset_ball (hs : IsClosed s) (h : s \u2286 ball x r) : \u2203 r' < r, s \u2286 ball x r'", "start": [2298, 1], "end": [2305, 81], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isSeparable", "code": "theorem IsCompact.isSeparable {s : Set \u03b1} (hs : IsCompact s) : IsSeparable s", "start": [2310, 1], "end": [2312, 42], "kind": "commanddeclaration"}, {"full_name": "Metric.secondCountable_of_almost_dense_set", "code": "theorem secondCountable_of_almost_dense_set\n    (H : \u2200 \u03b5 > (0 : \u211d), \u2203 s : Set \u03b1, s.Countable \u2227 \u2200 x, \u2203 y \u2208 s, dist x y \u2264 \u03b5) :\n    SecondCountableTopology \u03b1", "start": [2321, 1], "end": [2330, 23], "kind": "commanddeclaration"}, {"full_name": "lebesgue_number_lemma_of_metric", "code": "theorem lebesgue_number_lemma_of_metric {s : Set \u03b1} {\u03b9 : Sort*} {c : \u03b9 \u2192 Set \u03b1} (hs : IsCompact s)\n    (hc\u2081 : \u2200 i, IsOpen (c i)) (hc\u2082 : s \u2286 \u22c3 i, c i) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 i, ball x \u03b4 \u2286 c i", "start": [2337, 1], "end": [2341, 91], "kind": "commanddeclaration"}, {"full_name": "lebesgue_number_lemma_of_metric_sUnion", "code": "theorem lebesgue_number_lemma_of_metric_sUnion {s : Set \u03b1} {c : Set (Set \u03b1)} (hs : IsCompact s)\n    (hc\u2081 : \u2200 t \u2208 c, IsOpen t) (hc\u2082 : s \u2286 \u22c3\u2080 c) : \u2203 \u03b4 > 0, \u2200 x \u2208 s, \u2203 t \u2208 c, ball x \u03b4 \u2286 t", "start": [2344, 1], "end": [2346, 94], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_closedBall", "code": "theorem isBounded_closedBall : IsBounded (closedBall x r)", "start": [2363, 1], "end": [2367, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_ball", "code": "theorem isBounded_ball : IsBounded (ball x r)", "start": [2370, 1], "end": [2372, 53], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_sphere", "code": "theorem isBounded_sphere : IsBounded (sphere x r)", "start": [2375, 1], "end": [2377, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_subset_closedBall", "code": "theorem isBounded_iff_subset_closedBall (c : \u03b1) : IsBounded s \u2194 \u2203 r, s \u2286 closedBall c r", "start": [2380, 1], "end": [2383, 51], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.subset_closedBall", "code": "theorem _root_.Bornology.IsBounded.subset_closedBall (h : IsBounded s) (c : \u03b1) :\n    \u2203 r, s \u2286 closedBall c r", "start": [2386, 1], "end": [2388, 42], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.subset_ball_lt", "code": "theorem _root_.Bornology.IsBounded.subset_ball_lt (h : IsBounded s) (a : \u211d) (c : \u03b1) :\n    \u2203 r, a < r \u2227 s \u2286 ball c r", "start": [2391, 1], "end": [2395, 47], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.subset_ball", "code": "theorem _root_.Bornology.IsBounded.subset_ball (h : IsBounded s) (c : \u03b1) : \u2203 r, s \u2286 ball c r", "start": [2397, 1], "end": [2398, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_subset_ball", "code": "theorem isBounded_iff_subset_ball (c : \u03b1) : IsBounded s \u2194 \u2203 r, s \u2286 ball c r", "start": [2400, 1], "end": [2401, 73], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.subset_closedBall_lt", "code": "theorem _root_.Bornology.IsBounded.subset_closedBall_lt (h : IsBounded s) (a : \u211d) (c : \u03b1) :\n    \u2203 r, a < r \u2227 s \u2286 closedBall c r", "start": [2403, 1], "end": [2406, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_closure_of_isBounded", "code": "theorem isBounded_closure_of_isBounded (h : IsBounded s) : IsBounded (closure s)", "start": [2409, 1], "end": [2412, 46], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.closure", "code": "protected theorem _root_.Bornology.IsBounded.closure (h : IsBounded s) : IsBounded (closure s)", "start": [2415, 1], "end": [2416, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_closure_iff", "code": "@[simp]\ntheorem isBounded_closure_iff : IsBounded (closure s) \u2194 IsBounded s", "start": [2419, 1], "end": [2421, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.hasBasis_cobounded_compl_closedBall", "code": "theorem hasBasis_cobounded_compl_closedBall (c : \u03b1) :\n    (cobounded \u03b1).HasBasis (fun _ \u21a6 True) (fun r \u21a6 (closedBall c r)\u1d9c)", "start": [2429, 1], "end": [2431, 91], "kind": "commanddeclaration"}, {"full_name": "Metric.hasBasis_cobounded_compl_ball", "code": "theorem hasBasis_cobounded_compl_ball (c : \u03b1) :\n    (cobounded \u03b1).HasBasis (fun _ \u21a6 True) (fun r \u21a6 (ball c r)\u1d9c)", "start": [2433, 1], "end": [2435, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.comap_dist_right_atTop", "code": "@[simp]\ntheorem comap_dist_right_atTop (c : \u03b1) : comap (dist \u00b7 c) atTop = cobounded \u03b1", "start": [2437, 1], "end": [2440, 83], "kind": "commanddeclaration"}, {"full_name": "Metric.comap_dist_left_atTop", "code": "@[simp]\ntheorem comap_dist_left_atTop (c : \u03b1) : comap (dist c) atTop = cobounded \u03b1", "start": [2442, 1], "end": [2444, 60], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_dist_right_atTop_iff", "code": "@[simp]\ntheorem tendsto_dist_right_atTop_iff (c : \u03b1) {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} :\n    Tendsto (fun x \u21a6 dist (f x) c) l atTop \u2194 Tendsto f l (cobounded \u03b1)", "start": [2446, 1], "end": [2449, 58], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_dist_left_atTop_iff", "code": "@[simp]\ntheorem tendsto_dist_left_atTop_iff (c : \u03b1) {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} :\n    Tendsto (fun x \u21a6 dist c (f x)) l atTop \u2194 Tendsto f l (cobounded \u03b1)", "start": [2451, 1], "end": [2454, 56], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_dist_right_cobounded_atTop", "code": "theorem tendsto_dist_right_cobounded_atTop (c : \u03b1) : Tendsto (dist \u00b7 c) (cobounded \u03b1) atTop", "start": [2456, 1], "end": [2457, 52], "kind": "commanddeclaration"}, {"full_name": "Metric.tendsto_dist_left_cobounded_atTop", "code": "theorem tendsto_dist_left_cobounded_atTop (c : \u03b1) : Tendsto (dist c) (cobounded \u03b1) atTop", "start": [2459, 1], "end": [2460, 51], "kind": "commanddeclaration"}, {"full_name": "TotallyBounded.isBounded", "code": "theorem _root_.TotallyBounded.isBounded {s : Set \u03b1} (h : TotallyBounded s) : IsBounded s", "start": [2462, 1], "end": [2467, 69], "kind": "commanddeclaration"}, {"full_name": "IsCompact.isBounded", "code": "theorem _root_.IsCompact.isBounded {s : Set \u03b1} (h : IsCompact s) : IsBounded s", "start": [2470, 1], "end": [2473, 29], "kind": "commanddeclaration"}, {"full_name": "Metric.cobounded_le_cocompact", "code": "theorem cobounded_le_cocompact : cobounded \u03b1 \u2264 cocompact \u03b1", "start": [2480, 1], "end": [2481, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_range_iff", "code": "theorem isBounded_range_iff {f : \u03b2 \u2192 \u03b1} : IsBounded (range f) \u2194 \u2203 C, \u2200 x y, dist (f x) (f y) \u2264 C", "start": [2485, 1], "end": [2487, 57], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_image_iff", "code": "theorem isBounded_image_iff {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} :\n    IsBounded (f '' s) \u2194 \u2203 C, \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 C", "start": [2490, 1], "end": [2492, 55], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_range_of_tendsto_cofinite_uniformity", "code": "theorem isBounded_range_of_tendsto_cofinite_uniformity {f : \u03b2 \u2192 \u03b1}\n    (hf : Tendsto (Prod.map f f) (.cofinite \u00d7\u02e2 .cofinite) (\ud835\udce4 \u03b1)) : IsBounded (range f)", "start": [2494, 1], "end": [2500, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_range_of_cauchy_map_cofinite", "code": "theorem isBounded_range_of_cauchy_map_cofinite {f : \u03b2 \u2192 \u03b1} (hf : Cauchy (map f cofinite)) :\n    IsBounded (range f)", "start": [2503, 1], "end": [2505, 76], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.isBounded_range", "code": "theorem _root_.CauchySeq.isBounded_range {f : \u2115 \u2192 \u03b1} (hf : CauchySeq f) : IsBounded (range f)", "start": [2508, 1], "end": [2509, 75], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_range_of_tendsto_cofinite", "code": "theorem isBounded_range_of_tendsto_cofinite {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Tendsto f cofinite (\ud835\udcdd a)) :\n    IsBounded (range f)", "start": [2512, 1], "end": [2515, 85], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_of_compactSpace", "code": "theorem isBounded_of_compactSpace [CompactSpace \u03b1] : IsBounded s", "start": [2518, 1], "end": [2520, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_range_of_tendsto", "code": "theorem isBounded_range_of_tendsto (u : \u2115 \u2192 \u03b1) {x : \u03b1} (hu : Tendsto u atTop (\ud835\udcdd x)) :\n    IsBounded (range u)", "start": [2523, 1], "end": [2525, 31], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_nhds_cobounded", "code": "theorem disjoint_nhds_cobounded (x : \u03b1) : Disjoint (\ud835\udcdd x) (cobounded \u03b1)", "start": [2528, 1], "end": [2529, 92], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_cobounded_nhds", "code": "theorem disjoint_cobounded_nhds (x : \u03b1) : Disjoint (cobounded \u03b1) (\ud835\udcdd x)", "start": [2531, 1], "end": [2532, 35], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_nhdsSet_cobounded", "code": "theorem disjoint_nhdsSet_cobounded {s : Set \u03b1} (hs : IsCompact s) : Disjoint (\ud835\udcdd\u02e2 s) (cobounded \u03b1)", "start": [2534, 1], "end": [2535, 65], "kind": "commanddeclaration"}, {"full_name": "Metric.disjoint_cobounded_nhdsSet", "code": "theorem disjoint_cobounded_nhdsSet {s : Set \u03b1} (hs : IsCompact s) : Disjoint (cobounded \u03b1) (\ud835\udcdd\u02e2 s)", "start": [2537, 1], "end": [2538, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt", "code": "theorem exists_isOpen_isBounded_image_inter_of_isCompact_of_forall_continuousWithinAt\n    [TopologicalSpace \u03b2] {k s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (hk : IsCompact k)\n    (hf : \u2200 x \u2208 k, ContinuousWithinAt f s x) :\n    \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))", "start": [2540, 1], "end": [2553, 74], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt", "code": "theorem exists_isOpen_isBounded_image_of_isCompact_of_forall_continuousAt [TopologicalSpace \u03b2]\n    {k : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (hk : IsCompact k) (hf : \u2200 x \u2208 k, ContinuousAt f x) :\n    \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' t)", "start": [2556, 1], "end": [2563, 88], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_isOpen_isBounded_image_inter_of_isCompact_of_continuousOn", "code": "theorem exists_isOpen_isBounded_image_inter_of_isCompact_of_continuousOn [TopologicalSpace \u03b2]\n    {k s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (hk : IsCompact k) (hks : k \u2286 s) (hf : ContinuousOn f s) :\n    \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' (t \u2229 s))", "start": [2566, 1], "end": [2572, 18], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_isOpen_isBounded_image_of_isCompact_of_continuousOn", "code": "theorem exists_isOpen_isBounded_image_of_isCompact_of_continuousOn [TopologicalSpace \u03b2]\n    {k s : Set \u03b2} {f : \u03b2 \u2192 \u03b1} (hk : IsCompact k) (hs : IsOpen s) (hks : k \u2286 s)\n    (hf : ContinuousOn f s) : \u2203 t, k \u2286 t \u2227 IsOpen t \u2227 IsBounded (f '' t)", "start": [2575, 1], "end": [2581, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.isCompact_of_isClosed_isBounded", "code": "theorem isCompact_of_isClosed_isBounded [ProperSpace \u03b1] (hc : IsClosed s) (hb : IsBounded s) :\n    IsCompact s", "start": [2584, 1], "end": [2590, 62], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.isCompact_closure", "code": "theorem _root_.Bornology.IsBounded.isCompact_closure [ProperSpace \u03b1] (h : IsBounded s) :\n    IsCompact (closure s)", "start": [2593, 1], "end": [2596, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.isCompact_iff_isClosed_bounded", "code": "theorem isCompact_iff_isClosed_bounded [T2Space \u03b1] [ProperSpace \u03b1] :\n    IsCompact s \u2194 IsClosed s \u2227 IsBounded s", "start": [2600, 1], "end": [2604, 89], "kind": "commanddeclaration"}, {"full_name": "Metric.compactSpace_iff_isBounded_univ", "code": "theorem compactSpace_iff_isBounded_univ [ProperSpace \u03b1] :\n    CompactSpace \u03b1 \u2194 IsBounded (univ : Set \u03b1)", "start": [2607, 1], "end": [2609, 99], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_Icc", "code": "theorem isBounded_Icc (a b : \u03b1) : IsBounded (Icc a b)", "start": [2616, 1], "end": [2617, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_Ico", "code": "theorem isBounded_Ico (a b : \u03b1) : IsBounded (Ico a b)", "start": [2620, 1], "end": [2621, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_Ioc", "code": "theorem isBounded_Ioc (a b : \u03b1) : IsBounded (Ioc a b)", "start": [2624, 1], "end": [2625, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_Ioo", "code": "theorem isBounded_Ioo (a b : \u03b1) : IsBounded (Ioo a b)", "start": [2628, 1], "end": [2629, 37], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_of_bddAbove_of_bddBelow", "code": "theorem isBounded_of_bddAbove_of_bddBelow {s : Set \u03b1} (h\u2081 : BddAbove s) (h\u2082 : BddBelow s) :\n    IsBounded s", "start": [2632, 1], "end": [2638, 71], "kind": "commanddeclaration"}, {"full_name": "Metric.diam", "code": "noncomputable def diam (s : Set \u03b1) : \u211d :=\n  ENNReal.toReal (EMetric.diam s)", "start": [2649, 1], "end": [2652, 34], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_nonneg", "code": "theorem diam_nonneg : 0 \u2264 diam s", "start": [2655, 1], "end": [2657, 24], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_subsingleton", "code": "theorem diam_subsingleton (hs : s.Subsingleton) : diam s = 0", "start": [2660, 1], "end": [2661, 70], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_empty", "code": "@[simp]\ntheorem diam_empty : diam (\u2205 : Set \u03b1) = 0", "start": [2664, 1], "end": [2667, 39], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_singleton", "code": "@[simp]\ntheorem diam_singleton : diam ({x} : Set \u03b1) = 0", "start": [2670, 1], "end": [2673, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_pair", "code": "theorem diam_pair : diam ({x, y} : Set \u03b1) = dist x y", "start": [2677, 1], "end": [2678, 50], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_triple", "code": "theorem diam_triple :\n    Metric.diam ({x, y, z} : Set \u03b1) = max (max (dist x y) (dist x z)) (dist y z)", "start": [2682, 1], "end": [2685, 95], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_le_of_forall_dist_le", "code": "theorem ediam_le_of_forall_dist_le {C : \u211d} (h : \u2200 x \u2208 s, \u2200 y \u2208 s, dist x y \u2264 C) :\n    EMetric.diam s \u2264 ENNReal.ofReal C", "start": [2688, 1], "end": [2692, 98], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_le_of_forall_dist_le", "code": "theorem diam_le_of_forall_dist_le {C : \u211d} (h\u2080 : 0 \u2264 C) (h : \u2200 x \u2208 s, \u2200 y \u2208 s, dist x y \u2264 C) :\n    diam s \u2264 C", "start": [2695, 1], "end": [2699, 67], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_le_of_forall_dist_le_of_nonempty", "code": "theorem diam_le_of_forall_dist_le_of_nonempty (hs : s.Nonempty) {C : \u211d}\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, dist x y \u2264 C) : diam s \u2264 C", "start": [2702, 1], "end": [2709, 33], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_le_diam_of_mem'", "code": "theorem dist_le_diam_of_mem' (h : EMetric.diam s \u2260 \u22a4) (hx : x \u2208 s) (hy : y \u2208 s) :\n    dist x y \u2264 diam s", "start": [2712, 1], "end": [2717, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.isBounded_iff_ediam_ne_top", "code": "theorem isBounded_iff_ediam_ne_top : IsBounded s \u2194 EMetric.diam s \u2260 \u22a4", "start": [2720, 1], "end": [2724, 71], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.ediam_ne_top", "code": "alias \u27e8_root_.Bornology.IsBounded.ediam_ne_top, _\u27e9 := isBounded_iff_ediam_ne_top", "start": [2727, 1], "end": [2727, 81], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Metric.ediam_eq_top_iff_unbounded", "code": "theorem ediam_eq_top_iff_unbounded : EMetric.diam s = \u22a4 \u2194 \u00acIsBounded s", "start": [2730, 1], "end": [2731, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_univ_eq_top_iff_noncompact", "code": "theorem ediam_univ_eq_top_iff_noncompact [ProperSpace \u03b1] :\n    EMetric.diam (univ : Set \u03b1) = \u221e \u2194 NoncompactSpace \u03b1", "start": [2733, 1], "end": [2736, 23], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_univ_of_noncompact", "code": "@[simp]\ntheorem ediam_univ_of_noncompact [ProperSpace \u03b1] [NoncompactSpace \u03b1] :\n    EMetric.diam (univ : Set \u03b1) = \u221e", "start": [2739, 1], "end": [2742, 43], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_univ_of_noncompact", "code": "@[simp]\ntheorem diam_univ_of_noncompact [ProperSpace \u03b1] [NoncompactSpace \u03b1] : diam (univ : Set \u03b1) = 0", "start": [2745, 1], "end": [2747, 14], "kind": "commanddeclaration"}, {"full_name": "Metric.dist_le_diam_of_mem", "code": "theorem dist_le_diam_of_mem (h : IsBounded s) (hx : x \u2208 s) (hy : y \u2208 s) : dist x y \u2264 diam s", "start": [2750, 1], "end": [2752, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.ediam_of_unbounded", "code": "theorem ediam_of_unbounded (h : \u00acIsBounded s) : EMetric.diam s = \u221e", "start": [2755, 1], "end": [2755, 101], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_eq_zero_of_unbounded", "code": "theorem diam_eq_zero_of_unbounded (h : \u00acIsBounded s) : diam s = 0", "start": [2758, 1], "end": [2761, 54], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_mono", "code": "theorem diam_mono {s t : Set \u03b1} (h : s \u2286 t) (ht : IsBounded t) : diam s \u2264 diam t", "start": [2764, 1], "end": [2766, 61], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_union", "code": "theorem diam_union {t : Set \u03b1} (xs : x \u2208 s) (yt : y \u2208 t) :\n    diam (s \u222a t) \u2264 diam s + dist x y + diam t", "start": [2769, 1], "end": [2779, 79], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_union'", "code": "theorem diam_union' {t : Set \u03b1} (h : (s \u2229 t).Nonempty) : diam (s \u222a t) \u2264 diam s + diam t", "start": [2782, 1], "end": [2785, 31], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_le_of_subset_closedBall", "code": "theorem diam_le_of_subset_closedBall {r : \u211d} (hr : 0 \u2264 r) (h : s \u2286 closedBall x r) :\n    diam s \u2264 2 * r", "start": [2788, 1], "end": [2794, 47], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_closedBall", "code": "theorem diam_closedBall {r : \u211d} (h : 0 \u2264 r) : diam (closedBall x r) \u2264 2 * r", "start": [2797, 1], "end": [2799, 44], "kind": "commanddeclaration"}, {"full_name": "Metric.diam_ball", "code": "theorem diam_ball {r : \u211d} (h : 0 \u2264 r) : diam (ball x r) \u2264 2 * r", "start": [2802, 1], "end": [2804, 56], "kind": "commanddeclaration"}, {"full_name": "IsComplete.nonempty_iInter_of_nonempty_biInter", "code": "theorem _root_.IsComplete.nonempty_iInter_of_nonempty_biInter {s : \u2115 \u2192 Set \u03b1}\n    (h0 : IsComplete (s 0)) (hs : \u2200 n, IsClosed (s n)) (h's : \u2200 n, IsBounded (s n))\n    (h : \u2200 N, (\u22c2 n \u2264 N, s n).Nonempty) (h' : Tendsto (fun n => diam (s n)) atTop (\ud835\udcdd 0)) :\n    (\u22c2 n, s n).Nonempty", "start": [2807, 1], "end": [2829, 17], "kind": "commanddeclaration"}, {"full_name": "Metric.nonempty_iInter_of_nonempty_biInter", "code": "theorem nonempty_iInter_of_nonempty_biInter [CompleteSpace \u03b1] {s : \u2115 \u2192 Set \u03b1}\n    (hs : \u2200 n, IsClosed (s n)) (h's : \u2200 n, IsBounded (s n)) (h : \u2200 N, (\u22c2 n \u2264 N, s n).Nonempty)\n    (h' : Tendsto (fun n => diam (s n)) atTop (\ud835\udcdd 0)) : (\u22c2 n, s n).Nonempty", "start": [2832, 1], "end": [2837, 68], "kind": "commanddeclaration"}, {"full_name": "Metric.exists_isLocalMin_mem_ball", "code": "theorem exists_isLocalMin_mem_ball [ProperSpace \u03b1] [TopologicalSpace \u03b2]\n    [ConditionallyCompleteLinearOrder \u03b2] [OrderTopology \u03b2] {f : \u03b1 \u2192 \u03b2} {a z : \u03b1} {r : \u211d}\n    (hf : ContinuousOn f (closedBall a r)) (hz : z \u2208 closedBall a r)\n    (hf1 : \u2200 z' \u2208 sphere a r, f z < f z') : \u2203 z \u2208 ball a r, IsLocalMin f z", "start": [2842, 1], "end": [2848, 16], "kind": "commanddeclaration"}, {"full_name": "Mathlib.Meta.Positivity.evalDiam", "code": "@[positivity Metric.diam _]\ndef evalDiam : PositivityExt where eval {_ _} _z\u03b1 _p\u03b1 e := do\n  let .app _ s \u2190 whnfR e | throwError \"not Metric.diam\"\n  let p \u2190 mkAppOptM ``Metric.diam_nonneg #[none, none, s]\n  pure (.nonnegative p)", "start": [2857, 1], "end": [2862, 24], "kind": "commanddeclaration"}, {"full_name": "Metric.cobounded_eq_cocompact", "code": "theorem Metric.cobounded_eq_cocompact [ProperSpace \u03b1] : cobounded \u03b1 = cocompact \u03b1", "start": [2866, 1], "end": [2869, 61], "kind": "commanddeclaration"}, {"full_name": "tendsto_dist_right_cocompact_atTop", "code": "theorem tendsto_dist_right_cocompact_atTop [ProperSpace \u03b1] (x : \u03b1) :\n    Tendsto (dist \u00b7 x) (cocompact \u03b1) atTop", "start": [2872, 1], "end": [2874, 77], "kind": "commanddeclaration"}, {"full_name": "tendsto_dist_left_cocompact_atTop", "code": "theorem tendsto_dist_left_cocompact_atTop [ProperSpace \u03b1] (x : \u03b1) :\n    Tendsto (dist x) (cocompact \u03b1) atTop", "start": [2877, 1], "end": [2879, 76], "kind": "commanddeclaration"}, {"full_name": "comap_dist_left_atTop_eq_cocompact", "code": "theorem comap_dist_left_atTop_eq_cocompact [ProperSpace \u03b1] (x : \u03b1) :\n    comap (dist x) atTop = cocompact \u03b1", "start": [2882, 1], "end": [2883, 75], "kind": "commanddeclaration"}, {"full_name": "tendsto_cocompact_of_tendsto_dist_comp_atTop", "code": "theorem tendsto_cocompact_of_tendsto_dist_comp_atTop {f : \u03b2 \u2192 \u03b1} {l : Filter \u03b2} (x : \u03b1)\n    (h : Tendsto (fun y => dist (f y) x) l atTop) : Tendsto f l (cocompact \u03b1)", "start": [2886, 1], "end": [2888, 75], "kind": "commanddeclaration"}, {"full_name": "MetricSpace", "code": "class MetricSpace (\u03b1 : Type u) extends PseudoMetricSpace \u03b1 : Type u where\n  eq_of_dist_eq_zero : \u2200 {x y : \u03b1}, dist x y = 0 \u2192 x = y", "start": [2891, 1], "end": [2893, 57], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.ext", "code": "@[ext]\ntheorem MetricSpace.ext {\u03b1 : Type*} {m m' : MetricSpace \u03b1} (h : m.toDist = m'.toDist) :\n    m = m'", "start": [2896, 1], "end": [2900, 45], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.ofDistTopology", "code": "def MetricSpace.ofDistTopology {\u03b1 : Type u} [TopologicalSpace \u03b1] (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d)\n    (dist_self : \u2200 x : \u03b1, dist x x = 0) (dist_comm : \u2200 x y : \u03b1, dist x y = dist y x)\n    (dist_triangle : \u2200 x y z : \u03b1, dist x z \u2264 dist x y + dist y z)\n    (H : \u2200 s : Set \u03b1, IsOpen s \u2194 \u2200 x \u2208 s, \u2203 \u03b5 > 0, \u2200 y, dist x y < \u03b5 \u2192 y \u2208 s)\n    (eq_of_dist_eq_zero : \u2200 x y : \u03b1, dist x y = 0 \u2192 x = y) : MetricSpace \u03b1 :=\n  { PseudoMetricSpace.ofDistTopology dist dist_self dist_comm dist_triangle H with\n    eq_of_dist_eq_zero := eq_of_dist_eq_zero _ _ }", "start": [2903, 1], "end": [2912, 51], "kind": "commanddeclaration"}, {"full_name": "eq_of_dist_eq_zero", "code": "theorem eq_of_dist_eq_zero {x y : \u03b3} : dist x y = 0 \u2192 x = y", "start": [2917, 1], "end": [2918, 33], "kind": "commanddeclaration"}, {"full_name": "dist_eq_zero", "code": "@[simp]\ntheorem dist_eq_zero {x y : \u03b3} : dist x y = 0 \u2194 x = y", "start": [2921, 1], "end": [2923, 62], "kind": "commanddeclaration"}, {"full_name": "zero_eq_dist", "code": "@[simp]\ntheorem zero_eq_dist {x y : \u03b3} : 0 = dist x y \u2194 x = y", "start": [2926, 1], "end": [2927, 87], "kind": "commanddeclaration"}, {"full_name": "dist_ne_zero", "code": "theorem dist_ne_zero {x y : \u03b3} : dist x y \u2260 0 \u2194 x \u2260 y", "start": [2930, 1], "end": [2931, 46], "kind": "commanddeclaration"}, {"full_name": "dist_le_zero", "code": "@[simp]\ntheorem dist_le_zero {x y : \u03b3} : dist x y \u2264 0 \u2194 x = y", "start": [2934, 1], "end": [2936, 67], "kind": "commanddeclaration"}, {"full_name": "dist_pos", "code": "@[simp]\ntheorem dist_pos {x y : \u03b3} : 0 < dist x y \u2194 x \u2260 y", "start": [2939, 1], "end": [2941, 51], "kind": "commanddeclaration"}, {"full_name": "eq_of_forall_dist_le", "code": "theorem eq_of_forall_dist_le {x y : \u03b3} (h : \u2200 \u03b5 > 0, dist x y \u2264 \u03b5) : x = y", "start": [2944, 1], "end": [2945, 68], "kind": "commanddeclaration"}, {"full_name": "eq_of_nndist_eq_zero", "code": "theorem eq_of_nndist_eq_zero {x y : \u03b3} : nndist x y = 0 \u2192 x = y", "start": [2948, 1], "end": [2950, 86], "kind": "commanddeclaration"}, {"full_name": "nndist_eq_zero", "code": "@[simp]\ntheorem nndist_eq_zero {x y : \u03b3} : nndist x y = 0 \u2194 x = y", "start": [2953, 1], "end": [2956, 86], "kind": "commanddeclaration"}, {"full_name": "zero_eq_nndist", "code": "@[simp]\ntheorem zero_eq_nndist {x y : \u03b3} : 0 = nndist x y \u2194 x = y", "start": [2959, 1], "end": [2961, 86], "kind": "commanddeclaration"}, {"full_name": "Metric.closedBall_zero", "code": "@[simp] theorem closedBall_zero : closedBall x 0 = {x}", "start": [2968, 1], "end": [2968, 88], "kind": "commanddeclaration"}, {"full_name": "Metric.sphere_zero", "code": "@[simp] theorem sphere_zero : sphere x 0 = {x}", "start": [2971, 1], "end": [2971, 80], "kind": "commanddeclaration"}, {"full_name": "Metric.subsingleton_closedBall", "code": "theorem subsingleton_closedBall (x : \u03b3) {r : \u211d} (hr : r \u2264 0) : (closedBall x r).Subsingleton", "start": [2974, 1], "end": [2979, 33], "kind": "commanddeclaration"}, {"full_name": "Metric.subsingleton_sphere", "code": "theorem subsingleton_sphere (x : \u03b3) {r : \u211d} (hr : r \u2264 0) : (sphere x r).Subsingleton", "start": [2982, 1], "end": [2983, 63], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.to_separated", "code": "instance (priority := 100) _root_.MetricSpace.to_separated : SeparatedSpace \u03b3 :=\n  separated_def.2 fun _ _ h =>\n    eq_of_forall_dist_le fun _ \u03b50 => le_of_lt (h _ (dist_mem_uniformity \u03b50))", "start": [2987, 1], "end": [2989, 77], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEmbedding_iff'", "code": "theorem uniformEmbedding_iff' [MetricSpace \u03b2] {f : \u03b3 \u2192 \u03b2} :\n    UniformEmbedding f \u2194\n      (\u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 {a b : \u03b3}, dist a b < \u03b4 \u2192 dist (f a) (f b) < \u03b5) \u2227\n        \u2200 \u03b4 > 0, \u2203 \u03b5 > 0, \u2200 {a b : \u03b3}, dist (f a) (f b) < \u03b5 \u2192 dist a b < \u03b4", "start": [2992, 1], "end": [2998, 88], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.ofT0PseudoMetricSpace", "code": "@[reducible]\ndef _root_.MetricSpace.ofT0PseudoMetricSpace (\u03b1 : Type*) [PseudoMetricSpace \u03b1] [T0Space \u03b1] :\n    MetricSpace \u03b1 where\n  toPseudoMetricSpace := \u2039_\u203a\n  eq_of_dist_eq_zero hdist := (Metric.inseparable_iff.2 hdist).eq", "start": [3001, 1], "end": [3006, 66], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.toEMetricSpace", "code": "instance (priority := 100) _root_.MetricSpace.toEMetricSpace : EMetricSpace \u03b3 :=\n  .ofT0PseudoEMetricSpace \u03b3", "start": [3010, 1], "end": [3012, 28], "kind": "commanddeclaration"}, {"full_name": "Metric.isClosed_of_pairwise_le_dist", "code": "theorem isClosed_of_pairwise_le_dist {s : Set \u03b3} {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5)\n    (hs : s.Pairwise fun x y => \u03b5 \u2264 dist x y) : IsClosed s", "start": [3015, 1], "end": [3017, 71], "kind": "commanddeclaration"}, {"full_name": "Metric.closedEmbedding_of_pairwise_le_dist", "code": "theorem closedEmbedding_of_pairwise_le_dist {\u03b1 : Type*} [TopologicalSpace \u03b1] [DiscreteTopology \u03b1]\n    {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {f : \u03b1 \u2192 \u03b3} (hf : Pairwise fun x y => \u03b5 \u2264 dist (f x) (f y)) :\n    ClosedEmbedding f", "start": [3020, 1], "end": [3023, 78], "kind": "commanddeclaration"}, {"full_name": "Metric.uniformEmbedding_bot_of_pairwise_le_dist", "code": "theorem uniformEmbedding_bot_of_pairwise_le_dist {\u03b2 : Type*} {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {f : \u03b2 \u2192 \u03b1}\n    (hf : Pairwise fun x y => \u03b5 \u2264 dist (f x) (f y)) :\n    @UniformEmbedding _ _ \u22a5 (by infer_instance) f", "start": [3026, 1], "end": [3031, 79], "kind": "commanddeclaration"}, {"full_name": "Metric.finite_isBounded_inter_isClosed", "code": "theorem finite_isBounded_inter_isClosed [ProperSpace \u03b1] {K s : Set \u03b1} [DiscreteTopology s]\n    (hK : IsBounded K) (hs : IsClosed s) : Set.Finite (K \u2229 s)", "start": [3034, 1], "end": [3038, 80], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceUniformity", "code": "def MetricSpace.replaceUniformity {\u03b3} [U : UniformSpace \u03b3] (m : MetricSpace \u03b3)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : MetricSpace \u03b3 where\n  toPseudoMetricSpace := PseudoMetricSpace.replaceUniformity m.toPseudoMetricSpace H\n  eq_of_dist_eq_zero := @eq_of_dist_eq_zero _ _", "start": [3042, 1], "end": [3049, 48], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceUniformity_eq", "code": "theorem MetricSpace.replaceUniformity_eq {\u03b3} [U : UniformSpace \u03b3] (m : MetricSpace \u03b3)\n    (H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m", "start": [3052, 1], "end": [3054, 11], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceTopology", "code": "@[reducible]\ndef MetricSpace.replaceTopology {\u03b3} [U : TopologicalSpace \u03b3] (m : MetricSpace \u03b3)\n    (H : U = m.toPseudoMetricSpace.toUniformSpace.toTopologicalSpace) : MetricSpace \u03b3 :=\n  @MetricSpace.replaceUniformity \u03b3 (m.toUniformSpace.replaceTopology H) m rfl", "start": [3057, 1], "end": [3064, 78], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceTopology_eq", "code": "theorem MetricSpace.replaceTopology_eq {\u03b3} [U : TopologicalSpace \u03b3] (m : MetricSpace \u03b3)\n    (H : U = m.toPseudoMetricSpace.toUniformSpace.toTopologicalSpace) :\n    m.replaceTopology H = m", "start": [3067, 1], "end": [3070, 11], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace.toMetricSpaceOfDist", "code": "@[reducible]\ndef EMetricSpace.toMetricSpaceOfDist {\u03b1 : Type u} [EMetricSpace \u03b1] (dist : \u03b1 \u2192 \u03b1 \u2192 \u211d)\n    (edist_ne_top : \u2200 x y : \u03b1, edist x y \u2260 \u22a4) (h : \u2200 x y, dist x y = ENNReal.toReal (edist x y)) :\n    MetricSpace \u03b1 :=\n  @MetricSpace.ofT0PseudoMetricSpace _\n    (PseudoEMetricSpace.toPseudoMetricSpaceOfDist dist edist_ne_top h) _", "start": [3073, 1], "end": [3083, 73], "kind": "commanddeclaration"}, {"full_name": "EMetricSpace.toMetricSpace", "code": "def EMetricSpace.toMetricSpace {\u03b1 : Type u} [EMetricSpace \u03b1] (h : \u2200 x y : \u03b1, edist x y \u2260 \u22a4) :\n    MetricSpace \u03b1 :=\n  EMetricSpace.toMetricSpaceOfDist (fun x y => ENNReal.toReal (edist x y)) h fun _ _ => rfl", "start": [3086, 1], "end": [3091, 92], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceBornology", "code": "def MetricSpace.replaceBornology {\u03b1} [B : Bornology \u03b1] (m : MetricSpace \u03b1)\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) : MetricSpace \u03b1 :=\n  { PseudoMetricSpace.replaceBornology _ H, m with toBornology := B }", "start": [3094, 1], "end": [3100, 70], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.replaceBornology_eq", "code": "theorem MetricSpace.replaceBornology_eq {\u03b1} [m : MetricSpace \u03b1] [B : Bornology \u03b1]\n    (H : \u2200 s, @IsBounded _ B s \u2194 @IsBounded _ PseudoMetricSpace.toBornology s) :\n    MetricSpace.replaceBornology _ H = m", "start": [3103, 1], "end": [3107, 6], "kind": "commanddeclaration"}, {"full_name": "MetricSpace.induced", "code": "@[reducible]\ndef MetricSpace.induced {\u03b3 \u03b2} (f : \u03b3 \u2192 \u03b2) (hf : Function.Injective f) (m : MetricSpace \u03b2) :\n    MetricSpace \u03b3 :=\n  { PseudoMetricSpace.induced f m.toPseudoMetricSpace with\n    eq_of_dist_eq_zero := fun h => hf (dist_eq_zero.1 h) }", "start": [3110, 1], "end": [3116, 59], "kind": "commanddeclaration"}, {"full_name": "UniformEmbedding.comapMetricSpace", "code": "@[reducible]\ndef UniformEmbedding.comapMetricSpace {\u03b1 \u03b2} [UniformSpace \u03b1] [m : MetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : UniformEmbedding f) : MetricSpace \u03b1 :=\n  .replaceUniformity (.induced f h.inj m) h.comap_uniformity.symm", "start": [3119, 1], "end": [3124, 66], "kind": "commanddeclaration"}, {"full_name": "Embedding.comapMetricSpace", "code": "@[reducible]\ndef Embedding.comapMetricSpace {\u03b1 \u03b2} [TopologicalSpace \u03b1] [m : MetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2)\n    (h : Embedding f) : MetricSpace \u03b1 :=\n  .replaceTopology (.induced f h.inj m) h.induced", "start": [3127, 1], "end": [3132, 50], "kind": "commanddeclaration"}, {"full_name": "Subtype.metricSpace", "code": "instance Subtype.metricSpace {\u03b1 : Type*} {p : \u03b1 \u2192 Prop} [MetricSpace \u03b1] :\n    MetricSpace (Subtype p) :=\n  .induced Subtype.val Subtype.coe_injective \u2039_\u203a", "start": [3135, 1], "end": [3137, 49], "kind": "commanddeclaration"}, {"full_name": "Real.metricSpace", "code": "instance Real.metricSpace : MetricSpace \u211d := .ofT0PseudoMetricSpace \u211d", "start": [3169, 1], "end": [3170, 70], "kind": "commanddeclaration"}, {"full_name": "Prod.metricSpaceMax", "code": "instance Prod.metricSpaceMax [MetricSpace \u03b2] : MetricSpace (\u03b3 \u00d7 \u03b2) := .ofT0PseudoMetricSpace _", "start": [3187, 1], "end": [3187, 95], "kind": "commanddeclaration"}, {"full_name": "metricSpacePi", "code": "instance metricSpacePi : MetricSpace (\u2200 b, \u03c0 b) := .ofT0PseudoMetricSpace _", "start": [3198, 1], "end": [3199, 76], "kind": "commanddeclaration"}, {"full_name": "Metric.secondCountable_of_countable_discretization", "code": "theorem secondCountable_of_countable_discretization {\u03b1 : Type u} [MetricSpace \u03b1]\n    (H : \u2200 \u03b5 > (0 : \u211d), \u2203 (\u03b2 : Type*) (_ : Encodable \u03b2) (F : \u03b1 \u2192 \u03b2),\n      \u2200 x y, F x = F y \u2192 dist x y \u2264 \u03b5) :\n    SecondCountableTopology \u03b1", "start": [3211, 1], "end": [3223, 49], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.SeparationQuotient.dist_mk", "code": "theorem UniformSpace.SeparationQuotient.dist_mk {\u03b1 : Type u} [PseudoMetricSpace \u03b1] (p q : \u03b1) :\n    @dist (UniformSpace.SeparationQuotient \u03b1) _ (Quot.mk _ p) (Quot.mk _ q) = dist p q", "start": [3237, 1], "end": [3239, 6], "kind": "commanddeclaration"}, {"full_name": "dist_ofMul", "code": "@[simp] theorem dist_ofMul (a b : X) : dist (ofMul a) (ofMul b) = dist a b", "start": [3264, 1], "end": [3264, 82], "kind": "commanddeclaration"}, {"full_name": "dist_ofAdd", "code": "@[simp] theorem dist_ofAdd (a b : X) : dist (ofAdd a) (ofAdd b) = dist a b", "start": [3267, 1], "end": [3267, 82], "kind": "commanddeclaration"}, {"full_name": "dist_toMul", "code": "@[simp] theorem dist_toMul (a b : Additive X) : dist (toMul a) (toMul b) = dist a b", "start": [3270, 1], "end": [3270, 91], "kind": "commanddeclaration"}, {"full_name": "dist_toAdd", "code": "@[simp] theorem dist_toAdd (a b : Multiplicative X) : dist (toAdd a) (toAdd b) = dist a b", "start": [3273, 1], "end": [3273, 97], "kind": "commanddeclaration"}, {"full_name": "nndist_ofMul", "code": "@[simp] theorem nndist_ofMul (a b : X) : nndist (ofMul a) (ofMul b) = nndist a b", "start": [3285, 1], "end": [3285, 88], "kind": "commanddeclaration"}, {"full_name": "nndist_ofAdd", "code": "@[simp] theorem nndist_ofAdd (a b : X) : nndist (ofAdd a) (ofAdd b) = nndist a b", "start": [3288, 1], "end": [3288, 88], "kind": "commanddeclaration"}, {"full_name": "nndist_toMul", "code": "@[simp] theorem nndist_toMul (a b : Additive X) : nndist (toMul a) (toMul b) = nndist a b", "start": [3291, 1], "end": [3291, 97], "kind": "commanddeclaration"}, {"full_name": "nndist_toAdd", "code": "@[simp]\ntheorem nndist_toAdd (a b : Multiplicative X) : nndist (toAdd a) (toAdd b) = nndist a b", "start": [3294, 1], "end": [3295, 95], "kind": "commanddeclaration"}, {"full_name": "dist_toDual", "code": "@[simp] theorem dist_toDual (a b : X) : dist (toDual a) (toDual b) = dist a b", "start": [3320, 1], "end": [3320, 85], "kind": "commanddeclaration"}, {"full_name": "dist_ofDual", "code": "@[simp] theorem dist_ofDual (a b : X\u1d52\u1d48) : dist (ofDual a) (ofDual b) = dist a b", "start": [3323, 1], "end": [3323, 87], "kind": "commanddeclaration"}, {"full_name": "nndist_toDual", "code": "@[simp] theorem nndist_toDual (a b : X) : nndist (toDual a) (toDual b) = nndist a b", "start": [3334, 1], "end": [3334, 91], "kind": "commanddeclaration"}, {"full_name": "nndist_ofDual", "code": "@[simp] theorem nndist_ofDual (a b : X\u1d52\u1d48) : nndist (ofDual a) (ofDual b) = nndist a b", "start": [3337, 1], "end": [3337, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Bornology/Hom.lean", "imports": ["Mathlib/Topology/Bornology/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LocallyBoundedMap", "code": "structure LocallyBoundedMap (\u03b1 \u03b2 : Type*) [Bornology \u03b1] [Bornology \u03b2] where\n  \n  toFun : \u03b1 \u2192 \u03b2\n  \n  comap_cobounded_le' : (cobounded \u03b2).comap toFun \u2264 cobounded \u03b1", "start": [32, 1], "end": [38, 64], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMapClass", "code": "class LocallyBoundedMapClass (F : Type*) (\u03b1 \u03b2 : outParam <| Type*) [Bornology \u03b1]\n    [Bornology \u03b2] extends FunLike F \u03b1 fun _ => \u03b2 where\n  \n  comap_cobounded_le (f : F) : (cobounded \u03b2).comap f \u2264 cobounded \u03b1", "start": [43, 1], "end": [50, 67], "kind": "commanddeclaration"}, {"full_name": "Bornology.IsBounded.image", "code": "theorem Bornology.IsBounded.image [Bornology \u03b1] [Bornology \u03b2] [LocallyBoundedMapClass F \u03b1 \u03b2] (f : F)\n    {s : Set \u03b1} (hs : IsBounded s) : IsBounded (f '' s)", "start": [57, 1], "end": [59, 53], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMapClass.toLocallyBoundedMap", "code": "@[coe]\ndef LocallyBoundedMapClass.toLocallyBoundedMap [Bornology \u03b1] [Bornology \u03b2]\n    [LocallyBoundedMapClass F \u03b1 \u03b2] (f : F) : LocallyBoundedMap \u03b1 \u03b2 where\n  toFun := f\n  comap_cobounded_le' := comap_cobounded_le f", "start": [62, 1], "end": [69, 46], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.ext", "code": "@[ext]\ntheorem ext {f g : LocallyBoundedMap \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g", "start": [96, 1], "end": [98, 20], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.copy", "code": "protected def copy (f : LocallyBoundedMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : LocallyBoundedMap \u03b1 \u03b2 :=\n  \u27e8f', h.symm \u25b8 f.comap_cobounded_le'\u27e9", "start": [101, 1], "end": [104, 39], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.coe_copy", "code": "@[simp]\ntheorem coe_copy (f : LocallyBoundedMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : \u21d1(f.copy f' h) = f'", "start": [107, 1], "end": [109, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.copy_eq", "code": "theorem copy_eq (f : LocallyBoundedMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f", "start": [112, 1], "end": [113, 17], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.ofMapBounded", "code": "def ofMapBounded (f : \u03b1 \u2192 \u03b2) (h : \u2200 \u2983s : Set \u03b1\u2984, IsBounded s \u2192 IsBounded (f '' s)) :\n    LocallyBoundedMap \u03b1 \u03b2 :=\n  \u27e8f, comap_cobounded_le_iff.2 h\u27e9", "start": [116, 1], "end": [120, 34], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.coe_ofMapBounded", "code": "@[simp]\ntheorem coe_ofMapBounded (f : \u03b1 \u2192 \u03b2) {h} : \u21d1(ofMapBounded f h) = f", "start": [124, 1], "end": [126, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.ofMapBounded_apply", "code": "@[simp]\ntheorem ofMapBounded_apply (f : \u03b1 \u2192 \u03b2) {h} (a : \u03b1) : ofMapBounded f h a = f a", "start": [129, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.id", "code": "protected def id : LocallyBoundedMap \u03b1 \u03b1 :=\n  \u27e8id, comap_id.le\u27e9", "start": [136, 1], "end": [138, 20], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(LocallyBoundedMap.id \u03b1) = id", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.id_apply", "code": "@[simp]\ntheorem id_apply (a : \u03b1) : LocallyBoundedMap.id \u03b1 a = a", "start": [151, 1], "end": [153, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.comp", "code": "def comp (f : LocallyBoundedMap \u03b2 \u03b3) (g : LocallyBoundedMap \u03b1 \u03b2) : LocallyBoundedMap \u03b1 \u03b3\n    where\n  toFun := f \u2218 g\n  comap_cobounded_le' :=\n    comap_comap.ge.trans <| (comap_mono f.comap_cobounded_le').trans g.comap_cobounded_le'", "start": [156, 1], "end": [161, 91], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : LocallyBoundedMap \u03b2 \u03b3) (g : LocallyBoundedMap \u03b1 \u03b2) : \u21d1(f.comp g) = f \u2218 g", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.comp_apply", "code": "@[simp]\ntheorem comp_apply (f : LocallyBoundedMap \u03b2 \u03b3) (g : LocallyBoundedMap \u03b1 \u03b2) (a : \u03b1) :\n    f.comp g a = f (g a)", "start": [169, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.comp_assoc", "code": "@[simp]\ntheorem comp_assoc (f : LocallyBoundedMap \u03b3 \u03b4) (g : LocallyBoundedMap \u03b2 \u03b3)\n    (h : LocallyBoundedMap \u03b1 \u03b2) : (f.comp g).comp h = f.comp (g.comp h)", "start": [175, 1], "end": [178, 6], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : LocallyBoundedMap \u03b1 \u03b2) : f.comp (LocallyBoundedMap.id \u03b1) = f", "start": [181, 1], "end": [183, 19], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : LocallyBoundedMap \u03b1 \u03b2) : (LocallyBoundedMap.id \u03b2).comp f = f", "start": [186, 1], "end": [188, 19], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.cancel_right", "code": "@[simp]\ntheorem cancel_right {g\u2081 g\u2082 : LocallyBoundedMap \u03b2 \u03b3} {f : LocallyBoundedMap \u03b1 \u03b2}\n    (hf : Surjective f) : g\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082", "start": [191, 1], "end": [194, 85], "kind": "commanddeclaration"}, {"full_name": "LocallyBoundedMap.cancel_left", "code": "@[simp]\ntheorem cancel_left {g : LocallyBoundedMap \u03b2 \u03b3} {f\u2081 f\u2082 : LocallyBoundedMap \u03b1 \u03b2} (hg : Injective g) :\n    g.comp f\u2081 = g.comp f\u2082 \u2194 f\u2081 = f\u2082", "start": [198, 1], "end": [201, 81], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/Field.lean", "imports": ["Mathlib/Tactic/Positivity.lean", "Mathlib/Topology/Algebra/Order/Group.lean", "Mathlib/Topology/Algebra/Field.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "TopologicalRing.of_norm", "code": "theorem TopologicalRing.of_norm {R \ud835\udd5c : Type*} [NonUnitalNonAssocRing R] [LinearOrderedField \ud835\udd5c]\n    [TopologicalSpace R] [TopologicalAddGroup R] (norm : R \u2192 \ud835\udd5c)\n    (norm_nonneg : \u2200 x, 0 \u2264 norm x) (norm_mul_le : \u2200 x y, norm (x * y) \u2264 norm x * norm y)\n    (nhds_basis : (\ud835\udcdd (0 : R)).HasBasis ((0 : \ud835\udd5c) < \u00b7) (fun \u03b5 \u21a6 { x | norm x < \u03b5 })) :\n    TopologicalRing R", "start": [25, 1], "end": [49, 48], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.topologicalRing", "code": "instance (priority := 100) LinearOrderedField.topologicalRing : TopologicalRing \ud835\udd5c :=\n  .of_norm abs abs_nonneg (fun _ _ \u21a6 (abs_mul _ _).le) <| by\n    simpa using nhds_basis_abs_sub_lt (0 : \ud835\udd5c)", "start": [55, 1], "end": [57, 46], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul", "code": "theorem Filter.Tendsto.atTop_mul {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l atTop)\n    (hg : Tendsto g l (\ud835\udcdd C)) : Tendsto (fun x => f x * g x) l atTop", "start": [59, 1], "end": [65, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mul_atTop", "code": "theorem Filter.Tendsto.mul_atTop {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atTop", "start": [68, 1], "end": [72, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_neg", "code": "theorem Filter.Tendsto.atTop_mul_neg {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l atTop)\n    (hg : Tendsto g l (\ud835\udcdd C)) : Tendsto (fun x => f x * g x) l atBot", "start": [75, 1], "end": [80, 92], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.neg_mul_atTop", "code": "theorem Filter.Tendsto.neg_mul_atTop {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atTop) : Tendsto (fun x => f x * g x) l atBot", "start": [83, 1], "end": [87, 53], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul", "code": "theorem Filter.Tendsto.atBot_mul {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l atBot)\n    (hg : Tendsto g l (\ud835\udcdd C)) : Tendsto (fun x => f x * g x) l atBot", "start": [90, 1], "end": [95, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_neg", "code": "theorem Filter.Tendsto.atBot_mul_neg {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l atBot)\n    (hg : Tendsto g l (\ud835\udcdd C)) : Tendsto (fun x => f x * g x) l atTop", "start": [98, 1], "end": [103, 58], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.mul_atBot", "code": "theorem Filter.Tendsto.mul_atBot {C : \ud835\udd5c} (hC : 0 < C) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atBot", "start": [106, 1], "end": [110, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.neg_mul_atBot", "code": "theorem Filter.Tendsto.neg_mul_atBot {C : \ud835\udd5c} (hC : C < 0) (hf : Tendsto f l (\ud835\udcdd C))\n    (hg : Tendsto g l atBot) : Tendsto (fun x => f x * g x) l atTop", "start": [113, 1], "end": [117, 53], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_zero_atTop", "code": "theorem tendsto_inv_zero_atTop : Tendsto (fun x : \ud835\udd5c => x\u207b\u00b9) (\ud835\udcdd[>] (0 : \ud835\udd5c)) atTop", "start": [120, 1], "end": [125, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_atTop_zero'", "code": "theorem tendsto_inv_atTop_zero' : Tendsto (fun r : \ud835\udd5c => r\u207b\u00b9) atTop (\ud835\udcdd[>] (0 : \ud835\udd5c))", "start": [128, 1], "end": [133, 48], "kind": "commanddeclaration"}, {"full_name": "tendsto_inv_atTop_zero", "code": "theorem tendsto_inv_atTop_zero : Tendsto (fun r : \ud835\udd5c => r\u207b\u00b9) atTop (\ud835\udcdd 0)", "start": [136, 1], "end": [137, 49], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.div_atTop", "code": "theorem Filter.Tendsto.div_atTop {a : \ud835\udd5c} (h : Tendsto f l (\ud835\udcdd a)) (hg : Tendsto g l atTop) :\n    Tendsto (fun x => f x / g x) l (\ud835\udcdd 0)", "start": [140, 1], "end": [143, 60], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inv_tendsto_atTop", "code": "theorem Filter.Tendsto.inv_tendsto_atTop (h : Tendsto f l atTop) : Tendsto f\u207b\u00b9 l (\ud835\udcdd 0)", "start": [146, 1], "end": [147, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.inv_tendsto_zero", "code": "theorem Filter.Tendsto.inv_tendsto_zero (h : Tendsto f l (\ud835\udcdd[>] 0)) : Tendsto f\u207b\u00b9 l atTop", "start": [150, 1], "end": [151, 32], "kind": "commanddeclaration"}, {"full_name": "tendsto_pow_neg_atTop", "code": "theorem tendsto_pow_neg_atTop {n : \u2115} (hn : n \u2260 0) :\n    Tendsto (fun x : \ud835\udd5c => x ^ (-(n : \u2124))) atTop (\ud835\udcdd 0)", "start": [154, 1], "end": [158, 90], "kind": "commanddeclaration"}, {"full_name": "tendsto_zpow_atTop_zero", "code": "theorem tendsto_zpow_atTop_zero {n : \u2124} (hn : n < 0) :\n    Tendsto (fun x : \ud835\udd5c => x ^ n) atTop (\ud835\udcdd 0)", "start": [161, 1], "end": [165, 61], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_mul_zpow_atTop_zero", "code": "theorem tendsto_const_mul_zpow_atTop_zero {n : \u2124} {c : \ud835\udd5c} (hn : n < 0) :\n    Tendsto (fun x => c * x ^ n) atTop (\ud835\udcdd 0)", "start": [168, 1], "end": [170, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_mul_pow_nhds_iff'", "code": "theorem tendsto_const_mul_pow_nhds_iff' {n : \u2115} {c d : \ud835\udd5c} :\n    Tendsto (fun x : \ud835\udd5c => c * x ^ n) atTop (\ud835\udcdd d) \u2194 (c = 0 \u2228 n = 0) \u2227 c = d", "start": [173, 1], "end": [182, 62], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_mul_pow_nhds_iff", "code": "theorem tendsto_const_mul_pow_nhds_iff {n : \u2115} {c d : \ud835\udd5c} (hc : c \u2260 0) :\n    Tendsto (fun x : \ud835\udd5c => c * x ^ n) atTop (\ud835\udcdd d) \u2194 n = 0 \u2227 c = d", "start": [185, 1], "end": [187, 45], "kind": "commanddeclaration"}, {"full_name": "tendsto_const_mul_zpow_atTop_nhds_iff", "code": "theorem tendsto_const_mul_zpow_atTop_nhds_iff {n : \u2124} {c d : \ud835\udd5c} (hc : c \u2260 0) :\n    Tendsto (fun x : \ud835\udd5c => c * x ^ n) atTop (\ud835\udcdd d) \u2194 n = 0 \u2227 c = d \u2228 n < 0 \u2227 d = 0", "start": [190, 1], "end": [203, 61], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedSemifield.toHasContinuousInv\u2080", "code": "instance (priority := 100) LinearOrderedSemifield.toHasContinuousInv\u2080 {\ud835\udd5c}\n    [LinearOrderedSemifield \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c] [ContinuousMul \ud835\udd5c] :\n    HasContinuousInv\u2080 \ud835\udd5c := .of_nhds_one <| tendsto_order.2 <| by\n  refine \u27e8fun x hx => ?_, fun x hx => ?_\u27e9\n  \u00b7 obtain \u27e8x', h\u2080, hxx', h\u2081\u27e9 : \u2203 x', 0 < x' \u2227 x \u2264 x' \u2227 x' < 1 :=\n      \u27e8max x (1 / 2), one_half_pos.trans_le (le_max_right _ _), le_max_left _ _,\n        max_lt hx one_half_lt_one\u27e9\n    filter_upwards [Ioo_mem_nhds one_pos (one_lt_inv h\u2080 h\u2081)] with y hy\n    exact hxx'.trans_lt <| inv_inv x' \u25b8 inv_lt_inv_of_lt hy.1 hy.2\n  \u00b7 filter_upwards [Ioi_mem_nhds (inv_lt_one hx)] with y hy\n    simpa only [inv_inv] using inv_lt_inv_of_lt (inv_pos.2 <| one_pos.trans hx) hy", "start": [207, 1], "end": [217, 83], "kind": "commanddeclaration"}, {"full_name": "LinearOrderedField.toTopologicalDivisionRing", "code": "instance (priority := 100) LinearOrderedField.toTopologicalDivisionRing :\n    TopologicalDivisionRing \ud835\udd5c := \u27e8\u27e9", "start": [219, 1], "end": [220, 36], "kind": "commanddeclaration"}, {"full_name": "nhdsWithin_pos_comap_mul_left", "code": "theorem nhdsWithin_pos_comap_mul_left {x : \ud835\udd5c} (hx : 0 < x) :\n    comap (x * \u00b7) (\ud835\udcdd[>] 0) = \ud835\udcdd[>] 0", "start": [224, 1], "end": [229, 7], "kind": "commanddeclaration"}, {"full_name": "eventually_nhdsWithin_pos_mul_left", "code": "theorem eventually_nhdsWithin_pos_mul_left {x : \ud835\udd5c} (hx : 0 < x) {p : \ud835\udd5c \u2192 Prop}\n    (h : \u2200\u1da0 \u03b5 in \ud835\udcdd[>] 0, p \u03b5) : \u2200\u1da0 \u03b5 in \ud835\udcdd[>] 0, p (x * \u03b5)", "start": [232, 1], "end": [235, 31], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Equivalence.lean", "imports": ["Mathlib/CategoryTheory/FullSubcategory.lean", "Mathlib/CategoryTheory/EssentialImage.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/CategoryTheory/Functor/FullyFaithful.lean", "Mathlib/Tactic/CategoryTheory/Slice.lean", "Mathlib/CategoryTheory/Whiskering.lean"], "premises": [{"full_name": "CategoryTheory.Equivalence", "code": "structure Equivalence (C : Type u\u2081) (D : Type u\u2082) [Category.{v\u2081} C] [Category.{v\u2082} D] where mk' ::\n  \n  functor : C \u2964 D\n  \n  inverse : D \u2964 C\n  \n  unitIso : \ud835\udfed C \u2245 functor \u22d9 inverse\n  \n  counitIso : inverse \u22d9 functor \u2245 \ud835\udfed D\n  \n  functor_unitIso_comp :\n    \u2200 X : C, functor.map (unitIso.hom.app X) \u226b counitIso.hom.app (functor.obj X) =\n      \ud835\udfd9 (functor.obj X) := by aesop_cat", "start": [66, 1], "end": [91, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unit", "code": "@[pp_dot] abbrev unit (e : C \u224c D) : \ud835\udfed C \u27f6 e.functor \u22d9 e.inverse :=\n  e.unitIso.hom", "start": [106, 1], "end": [108, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.counit", "code": "@[pp_dot] abbrev counit (e : C \u224c D) : e.inverse \u22d9 e.functor \u27f6 \ud835\udfed D :=\n  e.counitIso.hom", "start": [111, 1], "end": [113, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unitInv", "code": "@[pp_dot] abbrev unitInv (e : C \u224c D) : e.functor \u22d9 e.inverse \u27f6 \ud835\udfed C :=\n  e.unitIso.inv", "start": [116, 1], "end": [118, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.counitInv", "code": "@[pp_dot] abbrev counitInv (e : C \u224c D) : \ud835\udfed D \u27f6 e.inverse \u22d9 e.functor :=\n  e.counitIso.inv", "start": [121, 1], "end": [123, 18], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.Equivalence_mk'_unit", "code": "@[simp]\ntheorem Equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unit = unit_iso.hom", "start": [128, 1], "end": [131, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.Equivalence_mk'_counit", "code": "@[simp]\ntheorem Equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counit = counit_iso.hom", "start": [134, 1], "end": [137, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.Equivalence_mk'_unitInv", "code": "@[simp]\ntheorem Equivalence_mk'_unitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).unitInv = unit_iso.inv", "start": [140, 1], "end": [143, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.Equivalence_mk'_counitInv", "code": "@[simp]\ntheorem Equivalence_mk'_counitInv (functor inverse unit_iso counit_iso f) :\n    (\u27e8functor, inverse, unit_iso, counit_iso, f\u27e9 : C \u224c D).counitInv = counit_iso.inv", "start": [146, 1], "end": [149, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.functor_unit_comp", "code": "@[simp]\ntheorem functor_unit_comp (e : C \u224c D) (X : C) :\n    e.functor.map (e.unit.app X) \u226b e.counit.app (e.functor.obj X) = \ud835\udfd9 (e.functor.obj X)", "start": [152, 1], "end": [155, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.counitInv_functor_comp", "code": "@[simp]\ntheorem counitInv_functor_comp (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) \u226b e.functor.map (e.unitInv.app X) = \ud835\udfd9 (e.functor.obj X)", "start": [158, 1], "end": [163, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.counitInv_app_functor", "code": "theorem counitInv_app_functor (e : C \u224c D) (X : C) :\n    e.counitInv.app (e.functor.obj X) = e.functor.map (e.unit.app X)", "start": [166, 1], "end": [170, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.counit_app_functor", "code": "theorem counit_app_functor (e : C \u224c D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unitInv.app X)", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unit_inverse_comp", "code": "@[simp]\ntheorem unit_inverse_comp (e : C \u224c D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) \u226b e.inverse.map (e.counit.app Y) = \ud835\udfd9 (e.inverse.obj Y)", "start": [179, 1], "end": [203, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inverse_counitInv_comp", "code": "@[simp]\ntheorem inverse_counitInv_comp (e : C \u224c D) (Y : D) :\n    e.inverse.map (e.counitInv.app Y) \u226b e.unitInv.app (e.inverse.obj Y) = \ud835\udfd9 (e.inverse.obj Y)", "start": [206, 1], "end": [211, 30], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unit_app_inverse", "code": "theorem unit_app_inverse (e : C \u224c D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) = e.inverse.map (e.counitInv.app Y)", "start": [214, 1], "end": [217, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unitInv_app_inverse", "code": "theorem unitInv_app_inverse (e : C \u224c D) (Y : D) :\n    e.unitInv.app (e.inverse.obj Y) = e.inverse.map (e.counit.app Y)", "start": [220, 1], "end": [224, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.fun_inv_map", "code": "@[simp]\ntheorem fun_inv_map (e : C \u224c D) (X Y : D) (f : X \u27f6 Y) :\n    e.functor.map (e.inverse.map f) = e.counit.app X \u226b f \u226b e.counitInv.app Y", "start": [227, 1], "end": [230, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inv_fun_map", "code": "@[simp]\ntheorem inv_fun_map (e : C \u224c D) (X Y : C) (f : X \u27f6 Y) :\n    e.inverse.map (e.functor.map f) = e.unitInv.app X \u226b f \u226b e.unit.app Y", "start": [233, 1], "end": [236, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.adjointify\u03b7", "code": "def adjointify\u03b7 : \ud835\udfed C \u2245 F \u22d9 G := by\n  calc\n    \ud835\udfed C \u2245 F \u22d9 G := \u03b7\n    _ \u2245 F \u22d9 \ud835\udfed D \u22d9 G := isoWhiskerLeft F (leftUnitor G).symm\n    _ \u2245 F \u22d9 (G \u22d9 F) \u22d9 G := isoWhiskerLeft F (isoWhiskerRight \u03b5.symm G)\n    _ \u2245 F \u22d9 G \u22d9 F \u22d9 G := isoWhiskerLeft F (associator G F G)\n    _ \u2245 (F \u22d9 G) \u22d9 F \u22d9 G := (associator F G (F \u22d9 G)).symm\n    _ \u2245 \ud835\udfed C \u22d9 F \u22d9 G := isoWhiskerRight \u03b7.symm (F \u22d9 G)\n    _ \u2245 F \u22d9 G := leftUnitor (F \u22d9 G)", "start": [244, 1], "end": [255, 36], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.adjointify_\u03b7_\u03b5", "code": "theorem adjointify_\u03b7_\u03b5 (X : C) :\n    F.map ((adjointify\u03b7 \u03b7 \u03b5).hom.app X) \u226b \u03b5.hom.app (F.obj X) = \ud835\udfd9 (F.obj X)", "start": [258, 1], "end": [266, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.mk", "code": "protected def mk (F : C \u2964 D) (G : D \u2964 C) (\u03b7 : \ud835\udfed C \u2245 F \u22d9 G) (\u03b5 : G \u22d9 F \u2245 \ud835\udfed D) : C \u224c D :=\n  \u27e8F, G, adjointify\u03b7 \u03b7 \u03b5, \u03b5, adjointify_\u03b7_\u03b5 \u03b7 \u03b5\u27e9", "start": [271, 1], "end": [275, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.refl", "code": "@[refl, simps]\ndef refl : C \u224c C :=\n  \u27e8\ud835\udfed C, \ud835\udfed C, Iso.refl _, Iso.refl _, fun _ => Category.id_comp _\u27e9", "start": [278, 1], "end": [281, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.symm", "code": "@[symm, simps, pp_dot]\ndef symm (e : C \u224c D) : D \u224c C :=\n  \u27e8e.inverse, e.functor, e.counitIso.symm, e.unitIso.symm, e.inverse_counitInv_comp\u27e9", "start": [287, 1], "end": [290, 85], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.trans", "code": "@[trans, simps, pp_dot]\ndef trans (e : C \u224c D) (f : D \u224c E) : C \u224c E\n    where\n  functor := e.functor \u22d9 f.functor\n  inverse := f.inverse \u22d9 e.inverse\n  unitIso := by\n    refine' Iso.trans e.unitIso _\n    exact isoWhiskerLeft e.functor (isoWhiskerRight f.unitIso e.inverse)\n  counitIso := by\n    refine' Iso.trans _ f.counitIso\n    exact isoWhiskerLeft f.inverse (isoWhiskerRight e.counitIso f.functor)\n  functor_unitIso_comp X := by\n    dsimp\n    rw [\u2190 f.functor.map_comp_assoc, e.functor.map_comp, \u2190 counitInv_app_functor, fun_inv_map,\n      Iso.inv_hom_id_app_assoc, assoc, Iso.inv_hom_id_app, counit_app_functor, \u2190 Functor.map_comp]\n    erw [comp_id, Iso.hom_inv_id_app, Functor.map_id]", "start": [295, 1], "end": [314, 54], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.funInvIdAssoc", "code": "def funInvIdAssoc (e : C \u224c D) (F : C \u2964 E) : e.functor \u22d9 e.inverse \u22d9 F \u2245 F :=\n  (Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight e.unitIso.symm F \u226a\u226b F.leftUnitor", "start": [317, 1], "end": [320, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.funInvIdAssoc_hom_app", "code": "@[simp]\ntheorem funInvIdAssoc_hom_app (e : C \u224c D) (F : C \u2964 E) (X : C) :\n    (funInvIdAssoc e F).hom.app X = F.map (e.unitInv.app X)", "start": [323, 1], "end": [327, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.funInvIdAssoc_inv_app", "code": "@[simp]\ntheorem funInvIdAssoc_inv_app (e : C \u224c D) (F : C \u2964 E) (X : C) :\n    (funInvIdAssoc e F).inv.app X = F.map (e.unit.app X)", "start": [330, 1], "end": [334, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.invFunIdAssoc", "code": "def invFunIdAssoc (e : C \u224c D) (F : D \u2964 E) : e.inverse \u22d9 e.functor \u22d9 F \u2245 F :=\n  (Functor.associator _ _ _).symm \u226a\u226b isoWhiskerRight e.counitIso F \u226a\u226b F.leftUnitor", "start": [337, 1], "end": [340, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.invFunIdAssoc_hom_app", "code": "@[simp]\ntheorem invFunIdAssoc_hom_app (e : C \u224c D) (F : D \u2964 E) (X : D) :\n    (invFunIdAssoc e F).hom.app X = F.map (e.counit.app X)", "start": [343, 1], "end": [347, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.invFunIdAssoc_inv_app", "code": "@[simp]\ntheorem invFunIdAssoc_inv_app (e : C \u224c D) (F : D \u2964 E) (X : D) :\n    (invFunIdAssoc e F).inv.app X = F.map (e.counitInv.app X)", "start": [350, 1], "end": [354, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.congrLeft", "code": "@[simps! functor inverse unitIso counitIso]\ndef congrLeft (e : C \u224c D) : C \u2964 E \u224c D \u2964 E :=\n  Equivalence.mk ((whiskeringLeft _ _ _).obj e.inverse) ((whiskeringLeft _ _ _).obj e.functor)\n    (NatIso.ofComponents fun F => (e.funInvIdAssoc F).symm)\n    (NatIso.ofComponents fun F => e.invFunIdAssoc F)", "start": [357, 1], "end": [362, 53], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.congrRight", "code": "@[simps! functor inverse unitIso counitIso]\ndef congrRight (e : C \u224c D) : E \u2964 C \u224c E \u2964 D :=\n  Equivalence.mk ((whiskeringRight _ _ _).obj e.functor) ((whiskeringRight _ _ _).obj e.inverse)\n    (NatIso.ofComponents\n      fun F => F.rightUnitor.symm \u226a\u226b isoWhiskerLeft F e.unitIso \u226a\u226b Functor.associator _ _ _)\n    (NatIso.ofComponents\n      fun F => Functor.associator _ _ _ \u226a\u226b isoWhiskerLeft F e.counitIso \u226a\u226b F.rightUnitor)", "start": [365, 1], "end": [372, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_unit_right", "code": "@[simp]\ntheorem cancel_unit_right {X Y : C} (f f' : X \u27f6 Y) :\n    f \u226b e.unit.app Y = f' \u226b e.unit.app Y \u2194 f = f'", "start": [384, 1], "end": [386, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_unitInv_right", "code": "@[simp]\ntheorem cancel_unitInv_right {X Y : C} (f f' : X \u27f6 e.inverse.obj (e.functor.obj Y)) :\n    f \u226b e.unitInv.app Y = f' \u226b e.unitInv.app Y \u2194 f = f'", "start": [389, 1], "end": [391, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_counit_right", "code": "@[simp]\ntheorem cancel_counit_right {X Y : D} (f f' : X \u27f6 e.functor.obj (e.inverse.obj Y)) :\n    f \u226b e.counit.app Y = f' \u226b e.counit.app Y \u2194 f = f'", "start": [394, 1], "end": [396, 84], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_counitInv_right", "code": "@[simp]\ntheorem cancel_counitInv_right {X Y : D} (f f' : X \u27f6 Y) :\n    f \u226b e.counitInv.app Y = f' \u226b e.counitInv.app Y \u2194 f = f'", "start": [399, 1], "end": [401, 90], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_unit_right_assoc", "code": "@[simp]\ntheorem cancel_unit_right_assoc {W X X' Y : C} (f : W \u27f6 X) (g : X \u27f6 Y) (f' : W \u27f6 X') (g' : X' \u27f6 Y) :\n    f \u226b g \u226b e.unit.app Y = f' \u226b g' \u226b e.unit.app Y \u2194 f \u226b g = f' \u226b g'", "start": [404, 1], "end": [407, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_counitInv_right_assoc", "code": "@[simp]\ntheorem cancel_counitInv_right_assoc {W X X' Y : D} (f : W \u27f6 X) (g : X \u27f6 Y) (f' : W \u27f6 X')\n    (g' : X' \u27f6 Y) : f \u226b g \u226b e.counitInv.app Y = f' \u226b g' \u226b e.counitInv.app Y \u2194 f \u226b g = f' \u226b g'", "start": [410, 1], "end": [413, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_unit_right_assoc'", "code": "@[simp]\ntheorem cancel_unit_right_assoc' {W X X' Y Y' Z : C} (f : W \u27f6 X) (g : X \u27f6 Y) (h : Y \u27f6 Z)\n    (f' : W \u27f6 X') (g' : X' \u27f6 Y') (h' : Y' \u27f6 Z) :\n    f \u226b g \u226b h \u226b e.unit.app Z = f' \u226b g' \u226b h' \u226b e.unit.app Z \u2194 f \u226b g \u226b h = f' \u226b g' \u226b h'", "start": [416, 1], "end": [420, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.cancel_counitInv_right_assoc'", "code": "@[simp]\ntheorem cancel_counitInv_right_assoc' {W X X' Y Y' Z : D} (f : W \u27f6 X) (g : X \u27f6 Y) (h : Y \u27f6 Z)\n    (f' : W \u27f6 X') (g' : X' \u27f6 Y') (h' : Y' \u27f6 Z) :\n    f \u226b g \u226b h \u226b e.counitInv.app Z = f' \u226b g' \u226b h' \u226b e.counitInv.app Z \u2194 f \u226b g \u226b h = f' \u226b g' \u226b h'", "start": [423, 1], "end": [427, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.powNat", "code": "def powNat (e : C \u224c C) : \u2115 \u2192 (C \u224c C)\n  | 0 => Equivalence.refl\n  | 1 => e\n  | n + 2 => e.trans (powNat e (n + 1))", "start": [437, 1], "end": [441, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.pow", "code": "def pow (e : C \u224c C) : \u2124 \u2192 (C \u224c C)\n  | Int.ofNat n => e.powNat n\n  | Int.negSucc n => e.symm.powNat (n + 1)", "start": [444, 1], "end": [447, 43], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.pow_zero", "code": "@[simp]\ntheorem pow_zero (e : C \u224c C) : e ^ (0 : \u2124) = Equivalence.refl", "start": [453, 1], "end": [455, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.pow_one", "code": "@[simp]\ntheorem pow_one (e : C \u224c C) : e ^ (1 : \u2124) = e", "start": [458, 1], "end": [460, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.pow_neg_one", "code": "@[simp]\ntheorem pow_neg_one (e : C \u224c C) : e ^ (-1 : \u2124) = e.symm", "start": [463, 1], "end": [465, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence", "code": "class IsEquivalence (F : C \u2964 D) where mk' ::\n  \n  inverse : D \u2964 C\n  \n  unitIso : \ud835\udfed C \u2245 F \u22d9 inverse\n  \n  counitIso : inverse \u22d9 F \u2245 \ud835\udfed D\n  \n  functor_unitIso_comp :\n    \u2200 X : C,\n      F.map ((unitIso.hom : \ud835\udfed C \u27f6 F \u22d9 inverse).app X) \u226b counitIso.hom.app (F.obj X) =\n        \ud835\udfd9 (F.obj X) := by\n    aesop_cat", "start": [474, 1], "end": [487, 14], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.ofEquivalence", "code": "instance ofEquivalence (F : C \u224c D) : IsEquivalence F.functor :=\n  { F with }", "start": [497, 1], "end": [498, 13], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.ofEquivalenceInverse", "code": "instance ofEquivalenceInverse (F : C \u224c D) : IsEquivalence F.inverse :=\n  IsEquivalence.ofEquivalence F.symm", "start": [501, 1], "end": [502, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.mk", "code": "protected def mk {F : C \u2964 D} (G : D \u2964 C) (\u03b7 : \ud835\udfed C \u2245 F \u22d9 G) (\u03b5 : G \u22d9 F \u2245 \ud835\udfed D) : IsEquivalence F :=\n  \u27e8G, adjointify\u03b7 \u03b7 \u03b5, \u03b5, adjointify_\u03b7_\u03b5 \u03b7 \u03b5\u27e9", "start": [507, 1], "end": [510, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.asEquivalence", "code": "def asEquivalence (F : C \u2964 D) [IsEquivalence F] : C \u224c D :=\n  \u27e8F, IsEquivalence.inverse F, IsEquivalence.unitIso, IsEquivalence.counitIso,\n    IsEquivalence.functor_unitIso_comp\u27e9", "start": [517, 1], "end": [520, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isEquivalenceRefl", "code": "instance isEquivalenceRefl : IsEquivalence (\ud835\udfed C) :=\n  IsEquivalence.ofEquivalence Equivalence.refl", "start": [523, 1], "end": [524, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.inv", "code": "def inv (F : C \u2964 D) [IsEquivalence F] : D \u2964 C :=\n  IsEquivalence.inverse F", "start": [527, 1], "end": [529, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isEquivalenceInv", "code": "instance isEquivalenceInv (F : C \u2964 D) [IsEquivalence F] : IsEquivalence F.inv :=\n  IsEquivalence.ofEquivalence F.asEquivalence.symm", "start": [532, 1], "end": [533, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.asEquivalence_functor", "code": "@[simp]\ntheorem asEquivalence_functor (F : C \u2964 D) [IsEquivalence F] : F.asEquivalence.functor = F", "start": [536, 1], "end": [538, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.asEquivalence_inverse", "code": "@[simp]\ntheorem asEquivalence_inverse (F : C \u2964 D) [IsEquivalence F] : F.asEquivalence.inverse = inv F", "start": [541, 1], "end": [543, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.asEquivalence_unit", "code": "@[simp]\ntheorem asEquivalence_unit {F : C \u2964 D} [IsEquivalence F] :\n    F.asEquivalence.unitIso = IsEquivalence.unitIso", "start": [546, 1], "end": [549, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.asEquivalence_counit", "code": "@[simp]\ntheorem asEquivalence_counit {F : C \u2964 D} [IsEquivalence F] :\n    F.asEquivalence.counitIso = IsEquivalence.counitIso", "start": [552, 1], "end": [555, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.inv_inv", "code": "@[simp]\ntheorem inv_inv (F : C \u2964 D) [IsEquivalence F] : inv (inv F) = F", "start": [558, 1], "end": [560, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.isEquivalenceTrans", "code": "instance isEquivalenceTrans (F : C \u2964 D) (G : D \u2964 E) [IsEquivalence F] [IsEquivalence G] :\n    IsEquivalence (F \u22d9 G) :=\n  IsEquivalence.ofEquivalence (Equivalence.trans (asEquivalence F) (asEquivalence G))", "start": [565, 1], "end": [567, 86], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.functor_inv", "code": "@[simp]\ntheorem functor_inv (E : C \u224c D) : E.functor.inv = E.inverse", "start": [574, 1], "end": [576, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inverse_inv", "code": "@[simp]\ntheorem inverse_inv (E : C \u224c D) : E.inverse.inv = E.functor", "start": [579, 1], "end": [581, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.functor_asEquivalence", "code": "@[simp]\ntheorem functor_asEquivalence (E : C \u224c D) : E.functor.asEquivalence = E", "start": [584, 1], "end": [587, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inverse_asEquivalence", "code": "@[simp]\ntheorem inverse_asEquivalence (E : C \u224c D) : E.inverse.asEquivalence = E.symm", "start": [590, 1], "end": [593, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.fun_inv_map", "code": "@[simp]\ntheorem fun_inv_map (F : C \u2964 D) [IsEquivalence F] (X Y : D) (f : X \u27f6 Y) :\n    F.map (F.inv.map f) = F.asEquivalence.counit.app X \u226b f \u226b F.asEquivalence.counitInv.app Y", "start": [600, 1], "end": [604, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.inv_fun_map", "code": "@[simp]\ntheorem inv_fun_map (F : C \u2964 D) [IsEquivalence F] (X Y : C) (f : X \u27f6 Y) :\n    F.inv.map (F.map f) = F.asEquivalence.unitInv.app X \u226b f \u226b F.asEquivalence.unit.app Y", "start": [607, 1], "end": [611, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.ofIso", "code": "@[simps!]\ndef ofIso {F G : C \u2964 D} (e : F \u2245 G) (hF : IsEquivalence F) : IsEquivalence G\n    where\n  inverse := hF.inverse\n  unitIso := hF.unitIso \u226a\u226b NatIso.hcomp e (Iso.refl hF.inverse)\n  counitIso := NatIso.hcomp (Iso.refl hF.inverse) e.symm \u226a\u226b hF.counitIso\n  functor_unitIso_comp X := by\n    dsimp [NatIso.hcomp]\n    erw [id_comp, F.map_id, comp_id]\n    apply (cancel_epi (e.hom.app X)).mp\n    slice_lhs 1 2 => rw [\u2190 e.hom.naturality]\n    slice_lhs 2 3 => rw [\u2190 NatTrans.vcomp_app', e.hom_inv_id]\n    simp only [NatTrans.id_app, id_comp, comp_id, F.map_comp, assoc]\n    erw [hF.counitIso.hom.naturality]\n    slice_lhs 1 2 => rw [functor_unitIso_comp]\n    simp only [Functor.id_map, id_comp]", "start": [614, 1], "end": [631, 40], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.ofIso_trans", "code": "theorem ofIso_trans {F G H : C \u2964 D} (e : F \u2245 G) (e' : G \u2245 H) (hF : IsEquivalence F) :\n    ofIso e' (ofIso e hF) = ofIso (e \u226a\u226b e') hF", "start": [634, 1], "end": [640, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.ofIso_refl", "code": "theorem ofIso_refl (F : C \u2964 D) (hF : IsEquivalence F) : ofIso (Iso.refl F) hF = hF", "start": [643, 1], "end": [649, 32], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.equivOfIso", "code": "@[simps]\ndef equivOfIso {F G : C \u2964 D} (e : F \u2245 G) : IsEquivalence F \u2243 IsEquivalence G\n    where\n  toFun := ofIso e\n  invFun := ofIso e.symm\n  left_inv hF := by rw [ofIso_trans, Iso.self_symm_id, ofIso_refl]\n  right_inv hF := by rw [ofIso_trans, Iso.symm_self_id, ofIso_refl]", "start": [652, 1], "end": [659, 68], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.cancelCompRight", "code": "@[simp]\ndef cancelCompRight {E : Type*} [Category E] (F : C \u2964 D) (G : D \u2964 E) (hG : IsEquivalence G)\n    (_ : IsEquivalence (F \u22d9 G)) : IsEquivalence F :=\n  ofIso (Functor.associator F G G.inv \u226a\u226b NatIso.hcomp (Iso.refl F) hG.unitIso.symm \u226a\u226b rightUnitor F)\n    (Functor.isEquivalenceTrans (F \u22d9 G) G.inv)", "start": [662, 1], "end": [667, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.IsEquivalence.cancelCompLeft", "code": "@[simp]\ndef cancelCompLeft {E : Type*} [Category E] (F : C \u2964 D) (G : D \u2964 E) (hF : IsEquivalence F)\n    (_ : IsEquivalence (F \u22d9 G)) : IsEquivalence G :=\n  ofIso\n    ((Functor.associator F.inv F G).symm \u226a\u226b NatIso.hcomp hF.counitIso (Iso.refl G) \u226a\u226b leftUnitor G)\n    (Functor.isEquivalenceTrans F.inv (F \u22d9 G))", "start": [670, 1], "end": [676, 47], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.essSurj_of_equivalence", "code": "theorem essSurj_of_equivalence (F : C \u2964 D) [IsEquivalence F] : EssSurj F", "start": [683, 1], "end": [688, 62], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.faithfulOfEquivalence", "code": "instance (priority := 100) faithfulOfEquivalence (F : C \u2964 D) [IsEquivalence F] : Faithful F where\n  map_injective := @fun X Y f g h => by\n    have p : F.inv.map (F.map f) = F.inv.map (F.map g) := congrArg F.inv.map h\n    simpa only [cancel_epi, cancel_mono, IsEquivalence.inv_fun_map] using p", "start": [692, 1], "end": [699, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.fullOfEquivalence", "code": "instance (priority := 100) fullOfEquivalence (F : C \u2964 D) [IsEquivalence F] : Full F\n    where\n  preimage {X Y} f := F.asEquivalence.unit.app X \u226b F.inv.map f \u226b F.asEquivalence.unitInv.app Y\n  witness {X Y} f :=\n    F.inv.map_injective <| by\n      simpa only [IsEquivalence.inv_fun_map, assoc, Iso.inv_hom_id_app_assoc,\n        Iso.inv_hom_id_app] using comp_id _", "start": [703, 1], "end": [713, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.equivalenceInverse", "code": "@[simps]\nprivate noncomputable def equivalenceInverse (F : C \u2964 D) [Full F] [Faithful F] [EssSurj F] : D \u2964 C\n    where\n  obj X := F.objPreimage X\n  map {X Y} f := F.preimage ((F.objObjPreimageIso X).hom \u226b f \u226b (F.objObjPreimageIso Y).inv)\n  map_id X := by apply F.map_injective; aesop_cat\n  map_comp {X Y Z} f g := by apply F.map_injective; simp", "start": [716, 1], "end": [722, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.ofFullyFaithfullyEssSurj", "code": "noncomputable def ofFullyFaithfullyEssSurj (F : C \u2964 D) [Full F] [Faithful F] [EssSurj F] :\n    IsEquivalence F :=\n  IsEquivalence.mk (equivalenceInverse F)\n    (NatIso.ofComponents (fun X => (F.preimageIso <| F.objObjPreimageIso <| F.obj X).symm)\n      fun f => by\n        apply F.map_injective\n        aesop_cat)\n    (NatIso.ofComponents F.objObjPreimageIso)", "start": [727, 1], "end": [738, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.functor_map_inj_iff", "code": "@[simp]\ntheorem functor_map_inj_iff (e : C \u224c D) {X Y : C} (f g : X \u27f6 Y) :\n    e.functor.map f = e.functor.map g \u2194 f = g", "start": [741, 1], "end": [744, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inverse_map_inj_iff", "code": "@[simp]\ntheorem inverse_map_inj_iff (e : C \u224c D) {X Y : D} (f g : X \u27f6 Y) :\n    e.inverse.map f = e.inverse.map g \u2194 f = g", "start": [747, 1], "end": [750, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.essSurjInducedFunctor", "code": "instance essSurjInducedFunctor {C' : Type*} (e : C' \u2243 D) : EssSurj (inducedFunctor e) where\n  mem_essImage Y := \u27e8e.symm Y, by simpa using \u27e8default\u27e9\u27e9", "start": [753, 1], "end": [754, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.inducedFunctorOfEquiv", "code": "noncomputable instance inducedFunctorOfEquiv {C' : Type*} (e : C' \u2243 D) :\n    IsEquivalence (inducedFunctor e) :=\n  Equivalence.ofFullyFaithfullyEssSurj _", "start": [757, 1], "end": [759, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.fullyFaithfulToEssImage", "code": "noncomputable instance fullyFaithfulToEssImage (F : C \u2964 D) [Full F] [Faithful F] :\n    IsEquivalence F.toEssImage :=\n  ofFullyFaithfullyEssSurj F.toEssImage", "start": [762, 1], "end": [764, 40], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/TensorProductBasis.lean", "imports": ["Mathlib/LinearAlgebra/DirectSum/Finsupp.lean", "Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Basis.tensorProduct", "code": "def Basis.tensorProduct (b : Basis \u03b9 R M) (c : Basis \u03ba R N) :\n    Basis (\u03b9 \u00d7 \u03ba) R (TensorProduct R M N) :=\n  Finsupp.basisSingleOne.map\n    ((TensorProduct.congr b.repr c.repr).trans <|\n        (finsuppTensorFinsupp R _ _ _ _).trans <|\n          Finsupp.lcongr (Equiv.refl _) (TensorProduct.lid R R)).symm", "start": [30, 1], "end": [36, 70], "kind": "commanddeclaration"}, {"full_name": "Basis.tensorProduct_apply", "code": "@[simp]\ntheorem Basis.tensorProduct_apply (b : Basis \u03b9 R M) (c : Basis \u03ba R N) (i : \u03b9) (j : \u03ba) :\n    Basis.tensorProduct b c (i, j) = b i \u2297\u209c c j", "start": [39, 1], "end": [41, 81], "kind": "commanddeclaration"}, {"full_name": "Basis.tensorProduct_apply'", "code": "theorem Basis.tensorProduct_apply' (b : Basis \u03b9 R M) (c : Basis \u03ba R N) (i : \u03b9 \u00d7 \u03ba) :\n    Basis.tensorProduct b c i = b i.1 \u2297\u209c c i.2", "start": [44, 1], "end": [45, 80], "kind": "commanddeclaration"}, {"full_name": "Basis.tensorProduct_repr_tmul_apply", "code": "@[simp]\ntheorem Basis.tensorProduct_repr_tmul_apply (b : Basis \u03b9 R M) (c : Basis \u03ba R N) (m : M) (n : N)\n    (i : \u03b9) (j : \u03ba) :\n    (Basis.tensorProduct b c).repr (m \u2297\u209c n) (i, j) = b.repr m i * c.repr n j", "start": [48, 1], "end": [52, 29], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Congruence.lean", "imports": ["Mathlib/Algebra/GroupRingAction/Basic.lean", "Mathlib/Algebra/Ring/InjSurj.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/GroupTheory/Congruence.lean", "Mathlib/Algebra/Hom/Ring/Defs.lean"], "premises": [{"full_name": "RingCon", "code": "structure RingCon (R : Type*) [Add R] [Mul R] extends Con R, AddCon R where", "start": [37, 1], "end": [39, 76], "kind": "commanddeclaration"}, {"full_name": "RingConGen.Rel", "code": "inductive RingConGen.Rel [Add R] [Mul R] (r : R \u2192 R \u2192 Prop) : R \u2192 R \u2192 Prop\n  | of : \u2200 x y, r x y \u2192 RingConGen.Rel r x y\n  | refl : \u2200 x, RingConGen.Rel r x x\n  | symm : \u2200 {x y}, RingConGen.Rel r x y \u2192 RingConGen.Rel r y x\n  | trans : \u2200 {x y z}, RingConGen.Rel r x y \u2192 RingConGen.Rel r y z \u2192 RingConGen.Rel r x z\n  | add : \u2200 {w x y z}, RingConGen.Rel r w x \u2192 RingConGen.Rel r y z \u2192\n      RingConGen.Rel r (w + y) (x + z)\n  | mul : \u2200 {w x y z}, RingConGen.Rel r w x \u2192 RingConGen.Rel r y z \u2192\n      RingConGen.Rel r (w * y) (x * z)", "start": [50, 1], "end": [60, 39], "kind": "commanddeclaration"}, {"full_name": "ringConGen", "code": "def ringConGen [Add R] [Mul R] (r : R \u2192 R \u2192 Prop) : RingCon R where\n  r := RingConGen.Rel r\n  iseqv := \u27e8RingConGen.Rel.refl, @RingConGen.Rel.symm _ _ _ _, @RingConGen.Rel.trans _ _ _ _\u27e9\n  add' := RingConGen.Rel.add\n  mul' := RingConGen.Rel.mul", "start": [63, 1], "end": [69, 29], "kind": "commanddeclaration"}, {"full_name": "RingCon.rel_eq_coe", "code": "theorem rel_eq_coe : c.r = c", "start": [89, 1], "end": [90, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.toCon_coe_eq_coe", "code": "@[simp]\ntheorem toCon_coe_eq_coe : (c.toCon : R \u2192 R \u2192 Prop) = c", "start": [93, 1], "end": [95, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.refl", "code": "protected theorem refl (x) : c x x", "start": [97, 1], "end": [98, 12], "kind": "commanddeclaration"}, {"full_name": "RingCon.symm", "code": "protected theorem symm {x y} : c x y \u2192 c y x", "start": [101, 1], "end": [102, 10], "kind": "commanddeclaration"}, {"full_name": "RingCon.trans", "code": "protected theorem trans {x y z} : c x y \u2192 c y z \u2192 c x z", "start": [105, 1], "end": [106, 11], "kind": "commanddeclaration"}, {"full_name": "RingCon.add", "code": "protected theorem add {w x y z} : c w x \u2192 c y z \u2192 c (w + y) (x + z)", "start": [109, 1], "end": [110, 9], "kind": "commanddeclaration"}, {"full_name": "RingCon.mul", "code": "protected theorem mul {w x y z} : c w x \u2192 c y z \u2192 c (w * y) (x * z)", "start": [113, 1], "end": [114, 9], "kind": "commanddeclaration"}, {"full_name": "RingCon.rel_mk", "code": "@[simp]\ntheorem rel_mk {s : Con R} {h a b} : RingCon.mk s h a b \u2194 @Setoid.r _ s.toSetoid a b", "start": [120, 1], "end": [122, 10], "kind": "commanddeclaration"}, {"full_name": "RingCon.Quotient", "code": "protected def Quotient :=\n  Quotient c.toSetoid", "start": [132, 1], "end": [134, 22], "kind": "commanddeclaration"}, {"full_name": "RingCon.toQuotient", "code": "@[coe] def toQuotient (r : R) : c.Quotient :=\n  @Quotient.mk'' _ c.toSetoid r", "start": [139, 1], "end": [141, 32], "kind": "commanddeclaration"}, {"full_name": "RingCon.quot_mk_eq_coe", "code": "@[simp]\ntheorem quot_mk_eq_coe (x : R) : Quot.mk c x = (x : c.Quotient)", "start": [156, 1], "end": [158, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.eq", "code": "@[simp]\nprotected theorem eq {a b : R} : (a : c.Quotient) = (b : c.Quotient) \u2194 c a b", "start": [161, 1], "end": [165, 16], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (x y : R) : (\u2191(x + y) : c.Quotient) = \u2191x + \u2191y", "start": [184, 1], "end": [186, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_mul", "code": "@[simp, norm_cast]\ntheorem coe_mul (x y : R) : (\u2191(x * y) : c.Quotient) = \u2191x * \u2191y", "start": [191, 1], "end": [193, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : (\u2191(0 : R) : c.Quotient) = 0", "start": [204, 1], "end": [206, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_one", "code": "@[simp, norm_cast]\ntheorem coe_one : (\u2191(1 : R) : c.Quotient) = 1", "start": [217, 1], "end": [219, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (a : \u03b1) (x : R) : (\u2191(a \u2022 x) : c.Quotient) = a \u2022 (x : c.Quotient)", "start": [230, 1], "end": [232, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (x : R) : (\u2191(-x) : c.Quotient) = -x", "start": [243, 1], "end": [245, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (x y : R) : (\u2191(x - y) : c.Quotient) = x - y", "start": [250, 1], "end": [252, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.hasZsmul", "code": "instance hasZsmul : SMul \u2124 c.Quotient := inferInstanceAs (SMul \u2124 c.toAddCon.Quotient)", "start": [255, 1], "end": [255, 86], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_zsmul", "code": "@[simp, norm_cast]\ntheorem coe_zsmul (z : \u2124) (x : R) : (\u2191(z \u2022 x) : c.Quotient) = z \u2022 (x : c.Quotient)", "start": [258, 1], "end": [260, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.hasNsmul", "code": "instance hasNsmul : SMul \u2115 c.Quotient := inferInstanceAs (SMul \u2115 c.toAddCon.Quotient)", "start": [269, 1], "end": [269, 86], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_nsmul", "code": "@[simp, norm_cast]\ntheorem coe_nsmul (n : \u2115) (x : R) : (\u2191(n \u2022 x) : c.Quotient) = n \u2022 (x : c.Quotient)", "start": [272, 1], "end": [274, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_pow", "code": "@[simp, norm_cast]\ntheorem coe_pow (x : R) (n : \u2115) : (\u2191(x ^ n) : c.Quotient) = (x : c.Quotient) ^ n", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_nat_cast", "code": "@[simp, norm_cast]\ntheorem coe_nat_cast (n : \u2115) : (\u2191(n : R) : c.Quotient) = n", "start": [299, 1], "end": [301, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.coe_int_cast", "code": "@[simp, norm_cast]\ntheorem coe_int_cast (n : \u2115) : (\u2191(n : R) : c.Quotient) = n", "start": [313, 1], "end": [315, 6], "kind": "commanddeclaration"}, {"full_name": "RingCon.isScalarTower_right", "code": "instance isScalarTower_right [Add R] [MulOneClass R] [SMul \u03b1 R] [IsScalarTower \u03b1 R R]\n    (c : RingCon R) : IsScalarTower \u03b1 c.Quotient c.Quotient where\n  smul_assoc _ := Quotient.ind\u2082' fun _ _ => congr_arg Quotient.mk'' <| smul_mul_assoc _ _ _", "start": [376, 1], "end": [378, 92], "kind": "commanddeclaration"}, {"full_name": "RingCon.smulCommClass", "code": "instance smulCommClass [Add R] [MulOneClass R] [SMul \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass \u03b1 R R] (c : RingCon R) : SMulCommClass \u03b1 c.Quotient c.Quotient where\n  smul_comm _ := Quotient.ind\u2082' fun _ _ => congr_arg Quotient.mk'' <| (mul_smul_comm _ _ _).symm", "start": [381, 1], "end": [383, 97], "kind": "commanddeclaration"}, {"full_name": "RingCon.smulCommClass'", "code": "instance smulCommClass' [Add R] [MulOneClass R] [SMul \u03b1 R] [IsScalarTower \u03b1 R R]\n    [SMulCommClass R \u03b1 R] (c : RingCon R) : SMulCommClass c.Quotient \u03b1 c.Quotient :=\n  haveI := SMulCommClass.symm R \u03b1 R\n  SMulCommClass.symm _ _ _", "start": [386, 1], "end": [389, 27], "kind": "commanddeclaration"}, {"full_name": "RingCon.mk'", "code": "def mk' [NonAssocSemiring R] (c : RingCon R) : R \u2192+* c.Quotient\n    where\n  toFun := toQuotient\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' _ _ := rfl\n  map_mul' _ _ := rfl", "start": [406, 1], "end": [413, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Ring/Fin.lean", "imports": ["Mathlib/Logic/Equiv/Fin.lean", "Mathlib/Algebra/Ring/Equiv.lean", "Mathlib/Algebra/Group/Prod.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "RingEquiv.piFinTwo", "code": "@[simps]\ndef RingEquiv.piFinTwo (R : Fin 2 \u2192 Type*) [\u2200 i, Semiring (R i)] :\n    (\u2200 i : Fin 2, R i) \u2243+* R 0 \u00d7 R 1 :=\n  { piFinTwoEquiv R with\n    toFun := piFinTwoEquiv R\n    map_add' := fun _ _ => rfl\n    map_mul' := fun _ _ => rfl }", "start": [24, 1], "end": [31, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/UniqueFactorizationDomain.lean", "imports": ["Mathlib/RingTheory/Noetherian.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/RingTheory/Multiplicity.lean", "Mathlib/Algebra/BigOperators/Associated.lean", "Mathlib/Algebra/GCDMonoid/Basic.lean", "Mathlib/Data/Finsupp/Multiset.lean"], "premises": [{"full_name": "WfDvdMonoid", "code": "class WfDvdMonoid (\u03b1 : Type*) [CommMonoidWithZero \u03b1] : Prop where\n  wellFounded_dvdNotUnit : WellFounded (@DvdNotUnit \u03b1 _)", "start": [34, 1], "end": [39, 57], "kind": "commanddeclaration"}, {"full_name": "IsNoetherianRing.wfDvdMonoid", "code": "instance (priority := 100) IsNoetherianRing.wfDvdMonoid [CommRing \u03b1] [IsDomain \u03b1]\n    [IsNoetherianRing \u03b1] : WfDvdMonoid \u03b1 :=\n  \u27e8by\n    convert InvImage.wf (fun a => Ideal.span ({a} : Set \u03b1)) (wellFounded_submodule_gt _ _)\n    ext\n    exact Ideal.span_singleton_lt_span_singleton.symm\u27e9", "start": [45, 1], "end": [50, 55], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.of_wfDvdMonoid_associates", "code": "theorem of_wfDvdMonoid_associates (_ : WfDvdMonoid (Associates \u03b1)) : WfDvdMonoid \u03b1", "start": [59, 1], "end": [60, 87], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.wfDvdMonoid_associates", "code": "instance wfDvdMonoid_associates : WfDvdMonoid (Associates \u03b1) :=\n  \u27e8(mk_surjective.wellFounded_iff mk_dvdNotUnit_mk_iff.symm).1 wellFounded_dvdNotUnit\u27e9", "start": [65, 1], "end": [66, 87], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.wellFounded_associates", "code": "theorem wellFounded_associates : WellFounded ((\u00b7 < \u00b7) : Associates \u03b1 \u2192 Associates \u03b1 \u2192 Prop)", "start": [69, 1], "end": [70, 57], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.exists_irreducible_factor", "code": "theorem exists_irreducible_factor {a : \u03b1} (ha : \u00acIsUnit a) (ha0 : a \u2260 0) :\n    \u2203 i, Irreducible i \u2227 i \u2223 a", "start": [76, 1], "end": [84, 10], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.induction_on_irreducible", "code": "@[elab_as_elim]\ntheorem induction_on_irreducible {P : \u03b1 \u2192 Prop} (a : \u03b1) (h0 : P 0) (hu : \u2200 u : \u03b1, IsUnit u \u2192 P u)\n    (hi : \u2200 a i : \u03b1, a \u2260 0 \u2192 Irreducible i \u2192 P a \u2192 P (i * a)) : P a", "start": [87, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.exists_factors", "code": "theorem exists_factors (a : \u03b1) :\n    a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Irreducible b) \u2227 Associated f.prod a", "start": [103, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.not_unit_iff_exists_factors_eq", "code": "theorem not_unit_iff_exists_factors_eq (a : \u03b1) (hn0 : a \u2260 0) :\n    \u00acIsUnit a \u2194 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Irreducible b) \u2227 f.prod = a \u2227 f \u2260 \u2205", "start": [114, 1], "end": [126, 80], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.of_wellFounded_associates", "code": "theorem WfDvdMonoid.of_wellFounded_associates [CancelCommMonoidWithZero \u03b1]\n    (h : WellFounded ((\u00b7 < \u00b7) : Associates \u03b1 \u2192 Associates \u03b1 \u2192 Prop)) : WfDvdMonoid \u03b1", "start": [131, 1], "end": [137, 42], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.iff_wellFounded_associates", "code": "theorem WfDvdMonoid.iff_wellFounded_associates [CancelCommMonoidWithZero \u03b1] :\n    WfDvdMonoid \u03b1 \u2194 WellFounded ((\u00b7 < \u00b7) : Associates \u03b1 \u2192 Associates \u03b1 \u2192 Prop)", "start": [140, 1], "end": [142, 87], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid", "code": "class UniqueFactorizationMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1] extends WfDvdMonoid \u03b1 :\n  Prop where\n  irreducible_iff_prime : \u2200 {a : \u03b1}, Irreducible a \u2194 Prime a", "start": [150, 1], "end": [170, 61], "kind": "commanddeclaration"}, {"full_name": "ufm_of_gcd_of_wfDvdMonoid", "code": "@[reducible]\ntheorem ufm_of_gcd_of_wfDvdMonoid [CancelCommMonoidWithZero \u03b1] [WfDvdMonoid \u03b1] [GCDMonoid \u03b1] :\n    UniqueFactorizationMonoid \u03b1", "start": [173, 1], "end": [177, 84], "kind": "commanddeclaration"}, {"full_name": "Associates.ufm", "code": "instance Associates.ufm [CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1] :\n    UniqueFactorizationMonoid (Associates \u03b1) :=\n  { (WfDvdMonoid.wfDvdMonoid_associates : WfDvdMonoid (Associates \u03b1)) with\n    irreducible_iff_prime := by\n      rw [\u2190 Associates.irreducible_iff_prime_iff]\n      apply UniqueFactorizationMonoid.irreducible_iff_prime }", "start": [180, 1], "end": [185, 62], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_prime_factors", "code": "theorem exists_prime_factors (a : \u03b1) :\n    a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Prime b) \u2227 f.prod ~\u1d64 a", "start": [194, 1], "end": [197, 37], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.induction_on_prime", "code": "@[elab_as_elim]\ntheorem induction_on_prime {P : \u03b1 \u2192 Prop} (a : \u03b1) (h\u2081 : P 0) (h\u2082 : \u2200 x : \u03b1, IsUnit x \u2192 P x)\n    (h\u2083 : \u2200 a p : \u03b1, a \u2260 0 \u2192 Prime p \u2192 P a \u2192 P (p * a)) : P a", "start": [200, 1], "end": [204, 56], "kind": "commanddeclaration"}, {"full_name": "prime_factors_unique", "code": "theorem prime_factors_unique [CancelCommMonoidWithZero \u03b1] :\n    \u2200 {f g : Multiset \u03b1},\n      (\u2200 x \u2208 f, Prime x) \u2192 (\u2200 x \u2208 g, Prime x) \u2192 f.prod ~\u1d64 g.prod \u2192 Multiset.Rel Associated f g", "start": [209, 1], "end": [233, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_unique", "code": "theorem factors_unique {f g : Multiset \u03b1} (hf : \u2200 x \u2208 f, Irreducible x)\n    (hg : \u2200 x \u2208 g, Irreducible x) (h : f.prod ~\u1d64 g.prod) : Multiset.Rel Associated f g", "start": [240, 1], "end": [243, 55], "kind": "commanddeclaration"}, {"full_name": "prime_factors_irreducible", "code": "theorem prime_factors_irreducible [CancelCommMonoidWithZero \u03b1] {a : \u03b1} {f : Multiset \u03b1}\n    (ha : Irreducible a) (pfa : (\u2200 b \u2208 f, Prime b) \u2227 f.prod ~\u1d64 a) : \u2203 p, a ~\u1d64 p \u2227 f = {p}", "start": [248, 1], "end": [269, 41], "kind": "commanddeclaration"}, {"full_name": "WfDvdMonoid.of_exists_prime_factors", "code": "theorem WfDvdMonoid.of_exists_prime_factors : WfDvdMonoid \u03b1", "start": [278, 1], "end": [318, 71], "kind": "commanddeclaration"}, {"full_name": "irreducible_iff_prime_of_exists_prime_factors", "code": "theorem irreducible_iff_prime_of_exists_prime_factors {p : \u03b1} : Irreducible p \u2194 Prime p", "start": [321, 1], "end": [328, 47], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.of_exists_prime_factors", "code": "theorem UniqueFactorizationMonoid.of_exists_prime_factors : UniqueFactorizationMonoid \u03b1", "start": [331, 1], "end": [333, 80], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.iff_exists_prime_factors", "code": "theorem UniqueFactorizationMonoid.iff_exists_prime_factors [CancelCommMonoidWithZero \u03b1] :\n    UniqueFactorizationMonoid \u03b1 \u2194\n      \u2200 a : \u03b1, a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Prime b) \u2227 f.prod ~\u1d64 a", "start": [338, 1], "end": [342, 55], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.uniqueFactorizationMonoid", "code": "theorem MulEquiv.uniqueFactorizationMonoid (e : \u03b1 \u2243* \u03b2) (h\u03b1 : UniqueFactorizationMonoid \u03b1) :\n    UniqueFactorizationMonoid \u03b2", "start": [349, 1], "end": [365, 14], "kind": "commanddeclaration"}, {"full_name": "MulEquiv.uniqueFactorizationMonoid_iff", "code": "theorem MulEquiv.uniqueFactorizationMonoid_iff (e : \u03b1 \u2243* \u03b2) :\n    UniqueFactorizationMonoid \u03b1 \u2194 UniqueFactorizationMonoid \u03b2", "start": [368, 1], "end": [370, 66], "kind": "commanddeclaration"}, {"full_name": "irreducible_iff_prime_of_exists_unique_irreducible_factors", "code": "theorem irreducible_iff_prime_of_exists_unique_irreducible_factors [CancelCommMonoidWithZero \u03b1]\n    (eif : \u2200 a : \u03b1, a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Irreducible b) \u2227 f.prod ~\u1d64 a)\n    (uif :\n      \u2200 f g : Multiset \u03b1,\n        (\u2200 x \u2208 f, Irreducible x) \u2192\n          (\u2200 x \u2208 g, Irreducible x) \u2192 f.prod ~\u1d64 g.prod \u2192 Multiset.Rel Associated f g)\n    (p : \u03b1) : Irreducible p \u2194 Prime p", "start": [375, 1], "end": [412, 23], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.of_exists_unique_irreducible_factors", "code": "theorem UniqueFactorizationMonoid.of_exists_unique_irreducible_factors [CancelCommMonoidWithZero \u03b1]\n    (eif : \u2200 a : \u03b1, a \u2260 0 \u2192 \u2203 f : Multiset \u03b1, (\u2200 b \u2208 f, Irreducible b) \u2227 f.prod ~\u1d64 a)\n    (uif :\n      \u2200 f g : Multiset \u03b1,\n        (\u2200 x \u2208 f, Irreducible x) \u2192\n          (\u2200 x \u2208 g, Irreducible x) \u2192 f.prod ~\u1d64 g.prod \u2192 Multiset.Rel Associated f g) :\n    UniqueFactorizationMonoid \u03b1", "start": [415, 1], "end": [425, 84], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors", "code": "noncomputable def factors (a : \u03b1) : Multiset \u03b1 :=\n  if h : a = 0 then 0 else Classical.choose (UniqueFactorizationMonoid.exists_prime_factors a h)", "start": [434, 1], "end": [436, 97], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_prod", "code": "theorem factors_prod {a : \u03b1} (ane0 : a \u2260 0) : Associated (factors a).prod a", "start": [439, 1], "end": [441, 64], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.ne_zero_of_mem_factors", "code": "theorem ne_zero_of_mem_factors {p a : \u03b1} (h : p \u2208 factors a) : a \u2260 0", "start": [444, 1], "end": [447, 34], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvd_of_mem_factors", "code": "theorem dvd_of_mem_factors {p a : \u03b1} (h : p \u2208 factors a) : p \u2223 a", "start": [450, 1], "end": [451, 93], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.prime_of_factor", "code": "theorem prime_of_factor {a : \u03b1} (x : \u03b1) (hx : x \u2208 factors a) : Prime x", "start": [454, 1], "end": [457, 95], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.irreducible_of_factor", "code": "theorem irreducible_of_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 factors a \u2192 Irreducible x", "start": [460, 1], "end": [461, 36], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_zero", "code": "@[simp]\ntheorem factors_zero : factors (0 : \u03b1) = 0", "start": [464, 1], "end": [465, 64], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_one", "code": "@[simp]\ntheorem factors_one : factors (1 : \u03b1) = 0", "start": [468, 1], "end": [474, 33], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_mem_factors_of_dvd", "code": "theorem exists_mem_factors_of_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) :\n    p \u2223 a \u2192 \u2203 q \u2208 factors a, p ~\u1d64 q", "start": [477, 1], "end": [491, 51], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_mem_factors", "code": "theorem exists_mem_factors {x : \u03b1} (hx : x \u2260 0) (h : \u00acIsUnit x) : \u2203 p, p \u2208 factors x", "start": [494, 1], "end": [497, 16], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_mul", "code": "theorem factors_mul {x y : \u03b1} (hx : x \u2260 0) (hy : y \u2260 0) :\n    Multiset.Rel Associated (factors (x * y)) (factors x + factors y)", "start": [500, 1], "end": [508, 70], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_pow", "code": "theorem factors_pow {x : \u03b1} (n : \u2115) :\n    Multiset.Rel Associated (factors (x ^ n)) (n \u2022 factors x)", "start": [511, 1], "end": [521, 72], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_pos", "code": "@[simp]\ntheorem factors_pos (x : \u03b1) (hx : x \u2260 0) : 0 < factors x \u2194 \u00acIsUnit x", "start": [524, 1], "end": [534, 89], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors", "code": "noncomputable def normalizedFactors (a : \u03b1) : Multiset \u03b1 :=\n  Multiset.map normalize <| factors a", "start": [545, 1], "end": [547, 38], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.factors_eq_normalizedFactors", "code": "@[simp]\ntheorem factors_eq_normalizedFactors {M : Type*} [CancelCommMonoidWithZero M] [DecidableEq M]\n    [UniqueFactorizationMonoid M] [Unique M\u02e3] (x : M) : factors x = normalizedFactors x", "start": [550, 1], "end": [558, 23], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod", "code": "theorem normalizedFactors_prod {a : \u03b1} (ane0 : a \u2260 0) :\n    Associated (normalizedFactors a).prod a", "start": [561, 1], "end": [569, 52], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.prime_of_normalized_factor", "code": "theorem prime_of_normalized_factor {a : \u03b1} : \u2200 x : \u03b1, x \u2208 normalizedFactors a \u2192 Prime x", "start": [572, 1], "end": [577, 95], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.irreducible_of_normalized_factor", "code": "theorem irreducible_of_normalized_factor {a : \u03b1} :\n    \u2200 x : \u03b1, x \u2208 normalizedFactors a \u2192 Irreducible x", "start": [580, 1], "end": [582, 47], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalize_normalized_factor", "code": "theorem normalize_normalized_factor {a : \u03b1} :\n    \u2200 x : \u03b1, x \u2208 normalizedFactors a \u2192 normalize x = x", "start": [585, 1], "end": [591, 23], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_irreducible", "code": "theorem normalizedFactors_irreducible {a : \u03b1} (ha : Irreducible a) :\n    normalizedFactors a = {normalize a}", "start": [594, 1], "end": [602, 98], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_eq_of_dvd", "code": "theorem normalizedFactors_eq_of_dvd (a : \u03b1) :\n    \u2200 (p) (_ : p \u2208 normalizedFactors a) (q) (_ : q \u2208 normalizedFactors a), p \u2223 q \u2192 p = q", "start": [605, 1], "end": [611, 51], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_mem_normalizedFactors_of_dvd", "code": "theorem exists_mem_normalizedFactors_of_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) :\n    p \u2223 a \u2192 \u2203 q \u2208 normalizedFactors a, p ~\u1d64 q", "start": [614, 1], "end": [630, 51], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_mem_normalizedFactors", "code": "theorem exists_mem_normalizedFactors {x : \u03b1} (hx : x \u2260 0) (h : \u00acIsUnit x) :\n    \u2203 p, p \u2208 normalizedFactors x", "start": [633, 1], "end": [637, 16], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_zero", "code": "@[simp]\ntheorem normalizedFactors_zero : normalizedFactors (0 : \u03b1) = 0", "start": [640, 1], "end": [642, 36], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_one", "code": "@[simp]\ntheorem normalizedFactors_one : normalizedFactors (1 : \u03b1) = 0", "start": [645, 1], "end": [655, 47], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_mul", "code": "@[simp]\ntheorem normalizedFactors_mul {x y : \u03b1} (hx : x \u2260 0) (hy : y \u2260 0) :\n    normalizedFactors (x * y) = normalizedFactors x + normalizedFactors y", "start": [658, 1], "end": [678, 58], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_pow", "code": "@[simp]\ntheorem normalizedFactors_pow {x : \u03b1} (n : \u2115) :\n    normalizedFactors (x ^ n) = n \u2022 normalizedFactors x", "start": [681, 1], "end": [688, 77], "kind": "commanddeclaration"}, {"full_name": "Irreducible.normalizedFactors_pow", "code": "theorem _root_.Irreducible.normalizedFactors_pow {p : \u03b1} (hp : Irreducible p) (k : \u2115) :\n    normalizedFactors (p ^ k) = Multiset.replicate k (normalize p)", "start": [691, 1], "end": [694, 30], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod_eq", "code": "theorem normalizedFactors_prod_eq (s : Multiset \u03b1) (hs : \u2200 a \u2208 s, Irreducible a) :\n    normalizedFactors s.prod = s.map normalize", "start": [697, 1], "end": [709, 71], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvd_iff_normalizedFactors_le_normalizedFactors", "code": "theorem dvd_iff_normalizedFactors_le_normalizedFactors {x y : \u03b1} (hx : x \u2260 0) (hy : y \u2260 0) :\n    x \u2223 y \u2194 normalizedFactors x \u2264 normalizedFactors y", "start": [712, 1], "end": [719, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.associated_iff_normalizedFactors_eq_normalizedFactors", "code": "theorem associated_iff_normalizedFactors_eq_normalizedFactors {x y : \u03b1} (hx : x \u2260 0) (hy : y \u2260 0) :\n    x ~\u1d64 y \u2194 normalizedFactors x = normalizedFactors y", "start": [722, 1], "end": [728, 40], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_of_irreducible_pow", "code": "theorem normalizedFactors_of_irreducible_pow {p : \u03b1} (hp : Irreducible p) (k : \u2115) :\n    normalizedFactors (p ^ k) = Multiset.replicate k (normalize p)", "start": [731, 1], "end": [733, 89], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.zero_not_mem_normalizedFactors", "code": "theorem zero_not_mem_normalizedFactors (x : \u03b1) : (0 : \u03b1) \u2209 normalizedFactors x", "start": [736, 1], "end": [737, 53], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvd_of_mem_normalizedFactors", "code": "theorem dvd_of_mem_normalizedFactors {a p : \u03b1} (H : p \u2208 normalizedFactors a) : p \u2223 a", "start": [740, 1], "end": [744, 91], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_associated_prime_pow_of_unique_normalized_factor", "code": "theorem exists_associated_prime_pow_of_unique_normalized_factor {p r : \u03b1}\n    (h : \u2200 {m}, m \u2208 normalizedFactors r \u2192 m = p) (hr : r \u2260 0) : \u2203 i : \u2115, Associated (p ^ i) r", "start": [747, 1], "end": [751, 81], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_prod_of_prime", "code": "theorem normalizedFactors_prod_of_prime [Nontrivial \u03b1] [Unique \u03b1\u02e3] {m : Multiset \u03b1}\n    (h : \u2200 p \u2208 m, Prime p) : normalizedFactors m.prod = m", "start": [754, 1], "end": [758, 59], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.mem_normalizedFactors_eq_of_associated", "code": "theorem mem_normalizedFactors_eq_of_associated {a b c : \u03b1} (ha : a \u2208 normalizedFactors c)\n    (hb : b \u2208 normalizedFactors c) (h : Associated a b) : a = b", "start": [761, 1], "end": [765, 29], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizedFactors_pos", "code": "@[simp]\ntheorem normalizedFactors_pos (x : \u03b1) (hx : x \u2260 0) : 0 < normalizedFactors x \u2194 \u00acIsUnit x", "start": [768, 1], "end": [780, 89], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvdNotUnit_iff_normalizedFactors_lt_normalizedFactors", "code": "theorem dvdNotUnit_iff_normalizedFactors_lt_normalizedFactors {x y : \u03b1} (hx : x \u2260 0) (hy : y \u2260 0) :\n    DvdNotUnit x y \u2194 normalizedFactors x < normalizedFactors y", "start": [783, 1], "end": [793, 80], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.normalizationMonoid", "code": "protected noncomputable def normalizationMonoid : NormalizationMonoid \u03b1 :=\n  normalizationMonoidOfMonoidHomRightInverse\n    { toFun := fun a : Associates \u03b1 =>\n        if a = 0 then 0\n        else\n          ((normalizedFactors a).map\n              (Classical.choose mk_surjective.hasRightInverse : Associates \u03b1 \u2192 \u03b1)).prod\n      map_one' := by simp\n      map_mul' := fun x y => by\n        by_cases hx : x = 0\n        \u00b7 simp [hx]\n        by_cases hy : y = 0\n        \u00b7 simp [hy]\n        simp [hx, hy] }\n    (by\n      intro x\n      dsimp\n      by_cases hx : x = 0\n      \u00b7 simp [hx]\n      have h : Associates.mkMonoidHom \u2218 Classical.choose mk_surjective.hasRightInverse =\n          (id : Associates \u03b1 \u2192 Associates \u03b1) := by\n        ext x\n        rw [Function.comp_apply, mkMonoidHom_apply,\n          Classical.choose_spec mk_surjective.hasRightInverse x]\n        rfl\n      rw [if_neg hx, \u2190 mkMonoidHom_apply, MonoidHom.map_multiset_prod, map_map, h, map_id, \u2190\n        associated_iff_eq]\n      apply normalizedFactors_prod hx)", "start": [806, 1], "end": [834, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.no_factors_of_no_prime_factors", "code": "theorem no_factors_of_no_prime_factors {a b : R} (ha : a \u2260 0)\n    (h : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 IsUnit d", "start": [846, 1], "end": [854, 76], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvd_of_dvd_mul_left_of_no_prime_factors", "code": "theorem dvd_of_dvd_mul_left_of_no_prime_factors {a b c : R} (ha : a \u2260 0) :\n    (\u2200 {d}, d \u2223 a \u2192 d \u2223 c \u2192 \u00acPrime d) \u2192 a \u2223 b * c \u2192 a \u2223 b", "start": [857, 1], "end": [874, 46], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.dvd_of_dvd_mul_right_of_no_prime_factors", "code": "theorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a \u2260 0)\n    (no_factors : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) : a \u2223 b * c \u2192 a \u2223 c", "start": [877, 1], "end": [881, 84], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_reduced_factors", "code": "theorem exists_reduced_factors :\n    \u2200 (a) (_ : a \u2260 (0 : R)) (b),\n      \u2203 a' b' c', (\u2200 {d}, d \u2223 a' \u2192 d \u2223 b' \u2192 IsUnit d) \u2227 c' * a' = a \u2227 c' * b' = b", "start": [884, 1], "end": [913, 38], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.exists_reduced_factors'", "code": "theorem exists_reduced_factors' (a b : R) (hb : b \u2260 0) :\n    \u2203 a' b' c', (\u2200 {d}, d \u2223 a' \u2192 d \u2223 b' \u2192 IsUnit d) \u2227 c' * a' = a \u2227 c' * b' = b", "start": [916, 1], "end": [919, 57], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.pow_right_injective", "code": "theorem pow_right_injective {a : R} (ha0 : a \u2260 0) (ha1 : \u00acIsUnit a) :\n    Function.Injective ((\u00b7 ^ \u00b7) a : \u2115 \u2192 R)", "start": [922, 1], "end": [932, 64], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.pow_eq_pow_iff", "code": "theorem pow_eq_pow_iff {a : R} (ha0 : a \u2260 0) (ha1 : \u00acIsUnit a) {i j : \u2115} : a ^ i = a ^ j \u2194 i = j", "start": [935, 1], "end": [936, 39], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.le_multiplicity_iff_replicate_le_normalizedFactors", "code": "theorem le_multiplicity_iff_replicate_le_normalizedFactors [DecidableEq R] {a b : R} {n : \u2115}\n    (ha : Irreducible a) (hb : b \u2260 0) :\n    \u2191n \u2264 multiplicity a b \u2194 replicate n (normalize a) \u2264 normalizedFactors b", "start": [947, 1], "end": [963, 90], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.multiplicity_eq_count_normalizedFactors", "code": "theorem multiplicity_eq_count_normalizedFactors [DecidableEq R] {a b : R} (ha : Irreducible a)\n    (hb : b \u2260 0) : multiplicity a b = (normalizedFactors b).count (normalize a)", "start": [966, 1], "end": [979, 93], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.count_normalizedFactors_eq", "code": "theorem count_normalizedFactors_eq [DecidableEq R] {p x : R} (hp : Irreducible p)\n    (hnorm : normalize p = p) {n : \u2115} (hle : p ^ n \u2223 x) (hlt : \u00acp ^ (n + 1) \u2223 x) :\n    (normalizedFactors x).count p = n", "start": [983, 1], "end": [997, 54], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.count_normalizedFactors_eq'", "code": "theorem count_normalizedFactors_eq' [DecidableEq R] {p x : R} (hp : p = 0 \u2228 Irreducible p)\n    (hnorm : normalize p = p) {n : \u2115} (hle : p ^ n \u2223 x) (hlt : \u00acp ^ (n + 1) \u2223 x) :\n    (normalizedFactors x).count p = n", "start": [1000, 1], "end": [1014, 54], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.max_power_factor", "code": "theorem max_power_factor {a\u2080 : R} {x : R} (h : a\u2080 \u2260 0) (hx : Irreducible x) :\n    \u2203 n : \u2115, \u2203 a : R, \u00acx \u2223 a \u2227 a\u2080 = x ^ n * a", "start": [1018, 1], "end": [1027, 23], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.prime_pow_coprime_prod_of_coprime_insert", "code": "theorem prime_pow_coprime_prod_of_coprime_insert [DecidableEq \u03b1] {s : Finset \u03b1} (i : \u03b1 \u2192 \u2115) (p : \u03b1)\n    (hps : p \u2209 s) (is_prime : \u2200 q \u2208 insert p s, Prime q)\n    (is_coprime : \u2200 (q) (_ : q \u2208 insert p s) (q') (_ : q' \u2208 insert p s), q \u2223 q' \u2192 q = q') :\n    \u2200 q : \u03b1, q \u2223 p ^ i p \u2192 (q \u2223 \u220f p' in s, p' ^ i p') \u2192 IsUnit q", "start": [1041, 1], "end": [1056, 87], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.induction_on_prime_power", "code": "theorem induction_on_prime_power {P : \u03b1 \u2192 Prop} (s : Finset \u03b1) (i : \u03b1 \u2192 \u2115)\n    (is_prime : \u2200 p \u2208 s, Prime p) (is_coprime : \u2200 (p) (_ : p \u2208 s) (q) (_ : q \u2208 s), p \u2223 q \u2192 p = q)\n    (h1 : \u2200 {x}, IsUnit x \u2192 P x) (hpr : \u2200 {p} (i : \u2115), Prime p \u2192 P (p ^ i))\n    (hcp : \u2200 {x y}, (\u2200 p, p \u2223 x \u2192 p \u2223 y \u2192 IsUnit p) \u2192 P x \u2192 P y \u2192 P (x * y)) :\n    P (\u220f p in s, p ^ i p)", "start": [1059, 1], "end": [1076, 85], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.induction_on_coprime", "code": "@[elab_as_elim]\ntheorem induction_on_coprime {P : \u03b1 \u2192 Prop} (a : \u03b1) (h0 : P 0) (h1 : \u2200 {x}, IsUnit x \u2192 P x)\n    (hpr : \u2200 {p} (i : \u2115), Prime p \u2192 P (p ^ i))\n    (hcp : \u2200 {x y}, (\u2200 p, p \u2223 x \u2192 p \u2223 y \u2192 IsUnit p) \u2192 P x \u2192 P y \u2192 P (x * y)) : P a", "start": [1079, 1], "end": [1098, 38], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.multiplicative_prime_power", "code": "theorem multiplicative_prime_power {f : \u03b1 \u2192 \u03b2} (s : Finset \u03b1) (i j : \u03b1 \u2192 \u2115)\n    (is_prime : \u2200 p \u2208 s, Prime p) (is_coprime : \u2200 (p) (_ : p \u2208 s) (q) (_ : q \u2208 s), p \u2223 q \u2192 p = q)\n    (h1 : \u2200 {x y}, IsUnit y \u2192 f (x * y) = f x * f y)\n    (hpr : \u2200 {p} (i : \u2115), Prime p \u2192 f (p ^ i) = f p ^ i)\n    (hcp : \u2200 {x y}, (\u2200 p, p \u2223 x \u2192 p \u2223 y \u2192 IsUnit p) \u2192 f (x * y) = f x * f y) :\n    f (\u220f p in s, p ^ (i p + j p)) = f (\u220f p in s, p ^ i p) * f (\u220f p in s, p ^ j p)", "start": [1101, 1], "end": [1120, 78], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.multiplicative_of_coprime", "code": "theorem multiplicative_of_coprime (f : \u03b1 \u2192 \u03b2) (a b : \u03b1) (h0 : f 0 = 0)\n    (h1 : \u2200 {x y}, IsUnit y \u2192 f (x * y) = f x * f y)\n    (hpr : \u2200 {p} (i : \u2115), Prime p \u2192 f (p ^ i) = f p ^ i)\n    (hcp : \u2200 {x y}, (\u2200 p, p \u2223 x \u2192 p \u2223 y \u2192 IsUnit p) \u2192 f (x * y) = f x * f y) :\n    f (a * b) = f a * f b", "start": [1123, 1], "end": [1175, 64], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet", "code": "@[reducible]\ndef FactorSet.{u} (\u03b1 : Type u) [CancelCommMonoidWithZero \u03b1] : Type u :=\n  WithTop (Multiset { a : Associates \u03b1 // Irreducible a })", "start": [1188, 1], "end": [1197, 59], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet.coe_add", "code": "theorem FactorSet.coe_add {a b : Multiset { a : Associates \u03b1 // Irreducible a }} :\n    (\u2191(a + b) : FactorSet \u03b1) = a + b", "start": [1202, 1], "end": [1203, 53], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet.sup_add_inf_eq_add", "code": "theorem FactorSet.sup_add_inf_eq_add [DecidableEq (Associates \u03b1)] :\n    \u2200 a b : FactorSet \u03b1, a \u2294 b + a \u2293 b = a + b", "start": [1206, 1], "end": [1214, 41], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet.prod", "code": "def FactorSet.prod : FactorSet \u03b1 \u2192 Associates \u03b1\n  | none => 0\n  | some s => (s.map (\u2191)).prod", "start": [1217, 1], "end": [1221, 31], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_top", "code": "@[simp]\ntheorem prod_top : (\u22a4 : FactorSet \u03b1).prod = 0", "start": [1224, 1], "end": [1226, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_coe", "code": "@[simp]\ntheorem prod_coe {s : Multiset { a : Associates \u03b1 // Irreducible a }} :\n    FactorSet.prod (s : FactorSet \u03b1) = (s.map (\u2191)).prod", "start": [1229, 1], "end": [1232, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_add", "code": "@[simp]\ntheorem prod_add : \u2200 a b : FactorSet \u03b1, (a + b).prod = a.prod * b.prod", "start": [1235, 1], "end": [1242, 98], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_mono", "code": "theorem prod_mono : \u2200 {a b : FactorSet \u03b1}, a \u2264 b \u2192 a.prod \u2264 b.prod", "start": [1245, 1], "end": [1250, 90], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet.prod_eq_zero_iff", "code": "theorem FactorSet.prod_eq_zero_iff [Nontrivial \u03b1] (p : FactorSet \u03b1) : p.prod = 0 \u2194 p = \u22a4", "start": [1253, 1], "end": [1258, 57], "kind": "commanddeclaration"}, {"full_name": "Associates.bcount", "code": "def bcount [DecidableEq (Associates \u03b1)] (p : { a : Associates \u03b1 // Irreducible a }) :\n    FactorSet \u03b1 \u2192 \u2115\n  | none => 0\n  | some s => s.count p", "start": [1261, 1], "end": [1265, 24], "kind": "commanddeclaration"}, {"full_name": "Associates.count", "code": "def count [DecidableEq (Associates \u03b1)] (p : Associates \u03b1) : FactorSet \u03b1 \u2192 \u2115 :=\n  if hp : Irreducible p then bcount \u27e8p, hp\u27e9 else 0", "start": [1270, 1], "end": [1274, 51], "kind": "commanddeclaration"}, {"full_name": "Associates.count_some", "code": "@[simp]\ntheorem count_some [DecidableEq (Associates \u03b1)] {p : Associates \u03b1} (hp : Irreducible p)\n    (s : Multiset _) : count p (some s) = s.count \u27e8p, hp\u27e9", "start": [1277, 1], "end": [1282, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.count_zero", "code": "@[simp]\ntheorem count_zero [DecidableEq (Associates \u03b1)] {p : Associates \u03b1} (hp : Irreducible p) :\n    count p (0 : FactorSet \u03b1) = 0", "start": [1285, 1], "end": [1290, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.count_reducible", "code": "theorem count_reducible [DecidableEq (Associates \u03b1)] {p : Associates \u03b1} (hp : \u00acIrreducible p) :\n    count p = 0", "start": [1293, 1], "end": [1295, 13], "kind": "commanddeclaration"}, {"full_name": "Associates.BfactorSetMem", "code": "def BfactorSetMem : { a : Associates \u03b1 // Irreducible a } \u2192 FactorSet \u03b1 \u2192 Prop\n  | _, \u22a4 => True\n  | p, some l => p \u2208 l", "start": [1298, 1], "end": [1301, 23], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSetMem", "code": "def FactorSetMem (p : Associates \u03b1) (s : FactorSet \u03b1) : Prop :=\n  if hp : Irreducible p then BfactorSetMem \u27e8p, hp\u27e9 s else False", "start": [1304, 1], "end": [1309, 64], "kind": "commanddeclaration"}, {"full_name": "Associates.factorSetMem_eq_mem", "code": "@[simp]\ntheorem factorSetMem_eq_mem (p : Associates \u03b1) (s : FactorSet \u03b1) : FactorSetMem p s = (p \u2208 s)", "start": [1315, 1], "end": [1317, 6], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factorSet_top", "code": "theorem mem_factorSet_top {p : Associates \u03b1} {hp : Irreducible p} : p \u2208 (\u22a4 : FactorSet \u03b1)", "start": [1320, 1], "end": [1321, 83], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factorSet_some", "code": "theorem mem_factorSet_some {p : Associates \u03b1} {hp : Irreducible p}\n    {l : Multiset { a : Associates \u03b1 // Irreducible a }} :\n    p \u2208 (l : FactorSet \u03b1) \u2194 Subtype.mk p hp \u2208 l", "start": [1324, 1], "end": [1327, 73], "kind": "commanddeclaration"}, {"full_name": "Associates.reducible_not_mem_factorSet", "code": "theorem reducible_not_mem_factorSet {p : Associates \u03b1} (hp : \u00acIrreducible p) (s : FactorSet \u03b1) :\n    \u00acp \u2208 s", "start": [1330, 1], "end": [1332, 24], "kind": "commanddeclaration"}, {"full_name": "Associates.unique'", "code": "theorem unique' {p q : Multiset (Associates \u03b1)} :\n    (\u2200 a \u2208 p, Irreducible a) \u2192 (\u2200 a \u2208 q, Irreducible a) \u2192 p.prod = q.prod \u2192 p = q", "start": [1337, 1], "end": [1346, 61], "kind": "commanddeclaration"}, {"full_name": "Associates.FactorSet.unique", "code": "theorem FactorSet.unique [Nontrivial \u03b1] {p q : FactorSet \u03b1} (h : p.prod = q.prod) : p = q", "start": [1349, 1], "end": [1359, 29], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_le_prod_iff_le", "code": "theorem prod_le_prod_iff_le [Nontrivial \u03b1] {p q : Multiset (Associates \u03b1)}\n    (hp : \u2200 a \u2208 p, Irreducible a) (hq : \u2200 a \u2208 q, Irreducible a) : p.prod \u2264 q.prod \u2194 p \u2264 q", "start": [1362, 1], "end": [1377, 17], "kind": "commanddeclaration"}, {"full_name": "Associates.factors'", "code": "noncomputable def factors' (a : \u03b1) : Multiset { a : Associates \u03b1 // Irreducible a } :=\n  (factors a).pmap (fun a ha => \u27e8Associates.mk a, (irreducible_mk _).2 ha\u27e9) irreducible_of_factor", "start": [1382, 1], "end": [1385, 98], "kind": "commanddeclaration"}, {"full_name": "Associates.map_subtype_coe_factors'", "code": "@[simp]\ntheorem map_subtype_coe_factors' {a : \u03b1} :\n    (factors' a).map (\u2191) = (factors a).map Associates.mk", "start": [1388, 1], "end": [1391, 59], "kind": "commanddeclaration"}, {"full_name": "Associates.factors'_cong", "code": "theorem factors'_cong {a b : \u03b1} (h : a ~\u1d64 b) : factors' a = factors' b", "start": [1394, 1], "end": [1406, 69], "kind": "commanddeclaration"}, {"full_name": "Associates.factors", "code": "noncomputable def factors (a : Associates \u03b1) : FactorSet \u03b1 := by\n  refine' if h : a = 0 then \u22a4 else Quotient.hrecOn a (fun x _ => some <| factors' x) _ h\n  intro a b hab\n  apply Function.hfunext\n  \u00b7 have : a ~\u1d64 0 \u2194 b ~\u1d64 0 := Iff.intro (fun ha0 => hab.symm.trans ha0) fun hb0 => hab.trans hb0\n    simp only [associated_zero_iff_eq_zero] at this\n    simp only [quotient_mk_eq_mk, this, mk_eq_zero]\n  exact fun ha hb _ => heq_of_eq <| congr_arg some <| factors'_cong hab", "start": [1409, 1], "end": [1418, 72], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_0", "code": "@[simp]\ntheorem factors_0 : (0 : Associates \u03b1).factors = \u22a4", "start": [1421, 1], "end": [1423, 14], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_mk", "code": "@[simp]\ntheorem factors_mk (a : \u03b1) (h : a \u2260 0) : (Associates.mk a).factors = factors' a", "start": [1426, 1], "end": [1430, 28], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_prod", "code": "@[simp]\ntheorem factors_prod (a : Associates \u03b1) : a.factors.prod = a", "start": [1433, 1], "end": [1440, 83], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_factors", "code": "theorem prod_factors [Nontrivial \u03b1] (s : FactorSet \u03b1) : s.prod.factors = s", "start": [1443, 1], "end": [1444, 37], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_subsingleton", "code": "@[nontriviality]\ntheorem factors_subsingleton [Subsingleton \u03b1] {a : Associates \u03b1} : a.factors = Option.none", "start": [1447, 1], "end": [1449, 31], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_eq_none_iff_zero", "code": "theorem factors_eq_none_iff_zero {a : Associates \u03b1} : a.factors = Option.none \u2194 a = 0", "start": [1452, 1], "end": [1455, 98], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_eq_some_iff_ne_zero", "code": "theorem factors_eq_some_iff_ne_zero {a : Associates \u03b1} :\n    (\u2203 s : Multiset { p : Associates \u03b1 // Irreducible p }, a.factors = some s) \u2194 a \u2260 0", "start": [1458, 1], "end": [1461, 30], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_of_factors_eq_factors", "code": "theorem eq_of_factors_eq_factors {a b : Associates \u03b1} (h : a.factors = b.factors) : a = b", "start": [1464, 1], "end": [1466, 43], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_of_prod_eq_prod", "code": "theorem eq_of_prod_eq_prod [Nontrivial \u03b1] {a b : FactorSet \u03b1} (h : a.prod = b.prod) : a = b", "start": [1469, 1], "end": [1472, 45], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_factors_of_eq_counts", "code": "theorem eq_factors_of_eq_counts {a b : Associates \u03b1} (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : \u2200 (p : Associates \u03b1) (_ : Irreducible p), p.count a.factors = p.count b.factors) :\n    a.factors = b.factors", "start": [1475, 1], "end": [1488, 72], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_of_eq_counts", "code": "theorem eq_of_eq_counts {a b : Associates \u03b1} (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : \u2200 p : Associates \u03b1, Irreducible p \u2192 p.count a.factors = p.count b.factors) : a = b", "start": [1491, 1], "end": [1493, 61], "kind": "commanddeclaration"}, {"full_name": "Associates.count_le_count_of_factors_le", "code": "theorem count_le_count_of_factors_le {a b p : Associates \u03b1} (hb : b \u2260 0) (hp : Irreducible p)\n    (h : a.factors \u2264 b.factors) : p.count a.factors \u2264 p.count b.factors", "start": [1496, 1], "end": [1504, 36], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_mul", "code": "@[simp]\ntheorem factors_mul (a b : Associates \u03b1) : (a * b).factors = a.factors + b.factors", "start": [1507, 1], "end": [1512, 58], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_mono", "code": "theorem factors_mono : \u2200 {a b : Associates \u03b1}, a \u2264 b \u2192 a.factors \u2264 b.factors", "start": [1515, 1], "end": [1516, 82], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_le", "code": "theorem factors_le {a b : Associates \u03b1} : a.factors \u2264 b.factors \u2194 a \u2264 b", "start": [1519, 1], "end": [1524, 17], "kind": "commanddeclaration"}, {"full_name": "Associates.count_le_count_of_le", "code": "theorem count_le_count_of_le {a b p : Associates \u03b1} (hb : b \u2260 0) (hp : Irreducible p) (h : a \u2264 b) :\n    p.count a.factors \u2264 p.count b.factors", "start": [1527, 1], "end": [1529, 55], "kind": "commanddeclaration"}, {"full_name": "Associates.prod_le", "code": "theorem prod_le [Nontrivial \u03b1] {a b : FactorSet \u03b1} : a.prod \u2264 b.prod \u2194 a \u2264 b", "start": [1532, 1], "end": [1539, 18], "kind": "commanddeclaration"}, {"full_name": "Associates.sup_mul_inf", "code": "theorem sup_mul_inf (a b : Associates \u03b1) : (a \u2294 b) * (a \u2293 b) = a * b", "start": [1562, 1], "end": [1566, 77], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_of_mem_factors", "code": "theorem dvd_of_mem_factors {a p : Associates \u03b1} {hp : Irreducible p} (hm : p \u2208 factors a) :\n    p \u2223 a", "start": [1569, 1], "end": [1579, 49], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_of_mem_factors'", "code": "theorem dvd_of_mem_factors' {a : \u03b1} {p : Associates \u03b1} {hp : Irreducible p} {hz : a \u2260 0}\n    (h_mem : Subtype.mk p hp \u2208 factors' a) : p \u2223 Associates.mk a", "start": [1582, 1], "end": [1587, 35], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factors'_of_dvd", "code": "theorem mem_factors'_of_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) (hd : p \u2223 a) :\n    Subtype.mk (Associates.mk p) ((irreducible_mk _).2 hp) \u2208 factors' a", "start": [1591, 1], "end": [1595, 63], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factors'_iff_dvd", "code": "theorem mem_factors'_iff_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) :\n    Subtype.mk (Associates.mk p) ((irreducible_mk _).2 hp) \u2208 factors' a \u2194 p \u2223 a", "start": [1598, 1], "end": [1604, 37], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factors_of_dvd", "code": "theorem mem_factors_of_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) (hd : p \u2223 a) :\n    Associates.mk p \u2208 factors (Associates.mk a)", "start": [1607, 1], "end": [1610, 63], "kind": "commanddeclaration"}, {"full_name": "Associates.mem_factors_iff_dvd", "code": "theorem mem_factors_iff_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) :\n    Associates.mk p \u2208 factors (Associates.mk a) \u2194 p \u2223 a", "start": [1613, 1], "end": [1619, 36], "kind": "commanddeclaration"}, {"full_name": "Associates.exists_prime_dvd_of_not_inf_one", "code": "theorem exists_prime_dvd_of_not_inf_one {a b : \u03b1} (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : Associates.mk a \u2293 Associates.mk b \u2260 1) : \u2203 p : \u03b1, Prime p \u2227 p \u2223 a \u2227 p \u2223 b", "start": [1622, 1], "end": [1641, 13], "kind": "commanddeclaration"}, {"full_name": "Associates.coprime_iff_inf_one", "code": "theorem coprime_iff_inf_one {a b : \u03b1} (ha0 : a \u2260 0) (hb0 : b \u2260 0) :\n    Associates.mk a \u2293 Associates.mk b = 1 \u2194 \u2200 {d : \u03b1}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d", "start": [1644, 1], "end": [1654, 24], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_self", "code": "theorem factors_self [Nontrivial \u03b1] {p : Associates \u03b1} (hp : Irreducible p) :\n    p.factors = some {\u27e8p, hp\u27e9}", "start": [1657, 1], "end": [1660, 71], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_prime_pow", "code": "theorem factors_prime_pow [Nontrivial \u03b1] {p : Associates \u03b1} (hp : Irreducible p) (k : \u2115) :\n    factors (p ^ k) = some (Multiset.replicate k \u27e8p, hp\u27e9)", "start": [1663, 1], "end": [1668, 83], "kind": "commanddeclaration"}, {"full_name": "Associates.prime_pow_dvd_iff_le", "code": "theorem prime_pow_dvd_iff_le [Nontrivial \u03b1] {m p : Associates \u03b1} (h\u2081 : m \u2260 0) (h\u2082 : Irreducible p)\n    {k : \u2115} : p ^ k \u2264 m \u2194 k \u2264 count p m.factors", "start": [1671, 1], "end": [1676, 27], "kind": "commanddeclaration"}, {"full_name": "Associates.le_of_count_ne_zero", "code": "theorem le_of_count_ne_zero {m p : Associates \u03b1} (h0 : m \u2260 0) (hp : Irreducible p) :\n    count p m.factors \u2260 0 \u2192 p \u2264 m", "start": [1679, 1], "end": [1686, 13], "kind": "commanddeclaration"}, {"full_name": "Associates.count_ne_zero_iff_dvd", "code": "theorem count_ne_zero_iff_dvd {a p : \u03b1} (ha0 : a \u2260 0) (hp : Irreducible p) :\n    (Associates.mk p).count (Associates.mk a).factors \u2260 0 \u2194 p \u2223 a", "start": [1689, 1], "end": [1701, 37], "kind": "commanddeclaration"}, {"full_name": "Associates.count_self", "code": "theorem count_self [Nontrivial \u03b1] {p : Associates \u03b1} (hp : Irreducible p) : p.count p.factors = 1", "start": [1704, 1], "end": [1705, 54], "kind": "commanddeclaration"}, {"full_name": "Associates.count_eq_zero_of_ne", "code": "theorem count_eq_zero_of_ne {p q : Associates \u03b1} (hp : Irreducible p) (hq : Irreducible q)\n    (h : p \u2260 q) : p.count q.factors = 0", "start": [1708, 1], "end": [1715, 53], "kind": "commanddeclaration"}, {"full_name": "Associates.count_mul", "code": "theorem count_mul {a : Associates \u03b1} (ha : a \u2260 0) {b : Associates \u03b1} (hb : b \u2260 0) {p : Associates \u03b1}\n    (hp : Irreducible p) : count p (factors (a * b)) = count p a.factors + count p b.factors", "start": [1718, 1], "end": [1724, 54], "kind": "commanddeclaration"}, {"full_name": "Associates.count_of_coprime", "code": "theorem count_of_coprime {a : Associates \u03b1} (ha : a \u2260 0) {b : Associates \u03b1} (hb : b \u2260 0)\n    (hab : \u2200 d, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) {p : Associates \u03b1} (hp : Irreducible p) :\n    count p a.factors = 0 \u2228 count p b.factors = 0", "start": [1727, 1], "end": [1734, 99], "kind": "commanddeclaration"}, {"full_name": "Associates.count_mul_of_coprime", "code": "theorem count_mul_of_coprime {a : Associates \u03b1} {b : Associates \u03b1} (hb : b \u2260 0) {p : Associates \u03b1}\n    (hp : Irreducible p) (hab : \u2200 d, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) :\n    count p a.factors = 0 \u2228 count p a.factors = count p (a * b).factors", "start": [1737, 1], "end": [1744, 41], "kind": "commanddeclaration"}, {"full_name": "Associates.count_mul_of_coprime'", "code": "theorem count_mul_of_coprime' {a b : Associates \u03b1} {p : Associates \u03b1} (hp : Irreducible p)\n    (hab : \u2200 d, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) :\n    count p (a * b).factors = count p a.factors \u2228 count p (a * b).factors = count p b.factors", "start": [1747, 1], "end": [1759, 23], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_count_of_dvd_count_mul", "code": "theorem dvd_count_of_dvd_count_mul {a b : Associates \u03b1} (hb : b \u2260 0) {p : Associates \u03b1}\n    (hp : Irreducible p) (hab : \u2200 d, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) {k : \u2115}\n    (habk : k \u2223 count p (a * b).factors) : k \u2223 count p a.factors", "start": [1762, 1], "end": [1771, 15], "kind": "commanddeclaration"}, {"full_name": "Associates.factors_one", "code": "@[simp]\ntheorem factors_one [Nontrivial \u03b1] : factors (1 : Associates \u03b1) = 0", "start": [1774, 1], "end": [1778, 27], "kind": "commanddeclaration"}, {"full_name": "Associates.pow_factors", "code": "@[simp]\ntheorem pow_factors [Nontrivial \u03b1] {a : Associates \u03b1} {k : \u2115} :\n    (a ^ k).factors = k \u2022 a.factors", "start": [1781, 1], "end": [1787, 46], "kind": "commanddeclaration"}, {"full_name": "Associates.count_pow", "code": "theorem count_pow [Nontrivial \u03b1] {a : Associates \u03b1} (ha : a \u2260 0) {p : Associates \u03b1}\n    (hp : Irreducible p) (k : \u2115) : count p (a ^ k).factors = k * count p a.factors", "start": [1790, 1], "end": [1795, 9], "kind": "commanddeclaration"}, {"full_name": "Associates.dvd_count_pow", "code": "theorem dvd_count_pow [Nontrivial \u03b1] {a : Associates \u03b1} (ha : a \u2260 0) {p : Associates \u03b1}\n    (hp : Irreducible p) (k : \u2115) : k \u2223 count p (a ^ k).factors", "start": [1798, 1], "end": [1801, 22], "kind": "commanddeclaration"}, {"full_name": "Associates.is_pow_of_dvd_count", "code": "theorem is_pow_of_dvd_count [Nontrivial \u03b1] {a : Associates \u03b1} (ha : a \u2260 0) {k : \u2115}\n    (hk : \u2200 (p : Associates \u03b1) (_ : Irreducible p), k \u2223 count p a.factors) :\n    \u2203 b : Associates \u03b1, a = b ^ k", "start": [1804, 1], "end": [1818, 30], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_pow_count_factors_of_dvd_pow", "code": "theorem eq_pow_count_factors_of_dvd_pow {p a : Associates \u03b1} (hp : Irreducible p) {n : \u2115}\n    (h : a \u2223 p ^ n) : a = p ^ p.count a.factors", "start": [1821, 1], "end": [1838, 69], "kind": "commanddeclaration"}, {"full_name": "Associates.count_factors_eq_find_of_dvd_pow", "code": "theorem count_factors_eq_find_of_dvd_pow {a p : Associates \u03b1} (hp : Irreducible p)\n    [\u2200 n : \u2115, Decidable (a \u2223 p ^ n)] {n : \u2115} (h : a \u2223 p ^ n) :\n    @Nat.find (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9 = p.count a.factors", "start": [1841, 1], "end": [1853, 57], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_pow_of_mul_eq_pow", "code": "theorem eq_pow_of_mul_eq_pow [Nontrivial \u03b1] {a b c : Associates \u03b1} (ha : a \u2260 0) (hb : b \u2260 0)\n    (hab : \u2200 d, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) {k : \u2115} (h : a * b = c ^ k) :\n    \u2203 d : Associates \u03b1, a = d ^ k", "start": [1856, 1], "end": [1871, 47], "kind": "commanddeclaration"}, {"full_name": "Associates.eq_pow_find_of_dvd_irreducible_pow", "code": "theorem eq_pow_find_of_dvd_irreducible_pow {a p : Associates \u03b1} (hp : Irreducible p)\n    [\u2200 n : \u2115, Decidable (a \u2223 p ^ n)] {n : \u2115} (h : a \u2223 p ^ n) :\n    a = p ^ @Nat.find (fun n => a \u2223 p ^ n) _ \u27e8n, h\u27e9", "start": [1874, 1], "end": [1879, 10], "kind": "commanddeclaration"}, {"full_name": "Associates.quot_out", "code": "theorem Associates.quot_out {\u03b1 : Type*} [CommMonoid \u03b1] (a : Associates \u03b1) :\n    Associates.mk (Quot.out a) = a", "start": [1888, 1], "end": [1889, 75], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.toGCDMonoid", "code": "noncomputable def UniqueFactorizationMonoid.toGCDMonoid (\u03b1 : Type*) [CancelCommMonoidWithZero \u03b1]\n    [UniqueFactorizationMonoid \u03b1] [DecidableEq (Associates \u03b1)] [DecidableEq \u03b1] : GCDMonoid \u03b1 where\n  gcd a b := Quot.out (Associates.mk a \u2293 Associates.mk b : Associates \u03b1)\n  lcm a b := Quot.out (Associates.mk a \u2294 Associates.mk b : Associates \u03b1)\n  gcd_dvd_left a b := by\n    rw [\u2190 mk_dvd_mk, (Associates.mk a \u2293 Associates.mk b).quot_out, congr_fun\u2082 dvd_eq_le]\n    exact inf_le_left\n  gcd_dvd_right a b := by\n    rw [\u2190 mk_dvd_mk, (Associates.mk a \u2293 Associates.mk b).quot_out, congr_fun\u2082 dvd_eq_le]\n    exact inf_le_right\n  dvd_gcd {a b c} hac hab := by\n    rw [\u2190 mk_dvd_mk, (Associates.mk c \u2293 Associates.mk b).quot_out, congr_fun\u2082 dvd_eq_le, le_inf_iff,\n      mk_le_mk_iff_dvd_iff, mk_le_mk_iff_dvd_iff]\n    exact \u27e8hac, hab\u27e9\n  lcm_zero_left a := by\n    have : Associates.mk (0 : \u03b1) = \u22a4 := rfl\n    dsimp\n    rw [this, top_sup_eq, \u2190 this, \u2190 associated_zero_iff_eq_zero, \u2190 mk_eq_mk_iff_associated, \u2190\n      associated_iff_eq, Associates.quot_out]\n  lcm_zero_right a := by\n    have : Associates.mk (0 : \u03b1) = \u22a4 := rfl\n    dsimp\n    rw [this, sup_top_eq, \u2190 this, \u2190 associated_zero_iff_eq_zero, \u2190 mk_eq_mk_iff_associated, \u2190\n      associated_iff_eq, Associates.quot_out]\n  gcd_mul_lcm a b := by\n    rw [\u2190 mk_eq_mk_iff_associated, \u2190 Associates.mk_mul_mk, \u2190 associated_iff_eq, Associates.quot_out,\n      Associates.quot_out, mul_comm, sup_mul_inf, Associates.mk_mul_mk]", "start": [1892, 1], "end": [1919, 72], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.toNormalizedGCDMonoid", "code": "noncomputable def UniqueFactorizationMonoid.toNormalizedGCDMonoid (\u03b1 : Type*)\n    [CancelCommMonoidWithZero \u03b1] [UniqueFactorizationMonoid \u03b1] [NormalizationMonoid \u03b1]\n    [DecidableEq (Associates \u03b1)] [DecidableEq \u03b1] : NormalizedGCDMonoid \u03b1 :=\n  { \u2039NormalizationMonoid \u03b1\u203a with\n    gcd := fun a b => (Associates.mk a \u2293 Associates.mk b).out\n    lcm := fun a b => (Associates.mk a \u2294 Associates.mk b).out\n    gcd_dvd_left := fun a b => (out_dvd_iff a (Associates.mk a \u2293 Associates.mk b)).2 <| inf_le_left\n    gcd_dvd_right := fun a b =>\n      (out_dvd_iff b (Associates.mk a \u2293 Associates.mk b)).2 <| inf_le_right\n    dvd_gcd := fun {a} {b} {c} hac hab =>\n      show a \u2223 (Associates.mk c \u2293 Associates.mk b).out by\n        rw [dvd_out_iff, le_inf_iff, mk_le_mk_iff_dvd_iff, mk_le_mk_iff_dvd_iff];\n          exact \u27e8hac, hab\u27e9\n    lcm_zero_left := fun a => show (\u22a4 \u2294 Associates.mk a).out = 0 by simp\n    lcm_zero_right := fun a => show (Associates.mk a \u2294 \u22a4).out = 0 by simp\n    gcd_mul_lcm := fun a b => by\n      rw [\u2190 out_mul, mul_comm, sup_mul_inf, mk_mul_mk, out_mk]\n      exact normalize_associated (a * b)\n    normalize_gcd := fun a b => by congr; apply normalize_out _\n    normalize_lcm := fun a b => by congr; apply normalize_out _ }", "start": [1922, 1], "end": [1943, 66], "kind": "commanddeclaration"}, {"full_name": "UniqueFactorizationMonoid.fintypeSubtypeDvd", "code": "noncomputable def fintypeSubtypeDvd {M : Type*} [CancelCommMonoidWithZero M]\n    [UniqueFactorizationMonoid M] [Fintype M\u02e3] (y : M) (hy : y \u2260 0) : Fintype { x // x \u2223 y } := by\n  haveI : Nontrivial M := \u27e8\u27e8y, 0, hy\u27e9\u27e9\n  haveI : NormalizationMonoid M := UniqueFactorizationMonoid.normalizationMonoid\n  haveI := Classical.decEq M\n  haveI := Classical.decEq (Associates M)\n  refine'\n    Fintype.ofFinset\n      (((normalizedFactors y).powerset.toFinset \u00d7\u02e2 (Finset.univ : Finset M\u02e3)).image fun s =>\n        (s.snd : M) * s.fst.prod)\n      fun x => _\n  simp only [exists_prop, Finset.mem_image, Finset.mem_product, Finset.mem_univ, and_true_iff,\n    Multiset.mem_toFinset, Multiset.mem_powerset, exists_eq_right, Multiset.mem_map]\n  constructor\n  \u00b7 rintro \u27e8s, hs, rfl\u27e9\n    show (s.snd : M) * s.fst.prod \u2223 y\n    rw [(unit_associated_one.mul_right s.fst.prod).dvd_iff_dvd_left, one_mul,\n      \u2190 (normalizedFactors_prod hy).dvd_iff_dvd_right]\n    exact Multiset.prod_dvd_prod_of_le hs\n  \u00b7 rintro (h : x \u2223 y)\n    have hx : x \u2260 0 := by\n      refine' mt (fun hx => _) hy\n      rwa [hx, zero_dvd_iff] at h\n    obtain \u27e8u, hu\u27e9 := normalizedFactors_prod hx\n    refine' \u27e8\u27e8normalizedFactors x, u\u27e9, _, (mul_comm _ _).trans hu\u27e9\n    exact (dvd_iff_normalizedFactors_le_normalizedFactors hx hy).mp h", "start": [1950, 1], "end": [1979, 70], "kind": "commanddeclaration"}, {"full_name": "factorization", "code": "noncomputable def factorization (n : \u03b1) : \u03b1 \u2192\u2080 \u2115 :=\n  Multiset.toFinsupp (normalizedFactors n)", "start": [1992, 1], "end": [1994, 43], "kind": "commanddeclaration"}, {"full_name": "factorization_eq_count", "code": "theorem factorization_eq_count {n p : \u03b1} :\n    factorization n p = Multiset.count p (normalizedFactors n)", "start": [1997, 1], "end": [1998, 90], "kind": "commanddeclaration"}, {"full_name": "factorization_zero", "code": "@[simp]\ntheorem factorization_zero : factorization (0 : \u03b1) = 0", "start": [2001, 1], "end": [2002, 82], "kind": "commanddeclaration"}, {"full_name": "factorization_one", "code": "@[simp]\ntheorem factorization_one : factorization (1 : \u03b1) = 0", "start": [2005, 1], "end": [2006, 81], "kind": "commanddeclaration"}, {"full_name": "support_factorization", "code": "@[simp]\ntheorem support_factorization {n : \u03b1} :\n    (factorization n).support = (normalizedFactors n).toFinset", "start": [2009, 1], "end": [2013, 51], "kind": "commanddeclaration"}, {"full_name": "factorization_mul", "code": "@[simp]\ntheorem factorization_mul {a b : \u03b1} (ha : a \u2260 0) (hb : b \u2260 0) :\n    factorization (a * b) = factorization a + factorization b", "start": [2016, 1], "end": [2020, 52], "kind": "commanddeclaration"}, {"full_name": "factorization_pow", "code": "theorem factorization_pow {x : \u03b1} {n : \u2115} : factorization (x ^ n) = n \u2022 factorization x", "start": [2023, 1], "end": [2026, 23], "kind": "commanddeclaration"}, {"full_name": "associated_of_factorization_eq", "code": "theorem associated_of_factorization_eq (a b : \u03b1) (ha : a \u2260 0) (hb : b \u2260 0)\n    (h : factorization a = factorization b) : Associated a b", "start": [2029, 1], "end": [2032, 68], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Bounded.lean", "imports": ["Mathlib/Data/Set/Intervals/Basic.lean", "Mathlib/Order/RelClasses.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Set.Bounded.mono", "code": "theorem Bounded.mono (hst : s \u2286 t) (hs : Bounded r t) : Bounded r s", "start": [26, 1], "end": [27, 40], "kind": "commanddeclaration"}, {"full_name": "Set.Unbounded.mono", "code": "theorem Unbounded.mono (hst : s \u2286 t) (hs : Unbounded r s) : Unbounded r t", "start": [30, 1], "end": [32, 19], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_of_forall_exists_lt", "code": "theorem unbounded_le_of_forall_exists_lt [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, a < b) :\n    Unbounded (\u00b7 \u2264 \u00b7) s", "start": [38, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_iff", "code": "theorem unbounded_le_iff [LinearOrder \u03b1] : Unbounded (\u00b7 \u2264 \u00b7) s \u2194 \u2200 a, \u2203 b \u2208 s, a < b", "start": [44, 1], "end": [45, 32], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_of_forall_exists_le", "code": "theorem unbounded_lt_of_forall_exists_le [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, a \u2264 b) :\n    Unbounded (\u00b7 < \u00b7) s", "start": [48, 1], "end": [51, 37], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_iff", "code": "theorem unbounded_lt_iff [LinearOrder \u03b1] : Unbounded (\u00b7 < \u00b7) s \u2194 \u2200 a, \u2203 b \u2208 s, a \u2264 b", "start": [54, 1], "end": [55, 32], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_of_forall_exists_gt", "code": "theorem unbounded_ge_of_forall_exists_gt [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, b < a) :\n    Unbounded (\u00b7 \u2265 \u00b7) s", "start": [58, 1], "end": [60, 46], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_iff", "code": "theorem unbounded_ge_iff [LinearOrder \u03b1] : Unbounded (\u00b7 \u2265 \u00b7) s \u2194 \u2200 a, \u2203 b \u2208 s, b < a", "start": [63, 1], "end": [67, 38], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_of_forall_exists_ge", "code": "theorem unbounded_gt_of_forall_exists_ge [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, b \u2264 a) :\n    Unbounded (\u00b7 > \u00b7) s", "start": [70, 1], "end": [73, 43], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_iff", "code": "theorem unbounded_gt_iff [LinearOrder \u03b1] : Unbounded (\u00b7 > \u00b7) s \u2194 \u2200 a, \u2203 b \u2208 s, b \u2264 a", "start": [76, 1], "end": [80, 38], "kind": "commanddeclaration"}, {"full_name": "Set.Bounded.rel_mono", "code": "theorem Bounded.rel_mono {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (h : Bounded r s) (hrr' : r \u2264 r') : Bounded r' s", "start": [89, 1], "end": [91, 38], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_of_bounded_lt", "code": "theorem bounded_le_of_bounded_lt [Preorder \u03b1] (h : Bounded (\u00b7 < \u00b7) s) : Bounded (\u00b7 \u2264 \u00b7) s", "start": [94, 1], "end": [95, 33], "kind": "commanddeclaration"}, {"full_name": "Set.Unbounded.rel_mono", "code": "theorem Unbounded.rel_mono {r' : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : r' \u2264 r) (h : Unbounded r s) : Unbounded r' s", "start": [98, 1], "end": [101, 41], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_of_unbounded_le", "code": "theorem unbounded_lt_of_unbounded_le [Preorder \u03b1] (h : Unbounded (\u00b7 \u2264 \u00b7) s) : Unbounded (\u00b7 < \u00b7) s", "start": [104, 1], "end": [105, 33], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_iff_bounded_lt", "code": "theorem bounded_le_iff_bounded_lt [Preorder \u03b1] [NoMaxOrder \u03b1] :\n    Bounded (\u00b7 \u2264 \u00b7) s \u2194 Bounded (\u00b7 < \u00b7) s", "start": [108, 1], "end": [113, 53], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_iff_unbounded_le", "code": "theorem unbounded_lt_iff_unbounded_le [Preorder \u03b1] [NoMaxOrder \u03b1] :\n    Unbounded (\u00b7 < \u00b7) s \u2194 Unbounded (\u00b7 \u2264 \u00b7) s", "start": [116, 1], "end": [118, 57], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_of_bounded_gt", "code": "theorem bounded_ge_of_bounded_gt [Preorder \u03b1] (h : Bounded (\u00b7 > \u00b7) s) : Bounded (\u00b7 \u2265 \u00b7) s", "start": [124, 1], "end": [126, 38], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_of_unbounded_ge", "code": "theorem unbounded_gt_of_unbounded_ge [Preorder \u03b1] (h : Unbounded (\u00b7 \u2265 \u00b7) s) : Unbounded (\u00b7 > \u00b7) s", "start": [129, 1], "end": [132, 43], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_iff_bounded_gt", "code": "theorem bounded_ge_iff_bounded_gt [Preorder \u03b1] [NoMinOrder \u03b1] :\n    Bounded (\u00b7 \u2265 \u00b7) s \u2194 Bounded (\u00b7 > \u00b7) s", "start": [135, 1], "end": [137, 39], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_iff_unbounded_ge", "code": "theorem unbounded_gt_iff_unbounded_ge [Preorder \u03b1] [NoMinOrder \u03b1] :\n    Unbounded (\u00b7 > \u00b7) s \u2194 Unbounded (\u00b7 \u2265 \u00b7) s", "start": [140, 1], "end": [142, 43], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_univ", "code": "theorem unbounded_le_univ [LE \u03b1] [NoTopOrder \u03b1] : Unbounded (\u00b7 \u2264 \u00b7) (@Set.univ \u03b1)", "start": [148, 1], "end": [150, 14], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_univ", "code": "theorem unbounded_lt_univ [Preorder \u03b1] [NoTopOrder \u03b1] : Unbounded (\u00b7 < \u00b7) (@Set.univ \u03b1)", "start": [153, 1], "end": [154, 49], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_univ", "code": "theorem unbounded_ge_univ [LE \u03b1] [NoBotOrder \u03b1] : Unbounded (\u00b7 \u2265 \u00b7) (@Set.univ \u03b1)", "start": [157, 1], "end": [159, 14], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_univ", "code": "theorem unbounded_gt_univ [Preorder \u03b1] [NoBotOrder \u03b1] : Unbounded (\u00b7 > \u00b7) (@Set.univ \u03b1)", "start": [162, 1], "end": [163, 49], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_self", "code": "theorem bounded_self (a : \u03b1) : Bounded r { b | r b a }", "start": [169, 1], "end": [170, 19], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Iio", "code": "theorem bounded_lt_Iio [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 < \u00b7) (Iio a)", "start": [176, 1], "end": [177, 17], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Iio", "code": "theorem bounded_le_Iio [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Iio a)", "start": [180, 1], "end": [181, 46], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Iic", "code": "theorem bounded_le_Iic [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Iic a)", "start": [184, 1], "end": [185, 17], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Iic", "code": "theorem bounded_lt_Iic [Preorder \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) : Bounded (\u00b7 < \u00b7) (Iic a)", "start": [188, 1], "end": [189, 58], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Ioi", "code": "theorem bounded_gt_Ioi [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 > \u00b7) (Ioi a)", "start": [192, 1], "end": [193, 17], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Ioi", "code": "theorem bounded_ge_Ioi [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Ioi a)", "start": [196, 1], "end": [197, 46], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Ici", "code": "theorem bounded_ge_Ici [Preorder \u03b1] (a : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Ici a)", "start": [200, 1], "end": [201, 17], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Ici", "code": "theorem bounded_gt_Ici [Preorder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) : Bounded (\u00b7 > \u00b7) (Ici a)", "start": [204, 1], "end": [205, 58], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Ioo", "code": "theorem bounded_lt_Ioo [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 < \u00b7) (Ioo a b)", "start": [211, 1], "end": [212, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Ico", "code": "theorem bounded_lt_Ico [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 < \u00b7) (Ico a b)", "start": [215, 1], "end": [216, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Ioc", "code": "theorem bounded_lt_Ioc [Preorder \u03b1] [NoMaxOrder \u03b1] (a b : \u03b1) : Bounded (\u00b7 < \u00b7) (Ioc a b)", "start": [219, 1], "end": [220, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_Icc", "code": "theorem bounded_lt_Icc [Preorder \u03b1] [NoMaxOrder \u03b1] (a b : \u03b1) : Bounded (\u00b7 < \u00b7) (Icc a b)", "start": [223, 1], "end": [224, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Ioo", "code": "theorem bounded_le_Ioo [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Ioo a b)", "start": [227, 1], "end": [228, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Ico", "code": "theorem bounded_le_Ico [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Ico a b)", "start": [231, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Ioc", "code": "theorem bounded_le_Ioc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Ioc a b)", "start": [235, 1], "end": [236, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_Icc", "code": "theorem bounded_le_Icc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2264 \u00b7) (Icc a b)", "start": [239, 1], "end": [240, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Ioo", "code": "theorem bounded_gt_Ioo [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Ioo a b)", "start": [243, 1], "end": [244, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Ioc", "code": "theorem bounded_gt_Ioc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Ioc a b)", "start": [247, 1], "end": [248, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Ico", "code": "theorem bounded_gt_Ico [Preorder \u03b1] [NoMinOrder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Ico a b)", "start": [251, 1], "end": [252, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_Icc", "code": "theorem bounded_gt_Icc [Preorder \u03b1] [NoMinOrder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Icc a b)", "start": [255, 1], "end": [256, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Ioo", "code": "theorem bounded_ge_Ioo [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Ioo a b)", "start": [259, 1], "end": [260, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Ioc", "code": "theorem bounded_ge_Ioc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Ioc a b)", "start": [263, 1], "end": [264, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Ico", "code": "theorem bounded_ge_Ico [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Ico a b)", "start": [267, 1], "end": [268, 50], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_Icc", "code": "theorem bounded_ge_Icc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 \u2265 \u00b7) (Icc a b)", "start": [271, 1], "end": [272, 50], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_Ioi", "code": "theorem unbounded_le_Ioi [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2264 \u00b7) (Ioi a)", "start": [278, 1], "end": [281, 66], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_Ici", "code": "theorem unbounded_le_Ici [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2264 \u00b7) (Ici a)", "start": [284, 1], "end": [286, 52], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_Ioi", "code": "theorem unbounded_lt_Ioi [SemilatticeSup \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 < \u00b7) (Ioi a)", "start": [289, 1], "end": [291, 52], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_Ici", "code": "theorem unbounded_lt_Ici [SemilatticeSup \u03b1] (a : \u03b1) : Unbounded (\u00b7 < \u00b7) (Ici a)", "start": [294, 1], "end": [295, 44], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_inter_not", "code": "theorem bounded_inter_not (H : \u2200 a b, \u2203 m, \u2200 c, r c a \u2228 r c b \u2192 r c m) (a : \u03b1) :\n    Bounded r (s \u2229 { b | \u00acr b a }) \u2194 Bounded r s", "start": [301, 1], "end": [306, 80], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_inter_not", "code": "theorem unbounded_inter_not (H : \u2200 a b, \u2203 m, \u2200 c, r c a \u2228 r c b \u2192 r c m) (a : \u03b1) :\n    Unbounded r (s \u2229 { b | \u00acr b a }) \u2194 Unbounded r s", "start": [309, 1], "end": [311, 51], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_inter_not_le", "code": "theorem bounded_le_inter_not_le [SemilatticeSup \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | \u00acb \u2264 a }) \u2194 Bounded (\u00b7 \u2264 \u00b7) s", "start": [317, 1], "end": [319, 99], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_inter_not_le", "code": "theorem unbounded_le_inter_not_le [SemilatticeSup \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | \u00acb \u2264 a }) \u2194 Unbounded (\u00b7 \u2264 \u00b7) s", "start": [322, 1], "end": [325, 34], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_inter_lt", "code": "theorem bounded_le_inter_lt [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | a < b }) \u2194 Bounded (\u00b7 \u2264 \u00b7) s", "start": [328, 1], "end": [330, 46], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_inter_lt", "code": "theorem unbounded_le_inter_lt [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | a < b }) \u2194 Unbounded (\u00b7 \u2264 \u00b7) s", "start": [333, 1], "end": [336, 22], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_le_inter_le", "code": "theorem bounded_le_inter_le [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | a \u2264 b }) \u2194 Bounded (\u00b7 \u2264 \u00b7) s", "start": [339, 1], "end": [343, 59], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_le_inter_le", "code": "theorem unbounded_le_inter_le [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2264 \u00b7) (s \u2229 { b | a \u2264 b }) \u2194 Unbounded (\u00b7 \u2264 \u00b7) s", "start": [346, 1], "end": [349, 30], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_inter_not_lt", "code": "theorem bounded_lt_inter_not_lt [SemilatticeSup \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 < \u00b7) (s \u2229 { b | \u00acb < a }) \u2194 Bounded (\u00b7 < \u00b7) s", "start": [355, 1], "end": [357, 99], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_inter_not_lt", "code": "theorem unbounded_lt_inter_not_lt [SemilatticeSup \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 < \u00b7) (s \u2229 { b | \u00acb < a }) \u2194 Unbounded (\u00b7 < \u00b7) s", "start": [360, 1], "end": [363, 34], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_inter_le", "code": "theorem bounded_lt_inter_le [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 < \u00b7) (s \u2229 { b | a \u2264 b }) \u2194 Bounded (\u00b7 < \u00b7) s", "start": [366, 1], "end": [369, 20], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_inter_le", "code": "theorem unbounded_lt_inter_le [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 < \u00b7) (s \u2229 { b | a \u2264 b }) \u2194 Unbounded (\u00b7 < \u00b7) s", "start": [372, 1], "end": [375, 20], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_lt_inter_lt", "code": "theorem bounded_lt_inter_lt [LinearOrder \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 < \u00b7) (s \u2229 { b | a < b }) \u2194 Bounded (\u00b7 < \u00b7) s", "start": [378, 1], "end": [381, 30], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_lt_inter_lt", "code": "theorem unbounded_lt_inter_lt [LinearOrder \u03b1] [NoMaxOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 < \u00b7) (s \u2229 { b | a < b }) \u2194 Unbounded (\u00b7 < \u00b7) s", "start": [384, 1], "end": [387, 30], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_inter_not_ge", "code": "theorem bounded_ge_inter_not_ge [SemilatticeInf \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | \u00aca \u2264 b }) \u2194 Bounded (\u00b7 \u2265 \u00b7) s", "start": [393, 1], "end": [395, 37], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_inter_not_ge", "code": "theorem unbounded_ge_inter_not_ge [SemilatticeInf \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | \u00aca \u2264 b }) \u2194 Unbounded (\u00b7 \u2265 \u00b7) s", "start": [398, 1], "end": [400, 39], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_inter_gt", "code": "theorem bounded_ge_inter_gt [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | b < a }) \u2194 Bounded (\u00b7 \u2265 \u00b7) s", "start": [403, 1], "end": [405, 33], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_inter_gt", "code": "theorem unbounded_ge_inter_gt [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | b < a }) \u2194 Unbounded (\u00b7 \u2265 \u00b7) s", "start": [408, 1], "end": [410, 35], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_ge_inter_ge", "code": "theorem bounded_ge_inter_ge [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | b \u2264 a }) \u2194 Bounded (\u00b7 \u2265 \u00b7) s", "start": [413, 1], "end": [415, 33], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_ge_iff_unbounded_inter_ge", "code": "theorem unbounded_ge_iff_unbounded_inter_ge [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | b \u2264 a }) \u2194 Unbounded (\u00b7 \u2265 \u00b7) s", "start": [418, 1], "end": [420, 35], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_inter_not_gt", "code": "theorem bounded_gt_inter_not_gt [SemilatticeInf \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 > \u00b7) (s \u2229 { b | \u00aca < b }) \u2194 Bounded (\u00b7 > \u00b7) s", "start": [426, 1], "end": [428, 37], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_inter_not_gt", "code": "theorem unbounded_gt_inter_not_gt [SemilatticeInf \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 > \u00b7) (s \u2229 { b | \u00aca < b }) \u2194 Unbounded (\u00b7 > \u00b7) s", "start": [431, 1], "end": [433, 39], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_inter_ge", "code": "theorem bounded_gt_inter_ge [LinearOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 > \u00b7) (s \u2229 { b | b \u2264 a }) \u2194 Bounded (\u00b7 > \u00b7) s", "start": [436, 1], "end": [438, 33], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_inter_ge", "code": "theorem unbounded_inter_ge [LinearOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 > \u00b7) (s \u2229 { b | b \u2264 a }) \u2194 Unbounded (\u00b7 > \u00b7) s", "start": [441, 1], "end": [443, 35], "kind": "commanddeclaration"}, {"full_name": "Set.bounded_gt_inter_gt", "code": "theorem bounded_gt_inter_gt [LinearOrder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) :\n    Bounded (\u00b7 > \u00b7) (s \u2229 { b | b < a }) \u2194 Bounded (\u00b7 > \u00b7) s", "start": [446, 1], "end": [448, 35], "kind": "commanddeclaration"}, {"full_name": "Set.unbounded_gt_inter_gt", "code": "theorem unbounded_gt_inter_gt [LinearOrder \u03b1] [NoMinOrder \u03b1] (a : \u03b1) :\n    Unbounded (\u00b7 > \u00b7) (s \u2229 { b | b < a }) \u2194 Unbounded (\u00b7 > \u00b7) s", "start": [451, 1], "end": [453, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Ordinal/Principal.lean", "imports": ["Mathlib/SetTheory/Ordinal/FixedPoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Ordinal.Principal", "code": "def Principal (op : Ordinal \u2192 Ordinal \u2192 Ordinal) (o : Ordinal) : Prop :=\n  \u2200 \u2983a b\u2984, a < o \u2192 b < o \u2192 op a b < o", "start": [43, 1], "end": [49, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_iff_principal_swap", "code": "theorem principal_iff_principal_swap {op : Ordinal \u2192 Ordinal \u2192 Ordinal} {o : Ordinal} :\n    Principal op o \u2194 Principal (Function.swap op) o", "start": [52, 1], "end": [54, 51], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_zero", "code": "theorem principal_zero {op : Ordinal \u2192 Ordinal \u2192 Ordinal} : Principal op 0", "start": [57, 1], "end": [58, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_one_iff", "code": "@[simp]\ntheorem principal_one_iff {op : Ordinal \u2192 Ordinal \u2192 Ordinal} : Principal op 1 \u2194 op 0 0 = 0", "start": [61, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.Principal.iterate_lt", "code": "theorem Principal.iterate_lt {op : Ordinal \u2192 Ordinal \u2192 Ordinal} {a o : Ordinal} (hao : a < o)\n    (ho : Principal op o) (n : \u2115) : (op a)^[n] a < o", "start": [69, 1], "end": [74, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.op_eq_self_of_principal", "code": "theorem op_eq_self_of_principal {op : Ordinal \u2192 Ordinal \u2192 Ordinal} {a o : Ordinal.{u}} (hao : a < o)\n    (H : IsNormal (op a)) (ho : Principal op o) (ho' : IsLimit o) : op a o = o", "start": [77, 1], "end": [81, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_le_of_principal", "code": "theorem nfp_le_of_principal {op : Ordinal \u2192 Ordinal \u2192 Ordinal} {a o : Ordinal} (hao : a < o)\n    (ho : Principal op o) : nfp (op a) a \u2264 o", "start": [84, 1], "end": [86, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_nfp_blsub\u2082", "code": "theorem principal_nfp_blsub\u2082 (op : Ordinal \u2192 Ordinal \u2192 Ordinal) (o : Ordinal) :\n    Principal op (nfp (fun o' => blsub\u2082.{u, u, u} o' o' (@fun a _ b _ => op a b)) o)", "start": [91, 1], "end": [105, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.unbounded_principal", "code": "theorem unbounded_principal (op : Ordinal \u2192 Ordinal \u2192 Ordinal) :\n    Set.Unbounded (\u00b7 < \u00b7) { o | Principal op o }", "start": [108, 1], "end": [110, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_one", "code": "theorem principal_add_one : Principal (\u00b7 + \u00b7) 1", "start": [116, 1], "end": [117, 36], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_of_le_one", "code": "theorem principal_add_of_le_one {o : Ordinal} (ho : o \u2264 1) : Principal (\u00b7 + \u00b7) o", "start": [120, 1], "end": [123, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_isLimit", "code": "theorem principal_add_isLimit {o : Ordinal} (ho\u2081 : 1 < o) (ho : Principal (\u00b7 + \u00b7) o) :\n    o.IsLimit", "start": [126, 1], "end": [135, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_iff_add_left_eq_self", "code": "theorem principal_add_iff_add_left_eq_self {o : Ordinal} :\n    Principal (\u00b7 + \u00b7) o \u2194 \u2200 a < o, a + o = o", "start": [138, 1], "end": [148, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_lt_add_of_not_principal_add", "code": "theorem exists_lt_add_of_not_principal_add {a} (ha : \u00acPrincipal (\u00b7 + \u00b7) a) :\n    \u2203 (b c : _) (_ : b < a) (_ : c < a), b + c = a", "start": [151, 1], "end": [159, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_iff_add_lt_ne_self", "code": "theorem principal_add_iff_add_lt_ne_self {a} :\n    Principal (\u00b7 + \u00b7) a \u2194 \u2200 \u2983b c\u2984, b < a \u2192 c < a \u2192 b + c \u2260 a", "start": [162, 1], "end": [167, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_omega", "code": "theorem add_omega {a : Ordinal} (h : a < omega) : a + omega = omega", "start": [170, 1], "end": [174, 68], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_omega", "code": "theorem principal_add_omega : Principal (\u00b7 + \u00b7) omega", "start": [177, 1], "end": [178, 58], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_omega_opow", "code": "theorem add_omega_opow {a b : Ordinal} (h : a < (omega^b)) : a + (omega^b) = (omega^b)", "start": [181, 1], "end": [196, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_omega_opow", "code": "theorem principal_add_omega_opow (o : Ordinal) : Principal (\u00b7 + \u00b7) (omega^o)", "start": [199, 1], "end": [200, 63], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_iff_zero_or_omega_opow", "code": "theorem principal_add_iff_zero_or_omega_opow {o : Ordinal} :\n    Principal (\u00b7 + \u00b7) o \u2194 o = 0 \u2228 \u2203 a, o = (omega^a)", "start": [203, 1], "end": [225, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_principal_add_of_principal_add", "code": "theorem opow_principal_add_of_principal_add {a} (ha : Principal (\u00b7 + \u00b7) a) (b : Ordinal) :\n    Principal (\u00b7 + \u00b7) (a^b)", "start": [228, 1], "end": [236, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.add_absorp", "code": "theorem add_absorp {a b c : Ordinal} (h\u2081 : a < (omega^b)) (h\u2082 : (omega^b) \u2264 c) : a + c = c", "start": [239, 1], "end": [240, 73], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_principal_add_is_principal_add", "code": "theorem mul_principal_add_is_principal_add (a : Ordinal.{u}) {b : Ordinal.{u}} (hb\u2081 : b \u2260 1)\n    (hb : Principal (\u00b7 + \u00b7) b) : Principal (\u00b7 + \u00b7) (a * b)", "start": [243, 1], "end": [258, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_one", "code": "theorem principal_mul_one : Principal (\u00b7 * \u00b7) 1", "start": [264, 1], "end": [266, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_two", "code": "theorem principal_mul_two : Principal (\u00b7 * \u00b7) 2", "start": [269, 1], "end": [274, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_of_le_two", "code": "theorem principal_mul_of_le_two {o : Ordinal} (ho : o \u2264 2) : Principal (\u00b7 * \u00b7) o", "start": [277, 1], "end": [285, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_of_principal_mul", "code": "theorem principal_add_of_principal_mul {o : Ordinal} (ho : Principal (\u00b7 * \u00b7) o) (ho\u2082 : o \u2260 2) :\n    Principal (\u00b7 + \u00b7) o", "start": [288, 1], "end": [297, 58], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_isLimit", "code": "theorem principal_mul_isLimit {o : Ordinal.{u}} (ho\u2082 : 2 < o) (ho : Principal (\u00b7 * \u00b7) o) :\n    o.IsLimit", "start": [300, 1], "end": [303, 55], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_iff_mul_left_eq", "code": "theorem principal_mul_iff_mul_left_eq {o : Ordinal} :\n    Principal (\u00b7 * \u00b7) o \u2194 \u2200 a, 0 < a \u2192 a < o \u2192 a * o = o", "start": [306, 1], "end": [320, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_omega", "code": "theorem principal_mul_omega : Principal (\u00b7 * \u00b7) omega", "start": [323, 1], "end": [327, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_omega", "code": "theorem mul_omega {a : Ordinal} (a0 : 0 < a) (ha : a < omega) : a * omega = omega", "start": [330, 1], "end": [331, 62], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_lt_omega_opow", "code": "theorem mul_lt_omega_opow {a b c : Ordinal} (c0 : 0 < c) (ha : a < (omega^c)) (hb : b < omega) :\n    a * b < (omega^c)", "start": [334, 1], "end": [346, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_omega_opow_opow", "code": "theorem mul_omega_opow_opow {a b : Ordinal} (a0 : 0 < a) (h : a < (omega^omega^b)) :\n    a * (omega^omega^b) = (omega^omega^b)", "start": [349, 1], "end": [359, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_omega_opow_opow", "code": "theorem principal_mul_omega_opow_opow (o : Ordinal) : Principal (\u00b7 * \u00b7) (omega^omega^o)", "start": [362, 1], "end": [363, 63], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_add_of_principal_mul_opow", "code": "theorem principal_add_of_principal_mul_opow {o b : Ordinal} (hb : 1 < b)\n    (ho : Principal (\u00b7 * \u00b7) (b^o)) : Principal (\u00b7 + \u00b7) o", "start": [366, 1], "end": [369, 71], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_mul_iff_le_two_or_omega_opow_opow", "code": "theorem principal_mul_iff_le_two_or_omega_opow_opow {o : Ordinal} :\n    Principal (\u00b7 * \u00b7) o \u2194 o \u2264 2 \u2228 \u2203 a, o = (omega^omega^a)", "start": [372, 1], "end": [389, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_omega_dvd", "code": "theorem mul_omega_dvd {a : Ordinal} (a0 : 0 < a) (ha : a < omega) : \u2200 {b}, omega \u2223 b \u2192 a * b = b", "start": [392, 1], "end": [393, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.mul_eq_opow_log_succ", "code": "theorem mul_eq_opow_log_succ {a b : Ordinal.{u}} (ha : a \u2260 0) (hb : Principal (\u00b7 * \u00b7) b)\n    (hb\u2082 : 2 < b) : a * b = (b^succ (log b a))", "start": [396, 1], "end": [412, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.principal_opow_omega", "code": "theorem principal_opow_omega : Principal (\u00b7^\u00b7) omega", "start": [418, 1], "end": [422, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.opow_omega", "code": "theorem opow_omega {a : Ordinal} (a1 : 1 < a) (h : a < omega) : (a^omega) = omega", "start": [425, 1], "end": [429, 25], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Encodable/Lattice.lean", "imports": ["Mathlib/Logic/Pairwise.lean", "Mathlib/Logic/Encodable/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Encodable.iSup_decode\u2082", "code": "theorem iSup_decode\u2082 [CompleteLattice \u03b1] (f : \u03b2 \u2192 \u03b1) :\n    \u2a06 (i : \u2115) (b \u2208 decode\u2082 \u03b2 i), f b = (\u2a06 b, f b)", "start": [29, 1], "end": [32, 46], "kind": "commanddeclaration"}, {"full_name": "Encodable.iUnion_decode\u2082", "code": "theorem iUnion_decode\u2082 (f : \u03b2 \u2192 Set \u03b1) : \u22c3 (i : \u2115) (b \u2208 decode\u2082 \u03b2 i), f b = \u22c3 b, f b", "start": [35, 1], "end": [36, 17], "kind": "commanddeclaration"}, {"full_name": "Encodable.iUnion_decode\u2082_cases", "code": "theorem iUnion_decode\u2082_cases {f : \u03b2 \u2192 Set \u03b1} {C : Set \u03b1 \u2192 Prop} (H0 : C \u2205) (H1 : \u2200 b, C (f b)) {n} :\n    C (\u22c3 b \u2208 decode\u2082 \u03b2 n, f b)", "start": [41, 1], "end": [49, 19], "kind": "commanddeclaration"}, {"full_name": "Encodable.iUnion_decode\u2082_disjoint_on", "code": "theorem iUnion_decode\u2082_disjoint_on {f : \u03b2 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on f)) :\n    Pairwise (Disjoint on fun i => \u22c3 b \u2208 decode\u2082 \u03b2 i, f b)", "start": [52, 1], "end": [58, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/UniformGroup.lean", "imports": ["Mathlib/Tactic/Abel.lean", "Mathlib/Topology/UniformSpace/UniformConvergence.lean", "Mathlib/Topology/UniformSpace/CompleteSeparated.lean", "Mathlib/Topology/Algebra/Group/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Topology/DiscreteSubset.lean", "Mathlib/Topology/UniformSpace/UniformEmbedding.lean", "Mathlib/Topology/UniformSpace/Compact.lean"], "premises": [{"full_name": "UniformGroup", "code": "class UniformGroup (\u03b1 : Type*) [UniformSpace \u03b1] [Group \u03b1] : Prop where\n  uniformContinuous_div : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => p.1 / p.2", "start": [50, 1], "end": [52, 71], "kind": "commanddeclaration"}, {"full_name": "UniformAddGroup", "code": "class UniformAddGroup (\u03b1 : Type*) [UniformSpace \u03b1] [AddGroup \u03b1] : Prop where\n  uniformContinuous_sub : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => p.1 - p.2", "start": [55, 1], "end": [58, 71], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.mk'", "code": "@[to_additive]\ntheorem UniformGroup.mk' {\u03b1} [UniformSpace \u03b1] [Group \u03b1]\n    (h\u2081 : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => p.1 * p.2) (h\u2082 : UniformContinuous fun p : \u03b1 => p\u207b\u00b9) :\n    UniformGroup \u03b1", "start": [63, 1], "end": [68, 77], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_div", "code": "@[to_additive]\ntheorem uniformContinuous_div : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => p.1 / p.2", "start": [74, 1], "end": [76, 37], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.div", "code": "@[to_additive]\ntheorem UniformContinuous.div [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x / g x", "start": [80, 1], "end": [83, 45], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.inv", "code": "@[to_additive]\ntheorem UniformContinuous.inv [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n    UniformContinuous fun x => (f x)\u207b\u00b9", "start": [87, 1], "end": [91, 11], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_inv", "code": "@[to_additive]\ntheorem uniformContinuous_inv : UniformContinuous fun x : \u03b1 => x\u207b\u00b9", "start": [95, 1], "end": [97, 27], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.mul", "code": "@[to_additive]\ntheorem UniformContinuous.mul [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f)\n    (hg : UniformContinuous g) : UniformContinuous fun x => f x * g x", "start": [101, 1], "end": [105, 11], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_mul", "code": "@[to_additive]\ntheorem uniformContinuous_mul : UniformContinuous fun p : \u03b1 \u00d7 \u03b1 => p.1 * p.2", "start": [109, 1], "end": [111, 50], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.pow_const", "code": "@[to_additive UniformContinuous.const_nsmul]\ntheorem UniformContinuous.pow_const [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n    \u2200 n : \u2115, UniformContinuous fun x => f x ^ n", "start": [115, 1], "end": [123, 34], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_pow_const", "code": "@[to_additive uniformContinuous_const_nsmul]\ntheorem uniformContinuous_pow_const (n : \u2115) : UniformContinuous fun x : \u03b1 => x ^ n", "start": [127, 1], "end": [129, 35], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.zpow_const", "code": "@[to_additive UniformContinuous.const_zsmul]\ntheorem UniformContinuous.zpow_const [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n    \u2200 n : \u2124, UniformContinuous fun x => f x ^ n", "start": [133, 1], "end": [141, 31], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_zpow_const", "code": "@[to_additive uniformContinuous_const_zsmul]\ntheorem uniformContinuous_zpow_const (n : \u2124) : UniformContinuous fun x : \u03b1 => x ^ n", "start": [145, 1], "end": [147, 36], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.to_topologicalGroup", "code": "@[to_additive]\ninstance (priority := 10) UniformGroup.to_topologicalGroup : TopologicalGroup \u03b1 where\n  continuous_mul := uniformContinuous_mul.continuous\n  continuous_inv := uniformContinuous_inv.continuous", "start": [151, 1], "end": [154, 53], "kind": "commanddeclaration"}, {"full_name": "uniformity_translate_mul", "code": "@[to_additive]\ntheorem uniformity_translate_mul (a : \u03b1) : ((\ud835\udce4 \u03b1).map fun x : \u03b1 \u00d7 \u03b1 => (x.1 * a, x.2 * a)) = \ud835\udce4 \u03b1", "start": [165, 1], "end": [175, 8], "kind": "commanddeclaration"}, {"full_name": "uniformEmbedding_translate_mul", "code": "@[to_additive]\ntheorem uniformEmbedding_translate_mul (a : \u03b1) : UniformEmbedding fun x : \u03b1 => x * a", "start": [179, 1], "end": [186, 34], "kind": "commanddeclaration"}, {"full_name": "Subgroup.uniformGroup", "code": "@[to_additive]\ninstance uniformGroup (S : Subgroup \u03b1) : UniformGroup S :=\n  \u27e8uniformContinuous_comap'\n      (uniformContinuous_div.comp <|\n        uniformContinuous_subtype_val.prod_map uniformContinuous_subtype_val)\u27e9", "start": [202, 1], "end": [206, 79], "kind": "commanddeclaration"}, {"full_name": "uniformGroup_sInf", "code": "@[to_additive]\ntheorem uniformGroup_sInf {us : Set (UniformSpace \u03b2)} (h : \u2200 u \u2208 us, @UniformGroup \u03b2 u _) :\n    @UniformGroup \u03b2 (sInf us) _", "start": [216, 1], "end": [222, 93], "kind": "commanddeclaration"}, {"full_name": "uniformGroup_iInf", "code": "@[to_additive]\ntheorem uniformGroup_iInf {\u03b9 : Sort*} {us' : \u03b9 \u2192 UniformSpace \u03b2}\n    (h' : \u2200 i, @UniformGroup \u03b2 (us' i) _) : @UniformGroup \u03b2 (\u2a05 i, us' i) _", "start": [226, 1], "end": [230, 56], "kind": "commanddeclaration"}, {"full_name": "uniformGroup_inf", "code": "@[to_additive]\ntheorem uniformGroup_inf {u\u2081 u\u2082 : UniformSpace \u03b2} (h\u2081 : @UniformGroup \u03b2 u\u2081 _)\n    (h\u2082 : @UniformGroup \u03b2 u\u2082 _) : @UniformGroup \u03b2 (u\u2081 \u2293 u\u2082) _", "start": [234, 1], "end": [239, 25], "kind": "commanddeclaration"}, {"full_name": "uniformGroup_comap", "code": "@[to_additive]\ntheorem uniformGroup_comap {\u03b3 : Type*} [Group \u03b3] {u : UniformSpace \u03b3} [UniformGroup \u03b3] {F : Type*}\n    [MonoidHomClass F \u03b2 \u03b3] (f : F) : @UniformGroup \u03b2 (u.comap f) _", "start": [243, 1], "end": [249, 97], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_comap_nhds_one", "code": "@[to_additive]\ntheorem uniformity_eq_comap_nhds_one : \ud835\udce4 \u03b1 = comap (fun x : \u03b1 \u00d7 \u03b1 => x.2 / x.1) (\ud835\udcdd (1 : \u03b1))", "start": [259, 1], "end": [272, 45], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_comap_nhds_one_swapped", "code": "@[to_additive]\ntheorem uniformity_eq_comap_nhds_one_swapped :\n    \ud835\udce4 \u03b1 = comap (fun x : \u03b1 \u00d7 \u03b1 => x.1 / x.2) (\ud835\udcdd (1 : \u03b1))", "start": [276, 1], "end": [280, 6], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.ext", "code": "@[to_additive]\ntheorem UniformGroup.ext {G : Type*} [Group G] {u v : UniformSpace G} (hu : @UniformGroup G u _)\n    (hv : @UniformGroup G v _)\n    (h : @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1) : u = v", "start": [284, 1], "end": [289, 91], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.ext_iff", "code": "@[to_additive]\ntheorem UniformGroup.ext_iff {G : Type*} [Group G] {u v : UniformSpace G}\n    (hu : @UniformGroup G u _) (hv : @UniformGroup G v _) :\n    u = v \u2194 @nhds _ u.toTopologicalSpace 1 = @nhds _ v.toTopologicalSpace 1", "start": [293, 1], "end": [297, 32], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.uniformity_countably_generated", "code": "@[to_additive]\ntheorem UniformGroup.uniformity_countably_generated [(\ud835\udcdd (1 : \u03b1)).IsCountablyGenerated] :\n    (\ud835\udce4 \u03b1).IsCountablyGenerated", "start": [303, 1], "end": [307, 46], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_comap_inv_mul_nhds_one", "code": "@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one :\n    \ud835\udce4 \u03b1 = comap (fun x : \u03b1 \u00d7 \u03b1 => x.1\u207b\u00b9 * x.2) (\ud835\udcdd (1 : \u03b1))", "start": [313, 1], "end": [318, 17], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_comap_inv_mul_nhds_one_swapped", "code": "@[to_additive]\ntheorem uniformity_eq_comap_inv_mul_nhds_one_swapped :\n    \ud835\udce4 \u03b1 = comap (fun x : \u03b1 \u00d7 \u03b1 => x.2\u207b\u00b9 * x.1) (\ud835\udcdd (1 : \u03b1))", "start": [322, 1], "end": [326, 6], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformity_of_nhds_one", "code": "@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.2 / x.1 \u2208 U i }", "start": [332, 1], "end": [337, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformity_of_nhds_one_inv_mul", "code": "@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.1\u207b\u00b9 * x.2 \u2208 U i }", "start": [341, 1], "end": [346, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformity_of_nhds_one_swapped", "code": "@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_swapped {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.1 / x.2 \u2208 U i }", "start": [350, 1], "end": [355, 18], "kind": "commanddeclaration"}, {"full_name": "Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped", "code": "@[to_additive]\ntheorem Filter.HasBasis.uniformity_of_nhds_one_inv_mul_swapped {\u03b9} {p : \u03b9 \u2192 Prop} {U : \u03b9 \u2192 Set \u03b1}\n    (h : (\ud835\udcdd (1 : \u03b1)).HasBasis p U) :\n    (\ud835\udce4 \u03b1).HasBasis p fun i => { x : \u03b1 \u00d7 \u03b1 | x.2\u207b\u00b9 * x.1 \u2208 U i }", "start": [359, 1], "end": [364, 18], "kind": "commanddeclaration"}, {"full_name": "group_separationRel", "code": "@[to_additive]\ntheorem group_separationRel (x y : \u03b1) : (x, y) \u2208 separationRel \u03b1 \u2194 x / y \u2208 closure ({1} : Set \u03b1)", "start": [368, 1], "end": [373, 85], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_of_tendsto_one", "code": "@[to_additive]\ntheorem uniformContinuous_of_tendsto_one {hom : Type*} [UniformSpace \u03b2] [Group \u03b2] [UniformGroup \u03b2]\n    [MonoidHomClass hom \u03b1 \u03b2] {f : hom} (h : Tendsto f (\ud835\udcdd 1) (\ud835\udcdd 1)) : UniformContinuous f", "start": [377, 1], "end": [385, 37], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_of_continuousAt_one", "code": "@[to_additive \"An additive group homomorphism (a bundled morphism of a type that implements\n`AddMonoidHomClass`) between two uniform additive groups is uniformly continuous provided that it\nis continuous at zero. See also `continuous_of_continuousAt_zero`.\"]\ntheorem uniformContinuous_of_continuousAt_one {hom : Type*} [UniformSpace \u03b2] [Group \u03b2]\n    [UniformGroup \u03b2] [MonoidHomClass hom \u03b1 \u03b2] (f : hom) (hf : ContinuousAt f 1) :\n    UniformContinuous f", "start": [389, 1], "end": [398, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidHom.uniformContinuous_of_continuousAt_one", "code": "@[to_additive]\ntheorem MonoidHom.uniformContinuous_of_continuousAt_one [UniformSpace \u03b2] [Group \u03b2] [UniformGroup \u03b2]\n    (f : \u03b1 \u2192* \u03b2) (hf : ContinuousAt f 1) : UniformContinuous f", "start": [402, 1], "end": [405, 52], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.uniformContinuous_iff_open_ker", "code": "@[to_additive \"A homomorphism from a uniform additive group to a discrete uniform additive group is\ncontinuous if and only if its kernel is open.\"]\ntheorem UniformGroup.uniformContinuous_iff_open_ker {hom : Type*} [UniformSpace \u03b2]\n    [DiscreteTopology \u03b2] [Group \u03b2] [UniformGroup \u03b2] [MonoidHomClass hom \u03b1 \u03b2] {f : hom} :\n    UniformContinuous f \u2194 IsOpen ((f : \u03b1 \u2192* \u03b2).ker : Set \u03b1)", "start": [409, 1], "end": [420, 34], "kind": "commanddeclaration"}, {"full_name": "uniformContinuous_monoidHom_of_continuous", "code": "@[to_additive]\ntheorem uniformContinuous_monoidHom_of_continuous {hom : Type*} [UniformSpace \u03b2] [Group \u03b2]\n    [UniformGroup \u03b2] [MonoidHomClass hom \u03b1 \u03b2] {f : hom} (h : Continuous f) : UniformContinuous f", "start": [424, 1], "end": [429, 16], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.mul", "code": "@[to_additive]\ntheorem CauchySeq.mul {\u03b9 : Type*} [SemilatticeSup \u03b9] {u v : \u03b9 \u2192 \u03b1} (hu : CauchySeq u)\n    (hv : CauchySeq v) : CauchySeq (u * v)", "start": [433, 1], "end": [436, 52], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.mul_const", "code": "@[to_additive]\ntheorem CauchySeq.mul_const {\u03b9 : Type*} [SemilatticeSup \u03b9] {u : \u03b9 \u2192 \u03b1} {x : \u03b1} (hu : CauchySeq u) :\n    CauchySeq fun n => u n * x", "start": [440, 1], "end": [443, 71], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.const_mul", "code": "@[to_additive]\ntheorem CauchySeq.const_mul {\u03b9 : Type*} [SemilatticeSup \u03b9] {u : \u03b9 \u2192 \u03b1} {x : \u03b1} (hu : CauchySeq u) :\n    CauchySeq fun n => x * u n", "start": [447, 1], "end": [450, 71], "kind": "commanddeclaration"}, {"full_name": "CauchySeq.inv", "code": "@[to_additive]\ntheorem CauchySeq.inv {\u03b9 : Type*} [SemilatticeSup \u03b9] {u : \u03b9 \u2192 \u03b1} (h : CauchySeq u) :\n    CauchySeq u\u207b\u00b9", "start": [454, 1], "end": [457, 41], "kind": "commanddeclaration"}, {"full_name": "totallyBounded_iff_subset_finite_iUnion_nhds_one", "code": "@[to_additive]\ntheorem totallyBounded_iff_subset_finite_iUnion_nhds_one {s : Set \u03b1} :\n    TotallyBounded s \u2194 \u2200 U \u2208 \ud835\udcdd (1 : \u03b1), \u2203 t : Set \u03b1, t.Finite \u2227 s \u2286 \u22c3 y \u2208 t, y \u2022 U", "start": [461, 1], "end": [465, 41], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.mul", "code": "@[to_additive]\ntheorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l'", "start": [473, 1], "end": [477, 95], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOnFilter.div", "code": "@[to_additive]\ntheorem TendstoUniformlyOnFilter.div (hf : TendstoUniformlyOnFilter f g l l')\n    (hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f / f') (g / g') l l'", "start": [481, 1], "end": [485, 95], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.mul", "code": "@[to_additive]\ntheorem TendstoUniformlyOn.mul (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f * f') (g * g') l s", "start": [489, 1], "end": [492, 84], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformlyOn.div", "code": "@[to_additive]\ntheorem TendstoUniformlyOn.div (hf : TendstoUniformlyOn f g l s)\n    (hf' : TendstoUniformlyOn f' g' l s) : TendstoUniformlyOn (f / f') (g / g') l s", "start": [496, 1], "end": [499, 84], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.mul", "code": "@[to_additive]\ntheorem TendstoUniformly.mul (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f * f') (g * g') l", "start": [503, 1], "end": [506, 82], "kind": "commanddeclaration"}, {"full_name": "TendstoUniformly.div", "code": "@[to_additive]\ntheorem TendstoUniformly.div (hf : TendstoUniformly f g l) (hf' : TendstoUniformly f' g' l) :\n    TendstoUniformly (f / f') (g / g') l", "start": [510, 1], "end": [513, 82], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.mul", "code": "@[to_additive]\ntheorem UniformCauchySeqOn.mul (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f * f') l s", "start": [517, 1], "end": [520, 82], "kind": "commanddeclaration"}, {"full_name": "UniformCauchySeqOn.div", "code": "@[to_additive]\ntheorem UniformCauchySeqOn.div (hf : UniformCauchySeqOn f l s) (hf' : UniformCauchySeqOn f' l s) :\n    UniformCauchySeqOn (f / f') l s", "start": [524, 1], "end": [527, 82], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.toUniformSpace", "code": "@[to_additive \"The right uniformity on a topological additive group (as opposed to the left\nuniformity).\n\nWarning: in general the right and left uniformities do not coincide and so one does not obtain a\n`UniformAddGroup` structure. Two important special cases where they _do_ coincide are for\ncommutative additive groups (see `comm_topologicalAddGroup_is_uniform`) and for compact\nadditive groups (see `topologicalAddGroup_is_uniform_of_compactSpace`).\"]\ndef TopologicalGroup.toUniformSpace : UniformSpace G where\n  uniformity := comap (fun p : G \u00d7 G => p.2 / p.1) (\ud835\udcdd 1)\n  refl := (Tendsto.mono_right (by simp) (pure_le_nhds _)).le_comap\n  symm :=\n    have : Tendsto (fun p : G \u00d7 G \u21a6 (p.2 / p.1)\u207b\u00b9) (comap (fun p : G \u00d7 G \u21a6 p.2 / p.1) (\ud835\udcdd 1))\n      (\ud835\udcdd 1\u207b\u00b9) := tendsto_id.inv.comp tendsto_comap\n    by simpa [tendsto_comap_iff]\n  comp := Tendsto.le_comap <| fun U H \u21a6 by\n    rcases exists_nhds_one_split H with \u27e8V, V_nhds, V_mul\u27e9\n    refine mem_map.2 (mem_of_superset (mem_lift' <| preimage_mem_comap V_nhds) ?_)\n    rintro \u27e8x, y\u27e9 \u27e8z, hz\u2081, hz\u2082\u27e9\n    simpa using V_mul _ hz\u2082 _ hz\u2081\n  isOpen_uniformity S := by\n    simp only [isOpen_iff_mem_nhds, \u2190 mem_comap_prod_mk, comap_comap, (\u00b7 \u2218 \u00b7), nhds_translation_div]", "start": [541, 1], "end": [567, 101], "kind": "commanddeclaration"}, {"full_name": "uniformity_eq_comap_nhds_one'", "code": "@[to_additive]\ntheorem uniformity_eq_comap_nhds_one' : \ud835\udce4 G = comap (fun p : G \u00d7 G => p.2 / p.1) (\ud835\udcdd (1 : G))", "start": [573, 1], "end": [575, 6], "kind": "commanddeclaration"}, {"full_name": "topologicalGroup_is_uniform_of_compactSpace", "code": "@[to_additive]\ntheorem topologicalGroup_is_uniform_of_compactSpace [CompactSpace G] : UniformGroup G", "start": [579, 1], "end": [583, 27], "kind": "commanddeclaration"}, {"full_name": "Subgroup.isClosed_of_discrete", "code": "@[to_additive]\ninstance Subgroup.isClosed_of_discrete [T2Space G] {H : Subgroup G} [DiscreteTopology H] :\n    IsClosed (H : Set G) := by\n  obtain \u27e8V, V_in, VH\u27e9 : \u2203 (V : Set G), V \u2208 \ud835\udcdd (1 : G) \u2227 V \u2229 (H : Set G) = {1}\n  exact nhds_inter_eq_singleton_of_mem_discrete H.one_mem\n  haveI : SeparatedSpace G := separated_iff_t2.mpr \u2039_\u203a\n  have : (fun p : G \u00d7 G => p.2 / p.1) \u207b\u00b9' V \u2208 \ud835\udce4 G := preimage_mem_comap V_in\n  apply isClosed_of_spaced_out this\n  intro h h_in h' h'_in\n  contrapose!\n  simp only [Set.mem_preimage, not_not]\n  rintro (hyp : h' / h \u2208 V)\n  have : h' / h \u2208 ({1} : Set G) := VH \u25b8 Set.mem_inter hyp (H.div_mem h'_in h_in)\n  exact (eq_of_div_eq_one this).symm", "start": [589, 1], "end": [602, 37], "kind": "commanddeclaration"}, {"full_name": "Subgroup.tendsto_coe_cofinite_of_discrete", "code": "@[to_additive]\nlemma Subgroup.tendsto_coe_cofinite_of_discrete [T2Space G] (H : Subgroup G) [DiscreteTopology H] :\n    Tendsto ((\u2191) : H \u2192 G) cofinite (cocompact _) :=\n  IsClosed.tendsto_coe_cofinite_of_discreteTopology inferInstance inferInstance", "start": [606, 1], "end": [609, 80], "kind": "mathlibtacticlemma"}, {"full_name": "MonoidHom.tendsto_coe_cofinite_of_discrete", "code": "@[to_additive]\nlemma MonoidHom.tendsto_coe_cofinite_of_discrete [T2Space G] {H : Type*} [Group H] {f : H \u2192* G}\n    (hf : Function.Injective f) (hf' : DiscreteTopology f.range) :\n    Tendsto f cofinite (cocompact _) := by\n  replace hf : Function.Injective f.rangeRestrict := by simpa\n  exact f.range.tendsto_coe_cofinite_of_discrete.comp hf.tendsto_cofinite", "start": [611, 1], "end": [616, 74], "kind": "mathlibtacticlemma"}, {"full_name": "TopologicalGroup.tendstoUniformly_iff", "code": "@[to_additive]\ntheorem TopologicalGroup.tendstoUniformly_iff {\u03b9 \u03b1 : Type*} (F : \u03b9 \u2192 \u03b1 \u2192 G) (f : \u03b1 \u2192 G)\n    (p : Filter \u03b9) :\n    @TendstoUniformly \u03b1 G \u03b9 (TopologicalGroup.toUniformSpace G) F f p \u2194\n      \u2200 u \u2208 \ud835\udcdd (1 : G), \u2200\u1da0 i in p, \u2200 a, F i a / f a \u2208 u", "start": [618, 1], "end": [624, 54], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.tendstoUniformlyOn_iff", "code": "@[to_additive]\ntheorem TopologicalGroup.tendstoUniformlyOn_iff {\u03b9 \u03b1 : Type*} (F : \u03b9 \u2192 \u03b1 \u2192 G) (f : \u03b1 \u2192 G)\n    (p : Filter \u03b9) (s : Set \u03b1) :\n    @TendstoUniformlyOn \u03b1 G \u03b9 (TopologicalGroup.toUniformSpace G) F f p s \u2194\n      \u2200 u \u2208 \ud835\udcdd (1 : G), \u2200\u1da0 i in p, \u2200 a \u2208 s, F i a / f a \u2208 u", "start": [628, 1], "end": [634, 60], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.tendstoLocallyUniformly_iff", "code": "@[to_additive]\ntheorem TopologicalGroup.tendstoLocallyUniformly_iff {\u03b9 \u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : \u03b9 \u2192 \u03b1 \u2192 G) (f : \u03b1 \u2192 G) (p : Filter \u03b9) :\n    @TendstoLocallyUniformly \u03b1 G \u03b9 (TopologicalGroup.toUniformSpace G) _ F f p \u2194\n      \u2200 u \u2208 \ud835\udcdd (1 : G), \u2200 (x : \u03b1), \u2203 t \u2208 \ud835\udcdd x, \u2200\u1da0 i in p, \u2200 a \u2208 t, F i a / f a \u2208 u", "start": [638, 1], "end": [645, 20], "kind": "commanddeclaration"}, {"full_name": "TopologicalGroup.tendstoLocallyUniformlyOn_iff", "code": "@[to_additive]\ntheorem TopologicalGroup.tendstoLocallyUniformlyOn_iff {\u03b9 \u03b1 : Type*} [TopologicalSpace \u03b1]\n    (F : \u03b9 \u2192 \u03b1 \u2192 G) (f : \u03b1 \u2192 G) (p : Filter \u03b9) (s : Set \u03b1) :\n    @TendstoLocallyUniformlyOn \u03b1 G \u03b9 (TopologicalGroup.toUniformSpace G) _ F f p s \u2194\n      \u2200 u \u2208 \ud835\udcdd (1 : G), \u2200 x \u2208 s, \u2203 t \u2208 \ud835\udcdd[s] x, \u2200\u1da0 i in p, \u2200 a \u2208 t, F i a / f a \u2208 u", "start": [649, 1], "end": [656, 16], "kind": "commanddeclaration"}, {"full_name": "comm_topologicalGroup_is_uniform", "code": "@[to_additive]\ntheorem comm_topologicalGroup_is_uniform : UniformGroup G", "start": [676, 1], "end": [691, 13], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.toUniformSpace_eq", "code": "@[to_additive]\ntheorem UniformGroup.toUniformSpace_eq {G : Type*} [u : UniformSpace G] [Group G]\n    [UniformGroup G] : TopologicalGroup.toUniformSpace G = u", "start": [699, 1], "end": [703, 71], "kind": "commanddeclaration"}, {"full_name": "tendsto_div_comap_self", "code": "@[to_additive]\ntheorem tendsto_div_comap_self (x\u2080 : \u03b1) :\n    Tendsto (fun t : \u03b2 \u00d7 \u03b2 => t.2 / t.1) ((comap fun p : \u03b2 \u00d7 \u03b2 => (e p.1, e p.2)) <| \ud835\udcdd (x\u2080, x\u2080))\n      (\ud835\udcdd 1)", "start": [722, 1], "end": [733, 50], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_Z_bilin_aux", "code": "private theorem extend_Z_bilin_aux (x\u2080 : \u03b1) (y\u2081 : \u03b4) : \u2203 U\u2082 \u2208 comap e (\ud835\udcdd x\u2080), \u2200 (x) (_ : x \u2208 U\u2082)\n    (x') (_ : x' \u2208 U\u2082), (fun p : \u03b2 \u00d7 \u03b4 => \u03c6 p.1 p.2) (x' - x, y\u2081) \u2208 W'", "start": [767, 1], "end": [782, 22], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_Z_bilin_key", "code": "private theorem extend_Z_bilin_key (x\u2080 : \u03b1) (y\u2080 : \u03b3) : \u2203 U \u2208 comap e (\ud835\udcdd x\u2080), \u2203 V \u2208 comap f (\ud835\udcdd y\u2080),\n    \u2200 (x) (_ : x \u2208 U) (x') (_ : x' \u2208 U), \u2200 (y) (_ : y \u2208 V) (y') (_ : y' \u2208 V),\n    (fun p : \u03b2 \u00d7 \u03b4 => \u03c6 p.1 p.2) (x', y') - (fun p : \u03b2 \u00d7 \u03b4 => \u03c6 p.1 p.2) (x, y) \u2208 W'", "start": [785, 1], "end": [831, 23], "kind": "commanddeclaration"}, {"full_name": "DenseInducing.extend_Z_bilin", "code": "theorem extend_Z_bilin : Continuous (extend (de.prod df) (fun p : \u03b2 \u00d7 \u03b4 => \u03c6 p.1 p.2))", "start": [836, 1], "end": [872, 24], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.completeSpace'", "code": "@[to_additive \"The quotient `G \u29f8 N` of a complete first countable topological additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. [N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nBecause an additive topological group is not equipped with a `UniformSpace` instance by default,\nwe must explicitly provide it in order to consider completeness. See\n`QuotientAddGroup.completeSpace` for a version in which `G` is already equipped with a uniform\nstructure.\"]\ninstance QuotientGroup.completeSpace' (G : Type u) [Group G] [TopologicalSpace G]\n    [TopologicalGroup G] [FirstCountableTopology G] (N : Subgroup G) [N.Normal]\n    [@CompleteSpace G (TopologicalGroup.toUniformSpace G)] :\n    @CompleteSpace (G \u29f8 N) (TopologicalGroup.toUniformSpace (G \u29f8 N)) := by\n  \n  letI : UniformSpace (G \u29f8 N) := TopologicalGroup.toUniformSpace (G \u29f8 N)\n  letI : UniformSpace G := TopologicalGroup.toUniformSpace G\n  haveI : (\ud835\udce4 (G \u29f8 N)).IsCountablyGenerated := comap.isCountablyGenerated _ _\n  obtain \u27e8u, hu, u_mul\u27e9 := TopologicalGroup.exists_antitone_basis_nhds_one G\n  obtain \u27e8hv, v_anti\u27e9 := @HasAntitoneBasis.map _ _ _ _ _ _ ((\u2191) : G \u2192 G \u29f8 N) hu\n  rw [\u2190 QuotientGroup.nhds_eq N 1, QuotientGroup.mk_one] at hv\n  refine' UniformSpace.complete_of_cauchySeq_tendsto fun x hx => _\n  \n  have key\u2080 : \u2200 i j : \u2115, \u2203 M : \u2115, j < M \u2227 \u2200 a b : \u2115, M \u2264 a \u2192 M \u2264 b \u2192\n      \u2200 g : G, x b = g \u2192 \u2203 g' : G, g / g' \u2208 u i \u2227 x a = g' := by\n    have h\ud835\udce4GN : (\ud835\udce4 (G \u29f8 N)).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst \u2208 (\u2191) '' u i } :=\n      by simpa [uniformity_eq_comap_nhds_one'] using hv.comap _\n    rw [h\ud835\udce4GN.cauchySeq_iff] at hx\n    simp only [ge_iff_le, mem_setOf_eq, forall_true_left, mem_image] at hx\n    intro i j\n    rcases hx i with \u27e8M, hM\u27e9\n    refine' \u27e8max j M + 1, (le_max_left _ _).trans_lt (lt_add_one _), fun a b ha hb g hg => _\u27e9\n    obtain \u27e8y, y_mem, hy\u27e9 :=\n      hM a (((le_max_right j _).trans (lt_add_one _).le).trans ha) b\n        (((le_max_right j _).trans (lt_add_one _).le).trans hb)\n    refine'\n      \u27e8y\u207b\u00b9 * g, by\n        simpa only [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_cancel_left] using y_mem, _\u27e9\n    rw [QuotientGroup.mk_mul, QuotientGroup.mk_inv, hy, hg, inv_div, div_mul_cancel']\n  \n  set \u03c6 : \u2115 \u2192 \u2115 := fun n => Nat.recOn n (choose <| key\u2080 0 0) fun k yk => choose <| key\u2080 (k + 1) yk\n  have h\u03c6 :\n    \u2200 n : \u2115,\n      \u03c6 n < \u03c6 (n + 1) \u2227\n        \u2200 a b : \u2115,\n          \u03c6 (n + 1) \u2264 a \u2192\n            \u03c6 (n + 1) \u2264 b \u2192 \u2200 g : G, x b = g \u2192 \u2203 g' : G, g / g' \u2208 u (n + 1) \u2227 x a = g' :=\n    fun n => choose_spec (key\u2080 (n + 1) (\u03c6 n))\n  \n  set x' : \u2200 n, PSigma fun g : G => x (\u03c6 (n + 1)) = g := fun n =>\n    Nat.recOn n\n      \u27e8choose (QuotientGroup.mk_surjective (x (\u03c6 1))),\n        (choose_spec (QuotientGroup.mk_surjective (x (\u03c6 1)))).symm\u27e9\n      fun k hk =>\n      \u27e8choose <| (h\u03c6 k).2 _ _ (h\u03c6 (k + 1)).1.le le_rfl hk.fst hk.snd,\n        (choose_spec <| (h\u03c6 k).2 _ _ (h\u03c6 (k + 1)).1.le le_rfl hk.fst hk.snd).2\u27e9\n  have hx' : \u2200 n : \u2115, (x' n).fst / (x' (n + 1)).fst \u2208 u (n + 1) := fun n =>\n    (choose_spec <| (h\u03c6 n).2 _ _ (h\u03c6 (n + 1)).1.le le_rfl (x' n).fst (x' n).snd).1\n  \n  have x'_cauchy : CauchySeq fun n => (x' n).fst := by\n    have h\ud835\udce4G : (\ud835\udce4 G).HasBasis (fun _ => True) fun i => { x | x.snd / x.fst \u2208 u i } := by\n      simpa [uniformity_eq_comap_nhds_one'] using hu.toHasBasis.comap _\n    rw [h\ud835\udce4G.cauchySeq_iff']\n    simp only [ge_iff_le, mem_setOf_eq, forall_true_left]\n    exact fun m =>\n      \u27e8m, fun n hmn =>\n        Nat.decreasingInduction'\n          (fun k _ _ hk => u_mul k \u27e8_, _, hx' k, hk, div_mul_div_cancel' _ _ _\u27e9) hmn\n          (by simpa only [div_self'] using mem_of_mem_nhds (hu.mem _))\u27e9\n  \n  rcases cauchySeq_tendsto_of_complete x'_cauchy with \u27e8x\u2080, hx\u2080\u27e9\n  refine'\n    \u27e8\u2191x\u2080,\n      tendsto_nhds_of_cauchySeq_of_subseq hx\n        (strictMono_nat_of_lt_succ fun n => (h\u03c6 (n + 1)).1).tendsto_atTop _\u27e9\n  convert ((continuous_coinduced_rng : Continuous ((\u2191) : G \u2192 G \u29f8 N)).tendsto x\u2080).comp hx\u2080\n  exact funext fun n => (x' n).snd", "start": [884, 1], "end": [975, 35], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.completeSpace", "code": "@[to_additive \"The quotient `G \u29f8 N` of a complete first countable uniform additive group\n`G` by a normal additive subgroup is itself complete. Consequently, quotients of Banach spaces by\nsubspaces are complete. In contrast to `QuotientAddGroup.completeSpace'`, in this version\n`G` is already equipped with a uniform structure.\n[N. Bourbaki, *General Topology*, IX.3.1 Proposition 4][bourbaki1966b]\n\nEven though `G` is equipped with a uniform structure, the quotient `G \u29f8 N` does not inherit a\nuniform structure, so it is still provided manually via `TopologicalAddGroup.toUniformSpace`.\nIn the most common use case \u2500 quotients of normed additive commutative groups by subgroups \u2500\nsignificant care was taken so that the uniform structure inherent in that setting coincides\n(definitionally) with the uniform structure provided here.\"]\ninstance QuotientGroup.completeSpace (G : Type u) [Group G] [us : UniformSpace G] [UniformGroup G]\n    [FirstCountableTopology G] (N : Subgroup G) [N.Normal] [hG : CompleteSpace G] :\n    @CompleteSpace (G \u29f8 N) (TopologicalGroup.toUniformSpace (G \u29f8 N)) := by\n  rw [\u2190 @UniformGroup.toUniformSpace_eq _ us _ _] at hG\n  infer_instance", "start": [979, 1], "end": [1003, 17], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Star.lean", "imports": ["Mathlib/Topology/ContinuousFunction/Basic.lean", "Mathlib/Topology/Algebra/Constructions.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Star/Prod.lean", "Mathlib/Algebra/Star/Pi.lean"], "premises": [{"full_name": "ContinuousStar", "code": "class ContinuousStar (R : Type*) [TopologicalSpace R] [Star R] : Prop where\n  \n  continuous_star : Continuous (star : R \u2192 R)", "start": [24, 1], "end": [27, 46], "kind": "commanddeclaration"}, {"full_name": "continuousOn_star", "code": "theorem continuousOn_star {s : Set R} : ContinuousOn star s", "start": [36, 1], "end": [37, 31], "kind": "commanddeclaration"}, {"full_name": "continuousWithinAt_star", "code": "theorem continuousWithinAt_star {s : Set R} {x : R} : ContinuousWithinAt star s x", "start": [40, 1], "end": [41, 37], "kind": "commanddeclaration"}, {"full_name": "continuousAt_star", "code": "theorem continuousAt_star {x : R} : ContinuousAt star x", "start": [44, 1], "end": [45, 31], "kind": "commanddeclaration"}, {"full_name": "tendsto_star", "code": "theorem tendsto_star (a : R) : Tendsto star (\ud835\udcdd a) (\ud835\udcdd (star a))", "start": [48, 1], "end": [49, 20], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.star", "code": "theorem Filter.Tendsto.star {f : \u03b1 \u2192 R} {l : Filter \u03b1} {y : R} (h : Tendsto f l (\ud835\udcdd y)) :\n    Tendsto (fun x => star (f x)) l (\ud835\udcdd (star y))", "start": [52, 1], "end": [54, 37], "kind": "commanddeclaration"}, {"full_name": "Continuous.star", "code": "@[continuity]\ntheorem Continuous.star (hf : Continuous f) : Continuous fun x => star (f x)", "start": [59, 1], "end": [61, 26], "kind": "commanddeclaration"}, {"full_name": "ContinuousAt.star", "code": "theorem ContinuousAt.star (hf : ContinuousAt f x) : ContinuousAt (fun x => star (f x)) x", "start": [64, 1], "end": [65, 28], "kind": "commanddeclaration"}, {"full_name": "ContinuousOn.star", "code": "theorem ContinuousOn.star (hf : ContinuousOn f s) : ContinuousOn (fun x => star (f x)) s", "start": [68, 1], "end": [69, 39], "kind": "commanddeclaration"}, {"full_name": "ContinuousWithinAt.star", "code": "theorem ContinuousWithinAt.star (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => star (f x)) s x", "start": [72, 1], "end": [74, 25], "kind": "commanddeclaration"}, {"full_name": "starContinuousMap", "code": "@[simps]\ndef starContinuousMap : C(R, R) :=\n  \u27e8star, continuous_star\u27e9", "start": [77, 1], "end": [80, 26], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Parity.lean", "imports": ["Mathlib/Tactic/Abel.lean", "Mathlib/Data/Nat/Parity.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.emod_two_ne_one", "code": "@[simp]\ntheorem emod_two_ne_one : \u00acn % 2 = 1 \u2194 n % 2 = 0", "start": [25, 1], "end": [27, 57], "kind": "commanddeclaration"}, {"full_name": "Int.emod_two_ne_zero", "code": "@[local simp]\ntheorem emod_two_ne_zero : \u00acn % 2 = 0 \u2194 n % 2 = 1", "start": [31, 1], "end": [33, 57], "kind": "commanddeclaration"}, {"full_name": "Int.even_iff", "code": "theorem even_iff : Even n \u2194 n % 2 = 0", "start": [36, 1], "end": [38, 79], "kind": "commanddeclaration"}, {"full_name": "Int.odd_iff", "code": "theorem odd_iff : Odd n \u2194 n % 2 = 1", "start": [41, 1], "end": [43, 72], "kind": "commanddeclaration"}, {"full_name": "Int.not_even_iff", "code": "theorem not_even_iff : \u00acEven n \u2194 n % 2 = 1", "start": [46, 1], "end": [46, 81], "kind": "commanddeclaration"}, {"full_name": "Int.not_odd_iff", "code": "theorem not_odd_iff : \u00acOdd n \u2194 n % 2 = 0", "start": [49, 1], "end": [49, 77], "kind": "commanddeclaration"}, {"full_name": "Int.even_iff_not_odd", "code": "theorem even_iff_not_odd : Even n \u2194 \u00acOdd n", "start": [52, 1], "end": [52, 76], "kind": "commanddeclaration"}, {"full_name": "Int.odd_iff_not_even", "code": "@[simp]\ntheorem odd_iff_not_even : Odd n \u2194 \u00acEven n", "start": [55, 1], "end": [56, 76], "kind": "commanddeclaration"}, {"full_name": "Int.isCompl_even_odd", "code": "theorem isCompl_even_odd : IsCompl { n : \u2124 | Even n } { n | Odd n }", "start": [59, 1], "end": [60, 42], "kind": "commanddeclaration"}, {"full_name": "Int.even_or_odd", "code": "theorem even_or_odd (n : \u2124) : Even n \u2228 Odd n", "start": [63, 1], "end": [64, 50], "kind": "commanddeclaration"}, {"full_name": "Int.even_or_odd'", "code": "theorem even_or_odd' (n : \u2124) : \u2203 k, n = 2 * k \u2228 n = 2 * k + 1", "start": [67, 1], "end": [68, 65], "kind": "commanddeclaration"}, {"full_name": "Int.even_xor'_odd", "code": "theorem even_xor'_odd (n : \u2124) : Xor' (Even n) (Odd n)", "start": [71, 1], "end": [74, 53], "kind": "commanddeclaration"}, {"full_name": "Int.even_xor'_odd'", "code": "theorem even_xor'_odd' (n : \u2124) : \u2203 k, Xor' (n = 2 * k) (n = 2 * k + 1)", "start": [77, 1], "end": [82, 33], "kind": "commanddeclaration"}, {"full_name": "Int.two_dvd_ne_zero", "code": "@[simp]\ntheorem two_dvd_ne_zero : \u00ac2 \u2223 n \u2194 n % 2 = 1", "start": [85, 1], "end": [87, 47], "kind": "commanddeclaration"}, {"full_name": "Int.not_even_one", "code": "@[simp]\ntheorem not_even_one : \u00acEven (1 : \u2124)", "start": [94, 1], "end": [97, 11], "kind": "commanddeclaration"}, {"full_name": "Int.even_add", "code": "@[parity_simps]\ntheorem even_add : Even (m + n) \u2194 (Even m \u2194 Even n)", "start": [100, 1], "end": [104, 40], "kind": "commanddeclaration"}, {"full_name": "Int.even_add'", "code": "theorem even_add' : Even (m + n) \u2194 (Odd m \u2194 Odd n)", "start": [107, 1], "end": [108, 65], "kind": "commanddeclaration"}, {"full_name": "Int.not_even_bit1", "code": "@[simp, deprecated]\ntheorem not_even_bit1 (n : \u2124) : \u00acEven (bit1 n)", "start": [113, 1], "end": [114, 79], "kind": "commanddeclaration"}, {"full_name": "Int.two_not_dvd_two_mul_add_one", "code": "theorem two_not_dvd_two_mul_add_one (n : \u2124) : \u00ac2 \u2223 2 * n + 1", "start": [117, 1], "end": [118, 18], "kind": "commanddeclaration"}, {"full_name": "Int.even_sub", "code": "@[parity_simps]\ntheorem even_sub : Even (m - n) \u2194 (Even m \u2194 Even n)", "start": [121, 1], "end": [123, 38], "kind": "commanddeclaration"}, {"full_name": "Int.even_sub'", "code": "theorem even_sub' : Even (m - n) \u2194 (Odd m \u2194 Odd n)", "start": [126, 1], "end": [127, 65], "kind": "commanddeclaration"}, {"full_name": "Int.even_add_one", "code": "@[parity_simps]\ntheorem even_add_one : Even (n + 1) \u2194 \u00acEven n", "start": [130, 1], "end": [132, 18], "kind": "commanddeclaration"}, {"full_name": "Int.even_mul", "code": "@[parity_simps]\ntheorem even_mul : Even (m * n) \u2194 Even m \u2228 Even n", "start": [135, 1], "end": [139, 40], "kind": "commanddeclaration"}, {"full_name": "Int.odd_mul", "code": "theorem odd_mul : Odd (m * n) \u2194 Odd m \u2227 Odd n", "start": [142, 1], "end": [142, 80], "kind": "commanddeclaration"}, {"full_name": "Int.Odd.of_mul_left", "code": "theorem Odd.of_mul_left (h : Odd (m * n)) : Odd m", "start": [145, 1], "end": [146, 19], "kind": "commanddeclaration"}, {"full_name": "Int.Odd.of_mul_right", "code": "theorem Odd.of_mul_right (h : Odd (m * n)) : Odd n", "start": [149, 1], "end": [150, 19], "kind": "commanddeclaration"}, {"full_name": "Int.even_pow", "code": "@[parity_simps]\ntheorem even_pow {n : \u2115} : Even (m ^ n) \u2194 Even m \u2227 n \u2260 0", "start": [153, 1], "end": [156, 8], "kind": "commanddeclaration"}, {"full_name": "Int.even_pow'", "code": "theorem even_pow' {n : \u2115} (h : n \u2260 0) : Even (m ^ n) \u2194 Even m", "start": [159, 1], "end": [160, 35], "kind": "commanddeclaration"}, {"full_name": "Int.odd_pow", "code": "@[parity_simps]\ntheorem odd_pow {n : \u2115} : Odd (m ^ n) \u2194 Odd m \u2228 n = 0", "start": [163, 1], "end": [165, 91], "kind": "commanddeclaration"}, {"full_name": "Int.odd_pow'", "code": "theorem odd_pow' {n : \u2115} (h : n \u2260 0) : Odd (m ^ n) \u2194 Odd m", "start": [167, 1], "end": [168, 33], "kind": "commanddeclaration"}, {"full_name": "Int.odd_add", "code": "@[parity_simps]\ntheorem odd_add : Odd (m + n) \u2194 (Odd m \u2194 Even n)", "start": [170, 1], "end": [172, 61], "kind": "commanddeclaration"}, {"full_name": "Int.odd_add'", "code": "theorem odd_add' : Odd (m + n) \u2194 (Odd n \u2194 Even m)", "start": [175, 1], "end": [176, 25], "kind": "commanddeclaration"}, {"full_name": "Int.ne_of_odd_add", "code": "theorem ne_of_odd_add (h : Odd (m + n)) : m \u2260 n", "start": [179, 1], "end": [180, 48], "kind": "commanddeclaration"}, {"full_name": "Int.odd_sub", "code": "@[parity_simps]\ntheorem odd_sub : Odd (m - n) \u2194 (Odd m \u2194 Even n)", "start": [183, 1], "end": [185, 61], "kind": "commanddeclaration"}, {"full_name": "Int.odd_sub'", "code": "theorem odd_sub' : Odd (m - n) \u2194 (Odd n \u2194 Even m)", "start": [188, 1], "end": [189, 75], "kind": "commanddeclaration"}, {"full_name": "Int.even_mul_succ_self", "code": "theorem even_mul_succ_self (n : \u2124) : Even (n * (n + 1))", "start": [192, 1], "end": [193, 53], "kind": "commanddeclaration"}, {"full_name": "Int.even_coe_nat", "code": "@[simp, norm_cast]\ntheorem even_coe_nat (n : \u2115) : Even (n : \u2124) \u2194 Even n", "start": [196, 1], "end": [198, 39], "kind": "commanddeclaration"}, {"full_name": "Int.odd_coe_nat", "code": "@[norm_cast]\ntheorem odd_coe_nat (n : \u2115) : Odd (n : \u2124) \u2194 Odd n", "start": [202, 1], "end": [204, 60], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_even", "code": "@[simp]\ntheorem natAbs_even : Even n.natAbs \u2194 Even n", "start": [207, 1], "end": [209, 61], "kind": "commanddeclaration"}, {"full_name": "Int.natAbs_odd", "code": "theorem natAbs_odd : Odd n.natAbs \u2194 Odd n", "start": [214, 1], "end": [215, 59], "kind": "commanddeclaration"}, {"full_name": "Even.natAbs", "code": "alias \u27e8_, _root_.Even.natAbs\u27e9 := natAbs_even", "start": [218, 1], "end": [218, 45], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Odd.natAbs", "code": "alias \u27e8_, _root_.Odd.natAbs\u27e9 := natAbs_odd", "start": [221, 1], "end": [221, 43], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Int.four_dvd_add_or_sub_of_odd", "code": "theorem four_dvd_add_or_sub_of_odd {a b : \u2124} (ha : Odd a) (hb : Odd b) :\n    4 \u2223 a + b \u2228 4 \u2223 a - b", "start": [228, 1], "end": [245, 8], "kind": "commanddeclaration"}, {"full_name": "Int.two_mul_ediv_two_of_even", "code": "theorem two_mul_ediv_two_of_even : Even n \u2192 2 * (n / 2) = n", "start": [248, 1], "end": [249, 56], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_two_mul_two_of_even", "code": "theorem ediv_two_mul_two_of_even : Even n \u2192 n / 2 * 2 = n", "start": [252, 1], "end": [253, 55], "kind": "commanddeclaration"}, {"full_name": "Int.two_mul_ediv_two_add_one_of_odd", "code": "theorem two_mul_ediv_two_add_one_of_odd : Odd n \u2192 2 * (n / 2) + 1 = n", "start": [256, 1], "end": [260, 22], "kind": "commanddeclaration"}, {"full_name": "Int.ediv_two_mul_two_add_one_of_odd", "code": "theorem ediv_two_mul_two_add_one_of_odd : Odd n \u2192 n / 2 * 2 + 1 = n", "start": [263, 1], "end": [266, 22], "kind": "commanddeclaration"}, {"full_name": "Int.add_one_ediv_two_mul_two_of_odd", "code": "theorem add_one_ediv_two_mul_two_of_odd : Odd n \u2192 1 + n / 2 * 2 = n", "start": [269, 1], "end": [273, 22], "kind": "commanddeclaration"}, {"full_name": "Int.two_mul_ediv_two_of_odd", "code": "theorem two_mul_ediv_two_of_odd (h : Odd n) : 2 * (n / 2) = n - 1", "start": [276, 1], "end": [277, 55], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/UniformSpace/Completion.lean", "imports": ["Mathlib/Topology/UniformSpace/AbstractCompletion.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CauchyFilter", "code": "def CauchyFilter (\u03b1 : Type u) [UniformSpace \u03b1] : Type u :=\n  { f : Filter \u03b1 // Cauchy f }", "start": [54, 1], "end": [61, 31], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.gen", "code": "def gen (s : Set (\u03b1 \u00d7 \u03b1)) : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1) :=\n  { p | s \u2208 p.1.val \u00d7\u02e2 p.2.val }", "start": [75, 1], "end": [77, 33], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.monotone_gen", "code": "theorem monotone_gen : Monotone (gen : Set (\u03b1 \u00d7 \u03b1) \u2192 _)", "start": [81, 1], "end": [82, 70], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.symm_gen", "code": "private theorem symm_gen : map Prod.swap ((\ud835\udce4 \u03b1).lift' gen) \u2264 (\ud835\udce4 \u03b1).lift' gen", "start": [87, 1], "end": [102, 23], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.compRel_gen_gen_subset_gen_compRel", "code": "private theorem compRel_gen_gen_subset_gen_compRel {s t : Set (\u03b1 \u00d7 \u03b1)} :\n    compRel (gen s) (gen t) \u2286 (gen (compRel s t) : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1))", "start": [104, 1], "end": [113, 96], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.comp_gen", "code": "private theorem comp_gen : (((\ud835\udce4 \u03b1).lift' gen).lift' fun s => compRel s s) \u2264 (\ud835\udce4 \u03b1).lift' gen", "start": [115, 1], "end": [128, 64], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.mem_uniformity", "code": "theorem mem_uniformity {s : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1)} :\n    s \u2208 \ud835\udce4 (CauchyFilter \u03b1) \u2194 \u2203 t \u2208 \ud835\udce4 \u03b1, gen t \u2286 s", "start": [138, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.mem_uniformity'", "code": "theorem mem_uniformity' {s : Set (CauchyFilter \u03b1 \u00d7 CauchyFilter \u03b1)} :\n    s \u2208 \ud835\udce4 (CauchyFilter \u03b1) \u2194 \u2203 t \u2208 \ud835\udce4 \u03b1, \u2200 f g : CauchyFilter \u03b1, t \u2208 f.1 \u00d7\u02e2 g.1 \u2192 (f, g) \u2208 s", "start": [144, 1], "end": [147, 58], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.pureCauchy", "code": "def pureCauchy (a : \u03b1) : CauchyFilter \u03b1 :=\n  \u27e8pure a, cauchy_pure\u27e9", "start": [151, 1], "end": [153, 24], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.uniformInducing_pureCauchy", "code": "theorem uniformInducing_pureCauchy : UniformInducing (pureCauchy : \u03b1 \u2192 CauchyFilter \u03b1)", "start": [157, 1], "end": [166, 8], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.uniformEmbedding_pureCauchy", "code": "theorem uniformEmbedding_pureCauchy : UniformEmbedding (pureCauchy : \u03b1 \u2192 CauchyFilter \u03b1)", "start": [170, 1], "end": [172, 72], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.denseRange_pureCauchy", "code": "theorem denseRange_pureCauchy : DenseRange (pureCauchy : \u03b1 \u2192 CauchyFilter \u03b1)", "start": [176, 1], "end": [198, 20], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.denseInducing_pureCauchy", "code": "theorem denseInducing_pureCauchy : DenseInducing (pureCauchy : \u03b1 \u2192 CauchyFilter \u03b1)", "start": [202, 1], "end": [203, 65], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.denseEmbedding_pureCauchy", "code": "theorem denseEmbedding_pureCauchy : DenseEmbedding (pureCauchy : \u03b1 \u2192 CauchyFilter \u03b1)", "start": [207, 1], "end": [208, 67], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.nonempty_cauchyFilter_iff", "code": "theorem nonempty_cauchyFilter_iff : Nonempty (CauchyFilter \u03b1) \u2194 Nonempty \u03b1", "start": [212, 1], "end": [217, 25], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.extend", "code": "def extend (f : \u03b1 \u2192 \u03b2) : CauchyFilter \u03b1 \u2192 \u03b2 :=\n  if UniformContinuous f then denseInducing_pureCauchy.extend f\n  else fun x => f (nonempty_cauchyFilter_iff.1 \u27e8x\u27e9).some", "start": [248, 1], "end": [252, 57], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.extend_pureCauchy", "code": "theorem extend_pureCauchy {f : \u03b1 \u2192 \u03b2} (hf : UniformContinuous f) (a : \u03b1) :\n    extend f (pureCauchy a) = f a", "start": [260, 1], "end": [263, 86], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.uniformContinuous_extend", "code": "theorem uniformContinuous_extend {f : \u03b1 \u2192 \u03b2} : UniformContinuous (extend f)", "start": [271, 1], "end": [276, 58], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.cauchyFilter_eq", "code": "theorem cauchyFilter_eq {\u03b1 : Type*} [Inhabited \u03b1] [UniformSpace \u03b1] [CompleteSpace \u03b1]\n    [SeparatedSpace \u03b1] {f g : CauchyFilter \u03b1} :\n    lim f.1 = lim g.1 \u2194 (f, g) \u2208 separationRel (CauchyFilter \u03b1)", "start": [284, 1], "end": [312, 69], "kind": "commanddeclaration"}, {"full_name": "CauchyFilter.separated_pureCauchy_injective", "code": "theorem separated_pureCauchy_injective {\u03b1 : Type*} [UniformSpace \u03b1] [s : SeparatedSpace \u03b1] :\n    @Function.Injective \u03b1 (Quotient (UniformSpace.separationSetoid (CauchyFilter \u03b1)))\n      fun a : \u03b1 => \u27e6pureCauchy a\u27e7", "start": [321, 1], "end": [328, 46], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.completeSpace_separation", "code": "instance completeSpace_separation [h : CompleteSpace \u03b1] :\n    CompleteSpace (Quotient (separationSetoid \u03b1)) := by\n  constructor\n  intro f hf\n  have : Cauchy (f.comap fun x => \u27e6x\u27e7) :=\n    hf.comap' comap_quotient_le_uniformity <| hf.left.comap_of_surj (surjective_quotient_mk' _)\n  let \u27e8x, (hx : (f.comap fun x => \u27e6x\u27e7) \u2264 \ud835\udcdd x)\u27e9 := CompleteSpace.complete this\n  exact \u27e8\u27e6x\u27e7,\n    (comap_le_comap_iff <| by simp).1\n      (hx.trans <| map_le_iff_le_comap.1 continuous_quotient_mk'.continuousAt)\u27e9", "start": [348, 1], "end": [357, 80], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion", "code": "def Completion :=\n  Quotient (separationSetoid <| CauchyFilter \u03b1)", "start": [360, 1], "end": [362, 48], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.inhabited", "code": "instance inhabited [Inhabited \u03b1] : Inhabited (Completion \u03b1) :=\n  inferInstanceAs <| Inhabited (Quotient _)", "start": [367, 1], "end": [368, 44], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformSpace", "code": "instance (priority := 50) uniformSpace : UniformSpace (Completion \u03b1) :=\n  separationSetoid.uniformSpace", "start": [370, 1], "end": [371, 32], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.completeSpace", "code": "instance completeSpace : CompleteSpace (Completion \u03b1) :=\n  UniformSpace.completeSpace_separation (CauchyFilter \u03b1)", "start": [373, 1], "end": [374, 57], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.separatedSpace", "code": "instance separatedSpace : SeparatedSpace (Completion \u03b1) :=\n  UniformSpace.separated_separation", "start": [376, 1], "end": [377, 36], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.t3Space", "code": "instance t3Space : T3Space (Completion \u03b1) :=\n  separated_t3", "start": [379, 1], "end": [380, 15], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.coe'", "code": "@[coe] def coe' : \u03b1 \u2192 Completion \u03b1 := Quotient.mk' \u2218 pureCauchy", "start": [382, 1], "end": [385, 64], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.coe_eq", "code": "protected theorem coe_eq : ((\u2191) : \u03b1 \u2192 Completion \u03b1) = Quotient.mk' \u2218 pureCauchy", "start": [392, 1], "end": [393, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.comap_coe_eq_uniformity", "code": "theorem comap_coe_eq_uniformity :\n    ((\ud835\udce4 _).comap fun p : \u03b1 \u00d7 \u03b1 => ((p.1 : Completion \u03b1), (p.2 : Completion \u03b1))) = \ud835\udce4 \u03b1", "start": [396, 1], "end": [405, 82], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformInducing_coe", "code": "theorem uniformInducing_coe : UniformInducing ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [408, 1], "end": [409, 30], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.denseRange_coe", "code": "theorem denseRange_coe : DenseRange ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [414, 1], "end": [415, 33], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.cPkg", "code": "def cPkg {\u03b1 : Type*} [UniformSpace \u03b1] : AbstractCompletion \u03b1 where\n  space := Completion \u03b1\n  coe := (\u2191)\n  uniformStruct := by infer_instance\n  complete := by infer_instance\n  separation := by infer_instance\n  uniformInducing := Completion.uniformInducing_coe \u03b1\n  dense := Completion.denseRange_coe", "start": [420, 1], "end": [428, 37], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.AbstractCompletion.inhabited", "code": "instance AbstractCompletion.inhabited : Inhabited (AbstractCompletion \u03b1) :=\n  \u27e8cPkg\u27e9", "start": [431, 1], "end": [432, 9], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.nonempty_completion_iff", "code": "theorem nonempty_completion_iff : Nonempty (Completion \u03b1) \u2194 Nonempty \u03b1", "start": [438, 1], "end": [439, 31], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_coe", "code": "theorem uniformContinuous_coe : UniformContinuous ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [442, 1], "end": [443, 29], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.continuous_coe", "code": "theorem continuous_coe : Continuous ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [446, 1], "end": [447, 22], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformEmbedding_coe", "code": "theorem uniformEmbedding_coe [SeparatedSpace \u03b1] : UniformEmbedding ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [450, 1], "end": [452, 44], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.coe_injective", "code": "theorem coe_injective [SeparatedSpace \u03b1] : Function.Injective ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [455, 1], "end": [456, 48], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.denseInducing_coe", "code": "theorem denseInducing_coe : DenseInducing ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [461, 1], "end": [462, 68], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.UniformCompletion.completeEquivSelf", "code": "def UniformCompletion.completeEquivSelf [CompleteSpace \u03b1] [SeparatedSpace \u03b1] : Completion \u03b1 \u2243\u1d64 \u03b1 :=\n  AbstractCompletion.compareEquiv Completion.cPkg AbstractCompletion.ofComplete", "start": [465, 1], "end": [467, 80], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.separableSpace_completion", "code": "instance separableSpace_completion [SeparableSpace \u03b1] : SeparableSpace (Completion \u03b1) :=\n  Completion.denseInducing_coe.separableSpace", "start": [472, 1], "end": [473, 46], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.denseEmbedding_coe", "code": "theorem denseEmbedding_coe [SeparatedSpace \u03b1] : DenseEmbedding ((\u2191) : \u03b1 \u2192 Completion \u03b1)", "start": [476, 1], "end": [477, 67], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.denseRange_coe\u2082", "code": "theorem denseRange_coe\u2082 :\n    DenseRange fun x : \u03b1 \u00d7 \u03b2 => ((x.1 : Completion \u03b1), (x.2 : Completion \u03b2))", "start": [480, 1], "end": [482, 41], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.denseRange_coe\u2083", "code": "theorem denseRange_coe\u2083 :\n    DenseRange fun x : \u03b1 \u00d7 \u03b2 \u00d7 \u03b3 =>\n      ((x.1 : Completion \u03b1), ((x.2.1 : Completion \u03b2), (x.2.2 : Completion \u03b3)))", "start": [485, 1], "end": [488, 42], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.induction_on", "code": "@[elab_as_elim]\ntheorem induction_on {p : Completion \u03b1 \u2192 Prop} (a : Completion \u03b1) (hp : IsClosed { a | p a })\n    (ih : \u2200 a : \u03b1, p a) : p a", "start": [491, 1], "end": [494, 43], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.induction_on\u2082", "code": "@[elab_as_elim]\ntheorem induction_on\u2082 {p : Completion \u03b1 \u2192 Completion \u03b2 \u2192 Prop} (a : Completion \u03b1) (b : Completion \u03b2)\n    (hp : IsClosed { x : Completion \u03b1 \u00d7 Completion \u03b2 | p x.1 x.2 })\n    (ih : \u2200 (a : \u03b1) (b : \u03b2), p a b) : p a b", "start": [497, 1], "end": [503, 14], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.induction_on\u2083", "code": "@[elab_as_elim]\ntheorem induction_on\u2083 {p : Completion \u03b1 \u2192 Completion \u03b2 \u2192 Completion \u03b3 \u2192 Prop} (a : Completion \u03b1)\n    (b : Completion \u03b2) (c : Completion \u03b3)\n    (hp : IsClosed { x : Completion \u03b1 \u00d7 Completion \u03b2 \u00d7 Completion \u03b3 | p x.1 x.2.1 x.2.2 })\n    (ih : \u2200 (a : \u03b1) (b : \u03b2) (c : \u03b3), p a b c) : p a b c", "start": [506, 1], "end": [513, 17], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.ext", "code": "theorem ext {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion \u03b1 \u2192 Y}\n    (hf : Continuous f) (hg : Continuous g) (h : \u2200 a : \u03b1, f a = g a) : f = g", "start": [516, 1], "end": [518, 22], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.ext'", "code": "theorem ext' {Y : Type*} [TopologicalSpace Y] [T2Space Y] {f g : Completion \u03b1 \u2192 Y}\n    (hf : Continuous f) (hg : Continuous g) (h : \u2200 a : \u03b1, f a = g a) (a : Completion \u03b1) :\n    f a = g a", "start": [521, 1], "end": [524, 28], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension", "code": "protected def extension (f : \u03b1 \u2192 \u03b2) : Completion \u03b1 \u2192 \u03b2 :=\n  cPkg.extend f", "start": [531, 1], "end": [534, 16], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_extension", "code": "theorem uniformContinuous_extension : UniformContinuous (Completion.extension f)", "start": [541, 1], "end": [542, 32], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.continuous_extension", "code": "@[continuity]\ntheorem continuous_extension : Continuous (Completion.extension f)", "start": [545, 1], "end": [547, 25], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension_coe", "code": "theorem extension_coe [SeparatedSpace \u03b2] (hf : UniformContinuous f) (a : \u03b1) :\n    (Completion.extension f) a = f a", "start": [554, 1], "end": [556, 23], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension_unique", "code": "theorem extension_unique (hf : UniformContinuous f) {g : Completion \u03b1 \u2192 \u03b2}\n    (hg : UniformContinuous g) (h : \u2200 a : \u03b1, f a = g (a : Completion \u03b1)) :\n    Completion.extension f = g", "start": [561, 1], "end": [564, 29], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension_comp_coe", "code": "@[simp]\ntheorem extension_comp_coe {f : Completion \u03b1 \u2192 \u03b2} (hf : UniformContinuous f) :\n    Completion.extension (f \u2218 (\u2191)) = f", "start": [567, 1], "end": [570, 26], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map", "code": "protected def map (f : \u03b1 \u2192 \u03b2) : Completion \u03b1 \u2192 Completion \u03b2 :=\n  cPkg.map cPkg f", "start": [579, 1], "end": [581, 18], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_map", "code": "theorem uniformContinuous_map : UniformContinuous (Completion.map f)", "start": [584, 1], "end": [585, 36], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.continuous_map", "code": "@[continuity]\ntheorem continuous_map : Continuous (Completion.map f)", "start": [588, 1], "end": [590, 29], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map_coe", "code": "theorem map_coe (hf : UniformContinuous f) (a : \u03b1) : (Completion.map f) a = f a", "start": [595, 1], "end": [596, 25], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map_unique", "code": "theorem map_unique {f : \u03b1 \u2192 \u03b2} {g : Completion \u03b1 \u2192 Completion \u03b2} (hg : UniformContinuous g)\n    (h : \u2200 a : \u03b1, \u2191(f a) = g a) : Completion.map f = g", "start": [599, 1], "end": [601, 28], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map_id", "code": "@[simp]\ntheorem map_id : Completion.map (@id \u03b1) = id", "start": [604, 1], "end": [606, 14], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension_map", "code": "theorem extension_map [CompleteSpace \u03b3] [SeparatedSpace \u03b3] {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2}\n    (hf : UniformContinuous f) (hg : UniformContinuous g) :\n    Completion.extension f \u2218 Completion.map g = Completion.extension (f \u2218 g)", "start": [609, 1], "end": [617, 27], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map_comp", "code": "theorem map_comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (hg : UniformContinuous g) (hf : UniformContinuous f) :\n    Completion.map g \u2218 Completion.map f = Completion.map (g \u2218 f)", "start": [620, 1], "end": [622, 55], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.completionSeparationQuotientEquiv", "code": "def completionSeparationQuotientEquiv (\u03b1 : Type u) [UniformSpace \u03b1] :\n    Completion (SeparationQuotient \u03b1) \u2243 Completion \u03b1 := by\n  refine'\n    \u27e8Completion.extension (SeparationQuotient.lift ((\u2191) : \u03b1 \u2192 Completion \u03b1)),\n      Completion.map Quotient.mk', _, _\u27e9\n  \u00b7 intro a\n    refine' induction_on a (isClosed_eq (continuous_map.comp continuous_extension) continuous_id) _\n    rintro \u27e8a\u27e9\n    rw [\u2190 Quotient.mk,extension_coe (SeparationQuotient.uniformContinuous_lift _),\n      SeparationQuotient.lift_mk (uniformContinuous_coe \u03b1), map_coe]\n    \u00b7 rfl\n    \u00b7 exact uniformContinuous_quotient_mk\n  \u00b7 intro a\n    refine' Completion.induction_on a\n        (isClosed_eq (continuous_extension.comp continuous_map) continuous_id) fun a => _\n    rw [map_coe]\n    \u00b7 rw [extension_coe (SeparationQuotient.uniformContinuous_lift _), Quotient.mk',\n        SeparationQuotient.lift_mk (uniformContinuous_coe \u03b1) _]\n    \u00b7 exact uniformContinuous_quotient_mk", "start": [631, 1], "end": [653, 42], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv", "code": "theorem uniformContinuous_completionSeparationQuotientEquiv :\n    UniformContinuous (completionSeparationQuotientEquiv \u03b1)", "start": [656, 1], "end": [658, 30], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_completionSeparationQuotientEquiv_symm", "code": "theorem uniformContinuous_completionSeparationQuotientEquiv_symm :\n    UniformContinuous (completionSeparationQuotientEquiv \u03b1).symm", "start": [661, 1], "end": [663, 24], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension\u2082", "code": "protected def extension\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Completion \u03b1 \u2192 Completion \u03b2 \u2192 \u03b3 :=\n  cPkg.extend\u2082 cPkg f", "start": [674, 1], "end": [676, 22], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.extension\u2082_coe_coe", "code": "theorem extension\u2082_coe_coe (hf : UniformContinuous\u2082 f) (a : \u03b1) (b : \u03b2) :\n    Completion.extension\u2082 f a b = f a b", "start": [685, 1], "end": [687, 38], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_extension\u2082", "code": "theorem uniformContinuous_extension\u2082 : UniformContinuous\u2082 (Completion.extension\u2082 f)", "start": [694, 1], "end": [695, 43], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map\u2082", "code": "protected def map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : Completion \u03b1 \u2192 Completion \u03b2 \u2192 Completion \u03b3 :=\n  cPkg.map\u2082 cPkg cPkg f", "start": [704, 1], "end": [706, 24], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.uniformContinuous_map\u2082", "code": "theorem uniformContinuous_map\u2082 (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) : UniformContinuous\u2082 (Completion.map\u2082 f)", "start": [709, 1], "end": [710, 42], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.continuous_map\u2082", "code": "theorem continuous_map\u2082 {\u03b4} [TopologicalSpace \u03b4] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {a : \u03b4 \u2192 Completion \u03b1}\n    {b : \u03b4 \u2192 Completion \u03b2} (ha : Continuous a) (hb : Continuous b) :\n    Continuous fun d : \u03b4 => Completion.map\u2082 f (a d) (b d)", "start": [713, 1], "end": [716, 39], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.map\u2082_coe_coe", "code": "theorem map\u2082_coe_coe (a : \u03b1) (b : \u03b2) (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (hf : UniformContinuous\u2082 f) :\n    Completion.map\u2082 f (a : Completion \u03b1) (b : Completion \u03b2) = f a b", "start": [719, 1], "end": [721, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Order/Filter/Archimedean.lean", "imports": ["Mathlib/Order/Filter/AtTopBot.lean", "Mathlib/Tactic/GCongr.lean", "Mathlib/Algebra/Order/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Nat.comap_cast_atTop", "code": "@[simp]\ntheorem Nat.comap_cast_atTop [StrictOrderedSemiring R] [Archimedean R] :\n    comap ((\u2191) : \u2115 \u2192 R) atTop = atTop", "start": [26, 1], "end": [29, 63], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_cast_atTop_iff", "code": "theorem tendsto_nat_cast_atTop_iff [StrictOrderedSemiring R] [Archimedean R] {f : \u03b1 \u2192 \u2115}\n    {l : Filter \u03b1} : Tendsto (fun n => (f n : R)) l atTop \u2194 Tendsto f l atTop", "start": [32, 1], "end": [34, 65], "kind": "commanddeclaration"}, {"full_name": "tendsto_nat_cast_atTop_atTop", "code": "theorem tendsto_nat_cast_atTop_atTop [StrictOrderedSemiring R] [Archimedean R] :\n    Tendsto ((\u2191) : \u2115 \u2192 R) atTop atTop", "start": [37, 1], "end": [39, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.nat_cast_atTop", "code": "theorem Filter.Eventually.nat_cast_atTop [StrictOrderedSemiring R] [Archimedean R] {p : R \u2192 Prop}\n    (h : \u2200\u1da0 (x:R) in atTop, p x) : \u2200\u1da0 (n:\u2115) in atTop, p n", "start": [42, 1], "end": [44, 55], "kind": "commanddeclaration"}, {"full_name": "Int.comap_cast_atTop", "code": "@[simp] theorem Int.comap_cast_atTop [StrictOrderedRing R] [Archimedean R] :\n    comap ((\u2191) : \u2124 \u2192 R) atTop = atTop", "start": [46, 1], "end": [49, 62], "kind": "commanddeclaration"}, {"full_name": "Int.comap_cast_atBot", "code": "@[simp]\ntheorem Int.comap_cast_atBot [StrictOrderedRing R] [Archimedean R] :\n    comap ((\u2191) : \u2124 \u2192 R) atBot = atBot", "start": [52, 1], "end": [57, 37], "kind": "commanddeclaration"}, {"full_name": "tendsto_int_cast_atTop_iff", "code": "theorem tendsto_int_cast_atTop_iff [StrictOrderedRing R] [Archimedean R] {f : \u03b1 \u2192 \u2124}\n    {l : Filter \u03b1} : Tendsto (fun n => (f n : R)) l atTop \u2194 Tendsto f l atTop", "start": [60, 1], "end": [62, 57], "kind": "commanddeclaration"}, {"full_name": "tendsto_int_cast_atBot_iff", "code": "theorem tendsto_int_cast_atBot_iff [StrictOrderedRing R] [Archimedean R] {f : \u03b1 \u2192 \u2124}\n    {l : Filter \u03b1} : Tendsto (fun n => (f n : R)) l atBot \u2194 Tendsto f l atBot", "start": [65, 1], "end": [67, 57], "kind": "commanddeclaration"}, {"full_name": "tendsto_int_cast_atTop_atTop", "code": "theorem tendsto_int_cast_atTop_atTop [StrictOrderedRing R] [Archimedean R] :\n    Tendsto ((\u2191) : \u2124 \u2192 R) atTop atTop", "start": [70, 1], "end": [72, 42], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.int_cast_atTop", "code": "theorem Filter.Eventually.int_cast_atTop [StrictOrderedRing R] [Archimedean R] {p : R \u2192 Prop}\n    (h : \u2200\u1da0 (x:R) in atTop, p x) : \u2200\u1da0 (n:\u2124) in atTop, p n", "start": [75, 1], "end": [77, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.int_cast_atBot", "code": "theorem Filter.Eventually.int_cast_atBot [StrictOrderedRing R] [Archimedean R] {p : R \u2192 Prop}\n    (h : \u2200\u1da0 (x:R) in atBot, p x) : \u2200\u1da0 (n:\u2124) in atBot, p n", "start": [79, 1], "end": [81, 55], "kind": "commanddeclaration"}, {"full_name": "Rat.comap_cast_atTop", "code": "@[simp]\ntheorem Rat.comap_cast_atTop [LinearOrderedField R] [Archimedean R] :\n    comap ((\u2191) : \u211a \u2192 R) atTop = atTop", "start": [83, 1], "end": [87, 50], "kind": "commanddeclaration"}, {"full_name": "Rat.comap_cast_atBot", "code": "@[simp] theorem Rat.comap_cast_atBot [LinearOrderedField R] [Archimedean R] :\n    comap ((\u2191) : \u211a \u2192 R) atBot = atBot", "start": [90, 1], "end": [94, 29], "kind": "commanddeclaration"}, {"full_name": "tendsto_rat_cast_atTop_iff", "code": "theorem tendsto_rat_cast_atTop_iff [LinearOrderedField R] [Archimedean R] {f : \u03b1 \u2192 \u211a}\n    {l : Filter \u03b1} : Tendsto (fun n => (f n : R)) l atTop \u2194 Tendsto f l atTop", "start": [97, 1], "end": [99, 57], "kind": "commanddeclaration"}, {"full_name": "tendsto_rat_cast_atBot_iff", "code": "theorem tendsto_rat_cast_atBot_iff [LinearOrderedField R] [Archimedean R] {f : \u03b1 \u2192 \u211a}\n    {l : Filter \u03b1} : Tendsto (fun n => (f n : R)) l atBot \u2194 Tendsto f l atBot", "start": [102, 1], "end": [104, 57], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.rat_cast_atTop", "code": "theorem Filter.Eventually.rat_cast_atTop [LinearOrderedField R] [Archimedean R] {p : R \u2192 Prop}\n    (h : \u2200\u1da0 (x:R) in atTop, p x) : \u2200\u1da0 (n:\u211a) in atTop, p n", "start": [107, 1], "end": [109, 55], "kind": "commanddeclaration"}, {"full_name": "Filter.Eventually.rat_cast_atBot", "code": "theorem Filter.Eventually.rat_cast_atBot [LinearOrderedField R] [Archimedean R] {p : R \u2192 Prop}\n    (h : \u2200\u1da0 (x:R) in atBot, p x) : \u2200\u1da0 (n:\u211a) in atBot, p n", "start": [111, 1], "end": [113, 55], "kind": "commanddeclaration"}, {"full_name": "atTop_hasAntitoneBasis_of_archimedean", "code": "theorem atTop_hasAntitoneBasis_of_archimedean [StrictOrderedSemiring R] [Archimedean R] :\n    (atTop : Filter R).HasAntitoneBasis fun n : \u2115 => Ici n where", "start": [116, 1], "end": [124, 61], "kind": "commanddeclaration"}, {"full_name": "atTop_hasCountableBasis_of_archimedean", "code": "theorem atTop_hasCountableBasis_of_archimedean [StrictOrderedSemiring R] [Archimedean R] :\n    (atTop : Filter R).HasCountableBasis (fun _ : \u2115 => True) fun n => Ici n", "start": [126, 1], "end": [128, 60], "kind": "commanddeclaration"}, {"full_name": "atBot_hasCountableBasis_of_archimedean", "code": "theorem atBot_hasCountableBasis_of_archimedean [LinearOrderedRing R] [Archimedean R] :\n    (atBot : Filter R).HasCountableBasis (fun _ : \u2124 => True) fun m => Iic m", "start": [132, 1], "end": [138, 46], "kind": "commanddeclaration"}, {"full_name": "atTop_isCountablyGenerated_of_archimedean", "code": "instance (priority := 100) atTop_isCountablyGenerated_of_archimedean [StrictOrderedSemiring R]\n    [Archimedean R] : (atTop : Filter R).IsCountablyGenerated :=\n  atTop_hasCountableBasis_of_archimedean.isCountablyGenerated", "start": [141, 1], "end": [143, 62], "kind": "commanddeclaration"}, {"full_name": "atBot_isCountablyGenerated_of_archimedean", "code": "instance (priority := 100) atBot_isCountablyGenerated_of_archimedean [LinearOrderedRing R]\n    [Archimedean R] : (atBot : Filter R).IsCountablyGenerated :=\n  atBot_hasCountableBasis_of_archimedean.isCountablyGenerated", "start": [146, 1], "end": [148, 62], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.const_mul_atTop'", "code": "theorem Tendsto.const_mul_atTop' (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => r * f x) l atTop", "start": [159, 1], "end": [175, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_const'", "code": "theorem Tendsto.atTop_mul_const' (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atTop", "start": [178, 1], "end": [194, 29], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_mul_neg_const'", "code": "theorem Tendsto.atTop_mul_neg_const' (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x * r) l atBot", "start": [203, 1], "end": [207, 89], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_const'", "code": "theorem Tendsto.atBot_mul_const' (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atBot", "start": [210, 1], "end": [215, 31], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_mul_neg_const'", "code": "theorem Tendsto.atBot_mul_neg_const' (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x * r) l atTop", "start": [218, 1], "end": [222, 87], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_nsmul_const", "code": "theorem Tendsto.atTop_nsmul_const {f : \u03b1 \u2192 \u2115} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atTop", "start": [231, 1], "end": [235, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_nsmul_neg_const", "code": "theorem Tendsto.atTop_nsmul_neg_const {f : \u03b1 \u2192 \u2115} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atBot", "start": [244, 1], "end": [245, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_zsmul_const", "code": "theorem Tendsto.atTop_zsmul_const {f : \u03b1 \u2192 \u2124} (hr : 0 < r) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atTop", "start": [248, 1], "end": [253, 84], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atTop_zsmul_neg_const", "code": "theorem Tendsto.atTop_zsmul_neg_const {f : \u03b1 \u2192 \u2124} (hr : r < 0) (hf : Tendsto f l atTop) :\n    Tendsto (fun x => f x \u2022 r) l atBot", "start": [256, 1], "end": [257, 93], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_zsmul_const", "code": "theorem Tendsto.atBot_zsmul_const {f : \u03b1 \u2192 \u2124} (hr : 0 < r) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x \u2022 r) l atBot", "start": [260, 1], "end": [263, 32], "kind": "commanddeclaration"}, {"full_name": "Filter.Tendsto.atBot_zsmul_neg_const", "code": "theorem Tendsto.atBot_zsmul_neg_const {f : \u03b1 \u2192 \u2124} (hr : r < 0) (hf : Tendsto f l atBot) :\n    Tendsto (fun x => f x \u2022 r) l atTop", "start": [266, 1], "end": [267, 93], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Int/Interval.lean", "imports": ["Mathlib/Data/Finset/LocallyFinite.lean", "Mathlib/Algebra/CharZero/Lemmas.lean", "Mathlib/Order/LocallyFinite.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.Icc_eq_finset_map", "code": "theorem Icc_eq_finset_map :\n    Icc a b =\n      (Finset.range (b + 1 - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding a)", "start": [80, 1], "end": [83, 6], "kind": "commanddeclaration"}, {"full_name": "Int.Ico_eq_finset_map", "code": "theorem Ico_eq_finset_map :\n    Ico a b = (Finset.range (b - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding a)", "start": [86, 1], "end": [88, 6], "kind": "commanddeclaration"}, {"full_name": "Int.Ioc_eq_finset_map", "code": "theorem Ioc_eq_finset_map :\n    Ioc a b =\n      (Finset.range (b - a).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding (a + 1))", "start": [91, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "Int.Ioo_eq_finset_map", "code": "theorem Ioo_eq_finset_map :\n    Ioo a b =\n      (Finset.range (b - a - 1).toNat).map (Nat.castEmbedding.trans <| addLeftEmbedding (a + 1))", "start": [97, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Int.uIcc_eq_finset_map", "code": "theorem uIcc_eq_finset_map :\n    uIcc a b = (range (max a b + 1 - min a b).toNat).map\n      (Nat.castEmbedding.trans <| addLeftEmbedding $ min a b)", "start": [103, 1], "end": [105, 69], "kind": "commanddeclaration"}, {"full_name": "Int.card_Icc", "code": "@[simp]\ntheorem card_Icc : (Icc a b).card = (b + 1 - a).toNat", "start": [108, 1], "end": [109, 91], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ico", "code": "@[simp]\ntheorem card_Ico : (Ico a b).card = (b - a).toNat", "start": [112, 1], "end": [113, 87], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ioc", "code": "@[simp]\ntheorem card_Ioc : (Ioc a b).card = (b - a).toNat", "start": [116, 1], "end": [117, 87], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ioo", "code": "@[simp]\ntheorem card_Ioo : (Ioo a b).card = (b - a - 1).toNat", "start": [120, 1], "end": [121, 91], "kind": "commanddeclaration"}, {"full_name": "Int.card_uIcc", "code": "@[simp]\ntheorem card_uIcc : (uIcc a b).card = (b - a).natAbs + 1", "start": [124, 1], "end": [132, 94], "kind": "commanddeclaration"}, {"full_name": "Int.card_Icc_of_le", "code": "theorem card_Icc_of_le (h : a \u2264 b + 1) : ((Icc a b).card : \u2124) = b + 1 - a", "start": [135, 1], "end": [136, 35], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ico_of_le", "code": "theorem card_Ico_of_le (h : a \u2264 b) : ((Ico a b).card : \u2124) = b - a", "start": [139, 1], "end": [140, 35], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ioc_of_le", "code": "theorem card_Ioc_of_le (h : a \u2264 b) : ((Ioc a b).card : \u2124) = b - a", "start": [143, 1], "end": [144, 35], "kind": "commanddeclaration"}, {"full_name": "Int.card_Ioo_of_lt", "code": "theorem card_Ioo_of_lt (h : a < b) : ((Ioo a b).card : \u2124) = b - a - 1", "start": [147, 1], "end": [148, 44], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Icc", "code": "theorem card_fintype_Icc : Fintype.card (Set.Icc a b) = (b + 1 - a).toNat", "start": [152, 1], "end": [153, 41], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ico", "code": "theorem card_fintype_Ico : Fintype.card (Set.Ico a b) = (b - a).toNat", "start": [157, 1], "end": [158, 41], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ioc", "code": "theorem card_fintype_Ioc : Fintype.card (Set.Ioc a b) = (b - a).toNat", "start": [162, 1], "end": [163, 41], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ioo", "code": "theorem card_fintype_Ioo : Fintype.card (Set.Ioo a b) = (b - a - 1).toNat", "start": [167, 1], "end": [168, 41], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_uIcc", "code": "theorem card_fintype_uIcc : Fintype.card (Set.uIcc a b) = (b - a).natAbs + 1", "start": [171, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Icc_of_le", "code": "theorem card_fintype_Icc_of_le (h : a \u2264 b + 1) : (Fintype.card (Set.Icc a b) : \u2124) = b + 1 - a", "start": [175, 1], "end": [176, 43], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ico_of_le", "code": "theorem card_fintype_Ico_of_le (h : a \u2264 b) : (Fintype.card (Set.Ico a b) : \u2124) = b - a", "start": [179, 1], "end": [180, 43], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ioc_of_le", "code": "theorem card_fintype_Ioc_of_le (h : a \u2264 b) : (Fintype.card (Set.Ioc a b) : \u2124) = b - a", "start": [183, 1], "end": [184, 43], "kind": "commanddeclaration"}, {"full_name": "Int.card_fintype_Ioo_of_lt", "code": "theorem card_fintype_Ioo_of_lt (h : a < b) : (Fintype.card (Set.Ioo a b) : \u2124) = b - a - 1", "start": [187, 1], "end": [188, 52], "kind": "commanddeclaration"}, {"full_name": "Int.image_Ico_emod", "code": "theorem image_Ico_emod (n a : \u2124) (h : 0 \u2264 a) : (Ico n (n + a)).image (\u00b7 % a) = Ico 0 a", "start": [191, 1], "end": [215, 76], "kind": "commanddeclaration"}]}
{"path": "Mathlib/GroupTheory/Archimedean.lean", "imports": ["Mathlib/GroupTheory/Subgroup/Basic.lean", "Mathlib/Algebra/Order/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AddSubgroup.cyclic_of_min", "code": "theorem AddSubgroup.cyclic_of_min {H : AddSubgroup G} {a : G}\n    (ha : IsLeast { g : G | g \u2208 H \u2227 0 < g } a) : H = AddSubgroup.closure {a}", "start": [37, 1], "end": [53, 66], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.exists_isLeast_pos", "code": "theorem AddSubgroup.exists_isLeast_pos {H : AddSubgroup G} (hbot : H \u2260 \u22a5) {a : G} (h\u2080 : 0 < a)\n    (hd : Disjoint (H : Set G) (Ioo 0 a)) : \u2203 b, IsLeast { g : G | g \u2208 H \u2227 0 < g } b", "start": [56, 1], "end": [86, 41], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.cyclic_of_isolated_zero", "code": "theorem AddSubgroup.cyclic_of_isolated_zero {H : AddSubgroup G} {a : G} (h\u2080 : 0 < a)\n    (hd : Disjoint (H : Set G) (Ioo 0 a)) : \u2203 b, H = closure {b}", "start": [88, 1], "end": [94, 69], "kind": "commanddeclaration"}, {"full_name": "Int.subgroup_cyclic", "code": "theorem Int.subgroup_cyclic (H : AddSubgroup \u2124) : \u2203 a, H = AddSubgroup.closure {a}", "start": [96, 1], "end": [100, 64], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Lipschitz.lean", "imports": ["Mathlib/Topology/Algebra/Order/Field.lean", "Mathlib/Topology/Bornology/Hom.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Set/Intervals/ProjIcc.lean"], "premises": [{"full_name": "LipschitzWith", "code": "def LipschitzWith [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 x y, edist (f x) (f y) \u2264 K * edist x y", "start": [53, 1], "end": [56, 43], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_iff_dist_le_mul", "code": "theorem lipschitzWith_iff_dist_le_mul [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} : LipschitzWith K f \u2194 \u2200 x y, dist (f x) (f y) \u2264 K * dist x y", "start": [59, 1], "end": [62, 12], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_le_mul", "code": "alias \u27e8LipschitzWith.dist_le_mul, LipschitzWith.of_dist_le_mul\u27e9 := lipschitzWith_iff_dist_le_mul", "start": [65, 1], "end": [65, 97], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzWith.of_dist_le_mul", "code": "alias \u27e8LipschitzWith.dist_le_mul, LipschitzWith.of_dist_le_mul\u27e9 := lipschitzWith_iff_dist_le_mul", "start": [65, 1], "end": [65, 97], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzOnWith", "code": "def LipschitzOnWith [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) (f : \u03b1 \u2192 \u03b2)\n    (s : Set \u03b1) :=\n  \u2200 \u2983x\u2984, x \u2208 s \u2192 \u2200 \u2983y\u2984, y \u2208 s \u2192 edist (f x) (f y) \u2264 K * edist x y", "start": [69, 1], "end": [73, 66], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz", "code": "def LocallyLipschitz [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (f : \u03b1 \u2192 \u03b2) : Prop :=\n  \u2200 x : \u03b1, \u2203 K, \u2203 t \u2208 \ud835\udcdd x, LipschitzOnWith K f t", "start": [76, 1], "end": [79, 49], "kind": "commanddeclaration"}, {"full_name": "lipschitzOnWith_empty", "code": "@[simp]\ntheorem lipschitzOnWith_empty [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) (f : \u03b1 \u2192 \u03b2) :\n    LipschitzOnWith K f \u2205", "start": [81, 1], "end": [84, 49], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.mono", "code": "theorem LipschitzOnWith.mono [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {s t : Set \u03b1}\n    {f : \u03b1 \u2192 \u03b2} (hf : LipschitzOnWith K f t) (h : s \u2286 t) : LipschitzOnWith K f s", "start": [87, 1], "end": [90, 46], "kind": "commanddeclaration"}, {"full_name": "lipschitzOnWith_iff_dist_le_mul", "code": "theorem lipschitzOnWith_iff_dist_le_mul [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {s : Set \u03b1} {f : \u03b1 \u2192 \u03b2} :\n    LipschitzOnWith K f s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 K * dist x y", "start": [93, 1], "end": [97, 12], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.dist_le_mul", "code": "alias \u27e8LipschitzOnWith.dist_le_mul, LipschitzOnWith.of_dist_le_mul\u27e9 :=\n  lipschitzOnWith_iff_dist_le_mul", "start": [100, 1], "end": [101, 34], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzOnWith.of_dist_le_mul", "code": "alias \u27e8LipschitzOnWith.dist_le_mul, LipschitzOnWith.of_dist_le_mul\u27e9 :=\n  lipschitzOnWith_iff_dist_le_mul", "start": [100, 1], "end": [101, 34], "kind": "stdtacticaliasaliaslr"}, {"full_name": "lipschitzOn_univ", "code": "@[simp]\ntheorem lipschitzOn_univ [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} :\n    LipschitzOnWith K f univ \u2194 LipschitzWith K f", "start": [105, 1], "end": [108, 93], "kind": "commanddeclaration"}, {"full_name": "lipschitzOnWith_iff_restrict", "code": "theorem lipschitzOnWith_iff_restrict [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} : LipschitzOnWith K f s \u2194 LipschitzWith K (s.restrict f)", "start": [111, 1], "end": [113, 89], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.to_restrict", "code": "alias \u27e8LipschitzOnWith.to_restrict, _\u27e9 := lipschitzOnWith_iff_restrict", "start": [116, 1], "end": [116, 71], "kind": "stdtacticaliasaliaslr"}, {"full_name": "MapsTo.lipschitzOnWith_iff_restrict", "code": "theorem MapsTo.lipschitzOnWith_iff_restrict [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {t : Set \u03b2} (h : MapsTo f s t) :\n    LipschitzOnWith K f s \u2194 LipschitzWith K (h.restrict f s t)", "start": [119, 1], "end": [122, 38], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.to_restrict_mapsTo", "code": "alias \u27e8LipschitzOnWith.to_restrict_mapsTo, _\u27e9 := MapsTo.lipschitzOnWith_iff_restrict", "start": [125, 1], "end": [125, 85], "kind": "stdtacticaliasaliaslr"}, {"full_name": "LipschitzWith.lipschitzOnWith", "code": "protected theorem lipschitzOnWith (h : LipschitzWith K f) (s : Set \u03b1) : LipschitzOnWith K f s", "start": [138, 1], "end": [139, 23], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_le_mul", "code": "theorem edist_le_mul (h : LipschitzWith K f) (x y : \u03b1) : edist (f x) (f y) \u2264 K * edist x y", "start": [142, 1], "end": [143, 8], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_le_mul_of_le", "code": "theorem edist_le_mul_of_le (h : LipschitzWith K f) (hr : edist x y \u2264 r) :\n    edist (f x) (f y) \u2264 K * r", "start": [146, 1], "end": [148, 44], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_lt_mul_of_lt", "code": "theorem edist_lt_mul_of_lt (h : LipschitzWith K f) (hK : K \u2260 0) (hr : edist x y < r) :\n    edist (f x) (f y) < K * r", "start": [151, 1], "end": [153, 99], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mapsTo_emetric_closedBall", "code": "theorem mapsTo_emetric_closedBall (h : LipschitzWith K f) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    MapsTo f (closedBall x r) (closedBall (f x) (K * r))", "start": [156, 1], "end": [157, 97], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mapsTo_emetric_ball", "code": "theorem mapsTo_emetric_ball (h : LipschitzWith K f) (hK : K \u2260 0) (x : \u03b1) (r : \u211d\u22650\u221e) :\n    MapsTo f (ball x r) (ball (f x) (K * r))", "start": [160, 1], "end": [161, 88], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_lt_top", "code": "theorem edist_lt_top (hf : LipschitzWith K f) {x y : \u03b1} (h : edist x y \u2260 \u22a4) :\n    edist (f x) (f y) < \u22a4", "start": [164, 1], "end": [166, 63], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mul_edist_le", "code": "theorem mul_edist_le (h : LipschitzWith K f) (x y : \u03b1) :\n    (K\u207b\u00b9 : \u211d\u22650\u221e) * edist (f x) (f y) \u2264 edist x y", "start": [169, 1], "end": [172, 42], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.of_edist_le", "code": "protected theorem of_edist_le (h : \u2200 x y, edist (f x) (f y) \u2264 edist x y) : LipschitzWith 1 f", "start": [175, 1], "end": [176, 56], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.weaken", "code": "protected theorem weaken (hf : LipschitzWith K f) {K' : \u211d\u22650} (h : K \u2264 K') : LipschitzWith K' f", "start": [179, 1], "end": [180, 82], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.ediam_image_le", "code": "theorem ediam_image_le (hf : LipschitzWith K f) (s : Set \u03b1) :\n    EMetric.diam (f '' s) \u2264 K * EMetric.diam s", "start": [183, 1], "end": [187, 67], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_lt_of_edist_lt_div", "code": "theorem edist_lt_of_edist_lt_div (hf : LipschitzWith K f) {x y : \u03b1} {d : \u211d\u22650\u221e}\n    (h : edist x y < d / K) : edist (f x) (f y) < d", "start": [190, 1], "end": [194, 41], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.uniformContinuous", "code": "protected theorem uniformContinuous (hf : LipschitzWith K f) : UniformContinuous f", "start": [197, 1], "end": [200, 100], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.continuous", "code": "protected theorem continuous (hf : LipschitzWith K f) : Continuous f", "start": [203, 1], "end": [205, 34], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.const", "code": "protected theorem const (b : \u03b2) : LipschitzWith 0 fun _ : \u03b1 => b", "start": [208, 1], "end": [210, 34], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.const'", "code": "protected theorem const' (b : \u03b2) {K : \u211d\u22650} : LipschitzWith K fun _ : \u03b1 => b", "start": [213, 1], "end": [214, 34], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.id", "code": "protected theorem id : LipschitzWith 1 (@id \u03b1)", "start": [216, 1], "end": [218, 46], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.subtype_val", "code": "protected theorem subtype_val (s : Set \u03b1) : LipschitzWith 1 (Subtype.val : s \u2192 \u03b1)", "start": [221, 1], "end": [223, 46], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.subtype_mk", "code": "theorem subtype_mk (hf : LipschitzWith K f) {p : \u03b2 \u2192 Prop} (hp : \u2200 x, p (f x)) :\n    LipschitzWith K (fun x => \u27e8f x, hp x\u27e9 : \u03b1 \u2192 { y // p y })", "start": [227, 1], "end": [229, 5], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.eval", "code": "protected theorem eval {\u03b1 : \u03b9 \u2192 Type u} [\u2200 i, PseudoEMetricSpace (\u03b1 i)] [Fintype \u03b9] (i : \u03b9) :\n    LipschitzWith 1 (Function.eval i : (\u2200 i, \u03b1 i) \u2192 \u03b1 i)", "start": [232, 1], "end": [234, 74], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.restrict", "code": "protected theorem restrict (hf : LipschitzWith K f) (s : Set \u03b1) : LipschitzWith K (s.restrict f)", "start": [237, 1], "end": [239, 20], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comp", "code": "protected theorem comp {Kf Kg : \u211d\u22650} {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} (hf : LipschitzWith Kf f)\n    (hg : LipschitzWith Kg g) : LipschitzWith (Kf * Kg) (f \u2218 g)", "start": [242, 1], "end": [248, 76], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comp_lipschitzOnWith", "code": "theorem comp_lipschitzOnWith {Kf Kg : \u211d\u22650} {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n    (hf : LipschitzWith Kf f) (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (Kf * Kg) (f \u2218 g) s", "start": [251, 1], "end": [253, 61], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.prod_fst", "code": "protected theorem prod_fst : LipschitzWith 1 (@Prod.fst \u03b1 \u03b2)", "start": [256, 1], "end": [257, 55], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.prod_snd", "code": "protected theorem prod_snd : LipschitzWith 1 (@Prod.snd \u03b1 \u03b2)", "start": [260, 1], "end": [261, 56], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.prod", "code": "protected theorem prod {f : \u03b1 \u2192 \u03b2} {Kf : \u211d\u22650} (hf : LipschitzWith Kf f) {g : \u03b1 \u2192 \u03b3} {Kg : \u211d\u22650}\n    (hg : LipschitzWith Kg g) : LipschitzWith (max Kf Kg) fun x => (f x, g x)", "start": [264, 1], "end": [269, 37], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.prod_mk_left", "code": "protected theorem prod_mk_left (a : \u03b1) : LipschitzWith 1 (Prod.mk a : \u03b2 \u2192 \u03b1 \u00d7 \u03b2)", "start": [272, 1], "end": [273, 92], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.prod_mk_right", "code": "protected theorem prod_mk_right (b : \u03b2) : LipschitzWith 1 fun a : \u03b1 => (a, b)", "start": [276, 1], "end": [277, 91], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.uncurry", "code": "protected theorem uncurry {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} {K\u03b1 K\u03b2 : \u211d\u22650} (h\u03b1 : \u2200 b, LipschitzWith K\u03b1 fun a => f a b)\n    (h\u03b2 : \u2200 a, LipschitzWith K\u03b2 (f a)) : LipschitzWith (K\u03b1 + K\u03b2) (Function.uncurry f)", "start": [280, 1], "end": [287, 73], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) : \u2200 n, LipschitzWith (K ^ n) f^[n]", "start": [290, 1], "end": [293, 75], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.edist_iterate_succ_le_geometric", "code": "theorem edist_iterate_succ_le_geometric {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) (x n) :\n    edist (f^[n] x) (f^[n + 1] x) \u2264 edist x (f x) * (K : \u211d\u22650\u221e) ^ n", "start": [296, 1], "end": [299, 60], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mul_end", "code": "protected theorem mul_end {f g : Function.End \u03b1} {Kf Kg} (hf : LipschitzWith Kf f)\n    (hg : LipschitzWith Kg g) : LipschitzWith (Kf * Kg) (f * g : Function.End \u03b1)", "start": [302, 1], "end": [304, 13], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.list_prod", "code": "protected theorem list_prod (f : \u03b9 \u2192 Function.End \u03b1) (K : \u03b9 \u2192 \u211d\u22650)\n    (h : \u2200 i, LipschitzWith (K i) (f i)) : \u2200 l : List \u03b9, LipschitzWith (l.map K).prod (l.map f).prod", "start": [307, 1], "end": [314, 58], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.pow_end", "code": "protected theorem pow_end {f : Function.End \u03b1} {K} (h : LipschitzWith K f) :\n    \u2200 n : \u2115, LipschitzWith (K ^ n) (f ^ n : Function.End \u03b1)", "start": [317, 1], "end": [322, 48], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.of_dist_le'", "code": "protected theorem of_dist_le' {K : \u211d} (h : \u2200 x y, dist (f x) (f y) \u2264 K * dist x y) :\n    LipschitzWith (Real.toNNReal K) f", "start": [332, 1], "end": [335, 62], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mk_one", "code": "protected theorem mk_one (h : \u2200 x y, dist (f x) (f y) \u2264 dist x y) : LipschitzWith 1 f", "start": [338, 1], "end": [339, 68], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.of_le_add_mul'", "code": "protected theorem of_le_add_mul' {f : \u03b1 \u2192 \u211d} (K : \u211d) (h : \u2200 x y, f x \u2264 f y + K * dist x y) :\n    LipschitzWith (Real.toNNReal K) f", "start": [342, 1], "end": [347, 87], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.of_le_add_mul", "code": "protected theorem of_le_add_mul {f : \u03b1 \u2192 \u211d} (K : \u211d\u22650) (h : \u2200 x y, f x \u2264 f y + K * dist x y) :\n    LipschitzWith K f", "start": [350, 1], "end": [353, 98], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.of_le_add", "code": "protected theorem of_le_add {f : \u03b1 \u2192 \u211d} (h : \u2200 x y, f x \u2264 f y + dist x y) : LipschitzWith 1 f", "start": [356, 1], "end": [357, 75], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.le_add_mul", "code": "protected theorem le_add_mul {f : \u03b1 \u2192 \u211d} {K : \u211d\u22650} (h : LipschitzWith K f) (x y) :\n    f x \u2264 f y + K * dist x y", "start": [360, 1], "end": [362, 72], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.iff_le_add_mul", "code": "protected theorem iff_le_add_mul {f : \u03b1 \u2192 \u211d} {K : \u211d\u22650} :\n    LipschitzWith K f \u2194 \u2200 x y, f x \u2264 f y + K * dist x y", "start": [365, 1], "end": [367, 60], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.nndist_le", "code": "theorem nndist_le (hf : LipschitzWith K f) (x y : \u03b1) : nndist (f x) (f y) \u2264 K * nndist x y", "start": [370, 1], "end": [371, 21], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_le_mul_of_le", "code": "theorem dist_le_mul_of_le (hf : LipschitzWith K f) (hr : dist x y \u2264 r) : dist (f x) (f y) \u2264 K * r", "start": [374, 1], "end": [375, 42], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mapsTo_closedBall", "code": "theorem mapsTo_closedBall (hf : LipschitzWith K f) (x : \u03b1) (r : \u211d) :\n    MapsTo f (Metric.closedBall x r) (Metric.closedBall (f x) (K * r))", "start": [378, 1], "end": [380, 26], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_lt_mul_of_lt", "code": "theorem dist_lt_mul_of_lt (hf : LipschitzWith K f) (hK : K \u2260 0) (hr : dist x y < r) :\n    dist (f x) (f y) < K * r", "start": [383, 1], "end": [385, 88], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.mapsTo_ball", "code": "theorem mapsTo_ball (hf : LipschitzWith K f) (hK : K \u2260 0) (x : \u03b1) (r : \u211d) :\n    MapsTo f (Metric.ball x r) (Metric.ball (f x) (K * r))", "start": [388, 1], "end": [390, 29], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.toLocallyBoundedMap", "code": "def toLocallyBoundedMap (f : \u03b1 \u2192 \u03b2) (hf : LipschitzWith K f) : LocallyBoundedMap \u03b1 \u03b2 :=\n  LocallyBoundedMap.ofMapBounded f fun _s hs =>\n    let \u27e8C, hC\u27e9 := Metric.isBounded_iff.1 hs\n    Metric.isBounded_iff.2 \u27e8K * C, ball_image_iff.2 fun _x hx => ball_image_iff.2 fun _y hy =>\n      hf.dist_le_mul_of_le (hC hx hy)\u27e9", "start": [393, 1], "end": [398, 39], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.coe_toLocallyBoundedMap", "code": "@[simp]\ntheorem coe_toLocallyBoundedMap (hf : LipschitzWith K f) : \u21d1(hf.toLocallyBoundedMap f) = f", "start": [401, 1], "end": [403, 6], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.comap_cobounded_le", "code": "theorem comap_cobounded_le (hf : LipschitzWith K f) :\n    comap f (Bornology.cobounded \u03b2) \u2264 Bornology.cobounded \u03b1", "start": [406, 1], "end": [408, 31], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.isBounded_image", "code": "theorem isBounded_image (hf : LipschitzWith K f) {s : Set \u03b1} (hs : IsBounded s) :\n    IsBounded (f '' s)", "start": [411, 1], "end": [414, 38], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.diam_image_le", "code": "theorem diam_image_le (hf : LipschitzWith K f) (s : Set \u03b1) (hs : IsBounded s) :\n    Metric.diam (f '' s) \u2264 K * Metric.diam s", "start": [417, 1], "end": [421, 96], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_left", "code": "protected theorem dist_left (y : \u03b1) : LipschitzWith 1 (dist \u00b7 y)", "start": [424, 1], "end": [425, 63], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_right", "code": "protected theorem dist_right (x : \u03b1) : LipschitzWith 1 (dist x)", "start": [428, 1], "end": [429, 63], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist", "code": "protected theorem dist : LipschitzWith 2 (Function.uncurry <| @dist \u03b1 _)", "start": [432, 1], "end": [434, 79], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.dist_iterate_succ_le_geometric", "code": "theorem dist_iterate_succ_le_geometric {f : \u03b1 \u2192 \u03b1} (hf : LipschitzWith K f) (x n) :\n    dist (f^[n] x) (f^[n + 1] x) \u2264 dist x (f x) * (K : \u211d) ^ n", "start": [437, 1], "end": [440, 71], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_max", "code": "theorem _root_.lipschitzWith_max : LipschitzWith 1 fun p : \u211d \u00d7 \u211d => max p.1 p.2", "start": [443, 1], "end": [445, 59], "kind": "commanddeclaration"}, {"full_name": "lipschitzWith_min", "code": "theorem _root_.lipschitzWith_min : LipschitzWith 1 fun p : \u211d \u00d7 \u211d => min p.1 p.2", "start": [448, 1], "end": [450, 59], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.max", "code": "protected theorem max (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => max (f x) (g x)", "start": [459, 1], "end": [461, 74], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.min", "code": "protected theorem min (hf : LipschitzWith Kf f) (hg : LipschitzWith Kg g) :\n    LipschitzWith (max Kf Kg) fun x => min (f x) (g x)", "start": [464, 1], "end": [466, 74], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.max_const", "code": "theorem max_const (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => max (f x) a", "start": [469, 1], "end": [470, 77], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.const_max", "code": "theorem const_max (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => max a (f x)", "start": [473, 1], "end": [474, 45], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.min_const", "code": "theorem min_const (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => min (f x) a", "start": [477, 1], "end": [478, 77], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.const_min", "code": "theorem const_min (hf : LipschitzWith Kf f) (a : \u211d) : LipschitzWith Kf fun x => min a (f x)", "start": [481, 1], "end": [482, 45], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.projIcc", "code": "protected theorem projIcc {a b : \u211d} (h : a \u2264 b) : LipschitzWith 1 (projIcc a b h)", "start": [487, 1], "end": [488, 60], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.uniformContinuousOn", "code": "protected theorem uniformContinuousOn (hf : LipschitzOnWith K f s) : UniformContinuousOn f s", "start": [512, 1], "end": [513, 94], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.continuousOn", "code": "protected theorem continuousOn (hf : LipschitzOnWith K f s) : ContinuousOn f s", "start": [516, 1], "end": [517, 38], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.edist_le_mul_of_le", "code": "theorem edist_le_mul_of_le (h : LipschitzOnWith K f s) (hx : x \u2208 s) (hy : y \u2208 s)\n    (hr : edist x y \u2264 r) :\n    edist (f x) (f y) \u2264 K * r", "start": [520, 1], "end": [523, 46], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.edist_lt_of_edist_lt_div", "code": "theorem edist_lt_of_edist_lt_div (hf : LipschitzOnWith K f s) {x y : \u03b1} (hx : x \u2208 s) (hy : y \u2208 s)\n    {d : \u211d\u22650\u221e} (hd : edist x y < d / K) : edist (f x) (f y) < d", "start": [525, 1], "end": [528, 53], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.comp", "code": "protected theorem comp {g : \u03b2 \u2192 \u03b3} {t : Set \u03b2} {Kg : \u211d\u22650} (hg : LipschitzOnWith Kg g t)\n    (hf : LipschitzOnWith K f s) (hmaps : MapsTo f s t) : LipschitzOnWith (Kg * K) (g \u2218 f) s", "start": [531, 1], "end": [533, 88], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.prod", "code": "protected theorem prod {g : \u03b1 \u2192 \u03b3} {Kf Kg : \u211d\u22650} (hf : LipschitzOnWith Kf f s)\n    (hg : LipschitzOnWith Kg g s) : LipschitzOnWith (max Kf Kg) (fun x => (f x, g x)) s", "start": [536, 1], "end": [541, 41], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.of_dist_le'", "code": "protected theorem of_dist_le' {K : \u211d} (h : \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 K * dist x y) :\n    LipschitzOnWith (Real.toNNReal K) f s", "start": [551, 1], "end": [554, 68], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.mk_one", "code": "protected theorem mk_one (h : \u2200 x \u2208 s, \u2200 y \u2208 s, dist (f x) (f y) \u2264 dist x y) :\n    LipschitzOnWith 1 f s", "start": [557, 1], "end": [559, 68], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.of_le_add_mul'", "code": "protected theorem of_le_add_mul' {f : \u03b1 \u2192 \u211d} (K : \u211d)\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y + K * dist x y) : LipschitzOnWith (Real.toNNReal K) f s", "start": [562, 1], "end": [569, 64], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.of_le_add_mul", "code": "protected theorem of_le_add_mul {f : \u03b1 \u2192 \u211d} (K : \u211d\u22650)\n    (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y + K * dist x y) : LipschitzOnWith K f s", "start": [572, 1], "end": [576, 74], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.of_le_add", "code": "protected theorem of_le_add {f : \u03b1 \u2192 \u211d} (h : \u2200 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y + dist x y) :\n    LipschitzOnWith 1 f s", "start": [579, 1], "end": [581, 77], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.le_add_mul", "code": "protected theorem le_add_mul {f : \u03b1 \u2192 \u211d} {K : \u211d\u22650} (h : LipschitzOnWith K f s) {x : \u03b1} (hx : x \u2208 s)\n    {y : \u03b1} (hy : y \u2208 s) : f x \u2264 f y + K * dist x y", "start": [584, 1], "end": [586, 78], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.iff_le_add_mul", "code": "protected theorem iff_le_add_mul {f : \u03b1 \u2192 \u211d} {K : \u211d\u22650} :\n    LipschitzOnWith K f s \u2194 \u2200 x \u2208 s, \u2200 y \u2208 s, f x \u2264 f y + K * dist x y", "start": [589, 1], "end": [591, 64], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.locallyLipschitz", "code": "protected lemma _root_.LipschitzWith.locallyLipschitz {K : \u211d\u22650} (hf : LipschitzWith K f) :\n    LocallyLipschitz f :=\n  fun _ \u21a6 \u27e8K, univ, Filter.univ_mem, lipschitzOn_univ.mpr hf\u27e9", "start": [601, 1], "end": [604, 62], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.id", "code": "protected lemma id : LocallyLipschitz (@id \u03b1) := LipschitzWith.id.locallyLipschitz", "start": [606, 1], "end": [607, 83], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.const", "code": "protected lemma const (b : \u03b2) : LocallyLipschitz (fun _ : \u03b1 \u21a6 b) :=\n  (LipschitzWith.const b).locallyLipschitz", "start": [609, 1], "end": [611, 43], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.continuous", "code": "protected theorem continuous {f : \u03b1 \u2192 \u03b2} (hf : LocallyLipschitz f) : Continuous f", "start": [613, 1], "end": [619, 42], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.comp", "code": "protected lemma comp  {f : \u03b2 \u2192 \u03b3} {g : \u03b1 \u2192 \u03b2}\n    (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) : LocallyLipschitz (f \u2218 g) := by\n  intro x\n  rcases hg x with \u27e8Kg, t, ht, hgL\u27e9\n  rcases hf (g x) with \u27e8Kf, u, hu, hfL\u27e9\n  refine \u27e8Kf * Kg, t \u2229 g\u207b\u00b9' u, inter_mem ht (hg.continuous.continuousAt hu), ?_\u27e9\n  exact hfL.comp (hgL.mono (inter_subset_left _ _))\n    ((mapsTo_preimage g u).mono_left (inter_subset_right _ _))", "start": [621, 1], "end": [630, 63], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.prod", "code": "protected lemma prod {f : \u03b1 \u2192 \u03b2} (hf : LocallyLipschitz f) {g : \u03b1 \u2192 \u03b3} (hg : LocallyLipschitz g) :\n    LocallyLipschitz fun x => (f x, g x) := by\n  intro x\n  rcases hf x with \u27e8Kf, t\u2081, h\u2081t, hfL\u27e9\n  rcases hg x with \u27e8Kg, t\u2082, h\u2082t, hgL\u27e9\n  refine \u27e8max Kf Kg, t\u2081 \u2229 t\u2082, Filter.inter_mem h\u2081t h\u2082t, ?_\u27e9\n  exact (hfL.mono (inter_subset_left t\u2081 t\u2082)).prod (hgL.mono (inter_subset_right t\u2081 t\u2082))", "start": [632, 1], "end": [639, 88], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.prod_mk_left", "code": "protected theorem prod_mk_left (a : \u03b1) : LocallyLipschitz (Prod.mk a : \u03b2 \u2192 \u03b1 \u00d7 \u03b2)", "start": [641, 1], "end": [642, 50], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.prod_mk_right", "code": "protected theorem prod_mk_right (b : \u03b2) : LocallyLipschitz (fun a : \u03b1 => (a, b))", "start": [644, 1], "end": [645, 51], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.iterate", "code": "protected theorem iterate {f : \u03b1 \u2192 \u03b1} (hf : LocallyLipschitz f) : \u2200 n, LocallyLipschitz f^[n]", "start": [647, 1], "end": [649, 76], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.mul_end", "code": "protected theorem mul_end {f g : Function.End \u03b1} (hf : LocallyLipschitz f)\n    (hg : LocallyLipschitz g) : LocallyLipschitz (f * g : Function.End \u03b1)", "start": [651, 1], "end": [652, 88], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.pow_end", "code": "protected theorem pow_end {f : Function.End \u03b1} (h : LocallyLipschitz f) :\n    \u2200 n : \u2115, LocallyLipschitz (f ^ n : Function.End \u03b1)", "start": [654, 1], "end": [659, 34], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.min", "code": "protected lemma min (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) :\n    LocallyLipschitz (fun x => min (f x) (g x)) :=\n  lipschitzWith_min.locallyLipschitz.comp (hf.prod hg)", "start": [663, 1], "end": [666, 55], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.max", "code": "protected lemma max (hf : LocallyLipschitz f) (hg : LocallyLipschitz g) :\n    LocallyLipschitz (fun x => max (f x) (g x)) :=\n  lipschitzWith_max.locallyLipschitz.comp (hf.prod hg)", "start": [668, 1], "end": [671, 55], "kind": "mathlibtacticlemma"}, {"full_name": "LocallyLipschitz.max_const", "code": "theorem max_const (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => max (f x) a", "start": [673, 1], "end": [674, 36], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.const_max", "code": "theorem const_max (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => max a (f x)", "start": [676, 1], "end": [677, 42], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.min_const", "code": "theorem min_const (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => min (f x) a", "start": [679, 1], "end": [680, 36], "kind": "commanddeclaration"}, {"full_name": "LocallyLipschitz.const_min", "code": "theorem const_min (hf : LocallyLipschitz f) (a : \u211d) : LocallyLipschitz fun x => min a (f x)", "start": [682, 1], "end": [683, 42], "kind": "commanddeclaration"}, {"full_name": "continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith", "code": "theorem continuousOn_prod_of_subset_closure_continuousOn_lipschitzOnWith [PseudoEMetricSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoEMetricSpace \u03b3] (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) {s s' : Set \u03b1} {t : Set \u03b2}\n    (hs' : s' \u2286 s) (hss' : s \u2286 closure s') (K : \u211d\u22650)\n    (ha : \u2200 a \u2208 s', ContinuousOn (fun y => f (a, y)) t)\n    (hb : \u2200 b \u2208 t, LipschitzOnWith K (fun x => f (x, b)) s) : ContinuousOn f (s \u00d7\u02e2 t)", "start": [688, 1], "end": [723, 34], "kind": "commanddeclaration"}, {"full_name": "continuousOn_prod_of_continuousOn_lipschitzOnWith", "code": "theorem continuousOn_prod_of_continuousOn_lipschitzOnWith [PseudoEMetricSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoEMetricSpace \u03b3] (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) {s : Set \u03b1} {t : Set \u03b2} (K : \u211d\u22650)\n    (ha : \u2200 a \u2208 s, ContinuousOn (fun y => f (a, y)) t)\n    (hb : \u2200 b \u2208 t, LipschitzOnWith K (fun x => f (x, b)) s) : ContinuousOn f (s \u00d7\u02e2 t)", "start": [725, 1], "end": [736, 40], "kind": "commanddeclaration"}, {"full_name": "continuous_prod_of_dense_continuous_lipschitzWith", "code": "theorem continuous_prod_of_dense_continuous_lipschitzWith [PseudoEMetricSpace \u03b1]\n    [TopologicalSpace \u03b2] [PseudoEMetricSpace \u03b3] (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (K : \u211d\u22650) {s : Set \u03b1}\n    (hs : Dense s) (ha : \u2200 a \u2208 s, Continuous fun y => f (a, y))\n    (hb : \u2200 b, LipschitzWith K fun x => f (x, b)) : Continuous f", "start": [739, 1], "end": [752, 42], "kind": "commanddeclaration"}, {"full_name": "continuous_prod_of_continuous_lipschitzWith", "code": "theorem continuous_prod_of_continuous_lipschitzWith [PseudoEMetricSpace \u03b1] [TopologicalSpace \u03b2]\n    [PseudoEMetricSpace \u03b3] (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (K : \u211d\u22650) (ha : \u2200 a, Continuous fun y => f (a, y))\n    (hb : \u2200 b, LipschitzWith K fun x => f (x, b)) : Continuous f", "start": [754, 1], "end": [763, 87], "kind": "commanddeclaration"}, {"full_name": "continuousAt_of_locally_lipschitz", "code": "theorem continuousAt_of_locally_lipschitz [PseudoMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    {x : \u03b1} {r : \u211d} (hr : 0 < r) (K : \u211d) (h : \u2200 y, dist y x < r \u2192 dist (f y) (f x) \u2264 K * dist y x) :\n    ContinuousAt f x", "start": [768, 1], "end": [777, 7], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.extend_real", "code": "theorem LipschitzOnWith.extend_real [PseudoMetricSpace \u03b1] {f : \u03b1 \u2192 \u211d} {s : Set \u03b1} {K : \u211d\u22650}\n    (hf : LipschitzOnWith K f s) : \u2203 g : \u03b1 \u2192 \u211d, LipschitzWith K g \u2227 EqOn f g s", "start": [780, 1], "end": [813, 26], "kind": "commanddeclaration"}, {"full_name": "LipschitzOnWith.extend_pi", "code": "theorem LipschitzOnWith.extend_pi [PseudoMetricSpace \u03b1] [Fintype \u03b9] {f : \u03b1 \u2192 \u03b9 \u2192 \u211d} {s : Set \u03b1}\n    {K : \u211d\u22650} (hf : LipschitzOnWith K f s) : \u2203 g : \u03b1 \u2192 \u03b9 \u2192 \u211d, LipschitzWith K g \u2227 EqOn f g s", "start": [816, 1], "end": [831, 22], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Opposites.lean", "imports": ["Mathlib/CategoryTheory/Equivalence.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver.Hom.op_inj", "code": "theorem Quiver.Hom.op_inj {X Y : C} :\n    Function.Injective (Quiver.Hom.op : (X \u27f6 Y) \u2192 (Opposite.op Y \u27f6 Opposite.op X))", "start": [37, 1], "end": [39, 30], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.unop_inj", "code": "theorem Quiver.Hom.unop_inj {X Y : C\u1d52\u1d56} :\n    Function.Injective (Quiver.Hom.unop : (X \u27f6 Y) \u2192 (Opposite.unop Y \u27f6 Opposite.unop X))", "start": [42, 1], "end": [44, 41], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.unop_op", "code": "@[simp]\ntheorem Quiver.Hom.unop_op {X Y : C} (f : X \u27f6 Y) : f.op.unop = f", "start": [47, 1], "end": [49, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.op_unop", "code": "@[simp]\ntheorem Quiver.Hom.op_unop {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) : f.unop.op = f", "start": [52, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Category.opposite", "code": "instance Category.opposite : Category.{v\u2081} C\u1d52\u1d56 where\n  comp f g := (g.unop \u226b f.unop).op\n  id X := (\ud835\udfd9 (unop X)).op", "start": [63, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_comp", "code": "@[simp, reassoc]\ntheorem op_comp {X Y Z : C} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).op = g.op \u226b f.op", "start": [72, 1], "end": [74, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_id", "code": "@[simp]\ntheorem op_id {X : C} : (\ud835\udfd9 X).op = \ud835\udfd9 (op X)", "start": [77, 1], "end": [79, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unop_comp", "code": "@[simp, reassoc]\ntheorem unop_comp {X Y Z : C\u1d52\u1d56} {f : X \u27f6 Y} {g : Y \u27f6 Z} : (f \u226b g).unop = g.unop \u226b f.unop", "start": [82, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unop_id", "code": "@[simp]\ntheorem unop_id {X : C\u1d52\u1d56} : (\ud835\udfd9 X).unop = \ud835\udfd9 (unop X)", "start": [87, 1], "end": [89, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unop_id_op", "code": "@[simp]\ntheorem unop_id_op {X : C} : (\ud835\udfd9 (op X)).unop = \ud835\udfd9 X", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_id_unop", "code": "@[simp]\ntheorem op_id_unop {X : C\u1d52\u1d56} : (\ud835\udfd9 (unop X)).op = \ud835\udfd9 X", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unopUnop", "code": "@[simps]\ndef unopUnop : C\u1d52\u1d56\u1d52\u1d56 \u2964 C where\n  obj X := unop (unop X)\n  map f := f.unop.unop", "start": [106, 1], "end": [110, 23], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.opOp", "code": "@[simps]\ndef opOp : C \u2964 C\u1d52\u1d56\u1d52\u1d56 where\n  obj X := op (op X)\n  map f := f.op.op", "start": [113, 1], "end": [117, 19], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.opOpEquivalence", "code": "@[simps]\ndef opOpEquivalence : C\u1d52\u1d56\u1d52\u1d56 \u224c C where\n  functor := unopUnop C\n  inverse := opOp C\n  unitIso := Iso.refl (\ud835\udfed C\u1d52\u1d56\u1d52\u1d56)\n  counitIso := Iso.refl (opOp C \u22d9 unopUnop C)", "start": [120, 1], "end": [126, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_op", "code": "instance isIso_op {X Y : C} (f : X \u27f6 Y) [IsIso f] : IsIso f.op :=\n  \u27e8\u27e8(inv f).op, \u27e8Quiver.Hom.unop_inj (by aesop_cat), Quiver.Hom.unop_inj (by aesop_cat)\u27e9\u27e9\u27e9", "start": [131, 1], "end": [133, 91], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_of_op", "code": "theorem isIso_of_op {X Y : C} (f : X \u27f6 Y) [IsIso f.op] : IsIso f", "start": [136, 1], "end": [140, 82], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_op_iff", "code": "theorem isIso_op_iff {X Y : C} (f : X \u27f6 Y) : IsIso f.op \u2194 IsIso f", "start": [143, 1], "end": [144, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_unop_iff", "code": "theorem isIso_unop_iff {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) : IsIso f.unop \u2194 IsIso f", "start": [147, 1], "end": [148, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isIso_unop", "code": "instance isIso_unop {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) [IsIso f] : IsIso f.unop :=\n  (isIso_unop_iff _).2 inferInstance", "start": [151, 1], "end": [152, 37], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.op_inv", "code": "@[simp]\ntheorem op_inv {X Y : C} (f : X \u27f6 Y) [IsIso f] : (inv f).op = inv f.op", "start": [155, 1], "end": [158, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.unop_inv", "code": "@[simp]\ntheorem unop_inv {X Y : C\u1d52\u1d56} (f : X \u27f6 Y) [IsIso f] : (inv f).unop = inv f.unop", "start": [161, 1], "end": [164, 46], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.op", "code": "@[simps, pp_dot]\nprotected def op (F : C \u2964 D) : C\u1d52\u1d56 \u2964 D\u1d52\u1d56 where\n  obj X := op (F.obj (unop X))\n  map f := (F.map f.unop).op", "start": [173, 1], "end": [178, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.unop", "code": "@[simps]\nprotected def unop (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) : C \u2964 D where\n  obj X := unop (F.obj (op X))\n  map f := (F.map f.op).unop", "start": [181, 1], "end": [187, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.opUnopIso", "code": "@[simps!]\ndef opUnopIso (F : C \u2964 D) : F.op.unop \u2245 F :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [190, 1], "end": [193, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.unopOpIso", "code": "@[simps!]\ndef unopOpIso (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) : F.unop.op \u2245 F :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [196, 1], "end": [199, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.opHom", "code": "@[simps]\ndef opHom : (C \u2964 D)\u1d52\u1d56 \u2964 C\u1d52\u1d56 \u2964 D\u1d52\u1d56 where\n  obj F := (unop F).op\n  map \u03b1 :=\n    { app := fun X => (\u03b1.unop.app (unop X)).op\n      naturality := fun X Y f => Quiver.Hom.unop_inj (\u03b1.unop.naturality f.unop).symm }", "start": [204, 1], "end": [211, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.opInv", "code": "@[simps]\ndef opInv : (C\u1d52\u1d56 \u2964 D\u1d52\u1d56) \u2964 (C \u2964 D)\u1d52\u1d56 where\n  obj F := op F.unop\n  map \u03b1 :=\n    Quiver.Hom.op\n      { app := fun X => (\u03b1.app (op X)).unop\n        naturality := fun X Y f => Quiver.Hom.op_inj <| (\u03b1.naturality f.op).symm }", "start": [214, 1], "end": [222, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftOp", "code": "@[simps, pp_dot]\nprotected def leftOp (F : C \u2964 D\u1d52\u1d56) : C\u1d52\u1d56 \u2964 D where\n  obj X := unop (F.obj (unop X))\n  map f := (F.map f.unop).unop", "start": [227, 1], "end": [234, 31], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightOp", "code": "@[simps, pp_dot]\nprotected def rightOp (F : C\u1d52\u1d56 \u2964 D) : C \u2964 D\u1d52\u1d56 where\n  obj X := op (F.obj (op X))\n  map f := (F.map f.op).op", "start": [237, 1], "end": [244, 27], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightOp_faithful", "code": "instance rightOp_faithful {F : C\u1d52\u1d56 \u2964 D} [Faithful F] : Faithful F.rightOp where\n  map_injective h := Quiver.Hom.op_inj (map_injective F (Quiver.Hom.op_inj h))", "start": [252, 1], "end": [254, 79], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftOp_faithful", "code": "instance leftOp_faithful {F : C \u2964 D\u1d52\u1d56} [Faithful F] : Faithful F.leftOp where\n  map_injective h := Quiver.Hom.unop_inj (map_injective F (Quiver.Hom.unop_inj h))", "start": [257, 1], "end": [259, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftOpRightOpIso", "code": "@[simps!]\ndef leftOpRightOpIso (F : C \u2964 D\u1d52\u1d56) : F.leftOp.rightOp \u2245 F :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [262, 1], "end": [265, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightOpLeftOpIso", "code": "@[simps!]\ndef rightOpLeftOpIso (F : C\u1d52\u1d56 \u2964 D) : F.rightOp.leftOp \u2245 F :=\n  NatIso.ofComponents fun X => Iso.refl _", "start": [268, 1], "end": [271, 42], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.rightOp_leftOp_eq", "code": "theorem rightOp_leftOp_eq (F : C\u1d52\u1d56 \u2964 D) : F.rightOp.leftOp = F", "start": [274, 1], "end": [278, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.op", "code": "@[simps]\nprotected def op (\u03b1 : F \u27f6 G) : G.op \u27f6 F.op where\n  app X := (\u03b1.app (unop X)).op\n  naturality X Y f := Quiver.Hom.unop_inj (by simp)", "start": [293, 1], "end": [297, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.op_id", "code": "@[simp]\ntheorem op_id (F : C \u2964 D) : NatTrans.op (\ud835\udfd9 F) = \ud835\udfd9 F.op", "start": [300, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.unop", "code": "@[simps]\nprotected def unop {F G : C\u1d52\u1d56 \u2964 D\u1d52\u1d56} (\u03b1 : F \u27f6 G) : G.unop \u27f6 F.unop where\n  app X := (\u03b1.app (op X)).unop\n  naturality X Y f := Quiver.Hom.op_inj (by simp)", "start": [305, 1], "end": [309, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.unop_id", "code": "@[simp]\ntheorem unop_id (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) : NatTrans.unop (\ud835\udfd9 F) = \ud835\udfd9 F.unop", "start": [312, 1], "end": [314, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeOp", "code": "@[simps]\nprotected def removeOp (\u03b1 : F.op \u27f6 G.op) : G \u27f6 F where\n  app X := (\u03b1.app (op X)).unop\n  naturality X Y f :=\n    Quiver.Hom.op_inj <| by simpa only [Functor.op_map] using (\u03b1.naturality f.op).symm", "start": [317, 1], "end": [324, 87], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeOp_id", "code": "@[simp]\ntheorem removeOp_id (F : C \u2964 D) : NatTrans.removeOp (\ud835\udfd9 F.op) = \ud835\udfd9 F", "start": [327, 1], "end": [329, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeUnop", "code": "@[simps]\nprotected def removeUnop {F G : C\u1d52\u1d56 \u2964 D\u1d52\u1d56} (\u03b1 : F.unop \u27f6 G.unop) : G \u27f6 F where\n  app X := (\u03b1.app (unop X)).op\n  naturality X Y f :=\n    Quiver.Hom.unop_inj <| by simpa only [Functor.unop_map] using (\u03b1.naturality f.unop).symm", "start": [332, 1], "end": [338, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeUnop_id", "code": "@[simp]\ntheorem removeUnop_id (F : C\u1d52\u1d56 \u2964 D\u1d52\u1d56) : NatTrans.removeUnop (\ud835\udfd9 F.unop) = \ud835\udfd9 F", "start": [341, 1], "end": [343, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftOp", "code": "@[simps]\nprotected def leftOp (\u03b1 : F \u27f6 G) : G.leftOp \u27f6 F.leftOp where\n  app X := (\u03b1.app (unop X)).unop\n  naturality X Y f := Quiver.Hom.op_inj (by simp)", "start": [352, 1], "end": [358, 50], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftOp_id", "code": "@[simp]\ntheorem leftOp_id : NatTrans.leftOp (\ud835\udfd9 F : F \u27f6 F) = \ud835\udfd9 F.leftOp", "start": [361, 1], "end": [363, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.leftOp_comp", "code": "@[simp]\ntheorem leftOp_comp (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) : NatTrans.leftOp (\u03b1 \u226b \u03b2) =\n    NatTrans.leftOp \u03b2 \u226b NatTrans.leftOp \u03b1", "start": [366, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeLeftOp", "code": "@[simps]\nprotected def removeLeftOp (\u03b1 : F.leftOp \u27f6 G.leftOp) : G \u27f6 F where\n  app X := (\u03b1.app (op X)).op\n  naturality X Y f :=\n    Quiver.Hom.unop_inj <| by simpa only [Functor.leftOp_map] using (\u03b1.naturality f.op).symm", "start": [372, 1], "end": [379, 93], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeLeftOp_id", "code": "@[simp]\ntheorem removeLeftOp_id : NatTrans.removeLeftOp (\ud835\udfd9 F.leftOp) = \ud835\udfd9 F", "start": [382, 1], "end": [384, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightOp", "code": "@[simps]\nprotected def rightOp (\u03b1 : F \u27f6 G) : G.rightOp \u27f6 F.rightOp where\n  app X := (\u03b1.app _).op\n  naturality X Y f := Quiver.Hom.unop_inj (by simp)", "start": [393, 1], "end": [399, 52], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightOp_id", "code": "@[simp]\ntheorem rightOp_id : NatTrans.rightOp (\ud835\udfd9 F : F \u27f6 F) = \ud835\udfd9 F.rightOp", "start": [402, 1], "end": [404, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.rightOp_comp", "code": "@[simp]\ntheorem rightOp_comp (\u03b1 : F \u27f6 G) (\u03b2 : G \u27f6 H) : NatTrans.rightOp (\u03b1 \u226b \u03b2) =\n    NatTrans.rightOp \u03b2 \u226b NatTrans.rightOp \u03b1", "start": [407, 1], "end": [410, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeRightOp", "code": "@[simps]\nprotected def removeRightOp (\u03b1 : F.rightOp \u27f6 G.rightOp) : G \u27f6 F where\n  app X := (\u03b1.app X.unop).unop\n  naturality X Y f :=\n    Quiver.Hom.op_inj <| by simpa only [Functor.rightOp_map] using (\u03b1.naturality f.unop).symm", "start": [413, 1], "end": [420, 94], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.removeRightOp_id", "code": "@[simp]\ntheorem removeRightOp_id : NatTrans.removeRightOp (\ud835\udfd9 F.rightOp) = \ud835\udfd9 F", "start": [423, 1], "end": [425, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.op", "code": "@[simps]\nprotected def op (\u03b1 : X \u2245 Y) : op Y \u2245 op X where\n  hom := \u03b1.hom.op\n  inv := \u03b1.inv.op\n  hom_inv_id := Quiver.Hom.unop_inj \u03b1.inv_hom_id\n  inv_hom_id := Quiver.Hom.unop_inj \u03b1.hom_inv_id", "start": [436, 1], "end": [443, 49], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.unop", "code": "@[simps]\ndef unop {X Y : C\u1d52\u1d56} (f : X \u2245 Y) : Y.unop \u2245 X.unop where\n  hom := f.hom.unop\n  inv := f.inv.unop\n  hom_inv_id := by simp only [\u2190 unop_comp, f.inv_hom_id, unop_id]\n  inv_hom_id := by simp only [\u2190 unop_comp, f.hom_inv_id, unop_id]", "start": [446, 1], "end": [452, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.unop_op", "code": "@[simp]\ntheorem unop_op {X Y : C\u1d52\u1d56} (f : X \u2245 Y) : f.unop.op = f", "start": [455, 1], "end": [456, 73], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.op_unop", "code": "@[simp]\ntheorem op_unop {X Y : C} (f : X \u2245 Y) : f.op.unop = f", "start": [459, 1], "end": [460, 71], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Iso.unop_hom_inv_id_app", "code": "@[reassoc (attr := simp)]\nlemma unop_hom_inv_id_app : (e.hom.app X).unop \u226b (e.inv.app X).unop = \ud835\udfd9 _ := by\n  rw [\u2190 unop_comp, inv_hom_id_app, unop_id]", "start": [467, 1], "end": [469, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.Iso.unop_inv_hom_id_app", "code": "@[reassoc (attr := simp)]\nlemma unop_inv_hom_id_app : (e.inv.app X).unop \u226b (e.hom.app X).unop = \ud835\udfd9 _ := by\n  rw [\u2190 unop_comp, hom_inv_id_app, unop_id]", "start": [471, 1], "end": [473, 44], "kind": "mathlibtacticlemma"}, {"full_name": "CategoryTheory.NatIso.op", "code": "@[simps]\nprotected def op (\u03b1 : F \u2245 G) : G.op \u2245 F.op where\n  hom := NatTrans.op \u03b1.hom\n  inv := NatTrans.op \u03b1.inv\n  hom_inv_id := by ext; dsimp; rw [\u2190 op_comp]; rw [\u03b1.inv_hom_id_app]; rfl\n  inv_hom_id := by ext; dsimp; rw [\u2190 op_comp]; rw [\u03b1.hom_inv_id_app]; rfl", "start": [485, 1], "end": [492, 74], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.removeOp", "code": "@[simps]\nprotected def removeOp (\u03b1 : F.op \u2245 G.op) : G \u2245 F where\n  hom := NatTrans.removeOp \u03b1.hom\n  inv := NatTrans.removeOp \u03b1.inv\n  hom_inv_id := by ext; dsimp; rw [\u2190 unop_comp]; rw [\u03b1.inv_hom_id_app]; rfl\n  inv_hom_id := by ext; dsimp; rw [\u2190 unop_comp]; rw [\u03b1.hom_inv_id_app]; rfl", "start": [495, 1], "end": [502, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatIso.unop", "code": "@[simps]\nprotected def unop {F G : C\u1d52\u1d56 \u2964 D\u1d52\u1d56} (\u03b1 : F \u2245 G) : G.unop \u2245 F.unop where\n  hom := NatTrans.unop \u03b1.hom\n  inv := NatTrans.unop \u03b1.inv\n  hom_inv_id := by ext; dsimp; rw [\u2190 unop_comp]; rw [\u03b1.inv_hom_id_app]; rfl\n  inv_hom_id := by ext; dsimp; rw [\u2190 unop_comp]; rw [\u03b1.hom_inv_id_app]; rfl", "start": [505, 1], "end": [512, 76], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.op", "code": "@[simps]\ndef op (e : C \u224c D) : C\u1d52\u1d56 \u224c D\u1d52\u1d56 where\n  functor := e.functor.op\n  inverse := e.inverse.op\n  unitIso := (NatIso.op e.unitIso).symm\n  counitIso := (NatIso.op e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.unop_inj\n    dsimp\n    simp", "start": [521, 1], "end": [532, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Equivalence.unop", "code": "@[simps]\ndef unop (e : C\u1d52\u1d56 \u224c D\u1d52\u1d56) : C \u224c D where\n  functor := e.functor.unop\n  inverse := e.inverse.unop\n  unitIso := (NatIso.unop e.unitIso).symm\n  counitIso := (NatIso.unop e.counitIso).symm\n  functor_unitIso_comp X := by\n    apply Quiver.Hom.op_inj\n    dsimp\n    simp", "start": [535, 1], "end": [546, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.opEquiv", "code": "@[simps]\ndef opEquiv (A B : C\u1d52\u1d56) : (A \u27f6 B) \u2243 (B.unop \u27f6 A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := rfl\n  right_inv _ := rfl", "start": [551, 1], "end": [570, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.subsingleton_of_unop", "code": "instance subsingleton_of_unop (A B : C\u1d52\u1d56) [Subsingleton (unop B \u27f6 unop A)] : Subsingleton (A \u27f6 B) :=\n  (opEquiv A B).subsingleton", "start": [573, 1], "end": [574, 29], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.decidableEqOfUnop", "code": "instance decidableEqOfUnop (A B : C\u1d52\u1d56) [DecidableEq (unop B \u27f6 unop A)] : DecidableEq (A \u27f6 B) :=\n  (opEquiv A B).decidableEq", "start": [577, 1], "end": [578, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.isoOpEquiv", "code": "@[simps]\ndef isoOpEquiv (A B : C\u1d52\u1d56) : (A \u2245 B) \u2243 (B.unop \u2245 A.unop) where\n  toFun f := f.unop\n  invFun g := g.op\n  left_inv _ := by\n    ext\n    rfl\n  right_inv _ := by\n    ext\n    rfl", "start": [581, 1], "end": [597, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.opUnopEquiv", "code": "@[simps]\ndef opUnopEquiv : (C \u2964 D)\u1d52\u1d56 \u224c C\u1d52\u1d56 \u2964 D\u1d52\u1d56 where\n  functor := opHom _ _\n  inverse := opInv _ _\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.opUnopIso.op)\n      (by\n        intro F G f\n        dsimp [opUnopIso]\n        rw [show f = f.unop.op by simp, \u2190 op_comp, \u2190 op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.unopOpIso", "start": [606, 1], "end": [620, 56], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.leftOpRightOpEquiv", "code": "@[simps!]\ndef leftOpRightOpEquiv : (C\u1d52\u1d56 \u2964 D)\u1d52\u1d56 \u224c C \u2964 D\u1d52\u1d56 where\n  functor :=\n    { obj := fun F => F.unop.rightOp\n      map := fun \u03b7 => NatTrans.rightOp \u03b7.unop }\n  inverse :=\n    { obj := fun F => op F.leftOp\n      map := fun \u03b7 => \u03b7.leftOp.op }\n  unitIso :=\n    NatIso.ofComponents (fun F => F.unop.rightOpLeftOpIso.op)\n      (by\n        intro F G \u03b7\n        dsimp\n        rw [show \u03b7 = \u03b7.unop.op by simp, \u2190 op_comp, \u2190 op_comp]\n        congr 1\n        aesop_cat)\n  counitIso := NatIso.ofComponents fun F => F.leftOpRightOpIso", "start": [623, 1], "end": [641, 63], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Logic/Lemmas.lean", "imports": ["Mathlib/Tactic/SplitIfs.lean", "Mathlib/Logic/Basic.lean", "Mathlib/Tactic/Convert.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "HEq.eq", "code": "protected alias \u27e8HEq.eq, Eq.heq\u27e9 := heq_iff_eq", "start": [22, 1], "end": [22, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "Eq.heq", "code": "protected alias \u27e8HEq.eq, Eq.heq\u27e9 := heq_iff_eq", "start": [22, 1], "end": [22, 47], "kind": "stdtacticaliasaliaslr"}, {"full_name": "dite_dite_distrib_left", "code": "theorem dite_dite_distrib_left {a : p \u2192 \u03b1} {b : \u00acp \u2192 q \u2192 \u03b1} {c : \u00acp \u2192 \u00acq \u2192 \u03b1} :\n    (dite p a fun hp \u21a6 dite q (b hp) (c hp)) =\n      dite q (fun hq \u21a6 (dite p a) fun hp \u21a6 b hp hq) fun hq \u21a6 (dite p a) fun hp \u21a6 c hp hq", "start": [28, 1], "end": [31, 20], "kind": "commanddeclaration"}, {"full_name": "dite_dite_distrib_right", "code": "theorem dite_dite_distrib_right {a : p \u2192 q \u2192 \u03b1} {b : p \u2192 \u00acq \u2192 \u03b1} {c : \u00acp \u2192 \u03b1} :\n    dite p (fun hp \u21a6 dite q (a hp) (b hp)) c =\n      dite q (fun hq \u21a6 dite p (fun hp \u21a6 a hp hq) c) fun hq \u21a6 dite p (fun hp \u21a6 b hp hq) c", "start": [34, 1], "end": [37, 20], "kind": "commanddeclaration"}, {"full_name": "ite_dite_distrib_left", "code": "theorem ite_dite_distrib_left {a : \u03b1} {b : q \u2192 \u03b1} {c : \u00acq \u2192 \u03b1} :\n    ite p a (dite q b c) = dite q (fun hq \u21a6 ite p a <| b hq) fun hq \u21a6 ite p a <| c hq", "start": [40, 1], "end": [42, 25], "kind": "commanddeclaration"}, {"full_name": "ite_dite_distrib_right", "code": "theorem ite_dite_distrib_right {a : q \u2192 \u03b1} {b : \u00acq \u2192 \u03b1} {c : \u03b1} :\n    ite p (dite q a b) c = dite q (fun hq \u21a6 ite p (a hq) c) fun hq \u21a6 ite p (b hq) c", "start": [45, 1], "end": [47, 26], "kind": "commanddeclaration"}, {"full_name": "dite_ite_distrib_left", "code": "theorem dite_ite_distrib_left {a : p \u2192 \u03b1} {b : \u00acp \u2192 \u03b1} {c : \u00acp \u2192 \u03b1} :\n    (dite p a fun hp \u21a6 ite q (b hp) (c hp)) = ite q (dite p a b) (dite p a c)", "start": [50, 1], "end": [52, 25], "kind": "commanddeclaration"}, {"full_name": "dite_ite_distrib_right", "code": "theorem dite_ite_distrib_right {a : p \u2192 \u03b1} {b : p \u2192 \u03b1} {c : \u00acp \u2192 \u03b1} :\n    dite p (fun hp \u21a6 ite q (a hp) (b hp)) c = ite q (dite p a c) (dite p b c)", "start": [55, 1], "end": [57, 26], "kind": "commanddeclaration"}, {"full_name": "ite_ite_distrib_left", "code": "theorem ite_ite_distrib_left : ite p a (ite q b c) = ite q (ite p a b) (ite p a c)", "start": [60, 1], "end": [61, 25], "kind": "commanddeclaration"}, {"full_name": "ite_ite_distrib_right", "code": "theorem ite_ite_distrib_right : ite p (ite q a b) c = ite q (ite p a c) (ite p b c)", "start": [64, 1], "end": [65, 26], "kind": "commanddeclaration"}, {"full_name": "Prop.forall", "code": "lemma Prop.forall {f : Prop \u2192 Prop} : (\u2200 p, f p) \u2194 f True \u2227 f False :=\n  \u27e8fun h \u21a6 \u27e8h _, h _\u27e9, by rintro \u27e8h\u2081, h\u2080\u27e9 p; by_cases hp : p <;> simp only [hp] <;> assumption\u27e9", "start": [68, 1], "end": [69, 96], "kind": "mathlibtacticlemma"}, {"full_name": "Prop.exists", "code": "lemma Prop.exists {f : Prop \u2192 Prop} : (\u2203 p, f p) \u2194 f True \u2228 f False :=\n  \u27e8fun \u27e8p, h\u27e9 \u21a6 by refine' (em p).imp _ _ <;> intro H <;> convert h <;> simp [H],\n    by rintro (h | h) <;> exact \u27e8_, h\u27e9\u27e9", "start": [72, 1], "end": [74, 40], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Basic.lean", "imports": ["Mathlib/Algebra/Hom/NonUnitalAlg.lean", "Mathlib/Algebra/Module/BigOperators.lean", "Mathlib/Algebra/BigOperators/Finsupp.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/Algebra/Equiv.lean", "Mathlib/LinearAlgebra/Finsupp.lean"], "premises": [{"full_name": "MonoidAlgebra", "code": "def MonoidAlgebra : Type max u\u2081 u\u2082 :=\n  G \u2192\u2080 k", "start": [75, 1], "end": [80, 9], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.inhabited", "code": "instance MonoidAlgebra.inhabited : Inhabited (MonoidAlgebra k G) :=\n  inferInstanceAs (Inhabited (G \u2192\u2080 k))", "start": [84, 1], "end": [85, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.addCommMonoid", "code": "instance MonoidAlgebra.addCommMonoid : AddCommMonoid (MonoidAlgebra k G) :=\n  inferInstanceAs (AddCommMonoid (G \u2192\u2080 k))", "start": [89, 1], "end": [90, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.instIsCancelAdd", "code": "instance MonoidAlgebra.instIsCancelAdd [IsCancelAdd k] : IsCancelAdd (MonoidAlgebra k G) :=\n  inferInstanceAs (IsCancelAdd (G \u2192\u2080 k))", "start": [93, 1], "end": [94, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.coeFun", "code": "instance MonoidAlgebra.coeFun : CoeFun (MonoidAlgebra k G) fun _ => G \u2192 k :=\n  Finsupp.coeFun", "start": [96, 1], "end": [97, 17], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single", "code": "abbrev single (a : G) (b : k) : MonoidAlgebra k G := Finsupp.single a b", "start": [113, 1], "end": [113, 72], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_zero", "code": "theorem single_zero (a : G) : (single a 0 : MonoidAlgebra k G) = 0", "start": [115, 1], "end": [115, 92], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_add", "code": "theorem single_add (a : G) (b\u2081 b\u2082 : k) : single a (b\u2081 + b\u2082) = single a b\u2081 + single a b\u2082", "start": [117, 1], "end": [118, 29], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.sum_single_index", "code": "@[simp]\ntheorem sum_single_index [AddCommMonoid N] {a : G} {b : k} {h : G \u2192 k \u2192 N} (h_zero : h a 0 = 0) :\n    (single a b).sum h = h a b", "start": [120, 1], "end": [122, 66], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.sum_single", "code": "@[simp]\ntheorem sum_single (f : MonoidAlgebra k G) : f.sum single = f", "start": [124, 1], "end": [126, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_apply", "code": "theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :\n    single a b a' = if a = a' then b else 0", "start": [128, 1], "end": [130, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_eq_zero", "code": "@[simp]\ntheorem single_eq_zero {a : G} {b : k} : single a b = 0 \u2194 b = 0", "start": [132, 1], "end": [133, 90], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomain", "code": "abbrev mapDomain {G' : Type*} (f : G \u2192 G') (v : MonoidAlgebra k G) : MonoidAlgebra k G' :=\n  Finsupp.mapDomain f v", "start": [135, 1], "end": [136, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomain_sum", "code": "theorem mapDomain_sum {k' G' : Type*} [Semiring k'] {f : G \u2192 G'} {s : MonoidAlgebra k' G}\n    {v : G \u2192 k' \u2192 MonoidAlgebra k G} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b)", "start": [138, 1], "end": [141, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNC", "code": "def liftNC (f : k \u2192+ R) (g : G \u2192 R) : MonoidAlgebra k G \u2192+ R :=\n  liftAddHom fun x : G => (AddMonoidHom.mulRight (g x)).comp f", "start": [143, 1], "end": [150, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNC_single", "code": "@[simp]\ntheorem liftNC_single (f : k \u2192+ R) (g : G \u2192 R) (a : G) (b : k) :\n    liftNC f g (single a b) = f b * g a", "start": [153, 1], "end": [156, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul", "code": "instance mul : Mul (MonoidAlgebra k G) :=\n  \u27e8fun f g => f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => single (a\u2081 * a\u2082) (b\u2081 * b\u2082)\u27e9", "start": [165, 1], "end": [169, 80], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_def", "code": "theorem mul_def {f g : MonoidAlgebra k G} :\n    f * g = f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => single (a\u2081 * a\u2082) (b\u2081 * b\u2082)", "start": [172, 1], "end": [174, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring (MonoidAlgebra k G) :=\n  { Finsupp.addCommMonoid with\n    left_distrib := fun f g h => by\n      haveI := Classical.decEq G\n      simp only [mul_def]\n      refine Eq.trans (congr_arg (sum f) (funext\u2082 fun a\u2081 b\u2081 => sum_add_index ?_ ?_)) ?_ <;>\n        simp only [mul_add, mul_zero, single_zero, single_add, forall_true_iff, sum_add]\n    right_distrib := fun f g h => by\n      haveI := Classical.decEq G\n      simp only [mul_def]\n      refine Eq.trans (sum_add_index ?_ ?_) ?_ <;>\n        simp only [add_mul, zero_mul, single_zero, single_add, forall_true_iff, sum_zero, sum_add]\n    zero_mul := fun f => by\n      simp only [mul_def]\n      exact sum_zero_index\n    mul_zero := fun f => by\n      simp only [mul_def]\n      exact Eq.trans (congr_arg (sum f) (funext\u2082 fun a\u2081 b\u2081 => sum_zero_index)) sum_zero }", "start": [177, 1], "end": [195, 90], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNC_mul", "code": "theorem liftNC_mul {g_hom : Type*} [MulHomClass g_hom G R] (f : k \u2192+* R) (g : g_hom)\n    (a b : MonoidAlgebra k G) (h_comm : \u2200 {x y}, y \u2208 a.support \u2192 Commute (f (b x)) (g y)) :\n    liftNC (f : k \u2192+ R) g (a * b) = liftNC (f : k \u2192+ R) g a * liftNC (f : k \u2192+ R) g b", "start": [200, 1], "end": [207, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalSemiring", "code": "instance nonUnitalSemiring : NonUnitalSemiring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalNonAssocSemiring with\n    mul_assoc := fun f g h => by\n      simp only [mul_def]\n      rw [sum_sum_index]; congr; ext a\u2081 b\u2081\n      rw [sum_sum_index, sum_sum_index]; congr; ext a\u2082 b\u2082\n      rw [sum_sum_index, sum_single_index]; congr; ext a\u2083 b\u2083\n      rw [sum_single_index, mul_assoc, mul_assoc]\n      all_goals simp only [single_zero, single_add, forall_true_iff, add_mul,\n        mul_add, zero_mul, mul_zero, sum_zero, sum_add] }", "start": [216, 1], "end": [226, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.one", "code": "instance one : One (MonoidAlgebra k G) :=\n  \u27e8single 1 1\u27e9", "start": [235, 1], "end": [238, 15], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.one_def", "code": "theorem one_def : (1 : MonoidAlgebra k G) = single 1 1", "start": [241, 1], "end": [242, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNC_one", "code": "@[simp]\ntheorem liftNC_one {g_hom : Type*} [OneHomClass g_hom G R] (f : k \u2192+* R) (g : g_hom) :\n    liftNC (f : k \u2192+ R) g 1 = 1", "start": [245, 1], "end": [247, 53], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonAssocSemiring", "code": "instance nonAssocSemiring : NonAssocSemiring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalNonAssocSemiring with\n    natCast := fun n => single 1 n\n    natCast_zero := by simp\n    natCast_succ := fun _ => by simp; rfl\n    one_mul := fun f => by\n      simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_add,\n        one_mul, sum_single]\n    mul_one := fun f => by\n      simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zero,\n        mul_one, sum_single] }", "start": [256, 1], "end": [266, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nat_cast_def", "code": "theorem nat_cast_def (n : \u2115) : (n : MonoidAlgebra k G) = single (1 : G) (n : k)", "start": [269, 1], "end": [270, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.semiring", "code": "instance semiring : Semiring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalSemiring,\n    MonoidAlgebra.nonAssocSemiring with }", "start": [282, 1], "end": [284, 42], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNCRingHom", "code": "def liftNCRingHom (f : k \u2192+* R) (g : G \u2192* R) (h_comm : \u2200 x y, Commute (f x) (g y)) :\n    MonoidAlgebra k G \u2192+* R :=\n  { liftNC (f : k \u2192+ R) g with\n    map_one' := liftNC_one _ _\n    map_mul' := fun _a _b => liftNC_mul _ _ _ _ fun {_ _} _ => h_comm _ _ }", "start": [289, 1], "end": [294, 76], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [CommSemiring k] [CommSemigroup G] :\n    NonUnitalCommSemiring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalSemiring with\n    mul_comm := fun f g => by\n      simp only [mul_def, Finsupp.sum, mul_comm]\n      rw [Finset.sum_comm]\n      simp only [mul_comm] }", "start": [299, 1], "end": [305, 29], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nontrivial", "code": "instance nontrivial [Semiring k] [Nontrivial k] [Nonempty G] : Nontrivial (MonoidAlgebra k G) :=\n  Finsupp.nontrivial", "start": [308, 1], "end": [309, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.commSemiring", "code": "instance commSemiring [CommSemiring k] [CommMonoid G] : CommSemiring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalCommSemiring, MonoidAlgebra.semiring with }", "start": [317, 1], "end": [318, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.unique", "code": "instance unique [Semiring k] [Subsingleton k] : Unique (MonoidAlgebra k G) :=\n  Finsupp.uniqueOfRight", "start": [321, 1], "end": [322, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.addCommGroup", "code": "instance addCommGroup [Ring k] : AddCommGroup (MonoidAlgebra k G) :=\n  Finsupp.addCommGroup", "start": [325, 1], "end": [326, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [Ring k] [Mul G] : NonUnitalNonAssocRing (MonoidAlgebra k G) :=\n  { MonoidAlgebra.addCommGroup, MonoidAlgebra.nonUnitalNonAssocSemiring with }", "start": [329, 1], "end": [330, 79], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalRing", "code": "instance nonUnitalRing [Ring k] [Semigroup G] : NonUnitalRing (MonoidAlgebra k G) :=\n  { MonoidAlgebra.addCommGroup, MonoidAlgebra.nonUnitalSemiring with }", "start": [333, 1], "end": [334, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonAssocRing", "code": "instance nonAssocRing [Ring k] [MulOneClass G] : NonAssocRing (MonoidAlgebra k G) :=\n  { MonoidAlgebra.addCommGroup,\n    MonoidAlgebra.nonAssocSemiring with\n    intCast := fun z => single 1 (z : k)\n    intCast_ofNat := fun n => by simp; rfl\n    intCast_negSucc := fun n => by simp; rfl }", "start": [337, 1], "end": [343, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.int_cast_def", "code": "theorem int_cast_def [Ring k] [MulOneClass G] (z : \u2124) :\n    (z : MonoidAlgebra k G) = single (1 : G) (z : k)", "start": [346, 1], "end": [348, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.ring", "code": "instance ring [Ring k] [Monoid G] : Ring (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonAssocRing, MonoidAlgebra.semiring with }", "start": [351, 1], "end": [352, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalCommRing", "code": "instance nonUnitalCommRing [CommRing k] [CommSemigroup G] :\n    NonUnitalCommRing (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalCommSemiring, MonoidAlgebra.nonUnitalRing with }", "start": [355, 1], "end": [357, 76], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.commRing", "code": "instance commRing [CommRing k] [CommMonoid G] : CommRing (MonoidAlgebra k G) :=\n  { MonoidAlgebra.nonUnitalCommRing, MonoidAlgebra.ring with }", "start": [360, 1], "end": [361, 63], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.smulZeroClass", "code": "instance smulZeroClass [Semiring k] [SMulZeroClass R k] : SMulZeroClass R (MonoidAlgebra k G) :=\n  Finsupp.smulZeroClass", "start": [366, 1], "end": [367, 24], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.distribSMul", "code": "instance distribSMul [Semiring k] [DistribSMul R k] : DistribSMul R (MonoidAlgebra k G) :=\n  Finsupp.distribSMul _ _", "start": [370, 1], "end": [371, 26], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.distribMulAction", "code": "instance distribMulAction [Monoid R] [Semiring k] [DistribMulAction R k] :\n    DistribMulAction R (MonoidAlgebra k G) :=\n  Finsupp.distribMulAction G k", "start": [374, 1], "end": [376, 31], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.module", "code": "instance module [Semiring R] [Semiring k] [Module R k] : Module R (MonoidAlgebra k G) :=\n  Finsupp.module G k", "start": [379, 1], "end": [380, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.faithfulSMul", "code": "instance faithfulSMul [Monoid R] [Semiring k] [DistribMulAction R k] [FaithfulSMul R k]\n    [Nonempty G] : FaithfulSMul R (MonoidAlgebra k G) :=\n  Finsupp.faithfulSMul", "start": [383, 1], "end": [385, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.isScalarTower", "code": "instance isScalarTower [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMul R S]\n    [IsScalarTower R S k] : IsScalarTower R S (MonoidAlgebra k G) :=\n  Finsupp.isScalarTower G k", "start": [388, 1], "end": [390, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.smulCommClass", "code": "instance smulCommClass [Monoid R] [Monoid S] [Semiring k] [DistribMulAction R k]\n    [DistribMulAction S k] [SMulCommClass R S k] : SMulCommClass R S (MonoidAlgebra k G) :=\n  Finsupp.smulCommClass G k", "start": [393, 1], "end": [395, 28], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.isCentralScalar", "code": "instance isCentralScalar [Monoid R] [Semiring k] [DistribMulAction R k] [DistribMulAction R\u1d50\u1d52\u1d56 k]\n    [IsCentralScalar R k] : IsCentralScalar R (MonoidAlgebra k G) :=\n  Finsupp.isCentralScalar G k", "start": [398, 1], "end": [400, 30], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.comapDistribMulActionSelf", "code": "def comapDistribMulActionSelf [Group G] [Semiring k] : DistribMulAction G (MonoidAlgebra k G) :=\n  Finsupp.comapDistribMulAction", "start": [403, 1], "end": [406, 32], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_apply", "code": "theorem mul_apply [DecidableEq G] [Mul G] (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => if a\u2081 * a\u2082 = x then b\u2081 * b\u2082 else 0", "start": [417, 1], "end": [422, 21], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_apply_antidiagonal", "code": "theorem mul_apply_antidiagonal [Mul G] (f g : MonoidAlgebra k G) (x : G) (s : Finset (G \u00d7 G))\n    (hs : \u2200 {p : G \u00d7 G}, p \u2208 s \u2194 p.1 * p.2 = x) : (f * g) x = \u2211 p in s, f p.1 * g p.2", "start": [425, 1], "end": [445, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_mul_single", "code": "@[simp]\ntheorem single_mul_single [Mul G] {a\u2081 a\u2082 : G} {b\u2081 b\u2082 : k} :\n    single a\u2081 b\u2081 * single a\u2082 b\u2082 = single (a\u2081 * a\u2082) (b\u2081 * b\u2082)", "start": [448, 1], "end": [452, 55], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_pow", "code": "@[simp]\ntheorem single_pow [Monoid G] {a : G} {b : k} : \u2200 n : \u2115, single a b ^ n = single (a ^ n) (b ^ n)", "start": [455, 1], "end": [460, 70], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomain_one", "code": "@[simp]\ntheorem mapDomain_one {\u03b1 : Type*} {\u03b2 : Type*} {\u03b1\u2082 : Type*} [Semiring \u03b2] [One \u03b1] [One \u03b1\u2082]\n    {F : Type*} [OneHomClass F \u03b1 \u03b1\u2082] (f : F) :\n    (mapDomain f (1 : MonoidAlgebra \u03b2 \u03b1) : MonoidAlgebra \u03b2 \u03b1\u2082) = (1 : MonoidAlgebra \u03b2 \u03b1\u2082)", "start": [465, 1], "end": [470, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomain_mul", "code": "theorem mapDomain_mul {\u03b1 : Type*} {\u03b2 : Type*} {\u03b1\u2082 : Type*} [Semiring \u03b2] [Mul \u03b1] [Mul \u03b1\u2082]\n    {F : Type*} [MulHomClass F \u03b1 \u03b1\u2082] (f : F) (x y : MonoidAlgebra \u03b2 \u03b1) :\n    mapDomain f (x * y) = mapDomain f x * mapDomain f y", "start": [473, 1], "end": [485, 19], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.ofMagma", "code": "@[simps]\ndef ofMagma [Mul G] : G \u2192\u2099* MonoidAlgebra k G where\n  toFun a := single a 1\n  map_mul' a b := by simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero]", "start": [490, 1], "end": [494, 94], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.of", "code": "@[simps]\ndef of [MulOneClass G] : G \u2192* MonoidAlgebra k G :=\n  { ofMagma k G with\n    toFun := fun a => single a 1\n    map_one' := rfl }", "start": [498, 1], "end": [503, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.smul_of", "code": "theorem smul_of [MulOneClass G] (g : G) (r : k) : r \u2022 of k G g = single g r", "start": [509, 1], "end": [511, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.of_injective", "code": "theorem of_injective [MulOneClass G] [Nontrivial k] :\n    Function.Injective (of k G)", "start": [514, 1], "end": [516, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.singleHom", "code": "@[simps]\ndef singleHom [MulOneClass G] : k \u00d7 G \u2192* MonoidAlgebra k G where\n  toFun a := single a.2 a.1\n  map_one' := rfl\n  map_mul' _a _b := single_mul_single.symm", "start": [519, 1], "end": [528, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_single_apply_aux", "code": "theorem mul_single_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G}\n    (H : \u2200 a, a * x = z \u2194 a = y) : (f * single x r) z = f y * r", "start": [532, 1], "end": [544, 70], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_single_one_apply", "code": "theorem mul_single_one_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) :\n    (HMul.hMul (\u03b2 := MonoidAlgebra k G) f (single 1 r)) x = f x * r", "start": [547, 1], "end": [549, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_single_apply_of_not_exists_mul", "code": "theorem mul_single_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G)\n    (h : \u00ac\u2203 d, g' = d * g) : (x * single g r) g' = 0", "start": [552, 1], "end": [562, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_mul_apply_aux", "code": "theorem single_mul_apply_aux [Mul G] (f : MonoidAlgebra k G) {r : k} {x y z : G}\n    (H : \u2200 a, x * a = y \u2194 a = z) : (single x r * f) y = r * f z", "start": [565, 1], "end": [575, 64], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_one_mul_apply", "code": "theorem single_one_mul_apply [MulOneClass G] (f : MonoidAlgebra k G) (r : k) (x : G) :\n    (single (1 : G) r * f) x = r * f x", "start": [578, 1], "end": [580, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_mul_apply_of_not_exists_mul", "code": "theorem single_mul_apply_of_not_exists_mul [Mul G] (r : k) {g g' : G} (x : MonoidAlgebra k G)\n    (h : \u00ac\u2203 d, g' = g * d) : (single g r * x) g' = 0", "start": [583, 1], "end": [593, 23], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNC_smul", "code": "theorem liftNC_smul [MulOneClass G] {R : Type*} [Semiring R] (f : k \u2192+* R) (g : G \u2192* R) (c : k)\n    (\u03c6 : MonoidAlgebra k G) : liftNC (f : k \u2192+ R) g (c \u2022 \u03c6) = f c * liftNC (f : k \u2192+ R) g \u03c6", "start": [596, 1], "end": [609, 84], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.isScalarTower_self", "code": "instance isScalarTower_self [IsScalarTower R k k] :\n    IsScalarTower R (MonoidAlgebra k G) (MonoidAlgebra k G) :=\n  \u27e8fun t a b => by\n    refine Finsupp.ext fun m => ?_\n    classical\n      simp only [smul_eq_mul, mul_apply]\n      rw [coe_smul]\n      refine Eq.trans (sum_smul_index' (g := a) (b := t) ?_) ?_ <;>\n        simp only [mul_apply, Finsupp.smul_sum, smul_ite, smul_mul_assoc,\n          zero_mul, ite_self, imp_true_iff, sum_zero, Pi.smul_apply, smul_zero]\u27e9", "start": [621, 1], "end": [632, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.smulCommClass_self", "code": "instance smulCommClass_self [SMulCommClass R k k] :\n    SMulCommClass R (MonoidAlgebra k G) (MonoidAlgebra k G) :=\n  \u27e8fun t a b => by\n    refine Finsupp.ext fun m => ?_\n    classical\n      simp only [smul_eq_mul, mul_apply]\n      rw [coe_smul]\n      refine Eq.symm (Eq.trans (congr_arg (sum a)\n        (funext\u2082 fun a\u2081 b\u2081 => sum_smul_index' (g := b) (b := t) ?_)) ?_) <;>\n      simp only [mul_apply, Finsupp.sum, Finset.smul_sum, smul_ite, mul_smul_comm,\n        imp_true_iff, ite_eq_right_iff, Pi.smul_apply, mul_zero, smul_zero]\u27e9", "start": [635, 1], "end": [650, 77], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.smulCommClass_symm_self", "code": "instance smulCommClass_symm_self [SMulCommClass k R k] :\n    SMulCommClass (MonoidAlgebra k G) R (MonoidAlgebra k G) :=\n  \u27e8fun t a b => by\n    haveI := SMulCommClass.symm k R k\n    rw [\u2190 smul_comm]\u27e9", "start": [653, 1], "end": [657, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalAlgHom_ext", "code": "theorem nonUnitalAlgHom_ext [DistribMulAction k A] {\u03c6\u2081 \u03c6\u2082 : MonoidAlgebra k G \u2192\u2099\u2090[k] A}\n    (h : \u2200 x, \u03c6\u2081 (single x 1) = \u03c6\u2082 (single x 1)) : \u03c6\u2081 = \u03c6\u2082", "start": [662, 1], "end": [667, 81], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.nonUnitalAlgHom_ext'", "code": "@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {\u03c6\u2081 \u03c6\u2082 : MonoidAlgebra k G \u2192\u2099\u2090[k] A}\n    (h : \u03c6\u2081.toMulHom.comp (ofMagma k G) = \u03c6\u2082.toMulHom.comp (ofMagma k G)) : \u03c6\u2081 = \u03c6\u2082", "start": [670, 1], "end": [674, 47], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftMagma", "code": "@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (G \u2192\u2099* A) \u2243 (MonoidAlgebra k G \u2192\u2099\u2090[k] A) where\n  toFun f :=\n    { liftAddHom fun x => (smulAddHom k A).flip (f x) with\n      toFun := fun a => a.sum fun m t => t \u2022 f m\n      map_smul' := fun t' a => by\n        dsimp only []\n        rw [Finsupp.smul_sum, sum_smul_index']\n        \u00b7 simp_rw [smul_assoc]\n        \u00b7 intro m\n          exact zero_smul k (f m)\n      map_mul' := fun a\u2081 a\u2082 => by\n        let g : G \u2192 k \u2192 A := fun m t => t \u2022 f m\n        have h\u2081 : \u2200 m, g m 0 = 0 := by\n          intro m\n          exact zero_smul k (f m)\n        have h\u2082 : \u2200 (m) (t\u2081 t\u2082 : k), g m (t\u2081 + t\u2082) = g m t\u2081 + g m t\u2082 := by\n          intros\n          rw [\u2190 add_smul]\n        simp_rw [Finsupp.mul_sum, Finsupp.sum_mul, smul_mul_smul, \u2190 f.map_mul, mul_def,\n          sum_comm a\u2082 a\u2081]\n        rw [sum_sum_index h\u2081 h\u2082]; congr; ext\n        rw [sum_sum_index h\u2081 h\u2082]; congr; ext\n        rw [sum_single_index (h\u2081 _)] }\n  invFun F := F.toMulHom.comp (ofMagma k G)\n  left_inv f := by\n    ext m\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]\n  right_inv F := by\n    refine nonUnitalAlgHom_ext' k (MulHom.ext fun m => ?_)\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]", "start": [677, 1], "end": [717, 37], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_one_comm", "code": "theorem single_one_comm [CommSemiring k] [MulOneClass G] (r : k) (f : MonoidAlgebra k G) :\n    single (1 : G) r * f = f * single (1 : G) r", "start": [731, 1], "end": [735, 60], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.singleOneRingHom", "code": "@[simps]\ndef singleOneRingHom [Semiring k] [MulOneClass G] : k \u2192+* MonoidAlgebra k G :=\n  { Finsupp.singleAddHom 1 with\n    map_one' := rfl\n    map_mul' := fun x y => by\n      simp only [ZeroHom.toFun_eq_coe, AddMonoidHom.toZeroHom_coe, singleAddHom_apply,\n        single_mul_single, mul_one] }", "start": [738, 1], "end": [746, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomainRingHom", "code": "@[simps]\ndef mapDomainRingHom (k : Type*) {H F : Type*} [Semiring k] [Monoid G] [Monoid H]\n    [MonoidHomClass F G H] (f : F) : MonoidAlgebra k G \u2192+* MonoidAlgebra k H :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra k G \u2192+ MonoidAlgebra k H) with\n    map_one' := mapDomain_one f\n    map_mul' := fun x y => mapDomain_mul f x y }", "start": [750, 1], "end": [757, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.ringHom_ext", "code": "theorem ringHom_ext {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G \u2192+* R}\n    (h\u2081 : \u2200 b, f (single 1 b) = g (single 1 b)) (h_of : \u2200 a, f (single a 1) = g (single a 1)) :\n    f = g", "start": [761, 1], "end": [770, 96], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.ringHom_ext'", "code": "@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [MulOneClass G] [Semiring R] {f g : MonoidAlgebra k G \u2192+* R}\n    (h\u2081 : f.comp singleOneRingHom = g.comp singleOneRingHom)\n    (h_of :\n      (f : MonoidAlgebra k G \u2192* R).comp (of k G) = (g : MonoidAlgebra k G \u2192* R).comp (of k G)) :\n    f = g", "start": [773, 1], "end": [783, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.algebra", "code": "instance algebra {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    Algebra k (MonoidAlgebra A G) :=\n  { singleOneRingHom.comp (algebraMap k A) with\n    smul_def' := fun r a => by\n      refine Finsupp.ext fun _ => ?_\n      rw [Finsupp.coe_smul]\n      simp [single_one_mul_apply, Algebra.smul_def, Pi.smul_apply]\n    commutes' := fun r f => by\n      refine Finsupp.ext fun _ => ?_\n      simp [single_one_mul_apply, mul_single_one_apply, Algebra.commutes] }", "start": [786, 1], "end": [801, 76], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.singleOneAlgHom", "code": "@[simps! apply]\ndef singleOneAlgHom {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    A \u2192\u2090[k] MonoidAlgebra A G :=\n  { singleOneRingHom with\n    commutes' := fun r => by\n      refine Finsupp.ext fun _ => ?_\n      simp\n      rfl }", "start": [803, 1], "end": [812, 12], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.coe_algebraMap", "code": "@[simp]\ntheorem coe_algebraMap {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    \u21d1(algebraMap k (MonoidAlgebra A G)) = single 1 \u2218 algebraMap k A", "start": [816, 1], "end": [819, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_eq_algebraMap_mul_of", "code": "theorem single_eq_algebraMap_mul_of [CommSemiring k] [Monoid G] (a : G) (b : k) :\n    single a b = algebraMap k (MonoidAlgebra k G) b * of k G a", "start": [822, 1], "end": [823, 74], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_algebraMap_eq_algebraMap_mul_of", "code": "theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [CommSemiring k] [Semiring A]\n    [Algebra k A] [Monoid G] (a : G) (b : k) :\n    single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b * of A G a", "start": [826, 1], "end": [828, 91], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.induction_on", "code": "theorem induction_on [Semiring k] [Monoid G] {p : MonoidAlgebra k G \u2192 Prop} (f : MonoidAlgebra k G)\n    (hM : \u2200 g, p (of k G g)) (hadd : \u2200 f g : MonoidAlgebra k G, p f \u2192 p g \u2192 p (f + g))\n    (hsmul : \u2200 (r : k) (f), p f \u2192 p (r \u2022 f)) : p f", "start": [831, 1], "end": [838, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.liftNCAlgHom", "code": "def liftNCAlgHom (f : A \u2192\u2090[k] B) (g : G \u2192* B) (h_comm : \u2200 x y, Commute (f x) (g y)) :\n    MonoidAlgebra A G \u2192\u2090[k] B :=\n  { liftNCRingHom (f : A \u2192+* B) g h_comm with\n    commutes' := by simp [liftNCRingHom] }", "start": [849, 1], "end": [853, 43], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.algHom_ext", "code": "theorem algHom_ext \u2983\u03c6\u2081 \u03c6\u2082 : MonoidAlgebra k G \u2192\u2090[k] A\u2984\n    (h : \u2200 x, \u03c6\u2081 (single x 1) = \u03c6\u2082 (single x 1)) : \u03c6\u2081 = \u03c6\u2082", "start": [856, 1], "end": [860, 86], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.algHom_ext'", "code": "@[ext high]\ntheorem algHom_ext' \u2983\u03c6\u2081 \u03c6\u2082 : MonoidAlgebra k G \u2192\u2090[k] A\u2984\n    (h :\n      (\u03c6\u2081 : MonoidAlgebra k G \u2192* A).comp (of k G) = (\u03c6\u2082 : MonoidAlgebra k G \u2192* A).comp (of k G)) :\n    \u03c6\u2081 = \u03c6\u2082", "start": [864, 1], "end": [870, 36], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift", "code": "def lift : (G \u2192* A) \u2243 (MonoidAlgebra k G \u2192\u2090[k] A) where\n  invFun f := (f : MonoidAlgebra k G \u2192* A).comp (of k G)\n  toFun F := liftNCAlgHom (Algebra.ofId k A) F fun _ _ => Algebra.commutes _ _\n  left_inv f := by\n    ext\n    simp [liftNCAlgHom, liftNCRingHom]\n  right_inv F := by\n    ext\n    simp [liftNCAlgHom, liftNCRingHom]", "start": [875, 1], "end": [885, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_apply'", "code": "theorem lift_apply' (F : G \u2192* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => algebraMap k A b * F a", "start": [890, 1], "end": [892, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_apply", "code": "theorem lift_apply (F : G \u2192* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => b \u2022 F a", "start": [895, 1], "end": [896, 94], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_def", "code": "theorem lift_def (F : G \u2192* A) : \u21d1(lift k G A F) = liftNC ((algebraMap k A : k \u2192+* A) : k \u2192+ A) F", "start": [899, 1], "end": [900, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : MonoidAlgebra k G \u2192\u2090[k] A) (x : G) :\n    (lift k G A).symm F x = F (single x 1)", "start": [903, 1], "end": [906, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_of", "code": "theorem lift_of (F : G \u2192* A) (x) : lift k G A F (of k G x) = F x", "start": [909, 1], "end": [910, 59], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_single", "code": "@[simp]\ntheorem lift_single (F : G \u2192* A) (a b) : lift k G A F (single a b) = b \u2022 F a", "start": [913, 1], "end": [915, 71], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_unique'", "code": "theorem lift_unique' (F : MonoidAlgebra k G \u2192\u2090[k] A) :\n    F = lift k G A ((F : MonoidAlgebra k G \u2192* A).comp (of k G))", "start": [918, 1], "end": [920, 41], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.lift_unique", "code": "theorem lift_unique (F : MonoidAlgebra k G \u2192\u2090[k] A) (f : MonoidAlgebra k G) :\n    F f = f.sum fun a b => b \u2022 F (single a 1)", "start": [923, 1], "end": [929, 22], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomainNonUnitalAlgHom", "code": "@[simps apply]\ndef mapDomainNonUnitalAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A]\n    {G H F : Type*} [Mul G] [Mul H] [MulHomClass F G H] (f : F) :\n    MonoidAlgebra A G \u2192\u2099\u2090[k] MonoidAlgebra A H :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra A G \u2192+ MonoidAlgebra A H) with\n    map_mul' := fun x y => mapDomain_mul f x y\n    map_smul' := fun r x => mapDomain_smul r x }", "start": [932, 1], "end": [940, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomain_algebraMap", "code": "theorem mapDomain_algebraMap {F : Type*} [MonoidHomClass F G H] (f : F) (r : k) :\n    mapDomain f (algebraMap k (MonoidAlgebra A G) r) = algebraMap k (MonoidAlgebra A H) r", "start": [945, 1], "end": [947, 65], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mapDomainAlgHom", "code": "@[simps!]\ndef mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] {H F : Type*}\n    [Monoid H] [MonoidHomClass F G H] (f : F) : MonoidAlgebra A G \u2192\u2090[k] MonoidAlgebra A H :=\n  { mapDomainRingHom A f with commutes' := mapDomain_algebraMap A f }", "start": [950, 1], "end": [955, 70], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr", "code": "def domCongr (e : G \u2243* H) : MonoidAlgebra A G \u2243\u2090[k] MonoidAlgebra A H :=\n  AlgEquiv.ofLinearEquiv\n    (Finsupp.domLCongr e : (G \u2192\u2080 A) \u2243\u2097[k] (H \u2192\u2080 A))\n    ((equivMapDomain_eq_mapDomain _ _).trans <| mapDomain_one e)\n    (fun f g => (equivMapDomain_eq_mapDomain _ _).trans <| (mapDomain_mul e f g).trans <|\n        congr_arg\u2082 _ (equivMapDomain_eq_mapDomain _ _).symm (equivMapDomain_eq_mapDomain _ _).symm)", "start": [961, 1], "end": [968, 100], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_toAlgHom", "code": "theorem domCongr_toAlgHom (e : G \u2243* H) : (domCongr k A e).toAlgHom = mapDomainAlgHom k A e", "start": [970, 1], "end": [971, 57], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_apply", "code": "@[simp] theorem domCongr_apply (e : G \u2243* H) (f : MonoidAlgebra A G) (h : H) :\n    domCongr k A e f h = f (e.symm h)", "start": [973, 1], "end": [975, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_support", "code": "@[simp] theorem domCongr_support (e : G \u2243* H) (f : MonoidAlgebra A G) :\n    (domCongr k A e f).support = f.support.map e", "start": [977, 1], "end": [979, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_single", "code": "@[simp] theorem domCongr_single (e : G \u2243* H) (g : G) (a : A) :\n    domCongr k A e (single g a) = single (e g) a", "start": [981, 1], "end": [983, 38], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_refl", "code": "@[simp] theorem domCongr_refl : domCongr k A (MulEquiv.refl G) = AlgEquiv.refl", "start": [985, 1], "end": [986, 49], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.domCongr_symm", "code": "@[simp] theorem domCongr_symm (e : G \u2243* H) : (domCongr k A e).symm = domCongr k A e.symm", "start": [988, 1], "end": [988, 96], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.GroupSmul.linearMap", "code": "def GroupSmul.linearMap [Monoid G] [CommSemiring k] (V : Type u\u2083) [AddCommMonoid V] [Module k V]\n    [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G) : V \u2192\u2097[k] V\n    where\n  toFun v := single g (1 : k) \u2022 v\n  map_add' x y := smul_add (single g (1 : k)) x y\n  map_smul' _c _x := smul_algebra_smul_comm _ _ _", "start": [998, 1], "end": [1004, 50], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.GroupSmul.linearMap_apply", "code": "@[simp]\ntheorem GroupSmul.linearMap_apply [Monoid G] [CommSemiring k] (V : Type u\u2083) [AddCommMonoid V]\n    [Module k V] [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G)\n    (v : V) : (GroupSmul.linearMap k V g) v = single g (1 : k) \u2022 v", "start": [1007, 1], "end": [1011, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.equivariantOfLinearOfComm", "code": "def equivariantOfLinearOfComm : V \u2192\u2097[MonoidAlgebra k G] W where\n  toFun := f\n  map_add' v v' := by simp\n  map_smul' c v := by\n    dsimp only []\n    refine Finsupp.induction c ?_ ?_\n    \u00b7 simp\n    \u00b7 intro g r c' _nm _nz w\n      dsimp at *\n      simp only [add_smul, f.map_add, w, add_left_inj, single_eq_algebraMap_mul_of, \u2190 smul_smul]\n      erw [algebraMap_smul (MonoidAlgebra k G) r, algebraMap_smul (MonoidAlgebra k G) r, f.map_smul,\n        h g v, of_apply]", "start": [1024, 1], "end": [1038, 25], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.equivariantOfLinearOfComm_apply", "code": "@[simp]\ntheorem equivariantOfLinearOfComm_apply (v : V) : (equivariantOfLinearOfComm f h) v = f v", "start": [1041, 1], "end": [1043, 6], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.prod_single", "code": "theorem prod_single [CommSemiring k] [CommMonoid G] {s : Finset \u03b9} {a : \u03b9 \u2192 G} {b : \u03b9 \u2192 k} :\n    (\u220f i in s, single (a i) (b i)) = single (\u220f i in s, a i) (\u220f i in s, b i)", "start": [1058, 1], "end": [1061, 76], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_single_apply", "code": "@[simp]\ntheorem mul_single_apply (f : MonoidAlgebra k G) (r : k) (x y : G) :\n    (f * single x r) y = f (y * x\u207b\u00b9) * r", "start": [1073, 1], "end": [1076, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.single_mul_apply", "code": "@[simp]\ntheorem single_mul_apply (r : k) (x : G) (f : MonoidAlgebra k G) (y : G) :\n    (single x r * f) y = r * f (x\u207b\u00b9 * y)", "start": [1079, 1], "end": [1082, 62], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_apply_left", "code": "theorem mul_apply_left (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = f.sum fun a b => b * g (a\u207b\u00b9 * x)", "start": [1085, 1], "end": [1090, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mul_apply_right", "code": "theorem mul_apply_right (f g : MonoidAlgebra k G) (x : G) :\n    (f * g) x = g.sum fun a b => f (x * a\u207b\u00b9) * b", "start": [1094, 1], "end": [1099, 58], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.opRingEquiv", "code": "@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [Monoid G] :\n    (MonoidAlgebra k G)\u1d50\u1d52\u1d56 \u2243+* MonoidAlgebra k\u1d50\u1d52\u1d56 G\u1d50\u1d52\u1d56 :=\n  { opAddEquiv.symm.trans <|\n      (Finsupp.mapRange.addEquiv (opAddEquiv : k \u2243+ k\u1d50\u1d52\u1d56)).trans <| Finsupp.domCongr opEquiv with\n    map_mul' := by\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [\u2190 AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := (MonoidAlgebra k G)\u1d50\u1d52\u1d56)\n        (S := MonoidAlgebra k\u1d50\u1d52\u1d56 G\u1d50\u1d52\u1d56) _) ?_\n      refine AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i\u2081 => AddMonoidHom.ext fun r\u2081 =>\n        AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i\u2082 => AddMonoidHom.ext fun r\u2082 => ?_\n      simp only [AddMonoidHom.coe_comp, AddEquiv.coe_toAddMonoidHom, opAddEquiv_apply,\n        Function.comp_apply, singleAddHom_apply, AddMonoidHom.compr\u2082_apply, AddMonoidHom.coe_mul,\n        AddMonoidHom.coe_mulLeft, AddMonoidHom.compl\u2082_apply]\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        AddEquiv.trans_apply, AddEquiv.trans_apply, MulOpposite.opAddEquiv_symm_apply]\n      rw [MulOpposite.unop_mul (\u03b1 := MonoidAlgebra k G)]\n      erw [unop_op, unop_op, single_mul_single]\n      simp }", "start": [1110, 1], "end": [1136, 13], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.opRingEquiv_single", "code": "theorem opRingEquiv_single [Monoid G] (r : k) (x : G) :\n    MonoidAlgebra.opRingEquiv (op (single x r)) = single (op x) (op r)", "start": [1142, 1], "end": [1143, 82], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.opRingEquiv_symm_single", "code": "theorem opRingEquiv_symm_single [Monoid G] (r : k\u1d50\u1d52\u1d56) (x : G\u1d50\u1d52\u1d56) :\n    MonoidAlgebra.opRingEquiv.symm (single x r) = op (single x.unop r.unop)", "start": [1147, 1], "end": [1148, 87], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.submoduleOfSmulMem", "code": "def submoduleOfSmulMem (W : Submodule k V) (h : \u2200 (g : G) (v : V), v \u2208 W \u2192 of k G g \u2022 v \u2208 W) :\n    Submodule (MonoidAlgebra k G) V where\n  carrier := W\n  zero_mem' := W.zero_mem'\n  add_mem' := W.add_mem'\n  smul_mem' := by\n    intro f v hv\n    rw [\u2190 Finsupp.sum_single f, Finsupp.sum, Finset.sum_smul]\n    simp_rw [\u2190 smul_of, smul_assoc]\n    exact Submodule.sum_smul_mem W _ fun g _ => h g v hv", "start": [1161, 1], "end": [1172, 57], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra", "code": "def AddMonoidAlgebra :=\n  G \u2192\u2080 k", "start": [1186, 1], "end": [1191, 9], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.inhabited", "code": "instance inhabited : Inhabited k[G] :=\n  inferInstanceAs (Inhabited (G \u2192\u2080 k))", "start": [1200, 1], "end": [1201, 39], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.addCommMonoid", "code": "instance addCommMonoid : AddCommMonoid k[G] :=\n  inferInstanceAs (AddCommMonoid (G \u2192\u2080 k))", "start": [1205, 1], "end": [1206, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.instIsCancelAdd", "code": "instance instIsCancelAdd [IsCancelAdd k] : IsCancelAdd (AddMonoidAlgebra k G) :=\n  inferInstanceAs (IsCancelAdd (G \u2192\u2080 k))", "start": [1209, 1], "end": [1210, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.coeFun", "code": "instance coeFun : CoeFun k[G] fun _ => G \u2192 k :=\n  Finsupp.coeFun", "start": [1212, 1], "end": [1213, 17], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single", "code": "abbrev single (a : G) (b : k) : k[G] := Finsupp.single a b", "start": [1231, 1], "end": [1231, 59], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_zero", "code": "theorem single_zero (a : G) : (single a 0 : k[G]) = 0", "start": [1233, 1], "end": [1233, 79], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_add", "code": "theorem single_add (a : G) (b\u2081 b\u2082 : k) : single a (b\u2081 + b\u2082) = single a b\u2081 + single a b\u2082", "start": [1235, 1], "end": [1236, 29], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sum_single_index", "code": "@[simp]\ntheorem sum_single_index [AddCommMonoid N] {a : G} {b : k} {h : G \u2192 k \u2192 N} (h_zero : h a 0 = 0) :\n    (single a b).sum h = h a b", "start": [1238, 1], "end": [1240, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.sum_single", "code": "@[simp]\ntheorem sum_single (f : k[G]) : f.sum single = f", "start": [1242, 1], "end": [1244, 23], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_apply", "code": "theorem single_apply {a a' : G} {b : k} [Decidable (a = a')] :\n    single a b a' = if a = a' then b else 0", "start": [1246, 1], "end": [1248, 23], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_eq_zero", "code": "@[simp]\ntheorem single_eq_zero {a : G} {b : k} : single a b = 0 \u2194 b = 0", "start": [1250, 1], "end": [1251, 90], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain", "code": "abbrev mapDomain {G' : Type*} (f : G \u2192 G') (v : k[G]) : k[G'] :=\n  Finsupp.mapDomain f v", "start": [1253, 1], "end": [1254, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain_sum", "code": "theorem mapDomain_sum {k' G' : Type*} [Semiring k'] {f : G \u2192 G'} {s : AddMonoidAlgebra k' G}\n    {v : G \u2192 k' \u2192 k[G]} :\n    mapDomain f (s.sum v) = s.sum fun a b => mapDomain f (v a b)", "start": [1256, 1], "end": [1259, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain_single", "code": "theorem mapDomain_single {G' : Type*} {f : G \u2192 G'} {a : G} {b : k} :\n    mapDomain f (single a b) = single (f a) b", "start": [1261, 1], "end": [1263, 27], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNC", "code": "def liftNC (f : k \u2192+ R) (g : Multiplicative G \u2192 R) : k[G] \u2192+ R :=\n  liftAddHom fun x : G => (AddMonoidHom.mulRight (g <| Multiplicative.ofAdd x)).comp f", "start": [1265, 1], "end": [1272, 87], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNC_single", "code": "@[simp]\ntheorem liftNC_single (f : k \u2192+ R) (g : Multiplicative G \u2192 R) (a : G) (b : k) :\n    liftNC f g (single a b) = f b * g (Multiplicative.ofAdd a)", "start": [1275, 1], "end": [1278, 32], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.hasMul", "code": "instance hasMul : Mul k[G] :=\n  \u27e8fun f g => f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => single (a\u2081 + a\u2082) (b\u2081 * b\u2082)\u27e9", "start": [1287, 1], "end": [1292, 80], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_def", "code": "theorem mul_def {f g : k[G]} :\n    f * g = f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => single (a\u2081 + a\u2082) (b\u2081 * b\u2082)", "start": [1295, 1], "end": [1297, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalNonAssocSemiring", "code": "instance nonUnitalNonAssocSemiring : NonUnitalNonAssocSemiring k[G] :=\n  { Finsupp.addCommMonoid with\n    left_distrib := fun f g h => by\n      haveI := Classical.decEq G\n      simp only [mul_def]\n      refine Eq.trans (congr_arg (sum f) (funext\u2082 fun a\u2081 b\u2081 => sum_add_index ?_ ?_)) ?_ <;>\n        simp only [mul_add, mul_zero, single_zero, single_add, forall_true_iff, sum_add]\n    right_distrib := fun f g h => by\n      haveI := Classical.decEq G\n      simp only [mul_def]\n      refine Eq.trans (sum_add_index ?_ ?_) ?_ <;>\n        simp only [add_mul, zero_mul, single_zero, single_add, forall_true_iff, sum_zero, sum_add]\n    zero_mul := fun f => by\n      simp only [mul_def]\n      exact sum_zero_index\n    mul_zero := fun f => by\n      simp only [mul_def]\n      exact Eq.trans (congr_arg (sum f) (funext\u2082 fun a\u2081 b\u2081 => sum_zero_index)) sum_zero\n    nsmul := fun n f => n \u2022 f\n    nsmul_zero := by\n      intros\n      refine Finsupp.ext fun _ => ?_\n      simp [-nsmul_eq_mul, add_smul]\n    nsmul_succ := by\n      intros\n      refine Finsupp.ext fun _ => ?_\n      simp only [fun n => Nat.add_comm n 1]\n      simp [-nsmul_eq_mul, add_smul] }", "start": [1300, 1], "end": [1330, 39], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNC_mul", "code": "theorem liftNC_mul {g_hom : Type*} [MulHomClass g_hom (Multiplicative G) R] (f : k \u2192+* R)\n    (g : g_hom) (a b : k[G])\n    (h_comm : \u2200 {x y}, y \u2208 a.support \u2192 Commute (f (b x)) (g <| Multiplicative.ofAdd y)) :\n    liftNC (f : k \u2192+ R) g (a * b) = liftNC (f : k \u2192+ R) g a * liftNC (f : k \u2192+ R) g b", "start": [1335, 1], "end": [1339, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.one", "code": "instance one : One k[G] :=\n  \u27e8single 0 1\u27e9", "start": [1348, 1], "end": [1351, 15], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.one_def", "code": "theorem one_def : (1 : k[G]) = single 0 1", "start": [1354, 1], "end": [1355, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNC_one", "code": "@[simp]\ntheorem liftNC_one {g_hom : Type*} [OneHomClass g_hom (Multiplicative G) R] (f : k \u2192+* R)\n    (g : g_hom) : liftNC (f : k \u2192+ R) g 1 = 1", "start": [1358, 1], "end": [1361, 37], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalSemiring", "code": "instance nonUnitalSemiring : NonUnitalSemiring k[G] :=\n  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with\n    mul_assoc := fun f g h => by\n      simp only [mul_def]\n      rw [sum_sum_index]; congr; ext a\u2081 b\u2081\n      rw [sum_sum_index, sum_sum_index]; congr; ext a\u2082 b\u2082\n      rw [sum_sum_index, sum_single_index]; congr; ext a\u2083 b\u2083\n      rw [sum_single_index, mul_assoc, add_assoc]\n      all_goals simp only [single_zero, single_add, forall_true_iff, add_mul,\n        mul_add, zero_mul, mul_zero, sum_zero, sum_add] }", "start": [1370, 1], "end": [1380, 58], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonAssocSemiring", "code": "instance nonAssocSemiring : NonAssocSemiring k[G] :=\n  { AddMonoidAlgebra.nonUnitalNonAssocSemiring with\n    natCast := fun n => single 0 n\n    natCast_zero := by simp\n    natCast_succ := fun _ => by simp; rfl\n    one_mul := fun f => by\n      simp only [mul_def, one_def, sum_single_index, zero_mul, single_zero, sum_zero, zero_add,\n        one_mul, sum_single]\n    mul_one := fun f => by\n      simp only [mul_def, one_def, sum_single_index, mul_zero, single_zero, sum_zero, add_zero,\n        mul_one, sum_single] }", "start": [1389, 1], "end": [1399, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nat_cast_def", "code": "theorem nat_cast_def (n : \u2115) : (n : k[G]) = single (0 : G) (n : k)", "start": [1402, 1], "end": [1403, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.smulZeroClass", "code": "instance smulZeroClass [Semiring k] [SMulZeroClass R k] : SMulZeroClass R k[G] :=\n  Finsupp.smulZeroClass", "start": [1413, 1], "end": [1414, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.semiring", "code": "instance semiring : Semiring k[G] :=\n  { AddMonoidAlgebra.nonUnitalSemiring,\n    AddMonoidAlgebra.nonAssocSemiring with }", "start": [1419, 1], "end": [1421, 45], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNCRingHom", "code": "def liftNCRingHom (f : k \u2192+* R) (g : Multiplicative G \u2192* R) (h_comm : \u2200 x y, Commute (f x) (g y)) :\n    k[G] \u2192+* R :=\n  { liftNC (f : k \u2192+ R) g with\n    map_one' := liftNC_one _ _\n    map_mul' := fun _a _b => liftNC_mul _ _ _ _ fun {_ _} _ => h_comm _ _ }", "start": [1426, 1], "end": [1431, 76], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalCommSemiring", "code": "instance nonUnitalCommSemiring [CommSemiring k] [AddCommSemigroup G] :\n    NonUnitalCommSemiring k[G] :=\n  { AddMonoidAlgebra.nonUnitalSemiring with\n    mul_comm := @mul_comm (MonoidAlgebra k <| Multiplicative G) _ }", "start": [1436, 1], "end": [1439, 68], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nontrivial", "code": "instance nontrivial [Semiring k] [Nontrivial k] [Nonempty G] : Nontrivial k[G] :=\n  Finsupp.nontrivial", "start": [1442, 1], "end": [1443, 21], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.commSemiring", "code": "instance commSemiring [CommSemiring k] [AddCommMonoid G] : CommSemiring k[G] :=\n  { AddMonoidAlgebra.nonUnitalCommSemiring, AddMonoidAlgebra.semiring with }", "start": [1451, 1], "end": [1452, 77], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.unique", "code": "instance unique [Semiring k] [Subsingleton k] : Unique k[G] :=\n  Finsupp.uniqueOfRight", "start": [1455, 1], "end": [1456, 24], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.addCommGroup", "code": "instance addCommGroup [Ring k] : AddCommGroup k[G] :=\n  Finsupp.addCommGroup", "start": [1459, 1], "end": [1460, 23], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalNonAssocRing", "code": "instance nonUnitalNonAssocRing [Ring k] [Add G] : NonUnitalNonAssocRing k[G] :=\n  { AddMonoidAlgebra.addCommGroup, AddMonoidAlgebra.nonUnitalNonAssocSemiring with }", "start": [1463, 1], "end": [1464, 85], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalRing", "code": "instance nonUnitalRing [Ring k] [AddSemigroup G] : NonUnitalRing k[G] :=\n  { AddMonoidAlgebra.addCommGroup, AddMonoidAlgebra.nonUnitalSemiring with }", "start": [1467, 1], "end": [1468, 77], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonAssocRing", "code": "instance nonAssocRing [Ring k] [AddZeroClass G] : NonAssocRing k[G] :=\n  { AddMonoidAlgebra.addCommGroup,\n    AddMonoidAlgebra.nonAssocSemiring with\n    intCast := fun z => single 0 (z : k)\n    intCast_ofNat := fun n => by simp; rfl\n    intCast_negSucc := fun n => by simp; rfl }", "start": [1471, 1], "end": [1477, 47], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.int_cast_def", "code": "theorem int_cast_def [Ring k] [AddZeroClass G] (z : \u2124) :\n    (z : k[G]) = single (0 : G) (z : k)", "start": [1480, 1], "end": [1482, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.ring", "code": "instance ring [Ring k] [AddMonoid G] : Ring k[G] :=\n  { AddMonoidAlgebra.nonAssocRing, AddMonoidAlgebra.semiring with }", "start": [1485, 1], "end": [1486, 68], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalCommRing", "code": "instance nonUnitalCommRing [CommRing k] [AddCommSemigroup G] :\n    NonUnitalCommRing k[G] :=\n  { AddMonoidAlgebra.nonUnitalCommSemiring, AddMonoidAlgebra.nonUnitalRing with }", "start": [1489, 1], "end": [1491, 82], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.commRing", "code": "instance commRing [CommRing k] [AddCommMonoid G] : CommRing k[G] :=\n  { AddMonoidAlgebra.nonUnitalCommRing, AddMonoidAlgebra.ring with }", "start": [1494, 1], "end": [1495, 69], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.distribSMul", "code": "instance distribSMul [Semiring k] [DistribSMul R k] : DistribSMul R k[G] :=\n  Finsupp.distribSMul G k", "start": [1500, 1], "end": [1501, 26], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.distribMulAction", "code": "instance distribMulAction [Monoid R] [Semiring k] [DistribMulAction R k] :\n    DistribMulAction R k[G] :=\n  Finsupp.distribMulAction G k", "start": [1504, 1], "end": [1506, 31], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.faithfulSMul", "code": "instance faithfulSMul [Semiring k] [SMulZeroClass R k] [FaithfulSMul R k] [Nonempty G] :\n    FaithfulSMul R k[G] :=\n  Finsupp.faithfulSMul", "start": [1509, 1], "end": [1511, 23], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.module", "code": "instance module [Semiring R] [Semiring k] [Module R k] : Module R k[G] :=\n  Finsupp.module G k", "start": [1514, 1], "end": [1515, 21], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.isScalarTower", "code": "instance isScalarTower [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMul R S]\n    [IsScalarTower R S k] : IsScalarTower R S k[G] :=\n  Finsupp.isScalarTower G k", "start": [1518, 1], "end": [1520, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.smulCommClass", "code": "instance smulCommClass [Semiring k] [SMulZeroClass R k] [SMulZeroClass S k] [SMulCommClass R S k] :\n    SMulCommClass R S k[G] :=\n  Finsupp.smulCommClass G k", "start": [1523, 1], "end": [1525, 28], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.isCentralScalar", "code": "instance isCentralScalar [Semiring k] [SMulZeroClass R k] [SMulZeroClass R\u1d50\u1d52\u1d56 k]\n    [IsCentralScalar R k] : IsCentralScalar R k[G] :=\n  Finsupp.isCentralScalar G k", "start": [1528, 1], "end": [1530, 30], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_apply", "code": "theorem mul_apply [DecidableEq G] [Add G] (f g : k[G]) (x : G) :\n    (f * g) x = f.sum fun a\u2081 b\u2081 => g.sum fun a\u2082 b\u2082 => if a\u2081 + a\u2082 = x then b\u2081 * b\u2082 else 0", "start": [1543, 1], "end": [1545, 60], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_apply_antidiagonal", "code": "theorem mul_apply_antidiagonal [Add G] (f g : k[G]) (x : G) (s : Finset (G \u00d7 G))\n    (hs : \u2200 {p : G \u00d7 G}, p \u2208 s \u2194 p.1 + p.2 = x) : (f * g) x = \u2211 p in s, f p.1 * g p.2", "start": [1548, 1], "end": [1550, 77], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mul_single", "code": "theorem single_mul_single [Add G] {a\u2081 a\u2082 : G} {b\u2081 b\u2082 : k} :\n    single a\u2081 b\u2081 * single a\u2082 b\u2082 = single (a\u2081 + a\u2082) (b\u2081 * b\u2082)", "start": [1553, 1], "end": [1555, 68], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_pow", "code": "theorem single_pow [AddMonoid G] {a : G} {b : k} : \u2200 n : \u2115, single a b ^ n = single (n \u2022 a) (b ^ n)", "start": [1561, 1], "end": [1566, 93], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain_one", "code": "@[simp]\ntheorem mapDomain_one {\u03b1 : Type*} {\u03b2 : Type*} {\u03b1\u2082 : Type*} [Semiring \u03b2] [Zero \u03b1] [Zero \u03b1\u2082]\n    {F : Type*} [ZeroHomClass F \u03b1 \u03b1\u2082] (f : F) :\n    (mapDomain f (1 : AddMonoidAlgebra \u03b2 \u03b1) : AddMonoidAlgebra \u03b2 \u03b1\u2082) =\n      (1 : AddMonoidAlgebra \u03b2 \u03b1\u2082)", "start": [1569, 1], "end": [1575, 51], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain_mul", "code": "theorem mapDomain_mul {\u03b1 : Type*} {\u03b2 : Type*} {\u03b1\u2082 : Type*} [Semiring \u03b2] [Add \u03b1] [Add \u03b1\u2082]\n    {F : Type*} [AddHomClass F \u03b1 \u03b1\u2082] (f : F) (x y : AddMonoidAlgebra \u03b2 \u03b1) :\n    mapDomain f (x * y) = mapDomain f x * mapDomain f y", "start": [1578, 1], "end": [1590, 19], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.ofMagma", "code": "@[simps]\ndef ofMagma [Add G] : Multiplicative G \u2192\u2099* k[G] where\n  toFun a := single a 1\n  map_mul' a b := by simp only [mul_def, mul_one, sum_single_index, single_eq_zero, mul_zero]; rfl", "start": [1597, 1], "end": [1601, 99], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of", "code": "def of [AddZeroClass G] : Multiplicative G \u2192* k[G] :=\n  { ofMagma k G with\n    toFun := fun a => single a 1\n    map_one' := rfl }", "start": [1605, 1], "end": [1609, 22], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'", "code": "def of' : G \u2192 k[G] := fun a => single a 1", "start": [1612, 1], "end": [1613, 42], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of_apply", "code": "@[simp]\ntheorem of_apply [AddZeroClass G] (a : Multiplicative G) :\n    of k G a = single (Multiplicative.toAdd a) 1", "start": [1618, 1], "end": [1621, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_apply", "code": "@[simp]\ntheorem of'_apply (a : G) : of' k G a = single a 1", "start": [1624, 1], "end": [1626, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of'_eq_of", "code": "theorem of'_eq_of [AddZeroClass G] (a : G) : of' k G a = of k G a", "start": [1629, 1], "end": [1630, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.of_injective", "code": "theorem of_injective [Nontrivial k] [AddZeroClass G] : Function.Injective (of k G)", "start": [1633, 1], "end": [1634, 53], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.singleHom", "code": "@[simps]\ndef singleHom [AddZeroClass G] : k \u00d7 Multiplicative G \u2192* k[G] where\n  toFun a := single (Multiplicative.toAdd a.2) a.1\n  map_one' := rfl\n  map_mul' _a _b := single_mul_single.symm", "start": [1637, 1], "end": [1646, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_single_apply_aux", "code": "theorem mul_single_apply_aux [Add G] (f : k[G]) (r : k) (x y z : G)\n    (H : \u2200 a, a + x = z \u2194 a = y) : (f * single x r) z = f y * r", "start": [1650, 1], "end": [1652, 75], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_single_zero_apply", "code": "theorem mul_single_zero_apply [AddZeroClass G] (f : k[G]) (r : k) (x : G) :\n    (f * single (0 : G) r) x = f x * r", "start": [1655, 1], "end": [1657, 59], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_single_apply_of_not_exists_add", "code": "theorem mul_single_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : k[G])\n    (h : \u00ac\u2203 d, g' = d + g) : (x * single g r) g' = 0", "start": [1660, 1], "end": [1662, 87], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mul_apply_aux", "code": "theorem single_mul_apply_aux [Add G] (f : k[G]) (r : k) (x y z : G)\n    (H : \u2200 a, x + a = y \u2194 a = z) : (single x r * f) y = r * f z", "start": [1665, 1], "end": [1667, 75], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_zero_mul_apply", "code": "theorem single_zero_mul_apply [AddZeroClass G] (f : k[G]) (r : k) (x : G) :\n    (single (0 : G) r * f) x = r * f x", "start": [1670, 1], "end": [1672, 59], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mul_apply_of_not_exists_add", "code": "theorem single_mul_apply_of_not_exists_add [Add G] (r : k) {g g' : G} (x : k[G])\n    (h : \u00ac\u2203 d, g' = g + d) : (single g r * x) g' = 0", "start": [1675, 1], "end": [1677, 87], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mul_single_apply", "code": "theorem mul_single_apply [AddGroup G] (f : k[G]) (r : k) (x y : G) :\n    (f * single x r) y = f (y - x) * r", "start": [1680, 1], "end": [1682, 95], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.single_mul_apply", "code": "theorem single_mul_apply [AddGroup G] (r : k) (x : G) (f : k[G]) (y : G) :\n    (single x r * f) y = r * f (-x + y)", "start": [1685, 1], "end": [1687, 67], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNC_smul", "code": "theorem liftNC_smul {R : Type*} [AddZeroClass G] [Semiring R] (f : k \u2192+* R)\n    (g : Multiplicative G \u2192* R) (c : k) (\u03c6 : MonoidAlgebra k G) :\n    liftNC (f : k \u2192+ R) g (c \u2022 \u03c6) = f c * liftNC (f : k \u2192+ R) g \u03c6", "start": [1690, 1], "end": [1693, 66], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.induction_on", "code": "theorem induction_on [AddMonoid G] {p : k[G] \u2192 Prop} (f : k[G])\n    (hM : \u2200 g, p (of k G (Multiplicative.ofAdd g)))\n    (hadd : \u2200 f g : k[G], p f \u2192 p g \u2192 p (f + g))\n    (hsmul : \u2200 (r : k) (f), p f \u2192 p (r \u2022 f)) : p f", "start": [1696, 1], "end": [1704, 54], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomainRingHom", "code": "@[simps]\ndef mapDomainRingHom (k : Type*) [Semiring k] {H F : Type*} [AddMonoid G] [AddMonoid H]\n    [AddMonoidHomClass F G H] (f : F) : k[G] \u2192+* k[H] :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra k G \u2192+ MonoidAlgebra k H) with\n    map_one' := mapDomain_one f\n    map_mul' := fun x y => mapDomain_mul f x y }", "start": [1707, 1], "end": [1714, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toMultiplicative", "code": "protected def AddMonoidAlgebra.toMultiplicative [Semiring k] [Add G] :\n    AddMonoidAlgebra k G \u2243+* MonoidAlgebra k (Multiplicative G) :=\n  { Finsupp.domCongr\n      Multiplicative.ofAdd with\n    toFun := equivMapDomain Multiplicative.ofAdd\n    map_mul' := fun x y => by\n      dsimp only []\n      repeat' rw [equivMapDomain_eq_mapDomain (M := k)]\n      dsimp [Multiplicative.ofAdd]\n      exact MonoidAlgebra.mapDomain_mul (\u03b1 := Multiplicative G) (\u03b2 := k)\n        (MulHom.id (Multiplicative G)) x y }", "start": [1732, 1], "end": [1745, 45], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.toAdditive", "code": "protected def MonoidAlgebra.toAdditive [Semiring k] [Mul G] :\n    MonoidAlgebra k G \u2243+* AddMonoidAlgebra k (Additive G) :=\n  { Finsupp.domCongr Additive.ofMul with\n    toFun := equivMapDomain Additive.ofMul\n    map_mul' := fun x y => by\n      dsimp only []\n      repeat' rw [equivMapDomain_eq_mapDomain (M := k)]\n      dsimp [Additive.ofMul]\n      convert MonoidAlgebra.mapDomain_mul (\u03b2 := k) (MulHom.id G) x y }", "start": [1748, 1], "end": [1758, 71], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.isScalarTower_self", "code": "instance isScalarTower_self [IsScalarTower R k k] :\n    IsScalarTower R k[G] k[G] :=\n  @MonoidAlgebra.isScalarTower_self k (Multiplicative G) R _ _ _ _", "start": [1772, 1], "end": [1774, 67], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.smulCommClass_self", "code": "instance smulCommClass_self [SMulCommClass R k k] :\n    SMulCommClass R k[G] k[G] :=\n  @MonoidAlgebra.smulCommClass_self k (Multiplicative G) R _ _ _ _", "start": [1777, 1], "end": [1782, 67], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.smulCommClass_symm_self", "code": "instance smulCommClass_symm_self [SMulCommClass k R k] :\n    SMulCommClass k[G] R k[G] :=\n  @MonoidAlgebra.smulCommClass_symm_self k (Multiplicative G) R _ _ _ _", "start": [1785, 1], "end": [1787, 72], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalAlgHom_ext", "code": "theorem nonUnitalAlgHom_ext [DistribMulAction k A] {\u03c6\u2081 \u03c6\u2082 : k[G] \u2192\u2099\u2090[k] A}\n    (h : \u2200 x, \u03c6\u2081 (single x 1) = \u03c6\u2082 (single x 1)) : \u03c6\u2081 = \u03c6\u2082", "start": [1792, 1], "end": [1796, 76], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.nonUnitalAlgHom_ext'", "code": "@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {\u03c6\u2081 \u03c6\u2082 : k[G] \u2192\u2099\u2090[k] A}\n    (h : \u03c6\u2081.toMulHom.comp (ofMagma k G) = \u03c6\u2082.toMulHom.comp (ofMagma k G)) : \u03c6\u2081 = \u03c6\u2082", "start": [1799, 1], "end": [1803, 77], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftMagma", "code": "@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (Multiplicative G \u2192\u2099* A) \u2243 (k[G] \u2192\u2099\u2090[k] A) :=\n  { (MonoidAlgebra.liftMagma k : (Multiplicative G \u2192\u2099* A) \u2243 (_ \u2192\u2099\u2090[k] A)) with\n    toFun := fun f =>\n      { (MonoidAlgebra.liftMagma k f : _) with\n        toFun := fun a => sum a fun m t => t \u2022 f (Multiplicative.ofAdd m) }\n    invFun := fun F => F.toMulHom.comp (ofMagma k G) }", "start": [1806, 1], "end": [1816, 55], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.singleZeroRingHom", "code": "@[simps]\ndef singleZeroRingHom [Semiring k] [AddMonoid G] : k \u2192+* k[G] :=\n  { Finsupp.singleAddHom 0 with\n    map_one' := rfl\n    map_mul' := fun x y => by simp only [singleAddHom, single_mul_single, zero_add] }", "start": [1830, 1], "end": [1836, 86], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.ringHom_ext", "code": "theorem ringHom_ext {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : k[G] \u2192+* R}\n    (h\u2080 : \u2200 b, f (single 0 b) = g (single 0 b)) (h_of : \u2200 a, f (single a 1) = g (single a 1)) :\n    f = g", "start": [1840, 1], "end": [1845, 70], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.ringHom_ext'", "code": "@[ext high]\ntheorem ringHom_ext' {R} [Semiring k] [AddMonoid G] [Semiring R] {f g : k[G] \u2192+* R}\n    (h\u2081 : f.comp singleZeroRingHom = g.comp singleZeroRingHom)\n    (h_of : (f : k[G] \u2192* R).comp (of k G) = (g : k[G] \u2192* R).comp (of k G)) :\n    f = g", "start": [1848, 1], "end": [1857, 62], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.opRingEquiv", "code": "@[simps! (config := { simpRhs := true }) apply symm_apply]\nprotected noncomputable def opRingEquiv [AddCommMonoid G] :\n    k[G]\u1d50\u1d52\u1d56 \u2243+* k\u1d50\u1d52\u1d56[G] :=\n  { MulOpposite.opAddEquiv.symm.trans\n      (Finsupp.mapRange.addEquiv (MulOpposite.opAddEquiv : k \u2243+ k\u1d50\u1d52\u1d56)) with\n    map_mul' := by\n      rw [Equiv.toFun_as_coe, AddEquiv.toEquiv_eq_coe]; erw [AddEquiv.coe_toEquiv]\n      rw [\u2190 AddEquiv.coe_toAddMonoidHom]\n      refine Iff.mpr (AddMonoidHom.map_mul_iff (R := k[G]\u1d50\u1d52\u1d56) (S := k\u1d50\u1d52\u1d56[G]) _) ?_\n      refine AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i\u2081 => AddMonoidHom.ext fun r\u2081 =>\n        AddMonoidHom.mul_op_ext _ _ <| addHom_ext' fun i\u2082 => AddMonoidHom.ext fun r\u2082 => ?_\n      dsimp\n      erw [AddEquiv.trans_apply, AddEquiv.trans_apply, AddEquiv.trans_apply,\n        MulOpposite.opAddEquiv_symm_apply]; rw [MulOpposite.unop_mul (\u03b1 := k[G])]\n      dsimp\n      erw [mapRange_single, single_mul_single, mapRange_single, mapRange_single]\n      simp only [mapRange_single, single_mul_single, \u2190 op_mul, add_comm] }", "start": [1866, 1], "end": [1889, 75], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.opRingEquiv_single", "code": "theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\n    AddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r)", "start": [1895, 1], "end": [1896, 80], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.opRingEquiv_symm_single", "code": "theorem opRingEquiv_symm_single [AddCommMonoid G] (r : k\u1d50\u1d52\u1d56) (x : G\u1d50\u1d52\u1d56) :\n    AddMonoidAlgebra.opRingEquiv.symm (single x r) = op (single x r.unop)", "start": [1900, 1], "end": [1901, 85], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.algebra", "code": "instance algebra [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] :\n    Algebra R k[G] :=\n  { singleZeroRingHom.comp (algebraMap R k) with\n    smul_def' := fun r a => by\n      refine Finsupp.ext fun _ => ?_\n      rw [Finsupp.coe_smul]\n      simp [single_zero_mul_apply, Algebra.smul_def, Pi.smul_apply]\n    commutes' := fun r f => by\n      refine Finsupp.ext fun _ => ?_\n      simp [single_zero_mul_apply, mul_single_zero_apply, Algebra.commutes] }", "start": [1906, 1], "end": [1921, 78], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.singleZeroAlgHom", "code": "@[simps! apply]\ndef singleZeroAlgHom [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] : k \u2192\u2090[R] k[G] :=\n  { singleZeroRingHom with\n    commutes' := fun r => by\n      refine Finsupp.ext fun _ => ?_\n      simp\n      rfl }", "start": [1924, 1], "end": [1932, 12], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.coe_algebraMap", "code": "@[simp]\ntheorem coe_algebraMap [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] :\n    (algebraMap R k[G] : R \u2192 k[G]) = single 0 \u2218 algebraMap R k", "start": [1936, 1], "end": [1939, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.liftNCAlgHom", "code": "def liftNCAlgHom (f : A \u2192\u2090[k] B) (g : Multiplicative G \u2192* B) (h_comm : \u2200 x y, Commute (f x) (g y)) :\n    A[G] \u2192\u2090[k] B :=\n  { liftNCRingHom (f : A \u2192+* B) g h_comm with\n    commutes' := by simp [liftNCRingHom] }", "start": [1950, 1], "end": [1954, 43], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.algHom_ext", "code": "theorem algHom_ext \u2983\u03c6\u2081 \u03c6\u2082 : k[G] \u2192\u2090[k] A\u2984\n    (h : \u2200 x, \u03c6\u2081 (single x 1) = \u03c6\u2082 (single x 1)) : \u03c6\u2081 = \u03c6\u2082", "start": [1957, 1], "end": [1961, 65], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.algHom_ext'", "code": "@[ext high]\ntheorem algHom_ext' \u2983\u03c6\u2081 \u03c6\u2082 : k[G] \u2192\u2090[k] A\u2984\n    (h : (\u03c6\u2081 : k[G] \u2192* A).comp (of k G) = (\u03c6\u2082 : k[G] \u2192* A).comp (of k G)) :\n    \u03c6\u2081 = \u03c6\u2082", "start": [1964, 1], "end": [1969, 36], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift", "code": "def lift : (Multiplicative G \u2192* A) \u2243 (k[G] \u2192\u2090[k] A) :=\n  { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ with\n    invFun := fun f => (f : k[G] \u2192* A).comp (of k G)\n    toFun := fun F =>\n      { @MonoidAlgebra.lift k (Multiplicative G) _ _ A _ _ F with\n        toFun := liftNCAlgHom (Algebra.ofId k A) F fun _ _ => Algebra.commutes _ _ } }", "start": [1974, 1], "end": [1981, 87], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_apply'", "code": "theorem lift_apply' (F : Multiplicative G \u2192* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => algebraMap k A b * F (Multiplicative.ofAdd a)", "start": [1986, 1], "end": [1988, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_apply", "code": "theorem lift_apply (F : Multiplicative G \u2192* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => b \u2022 F (Multiplicative.ofAdd a)", "start": [1991, 1], "end": [1993, 44], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_def", "code": "theorem lift_def (F : Multiplicative G \u2192* A) :\n    \u21d1(lift k G A F) = liftNC ((algebraMap k A : k \u2192+* A) : k \u2192+ A) F", "start": [1996, 1], "end": [1998, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_symm_apply", "code": "@[simp]\ntheorem lift_symm_apply (F : k[G] \u2192\u2090[k] A) (x : Multiplicative G) :\n    (lift k G A).symm F x = F (single (Multiplicative.toAdd x) 1)", "start": [2001, 1], "end": [2004, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_of", "code": "theorem lift_of (F : Multiplicative G \u2192* A) (x : Multiplicative G) :\n    lift k G A F (of k G x) = F x", "start": [2007, 1], "end": [2008, 97], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_single", "code": "@[simp]\ntheorem lift_single (F : Multiplicative G \u2192* A) (a b) :\n    lift k G A F (single a b) = b \u2022 F (Multiplicative.ofAdd a)", "start": [2011, 1], "end": [2014, 71], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_unique'", "code": "theorem lift_unique' (F : k[G] \u2192\u2090[k] A) :\n    F = lift k G A ((F : k[G] \u2192* A).comp (of k G))", "start": [2017, 1], "end": [2019, 41], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.lift_unique", "code": "theorem lift_unique (F : k[G] \u2192\u2090[k] A) (f : MonoidAlgebra k G) :\n    F f = f.sum fun a b => b \u2022 F (single a 1)", "start": [2022, 1], "end": [2028, 22], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.algHom_ext_iff", "code": "theorem algHom_ext_iff {\u03c6\u2081 \u03c6\u2082 : k[G] \u2192\u2090[k] A} :\n    (\u2200 x, \u03c6\u2081 (Finsupp.single x 1) = \u03c6\u2082 (Finsupp.single x 1)) \u2194 \u03c6\u2081 = \u03c6\u2082", "start": [2031, 1], "end": [2033, 48], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.prod_single", "code": "theorem prod_single [CommSemiring k] [AddCommMonoid G] {s : Finset \u03b9} {a : \u03b9 \u2192 G} {b : \u03b9 \u2192 k} :\n    (\u220f i in s, single (a i) (b i)) = single (\u2211 i in s, a i) (\u220f i in s, b i)", "start": [2046, 1], "end": [2049, 75], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomain_algebraMap", "code": "theorem mapDomain_algebraMap (A : Type*) {H F : Type*} [CommSemiring k] [Semiring A] [Algebra k A]\n    [AddMonoid G] [AddMonoid H] [AddMonoidHomClass F G H] (f : F) (r : k) :\n    mapDomain f (algebraMap k A[G] r) = algebraMap k A[H] r", "start": [2054, 1], "end": [2057, 98], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomainNonUnitalAlgHom", "code": "@[simps apply]\ndef mapDomainNonUnitalAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A]\n    {G H F : Type*} [Add G] [Add H] [AddHomClass F G H] (f : F) :\n    A[G] \u2192\u2099\u2090[k] A[H] :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra A G \u2192+ MonoidAlgebra A H) with\n    map_mul' := fun x y => mapDomain_mul f x y\n    map_smul' := fun r x => mapDomain_smul r x }", "start": [2060, 1], "end": [2068, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mapDomainAlgHom", "code": "@[simps!]\ndef mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] [AddMonoid G]\n    {H F : Type*} [AddMonoid H] [AddMonoidHomClass F G H] (f : F) :\n    A[G] \u2192\u2090[k] A[H] :=\n  { mapDomainRingHom A f with commutes' := mapDomain_algebraMap A f }", "start": [2072, 1], "end": [2078, 70], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr", "code": "def domCongr (e : G \u2243+ H) : A[G] \u2243\u2090[k] A[H] :=\n  AlgEquiv.ofLinearEquiv\n    (Finsupp.domLCongr e : (G \u2192\u2080 A) \u2243\u2097[k] (H \u2192\u2080 A))\n    ((equivMapDomain_eq_mapDomain _ _).trans <| mapDomain_one e)\n    (fun f g => (equivMapDomain_eq_mapDomain _ _).trans <| (mapDomain_mul e f g).trans <|\n        congr_arg\u2082 _ (equivMapDomain_eq_mapDomain _ _).symm (equivMapDomain_eq_mapDomain _ _).symm)", "start": [2087, 1], "end": [2094, 100], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_toAlgHom", "code": "theorem domCongr_toAlgHom (e : G \u2243+ H) : (domCongr k A e).toAlgHom = mapDomainAlgHom k A e", "start": [2096, 1], "end": [2097, 57], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_apply", "code": "@[simp] theorem domCongr_apply (e : G \u2243+ H) (f : MonoidAlgebra A G) (h : H) :\n    domCongr k A e f h = f (e.symm h)", "start": [2099, 1], "end": [2101, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_support", "code": "@[simp] theorem domCongr_support (e : G \u2243+ H) (f : MonoidAlgebra A G) :\n    (domCongr k A e f).support = f.support.map e", "start": [2103, 1], "end": [2105, 6], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_single", "code": "@[simp] theorem domCongr_single (e : G \u2243+ H) (g : G) (a : A) :\n    domCongr k A e (single g a) = single (e g) a", "start": [2107, 1], "end": [2109, 38], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_refl", "code": "@[simp] theorem domCongr_refl : domCongr k A (AddEquiv.refl G) = AlgEquiv.refl", "start": [2111, 1], "end": [2112, 49], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.domCongr_symm", "code": "@[simp] theorem domCongr_symm (e : G \u2243+ H) : (domCongr k A e).symm = domCongr k A e.symm", "start": [2114, 1], "end": [2114, 96], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.toMultiplicativeAlgEquiv", "code": "def AddMonoidAlgebra.toMultiplicativeAlgEquiv [Semiring k] [Algebra R k] [AddMonoid G] :\n    AddMonoidAlgebra k G \u2243\u2090[R] MonoidAlgebra k (Multiplicative G) :=\n  { AddMonoidAlgebra.toMultiplicative k G with\n    commutes' := fun r => by simp [AddMonoidAlgebra.toMultiplicative] }", "start": [2120, 1], "end": [2125, 72], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.toAdditiveAlgEquiv", "code": "def MonoidAlgebra.toAdditiveAlgEquiv [Semiring k] [Algebra R k] [Monoid G] :\n    MonoidAlgebra k G \u2243\u2090[R] AddMonoidAlgebra k (Additive G) :=\n  { MonoidAlgebra.toAdditive k G with commutes' := fun r => by simp [MonoidAlgebra.toAdditive] }", "start": [2128, 1], "end": [2132, 97], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/Basic.lean", "imports": ["Mathlib/Algebra/AddTorsor.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": []}
{"path": "Mathlib/LinearAlgebra/FreeModule/Basic.lean", "imports": ["Mathlib/LinearAlgebra/TensorProductBasis.lean", "Mathlib/LinearAlgebra/FinsuppVectorSpace.lean", "Mathlib/LinearAlgebra/StdBasis.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Logic/Small/Basic.lean", "Mathlib/LinearAlgebra/DirectSum/Finsupp.lean"], "premises": [{"full_name": "Module.Free", "code": "class Module.Free : Prop where\n  exists_basis : Nonempty <| (I : Type v) \u00d7 Basis I R M", "start": [40, 1], "end": [42, 56], "kind": "commanddeclaration"}, {"full_name": "Module.free_def", "code": "theorem Module.free_def [Small.{w,v} M] :\n    Module.Free R M \u2194 \u2203 I : Type w, Nonempty (Basis I R M)", "start": [50, 1], "end": [58, 85], "kind": "commanddeclaration"}, {"full_name": "Module.free_iff_set", "code": "theorem Module.free_iff_set : Module.Free R M \u2194 \u2203 S : Set M, Nonempty (Basis S R M)", "start": [61, 1], "end": [63, 47], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_basis", "code": "theorem Module.Free.of_basis {\u03b9 : Type w} (b : Basis \u03b9 R M) : Module.Free R M", "start": [68, 1], "end": [69, 58], "kind": "commanddeclaration"}, {"full_name": "Module.Free.ChooseBasisIndex", "code": "def ChooseBasisIndex : Type _ :=\n  ((Module.free_iff_set R M).mp \u2039_\u203a).choose", "start": [82, 1], "end": [85, 44], "kind": "commanddeclaration"}, {"full_name": "Module.Free.chooseBasis", "code": "noncomputable def chooseBasis : Basis (ChooseBasisIndex R M) R M :=\n  ((Module.free_iff_set R M).mp \u2039_\u203a).choose_spec.some", "start": [92, 1], "end": [95, 54], "kind": "commanddeclaration"}, {"full_name": "Module.Free.repr", "code": "noncomputable def repr : M \u2243\u2097[R] ChooseBasisIndex R M \u2192\u2080 R :=\n  (chooseBasis R M).repr", "start": [98, 1], "end": [100, 25], "kind": "commanddeclaration"}, {"full_name": "Module.Free.constr", "code": "noncomputable def constr {S : Type z} [Semiring S] [Module S N] [SMulCommClass R S N] :\n    (ChooseBasisIndex R M \u2192 N) \u2243\u2097[S] M \u2192\u2097[R] N :=\n  Basis.constr (chooseBasis R M) S", "start": [103, 1], "end": [113, 35], "kind": "commanddeclaration"}, {"full_name": "Module.Free.noZeroSMulDivisors", "code": "instance (priority := 100) noZeroSMulDivisors [NoZeroDivisors R] : NoZeroSMulDivisors R M :=\n  let \u27e8\u27e8_, b\u27e9\u27e9 := exists_basis (R := R) (M := M)\n  b.noZeroSMulDivisors", "start": [116, 1], "end": [118, 23], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_equiv", "code": "theorem of_equiv (e : M \u2243\u2097[R] N) : Module.Free R N", "start": [126, 1], "end": [127, 38], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_equiv'", "code": "theorem of_equiv' {P : Type v} [AddCommMonoid P] [Module R P] (_ : Module.Free R P)\n    (e : P \u2243\u2097[R] N) : Module.Free R N", "start": [130, 1], "end": [134, 13], "kind": "commanddeclaration"}, {"full_name": "Module.Free.self", "code": "instance self : Module.Free R R :=\n  of_basis (Basis.singleton Unit R)", "start": [139, 1], "end": [141, 36], "kind": "commanddeclaration"}, {"full_name": "Module.Free.prod", "code": "instance prod [Module.Free R N] : Module.Free R (M \u00d7 N) :=\n  of_basis <| (chooseBasis R M).prod (chooseBasis R N)", "start": [144, 1], "end": [145, 55], "kind": "commanddeclaration"}, {"full_name": "Module.Free.pi", "code": "instance pi (M : \u03b9 \u2192 Type*) [Finite \u03b9] [\u2200 i : \u03b9, AddCommMonoid (M i)] [\u2200 i : \u03b9, Module R (M i)]\n    [\u2200 i : \u03b9, Module.Free R (M i)] : Module.Free R (\u2200 i, M i) :=\n  let \u27e8_\u27e9 := nonempty_fintype \u03b9\n  of_basis <| Pi.basis fun i => chooseBasis R (M i)", "start": [148, 1], "end": [152, 52], "kind": "commanddeclaration"}, {"full_name": "Module.Free.matrix", "code": "instance matrix {m n : Type*} [Finite m] [Finite n] : Module.Free R (Matrix m n M) :=\n  Module.Free.pi R _", "start": [155, 1], "end": [157, 21], "kind": "commanddeclaration"}, {"full_name": "Module.Free.ulift", "code": "instance ulift [Free R M] : Free R (ULift M) := of_equiv ULift.moduleEquiv.symm", "start": [160, 1], "end": [160, 80], "kind": "commanddeclaration"}, {"full_name": "Module.Free.function", "code": "instance function [Finite \u03b9] : Module.Free R (\u03b9 \u2192 M) :=\n  Free.pi _ _", "start": [164, 1], "end": [167, 14], "kind": "commanddeclaration"}, {"full_name": "Module.Free.finsupp", "code": "instance finsupp : Module.Free R (\u03b9 \u2192\u2080 M) :=\n  of_basis (Finsupp.basis fun _ => chooseBasis R M)", "start": [170, 1], "end": [171, 52], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_subsingleton", "code": "instance (priority := 100) of_subsingleton [Subsingleton N] : Module.Free R N :=\n  of_basis.{u,z,z} (Basis.empty N : Basis PEmpty R N)", "start": [176, 1], "end": [177, 54], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_subsingleton'", "code": "instance (priority := 100) of_subsingleton' [Subsingleton R] : Module.Free R N :=\n  letI := Module.subsingleton R N\n  Module.Free.of_subsingleton R N", "start": [180, 1], "end": [182, 34], "kind": "commanddeclaration"}, {"full_name": "Module.Free.dfinsupp", "code": "instance dfinsupp {\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i : \u03b9, AddCommMonoid (M i)]\n    [\u2200 i : \u03b9, Module R (M i)] [\u2200 i : \u03b9, Module.Free R (M i)] : Module.Free R (\u03a0\u2080 i, M i) :=\n  of_basis <| DFinsupp.basis fun i => chooseBasis R (M i)", "start": [185, 1], "end": [187, 58], "kind": "commanddeclaration"}, {"full_name": "Module.Free.directSum", "code": "instance directSum {\u03b9 : Type*} (M : \u03b9 \u2192 Type*) [\u2200 i : \u03b9, AddCommMonoid (M i)]\n    [\u2200 i : \u03b9, Module R (M i)] [\u2200 i : \u03b9, Module.Free R (M i)] : Module.Free R (\u2a01 i, M i) :=\n  Module.Free.dfinsupp R M", "start": [190, 1], "end": [192, 27], "kind": "commanddeclaration"}, {"full_name": "Module.Free.tensor", "code": "instance tensor : Module.Free R (M \u2297[R] N) :=\n  let \u27e8bM\u27e9 := exists_basis (R := R) (M := M)\n  let \u27e8bN\u27e9 := exists_basis (R := R) (M := N)\n  of_basis (bM.2.tensorProduct bN.2)", "start": [203, 1], "end": [206, 37], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/Ideal/Quotient.lean", "imports": ["Mathlib/RingTheory/Ideal/Basic.lean", "Mathlib/LinearAlgebra/Quotient.lean", "Mathlib/Algebra/Ring/Prod.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Tactic/FinCases.lean", "Mathlib/Algebra/Ring/Fin.lean", "Mathlib/RingTheory/Congruence.lean"], "premises": [{"full_name": "Ideal.Quotient.one", "code": "instance one (I : Ideal R) : One (R \u29f8 I) :=\n  \u27e8Submodule.Quotient.mk 1\u27e9", "start": [57, 1], "end": [58, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.ringCon", "code": "protected def ringCon (I : Ideal R) : RingCon R :=\n  { QuotientAddGroup.con I.toAddSubgroup with\n    mul' := fun {a\u2081 b\u2081 a\u2082 b\u2082} h\u2081 h\u2082 => by\n      rw [Submodule.quotientRel_r_def] at h\u2081 h\u2082 \u22a2\n      have F := I.add_mem (I.mul_mem_left a\u2082 h\u2081) (I.mul_mem_right b\u2081 h\u2082)\n      have : a\u2081 * a\u2082 - b\u2081 * b\u2082 = a\u2082 * (a\u2081 - b\u2081) + (a\u2082 - b\u2082) * b\u2081 := by\n        rw [mul_sub, sub_mul, sub_add_sub_cancel, mul_comm, mul_comm b\u2081]\n      rwa [\u2190 this] at F }", "start": [61, 1], "end": [69, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.commRing", "code": "instance commRing (I : Ideal R) : CommRing (R \u29f8 I) :=\n    inferInstanceAs (CommRing (Quotient.ringCon I).Quotient)", "start": [72, 1], "end": [73, 61], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.isScalarTower_right", "code": "instance (priority := 100) isScalarTower_right {\u03b1} [SMul \u03b1 R] [IsScalarTower \u03b1 R R] :\n    IsScalarTower \u03b1 (R \u29f8 I) (R \u29f8 I) :=\n  (Quotient.ringCon I).isScalarTower_right", "start": [80, 1], "end": [82, 43], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.smulCommClass", "code": "instance smulCommClass {\u03b1} [SMul \u03b1 R] [IsScalarTower \u03b1 R R] [SMulCommClass \u03b1 R R] :\n    SMulCommClass \u03b1 (R \u29f8 I) (R \u29f8 I) :=\n  (Quotient.ringCon I).smulCommClass", "start": [85, 1], "end": [87, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.smulCommClass'", "code": "instance smulCommClass' {\u03b1} [SMul \u03b1 R] [IsScalarTower \u03b1 R R] [SMulCommClass R \u03b1 R] :\n    SMulCommClass (R \u29f8 I) \u03b1 (R \u29f8 I) :=\n  (Quotient.ringCon I).smulCommClass'", "start": [90, 1], "end": [92, 38], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk", "code": "def mk (I : Ideal R) : R \u2192+* R \u29f8 I where\n  toFun a := Submodule.Quotient.mk a\n  map_zero' := rfl\n  map_one' := rfl\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl", "start": [95, 1], "end": [101, 22], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.ringHom_ext", "code": "@[ext 1100]\ntheorem ringHom_ext [NonAssocSemiring S] \u2983f g : R \u29f8 I \u2192+* S\u2984 (h : f.comp (mk I) = g.comp (mk I)) :\n    f = g", "start": [107, 1], "end": [114, 76], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.inhabited", "code": "instance inhabited : Inhabited (R \u29f8 I) :=\n  \u27e8mk I 37\u27e9", "start": [117, 1], "end": [118, 12], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.eq", "code": "protected theorem eq : mk I x = mk I y \u2194 x - y \u2208 I", "start": [121, 1], "end": [122, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk_eq_mk", "code": "@[simp]\ntheorem mk_eq_mk (x : R) : (Submodule.Quotient.mk x : R \u29f8 I) = mk I x", "start": [125, 1], "end": [126, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.eq_zero_iff_mem", "code": "theorem eq_zero_iff_mem {I : Ideal R} : mk I a = 0 \u2194 a \u2208 I", "start": [129, 1], "end": [130, 34], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.eq_zero_iff_dvd", "code": "theorem eq_zero_iff_dvd (x y : R) : Ideal.Quotient.mk (Ideal.span ({x} : Set R)) y = 0 \u2194 x \u2223 y", "start": [133, 1], "end": [134, 64], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk_eq_mk_iff_sub_mem", "code": "theorem mk_eq_mk_iff_sub_mem (x y : R) : mk I x = mk I y \u2194 x - y \u2208 I", "start": [137, 1], "end": [138, 47], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.zero_eq_one_iff", "code": "theorem zero_eq_one_iff {I : Ideal R} : (0 : R \u29f8 I) = 1 \u2194 I = \u22a4", "start": [140, 1], "end": [141, 65], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.zero_ne_one_iff", "code": "theorem zero_ne_one_iff {I : Ideal R} : (0 : R \u29f8 I) \u2260 1 \u2194 I \u2260 \u22a4", "start": [144, 1], "end": [145, 28], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.nontrivial", "code": "protected theorem nontrivial {I : Ideal R} (hI : I \u2260 \u22a4) : Nontrivial (R \u29f8 I)", "start": [148, 1], "end": [149, 33], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.subsingleton_iff", "code": "theorem subsingleton_iff {I : Ideal R} : Subsingleton (R \u29f8 I) \u2194 I = \u22a4", "start": [152, 1], "end": [154, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.mk_surjective", "code": "theorem mk_surjective : Function.Surjective (mk I)", "start": [160, 1], "end": [161, 54], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.quotient_ring_saturate", "code": "theorem quotient_ring_saturate (I : Ideal R) (s : Set R) :\n    mk I \u207b\u00b9' (mk I '' s) = \u22c3 x : I, (fun y => x.1 + y) '' s", "start": [167, 1], "end": [175, 94], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.noZeroDivisors", "code": "instance noZeroDivisors (I : Ideal R) [hI : I.IsPrime] : NoZeroDivisors (R \u29f8 I) where\n    eq_zero_or_eq_zero_of_mul_eq_zero {a b} := Quotient.inductionOn\u2082' a b fun {_ _} hab =>\n      (hI.mem_or_mem (eq_zero_iff_mem.1 hab)).elim (Or.inl \u2218 eq_zero_iff_mem.2)\n        (Or.inr \u2218 eq_zero_iff_mem.2)", "start": [178, 1], "end": [181, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.isDomain", "code": "instance isDomain (I : Ideal R) [hI : I.IsPrime] : IsDomain (R \u29f8 I) :=\n  let _ := Quotient.nontrivial hI.1\n  NoZeroDivisors.to_isDomain _", "start": [184, 1], "end": [186, 31], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.isDomain_iff_prime", "code": "theorem isDomain_iff_prime (I : Ideal R) : IsDomain (R \u29f8 I) \u2194 I.IsPrime", "start": [189, 1], "end": [195, 46], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.exists_inv", "code": "theorem exists_inv {I : Ideal R} [hI : I.IsMaximal] :\n    \u2200 {a : R \u29f8 I}, a \u2260 0 \u2192 \u2203 b : R \u29f8 I, a * b = 1", "start": [198, 1], "end": [206, 60], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.groupWithZero", "code": "@[reducible]\nprotected noncomputable def groupWithZero (I : Ideal R) [hI : I.IsMaximal] :\n    GroupWithZero (R \u29f8 I) :=\n  { inv := fun a => if ha : a = 0 then 0 else Classical.choose (exists_inv ha)\n    mul_inv_cancel := fun a (ha : a \u2260 0) =>\n      show a * dite _ _ _ = _ by rw [dif_neg ha]; exact Classical.choose_spec (exists_inv ha)\n    inv_zero := dif_pos rfl }", "start": [211, 1], "end": [221, 30], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.field", "code": "@[reducible]\nprotected noncomputable def field (I : Ideal R) [hI : I.IsMaximal] : Field (R \u29f8 I) :=\n  { Quotient.commRing I, Quotient.groupWithZero I with }", "start": [224, 1], "end": [230, 57], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.maximal_of_isField", "code": "theorem maximal_of_isField (I : Ideal R) (hqf : IsField (R \u29f8 I)) : I.IsMaximal", "start": [233, 1], "end": [243, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.maximal_ideal_iff_isField_quotient", "code": "theorem maximal_ideal_iff_isField_quotient (I : Ideal R) : I.IsMaximal \u2194 IsField (R \u29f8 I)", "start": [246, 1], "end": [251, 26], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift", "code": "def lift (I : Ideal R) (f : R \u2192+* S) (H : \u2200 a : R, a \u2208 I \u2192 f a = 0) : R \u29f8 I \u2192+* S :=\n  { QuotientAddGroup.lift I.toAddSubgroup f.toAddMonoidHom H with\n    map_one' := f.map_one\n    map_mul' := fun a\u2081 a\u2082 => Quotient.inductionOn\u2082' a\u2081 a\u2082 f.map_mul }", "start": [256, 1], "end": [261, 70], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift_mk", "code": "@[simp]\ntheorem lift_mk (I : Ideal R) (f : R \u2192+* S) (H : \u2200 a : R, a \u2208 I \u2192 f a = 0) :\n    lift I f H (mk I a) = f a", "start": [264, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.lift_surjective_of_surjective", "code": "theorem lift_surjective_of_surjective (I : Ideal R) {f : R \u2192+* S} (H : \u2200 a : R, a \u2208 I \u2192 f a = 0)\n    (hf : Function.Surjective f) : Function.Surjective (Ideal.Quotient.lift I f H)", "start": [270, 1], "end": [275, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.factor", "code": "def factor (S T : Ideal R) (H : S \u2264 T) : R \u29f8 S \u2192+* R \u29f8 T :=\n  Ideal.Quotient.lift S (mk T) fun _ hx => eq_zero_iff_mem.2 (H hx)", "start": [278, 1], "end": [282, 68], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.factor_mk", "code": "@[simp]\ntheorem factor_mk (S T : Ideal R) (H : S \u2264 T) (x : R) : factor S T H (mk S x) = mk T x", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.Quotient.factor_comp_mk", "code": "@[simp]\ntheorem factor_comp_mk (S T : Ideal R) (H : S \u2264 T) : (factor S T H).comp (mk S) = mk T", "start": [290, 1], "end": [293, 37], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotEquivOfEq", "code": "def quotEquivOfEq {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) : R \u29f8 I \u2243+* R \u29f8 J :=\n  { Submodule.quotEquivOfEq I J h with\n    map_mul' := by\n      rintro \u27e8x\u27e9 \u27e8y\u27e9\n      rfl }", "start": [298, 1], "end": [306, 12], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotEquivOfEq_mk", "code": "@[simp]\ntheorem quotEquivOfEq_mk {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) (x : R) :\n    quotEquivOfEq h (Ideal.Quotient.mk I x) = Ideal.Quotient.mk J x", "start": [309, 1], "end": [312, 6], "kind": "commanddeclaration"}, {"full_name": "Ideal.quotEquivOfEq_symm", "code": "@[simp]\ntheorem quotEquivOfEq_symm {R : Type*} [CommRing R] {I J : Ideal R} (h : I = J) :\n    (Ideal.quotEquivOfEq h).symm = Ideal.quotEquivOfEq h.symm", "start": [315, 1], "end": [317, 77], "kind": "commanddeclaration"}, {"full_name": "Ideal.modulePi", "code": "instance modulePi : Module (R \u29f8 I) ((\u03b9 \u2192 R) \u29f8 I.pi \u03b9) where\n  smul c m :=\n    Quotient.liftOn\u2082' c m (fun r m => Submodule.Quotient.mk <| r \u2022 m) $ by\n      intro c\u2081 m\u2081 c\u2082 m\u2082 hc hm\n      apply Ideal.Quotient.eq.2\n      rw [Submodule.quotientRel_r_def] at hc hm\n      intro i\n      exact I.mul_sub_mul_mem hc (hm i)\n  one_smul := by\n    rintro \u27e8a\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr with i; exact one_mul (a i)\n  mul_smul := by\n    rintro \u27e8a\u27e9 \u27e8b\u27e9 \u27e8c\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr 1; funext i; exact mul_assoc a b (c i)\n  smul_add := by\n    rintro \u27e8a\u27e9 \u27e8b\u27e9 \u27e8c\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr with i; exact mul_add a (b i) (c i)\n  smul_zero := by\n    rintro \u27e8a\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr with _; exact mul_zero a\n  add_smul := by\n    rintro \u27e8a\u27e9 \u27e8b\u27e9 \u27e8c\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr with i; exact add_mul a b (c i)\n  zero_smul := by\n    rintro \u27e8a\u27e9\n    convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n    congr with i; exact zero_mul (a i)", "start": [324, 1], "end": [356, 39], "kind": "commanddeclaration"}, {"full_name": "Ideal.piQuotEquiv", "code": "noncomputable def piQuotEquiv : ((\u03b9 \u2192 R) \u29f8 I.pi \u03b9) \u2243\u2097[R \u29f8 I] \u03b9 \u2192 (R \u29f8 I) where\n  toFun := fun x \u21a6\n      Quotient.liftOn' x (fun f i => Ideal.Quotient.mk I (f i)) fun a b hab =>\n        funext fun i => (Submodule.Quotient.eq' _).2 (QuotientAddGroup.leftRel_apply.mp hab i)\n  map_add' := by rintro \u27e8_\u27e9 \u27e8_\u27e9; rfl\n  map_smul' := by rintro \u27e8_\u27e9 \u27e8_\u27e9; rfl\n  invFun := fun x \u21a6 Ideal.Quotient.mk (I.pi \u03b9) fun i \u21a6 Quotient.out' (x i)\n  left_inv := by\n    rintro \u27e8x\u27e9\n    exact Ideal.Quotient.eq.2 fun i => Ideal.Quotient.eq.1 (Quotient.out_eq' _)\n  right_inv := by\n    intro x\n    ext i\n    obtain \u27e8_, _\u27e9 := @Quot.exists_rep _ _ (x i)\n    convert Quotient.out_eq' (x i)", "start": [359, 1], "end": [374, 35], "kind": "commanddeclaration"}, {"full_name": "Ideal.map_pi", "code": "theorem map_pi {\u03b9 : Type*} [Finite \u03b9] {\u03b9' : Type w} (x : \u03b9 \u2192 R) (hi : \u2200 i, x i \u2208 I)\n    (f : (\u03b9 \u2192 R) \u2192\u2097[R] \u03b9' \u2192 R) (i : \u03b9') : f x i \u2208 I", "start": [377, 1], "end": [385, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/RingTheory/PrincipalIdealDomain.lean", "imports": ["Mathlib/RingTheory/UniqueFactorizationDomain.lean", "Mathlib/Algebra/EuclideanDomain/Instances.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Submodule.IsPrincipal", "code": "@[mk_iff]\nclass Submodule.IsPrincipal (S : Submodule R M) : Prop where\n  principal' : \u2203 a, S = span R {a}", "start": [50, 1], "end": [53, 35], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.principal", "code": "theorem Submodule.IsPrincipal.principal (S : Submodule R M) [Submodule.IsPrincipal S] :\n    \u2203 a, S = span R {a}", "start": [56, 1], "end": [58, 35], "kind": "commanddeclaration"}, {"full_name": "bot_isPrincipal", "code": "instance bot_isPrincipal : (\u22a5 : Submodule R M).IsPrincipal :=\n  \u27e8\u27e80, by simp\u27e9\u27e9", "start": [61, 1], "end": [62, 17], "kind": "commanddeclaration"}, {"full_name": "top_isPrincipal", "code": "instance top_isPrincipal : (\u22a4 : Submodule R R).IsPrincipal :=\n  \u27e8\u27e81, Ideal.span_singleton_one.symm\u27e9\u27e9", "start": [65, 1], "end": [66, 39], "kind": "commanddeclaration"}, {"full_name": "IsPrincipalIdealRing", "code": "@[mk_iff isPrincipalIdealRing_iff]\nclass IsPrincipalIdealRing (R : Type u) [Ring R] : Prop where\n  principal : \u2200 S : Ideal R, S.IsPrincipal", "start": [71, 1], "end": [74, 43], "kind": "commanddeclaration"}, {"full_name": "DivisionRing.isPrincipalIdealRing", "code": "instance (priority := 100) DivisionRing.isPrincipalIdealRing (K : Type u) [DivisionRing K] :\n    IsPrincipalIdealRing K where\n  principal S := by\n    rcases Ideal.eq_bot_or_top S with (rfl | rfl)\n    apply bot_isPrincipal\n    apply top_isPrincipal", "start": [79, 1], "end": [84, 26], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.generator", "code": "noncomputable def generator (S : Submodule R M) [S.IsPrincipal] : M :=\n  Classical.choose (principal S)", "start": [97, 1], "end": [99, 33], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.span_singleton_generator", "code": "theorem span_singleton_generator (S : Submodule R M) [S.IsPrincipal] : span R {generator S} = S", "start": [102, 1], "end": [103, 48], "kind": "commanddeclaration"}, {"full_name": "Ideal.span_singleton_generator", "code": "theorem _root_.Ideal.span_singleton_generator (I : Ideal R) [I.IsPrincipal] :\n    Ideal.span ({generator I} : Set R) = I", "start": [106, 1], "end": [108, 48], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.generator_mem", "code": "@[simp]\ntheorem generator_mem (S : Submodule R M) [S.IsPrincipal] : generator S \u2208 S", "start": [111, 1], "end": [114, 38], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.mem_iff_eq_smul_generator", "code": "theorem mem_iff_eq_smul_generator (S : Submodule R M) [S.IsPrincipal] {x : M} :\n    x \u2208 S \u2194 \u2203 s : R, x = s \u2022 generator S", "start": [117, 1], "end": [119, 73], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.eq_bot_iff_generator_eq_zero", "code": "theorem eq_bot_iff_generator_eq_zero (S : Submodule R M) [S.IsPrincipal] :\n    S = \u22a5 \u2194 generator S = 0", "start": [122, 1], "end": [123, 94], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.mem_iff_generator_dvd", "code": "theorem mem_iff_generator_dvd (S : Ideal R) [S.IsPrincipal] {x : R} : x \u2208 S \u2194 generator S \u2223 x", "start": [132, 1], "end": [133, 99], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.prime_generator_of_isPrime", "code": "theorem prime_generator_of_isPrime (S : Ideal R) [Submodule.IsPrincipal S] [is_prime : S.IsPrime]\n    (ne_bot : S \u2260 \u22a5) : Prime (generator S)", "start": [136, 1], "end": [140, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.generator_map_dvd_of_mem", "code": "theorem generator_map_dvd_of_mem {N : Submodule R M} (\u03d5 : M \u2192\u2097[R] R) [(N.map \u03d5).IsPrincipal] {x : M}\n    (hx : x \u2208 N) : generator (N.map \u03d5) \u2223 \u03d5 x", "start": [144, 1], "end": [147, 21], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.generator_submoduleImage_dvd_of_mem", "code": "theorem generator_submoduleImage_dvd_of_mem {N O : Submodule R M} (hNO : N \u2264 O) (\u03d5 : O \u2192\u2097[R] R)\n    [(\u03d5.submoduleImage N).IsPrincipal] {x : M} (hx : x \u2208 N) :\n    generator (\u03d5.submoduleImage N) \u2223 \u03d5 \u27e8x, hNO hx\u27e9", "start": [151, 1], "end": [155, 21], "kind": "commanddeclaration"}, {"full_name": "IsPrime.to_maximal_ideal", "code": "theorem to_maximal_ideal [CommRing R] [IsDomain R] [IsPrincipalIdealRing R] {S : Ideal R}\n    [hpi : IsPrime S] (hS : S \u2260 \u22a5) : IsMaximal S", "start": [170, 1], "end": [185, 61], "kind": "commanddeclaration"}, {"full_name": "mod_mem_iff", "code": "theorem mod_mem_iff {S : Ideal R} {x y : R} (hy : y \u2208 S) : x % y \u2208 S \u2194 x \u2208 S", "start": [196, 1], "end": [198, 73], "kind": "commanddeclaration"}, {"full_name": "EuclideanDomain.to_principal_ideal_domain", "code": "instance (priority := 100) EuclideanDomain.to_principal_ideal_domain : IsPrincipalIdealRing R where\n  principal S :=\n    \u27e8if h : { x : R | x \u2208 S \u2227 x \u2260 0 }.Nonempty then\n        have wf : WellFounded (EuclideanDomain.r : R \u2192 R \u2192 Prop) := EuclideanDomain.r_wellFounded\n        have hmin : WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h \u2208 S \u2227\n            WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h \u2260 0 :=\n          WellFounded.min_mem wf { x : R | x \u2208 S \u2227 x \u2260 0 } h\n        \u27e8WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h,\n          Submodule.ext fun x => \u27e8fun hx =>\n            div_add_mod x (WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h) \u25b8\n              (Ideal.mem_span_singleton.2 <| dvd_add (dvd_mul_right _ _) <| by\n                have : x % WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h \u2209\n                    { x : R | x \u2208 S \u2227 x \u2260 0 } :=\n                  fun h\u2081 => WellFounded.not_lt_min wf _ h h\u2081 (mod_lt x hmin.2)\n                have : x % WellFounded.min wf { x : R | x \u2208 S \u2227 x \u2260 0 } h = 0 := by\n                  simp only [not_and_or, Set.mem_setOf_eq, not_ne_iff] at this\n                  exact this.neg_resolve_left <| (mod_mem_iff hmin.1).2 hx\n                simp [*]),\n              fun hx =>\n                let \u27e8y, hy\u27e9 := Ideal.mem_span_singleton.1 hx\n                hy.symm \u25b8 S.mul_mem_right _ hmin.1\u27e9\u27e9\n      else \u27e80, Submodule.ext fun a => by\n            rw [\u2190 @Submodule.bot_coe R R _ _ _, span_eq, Submodule.mem_bot]\n            exact \u27e8fun haS => by_contra fun ha0 => h \u27e8a, \u27e8haS, ha0\u27e9\u27e9,\n              fun h\u2081 => h\u2081.symm \u25b8 S.zero_mem\u27e9\u27e9\u27e9", "start": [202, 1], "end": [226, 48], "kind": "commanddeclaration"}, {"full_name": "IsField.isPrincipalIdealRing", "code": "theorem IsField.isPrincipalIdealRing {R : Type*} [CommRing R] (h : IsField R) :\n    IsPrincipalIdealRing R", "start": [231, 1], "end": [233, 86], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.isNoetherianRing", "code": "instance (priority := 100) isNoetherianRing [Ring R] [IsPrincipalIdealRing R] :\n    IsNoetherianRing R :=\n  isNoetherianRing_iff.2\n    \u27e8fun s : Ideal R => by\n      rcases (IsPrincipalIdealRing.principal s).principal with \u27e8a, rfl\u27e9\n      rw [\u2190 Finset.coe_singleton]\n      exact \u27e8{a}, SetLike.coe_injective rfl\u27e9\u27e9", "start": [241, 1], "end": [247, 46], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.isMaximal_of_irreducible", "code": "theorem isMaximal_of_irreducible [CommRing R] [IsPrincipalIdealRing R] {p : R}\n    (hp : Irreducible p) : Ideal.IsMaximal (span R ({p} : Set R))", "start": [250, 1], "end": [257, 78], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.irreducible_iff_prime", "code": "theorem irreducible_iff_prime {p : R} : Irreducible p \u2194 Prime p", "start": [262, 1], "end": [264, 23], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.associates_irreducible_iff_prime", "code": "theorem associates_irreducible_iff_prime : \u2200 {p : Associates R}, Irreducible p \u2194 Prime p", "start": [267, 1], "end": [268, 87], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.factors", "code": "noncomputable def factors (a : R) : Multiset R :=\n  if h : a = 0 then \u2205 else Classical.choose (WfDvdMonoid.exists_factors a h)", "start": [275, 1], "end": [277, 77], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.factors_spec", "code": "theorem factors_spec (a : R) (h : a \u2260 0) :\n    (\u2200 b \u2208 factors a, Irreducible b) \u2227 Associated (factors a).prod a", "start": [280, 1], "end": [283, 63], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.ne_zero_of_mem_factors", "code": "theorem ne_zero_of_mem_factors {R : Type v} [CommRing R] [IsDomain R] [IsPrincipalIdealRing R]\n    {a b : R} (ha : a \u2260 0) (hb : b \u2208 factors a) : b \u2260 0", "start": [286, 1], "end": [288, 51], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.mem_submonoid_of_factors_subset_of_units_subset", "code": "theorem mem_submonoid_of_factors_subset_of_units_subset (s : Submonoid R) {a : R} (ha : a \u2260 0)\n    (hfac : \u2200 b \u2208 factors a, b \u2208 s) (hunit : \u2200 c : R\u02e3, (c : R) \u2208 s) : a \u2208 s", "start": [291, 1], "end": [295, 53], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.ringHom_mem_submonoid_of_factors_subset_of_units_subset", "code": "theorem ringHom_mem_submonoid_of_factors_subset_of_units_subset {R S : Type*} [CommRing R]\n    [IsDomain R] [IsPrincipalIdealRing R] [Semiring S] (f : R \u2192+* S) (s : Submonoid S) (a : R)\n    (ha : a \u2260 0) (h : \u2200 b \u2208 factors a, f b \u2208 s) (hf : \u2200 c : R\u02e3, f c \u2208 s) : f a \u2208 s", "start": [298, 1], "end": [303, 82], "kind": "commanddeclaration"}, {"full_name": "PrincipalIdealRing.to_uniqueFactorizationMonoid", "code": "instance (priority := 100) to_uniqueFactorizationMonoid : UniqueFactorizationMonoid R :=\n  { (IsNoetherianRing.wfDvdMonoid : WfDvdMonoid R) with\n    irreducible_iff_prime := PrincipalIdealRing.irreducible_iff_prime }", "start": [307, 1], "end": [310, 72], "kind": "commanddeclaration"}, {"full_name": "Submodule.IsPrincipal.of_comap", "code": "theorem Submodule.IsPrincipal.of_comap (f : M \u2192\u2097[R] N) (hf : Function.Surjective f)\n    (S : Submodule R N) [hI : IsPrincipal (S.comap f)] : IsPrincipal S", "start": [325, 1], "end": [329, 51], "kind": "commanddeclaration"}, {"full_name": "Ideal.IsPrincipal.of_comap", "code": "theorem Ideal.IsPrincipal.of_comap (f : R \u2192+* S) (hf : Function.Surjective f) (I : Ideal S)\n    [hI : IsPrincipal (I.comap f)] : IsPrincipal I", "start": [332, 1], "end": [336, 78], "kind": "commanddeclaration"}, {"full_name": "IsPrincipalIdealRing.of_surjective", "code": "theorem IsPrincipalIdealRing.of_surjective [IsPrincipalIdealRing R] (f : R \u2192+* S)\n    (hf : Function.Surjective f) : IsPrincipalIdealRing S", "start": [339, 1], "end": [342, 47], "kind": "commanddeclaration"}, {"full_name": "span_gcd", "code": "theorem span_gcd (x y : R) : span ({gcd x y} : Set R) = span ({x, y} : Set R)", "start": [353, 1], "end": [371, 49], "kind": "commanddeclaration"}, {"full_name": "gcd_dvd_iff_exists", "code": "theorem gcd_dvd_iff_exists (a b : R) {z} : gcd a b \u2223 z \u2194 \u2203 x y, z = a * x + b * y", "start": [374, 1], "end": [376, 30], "kind": "commanddeclaration"}, {"full_name": "exists_gcd_eq_mul_add_mul", "code": "theorem exists_gcd_eq_mul_add_mul (a b : R) : \u2203 x y, gcd a b = a * x + b * y", "start": [379, 1], "end": [381, 28], "kind": "commanddeclaration"}, {"full_name": "gcd_isUnit_iff", "code": "theorem gcd_isUnit_iff (x y : R) : IsUnit (gcd x y) \u2194 IsCoprime x y", "start": [384, 1], "end": [385, 93], "kind": "commanddeclaration"}, {"full_name": "isCoprime_of_dvd", "code": "theorem isCoprime_of_dvd (x y : R) (nonzero : \u00ac(x = 0 \u2227 y = 0))\n    (H : \u2200 z \u2208 nonunits R, z \u2260 0 \u2192 z \u2223 x \u2192 \u00acz \u2223 y) : IsCoprime x y", "start": [389, 1], "end": [394, 28], "kind": "commanddeclaration"}, {"full_name": "dvd_or_coprime", "code": "theorem dvd_or_coprime (x y : R) (h : Irreducible x) : x \u2223 y \u2228 IsCoprime x y", "start": [398, 1], "end": [405, 100], "kind": "commanddeclaration"}, {"full_name": "isCoprime_of_irreducible_dvd", "code": "theorem isCoprime_of_irreducible_dvd {x y : R} (nonzero : \u00ac(x = 0 \u2227 y = 0))\n    (H : \u2200 z : R, Irreducible z \u2192 z \u2223 x \u2192 \u00acz \u2223 y) : IsCoprime x y", "start": [408, 1], "end": [415, 17], "kind": "commanddeclaration"}, {"full_name": "isCoprime_of_prime_dvd", "code": "theorem isCoprime_of_prime_dvd {x y : R} (nonzero : \u00ac(x = 0 \u2227 y = 0))\n    (H : \u2200 z : R, Prime z \u2192 z \u2223 x \u2192 \u00acz \u2223 y) : IsCoprime x y", "start": [418, 1], "end": [420, 92], "kind": "commanddeclaration"}, {"full_name": "Irreducible.coprime_iff_not_dvd", "code": "theorem Irreducible.coprime_iff_not_dvd {p n : R} (pp : Irreducible p) :\n    IsCoprime p n \u2194 \u00acp \u2223 n", "start": [423, 1], "end": [437, 62], "kind": "commanddeclaration"}, {"full_name": "Prime.coprime_iff_not_dvd", "code": "theorem Prime.coprime_iff_not_dvd {p n : R} (pp : Prime p) : IsCoprime p n \u2194 \u00acp \u2223 n", "start": [440, 1], "end": [441, 37], "kind": "commanddeclaration"}, {"full_name": "Irreducible.dvd_iff_not_coprime", "code": "theorem Irreducible.dvd_iff_not_coprime {p n : R} (hp : Irreducible p) : p \u2223 n \u2194 \u00acIsCoprime p n", "start": [444, 1], "end": [445, 40], "kind": "commanddeclaration"}, {"full_name": "Irreducible.coprime_pow_of_not_dvd", "code": "theorem Irreducible.coprime_pow_of_not_dvd {p a : R} (m : \u2115) (hp : Irreducible p) (h : \u00acp \u2223 a) :\n    IsCoprime a (p ^ m)", "start": [448, 1], "end": [450, 46], "kind": "commanddeclaration"}, {"full_name": "Irreducible.coprime_or_dvd", "code": "theorem Irreducible.coprime_or_dvd {p : R} (hp : Irreducible p) (i : R) : IsCoprime p i \u2228 p \u2223 i", "start": [453, 1], "end": [454, 51], "kind": "commanddeclaration"}, {"full_name": "exists_associated_pow_of_mul_eq_pow'", "code": "theorem exists_associated_pow_of_mul_eq_pow' {a b c : R} (hab : IsCoprime a b) {k : \u2115}\n    (h : a * b = c ^ k) : \u2203 d : R, Associated (d ^ k) a", "start": [457, 1], "end": [459, 71], "kind": "commanddeclaration"}, {"full_name": "nonPrincipals", "code": "def nonPrincipals :=\n  { I : Ideal R | \u00acI.IsPrincipal }", "start": [470, 1], "end": [472, 35], "kind": "commanddeclaration"}, {"full_name": "nonPrincipals_def", "code": "theorem nonPrincipals_def {I : Ideal R} : I \u2208 nonPrincipals R \u2194 \u00acI.IsPrincipal", "start": [475, 1], "end": [476, 10], "kind": "commanddeclaration"}, {"full_name": "nonPrincipals_eq_empty_iff", "code": "theorem nonPrincipals_eq_empty_iff : nonPrincipals R = \u2205 \u2194 IsPrincipalIdealRing R", "start": [481, 1], "end": [482, 86], "kind": "commanddeclaration"}, {"full_name": "nonPrincipals_zorn", "code": "theorem nonPrincipals_zorn (c : Set (Ideal R)) (hs : c \u2286 nonPrincipals R)\n    (hchain : IsChain (\u00b7 \u2264 \u00b7) c) {K : Ideal R} (hKmem : K \u2208 c) :\n    \u2203 I \u2208 nonPrincipals R, \u2200 J \u2208 c, J \u2264 I", "start": [485, 1], "end": [498, 22], "kind": "commanddeclaration"}, {"full_name": "IsPrincipalIdealRing.of_prime", "code": "theorem IsPrincipalIdealRing.of_prime (H : \u2200 P : Ideal R, P.IsPrime \u2192 P.IsPrincipal) :\n    IsPrincipalIdealRing R", "start": [501, 1], "end": [545, 99], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/Ordinal.lean", "imports": ["Mathlib/SetTheory/Ordinal/Principal.lean", "Mathlib/Tactic/Linarith.lean", "Mathlib/Order/Bounded.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Finsupp/Multiset.lean"], "premises": [{"full_name": "Cardinal.ord_isLimit", "code": "theorem ord_isLimit {c} (co : \u2135\u2080 \u2264 c) : (ord c).IsLimit", "start": [62, 1], "end": [71, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx.initialSeg", "code": "def alephIdx.initialSeg : @InitialSeg Cardinal Ordinal (\u00b7 < \u00b7) (\u00b7 < \u00b7) :=\n  @RelEmbedding.collapse Cardinal Ordinal (\u00b7 < \u00b7) (\u00b7 < \u00b7) _ Cardinal.ord.orderEmbedding.ltEmbedding", "start": [77, 1], "end": [86, 100], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx", "code": "def alephIdx : Cardinal \u2192 Ordinal :=\n  alephIdx.initialSeg", "start": [89, 1], "end": [95, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx.initialSeg_coe", "code": "@[simp]\ntheorem alephIdx.initialSeg_coe : (alephIdx.initialSeg : Cardinal \u2192 Ordinal) = alephIdx", "start": [98, 1], "end": [100, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx_lt", "code": "@[simp]\ntheorem alephIdx_lt {a b} : alephIdx a < alephIdx b \u2194 a < b", "start": [103, 1], "end": [105, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx_le", "code": "@[simp]\ntheorem alephIdx_le {a b} : alephIdx a \u2264 alephIdx b \u2194 a \u2264 b", "start": [108, 1], "end": [110, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx.init", "code": "theorem alephIdx.init {a b} : b < alephIdx a \u2192 \u2203 c, alephIdx c = b", "start": [113, 1], "end": [114, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx.relIso", "code": "def alephIdx.relIso : @RelIso Cardinal.{u} Ordinal.{u} (\u00b7 < \u00b7) (\u00b7 < \u00b7) :=\n  @RelIso.ofSurjective Cardinal.{u} Ordinal.{u} (\u00b7 < \u00b7) (\u00b7 < \u00b7) alephIdx.initialSeg.{u} <|\n    (InitialSeg.eq_or_principal alephIdx.initialSeg.{u}).resolve_right fun \u27e8o, e\u27e9 => by\n      have : \u2200 c, alephIdx c < o := fun c => (e _).2 \u27e8_, rfl\u27e9\n      refine' Ordinal.inductionOn o _ this; intro \u03b1 r _ h\n      let s := \u2a06 a, invFun alephIdx (Ordinal.typein r a)\n      apply (lt_succ s).not_le\n      have I : Injective.{u+2, u+2} alephIdx := alephIdx.initialSeg.toEmbedding.injective\n      simpa only [typein_enum, leftInverse_invFun I (succ s)] using\n        le_ciSup\n          (Cardinal.bddAbove_range.{u, u} fun a : \u03b1 => invFun alephIdx (Ordinal.typein r a))\n          (Ordinal.enum r _ (h (succ s)))", "start": [117, 1], "end": [135, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx.relIso_coe", "code": "@[simp]\ntheorem alephIdx.relIso_coe : (alephIdx.relIso : Cardinal \u2192 Ordinal) = alephIdx", "start": [138, 1], "end": [140, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.type_cardinal", "code": "@[simp]\ntheorem type_cardinal : @type Cardinal (\u00b7 < \u00b7) _ = Ordinal.univ.{u, u + 1}", "start": [143, 1], "end": [145, 63], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_cardinal", "code": "@[simp]\ntheorem mk_cardinal : #Cardinal = univ.{u, u + 1}", "start": [148, 1], "end": [150, 71], "kind": "commanddeclaration"}, {"full_name": "Cardinal.Aleph'.relIso", "code": "def Aleph'.relIso :=\n  Cardinal.alephIdx.relIso.symm", "start": [153, 1], "end": [160, 32], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'", "code": "def aleph' : Ordinal \u2192 Cardinal :=\n  Aleph'.relIso", "start": [163, 1], "end": [167, 16], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'.relIso_coe", "code": "@[simp]\ntheorem aleph'.relIso_coe : (Aleph'.relIso : Ordinal \u2192 Cardinal) = aleph'", "start": [170, 1], "end": [172, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_lt", "code": "@[simp]\ntheorem aleph'_lt {o\u2081 o\u2082 : Ordinal} : aleph' o\u2081 < aleph' o\u2082 \u2194 o\u2081 < o\u2082", "start": [175, 1], "end": [177, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_le", "code": "@[simp]\ntheorem aleph'_le {o\u2081 o\u2082 : Ordinal} : aleph' o\u2081 \u2264 aleph' o\u2082 \u2194 o\u2081 \u2264 o\u2082", "start": [180, 1], "end": [182, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_alephIdx", "code": "@[simp]\ntheorem aleph'_alephIdx (c : Cardinal) : aleph' c.alephIdx = c", "start": [185, 1], "end": [187, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.alephIdx_aleph'", "code": "@[simp]\ntheorem alephIdx_aleph' (o : Ordinal) : (aleph' o).alephIdx = o", "start": [190, 1], "end": [192, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_zero", "code": "@[simp]\ntheorem aleph'_zero : aleph' 0 = 0", "start": [195, 1], "end": [198, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_succ", "code": "@[simp]\ntheorem aleph'_succ {o : Ordinal} : aleph' (succ o) = succ (aleph' o)", "start": [201, 1], "end": [205, 16], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_nat", "code": "@[simp]\ntheorem aleph'_nat : \u2200 n : \u2115, aleph' n = n", "start": [208, 1], "end": [211, 87], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_le_of_limit", "code": "theorem aleph'_le_of_limit {o : Ordinal} (l : o.IsLimit) {c} :\n    aleph' o \u2264 c \u2194 \u2200 o' < o, aleph' o' \u2264 c", "start": [214, 1], "end": [220, 18], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_limit", "code": "theorem aleph'_limit {o : Ordinal} (ho : o.IsLimit) : aleph' o = \u2a06 a : Iio o, aleph' a", "start": [223, 1], "end": [226, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_omega", "code": "@[simp]\ntheorem aleph'_omega : aleph' \u03c9 = \u2135\u2080", "start": [229, 1], "end": [233, 90], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'Equiv", "code": "@[simp]\ndef aleph'Equiv : Ordinal \u2243 Cardinal :=\n  \u27e8aleph', alephIdx, alephIdx_aleph', aleph'_alephIdx\u27e9", "start": [236, 1], "end": [239, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph", "code": "def aleph (o : Ordinal) : Cardinal :=\n  aleph' (\u03c9 + o)", "start": [242, 1], "end": [246, 17], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_lt", "code": "@[simp]\ntheorem aleph_lt {o\u2081 o\u2082 : Ordinal} : aleph o\u2081 < aleph o\u2082 \u2194 o\u2081 < o\u2082", "start": [249, 1], "end": [251, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_le", "code": "@[simp]\ntheorem aleph_le {o\u2081 o\u2082 : Ordinal} : aleph o\u2081 \u2264 aleph o\u2082 \u2194 o\u2081 \u2264 o\u2082", "start": [254, 1], "end": [256, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.max_aleph_eq", "code": "@[simp]\ntheorem max_aleph_eq (o\u2081 o\u2082 : Ordinal) : max (aleph o\u2081) (aleph o\u2082) = aleph (max o\u2081 o\u2082)", "start": [259, 1], "end": [263, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_succ", "code": "@[simp]\ntheorem aleph_succ {o : Ordinal} : aleph (succ o) = succ (aleph o)", "start": [266, 1], "end": [268, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_zero", "code": "@[simp]\ntheorem aleph_zero : aleph 0 = \u2135\u2080", "start": [271, 1], "end": [272, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_limit", "code": "theorem aleph_limit {o : Ordinal} (ho : o.IsLimit) : aleph o = \u2a06 a : Iio o, aleph a", "start": [275, 1], "end": [285, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_aleph'", "code": "theorem aleph0_le_aleph' {o : Ordinal} : \u2135\u2080 \u2264 aleph' o \u2194 \u03c9 \u2264 o", "start": [288, 1], "end": [288, 100], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_aleph", "code": "theorem aleph0_le_aleph (o : Ordinal) : \u2135\u2080 \u2264 aleph o", "start": [291, 1], "end": [293, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_pos", "code": "theorem aleph'_pos {o : Ordinal} (ho : 0 < o) : 0 < aleph' o", "start": [296, 1], "end": [296, 98], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_pos", "code": "theorem aleph_pos (o : Ordinal) : 0 < aleph o", "start": [299, 1], "end": [300, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_toNat", "code": "@[simp]\ntheorem aleph_toNat (o : Ordinal) : toNat (aleph o) = 0", "start": [303, 1], "end": [305, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_toPartENat", "code": "@[simp]\ntheorem aleph_toPartENat (o : Ordinal) : toPartENat (aleph o) = \u22a4", "start": [308, 1], "end": [310, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nonempty_out_aleph", "code": "instance nonempty_out_aleph (o : Ordinal) : Nonempty (aleph o).ord.out.\u03b1 := by\n  rw [out_nonempty_iff_ne_zero, \u2190 ord_zero]\n  exact fun h => (ord_injective h).not_gt (aleph_pos o)", "start": [313, 1], "end": [315, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_aleph_isLimit", "code": "theorem ord_aleph_isLimit (o : Ordinal) : (aleph o).ord.IsLimit", "start": [318, 1], "end": [319, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.exists_aleph", "code": "theorem exists_aleph {c : Cardinal} : \u2135\u2080 \u2264 c \u2194 \u2203 o, c = aleph o", "start": [325, 1], "end": [330, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph'_isNormal", "code": "theorem aleph'_isNormal : IsNormal (ord \u2218 aleph')", "start": [333, 1], "end": [335, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_isNormal", "code": "theorem aleph_isNormal : IsNormal (ord \u2218 aleph)", "start": [338, 1], "end": [339, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.succ_aleph0", "code": "theorem succ_aleph0 : succ \u2135\u2080 = aleph 1", "start": [342, 1], "end": [342, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_lt_aleph_one", "code": "theorem aleph0_lt_aleph_one : \u2135\u2080 < aleph 1", "start": [345, 1], "end": [347, 16], "kind": "commanddeclaration"}, {"full_name": "Cardinal.countable_iff_lt_aleph_one", "code": "theorem countable_iff_lt_aleph_one {\u03b1 : Type*} (s : Set \u03b1) : s.Countable \u2194 #s < aleph 1", "start": [350, 1], "end": [351, 63], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_card_unbounded", "code": "theorem ord_card_unbounded : Unbounded (\u00b7 < \u00b7) { b : Ordinal | b.card.ord = b }", "start": [354, 1], "end": [360, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_aleph'_of_eq_card_ord", "code": "theorem eq_aleph'_of_eq_card_ord {o : Ordinal} (ho : o.card.ord = o) : \u2203 a, (aleph' a).ord = o", "start": [363, 1], "end": [364, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_aleph'_eq_enum_card", "code": "theorem ord_aleph'_eq_enum_card : ord \u2218 aleph' = enumOrd { b : Ordinal | b.card.ord = b }", "start": [367, 1], "end": [374, 65], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_card_unbounded'", "code": "theorem ord_card_unbounded' : Unbounded (\u00b7 < \u00b7) { b : Ordinal | b.card.ord = b \u2227 \u03c9 \u2264 b }", "start": [377, 1], "end": [379, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_aleph_of_eq_card_ord", "code": "theorem eq_aleph_of_eq_card_ord {o : Ordinal} (ho : o.card.ord = o) (ho' : \u03c9 \u2264 o) :\n    \u2203 a, (aleph a).ord = o", "start": [382, 1], "end": [388, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.ord_aleph_eq_enum_card", "code": "theorem ord_aleph_eq_enum_card :\n    ord \u2218 aleph = enumOrd { b : Ordinal | b.card.ord = b \u2227 \u03c9 \u2264 b }", "start": [391, 1], "end": [400, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth", "code": "def beth (o : Ordinal.{u}) : Cardinal.{u} :=\n  limitRecOn o aleph0 (fun _ x => (2 : Cardinal) ^ x) fun a _ IH => \u2a06 b : Iio a, IH b.1 b.2", "start": [406, 1], "end": [412, 92], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_zero", "code": "@[simp]\ntheorem beth_zero : beth 0 = aleph0", "start": [415, 1], "end": [417, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_succ", "code": "@[simp]\ntheorem beth_succ (o : Ordinal) : beth (succ o) = 2 ^ beth o", "start": [420, 1], "end": [422, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_limit", "code": "theorem beth_limit {o : Ordinal} : o.IsLimit \u2192 beth o = \u2a06 a : Iio o, beth a", "start": [425, 1], "end": [426, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_strictMono", "code": "theorem beth_strictMono : StrictMono beth", "start": [429, 1], "end": [443, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_mono", "code": "theorem beth_mono : Monotone beth", "start": [446, 1], "end": [447, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_lt", "code": "@[simp]\ntheorem beth_lt {o\u2081 o\u2082 : Ordinal} : beth o\u2081 < beth o\u2082 \u2194 o\u2081 < o\u2082", "start": [450, 1], "end": [452, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_le", "code": "@[simp]\ntheorem beth_le {o\u2081 o\u2082 : Ordinal} : beth o\u2081 \u2264 beth o\u2082 \u2194 o\u2081 \u2264 o\u2082", "start": [455, 1], "end": [457, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_le_beth", "code": "theorem aleph_le_beth (o : Ordinal) : aleph o \u2264 beth o", "start": [460, 1], "end": [468, 63], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_le_beth", "code": "theorem aleph0_le_beth (o : Ordinal) : \u2135\u2080 \u2264 beth o", "start": [471, 1], "end": [472, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_pos", "code": "theorem beth_pos (o : Ordinal) : 0 < beth o", "start": [475, 1], "end": [476, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_ne_zero", "code": "theorem beth_ne_zero (o : Ordinal) : beth o \u2260 0", "start": [479, 1], "end": [480, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.beth_normal", "code": "theorem beth_normal : IsNormal.{u} fun o => (beth o).ord", "start": [483, 1], "end": [487, 52], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_self", "code": "theorem mul_eq_self {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c * c = c", "start": [494, 1], "end": [542, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_max", "code": "theorem mul_eq_max {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : \u2135\u2080 \u2264 b) : a * b = max a b", "start": [547, 1], "end": [554, 83], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_mk_eq_max", "code": "@[simp]\ntheorem mul_mk_eq_max {\u03b1 \u03b2 : Type u} [Infinite \u03b1] [Infinite \u03b2] : #\u03b1 * #\u03b2 = max #\u03b1 #\u03b2", "start": [557, 1], "end": [559, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_mul_aleph", "code": "@[simp]\ntheorem aleph_mul_aleph (o\u2081 o\u2082 : Ordinal) : aleph o\u2081 * aleph o\u2082 = aleph (max o\u2081 o\u2082)", "start": [562, 1], "end": [564, 83], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_eq", "code": "@[simp]\ntheorem aleph0_mul_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : \u2135\u2080 * a = a", "start": [567, 1], "end": [569, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_aleph0_eq", "code": "@[simp]\ntheorem mul_aleph0_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : a * \u2135\u2080 = a", "start": [572, 1], "end": [574, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_mk_eq", "code": "theorem aleph0_mul_mk_eq {\u03b1 : Type*} [Infinite \u03b1] : \u2135\u2080 * #\u03b1 = #\u03b1", "start": [578, 1], "end": [579, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_mul_aleph0_eq", "code": "theorem mk_mul_aleph0_eq {\u03b1 : Type*} [Infinite \u03b1] : #\u03b1 * \u2135\u2080 = #\u03b1", "start": [583, 1], "end": [584, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph0_mul_aleph", "code": "@[simp]\ntheorem aleph0_mul_aleph (o : Ordinal) : \u2135\u2080 * aleph o = aleph o", "start": [587, 1], "end": [589, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_mul_aleph0", "code": "@[simp]\ntheorem aleph_mul_aleph0 (o : Ordinal) : aleph o * \u2135\u2080 = aleph o", "start": [592, 1], "end": [594, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_lt_of_lt", "code": "theorem mul_lt_of_lt {a b c : Cardinal} (hc : \u2135\u2080 \u2264 c) (h1 : a < c) (h2 : b < c) : a * b < c", "start": [597, 1], "end": [601, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_le_max_of_aleph0_le_left", "code": "theorem mul_le_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) : a * b \u2264 max a b", "start": [604, 1], "end": [607, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_max_of_aleph0_le_left", "code": "theorem mul_eq_max_of_aleph0_le_left {a b : Cardinal} (h : \u2135\u2080 \u2264 a) (h' : b \u2260 0) :\n    a * b = max a b", "start": [610, 1], "end": [618, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_le_max_of_aleph0_le_right", "code": "theorem mul_le_max_of_aleph0_le_right {a b : Cardinal} (h : \u2135\u2080 \u2264 b) : a * b \u2264 max a b", "start": [621, 1], "end": [622, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_max_of_aleph0_le_right", "code": "theorem mul_eq_max_of_aleph0_le_right {a b : Cardinal} (h' : a \u2260 0) (h : \u2135\u2080 \u2264 b) :\n    a * b = max a b", "start": [625, 1], "end": [628, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_max'", "code": "theorem mul_eq_max' {a b : Cardinal} (h : \u2135\u2080 \u2264 a * b) : a * b = max a b", "start": [631, 1], "end": [634, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_le_max", "code": "theorem mul_le_max (a b : Cardinal) : a * b \u2264 max (max a b) \u2135\u2080", "start": [637, 1], "end": [646, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_left", "code": "theorem mul_eq_left {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 a) (hb' : b \u2260 0) : a * b = a", "start": [649, 1], "end": [650, 59], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_right", "code": "theorem mul_eq_right {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (ha : a \u2264 b) (ha' : a \u2260 0) : a * b = b", "start": [653, 1], "end": [654, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_mul_left", "code": "theorem le_mul_left {a b : Cardinal} (h : b \u2260 0) : a \u2264 b * a", "start": [657, 1], "end": [659, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_mul_right", "code": "theorem le_mul_right {a b : Cardinal} (h : b \u2260 0) : a \u2264 a * b", "start": [662, 1], "end": [664, 22], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mul_eq_left_iff", "code": "theorem mul_eq_left_iff {a b : Cardinal} : a * b = a \u2194 max \u2135\u2080 b \u2264 a \u2227 b \u2260 0 \u2228 b = 1 \u2228 a = 0", "start": [667, 1], "end": [709, 19], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_self", "code": "theorem add_eq_self {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c + c = c", "start": [715, 1], "end": [721, 27], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_max", "code": "theorem add_eq_max {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) : a + b = max a b", "start": [724, 1], "end": [730, 58], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_max'", "code": "theorem add_eq_max' {a b : Cardinal} (ha : \u2135\u2080 \u2264 b) : a + b = max a b", "start": [733, 1], "end": [734, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_mk_eq_max", "code": "@[simp]\ntheorem add_mk_eq_max {\u03b1 \u03b2 : Type u} [Infinite \u03b1] : #\u03b1 + #\u03b2 = max #\u03b1 #\u03b2", "start": [737, 1], "end": [739, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_mk_eq_max'", "code": "@[simp]\ntheorem add_mk_eq_max' {\u03b1 \u03b2 : Type u} [Infinite \u03b2] : #\u03b1 + #\u03b2 = max #\u03b1 #\u03b2", "start": [742, 1], "end": [744, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_le_max", "code": "theorem add_le_max (a b : Cardinal) : a + b \u2264 max (max a b) \u2135\u2080", "start": [747, 1], "end": [754, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_le_of_le", "code": "theorem add_le_of_le {a b c : Cardinal} (hc : \u2135\u2080 \u2264 c) (h1 : a \u2264 c) (h2 : b \u2264 c) : a + b \u2264 c", "start": [757, 1], "end": [758, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_lt_of_lt", "code": "theorem add_lt_of_lt {a b c : Cardinal} (hc : \u2135\u2080 \u2264 c) (h1 : a < c) (h2 : b < c) : a + b < c", "start": [761, 1], "end": [764, 45], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_of_add_eq_of_aleph0_le", "code": "theorem eq_of_add_eq_of_aleph0_le {a b c : Cardinal} (h : a + b = c) (ha : a < c) (hc : \u2135\u2080 \u2264 c) :\n    b = c", "start": [767, 1], "end": [774, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_left", "code": "theorem add_eq_left {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (hb : b \u2264 a) : a + b = a", "start": [777, 1], "end": [778, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_right", "code": "theorem add_eq_right {a b : Cardinal} (hb : \u2135\u2080 \u2264 b) (ha : a \u2264 b) : a + b = b", "start": [781, 1], "end": [782, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_left_iff", "code": "theorem add_eq_left_iff {a b : Cardinal} : a + b = a \u2194 max \u2135\u2080 b \u2264 a \u2228 b = 0", "start": [785, 1], "end": [802, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_eq_right_iff", "code": "theorem add_eq_right_iff {a b : Cardinal} : a + b = b \u2194 max \u2135\u2080 a \u2264 b \u2228 a = 0", "start": [805, 1], "end": [806, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_nat_eq", "code": "theorem add_nat_eq {a : Cardinal} (n : \u2115) (ha : \u2135\u2080 \u2264 a) : a + n = a", "start": [809, 1], "end": [810, 49], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_add_eq", "code": "theorem nat_add_eq {a : Cardinal} (n : \u2115) (ha : \u2135\u2080 \u2264 a) : n + a = a", "start": [813, 1], "end": [814, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_one_eq", "code": "theorem add_one_eq {a : Cardinal} (ha : \u2135\u2080 \u2264 a) : a + 1 = a", "start": [816, 1], "end": [817, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_add_one_eq", "code": "theorem mk_add_one_eq {\u03b1 : Type*} [Infinite \u03b1] : #\u03b1 + 1 = #\u03b1", "start": [821, 1], "end": [822, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_of_add_eq_add_left", "code": "protected theorem eq_of_add_eq_add_left {a b c : Cardinal} (h : a + b = a + c) (ha : a < \u2135\u2080) :\n    b = c", "start": [825, 1], "end": [843, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.eq_of_add_eq_add_right", "code": "protected theorem eq_of_add_eq_add_right {a b c : Cardinal} (h : a + b = c + b) (hb : b < \u2135\u2080) :\n    a = c", "start": [846, 1], "end": [849, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.aleph_add_aleph", "code": "@[simp]\ntheorem aleph_add_aleph (o\u2081 o\u2082 : Ordinal) : aleph o\u2081 + aleph o\u2082 = aleph (max o\u2081 o\u2082)", "start": [852, 1], "end": [854, 62], "kind": "commanddeclaration"}, {"full_name": "Cardinal.principal_add_ord", "code": "theorem principal_add_ord {c : Cardinal} (hc : \u2135\u2080 \u2264 c) : Ordinal.Principal (\u00b7 + \u00b7) c.ord", "start": [857, 1], "end": [860, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.principal_add_aleph", "code": "theorem principal_add_aleph (o : Ordinal) : Ordinal.Principal (\u00b7 + \u00b7) (aleph o).ord", "start": [863, 1], "end": [864, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_right_inj_of_lt_aleph0", "code": "theorem add_right_inj_of_lt_aleph0 {\u03b1 \u03b2 \u03b3 : Cardinal} (\u03b3\u2080 : \u03b3 < aleph0) : \u03b1 + \u03b3 = \u03b2 + \u03b3 \u2194 \u03b1 = \u03b2", "start": [867, 1], "end": [868, 94], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_nat_inj", "code": "@[simp]\ntheorem add_nat_inj {\u03b1 \u03b2 : Cardinal} (n : \u2115) : \u03b1 + n = \u03b2 + n \u2194 \u03b1 = \u03b2", "start": [871, 1], "end": [873, 47], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_one_inj", "code": "@[simp]\ntheorem add_one_inj {\u03b1 \u03b2 : Cardinal} : \u03b1 + 1 = \u03b2 + 1 \u2194 \u03b1 = \u03b2", "start": [876, 1], "end": [878, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_le_add_iff_of_lt_aleph0", "code": "theorem add_le_add_iff_of_lt_aleph0 {\u03b1 \u03b2 \u03b3 : Cardinal} (\u03b3\u2080 : \u03b3 < Cardinal.aleph0) :\n    \u03b1 + \u03b3 \u2264 \u03b2 + \u03b3 \u2194 \u03b1 \u2264 \u03b2", "start": [881, 1], "end": [886, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_nat_le_add_nat_iff_of_lt_aleph_0", "code": "@[simp]\ntheorem add_nat_le_add_nat_iff_of_lt_aleph_0 {\u03b1 \u03b2 : Cardinal} (n : \u2115) : \u03b1 + n \u2264 \u03b2 + n \u2194 \u03b1 \u2264 \u03b2", "start": [889, 1], "end": [891, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.add_one_le_add_one_iff_of_lt_aleph_0", "code": "@[simp]\ntheorem add_one_le_add_one_iff_of_lt_aleph_0 {\u03b1 \u03b2 : Cardinal} : \u03b1 + 1 \u2264 \u03b2 + 1 \u2194 \u03b1 \u2264 \u03b2", "start": [894, 1], "end": [896, 44], "kind": "commanddeclaration"}, {"full_name": "Cardinal.pow_le", "code": "theorem pow_le {\u03ba \u03bc : Cardinal.{u}} (H1 : \u2135\u2080 \u2264 \u03ba) (H2 : \u03bc < \u2135\u2080) : \u03ba ^ \u03bc \u2264 \u03ba", "start": [906, 1], "end": [923, 9], "kind": "commanddeclaration"}, {"full_name": "Cardinal.pow_eq", "code": "theorem pow_eq {\u03ba \u03bc : Cardinal.{u}} (H1 : \u2135\u2080 \u2264 \u03ba) (H2 : 1 \u2264 \u03bc) (H3 : \u03bc < \u2135\u2080) : \u03ba ^ \u03bc = \u03ba", "start": [926, 1], "end": [927, 48], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_self_eq", "code": "theorem power_self_eq {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c ^ c = 2 ^ c", "start": [930, 1], "end": [933, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.prod_eq_two_power", "code": "theorem prod_eq_two_power {\u03b9 : Type u} [Infinite \u03b9] {c : \u03b9 \u2192 Cardinal.{v}} (h\u2081 : \u2200 i, 2 \u2264 c i)\n    (h\u2082 : \u2200 i, lift.{u} (c i) \u2264 lift.{v} #\u03b9) : prod c = 2 ^ lift.{v} #\u03b9", "start": [936, 1], "end": [945, 15], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_eq_two_power", "code": "theorem power_eq_two_power {c\u2081 c\u2082 : Cardinal} (h\u2081 : \u2135\u2080 \u2264 c\u2081) (h\u2082 : 2 \u2264 c\u2082) (h\u2082' : c\u2082 \u2264 c\u2081) :\n    c\u2082 ^ c\u2081 = 2 ^ c\u2081", "start": [948, 1], "end": [950, 86], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nat_power_eq", "code": "theorem nat_power_eq {c : Cardinal.{u}} (h : \u2135\u2080 \u2264 c) {n : \u2115} (hn : 2 \u2264 n) :\n    (n : Cardinal.{u}) ^ c = 2 ^ c", "start": [953, 1], "end": [955, 79], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_nat_le", "code": "theorem power_nat_le {c : Cardinal.{u}} {n : \u2115} (h : \u2135\u2080 \u2264 c) : c ^\u2115 n \u2264 c", "start": [958, 1], "end": [959, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_nat_eq", "code": "theorem power_nat_eq {c : Cardinal.{u}} {n : \u2115} (h1 : \u2135\u2080 \u2264 c) (h2 : 1 \u2264 n) : c ^\u2115 n = c", "start": [962, 1], "end": [963, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.power_nat_le_max", "code": "theorem power_nat_le_max {c : Cardinal.{u}} {n : \u2115} : c ^ (n : Cardinal.{u}) \u2264 max c \u2135\u2080", "start": [966, 1], "end": [969, 71], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_aleph0", "code": "theorem powerlt_aleph0 {c : Cardinal} (h : \u2135\u2080 \u2264 c) : c ^< \u2135\u2080 = c", "start": [972, 1], "end": [979, 53], "kind": "commanddeclaration"}, {"full_name": "Cardinal.powerlt_aleph0_le", "code": "theorem powerlt_aleph0_le (c : Cardinal) : c ^< \u2135\u2080 \u2264 max c \u2135\u2080", "start": [982, 1], "end": [987, 74], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_list_eq_mk", "code": "@[simp]\ntheorem mk_list_eq_mk (\u03b1 : Type u) [Infinite \u03b1] : #(List \u03b1) = #\u03b1", "start": [993, 1], "end": [1001, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_list_eq_aleph0", "code": "theorem mk_list_eq_aleph0 (\u03b1 : Type u) [Countable \u03b1] [Nonempty \u03b1] : #(List \u03b1) = \u2135\u2080", "start": [1004, 1], "end": [1005, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_list_eq_max_mk_aleph0", "code": "theorem mk_list_eq_max_mk_aleph0 (\u03b1 : Type u) [Nonempty \u03b1] : #(List \u03b1) = max #\u03b1 \u2135\u2080", "start": [1008, 1], "end": [1013, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_list_le_max", "code": "theorem mk_list_le_max (\u03b1 : Type u) : #(List \u03b1) \u2264 max \u2135\u2080 #\u03b1", "start": [1016, 1], "end": [1020, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finset_of_infinite", "code": "@[simp]\ntheorem mk_finset_of_infinite (\u03b1 : Type u) [Infinite \u03b1] : #(Finset \u03b1) = #\u03b1", "start": [1023, 1], "end": [1029, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_lift_of_infinite", "code": "@[simp]\ntheorem mk_finsupp_lift_of_infinite (\u03b1 : Type u) (\u03b2 : Type v) [Infinite \u03b1] [Zero \u03b2] [Nontrivial \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = max (lift.{v} #\u03b1) (lift.{u} #\u03b2)", "start": [1032, 1], "end": [1046, 69], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_of_infinite", "code": "theorem mk_finsupp_of_infinite (\u03b1 \u03b2 : Type u) [Infinite \u03b1] [Zero \u03b2] [Nontrivial \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = max #\u03b1 #\u03b2", "start": [1049, 1], "end": [1050, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_lift_of_infinite'", "code": "@[simp]\ntheorem mk_finsupp_lift_of_infinite' (\u03b1 : Type u) (\u03b2 : Type v) [Nonempty \u03b1] [Zero \u03b2] [Infinite \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = max (lift.{v} #\u03b1) (lift.{u} #\u03b2)", "start": [1053, 1], "end": [1061, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_of_infinite'", "code": "theorem mk_finsupp_of_infinite' (\u03b1 \u03b2 : Type u) [Nonempty \u03b1] [Zero \u03b2] [Infinite \u03b2] :\n    #(\u03b1 \u2192\u2080 \u03b2) = max #\u03b1 #\u03b2", "start": [1064, 1], "end": [1065, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_finsupp_nat", "code": "theorem mk_finsupp_nat (\u03b1 : Type u) [Nonempty \u03b1] : #(\u03b1 \u2192\u2080 \u2115) = max #\u03b1 \u2135\u2080", "start": [1068, 1], "end": [1068, 84], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_multiset_of_nonempty", "code": "@[simp]\ntheorem mk_multiset_of_nonempty (\u03b1 : Type u) [Nonempty \u03b1] : #(Multiset \u03b1) = max #\u03b1 \u2135\u2080", "start": [1071, 1], "end": [1073, 66], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_multiset_of_infinite", "code": "theorem mk_multiset_of_infinite (\u03b1 : Type u) [Infinite \u03b1] : #(Multiset \u03b1) = #\u03b1", "start": [1076, 1], "end": [1076, 90], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_multiset_of_isEmpty", "code": "@[simp]\ntheorem mk_multiset_of_isEmpty (\u03b1 : Type u) [IsEmpty \u03b1] : #(Multiset \u03b1) = 1", "start": [1079, 1], "end": [1081, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_multiset_of_countable", "code": "theorem mk_multiset_of_countable (\u03b1 : Type u) [Countable \u03b1] [Nonempty \u03b1] : #(Multiset \u03b1) = \u2135\u2080", "start": [1084, 1], "end": [1085, 57], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_bounded_set_le_of_infinite", "code": "theorem mk_bounded_set_le_of_infinite (\u03b1 : Type u) [Infinite \u03b1] (c : Cardinal) :\n    #{ t : Set \u03b1 // #t \u2264 c } \u2264 #\u03b1 ^ c", "start": [1088, 1], "end": [1119, 37], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_bounded_set_le", "code": "theorem mk_bounded_set_le (\u03b1 : Type u) (c : Cardinal) :\n    #{ t : Set \u03b1 // #t \u2264 c } \u2264 max #\u03b1 \u2135\u2080 ^ c", "start": [1122, 1], "end": [1132, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_bounded_subset_le", "code": "theorem mk_bounded_subset_le {\u03b1 : Type u} (s : Set \u03b1) (c : Cardinal.{u}) :\n    #{ t : Set \u03b1 // t \u2286 s \u2227 #t \u2264 c } \u2264 max #s \u2135\u2080 ^ c", "start": [1135, 1], "end": [1144, 91], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_of_infinite", "code": "theorem mk_compl_of_infinite {\u03b1 : Type*} [Infinite \u03b1] (s : Set \u03b1) (h2 : #s < #\u03b1) :\n    #(s\u1d9c : Set \u03b1) = #\u03b1", "start": [1150, 1], "end": [1153, 23], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_finset_of_infinite", "code": "theorem mk_compl_finset_of_infinite {\u03b1 : Type*} [Infinite \u03b1] (s : Finset \u03b1) :\n    #((\u2191s)\u1d9c : Set \u03b1) = #\u03b1", "start": [1156, 1], "end": [1159, 60], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_eq_mk_compl_infinite", "code": "theorem mk_compl_eq_mk_compl_infinite {\u03b1 : Type*} [Infinite \u03b1] {s t : Set \u03b1} (hs : #s < #\u03b1)\n    (ht : #t < #\u03b1) : #(s\u1d9c : Set \u03b1) = #(t\u1d9c : Set \u03b1)", "start": [1162, 1], "end": [1164, 60], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_eq_mk_compl_finite_lift", "code": "theorem mk_compl_eq_mk_compl_finite_lift {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b1] {s : Set \u03b1}\n    {t : Set \u03b2} (h1 : (lift.{max v w, u} #\u03b1) = (lift.{max u w, v} #\u03b2))\n    (h2 : lift.{max v w, u} #s = lift.{max u w, v} #t) :\n    lift.{max v w} #(s\u1d9c : Set \u03b1) = lift.{max u w} #(t\u1d9c : Set \u03b2)", "start": [1167, 1], "end": [1179, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_eq_mk_compl_finite", "code": "theorem mk_compl_eq_mk_compl_finite {\u03b1 \u03b2 : Type u} [Finite \u03b1] {s : Set \u03b1} {t : Set \u03b2}\n    (h1 : #\u03b1 = #\u03b2) (h : #s = #t) : #(s\u1d9c : Set \u03b1) = #(t\u1d9c : Set \u03b2)", "start": [1182, 1], "end": [1186, 21], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_compl_eq_mk_compl_finite_same", "code": "theorem mk_compl_eq_mk_compl_finite_same {\u03b1 : Type u} [Finite \u03b1] {s t : Set \u03b1} (h : #s = #t) :\n    #(s\u1d9c : Set \u03b1) = #(t\u1d9c : Set \u03b1)", "start": [1189, 1], "end": [1191, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.extend_function", "code": "theorem extend_function {\u03b1 \u03b2 : Type*} {s : Set \u03b1} (f : s \u21aa \u03b2)\n    (h : Nonempty ((s\u1d9c : Set \u03b1) \u2243 ((range f)\u1d9c : Set \u03b2))) : \u2203 g : \u03b1 \u2243 \u03b2, \u2200 x : s, g x = f x", "start": [1197, 1], "end": [1203, 76], "kind": "commanddeclaration"}, {"full_name": "Cardinal.extend_function_finite", "code": "theorem extend_function_finite {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b1] {s : Set \u03b1} (f : s \u21aa \u03b2)\n    (h : Nonempty (\u03b1 \u2243 \u03b2)) : \u2203 g : \u03b1 \u2243 \u03b2, \u2200 x : s, g x = f x", "start": [1206, 1], "end": [1212, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.extend_function_of_lt", "code": "theorem extend_function_of_lt {\u03b1 \u03b2 : Type*} {s : Set \u03b1} (f : s \u21aa \u03b2) (hs : #s < #\u03b1)\n    (h : Nonempty (\u03b1 \u2243 \u03b2)) : \u2203 g : \u03b1 \u2243 \u03b2, \u2200 x : s, g x = f x", "start": [1215, 1], "end": [1224, 72], "kind": "commanddeclaration"}, {"full_name": "Ordinal.omega_lt_omega1", "code": "lemma omega_lt_omega1 : \u03c9 < \u03c9\u2081 := ord_aleph0.symm.trans_lt (ord_lt_ord.mpr (aleph0_lt_aleph_one))", "start": [1470, 1], "end": [1470, 98], "kind": "mathlibtacticlemma"}, {"full_name": "Ordinal.Cardinal.mk_iUnion_Ordinal_le_of_le", "code": "lemma mk_iUnion_Ordinal_le_of_le {\u03b2 : Type*} {o : Ordinal} {c : Cardinal}\n    (ho : o.card \u2264 c) (hc : \u2135\u2080 \u2264 c) (A : Ordinal \u2192 Set \u03b2)\n    (hA : \u2200 j < o, #(A j) \u2264 c) :\n    #(\u22c3 j < o, A j) \u2264 c := by\n  simp_rw [\u2190 mem_Iio, biUnion_eq_iUnion, iUnion, iSup, \u2190 o.enumIsoOut.symm.surjective.range_comp]\n  apply ((mk_iUnion_le _).trans _).trans_eq (mul_eq_self hc)\n  rw [mk_ordinal_out]\n  exact mul_le_mul' ho <| ciSup_le' <| (hA _ <| typein_lt_self \u00b7)", "start": [1482, 1], "end": [1492, 66], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Algebra/InfiniteSum/Basic.lean", "imports": ["Mathlib/Topology/Algebra/Star.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Data/Nat/Parity.lean", "Mathlib/Logic/Encodable/Lattice.lean"], "premises": [{"full_name": "HasSum", "code": "def HasSum (f : \u03b2 \u2192 \u03b1) (a : \u03b1) : Prop :=\n  Tendsto (fun s : Finset \u03b2 => \u2211 b in s, f b) atTop (\ud835\udcdd a)", "start": [44, 1], "end": [58, 58], "kind": "commanddeclaration"}, {"full_name": "Summable", "code": "def Summable (f : \u03b2 \u2192 \u03b1) : Prop :=\n  \u2203 a, HasSum f a", "start": [61, 1], "end": [63, 18], "kind": "commanddeclaration"}, {"full_name": "tsum", "code": "irreducible_def tsum {\u03b2} (f : \u03b2 \u2192 \u03b1) :=\n  if h : Summable f then\n  \n    if (support f).Finite then finsum f\n    else Classical.choose h\n  else 0", "start": [66, 1], "end": [74, 9], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "HasSum.summable", "code": "theorem HasSum.summable (h : HasSum f a) : Summable f", "start": [83, 1], "end": [84, 9], "kind": "commanddeclaration"}, {"full_name": "hasSum_zero", "code": "theorem hasSum_zero : HasSum (fun _ => 0 : \u03b2 \u2192 \u03b1) 0", "start": [87, 1], "end": [88, 92], "kind": "commanddeclaration"}, {"full_name": "hasSum_empty", "code": "theorem hasSum_empty [IsEmpty \u03b2] : HasSum f 0", "start": [91, 1], "end": [92, 31], "kind": "commanddeclaration"}, {"full_name": "summable_zero", "code": "theorem summable_zero : Summable (fun _ => 0 : \u03b2 \u2192 \u03b1)", "start": [95, 1], "end": [96, 23], "kind": "commanddeclaration"}, {"full_name": "summable_empty", "code": "theorem summable_empty [IsEmpty \u03b2] : Summable f", "start": [99, 1], "end": [100, 24], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_zero_of_not_summable", "code": "theorem tsum_eq_zero_of_not_summable (h : \u00acSummable f) : \u2211' b, f b = 0", "start": [103, 1], "end": [103, 96], "kind": "commanddeclaration"}, {"full_name": "summable_congr", "code": "theorem summable_congr (hfg : \u2200 b, f b = g b) : Summable f \u2194 Summable g", "start": [106, 1], "end": [107, 47], "kind": "commanddeclaration"}, {"full_name": "Summable.congr", "code": "theorem Summable.congr (hf : Summable f) (hfg : \u2200 b, f b = g b) : Summable g", "start": [110, 1], "end": [111, 29], "kind": "commanddeclaration"}, {"full_name": "HasSum.hasSum_of_sum_eq", "code": "theorem HasSum.hasSum_of_sum_eq {g : \u03b3 \u2192 \u03b1}\n    (h_eq :\n      \u2200 u : Finset \u03b3,\n        \u2203 v : Finset \u03b2, \u2200 v', v \u2286 v' \u2192 \u2203 u', u \u2286 u' \u2227 \u2211 x in u', g x = \u2211 b in v', f b)\n    (hf : HasSum g a) : HasSum f a", "start": [114, 1], "end": [119, 55], "kind": "commanddeclaration"}, {"full_name": "hasSum_iff_hasSum", "code": "theorem hasSum_iff_hasSum {g : \u03b3 \u2192 \u03b1}\n    (h\u2081 :\n      \u2200 u : Finset \u03b3,\n        \u2203 v : Finset \u03b2, \u2200 v', v \u2286 v' \u2192 \u2203 u', u \u2286 u' \u2227 \u2211 x in u', g x = \u2211 b in v', f b)\n    (h\u2082 :\n      \u2200 v : Finset \u03b2,\n        \u2203 u : Finset \u03b3, \u2200 u', u \u2286 u' \u2192 \u2203 v', v \u2286 v' \u2227 \u2211 b in v', f b = \u2211 x in u', g x) :\n    HasSum f a \u2194 HasSum g a", "start": [122, 1], "end": [130, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.hasSum_iff", "code": "theorem Function.Injective.hasSum_iff {g : \u03b3 \u2192 \u03b2} (hg : Injective g)\n    (hf : \u2200 x, x \u2209 Set.range g \u2192 f x = 0) : HasSum (f \u2218 g) a \u2194 HasSum f a", "start": [133, 1], "end": [135, 73], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.summable_iff", "code": "theorem Function.Injective.summable_iff {g : \u03b3 \u2192 \u03b2} (hg : Injective g)\n    (hf : \u2200 (x) (_ : x \u2209 Set.range g), f x = 0) : Summable (f \u2218 g) \u2194 Summable f", "start": [138, 1], "end": [140, 41], "kind": "commanddeclaration"}, {"full_name": "hasSum_extend_zero", "code": "@[simp] theorem hasSum_extend_zero {g : \u03b2 \u2192 \u03b3} (hg : Injective g) :\n    HasSum (extend g f 0) a \u2194 HasSum f a", "start": [143, 1], "end": [146, 26], "kind": "commanddeclaration"}, {"full_name": "summable_extend_zero", "code": "@[simp] theorem summable_extend_zero {g : \u03b2 \u2192 \u03b3} (hg : Injective g) :\n    Summable (extend g f 0) \u2194 Summable f", "start": [148, 1], "end": [150, 46], "kind": "commanddeclaration"}, {"full_name": "hasSum_subtype_iff_of_support_subset", "code": "theorem hasSum_subtype_iff_of_support_subset {s : Set \u03b2} (hf : support f \u2286 s) :\n    HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a \u2194 HasSum f a", "start": [152, 1], "end": [154, 78], "kind": "commanddeclaration"}, {"full_name": "hasSum_subtype_iff_indicator", "code": "theorem hasSum_subtype_iff_indicator {s : Set \u03b2} :\n    HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a \u2194 HasSum (s.indicator f) a", "start": [157, 1], "end": [160, 71], "kind": "commanddeclaration"}, {"full_name": "summable_subtype_iff_indicator", "code": "theorem summable_subtype_iff_indicator {s : Set \u03b2} :\n    Summable (f \u2218 (\u2191) : s \u2192 \u03b1) \u2194 Summable (s.indicator f)", "start": [163, 1], "end": [165, 53], "kind": "commanddeclaration"}, {"full_name": "hasSum_subtype_support", "code": "@[simp]\ntheorem hasSum_subtype_support : HasSum (f \u2218 (\u2191) : support f \u2192 \u03b1) a \u2194 HasSum f a", "start": [168, 1], "end": [170, 60], "kind": "commanddeclaration"}, {"full_name": "hasSum_fintype", "code": "theorem hasSum_fintype [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) : HasSum f (\u2211 b, f b)", "start": [173, 1], "end": [174, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.hasSum", "code": "protected theorem Finset.hasSum (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    HasSum (f \u2218 (\u2191) : (\u2191s : Set \u03b2) \u2192 \u03b1) (\u2211 b in s, f b)", "start": [177, 1], "end": [180, 25], "kind": "commanddeclaration"}, {"full_name": "Finset.summable", "code": "protected theorem Finset.summable (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    Summable (f \u2218 (\u2191) : (\u2191s : Set \u03b2) \u2192 \u03b1)", "start": [183, 1], "end": [185, 24], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.summable", "code": "protected theorem Set.Finite.summable {s : Set \u03b2} (hs : s.Finite) (f : \u03b2 \u2192 \u03b1) :\n    Summable (f \u2218 (\u2191) : s \u2192 \u03b1)", "start": [188, 1], "end": [191, 32], "kind": "commanddeclaration"}, {"full_name": "hasSum_sum_of_ne_finset_zero", "code": "theorem hasSum_sum_of_ne_finset_zero (hf : \u2200 (b) (_ : b \u2209 s), f b = 0) : HasSum f (\u2211 b in s, f b)", "start": [194, 1], "end": [196, 85], "kind": "commanddeclaration"}, {"full_name": "summable_of_ne_finset_zero", "code": "theorem summable_of_ne_finset_zero (hf : \u2200 (b) (_ : b \u2209 s), f b = 0) : Summable f", "start": [199, 1], "end": [200, 45], "kind": "commanddeclaration"}, {"full_name": "summable_of_finite_support", "code": "theorem summable_of_finite_support (h : (support f).Finite) : Summable f", "start": [203, 1], "end": [204, 59], "kind": "commanddeclaration"}, {"full_name": "Summable.hasSum", "code": "theorem Summable.hasSum (ha : Summable f) : HasSum f (\u2211' b, f b)", "start": [206, 1], "end": [210, 45], "kind": "commanddeclaration"}, {"full_name": "hasSum_single", "code": "theorem hasSum_single {f : \u03b2 \u2192 \u03b1} (b : \u03b2) (hf : \u2200 (b') (_ : b' \u2260 b), f b' = 0) : HasSum f (f b)", "start": [213, 1], "end": [215, 48], "kind": "commanddeclaration"}, {"full_name": "hasSum_ite_eq", "code": "theorem hasSum_ite_eq (b : \u03b2) [DecidablePred (\u00b7 = b)] (a : \u03b1) :\n    HasSum (fun b' => if b' = b then a else 0) a", "start": [218, 1], "end": [221, 26], "kind": "commanddeclaration"}, {"full_name": "hasSum_pi_single", "code": "theorem hasSum_pi_single [DecidableEq \u03b2] (b : \u03b2) (a : \u03b1) : HasSum (Pi.single b a) a", "start": [224, 1], "end": [226, 25], "kind": "commanddeclaration"}, {"full_name": "Equiv.hasSum_iff", "code": "theorem Equiv.hasSum_iff (e : \u03b3 \u2243 \u03b2) : HasSum (f \u2218 e) a \u2194 HasSum f a", "start": [229, 1], "end": [230, 36], "kind": "commanddeclaration"}, {"full_name": "Function.Injective.hasSum_range_iff", "code": "theorem Function.Injective.hasSum_range_iff {g : \u03b3 \u2192 \u03b2} (hg : Injective g) :\n    HasSum (fun x : Set.range g => f x) a \u2194 HasSum (f \u2218 g) a", "start": [233, 1], "end": [235, 43], "kind": "commanddeclaration"}, {"full_name": "Equiv.summable_iff", "code": "theorem Equiv.summable_iff (e : \u03b3 \u2243 \u03b2) : Summable (f \u2218 e) \u2194 Summable f", "start": [238, 1], "end": [239, 37], "kind": "commanddeclaration"}, {"full_name": "Summable.prod_symm", "code": "theorem Summable.prod_symm {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} (hf : Summable f) : Summable fun p : \u03b3 \u00d7 \u03b2 => f p.swap", "start": [242, 1], "end": [243, 41], "kind": "commanddeclaration"}, {"full_name": "Equiv.hasSum_iff_of_support", "code": "theorem Equiv.hasSum_iff_of_support {g : \u03b3 \u2192 \u03b1} (e : support f \u2243 support g)\n    (he : \u2200 x : support f, g (e x) = f x) : HasSum f a \u2194 HasSum g a", "start": [246, 1], "end": [249, 78], "kind": "commanddeclaration"}, {"full_name": "hasSum_iff_hasSum_of_ne_zero_bij", "code": "theorem hasSum_iff_hasSum_of_ne_zero_bij {g : \u03b3 \u2192 \u03b1} (i : support g \u2192 \u03b2)\n    (hi : \u2200 \u2983x y\u2984, i x = i y \u2192 (x : \u03b3) = y) (hf : support f \u2286 Set.range i)\n    (hfg : \u2200 x, f (i x) = g x) : HasSum f a \u2194 HasSum g a", "start": [252, 1], "end": [260, 10], "kind": "commanddeclaration"}, {"full_name": "Equiv.summable_iff_of_support", "code": "theorem Equiv.summable_iff_of_support {g : \u03b3 \u2192 \u03b1} (e : support f \u2243 support g)\n    (he : \u2200 x : support f, g (e x) = f x) : Summable f \u2194 Summable g", "start": [263, 1], "end": [265, 51], "kind": "commanddeclaration"}, {"full_name": "HasSum.map", "code": "protected theorem HasSum.map [AddCommMonoid \u03b3] [TopologicalSpace \u03b3] (hf : HasSum f a) {G}\n    [AddMonoidHomClass G \u03b1 \u03b3] (g : G) (hg : Continuous g) : HasSum (g \u2218 f) (g a)", "start": [268, 1], "end": [273, 34], "kind": "commanddeclaration"}, {"full_name": "Summable.map", "code": "protected theorem Summable.map [AddCommMonoid \u03b3] [TopologicalSpace \u03b3] (hf : Summable f) {G}\n    [AddMonoidHomClass G \u03b1 \u03b3] (g : G) (hg : Continuous g) : Summable (g \u2218 f)", "start": [276, 1], "end": [278, 32], "kind": "commanddeclaration"}, {"full_name": "Summable.map_iff_of_leftInverse", "code": "protected theorem Summable.map_iff_of_leftInverse [AddCommMonoid \u03b3] [TopologicalSpace \u03b3] {G G'}\n    [AddMonoidHomClass G \u03b1 \u03b3] [AddMonoidHomClass G' \u03b3 \u03b1] (g : G) (g' : G') (hg : Continuous g)\n    (hg' : Continuous g') (hinv : Function.LeftInverse g' g) : Summable (g \u2218 f) \u2194 Summable f", "start": [281, 1], "end": [286, 71], "kind": "commanddeclaration"}, {"full_name": "Summable.map_iff_of_equiv", "code": "protected theorem Summable.map_iff_of_equiv [AddCommMonoid \u03b3] [TopologicalSpace \u03b3] {G}\n    [AddEquivClass G \u03b1 \u03b3] (g : G) (hg : Continuous g)\n    (hg' : Continuous (AddEquivClass.toEquivLike.inv g : \u03b3 \u2192 \u03b1)) : Summable (g \u2218 f) \u2194 Summable f", "start": [289, 1], "end": [293, 100], "kind": "commanddeclaration"}, {"full_name": "HasSum.tendsto_sum_nat", "code": "theorem HasSum.tendsto_sum_nat {f : \u2115 \u2192 \u03b1} (h : HasSum f a) :\n    Tendsto (fun n : \u2115 => \u2211 i in range n, f i) atTop (\ud835\udcdd a)", "start": [296, 1], "end": [299, 30], "kind": "commanddeclaration"}, {"full_name": "HasSum.unique", "code": "theorem HasSum.unique {a\u2081 a\u2082 : \u03b1} [T2Space \u03b1] : HasSum f a\u2081 \u2192 HasSum f a\u2082 \u2192 a\u2081 = a\u2082", "start": [302, 1], "end": [303, 22], "kind": "commanddeclaration"}, {"full_name": "Summable.hasSum_iff_tendsto_nat", "code": "theorem Summable.hasSum_iff_tendsto_nat [T2Space \u03b1] {f : \u2115 \u2192 \u03b1} {a : \u03b1} (hf : Summable f) :\n    HasSum f a \u2194 Tendsto (fun n : \u2115 => \u2211 i in range n, f i) atTop (\ud835\udcdd a)", "start": [306, 1], "end": [310, 18], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.summable_iff_of_hasSum_iff", "code": "theorem Function.Surjective.summable_iff_of_hasSum_iff {\u03b1' : Type*} [AddCommMonoid \u03b1']\n    [TopologicalSpace \u03b1'] {e : \u03b1' \u2192 \u03b1} (hes : Function.Surjective e) {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1'}\n    (he : \u2200 {a}, HasSum f (e a) \u2194 HasSum g a) : Summable f \u2194 Summable g", "start": [313, 1], "end": [316, 42], "kind": "commanddeclaration"}, {"full_name": "HasSum.add", "code": "theorem HasSum.add (hf : HasSum f a) (hg : HasSum g b) : HasSum (fun b => f b + g b) (a + b)", "start": [321, 1], "end": [324, 18], "kind": "commanddeclaration"}, {"full_name": "Summable.add", "code": "theorem Summable.add (hf : Summable f) (hg : Summable g) : Summable fun b => f b + g b", "start": [327, 1], "end": [328, 37], "kind": "commanddeclaration"}, {"full_name": "hasSum_sum", "code": "theorem hasSum_sum {f : \u03b3 \u2192 \u03b2 \u2192 \u03b1} {a : \u03b3 \u2192 \u03b1} {s : Finset \u03b3} :\n    (\u2200 i \u2208 s, HasSum (f i) (a i)) \u2192 HasSum (fun b => \u2211 i in s, f i b) (\u2211 i in s, a i)", "start": [331, 1], "end": [337, 44], "kind": "commanddeclaration"}, {"full_name": "summable_sum", "code": "theorem summable_sum {f : \u03b3 \u2192 \u03b2 \u2192 \u03b1} {s : Finset \u03b3} (hf : \u2200 i \u2208 s, Summable (f i)) :\n    Summable fun b => \u2211 i in s, f i b", "start": [340, 1], "end": [342, 53], "kind": "commanddeclaration"}, {"full_name": "HasSum.add_disjoint", "code": "theorem HasSum.add_disjoint {s t : Set \u03b2} (hs : Disjoint s t) (ha : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasSum (f \u2218 (\u2191) : t \u2192 \u03b1) b) : HasSum (f \u2218 (\u2191) : (s \u222a t : Set \u03b2) \u2192 \u03b1) (a + b)", "start": [345, 1], "end": [349, 18], "kind": "commanddeclaration"}, {"full_name": "hasSum_sum_disjoint", "code": "theorem hasSum_sum_disjoint {\u03b9} (s : Finset \u03b9) {t : \u03b9 \u2192 Set \u03b2} {a : \u03b9 \u2192 \u03b1}\n    (hs : (s : Set \u03b9).Pairwise (Disjoint on t)) (hf : \u2200 i \u2208 s, HasSum (f \u2218 (\u2191) : t i \u2192 \u03b1) (a i)) :\n    HasSum (f \u2218 (\u2191) : (\u22c3 i \u2208 s, t i) \u2192 \u03b1) (\u2211 i in s, a i)", "start": [352, 1], "end": [357, 22], "kind": "commanddeclaration"}, {"full_name": "HasSum.add_isCompl", "code": "theorem HasSum.add_isCompl {s t : Set \u03b2} (hs : IsCompl s t) (ha : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasSum (f \u2218 (\u2191) : t \u2192 \u03b1) b) : HasSum f (a + b)", "start": [360, 1], "end": [363, 80], "kind": "commanddeclaration"}, {"full_name": "HasSum.add_compl", "code": "theorem HasSum.add_compl {s : Set \u03b2} (ha : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a)\n    (hb : HasSum (f \u2218 (\u2191) : (s\u1d9c : Set \u03b2) \u2192 \u03b1) b) : HasSum f (a + b)", "start": [366, 1], "end": [368, 34], "kind": "commanddeclaration"}, {"full_name": "Summable.add_compl", "code": "theorem Summable.add_compl {s : Set \u03b2} (hs : Summable (f \u2218 (\u2191) : s \u2192 \u03b1))\n    (hsc : Summable (f \u2218 (\u2191) : (s\u1d9c : Set \u03b2) \u2192 \u03b1)) : Summable f", "start": [371, 1], "end": [373, 44], "kind": "commanddeclaration"}, {"full_name": "HasSum.compl_add", "code": "theorem HasSum.compl_add {s : Set \u03b2} (ha : HasSum (f \u2218 (\u2191) : (s\u1d9c : Set \u03b2) \u2192 \u03b1) a)\n    (hb : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) b) : HasSum f (a + b)", "start": [376, 1], "end": [378, 39], "kind": "commanddeclaration"}, {"full_name": "HasSum.even_add_odd", "code": "theorem HasSum.even_add_odd {f : \u2115 \u2192 \u03b1} (he : HasSum (fun k => f (2 * k)) a)\n    (ho : HasSum (fun k => f (2 * k + 1)) b) : HasSum f (a + b)", "start": [381, 1], "end": [387, 45], "kind": "commanddeclaration"}, {"full_name": "Summable.compl_add", "code": "theorem Summable.compl_add {s : Set \u03b2} (hs : Summable (f \u2218 (\u2191) : (s\u1d9c : Set \u03b2) \u2192 \u03b1))\n    (hsc : Summable (f \u2218 (\u2191) : s \u2192 \u03b1)) : Summable f", "start": [390, 1], "end": [392, 44], "kind": "commanddeclaration"}, {"full_name": "Summable.even_add_odd", "code": "theorem Summable.even_add_odd {f : \u2115 \u2192 \u03b1} (he : Summable fun k => f (2 * k))\n    (ho : Summable fun k => f (2 * k + 1)) : Summable f", "start": [395, 1], "end": [397, 46], "kind": "commanddeclaration"}, {"full_name": "HasSum.sigma", "code": "theorem HasSum.sigma [RegularSpace \u03b1] {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3 b : \u03b2, \u03b3 b) \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1} {a : \u03b1}\n    (ha : HasSum f a) (hf : \u2200 b, HasSum (fun c => f \u27e8b, c\u27e9) (g b)) : HasSum g a", "start": [400, 1], "end": [416, 59], "kind": "commanddeclaration"}, {"full_name": "HasSum.prod_fiberwise", "code": "theorem HasSum.prod_fiberwise [RegularSpace \u03b1] {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1} {a : \u03b1} (ha : HasSum f a)\n    (hf : \u2200 b, HasSum (fun c => f (b, c)) (g b)) : HasSum g a", "start": [419, 1], "end": [423, 63], "kind": "commanddeclaration"}, {"full_name": "Summable.sigma'", "code": "theorem Summable.sigma' [RegularSpace \u03b1] {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b1} (ha : Summable f)\n    (hf : \u2200 b, Summable fun c => f \u27e8b, c\u27e9) : Summable fun b => \u2211' c, f \u27e8b, c\u27e9", "start": [426, 1], "end": [428, 52], "kind": "commanddeclaration"}, {"full_name": "HasSum.sigma_of_hasSum", "code": "theorem HasSum.sigma_of_hasSum [T3Space \u03b1] {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b1} {g : \u03b2 \u2192 \u03b1}\n    {a : \u03b1} (ha : HasSum g a) (hf : \u2200 b, HasSum (fun c => f \u27e8b, c\u27e9) (g b)) (hf' : Summable f) :\n    HasSum f a", "start": [431, 1], "end": [433, 78], "kind": "commanddeclaration"}, {"full_name": "HasSum.update'", "code": "theorem HasSum.update' {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [AddCommMonoid \u03b1] [T2Space \u03b1]\n    [ContinuousAdd \u03b1] {f : \u03b2 \u2192 \u03b1} {a a' : \u03b1} (hf : HasSum f a) (b : \u03b2) (x : \u03b1)\n    (hf' : HasSum (update f b x) a') : a + x = a' + f b", "start": [436, 1], "end": [449, 58], "kind": "commanddeclaration"}, {"full_name": "eq_add_of_hasSum_ite", "code": "theorem eq_add_of_hasSum_ite {\u03b1 \u03b2 : Type*} [TopologicalSpace \u03b1] [AddCommMonoid \u03b1] [T2Space \u03b1]\n    [ContinuousAdd \u03b1] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : HasSum f a) (b : \u03b2) (a' : \u03b1)\n    (hf' : HasSum (fun n => ite (n = b) 0 (f n)) a') : a = a' + f b", "start": [452, 1], "end": [460, 21], "kind": "commanddeclaration"}, {"full_name": "tsum_congr_subtype", "code": "theorem tsum_congr_subtype (f : \u03b2 \u2192 \u03b1) {s t : Set \u03b2} (h : s = t) :\n    \u2211' x : s, f x = \u2211' x : t, f x", "start": [469, 1], "end": [470, 47], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_finsum", "code": "theorem tsum_eq_finsum (hf : (support f).Finite) :\n    \u2211' b, f b = \u2211\u1da0 b, f b", "start": [473, 1], "end": [474, 83], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_sum", "code": "theorem tsum_eq_sum {s : Finset \u03b2} (hf : \u2200 (b) (_ : b \u2209 s), f b = 0) :\n    \u2211' b, f b = \u2211 b in s, f b", "start": [476, 1], "end": [485, 44], "kind": "commanddeclaration"}, {"full_name": "tsum_zero", "code": "@[simp]\ntheorem tsum_zero : \u2211' _ : \u03b2, (0 : \u03b1) = 0", "start": [488, 1], "end": [489, 77], "kind": "commanddeclaration"}, {"full_name": "tsum_empty", "code": "@[simp]\ntheorem tsum_empty [IsEmpty \u03b2] : \u2211' b, f b = 0", "start": [493, 1], "end": [495, 50], "kind": "commanddeclaration"}, {"full_name": "tsum_congr", "code": "theorem tsum_congr {f g : \u03b2 \u2192 \u03b1}\n    (hfg : \u2200 b, f b = g b) : \u2211' b, f b = \u2211' b, g b", "start": [498, 1], "end": [500, 30], "kind": "commanddeclaration"}, {"full_name": "tsum_fintype", "code": "theorem tsum_fintype [Fintype \u03b2] (f : \u03b2 \u2192 \u03b1) : \u2211' b, f b = \u2211 b, f b", "start": [503, 1], "end": [504, 26], "kind": "commanddeclaration"}, {"full_name": "sum_eq_tsum_indicator", "code": "theorem sum_eq_tsum_indicator (f : \u03b2 \u2192 \u03b1) (s : Finset \u03b2) :\n    \u2211 x in s, f x = \u2211' x, Set.indicator (\u2191s) f x", "start": [507, 1], "end": [513, 28], "kind": "commanddeclaration"}, {"full_name": "tsum_bool", "code": "theorem tsum_bool (f : Bool \u2192 \u03b1) : \u2211' i : Bool, f i = f false + f true", "start": [516, 1], "end": [517, 48], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_single", "code": "theorem tsum_eq_single {f : \u03b2 \u2192 \u03b1} (b : \u03b2) (hf : \u2200 (b') (_ : b' \u2260 b), f b' = 0) :\n    \u2211' b, f b = f b", "start": [520, 1], "end": [523, 48], "kind": "commanddeclaration"}, {"full_name": "tsum_tsum_eq_single", "code": "theorem tsum_tsum_eq_single (f : \u03b2 \u2192 \u03b3 \u2192 \u03b1) (b : \u03b2) (c : \u03b3) (hfb : \u2200 (b') (_ : b' \u2260 b), f b' c = 0)\n    (hfc : \u2200 (b' : \u03b2) (c' : \u03b3), c' \u2260 c \u2192 f b' c' = 0) : \u2211' (b') (c'), f b' c' = f b c", "start": [526, 1], "end": [530, 38], "kind": "commanddeclaration"}, {"full_name": "tsum_ite_eq", "code": "@[simp]\ntheorem tsum_ite_eq (b : \u03b2) [DecidablePred (\u00b7 = b)] (a : \u03b1) :\n    \u2211' b', (if b' = b then a else 0) = a", "start": [533, 1], "end": [538, 29], "kind": "commanddeclaration"}, {"full_name": "tsum_pi_single", "code": "@[simp]\ntheorem tsum_pi_single [DecidableEq \u03b2] (b : \u03b2) (a : \u03b1) : \u2211' b', Pi.single b a b' = a", "start": [541, 1], "end": [545, 29], "kind": "commanddeclaration"}, {"full_name": "Finset.tsum_subtype", "code": "@[simp, nolint simpNF]\ntheorem Finset.tsum_subtype (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    \u2211' x : { x // x \u2208 s }, f x = \u2211 x in s, f x", "start": [549, 1], "end": [552, 42], "kind": "commanddeclaration"}, {"full_name": "Finset.tsum_subtype'", "code": "theorem Finset.tsum_subtype' (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1) :\n    \u2211' x : (s : Set \u03b2), f x = \u2211 x in s, f x", "start": [555, 1], "end": [556, 55], "kind": "commanddeclaration"}, {"full_name": "tsum_singleton", "code": "@[simp, nolint simpNF]\ntheorem tsum_singleton (b : \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2211' x : ({b} : Set \u03b2), f x = f b", "start": [560, 1], "end": [562, 60], "kind": "commanddeclaration"}, {"full_name": "HasSum.tsum_eq", "code": "theorem HasSum.tsum_eq (ha : HasSum f a) : \u2211' b, f b = a", "start": [567, 1], "end": [568, 38], "kind": "commanddeclaration"}, {"full_name": "Summable.hasSum_iff", "code": "theorem Summable.hasSum_iff (h : Summable f) : HasSum f a \u2194 \u2211' b, f b = a", "start": [571, 1], "end": [572, 51], "kind": "commanddeclaration"}, {"full_name": "tsum_dite_right", "code": "theorem tsum_dite_right (P : Prop) [Decidable P] (x : \u03b2 \u2192 \u00acP \u2192 \u03b1) :\n    \u2211' b : \u03b2, (if h : P then (0 : \u03b1) else x b h) = if h : P then (0 : \u03b1) else \u2211' b : \u03b2, x b h", "start": [575, 1], "end": [577, 32], "kind": "commanddeclaration"}, {"full_name": "tsum_dite_left", "code": "theorem tsum_dite_left (P : Prop) [Decidable P] (x : \u03b2 \u2192 P \u2192 \u03b1) :\n    \u2211' b : \u03b2, (if h : P then x b h else 0) = if h : P then \u2211' b : \u03b2, x b h else 0", "start": [580, 1], "end": [582, 32], "kind": "commanddeclaration"}, {"full_name": "Function.Surjective.tsum_eq_tsum_of_hasSum_iff_hasSum", "code": "theorem Function.Surjective.tsum_eq_tsum_of_hasSum_iff_hasSum {\u03b1' : Type*} [AddCommMonoid \u03b1']\n    [TopologicalSpace \u03b1'] {e : \u03b1' \u2192 \u03b1} (hes : Function.Surjective e) (h0 : e 0 = 0) {f : \u03b2 \u2192 \u03b1}\n    {g : \u03b3 \u2192 \u03b1'} (h : \u2200 {a}, HasSum f (e a) \u2194 HasSum g a) : \u2211' b, f b = e (\u2211' c, g c)", "start": [585, 1], "end": [590, 32], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_tsum_of_hasSum_iff_hasSum", "code": "theorem tsum_eq_tsum_of_hasSum_iff_hasSum {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1}\n    (h : \u2200 {a}, HasSum f a \u2194 HasSum g a) : \u2211' b, f b = \u2211' c, g c", "start": [593, 1], "end": [595, 57], "kind": "commanddeclaration"}, {"full_name": "Equiv.tsum_eq", "code": "theorem Equiv.tsum_eq (j : \u03b3 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2211' c, f (j c) = \u2211' b, f b", "start": [598, 1], "end": [599, 49], "kind": "commanddeclaration"}, {"full_name": "Equiv.tsum_eq_tsum_of_support", "code": "theorem Equiv.tsum_eq_tsum_of_support {f : \u03b2 \u2192 \u03b1} {g : \u03b3 \u2192 \u03b1} (e : support f \u2243 support g)\n    (he : \u2200 x, g (e x) = f x) : \u2211' x, f x = \u2211' y, g y", "start": [602, 1], "end": [604, 65], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_tsum_of_ne_zero_bij", "code": "theorem tsum_eq_tsum_of_ne_zero_bij {g : \u03b3 \u2192 \u03b1} (i : support g \u2192 \u03b2)\n    (hi : \u2200 \u2983x y\u2984, i x = i y \u2192 (x : \u03b3) = y) (hf : support f \u2286 Set.range i)\n    (hfg : \u2200 x, f (i x) = g x) : \u2211' x, f x = \u2211' y, g y", "start": [607, 1], "end": [610, 83], "kind": "commanddeclaration"}, {"full_name": "tsum_subtype", "code": "theorem tsum_subtype (s : Set \u03b2) (f : \u03b2 \u2192 \u03b1) : \u2211' x : s, f x = \u2211' x, s.indicator f x", "start": [615, 1], "end": [616, 65], "kind": "commanddeclaration"}, {"full_name": "tsum_subtype_eq_of_support_subset", "code": "theorem tsum_subtype_eq_of_support_subset {f : \u03b2 \u2192 \u03b1} {s : Set \u03b2} (hs : support f \u2286 s) :\n    \u2211' x : s, f x = \u2211' x, f x", "start": [619, 1], "end": [621, 78], "kind": "commanddeclaration"}, {"full_name": "tsum_univ", "code": "@[simp, nolint simpNF]\ntheorem tsum_univ (f : \u03b2 \u2192 \u03b1) : \u2211' x : (Set.univ : Set \u03b2), f x = \u2211' x, f x", "start": [625, 1], "end": [627, 57], "kind": "commanddeclaration"}, {"full_name": "tsum_image", "code": "theorem tsum_image {g : \u03b3 \u2192 \u03b2} (f : \u03b2 \u2192 \u03b1) {s : Set \u03b3} (hg : Set.InjOn g s) :\n    \u2211' x : g '' s, f x = \u2211' x : s, f (g x)", "start": [630, 1], "end": [632, 62], "kind": "commanddeclaration"}, {"full_name": "tsum_range", "code": "theorem tsum_range {g : \u03b3 \u2192 \u03b2} (f : \u03b2 \u2192 \u03b1) (hg : Injective g) :\n    \u2211' x : Set.range g, f x = \u2211' x, f (g x)", "start": [635, 1], "end": [638, 53], "kind": "commanddeclaration"}, {"full_name": "tsum_add", "code": "theorem tsum_add (hf : Summable f) (hg : Summable g) :\n    \u2211' b, (f b + g b) = \u2211' b, f b + \u2211' b, g b", "start": [645, 1], "end": [647, 36], "kind": "commanddeclaration"}, {"full_name": "tsum_sum", "code": "theorem tsum_sum {f : \u03b3 \u2192 \u03b2 \u2192 \u03b1} {s : Finset \u03b3} (hf : \u2200 i \u2208 s, Summable (f i)) :\n    \u2211' b, \u2211 i in s, f i b = \u2211 i in s, \u2211' b, f i b", "start": [650, 1], "end": [652, 52], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_add_tsum_ite'", "code": "theorem tsum_eq_add_tsum_ite' {f : \u03b2 \u2192 \u03b1} (b : \u03b2) (hf : Summable (update f b 0)) :\n    \u2211' x, f x = f b + \u2211' x, ite (x = b) 0 (f x)", "start": [655, 1], "end": [668, 83], "kind": "commanddeclaration"}, {"full_name": "tsum_sigma'", "code": "theorem tsum_sigma' {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b4} (h\u2081 : \u2200 b, Summable fun c => f \u27e8b, c\u27e9)\n    (h\u2082 : Summable f) : \u2211' p, f p = \u2211' (b) (c), f \u27e8b, c\u27e9", "start": [673, 1], "end": [675, 56], "kind": "commanddeclaration"}, {"full_name": "tsum_prod'", "code": "theorem tsum_prod' {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b4} (h : Summable f) (h\u2081 : \u2200 b, Summable fun c => f (b, c)) :\n    \u2211' p, f p = \u2211' (b) (c), f (b, c)", "start": [678, 1], "end": [680, 64], "kind": "commanddeclaration"}, {"full_name": "tsum_comm'", "code": "theorem tsum_comm' {f : \u03b2 \u2192 \u03b3 \u2192 \u03b4} (h : Summable (Function.uncurry f)) (h\u2081 : \u2200 b, Summable (f b))\n    (h\u2082 : \u2200 c, Summable fun b => f b c) : \u2211' (c) (b), f b c = \u2211' (b) (c), f b c", "start": [683, 1], "end": [686, 6], "kind": "commanddeclaration"}, {"full_name": "tsum_iSup_decode\u2082", "code": "theorem tsum_iSup_decode\u2082 [CompleteLattice \u03b2] (m : \u03b2 \u2192 \u03b1) (m0 : m \u22a5 = 0) (s : \u03b3 \u2192 \u03b2) :\n    \u2211' i : \u2115, m (\u2a06 b \u2208 decode\u2082 \u03b3 i, s b) = \u2211' b : \u03b3, m (s b)", "start": [697, 1], "end": [725, 37], "kind": "commanddeclaration"}, {"full_name": "tsum_iUnion_decode\u2082", "code": "theorem tsum_iUnion_decode\u2082 (m : Set \u03b2 \u2192 \u03b1) (m0 : m \u2205 = 0) (s : \u03b3 \u2192 Set \u03b2) :\n    \u2211' i, m (\u22c3 b \u2208 decode\u2082 \u03b3 i, s b) = \u2211' b, m (s b)", "start": [728, 1], "end": [731, 27], "kind": "commanddeclaration"}, {"full_name": "rel_iSup_tsum", "code": "theorem rel_iSup_tsum [CompleteLattice \u03b2] (m : \u03b2 \u2192 \u03b1) (m0 : m \u22a5 = 0) (R : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (m_iSup : \u2200 s : \u2115 \u2192 \u03b2, R (m (\u2a06 i, s i)) (\u2211' i, m (s i))) (s : \u03b3 \u2192 \u03b2) :\n    R (m (\u2a06 b : \u03b3, s b)) (\u2211' b : \u03b3, m (s b))", "start": [747, 1], "end": [753, 17], "kind": "commanddeclaration"}, {"full_name": "rel_iSup_sum", "code": "theorem rel_iSup_sum [CompleteLattice \u03b2] (m : \u03b2 \u2192 \u03b1) (m0 : m \u22a5 = 0) (R : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (m_iSup : \u2200 s : \u2115 \u2192 \u03b2, R (m (\u2a06 i, s i)) (\u2211' i, m (s i))) (s : \u03b4 \u2192 \u03b2) (t : Finset \u03b4) :\n    R (m (\u2a06 d \u2208 t, s d)) (\u2211 d in t, m (s d))", "start": [756, 1], "end": [761, 38], "kind": "commanddeclaration"}, {"full_name": "rel_sup_add", "code": "theorem rel_sup_add [CompleteLattice \u03b2] (m : \u03b2 \u2192 \u03b1) (m0 : m \u22a5 = 0) (R : \u03b1 \u2192 \u03b1 \u2192 Prop)\n    (m_iSup : \u2200 s : \u2115 \u2192 \u03b2, R (m (\u2a06 i, s i)) (\u2211' i, m (s i))) (s\u2081 s\u2082 : \u03b2) :\n    R (m (s\u2081 \u2294 s\u2082)) (m s\u2081 + m s\u2082)", "start": [764, 1], "end": [770, 52], "kind": "commanddeclaration"}, {"full_name": "tsum_add_tsum_compl", "code": "theorem tsum_add_tsum_compl {s : Set \u03b2} (hs : Summable (f \u2218 (\u2191) : s \u2192 \u03b1))\n    (hsc : Summable (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1)) : \u2211' x : s, f x + \u2211' x : \u2191s\u1d9c, f x = \u2211' x, f x", "start": [777, 1], "end": [779, 48], "kind": "commanddeclaration"}, {"full_name": "tsum_union_disjoint", "code": "theorem tsum_union_disjoint {s t : Set \u03b2} (hd : Disjoint s t) (hs : Summable (f \u2218 (\u2191) : s \u2192 \u03b1))\n    (ht : Summable (f \u2218 (\u2191) : t \u2192 \u03b1)) : \u2211' x : \u2191(s \u222a t), f x = \u2211' x : s, f x + \u2211' x : t, f x", "start": [782, 1], "end": [784, 48], "kind": "commanddeclaration"}, {"full_name": "tsum_finset_bUnion_disjoint", "code": "theorem tsum_finset_bUnion_disjoint {\u03b9} {s : Finset \u03b9} {t : \u03b9 \u2192 Set \u03b2}\n    (hd : (s : Set \u03b9).Pairwise (Disjoint on t)) (hf : \u2200 i \u2208 s, Summable (f \u2218 (\u2191) : t i \u2192 \u03b1)) :\n    \u2211' x : \u22c3 i \u2208 s, t i, f x = \u2211 i in s, \u2211' x : t i, f x", "start": [787, 1], "end": [790, 66], "kind": "commanddeclaration"}, {"full_name": "tsum_even_add_odd", "code": "theorem tsum_even_add_odd {f : \u2115 \u2192 \u03b1} (he : Summable fun k => f (2 * k))\n    (ho : Summable fun k => f (2 * k + 1)) :\n    \u2211' k, f (2 * k) + \u2211' k, f (2 * k + 1) = \u2211' k, f k", "start": [793, 1], "end": [796, 50], "kind": "commanddeclaration"}, {"full_name": "HasSum.neg", "code": "theorem HasSum.neg (h : HasSum f a) : HasSum (fun b => -f b) (-a)", "start": [808, 1], "end": [809, 61], "kind": "commanddeclaration"}, {"full_name": "Summable.neg", "code": "theorem Summable.neg (hf : Summable f) : Summable fun b => -f b", "start": [812, 1], "end": [813, 25], "kind": "commanddeclaration"}, {"full_name": "Summable.of_neg", "code": "theorem Summable.of_neg (hf : Summable fun b => -f b) : Summable f", "start": [816, 1], "end": [817, 36], "kind": "commanddeclaration"}, {"full_name": "summable_neg_iff", "code": "theorem summable_neg_iff : (Summable fun b => -f b) \u2194 Summable f", "start": [820, 1], "end": [821, 34], "kind": "commanddeclaration"}, {"full_name": "HasSum.sub", "code": "theorem HasSum.sub (hf : HasSum f a\u2081) (hg : HasSum g a\u2082) :\n    HasSum (fun b => f b - g b) (a\u2081 - a\u2082)", "start": [824, 1], "end": [827, 22], "kind": "commanddeclaration"}, {"full_name": "Summable.sub", "code": "theorem Summable.sub (hf : Summable f) (hg : Summable g) : Summable fun b => f b - g b", "start": [830, 1], "end": [831, 37], "kind": "commanddeclaration"}, {"full_name": "Summable.trans_sub", "code": "theorem Summable.trans_sub (hg : Summable g) (hfg : Summable fun b => f b - g b) : Summable f", "start": [834, 1], "end": [835, 47], "kind": "commanddeclaration"}, {"full_name": "summable_iff_of_summable_sub", "code": "theorem summable_iff_of_summable_sub (hfg : Summable fun b => f b - g b) :\n    Summable f \u2194 Summable g", "start": [838, 1], "end": [840, 96], "kind": "commanddeclaration"}, {"full_name": "HasSum.update", "code": "theorem HasSum.update (hf : HasSum f a\u2081) (b : \u03b2) [DecidableEq \u03b2] (a : \u03b1) :\n    HasSum (update f b a) (a - f b + a\u2081)", "start": [843, 1], "end": [850, 75], "kind": "commanddeclaration"}, {"full_name": "Summable.update", "code": "theorem Summable.update (hf : Summable f) (b : \u03b2) [DecidableEq \u03b2] (a : \u03b1) :\n    Summable (update f b a)", "start": [853, 1], "end": [855, 34], "kind": "commanddeclaration"}, {"full_name": "HasSum.hasSum_compl_iff", "code": "theorem HasSum.hasSum_compl_iff {s : Set \u03b2} (hf : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a\u2081) :\n    HasSum (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1) a\u2082 \u2194 HasSum f (a\u2081 + a\u2082)", "start": [858, 1], "end": [863, 46], "kind": "commanddeclaration"}, {"full_name": "HasSum.hasSum_iff_compl", "code": "theorem HasSum.hasSum_iff_compl {s : Set \u03b2} (hf : HasSum (f \u2218 (\u2191) : s \u2192 \u03b1) a\u2081) :\n    HasSum f a\u2082 \u2194 HasSum (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1) (a\u2082 - a\u2081)", "start": [866, 1], "end": [868, 73], "kind": "commanddeclaration"}, {"full_name": "Summable.summable_compl_iff", "code": "theorem Summable.summable_compl_iff {s : Set \u03b2} (hf : Summable (f \u2218 (\u2191) : s \u2192 \u03b1)) :\n    Summable (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1) \u2194 Summable f", "start": [871, 1], "end": [874, 48], "kind": "commanddeclaration"}, {"full_name": "Finset.hasSum_compl_iff", "code": "protected theorem Finset.hasSum_compl_iff (s : Finset \u03b2) :\n    HasSum (fun x : { x // x \u2209 s } => f x) a \u2194 HasSum f (a + \u2211 i in s, f i)", "start": [877, 1], "end": [879, 58], "kind": "commanddeclaration"}, {"full_name": "Finset.hasSum_iff_compl", "code": "protected theorem Finset.hasSum_iff_compl (s : Finset \u03b2) :\n    HasSum f a \u2194 HasSum (fun x : { x // x \u2209 s } => f x) (a - \u2211 i in s, f i)", "start": [882, 1], "end": [884, 32], "kind": "commanddeclaration"}, {"full_name": "Finset.summable_compl_iff", "code": "protected theorem Finset.summable_compl_iff (s : Finset \u03b2) :\n    (Summable fun x : { x // x \u2209 s } => f x) \u2194 Summable f", "start": [887, 1], "end": [889, 36], "kind": "commanddeclaration"}, {"full_name": "Set.Finite.summable_compl_iff", "code": "theorem Set.Finite.summable_compl_iff {s : Set \u03b2} (hs : s.Finite) :\n    Summable (f \u2218 (\u2191) : \u2191s\u1d9c \u2192 \u03b1) \u2194 Summable f", "start": [892, 1], "end": [894, 37], "kind": "commanddeclaration"}, {"full_name": "hasSum_ite_sub_hasSum", "code": "theorem hasSum_ite_sub_hasSum [DecidableEq \u03b2] (hf : HasSum f a) (b : \u03b2) :\n    HasSum (fun n => ite (n = b) 0 (f n)) (a - f b)", "start": [897, 1], "end": [902, 38], "kind": "commanddeclaration"}, {"full_name": "tsum_neg", "code": "theorem tsum_neg : \u2211' b, -f b = -\u2211' b, f b", "start": [909, 1], "end": [912, 97], "kind": "commanddeclaration"}, {"full_name": "tsum_sub", "code": "theorem tsum_sub (hf : Summable f) (hg : Summable g) :\n    \u2211' b, (f b - g b) = \u2211' b, f b - \u2211' b, g b", "start": [915, 1], "end": [917, 36], "kind": "commanddeclaration"}, {"full_name": "sum_add_tsum_compl", "code": "theorem sum_add_tsum_compl {s : Finset \u03b2} (hf : Summable f) :\n    ((\u2211 x in s, f x) + \u2211' x : \u2191(s : Set \u03b2)\u1d9c, f x) = \u2211' x, f x", "start": [920, 1], "end": [922, 75], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_add_tsum_ite", "code": "theorem tsum_eq_add_tsum_ite [DecidableEq \u03b2] (hf : Summable f) (b : \u03b2) :\n    \u2211' n, f n = f b + \u2211' n, ite (n = b) 0 (f n)", "start": [925, 1], "end": [931, 41], "kind": "commanddeclaration"}, {"full_name": "hasSum_nat_add_iff", "code": "theorem hasSum_nat_add_iff {f : \u2115 \u2192 \u03b1} (k : \u2115) {a : \u03b1} :\n    HasSum (fun n => f (n + k)) a \u2194 HasSum f (a + \u2211 i in range k, f i)", "start": [945, 1], "end": [949, 6], "kind": "commanddeclaration"}, {"full_name": "summable_nat_add_iff", "code": "theorem summable_nat_add_iff {f : \u2115 \u2192 \u03b1} (k : \u2115) : (Summable fun n => f (n + k)) \u2194 Summable f", "start": [952, 1], "end": [955, 34], "kind": "commanddeclaration"}, {"full_name": "hasSum_nat_add_iff'", "code": "theorem hasSum_nat_add_iff' {f : \u2115 \u2192 \u03b1} (k : \u2115) {a : \u03b1} :\n    HasSum (fun n => f (n + k)) (a - \u2211 i in range k, f i) \u2194 HasSum f a", "start": [958, 1], "end": [960, 28], "kind": "commanddeclaration"}, {"full_name": "HasSum.sum_range_add", "code": "theorem HasSum.sum_range_add [AddCommMonoid M] [TopologicalSpace M] [ContinuousAdd M] {f : \u2115 \u2192 M}\n    {k : \u2115} {a : M} (h : HasSum (fun n \u21a6 f (n + k)) a) : HasSum f ((\u2211 i in range k, f i) + a)", "start": [963, 1], "end": [966, 47], "kind": "commanddeclaration"}, {"full_name": "sum_add_tsum_nat_add'", "code": "theorem sum_add_tsum_nat_add' [AddCommMonoid M] [TopologicalSpace M] [ContinuousAdd M] [T2Space M]\n    {f : \u2115 \u2192 M} {k : \u2115} (h : Summable (fun n => f (n + k))) :\n    ((\u2211 i in range k, f i) + \u2211' i, f (i + k)) = \u2211' i, f i", "start": [968, 1], "end": [971, 38], "kind": "commanddeclaration"}, {"full_name": "sum_add_tsum_nat_add", "code": "theorem sum_add_tsum_nat_add [T2Space \u03b1] {f : \u2115 \u2192 \u03b1} (k : \u2115) (h : Summable f) :\n    ((\u2211 i in range k, f i) + \u2211' i, f (i + k)) = \u2211' i, f i", "start": [973, 1], "end": [975, 56], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_zero_add'", "code": "theorem tsum_eq_zero_add' [AddCommMonoid M] [TopologicalSpace M] [ContinuousAdd M] [T2Space M]\n    {f : \u2115 \u2192 M} (hf : Summable (fun n => f (n + 1))) :\n    \u2211' b, f b = f 0 + \u2211' b, f (b + 1)", "start": [978, 1], "end": [981, 67], "kind": "commanddeclaration"}, {"full_name": "tsum_eq_zero_add", "code": "theorem tsum_eq_zero_add [T2Space \u03b1] {f : \u2115 \u2192 \u03b1} (hf : Summable f) :\n    \u2211' b, f b = f 0 + \u2211' b, f (b + 1)", "start": [983, 1], "end": [985, 53], "kind": "commanddeclaration"}, {"full_name": "tendsto_sum_nat_add", "code": "theorem tendsto_sum_nat_add [T2Space \u03b1] (f : \u2115 \u2192 \u03b1) :\n    Tendsto (fun i => \u2211' k, f (k + i)) atTop (\ud835\udcdd 0)", "start": [988, 1], "end": [1001, 42], "kind": "commanddeclaration"}, {"full_name": "HasSum.int_rec", "code": "theorem HasSum.int_rec {b : \u03b1} {f g : \u2115 \u2192 \u03b1} (hf : HasSum f a) (hg : HasSum g b) :\n    @HasSum \u03b1 _ _ _ (@Int.rec (fun _ => \u03b1) f g : \u2124 \u2192 \u03b1) (a + b)", "start": [1004, 1], "end": [1018, 90], "kind": "commanddeclaration"}, {"full_name": "HasSum.nonneg_add_neg", "code": "theorem HasSum.nonneg_add_neg {b : \u03b1} {f : \u2124 \u2192 \u03b1} (hnonneg : HasSum (fun n : \u2115 => f n) a)\n    (hneg : HasSum (fun n : \u2115 => f (-n.succ)) b) : HasSum f (a + b)", "start": [1021, 1], "end": [1025, 22], "kind": "commanddeclaration"}, {"full_name": "HasSum.pos_add_zero_add_neg", "code": "theorem HasSum.pos_add_zero_add_neg {b : \u03b1} {f : \u2124 \u2192 \u03b1} (hpos : HasSum (fun n : \u2115 => f (n + 1)) a)\n    (hneg : HasSum (fun n : \u2115 => f (-n.succ)) b) : HasSum f (a + f 0 + b)", "start": [1028, 1], "end": [1033, 49], "kind": "commanddeclaration"}, {"full_name": "summable_int_of_summable_nat", "code": "theorem summable_int_of_summable_nat {f : \u2124 \u2192 \u03b1} (hp : Summable fun n : \u2115 => f n)\n    (hn : Summable fun n : \u2115 => f (-n)) : Summable f", "start": [1036, 1], "end": [1038, 99], "kind": "commanddeclaration"}, {"full_name": "HasSum.sum_nat_of_sum_int", "code": "theorem HasSum.sum_nat_of_sum_int {\u03b1 : Type*} [AddCommMonoid \u03b1] [TopologicalSpace \u03b1]\n    [ContinuousAdd \u03b1] {a : \u03b1} {f : \u2124 \u2192 \u03b1} (hf : HasSum f a) :\n    HasSum (fun n : \u2115 => f n + f (-n)) (a + f 0)", "start": [1041, 1], "end": [1084, 58], "kind": "commanddeclaration"}, {"full_name": "summable_iff_cauchySeq_finset", "code": "theorem summable_iff_cauchySeq_finset [CompleteSpace \u03b1] {f : \u03b2 \u2192 \u03b1} :\n    Summable f \u2194 CauchySeq fun s : Finset \u03b2 => \u2211 b in s, f b", "start": [1095, 1], "end": [1098, 37], "kind": "commanddeclaration"}, {"full_name": "cauchySeq_finset_iff_vanishing", "code": "theorem cauchySeq_finset_iff_vanishing :\n    (CauchySeq fun s : Finset \u03b2 => \u2211 b in s, f b) \u2194\n      \u2200 e \u2208 \ud835\udcdd (0 : \u03b1), \u2203 s : Finset \u03b2, \u2200 t, Disjoint t s \u2192 (\u2211 b in t, f b) \u2208 e", "start": [1103, 1], "end": [1124, 74], "kind": "commanddeclaration"}, {"full_name": "tendsto_tsum_compl_atTop_zero", "code": "theorem tendsto_tsum_compl_atTop_zero (f : \u03b2 \u2192 \u03b1) :\n    Tendsto (fun s : Finset \u03b2 => \u2211' b : { x // x \u2209 s }, f b) atTop (\ud835\udcdd 0)", "start": [1127, 1], "end": [1150, 36], "kind": "commanddeclaration"}, {"full_name": "summable_iff_vanishing", "code": "theorem summable_iff_vanishing :\n    Summable f \u2194 \u2200 e \u2208 \ud835\udcdd (0 : \u03b1), \u2203 s : Finset \u03b2, \u2200 t, Disjoint t s \u2192 (\u2211 b in t, f b) \u2208 e", "start": [1155, 1], "end": [1157, 69], "kind": "commanddeclaration"}, {"full_name": "Summable.summable_of_eq_zero_or_self", "code": "theorem Summable.summable_of_eq_zero_or_self (hf : Summable f) (h : \u2200 b, g b = 0 \u2228 g b = f b) :\n    Summable g", "start": [1161, 1], "end": [1175, 81], "kind": "commanddeclaration"}, {"full_name": "Summable.indicator", "code": "protected theorem Summable.indicator (hf : Summable f) (s : Set \u03b2) : Summable (s.indicator f)", "start": [1178, 1], "end": [1179, 70], "kind": "commanddeclaration"}, {"full_name": "Summable.comp_injective", "code": "theorem Summable.comp_injective {i : \u03b3 \u2192 \u03b2} (hf : Summable f) (hi : Injective i) :\n    Summable (f \u2218 i)", "start": [1182, 1], "end": [1185, 97], "kind": "commanddeclaration"}, {"full_name": "Summable.subtype", "code": "theorem Summable.subtype (hf : Summable f) (s : Set \u03b2) : Summable (f \u2218 (\u2191) : s \u2192 \u03b1)", "start": [1188, 1], "end": [1189, 42], "kind": "commanddeclaration"}, {"full_name": "summable_subtype_and_compl", "code": "theorem summable_subtype_and_compl {s : Set \u03b2} :\n    ((Summable fun x : s => f x) \u2227 Summable fun x : \u2191s\u1d9c => f x) \u2194 Summable f", "start": [1192, 1], "end": [1194, 71], "kind": "commanddeclaration"}, {"full_name": "Summable.sigma_factor", "code": "theorem Summable.sigma_factor {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b1} (ha : Summable f) (b : \u03b2) :\n    Summable fun c => f \u27e8b, c\u27e9", "start": [1197, 1], "end": [1199, 39], "kind": "commanddeclaration"}, {"full_name": "Summable.sigma", "code": "theorem Summable.sigma {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b1} (ha : Summable f) :\n    Summable fun b => \u2211' c, f \u27e8b, c\u27e9", "start": [1202, 1], "end": [1204, 39], "kind": "commanddeclaration"}, {"full_name": "Summable.prod_factor", "code": "theorem Summable.prod_factor {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} (h : Summable f) (b : \u03b2) :\n    Summable fun c => f (b, c)", "start": [1207, 1], "end": [1209, 53], "kind": "commanddeclaration"}, {"full_name": "tsum_sigma", "code": "theorem tsum_sigma [T0Space \u03b1] {\u03b3 : \u03b2 \u2192 Type*} {f : (\u03a3b : \u03b2, \u03b3 b) \u2192 \u03b1} (ha : Summable f) :\n    \u2211' p, f p = \u2211' (b) (c), f \u27e8b, c\u27e9", "start": [1212, 1], "end": [1214, 46], "kind": "commanddeclaration"}, {"full_name": "tsum_prod", "code": "theorem tsum_prod [T0Space \u03b1] {f : \u03b2 \u00d7 \u03b3 \u2192 \u03b1} (h : Summable f) :\n    \u2211' p, f p = \u2211' (b) (c), f \u27e8b, c\u27e9", "start": [1217, 1], "end": [1219, 29], "kind": "commanddeclaration"}, {"full_name": "tsum_comm", "code": "theorem tsum_comm [T0Space \u03b1] {f : \u03b2 \u2192 \u03b3 \u2192 \u03b1} (h : Summable (Function.uncurry f)) :\n    \u2211' (c) (b), f b c = \u2211' (b) (c), f b c", "start": [1222, 1], "end": [1224, 53], "kind": "commanddeclaration"}, {"full_name": "tsum_subtype_add_tsum_subtype_compl", "code": "theorem tsum_subtype_add_tsum_subtype_compl [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Summable f) (s : Set \u03b2) :\n    \u2211' x : s, f x + \u2211' x : \u2191s\u1d9c, f x = \u2211' x, f x", "start": [1227, 1], "end": [1229, 87], "kind": "commanddeclaration"}, {"full_name": "sum_add_tsum_subtype_compl", "code": "theorem sum_add_tsum_subtype_compl [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Summable f) (s : Finset \u03b2) :\n    \u2211 x in s, f x + \u2211' x : { x // x \u2209 s }, f x = \u2211' x, f x", "start": [1232, 1], "end": [1236, 6], "kind": "commanddeclaration"}, {"full_name": "Summable.vanishing", "code": "theorem Summable.vanishing (hf : Summable f) \u2983e : Set G\u2984 (he : e \u2208 \ud835\udcdd (0 : G)) :\n    \u2203 s : Finset \u03b1, \u2200 t, Disjoint t s \u2192 (\u2211 k in t, f k) \u2208 e", "start": [1245, 1], "end": [1250, 59], "kind": "commanddeclaration"}, {"full_name": "Summable.tendsto_cofinite_zero", "code": "theorem Summable.tendsto_cofinite_zero (hf : Summable f) : Tendsto f cofinite (\ud835\udcdd 0)", "start": [1253, 1], "end": [1260, 54], "kind": "commanddeclaration"}, {"full_name": "Summable.tendsto_atTop_zero", "code": "theorem Summable.tendsto_atTop_zero {f : \u2115 \u2192 G} (hf : Summable f) : Tendsto f atTop (\ud835\udcdd 0)", "start": [1263, 1], "end": [1265, 33], "kind": "commanddeclaration"}, {"full_name": "Summable.countable_support", "code": "theorem Summable.countable_support [TopologicalSpace.FirstCountableTopology G] [T1Space G]\n    (hf : Summable f) : f.support.Countable", "start": [1268, 1], "end": [1270, 84], "kind": "commanddeclaration"}, {"full_name": "HasSum.const_smul", "code": "theorem HasSum.const_smul {a : \u03b1} (b : \u03b3) (hf : HasSum f a) : HasSum (fun i => b \u2022 f i) (b \u2022 a)", "start": [1279, 1], "end": [1280, 74], "kind": "commanddeclaration"}, {"full_name": "Summable.const_smul", "code": "theorem Summable.const_smul (b : \u03b3) (hf : Summable f) : Summable fun i => b \u2022 f i", "start": [1283, 1], "end": [1284, 36], "kind": "commanddeclaration"}, {"full_name": "tsum_const_smul", "code": "theorem tsum_const_smul [T2Space \u03b1] (b : \u03b3) (hf : Summable f) : \u2211' i, b \u2022 f i = b \u2022 \u2211' i, f i", "start": [1287, 1], "end": [1290, 35], "kind": "commanddeclaration"}, {"full_name": "tsum_const_smul'", "code": "lemma tsum_const_smul' {\u03b3 : Type*} [Group \u03b3] [DistribMulAction \u03b3 \u03b1] [ContinuousConstSMul \u03b3 \u03b1]\n    [T2Space \u03b1] (g : \u03b3) : \u2211' (i : \u03b2), g \u2022 f i = g \u2022 \u2211' (i : \u03b2), f i := by\n  by_cases hf : Summable f\n  \u00b7 exact tsum_const_smul g hf\n  rw [tsum_eq_zero_of_not_summable hf]\n  simp only [smul_zero]\n  let mul_g : \u03b1 \u2243+ \u03b1 := DistribMulAction.toAddEquiv \u03b1 g\n  apply tsum_eq_zero_of_not_summable\n  change \u00ac Summable (mul_g \u2218 f)\n  rwa [Summable.map_iff_of_equiv mul_g]\n  \u00b7 apply continuous_const_smul\n  \u00b7 apply continuous_const_smul", "start": [1293, 1], "end": [1306, 32], "kind": "mathlibtacticlemma"}, {"full_name": "tsum_const_smul''", "code": "lemma tsum_const_smul'' {\u03b3 : Type*} [DivisionRing \u03b3] [Module \u03b3 \u03b1] [ContinuousConstSMul \u03b3 \u03b1]\n    [T2Space \u03b1] (g : \u03b3) : \u2211' (i : \u03b2), g \u2022 f i = g \u2022 \u2211' (i : \u03b2), f i := by\n  by_cases hf : Summable f\n  \u00b7 exact tsum_const_smul g hf\n  rw [tsum_eq_zero_of_not_summable hf]\n  simp only [smul_zero]\n  by_cases hg : g = 0\n  \u00b7 simp [hg]\n  let mul_g : \u03b1 \u2243+ \u03b1 := DistribMulAction.toAddEquiv\u2080 \u03b1 g hg\n  apply tsum_eq_zero_of_not_summable\n  change \u00ac Summable (mul_g \u2218 f)\n  rwa [Summable.map_iff_of_equiv] <;> apply continuous_const_smul", "start": [1308, 1], "end": [1322, 66], "kind": "mathlibtacticlemma"}, {"full_name": "HasSum.prod_mk", "code": "theorem HasSum.prod_mk {f : \u03b2 \u2192 \u03b1} {g : \u03b2 \u2192 \u03b3} {a : \u03b1} {b : \u03b3} (hf : HasSum f a) (hg : HasSum g b) :\n    HasSum (fun x => (\u27e8f x, g x\u27e9 : \u03b1 \u00d7 \u03b3)) \u27e8a, b\u27e9", "start": [1333, 1], "end": [1335, 66], "kind": "commanddeclaration"}, {"full_name": "Pi.hasSum", "code": "theorem Pi.hasSum {f : \u03b9 \u2192 \u2200 x, \u03c0 x} {g : \u2200 x, \u03c0 x} :\n    HasSum f g \u2194 \u2200 x, HasSum (fun i => f i x) (g x)", "start": [1344, 1], "end": [1346, 49], "kind": "commanddeclaration"}, {"full_name": "Pi.summable", "code": "theorem Pi.summable {f : \u03b9 \u2192 \u2200 x, \u03c0 x} : Summable f \u2194 \u2200 x, Summable fun i => f i x", "start": [1349, 1], "end": [1350, 42], "kind": "commanddeclaration"}, {"full_name": "tsum_apply", "code": "theorem tsum_apply [\u2200 x, T2Space (\u03c0 x)] {f : \u03b9 \u2192 \u2200 x, \u03c0 x} {x : \u03b1} (hf : Summable f) :\n    (\u2211' i, f i) x = \u2211' i, f i x", "start": [1353, 1], "end": [1355, 42], "kind": "commanddeclaration"}, {"full_name": "HasSum.op", "code": "theorem HasSum.op (hf : HasSum f a) : HasSum (fun a => op (f a)) (op a)", "start": [1369, 1], "end": [1370, 47], "kind": "commanddeclaration"}, {"full_name": "Summable.op", "code": "theorem Summable.op (hf : Summable f) : Summable (op \u2218 f)", "start": [1373, 1], "end": [1374, 24], "kind": "commanddeclaration"}, {"full_name": "HasSum.unop", "code": "theorem HasSum.unop {f : \u03b2 \u2192 \u03b1\u1d50\u1d52\u1d56} {a : \u03b1\u1d50\u1d52\u1d56} (hf : HasSum f a) :\n    HasSum (fun a => unop (f a)) (unop a)", "start": [1377, 1], "end": [1379, 54], "kind": "commanddeclaration"}, {"full_name": "Summable.unop", "code": "theorem Summable.unop {f : \u03b2 \u2192 \u03b1\u1d50\u1d52\u1d56} (hf : Summable f) : Summable (unop \u2218 f)", "start": [1382, 1], "end": [1383, 26], "kind": "commanddeclaration"}, {"full_name": "hasSum_op", "code": "@[simp]\ntheorem hasSum_op : HasSum (fun a => op (f a)) (op a) \u2194 HasSum f a", "start": [1386, 1], "end": [1388, 27], "kind": "commanddeclaration"}, {"full_name": "hasSum_unop", "code": "@[simp]\ntheorem hasSum_unop {f : \u03b2 \u2192 \u03b1\u1d50\u1d52\u1d56} {a : \u03b1\u1d50\u1d52\u1d56} :\n    HasSum (fun a => unop (f a)) (unop a) \u2194 HasSum f a", "start": [1391, 1], "end": [1394, 27], "kind": "commanddeclaration"}, {"full_name": "summable_op", "code": "@[simp]\ntheorem summable_op : (Summable fun a => op (f a)) \u2194 Summable f", "start": [1397, 1], "end": [1399, 31], "kind": "commanddeclaration"}, {"full_name": "summable_unop", "code": "@[simp low]\ntheorem summable_unop {f : \u03b2 \u2192 \u03b1\u1d50\u1d52\u1d56} : (Summable fun a => unop (f a)) \u2194 Summable f", "start": [1403, 1], "end": [1405, 31], "kind": "commanddeclaration"}, {"full_name": "tsum_op", "code": "theorem tsum_op : \u2211' x, MulOpposite.op (f x) = MulOpposite.op (\u2211' x, f x)", "start": [1410, 1], "end": [1414, 94], "kind": "commanddeclaration"}, {"full_name": "tsum_unop", "code": "theorem tsum_unop {f : \u03b2 \u2192 \u03b1\u1d50\u1d52\u1d56} : \u2211' x, MulOpposite.unop (f x) = MulOpposite.unop (\u2211' x, f x)", "start": [1417, 1], "end": [1418, 40], "kind": "commanddeclaration"}, {"full_name": "HasSum.star", "code": "theorem HasSum.star (h : HasSum f a) : HasSum (fun b => star (f b)) (star a)", "start": [1431, 1], "end": [1432, 65], "kind": "commanddeclaration"}, {"full_name": "Summable.star", "code": "theorem Summable.star (hf : Summable f) : Summable fun b => star (f b)", "start": [1435, 1], "end": [1436, 26], "kind": "commanddeclaration"}, {"full_name": "Summable.ofStar", "code": "theorem Summable.ofStar (hf : Summable fun b => Star.star (f b)) : Summable f", "start": [1439, 1], "end": [1440, 39], "kind": "commanddeclaration"}, {"full_name": "summable_star_iff", "code": "@[simp]\ntheorem summable_star_iff : (Summable fun b => star (f b)) \u2194 Summable f", "start": [1443, 1], "end": [1445, 35], "kind": "commanddeclaration"}, {"full_name": "summable_star_iff'", "code": "@[simp]\ntheorem summable_star_iff' : Summable (star f) \u2194 Summable f", "start": [1448, 1], "end": [1450, 20], "kind": "commanddeclaration"}, {"full_name": "tsum_star", "code": "theorem tsum_star : star (\u2211' b, f b) = \u2211' b, star (f b)", "start": [1455, 1], "end": [1459, 17], "kind": "commanddeclaration"}, {"full_name": "MulAction.automorphize", "code": "@[to_additive \"Given an additive group `\u03b1` acting on a type `\u03b2`, and a function `f : \u03b2 \u2192 M`,\n  we automorphize `f` to a function `\u03b2 \u29f8 \u03b1 \u2192 M` by summing over `\u03b1` orbits,\n  `b \u21a6 \u2211' (a : \u03b1), f(a \u2022 b)`.\"]\nnoncomputable def MulAction.automorphize [Group \u03b1] [MulAction \u03b1 \u03b2] (f : \u03b2 \u2192 M) :\n    Quotient (MulAction.orbitRel \u03b1 \u03b2) \u2192 M := by\n  refine @Quotient.lift _ _ (_) (fun b \u21a6 \u2211' (a : \u03b1), f (a \u2022 b)) ?_\n  intro b\u2081 b\u2082 \u27e8a, (ha : a \u2022 b\u2082 = b\u2081)\u27e9\n  simp only\n  rw [\u2190 ha]\n  convert (Equiv.mulRight a).tsum_eq (fun a' \u21a6 f (a' \u2022 b\u2082)) using 1\n  simp only [Equiv.coe_mulRight]\n  congr\n  ext\n  congr 1\n  simp only [mul_smul]", "start": [1469, 1], "end": [1485, 23], "kind": "commanddeclaration"}, {"full_name": "MulAction.automorphize_smul_left", "code": "lemma MulAction.automorphize_smul_left [Group \u03b1] [MulAction \u03b1 \u03b2] (f : \u03b2 \u2192 M)\n    (g : Quotient (MulAction.orbitRel \u03b1 \u03b2) \u2192 R) :\n    MulAction.automorphize ((g \u2218 (@Quotient.mk' _ (_))) \u2022 f)\n      = g \u2022 (MulAction.automorphize f : Quotient (MulAction.orbitRel \u03b1 \u03b2) \u2192 M) := by\n  ext x\n  apply @Quotient.inductionOn' \u03b2 (MulAction.orbitRel \u03b1 \u03b2) _ x _\n  intro b\n  simp only [automorphize, Pi.smul_apply', comp_apply]\n  set \u03c0 : \u03b2 \u2192 Quotient (MulAction.orbitRel \u03b1 \u03b2) := Quotient.mk (MulAction.orbitRel \u03b1 \u03b2)\n  have H\u2081 : \u2200 a : \u03b1, \u03c0 (a \u2022 b) = \u03c0 b\n  \u00b7 intro a\n    apply (@Quotient.eq _ (MulAction.orbitRel \u03b1 \u03b2) (a \u2022 b) b).mpr\n    use a\n  change \u2211' a : \u03b1, g (\u03c0 (a \u2022 b)) \u2022 f (a \u2022 b) = g (\u03c0 b) \u2022 \u2211' a : \u03b1, f (a \u2022 b)\n  simp_rw [H\u2081]\n  exact tsum_const_smul'' _", "start": [1487, 1], "end": [1504, 28], "kind": "mathlibtacticlemma"}, {"full_name": "AddAction.automorphize_smul_left", "code": "lemma AddAction.automorphize_smul_left [AddGroup \u03b1] [AddAction \u03b1 \u03b2]  (f : \u03b2 \u2192 M)\n    (g : Quotient (AddAction.orbitRel \u03b1 \u03b2) \u2192 R) :\n    AddAction.automorphize ((g \u2218 (@Quotient.mk' _ (_))) \u2022 f)\n      = g \u2022 (AddAction.automorphize f : Quotient (AddAction.orbitRel \u03b1 \u03b2) \u2192 M) := by\n  ext x\n  apply @Quotient.inductionOn' \u03b2 (AddAction.orbitRel \u03b1 \u03b2) _ x _\n  intro b\n  simp only [automorphize, Pi.smul_apply', comp_apply]\n  set \u03c0 : \u03b2 \u2192 Quotient (AddAction.orbitRel \u03b1 \u03b2) := Quotient.mk (AddAction.orbitRel \u03b1 \u03b2)\n  have H\u2081 : \u2200 a : \u03b1, \u03c0 (a +\u1d65 b) = \u03c0 b\n  \u00b7 intro a\n    apply (@Quotient.eq _ (AddAction.orbitRel \u03b1 \u03b2) (a +\u1d65 b) b).mpr\n    use a\n  change \u2211' a : \u03b1, g (\u03c0 (a +\u1d65 b)) \u2022 f (a +\u1d65 b) = g (\u03c0 b) \u2022 \u2211' a : \u03b1, f (a +\u1d65 b)\n  simp_rw [H\u2081]\n  exact tsum_const_smul'' _", "start": [1506, 1], "end": [1523, 28], "kind": "mathlibtacticlemma"}, {"full_name": "QuotientGroup.automorphize", "code": "@[to_additive \"Given a subgroup `\u0393` of an additive group `G`, and a function `f : G \u2192 M`, we\n  automorphize `f` to a function `G \u29f8 \u0393 \u2192 M` by summing over `\u0393` orbits,\n  `g \u21a6 \u2211' (\u03b3 : \u0393), f(\u03b3 \u2022 g)`.\"]\nnoncomputable def QuotientGroup.automorphize  (f : G \u2192 M) : G \u29f8 \u0393 \u2192 M := MulAction.automorphize f", "start": [1531, 1], "end": [1536, 98], "kind": "commanddeclaration"}, {"full_name": "QuotientGroup.automorphize_smul_left", "code": "lemma QuotientGroup.automorphize_smul_left (f : G \u2192 M) (g : G \u29f8 \u0393 \u2192 R) :\n    (QuotientGroup.automorphize ((g \u2218 (@Quotient.mk' _ (_)) : G \u2192 R) \u2022 f) : G \u29f8 \u0393 \u2192 M)\n      = g \u2022 (QuotientGroup.automorphize f : G \u29f8 \u0393 \u2192 M) :=\n  MulAction.automorphize_smul_left f g", "start": [1538, 1], "end": [1543, 39], "kind": "mathlibtacticlemma"}, {"full_name": "QuotientAddGroup.automorphize_smul_left", "code": "lemma QuotientAddGroup.automorphize_smul_left (f : G \u2192 M) (g : G \u29f8 \u0393 \u2192 R) :\n    QuotientAddGroup.automorphize ((g \u2218 (@Quotient.mk' _ (_))) \u2022 f)\n      = g \u2022 (QuotientAddGroup.automorphize f : G \u29f8 \u0393 \u2192 M) :=\n  AddAction.automorphize_smul_left f g", "start": [1551, 1], "end": [1556, 39], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Topology/Algebra/Order/MonotoneConvergence.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "SupConvergenceClass", "code": "class SupConvergenceClass (\u03b1 : Type*) [Preorder \u03b1] [TopologicalSpace \u03b1] : Prop where\n  \n  tendsto_coe_atTop_isLUB :\n    \u2200 (a : \u03b1) (s : Set \u03b1), IsLUB s a \u2192 Tendsto (CoeTC.coe : s \u2192 \u03b1) atTop (\ud835\udcdd a)", "start": [37, 1], "end": [46, 79], "kind": "commanddeclaration"}, {"full_name": "InfConvergenceClass", "code": "class InfConvergenceClass (\u03b1 : Type*) [Preorder \u03b1] [TopologicalSpace \u03b1] : Prop where\n  \n  tendsto_coe_atBot_isGLB :\n    \u2200 (a : \u03b1) (s : Set \u03b1), IsGLB s a \u2192 Tendsto (CoeTC.coe : s \u2192 \u03b1) atBot (\ud835\udcdd a)", "start": [49, 1], "end": [58, 79], "kind": "commanddeclaration"}, {"full_name": "OrderDual.supConvergenceClass", "code": "instance OrderDual.supConvergenceClass [Preorder \u03b1] [TopologicalSpace \u03b1] [InfConvergenceClass \u03b1] :\n    SupConvergenceClass \u03b1\u1d52\u1d48 :=\n  \u27e8\u2039InfConvergenceClass \u03b1\u203a.1\u27e9", "start": [61, 1], "end": [63, 30], "kind": "commanddeclaration"}, {"full_name": "OrderDual.infConvergenceClass", "code": "instance OrderDual.infConvergenceClass [Preorder \u03b1] [TopologicalSpace \u03b1] [SupConvergenceClass \u03b1] :\n    InfConvergenceClass \u03b1\u1d52\u1d48 :=\n  \u27e8\u2039SupConvergenceClass \u03b1\u203a.1\u27e9", "start": [66, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.supConvergenceClass", "code": "instance (priority := 100) LinearOrder.supConvergenceClass [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] : SupConvergenceClass \u03b1 := by\n  refine' \u27e8fun a s ha => tendsto_order.2 \u27e8fun b hb => _, fun b hb => _\u27e9\u27e9\n  \u00b7 rcases ha.exists_between hb with \u27e8c, hcs, bc, bca\u27e9\n    lift c to s using hcs\n    refine' (eventually_ge_atTop c).mono fun x hx => bc.trans_le hx\n  \u00b7 exact eventually_of_forall fun x => (ha.1 x.2).trans_lt hb", "start": [72, 1], "end": [78, 63], "kind": "commanddeclaration"}, {"full_name": "LinearOrder.infConvergenceClass", "code": "instance (priority := 100) LinearOrder.infConvergenceClass [TopologicalSpace \u03b1] [LinearOrder \u03b1]\n    [OrderTopology \u03b1] : InfConvergenceClass \u03b1 :=\n  show InfConvergenceClass \u03b1\u1d52\u1d48\u1d52\u1d48 from OrderDual.infConvergenceClass", "start": [82, 1], "end": [84, 68], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_isLUB", "code": "theorem tendsto_atTop_isLUB (h_mono : Monotone f) (ha : IsLUB (Set.range f) a) :\n    Tendsto f atTop (\ud835\udcdd a)", "start": [95, 1], "end": [99, 89], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_isLUB", "code": "theorem tendsto_atBot_isLUB (h_anti : Antitone f) (ha : IsLUB (Set.range f) a) :\n    Tendsto f atBot (\ud835\udcdd a)", "start": [102, 1], "end": [103, 88], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_isGLB", "code": "theorem tendsto_atBot_isGLB (h_mono : Monotone f) (ha : IsGLB (Set.range f) a) :\n    Tendsto f atBot (\ud835\udcdd a)", "start": [112, 1], "end": [113, 88], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_isGLB", "code": "theorem tendsto_atTop_isGLB (h_anti : Antitone f) (ha : IsGLB (Set.range f) a) :\n    Tendsto f atTop (\ud835\udcdd a)", "start": [116, 1], "end": [117, 88], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_ciSup", "code": "theorem tendsto_atTop_ciSup (h_mono : Monotone f) (hbdd : BddAbove <| range f) :\n    Tendsto f atTop (\ud835\udcdd (\u2a06 i, f i))", "start": [126, 1], "end": [129, 77], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_ciSup", "code": "theorem tendsto_atBot_ciSup (h_anti : Antitone f) (hbdd : BddAbove <| range f) :\n    Tendsto f atBot (\ud835\udcdd (\u2a06 i, f i))", "start": [132, 1], "end": [133, 99], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_ciInf", "code": "theorem tendsto_atBot_ciInf (h_mono : Monotone f) (hbdd : BddBelow <| range f) :\n    Tendsto f atBot (\ud835\udcdd (\u2a05 i, f i))", "start": [142, 1], "end": [143, 99], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_ciInf", "code": "theorem tendsto_atTop_ciInf (h_anti : Antitone f) (hbdd : BddBelow <| range f) :\n    Tendsto f atTop (\ud835\udcdd (\u2a05 i, f i))", "start": [146, 1], "end": [147, 99], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_iSup", "code": "theorem tendsto_atTop_iSup (h_mono : Monotone f) : Tendsto f atTop (\ud835\udcdd (\u2a06 i, f i))", "start": [156, 1], "end": [157, 51], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_iSup", "code": "theorem tendsto_atBot_iSup (h_anti : Antitone f) : Tendsto f atBot (\ud835\udcdd (\u2a06 i, f i))", "start": [160, 1], "end": [161, 51], "kind": "commanddeclaration"}, {"full_name": "tendsto_atBot_iInf", "code": "theorem tendsto_atBot_iInf (h_mono : Monotone f) : Tendsto f atBot (\ud835\udcdd (\u2a05 i, f i))", "start": [170, 1], "end": [171, 51], "kind": "commanddeclaration"}, {"full_name": "tendsto_atTop_iInf", "code": "theorem tendsto_atTop_iInf (h_anti : Antitone f) : Tendsto f atTop (\ud835\udcdd (\u2a05 i, f i))", "start": [174, 1], "end": [175, 51], "kind": "commanddeclaration"}, {"full_name": "Prod.supConvergenceClass", "code": "instance Prod.supConvergenceClass\n    [Preorder \u03b1] [Preorder \u03b2] [TopologicalSpace \u03b1] [TopologicalSpace \u03b2]\n    [SupConvergenceClass \u03b1] [SupConvergenceClass \u03b2] : SupConvergenceClass (\u03b1 \u00d7 \u03b2) := by\n  constructor\n  rintro \u27e8a, b\u27e9 s h\n  rw [isLUB_prod, \u2190 range_restrict, \u2190 range_restrict] at h\n  have A : Tendsto (fun x : s => (x : \u03b1 \u00d7 \u03b2).1) atTop (\ud835\udcdd a) :=\n    tendsto_atTop_isLUB (monotone_fst.restrict s) h.1\n  have B : Tendsto (fun x : s => (x : \u03b1 \u00d7 \u03b2).2) atTop (\ud835\udcdd b) :=\n    tendsto_atTop_isLUB (monotone_snd.restrict s) h.2\n  convert A.prod_mk_nhds B", "start": [182, 1], "end": [192, 27], "kind": "commanddeclaration"}, {"full_name": "Pi.supConvergenceClass", "code": "instance Pi.supConvergenceClass\n    {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, TopologicalSpace (\u03b1 i)]\n    [\u2200 i, SupConvergenceClass (\u03b1 i)] : SupConvergenceClass (\u2200 i, \u03b1 i) := by\n  refine' \u27e8fun f s h => _\u27e9\n  simp only [isLUB_pi, \u2190 range_restrict] at h\n  exact tendsto_pi_nhds.2 fun i => tendsto_atTop_isLUB ((monotone_eval _).restrict _) (h i)", "start": [201, 1], "end": [206, 92], "kind": "commanddeclaration"}, {"full_name": "Pi.infConvergenceClass", "code": "instance Pi.infConvergenceClass\n    {\u03b9 : Type*} {\u03b1 : \u03b9 \u2192 Type*} [\u2200 i, Preorder (\u03b1 i)] [\u2200 i, TopologicalSpace (\u03b1 i)]\n    [\u2200 i, InfConvergenceClass (\u03b1 i)] : InfConvergenceClass (\u2200 i, \u03b1 i) :=\n  show InfConvergenceClass (\u2200 i, (\u03b1 i)\u1d52\u1d48)\u1d52\u1d48 from OrderDual.infConvergenceClass", "start": [208, 1], "end": [211, 79], "kind": "commanddeclaration"}, {"full_name": "Pi.supConvergenceClass'", "code": "instance Pi.supConvergenceClass' {\u03b9 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1]\n    [SupConvergenceClass \u03b1] : SupConvergenceClass (\u03b9 \u2192 \u03b1) :=\n  supConvergenceClass", "start": [213, 1], "end": [215, 22], "kind": "commanddeclaration"}, {"full_name": "Pi.infConvergenceClass'", "code": "instance Pi.infConvergenceClass' {\u03b9 : Type*} [Preorder \u03b1] [TopologicalSpace \u03b1]\n    [InfConvergenceClass \u03b1] : InfConvergenceClass (\u03b9 \u2192 \u03b1) :=\n  Pi.infConvergenceClass", "start": [218, 1], "end": [220, 25], "kind": "commanddeclaration"}, {"full_name": "tendsto_of_monotone", "code": "theorem tendsto_of_monotone {\u03b9 \u03b1 : Type*} [Preorder \u03b9] [TopologicalSpace \u03b1]\n    [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1] {f : \u03b9 \u2192 \u03b1} (h_mono : Monotone f) :\n    Tendsto f atTop atTop \u2228 \u2203 l, Tendsto f atTop (\ud835\udcdd l)", "start": [223, 1], "end": [227, 59], "kind": "commanddeclaration"}, {"full_name": "tendsto_iff_tendsto_subseq_of_monotone", "code": "theorem tendsto_iff_tendsto_subseq_of_monotone {\u03b9\u2081 \u03b9\u2082 \u03b1 : Type*} [SemilatticeSup \u03b9\u2081] [Preorder \u03b9\u2082]\n    [Nonempty \u03b9\u2081] [TopologicalSpace \u03b1] [ConditionallyCompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [NoMaxOrder \u03b1] {f : \u03b9\u2082 \u2192 \u03b1} {\u03c6 : \u03b9\u2081 \u2192 \u03b9\u2082} {l : \u03b1} (hf : Monotone f)\n    (hg : Tendsto \u03c6 atTop atTop) : Tendsto f atTop (\ud835\udcdd l) \u2194 Tendsto (f \u2218 \u03c6) atTop (\ud835\udcdd l)", "start": [230, 1], "end": [238, 48], "kind": "commanddeclaration"}, {"full_name": "Monotone.ge_of_tendsto", "code": "theorem Monotone.ge_of_tendsto [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f) (ha : Tendsto f atTop (\ud835\udcdd a)) (b : \u03b2) :\n    f b \u2264 a", "start": [249, 1], "end": [253, 77], "kind": "commanddeclaration"}, {"full_name": "Monotone.le_of_tendsto", "code": "theorem Monotone.le_of_tendsto [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [SemilatticeInf \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f) (ha : Tendsto f atBot (\ud835\udcdd a)) (b : \u03b2) :\n    a \u2264 f b", "start": [256, 1], "end": [259, 29], "kind": "commanddeclaration"}, {"full_name": "Antitone.le_of_tendsto", "code": "theorem Antitone.le_of_tendsto [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Antitone f) (ha : Tendsto f atTop (\ud835\udcdd a)) (b : \u03b2) :\n    a \u2264 f b", "start": [262, 1], "end": [265, 35], "kind": "commanddeclaration"}, {"full_name": "Antitone.ge_of_tendsto", "code": "theorem Antitone.ge_of_tendsto [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [SemilatticeInf \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Antitone f) (ha : Tendsto f atBot (\ud835\udcdd a)) (b : \u03b2) :\n    f b \u2264 a", "start": [268, 1], "end": [271, 35], "kind": "commanddeclaration"}, {"full_name": "isLUB_of_tendsto_atTop", "code": "theorem isLUB_of_tendsto_atTop [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f)\n    (ha : Tendsto f atTop (\ud835\udcdd a)) : IsLUB (Set.range f) a", "start": [274, 1], "end": [280, 75], "kind": "commanddeclaration"}, {"full_name": "isGLB_of_tendsto_atBot", "code": "theorem isGLB_of_tendsto_atBot [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeInf \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f)\n    (ha : Tendsto f atBot (\ud835\udcdd a)) : IsGLB (Set.range f) a", "start": [283, 1], "end": [286, 59], "kind": "commanddeclaration"}, {"full_name": "isLUB_of_tendsto_atBot", "code": "theorem isLUB_of_tendsto_atBot [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeInf \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Antitone f)\n    (ha : Tendsto f atBot (\ud835\udcdd a)) : IsLUB (Set.range f) a", "start": [289, 1], "end": [292, 62], "kind": "commanddeclaration"}, {"full_name": "isGLB_of_tendsto_atTop", "code": "theorem isGLB_of_tendsto_atTop [TopologicalSpace \u03b1] [Preorder \u03b1] [OrderClosedTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Antitone f)\n    (ha : Tendsto f atTop (\ud835\udcdd a)) : IsGLB (Set.range f) a", "start": [295, 1], "end": [298, 62], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_of_tendsto", "code": "theorem iSup_eq_of_tendsto {\u03b1 \u03b2} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Monotone f) :\n    Tendsto f atTop (\ud835\udcdd a) \u2192 iSup f = a", "start": [301, 1], "end": [304, 46], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_of_tendsto", "code": "theorem iInf_eq_of_tendsto {\u03b1} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n    [Nonempty \u03b2] [SemilatticeSup \u03b2] {f : \u03b2 \u2192 \u03b1} {a : \u03b1} (hf : Antitone f) :\n    Tendsto f atTop (\ud835\udcdd a) \u2192 iInf f = a", "start": [307, 1], "end": [310, 46], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_iSup_subseq_of_monotone", "code": "theorem iSup_eq_iSup_subseq_of_monotone {\u03b9\u2081 \u03b9\u2082 \u03b1 : Type*} [Preorder \u03b9\u2082] [CompleteLattice \u03b1]\n    {l : Filter \u03b9\u2081} [l.NeBot] {f : \u03b9\u2082 \u2192 \u03b1} {\u03c6 : \u03b9\u2081 \u2192 \u03b9\u2082} (hf : Monotone f)\n    (h\u03c6 : Tendsto \u03c6 l atTop) : \u2a06 i, f i = \u2a06 i, f (\u03c6 i)", "start": [313, 1], "end": [319, 40], "kind": "commanddeclaration"}, {"full_name": "iSup_eq_iSup_subseq_of_antitone", "code": "theorem iSup_eq_iSup_subseq_of_antitone {\u03b9\u2081 \u03b9\u2082 \u03b1 : Type*} [Preorder \u03b9\u2082] [CompleteLattice \u03b1]\n    {l : Filter \u03b9\u2081} [l.NeBot] {f : \u03b9\u2082 \u2192 \u03b1} {\u03c6 : \u03b9\u2081 \u2192 \u03b9\u2082} (hf : Antitone f)\n    (h\u03c6 : Tendsto \u03c6 l atBot) : \u2a06 i, f i = \u2a06 i, f (\u03c6 i)", "start": [322, 1], "end": [328, 40], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_iInf_subseq_of_monotone", "code": "theorem iInf_eq_iInf_subseq_of_monotone {\u03b9\u2081 \u03b9\u2082 \u03b1 : Type*} [Preorder \u03b9\u2082] [CompleteLattice \u03b1]\n    {l : Filter \u03b9\u2081} [l.NeBot] {f : \u03b9\u2082 \u2192 \u03b1} {\u03c6 : \u03b9\u2081 \u2192 \u03b9\u2082} (hf : Monotone f)\n    (h\u03c6 : Tendsto \u03c6 l atBot) : \u2a05 i, f i = \u2a05 i, f (\u03c6 i)", "start": [331, 1], "end": [334, 45], "kind": "commanddeclaration"}, {"full_name": "iInf_eq_iInf_subseq_of_antitone", "code": "theorem iInf_eq_iInf_subseq_of_antitone {\u03b9\u2081 \u03b9\u2082 \u03b1 : Type*} [Preorder \u03b9\u2082] [CompleteLattice \u03b1]\n    {l : Filter \u03b9\u2081} [l.NeBot] {f : \u03b9\u2082 \u2192 \u03b1} {\u03c6 : \u03b9\u2081 \u2192 \u03b9\u2082} (hf : Antitone f)\n    (h\u03c6 : Tendsto \u03c6 l atTop) : \u2a05 i, f i = \u2a05 i, f (\u03c6 i)", "start": [337, 1], "end": [340, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Periodic.lean", "imports": ["Mathlib/GroupTheory/Coset.lean", "Mathlib/Algebra/Order/Archimedean.lean", "Mathlib/Data/Int/Parity.lean", "Mathlib/GroupTheory/Submonoid/Membership.lean", "Mathlib/GroupTheory/Subgroup/ZPowers.lean", "Mathlib/Algebra/Module/Basic.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Field/Opposite.lean"], "premises": [{"full_name": "Function.Periodic", "code": "@[simp]\ndef Periodic [Add \u03b1] (f : \u03b1 \u2192 \u03b2) (c : \u03b1) : Prop :=\n  \u2200 x : \u03b1, f (x + c) = f x", "start": [47, 1], "end": [50, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.funext", "code": "protected theorem Periodic.funext [Add \u03b1] (h : Periodic f c) : (fun x => f (x + c)) = f", "start": [53, 1], "end": [54, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.comp", "code": "protected theorem Periodic.comp [Add \u03b1] (h : Periodic f c) (g : \u03b2 \u2192 \u03b3) : Periodic (g \u2218 f) c", "start": [57, 1], "end": [58, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.comp_addHom", "code": "theorem Periodic.comp_addHom [Add \u03b1] [Add \u03b3] (h : Periodic f c) (g : AddHom \u03b3 \u03b1) (g_inv : \u03b1 \u2192 \u03b3)\n    (hg : RightInverse g_inv g) : Periodic (f \u2218 g) (g_inv c)", "start": [61, 1], "end": [63, 49], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.mul", "code": "@[to_additive]\nprotected theorem Periodic.mul [Add \u03b1] [Mul \u03b2] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f * g) c", "start": [66, 1], "end": [68, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.div", "code": "@[to_additive]\nprotected theorem Periodic.div [Add \u03b1] [Div \u03b2] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f / g) c", "start": [72, 1], "end": [74, 38], "kind": "commanddeclaration"}, {"full_name": "List.periodic_prod", "code": "@[to_additive]\ntheorem _root_.List.periodic_prod [Add \u03b1] [Monoid \u03b2] (l : List (\u03b1 \u2192 \u03b2))\n    (hl : \u2200 f \u2208 l, Periodic f c) : Periodic l.prod c", "start": [78, 1], "end": [84, 57], "kind": "commanddeclaration"}, {"full_name": "Multiset.periodic_prod", "code": "@[to_additive]\ntheorem _root_.Multiset.periodic_prod [Add \u03b1] [CommMonoid \u03b2] (s : Multiset (\u03b1 \u2192 \u03b2))\n    (hs : \u2200 f \u2208 s, Periodic f c) : Periodic s.prod c", "start": [88, 1], "end": [91, 89], "kind": "commanddeclaration"}, {"full_name": "Finset.periodic_prod", "code": "@[to_additive]\ntheorem _root_.Finset.periodic_prod [Add \u03b1] [CommMonoid \u03b2] {\u03b9 : Type*} {f : \u03b9 \u2192 \u03b1 \u2192 \u03b2}\n    (s : Finset \u03b9) (hs : \u2200 i \u2208 s, Periodic (f i) c) : Periodic (\u220f i in s, f i) c", "start": [95, 1], "end": [98, 76], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.smul", "code": "@[to_additive]\nprotected theorem Periodic.smul [Add \u03b1] [SMul \u03b3 \u03b2] (h : Periodic f c) (a : \u03b3) :\n    Periodic (a \u2022 f) c", "start": [102, 1], "end": [104, 38], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_smul", "code": "protected theorem Periodic.const_smul [AddMonoid \u03b1] [Group \u03b3] [DistribMulAction \u03b3 \u03b1]\n    (h : Periodic f c) (a : \u03b3) : Periodic (fun x => f (a \u2022 x)) (a\u207b\u00b9 \u2022 c)", "start": [108, 1], "end": [110, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_smul\u2080", "code": "protected theorem Periodic.const_smul\u2080 [AddCommMonoid \u03b1] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Periodic f c) (a : \u03b3) : Periodic (fun x => f (a \u2022 x)) (a\u207b\u00b9 \u2022 c)", "start": [113, 1], "end": [117, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_mul", "code": "protected theorem Periodic.const_mul [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (a * x)) (a\u207b\u00b9 * c)", "start": [120, 1], "end": [122, 27], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_inv_smul", "code": "theorem Periodic.const_inv_smul [AddMonoid \u03b1] [Group \u03b3] [DistribMulAction \u03b3 \u03b1] (h : Periodic f c)\n    (a : \u03b3) : Periodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c)", "start": [125, 1], "end": [127, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_inv_smul\u2080", "code": "theorem Periodic.const_inv_smul\u2080 [AddCommMonoid \u03b1] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Periodic f c) (a : \u03b3) : Periodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c)", "start": [130, 1], "end": [132, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_inv_mul", "code": "theorem Periodic.const_inv_mul [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (a\u207b\u00b9 * x)) (a * c)", "start": [135, 1], "end": [137, 22], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.mul_const", "code": "theorem Periodic.mul_const [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x * a)) (c * a\u207b\u00b9)", "start": [140, 1], "end": [142, 35], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.mul_const'", "code": "theorem Periodic.mul_const' [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x * a)) (c / a)", "start": [145, 1], "end": [146, 96], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.mul_const_inv", "code": "theorem Periodic.mul_const_inv [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x * a\u207b\u00b9)) (c * a)", "start": [149, 1], "end": [151, 39], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.div_const", "code": "theorem Periodic.div_const [DivisionSemiring \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x / a)) (c * a)", "start": [154, 1], "end": [155, 100], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.add_period", "code": "theorem Periodic.add_period [AddSemigroup \u03b1] (h1 : Periodic f c\u2081) (h2 : Periodic f c\u2082) :\n    Periodic f (c\u2081 + c\u2082)", "start": [158, 1], "end": [159, 54], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_eq", "code": "theorem Periodic.sub_eq [AddGroup \u03b1] (h : Periodic f c) (x : \u03b1) : f (x - c) = f x", "start": [162, 1], "end": [163, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_eq'", "code": "theorem Periodic.sub_eq' [AddCommGroup \u03b1] (h : Periodic f c) : f (c - x) = f (-x)", "start": [166, 1], "end": [167, 43], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.neg", "code": "protected theorem Periodic.neg [AddGroup \u03b1] (h : Periodic f c) : Periodic f (-c)", "start": [170, 1], "end": [171, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_period", "code": "theorem Periodic.sub_period [AddGroup \u03b1] (h1 : Periodic f c\u2081) (h2 : Periodic f c\u2082) :\n    Periodic f (c\u2081 - c\u2082)", "start": [174, 1], "end": [176, 47], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_add", "code": "theorem Periodic.const_add [AddSemigroup \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (a + x)) c", "start": [179, 1], "end": [180, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.add_const", "code": "theorem Periodic.add_const [AddCommSemigroup \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x + a)) c", "start": [183, 1], "end": [185, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.const_sub", "code": "theorem Periodic.const_sub [AddCommGroup \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (a - x)) c", "start": [188, 1], "end": [190, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_const", "code": "theorem Periodic.sub_const [AddCommGroup \u03b1] (h : Periodic f c) (a : \u03b1) :\n    Periodic (fun x => f (x - a)) c", "start": [193, 1], "end": [195, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nsmul", "code": "theorem Periodic.nsmul [AddMonoid \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (n \u2022 c)", "start": [198, 1], "end": [199, 85], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nat_mul", "code": "theorem Periodic.nat_mul [Semiring \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (n * c)", "start": [202, 1], "end": [203, 44], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.neg_nsmul", "code": "theorem Periodic.neg_nsmul [AddGroup \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (-(n \u2022 c))", "start": [206, 1], "end": [207, 18], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.neg_nat_mul", "code": "theorem Periodic.neg_nat_mul [Ring \u03b1] (h : Periodic f c) (n : \u2115) : Periodic f (-(n * c))", "start": [210, 1], "end": [211, 20], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_nsmul_eq", "code": "theorem Periodic.sub_nsmul_eq [AddGroup \u03b1] (h : Periodic f c) (n : \u2115) : f (x - n \u2022 c) = f x", "start": [214, 1], "end": [215, 52], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_nat_mul_eq", "code": "theorem Periodic.sub_nat_mul_eq [Ring \u03b1] (h : Periodic f c) (n : \u2115) : f (x - n * c) = f x", "start": [218, 1], "end": [219, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nsmul_sub_eq", "code": "theorem Periodic.nsmul_sub_eq [AddCommGroup \u03b1] (h : Periodic f c) (n : \u2115) :\n    f (n \u2022 c - x) = f (-x)", "start": [222, 1], "end": [224, 22], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nat_mul_sub_eq", "code": "theorem Periodic.nat_mul_sub_eq [Ring \u03b1] (h : Periodic f c) (n : \u2115) : f (n * c - x) = f (-x)", "start": [227, 1], "end": [228, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.zsmul", "code": "protected theorem Periodic.zsmul [AddGroup \u03b1] (h : Periodic f c) (n : \u2124) : Periodic f (n \u2022 c)", "start": [231, 1], "end": [234, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.int_mul", "code": "protected theorem Periodic.int_mul [Ring \u03b1] (h : Periodic f c) (n : \u2124) : Periodic f (n * c)", "start": [237, 1], "end": [238, 44], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_zsmul_eq", "code": "theorem Periodic.sub_zsmul_eq [AddGroup \u03b1] (h : Periodic f c) (n : \u2124) : f (x - n \u2022 c) = f x", "start": [241, 1], "end": [242, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_int_mul_eq", "code": "theorem Periodic.sub_int_mul_eq [Ring \u03b1] (h : Periodic f c) (n : \u2124) : f (x - n * c) = f x", "start": [245, 1], "end": [246, 25], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.zsmul_sub_eq", "code": "theorem Periodic.zsmul_sub_eq [AddCommGroup \u03b1] (h : Periodic f c) (n : \u2124) :\n    f (n \u2022 c - x) = f (-x)", "start": [249, 1], "end": [251, 22], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.int_mul_sub_eq", "code": "theorem Periodic.int_mul_sub_eq [Ring \u03b1] (h : Periodic f c) (n : \u2124) : f (n * c - x) = f (-x)", "start": [254, 1], "end": [255, 24], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.eq", "code": "protected theorem Periodic.eq [AddZeroClass \u03b1] (h : Periodic f c) : f c = f 0", "start": [258, 1], "end": [259, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.neg_eq", "code": "protected theorem Periodic.neg_eq [AddGroup \u03b1] (h : Periodic f c) : f (-c) = f 0", "start": [262, 1], "end": [263, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nsmul_eq", "code": "protected theorem Periodic.nsmul_eq [AddMonoid \u03b1] (h : Periodic f c) (n : \u2115) : f (n \u2022 c) = f 0", "start": [266, 1], "end": [267, 17], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.nat_mul_eq", "code": "theorem Periodic.nat_mul_eq [Semiring \u03b1] (h : Periodic f c) (n : \u2115) : f (n * c) = f 0", "start": [270, 1], "end": [271, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.zsmul_eq", "code": "theorem Periodic.zsmul_eq [AddGroup \u03b1] (h : Periodic f c) (n : \u2124) : f (n \u2022 c) = f 0", "start": [274, 1], "end": [275, 17], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.int_mul_eq", "code": "theorem Periodic.int_mul_eq [Ring \u03b1] (h : Periodic f c) (n : \u2124) : f (n * c) = f 0", "start": [278, 1], "end": [279, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.exists_mem_Ico\u2080", "code": "theorem Periodic.exists_mem_Ico\u2080 [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : 0 < c) (x) : \u2203 y \u2208 Ico 0 c, f x = f y", "start": [282, 1], "end": [287, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.exists_mem_Ico", "code": "theorem Periodic.exists_mem_Ico [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : 0 < c) (x a) : \u2203 y \u2208 Ico a (a + c), f x = f y", "start": [290, 1], "end": [295, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.exists_mem_Ioc", "code": "theorem Periodic.exists_mem_Ioc [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : 0 < c) (x a) : \u2203 y \u2208 Ioc a (a + c), f x = f y", "start": [298, 1], "end": [303, 37], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.image_Ioc", "code": "theorem Periodic.image_Ioc [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : 0 < c) (a : \u03b1) : f '' Ioc a (a + c) = range f", "start": [306, 1], "end": [310, 22], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.image_Icc", "code": "theorem Periodic.image_Icc [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : 0 < c) (a : \u03b1) : f '' Icc a (a + c) = range f", "start": [313, 1], "end": [315, 93], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.image_uIcc", "code": "theorem Periodic.image_uIcc [LinearOrderedAddCommGroup \u03b1] [Archimedean \u03b1] (h : Periodic f c)\n    (hc : c \u2260 0) (a : \u03b1) : f '' uIcc a (a + c) = range f", "start": [317, 1], "end": [323, 77], "kind": "commanddeclaration"}, {"full_name": "Function.periodic_with_period_zero", "code": "theorem periodic_with_period_zero [AddZeroClass \u03b1] (f : \u03b1 \u2192 \u03b2) : Periodic f 0", "start": [325, 1], "end": [326, 16], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.map_vadd_zmultiples", "code": "theorem Periodic.map_vadd_zmultiples [AddCommGroup \u03b1] (hf : Periodic f c)\n    (a : AddSubgroup.zmultiples c) (x : \u03b1) : f (a +\u1d65 x) = f x", "start": [329, 1], "end": [332, 58], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.map_vadd_multiples", "code": "theorem Periodic.map_vadd_multiples [AddCommMonoid \u03b1] (hf : Periodic f c)\n    (a : AddSubmonoid.multiples c) (x : \u03b1) : f (a +\u1d65 x) = f x", "start": [335, 1], "end": [338, 59], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.lift", "code": "def Periodic.lift [AddGroup \u03b1] (h : Periodic f c) (x : \u03b1 \u29f8 AddSubgroup.zmultiples c) : \u03b2 :=\n  Quotient.liftOn' x f fun a b h' => by\n    rw [QuotientAddGroup.leftRel_apply] at h'\n    obtain \u27e8k, hk\u27e9 := h'\n    exact (h.zsmul k _).symm.trans (congr_arg f (add_eq_of_eq_neg_add hk))", "start": [341, 1], "end": [346, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.lift_coe", "code": "@[simp]\ntheorem Periodic.lift_coe [AddGroup \u03b1] (h : Periodic f c) (a : \u03b1) :\n    h.lift (a : \u03b1 \u29f8 AddSubgroup.zmultiples c) = f a", "start": [349, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic", "code": "@[simp]\ndef Antiperiodic [Add \u03b1] [Neg \u03b2] (f : \u03b1 \u2192 \u03b2) (c : \u03b1) : Prop :=\n  \u2200 x : \u03b1, f (x + c) = -f x", "start": [357, 1], "end": [361, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.funext", "code": "protected theorem Antiperiodic.funext [Add \u03b1] [Neg \u03b2] (h : Antiperiodic f c) :\n    (fun x => f (x + c)) = -f", "start": [364, 1], "end": [366, 11], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.funext'", "code": "protected theorem Antiperiodic.funext' [Add \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) :\n    (fun x => -f (x + c)) = f", "start": [369, 1], "end": [371, 33], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.periodic", "code": "protected theorem Antiperiodic.periodic [Semiring \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) :\n    Periodic f (2 * c)", "start": [374, 1], "end": [377, 62], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.eq", "code": "protected theorem Antiperiodic.eq [AddZeroClass \u03b1] [Neg \u03b2] (h : Antiperiodic f c) : f c = -f 0", "start": [380, 1], "end": [381, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.nat_even_mul_periodic", "code": "theorem Antiperiodic.nat_even_mul_periodic [Semiring \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c)\n    (n : \u2115) : Periodic f (n * (2 * c))", "start": [384, 1], "end": [386, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.nat_odd_mul_antiperiodic", "code": "theorem Antiperiodic.nat_odd_mul_antiperiodic [Semiring \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c)\n    (n : \u2115) : Antiperiodic f (n * (2 * c) + c)", "start": [389, 1], "end": [391, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.int_even_mul_periodic", "code": "theorem Antiperiodic.int_even_mul_periodic [Ring \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c)\n    (n : \u2124) : Periodic f (n * (2 * c))", "start": [394, 1], "end": [396, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.int_odd_mul_antiperiodic", "code": "theorem Antiperiodic.int_odd_mul_antiperiodic [Ring \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c)\n    (n : \u2124) : Antiperiodic f (n * (2 * c) + c)", "start": [399, 1], "end": [401, 42], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.sub_eq", "code": "theorem Antiperiodic.sub_eq [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) (x : \u03b1) :\n    f (x - c) = -f x", "start": [404, 1], "end": [405, 88], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.sub_eq'", "code": "theorem Antiperiodic.sub_eq' [AddCommGroup \u03b1] [Neg \u03b2] (h : Antiperiodic f c) :\n    f (c - x) = -f (-x)", "start": [408, 1], "end": [409, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.neg", "code": "protected theorem Antiperiodic.neg [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) :\n    Antiperiodic f (-c)", "start": [412, 1], "end": [413, 87], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.neg_eq", "code": "theorem Antiperiodic.neg_eq [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) : f (-c) = -f 0", "start": [416, 1], "end": [417, 41], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.nat_mul_eq_of_eq_zero", "code": "theorem Antiperiodic.nat_mul_eq_of_eq_zero [Semiring \u03b1] [NegZeroClass \u03b2] (h : Antiperiodic f c)\n    (hi : f 0 = 0) : \u2200 n : \u2115, f (n * c) = 0", "start": [420, 1], "end": [423, 79], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.int_mul_eq_of_eq_zero", "code": "theorem Antiperiodic.int_mul_eq_of_eq_zero [Ring \u03b1] [SubtractionMonoid \u03b2] (h : Antiperiodic f c)\n    (hi : f 0 = 0) : \u2200 n : \u2124, f (n * c) = 0", "start": [426, 1], "end": [429, 95], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_add", "code": "theorem Antiperiodic.const_add [AddSemigroup \u03b1] [Neg \u03b2] (h : Antiperiodic f c) (a : \u03b1) :\n    Antiperiodic (fun x => f (a + x)) c", "start": [432, 1], "end": [433, 89], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.add_const", "code": "theorem Antiperiodic.add_const [AddCommSemigroup \u03b1] [Neg \u03b2] (h : Antiperiodic f c) (a : \u03b1) :\n    Antiperiodic (fun x => f (x + a)) c", "start": [436, 1], "end": [438, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_sub", "code": "theorem Antiperiodic.const_sub [AddCommGroup \u03b1] [InvolutiveNeg \u03b2] (h : Antiperiodic f c) (a : \u03b1) :\n    Antiperiodic (fun x => f (a - x)) c", "start": [441, 1], "end": [443, 34], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.sub_const", "code": "theorem Antiperiodic.sub_const [AddCommGroup \u03b1] [Neg \u03b2] (h : Antiperiodic f c) (a : \u03b1) :\n    Antiperiodic (fun x => f (x - a)) c", "start": [446, 1], "end": [448, 53], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.smul", "code": "theorem Antiperiodic.smul [Add \u03b1] [Monoid \u03b3] [AddGroup \u03b2] [DistribMulAction \u03b3 \u03b2]\n    (h : Antiperiodic f c) (a : \u03b3) : Antiperiodic (a \u2022 f) c", "start": [451, 1], "end": [452, 75], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_smul", "code": "theorem Antiperiodic.const_smul [AddMonoid \u03b1] [Neg \u03b2] [Group \u03b3] [DistribMulAction \u03b3 \u03b1]\n    (h : Antiperiodic f c) (a : \u03b3) : Antiperiodic (fun x => f (a \u2022 x)) (a\u207b\u00b9 \u2022 c)", "start": [455, 1], "end": [457, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_smul\u2080", "code": "theorem Antiperiodic.const_smul\u2080 [AddCommMonoid \u03b1] [Neg \u03b2] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Antiperiodic f c) {a : \u03b3} (ha : a \u2260 0) : Antiperiodic (fun x => f (a \u2022 x)) (a\u207b\u00b9 \u2022 c)", "start": [460, 1], "end": [462, 71], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_mul", "code": "theorem Antiperiodic.const_mul [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (a * x)) (a\u207b\u00b9 * c)", "start": [465, 1], "end": [467, 19], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_inv_smul", "code": "theorem Antiperiodic.const_inv_smul [AddMonoid \u03b1] [Neg \u03b2] [Group \u03b3] [DistribMulAction \u03b3 \u03b1]\n    (h : Antiperiodic f c) (a : \u03b3) : Antiperiodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c)", "start": [470, 1], "end": [472, 46], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_inv_smul\u2080", "code": "theorem Antiperiodic.const_inv_smul\u2080 [AddCommMonoid \u03b1] [Neg \u03b2] [DivisionSemiring \u03b3] [Module \u03b3 \u03b1]\n    (h : Antiperiodic f c) {a : \u03b3} (ha : a \u2260 0) : Antiperiodic (fun x => f (a\u207b\u00b9 \u2022 x)) (a \u2022 c)", "start": [475, 1], "end": [477, 60], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.const_inv_mul", "code": "theorem Antiperiodic.const_inv_mul [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (a\u207b\u00b9 * x)) (a * c)", "start": [480, 1], "end": [482, 23], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.mul_const", "code": "theorem Antiperiodic.mul_const [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x * a)) (c * a\u207b\u00b9)", "start": [485, 1], "end": [487, 57], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.mul_const'", "code": "theorem Antiperiodic.mul_const' [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x * a)) (c / a)", "start": [490, 1], "end": [492, 51], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.mul_const_inv", "code": "theorem Antiperiodic.mul_const_inv [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x * a\u207b\u00b9)) (c * a)", "start": [495, 1], "end": [497, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.div_inv", "code": "theorem Antiperiodic.div_inv [DivisionSemiring \u03b1] [Neg \u03b2] (h : Antiperiodic f c) {a : \u03b1}\n    (ha : a \u2260 0) : Antiperiodic (fun x => f (x / a)) (c * a)", "start": [500, 1], "end": [502, 55], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.add", "code": "theorem Antiperiodic.add [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Antiperiodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Periodic f (c\u2081 + c\u2082)", "start": [505, 1], "end": [506, 81], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.sub", "code": "theorem Antiperiodic.sub [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Antiperiodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Periodic f (c\u2081 - c\u2082)", "start": [509, 1], "end": [511, 50], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.add_antiperiod", "code": "theorem Periodic.add_antiperiod [AddGroup \u03b1] [Neg \u03b2] (h1 : Periodic f c\u2081) (h2 : Antiperiodic f c\u2082) :\n    Antiperiodic f (c\u2081 + c\u2082)", "start": [514, 1], "end": [515, 58], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_antiperiod", "code": "theorem Periodic.sub_antiperiod [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Periodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : Antiperiodic f (c\u2081 - c\u2082)", "start": [518, 1], "end": [520, 61], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.add_antiperiod_eq", "code": "theorem Periodic.add_antiperiod_eq [AddGroup \u03b1] [Neg \u03b2] (h1 : Periodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : f (c\u2081 + c\u2082) = -f 0", "start": [523, 1], "end": [525, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Periodic.sub_antiperiod_eq", "code": "theorem Periodic.sub_antiperiod_eq [AddGroup \u03b1] [InvolutiveNeg \u03b2] (h1 : Periodic f c\u2081)\n    (h2 : Antiperiodic f c\u2082) : f (c\u2081 - c\u2082) = -f 0", "start": [528, 1], "end": [530, 28], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.mul", "code": "theorem Antiperiodic.mul [Add \u03b1] [Mul \u03b2] [HasDistribNeg \u03b2] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f * g) c", "start": [533, 1], "end": [534, 64], "kind": "commanddeclaration"}, {"full_name": "Function.Antiperiodic.div", "code": "theorem Antiperiodic.div [Add \u03b1] [DivisionMonoid \u03b2] [HasDistribNeg \u03b2] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f / g) c", "start": [537, 1], "end": [538, 81], "kind": "commanddeclaration"}, {"full_name": "Int.fract_periodic", "code": "theorem Int.fract_periodic (\u03b1) [LinearOrderedRing \u03b1] [FloorRing \u03b1] :\n    Function.Periodic Int.fract (1 : \u03b1)", "start": [543, 1], "end": [545, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/UniformMulAction.lean", "imports": ["Mathlib/Topology/UniformSpace/Completion.lean", "Mathlib/Topology/Algebra/UniformGroup.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "UniformContinuousConstVAdd", "code": "class UniformContinuousConstVAdd [VAdd M X] : Prop where\n  uniformContinuous_const_vadd : \u2200 c : M, UniformContinuous ((\u00b7 +\u1d65 \u00b7) c : X \u2192 X)", "start": [34, 1], "end": [36, 81], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousConstSMul", "code": "@[to_additive]\nclass UniformContinuousConstSMul [SMul M X] : Prop where\n  uniformContinuous_const_smul : \u2200 c : M, UniformContinuous ((\u00b7 \u2022 \u00b7) c : X \u2192 X)", "start": [39, 1], "end": [42, 80], "kind": "commanddeclaration"}, {"full_name": "AddMonoid.uniformContinuousConstSMul_nat", "code": "instance AddMonoid.uniformContinuousConstSMul_nat [AddGroup X] [UniformAddGroup X] :\n    UniformContinuousConstSMul \u2115 X :=\n  \u27e8uniformContinuous_const_nsmul\u27e9", "start": [49, 1], "end": [51, 34], "kind": "commanddeclaration"}, {"full_name": "AddGroup.uniformContinuousConstSMul_int", "code": "instance AddGroup.uniformContinuousConstSMul_int [AddGroup X] [UniformAddGroup X] :\n    UniformContinuousConstSMul \u2124 X :=\n  \u27e8uniformContinuous_const_zsmul\u27e9", "start": [54, 1], "end": [56, 34], "kind": "commanddeclaration"}, {"full_name": "uniformContinuousConstSMul_of_continuousConstSMul", "code": "theorem uniformContinuousConstSMul_of_continuousConstSMul [Monoid R] [AddCommGroup M]\n    [DistribMulAction R M] [UniformSpace M] [UniformAddGroup M] [ContinuousConstSMul R M] :\n    UniformContinuousConstSMul R M", "start": [59, 1], "end": [67, 59], "kind": "commanddeclaration"}, {"full_name": "Ring.uniformContinuousConstSMul", "code": "instance Ring.uniformContinuousConstSMul [Ring R] [UniformSpace R] [UniformAddGroup R]\n    [ContinuousMul R] : UniformContinuousConstSMul R R :=\n  uniformContinuousConstSMul_of_continuousConstSMul _ _", "start": [70, 1], "end": [73, 56], "kind": "commanddeclaration"}, {"full_name": "Ring.uniformContinuousConstSMul_op", "code": "instance Ring.uniformContinuousConstSMul_op [Ring R] [UniformSpace R] [UniformAddGroup R]\n    [ContinuousMul R] : UniformContinuousConstSMul R\u1d50\u1d52\u1d56 R :=\n  uniformContinuousConstSMul_of_continuousConstSMul _ _", "start": [76, 1], "end": [79, 56], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousConstSMul.to_continuousConstSMul", "code": "@[to_additive]\ninstance (priority := 100) UniformContinuousConstSMul.to_continuousConstSMul\n    [UniformContinuousConstSMul M X] : ContinuousConstSMul M X :=\n  \u27e8fun c => (uniformContinuous_const_smul c).continuous\u27e9", "start": [86, 1], "end": [89, 57], "kind": "commanddeclaration"}, {"full_name": "UniformContinuous.const_smul", "code": "@[to_additive]\ntheorem UniformContinuous.const_smul [UniformContinuousConstSMul M X] {f : Y \u2192 X}\n    (hf : UniformContinuous f) (c : M) : UniformContinuous (c \u2022 f)", "start": [95, 1], "end": [98, 43], "kind": "commanddeclaration"}, {"full_name": "UniformContinuousConstSMul.op", "code": "@[to_additive \"If an additive action is central, then its right action is uniform\ncontinuous when its left action is.\"]\ninstance (priority := 100) UniformContinuousConstSMul.op [SMul M\u1d50\u1d52\u1d56 X] [IsCentralScalar M X]\n    [UniformContinuousConstSMul M X] : UniformContinuousConstSMul M\u1d50\u1d52\u1d56 X :=\n  \u27e8MulOpposite.rec' fun c => by\n    dsimp only\n    simp_rw [op_smul_eq_smul]\n    exact uniformContinuous_const_smul c\u27e9", "start": [102, 1], "end": [111, 42], "kind": "commanddeclaration"}, {"full_name": "MulOpposite.uniformContinuousConstSMul", "code": "@[to_additive]\ninstance MulOpposite.uniformContinuousConstSMul [UniformContinuousConstSMul M X] :\n    UniformContinuousConstSMul M X\u1d50\u1d52\u1d56 :=\n  \u27e8fun c =>\n    MulOpposite.uniformContinuous_op.comp <| MulOpposite.uniformContinuous_unop.const_smul c\u27e9", "start": [115, 1], "end": [119, 94], "kind": "commanddeclaration"}, {"full_name": "UniformGroup.to_uniformContinuousConstSMul", "code": "@[to_additive]\ninstance UniformGroup.to_uniformContinuousConstSMul {G : Type u} [Group G] [UniformSpace G]\n    [UniformGroup G] : UniformContinuousConstSMul G G :=\n  \u27e8fun _ => uniformContinuous_const.mul uniformContinuous_id\u27e9", "start": [125, 1], "end": [128, 62], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.smul_def", "code": "@[to_additive]\ntheorem smul_def (c : M) (x : Completion X) : c \u2022 x = Completion.map (c \u2022 \u00b7) x", "start": [144, 1], "end": [146, 6], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.instIsScalarTower", "code": "@[to_additive instVAddAssocClass]\ninstance instIsScalarTower [SMul N X] [SMul M N] [UniformContinuousConstSMul M X]\n    [UniformContinuousConstSMul N X] [IsScalarTower M N X] : IsScalarTower M N (Completion X) :=\n  \u27e8fun m n x => by\n    have : _ = (_ : Completion X \u2192 Completion X) :=\n      map_comp (uniformContinuous_const_smul m) (uniformContinuous_const_smul n)\n    refine' Eq.trans _ (congr_fun this.symm x)\n    exact congr_arg (fun f => Completion.map f x) (funext (smul_assoc _ _))\u27e9", "start": [154, 1], "end": [161, 77], "kind": "commanddeclaration"}, {"full_name": "UniformSpace.Completion.coe_smul", "code": "@[to_additive (attr := simp, norm_cast)]\ntheorem coe_smul (c : M) (x : X) : (\u2191(c \u2022 x) : Completion X) = c \u2022 (x : Completion X)", "start": [182, 1], "end": [184, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Instances/Int.lean", "imports": ["Mathlib/Data/Int/Interval.lean", "Mathlib/Topology/MetricSpace/Basic.lean", "Mathlib/Order/Filter/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Int.dist_eq", "code": "theorem dist_eq (x y : \u2124) : dist x y = |(x : \u211d) - y|", "start": [28, 1], "end": [28, 60], "kind": "commanddeclaration"}, {"full_name": "Int.dist_eq'", "code": "theorem dist_eq' (m n : \u2124) : dist m n = |m - n|", "start": [31, 1], "end": [31, 78], "kind": "commanddeclaration"}, {"full_name": "Int.dist_cast_real", "code": "@[norm_cast, simp]\ntheorem dist_cast_real (x y : \u2124) : dist (x : \u211d) y = dist x y", "start": [33, 1], "end": [35, 6], "kind": "commanddeclaration"}, {"full_name": "Int.pairwise_one_le_dist", "code": "theorem pairwise_one_le_dist : Pairwise fun m n : \u2124 => 1 \u2264 dist m n", "start": [38, 1], "end": [40, 94], "kind": "commanddeclaration"}, {"full_name": "Int.uniformEmbedding_coe_real", "code": "theorem uniformEmbedding_coe_real : UniformEmbedding ((\u2191) : \u2124 \u2192 \u211d)", "start": [43, 1], "end": [44, 76], "kind": "commanddeclaration"}, {"full_name": "Int.closedEmbedding_coe_real", "code": "theorem closedEmbedding_coe_real : ClosedEmbedding ((\u2191) : \u2124 \u2192 \u211d)", "start": [47, 1], "end": [48, 71], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_ball", "code": "theorem preimage_ball (x : \u2124) (r : \u211d) : (\u2191) \u207b\u00b9' ball (x : \u211d) r = ball x r", "start": [53, 1], "end": [53, 81], "kind": "commanddeclaration"}, {"full_name": "Int.preimage_closedBall", "code": "theorem preimage_closedBall (x : \u2124) (r : \u211d) : (\u2191) \u207b\u00b9' closedBall (x : \u211d) r = closedBall x r", "start": [56, 1], "end": [56, 99], "kind": "commanddeclaration"}, {"full_name": "Int.ball_eq_Ioo", "code": "theorem ball_eq_Ioo (x : \u2124) (r : \u211d) : ball x r = Ioo \u230a\u2191x - r\u230b \u2308\u2191x + r\u2309", "start": [59, 1], "end": [60, 55], "kind": "commanddeclaration"}, {"full_name": "Int.closedBall_eq_Icc", "code": "theorem closedBall_eq_Icc (x : \u2124) (r : \u211d) : closedBall x r = Icc \u2308\u2191x - r\u2309 \u230a\u2191x + r\u230b", "start": [63, 1], "end": [64, 67], "kind": "commanddeclaration"}, {"full_name": "Int.cobounded_eq", "code": "@[simp]\ntheorem cobounded_eq : Bornology.cobounded \u2124 = atBot \u2294 atTop", "start": [72, 1], "end": [75, 68], "kind": "commanddeclaration"}, {"full_name": "Int.cocompact_eq", "code": "@[simp]\ntheorem cocompact_eq : cocompact \u2124 = atBot \u2294 atTop", "start": [77, 1], "end": [79, 46], "kind": "commanddeclaration"}, {"full_name": "Int.cofinite_eq", "code": "@[simp]\ntheorem cofinite_eq : (cofinite : Filter \u2124) = atBot \u2294 atTop", "start": [82, 1], "end": [84, 45], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/Algebra/Order/Archimedean.lean", "imports": ["Mathlib/Topology/Order/Basic.lean", "Mathlib/GroupTheory/Archimedean.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Rat.denseRange_cast", "code": "theorem Rat.denseRange_cast {\ud835\udd5c} [LinearOrderedField \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [OrderTopology \ud835\udd5c]\n    [Archimedean \ud835\udd5c] : DenseRange ((\u2191) : \u211a \u2192 \ud835\udd5c)", "start": [28, 1], "end": [31, 83], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.dense_of_not_isolated_zero", "code": "theorem dense_of_not_isolated_zero (S : AddSubgroup G) (hS : \u2200 \u03b5 > 0, \u2203 g \u2208 S, g \u2208 Ioo 0 \u03b5) :\n    Dense (S : Set G)", "start": [39, 1], "end": [53, 33], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.dense_of_no_min", "code": "theorem dense_of_no_min (S : AddSubgroup G) (hbot : S \u2260 \u22a5)\n    (H : \u00ac\u2203 a : G, IsLeast { g : G | g \u2208 S \u2227 0 < g } a) : Dense (S : Set G)", "start": [55, 1], "end": [62, 55], "kind": "commanddeclaration"}, {"full_name": "AddSubgroup.dense_or_cyclic", "code": "theorem dense_or_cyclic (S : AddSubgroup G) : Dense (S : Set G) \u2228 \u2203 a : G, S = closure {a}", "start": [65, 1], "end": [71, 56], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Order/Group/Bounds.lean", "imports": ["Mathlib/Algebra/Order/Group/Defs.lean", "Mathlib/Order/Bounds/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsGLB.exists_between_self_add", "code": "theorem IsGLB.exists_between_self_add (h : IsGLB s a) (h\u03b5 : 0 < \u03b5) : \u2203 b \u2208 s, a \u2264 b \u2227 b < a + \u03b5", "start": [21, 1], "end": [22, 47], "kind": "commanddeclaration"}, {"full_name": "IsGLB.exists_between_self_add'", "code": "theorem IsGLB.exists_between_self_add' (h : IsGLB s a) (h\u2082 : a \u2209 s) (h\u03b5 : 0 < \u03b5) :\n    \u2203 b \u2208 s, a < b \u2227 b < a + \u03b5", "start": [25, 1], "end": [27, 51], "kind": "commanddeclaration"}, {"full_name": "IsLUB.exists_between_sub_self", "code": "theorem IsLUB.exists_between_sub_self (h : IsLUB s a) (h\u03b5 : 0 < \u03b5) : \u2203 b \u2208 s, a - \u03b5 < b \u2227 b \u2264 a", "start": [30, 1], "end": [31, 39], "kind": "commanddeclaration"}, {"full_name": "IsLUB.exists_between_sub_self'", "code": "theorem IsLUB.exists_between_sub_self' (h : IsLUB s a) (h\u2082 : a \u2209 s) (h\u03b5 : 0 < \u03b5) :\n    \u2203 b \u2208 s, a - \u03b5 < b \u2227 b < a", "start": [34, 1], "end": [36, 43], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Topology/MetricSpace/Antilipschitz.lean", "imports": ["Mathlib/Topology/MetricSpace/Lipschitz.lean", "Mathlib/Topology/UniformSpace/CompleteSeparated.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "AntilipschitzWith", "code": "def AntilipschitzWith [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] (K : \u211d\u22650) (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 x y, edist x y \u2264 K * edist (f x) (f y)", "start": [31, 1], "end": [34, 43], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.edist_lt_top", "code": "theorem AntilipschitzWith.edist_lt_top [PseudoEMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} (h : AntilipschitzWith K f) (x y : \u03b1) : edist x y < \u22a4", "start": [37, 1], "end": [39, 79], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.edist_ne_top", "code": "theorem AntilipschitzWith.edist_ne_top [PseudoEMetricSpace \u03b1] [PseudoMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} (h : AntilipschitzWith K f) (x y : \u03b1) : edist x y \u2260 \u22a4", "start": [42, 1], "end": [44, 26], "kind": "commanddeclaration"}, {"full_name": "antilipschitzWith_iff_le_mul_nndist", "code": "theorem antilipschitzWith_iff_le_mul_nndist :\n    AntilipschitzWith K f \u2194 \u2200 x y, nndist x y \u2264 K * nndist (f x) (f y)", "start": [51, 1], "end": [54, 12], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_nndist", "code": "alias \u27e8AntilipschitzWith.le_mul_nndist, AntilipschitzWith.of_le_mul_nndist\u27e9 :=\n  antilipschitzWith_iff_le_mul_nndist", "start": [57, 1], "end": [58, 38], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntilipschitzWith.of_le_mul_nndist", "code": "alias \u27e8AntilipschitzWith.le_mul_nndist, AntilipschitzWith.of_le_mul_nndist\u27e9 :=\n  antilipschitzWith_iff_le_mul_nndist", "start": [57, 1], "end": [58, 38], "kind": "stdtacticaliasaliaslr"}, {"full_name": "antilipschitzWith_iff_le_mul_dist", "code": "theorem antilipschitzWith_iff_le_mul_dist :\n    AntilipschitzWith K f \u2194 \u2200 x y, dist x y \u2264 K * dist (f x) (f y)", "start": [62, 1], "end": [65, 12], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_dist", "code": "alias \u27e8AntilipschitzWith.le_mul_dist, AntilipschitzWith.of_le_mul_dist\u27e9 :=\n  antilipschitzWith_iff_le_mul_dist", "start": [68, 1], "end": [69, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntilipschitzWith.of_le_mul_dist", "code": "alias \u27e8AntilipschitzWith.le_mul_dist, AntilipschitzWith.of_le_mul_dist\u27e9 :=\n  antilipschitzWith_iff_le_mul_dist", "start": [68, 1], "end": [69, 36], "kind": "stdtacticaliasaliaslr"}, {"full_name": "AntilipschitzWith.mul_le_nndist", "code": "theorem mul_le_nndist (hf : AntilipschitzWith K f) (x y : \u03b1) :\n    K\u207b\u00b9 * nndist x y \u2264 nndist (f x) (f y)", "start": [75, 1], "end": [77, 84], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.mul_le_dist", "code": "theorem mul_le_dist (hf : AntilipschitzWith K f) (x y : \u03b1) :\n    (K\u207b\u00b9 * dist x y : \u211d) \u2264 dist (f x) (f y)", "start": [80, 1], "end": [81, 86], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.k", "code": "@[nolint unusedArguments]\nprotected def k (_hf : AntilipschitzWith K f) : \u211d\u22650 := K", "start": [97, 1], "end": [100, 57], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.injective", "code": "protected theorem injective {\u03b1 : Type*} {\u03b2 : Type*} [EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]\n    {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} (hf : AntilipschitzWith K f) : Function.Injective f", "start": [104, 1], "end": [106, 67], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.mul_le_edist", "code": "theorem mul_le_edist (hf : AntilipschitzWith K f) (x y : \u03b1) :\n    (K : \u211d\u22650\u221e)\u207b\u00b9 * edist x y \u2264 edist (f x) (f y)", "start": [109, 1], "end": [112, 43], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.ediam_preimage_le", "code": "theorem ediam_preimage_le (hf : AntilipschitzWith K f) (s : Set \u03b2) : diam (f \u207b\u00b9' s) \u2264 K * diam s", "start": [115, 1], "end": [117, 69], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.le_mul_ediam_image", "code": "theorem le_mul_ediam_image (hf : AntilipschitzWith K f) (s : Set \u03b1) : diam s \u2264 K * diam (f '' s)", "start": [120, 1], "end": [121, 80], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.id", "code": "protected theorem id : AntilipschitzWith 1 (id : \u03b1 \u2192 \u03b1)", "start": [124, 1], "end": [125, 52], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.comp", "code": "theorem comp {Kg : \u211d\u22650} {g : \u03b2 \u2192 \u03b3} (hg : AntilipschitzWith Kg g) {Kf : \u211d\u22650} {f : \u03b1 \u2192 \u03b2}\n    (hf : AntilipschitzWith Kf f) : AntilipschitzWith (Kf * Kg) (g \u2218 f)", "start": [128, 1], "end": [133, 53], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.restrict", "code": "theorem restrict (hf : AntilipschitzWith K f) (s : Set \u03b1) : AntilipschitzWith K (s.restrict f)", "start": [136, 1], "end": [137, 20], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.codRestrict", "code": "theorem codRestrict (hf : AntilipschitzWith K f) {s : Set \u03b2} (hs : \u2200 x, f x \u2208 s) :\n    AntilipschitzWith K (s.codRestrict f hs)", "start": [140, 1], "end": [141, 66], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.to_rightInvOn'", "code": "theorem to_rightInvOn' {s : Set \u03b1} (hf : AntilipschitzWith K (s.restrict f)) {g : \u03b2 \u2192 \u03b1}\n    {t : Set \u03b2} (g_maps : MapsTo g t s) (g_inv : RightInvOn g f t) :\n    LipschitzWith K (t.restrict g)", "start": [144, 1], "end": [148, 47], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.to_rightInvOn", "code": "theorem to_rightInvOn (hf : AntilipschitzWith K f) {g : \u03b2 \u2192 \u03b1} {t : Set \u03b2} (h : RightInvOn g f t) :\n    LipschitzWith K (t.restrict g)", "start": [151, 1], "end": [153, 56], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.to_rightInverse", "code": "theorem to_rightInverse (hf : AntilipschitzWith K f) {g : \u03b2 \u2192 \u03b1} (hg : Function.RightInverse g f) :\n    LipschitzWith K g", "start": [156, 1], "end": [160, 27], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.comap_uniformity_le", "code": "theorem comap_uniformity_le (hf : AntilipschitzWith K f) : (\ud835\udce4 \u03b2).comap (Prod.map f f) \u2264 \ud835\udce4 \u03b1", "start": [163, 1], "end": [169, 36], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.uniformInducing", "code": "protected theorem uniformInducing (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    UniformInducing f", "start": [172, 1], "end": [174, 52], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.uniformEmbedding", "code": "protected theorem uniformEmbedding {\u03b1 : Type*} {\u03b2 : Type*} [EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2]\n    {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    UniformEmbedding f", "start": [177, 1], "end": [180, 41], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.isComplete_range", "code": "theorem isComplete_range [CompleteSpace \u03b1] (hf : AntilipschitzWith K f)\n    (hfc : UniformContinuous f) : IsComplete (range f)", "start": [183, 1], "end": [185, 44], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.isClosed_range", "code": "theorem isClosed_range {\u03b1 \u03b2 : Type*} [PseudoEMetricSpace \u03b1] [EMetricSpace \u03b2] [CompleteSpace \u03b1]\n    {f : \u03b1 \u2192 \u03b2} {K : \u211d\u22650} (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    IsClosed (range f)", "start": [188, 1], "end": [191, 37], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.closedEmbedding", "code": "theorem closedEmbedding {\u03b1 : Type*} {\u03b2 : Type*} [EMetricSpace \u03b1] [EMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} [CompleteSpace \u03b1] (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    ClosedEmbedding f", "start": [194, 1], "end": [197, 85], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.subtype_coe", "code": "theorem subtype_coe (s : Set \u03b1) : AntilipschitzWith 1 ((\u2191) : s \u2192 \u03b1)", "start": [200, 1], "end": [201, 34], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.of_subsingleton", "code": "@[nontriviality] theorem of_subsingleton [Subsingleton \u03b1] {K : \u211d\u22650} : AntilipschitzWith K f", "start": [204, 1], "end": [206, 57], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.subsingleton", "code": "protected theorem subsingleton {\u03b1 \u03b2} [EMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {f : \u03b1 \u2192 \u03b2}\n    (h : AntilipschitzWith 0 f) : Subsingleton \u03b1", "start": [209, 1], "end": [212, 65], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.isBounded_preimage", "code": "theorem isBounded_preimage (hf : AntilipschitzWith K f) {s : Set \u03b2} (hs : IsBounded s) :\n    IsBounded (f \u207b\u00b9' s)", "start": [223, 1], "end": [226, 85], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.tendsto_cobounded", "code": "theorem tendsto_cobounded (hf : AntilipschitzWith K f) : Tendsto f (cobounded \u03b1) (cobounded \u03b2)", "start": [229, 1], "end": [230, 58], "kind": "commanddeclaration"}, {"full_name": "AntilipschitzWith.properSpace", "code": "protected theorem properSpace {\u03b1 : Type*} [MetricSpace \u03b1] {K : \u211d\u22650} {f : \u03b1 \u2192 \u03b2} [ProperSpace \u03b1]\n    (hK : AntilipschitzWith K f) (f_cont : Continuous f) (hf : Function.Surjective f) :\n    ProperSpace \u03b2", "start": [233, 1], "end": [243, 35], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.to_rightInverse", "code": "theorem LipschitzWith.to_rightInverse [PseudoEMetricSpace \u03b1] [PseudoEMetricSpace \u03b2] {K : \u211d\u22650}\n    {f : \u03b1 \u2192 \u03b2} (hf : LipschitzWith K f) {g : \u03b2 \u2192 \u03b1} (hg : Function.RightInverse g f) :\n    AntilipschitzWith K g", "start": [248, 1], "end": [250, 82], "kind": "commanddeclaration"}, {"full_name": "LipschitzWith.properSpace", "code": "protected theorem LipschitzWith.properSpace [PseudoMetricSpace \u03b1] [MetricSpace \u03b2] [ProperSpace \u03b2]\n    {K : \u211d\u22650} {f : \u03b1 \u2243\u209c \u03b2} (hK : LipschitzWith K f) : ProperSpace \u03b1", "start": [253, 1], "end": [256, 83], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/EqToHom.lean", "imports": ["Mathlib/CategoryTheory/Opposites.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.eqToHom", "code": "def eqToHom {X Y : C} (p : X = Y) : X \u27f6 Y := by rw [p]; exact \ud835\udfd9 _", "start": [41, 1], "end": [46, 66], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_refl", "code": "@[simp]\ntheorem eqToHom_refl (X : C) (p : X = X) : eqToHom p = \ud835\udfd9 X", "start": [49, 1], "end": [51, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_trans", "code": "@[reassoc (attr := simp)]\ntheorem eqToHom_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    eqToHom p \u226b eqToHom q = eqToHom (p.trans q)", "start": [54, 1], "end": [59, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.comp_eqToHom_iff", "code": "theorem comp_eqToHom_iff {X Y Y' : C} (p : Y = Y') (f : X \u27f6 Y) (g : X \u27f6 Y') :\n    f \u226b eqToHom p = g \u2194 f = g \u226b eqToHom p.symm", "start": [62, 1], "end": [65, 57], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_comp_iff", "code": "theorem eqToHom_comp_iff {X X' Y : C} (p : X = X') (f : X \u27f6 Y) (g : X' \u27f6 Y) :\n    eqToHom p \u226b g = f \u2194 g = eqToHom p.symm \u226b f", "start": [68, 1], "end": [71, 51], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_naturality", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_naturality {f g : \u03b2 \u2192 C} (z : \u2200 b, f b \u27f6 g b) {j j' : \u03b2} (w : j = j') :\n    z j \u226b eqToHom (by simp [w]) = eqToHom (by simp [w]) \u226b z j'", "start": [74, 1], "end": [81, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_iso_hom_naturality", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_hom_naturality {f g : \u03b2 \u2192 C} (z : \u2200 b, f b \u2245 g b) {j j' : \u03b2} (w : j = j') :\n    (z j).hom \u226b eqToHom (by simp [w]) = eqToHom (by simp [w]) \u226b (z j').hom", "start": [83, 1], "end": [90, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_iso_inv_naturality", "code": "@[reassoc (attr := simp, nolint simpNF)]\ntheorem eqToHom_iso_inv_naturality {f g : \u03b2 \u2192 C} (z : \u2200 b, f b \u2245 g b) {j j' : \u03b2} (w : j = j') :\n    (z j).inv \u226b eqToHom (by simp [w]) = eqToHom (by simp [w]) \u226b (z j').inv", "start": [92, 1], "end": [99, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congrArg_cast_hom_left", "code": "@[simp, nolint simpNF]\ntheorem congrArg_cast_hom_left {X Y Z : C} (p : X = Y) (q : Y \u27f6 Z) :\n    cast (congrArg (fun W : C => W \u27f6 Z) p.symm) q = eqToHom p \u226b q", "start": [103, 1], "end": [108, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congrArg_mpr_hom_left", "code": "theorem congrArg_mpr_hom_left {X Y Z : C} (p : X = Y) (q : Y \u27f6 Z) :\n    (congrArg (fun W : C => W \u27f6 Z) p).mpr q = eqToHom p \u226b q", "start": [110, 2], "end": [120, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congrArg_cast_hom_right", "code": "@[simp, nolint simpNF]\ntheorem congrArg_cast_hom_right {X Y Z : C} (p : X \u27f6 Y) (q : Z = Y) :\n    cast (congrArg (fun W : C => X \u27f6 W) q.symm) p = p \u226b eqToHom q.symm", "start": [125, 1], "end": [130, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.congrArg_mpr_hom_right", "code": "theorem congrArg_mpr_hom_right {X Y Z : C} (p : X \u27f6 Y) (q : Z = Y) :\n    (congrArg (fun W : C => X \u27f6 W) q).mpr p = p \u226b eqToHom q.symm", "start": [132, 1], "end": [142, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso", "code": "def eqToIso {X Y : C} (p : X = Y) : X \u2245 Y :=\n  \u27e8eqToHom p, eqToHom p.symm, by simp, by simp\u27e9", "start": [145, 1], "end": [151, 48], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso.hom", "code": "@[simp]\ntheorem eqToIso.hom {X Y : C} (p : X = Y) : (eqToIso p).hom = eqToHom p", "start": [154, 1], "end": [156, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso.inv", "code": "@[simp]\ntheorem eqToIso.inv {X Y : C} (p : X = Y) : (eqToIso p).inv = eqToHom p.symm", "start": [159, 1], "end": [161, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso_refl", "code": "@[simp]\ntheorem eqToIso_refl {X : C} (p : X = X) : eqToIso p = Iso.refl X", "start": [164, 1], "end": [166, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso_trans", "code": "@[simp]\ntheorem eqToIso_trans {X Y Z : C} (p : X = Y) (q : Y = Z) :\n    eqToIso p \u226a\u226b eqToIso q = eqToIso (p.trans q)", "start": [169, 1], "end": [171, 65], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_op", "code": "@[simp]\ntheorem eqToHom_op {X Y : C} (h : X = Y) : (eqToHom h).op = eqToHom (congr_arg op h.symm)", "start": [174, 1], "end": [177, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_unop", "code": "@[simp]\ntheorem eqToHom_unop {X Y : C\u1d52\u1d56} (h : X = Y) :\n    (eqToHom h).unop = eqToHom (congr_arg unop h.symm)", "start": [180, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.inv_eqToHom", "code": "@[simp]\ntheorem inv_eqToHom {X Y : C} (h : X = Y) : inv (eqToHom h) = eqToHom h.symm", "start": [190, 1], "end": [192, 12], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.ext", "code": "theorem ext {F G : C \u2964 D} (h_obj : \u2200 X, F.obj X = G.obj X)\n    (h_map : \u2200 X Y f,\n      F.map f = eqToHom (h_obj X) \u226b G.map f \u226b eqToHom (h_obj Y).symm := by aesop_cat) :\n    F = G", "start": [199, 1], "end": [214, 28], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.conj_eqToHom_iff_heq", "code": "theorem conj_eqToHom_iff_heq {W X Y Z : C} (f : W \u27f6 X) (g : Y \u27f6 Z) (h : W = Y) (h' : X = Z) :\n    f = eqToHom h \u226b g \u226b eqToHom h'.symm \u2194 HEq f g", "start": [217, 1], "end": [222, 7], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.hext", "code": "theorem hext {F G : C \u2964 D} (h_obj : \u2200 X, F.obj X = G.obj X)\n    (h_map : \u2200 (X Y) (f : X \u27f6 Y), HEq (F.map f) (G.map f)) : F = G", "start": [225, 1], "end": [228, 97], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.congr_obj", "code": "theorem congr_obj {F G : C \u2964 D} (h : F = G) (X) : F.obj X = G.obj X", "start": [232, 1], "end": [232, 81], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.congr_hom", "code": "theorem congr_hom {F G : C \u2964 D} (h : F = G) {X Y} (f : X \u27f6 Y) :\n    F.map f = eqToHom (congr_obj h X) \u226b G.map f \u226b eqToHom (congr_obj h Y).symm", "start": [235, 1], "end": [237, 16], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.congr_inv_of_congr_hom", "code": "theorem congr_inv_of_congr_hom (F G : C \u2964 D) {X Y : C} (e : X \u2245 Y) (hX : F.obj X = G.obj X)\n    (hY : F.obj Y = G.obj Y)\n    (h\u2082 : F.map e.hom = eqToHom (by rw [hX]) \u226b G.map e.hom \u226b eqToHom (by rw [hY])) :\n    F.map e.inv = eqToHom (by rw [hY]) \u226b G.map e.inv \u226b eqToHom (by rw [hX])", "start": [240, 1], "end": [245, 20], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.congr_map", "code": "theorem congr_map (F : C \u2964 D) {X Y : C} {f g : X \u27f6 Y} (h : f = g) : F.map f = F.map g", "start": [248, 1], "end": [248, 99], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_comp_heq", "code": "theorem map_comp_heq (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y) (hz : F.obj Z = G.obj Z)\n    (hf : HEq (F.map f) (G.map f)) (hg : HEq (F.map g) (G.map g)) :\n    HEq (F.map (f \u226b g)) (G.map (f \u226b g))", "start": [256, 1], "end": [260, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.map_comp_heq'", "code": "theorem map_comp_heq' (hobj : \u2200 X : C, F.obj X = G.obj X)\n    (hmap : \u2200 {X Y} (f : X \u27f6 Y), HEq (F.map f) (G.map f)) :\n    HEq (F.map (f \u226b g)) (G.map (f \u226b g))", "start": [263, 1], "end": [266, 41], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.precomp_map_heq", "code": "theorem precomp_map_heq (H : E \u2964 C) (hmap : \u2200 {X Y} (f : X \u27f6 Y), HEq (F.map f) (G.map f)) {X Y : E}\n    (f : X \u27f6 Y) : HEq ((H \u22d9 F).map f) ((H \u22d9 G).map f)", "start": [269, 1], "end": [271, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.postcomp_map_heq", "code": "theorem postcomp_map_heq (H : D \u2964 E) (hx : F.obj X = G.obj X) (hy : F.obj Y = G.obj Y)\n    (hmap : HEq (F.map f) (G.map f)) : HEq ((F \u22d9 H).map f) ((G \u22d9 H).map f)", "start": [274, 1], "end": [277, 8], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.postcomp_map_heq'", "code": "theorem postcomp_map_heq' (H : D \u2964 E) (hobj : \u2200 X : C, F.obj X = G.obj X)\n    (hmap : \u2200 {X Y} (f : X \u27f6 Y), HEq (F.map f) (G.map f)) : HEq ((F \u22d9 H).map f) ((G \u22d9 H).map f)", "start": [280, 1], "end": [282, 44], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.hcongr_hom", "code": "theorem hcongr_hom {F G : C \u2964 D} (h : F = G) {X Y} (f : X \u27f6 Y) : HEq (F.map f) (G.map f)", "start": [285, 1], "end": [286, 9], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_map", "code": "theorem eqToHom_map (F : C \u2964 D) {X Y : C} (p : X = Y) :\n    F.map (eqToHom p) = eqToHom (congr_arg F.obj p)", "start": [293, 1], "end": [300, 72], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToIso_map", "code": "theorem eqToIso_map (F : C \u2964 D) {X Y : C} (p : X = Y) :\n    F.mapIso (eqToIso p) = eqToIso (congr_arg F.obj p)", "start": [303, 1], "end": [306, 80], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eqToHom_app", "code": "@[simp]\ntheorem eqToHom_app {F G : C \u2964 D} (h : F = G) (X : C) :\n    (eqToHom h : F \u27f6 G).app X = eqToHom (Functor.congr_obj h X)", "start": [309, 1], "end": [311, 83], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.NatTrans.congr", "code": "theorem NatTrans.congr {F G : C \u2964 D} (\u03b1 : F \u27f6 G) {X Y : C} (h : X = Y) :\n    \u03b1.app X = F.map (eqToHom h) \u226b \u03b1.app Y \u226b G.map (eqToHom h.symm)", "start": [314, 1], "end": [317, 21], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.eq_conj_eqToHom", "code": "theorem eq_conj_eqToHom {X Y : C} (f : X \u27f6 Y) : f = eqToHom rfl \u226b f \u226b eqToHom rfl", "start": [320, 1], "end": [321, 63], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.dcongr_arg", "code": "theorem dcongr_arg {\u03b9 : Type*} {F G : \u03b9 \u2192 C} (\u03b1 : \u2200 i, F i \u27f6 G i) {i j : \u03b9} (h : i = j) :\n    \u03b1 i = eqToHom (congr_arg F h) \u226b \u03b1 j \u226b eqToHom (congr_arg G h.symm)", "start": [324, 1], "end": [327, 7], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/Path.lean", "imports": ["Mathlib/Combinatorics/Quiver/Basic.lean", "Mathlib/Logic/Lemmas.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver.Path", "code": "inductive Path {V : Type u} [Quiver.{v} V] (a : V) : V \u2192 Sort max (u + 1) v\n  | nil : Path a a\n  | cons : \u2200 {b c : V}, Path a b \u2192 (b \u27f6 c) \u2192 Path a c", "start": [24, 1], "end": [27, 54], "kind": "commanddeclaration"}, {"full_name": "Quiver.Hom.toPath", "code": "def Hom.toPath {V} [Quiver V] {a b : V} (e : a \u27f6 b) : Path a b :=\n  Path.nil.cons e", "start": [33, 1], "end": [35, 18], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.nil_ne_cons", "code": "lemma nil_ne_cons (p : Path a b) (e : b \u27f6 a) : Path.nil \u2260 p.cons e :=\n  fun h => by injection h", "start": [42, 1], "end": [43, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Quiver.Path.cons_ne_nil", "code": "lemma cons_ne_nil (p : Path a b) (e : b \u27f6 a) : p.cons e \u2260 Path.nil :=\n  fun h => by injection h", "start": [46, 1], "end": [47, 26], "kind": "mathlibtacticlemma"}, {"full_name": "Quiver.Path.obj_eq_of_cons_eq_cons", "code": "lemma obj_eq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b \u27f6 d} {e' : c \u27f6 d} (h : p.cons e = p'.cons e') : b = c := by injection h", "start": [50, 1], "end": [51, 83], "kind": "mathlibtacticlemma"}, {"full_name": "Quiver.Path.heq_of_cons_eq_cons", "code": "lemma heq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b \u27f6 d} {e' : c \u27f6 d} (h : p.cons e = p'.cons e') : HEq p p' := by injection h", "start": [54, 1], "end": [55, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Quiver.Path.hom_heq_of_cons_eq_cons", "code": "lemma hom_heq_of_cons_eq_cons {p : Path a b} {p' : Path a c}\n    {e : b \u27f6 d} {e' : c \u27f6 d} (h : p.cons e = p'.cons e') : HEq e e' := by injection h", "start": [58, 1], "end": [59, 86], "kind": "mathlibtacticlemma"}, {"full_name": "Quiver.Path.length", "code": "def length {a : V} : \u2200 {b : V}, Path a b \u2192 \u2115\n  | _, nil => 0\n  | _, cons p _ => p.length + 1", "start": [62, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.length_nil", "code": "@[simp]\ntheorem length_nil {a : V} : (nil : Path a a).length = 0", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.length_cons", "code": "@[simp]\ntheorem length_cons (a b c : V) (p : Path a b) (e : b \u27f6 c) : (p.cons e).length = p.length + 1", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.eq_of_length_zero", "code": "theorem eq_of_length_zero (p : Path a b) (hzero : p.length = 0) : a = b", "start": [81, 1], "end": [84, 35], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp", "code": "def comp {a b : V} : \u2200 {c}, Path a b \u2192 Path b c \u2192 Path a c\n  | _, p, nil => p\n  | _, p, cons q e => (p.comp q).cons e", "start": [87, 1], "end": [90, 40], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_cons", "code": "@[simp]\ntheorem comp_cons {a b c d : V} (p : Path a b) (q : Path b c) (e : c \u27f6 d) :\n    p.comp (q.cons e) = (p.comp q).cons e", "start": [93, 1], "end": [96, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_nil", "code": "@[simp]\ntheorem comp_nil {a b : V} (p : Path a b) : p.comp Path.nil = p", "start": [99, 1], "end": [101, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.nil_comp", "code": "@[simp]\ntheorem nil_comp {a : V} : \u2200 {b} (p : Path a b), Path.nil.comp p = p", "start": [104, 1], "end": [107, 49], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_assoc", "code": "@[simp]\ntheorem comp_assoc {a b c : V} :\n    \u2200 {d} (p : Path a b) (q : Path b c) (r : Path c d), (p.comp q).comp r = p.comp (q.comp r)", "start": [110, 1], "end": [114, 83], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.length_comp", "code": "@[simp]\ntheorem length_comp (p : Path a b) : \u2200 {c} (q : Path b c), (p.comp q).length = p.length + q.length", "start": [117, 1], "end": [120, 56], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_inj", "code": "theorem comp_inj {p\u2081 p\u2082 : Path a b} {q\u2081 q\u2082 : Path b c} (hq : q\u2081.length = q\u2082.length) :\n    p\u2081.comp q\u2081 = p\u2082.comp q\u2082 \u2194 p\u2081 = p\u2082 \u2227 q\u2081 = q\u2082", "start": [123, 1], "end": [134, 21], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_inj'", "code": "theorem comp_inj' {p\u2081 p\u2082 : Path a b} {q\u2081 q\u2082 : Path b c} (h : p\u2081.length = p\u2082.length) :\n    p\u2081.comp q\u2081 = p\u2082.comp q\u2082 \u2194 p\u2081 = p\u2082 \u2227 q\u2081 = q\u2082", "start": [137, 1], "end": [140, 30], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_injective_left", "code": "theorem comp_injective_left (q : Path b c) : Injective fun p : Path a b => p.comp q", "start": [143, 1], "end": [144, 38], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_injective_right", "code": "theorem comp_injective_right (p : Path a b) : Injective (p.comp : Path b c \u2192 Path a c)", "start": [147, 1], "end": [148, 39], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_inj_left", "code": "@[simp]\ntheorem comp_inj_left {p\u2081 p\u2082 : Path a b} {q : Path b c} : p\u2081.comp q = p\u2082.comp q \u2194 p\u2081 = p\u2082", "start": [151, 1], "end": [153, 31], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.comp_inj_right", "code": "@[simp]\ntheorem comp_inj_right {p : Path a b} {q\u2081 q\u2082 : Path b c} : p.comp q\u2081 = p.comp q\u2082 \u2194 q\u2081 = q\u2082", "start": [156, 1], "end": [158, 32], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.toList", "code": "@[simp]\ndef toList : \u2200 {b : V}, Path a b \u2192 List V\n  | _, nil => []\n  | _, @cons _ _ _ c _ p _ => c :: p.toList", "start": [161, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.toList_comp", "code": "@[simp]\ntheorem toList_comp (p : Path a b) : \u2200 {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList", "start": [168, 1], "end": [173, 52], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.toList_chain_nonempty", "code": "theorem toList_chain_nonempty :\n    \u2200 {b} (p : Path a b), p.toList.Chain (fun x y => Nonempty (y \u27f6 x)) b", "start": [176, 1], "end": [179, 52], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.toList_injective", "code": "theorem toList_injective (a : V) : \u2200 b, Injective (toList : Path a b \u2192 List V)", "start": [184, 1], "end": [191, 36], "kind": "commanddeclaration"}, {"full_name": "Quiver.Path.toList_inj", "code": "@[simp]\ntheorem toList_inj {p q : Path a b} : p.toList = q.toList \u2194 p = q", "start": [194, 1], "end": [196, 32], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapPath", "code": "def mapPath {a : V} : \u2200 {b : V}, Path a b \u2192 Path (F.obj a) (F.obj b)\n  | _, Path.nil => Path.nil\n  | _, Path.cons p e => Path.cons (mapPath p) (F.map e)", "start": [209, 1], "end": [212, 56], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapPath_nil", "code": "@[simp]\ntheorem mapPath_nil (a : V) : F.mapPath (Path.nil : Path a a) = Path.nil", "start": [215, 1], "end": [217, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapPath_cons", "code": "@[simp]\ntheorem mapPath_cons {a b c : V} (p : Path a b) (e : b \u27f6 c) :\n    F.mapPath (Path.cons p e) = Path.cons (F.mapPath p) (F.map e)", "start": [220, 1], "end": [223, 6], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapPath_comp", "code": "@[simp]\ntheorem mapPath_comp {a b : V} (p : Path a b) :\n    \u2200 {c : V} (q : Path b c), F.mapPath (p.comp q) = (F.mapPath p).comp (F.mapPath q)", "start": [226, 1], "end": [230, 56], "kind": "commanddeclaration"}, {"full_name": "Prefunctor.mapPath_toPath", "code": "@[simp]\ntheorem mapPath_toPath {a b : V} (f : a \u27f6 b) : F.mapPath f.toPath = (F.map f).toPath", "start": [233, 1], "end": [235, 6], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Combinatorics/Quiver/Push.lean", "imports": ["Mathlib/Combinatorics/Quiver/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Quiver.Push", "code": "@[nolint unusedArguments]\ndef Push (_ : V \u2192 W) :=\n  W", "start": [25, 1], "end": [28, 4], "kind": "commanddeclaration"}, {"full_name": "Quiver.PushQuiver", "code": "inductive PushQuiver {V : Type u} [Quiver.{v} V] {W : Type u\u2082} (\u03c3 : V \u2192 W) : W \u2192 W \u2192 Type max u u\u2082 v\n  | arrow {X Y : V} (f : X \u27f6 Y) : PushQuiver \u03c3 (\u03c3 X) (\u03c3 Y)", "start": [34, 1], "end": [36, 59], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.of", "code": "def of : V \u2964q Push \u03c3 where\n  obj := \u03c3\n  map f := PushQuiver.arrow f", "start": [44, 1], "end": [47, 30], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.of_obj", "code": "@[simp]\ntheorem of_obj : (of \u03c3).obj = \u03c3", "start": [50, 1], "end": [52, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.lift", "code": "noncomputable def lift : Push \u03c3 \u2964q W' where\n  obj := \u03c4\n  map :=\n    @PushQuiver.rec V _ W \u03c3 (fun X Y _ => \u03c4 X \u27f6 \u03c4 Y) @fun X Y f => by\n      dsimp only\n      rw [\u2190 h X, \u2190 h Y]\n      exact \u03c6.map f", "start": [57, 1], "end": [66, 20], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.lift_obj", "code": "theorem lift_obj : (lift \u03c3 \u03c6 \u03c4 h).obj = \u03c4", "start": [69, 1], "end": [70, 6], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.lift_comp", "code": "theorem lift_comp : (of \u03c3 \u22d9q lift \u03c3 \u03c6 \u03c4 h) = \u03c6", "start": [73, 1], "end": [89, 15], "kind": "commanddeclaration"}, {"full_name": "Quiver.Push.lift_unique", "code": "theorem lift_unique (\u03a6 : Push \u03c3 \u2964q W') (\u03a6\u2080 : \u03a6.obj = \u03c4) (\u03a6comp : (of \u03c3 \u22d9q \u03a6) = \u03c6) :\n    \u03a6 = lift \u03c3 \u03c6 \u03c4 h", "start": [92, 1], "end": [102, 8], "kind": "commanddeclaration"}]}
{"path": "Mathlib/CategoryTheory/Functor/Const.lean", "imports": ["Mathlib/CategoryTheory/Opposites.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "CategoryTheory.Functor.const", "code": "@[simps]\ndef const : C \u2964 J \u2964 C\n    where\n  obj X :=\n    { obj := fun _ => X\n      map := fun _ => \ud835\udfd9 X }\n  map f := { app := fun _ => f }", "start": [33, 1], "end": [41, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.const.opObjOp", "code": "@[simps]\ndef opObjOp (X : C) : (const J\u1d52\u1d56).obj (op X) \u2245 ((const J).obj X).op\n    where\n  hom := { app := fun j => \ud835\udfd9 _ }\n  inv := { app := fun j => \ud835\udfd9 _ }", "start": [50, 1], "end": [57, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.const.opObjUnop", "code": "def opObjUnop (X : C\u1d52\u1d56) : (const J\u1d52\u1d56).obj (unop X) \u2245 ((const J).obj X).leftOp\n    where\n  hom := { app := fun j => \ud835\udfd9 _ }\n  inv := { app := fun j => \ud835\udfd9 _ }", "start": [60, 1], "end": [67, 33], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.const.opObjUnop_hom_app", "code": "@[simp]\ntheorem opObjUnop_hom_app (X : C\u1d52\u1d56) (j : J\u1d52\u1d56) : (opObjUnop.{v\u2081, v\u2082} X).hom.app j = \ud835\udfd9 _", "start": [71, 1], "end": [73, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.const.opObjUnop_inv_app", "code": "@[simp]\ntheorem opObjUnop_inv_app (X : C\u1d52\u1d56) (j : J\u1d52\u1d56) : (opObjUnop.{v\u2081, v\u2082} X).inv.app j = \ud835\udfd9 _", "start": [76, 1], "end": [78, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.const.unop_functor_op_obj_map", "code": "@[simp]\ntheorem unop_functor_op_obj_map (X : C\u1d52\u1d56) {j\u2081 j\u2082 : J} (f : j\u2081 \u27f6 j\u2082) :\n    (unop ((Functor.op (const J)).obj X)).map f = \ud835\udfd9 (unop X)", "start": [81, 1], "end": [84, 6], "kind": "commanddeclaration"}, {"full_name": "CategoryTheory.Functor.constComp", "code": "@[simps]\ndef constComp (X : C) (F : C \u2964 D) : (const J).obj X \u22d9 F \u2245 (const J).obj (F.obj X)\n    where\n  hom := { app := fun _ => \ud835\udfd9 _ }\n  inv := { app := fun _ => \ud835\udfd9 _ }", "start": [93, 1], "end": [100, 33], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Data/Polynomial/Basic.lean", "imports": ["Mathlib/Algebra/MonoidAlgebra/Basic.lean", "Mathlib/Data/Finset/Sort.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Polynomial", "code": "structure Polynomial (R : Type*) [Semiring R] where ofFinsupp ::\n  toFinsupp : AddMonoidAlgebra R \u2115", "start": [58, 1], "end": [63, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.forall_iff_forall_finsupp", "code": "theorem forall_iff_forall_finsupp (P : R[X] \u2192 Prop) :\n    (\u2200 p, P p) \u2194 \u2200 q : R[\u2115], P \u27e8q\u27e9", "start": [87, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.exists_iff_exists_finsupp", "code": "theorem exists_iff_exists_finsupp (P : R[X] \u2192 Prop) :\n    (\u2203 p, P p) \u2194 \u2203 q : R[\u2115], P \u27e8q\u27e9", "start": [92, 1], "end": [94, 55], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eta", "code": "@[simp]\ntheorem eta (f : R[X]) : Polynomial.ofFinsupp f.toFinsupp = f", "start": [97, 1], "end": [98, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.add", "code": "private irreducible_def add : R[X] \u2192 R[X] \u2192 R[X]\n  | \u27e8a\u27e9, \u27e8b\u27e9 => \u27e8a + b\u27e9", "start": [111, 1], "end": [112, 24], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Polynomial.neg", "code": "private irreducible_def neg {R : Type u} [Ring R] : R[X] \u2192 R[X]\n  | \u27e8a\u27e9 => \u27e8-a\u27e9", "start": [114, 1], "end": [115, 16], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Polynomial.mul", "code": "private irreducible_def mul : R[X] \u2192 R[X] \u2192 R[X]\n  | \u27e8a\u27e9, \u27e8b\u27e9 => \u27e8a * b\u27e9", "start": [117, 1], "end": [118, 24], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Polynomial.zero", "code": "instance zero : Zero R[X] :=\n  \u27e8\u27e80\u27e9\u27e9", "start": [120, 1], "end": [121, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.one", "code": "instance one : One R[X] :=\n  \u27e8\u27e81\u27e9\u27e9", "start": [124, 1], "end": [125, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.add'", "code": "instance add' : Add R[X] :=\n  \u27e8add\u27e9", "start": [128, 1], "end": [129, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.neg'", "code": "instance neg' {R : Type u} [Ring R] : Neg R[X] :=\n  \u27e8neg\u27e9", "start": [132, 1], "end": [133, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sub", "code": "instance sub {R : Type u} [Ring R] : Sub R[X] :=\n  \u27e8fun a b => a + -b\u27e9", "start": [136, 1], "end": [137, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul'", "code": "instance mul' : Mul R[X] :=\n  \u27e8mul\u27e9", "start": [140, 1], "end": [141, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smulZeroClass", "code": "instance smulZeroClass {S : Type*} [SMulZeroClass S R] : SMulZeroClass S R[X] where\n  smul r p := \u27e8r \u2022 p.toFinsupp\u27e9\n  smul_zero a := congr_arg ofFinsupp (smul_zero a)", "start": [144, 1], "end": [146, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.pow", "code": "instance (priority := 1) pow : Pow R[X] \u2115 where pow p n := npowRec n p", "start": [150, 1], "end": [150, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_zero", "code": "@[simp]\ntheorem ofFinsupp_zero : (\u27e80\u27e9 : R[X]) = 0", "start": [153, 1], "end": [155, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_one", "code": "@[simp]\ntheorem ofFinsupp_one : (\u27e81\u27e9 : R[X]) = 1", "start": [158, 1], "end": [160, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_add", "code": "@[simp]\ntheorem ofFinsupp_add {a b} : (\u27e8a + b\u27e9 : R[X]) = \u27e8a\u27e9 + \u27e8b\u27e9", "start": [163, 1], "end": [165, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_neg", "code": "@[simp]\ntheorem ofFinsupp_neg {R : Type u} [Ring R] {a} : (\u27e8-a\u27e9 : R[X]) = -\u27e8a\u27e9", "start": [168, 1], "end": [170, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_sub", "code": "@[simp]\ntheorem ofFinsupp_sub {R : Type u} [Ring R] {a b} : (\u27e8a - b\u27e9 : R[X]) = \u27e8a\u27e9 - \u27e8b\u27e9", "start": [173, 1], "end": [176, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_mul", "code": "@[simp]\ntheorem ofFinsupp_mul (a b) : (\u27e8a * b\u27e9 : R[X]) = \u27e8a\u27e9 * \u27e8b\u27e9", "start": [179, 1], "end": [181, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_smul", "code": "@[simp]\ntheorem ofFinsupp_smul {S : Type*} [SMulZeroClass S R] (a : S) (b) :\n    (\u27e8a \u2022 b\u27e9 : R[X]) = (a \u2022 \u27e8b\u27e9 : R[X])", "start": [184, 1], "end": [187, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_pow", "code": "@[simp]\ntheorem ofFinsupp_pow (a) (n : \u2115) : (\u27e8a ^ n\u27e9 : R[X]) = \u27e8a\u27e9 ^ n", "start": [190, 1], "end": [195, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_zero", "code": "@[simp]\ntheorem toFinsupp_zero : (0 : R[X]).toFinsupp = 0", "start": [198, 1], "end": [200, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_one", "code": "@[simp]\ntheorem toFinsupp_one : (1 : R[X]).toFinsupp = 1", "start": [203, 1], "end": [205, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_add", "code": "@[simp]\ntheorem toFinsupp_add (a b : R[X]) : (a + b).toFinsupp = a.toFinsupp + b.toFinsupp", "start": [208, 1], "end": [212, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_neg", "code": "@[simp]\ntheorem toFinsupp_neg {R : Type u} [Ring R] (a : R[X]) : (-a).toFinsupp = -a.toFinsupp", "start": [215, 1], "end": [218, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_sub", "code": "@[simp]\ntheorem toFinsupp_sub {R : Type u} [Ring R] (a b : R[X]) :\n    (a - b).toFinsupp = a.toFinsupp - b.toFinsupp", "start": [221, 1], "end": [225, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_mul", "code": "@[simp]\ntheorem toFinsupp_mul (a b : R[X]) : (a * b).toFinsupp = a.toFinsupp * b.toFinsupp", "start": [228, 1], "end": [232, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_smul", "code": "@[simp]\ntheorem toFinsupp_smul {S : Type*} [SMulZeroClass S R] (a : S) (b : R[X]) :\n    (a \u2022 b).toFinsupp = a \u2022 b.toFinsupp", "start": [235, 1], "end": [238, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_pow", "code": "@[simp]\ntheorem toFinsupp_pow (a : R[X]) (n : \u2115) : (a ^ n).toFinsupp = a.toFinsupp ^ n", "start": [241, 1], "end": [244, 23], "kind": "commanddeclaration"}, {"full_name": "IsSMulRegular.polynomial", "code": "theorem _root_.IsSMulRegular.polynomial {S : Type*} [Monoid S] [DistribMulAction S R] {a : S}\n    (ha : IsSMulRegular R a) : IsSMulRegular R[X] a", "start": [247, 1], "end": [249, 76], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_injective", "code": "theorem toFinsupp_injective : Function.Injective (toFinsupp : R[X] \u2192 AddMonoidAlgebra _ _)", "start": [252, 1], "end": [253, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_inj", "code": "@[simp]\ntheorem toFinsupp_inj {a b : R[X]} : a.toFinsupp = b.toFinsupp \u2194 a = b", "start": [256, 1], "end": [258, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_eq_zero", "code": "@[simp]\ntheorem toFinsupp_eq_zero {a : R[X]} : a.toFinsupp = 0 \u2194 a = 0", "start": [261, 1], "end": [263, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_eq_one", "code": "@[simp]\ntheorem toFinsupp_eq_one {a : R[X]} : a.toFinsupp = 1 \u2194 a = 1", "start": [266, 1], "end": [268, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_inj", "code": "theorem ofFinsupp_inj {a b} : (\u27e8a\u27e9 : R[X]) = \u27e8b\u27e9 \u2194 a = b", "start": [271, 1], "end": [273, 34], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_eq_zero", "code": "@[simp]\ntheorem ofFinsupp_eq_zero {a} : (\u27e8a\u27e9 : R[X]) = 0 \u2194 a = 0", "start": [276, 1], "end": [278, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_eq_one", "code": "@[simp]\ntheorem ofFinsupp_eq_one {a} : (\u27e8a\u27e9 : R[X]) = 1 \u2194 a = 1", "start": [281, 1], "end": [282, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.inhabited", "code": "instance inhabited : Inhabited R[X] :=\n  \u27e80\u27e9", "start": [285, 1], "end": [286, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.natCast", "code": "instance natCast : NatCast R[X] :=\n  \u27e8fun n => Polynomial.ofFinsupp n\u27e9", "start": [289, 1], "end": [290, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.semiring", "code": "instance semiring : Semiring R[X] :=\n  { Function.Injective.semiring toFinsupp toFinsupp_injective toFinsupp_zero toFinsupp_one\n      toFinsupp_add toFinsupp_mul (fun _ _ => toFinsupp_smul _ _) toFinsupp_pow fun _ => rfl with\n    toNatCast := Polynomial.natCast\n    toAdd := Polynomial.add'\n    toMul := Polynomial.mul'\n    toZero := Polynomial.zero\n    toOne := Polynomial.one\n    nsmul := (. \u2022 .)\n    npow := fun n x => (x ^ n) }", "start": [293, 1], "end": [303, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.distribSMul", "code": "instance distribSMul {S} [DistribSMul S R] : DistribSMul S R[X] :=\n  { Function.Injective.distribSMul \u27e8\u27e8toFinsupp, toFinsupp_zero\u27e9, toFinsupp_add\u27e9 toFinsupp_injective\n      toFinsupp_smul with\n    toSMulZeroClass := Polynomial.smulZeroClass }", "start": [306, 1], "end": [310, 50], "kind": "commanddeclaration"}, {"full_name": "Polynomial.distribMulAction", "code": "instance distribMulAction {S} [Monoid S] [DistribMulAction S R] : DistribMulAction S R[X] :=\n  { Function.Injective.distribMulAction \u27e8\u27e8toFinsupp, toFinsupp_zero (R := R)\u27e9, toFinsupp_add\u27e9\n      toFinsupp_injective toFinsupp_smul with\n    toSMul := Polynomial.smulZeroClass.toSMul }", "start": [313, 1], "end": [317, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.faithfulSMul", "code": "instance faithfulSMul {S} [SMulZeroClass S R] [FaithfulSMul S R] : FaithfulSMul S R[X] where\n  eq_of_smul_eq_smul {_s\u2081 _s\u2082} h :=\n    eq_of_smul_eq_smul fun a : \u2115 \u2192\u2080 R => congr_arg toFinsupp (h \u27e8a\u27e9)", "start": [320, 1], "end": [322, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.module", "code": "instance module {S} [Semiring S] [Module S R] : Module S R[X] :=\n  { Function.Injective.module _ \u27e8\u27e8toFinsupp, toFinsupp_zero\u27e9, toFinsupp_add\u27e9 toFinsupp_injective\n      toFinsupp_smul with\n    toDistribMulAction := Polynomial.distribMulAction }", "start": [325, 1], "end": [329, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smulCommClass", "code": "instance smulCommClass {S\u2081 S\u2082} [SMulZeroClass S\u2081 R] [SMulZeroClass S\u2082 R] [SMulCommClass S\u2081 S\u2082 R] :\n  SMulCommClass S\u2081 S\u2082 R[X] :=\n  \u27e8by\n    rintro m n \u27e8f\u27e9\n    simp_rw [\u2190 ofFinsupp_smul, smul_comm m n f]\u27e9", "start": [332, 1], "end": [336, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isScalarTower", "code": "instance isScalarTower {S\u2081 S\u2082} [SMul S\u2081 S\u2082] [SMulZeroClass S\u2081 R] [SMulZeroClass S\u2082 R]\n  [IsScalarTower S\u2081 S\u2082 R] : IsScalarTower S\u2081 S\u2082 R[X] :=\n  \u27e8by\n    rintro _ _ \u27e8\u27e9\n    simp_rw [\u2190 ofFinsupp_smul, smul_assoc]\u27e9", "start": [339, 1], "end": [343, 44], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isScalarTower_right", "code": "instance isScalarTower_right {\u03b1 K : Type*} [Semiring K] [DistribSMul \u03b1 K] [IsScalarTower \u03b1 K K] :\n    IsScalarTower \u03b1 K[X] K[X] :=\n  \u27e8by\n    rintro _ \u27e8\u27e9 \u27e8\u27e9;\n      simp_rw [smul_eq_mul, \u2190 ofFinsupp_smul, \u2190 ofFinsupp_mul, \u2190 ofFinsupp_smul, smul_mul_assoc]\u27e9", "start": [346, 1], "end": [350, 98], "kind": "commanddeclaration"}, {"full_name": "Polynomial.isCentralScalar", "code": "instance isCentralScalar {S} [SMulZeroClass S R] [SMulZeroClass S\u1d50\u1d52\u1d56 R] [IsCentralScalar S R] :\n  IsCentralScalar S R[X] :=\n  \u27e8by\n    rintro _ \u27e8\u27e9\n    simp_rw [\u2190 ofFinsupp_smul, op_smul_eq_smul]\u27e9", "start": [353, 1], "end": [357, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.unique", "code": "instance unique [Subsingleton R] : Unique R[X] :=\n  { Polynomial.inhabited with\n    uniq := by\n      rintro \u27e8x\u27e9\n      refine' congr_arg ofFinsupp _\n      simp }", "start": [360, 1], "end": [365, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsuppIso", "code": "@[simps apply symm_apply]\ndef toFinsuppIso : R[X] \u2243+* R[\u2115] where\n  toFun := toFinsupp\n  invFun := ofFinsupp\n  left_inv := fun \u27e8_p\u27e9 => rfl\n  right_inv _p := rfl\n  map_mul' := toFinsupp_mul\n  map_add' := toFinsupp_add", "start": [370, 1], "end": [379, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_sum", "code": "theorem ofFinsupp_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R[\u2115]) :\n    (\u27e8\u2211 i in s, f i\u27e9 : R[X]) = \u2211 i in s, \u27e8f i\u27e9", "start": [389, 1], "end": [391, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_sum", "code": "theorem toFinsupp_sum {\u03b9 : Type*} (s : Finset \u03b9) (f : \u03b9 \u2192 R[X]) :\n    (\u2211 i in s, f i : R[X]).toFinsupp = \u2211 i in s, (f i).toFinsupp", "start": [394, 1], "end": [396, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support", "code": "def support : R[X] \u2192 Finset \u2115\n  | \u27e8p\u27e9 => p.support", "start": [399, 1], "end": [405, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_ofFinsupp", "code": "@[simp]\ntheorem support_ofFinsupp (p) : support (\u27e8p\u27e9 : R[X]) = p.support", "start": [408, 1], "end": [409, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_toFinsupp", "code": "theorem support_toFinsupp (p : R[X]) : p.toFinsupp.support = p.support", "start": [412, 1], "end": [412, 90], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_zero", "code": "@[simp]\ntheorem support_zero : (0 : R[X]).support = \u2205", "start": [414, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_eq_empty", "code": "@[simp]\ntheorem support_eq_empty : p.support = \u2205 \u2194 p = 0", "start": [419, 1], "end": [422, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.card_support_eq_zero", "code": "theorem card_support_eq_zero : p.support.card = 0 \u2194 p = 0", "start": [425, 1], "end": [425, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial", "code": "def monomial (n : \u2115) : R \u2192\u2097[R] R[X] where\n  toFun t := \u27e8Finsupp.single n t\u27e9\n  map_add' x y := by simp; rw [ofFinsupp_add]\n  map_smul' r x := by simp; rw [\u2190 ofFinsupp_smul, smul_single']", "start": [428, 1], "end": [434, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_monomial", "code": "@[simp]\ntheorem toFinsupp_monomial (n : \u2115) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r", "start": [437, 1], "end": [439, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_single", "code": "@[simp]\ntheorem ofFinsupp_single (n : \u2115) (r : R) : (\u27e8Finsupp.single n r\u27e9 : R[X]) = monomial n r", "start": [442, 1], "end": [444, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_zero_right", "code": "theorem monomial_zero_right (n : \u2115) : monomial n (0 : R) = 0", "start": [448, 1], "end": [449, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_zero_one", "code": "theorem monomial_zero_one : monomial 0 (1 : R) = 1", "start": [453, 1], "end": [454, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_add", "code": "theorem monomial_add (n : \u2115) (r s : R) : monomial n (r + s) = monomial n r + monomial n s", "start": [458, 1], "end": [459, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mul_monomial", "code": "theorem monomial_mul_monomial (n m : \u2115) (r s : R) :\n    monomial n r * monomial m s = monomial (n + m) (r * s)", "start": [462, 1], "end": [465, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_pow", "code": "@[simp]\ntheorem monomial_pow (n : \u2115) (r : R) (k : \u2115) : monomial n r ^ k = monomial (n * k) (r ^ k)", "start": [468, 1], "end": [472, 87], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_monomial", "code": "theorem smul_monomial {S} [SMulZeroClass S R] (a : S) (n : \u2115) (b : R) :\n    a \u2022 monomial n b = monomial n (a \u2022 b)", "start": [475, 1], "end": [477, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_injective", "code": "theorem monomial_injective (n : \u2115) : Function.Injective (monomial n : R \u2192 R[X])", "start": [480, 1], "end": [481, 60], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_eq_zero_iff", "code": "@[simp]\ntheorem monomial_eq_zero_iff (t : R) (n : \u2115) : monomial n t = 0 \u2194 t = 0", "start": [484, 1], "end": [486, 64], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_add", "code": "theorem support_add : (p + q).support \u2286 p.support \u222a q.support", "start": [489, 1], "end": [492, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C", "code": "def C : R \u2192+* R[X] :=\n  { monomial 0 with\n    map_one' := by simp [monomial_zero_one]\n    map_mul' := by simp [monomial_mul_monomial]\n    map_zero' := by simp }", "start": [495, 1], "end": [502, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_zero_left", "code": "@[simp]\ntheorem monomial_zero_left (a : R) : monomial 0 a = C a", "start": [505, 1], "end": [507, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_C", "code": "@[simp]\ntheorem toFinsupp_C (a : R) : (C a).toFinsupp = single 0 a", "start": [510, 1], "end": [512, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_0", "code": "theorem C_0 : C (0 : R) = 0", "start": [515, 1], "end": [515, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_1", "code": "theorem C_1 : C (1 : R) = 1", "start": [518, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul", "code": "theorem C_mul : C (a * b) = C a * C b", "start": [522, 1], "end": [523, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_add", "code": "theorem C_add : C (a + b) = C a + C b", "start": [526, 1], "end": [527, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_C", "code": "@[simp]\ntheorem smul_C {S} [SMulZeroClass S R] (s : S) (r : R) : s \u2022 C r = C (s \u2022 r)", "start": [530, 1], "end": [532, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_bit0", "code": "theorem C_bit0 : C (bit0 a) = bit0 (C a)", "start": [537, 1], "end": [538, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_bit1", "code": "theorem C_bit1 : C (bit1 a) = bit1 (C a)", "start": [543, 1], "end": [543, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_pow", "code": "theorem C_pow : C (a ^ n) = C a ^ n", "start": [546, 1], "end": [547, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_eq_nat_cast", "code": "theorem C_eq_nat_cast (n : \u2115) : C (n : R) = (n : R[X])", "start": [551, 1], "end": [552, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_monomial", "code": "@[simp]\ntheorem C_mul_monomial : C a * monomial n b = monomial n (a * b)", "start": [555, 1], "end": [557, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mul_C", "code": "@[simp]\ntheorem monomial_mul_C : monomial n a * C b = monomial n (a * b)", "start": [560, 1], "end": [562, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X", "code": "def X : R[X] :=\n  monomial 1 1", "start": [565, 1], "end": [567, 15], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_one_one_eq_X", "code": "theorem monomial_one_one_eq_X : monomial 1 (1 : R) = X", "start": [570, 1], "end": [571, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_one_right_eq_X_pow", "code": "theorem monomial_one_right_eq_X_pow (n : \u2115) : monomial n (1 : R) = X ^ n", "start": [574, 1], "end": [577, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_X", "code": "@[simp]\ntheorem toFinsupp_X : X.toFinsupp = Finsupp.single 1 (1 : R)", "start": [580, 1], "end": [582, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_mul", "code": "theorem X_mul : X * p = p * X", "start": [585, 1], "end": [592, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mul", "code": "theorem X_pow_mul {n : \u2115} : X ^ n * p = p * X ^ n", "start": [595, 1], "end": [599, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_mul_C", "code": "@[simp]\ntheorem X_mul_C (r : R) : X * C r = C r * X", "start": [602, 1], "end": [607, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mul_C", "code": "@[simp]\ntheorem X_pow_mul_C (r : R) (n : \u2115) : X ^ n * C r = C r * X ^ n", "start": [610, 1], "end": [615, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mul_assoc", "code": "theorem X_pow_mul_assoc {n : \u2115} : p * X ^ n * q = p * q * X ^ n", "start": [618, 1], "end": [619, 41], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mul_assoc_C", "code": "@[simp]\ntheorem X_pow_mul_assoc_C {n : \u2115} (r : R) : p * X ^ n * C r = p * C r * X ^ n", "start": [622, 1], "end": [627, 18], "kind": "commanddeclaration"}, {"full_name": "Polynomial.commute_X", "code": "theorem commute_X (p : R[X]) : Commute X p", "start": [630, 1], "end": [631, 8], "kind": "commanddeclaration"}, {"full_name": "Polynomial.commute_X_pow", "code": "theorem commute_X_pow (p : R[X]) (n : \u2115) : Commute (X ^ n) p", "start": [634, 1], "end": [635, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mul_X", "code": "@[simp]\ntheorem monomial_mul_X (n : \u2115) (r : R) : monomial n r * X = monomial (n + 1) r", "start": [638, 1], "end": [640, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_mul_X_pow", "code": "@[simp]\ntheorem monomial_mul_X_pow (n : \u2115) (r : R) (k : \u2115) :\n    monomial n r * X ^ k = monomial (n + k) r", "start": [643, 1], "end": [648, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_mul_monomial", "code": "@[simp]\ntheorem X_mul_monomial (n : \u2115) (r : R) : X * monomial n r = monomial (n + 1) r", "start": [651, 1], "end": [653, 29], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_mul_monomial", "code": "@[simp]\ntheorem X_pow_mul_monomial (k n : \u2115) (r : R) : X ^ k * monomial n r = monomial (n + k) r", "start": [656, 1], "end": [658, 37], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff", "code": "def coeff : R[X] \u2192 \u2115 \u2192 R\n  | \u27e8p\u27e9 => p", "start": [661, 1], "end": [666, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_ofFinsupp", "code": "@[simp]\ntheorem coeff_ofFinsupp (p) : coeff (\u27e8p\u27e9 : R[X]) = p", "start": [670, 1], "end": [671, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_injective", "code": "theorem coeff_injective : Injective (coeff : R[X] \u2192 \u2115 \u2192 R)", "start": [673, 1], "end": [676, 66], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_inj", "code": "@[simp]\ntheorem coeff_inj : p.coeff = q.coeff \u2194 p = q", "start": [679, 1], "end": [681, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_apply", "code": "theorem toFinsupp_apply (f : R[X]) (i) : f.toFinsupp i = f.coeff i", "start": [684, 1], "end": [684, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_monomial", "code": "theorem coeff_monomial : coeff (monomial n a) m = if n = m then a else 0", "start": [687, 1], "end": [691, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_zero", "code": "@[simp]\ntheorem coeff_zero (n : \u2115) : coeff (0 : R[X]) n = 0", "start": [694, 1], "end": [696, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_one", "code": "theorem coeff_one {n : \u2115} : coeff (1 : R[X]) n = if n = 0 then 1 else 0", "start": [699, 1], "end": [701, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_one_zero", "code": "@[simp]\ntheorem coeff_one_zero : coeff (1 : R[X]) 0 = 1", "start": [704, 1], "end": [706, 19], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_one", "code": "@[simp]\ntheorem coeff_X_one : coeff (X : R[X]) 1 = 1", "start": [709, 1], "end": [711, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_zero", "code": "@[simp]\ntheorem coeff_X_zero : coeff (X : R[X]) 0 = 0", "start": [714, 1], "end": [716, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_monomial_succ", "code": "@[simp]\ntheorem coeff_monomial_succ : coeff (monomial (n + 1) a) 0 = 0", "start": [719, 1], "end": [720, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X", "code": "theorem coeff_X : coeff (X : R[X]) n = if 1 = n then 1 else 0", "start": [723, 1], "end": [724, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_X_of_ne_one", "code": "theorem coeff_X_of_ne_one {n : \u2115} (hn : n \u2260 1) : coeff (X : R[X]) n = 0", "start": [727, 1], "end": [728, 31], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mem_support_iff", "code": "@[simp]\ntheorem mem_support_iff : n \u2208 p.support \u2194 p.coeff n \u2260 0", "start": [731, 1], "end": [734, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.not_mem_support_iff", "code": "theorem not_mem_support_iff : n \u2209 p.support \u2194 p.coeff n = 0", "start": [737, 1], "end": [737, 71], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C", "code": "theorem coeff_C : coeff (C a) n = ite (n = 0) a 0", "start": [740, 1], "end": [742, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_zero", "code": "@[simp]\ntheorem coeff_C_zero : coeff (C a) 0 = a", "start": [745, 1], "end": [747, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_ne_zero", "code": "theorem coeff_C_ne_zero (h : n \u2260 0) : (C a).coeff n = 0", "start": [750, 1], "end": [750, 85], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_C_succ", "code": "@[simp]\nlemma coeff_C_succ {r : R} {n : \u2115} : coeff (C r) (n + 1) = 0 := by simp [coeff_C]", "start": [753, 1], "end": [754, 82], "kind": "mathlibtacticlemma"}, {"full_name": "Polynomial.coeff_nat_cast_ite", "code": "@[simp]\ntheorem coeff_nat_cast_ite : (Nat.cast m : R[X]).coeff n = ite (n = 0) m 0", "start": [756, 1], "end": [758, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_ofNat_zero", "code": "@[simp]\ntheorem coeff_ofNat_zero (a : \u2115) [a.AtLeastTwo] :\n    coeff (no_index (OfNat.ofNat a : R[X])) 0 = OfNat.ofNat a", "start": [761, 1], "end": [764, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_ofNat_succ", "code": "@[simp]\ntheorem coeff_ofNat_succ (a n : \u2115) [h : a.AtLeastTwo] :\n    coeff (no_index (OfNat.ofNat a : R[X])) (n + 1) = 0", "start": [767, 1], "end": [771, 7], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_X_pow_eq_monomial", "code": "theorem C_mul_X_pow_eq_monomial : \u2200 {n : \u2115}, C a * X ^ n = monomial n a", "start": [773, 1], "end": [776, 92], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_C_mul_X_pow", "code": "@[simp high]\ntheorem toFinsupp_C_mul_X_pow (a : R) (n : \u2115) :\n    Polynomial.toFinsupp (C a * X ^ n) = Finsupp.single n a", "start": [779, 1], "end": [782, 51], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_mul_X_eq_monomial", "code": "theorem C_mul_X_eq_monomial : C a * X = monomial 1 a", "start": [785, 1], "end": [785, 99], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_C_mul_X", "code": "@[simp high]\ntheorem toFinsupp_C_mul_X (a : R) : Polynomial.toFinsupp (C a * X) = Finsupp.single 1 a", "start": [788, 1], "end": [790, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_injective", "code": "theorem C_injective : Injective (C : R \u2192 R[X])", "start": [793, 1], "end": [794, 23], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_inj", "code": "@[simp]\ntheorem C_inj : C a = C b \u2194 a = b", "start": [797, 1], "end": [799, 21], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_eq_zero", "code": "@[simp]\ntheorem C_eq_zero : C a = 0 \u2194 a = 0", "start": [802, 1], "end": [804, 35], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_ne_zero", "code": "theorem C_ne_zero : C a \u2260 0 \u2194 a \u2260 0", "start": [807, 1], "end": [808, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.subsingleton_iff_subsingleton", "code": "theorem subsingleton_iff_subsingleton : Subsingleton R[X] \u2194 Subsingleton R", "start": [811, 1], "end": [814, 20], "kind": "commanddeclaration"}, {"full_name": "Polynomial.Nontrivial.of_polynomial_ne", "code": "theorem Nontrivial.of_polynomial_ne (h : p \u2260 q) : Nontrivial R", "start": [817, 1], "end": [818, 84], "kind": "commanddeclaration"}, {"full_name": "Polynomial.forall_eq_iff_forall_eq", "code": "theorem forall_eq_iff_forall_eq : (\u2200 f g : R[X], f = g) \u2194 \u2200 a b : R, a = b", "start": [821, 1], "end": [822, 70], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ext_iff", "code": "theorem ext_iff {p q : R[X]} : p = q \u2194 \u2200 n, coeff p n = coeff q n", "start": [825, 1], "end": [830, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ext", "code": "@[ext]\ntheorem ext {p q : R[X]} : (\u2200 n, coeff p n = coeff q n) \u2192 p = q", "start": [833, 1], "end": [835, 12], "kind": "commanddeclaration"}, {"full_name": "Polynomial.addSubmonoid_closure_setOf_eq_monomial", "code": "theorem addSubmonoid_closure_setOf_eq_monomial :\n    AddSubmonoid.closure { p : R[X] | \u2203 n a, p = monomial n a } = \u22a4", "start": [838, 1], "end": [846, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.addHom_ext", "code": "theorem addHom_ext {M : Type*} [AddMonoid M] {f g : R[X] \u2192+ M}\n    (h : \u2200 n a, f (monomial n a) = g (monomial n a)) : f = g", "start": [849, 1], "end": [853, 16], "kind": "commanddeclaration"}, {"full_name": "Polynomial.addHom_ext'", "code": "@[ext high]\ntheorem addHom_ext' {M : Type*} [AddMonoid M] {f g : R[X] \u2192+ M}\n    (h : \u2200 n, f.comp (monomial n).toAddMonoidHom = g.comp (monomial n).toAddMonoidHom) : f = g", "start": [856, 1], "end": [859, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.lhom_ext'", "code": "@[ext high]\ntheorem lhom_ext' {M : Type*} [AddCommMonoid M] [Module R M] {f g : R[X] \u2192\u2097[R] M}\n    (h : \u2200 n, f.comp (monomial n) = g.comp (monomial n)) : f = g", "start": [862, 1], "end": [865, 86], "kind": "commanddeclaration"}, {"full_name": "Polynomial.eq_zero_of_eq_zero", "code": "theorem eq_zero_of_eq_zero (h : (0 : R) = (1 : R)) (p : R[X]) : p = 0", "start": [869, 1], "end": [870, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_monomial", "code": "theorem support_monomial (n) {a : R} (H : a \u2260 0) : (monomial n a).support = singleton n", "start": [875, 1], "end": [876, 77], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_monomial'", "code": "theorem support_monomial' (n) (a : R) : (monomial n a).support \u2286 singleton n", "start": [879, 1], "end": [881, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_C_mul_X", "code": "theorem support_C_mul_X {c : R} (h : c \u2260 0) : Polynomial.support (C c * X) = singleton 1", "start": [884, 1], "end": [885, 49], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_C_mul_X'", "code": "theorem support_C_mul_X' (c : R) : Polynomial.support (C c * X) \u2286 singleton 1", "start": [888, 1], "end": [889, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_C_mul_X_pow", "code": "theorem support_C_mul_X_pow (n : \u2115) {c : R} (h : c \u2260 0) :\n    Polynomial.support (C c * X ^ n) = singleton n", "start": [892, 1], "end": [894, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_C_mul_X_pow'", "code": "theorem support_C_mul_X_pow' (n : \u2115) (c : R) : Polynomial.support (C c * X ^ n) \u2286 singleton n", "start": [897, 1], "end": [898, 67], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_binomial'", "code": "theorem support_binomial' (k m : \u2115) (x y : R) :\n    Polynomial.support (C x * X ^ k + C y * X ^ m) \u2286 {k, m}", "start": [903, 1], "end": [909, 80], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_trinomial'", "code": "theorem support_trinomial' (k m n : \u2115) (x y z : R) :\n    Polynomial.support (C x * X ^ k + C y * X ^ m + C z * X ^ n) \u2286 {k, m, n}", "start": [912, 1], "end": [922, 100], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_pow_eq_monomial", "code": "theorem X_pow_eq_monomial (n) : X ^ n = monomial n (1 : R)", "start": [927, 1], "end": [930, 58], "kind": "commanddeclaration"}, {"full_name": "Polynomial.toFinsupp_X_pow", "code": "@[simp high]\ntheorem toFinsupp_X_pow (n : \u2115) : (X ^ n).toFinsupp = Finsupp.single n (1 : R)", "start": [933, 1], "end": [935, 45], "kind": "commanddeclaration"}, {"full_name": "Polynomial.smul_X_eq_monomial", "code": "theorem smul_X_eq_monomial {n} : a \u2022 X ^ n = monomial n (a : R)", "start": [938, 1], "end": [939, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_X_pow", "code": "theorem support_X_pow (H : \u00ac(1 : R) = 0) (n : \u2115) : (X ^ n : R[X]).support = singleton n", "start": [942, 1], "end": [944, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_X_empty", "code": "theorem support_X_empty (H : (1 : R) = 0) : (X : R[X]).support = \u2205", "start": [947, 1], "end": [948, 47], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_X", "code": "theorem support_X (H : \u00ac(1 : R) = 0) : (X : R[X]).support = singleton 1", "start": [951, 1], "end": [952, 38], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_left_inj", "code": "theorem monomial_left_inj {a : R} (ha : a \u2260 0) {i j : \u2115} :\n    monomial i a = monomial j a \u2194 i = j", "start": [955, 1], "end": [958, 91], "kind": "commanddeclaration"}, {"full_name": "Polynomial.binomial_eq_binomial", "code": "theorem binomial_eq_binomial {k l m n : \u2115} {u v : R} (hu : u \u2260 0) (hv : v \u2260 0) :\n    C u * X ^ k + C v * X ^ l = C u * X ^ m + C v * X ^ n \u2194\n      k = m \u2227 l = n \u2228 u = v \u2227 k = n \u2227 l = m \u2228 u + v = 0 \u2227 k = l \u2227 m = n", "start": [961, 1], "end": [965, 61], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nat_cast_mul", "code": "theorem nat_cast_mul (n : \u2115) (p : R[X]) : (n : R[X]) * p = n \u2022 p", "start": [968, 1], "end": [969, 26], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum", "code": "def sum {S : Type*} [AddCommMonoid S] (p : R[X]) (f : \u2115 \u2192 R \u2192 S) : S :=\n  \u2211 n in p.support, f n (p.coeff n)", "start": [972, 1], "end": [974, 36], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_def", "code": "theorem sum_def {S : Type*} [AddCommMonoid S] (p : R[X]) (f : \u2115 \u2192 R \u2192 S) :\n    p.sum f = \u2211 n in p.support, f n (p.coeff n)", "start": [977, 1], "end": [979, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_eq_of_subset", "code": "theorem sum_eq_of_subset {S : Type*} [AddCommMonoid S] {p : R[X]} (f : \u2115 \u2192 R \u2192 S)\n    (hf : \u2200 i, f i 0 = 0) {s : Finset \u2115} (hs : p.support \u2286 s) :\n    p.sum f = \u2211 n in s, f n (p.coeff n)", "start": [982, 1], "end": [985, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.mul_eq_sum_sum", "code": "theorem mul_eq_sum_sum :\n    p * q = \u2211 i in p.support, q.sum fun j a => (monomial (i + j)) (p.coeff i * a)", "start": [988, 1], "end": [994, 6], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_zero_index", "code": "@[simp]\ntheorem sum_zero_index {S : Type*} [AddCommMonoid S] (f : \u2115 \u2192 R \u2192 S) : (0 : R[X]).sum f = 0", "start": [997, 1], "end": [999, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_monomial_index", "code": "@[simp]\ntheorem sum_monomial_index {S : Type*} [AddCommMonoid S] {n : \u2115} (a : R) (f : \u2115 \u2192 R \u2192 S)\n    (hf : f n 0 = 0) : (monomial n a : R[X]).sum f = f n a", "start": [1002, 1], "end": [1005, 30], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_C_index", "code": "@[simp]\ntheorem sum_C_index {a} {\u03b2} [AddCommMonoid \u03b2] {f : \u2115 \u2192 R \u2192 \u03b2} (h : f 0 0 = 0) :\n    (C a).sum f = f 0 a", "start": [1008, 1], "end": [1011, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_X_index", "code": "@[simp]\ntheorem sum_X_index {S : Type*} [AddCommMonoid S] {f : \u2115 \u2192 R \u2192 S} (hf : f 1 0 = 0) :\n    (X : R[X]).sum f = f 1 1", "start": [1015, 1], "end": [1018, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_add_index", "code": "theorem sum_add_index {S : Type*} [AddCommMonoid S] (p q : R[X]) (f : \u2115 \u2192 R \u2192 S)\n    (hf : \u2200 i, f i 0 = 0) (h_add : \u2200 a b\u2081 b\u2082, f a (b\u2081 + b\u2082) = f a b\u2081 + f a b\u2082) :\n    (p + q).sum f = p.sum f + q.sum f", "start": [1021, 1], "end": [1025, 79], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_add'", "code": "theorem sum_add' {S : Type*} [AddCommMonoid S] (p : R[X]) (f g : \u2115 \u2192 R \u2192 S) :\n    p.sum (f + g) = p.sum f + p.sum g", "start": [1028, 1], "end": [1029, 83], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_add", "code": "theorem sum_add {S : Type*} [AddCommMonoid S] (p : R[X]) (f g : \u2115 \u2192 R \u2192 S) :\n    (p.sum fun n x => f n x + g n x) = p.sum f + p.sum g", "start": [1032, 1], "end": [1034, 17], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_smul_index", "code": "theorem sum_smul_index {S : Type*} [AddCommMonoid S] (p : R[X]) (b : R) (f : \u2115 \u2192 R \u2192 S)\n    (hf : \u2200 i, f i 0 = 0) : (b \u2022 p).sum f = p.sum fun n a => f n (b * a)", "start": [1037, 1], "end": [1039, 28], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_monomial_eq", "code": "theorem sum_monomial_eq : \u2200 p : R[X], (p.sum fun n a => monomial n a) = p", "start": [1042, 1], "end": [1043, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.sum_C_mul_X_pow_eq", "code": "theorem sum_C_mul_X_pow_eq (p : R[X]) : (p.sum fun n a => C a * X ^ n) = p", "start": [1046, 1], "end": [1047, 53], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase", "code": "irreducible_def erase (n : \u2115) : R[X] \u2192 R[X]\n  | \u27e8p\u27e9 => \u27e8p.erase n\u27e9", "start": [1050, 1], "end": [1052, 23], "kind": "leanelabcommandcommandirreducibledef"}, {"full_name": "Polynomial.toFinsupp_erase", "code": "@[simp]\ntheorem toFinsupp_erase (p : R[X]) (n : \u2115) : toFinsupp (p.erase n) = p.toFinsupp.erase n", "start": [1055, 1], "end": [1058, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ofFinsupp_erase", "code": "@[simp]\ntheorem ofFinsupp_erase (p : R[\u2115]) (n : \u2115) :\n    (\u27e8p.erase n\u27e9 : R[X]) = (\u27e8p\u27e9 : R[X]).erase n", "start": [1061, 1], "end": [1065, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_erase", "code": "@[simp]\ntheorem support_erase (p : R[X]) (n : \u2115) : support (p.erase n) = (support p).erase n", "start": [1068, 1], "end": [1071, 56], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_add_erase", "code": "theorem monomial_add_erase (p : R[X]) (n : \u2115) : monomial n (coeff p n) + p.erase n = p", "start": [1074, 1], "end": [1078, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_erase", "code": "theorem coeff_erase (p : R[X]) (n i : \u2115) :\n    (p.erase n).coeff i = if i = n then 0 else p.coeff i", "start": [1081, 1], "end": [1086, 52], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase_zero", "code": "@[simp]\ntheorem erase_zero (n : \u2115) : (0 : R[X]).erase n = 0", "start": [1089, 1], "end": [1091, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase_monomial", "code": "@[simp]\ntheorem erase_monomial {n : \u2115} {a : R} : erase n (monomial n a) = 0", "start": [1094, 1], "end": [1096, 33], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase_same", "code": "@[simp]\ntheorem erase_same (p : R[X]) (n : \u2115) : coeff (p.erase n) n = 0", "start": [1099, 1], "end": [1100, 89], "kind": "commanddeclaration"}, {"full_name": "Polynomial.erase_ne", "code": "@[simp]\ntheorem erase_ne (p : R[X]) (n i : \u2115) (h : i \u2260 n) : coeff (p.erase n) i = coeff p i", "start": [1103, 1], "end": [1105, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.update", "code": "def update (p : R[X]) (n : \u2115) (a : R) : R[X] :=\n  Polynomial.ofFinsupp (p.toFinsupp.update n a)", "start": [1110, 1], "end": [1114, 48], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_update", "code": "theorem coeff_update (p : R[X]) (n : \u2115) (a : R) :\n    (p.update n a).coeff = Function.update p.coeff n a", "start": [1117, 1], "end": [1121, 63], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_update_apply", "code": "theorem coeff_update_apply (p : R[X]) (n : \u2115) (a : R) (i : \u2115) :\n    (p.update n a).coeff i = if i = n then a else p.coeff i", "start": [1124, 1], "end": [1126, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_update_same", "code": "@[simp]\ntheorem coeff_update_same (p : R[X]) (n : \u2115) (a : R) : (p.update n a).coeff n = a", "start": [1129, 1], "end": [1131, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_update_ne", "code": "theorem coeff_update_ne (p : R[X]) {n : \u2115} (a : R) {i : \u2115} (h : i \u2260 n) :\n    (p.update n a).coeff i = p.coeff i", "start": [1134, 1], "end": [1135, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.update_zero_eq_erase", "code": "@[simp]\ntheorem update_zero_eq_erase (p : R[X]) (n : \u2115) : p.update n 0 = p.erase n", "start": [1138, 1], "end": [1141, 39], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_update", "code": "theorem support_update (p : R[X]) (n : \u2115) (a : R) [Decidable (a = 0)] :\n    support (p.update n a) = if a = 0 then p.support.erase n else insert n p.support", "start": [1144, 1], "end": [1149, 10], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_update_zero", "code": "theorem support_update_zero (p : R[X]) (n : \u2115) : support (p.update n 0) = p.support.erase n", "start": [1152, 1], "end": [1153, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_update_ne_zero", "code": "theorem support_update_ne_zero (p : R[X]) (n : \u2115) {a : R} (ha : a \u2260 0) :\n    support (p.update n a) = insert n p.support", "start": [1156, 1], "end": [1157, 95], "kind": "commanddeclaration"}, {"full_name": "Polynomial.commSemiring", "code": "instance commSemiring : CommSemiring R[X] :=\n  { Function.Injective.commSemigroup toFinsupp toFinsupp_injective toFinsupp_mul with\n    toSemiring := Polynomial.semiring }", "start": [1168, 1], "end": [1170, 40], "kind": "commanddeclaration"}, {"full_name": "Polynomial.intCast", "code": "instance intCast : IntCast R[X] :=\n  \u27e8fun n => ofFinsupp n\u27e9", "start": [1179, 1], "end": [1180, 25], "kind": "commanddeclaration"}, {"full_name": "Polynomial.ring", "code": "instance ring : Ring R[X] :=\n  { Function.Injective.ring toFinsupp toFinsupp_injective (toFinsupp_zero (R := R))\n      toFinsupp_one toFinsupp_add\n      toFinsupp_mul toFinsupp_neg toFinsupp_sub (fun _ _ => toFinsupp_smul _ _)\n      (fun _ _ => toFinsupp_smul _ _) toFinsupp_pow (fun _ => rfl) fun _ => rfl with\n    toSemiring := Polynomial.semiring,\n    toIntCast := Polynomial.intCast\n    toNeg := Polynomial.neg'\n    toSub := Polynomial.sub\n    zsmul := ((. \u2022 .) : \u2124 \u2192 R[X] \u2192 R[X]) }", "start": [1183, 1], "end": [1193, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_neg", "code": "@[simp]\ntheorem coeff_neg (p : R[X]) (n : \u2115) : coeff (-p) n = -coeff p n", "start": [1196, 1], "end": [1200, 62], "kind": "commanddeclaration"}, {"full_name": "Polynomial.coeff_sub", "code": "@[simp]\ntheorem coeff_sub (p q : R[X]) (n : \u2115) : coeff (p - q) n = coeff p n - coeff q n", "start": [1203, 1], "end": [1208, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.monomial_neg", "code": "theorem monomial_neg (n : \u2115) (a : R) : monomial n (-a) = -monomial n a", "start": [1212, 1], "end": [1213, 81], "kind": "commanddeclaration"}, {"full_name": "Polynomial.support_neg", "code": "@[simp]\ntheorem support_neg {p : R[X]} : (-p).support = p.support", "start": [1216, 1], "end": [1220, 68], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_eq_int_cast", "code": "theorem C_eq_int_cast (n : \u2124) : C (n : R) = n", "start": [1223, 1], "end": [1223, 57], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_neg", "code": "theorem C_neg : C (-a) = -C a", "start": [1226, 1], "end": [1227, 22], "kind": "commanddeclaration"}, {"full_name": "Polynomial.C_sub", "code": "theorem C_sub : C (a - b) = C a - C b", "start": [1230, 1], "end": [1231, 24], "kind": "commanddeclaration"}, {"full_name": "Polynomial.commRing", "code": "instance commRing [CommRing R] : CommRing R[X] :=\n  { toRing := Polynomial.ring\n    mul_comm := mul_comm }", "start": [1236, 1], "end": [1239, 27], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nontrivial", "code": "instance nontrivial : Nontrivial R[X] := by\n  have h : Nontrivial R[\u2115] := by infer_instance\n  rcases h.exists_pair_ne with \u27e8x, y, hxy\u27e9\n  refine' \u27e8\u27e8\u27e8x\u27e9, \u27e8y\u27e9, _\u27e9\u27e9\n  simp [hxy]", "start": [1246, 1], "end": [1250, 13], "kind": "commanddeclaration"}, {"full_name": "Polynomial.X_ne_zero", "code": "theorem X_ne_zero : (X : R[X]) \u2260 0", "start": [1253, 1], "end": [1254, 46], "kind": "commanddeclaration"}, {"full_name": "Polynomial.rat_smul_eq_C_mul", "code": "theorem rat_smul_eq_C_mul (a : \u211a) (f : R[X]) : a \u2022 f = Polynomial.C (a : R) * f", "start": [1263, 1], "end": [1264, 69], "kind": "commanddeclaration"}, {"full_name": "Polynomial.nontrivial_iff", "code": "@[simp]\ntheorem nontrivial_iff [Semiring R] : Nontrivial R[X] \u2194 Nontrivial R", "start": [1269, 1], "end": [1274, 43], "kind": "commanddeclaration"}, {"full_name": "Polynomial.repr", "code": "protected instance repr [Repr R] [DecidableEq R] : Repr R[X] :=\n  \u27e8fun p prec =>\n    let termPrecAndReprs : List (WithTop \u2115 \u00d7 Lean.Format) :=\n      List.map (fun\n        | 0 => (max_prec, \"C \" ++ reprArg (coeff p 0))\n        | 1 => if coeff p 1 = 1\n          then (\u22a4, \"X\")\n          else (70, \"C \" ++ reprArg (coeff p 1) ++ \" * X\")\n        | n =>\n          if coeff p n = 1\n          then (80, \"X ^ \" ++ Nat.repr n)\n          else (70, \"C \" ++ reprArg (coeff p n) ++ \" * X ^ \" ++ Nat.repr n))\n      (p.support.sort (\u00b7 \u2264 \u00b7));\n    match termPrecAndReprs with\n    | [] => \"0\"\n    | [(tprec, t)] => if prec \u2265 tprec then Lean.Format.paren t else t\n    | ts =>\n      (if prec \u2265 65 then Lean.Format.paren else id)\n      (Lean.Format.fill\n        (Lean.Format.joinSep (ts.map Prod.snd) (\" +\" ++ Lean.Format.line)))\u27e9", "start": [1281, 1], "end": [1301, 77], "kind": "commanddeclaration"}]}
{"path": "Mathlib/Algebra/Regular/Pow.lean", "imports": ["Mathlib/Algebra/BigOperators/Basic.lean", "Mathlib/Algebra/Hom/Iterate.lean", "Mathlib/Algebra/Regular/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "IsLeftRegular.pow", "code": "theorem IsLeftRegular.pow (n : \u2115) (rla : IsLeftRegular a) : IsLeftRegular (a ^ n)", "start": [30, 1], "end": [32, 63], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.pow", "code": "theorem IsRightRegular.pow (n : \u2115) (rra : IsRightRegular a) : IsRightRegular (a ^ n)", "start": [35, 1], "end": [38, 22], "kind": "commanddeclaration"}, {"full_name": "IsRegular.pow", "code": "theorem IsRegular.pow (n : \u2115) (ra : IsRegular a) : IsRegular (a ^ n)", "start": [41, 1], "end": [43, 63], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.pow_iff", "code": "theorem IsLeftRegular.pow_iff {n : \u2115} (n0 : 0 < n) : IsLeftRegular (a ^ n) \u2194 IsLeftRegular a", "start": [46, 1], "end": [50, 29], "kind": "commanddeclaration"}, {"full_name": "IsRightRegular.pow_iff", "code": "theorem IsRightRegular.pow_iff {n : \u2115} (n0 : 0 < n) :\n    IsRightRegular (a ^ n) \u2194 IsRightRegular a", "start": [53, 1], "end": [58, 30], "kind": "commanddeclaration"}, {"full_name": "IsRegular.pow_iff", "code": "theorem IsRegular.pow_iff {n : \u2115} (n0 : 0 < n) : IsRegular (a ^ n) \u2194 IsRegular a", "start": [61, 1], "end": [64, 64], "kind": "commanddeclaration"}, {"full_name": "IsLeftRegular.prod", "code": "lemma IsLeftRegular.prod (h : \u2200 i \u2208 s, IsLeftRegular (f i)) :\n    IsLeftRegular (\u220f i in s, f i) :=\n  s.prod_induction _ _ (@IsLeftRegular.mul R _) isRegular_one.left h", "start": [75, 1], "end": [77, 69], "kind": "mathlibtacticlemma"}, {"full_name": "IsRightRegular.prod", "code": "lemma IsRightRegular.prod (h : \u2200 i \u2208 s, IsRightRegular (f i)) :\n    IsRightRegular (\u220f i in s, f i) :=\n  s.prod_induction _ _ (@IsRightRegular.mul R _) isRegular_one.right h", "start": [79, 1], "end": [81, 71], "kind": "mathlibtacticlemma"}, {"full_name": "IsRegular.prod", "code": "lemma IsRegular.prod (h : \u2200 i \u2208 s, IsRegular (f i)) :\n    IsRegular (\u220f i in s, f i) :=\n  \u27e8IsLeftRegular.prod fun a ha \u21a6 (h a ha).left,\n   IsRightRegular.prod fun a ha \u21a6 (h a ha).right\u27e9", "start": [83, 1], "end": [86, 50], "kind": "mathlibtacticlemma"}]}
{"path": "Mathlib/Algebra/MonoidAlgebra/Support.lean", "imports": ["Mathlib/Algebra/MonoidAlgebra/Basic.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "MonoidAlgebra.support_single_mul_subset", "code": "theorem support_single_mul_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :\n    (single a r * f : MonoidAlgebra k G).support \u2286 Finset.image ((\u00b7 * \u00b7) a) f.support", "start": [23, 1], "end": [36, 61], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_mul_single_subset", "code": "theorem support_mul_single_subset [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) (r : k) (a : G) :\n    (f * single a r).support \u2286 Finset.image (\u00b7 * a) f.support", "start": [39, 1], "end": [52, 53], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_single_mul_eq_image", "code": "theorem support_single_mul_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}\n    (hr : \u2200 y, r * y = 0 \u2194 y = 0) {x : G} (lx : IsLeftRegular x) :\n    (single x r * f : MonoidAlgebra k G).support = Finset.image ((\u00b7 * \u00b7) x) f.support", "start": [55, 1], "end": [62, 98], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_mul_single_eq_image", "code": "theorem support_mul_single_eq_image [DecidableEq G] [Mul G] (f : MonoidAlgebra k G) {r : k}\n    (hr : \u2200 y, y * r = 0 \u2194 y = 0) {x : G} (rx : IsRightRegular x) :\n    (f * single x r).support = Finset.image (\u00b7 * x) f.support", "start": [65, 1], "end": [72, 98], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_mul", "code": "theorem support_mul [Mul G] [DecidableEq G] (a b : MonoidAlgebra k G) :\n    (a * b).support \u2286 a.support.biUnion fun a\u2081 => b.support.biUnion fun a\u2082 => {a\u2081 * a\u2082}", "start": [75, 1], "end": [79, 82], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_mul_single", "code": "theorem support_mul_single [RightCancelSemigroup G] (f : MonoidAlgebra k G) (r : k)\n    (hr : \u2200 y, y * r = 0 \u2194 y = 0) (x : G) :\n    (f * single x r).support = f.support.map (mulRightEmbedding x)", "start": [82, 1], "end": [88, 51], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.support_single_mul", "code": "theorem support_single_mul [LeftCancelSemigroup G] (f : MonoidAlgebra k G) (r : k)\n    (hr : \u2200 y, r * y = 0 \u2194 y = 0) (x : G) :\n    (single x r * f : MonoidAlgebra k G).support = f.support.map (mulLeftEmbedding x)", "start": [91, 1], "end": [97, 39], "kind": "commanddeclaration"}, {"full_name": "MonoidAlgebra.mem_span_support", "code": "theorem mem_span_support (f : MonoidAlgebra k G) :\n    f \u2208 Submodule.span k (of k G '' (f.support : Set G))", "start": [104, 1], "end": [107, 80], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_mul", "code": "theorem support_mul [DecidableEq G] [Add G] (a b : k[G]) :\n    (a * b).support \u2286 a.support.biUnion fun a\u2081 => b.support.biUnion fun a\u2082 => {a\u2081 + a\u2082}", "start": [120, 1], "end": [122, 60], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_mul_single", "code": "theorem support_mul_single [AddRightCancelSemigroup G] (f : k[G]) (r : k)\n    (hr : \u2200 y, y * r = 0 \u2194 y = 0) (x : G) :\n    (f * single x r : k[G]).support = f.support.map (addRightEmbedding x)", "start": [125, 1], "end": [128, 70], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.support_single_mul", "code": "theorem support_single_mul [AddLeftCancelSemigroup G] (f : k[G]) (r : k)\n    (hr : \u2200 y, r * y = 0 \u2194 y = 0) (x : G) :\n    (single x r * f : k[G]).support = f.support.map (addLeftEmbedding x)", "start": [131, 1], "end": [134, 70], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_span_support", "code": "theorem mem_span_support [AddZeroClass G] (f : k[G]) :\n    f \u2208 Submodule.span k (of k G '' (f.support : Set G))", "start": [139, 1], "end": [142, 88], "kind": "commanddeclaration"}, {"full_name": "AddMonoidAlgebra.mem_span_support'", "code": "theorem mem_span_support' (f : k[G]) :\n    f \u2208 Submodule.span k (of' k G '' (f.support : Set G))", "start": [145, 1], "end": [150, 65], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/AffineSpace/AffineMap.lean", "imports": ["Mathlib/LinearAlgebra/BilinearMap.lean", "lake-packages/lean4/src/lean/Init.lean", "Mathlib/LinearAlgebra/Pi.lean", "Mathlib/Data/Set/Pointwise/Interval.lean", "Mathlib/LinearAlgebra/AffineSpace/Basic.lean", "Mathlib/LinearAlgebra/Prod.lean"], "premises": [{"full_name": "AffineMap", "code": "structure AffineMap (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*) [Ring k]\n  [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n  [AffineSpace V2 P2] where\n  toFun : P1 \u2192 P2\n  linear : V1 \u2192\u2097[k] V2\n  map_vadd' : \u2200 (p : P1) (v : V1), toFun (v +\u1d65 p) = linear v +\u1d65 toFun p", "start": [48, 1], "end": [55, 72], "kind": "commanddeclaration"}, {"full_name": "AffineMap.funLike", "code": "instance AffineMap.funLike (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*)\n    [Ring k] [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n    [AffineSpace V2 P2] : FunLike (P1 \u2192\u1d43[k] P2) P1 fun _ => P2\n    where\n  coe := AffineMap.toFun\n  coe_injective' := fun \u27e8f, f_linear, f_add\u27e9 \u27e8g, g_linear, g_add\u27e9 => fun (h : f = g) => by\n    cases' (AddTorsor.Nonempty : Nonempty P1) with p\n    congr with v\n    apply vadd_right_cancel (f p)\n    erw [\u2190 f_add, h, \u2190 g_add]", "start": [62, 1], "end": [71, 30], "kind": "commanddeclaration"}, {"full_name": "AffineMap.hasCoeToFun", "code": "instance AffineMap.hasCoeToFun (k : Type*) {V1 : Type*} (P1 : Type*) {V2 : Type*} (P2 : Type*)\n    [Ring k] [AddCommGroup V1] [Module k V1] [AffineSpace V1 P1] [AddCommGroup V2] [Module k V2]\n    [AffineSpace V2 P2] : CoeFun (P1 \u2192\u1d43[k] P2) fun _ => P1 \u2192 P2 :=\n  FunLike.hasCoeToFun", "start": [74, 1], "end": [77, 22], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAffineMap", "code": "def toAffineMap : V\u2081 \u2192\u1d43[k] V\u2082 where\n  toFun := f\n  linear := f\n  map_vadd' p v := f.map_add v p", "start": [85, 1], "end": [89, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_toAffineMap", "code": "@[simp]\ntheorem coe_toAffineMap : \u21d1f.toAffineMap = f", "start": [92, 1], "end": [94, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.toAffineMap_linear", "code": "@[simp]\ntheorem toAffineMap_linear : f.toAffineMap.linear = f", "start": [97, 1], "end": [99, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_mk", "code": "@[simp]\ntheorem coe_mk (f : P1 \u2192 P2) (linear add) : ((mk f linear add : P1 \u2192\u1d43[k] P2) : P1 \u2192 P2) = f", "start": [111, 1], "end": [115, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.toFun_eq_coe", "code": "@[simp]\ntheorem toFun_eq_coe (f : P1 \u2192\u1d43[k] P2) : f.toFun = \u21d1f", "start": [118, 1], "end": [121, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.map_vadd", "code": "@[simp]\ntheorem map_vadd (f : P1 \u2192\u1d43[k] P2) (p : P1) (v : V1) : f (v +\u1d65 p) = f.linear v +\u1d65 f p", "start": [124, 1], "end": [129, 18], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linearMap_vsub", "code": "@[simp]\ntheorem linearMap_vsub (f : P1 \u2192\u1d43[k] P2) (p1 p2 : P1) : f.linear (p1 -\u1d65 p2) = f p1 -\u1d65 f p2", "start": [132, 1], "end": [137, 58], "kind": "commanddeclaration"}, {"full_name": "AffineMap.ext", "code": "@[ext]\ntheorem ext {f g : P1 \u2192\u1d43[k] P2} (h : \u2200 p, f p = g p) : f = g", "start": [140, 1], "end": [143, 20], "kind": "commanddeclaration"}, {"full_name": "AffineMap.ext_iff", "code": "theorem ext_iff {f g : P1 \u2192\u1d43[k] P2} : f = g \u2194 \u2200 p, f p = g p", "start": [146, 1], "end": [147, 28], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coeFn_injective", "code": "theorem coeFn_injective : @Function.Injective (P1 \u2192\u1d43[k] P2) (P1 \u2192 P2) (\u21d1)", "start": [150, 1], "end": [151, 24], "kind": "commanddeclaration"}, {"full_name": "AffineMap.congr_arg", "code": "protected theorem congr_arg (f : P1 \u2192\u1d43[k] P2) {x y : P1} (h : x = y) : f x = f y", "start": [154, 1], "end": [155, 16], "kind": "commanddeclaration"}, {"full_name": "AffineMap.congr_fun", "code": "protected theorem congr_fun {f g : P1 \u2192\u1d43[k] P2} (h : f = g) (x : P1) : f x = g x", "start": [158, 1], "end": [159, 10], "kind": "commanddeclaration"}, {"full_name": "AffineMap.const", "code": "def const (p : P2) : P1 \u2192\u1d43[k] P2 where\n  toFun := Function.const P1 p\n  linear := 0\n  map_vadd' _ _ :=\n    letI : AddAction V2 P2 := inferInstance\n    by simp", "start": [164, 1], "end": [170, 12], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_const", "code": "@[simp]\ntheorem coe_const (p : P2) : \u21d1(const k P1 p) = Function.const P1 p", "start": [173, 1], "end": [175, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.const_apply", "code": "@[simp]\ntheorem const_apply (p : P2) (q : P1) : (const k P1 p) q = p", "start": [179, 1], "end": [180, 68], "kind": "commanddeclaration"}, {"full_name": "AffineMap.const_linear", "code": "@[simp]\ntheorem const_linear (p : P2) : (const k P1 p).linear = 0", "start": [182, 1], "end": [184, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linear_eq_zero_iff_exists_const", "code": "theorem linear_eq_zero_iff_exists_const (f : P1 \u2192\u1d43[k] P2) :\n    f.linear = 0 \u2194 \u2203 q, f = const k P1 q", "start": [189, 1], "end": [197, 30], "kind": "commanddeclaration"}, {"full_name": "AffineMap.nonempty", "code": "instance nonempty : Nonempty (P1 \u2192\u1d43[k] P2) :=\n  (AddTorsor.Nonempty : Nonempty P2).elim fun p => \u27e8const k P1 p\u27e9", "start": [200, 1], "end": [201, 66], "kind": "commanddeclaration"}, {"full_name": "AffineMap.mk'", "code": "def mk' (f : P1 \u2192 P2) (f' : V1 \u2192\u2097[k] V2) (p : P1) (h : \u2200 p' : P1, f p' = f' (p' -\u1d65 p) +\u1d65 f p) :\n    P1 \u2192\u1d43[k] P2 where\n  toFun := f\n  linear := f'\n  map_vadd' p' v := by rw [h, h p', vadd_vsub_assoc, f'.map_add, vadd_vadd]", "start": [204, 1], "end": [211, 76], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_mk'", "code": "@[simp]\ntheorem coe_mk' (f : P1 \u2192 P2) (f' : V1 \u2192\u2097[k] V2) (p h) : \u21d1(mk' f f' p h) = f", "start": [214, 1], "end": [216, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.mk'_linear", "code": "@[simp]\ntheorem mk'_linear (f : P1 \u2192 P2) (f' : V1 \u2192\u2097[k] V2) (p h) : (mk' f f' p h).linear = f'", "start": [219, 1], "end": [221, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.mulAction", "code": "instance mulAction : MulAction R (P1 \u2192\u1d43[k] V2) where\n  smul c f := \u27e8c \u2022 \u21d1f, c \u2022 f.linear, fun p v => by simp [smul_add, map_vadd f]\u27e9\n  one_smul f := ext fun p => one_smul _ _\n  mul_smul c\u2081 c\u2082 f := ext fun p => mul_smul _ _ _", "start": [227, 1], "end": [232, 50], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_smul", "code": "@[simp, norm_cast]\ntheorem coe_smul (c : R) (f : P1 \u2192\u1d43[k] V2) : \u21d1(c \u2022 f) = c \u2022 \u21d1f", "start": [234, 1], "end": [236, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.smul_linear", "code": "@[simp]\ntheorem smul_linear (t : R) (f : P1 \u2192\u1d43[k] V2) : (t \u2022 f).linear = t \u2022 f.linear", "start": [239, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.isCentralScalar", "code": "instance isCentralScalar [DistribMulAction R\u1d50\u1d52\u1d56 V2] [IsCentralScalar R V2] :\n  IsCentralScalar R (P1 \u2192\u1d43[k] V2) where\n    op_smul_eq_smul _r _x := ext fun _ => op_smul_eq_smul _ _", "start": [244, 1], "end": [246, 62], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_zero", "code": "@[simp, norm_cast]\ntheorem coe_zero : \u21d1(0 : P1 \u2192\u1d43[k] V2) = 0", "start": [265, 1], "end": [267, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_add", "code": "@[simp, norm_cast]\ntheorem coe_add (f g : P1 \u2192\u1d43[k] V2) : \u21d1(f + g) = f + g", "start": [270, 1], "end": [272, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_neg", "code": "@[simp, norm_cast]\ntheorem coe_neg (f : P1 \u2192\u1d43[k] V2) : \u21d1(-f) = -f", "start": [275, 1], "end": [277, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_sub", "code": "@[simp, norm_cast]\ntheorem coe_sub (f g : P1 \u2192\u1d43[k] V2) : \u21d1(f - g) = f - g", "start": [280, 1], "end": [282, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.zero_linear", "code": "@[simp]\ntheorem zero_linear : (0 : P1 \u2192\u1d43[k] V2).linear = 0", "start": [285, 1], "end": [287, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.add_linear", "code": "@[simp]\ntheorem add_linear (f g : P1 \u2192\u1d43[k] V2) : (f + g).linear = f.linear + g.linear", "start": [290, 1], "end": [292, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.sub_linear", "code": "@[simp]\ntheorem sub_linear (f g : P1 \u2192\u1d43[k] V2) : (f - g).linear = f.linear - g.linear", "start": [295, 1], "end": [297, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.neg_linear", "code": "@[simp]\ntheorem neg_linear (f : P1 \u2192\u1d43[k] V2) : (-f).linear = -f.linear", "start": [300, 1], "end": [302, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.vadd_apply", "code": "@[simp]\ntheorem vadd_apply (f : P1 \u2192\u1d43[k] V2) (g : P1 \u2192\u1d43[k] P2) (p : P1) : (f +\u1d65 g) p = f p +\u1d65 g p", "start": [328, 1], "end": [330, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.vsub_apply", "code": "@[simp]\ntheorem vsub_apply (f g : P1 \u2192\u1d43[k] P2) (p : P1) : (f -\u1d65 g : P1 \u2192\u1d43[k] V2) p = f p -\u1d65 g p", "start": [333, 1], "end": [335, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.fst", "code": "def fst : P1 \u00d7 P2 \u2192\u1d43[k] P1 where\n  toFun := Prod.fst\n  linear := LinearMap.fst k V1 V2\n  map_vadd' _ _ := rfl", "start": [338, 1], "end": [342, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_fst", "code": "@[simp]\ntheorem coe_fst : \u21d1(fst : P1 \u00d7 P2 \u2192\u1d43[k] P1) = Prod.fst", "start": [345, 1], "end": [347, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.fst_linear", "code": "@[simp]\ntheorem fst_linear : (fst : P1 \u00d7 P2 \u2192\u1d43[k] P1).linear = LinearMap.fst k V1 V2", "start": [350, 1], "end": [352, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.snd", "code": "def snd : P1 \u00d7 P2 \u2192\u1d43[k] P2 where\n  toFun := Prod.snd\n  linear := LinearMap.snd k V1 V2\n  map_vadd' _ _ := rfl", "start": [355, 1], "end": [359, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_snd", "code": "@[simp]\ntheorem coe_snd : \u21d1(snd : P1 \u00d7 P2 \u2192\u1d43[k] P2) = Prod.snd", "start": [362, 1], "end": [364, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.snd_linear", "code": "@[simp]\ntheorem snd_linear : (snd : P1 \u00d7 P2 \u2192\u1d43[k] P2).linear = LinearMap.snd k V1 V2", "start": [367, 1], "end": [369, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.id", "code": "nonrec def id : P1 \u2192\u1d43[k] P1 where\n  toFun := id\n  linear := LinearMap.id\n  map_vadd' _ _ := rfl", "start": [373, 1], "end": [377, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_id", "code": "@[simp]\ntheorem coe_id : \u21d1(id k P1) = _root_.id", "start": [380, 1], "end": [383, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.id_linear", "code": "@[simp]\ntheorem id_linear : (id k P1).linear = LinearMap.id", "start": [386, 1], "end": [388, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.id_apply", "code": "theorem id_apply (p : P1) : id k P1 p = p", "start": [393, 1], "end": [395, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.comp", "code": "def comp (f : P2 \u2192\u1d43[k] P3) (g : P1 \u2192\u1d43[k] P2) : P1 \u2192\u1d43[k] P3 where\n  toFun := f \u2218 g\n  linear := f.linear.comp g.linear\n  map_vadd' := by\n    intro p v\n    rw [Function.comp_apply, g.map_vadd, f.map_vadd]\n    rfl", "start": [403, 1], "end": [410, 8], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_comp", "code": "@[simp]\ntheorem coe_comp (f : P2 \u2192\u1d43[k] P3) (g : P1 \u2192\u1d43[k] P2) : \u21d1(f.comp g) = f \u2218 g", "start": [413, 1], "end": [416, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.comp_apply", "code": "theorem comp_apply (f : P2 \u2192\u1d43[k] P3) (g : P1 \u2192\u1d43[k] P2) (p : P1) : f.comp g p = f (g p)", "start": [419, 1], "end": [421, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.comp_id", "code": "@[simp]\ntheorem comp_id (f : P1 \u2192\u1d43[k] P2) : f.comp (id k P1) = f", "start": [424, 1], "end": [426, 19], "kind": "commanddeclaration"}, {"full_name": "AffineMap.id_comp", "code": "@[simp]\ntheorem id_comp (f : P1 \u2192\u1d43[k] P2) : (id k P2).comp f = f", "start": [429, 1], "end": [431, 19], "kind": "commanddeclaration"}, {"full_name": "AffineMap.comp_assoc", "code": "theorem comp_assoc (f\u2083\u2084 : P3 \u2192\u1d43[k] P4) (f\u2082\u2083 : P2 \u2192\u1d43[k] P3) (f\u2081\u2082 : P1 \u2192\u1d43[k] P2) :\n    (f\u2083\u2084.comp f\u2082\u2083).comp f\u2081\u2082 = f\u2083\u2084.comp (f\u2082\u2083.comp f\u2081\u2082)", "start": [434, 1], "end": [436, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_mul", "code": "@[simp]\ntheorem coe_mul (f g : P1 \u2192\u1d43[k] P1) : \u21d1(f * g) = f \u2218 g", "start": [446, 1], "end": [448, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_one", "code": "@[simp]\ntheorem coe_one : \u21d1(1 : P1 \u2192\u1d43[k] P1) = _root_.id", "start": [451, 1], "end": [453, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linearHom", "code": "@[simps]\ndef linearHom : (P1 \u2192\u1d43[k] P1) \u2192* V1 \u2192\u2097[k] V1 where\n  toFun := linear\n  map_one' := rfl\n  map_mul' _ _ := rfl", "start": [456, 1], "end": [461, 22], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linear_injective_iff", "code": "@[simp]\ntheorem linear_injective_iff (f : P1 \u2192\u1d43[k] P2) :\n    Function.Injective f.linear \u2194 Function.Injective f", "start": [464, 1], "end": [471, 53], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linear_surjective_iff", "code": "@[simp]\ntheorem linear_surjective_iff (f : P1 \u2192\u1d43[k] P2) :\n    Function.Surjective f.linear \u2194 Function.Surjective f", "start": [474, 1], "end": [481, 55], "kind": "commanddeclaration"}, {"full_name": "AffineMap.linear_bijective_iff", "code": "@[simp]\ntheorem linear_bijective_iff (f : P1 \u2192\u1d43[k] P2) :\n    Function.Bijective f.linear \u2194 Function.Bijective f", "start": [484, 1], "end": [487, 59], "kind": "commanddeclaration"}, {"full_name": "AffineMap.image_vsub_image", "code": "theorem image_vsub_image {s t : Set P1} (f : P1 \u2192\u1d43[k] P2) :\n    f '' s -\u1d65 f '' t = f.linear '' (s -\u1d65 t)", "start": [490, 1], "end": [500, 30], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap", "code": "def lineMap (p\u2080 p\u2081 : P1) : k \u2192\u1d43[k] P1 :=\n  ((LinearMap.id : k \u2192\u2097[k] k).smulRight (p\u2081 -\u1d65 p\u2080)).toAffineMap +\u1d65 const k k p\u2080", "start": [505, 1], "end": [507, 80], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_lineMap", "code": "theorem coe_lineMap (p\u2080 p\u2081 : P1) : (lineMap p\u2080 p\u2081 : k \u2192 P1) = fun c => c \u2022 (p\u2081 -\u1d65 p\u2080) +\u1d65 p\u2080", "start": [510, 1], "end": [511, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply", "code": "theorem lineMap_apply (p\u2080 p\u2081 : P1) (c : k) : lineMap p\u2080 p\u2081 c = c \u2022 (p\u2081 -\u1d65 p\u2080) +\u1d65 p\u2080", "start": [514, 1], "end": [515, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_module'", "code": "theorem lineMap_apply_module' (p\u2080 p\u2081 : V1) (c : k) : lineMap p\u2080 p\u2081 c = c \u2022 (p\u2081 - p\u2080) + p\u2080", "start": [518, 1], "end": [519, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_module", "code": "theorem lineMap_apply_module (p\u2080 p\u2081 : V1) (c : k) : lineMap p\u2080 p\u2081 c = (1 - c) \u2022 p\u2080 + c \u2022 p\u2081", "start": [522, 1], "end": [523, 57], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_ring'", "code": "theorem lineMap_apply_ring' (a b c : k) : lineMap a b c = c * (b - a) + a", "start": [526, 1], "end": [527, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_ring", "code": "theorem lineMap_apply_ring (a b c : k) : lineMap a b c = (1 - c) * a + c * b", "start": [530, 1], "end": [531, 29], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vadd_apply", "code": "theorem lineMap_vadd_apply (p : P1) (v : V1) (c : k) : lineMap p (v +\u1d65 p) c = c \u2022 v +\u1d65 p", "start": [534, 1], "end": [535, 32], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_linear", "code": "@[simp]\ntheorem lineMap_linear (p\u2080 p\u2081 : P1) :\n    (lineMap p\u2080 p\u2081 : k \u2192\u1d43[k] P1).linear = LinearMap.id.smulRight (p\u2081 -\u1d65 p\u2080)", "start": [538, 1], "end": [541, 13], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_same_apply", "code": "theorem lineMap_same_apply (p : P1) (c : k) : lineMap p p c = p", "start": [544, 1], "end": [547, 38], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_same", "code": "@[simp]\ntheorem lineMap_same (p : P1) : lineMap p p = const k k p", "start": [550, 1], "end": [552, 30], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_zero", "code": "@[simp]\ntheorem lineMap_apply_zero (p\u2080 p\u2081 : P1) : lineMap p\u2080 p\u2081 (0 : k) = p\u2080", "start": [555, 1], "end": [559, 25], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_one", "code": "@[simp]\ntheorem lineMap_apply_one (p\u2080 p\u2081 : P1) : lineMap p\u2080 p\u2081 (1 : k) = p\u2081", "start": [562, 1], "end": [565, 38], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_eq_lineMap_iff", "code": "@[simp]\ntheorem lineMap_eq_lineMap_iff [NoZeroSMulDivisors k V1] {p\u2080 p\u2081 : P1} {c\u2081 c\u2082 : k} :\n    lineMap p\u2080 p\u2081 c\u2081 = lineMap p\u2080 p\u2081 c\u2082 \u2194 p\u2080 = p\u2081 \u2228 c\u2081 = c\u2082", "start": [568, 1], "end": [572, 80], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_eq_left_iff", "code": "@[simp]\ntheorem lineMap_eq_left_iff [NoZeroSMulDivisors k V1] {p\u2080 p\u2081 : P1} {c : k} :\n    lineMap p\u2080 p\u2081 c = p\u2080 \u2194 p\u2080 = p\u2081 \u2228 c = 0", "start": [575, 1], "end": [578, 58], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_eq_right_iff", "code": "@[simp]\ntheorem lineMap_eq_right_iff [NoZeroSMulDivisors k V1] {p\u2080 p\u2081 : P1} {c : k} :\n    lineMap p\u2080 p\u2081 c = p\u2081 \u2194 p\u2080 = p\u2081 \u2228 c = 1", "start": [581, 1], "end": [584, 57], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_injective", "code": "theorem lineMap_injective [NoZeroSMulDivisors k V1] {p\u2080 p\u2081 : P1} (h : p\u2080 \u2260 p\u2081) :\n    Function.Injective (lineMap p\u2080 p\u2081 : k \u2192 P1)", "start": [589, 1], "end": [591, 48], "kind": "commanddeclaration"}, {"full_name": "AffineMap.apply_lineMap", "code": "@[simp]\ntheorem apply_lineMap (f : P1 \u2192\u1d43[k] P2) (p\u2080 p\u2081 : P1) (c : k) :\n    f (lineMap p\u2080 p\u2081 c) = lineMap (f p\u2080) (f p\u2081) c", "start": [596, 1], "end": [600, 55], "kind": "commanddeclaration"}, {"full_name": "AffineMap.comp_lineMap", "code": "@[simp]\ntheorem comp_lineMap (f : P1 \u2192\u1d43[k] P2) (p\u2080 p\u2081 : P1) :\n    f.comp (lineMap p\u2080 p\u2081) = lineMap (f p\u2080) (f p\u2081)", "start": [603, 1], "end": [606, 31], "kind": "commanddeclaration"}, {"full_name": "AffineMap.fst_lineMap", "code": "@[simp]\ntheorem fst_lineMap (p\u2080 p\u2081 : P1 \u00d7 P2) (c : k) : (lineMap p\u2080 p\u2081 c).1 = lineMap p\u2080.1 p\u2081.1 c", "start": [609, 1], "end": [611, 28], "kind": "commanddeclaration"}, {"full_name": "AffineMap.snd_lineMap", "code": "@[simp]\ntheorem snd_lineMap (p\u2080 p\u2081 : P1 \u00d7 P2) (c : k) : (lineMap p\u2080 p\u2081 c).2 = lineMap p\u2080.2 p\u2081.2 c", "start": [614, 1], "end": [616, 28], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_symm", "code": "theorem lineMap_symm (p\u2080 p\u2081 : P1) :\n    lineMap p\u2080 p\u2081 = (lineMap p\u2081 p\u2080).comp (lineMap (1 : k) (0 : k))", "start": [619, 1], "end": [622, 7], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_apply_one_sub", "code": "theorem lineMap_apply_one_sub (p\u2080 p\u2081 : P1) (c : k) : lineMap p\u2080 p\u2081 (1 - c) = lineMap p\u2081 p\u2080 c", "start": [625, 1], "end": [628, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vsub_left", "code": "@[simp]\ntheorem lineMap_vsub_left (p\u2080 p\u2081 : P1) (c : k) : lineMap p\u2080 p\u2081 c -\u1d65 p\u2080 = c \u2022 (p\u2081 -\u1d65 p\u2080)", "start": [631, 1], "end": [633, 16], "kind": "commanddeclaration"}, {"full_name": "AffineMap.left_vsub_lineMap", "code": "@[simp]\ntheorem left_vsub_lineMap (p\u2080 p\u2081 : P1) (c : k) : p\u2080 -\u1d65 lineMap p\u2080 p\u2081 c = c \u2022 (p\u2080 -\u1d65 p\u2081)", "start": [636, 1], "end": [638, 83], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vsub_right", "code": "@[simp]\ntheorem lineMap_vsub_right (p\u2080 p\u2081 : P1) (c : k) : lineMap p\u2080 p\u2081 c -\u1d65 p\u2081 = (1 - c) \u2022 (p\u2080 -\u1d65 p\u2081)", "start": [641, 1], "end": [643, 50], "kind": "commanddeclaration"}, {"full_name": "AffineMap.right_vsub_lineMap", "code": "@[simp]\ntheorem right_vsub_lineMap (p\u2080 p\u2081 : P1) (c : k) : p\u2081 -\u1d65 lineMap p\u2080 p\u2081 c = (1 - c) \u2022 (p\u2081 -\u1d65 p\u2080)", "start": [646, 1], "end": [648, 50], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vadd_lineMap", "code": "theorem lineMap_vadd_lineMap (v\u2081 v\u2082 : V1) (p\u2081 p\u2082 : P1) (c : k) :\n    lineMap v\u2081 v\u2082 c +\u1d65 lineMap p\u2081 p\u2082 c = lineMap (v\u2081 +\u1d65 p\u2081) (v\u2082 +\u1d65 p\u2082) c", "start": [651, 1], "end": [653, 91], "kind": "commanddeclaration"}, {"full_name": "AffineMap.lineMap_vsub_lineMap", "code": "theorem lineMap_vsub_lineMap (p\u2081 p\u2082 p\u2083 p\u2084 : P1) (c : k) :\n    lineMap p\u2081 p\u2082 c -\u1d65 lineMap p\u2083 p\u2084 c = lineMap (p\u2081 -\u1d65 p\u2083) (p\u2082 -\u1d65 p\u2084) c", "start": [656, 1], "end": [658, 87], "kind": "commanddeclaration"}, {"full_name": "AffineMap.decomp", "code": "theorem decomp (f : V1 \u2192\u1d43[k] V2) : (f : V1 \u2192 V2) = \u21d1f.linear + fun _ => f 0", "start": [661, 1], "end": [667, 48], "kind": "commanddeclaration"}, {"full_name": "AffineMap.decomp'", "code": "theorem decomp' (f : V1 \u2192\u1d43[k] V2) : (f.linear : V1 \u2192 V2) = \u21d1f - fun _ => f 0", "start": [670, 1], "end": [674, 73], "kind": "commanddeclaration"}, {"full_name": "AffineMap.image_uIcc", "code": "theorem image_uIcc {k : Type*} [LinearOrderedField k] (f : k \u2192\u1d43[k] k) (a b : k) :\n    f '' Set.uIcc a b = Set.uIcc (f a) (f b)", "start": [677, 1], "end": [685, 86], "kind": "commanddeclaration"}, {"full_name": "AffineMap.proj", "code": "def proj (i : \u03b9) : (\u2200 i : \u03b9, P i) \u2192\u1d43[k] P i where\n  toFun f := f i\n  linear := @LinearMap.proj k \u03b9 _ V _ _ i\n  map_vadd' _ _ := rfl", "start": [693, 1], "end": [697, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.proj_apply", "code": "@[simp]\ntheorem proj_apply (i : \u03b9) (f : \u2200 i, P i) : @proj k _ \u03b9 V P _ _ _ i f = f i", "start": [700, 1], "end": [702, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.proj_linear", "code": "@[simp]\ntheorem proj_linear (i : \u03b9) : (@proj k _ \u03b9 V P _ _ _ i).linear = @LinearMap.proj k \u03b9 _ V _ _ i", "start": [705, 1], "end": [707, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.pi_lineMap_apply", "code": "theorem pi_lineMap_apply (f g : \u2200 i, P i) (c : k) (i : \u03b9) :\n    lineMap f g c i = lineMap (f i) (g i) c", "start": [710, 1], "end": [712, 54], "kind": "commanddeclaration"}, {"full_name": "AffineMap.distribMulAction", "code": "instance distribMulAction : DistribMulAction R (P1 \u2192\u1d43[k] V2) where\n  smul_add _c _f _g := ext fun _p => smul_add _ _ _\n  smul_zero _c := ext fun _p => smul_zero _", "start": [733, 1], "end": [736, 44], "kind": "commanddeclaration"}, {"full_name": "AffineMap.toConstProdLinearMap", "code": "@[simps]\ndef toConstProdLinearMap : (V1 \u2192\u1d43[k] V2) \u2243\u2097[R] V2 \u00d7 (V1 \u2192\u2097[k] V2) where\n  toFun f := \u27e8f 0, f.linear\u27e9\n  invFun p := p.2.toAffineMap + const k V1 p.1\n  left_inv f := by\n    ext\n    rw [f.decomp]\n    simp [const_apply _ _]  right_inv := by\n    rintro \u27e8v, f\u27e9\n    ext <;> simp [const_apply _ _, const_linear _ _]  map_add' := by simp\n  map_smul' := by simp", "start": [752, 1], "end": [769, 23], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety", "code": "def homothety (c : P1) (r : k) : P1 \u2192\u1d43[k] P1 :=\n  r \u2022 (id k P1 -\u1d65 const k P1 c) +\u1d65 const k P1 c", "start": [782, 1], "end": [784, 48], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_def", "code": "theorem homothety_def (c : P1) (r : k) :\n    homothety c r = r \u2022 (id k P1 -\u1d65 const k P1 c) +\u1d65 const k P1 c", "start": [787, 1], "end": [789, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_apply", "code": "theorem homothety_apply (c : P1) (r : k) (p : P1) : homothety c r p = r \u2022 (p -\u1d65 c : V1) +\u1d65 c", "start": [792, 1], "end": [793, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_eq_lineMap", "code": "theorem homothety_eq_lineMap (c : P1) (r : k) (p : P1) : homothety c r p = lineMap c p r", "start": [796, 1], "end": [797, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_one", "code": "@[simp]\ntheorem homothety_one (c : P1) : homothety c (1 : k) = id k P1", "start": [800, 1], "end": [803, 25], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_apply_same", "code": "@[simp]\ntheorem homothety_apply_same (c : P1) (r : k) : homothety c r c = c", "start": [806, 1], "end": [808, 25], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_mul_apply", "code": "theorem homothety_mul_apply (c : P1) (r\u2081 r\u2082 : k) (p : P1) :\n    homothety c (r\u2081 * r\u2082) p = homothety c r\u2081 (homothety c r\u2082 p)", "start": [811, 1], "end": [813, 51], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_mul", "code": "theorem homothety_mul (c : P1) (r\u2081 r\u2082 : k) :\n    homothety c (r\u2081 * r\u2082) = (homothety c r\u2081).comp (homothety c r\u2082)", "start": [816, 1], "end": [818, 37], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_zero", "code": "@[simp]\ntheorem homothety_zero (c : P1) : homothety c (0 : k) = const k P1 c", "start": [821, 1], "end": [824, 25], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothety_add", "code": "@[simp]\ntheorem homothety_add (c : P1) (r\u2081 r\u2082 : k) :\n    homothety c (r\u2081 + r\u2082) = r\u2081 \u2022 (id k P1 -\u1d65 const k P1 c) +\u1d65 homothety c r\u2082", "start": [827, 1], "end": [830, 49], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothetyHom", "code": "def homothetyHom (c : P1) : k \u2192* P1 \u2192\u1d43[k] P1 where\n  toFun := homothety c\n  map_one' := homothety_one c\n  map_mul' := homothety_mul c", "start": [833, 1], "end": [837, 30], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_homothetyHom", "code": "@[simp]\ntheorem coe_homothetyHom (c : P1) : \u21d1(homothetyHom c : k \u2192* _) = homothety c", "start": [840, 1], "end": [842, 6], "kind": "commanddeclaration"}, {"full_name": "AffineMap.homothetyAffine", "code": "def homothetyAffine (c : P1) : k \u2192\u1d43[k] P1 \u2192\u1d43[k] P1 :=\n  \u27e8homothety c, (LinearMap.lsmul k _).flip (id k P1 -\u1d65 const k P1 c),\n    Function.swap (homothety_add c)\u27e9", "start": [845, 1], "end": [848, 37], "kind": "commanddeclaration"}, {"full_name": "AffineMap.coe_homothetyAffine", "code": "@[simp]\ntheorem coe_homothetyAffine (c : P1) : \u21d1(homothetyAffine c : k \u2192\u1d43[k] _) = homothety c", "start": [851, 1], "end": [853, 6], "kind": "commanddeclaration"}, {"full_name": "Convex.combo_affine_apply", "code": "theorem Convex.combo_affine_apply {x y : E} {a b : \ud835\udd5c} {f : E \u2192\u1d43[\ud835\udd5c] F} (h : a + b = 1) :\n    f (a \u2022 x + b \u2022 y) = a \u2022 f x + b \u2022 f y", "start": [864, 1], "end": [869, 30], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/GeneralLinearGroup.lean", "imports": ["Mathlib/Algebra/Module/Equiv.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.GeneralLinearGroup", "code": "@[reducible]\ndef GeneralLinearGroup :=\n  (M \u2192\u2097[R] M)\u02e3", "start": [30, 1], "end": [33, 15], "kind": "commanddeclaration"}, {"full_name": "LinearMap.GeneralLinearGroup.toLinearEquiv", "code": "def toLinearEquiv (f : GeneralLinearGroup R M) : M \u2243\u2097[R] M :=\n  { f.val with\n    invFun := f.inv.toFun\n    left_inv := fun m \u21a6 show (f.inv * f.val) m = m by erw [f.inv_val]; simp\n    right_inv := fun m \u21a6 show (f.val * f.inv) m = m by erw [f.val_inv]; simp }", "start": [43, 1], "end": [48, 79], "kind": "commanddeclaration"}, {"full_name": "LinearMap.GeneralLinearGroup.ofLinearEquiv", "code": "def ofLinearEquiv (f : M \u2243\u2097[R] M) : GeneralLinearGroup R M where\n  val := f\n  inv := (f.symm : M \u2192\u2097[R] M)\n  val_inv := LinearMap.ext fun _ \u21a6 f.apply_symm_apply _\n  inv_val := LinearMap.ext fun _ \u21a6 f.symm_apply_apply _", "start": [51, 1], "end": [56, 56], "kind": "commanddeclaration"}, {"full_name": "LinearMap.GeneralLinearGroup.generalLinearEquiv", "code": "def generalLinearEquiv : GeneralLinearGroup R M \u2243* M \u2243\u2097[R] M where\n  toFun := toLinearEquiv\n  invFun := ofLinearEquiv\n  left_inv f := by ext; rfl\n  right_inv f := by ext; rfl\n  map_mul' x y := by ext; rfl", "start": [61, 1], "end": [68, 30], "kind": "commanddeclaration"}, {"full_name": "LinearMap.GeneralLinearGroup.generalLinearEquiv_to_linearMap", "code": "@[simp]\ntheorem generalLinearEquiv_to_linearMap (f : GeneralLinearGroup R M) :\n    (generalLinearEquiv R M f : M \u2192\u2097[R] M) = f", "start": [71, 1], "end": [73, 62], "kind": "commanddeclaration"}, {"full_name": "LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv", "code": "@[simp]\ntheorem coeFn_generalLinearEquiv (f : GeneralLinearGroup R M) :\n    (generalLinearEquiv R M f) = (f : M \u2192 M)", "start": [76, 1], "end": [78, 52], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Basis/VectorSpace.lean", "imports": ["Mathlib/LinearAlgebra/FreeModule/Basic.lean", "Mathlib/LinearAlgebra/Basis.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Basis.extend", "code": "noncomputable def extend (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    Basis (hs.extend (subset_univ s)) K V :=\n  Basis.mk\n    (@LinearIndependent.restrict_of_comp_subtype _ _ _ id _ _ _ _ (hs.linearIndependent_extend _))\n    (SetLike.coe_subset_coe.mp <| by simpa using hs.subset_span_extend (subset_univ s))", "start": [50, 1], "end": [55, 88], "kind": "commanddeclaration"}, {"full_name": "Basis.extend_apply_self", "code": "theorem extend_apply_self (hs : LinearIndependent K ((\u2191) : s \u2192 V)) (x : hs.extend _) :\n    Basis.extend hs x = x", "start": [58, 1], "end": [60, 23], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_extend", "code": "@[simp]\ntheorem coe_extend (hs : LinearIndependent K ((\u2191) : s \u2192 V)) : \u21d1(Basis.extend hs) = ((\u2191) : _ \u2192 _)", "start": [63, 1], "end": [65, 32], "kind": "commanddeclaration"}, {"full_name": "Basis.range_extend", "code": "theorem range_extend (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    range (Basis.extend hs) = hs.extend (subset_univ _)", "start": [68, 1], "end": [70, 59], "kind": "commanddeclaration"}, {"full_name": "Basis.sumExtendIndex", "code": "def sumExtendIndex (hs : LinearIndependent K v) : Set V :=\n  LinearIndependent.extend hs.to_subtype_range (subset_univ _) \\ range v", "start": [74, 1], "end": [79, 73], "kind": "commanddeclaration"}, {"full_name": "Basis.sumExtend", "code": "noncomputable def sumExtend (hs : LinearIndependent K v) : Basis (\u03b9 \u2295 sumExtendIndex hs) K V :=\n  let s := Set.range v\n  let e : \u03b9 \u2243 s := Equiv.ofInjective v hs.injective\n  let b := hs.to_subtype_range.extend (subset_univ (Set.range v))\n  (Basis.extend hs.to_subtype_range).reindex <|\n    Equiv.symm <|\n      calc\n        Sum \u03b9 (b \\ s : Set V) \u2243 Sum s (b \\ s : Set V) := Equiv.sumCongr e (Equiv.refl _)\n        _ \u2243 b :=\n          haveI := Classical.decPred (\u00b7 \u2208 s)\n          Equiv.Set.sumDiffSubset (hs.to_subtype_range.subset_extend _)", "start": [81, 1], "end": [92, 72], "kind": "commanddeclaration"}, {"full_name": "Basis.subset_extend", "code": "theorem subset_extend {s : Set V} (hs : LinearIndependent K ((\u2191) : s \u2192 V)) :\n    s \u2286 hs.extend (Set.subset_univ _)", "start": [95, 1], "end": [97, 21], "kind": "commanddeclaration"}, {"full_name": "Basis.ofVectorSpaceIndex", "code": "noncomputable def ofVectorSpaceIndex : Set V :=\n  (linearIndependent_empty K V).extend (subset_univ _)", "start": [104, 1], "end": [106, 55], "kind": "commanddeclaration"}, {"full_name": "Basis.ofVectorSpace", "code": "noncomputable def ofVectorSpace : Basis (ofVectorSpaceIndex K V) K V :=\n  Basis.extend (linearIndependent_empty K V)", "start": [109, 1], "end": [111, 45], "kind": "commanddeclaration"}, {"full_name": "Module.Free.of_divisionRing", "code": "instance (priority := 100) _root_.Module.Free.of_divisionRing : Module.Free K V :=\n  Module.Free.of_basis (ofVectorSpace K V)", "start": [114, 1], "end": [115, 43], "kind": "commanddeclaration"}, {"full_name": "Basis.ofVectorSpace_apply_self", "code": "theorem ofVectorSpace_apply_self (x : ofVectorSpaceIndex K V) : ofVectorSpace K V x = x", "start": [118, 1], "end": [120, 29], "kind": "commanddeclaration"}, {"full_name": "Basis.coe_ofVectorSpace", "code": "@[simp]\ntheorem coe_ofVectorSpace : \u21d1(ofVectorSpace K V) = ((\u2191) : _ \u2192 _ )", "start": [123, 1], "end": [125, 49], "kind": "commanddeclaration"}, {"full_name": "Basis.ofVectorSpaceIndex.linearIndependent", "code": "theorem ofVectorSpaceIndex.linearIndependent :\n    LinearIndependent K ((\u2191) : ofVectorSpaceIndex K V \u2192 V)", "start": [128, 1], "end": [132, 32], "kind": "commanddeclaration"}, {"full_name": "Basis.range_ofVectorSpace", "code": "theorem range_ofVectorSpace : range (ofVectorSpace K V) = ofVectorSpaceIndex K V", "start": [135, 1], "end": [136, 17], "kind": "commanddeclaration"}, {"full_name": "Basis.exists_basis", "code": "theorem exists_basis : \u2203 s : Set V, Nonempty (Basis s K V)", "start": [139, 1], "end": [140, 48], "kind": "commanddeclaration"}, {"full_name": "VectorSpace.card_fintype", "code": "theorem VectorSpace.card_fintype [Fintype K] [Fintype V] : \u2203 n : \u2115, card V = card K ^ n", "start": [153, 1], "end": [155, 93], "kind": "commanddeclaration"}, {"full_name": "nonzero_span_atom", "code": "theorem nonzero_span_atom (v : V) (hv : v \u2260 0) : IsAtom (span K {v} : Submodule K V)", "start": [162, 1], "end": [177, 35], "kind": "commanddeclaration"}, {"full_name": "atom_iff_nonzero_span", "code": "theorem atom_iff_nonzero_span (W : Submodule K V) :\n    IsAtom W \u2194 \u2203 (v : V) (_ : v \u2260 0), W = span K {v}", "start": [180, 1], "end": [193, 33], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_leftInverse_of_injective", "code": "theorem LinearMap.exists_leftInverse_of_injective (f : V \u2192\u2097[K] V') (hf_inj : LinearMap.ker f = \u22a5) :\n    \u2203 g : V' \u2192\u2097[K] V, g.comp f = LinearMap.id", "start": [207, 1], "end": [227, 61], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_isCompl", "code": "theorem Submodule.exists_isCompl (p : Submodule K V) : \u2203 q : Submodule K V, IsCompl p q", "start": [230, 1], "end": [232, 73], "kind": "commanddeclaration"}, {"full_name": "Module.Submodule.complementedLattice", "code": "instance Module.Submodule.complementedLattice : ComplementedLattice (Submodule K V) :=\n  \u27e8Submodule.exists_isCompl\u27e9", "start": [235, 1], "end": [236, 29], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_rightInverse_of_surjective", "code": "theorem LinearMap.exists_rightInverse_of_surjective (f : V \u2192\u2097[K] V') (hf_surj : range f = \u22a4) :\n    \u2203 g : V' \u2192\u2097[K] V, f.comp g = LinearMap.id", "start": [239, 1], "end": [246, 66], "kind": "commanddeclaration"}, {"full_name": "LinearMap.exists_extend", "code": "theorem LinearMap.exists_extend {p : Submodule K V} (f : p \u2192\u2097[K] V') :\n    \u2203 g : V \u2192\u2097[K] V', g.comp p.subtype = f", "start": [249, 1], "end": [254, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.exists_le_ker_of_lt_top", "code": "theorem Submodule.exists_le_ker_of_lt_top (p : Submodule K V) (hp : p < \u22a4) :\n    \u2203 (f : V \u2192\u2097[K] K), f \u2260 0 \u2227 p \u2264 ker f", "start": [259, 1], "end": [272, 54], "kind": "commanddeclaration"}, {"full_name": "quotient_prod_linearEquiv", "code": "theorem quotient_prod_linearEquiv (p : Submodule K V) : Nonempty (((V \u29f8 p) \u00d7 p) \u2243\u2097[K] V)", "start": [275, 1], "end": [279, 39], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/Isomorphisms.lean", "imports": ["Mathlib/LinearAlgebra/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "LinearMap.quotKerEquivRange", "code": "noncomputable def quotKerEquivRange : (M \u29f8 LinearMap.ker f) \u2243\u2097[R] LinearMap.range f :=\n  (LinearEquiv.ofInjective (f.ker.liftQ f <| le_rfl) <|\n        ker_eq_bot.mp <| Submodule.ker_liftQ_eq_bot _ _ _ (le_refl (LinearMap.ker f))).trans\n    (LinearEquiv.ofEq _ _ <| Submodule.range_liftQ _ _ _)", "start": [37, 1], "end": [42, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotKerEquivOfSurjective", "code": "noncomputable def quotKerEquivOfSurjective (f : M \u2192\u2097[R] M\u2082) (hf : Function.Surjective f) :\n    (M \u29f8 LinearMap.ker f) \u2243\u2097[R] M\u2082 :=\n  f.quotKerEquivRange.trans (LinearEquiv.ofTop (LinearMap.range f) (LinearMap.range_eq_top.2 hf))", "start": [45, 1], "end": [48, 98], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotKerEquivRange_apply_mk", "code": "@[simp]\ntheorem quotKerEquivRange_apply_mk (x : M) :\n    (f.quotKerEquivRange (Submodule.Quotient.mk x) : M\u2082) = f x", "start": [51, 1], "end": [54, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotKerEquivRange_symm_apply_image", "code": "@[simp]\ntheorem quotKerEquivRange_symm_apply_image (x : M) (h : f x \u2208 LinearMap.range f) :\n    f.quotKerEquivRange.symm \u27e8f x, h\u27e9 = f.ker.mkQ x", "start": [57, 1], "end": [60, 53], "kind": "commanddeclaration"}, {"full_name": "LinearMap.subToSupQuotient", "code": "@[reducible]\ndef subToSupQuotient (p p' : Submodule R M) :\n    { x // x \u2208 p } \u2192\u2097[R] { x // x \u2208 p \u2294 p' } \u29f8 comap (Submodule.subtype (p \u2294 p')) p' :=\n  (comap (p \u2294 p').subtype p').mkQ.comp (Submodule.ofLe le_sup_left)", "start": [64, 1], "end": [68, 68], "kind": "commanddeclaration"}, {"full_name": "LinearMap.comap_leq_ker_subToSupQuotient", "code": "theorem comap_leq_ker_subToSupQuotient (p p' : Submodule R M) :\n    comap (Submodule.subtype p) (p \u2293 p') \u2264 ker (subToSupQuotient p p')", "start": [71, 1], "end": [74, 52], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfToSupQuotient", "code": "def quotientInfToSupQuotient (p p' : Submodule R M) :\n    (\u21a5p) \u29f8 (comap p.subtype (p \u2293 p')) \u2192\u2097[R] (\u21a5(p \u2294 p')) \u29f8 (comap (p \u2294 p').subtype p') :=\n   (comap p.subtype (p \u2293 p')).liftQ (subToSupQuotient p p') (comap_leq_ker_subToSupQuotient p p')", "start": [76, 1], "end": [81, 98], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_injective", "code": "theorem quotientInfEquivSupQuotient_injective (p p' : Submodule R M) :\n    Function.Injective (quotientInfToSupQuotient p p')", "start": [85, 1], "end": [89, 39], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_surjective", "code": "theorem quotientInfEquivSupQuotient_surjective (p p' : Submodule R M) :\n    Function.Surjective (quotientInfToSupQuotient p p')", "start": [92, 1], "end": [97, 89], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient", "code": "noncomputable def quotientInfEquivSupQuotient (p p' : Submodule R M) :\n    (p \u29f8 comap p.subtype (p \u2293 p')) \u2243\u2097[R] _ \u29f8 comap (p \u2294 p').subtype p' :=\n  LinearEquiv.ofBijective (quotientInfToSupQuotient p p')\n    \u27e8quotientInfEquivSupQuotient_injective p p', quotientInfEquivSupQuotient_surjective p p'\u27e9", "start": [99, 1], "end": [105, 94], "kind": "commanddeclaration"}, {"full_name": "LinearMap.coe_quotientInfToSupQuotient", "code": "theorem coe_quotientInfToSupQuotient (p p' : Submodule R M) :\n    \u21d1(quotientInfToSupQuotient p p') = quotientInfEquivSupQuotient p p'", "start": [111, 1], "end": [113, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_apply_mk", "code": "@[simp, nolint simpNF]\ntheorem quotientInfEquivSupQuotient_apply_mk (p p' : Submodule R M) (x : p) :\n    let map := ofLe (le_sup_left : p \u2264 p \u2294 p')\n    quotientInfEquivSupQuotient p p' (Submodule.Quotient.mk x) =\n      @Submodule.Quotient.mk R (p \u2294 p' : Submodule R M) _ _ _ (comap (p \u2294 p').subtype p') (map x)", "start": [117, 1], "end": [122, 6], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_symm_apply_left", "code": "theorem quotientInfEquivSupQuotient_symm_apply_left (p p' : Submodule R M) (x : \u21a5(p \u2294 p'))\n    (hx : (x : M) \u2208 p) :\n    (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x) =\n      Submodule.Quotient.mk \u27e8x, hx\u27e9", "start": [125, 1], "end": [131, 58], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_symm_apply_eq_zero_iff", "code": "theorem quotientInfEquivSupQuotient_symm_apply_eq_zero_iff {p p' : Submodule R M} {x : \u21a5(p \u2294 p')} :\n    (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x) = 0 \u2194 (x : M) \u2208 p'", "start": [136, 1], "end": [140, 79], "kind": "commanddeclaration"}, {"full_name": "LinearMap.quotientInfEquivSupQuotient_symm_apply_right", "code": "theorem quotientInfEquivSupQuotient_symm_apply_right (p p' : Submodule R M) {x : \u21a5(p \u2294 p')}\n    (hx : (x : M) \u2208 p') : (quotientInfEquivSupQuotient p p').symm (Submodule.Quotient.mk x)\n    = 0", "start": [143, 1], "end": [146, 58], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientQuotientEquivQuotientAux", "code": "def quotientQuotientEquivQuotientAux (h : S \u2264 T) : (M \u29f8 S) \u29f8 T.map S.mkQ \u2192\u2097[R] M \u29f8 T :=\n  liftQ _ (mapQ S T LinearMap.id h)\n    (by\n      rintro _ \u27e8x, hx, rfl\u27e9\n      rw [LinearMap.mem_ker, mkQ_apply, mapQ_apply]\n      exact (Quotient.mk_eq_zero _).mpr hx)", "start": [159, 1], "end": [165, 44], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientQuotientEquivQuotientAux_mk", "code": "@[simp]\ntheorem quotientQuotientEquivQuotientAux_mk (x : M \u29f8 S) :\n    quotientQuotientEquivQuotientAux S T h (Quotient.mk x) = mapQ S T LinearMap.id h x", "start": [168, 1], "end": [171, 20], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientQuotientEquivQuotientAux_mk_mk", "code": "theorem quotientQuotientEquivQuotientAux_mk_mk (x : M) :\n    quotientQuotientEquivQuotientAux S T h (Quotient.mk (Quotient.mk x)) = Quotient.mk x", "start": [175, 1], "end": [176, 100], "kind": "commanddeclaration"}, {"full_name": "Submodule.quotientQuotientEquivQuotient", "code": "def quotientQuotientEquivQuotient : ((M \u29f8 S) \u29f8 T.map S.mkQ) \u2243\u2097[R] M \u29f8 T :=\n  { quotientQuotientEquivQuotientAux S T h with\n    toFun := quotientQuotientEquivQuotientAux S T h\n    invFun := mapQ _ _ (mkQ S) (le_comap_map _ _)\n    left_inv := fun x => Quotient.inductionOn' x fun x => Quotient.inductionOn' x fun x => by simp\n    right_inv := fun x => Quotient.inductionOn' x fun x => by simp }", "start": [179, 1], "end": [185, 69], "kind": "commanddeclaration"}, {"full_name": "Submodule.card_quotient_mul_card_quotient", "code": "theorem card_quotient_mul_card_quotient (S T : Submodule R M) (hST : T \u2264 S)\n    [DecidablePred fun x => x \u2208 S.map T.mkQ] [Fintype (M \u29f8 S)] [Fintype (M \u29f8 T)] :\n    Fintype.card (S.map T.mkQ) * Fintype.card (M \u29f8 S) = Fintype.card (M \u29f8 T)", "start": [188, 1], "end": [193, 75], "kind": "commanddeclaration"}]}
{"path": "Mathlib/LinearAlgebra/InvariantBasisNumber.lean", "imports": ["Mathlib/RingTheory/PrincipalIdealDomain.lean", "Mathlib/RingTheory/Ideal/Quotient.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "StrongRankCondition", "code": "@[mk_iff]\nclass StrongRankCondition : Prop where\n  \n  le_of_fin_injective : \u2200 {n m : \u2115} (f : (Fin n \u2192 R) \u2192\u2097[R] Fin m \u2192 R), Injective f \u2192 n \u2264 m", "start": [79, 1], "end": [84, 91], "kind": "commanddeclaration"}, {"full_name": "le_of_fin_injective", "code": "theorem le_of_fin_injective [StrongRankCondition R] {n m : \u2115} (f : (Fin n \u2192 R) \u2192\u2097[R] Fin m \u2192 R) :\n    Injective f \u2192 n \u2264 m", "start": [87, 1], "end": [89, 44], "kind": "commanddeclaration"}, {"full_name": "strongRankCondition_iff_succ", "code": "theorem strongRankCondition_iff_succ :\n    StrongRankCondition R \u2194\n      \u2200 (n : \u2115) (f : (Fin (n + 1) \u2192 R) \u2192\u2097[R] Fin n \u2192 R), \u00acFunction.Injective f", "start": [92, 1], "end": [103, 84], "kind": "commanddeclaration"}, {"full_name": "card_le_of_injective", "code": "theorem card_le_of_injective [StrongRankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R) (i : Injective f) : Fintype.card \u03b1 \u2264 Fintype.card \u03b2", "start": [106, 1], "end": [112, 79], "kind": "commanddeclaration"}, {"full_name": "card_le_of_injective'", "code": "theorem card_le_of_injective' [StrongRankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192\u2080 R) \u2192\u2097[R] \u03b2 \u2192\u2080 R) (i : Injective f) : Fintype.card \u03b1 \u2264 Fintype.card \u03b2", "start": [115, 1], "end": [121, 46], "kind": "commanddeclaration"}, {"full_name": "RankCondition", "code": "class RankCondition : Prop where\n  \n  le_of_fin_surjective : \u2200 {n m : \u2115} (f : (Fin n \u2192 R) \u2192\u2097[R] Fin m \u2192 R), Surjective f \u2192 m \u2264 n", "start": [124, 1], "end": [128, 93], "kind": "commanddeclaration"}, {"full_name": "le_of_fin_surjective", "code": "theorem le_of_fin_surjective [RankCondition R] {n m : \u2115} (f : (Fin n \u2192 R) \u2192\u2097[R] Fin m \u2192 R) :\n    Surjective f \u2192 m \u2264 n", "start": [131, 1], "end": [133, 39], "kind": "commanddeclaration"}, {"full_name": "card_le_of_surjective", "code": "theorem card_le_of_surjective [RankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192 R) \u2192\u2097[R] \u03b2 \u2192 R) (i : Surjective f) : Fintype.card \u03b2 \u2264 Fintype.card \u03b1", "start": [136, 1], "end": [142, 81], "kind": "commanddeclaration"}, {"full_name": "card_le_of_surjective'", "code": "theorem card_le_of_surjective' [RankCondition R] {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2]\n    (f : (\u03b1 \u2192\u2080 R) \u2192\u2097[R] \u03b2 \u2192\u2080 R) (i : Surjective f) : Fintype.card \u03b2 \u2264 Fintype.card \u03b1", "start": [145, 1], "end": [151, 48], "kind": "commanddeclaration"}, {"full_name": "rankCondition_of_strongRankCondition", "code": "instance (priority := 100) rankCondition_of_strongRankCondition [StrongRankCondition R] :\n    RankCondition R where\n  le_of_fin_surjective f s :=\n    le_of_fin_injective R _ (f.splittingOfFunOnFintypeSurjective_injective s)", "start": [154, 1], "end": [161, 78], "kind": "commanddeclaration"}, {"full_name": "InvariantBasisNumber", "code": "class InvariantBasisNumber : Prop where\n  \n  eq_of_fin_equiv : \u2200 {n m : \u2115}, ((Fin n \u2192 R) \u2243\u2097[R] Fin m \u2192 R) \u2192 n = m", "start": [164, 1], "end": [169, 71], "kind": "commanddeclaration"}, {"full_name": "invariantBasisNumber_of_rankCondition", "code": "instance (priority := 100) invariantBasisNumber_of_rankCondition [RankCondition R] :\n    InvariantBasisNumber R where\n  eq_of_fin_equiv e := le_antisymm (le_of_fin_surjective R e.symm.toLinearMap e.symm.surjective)\n    (le_of_fin_surjective R e.toLinearMap e.surjective)", "start": [172, 1], "end": [175, 56], "kind": "commanddeclaration"}, {"full_name": "eq_of_fin_equiv", "code": "theorem eq_of_fin_equiv {n m : \u2115} : ((Fin n \u2192 R) \u2243\u2097[R] Fin m \u2192 R) \u2192 n = m", "start": [184, 1], "end": [185, 39], "kind": "commanddeclaration"}, {"full_name": "card_eq_of_linearEquiv", "code": "theorem card_eq_of_linearEquiv {\u03b1 \u03b2 : Type*} [Fintype \u03b1] [Fintype \u03b2] (f : (\u03b1 \u2192 R) \u2243\u2097[R] \u03b2 \u2192 R) :\n    Fintype.card \u03b1 = Fintype.card \u03b2", "start": [188, 1], "end": [192, 64], "kind": "commanddeclaration"}, {"full_name": "nontrivial_of_invariantBasisNumber", "code": "theorem nontrivial_of_invariantBasisNumber : Nontrivial R", "start": [197, 1], "end": [209, 38], "kind": "commanddeclaration"}, {"full_name": "IsNoetherianRing.strongRankCondition", "code": "instance (priority := 100) IsNoetherianRing.strongRankCondition : StrongRankCondition R := by\n  constructor\n  intro m n f i\n  by_contra h\n  rw [not_le, \u2190 Nat.add_one_le_iff, le_iff_exists_add] at h\n  obtain \u27e8m, rfl\u27e9 := h\n  let e : Fin (n + 1 + m) \u2243 Sum (Fin n) (Fin (1 + m)) :=\n    (finCongr (add_assoc _ _ _)).trans finSumFinEquiv.symm\n  let f' :=\n    f.comp\n      ((LinearEquiv.sumArrowLequivProdArrow _ _ R R).symm.trans\n          (LinearEquiv.funCongrLeft R R e)).toLinearMap\n  have i' : Injective f' := i.comp (LinearEquiv.injective _)\n  apply @zero_ne_one (Fin (1 + m) \u2192 R) _ _\n  apply (IsNoetherian.equivPUnitOfProdInjective f' i').injective\n  ext", "start": [220, 1], "end": [241, 6], "kind": "commanddeclaration"}, {"full_name": "induced_map", "code": "private def induced_map (I : Ideal R) (e : (\u03b9 \u2192 R) \u2192\u2097[R] \u03b9' \u2192 R) :\n    (\u03b9 \u2192 R) \u29f8 I.pi \u03b9 \u2192 (\u03b9' \u2192 R) \u29f8 I.pi \u03b9' := fun x =>\n  Quotient.liftOn' x (fun y => Ideal.Quotient.mk (I.pi \u03b9') (e y))\n    (by\n      refine' fun a b hab => Ideal.Quotient.eq.2 fun h => _\n      rw [Submodule.quotientRel_r_def] at hab\n      rw [\u2190 LinearMap.map_sub]\n      exact Ideal.map_pi _ _ hab e h)", "start": [265, 1], "end": [273, 38], "kind": "commanddeclaration"}, {"full_name": "induced_equiv", "code": "private def induced_equiv [Fintype \u03b9'] (I : Ideal R) (e : (\u03b9 \u2192 R) \u2243\u2097[R] \u03b9' \u2192 R) :\n    ((\u03b9 \u2192 R) \u29f8 I.pi \u03b9) \u2243\u2097[R \u29f8 I] (\u03b9' \u2192 R) \u29f8 I.pi \u03b9' := by\n  refine'\n    { toFun := induced_map I e\n      invFun := induced_map I e.symm.. }\n  all_goals\n    first |rintro \u27e8a\u27e9 \u27e8b\u27e9|rintro \u27e8a\u27e9\n  pick_goal 3\n  convert_to Ideal.Quotient.mk (I.pi \u03b9) _ = Ideal.Quotient.mk (I.pi \u03b9) _\n  congr\n  simp only [LinearEquiv.coe_coe, LinearEquiv.symm_apply_apply]\n  all_goals\n    convert_to Ideal.Quotient.mk (I.pi \u03b9') _ = Ideal.Quotient.mk (I.pi \u03b9') _\n    congr\n    simp only [map_add, LinearEquiv.coe_coe, LinearEquiv.map_smul\u209b\u2097, RingHom.id_apply,\n      LinearEquiv.apply_symm_apply]", "start": [277, 1], "end": [296, 36], "kind": "commanddeclaration"}, {"full_name": "invariantBasisNumber_of_nontrivial_of_commRing", "code": "instance (priority := 100) invariantBasisNumber_of_nontrivial_of_commRing {R : Type u} [CommRing R]\n    [Nontrivial R] : InvariantBasisNumber R :=\n  \u27e8fun e =>\n    let \u27e8I, _hI\u27e9 := Ideal.exists_maximal R\n    eq_of_fin_equiv (R \u29f8 I)\n      ((Ideal.piQuotEquiv _ _).symm \u226a\u226b\u2097 (induced_equiv _ e \u226a\u226b\u2097 Ideal.piQuotEquiv _ _))\u27e9", "start": [306, 1], "end": [316, 88], "kind": "commanddeclaration"}]}
{"path": "Mathlib/SetTheory/Cardinal/Cofinality.lean", "imports": ["Mathlib/SetTheory/Cardinal/Ordinal.lean", "Mathlib/SetTheory/Ordinal/FixedPoint.lean", "lake-packages/lean4/src/lean/Init.lean"], "premises": [{"full_name": "Order.cof", "code": "def cof (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Cardinal :=\n  sInf { c | \u2203 S : Set \u03b1, (\u2200 a, \u2203 b \u2208 S, r a b) \u2227 #S = c }", "start": [63, 1], "end": [66, 59], "kind": "commanddeclaration"}, {"full_name": "Order.cof_nonempty", "code": "theorem cof_nonempty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsRefl \u03b1 r] :\n    { c | \u2203 S : Set \u03b1, (\u2200 a, \u2203 b \u2208 S, r a b) \u2227 #S = c }.Nonempty", "start": [69, 1], "end": [72, 47], "kind": "commanddeclaration"}, {"full_name": "Order.cof_le", "code": "theorem cof_le (r : \u03b1 \u2192 \u03b1 \u2192 Prop) {S : Set \u03b1} (h : \u2200 a, \u2203 b \u2208 S, r a b) : cof r \u2264 #S", "start": [75, 1], "end": [76, 24], "kind": "commanddeclaration"}, {"full_name": "Order.le_cof", "code": "theorem le_cof {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [IsRefl \u03b1 r] (c : Cardinal) :\n    c \u2264 cof r \u2194 \u2200 {S : Set \u03b1}, (\u2200 a, \u2203 b \u2208 S, r a b) \u2192 c \u2264 #S", "start": [79, 1], "end": [84, 12], "kind": "commanddeclaration"}, {"full_name": "RelIso.cof_le_lift", "code": "theorem RelIso.cof_le_lift {\u03b1 : Type u} {\u03b2 : Type v} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s} [IsRefl \u03b2 s]\n    (f : r \u2243r s) : Cardinal.lift.{max u v} (Order.cof r) \u2264\n    Cardinal.lift.{max u v} (Order.cof s)", "start": [89, 1], "end": [101, 32], "kind": "commanddeclaration"}, {"full_name": "RelIso.cof_eq_lift", "code": "theorem RelIso.cof_eq_lift {\u03b1 : Type u} {\u03b2 : Type v} {r s} [IsRefl \u03b1 r] [IsRefl \u03b2 s] (f : r \u2243r s) :\n    Cardinal.lift.{max u v} (Order.cof r) = Cardinal.lift.{max u v} (Order.cof s)", "start": [104, 1], "end": [106, 62], "kind": "commanddeclaration"}, {"full_name": "RelIso.cof_le", "code": "theorem RelIso.cof_le {\u03b1 \u03b2 : Type u} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} {s} [IsRefl \u03b2 s] (f : r \u2243r s) :\n    Order.cof r \u2264 Order.cof s", "start": [109, 1], "end": [111, 35], "kind": "commanddeclaration"}, {"full_name": "RelIso.cof_eq", "code": "theorem RelIso.cof_eq {\u03b1 \u03b2 : Type u} {r s} [IsRefl \u03b1 r] [IsRefl \u03b2 s] (f : r \u2243r s) :\n    Order.cof r = Order.cof s", "start": [114, 1], "end": [116, 36], "kind": "commanddeclaration"}, {"full_name": "StrictOrder.cof", "code": "def StrictOrder.cof (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : Cardinal :=\n  Order.cof (swap r\u1d9c)", "start": [119, 1], "end": [122, 22], "kind": "commanddeclaration"}, {"full_name": "StrictOrder.cof_nonempty", "code": "theorem StrictOrder.cof_nonempty (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsIrrefl \u03b1 r] :\n    { c | \u2203 S : Set \u03b1, Unbounded r S \u2227 #S = c }.Nonempty", "start": [125, 1], "end": [128, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof", "code": "def cof (o : Ordinal.{u}) : Cardinal.{u} :=\n  o.liftOn (fun a => StrictOrder.cof a.r)\n    (by\n      rintro \u27e8\u03b1, r, wo\u2081\u27e9 \u27e8\u03b2, s, wo\u2082\u27e9 \u27e8\u27e8f, hf\u27e9\u27e9\n      haveI := wo\u2081; haveI := wo\u2082\n      dsimp only\n      apply @RelIso.cof_eq _ _ _ _ ?_ ?_\n      \u00b7 constructor\n        exact @fun a b => not_iff_not.2 hf\n      \u00b7 dsimp only [swap]\n        exact \u27e8fun _ => irrefl _\u27e9\n      \u00b7 dsimp only [swap]\n        exact \u27e8fun _ => irrefl _\u27e9)", "start": [136, 1], "end": [153, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_type", "code": "theorem cof_type (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : (type r).cof = StrictOrder.cof r", "start": [156, 1], "end": [157, 6], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_cof_type", "code": "theorem le_cof_type [IsWellOrder \u03b1 r] {c} : c \u2264 cof (type r) \u2194 \u2200 S, Unbounded r S \u2192 c \u2264 #S", "start": [160, 1], "end": [164, 19], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_type_le", "code": "theorem cof_type_le [IsWellOrder \u03b1 r] {S : Set \u03b1} (h : Unbounded r S) : cof (type r) \u2264 #S", "start": [167, 1], "end": [168, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lt_cof_type", "code": "theorem lt_cof_type [IsWellOrder \u03b1 r] {S : Set \u03b1} : #S < cof (type r) \u2192 Bounded r S", "start": [171, 1], "end": [172, 40], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_eq", "code": "theorem cof_eq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] : \u2203 S, Unbounded r S \u2227 #S = cof (type r)", "start": [175, 1], "end": [176, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ord_cof_eq", "code": "theorem ord_cof_eq (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] :\n    \u2203 S, Unbounded r S \u2227 type (Subrel r S) = (cof (type r)).ord", "start": [179, 1], "end": [212, 79], "kind": "commanddeclaration"}, {"full_name": "Ordinal.card_mem_cof", "code": "private theorem card_mem_cof {o} : \u2203 (\u03b9 : _) (f : \u03b9 \u2192 Ordinal), lsub.{u, u} f = o \u2227 #\u03b9 = o.card", "start": [218, 1], "end": [219, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_lsub_def_nonempty", "code": "theorem cof_lsub_def_nonempty (o) :\n    { a : Cardinal | \u2203 (\u03b9 : _) (f : \u03b9 \u2192 Ordinal), lsub.{u, u} f = o \u2227 #\u03b9 = a }.Nonempty", "start": [221, 1], "end": [224, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_eq_sInf_lsub", "code": "theorem cof_eq_sInf_lsub (o : Ordinal.{u}) : cof o =\n    sInf { a : Cardinal | \u2203 (\u03b9 : Type u) (f : \u03b9 \u2192 Ordinal), lsub.{u, u} f = o \u2227 #\u03b9 = a }", "start": [227, 1], "end": [258, 50], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lift_cof", "code": "@[simp]\ntheorem lift_cof (o) : Cardinal.lift.{u, v} (cof o) = cof (Ordinal.lift.{u, v} o)", "start": [261, 1], "end": [282, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_le_card", "code": "theorem cof_le_card (o) : cof o \u2264 card o", "start": [285, 1], "end": [287, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_ord_le", "code": "theorem cof_ord_le (c : Cardinal) : c.ord.cof \u2264 c", "start": [290, 1], "end": [290, 86], "kind": "commanddeclaration"}, {"full_name": "Ordinal.ord_cof_le", "code": "theorem ord_cof_le (o : Ordinal.{u}) : o.cof.ord \u2264 o", "start": [293, 1], "end": [294, 55], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_lsub_cof", "code": "theorem exists_lsub_cof (o : Ordinal) :\n    \u2203 (\u03b9 : _) (f : \u03b9 \u2192 Ordinal), lsub.{u, u} f = o \u2227 #\u03b9 = cof o", "start": [297, 1], "end": [300, 44], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_lsub_le", "code": "theorem cof_lsub_le {\u03b9} (f : \u03b9 \u2192 Ordinal) : cof (lsub.{u, u} f) \u2264 #\u03b9", "start": [303, 1], "end": [305, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_lsub_le_lift", "code": "theorem cof_lsub_le_lift {\u03b9} (f : \u03b9 \u2192 Ordinal) :\n    cof (lsub.{u, v} f) \u2264 Cardinal.lift.{v, u} #\u03b9", "start": [308, 1], "end": [314, 90], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_cof_iff_lsub", "code": "theorem le_cof_iff_lsub {o : Ordinal} {a : Cardinal} :\n    a \u2264 cof o \u2194 \u2200 {\u03b9} (f : \u03b9 \u2192 Ordinal), lsub.{u, u} f = o \u2192 a \u2264 #\u03b9", "start": [317, 1], "end": [324, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_lt_ord_lift", "code": "theorem lsub_lt_ord_lift {\u03b9} {f : \u03b9 \u2192 Ordinal} {c : Ordinal}\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c.cof)\n    (hf : \u2200 i, f i < c) : lsub.{u, v} f < c", "start": [327, 1], "end": [332, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.lsub_lt_ord", "code": "theorem lsub_lt_ord {\u03b9} {f : \u03b9 \u2192 Ordinal} {c : Ordinal} (h\u03b9 : #\u03b9 < c.cof) :\n    (\u2200 i, f i < c) \u2192 lsub.{u, u} f < c", "start": [335, 1], "end": [337, 43], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_sup_le_lift", "code": "theorem cof_sup_le_lift {\u03b9} {f : \u03b9 \u2192 Ordinal} (H : \u2200 i, f i < sup.{u, v} f) :\n    cof (sup.{u, v} f) \u2264 Cardinal.lift.{v, u} #\u03b9", "start": [340, 1], "end": [344, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_sup_le", "code": "theorem cof_sup_le {\u03b9} {f : \u03b9 \u2192 Ordinal} (H : \u2200 i, f i < sup.{u, u} f) :\n    cof (sup.{u, u} f) \u2264 #\u03b9", "start": [347, 1], "end": [350, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_lt_ord_lift", "code": "theorem sup_lt_ord_lift {\u03b9} {f : \u03b9 \u2192 Ordinal} {c : Ordinal} (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c.cof)\n    (hf : \u2200 i, f i < c) : sup.{u, v} f < c", "start": [353, 1], "end": [355, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_lt_ord", "code": "theorem sup_lt_ord {\u03b9} {f : \u03b9 \u2192 Ordinal} {c : Ordinal} (h\u03b9 : #\u03b9 < c.cof) :\n    (\u2200 i, f i < c) \u2192 sup.{u, u} f < c", "start": [358, 1], "end": [360, 42], "kind": "commanddeclaration"}, {"full_name": "Ordinal.iSup_lt_lift", "code": "theorem iSup_lt_lift {\u03b9} {f : \u03b9 \u2192 Cardinal} {c : Cardinal}\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c.ord.cof)\n    (hf : \u2200 i, f i < c) : iSup.{max u v + 1, u + 1} f < c", "start": [363, 1], "end": [369, 11], "kind": "commanddeclaration"}, {"full_name": "Ordinal.iSup_lt", "code": "theorem iSup_lt {\u03b9} {f : \u03b9 \u2192 Cardinal} {c : Cardinal} (h\u03b9 : #\u03b9 < c.ord.cof) :\n    (\u2200 i, f i < c) \u2192 iSup f < c", "start": [372, 1], "end": [374, 39], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_lt_ord_lift", "code": "theorem nfpFamily_lt_ord_lift {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : \u2135\u2080 < cof c)\n    (hc' : Cardinal.lift.{v, u} #\u03b9 < cof c) (hf : \u2200 (i), \u2200 b < c, f i b < c) {a} (ha : a < c) :\n    nfpFamily.{u, v} f a < c", "start": [377, 1], "end": [386, 21], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpFamily_lt_ord", "code": "theorem nfpFamily_lt_ord {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : \u2135\u2080 < cof c) (hc' : #\u03b9 < cof c)\n    (hf : \u2200 (i), \u2200 b < c, f i b < c) {a} : a < c \u2192 nfpFamily.{u, u} f a < c", "start": [389, 1], "end": [391, 54], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_lt_ord_lift", "code": "theorem nfpBFamily_lt_ord_lift {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c} (hc : \u2135\u2080 < cof c)\n    (hc' : Cardinal.lift.{v, u} o.card < cof c) (hf : \u2200 (i hi), \u2200 b < c, f i hi b < c) {a} :\n    a < c \u2192 nfpBFamily.{u, v} o f a < c", "start": [394, 1], "end": [397, 69], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfpBFamily_lt_ord", "code": "theorem nfpBFamily_lt_ord {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c} (hc : \u2135\u2080 < cof c)\n    (hc' : o.card < cof c) (hf : \u2200 (i hi), \u2200 b < c, f i hi b < c) {a} :\n    a < c \u2192 nfpBFamily.{u, u} o f a < c", "start": [400, 1], "end": [403, 57], "kind": "commanddeclaration"}, {"full_name": "Ordinal.nfp_lt_ord", "code": "theorem nfp_lt_ord {f : Ordinal \u2192 Ordinal} {c} (hc : \u2135\u2080 < cof c) (hf : \u2200 i < c, f i < c) {a} :\n    a < c \u2192 nfp f a < c", "start": [406, 1], "end": [408, 88], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_blsub_cof", "code": "theorem exists_blsub_cof (o : Ordinal) :\n    \u2203 f : \u2200 a < (cof o).ord, Ordinal, blsub.{u, u} _ f = o", "start": [411, 1], "end": [417, 16], "kind": "commanddeclaration"}, {"full_name": "Ordinal.le_cof_iff_blsub", "code": "theorem le_cof_iff_blsub {b : Ordinal} {a : Cardinal} :\n    a \u2264 cof b \u2194 \u2200 {o} (f : \u2200 a < o, Ordinal), blsub.{u, u} o f = b \u2192 a \u2264 o.card", "start": [420, 1], "end": [426, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_blsub_le_lift", "code": "theorem cof_blsub_le_lift {o} (f : \u2200 a < o, Ordinal) :\n    cof (blsub.{u, v} o f) \u2264 Cardinal.lift.{v, u} o.card", "start": [429, 1], "end": [432, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_blsub_le", "code": "theorem cof_blsub_le {o} (f : \u2200 a < o, Ordinal) : cof (blsub.{u, u} o f) \u2264 o.card", "start": [435, 1], "end": [437, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_lt_ord_lift", "code": "theorem blsub_lt_ord_lift {o : Ordinal.{u}} {f : \u2200 a < o, Ordinal} {c : Ordinal}\n    (ho : Cardinal.lift.{v, u} o.card < c.cof) (hf : \u2200 i hi, f i hi < c) : blsub.{u, v} o f < c", "start": [440, 1], "end": [443, 78], "kind": "commanddeclaration"}, {"full_name": "Ordinal.blsub_lt_ord", "code": "theorem blsub_lt_ord {o : Ordinal} {f : \u2200 a < o, Ordinal} {c : Ordinal} (ho : o.card < c.cof)\n    (hf : \u2200 i hi, f i hi < c) : blsub.{u, u} o f < c", "start": [446, 1], "end": [448, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_bsup_le_lift", "code": "theorem cof_bsup_le_lift {o : Ordinal} {f : \u2200 a < o, Ordinal} (H : \u2200 i h, f i h < bsup.{u, v} o f) :\n    cof (bsup.{u, v} o f) \u2264 Cardinal.lift.{v, u} o.card", "start": [451, 1], "end": [455, 35], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_bsup_le", "code": "theorem cof_bsup_le {o : Ordinal} {f : \u2200 a < o, Ordinal} :\n    (\u2200 i h, f i h < bsup.{u, u} o f) \u2192 cof (bsup.{u, u} o f) \u2264 o.card", "start": [458, 1], "end": [461, 25], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_lt_ord_lift", "code": "theorem bsup_lt_ord_lift {o : Ordinal} {f : \u2200 a < o, Ordinal} {c : Ordinal}\n    (ho : Cardinal.lift.{v, u} o.card < c.cof) (hf : \u2200 i hi, f i hi < c) : bsup.{u, v} o f < c", "start": [464, 1], "end": [466, 55], "kind": "commanddeclaration"}, {"full_name": "Ordinal.bsup_lt_ord", "code": "theorem bsup_lt_ord {o : Ordinal} {f : \u2200 a < o, Ordinal} {c : Ordinal} (ho : o.card < c.cof) :\n    (\u2200 i hi, f i hi < c) \u2192 bsup.{u, u} o f < c", "start": [469, 1], "end": [471, 45], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_zero", "code": "@[simp]\ntheorem cof_zero : cof 0 = 0", "start": [477, 1], "end": [481, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_eq_zero", "code": "@[simp]\ntheorem cof_eq_zero {o} : cof o = 0 \u2194 o = 0", "start": [484, 1], "end": [492, 26], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_ne_zero", "code": "theorem cof_ne_zero {o} : cof o \u2260 0 \u2194 o \u2260 0", "start": [495, 1], "end": [496, 18], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_succ", "code": "@[simp]\ntheorem cof_succ (o) : cof (succ o) = 1", "start": [499, 1], "end": [512, 49], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_eq_one_iff_is_succ", "code": "@[simp]\ntheorem cof_eq_one_iff_is_succ {o} : cof.{u} o = 1 \u2194 \u2203 a, o = succ a", "start": [515, 1], "end": [542, 31], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence", "code": "def IsFundamentalSequence (a o : Ordinal.{u}) (f : \u2200 b < o, Ordinal.{u}) : Prop :=\n  o \u2264 a.cof.ord \u2227 (\u2200 {i j} (hi hj), i < j \u2192 f i hi < f j hj) \u2227 blsub.{u, u} o f = a", "start": [545, 1], "end": [548, 84], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.cof_eq", "code": "protected theorem cof_eq (hf : IsFundamentalSequence a o f) : a.cof.ord = o", "start": [555, 1], "end": [558, 64], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.strict_mono", "code": "protected theorem strict_mono (hf : IsFundamentalSequence a o f) {i j} :\n    \u2200 hi hj, i < j \u2192 f i hi < f j hj", "start": [561, 1], "end": [563, 9], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.blsub_eq", "code": "theorem blsub_eq (hf : IsFundamentalSequence a o f) : blsub.{u, u} o f = a", "start": [566, 1], "end": [567, 9], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.ord_cof", "code": "theorem ord_cof (hf : IsFundamentalSequence a o f) :\n    IsFundamentalSequence a a.cof.ord fun i hi => f i (hi.trans_le (by rw [hf.cof_eq]))", "start": [570, 1], "end": [574, 11], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.id_of_le_cof", "code": "theorem id_of_le_cof (h : o \u2264 o.cof.ord) : IsFundamentalSequence o o fun a _ => a", "start": [577, 1], "end": [578, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.zero", "code": "protected theorem zero {f : \u2200 b < (0 : Ordinal), Ordinal} : IsFundamentalSequence 0 0 f", "start": [581, 1], "end": [582, 93], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.succ", "code": "protected theorem succ : IsFundamentalSequence (succ o) 1 fun _ _ => o", "start": [585, 1], "end": [590, 23], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.monotone", "code": "protected theorem monotone (hf : IsFundamentalSequence a o f) {i j : Ordinal} (hi : i < o)\n    (hj : j < o) (hij : i \u2264 j) : f i hi \u2264 f j hj", "start": [593, 1], "end": [597, 8], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsFundamentalSequence.trans", "code": "theorem trans {a o o' : Ordinal.{u}} {f : \u2200 b < o, Ordinal.{u}} (hf : IsFundamentalSequence a o f)\n    {g : \u2200 b < o', Ordinal.{u}} (hg : IsFundamentalSequence o o' g) :\n    IsFundamentalSequence a o' fun i hi =>\n      f (g i hi) (by rw [\u2190 hg.2.2]; apply lt_blsub)", "start": [600, 1], "end": [609, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.exists_fundamental_sequence", "code": "theorem exists_fundamental_sequence (a : Ordinal.{u}) :\n    \u2203 f, IsFundamentalSequence a a.cof.ord f", "start": [614, 1], "end": [645, 38], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_cof", "code": "@[simp]\ntheorem cof_cof (a : Ordinal.{u}) : cof (cof a).ord = cof a", "start": [648, 1], "end": [652, 48], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.isFundamentalSequence", "code": "protected theorem IsNormal.isFundamentalSequence {f : Ordinal.{u} \u2192 Ordinal.{u}} (hf : IsNormal f)\n    {a o} (ha : IsLimit a) {g} (hg : IsFundamentalSequence a o g) :\n    IsFundamentalSequence (f a) o fun b hb => f (g b hb)", "start": [655, 1], "end": [680, 41], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.cof_eq", "code": "theorem IsNormal.cof_eq {f} (hf : IsNormal f) {a} (ha : IsLimit a) : cof (f a) = cof a", "start": [683, 1], "end": [685, 56], "kind": "commanddeclaration"}, {"full_name": "Ordinal.IsNormal.cof_le", "code": "theorem IsNormal.cof_le {f} (hf : IsNormal f) (a) : cof a \u2264 cof (f a)", "start": [688, 1], "end": [694, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_add", "code": "@[simp]\ntheorem cof_add (a b : Ordinal) : b \u2260 0 \u2192 cof (a + b) = cof b", "start": [697, 1], "end": [702, 37], "kind": "commanddeclaration"}, {"full_name": "Ordinal.aleph0_le_cof", "code": "theorem aleph0_le_cof {o} : \u2135\u2080 \u2264 cof o \u2194 IsLimit o", "start": [705, 1], "end": [720, 33], "kind": "commanddeclaration"}, {"full_name": "Ordinal.aleph'_cof", "code": "@[simp]\ntheorem aleph'_cof {o : Ordinal} (ho : o.IsLimit) : (aleph' o).ord.cof = o.cof", "start": [723, 1], "end": [725, 28], "kind": "commanddeclaration"}, {"full_name": "Ordinal.aleph_cof", "code": "@[simp]\ntheorem aleph_cof {o : Ordinal} (ho : o.IsLimit) : (aleph o).ord.cof = o.cof", "start": [728, 1], "end": [730, 27], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_omega", "code": "@[simp]\ntheorem cof_omega : cof \u03c9 = \u2135\u2080", "start": [733, 1], "end": [737, 22], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_eq'", "code": "theorem cof_eq' (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [IsWellOrder \u03b1 r] (h : IsLimit (type r)) :\n    \u2203 S : Set \u03b1, (\u2200 a, \u2203 b \u2208 S, r a b) \u2227 #S = cof (type r)", "start": [740, 1], "end": [753, 7], "kind": "commanddeclaration"}, {"full_name": "Ordinal.cof_univ", "code": "@[simp]\ntheorem cof_univ : cof univ.{u, v} = Cardinal.univ.{u, v}", "start": [756, 1], "end": [774, 20], "kind": "commanddeclaration"}, {"full_name": "Ordinal.unbounded_of_unbounded_sUnion", "code": "theorem unbounded_of_unbounded_sUnion (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [wo : IsWellOrder \u03b1 r] {s : Set (Set \u03b1)}\n    (h\u2081 : Unbounded r <| \u22c3\u2080 s) (h\u2082 : #s < StrictOrder.cof r) : \u2203 x \u2208 s, Unbounded r x", "start": [780, 1], "end": [789, 92], "kind": "commanddeclaration"}, {"full_name": "Ordinal.unbounded_of_unbounded_iUnion", "code": "theorem unbounded_of_unbounded_iUnion {\u03b1 \u03b2 : Type u} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) [wo : IsWellOrder \u03b1 r]\n    (s : \u03b2 \u2192 Set \u03b1) (h\u2081 : Unbounded r <| \u22c3 x, s x) (h\u2082 : #\u03b2 < StrictOrder.cof r) :\n    \u2203 x : \u03b2, Unbounded r (s x)", "start": [792, 1], "end": [799, 15], "kind": "commanddeclaration"}, {"full_name": "Ordinal.infinite_pigeonhole", "code": "theorem infinite_pigeonhole {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1) (h\u2081 : \u2135\u2080 \u2264 #\u03b2) (h\u2082 : #\u03b1 < (#\u03b2).ord.cof) :\n    \u2203 a : \u03b1, #(f \u207b\u00b9' {a}) = #\u03b2", "start": [802, 1], "end": [815, 17], "kind": "commanddeclaration"}, {"full_name": "Ordinal.infinite_pigeonhole_card", "code": "theorem infinite_pigeonhole_card {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1) (\u03b8 : Cardinal) (h\u03b8 : \u03b8 \u2264 #\u03b2)\n    (h\u2081 : \u2135\u2080 \u2264 \u03b8) (h\u2082 : #\u03b1 < \u03b8.ord.cof) : \u2203 a : \u03b1, \u03b8 \u2264 #(f \u207b\u00b9' {a})", "start": [818, 1], "end": [824, 59], "kind": "commanddeclaration"}, {"full_name": "Ordinal.infinite_pigeonhole_set", "code": "theorem infinite_pigeonhole_set {\u03b2 \u03b1 : Type u} {s : Set \u03b2} (f : s \u2192 \u03b1) (\u03b8 : Cardinal)\n    (h\u03b8 : \u03b8 \u2264 #s) (h\u2081 : \u2135\u2080 \u2264 \u03b8) (h\u2082 : #\u03b1 < \u03b8.ord.cof) :\n    \u2203 (a : \u03b1) (t : Set \u03b2) (h : t \u2286 s), \u03b8 \u2264 #t \u2227 \u2200 \u2983x\u2984 (hx : x \u2208 t), f \u27e8x, h hx\u27e9 = a", "start": [827, 1], "end": [840, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsStrongLimit", "code": "def IsStrongLimit (c : Cardinal) : Prop :=\n  c \u2260 0 \u2227 \u2200 x < c, (2^x) < c", "start": [856, 1], "end": [859, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsStrongLimit.ne_zero", "code": "theorem IsStrongLimit.ne_zero {c} (h : IsStrongLimit c) : c \u2260 0", "start": [862, 1], "end": [863, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsStrongLimit.two_power_lt", "code": "theorem IsStrongLimit.two_power_lt {x c} (h : IsStrongLimit c) : x < c \u2192 (2^x) < c", "start": [866, 1], "end": [867, 8], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isStrongLimit_aleph0", "code": "theorem isStrongLimit_aleph0 : IsStrongLimit \u2135\u2080", "start": [870, 1], "end": [873, 42], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsStrongLimit.isSuccLimit", "code": "protected theorem IsStrongLimit.isSuccLimit {c} (H : IsStrongLimit c) : IsSuccLimit c", "start": [876, 1], "end": [877, 92], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsStrongLimit.isLimit", "code": "theorem IsStrongLimit.isLimit {c} (H : IsStrongLimit c) : IsLimit c", "start": [880, 1], "end": [881, 29], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isStrongLimit_beth", "code": "theorem isStrongLimit_beth {o : Ordinal} (H : IsSuccLimit o) : IsStrongLimit (beth o)", "start": [884, 1], "end": [893, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_bounded_subset", "code": "theorem mk_bounded_subset {\u03b1 : Type*} (h : \u2200 x < #\u03b1, (2^x) < #\u03b1) {r : \u03b1 \u2192 \u03b1 \u2192 Prop}\n    [IsWellOrder \u03b1 r] (hr : (#\u03b1).ord = type r) : #{ s : Set \u03b1 // Bounded r s } = #\u03b1", "start": [896, 1], "end": [924, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.mk_subset_mk_lt_cof", "code": "theorem mk_subset_mk_lt_cof {\u03b1 : Type*} (h : \u2200 x < #\u03b1, (2^x) < #\u03b1) :\n    #{ s : Set \u03b1 // #s < cof (#\u03b1).ord } = #\u03b1", "start": [927, 1], "end": [945, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsRegular", "code": "def IsRegular (c : Cardinal) : Prop :=\n  \u2135\u2080 \u2264 c \u2227 c \u2264 c.ord.cof", "start": [948, 1], "end": [950, 25], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsRegular.aleph0_le", "code": "theorem IsRegular.aleph0_le {c : Cardinal} (H : c.IsRegular) : \u2135\u2080 \u2264 c", "start": [953, 1], "end": [954, 6], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsRegular.cof_eq", "code": "theorem IsRegular.cof_eq {c : Cardinal} (H : c.IsRegular) : c.ord.cof = c", "start": [957, 1], "end": [958, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsRegular.pos", "code": "theorem IsRegular.pos {c : Cardinal} (H : c.IsRegular) : 0 < c", "start": [961, 1], "end": [962, 26], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsRegular.ord_pos", "code": "theorem IsRegular.ord_pos {c : Cardinal} (H : c.IsRegular) : 0 < c.ord", "start": [965, 1], "end": [967, 14], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_cof", "code": "theorem isRegular_cof {o : Ordinal} (h : o.IsLimit) : IsRegular o.cof", "start": [970, 1], "end": [971, 38], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_aleph0", "code": "theorem isRegular_aleph0 : IsRegular \u2135\u2080", "start": [974, 1], "end": [975, 20], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_succ", "code": "theorem isRegular_succ {c : Cardinal.{u}} (h : \u2135\u2080 \u2264 c) : IsRegular (succ c)", "start": [978, 1], "end": [997, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_aleph_one", "code": "theorem isRegular_aleph_one : IsRegular (aleph 1)", "start": [1000, 1], "end": [1002, 30], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_aleph'_succ", "code": "theorem isRegular_aleph'_succ {o : Ordinal} (h : \u03c9 \u2264 o) : IsRegular (aleph' (succ o))", "start": [1005, 1], "end": [1007, 46], "kind": "commanddeclaration"}, {"full_name": "Cardinal.isRegular_aleph_succ", "code": "theorem isRegular_aleph_succ (o : Ordinal) : IsRegular (aleph (succ o))", "start": [1010, 1], "end": [1012, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.infinite_pigeonhole_card_lt", "code": "theorem infinite_pigeonhole_card_lt {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1) (w : #\u03b1 < #\u03b2) (w' : \u2135\u2080 \u2264 #\u03b1) :\n    \u2203 a : \u03b1, #\u03b1 < #(f \u207b\u00b9' {a})", "start": [1015, 1], "end": [1023, 54], "kind": "commanddeclaration"}, {"full_name": "Cardinal.exists_infinite_fiber", "code": "theorem exists_infinite_fiber {\u03b2 \u03b1 : Type u} (f : \u03b2 \u2192 \u03b1) (w : #\u03b1 < #\u03b2) (w' : Infinite \u03b1) :\n    \u2203 a : \u03b1, Infinite (f \u207b\u00b9' {a})", "start": [1026, 1], "end": [1033, 28], "kind": "commanddeclaration"}, {"full_name": "Cardinal.le_range_of_union_finset_eq_top", "code": "theorem le_range_of_union_finset_eq_top {\u03b1 \u03b2 : Type*} [Infinite \u03b2] (f : \u03b1 \u2192 Finset \u03b2)\n    (w : \u22c3 a, (f a : Set \u03b2) = \u22a4) : #\u03b2 \u2264 #(range f)", "start": [1036, 1], "end": [1057, 88], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lsub_lt_ord_lift_of_isRegular", "code": "theorem lsub_lt_ord_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) : (\u2200 i, f i < c.ord) \u2192 Ordinal.lsub.{u, v} f < c.ord", "start": [1060, 1], "end": [1062, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lsub_lt_ord_of_isRegular", "code": "theorem lsub_lt_ord_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal} {c} (hc : IsRegular c) (h\u03b9 : #\u03b9 < c) :\n    (\u2200 i, f i < c.ord) \u2192 Ordinal.lsub f < c.ord", "start": [1065, 1], "end": [1067, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sup_lt_ord_lift_of_isRegular", "code": "theorem sup_lt_ord_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) : (\u2200 i, f i < c.ord) \u2192 Ordinal.sup.{u, v} f < c.ord", "start": [1070, 1], "end": [1072, 39], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sup_lt_ord_of_isRegular", "code": "theorem sup_lt_ord_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal} {c} (hc : IsRegular c) (h\u03b9 : #\u03b9 < c) :\n    (\u2200 i, f i < c.ord) \u2192 Ordinal.sup f < c.ord", "start": [1075, 1], "end": [1077, 34], "kind": "commanddeclaration"}, {"full_name": "Cardinal.blsub_lt_ord_lift_of_isRegular", "code": "theorem blsub_lt_ord_lift_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal} {c} (hc : IsRegular c)\n    (ho : Cardinal.lift.{v, u} o.card < c) :\n    (\u2200 i hi, f i hi < c.ord) \u2192 Ordinal.blsub.{u, v} o f < c.ord", "start": [1080, 1], "end": [1083, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.blsub_lt_ord_of_isRegular", "code": "theorem blsub_lt_ord_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal} {c} (hc : IsRegular c)\n    (ho : o.card < c) : (\u2200 i hi, f i hi < c.ord) \u2192 Ordinal.blsub o f < c.ord", "start": [1086, 1], "end": [1088, 36], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bsup_lt_ord_lift_of_isRegular", "code": "theorem bsup_lt_ord_lift_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} o.card < c) :\n    (\u2200 i hi, f i hi < c.ord) \u2192 Ordinal.bsup.{u, v} o f < c.ord", "start": [1091, 1], "end": [1094, 40], "kind": "commanddeclaration"}, {"full_name": "Cardinal.bsup_lt_ord_of_isRegular", "code": "theorem bsup_lt_ord_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : o.card < c) : (\u2200 i hi, f i hi < c.ord) \u2192 Ordinal.bsup o f < c.ord", "start": [1097, 1], "end": [1099, 35], "kind": "commanddeclaration"}, {"full_name": "Cardinal.iSup_lt_lift_of_isRegular", "code": "theorem iSup_lt_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Cardinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) : (\u2200 i, f i < c) \u2192 iSup.{max u v + 1, u + 1} f < c", "start": [1102, 1], "end": [1104, 43], "kind": "commanddeclaration"}, {"full_name": "Cardinal.iSup_lt_of_isRegular", "code": "theorem iSup_lt_of_isRegular {\u03b9} {f : \u03b9 \u2192 Cardinal} {c} (hc : IsRegular c) (h\u03b9 : #\u03b9 < c) :\n    (\u2200 i, f i < c) \u2192 iSup f < c", "start": [1107, 1], "end": [1109, 31], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_lt_lift_of_isRegular", "code": "theorem sum_lt_lift_of_isRegular {\u03b9 : Type u} {f : \u03b9 \u2192 Cardinal} {c : Cardinal} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) (hf : \u2200 i, f i < c) : sum f < c", "start": [1112, 1], "end": [1114, 93], "kind": "commanddeclaration"}, {"full_name": "Cardinal.sum_lt_of_isRegular", "code": "theorem sum_lt_of_isRegular {\u03b9 : Type u} {f : \u03b9 \u2192 Cardinal} {c : Cardinal} (hc : IsRegular c)\n    (h\u03b9 : #\u03b9 < c) : (\u2200 i, f i < c) \u2192 sum f < c", "start": [1117, 1], "end": [1119, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nfpFamily_lt_ord_lift_of_isRegular", "code": "theorem nfpFamily_lt_ord_lift_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) (hc' : c \u2260 \u2135\u2080) (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) {a}\n    (ha : a < c.ord) : nfpFamily.{u, v} f a < c.ord", "start": [1122, 1], "end": [1127, 11], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nfpFamily_lt_ord_of_isRegular", "code": "theorem nfpFamily_lt_ord_of_isRegular {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : #\u03b9 < c) (hc' : c \u2260 \u2135\u2080) {a} (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) :\n    a < c.ord \u2192 nfpFamily.{u, u} f a < c.ord", "start": [1130, 1], "end": [1133, 66], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nfpBFamily_lt_ord_lift_of_isRegular", "code": "theorem nfpBFamily_lt_ord_lift_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c}\n    (hc : IsRegular c) (ho : Cardinal.lift.{v, u} o.card < c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 (i hi), \u2200 b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord \u2192 nfpBFamily.{u, v} o f a < c.ord", "start": [1136, 1], "end": [1140, 86], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nfpBFamily_lt_ord_of_isRegular", "code": "theorem nfpBFamily_lt_ord_of_isRegular {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c}\n    (hc : IsRegular c) (ho : o.card < c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 (i hi), \u2200 b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord \u2192 nfpBFamily.{u, u} o f a < c.ord", "start": [1143, 1], "end": [1147, 67], "kind": "commanddeclaration"}, {"full_name": "Cardinal.nfp_lt_ord_of_isRegular", "code": "theorem nfp_lt_ord_of_isRegular {f : Ordinal \u2192 Ordinal} {c} (hc : IsRegular c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 i < c.ord, f i < c.ord) {a} : a < c.ord \u2192 nfp f a < c.ord", "start": [1150, 1], "end": [1156, 7], "kind": "commanddeclaration"}, {"full_name": "Cardinal.derivFamily_lt_ord_lift", "code": "theorem derivFamily_lt_ord_lift {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : Cardinal.lift.{v, u} #\u03b9 < c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) {a} :\n    a < c.ord \u2192 derivFamily.{u, v} f a < c.ord", "start": [1159, 1], "end": [1181, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.derivFamily_lt_ord", "code": "theorem derivFamily_lt_ord {\u03b9} {f : \u03b9 \u2192 Ordinal \u2192 Ordinal} {c} (hc : IsRegular c) (h\u03b9 : #\u03b9 < c)\n    (hc' : c \u2260 \u2135\u2080) (hf : \u2200 (i), \u2200 b < c.ord, f i b < c.ord) {a} :\n    a < c.ord \u2192 derivFamily.{u, u} f a < c.ord", "start": [1184, 1], "end": [1187, 55], "kind": "commanddeclaration"}, {"full_name": "Cardinal.derivBFamily_lt_ord_lift", "code": "theorem derivBFamily_lt_ord_lift {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c}\n    (hc : IsRegular c) (h\u03b9 : Cardinal.lift.{v, u} o.card < c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 (i hi), \u2200 b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord \u2192 derivBFamily.{u, v} o f a < c.ord", "start": [1190, 1], "end": [1194, 75], "kind": "commanddeclaration"}, {"full_name": "Cardinal.derivBFamily_lt_ord", "code": "theorem derivBFamily_lt_ord {o : Ordinal} {f : \u2200 a < o, Ordinal \u2192 Ordinal} {c} (hc : IsRegular c)\n    (h\u03b9 : o.card < c) (hc' : c \u2260 \u2135\u2080) (hf : \u2200 (i hi), \u2200 b < c.ord, f i hi b < c.ord) {a} :\n    a < c.ord \u2192 derivBFamily.{u, u} o f a < c.ord", "start": [1197, 1], "end": [1200, 56], "kind": "commanddeclaration"}, {"full_name": "Cardinal.deriv_lt_ord", "code": "theorem deriv_lt_ord {f : Ordinal.{u} \u2192 Ordinal} {c} (hc : IsRegular c) (hc' : c \u2260 \u2135\u2080)\n    (hf : \u2200 i < c.ord, f i < c.ord) {a} : a < c.ord \u2192 deriv f a < c.ord", "start": [1203, 1], "end": [1206, 97], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsInaccessible", "code": "def IsInaccessible (c : Cardinal) :=\n  \u2135\u2080 < c \u2227 IsRegular c \u2227 IsStrongLimit c", "start": [1209, 1], "end": [1211, 41], "kind": "commanddeclaration"}, {"full_name": "Cardinal.IsInaccessible.mk", "code": "theorem IsInaccessible.mk {c} (h\u2081 : \u2135\u2080 < c) (h\u2082 : c \u2264 c.ord.cof) (h\u2083 : \u2200 x < c, (2^x) < c) :\n    IsInaccessible c", "start": [1214, 1], "end": [1216, 51], "kind": "commanddeclaration"}, {"full_name": "Cardinal.univ_inaccessible", "code": "theorem univ_inaccessible : IsInaccessible univ.{u, v}", "start": [1220, 1], "end": [1224, 24], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_power_cof", "code": "theorem lt_power_cof {c : Cardinal.{u}} : \u2135\u2080 \u2264 c \u2192 c < (c^cof c.ord)", "start": [1227, 1], "end": [1242, 33], "kind": "commanddeclaration"}, {"full_name": "Cardinal.lt_cof_power", "code": "theorem lt_cof_power {a b : Cardinal} (ha : \u2135\u2080 \u2264 a) (b1 : 1 < b) : a < cof (b^a).ord", "start": [1245, 1], "end": [1249, 53], "kind": "commanddeclaration"}, {"full_name": "Ordinal.sup_sequence_lt_omega1", "code": "lemma sup_sequence_lt_omega1 {\u03b1} [Countable \u03b1] (o : \u03b1 \u2192 Ordinal) (ho : \u2200 n, o n < \u03c9\u2081) :\n    sup o < \u03c9\u2081 := by\n  apply sup_lt_ord_lift _ ho\n  rw [Cardinal.isRegular_aleph_one.cof_eq]\n  exact lt_of_le_of_lt mk_le_aleph0 aleph0_lt_aleph_one", "start": [1261, 1], "end": [1265, 56], "kind": "mathlibtacticlemma"}]}
